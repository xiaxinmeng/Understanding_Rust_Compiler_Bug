{"sha": "fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQzMTI1Mzc1ZjE3YmE0ZDQ3YWFmMDBkMGM1ZDE2ZDcyYTI0ZjRmOA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-09-14T10:23:37Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-09-14T10:23:37Z"}, "message": "In libobjc/: Implemented objc_sync_enter() and objc_sync_exit(), which are required by @synchronized() to work.\n\nIn libobjc/:\n       Implemented objc_sync_enter() and objc_sync_exit(), which are\n       required by @synchronized() to work.\n       * objc-sync.c: New file.\n       * objc/objc-sync.h: New file.\n       * objc-private/objc-sync.h: New file.\n       * init.c (__objc_exec_class): Call __objc_sync_init() during the\n       Objective-C runtime startup.\n       * Makefile.in: Added objc-sync.c and objc-sync.h.\n       * configure.ac: Added GCC_CHECK_TLS.\n       * acinclude.m4: Include ../config/enable.m4 and ../config/tls.m4.\n       * configure: Regenerated.\n       * config.h.in: Regenerated.\n\nFrom-SVN: r164276", "tree": {"sha": "a612f102fc0035c2f3ad31c1091a959c15fb4afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a612f102fc0035c2f3ad31c1091a959c15fb4afc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4359dc2a313d076c3e98f7f5c0b5455637e0b69e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4359dc2a313d076c3e98f7f5c0b5455637e0b69e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4359dc2a313d076c3e98f7f5c0b5455637e0b69e"}], "stats": {"total": 850, "additions": 846, "deletions": 4}, "files": [{"sha": "9022c1b5bc0f83c9f7b2ed268020cf8a1a767ccb", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -1,3 +1,18 @@\n+2010-09-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented objc_sync_enter() and objc_sync_exit(), which are\n+\trequired by @synchronized() to work.\n+\t* objc-sync.c: New file.\n+\t* objc/objc-sync.h: New file.\n+\t* objc-private/objc-sync.h: New file.\n+\t* init.c (__objc_exec_class): Call __objc_sync_init() during the\n+\tObjective-C runtime startup.\n+\t* Makefile.in: Added objc-sync.c and objc-sync.h.\n+\t* configure.ac: Added GCC_CHECK_TLS.\n+\t* acinclude.m4: Include ../config/enable.m4 and ../config/tls.m4.\n+\t* configure: Regenerated.\n+\t* config.h.in: Regenerated.\n+\t\n 2010-09-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* Makefile.in (%_gc.lo): New pattern rules to build the"}, {"sha": "78d5bb01c61dace56f63e145c501e808378a1e48", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -111,6 +111,7 @@ INCLUDES = -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n OBJC_H = \\\n   objc.h \\\n   objc-exception.h \\\n+  objc-sync.h \\\n   \\\n   NXConstStr.h \\\n   Object.h \\\n@@ -159,6 +160,7 @@ C_SOURCE_FILES = \\\n    init.c \\\n    memory.c \\\n    nil_method.c \\\n+   objc-sync.c \\\n    objects.c \\\n    sarray.c \\\n    selector.c \\"}, {"sha": "581a5f272aeeb891b0c0a137f58e8c955ab99625", "filename": "libobjc/acinclude.m4", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Facinclude.m4?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -1,4 +1,4 @@\n-dnl Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2004\n+dnl Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2010\n dnl Free Software Foundation, Inc.\n dnl This file is free software; the Free Software Foundation\n dnl gives unlimited permission to copy and/or distribute it,\n@@ -11,6 +11,8 @@ dnl PARTICULAR PURPOSE.\n \n m4_include(../config/acx.m4)\n m4_include(../config/no-executables.m4)\n+m4_include(../config/enable.m4)\n+m4_include(../config/tls.m4)\n \n m4_include(../libtool.m4)\n dnl The lines below arrange for aclocal not to bring an installed"}, {"sha": "d9c8172d258bb42eaebab4e8a02948f80a0e0010", "filename": "libobjc/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fconfig.h.in?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -1,5 +1,8 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n+/* Define to 1 if the target assembler supports thread-local storage. */\n+#undef HAVE_CC_TLS\n+\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #undef HAVE_DLFCN_H\n \n@@ -33,6 +36,9 @@\n /* Define to 1 if you have the <sys/types.h> header file. */\n #undef HAVE_SYS_TYPES_H\n \n+/* Define to 1 if the target supports thread-local storage. */\n+#undef HAVE_TLS\n+\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n "}, {"sha": "ffa3a88cdd4c717eba10b38b464f979151a8d5ed", "filename": "libobjc/configure", "status": "modified", "additions": 214, "deletions": 3, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fconfigure?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -718,6 +718,7 @@ with_pic\n enable_fast_install\n with_gnu_ld\n enable_libtool_lock\n+enable_tls\n enable_sjlj_exceptions\n '\n       ac_precious_vars='build_alias\n@@ -1351,6 +1352,7 @@ Optional Features:\n   --enable-fast-install[=PKGS]\n                           optimize for fast installation [default=yes]\n   --disable-libtool-lock  avoid locking (might break parallel builds)\n+  --enable-tls            Use thread-local storage [default=yes]\n   --enable-sjlj-exceptions\n                           force use of builtin_setjmp for exceptions\n \n@@ -10566,7 +10568,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10569 \"configure\"\n+#line 10571 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -10672,7 +10674,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10675 \"configure\"\n+#line 10677 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11232,6 +11234,215 @@ $as_echo \"#define HAVE_GTHR_DEFAULT 1\" >>confdefs.h\n \n fi\n \n+# Check if we have thread-local storage\n+\n+\n+   # Check whether --enable-tls was given.\n+if test \"${enable_tls+set}\" = set; then :\n+  enableval=$enable_tls;\n+      case \"$enableval\" in\n+       yes|no) ;;\n+       *) as_fn_error \"Argument to enable/disable tls must be yes or no\" \"$LINENO\" 5 ;;\n+      esac\n+\n+else\n+  enable_tls=yes\n+fi\n+\n+\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the target supports thread-local storage\" >&5\n+$as_echo_n \"checking whether the target supports thread-local storage... \" >&6; }\n+if test \"${gcc_cv_have_tls+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+\n+    if test \"$cross_compiling\" = yes; then :\n+                if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+__thread int a; int b; int main() { return a = b; }\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  chktls_save_LDFLAGS=\"$LDFLAGS\"\n+\t  \t  \t  case $host in\n+\t    *-*-linux*)\n+\t      LDFLAGS=\"-shared -Wl,--no-undefined $LDFLAGS\"\n+\t      ;;\n+\t  esac\n+\t  chktls_save_CFLAGS=\"$CFLAGS\"\n+\t  CFLAGS=\"-fPIC $CFLAGS\"\n+\t  \t  if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+int f() { return 0; }\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+__thread int a; int b; int f() { return a = b; }\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  gcc_cv_have_tls=yes\n+else\n+  gcc_cv_have_tls=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+else\n+  gcc_cv_have_tls=yes\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+\t  CFLAGS=\"$chktls_save_CFLAGS\"\n+\t  LDFLAGS=\"$chktls_save_LDFLAGS\"\n+else\n+  gcc_cv_have_tls=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+\n+\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+__thread int a; int b; int main() { return a = b; }\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+                      chktls_save_LDFLAGS=\"$LDFLAGS\"\n+      LDFLAGS=\"-static $LDFLAGS\"\n+      if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+int main() { return 0; }\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  if test \"$cross_compiling\" = yes; then :\n+  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+as_fn_error \"cannot run test program while cross compiling\n+See \\`config.log' for more details.\" \"$LINENO\" 5; }\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+__thread int a; int b; int main() { return a = b; }\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+  gcc_cv_have_tls=yes\n+else\n+  gcc_cv_have_tls=no\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+else\n+  gcc_cv_have_tls=yes\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+      LDFLAGS=\"$chktls_save_LDFLAGS\"\n+      if test $gcc_cv_have_tls = yes; then\n+\t\t\t\t\t\tchktls_save_CFLAGS=\"$CFLAGS\"\n+\tthread_CFLAGS=failed\n+\tfor flag in '' '-pthread' '-lpthread'; do\n+\t  CFLAGS=\"$flag $chktls_save_CFLAGS\"\n+\t  if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+\t\tvoid *g(void *d) { return NULL; }\n+int\n+main ()\n+{\n+pthread_t t; pthread_create(&t,NULL,g,NULL);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  thread_CFLAGS=\"$flag\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+\t  if test \"X$thread_CFLAGS\" != Xfailed; then\n+\t    break\n+\t  fi\n+\tdone\n+\tCFLAGS=\"$chktls_save_CFLAGS\"\n+\tif test \"X$thread_CFLAGS\" != Xfailed; then\n+\t  CFLAGS=\"$thread_CFLAGS $chktls_save_CFLAGS\"\n+ \t  \t  \t  \t  \t  \t  if test \"$cross_compiling\" = yes; then :\n+  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+as_fn_error \"cannot run test program while cross compiling\n+See \\`config.log' for more details.\" \"$LINENO\" 5; }\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+\t\t__thread int a;\n+\t\tstatic int *volatile a_in_other_thread;\n+\t\tstatic void *\n+\t\tthread_func (void *arg)\n+\t\t{\n+\t\t  a_in_other_thread = &a;\n+\t\t  return (void *)0;\n+\t\t}\n+int\n+main ()\n+{\n+pthread_t thread;\n+\t\tvoid *thread_retval;\n+\t\tint *volatile a_in_main_thread;\n+\t\ta_in_main_thread = &a;\n+\t\tif (pthread_create (&thread, (pthread_attr_t *)0,\n+\t\t\t\t    thread_func, (void *)0))\n+\t\t  return 0;\n+\t\tif (pthread_join (thread, &thread_retval))\n+\t\t  return 0;\n+\t\treturn (a_in_other_thread == a_in_main_thread);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+  gcc_cv_have_tls=yes\n+else\n+  gcc_cv_have_tls=no\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+\t  CFLAGS=\"$chktls_save_CFLAGS\"\n+\tfi\n+      fi\n+else\n+  gcc_cv_have_tls=no\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_have_tls\" >&5\n+$as_echo \"$gcc_cv_have_tls\" >&6; }\n+  if test \"$enable_tls $gcc_cv_have_tls\" = \"yes yes\"; then\n+\n+$as_echo \"#define HAVE_TLS 1\" >>confdefs.h\n+\n+  fi\n \n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for exception model to use\" >&5\n $as_echo_n \"checking for exception model to use... \" >&6; }\n@@ -11246,7 +11457,7 @@ if test \"${enable_sjlj_exceptions+set}\" = set; then :\n   enableval=$enable_sjlj_exceptions; :\n else\n   cat > conftest.$ac_ext << EOF\n-#line 11249 \"configure\"\n+#line 11460 \"configure\"\n @interface Frob\n @end\n @implementation Frob"}, {"sha": "ed532fab02588aebfcd6af608638ef42940d3281", "filename": "libobjc/configure.ac", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fconfigure.ac?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -215,6 +215,8 @@ if test $target_thread_file != single; then\n         [Define if the compiler has a thread header that is non single.])\n fi \n \n+# Check if we have thread-local storage\n+GCC_CHECK_TLS\n \n AC_MSG_CHECKING([for exception model to use])\n AC_LANG_PUSH(C)"}, {"sha": "206b85b5c0d6cc8a93f2fb6146e17a315c98bde5", "filename": "libobjc/init.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -32,6 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc/hash.h\"\n #include \"objc/objc-list.h\" \n #include \"objc-private/runtime.h\"\n+#include \"objc-private/objc-sync.h\" /* For __objc_sync_init() */\n \n /* The version number of this runtime.  This must match the number \n    defined in gcc (objc-act.c).  */\n@@ -550,6 +551,7 @@ __objc_exec_class (Module_t module)\n       __objc_load_methods = objc_hash_new (128, \n \t\t\t\t\t   (hash_func_type)objc_hash_ptr,\n \t\t\t\t\t   objc_compare_ptrs);\n+      __objc_sync_init ();\n       previous_constructors = 1;\n     }\n "}, {"sha": "e69d756d3adeb42fd71918d105055bedd4996ebe", "filename": "libobjc/objc-private/objc-sync.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fobjc-private%2Fobjc-sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fobjc-private%2Fobjc-sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fobjc-sync.h?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -0,0 +1,41 @@\n+/* GNU Objective C Runtime @synchronized implementation - Private functions\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 3, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __objc_private_objc_sync_INCLUDE_GNU\n+#define __objc_private_objc_sync_INCLUDE_GNU\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+/* This function needs to be called at startup before @synchronized()\n+   can be used.  */\n+void\n+__objc_sync_init (void);\n+\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n+#endif /* not __objc_private_objc_sync_INCLUDE_GNU */"}, {"sha": "7f42115bfb0c6f15b9359d9ba46b9f208da753fa", "filename": "libobjc/objc-sync.c", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fobjc-sync.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fobjc-sync.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-sync.c?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -0,0 +1,491 @@\n+/* GNU Objective C Runtime @synchronized implementation\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 3, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/*\n+  This file implements objc_sync_enter() and objc_sync_exit(), the\n+  two functions required to support @synchronized().\n+\n+  objc_sync_enter(object) needs to get a recursive lock associated\n+  with 'object', and lock it.\n+\n+  objc_sync_exit(object) needs to get the recursive lock associated\n+  with 'object', and unlock it.\n+ */\n+\n+/* To avoid the overhead of continuously allocating and deallocating\n+   locks, we implement a pool of locks.  When a lock is needed for an\n+   object, we get a lock from the pool and associate it with the\n+   object.\n+ \n+   The lock pool need to be protected by its own lock (the\n+   \"protection\" lock), which has to be locked then unlocked each time\n+   objc_sync_enter() and objc_sync_exit() are called.  To reduce the\n+   contention on the protection lock, instead of a single pool with a\n+   single (global) protection lock we use a number of smaller pools,\n+   each with its own pool protection lock.  To decide which lock pool\n+   to use for each object, we compute a hash from the object pointer.\n+ \n+   The implementation of each lock pool uses a linked list of all the\n+   locks in the pool (both unlocked, and locked); this works in the\n+   assumption that the number of locks concurrently required is very\n+   low.  In practice, it seems that you rarely see more than a few\n+   locks ever concurrently required.\n+ \n+   A standard case is a thread acquiring a lock recursively, over and\n+   over again: for example when most methods of a class are protected\n+   by @synchronized(self) but they also call each other.  We use\n+   thread-local storage to implement a cache and optimize this case.\n+   The cache stores locks that the thread successfully acquired,\n+   allowing objc_sync_enter() and objc_sync_exit() to locate a lock\n+   which is already held by the current thread without having to use\n+   any protection lock or synchronization mechanism.  It can so detect\n+   recursive locks/unlocks, and transform them into no-ops that\n+   require no actual locking or synchronization mechanisms at all.\n+*/\n+\n+/* You can disable the thread-local cache (most likely to benchmark\n+   the code with and without it) by compiling with\n+   -DSYNC_CACHE_DISABLE, or commenting out the following line.\n+ */\n+/* #define SYNC_CACHE_DISABLE */\n+\n+/* If thread-local storage is not available, automatically disable the\n+   cache.\n+*/\n+#ifndef HAVE_TLS\n+# define SYNC_CACHE_DISABLE\n+#endif\n+\n+#include \"objc/objc-sync.h\"         /* For objc_sync_enter(), objc_sync_exit() */\n+#include \"objc/objc-api.h\"          /* For objc_malloc() */\n+#include \"objc/thr.h\"               /* For objc_mutex_loc() and similar */\n+#include \"objc-private/objc-sync.h\" /* For __objc_sync_init() */\n+\n+/* We have 32 pools of locks, each of them protected by its own\n+   protection lock.  It's tempting to increase this number to reduce\n+   contention; but in our tests it is high enough.\n+ */\n+#define SYNC_NUMBER_OF_POOLS 32\n+\n+/* Given an object, it determines which pool contains the associated\n+   lock.\n+ */\n+#define SYNC_OBJECT_HASH(OBJECT) ((((size_t)OBJECT >> 8) ^ (size_t)OBJECT) & (SYNC_NUMBER_OF_POOLS - 1))\n+\n+/* The locks protecting each pool.  */\n+static objc_mutex_t sync_pool_protection_locks[SYNC_NUMBER_OF_POOLS];\n+\n+/* The data structure (linked list) holding the locks.  */\n+typedef struct lock_node\n+{\n+  /* Pointer to next entry on the list.  NULL indicates end of list.\n+     You need to hold the appropriate sync_pool_protection_locks[N] to\n+     read or write this variable.  */\n+  struct lock_node *next;\n+\n+  /* The (recursive) lock.  Allocated when the node is created, and\n+     always not-NULL, and unchangeable, after that.  */\n+  objc_mutex_t lock;\n+\n+  /* This is how many times the objc_mutex_lock() has been called on\n+     the lock (it is 0 when the lock is unused).  Used to track when\n+     the lock is no longer associated with an object and can be reused\n+     for another object.  It records \"real\" locks, potentially (but\n+     not necessarily) by multiple threads.  You need to hold the\n+     appropriate sync_pool_protection_locks[N] to read or write this\n+     variable.  */\n+  unsigned int usage_count;\n+\n+  /* The object that the lock is associated with.  This variable can\n+     only be written when holding the sync_pool_protection_locks[N]\n+     and when node->usage_count == 0, ie, the lock is not being used.\n+     You can read this variable either when you hold the\n+     sync_pool_protection_locks[N] or when you hold node->lock,\n+     because in that case you know that node->usage_count can't get to\n+     zero until you release the lock.  It is valid to have usage_count\n+     == 0 and object != nil; in that case, the lock is not currently\n+     being used, but is still currently associated with the object.\n+   */\n+  id object;\n+\n+  /* This is a counter reserved for use by the thread currently\n+     holding the lock.  So, you need to hold node->lock to read or\n+     write this variable.  It is normally 0, and if the cache is not\n+     being used, it is kept at 0 (even if recursive locks are being\n+     done; in that case, no difference is made between recursive and\n+     non-recursive locks: they all increase usage_count, and call\n+     objc_mutex_lock()).  When the cache is being used, a thread may\n+     be able to find a lock that it already holds using the cache; in\n+     that case, to perform additional locks/unlocks it can\n+     increase/decrease the recursive_usage_count (which does not\n+     require any synchronization with other threads, since it's\n+     protected by the node->lock itself) instead of the usage_count\n+     (which requires locking the pool protection lock).  And it can\n+     skip the call to objc_mutex_lock/unlock too.\n+   */\n+  unsigned int recursive_usage_count;\n+} *lock_node_ptr;\n+\n+\n+/* The pools of locks.  Each of them is a linked list of lock_nodes.\n+   In the list we keep both unlocked and locked nodes.\n+ */\n+static lock_node_ptr sync_pool_array[SYNC_NUMBER_OF_POOLS];\n+\n+#ifndef SYNC_CACHE_DISABLE\n+/* We store a cache of locks acquired by each thread in thread-local\n+   storage.\n+*/\n+static __thread lock_node_ptr *lock_cache = NULL;\n+\n+/* This is a conservative implementation that uses a static array of\n+   fixed size as cache.  Because the cache is an array that we scan\n+   linearly, the bigger it is, the slower it gets.  This does not\n+   matter much at small sizes (eg, the overhead of checking 8 cache\n+   slots instead of 4 is very small compared to the other overheads\n+   involved such as function calls and lock/unlock operations), but at\n+   large sizes it becomes important as obviously there is a size over\n+   which using the cache backfires: the lookup is so slow that the\n+   cache slows down the software instead of speeding it up.  In\n+   practice, it seems that most threads use a small number of\n+   concurrent locks, so we have a conservative implementation with a\n+   fixed-size cache of 8 locks which gives a very predictable\n+   behaviour.  If a thread locks lots of different locks, only the\n+   first 8 get the speed benefits of the cache, but the cache remains\n+   always small, fast and predictable.\n+ \n+   SYNC_CACHE_SIZE is the size of the lock cache for each thread.\n+ */\n+#define SYNC_CACHE_SIZE 8\n+#endif /* SYNC_CACHE_DISABLE */\n+\n+/* Called at startup by init.c.  */\n+void\n+__objc_sync_init (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SYNC_NUMBER_OF_POOLS; i++)\n+    {\n+      lock_node_ptr new_node;\n+      \n+      /* Create a protection lock for each pool.  */\n+      sync_pool_protection_locks[i] = objc_mutex_allocate ();\n+\n+      /* Preallocate a lock per pool.  */\n+      new_node = objc_malloc (sizeof (struct lock_node));\n+      new_node->lock = objc_mutex_allocate ();\n+      new_node->object = nil;\n+      new_node->usage_count = 0;\n+      new_node->recursive_usage_count = 0;\n+      new_node->next = NULL;\n+\n+      sync_pool_array[i] = new_node;\n+    }\n+}  \n+\n+int\n+objc_sync_enter (id object)\n+{\n+#ifndef SYNC_CACHE_DISABLE\n+  int free_cache_slot;\n+#endif\n+  int hash;\n+  lock_node_ptr node;\n+  lock_node_ptr unused_node;\n+\n+  if (object == nil)\n+    {\n+      return OBJC_SYNC_SUCCESS;\n+    }\n+\n+#ifndef SYNC_CACHE_DISABLE\n+  if (lock_cache == NULL)\n+    {\n+      /* Note that this calloc only happen only once per thread, the\n+\t very first time a thread does a objc_sync_enter().\n+       */\n+      lock_cache = objc_calloc (SYNC_CACHE_SIZE, sizeof (lock_node_ptr));\n+    }\n+\n+  /* Check the cache to see if we have a record of having already\n+     locked the lock corresponding to this object.  While doing so,\n+     keep track of the first free cache node in case we need it later.\n+   */ \n+  node = NULL;\n+  free_cache_slot = -1;\n+\n+  {\n+    int i;\n+    for (i = 0; i < SYNC_CACHE_SIZE; i++)\n+      {\n+\tlock_node_ptr locked_node = lock_cache[i];\n+\t\n+\tif (locked_node == NULL)\n+\t  {\n+\t    if (free_cache_slot == -1)\n+\t      {\n+\t\tfree_cache_slot = i;\n+\t      }\n+\t  }\n+\telse if (locked_node->object == object)\n+\t  {\n+\t    node = locked_node;\n+\t    break;\n+\t  }\n+      }\n+  }\n+\n+  if (node != NULL)\n+    {\n+      /* We found the lock.  Increase recursive_usage_count, which is\n+\t protected by node->lock, which we already hold.\n+       */\n+      node->recursive_usage_count++;\n+      \n+      /* There is no need to actually lock anything, since we already\n+\t hold the lock.  Correspondingly, objc_sync_exit() will just\n+\t decrease recursive_usage_count and do nothing to unlock.\n+       */\n+      return OBJC_SYNC_SUCCESS;\n+    }\n+#endif /* SYNC_CACHE_DISABLE */\n+\n+  /* The following is the standard lookup for the lock in the standard\n+     pool lock.  It requires a pool protection lock.\n+   */\n+  hash = SYNC_OBJECT_HASH(object);\n+\n+  /* Search for an existing lock for 'object'.  While searching, make\n+     note of any unused lock if we find any.\n+   */\n+  unused_node = NULL;\n+\n+  objc_mutex_lock (sync_pool_protection_locks[hash]);\n+\n+  node = sync_pool_array[hash];\n+\n+  while (node != NULL)\n+    {\n+      if (node->object == object)\n+\t{\n+\t  /* We found the lock.  */\n+\t  node->usage_count++;\n+\t  objc_mutex_unlock (sync_pool_protection_locks[hash]);\n+\n+#ifndef SYNC_CACHE_DISABLE\n+\t  /* Put it in the cache.  */\n+\t  if (free_cache_slot != -1)\n+\t    {\n+\t      lock_cache[free_cache_slot] = node;\n+\t    }\n+#endif\n+\n+\t  /* Lock it.  */\n+\t  objc_mutex_lock (node->lock);\n+\n+\t  return OBJC_SYNC_SUCCESS;\n+\t}\n+\n+      if (unused_node == NULL  &&  node->usage_count == 0)\n+\t{\n+\t  /* We found the first unused node.  Record it.  */\n+\t  unused_node = node;\n+\t}\n+      \n+      node = node->next;\n+    }\n+\n+  /* An existing lock for 'object' could not be found.  */\n+  if (unused_node != NULL)\n+    {\n+      /* But we found a unused lock; use it.  */\n+      unused_node->object = object;\n+      unused_node->usage_count = 1;\n+      unused_node->recursive_usage_count = 0;\n+      objc_mutex_unlock (sync_pool_protection_locks[hash]);\n+\n+#ifndef SYNC_CACHE_DISABLE\n+      if (free_cache_slot != -1)\n+\t{\n+\t  lock_cache[free_cache_slot] = unused_node;\n+\t}\n+#endif\n+\n+      objc_mutex_lock (unused_node->lock);\n+\n+      return OBJC_SYNC_SUCCESS;\n+    }\n+  else\n+    {\n+      /* There are no unused nodes; allocate a new node.  */\n+      lock_node_ptr new_node;\n+\n+      /* Create the node.  */\n+      new_node = objc_malloc (sizeof (struct lock_node));\n+      new_node->lock = objc_mutex_allocate ();\n+      new_node->object = object;\n+      new_node->usage_count = 1;\n+      new_node->recursive_usage_count = 0;\n+\n+      /* Attach it at the beginning of the pool.  */\n+      new_node->next = sync_pool_array[hash];\n+      sync_pool_array[hash] = new_node;\n+      objc_mutex_unlock (sync_pool_protection_locks[hash]);\n+\n+#ifndef SYNC_CACHE_DISABLE\n+      if (free_cache_slot != -1)\n+\t{\n+\t  lock_cache[free_cache_slot] = new_node;\n+\t}\n+#endif\n+\n+      objc_mutex_lock (new_node->lock);\n+\n+      return OBJC_SYNC_SUCCESS;\n+    }\n+}\n+\n+int\n+objc_sync_exit (id object)\n+{\n+  int hash;\n+  lock_node_ptr node;\n+\n+  if (object == nil)\n+    {\n+      return OBJC_SYNC_SUCCESS;\n+    }\n+  \n+#ifndef SYNC_CACHE_DISABLE\n+  if (lock_cache != NULL)\n+    {\n+      int i;\n+    \n+      /* Find the lock in the cache.  */\n+      node = NULL;\n+      for (i = 0; i < SYNC_CACHE_SIZE; i++)\n+\t{\n+\t  lock_node_ptr locked_node = lock_cache[i];\n+\t  \n+\t  if (locked_node != NULL  &&  locked_node->object == object)\n+\t    {\n+\t      node = locked_node;\n+\t      break;\n+\t    }\n+\t}\n+      /* Note that, if a node was found in the cache, the variable i\n+\t now holds the index where it was found, which will be used to\n+\t remove it from the cache.  */\n+\n+      if (node != NULL)\n+\t{\n+\t  if (node->recursive_usage_count > 0)\n+\t    {\n+\t      node->recursive_usage_count--;\n+\t      return OBJC_SYNC_SUCCESS;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We need to do a real unlock.  */\n+\t      hash = SYNC_OBJECT_HASH(object);\n+\t      \n+\t      /* TODO: If we had atomic increase/decrease operations\n+\t\t with memory barriers, we could avoid the lock here!\n+\t      */\n+\t      objc_mutex_lock (sync_pool_protection_locks[hash]);\n+\t      node->usage_count--;\n+\t      /* Normally, we do not reset object to nil here.  We'll\n+\t\t leave the lock associated with that object, at zero\n+\t\t usage count.  This makes it slighly more efficient to\n+\t\t provide a lock for that object if (as likely)\n+\t\t requested again.  If the object is deallocated, we\n+\t\t don't care.  It will never match a new lock that is\n+\t\t requested, and the node will be reused at some point.\n+\n+\t\t But, if garbage collection is enabled, leaving a\n+\t\t pointer to the object in memory might prevent the\n+\t\t object from being released.  In that case, we remove\n+\t\t it (TODO: maybe we should avoid using the garbage\n+\t\t collector at all ?  Nothing is ever deallocated in\n+\t\t this file).\n+\t      */\n+#if OBJC_WITH_GC\n+\t      node->object = nil;\n+#endif\n+\t      objc_mutex_unlock (sync_pool_protection_locks[hash]);\n+\t    \n+\t      /* PS: Between objc_mutex_unlock\n+\t\t (sync_pool_protection_locks[hash]) and\n+\t\t objc_mutex_unlock (node->lock), the pool is unlocked\n+\t\t so other threads may allocate this same lock to\n+\t\t another object (!).  This is not a problem, but it is\n+\t\t curious.\n+\t      */\n+\t      objc_mutex_unlock (node->lock);\n+\t      \n+\t      /* Remove the node from the cache.  */\n+\t      lock_cache[i] = NULL;\n+\t      \n+\t      return OBJC_SYNC_SUCCESS;\n+\t    }\n+\t}\n+    }\n+#endif\t  \n+\n+  /* The cache either wasn't there, or didn't work (eg, we overflowed\n+     it at some point and stopped recording new locks in the cache).\n+     Proceed with a full search of the lock pool.  */\n+  hash = SYNC_OBJECT_HASH(object);\n+\n+  objc_mutex_lock (sync_pool_protection_locks[hash]);\n+\n+  /* Search for an existing lock for 'object'.  */\n+  node = sync_pool_array[hash];\n+\n+  while (node != NULL)\n+    {\n+      if (node->object == object)\n+\t{\n+\t  /* We found the lock.  */\n+\t  node->usage_count--;\n+\t  objc_mutex_unlock (sync_pool_protection_locks[hash]);\n+\n+\t  objc_mutex_unlock (node->lock);\n+\n+\t  /* No need to remove the node from the cache, since it\n+\t     wasn't found in the cache when we looked for it!\n+\t   */\n+\n+\t  return OBJC_SYNC_SUCCESS;\n+\t}\n+      \n+      node = node->next;\n+    }\n+\n+  objc_mutex_unlock (sync_pool_protection_locks[hash]);\n+\n+  /* A lock for 'object' to unlock could not be found (!!).  */\n+  return OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n+}"}, {"sha": "fc8e930a464b61425062997f1514c2d1944e5f2f", "filename": "libobjc/objc/objc-sync.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fobjc%2Fobjc-sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8/libobjc%2Fobjc%2Fobjc-sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fobjc-sync.h?ref=fd3125375f17ba4d47aaf00d0c5d16d72a24f4f8", "patch": "@@ -0,0 +1,70 @@\n+/* GNU Objective C Runtime @synchronized implementation\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __objc_sync_INCLUDE_GNU\n+#define __objc_sync_INCLUDE_GNU\n+\n+#include \"objc.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* These functions are automatically called by @synchronized().  */\n+\n+/* 'objc_sync_enter' is automatically called when entering a\n+   @synchronized() block.  It locks the recursive lock associated with\n+   'object'.  If 'object' is nil, it does nothing.  It returns\n+   OBJC_SYNC_SUCCESS on success; see the enumeration below for error\n+   values.\n+ \n+   Note that you should not rely on the behaviour when 'object' is nil\n+   because it could change.\n+ */\n+int objc_sync_enter (id object);\n+\n+/* 'objc_sync_exit' is automatically called when exiting from a\n+   @synchronized() block.  It unlocks the recursive lock associated\n+   with 'object'.  If 'object' is nil, it does nothing.  It returns\n+   OBJC_SYNC_SUCCESS on success; see the enumeration below for error\n+   values.\n+ */\n+int objc_sync_exit (id object);\n+\n+/* All the possible return values for objc_sync_enter() and\n+   objc_sync_exit().\n+ */\n+enum {\n+  OBJC_SYNC_SUCCESS = 0,\n+  OBJC_SYNC_NOT_OWNING_THREAD_ERROR = -1,\n+  OBJC_SYNC_TIMED_OUT = -2,\n+  OBJC_SYNC_NOT_INITIALIZED = -3\n+};\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* not __objc_sync_INCLUDE_GNU */"}]}