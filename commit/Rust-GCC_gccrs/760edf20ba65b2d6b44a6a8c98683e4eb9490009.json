{"sha": "760edf20ba65b2d6b44a6a8c98683e4eb9490009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYwZWRmMjBiYTY1YjJkNmI0NGE2YThjOTg2ODNlNGViOTQ5MDAwOQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-07-09T02:51:09Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-07-09T02:51:09Z"}, "message": "reduce conditional compilation based on AUTO_INC_DEC\n\ngcc/ChangeLog:\n\n2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* auto-inc-dec.c (pass_inc_dec::execute): Don't check the value\n\tof AUTO_INC_DEC with the preprocessor.\n\t* combine.c (combine_instructions): Likewise.\n\t(can_combine_p): Likewise.\n\t(try_combine): Likewise.\n\t* emit-rtl.c (try_split): Likewise.\n\t* loop-invariant.c (calculate_loop_reg_pressure): Likewise.\n\t* lower-subreg.c (resolve_simple_move): Likewise.\n\t* lra.c (update_inc_notes): Likewise.\n\t* recog.c (asm_operand_ok): Likewise.\n\t(constrain_operands): Likewise.\n\t* regrename.c (scan_rtx_address): Likewise.\n\t* reload.c (update_auto_inc_notes): Likewise.\n\t(reg_inc_found_and_valid_p): Likewise.\n\t* reload1.c (reload): Likewise.\n\t(emit_input_reload_insns): Likewise.\n\t(delete_output_reload): Likewise.\n\t* sched-deps.c (init_insn_reg_pressure_info): Likewise.\n\t* valtrack.c (cleanup_auto_inc_dec): Likewise.\n\nFrom-SVN: r225596", "tree": {"sha": "3b2f06358a06111a3171d4f07399d8b62fc9689d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b2f06358a06111a3171d4f07399d8b62fc9689d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/760edf20ba65b2d6b44a6a8c98683e4eb9490009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/760edf20ba65b2d6b44a6a8c98683e4eb9490009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/760edf20ba65b2d6b44a6a8c98683e4eb9490009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/760edf20ba65b2d6b44a6a8c98683e4eb9490009/comments", "author": null, "committer": null, "parents": [{"sha": "16cb56686dba6e45ab5e19b86fbed7712e1e6501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16cb56686dba6e45ab5e19b86fbed7712e1e6501", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16cb56686dba6e45ab5e19b86fbed7712e1e6501"}], "stats": {"total": 236, "additions": 111, "deletions": 125}, "files": [{"sha": "6ddd1ce78ceb7c7c95fc02a36e0a70ffaab9f928", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -1,3 +1,25 @@\n+2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* auto-inc-dec.c (pass_inc_dec::execute): Don't check the value\n+\tof AUTO_INC_DEC with the preprocessor.\n+\t* combine.c (combine_instructions): Likewise.\n+\t(can_combine_p): Likewise.\n+\t(try_combine): Likewise.\n+\t* emit-rtl.c (try_split): Likewise.\n+\t* loop-invariant.c (calculate_loop_reg_pressure): Likewise.\n+\t* lower-subreg.c (resolve_simple_move): Likewise.\n+\t* lra.c (update_inc_notes): Likewise.\n+\t* recog.c (asm_operand_ok): Likewise.\n+\t(constrain_operands): Likewise.\n+\t* regrename.c (scan_rtx_address): Likewise.\n+\t* reload.c (update_auto_inc_notes): Likewise.\n+\t(reg_inc_found_and_valid_p): Likewise.\n+\t* reload1.c (reload): Likewise.\n+\t(emit_input_reload_insns): Likewise.\n+\t(delete_output_reload): Likewise.\n+\t* sched-deps.c (init_insn_reg_pressure_info): Likewise.\n+\t* valtrack.c (cleanup_auto_inc_dec): Likewise.\n+\n 2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* rtl.h: Always define AUTO_INC_DEC."}, {"sha": "f0c9ca3f98299e9122e8467b633004d3d83cdd85", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -116,7 +116,6 @@ along with GCC; see the file COPYING3.  If not see\n   before the ref or +c if the increment was after the ref, then if we\n   can do the combination but switch the pre/post bit.  */\n \n-#if AUTO_INC_DEC\n \n enum form\n {\n@@ -1441,8 +1440,6 @@ merge_in_block (int max_reg, basic_block bb)\n     }\n }\n \n-#endif\n-\n /* Discover auto-inc auto-dec instructions.  */\n \n namespace {\n@@ -1470,11 +1467,10 @@ class pass_inc_dec : public rtl_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-#if AUTO_INC_DEC\n+      if (!AUTO_INC_DEC)\n+\treturn false;\n+\n       return (optimize > 0 && flag_auto_inc_dec);\n-#else\n-      return false;\n-#endif\n     }\n \n \n@@ -1485,7 +1481,9 @@ class pass_inc_dec : public rtl_opt_pass\n unsigned int\n pass_inc_dec::execute (function *fun ATTRIBUTE_UNUSED)\n {\n-#if AUTO_INC_DEC\n+  if (!AUTO_INC_DEC)\n+    return 0;\n+\n   basic_block bb;\n   int max_reg = max_reg_num ();\n \n@@ -1508,7 +1506,7 @@ pass_inc_dec::execute (function *fun ATTRIBUTE_UNUSED)\n   free (reg_next_def);\n \n   mem_tmp = NULL;\n-#endif\n+\n   return 0;\n }\n "}, {"sha": "d68515c289844b19081fe7d4f002eca9624c6807", "filename": "gcc/combine.c", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -1197,9 +1197,7 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n       FOR_BB_INSNS (this_basic_block, insn)\n         if (INSN_P (insn) && BLOCK_FOR_INSN (insn))\n \t  {\n-#if AUTO_INC_DEC\n             rtx links;\n-#endif\n \n             subst_low_luid = DF_INSN_LUID (insn);\n             subst_insn = insn;\n@@ -1208,12 +1206,11 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n \t\t         insn);\n \t    record_dead_and_set_regs (insn);\n \n-#if AUTO_INC_DEC\n-\t    for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n-\t      if (REG_NOTE_KIND (links) == REG_INC)\n-\t        set_nonzero_bits_and_sign_copies (XEXP (links, 0), NULL_RTX,\n-\t\t\t\t\t\t  insn);\n-#endif\n+\t    if (AUTO_INC_DEC)\n+\t      for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n+\t\tif (REG_NOTE_KIND (links) == REG_INC)\n+\t\t  set_nonzero_bits_and_sign_copies (XEXP (links, 0), NULL_RTX,\n+\t\t\t\t\t\t    insn);\n \n \t    /* Record the current insn_rtx_cost of this instruction.  */\n \t    if (NONJUMP_INSN_P (insn))\n@@ -1792,9 +1789,7 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n   const_rtx set = 0;\n   rtx src, dest;\n   rtx_insn *p;\n-#if AUTO_INC_DEC\n   rtx link;\n-#endif\n   bool all_adjacent = true;\n   int (*is_volatile_p) (const_rtx);\n \n@@ -2073,22 +2068,21 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n      Also insist that I3 not be a jump; if it were one\n      and the incremented register were spilled, we would lose.  */\n \n-#if AUTO_INC_DEC\n-  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-    if (REG_NOTE_KIND (link) == REG_INC\n-\t&& (JUMP_P (i3)\n-\t    || reg_used_between_p (XEXP (link, 0), insn, i3)\n-\t    || (pred != NULL_RTX\n-\t\t&& reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (pred)))\n-\t    || (pred2 != NULL_RTX\n-\t\t&& reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (pred2)))\n-\t    || (succ != NULL_RTX\n-\t\t&& reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (succ)))\n-\t    || (succ2 != NULL_RTX\n-\t\t&& reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (succ2)))\n-\t    || reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i3))))\n-      return 0;\n-#endif\n+  if (AUTO_INC_DEC)\n+    for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+      if (REG_NOTE_KIND (link) == REG_INC\n+\t  && (JUMP_P (i3)\n+\t      || reg_used_between_p (XEXP (link, 0), insn, i3)\n+\t      || (pred != NULL_RTX\n+\t\t  && reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (pred)))\n+\t      || (pred2 != NULL_RTX\n+\t\t  && reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (pred2)))\n+\t      || (succ != NULL_RTX\n+\t\t  && reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (succ)))\n+\t      || (succ2 != NULL_RTX\n+\t\t  && reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (succ2)))\n+\t      || reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i3))))\n+\treturn 0;\n \n   /* Don't combine an insn that follows a CC0-setting insn.\n      An insn that uses CC0 must not be separated from the one that sets it.\n@@ -3040,20 +3034,19 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t    || GET_CODE (XEXP (SET_DEST (PATTERN (i3)), 0)) == POST_DEC)))\n     /* It's not the exception.  */\n #endif\n-#if AUTO_INC_DEC\n-    {\n-      rtx link;\n-      for (link = REG_NOTES (i3); link; link = XEXP (link, 1))\n-\tif (REG_NOTE_KIND (link) == REG_INC\n-\t    && (reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i2))\n-\t\t|| (i1 != 0\n-\t\t    && reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i1)))))\n-\t  {\n-\t    undo_all ();\n-\t    return 0;\n-\t  }\n-    }\n-#endif\n+    if (AUTO_INC_DEC)\n+      {\n+\trtx link;\n+\tfor (link = REG_NOTES (i3); link; link = XEXP (link, 1))\n+\t  if (REG_NOTE_KIND (link) == REG_INC\n+\t      && (reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i2))\n+\t\t  || (i1 != 0\n+\t\t      && reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i1)))))\n+\t    {\n+\t      undo_all ();\n+\t      return 0;\n+\t    }\n+      }\n \n   /* See if the SETs in I1 or I2 need to be kept around in the merged\n      instruction: whenever the value set there is still needed past I3."}, {"sha": "93dd4595ed05b26a64bd6c7fcce231a9838ba403", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -3588,7 +3588,6 @@ prev_cc0_setter (rtx_insn *insn)\n   return insn;\n }\n \n-#if AUTO_INC_DEC\n /* Find a RTX_AUTOINC class rtx which matches DATA.  */\n \n static int\n@@ -3604,7 +3603,6 @@ find_auto_inc (const_rtx x, const_rtx reg)\n     }\n   return false;\n }\n-#endif\n \n /* Increment the label uses for all labels present in rtx.  */\n \n@@ -3776,8 +3774,10 @@ try_split (rtx pat, rtx_insn *trial, int last)\n \t    }\n \t  break;\n \n-#if AUTO_INC_DEC\n \tcase REG_INC:\n+\t  if (!AUTO_INC_DEC)\n+\t    break;\n+\n \t  for (insn = insn_last; insn != NULL_RTX; insn = PREV_INSN (insn))\n \t    {\n \t      rtx reg = XEXP (note, 0);\n@@ -3786,7 +3786,6 @@ try_split (rtx pat, rtx_insn *trial, int last)\n \t\tadd_reg_note (insn, REG_INC, reg);\n \t    }\n \t  break;\n-#endif\n \n \tcase REG_ARGS_SIZE:\n \t  fixup_args_size_notes (NULL, insn_last, INTVAL (XEXP (note, 0)));"}, {"sha": "702f3e32bd7c7c77918eea2c80ac69aec362540c", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -1992,11 +1992,11 @@ calculate_loop_reg_pressure (void)\n \n \t  note_stores (PATTERN (insn), mark_reg_store, NULL);\n \n-#if AUTO_INC_DEC\n-\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t    if (REG_NOTE_KIND (link) == REG_INC)\n-\t      mark_reg_store (XEXP (link, 0), NULL_RTX, NULL);\n-#endif\n+\t  if (AUTO_INC_DEC)\n+\t    for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t      if (REG_NOTE_KIND (link) == REG_INC)\n+\t\tmark_reg_store (XEXP (link, 0), NULL_RTX, NULL);\n+\n \t  while (n_regs_set-- > 0)\n \t    {\n \t      rtx note = find_regno_note (insn, REG_UNUSED,"}, {"sha": "f3b2ab5497daeb36f96003bf1554f477d4c1e5f1", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -940,19 +940,19 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n \n       reg = gen_reg_rtx (orig_mode);\n \n-#if AUTO_INC_DEC\n-      {\n-\trtx move = emit_move_insn (reg, src);\n-\tif (MEM_P (src))\n-\t  {\n-\t    rtx note = find_reg_note (insn, REG_INC, NULL_RTX);\n-\t    if (note)\n-\t      add_reg_note (move, REG_INC, XEXP (note, 0));\n-\t  }\n-      }\n-#else\n-      emit_move_insn (reg, src);\n-#endif\n+      if (AUTO_INC_DEC)\n+\t{\n+\t  rtx move = emit_move_insn (reg, src);\n+\t  if (MEM_P (src))\n+\t    {\n+\t      rtx note = find_reg_note (insn, REG_INC, NULL_RTX);\n+\t      if (note)\n+\t\tadd_reg_note (move, REG_INC, XEXP (note, 0));\n+\t    }\n+\t}\n+      else\n+\temit_move_insn (reg, src);\n+\n       src = reg;\n     }\n \n@@ -1043,15 +1043,13 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n \tmdest = simplify_gen_subreg (orig_mode, dest, GET_MODE (dest), 0);\n       minsn = emit_move_insn (real_dest, mdest);\n \n-#if AUTO_INC_DEC\n-  if (MEM_P (real_dest)\n+  if (AUTO_INC_DEC && MEM_P (real_dest)\n       && !(resolve_reg_p (real_dest) || resolve_subreg_p (real_dest)))\n     {\n       rtx note = find_reg_note (insn, REG_INC, NULL_RTX);\n       if (note)\n \tadd_reg_note (minsn, REG_INC, XEXP (note, 0));\n     }\n-#endif\n \n       smove = single_set (minsn);\n       gcc_assert (smove != NULL_RTX);"}, {"sha": "cb7013088bca577caa465972fbab5d840a531873", "filename": "gcc/lra.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -2088,7 +2088,6 @@ has_nonexceptional_receiver (void)\n   return false;\n }\n \n-#if AUTO_INC_DEC\n \n /* Process recursively X of INSN and add REG_INC notes if necessary.  */\n static void\n@@ -2116,7 +2115,6 @@ add_auto_inc_notes (rtx_insn *insn, rtx x)\n     }\n }\n \n-#endif\n \n /* Remove all REG_DEAD and REG_UNUSED notes and regenerate REG_INC.\n    We change pseudos by hard registers without notification of DF and\n@@ -2143,9 +2141,9 @@ update_inc_notes (void)\n \t    else\n \t      pnote = &XEXP (*pnote, 1);\n \t  }\n-#if AUTO_INC_DEC\n-\tadd_auto_inc_notes (insn, PATTERN (insn));\n-#endif\n+\n+\tif (AUTO_INC_DEC)\n+\t  add_auto_inc_notes (insn, PATTERN (insn));\n       }\n }\n "}, {"sha": "b69ace56c8b08cd7269f30edb78bea3ece7ffc62", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -1704,9 +1704,7 @@ int\n asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n {\n   int result = 0;\n-#if AUTO_INC_DEC\n   bool incdec_ok = false;\n-#endif\n \n   /* Use constrain_operands after reload.  */\n   gcc_assert (!reload_completed);\n@@ -1774,7 +1772,6 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \t    result = 1;\n \t  break;\n \n-#if AUTO_INC_DEC\n \tcase '<':\n \tcase '>':\n \t  /* ??? Before auto-inc-dec, auto inc/dec insns are not supposed\n@@ -1784,7 +1781,6 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \n \t     Match any memory and hope things are resolved after reload.  */\n \t  incdec_ok = true;\n-#endif\n \tdefault:\n \t  cn = lookup_constraint (constraint);\n \t  switch (get_constraint_type (cn))\n@@ -1828,9 +1824,8 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \treturn 0;\n     }\n \n-#if AUTO_INC_DEC\n   /* For operands without < or > constraints reject side-effects.  */\n-  if (!incdec_ok && result && MEM_P (op))\n+  if (AUTO_INC_DEC && !incdec_ok && result && MEM_P (op))\n     switch (GET_CODE (XEXP (op, 0)))\n       {\n       case PRE_INC:\n@@ -1843,7 +1838,6 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n       default:\n \tbreak;\n       }\n-#endif\n \n   return result;\n }\n@@ -2806,9 +2800,8 @@ constrain_operands (int strict, alternative_mask alternatives)\n \t\t    = recog_data.operand[funny_match[funny_match_index].this_op];\n \t\t}\n \n-#if AUTO_INC_DEC\n \t      /* For operands without < or > constraints reject side-effects.  */\n-\t      if (recog_data.is_asm)\n+\t      if (AUTO_INC_DEC && recog_data.is_asm)\n \t\t{\n \t\t  for (opno = 0; opno < recog_data.n_operands; opno++)\n \t\t    if (MEM_P (recog_data.operand[opno]))\n@@ -2829,7 +2822,7 @@ constrain_operands (int strict, alternative_mask alternatives)\n \t\t\t  break;\n \t\t\t}\n \t\t}\n-#endif\n+\n \t      return 1;\n \t    }\n \t}"}, {"sha": "57c3ad26b9b0fb6d76f62f80f7fb7bdf11735913", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -1307,11 +1307,11 @@ scan_rtx_address (rtx_insn *insn, rtx *loc, enum reg_class cl,\n     case PRE_INC:\n     case PRE_DEC:\n     case PRE_MODIFY:\n-#if !AUTO_INC_DEC\n       /* If the target doesn't claim to handle autoinc, this must be\n \t something special, like a stack push.  Kill this chain.  */\n+    if (!AUTO_INC_DEC)\n       action = mark_all_read;\n-#endif\n+\n       break;\n \n     case MEM:"}, {"sha": "a670f13b72bb4ff6089d5b1f20372366cd38b8e9", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -5447,14 +5447,13 @@ static void\n update_auto_inc_notes (rtx_insn *insn ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED,\n \t\t       int reloadnum ATTRIBUTE_UNUSED)\n {\n-#if AUTO_INC_DEC\n-  rtx link;\n+  if (!AUTO_INC_DEC)\n+    return;\n \n-  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+  for (rtx link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     if (REG_NOTE_KIND (link) == REG_INC\n         && (int) REGNO (XEXP (link, 0)) == regno)\n       push_replacement (&XEXP (link, 0), reloadnum, VOIDmode);\n-#endif\n }\n \f\n /* Record the pseudo registers we must reload into hard registers in a\n@@ -7168,13 +7167,15 @@ find_inc_amount (rtx x, rtx inced)\n /* Return 1 if registers from REGNO to ENDREGNO are the subjects of a\n    REG_INC note in insn INSN.  REGNO must refer to a hard register.  */\n \n-#if AUTO_INC_DEC\n static int\n reg_inc_found_and_valid_p (unsigned int regno, unsigned int endregno,\n \t\t\t   rtx insn)\n {\n   rtx link;\n \n+  if (!AUTO_INC_DEC)\n+    return 0;\n+\n   gcc_assert (insn);\n \n   if (! INSN_P (insn))\n@@ -7189,11 +7190,6 @@ reg_inc_found_and_valid_p (unsigned int regno, unsigned int endregno,\n       }\n   return 0;\n }\n-#else\n-\n-#define reg_inc_found_and_valid_p(regno,endregno,insn) 0\n-\n-#endif\n \n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.\n    If SETS is 1, also consider SETs.  If SETS is 2, enable checking"}, {"sha": "956f0eb2a1b966fb235a3255a9ceb4d16f6f339c", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -417,9 +417,7 @@ static void delete_output_reload (rtx_insn *, int, int, rtx);\n static void delete_address_reloads (rtx_insn *, rtx_insn *);\n static void delete_address_reloads_1 (rtx_insn *, rtx, rtx_insn *);\n static void inc_for_reload (rtx, rtx, rtx, int);\n-#if AUTO_INC_DEC\n static void add_auto_inc_notes (rtx_insn *, rtx);\n-#endif\n static void substitute (rtx *, const_rtx, rtx);\n static bool gen_reload_chain_without_interm_reg_p (int, int);\n static int reloads_conflict (int, int);\n@@ -1250,9 +1248,8 @@ reload (rtx_insn *first, int global)\n \t      pnote = &XEXP (*pnote, 1);\n \t  }\n \n-#if AUTO_INC_DEC\n-\tadd_auto_inc_notes (insn, PATTERN (insn));\n-#endif\n+\tif (AUTO_INC_DEC)\n+\t  add_auto_inc_notes (insn, PATTERN (insn));\n \n \t/* Simplify (subreg (reg)) if it appears as an operand.  */\n \tcleanup_subreg_operands (insn);\n@@ -7397,10 +7394,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t     is ill-formed and we must reject this optimization.  */\n \t  extract_insn (temp);\n \t  if (constrain_operands (1, get_enabled_alternatives (temp))\n-#if AUTO_INC_DEC\n-\t      && ! find_reg_note (temp, REG_INC, reloadreg)\n-#endif\n-\t      )\n+\t      && (!AUTO_INC_DEC || ! find_reg_note (temp, REG_INC, reloadreg)))\n \t    {\n \t      /* If the previous insn is an output reload, the source is\n \t\t a reload register, and its spill_reg_store entry will\n@@ -8870,10 +8864,10 @@ delete_output_reload (rtx_insn *insn, int j, int last_reload_reg,\n \tcontinue;\n       if (MEM_P (reg2) || reload_override_in[k])\n \treg2 = rld[k].in_reg;\n-#if AUTO_INC_DEC\n-      if (rld[k].out && ! rld[k].out_reg)\n+\n+      if (AUTO_INC_DEC && rld[k].out && ! rld[k].out_reg)\n \treg2 = XEXP (rld[k].in_reg, 0);\n-#endif\n+\n       while (GET_CODE (reg2) == SUBREG)\n \treg2 = SUBREG_REG (reg2);\n       if (rtx_equal_p (reg2, reg))\n@@ -9266,7 +9260,6 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n     }\n }\n \f\n-#if AUTO_INC_DEC\n static void\n add_auto_inc_notes (rtx_insn *insn, rtx x)\n {\n@@ -9291,4 +9284,3 @@ add_auto_inc_notes (rtx_insn *insn, rtx x)\n \t  add_auto_inc_notes (insn, XVECEXP (x, i, j));\n     }\n }\n-#endif"}, {"sha": "e3f48da442080d08b3fbf30dd95152a44a80034e", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -2222,11 +2222,10 @@ init_insn_reg_pressure_info (rtx_insn *insn)\n \n   note_stores (PATTERN (insn), mark_insn_reg_store, insn);\n \n-#if AUTO_INC_DEC\n-  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-    if (REG_NOTE_KIND (link) == REG_INC)\n-      mark_insn_reg_store (XEXP (link, 0), NULL_RTX, insn);\n-#endif\n+  if (AUTO_INC_DEC)\n+    for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+      if (REG_NOTE_KIND (link) == REG_INC)\n+\tmark_insn_reg_store (XEXP (link, 0), NULL_RTX, insn);\n \n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     if (REG_NOTE_KIND (link) == REG_DEAD)"}, {"sha": "3dfefc9fc2e249db319c467d5714a7992f71f3ad", "filename": "gcc/valtrack.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760edf20ba65b2d6b44a6a8c98683e4eb9490009/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=760edf20ba65b2d6b44a6a8c98683e4eb9490009", "patch": "@@ -54,7 +54,9 @@ static rtx\n cleanup_auto_inc_dec (rtx src, machine_mode mem_mode ATTRIBUTE_UNUSED)\n {\n   rtx x = src;\n-#if AUTO_INC_DEC\n+  if (!AUTO_INC_DEC)\n+    return copy_rtx (x);\n+\n   const RTX_CODE code = GET_CODE (x);\n   int i;\n   const char *fmt;\n@@ -137,10 +139,6 @@ cleanup_auto_inc_dec (rtx src, machine_mode mem_mode ATTRIBUTE_UNUSED)\n \t    = cleanup_auto_inc_dec (XVECEXP (src, i, j), mem_mode);\n       }\n \n-#else /* !AUTO_INC_DEC */\n-  x = copy_rtx (x);\n-#endif /* !AUTO_INC_DEC */\n-\n   return x;\n }\n "}]}