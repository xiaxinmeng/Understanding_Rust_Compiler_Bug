{"sha": "92bed036098928cd4659c8990e14cf7ad040e0c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJiZWQwMzYwOTg5MjhjZDQ2NTljODk5MGUxNGNmN2FkMDQwZTBjMg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-06-16T12:21:33Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-06-16T12:21:33Z"}, "message": "c++: Improve access checking inside templates [PR41437]\n\nThis patch generalizes our existing functionality for deferring access\nchecking of typedefs when parsing a function or class template to now\ndefer all kinds of access checks until template instantiation time,\nincluding member function and member object accesses.\n\nSince all access checks eventually go through enforce_access, the main\ncomponent of this patch is new handling inside enforce_access to defer\nthe current access check if we're inside a template.  The bulk of the\nrest of the patch consists of removing now-unneeded code pertaining to\nsuppressing access checks inside templates or pertaining to\ntypedef-specific access handling.  Renamings and other changes with no\nfunctional impact have been split off into the followup patch.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/41437\n\tPR c++/47346\n\t* call.c (enforce_access): Move to semantics.c.\n\t* cp-tree.h (enforce_access): Delete.\n\t(get_types_needing_access_check): Delete.\n\t(add_typedef_to_current_template_for_access_check): Delete.\n\t* decl.c (make_typename_type): Adjust accordingly.  Use\n\tcheck_accessibility_of_qualified_id instead of directly using\n\tperform_or_defer_access_check.\n\t* parser.c (cp_parser_template_declaration_after_parameters):\n\tDon't push a dk_no_check access state when parsing a template.\n\t* pt.c (get_types_needing_access_check): Delete.\n\t(append_type_to_template_for_access_check_1): Delete.\n\t(perform_typedefs_access_check): Adjust.  If type_decl is a\n\tFIELD_DECL, also check its DECL_CONTEXT for dependence. Use\n\ttsubst_copy instead of tsubst to substitute into type_decl so\n\tthat we substitute into the DECL_CONTEXT of a FIELD_DECL.\n\t(append_type_to_template_for_access_check): Delete.\n\t* search.c (accessible_p): Remove the processing_template_decl\n\tearly exit.\n\t* semantics.c (enforce_access): Moved from call.c.  If we're\n\tparsing a template and the access check failed, add the check to\n\tTI_TYPEDEFS_NEEDING_ACCESS_CHECKING.\n\t(perform_or_defer_access_check): Adjust comment.\n\t(add_typedef_to_current_template_for_access_check): Delete.\n\t(check_accessibility_of_qualified_id):  Adjust accordingly.\n\tExit early if the scope is dependent.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/41437\n\tPR c++/47346\n\t* g++.dg/cpp2a/concepts-using2.C: Adjust.\n\t* g++.dg/lto/20081219_1.C: Adjust.\n\t* g++.dg/lto/20091002-1_0.C: Adjust.\n\t* g++.dg/lto/pr65475c_0.C: Adjust.\n\t* g++.dg/opt/dump1.C: Adjust.\n\t* g++.dg/other/pr53574.C: Adjust.\n\t* g++.dg/template/access30.C: New test.\n\t* g++.dg/template/access31.C: New test.\n\t* g++.dg/wrappers/wrapper-around-type-pack-expansion.C: Adjust.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/94003\n\t* testsuite/20_util/is_constructible/94003.cc: New test.", "tree": {"sha": "a41d5a47ed52906aaae2ff413a440c41791e5b94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a41d5a47ed52906aaae2ff413a440c41791e5b94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92bed036098928cd4659c8990e14cf7ad040e0c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92bed036098928cd4659c8990e14cf7ad040e0c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92bed036098928cd4659c8990e14cf7ad040e0c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92bed036098928cd4659c8990e14cf7ad040e0c2/comments", "author": null, "committer": null, "parents": [{"sha": "a97e49a89d11b302b12ec319a3316ba78adca02a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97e49a89d11b302b12ec319a3316ba78adca02a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a97e49a89d11b302b12ec319a3316ba78adca02a"}], "stats": {"total": 396, "additions": 156, "deletions": 240}, "files": [{"sha": "b55dc83f0e7caec48a8add9fe5c8c014a460e8f2", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -7083,42 +7083,6 @@ complain_about_access (tree decl, tree diag_decl, bool issue_error)\n     }\n }\n \n-/* If the current scope isn't allowed to access DECL along\n-   BASETYPE_PATH, give an error.  The most derived class in\n-   BASETYPE_PATH is the one used to qualify DECL. DIAG_DECL is\n-   the declaration to use in the error diagnostic.  */\n-\n-bool\n-enforce_access (tree basetype_path, tree decl, tree diag_decl,\n-\t\ttsubst_flags_t complain, access_failure_info *afi)\n-{\n-  gcc_assert (TREE_CODE (basetype_path) == TREE_BINFO);\n-\n-  if (flag_new_inheriting_ctors\n-      && DECL_INHERITED_CTOR (decl))\n-    {\n-      /* 7.3.3/18: The additional constructors are accessible if they would be\n-\t accessible when used to construct an object of the corresponding base\n-\t class.  */\n-      decl = strip_inheriting_ctors (decl);\n-      basetype_path = lookup_base (basetype_path, DECL_CONTEXT (decl),\n-\t\t\t\t   ba_any, NULL, complain);\n-    }\n-\n-  if (!accessible_p (basetype_path, decl, true))\n-    {\n-      if (flag_new_inheriting_ctors)\n-\tdiag_decl = strip_inheriting_ctors (diag_decl);\n-      if (complain & tf_error)\n-\tcomplain_about_access (decl, diag_decl, true);\n-      if (afi)\n-\tafi->record_access_failure (basetype_path, decl, diag_decl);\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n /* Initialize a temporary of type TYPE with EXPR.  The FLAGS are a\n    bitwise or of LOOKUP_* values.  If any errors are warnings are\n    generated, set *DIAGNOSTIC_FN to \"error\" or \"warning\","}, {"sha": "771d51cc283c99e09216c6685d77bb94ccb1e6fe", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -6339,9 +6339,6 @@ class access_failure_info\n };\n \n extern void complain_about_access\t\t(tree, tree, bool);\n-extern bool enforce_access\t\t\t(tree, tree, tree,\n-\t\t\t\t\t\t tsubst_flags_t,\n-\t\t\t\t\t\t access_failure_info *afi = NULL);\n extern void push_defarg_context\t\t\t(tree);\n extern void pop_defarg_context\t\t\t(void);\n extern tree convert_default_arg\t\t\t(tree, tree, tree, int,\n@@ -6939,7 +6936,6 @@ extern tree make_pack_expansion                 (tree, tsubst_flags_t = tf_warni\n extern bool check_for_bare_parameter_packs      (tree, location_t = UNKNOWN_LOCATION);\n extern tree build_template_info\t\t\t(tree, tree);\n extern tree get_template_info\t\t\t(const_tree);\n-extern vec<qualified_typedef_usage_t, va_gc> *get_types_needing_access_check (tree);\n extern int template_class_depth\t\t\t(tree);\n extern int is_specialization_of\t\t\t(tree, tree);\n extern bool is_specialization_of_friend\t\t(tree, tree);\n@@ -7257,8 +7253,6 @@ extern void finish_mem_initializers\t\t(tree);\n extern tree check_template_template_default_arg (tree);\n extern bool expand_or_defer_fn_1\t\t(tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n-extern void add_typedef_to_current_template_for_access_check (tree, tree,\n-\t\t\t\t\t\t\t      location_t);\n extern bool check_accessibility_of_qualified_id (tree, tree, tree, tsubst_flags_t);\n extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool,\n \t\t\t\t\t\t bool, bool, tsubst_flags_t);"}, {"sha": "539609e8ada0ed2b14e529fd9e87c8dc7931ba86", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -4009,14 +4009,10 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n       return error_mark_node;\n     }\n \n-  if (!perform_or_defer_access_check (TYPE_BINFO (context), t, t, complain))\n+  if (!check_accessibility_of_qualified_id (t, /*object_type=*/NULL_TREE,\n+\t\t\t\t\t    context, complain))\n     return error_mark_node;\n \n-  /* If we are currently parsing a template and if T is a typedef accessed\n-     through CONTEXT then we need to remember and check access of T at\n-     template instantiation time.  */\n-  add_typedef_to_current_template_for_access_check (t, context, input_location);\n-\n   if (want_template)\n     return lookup_template_class (t, TREE_OPERAND (fullname, 1),\n \t\t\t\t  NULL_TREE, context,"}, {"sha": "799f310bceee94a13e785e9724704255825cfc70", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -29118,16 +29118,12 @@ cp_parser_template_declaration_after_parameters (cp_parser* parser,\n     decl = cp_parser_concept_definition (parser);\n   else\n     {\n-      /* There are no access checks when parsing a template, as we do not\n-\t know if a specialization will be a friend.  */\n-      push_deferring_access_checks (dk_no_check);\n       cp_token *token = cp_lexer_peek_token (parser->lexer);\n       decl = cp_parser_single_declaration (parser,\n \t\t\t\t\t   checks,\n \t\t\t\t\t   member_p,\n                                            /*explicit_specialization_p=*/false,\n \t\t\t\t\t   &friend_p);\n-      pop_deferring_access_checks ();\n \n       /* If this is a member template declaration, let the front\n \t end know.  */"}, {"sha": "bab48c2fdf608934a8d305c96ee05cf32ee45268", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 115, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -216,8 +216,6 @@ static bool dependent_type_p_r (tree);\n static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n static tree tsubst_decl (tree, tree, tsubst_flags_t);\n static void perform_typedefs_access_check (tree tmpl, tree targs);\n-static void append_type_to_template_for_access_check_1 (tree, tree, tree,\n-\t\t\t\t\t\t\tlocation_t);\n static tree listify (tree);\n static tree listify_autos (tree, tree);\n static tree tsubst_template_parm (tree, tree, tsubst_flags_t);\n@@ -11532,7 +11530,7 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n     return;\n \n   if (vec<qualified_typedef_usage_t, va_gc> *tdefs\n-      = get_types_needing_access_check (tmpl))\n+      = TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (get_template_info (tmpl)))\n     FOR_EACH_VEC_ELT (*tdefs, i, iter)\n       {\n \ttree type_decl = iter->typedef_decl;\n@@ -11541,8 +11539,10 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n \tif (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n \t  continue;\n \n-\tif (uses_template_parms (type_decl))\n-\t  type_decl = tsubst (type_decl, targs, tf_error, NULL_TREE);\n+\tif (uses_template_parms (type_decl)\n+\t    || (TREE_CODE (type_decl) == FIELD_DECL\n+\t\t&& uses_template_parms (DECL_CONTEXT (type_decl))))\n+\t  type_decl = tsubst_copy (type_decl, targs, tf_error, NULL_TREE);\n \tif (uses_template_parms (type_scope))\n \t  type_scope = tsubst (type_scope, targs, tf_error, NULL_TREE);\n \n@@ -29154,116 +29154,6 @@ check_auto_in_tmpl_args (tree tmpl, tree args)\n   return errors;\n }\n \n-/* For a given template T, return the vector of typedefs referenced\n-   in T for which access check is needed at T instantiation time.\n-   T is either  a FUNCTION_DECL or a RECORD_TYPE.\n-   Those typedefs were added to T by the function\n-   append_type_to_template_for_access_check.  */\n-\n-vec<qualified_typedef_usage_t, va_gc> *\n-get_types_needing_access_check (tree t)\n-{\n-  gcc_checking_assert ((CLASS_TYPE_P (t) || TREE_CODE (t) == FUNCTION_DECL));\n-  \n-  if (tree ti = get_template_info (t))\n-    if (TI_TEMPLATE (ti))\n-      return TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti);\n-\n-  return NULL;\n-}\n-\n-/* Append the typedef TYPE_DECL used in template T to a list of typedefs\n-   tied to T. That list of typedefs will be access checked at\n-   T instantiation time.\n-   T is either a FUNCTION_DECL or a RECORD_TYPE.\n-   TYPE_DECL is a TYPE_DECL node representing a typedef.\n-   SCOPE is the scope through which TYPE_DECL is accessed.\n-   LOCATION is the location of the usage point of TYPE_DECL.\n-\n-   This function is a subroutine of\n-   append_type_to_template_for_access_check.  */\n-\n-static void\n-append_type_to_template_for_access_check_1 (tree t,\n-\t\t\t\t\t    tree type_decl,\n-\t\t\t\t\t    tree scope,\n-\t\t\t\t\t    location_t location)\n-{\n-  qualified_typedef_usage_t typedef_usage;\n-  tree ti;\n-\n-  if (!t || t == error_mark_node)\n-    return;\n-\n-  gcc_assert ((TREE_CODE (t) == FUNCTION_DECL\n-\t       || CLASS_TYPE_P (t))\n-\t      && type_decl\n-\t      && TREE_CODE (type_decl) == TYPE_DECL\n-\t      && scope);\n-\n-  if (!(ti = get_template_info (t)))\n-    return;\n-\n-  gcc_assert (TI_TEMPLATE (ti));\n-\n-  typedef_usage.typedef_decl = type_decl;\n-  typedef_usage.context = scope;\n-  typedef_usage.locus = location;\n-\n-  vec_safe_push (TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti), typedef_usage);\n-}\n-\n-/* Append TYPE_DECL to the template TEMPL.\n-   TEMPL is either a class type, a FUNCTION_DECL or a TEMPLATE_DECL.\n-   At TEMPL instanciation time, TYPE_DECL will be checked to see\n-   if it can be accessed through SCOPE.\n-   LOCATION is the location of the usage point of TYPE_DECL.\n-\n-   e.g. consider the following code snippet:\n-\n-     class C\n-     {\n-       typedef int myint;\n-     };\n-\n-     template<class U> struct S\n-     {\n-       C::myint mi; // <-- usage point of the typedef C::myint\n-     };\n-\n-     S<char> s;\n-\n-   At S<char> instantiation time, we need to check the access of C::myint\n-   In other words, we need to check the access of the myint typedef through\n-   the C scope. For that purpose, this function will add the myint typedef\n-   and the scope C through which its being accessed to a list of typedefs\n-   tied to the template S. That list will be walked at template instantiation\n-   time and access check performed on each typedefs it contains.\n-   Note that this particular code snippet should yield an error because\n-   myint is private to C.  */\n-\n-void\n-append_type_to_template_for_access_check (tree templ,\n-                                          tree type_decl,\n-\t\t\t\t\t  tree scope,\n-\t\t\t\t\t  location_t location)\n-{\n-  qualified_typedef_usage_t *iter;\n-  unsigned i;\n-\n-  gcc_assert (type_decl && (TREE_CODE (type_decl) == TYPE_DECL));\n-\n-  /* Make sure we don't append the type to the template twice.  */\n-  if (vec<qualified_typedef_usage_t, va_gc> *tdefs\n-      = get_types_needing_access_check (templ))\n-    FOR_EACH_VEC_ELT (*tdefs, i, iter)\n-      if (iter->typedef_decl == type_decl && scope == iter->context)\n-\treturn;\n-\n-  append_type_to_template_for_access_check_1 (templ, type_decl,\n-\t\t\t\t\t      scope, location);\n-}\n-\n /* Recursively walk over && expressions searching for EXPR. Return a reference\n    to that expression.  */\n "}, {"sha": "a1a45a5ee6b9ededc995b5b315074e2f0af02da7", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -827,21 +827,6 @@ accessible_p (tree type, tree decl, bool consider_local_p)\n   if (current_function_decl && DECL_THUNK_P (current_function_decl))\n     return 1;\n \n-  /* In a template declaration, we cannot be sure whether the\n-     particular specialization that is instantiated will be a friend\n-     or not.  Therefore, all access checks are deferred until\n-     instantiation.  However, PROCESSING_TEMPLATE_DECL is set in the\n-     parameter list for a template (because we may see dependent types\n-     in default arguments for template parameters), and access\n-     checking should be performed in the outermost parameter list.  */\n-  if (processing_template_decl\n-      /* FIXME CWG has been talking about doing access checking in the context\n-\t of the constraint-expression, rather than the constrained declaration,\n-\t in which case we would want to remove this test.  */\n-      && !processing_constraint_expression_p ()\n-      && (!processing_template_parmlist || processing_template_decl > 1))\n-    return 1;\n-\n   tree otype = NULL_TREE;\n   if (!TYPE_P (type))\n     {"}, {"sha": "13b844a49c9f035dca06336fc75326053f8e28ea", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 72, "deletions": 51, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -256,6 +256,68 @@ pop_to_parent_deferring_access_checks (void)\n     }\n }\n \n+/* If the current scope isn't allowed to access DECL along\n+   BASETYPE_PATH, give an error, or if we're parsing a function or class\n+   template, defer the access check to be performed at instantiation time.\n+   The most derived class in BASETYPE_PATH is the one used to qualify DECL.\n+   DIAG_DECL is the declaration to use in the error diagnostic.  */\n+\n+static bool\n+enforce_access (tree basetype_path, tree decl, tree diag_decl,\n+\t\ttsubst_flags_t complain, access_failure_info *afi = NULL)\n+{\n+  gcc_assert (TREE_CODE (basetype_path) == TREE_BINFO);\n+\n+  if (flag_new_inheriting_ctors\n+      && DECL_INHERITED_CTOR (decl))\n+    {\n+      /* 7.3.3/18: The additional constructors are accessible if they would be\n+\t accessible when used to construct an object of the corresponding base\n+\t class.  */\n+      decl = strip_inheriting_ctors (decl);\n+      basetype_path = lookup_base (basetype_path, DECL_CONTEXT (decl),\n+\t\t\t\t   ba_any, NULL, complain);\n+    }\n+\n+  tree cs = current_scope ();\n+  if (processing_template_decl\n+      && (CLASS_TYPE_P (cs) || TREE_CODE (cs) == FUNCTION_DECL))\n+    if (tree template_info = get_template_info (cs))\n+      {\n+\t/* When parsing a function or class template, we in general need to\n+\t   defer access checks until template instantiation time, since a friend\n+\t   declaration may grant access only to a particular specialization of\n+\t   the template.  */\n+\n+\tif (accessible_p (basetype_path, decl, /*consider_local_p=*/true))\n+\t  /* But if the member is deemed accessible at parse time, then we can\n+\t     assume it'll be accessible at instantiation time.  */\n+\t  return true;\n+\n+\t/* Defer this access check until instantiation time.  */\n+\tqualified_typedef_usage_t typedef_usage;\n+\ttypedef_usage.typedef_decl = decl;\n+\ttypedef_usage.context = TREE_TYPE (basetype_path);\n+\ttypedef_usage.locus = input_location;\n+\tvec_safe_push (TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (template_info),\n+\t\t       typedef_usage);\n+\treturn true;\n+      }\n+\n+  if (!accessible_p (basetype_path, decl, /*consider_local_p=*/true))\n+    {\n+      if (flag_new_inheriting_ctors)\n+\tdiag_decl = strip_inheriting_ctors (diag_decl);\n+      if (complain & tf_error)\n+\tcomplain_about_access (decl, diag_decl, true);\n+      if (afi)\n+\tafi->record_access_failure (basetype_path, decl, diag_decl);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n /* Perform the access checks in CHECKS.  The TREE_PURPOSE of each node\n    is the BINFO indicating the qualifying scope used to access the\n    DECL node stored in the TREE_VALUE of the node.  If CHECKS is empty\n@@ -320,9 +382,7 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n   deferred_access *ptr;\n   deferred_access_check *chk;\n \n-\n-  /* Exit if we are in a context that no access checking is performed.\n-     */\n+  /* Exit if we are in a context that no access checking is performed.  */\n   if (deferred_access_no_check)\n     return true;\n \n@@ -1992,37 +2052,6 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n   return ret;\n }\n \n-/* If we are currently parsing a template and we encountered a typedef\n-   TYPEDEF_DECL that is being accessed though CONTEXT, this function\n-   adds the typedef to a list tied to the current template.\n-   At template instantiation time, that list is walked and access check\n-   performed for each typedef.\n-   LOCATION is the location of the usage point of TYPEDEF_DECL.  */\n-\n-void\n-add_typedef_to_current_template_for_access_check (tree typedef_decl,\n-                                                  tree context,\n-\t\t\t\t\t\t  location_t location)\n-{\n-    tree template_info = NULL;\n-    tree cs = current_scope ();\n-\n-    if (!is_typedef_decl (typedef_decl)\n-\t|| !context\n-\t|| !CLASS_TYPE_P (context)\n-\t|| !cs)\n-      return;\n-\n-    if (CLASS_TYPE_P (cs) || TREE_CODE (cs) == FUNCTION_DECL)\n-      template_info = get_template_info (cs);\n-\n-    if (template_info\n-\t&& TI_TEMPLATE (template_info)\n-\t&& !currently_open_class (context))\n-      append_type_to_template_for_access_check (cs, typedef_decl,\n-\t\t\t\t\t\tcontext, location);\n-}\n-\n /* DECL was the declaration to which a qualified-id resolved.  Issue\n    an error message if it is not accessible.  If OBJECT_TYPE is\n    non-NULL, we have just seen `x->' or `x.' and OBJECT_TYPE is the\n@@ -2036,28 +2065,21 @@ check_accessibility_of_qualified_id (tree decl,\n \t\t\t\t     tree nested_name_specifier,\n \t\t\t\t     tsubst_flags_t complain)\n {\n-  tree scope;\n-  tree qualifying_type = NULL_TREE;\n-\n-  /* If we are parsing a template declaration and if decl is a typedef,\n-     add it to a list tied to the template.\n-     At template instantiation time, that list will be walked and\n-     access check performed.  */\n-  add_typedef_to_current_template_for_access_check (decl,\n-\t\t\t\t\t\t    nested_name_specifier\n-\t\t\t\t\t\t    ? nested_name_specifier\n-\t\t\t\t\t\t    : DECL_CONTEXT (decl),\n-\t\t\t\t\t\t    input_location);\n-\n   /* If we're not checking, return immediately.  */\n   if (deferred_access_no_check)\n     return true;\n \n   /* Determine the SCOPE of DECL.  */\n-  scope = context_for_name_lookup (decl);\n+  tree scope = context_for_name_lookup (decl);\n   /* If the SCOPE is not a type, then DECL is not a member.  */\n-  if (!TYPE_P (scope))\n+  if (!TYPE_P (scope)\n+      /* If SCOPE is dependent then we can't perform this access check now,\n+\t and since we'll perform this access check again after substitution\n+\t there's no need to explicitly defer it.  */\n+      || dependent_type_p (scope))\n     return true;\n+\n+  tree qualifying_type = NULL_TREE;\n   /* Compute the scope through which DECL is being accessed.  */\n   if (object_type\n       /* OBJECT_TYPE might not be a class type; consider:\n@@ -2096,8 +2118,7 @@ check_accessibility_of_qualified_id (tree decl,\n   if (qualifying_type\n       /* It is possible for qualifying type to be a TEMPLATE_TYPE_PARM\n \t or similar in a default argument value.  */\n-      && CLASS_TYPE_P (qualifying_type)\n-      && !dependent_type_p (qualifying_type))\n+      && CLASS_TYPE_P (qualifying_type))\n     return perform_or_defer_access_check (TYPE_BINFO (qualifying_type), decl,\n \t\t\t\t\t  decl, complain);\n "}, {"sha": "b9a67f5d8dae3a297b2050a3f4c920cf579cfb50", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-using2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-using2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-using2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-using2.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -10,7 +10,7 @@ template <typename b> using g = typename f<b>::e;\n struct b;\n template <typename b> struct f { using e = b; };\n template <typename ai> struct m { typedef g<ai> aj; };\n-template <typename b> class n { typedef typename m<b>::aj e; };\n+template <typename b> struct n { typedef typename m<b>::aj e; };\n template <typename b> using an = typename n<b>::e;\n template <typename> constexpr bool ao = c<true>::d;\n template <typename> constexpr bool i = c<1>::d;\n@@ -38,7 +38,7 @@ template <typename da> concept de = dd<da>;\n struct {\n   template <de da, typename b> void operator()(da, b);\n } di;\n-class p {\n+struct p {\n   void begin();\n };\n template <typename> using df = p;"}, {"sha": "8d64a0212cb83e708e6582d94ee7d4a897ee5c7e", "filename": "gcc/testsuite/g++.dg/lto/20081219_1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_1.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -7,7 +7,7 @@ namespace std __attribute__ ((__visibility__ (\"default\")))\n {\n   using::mbstate_t;\n   typedef int *__c_locale;\n-  class locale\n+  struct locale\n   {\n     class facet;\n   };"}, {"sha": "e09ce01cdfc5d1fc1e24e8802c059ab16302cdde", "filename": "gcc/testsuite/g++.dg/lto/20091002-1_0.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -14,7 +14,7 @@ namespace std __attribute__ ((__visibility__ (\"default\")))\n   typedef basic_ostream<char> ostream;\n   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >\n       class num_get;\n-  class locale   {\n+  struct locale   {\n       class facet;\n   };\n   class locale::facet   {"}, {"sha": "4e3de7d6a349ef2f9b4dfe975f6c86396207be44", "filename": "gcc/testsuite/g++.dg/lto/pr65475c_0.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_0.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -24,7 +24,9 @@ namespace std\n {\n class locale\n {\n+public:\n     class facet;\n+private:\n     class _Impl;\n     _Impl *_M_impl;\n };\n@@ -70,6 +72,7 @@ class ios_base\n     int _M_word_size;\n     _Words *_M_word;\n     locale _M_ios_locale;\n+protected:\n     virtual ~ ios_base ();\n };\n template < typename, typename > class istreambuf_iterator"}, {"sha": "558bee007626943bbf2e8f204cfdee82e6d9a2f8", "filename": "gcc/testsuite/g++.dg/opt/dump1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -396,7 +396,7 @@ namespace std __attribute__ ((__visibility__ (\"default\")))\n     ;\n   template<typename _Signature>\n     class function;\n-  class _Function_base\n+  struct _Function_base\n   {\n     template<typename _Functor>\n       class _Base_manager"}, {"sha": "87622d522ee5a29281e411e4346b755305ceb511", "filename": "gcc/testsuite/g++.dg/other/pr53574.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr53574.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr53574.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr53574.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -6,7 +6,7 @@ template <typename> struct A { typedef int type; };\n struct B {\n   typedef __SIZE_TYPE__ H;\n };\n-template <typename> class allocator : B {};\n+template <typename> class allocator : public B {};\n template <typename _Alloc> struct C {\n   template <typename T>\n   static typename T::H foo(T *);"}, {"sha": "b03a99af1f0642cc77d297fa3ea2ae3166bcfb99", "filename": "gcc/testsuite/g++.dg/template/access30.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess30.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/41437\n+// { dg-do compile }\n+\n+class A { struct B { B(); }; };\n+template<typename T> void f() { A::B b; } // { dg-error \"private\" }\n+void g() { f<int>(); }\n+\n+class X { template<typename> struct A{}; };\n+\n+X::A<int> a; // { dg-error \"private\" }"}, {"sha": "0aa7dbbf8f1f5e3fa4b4dac64b9c8a387a41cf8a", "filename": "gcc/testsuite/g++.dg/template/access31.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess31.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/47346\n+// { dg-do compile }\n+\n+class C\n+{\n+  struct Private { };\n+};\n+\n+template<typename T>\n+struct exploit1\n+{\n+    typedef C::Private type; // { dg-error \"private\" }\n+};\n+exploit1<int>::type x1;\n+\n+template<typename T>\n+struct exploit2 : C::Private // { dg-error \"private\" }\n+{\n+};\n+exploit2<int> x2;\n+\n+template<typename T>\n+struct exploit3\n+{\n+    template<class U = C::Private> // { dg-error \"private\" }\n+    struct E {};\n+};\n+\n+exploit3<int>::E<> e;"}, {"sha": "1f9ad5fdb4725a2f717c0767f4da6bdbe5398e67", "filename": "gcc/testsuite/g++.dg/wrappers/wrapper-around-type-pack-expansion.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwrappers%2Fwrapper-around-type-pack-expansion.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwrappers%2Fwrapper-around-type-pack-expansion.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwrappers%2Fwrapper-around-type-pack-expansion.C?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -35,7 +35,7 @@ struct __alloc_traits    : allocator_traits<_Alloc>    {\n   template<typename _Tp>       struct rebind       {   typedef typename _Base_type::template rebind_alloc<_Tp> other;   };\n };\n \n-template<typename _Tp>     class allocator {\n+template<typename _Tp>     struct allocator {\n   typedef _Tp value_type;\n   template<typename _Tp1>  struct rebind  {   typedef allocator<_Tp1> other;   };\n };"}, {"sha": "80646b37f55d04b4eb86f40a6938fabde3b81314", "filename": "libstdc++-v3/testsuite/20_util/is_constructible/94003.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92bed036098928cd4659c8990e14cf7ad040e0c2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2F94003.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92bed036098928cd4659c8990e14cf7ad040e0c2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2F94003.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2F94003.cc?ref=92bed036098928cd4659c8990e14cf7ad040e0c2", "patch": "@@ -0,0 +1,28 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <type_traits>\n+\n+class Class { Class() {} };\n+\n+template <typename X> static bool foo() {\n+  return std::is_constructible<Class>::value;\n+}\n+\n+static_assert(!std::is_constructible<Class>::value, \"\");"}]}