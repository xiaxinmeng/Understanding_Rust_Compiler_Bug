{"sha": "a441447f7f6495bb8a8e6d160d7c095da787e708", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ0MTQ0N2Y3ZjY0OTViYjhhOGU2ZDE2MGQ3YzA5NWRhNzg3ZTcwOA==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2006-06-23T16:18:49Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2006-06-23T16:18:49Z"}, "message": "tree.c (max_int_size_in_bytes): New function, inspired from code in function.c:assign_temp.\n\n        * tree.c (max_int_size_in_bytes): New function, inspired from\n        code in function.c:assign_temp.\n        * tree.h (max_int_size_in_bytes): Declare.\n        * function.c (assign_temp): Use it.\n        * gimplify.c (create_tmp_var): Relax the assertions on the type\n        properties, not mandating constant size any more.\n        (force_constant_size): New static function.\n        (gimple_add_tmp_var): Use it, forcing variable size to a\n        constant upper bound if it is not constant on entry.\n\n        * ada/misc.c (gnat_type_max_size): Look at TYPE_ADA_SIZE if we have\n        not been able to get a constant upper bound from TYPE_SIZE_UNIT.\n\n\t* gnat.dg/varsize_temp.adb: New test.\n\nFrom-SVN: r114938", "tree": {"sha": "21e2dd58058f99241fdf55ad680c1c3ebc3dd2e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21e2dd58058f99241fdf55ad680c1c3ebc3dd2e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a441447f7f6495bb8a8e6d160d7c095da787e708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a441447f7f6495bb8a8e6d160d7c095da787e708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a441447f7f6495bb8a8e6d160d7c095da787e708", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a441447f7f6495bb8a8e6d160d7c095da787e708/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3d536f1c1c0aa3d414c17c4acc44c900b1f1e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d536f1c1c0aa3d414c17c4acc44c900b1f1e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3d536f1c1c0aa3d414c17c4acc44c900b1f1e38"}], "stats": {"total": 176, "additions": 153, "deletions": 23}, "files": [{"sha": "508ee05d8c181236ba2b465722724164c4138850", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a441447f7f6495bb8a8e6d160d7c095da787e708", "patch": "@@ -1,3 +1,18 @@\n+2006-06-23  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* tree.c (max_int_size_in_bytes): New function, inspired from\n+\tcode in function.c:assign_temp.\n+\t* tree.h (max_int_size_in_bytes): Declare.\n+\t* function.c (assign_temp): Use it.\n+\t* gimplify.c (create_tmp_var): Relax the assertions on the type\n+\tproperties, not mandating constant size any more.\n+\t(force_constant_size): New static function.\n+\t(gimple_add_tmp_var): Use it, forcing variable size to a\n+\tconstant upper bound if it is not constant on entry.\n+\n+\t* ada/misc.c (gnat_type_max_size): Look at TYPE_ADA_SIZE if we have\n+\tnot been able to get a constant upper bound from TYPE_SIZE_UNIT.\n+\n 2006-06-23  Danny Smith   <dannysmith@users.sourceforge.net>\n \n \tPR target/27789"}, {"sha": "47206da7e8699b86f84d4affb4f9cebbb580c8a3", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=a441447f7f6495bb8a8e6d160d7c095da787e708", "patch": "@@ -745,13 +745,40 @@ gnat_get_alias_set (tree type)\n   return -1;\n }\n \n-/* GNU_TYPE is a type.  Return its maxium size in bytes, if known.  */\n+/* GNU_TYPE is a type.  Return its maxium size in bytes, if known,\n+   as a constant when possible.  */\n \n static tree\n-gnat_type_max_size (gnu_type)\n-     tree gnu_type;\n+gnat_type_max_size (tree gnu_type)\n {\n-  return max_size (TYPE_SIZE_UNIT (gnu_type), true);\n+  /* First see what we can get from TYPE_SIZE_UNIT, which might not be\n+     constant even for simple expressions if it has already been gimplified\n+     and replaced by a VAR_DECL.  */\n+\n+  tree max_unitsize = max_size (TYPE_SIZE_UNIT (gnu_type), true);\n+\n+  /* If we don't have a constant, see what we can get from TYPE_ADA_SIZE,\n+     typically not gimplified.  */\n+\n+  if (!host_integerp (max_unitsize, 1)\n+      && (TREE_CODE (gnu_type) == RECORD_TYPE\n+\t  || TREE_CODE (gnu_type) == UNION_TYPE\n+\t  || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n+      && TYPE_ADA_SIZE (gnu_type))\n+    {\n+      tree max_adasize = max_size (TYPE_ADA_SIZE (gnu_type), true);\n+      \n+      /* If we have succeded in finding a constant, round it up to the\n+\t type's alignment and return the result in byte units.  */\n+\n+      if (host_integerp (max_adasize, 1))\n+\tmax_unitsize\n+\t  = size_binop (CEIL_DIV_EXPR,\n+\t\t\tround_up (max_adasize, TYPE_ALIGN (gnu_type)),\n+\t\t\tbitsize_unit_node);\n+    }\n+\n+  return max_unitsize;\n }\n \n /* GNU_TYPE is a type. Determine if it should be passed by reference by"}, {"sha": "4f989ddf92960ea74077bdee110e82c8b03d4d60", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a441447f7f6495bb8a8e6d160d7c095da787e708", "patch": "@@ -821,7 +821,6 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n   if (mode == BLKmode || memory_required)\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n-      tree size_tree;\n       rtx tmp;\n \n       /* Zero sized arrays are GNU C extension.  Set size to 1 to avoid\n@@ -830,20 +829,10 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n \tsize = 1;\n \n       /* Unfortunately, we don't yet know how to allocate variable-sized\n-\t temporaries.  However, sometimes we have a fixed upper limit on\n-\t the size (which is stored in TYPE_ARRAY_MAX_SIZE) and can use that\n-\t instead.  This is the case for Chill variable-sized strings.  */\n-      if (size == -1 && TREE_CODE (type) == ARRAY_TYPE\n-\t  && TYPE_ARRAY_MAX_SIZE (type) != NULL_TREE\n-\t  && host_integerp (TYPE_ARRAY_MAX_SIZE (type), 1))\n-\tsize = tree_low_cst (TYPE_ARRAY_MAX_SIZE (type), 1);\n-\n-      /* If we still haven't been able to get a size, see if the language\n-\t can compute a maximum size.  */\n-      if (size == -1\n-\t  && (size_tree = lang_hooks.types.max_size (type)) != 0\n-\t  && host_integerp (size_tree, 1))\n-\tsize = tree_low_cst (size_tree, 1);\n+\t temporaries.  However, sometimes we can find a fixed upper limit on\n+\t the size, so try that instead.  */\n+      else if (size == -1)\n+\tsize = max_int_size_in_bytes (type);\n \n       /* The size of the temporary may be too large to fit into an integer.  */\n       /* ??? Not sure this should happen except for user silliness, so limit"}, {"sha": "965c5f2fa3cc9005d9e6d815f437f9148fac6038", "filename": "gcc/gimplify.c", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=a441447f7f6495bb8a8e6d160d7c095da787e708", "patch": "@@ -479,10 +479,12 @@ create_tmp_var (tree type, const char *prefix)\n   tree tmp_var;\n \n   /* We don't allow types that are addressable (meaning we can't make copies),\n-     incomplete, or of variable size.  */\n-  gcc_assert (!TREE_ADDRESSABLE (type)\n-\t      && COMPLETE_TYPE_P (type)\n-\t      && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST);\n+     or incomplete.  We also used to reject every variable size objects here,\n+     but now support those for which a constant upper bound can be obtained.\n+     The processing for variable sizes is performed in gimple_add_tmp_var,\n+     point at which it really matters and possibly reached via paths not going\n+     through this function, e.g. after direct calls to create_tmp_var_raw.  */\n+  gcc_assert (!TREE_ADDRESSABLE (type) && COMPLETE_TYPE_P (type));\n \n   tmp_var = create_tmp_var_raw (type, prefix);\n   gimple_add_tmp_var (tmp_var);\n@@ -688,11 +690,41 @@ declare_vars (tree vars, tree scope, bool debug_info)\n     }\n }\n \n+/* For VAR a VAR_DECL of variable size, try to find a constant upper bound\n+   for the size and adjust DECL_SIZE/DECL_SIZE_UNIT accordingly.  Abort if\n+   no such upper bound can be obtained.  */\n+\n+static void\n+force_constant_size (tree var)\n+{\n+  /* The only attempt we make is by querying the maximum size of objects\n+     of the variable's type.  */\n+\n+  HOST_WIDE_INT max_size;\n+\n+  gcc_assert (TREE_CODE (var) == VAR_DECL);\n+\n+  max_size = max_int_size_in_bytes (TREE_TYPE (var));\n+\n+  gcc_assert (max_size >= 0);\n+\n+  DECL_SIZE_UNIT (var)\n+    = build_int_cst (TREE_TYPE (DECL_SIZE_UNIT (var)), max_size);\n+  DECL_SIZE (var)\n+    = build_int_cst (TREE_TYPE (DECL_SIZE (var)), max_size * BITS_PER_UNIT);\n+}\n+\n void\n gimple_add_tmp_var (tree tmp)\n {\n   gcc_assert (!TREE_CHAIN (tmp) && !DECL_SEEN_IN_BIND_EXPR_P (tmp));\n \n+  /* Later processing assumes that the object size is constant, which might\n+     not be true at this point.  Force the use of a constant upper bound in\n+     this case.  */\n+  if (!host_integerp (DECL_SIZE_UNIT (tmp), 1))\n+    force_constant_size (tmp);\n+\n   DECL_CONTEXT (tmp) = current_function_decl;\n   DECL_SEEN_IN_BIND_EXPR_P (tmp) = 1;\n "}, {"sha": "cadfeef986d263bdc477fb6dac799bd80288136e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a441447f7f6495bb8a8e6d160d7c095da787e708", "patch": "@@ -1,3 +1,7 @@\n+2006-06-23  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gnat.dg/varsize_temp.adb: New test.\n+\t\n 2006-06-23  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/11468"}, {"sha": "b7c3a0b6039767ac741be1ec73e4e175246a9056", "filename": "gcc/testsuite/gnat.dg/varsize_temp.adb", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize_temp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize_temp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize_temp.adb?ref=a441447f7f6495bb8a8e6d160d7c095da787e708", "patch": "@@ -0,0 +1,29 @@\n+-- { dg-do compile }\n+\n+procedure Varsize_Temp (Nbytes : Natural) is\n+\n+   type Message_T (Length : Natural) is record\n+      case Length is\n+         when 0 => null;\n+         when others => Id : Natural;\n+      end case;\n+   end record;\n+\n+   type Local_Message_T is new Message_T (Nbytes);\n+\n+   function One_message return Local_Message_T is\n+      M : Local_Message_T;\n+   begin\n+      if M.Length > 0 then\n+         M.Id := 1;\n+      end if;\n+      return M;\n+   end;\n+\n+   procedure Process (X : Local_Message_T) is begin null; end;\n+\n+begin\n+   Process (One_Message);\n+end;\n+\n+"}, {"sha": "cbf4cc51eed72770122a4f6b5421ec9e0635a6fa", "filename": "gcc/tree.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a441447f7f6495bb8a8e6d160d7c095da787e708", "patch": "@@ -1733,6 +1733,39 @@ int_size_in_bytes (tree type)\n \n   return TREE_INT_CST_LOW (t);\n }\n+\n+/* Return the maximum size of TYPE (in bytes) as a wide integer\n+   or return -1 if the size can vary or is larger than an integer.  */\n+\n+HOST_WIDE_INT\n+max_int_size_in_bytes (tree type)\n+{\n+  HOST_WIDE_INT size = -1;\n+  tree size_tree;\n+\n+  /* If this is an array type, check for a possible MAX_SIZE attached.  */\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      size_tree = TYPE_ARRAY_MAX_SIZE (type);\n+\n+      if (size_tree && host_integerp (size_tree, 1))\n+\tsize = tree_low_cst (size_tree, 1);\n+    }\n+\n+  /* If we still haven't been able to get a size, see if the language\n+     can compute a maximum size.  */\n+\n+  if (size == -1)\n+    {\n+      size_tree = lang_hooks.types.max_size (type);\n+\n+      if (size_tree && host_integerp (size_tree, 1))\n+\tsize = tree_low_cst (size_tree, 1);\n+    }\n+\n+  return size;\n+}\n \f\n /* Return the bit position of FIELD, in bits from the start of the record.\n    This is a tree of type bitsizetype.  */"}, {"sha": "6d8ad6aac5cd9a38814a754524333a463fd96aae", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a441447f7f6495bb8a8e6d160d7c095da787e708/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a441447f7f6495bb8a8e6d160d7c095da787e708", "patch": "@@ -3833,6 +3833,7 @@ extern tree expr_last (tree);\n extern tree expr_only (tree);\n extern tree size_in_bytes (tree);\n extern HOST_WIDE_INT int_size_in_bytes (tree);\n+extern HOST_WIDE_INT max_int_size_in_bytes (tree);\n extern tree bit_position (tree);\n extern HOST_WIDE_INT int_bit_position (tree);\n extern tree byte_position (tree);"}]}