{"sha": "f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE2Y2I4ZGZiOTNhNDI0ODg3YjU0MzAxNWMxZTBjZmM3M2VjMmZlMw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-22T13:23:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-22T13:23:35Z"}, "message": "[Ada] Allow attribute 'Valid_Scalars on private types\n\nThis patch modifies the analysis and expansion of attribute 'Valid_Scalars. It\nis now possible to specify the attribute on a prefix of an untagged private\ntype.\n\n------------\n-- Source --\n------------\n\n--  gnat.adc\n\npragma Initialize_Scalars;\n\n--  pack1.ads\n\npackage Pack1 is\n   type Acc_1  is private;\n   type Acc_2  is private;\n   type Arr_1  is private;\n   type Arr_2  is private;\n   type Bool_1 is private;\n   type Cmpx_1 is private;\n   type Cmpx_2 is private;\n   type Enum_1 is private;\n   type Enum_2 is private;\n   type Fix_1  is private;\n   type Fix_2  is private;\n   type Flt_1  is private;\n   type Flt_2  is private;\n   type Modl_1 is private;\n   type Prot_1 is limited private;\n   type Prot_2 is limited private;\n   type Prot_3 (Discr : Boolean) is limited private;\n   type Rec_1  is private;\n   type Rec_2  is private;\n   type Rec_3  is private;\n   type Rec_4 (Discr : Boolean) is private;\n   type Rec_5 (Discr_1 : Boolean; Discr_2 : Boolean) is private;\n   type Sign_1 is private;\n   type Tag_1  is tagged private;\n   type Task_1 is limited private;\n   type Task_2 (Discr : Boolean) is limited private;\n\n   type Prec_Arr_1 is private;\n   type Prec_Arr_2 is private;\n   type Prec_Arr_3 is private;\n   type Prec_Arr_4 is private;\n   type Prec_Arr_5 is private;\n\n   type Prec_Rec_1 is private;\n   type Prec_Rec_2 (Discr : Boolean) is private;\n   type Prec_Rec_3 (Discr_1 : Boolean; Discr_2 : Boolean) is private;\n   type Prec_Rec_4 is private;\n   type Prec_Rec_5 is private;\n   type Prec_Rec_6 is private;\n   type Prec_Rec_7 is private;\n   type Prec_Rec_8 is private;\n   type Prec_Rec_9 is private;\n\nprivate\n   type Acc_1 is access Boolean;\n   type Acc_2 is access procedure;\n   type Arr_1  is array (1 .. 10) of Boolean;\n   type Arr_2  is array (1 .. 3) of access Boolean;\n   type Bool_1 is new Boolean;\n   type Cmpx_1 is array (1 .. 5) of Rec_5 (True, True);\n   type Cmpx_2 is record\n      Comp_1 : Cmpx_1;\n      Comp_2 : Rec_4 (True);\n   end record;\n   type Enum_1 is (One, Two, Three);\n   type Enum_2 is ('f', 'o', 'u', 'r');\n   type Fix_1  is delta 0.5 range 0.0 .. 10.0;\n   type Fix_2  is delta 0.1 digits 15;\n   type Flt_1  is digits 8;\n   type Flt_2  is digits 10 range -1.0 .. 1.0;\n   type Modl_1 is mod 8;\n   protected type Prot_1 is\n   end Prot_1;\n   protected type Prot_2 is\n   private\n      Comp_1 : Boolean;\n      Comp_2 : Boolean;\n   end Prot_2;\n   protected type Prot_3 (Discr : Boolean) is\n   private\n      Comp_1 : Boolean;\n      Comp_2 : Rec_4 (Discr);\n   end Prot_3;\n   type Rec_1  is null record;\n   type Rec_2  is record\n      null;\n   end record;\n   type Rec_3  is record\n      Comp_1 : Boolean;\n      Comp_2 : Boolean;\n   end record;\n   type Rec_4 (Discr : Boolean) is record\n      case Discr is\n         when True =>\n            Comp_1 : Boolean;\n            Comp_2 : Boolean;\n         when False =>\n            Comp_3 : access Boolean;\n      end case;\n   end record;\n   type Rec_5 (Discr_1 : Boolean; Discr_2 : Boolean) is record\n      Comp_1 : Boolean;\n      Comp_2 : Boolean;\n      case Discr_1 is\n         when True =>\n            case Discr_2 is\n               when True =>\n                  Comp_3 : Boolean;\n                  Comp_4 : Boolean;\n               when False =>\n                  null;\n            end case;\n         when False =>\n            null;\n      end case;\n   end record;\n   type Sign_1 is range 1 .. 10;\n   type Tag_1 is tagged null record;\n   task type Task_1;\n   task type Task_2 (Discr : Boolean);\n\n   type Prec_Arr_1 is array (1 .. 2) of Boolean;\n   type Prec_Arr_2 is array (1 .. 2, 1 .. 2) of Boolean;\n   type Prec_Arr_3 is array (1 .. 2) of Prec_Rec_1;\n   type Prec_Arr_4 is array (1 .. 2) of Prec_Rec_2 (True);\n   type Prec_Arr_5 is array (1 .. 2) of Prec_Rec_3 (True, True);\n\n   type Prec_Rec_1 is record\n      Comp_1 : Boolean;\n   end record;\n\n   type Prec_Rec_2 (Discr : Boolean) is record\n      case Discr is\n         when True =>\n            Comp_1 : Boolean;\n         when others =>\n            Comp_2 : Boolean;\n      end case;\n   end record;\n\n   type Prec_Rec_3 (Discr_1 : Boolean; Discr_2 : Boolean) is record\n      case Discr_1 is\n         when True =>\n            case Discr_2 is\n               when True =>\n                  Comp_1 : Boolean;\n               when others =>\n                  Comp_2 : Boolean;\n            end case;\n         when False =>\n            case Discr_2 is\n               when True =>\n                  Comp_3 : Boolean;\n               when others =>\n                  Comp_4 : Boolean;\n            end case;\n      end case;\n   end record;\n\n   type Prec_Rec_4 is record\n      Comp : Prec_Arr_1;\n   end record;\n\n   type Prec_Rec_5 is record\n      Comp : Prec_Arr_4;\n   end record;\n\n   type Prec_Rec_6 is record\n      Comp : Prec_Arr_5;\n   end record;\n\n   type Prec_Rec_7 is record\n      Comp : Prec_Rec_4;\n   end record;\n\n   type Prec_Rec_8 is record\n      Comp : Prec_Rec_5;\n   end record;\n\n   type Prec_Rec_9 is record\n      Comp : Prec_Rec_6;\n   end record;\nend Pack1;\n\n--  pack1.adb\n\npackage body Pack1 is\n   protected body Prot_1 is end Prot_1;\n   protected body Prot_2 is end Prot_2;\n   protected body Prot_3 is end Prot_3;\n\n   task body Task_1 is begin null; end Task_1;\n   task body Task_2 is begin null; end Task_2;\nend Pack1;\n\n--  pack2.ads\n\nwith Pack1; use Pack1;\n\npackage Pack2 is\n   type Acc_3  is private;\n   type Acc_4  is private;\n   type Arr_3  is private;\n   type Arr_4  is private;\n   type Bool_2 is private;\n   type Cmpx_3 is private;\n   type Cmpx_4 is private;\n   type Enum_3 is private;\n   type Enum_4 is private;\n   type Fix_3  is private;\n   type Fix_4  is private;\n   type Flt_3  is private;\n   type Flt_4  is private;\n   type Modl_2 is private;\n   type Prot_4 is limited private;\n   type Prot_5 is limited private;\n   type Prot_6 is limited private;\n   type Rec_6  is private;\n   type Rec_7  is private;\n   type Rec_8  is private;\n   type Rec_9  (Discr : Boolean) is private;\n   type Rec_10 (Discr : Boolean) is private;\n   type Sign_2 is private;\n   type Task_3 is limited private;\n\nprivate\n   type Acc_3  is new Acc_1;\n   type Acc_4  is new Acc_2;\n   type Arr_3  is new Arr_1;\n   type Arr_4  is new Arr_2;\n   type Bool_2 is new Bool_1;\n   type Cmpx_3 is new Cmpx_1;\n   type Cmpx_4 is new Cmpx_2;\n   type Enum_3 is new Enum_1;\n   type Enum_4 is new Enum_2;\n   type Fix_3  is new Fix_1;\n   type Fix_4  is new Fix_2;\n   type Flt_3  is new Flt_1;\n   type Flt_4  is new Flt_2;\n   type Modl_2 is new Modl_1;\n   type Prot_4 is new Prot_1;\n   type Prot_5 is new Prot_2;\n   type Prot_6 is new Prot_3 (True);\n   type Rec_6  is new Rec_1;\n   type Rec_7  is new Rec_2;\n   type Rec_8  is new Rec_3;\n   type Rec_9  (Discr : Boolean) is\n     new Rec_4 (Discr => Discr);\n   type Rec_10 (Discr : Boolean) is\n     new Rec_5 (Discr_1 => Discr, Discr_2 => True);\n   type Sign_2 is new Sign_1;\n   type Task_3 is new Task_1;\nend Pack2;\n\n--  main.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\nwith Pack1; use Pack1;\nwith Pack2; use Pack2;\n\nprocedure Main is\n   procedure Check\n     (Actual : Boolean;\n      Valid  : Boolean;\n      Test   : String)\n   is\n   begin\n      if Actual /= Valid then\n         Put_Line (\"ERROR \" & Test);\n         Put_Line (\"  valid : \" & Valid'Img);\n         Put_Line (\"  actual: \" & Actual'Img);\n      end if;\n   end Check;\n\n   Valid     : constant Boolean := True;\n   Not_Valid : constant Boolean := not Valid;\n\n   pragma Warnings (Off);\n   Acc_1_Obj  : Acc_1;\n   Acc_2_Obj  : Acc_2;\n   Acc_3_Obj  : Acc_3;\n   Acc_4_Obj  : Acc_4;\n   Arr_1_Obj  : Arr_1;\n   Arr_2_Obj  : Arr_2;\n   Arr_3_Obj  : Arr_3;\n   Arr_4_Obj  : Arr_4;\n   Bool_1_Obj : Bool_1;\n   Bool_2_Obj : Bool_2;\n   Cmpx_1_Obj : Cmpx_1;\n   Cmpx_2_Obj : Cmpx_2;\n   Cmpx_3_Obj : Cmpx_3;\n   Cmpx_4_Obj : Cmpx_4;\n   Enum_1_Obj : Enum_1;\n   Enum_2_Obj : Enum_2;\n   Enum_3_Obj : Enum_3;\n   Enum_4_Obj : Enum_4;\n   Fix_1_Obj  : Fix_1;\n   Fix_2_Obj  : Fix_2;\n   Fix_3_Obj  : Fix_3;\n   Fix_4_Obj  : Fix_4;\n   Flt_1_Obj  : Flt_1;\n   Flt_2_Obj  : Flt_2;\n   Flt_3_Obj  : Flt_3;\n   Flt_4_Obj  : Flt_4;\n   Modl_1_Obj : Modl_1;\n   Modl_2_Obj : Modl_2;\n   Prot_1_Obj : Prot_1;\n   Prot_2_Obj : Prot_2;\n   Prot_3_Obj : Prot_3 (True);\n   Prot_4_Obj : Prot_4;\n   Prot_5_Obj : Prot_5;\n   Rec_1_Obj  : Rec_1;\n   Rec_2_Obj  : Rec_2;\n   Rec_3_Obj  : Rec_3;\n   Rec_4_Obj  : Rec_4 (True);\n   Rec_5_Obj  : Rec_5 (True, True);\n   Rec_6_Obj  : Rec_6;\n   Rec_7_Obj  : Rec_7;\n   Rec_8_Obj  : Rec_8;\n   Rec_9_Obj  : Rec_9 (True);\n   Sign_1_Obj : Sign_1;\n   Sign_2_Obj : Sign_2;\n   Tag_1_Obj  : Tag_1;\n   Task_1_Obj : Task_1;\n   Task_2_Obj : Task_2 (True);\n   Task_3_Obj : Task_3;\n\n   Prec_Arr_1_Obj : Prec_Arr_1;\n   Prec_Arr_2_Obj : Prec_Arr_2;\n   Prec_Arr_3_Obj : Prec_Arr_3;\n   Prec_Arr_4_Obj : Prec_Arr_4;\n   Prec_Arr_5_Obj : Prec_Arr_5;\n\n   Prec_Rec_1_Obj : Prec_Rec_1;\n   Prec_Rec_2_Obj : Prec_Rec_2 (True);\n   Prec_Rec_3_Obj : Prec_Rec_3 (True, True);\n   Prec_Rec_4_Obj : Prec_Rec_4;\n   Prec_Rec_5_Obj : Prec_Rec_5;\n   Prec_Rec_6_Obj : Prec_Rec_6;\n   Prec_Rec_7_Obj : Prec_Rec_7;\n   Prec_Rec_8_Obj : Prec_Rec_8;\n   Prec_Rec_9_Obj : Prec_Rec_9;\n   pragma Warnings (On);\n\nbegin\n   Check (Acc_1_Obj'Valid_Scalars,  Valid,     \"Acc_1_Obj\");\n   Check (Acc_2_Obj'Valid_Scalars,  Valid,     \"Acc_2_Obj\");\n   Check (Acc_3_Obj'Valid_Scalars,  Valid,     \"Acc_3_Obj\");\n   Check (Acc_4_Obj'Valid_Scalars,  Valid,     \"Acc_4_Obj\");\n   Check (Arr_1_Obj'Valid_Scalars,  Not_Valid, \"Arr_1_Obj\");\n   Check (Arr_2_Obj'Valid_Scalars,  Valid,     \"Arr_2_Obj\");\n   Check (Arr_3_Obj'Valid_Scalars,  Not_Valid, \"Arr_3_Obj\");\n   Check (Arr_4_Obj'Valid_Scalars,  Valid,     \"Arr_4_Obj\");\n   Check (Bool_1_Obj'Valid_Scalars, Not_Valid, \"Bool_1_Obj\");\n   Check (Bool_2_Obj'Valid_Scalars, Not_Valid, \"Bool_2_Obj\");\n   Check (Cmpx_1_Obj'Valid_Scalars, Not_Valid, \"Cmpx_1_Obj\");\n   Check (Cmpx_2_Obj'Valid_Scalars, Not_Valid, \"Cmpx_2_Obj\");\n   Check (Cmpx_3_Obj'Valid_Scalars, Not_Valid, \"Cmpx_3_Obj\");\n   Check (Cmpx_4_Obj'Valid_Scalars, Not_Valid, \"Cmpx_4_Obj\");\n   Check (Enum_1_Obj'Valid_Scalars, Not_Valid, \"Enum_1_Obj\");\n   Check (Enum_2_Obj'Valid_Scalars, Not_Valid, \"Enum_2_Obj\");\n   Check (Enum_3_Obj'Valid_Scalars, Not_Valid, \"Enum_3_Obj\");\n   Check (Enum_4_Obj'Valid_Scalars, Not_Valid, \"Enum_4_Obj\");\n   Check (Fix_1_Obj'Valid_Scalars,  Not_Valid, \"Fix_1_Obj\");\n   Check (Fix_2_Obj'Valid_Scalars,  Not_Valid, \"Fix_2_Obj\");\n   Check (Fix_3_Obj'Valid_Scalars,  Not_Valid, \"Fix_3_Obj\");\n   Check (Fix_4_Obj'Valid_Scalars,  Not_Valid, \"Fix_4_Obj\");\n   Check (Flt_1_Obj'Valid_Scalars,  Not_Valid, \"Flt_1_Obj\");\n   Check (Flt_2_Obj'Valid_Scalars,  Not_Valid, \"Flt_2_Obj\");\n   Check (Flt_3_Obj'Valid_Scalars,  Not_Valid, \"Flt_3_Obj\");\n   Check (Flt_4_Obj'Valid_Scalars,  Not_Valid, \"Flt_4_Obj\");\n   Check (Modl_1_Obj'Valid_Scalars, Not_Valid, \"Modl_1_Obj\");\n   Check (Modl_2_Obj'Valid_Scalars, Not_Valid, \"Modl_2_Obj\");\n   Check (Prot_1_Obj'Valid_Scalars, Valid,     \"Prot_1_Obj\");\n   Check (Prot_2_Obj'Valid_Scalars, Not_Valid, \"Prot_2_Obj\");\n   Check (Prot_3_Obj'Valid_Scalars, Not_Valid, \"Prot_3_Obj\");\n   Check (Prot_4_Obj'Valid_Scalars, Valid,     \"Prot_4_Obj\");\n   Check (Prot_5_Obj'Valid_Scalars, Not_Valid, \"Prot_5_Obj\");\n   Check (Rec_1_Obj'Valid_Scalars,  Valid,     \"Rec_1_Obj\");\n   Check (Rec_2_Obj'Valid_Scalars,  Valid,     \"Rec_2_Obj\");\n   Check (Rec_3_Obj'Valid_Scalars,  Not_Valid, \"Rec_3_Obj\");\n   Check (Rec_4_Obj'Valid_Scalars,  Not_Valid, \"Rec_4_Obj\");\n   Check (Rec_5_Obj'Valid_Scalars,  Not_Valid, \"Rec_5_Obj\");\n   Check (Rec_6_Obj'Valid_Scalars,  Valid,     \"Rec_6_Obj\");\n   Check (Rec_7_Obj'Valid_Scalars,  Valid,     \"Rec_7_Obj\");\n   Check (Rec_8_Obj'Valid_Scalars,  Not_Valid, \"Rec_8_Obj\");\n   Check (Rec_9_Obj'Valid_Scalars,  Not_Valid, \"Rec_9_Obj\");\n   Check (Sign_1_Obj'Valid_Scalars, Not_Valid, \"Sign_1_Obj\");\n   Check (Sign_2_Obj'Valid_Scalars, Not_Valid, \"Sign_2_Obj\");\n   Check (Tag_1_Obj'Valid_Scalars,  Valid,     \"Tag_1_Obj\");\n   Check (Task_1_Obj'Valid_Scalars, Valid,     \"Task_1_Obj\");\n   Check (Task_2_Obj'Valid_Scalars, Valid,     \"Task_2_Obj\");\n   Check (Task_3_Obj'Valid_Scalars, Valid,     \"Task_3_Obj\");\n\n   Check (Prec_Arr_1_Obj'Valid_Scalars, Not_Valid, \"Prec_Arr_1_Obj\");\n   Check (Prec_Arr_2_Obj'Valid_Scalars, Not_Valid, \"Prec_Arr_2_Obj\");\n   Check (Prec_Arr_3_Obj'Valid_Scalars, Not_Valid, \"Prec_Arr_3_Obj\");\n   Check (Prec_Arr_4_Obj'Valid_Scalars, Not_Valid, \"Prec_Arr_4_Obj\");\n   Check (Prec_Arr_5_Obj'Valid_Scalars, Not_Valid, \"Prec_Arr_5_Obj\");\n\n   Check (Prec_Rec_1_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_1_Obj\");\n   Check (Prec_Rec_2_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_2_Obj\");\n   Check (Prec_Rec_3_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_3_Obj\");\n   Check (Prec_Rec_4_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_4_Obj\");\n   Check (Prec_Rec_5_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_5_Obj\");\n   Check (Prec_Rec_6_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_6_Obj\");\n   Check (Prec_Rec_7_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_7_Obj\");\n   Check (Prec_Rec_8_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_8_Obj\");\n   Check (Prec_Rec_9_Obj'Valid_Scalars, Not_Valid, \"Prec_Rec_9_Obj\");\nend Main;\n\n-----------------\n-- Compilation --\n-----------------\n\n$ gnatmake -q main.adb\n$ ./main\n\n2018-05-22  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_attr.adb (Build_Array_VS_Func): Reimplemented.\n\t(Build_Record_VS_Func): Reimplemented.\n\t(Expand_N_Attribute): Reimplement the handling of attribute\n\t'Valid_Scalars.\n\t* sem_attr.adb (Analyze_Attribute): Reimplement the handling of\n\tattribute 'Valid_Scalars.\n\t* sem_util.adb (Scalar_Part_Present): Reimplemented.\n\t(Validated_View): New routine.\n\t* sem_util.ads (Scalar_Part_Present): Update the parameter profile and\n\tcomment on usage.\n\t(Validated_View): New routine.\n\t* doc/gnat_rm/implementation_defined_attributes.rst: Update the\n\tdocumentation of attribute 'Valid_Scalars.\n\t* gnat_rm.texi: Regenerate.\n\nFrom-SVN: r260518", "tree": {"sha": "6e81c979c23c88ac7b1aae73f16d84da0bb2309b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e81c979c23c88ac7b1aae73f16d84da0bb2309b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b3035ab58483345370f144fd9b12e8e072027e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3035ab58483345370f144fd9b12e8e072027e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b3035ab58483345370f144fd9b12e8e072027e4"}], "stats": {"total": 1208, "additions": 723, "deletions": 485}, "files": [{"sha": "76000d253f2d9ced18a0ecf0175b062644df0890", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "patch": "@@ -1,3 +1,20 @@\n+2018-05-22  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_attr.adb (Build_Array_VS_Func): Reimplemented.\n+\t(Build_Record_VS_Func): Reimplemented.\n+\t(Expand_N_Attribute): Reimplement the handling of attribute\n+\t'Valid_Scalars.\n+\t* sem_attr.adb (Analyze_Attribute): Reimplement the handling of\n+\tattribute 'Valid_Scalars.\n+\t* sem_util.adb (Scalar_Part_Present): Reimplemented.\n+\t(Validated_View): New routine.\n+\t* sem_util.ads (Scalar_Part_Present): Update the parameter profile and\n+\tcomment on usage.\n+\t(Validated_View): New routine.\n+\t* doc/gnat_rm/implementation_defined_attributes.rst: Update the\n+\tdocumentation of attribute 'Valid_Scalars.\n+\t* gnat_rm.texi: Regenerate.\n+\n 2018-05-22  Bob Duff  <duff@adacore.com>\n \n \t* binde.adb: (Choose): Ignore a pragma Elaborate_Body that appears in"}, {"sha": "0b4f780bd254d47a890355eb428f910ee53bae2e", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "patch": "@@ -1534,32 +1534,31 @@ Attribute Valid_Scalars\n =======================\n .. index:: Valid_Scalars\n \n-The ``'Valid_Scalars`` attribute is intended to make it easier to\n-check the validity of scalar subcomponents of composite objects. It\n-is defined for any prefix ``X`` that denotes an object.\n-The value of this attribute is of the predefined type Boolean.\n-``X'Valid_Scalars`` yields True if and only if evaluation of\n-``P'Valid`` yields True for every scalar part P of X or if X has\n-no scalar parts. It is not specified in what order the scalar parts\n-are checked, nor whether any more are checked after any one of them\n-is determined to be invalid. If the prefix ``X`` is of a class-wide\n-type ``T'Class`` (where ``T`` is the associated specific type),\n-or if the prefix ``X`` is of a specific tagged type ``T``, then\n-only the scalar parts of components of ``T`` are traversed; in other\n-words, components of extensions of ``T`` are not traversed even if\n-``T'Class (X)'Tag /= T'Tag`` . The compiler will issue a warning if it can\n-be determined at compile time that the prefix of the attribute has no\n-scalar parts (e.g., if the prefix is of an access type, an interface type,\n-an undiscriminated task type, or an undiscriminated protected type).\n-\n-For scalar types, ``Valid_Scalars`` is equivalent to ``Valid``. The use\n-of this attribute is not permitted for ``Unchecked_Union`` types for which\n-in general it is not possible to determine the values of the discriminants.\n-\n-Note: ``Valid_Scalars`` can generate a lot of code, especially in the case\n-of a large variant record. If the attribute is called in many places in the\n-same program applied to objects of the same type, it can reduce program size\n-to write a function with a single use of the attribute, and then call that\n+The ``'Valid_Scalars`` attribute is intended to make it easier to check the\n+validity of scalar subcomponents of composite objects. The attribute is defined\n+for any prefix ``P`` which denotes an object. Prefix ``P`` can be any type\n+except for tagged private or ``Unchecked_Union`` types. The value of the\n+attribute is of type ``Boolean``.\n+\n+``P'Valid_Scalars`` yields ``True`` if and only if the evaluation of\n+``C'Valid`` yields ``True`` for every scalar subcomponent ``C`` of ``P``, or if\n+``P`` has no scalar subcomponents. Attribute ``'Valid_Scalars`` is equivalent\n+to attribute ``'Valid`` for scalar types.\n+\n+It is not specified in what order the subcomponents are checked, nor whether\n+any more are checked after any one of them is determined to be invalid. If the\n+prefix ``P`` is of a class-wide type ``T'Class`` (where ``T`` is the associated\n+specific type), or if the prefix ``P`` is of a specific tagged type ``T``, then\n+only the subcomponents of ``T`` are checked; in other words, components of\n+extensions of ``T`` are not checked even if ``T'Class (P)'Tag /= T'Tag``.\n+\n+The compiler will issue a warning if it can be determined at compile time that\n+the prefix of the attribute has no scalar subcomponents.\n+\n+Note: ``Valid_Scalars`` can generate a lot of code, especially in the case of\n+a large variant record. If the attribute is called in many places in the same\n+program applied to objects of the same type, it can reduce program size to\n+write a function with a single use of the attribute, and then call that\n function from multiple places.\n \n Attribute VADS_Size"}, {"sha": "c29aa808ccf516332720d502f160f70e9c82c76c", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 535, "deletions": 386, "changes": 921, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "patch": "@@ -75,23 +75,41 @@ package body Exp_Attr is\n    -----------------------\n \n    function Build_Array_VS_Func\n-     (A_Type : Entity_Id;\n-      Nod    : Node_Id) return Entity_Id;\n-   --  Build function to test Valid_Scalars for array type A_Type. Nod is the\n-   --  Valid_Scalars attribute node, used to insert the function body, and the\n-   --  value returned is the entity of the constructed function body. We do not\n-   --  bother to generate a separate spec for this subprogram.\n+     (Attr       : Node_Id;\n+      Formal_Typ : Entity_Id;\n+      Array_Typ  : Entity_Id;\n+      Comp_Typ   : Entity_Id) return Entity_Id;\n+   --  Validate the components of an array type by means of a function. Return\n+   --  the entity of the validation function. The parameters are as follows:\n+   --\n+   --    * Attr - the 'Valid_Scalars attribute for which the function is\n+   --      generated.\n+   --\n+   --    * Formal_Typ - the type of the generated function's only formal\n+   --      parameter.\n+   --\n+   --    * Array_Typ - the array type whose components are to be validated\n+   --\n+   --    * Comp_Typ - the component type of the array\n \n    function Build_Disp_Get_Task_Id_Call (Actual : Node_Id) return Node_Id;\n    --  Build a call to Disp_Get_Task_Id, passing Actual as actual parameter\n \n    function Build_Record_VS_Func\n-     (R_Type : Entity_Id;\n-      Nod    : Node_Id) return Entity_Id;\n-   --  Build function to test Valid_Scalars for record type A_Type. Nod is the\n-   --  Valid_Scalars attribute node, used to insert the function body, and the\n-   --  value returned is the entity of the constructed function body. We do not\n-   --  bother to generate a separate spec for this subprogram.\n+     (Attr       : Node_Id;\n+      Formal_Typ : Entity_Id;\n+      Rec_Typ    : Entity_Id) return Entity_Id;\n+   --  Validate the components, discriminants, and variants of a record type by\n+   --  means of a function. Return the entity of the validation function. The\n+   --  parameters are as follows:\n+   --\n+   --    * Attr - the 'Valid_Scalars attribute for which the function is\n+   --      generated.\n+   --\n+   --    * Formal_Typ - the type of the generated function's only formal\n+   --      parameter.\n+   --\n+   --    * Rec_Typ - the record type whose internals are to be validated\n \n    procedure Compile_Stream_Body_In_Scope\n      (N     : Node_Id;\n@@ -219,140 +237,178 @@ package body Exp_Attr is\n    -------------------------\n \n    function Build_Array_VS_Func\n-     (A_Type : Entity_Id;\n-      Nod    : Node_Id) return Entity_Id\n+     (Attr       : Node_Id;\n+      Formal_Typ : Entity_Id;\n+      Array_Typ  : Entity_Id;\n+      Comp_Typ   : Entity_Id) return Entity_Id\n    is\n-      Loc        : constant Source_Ptr := Sloc (Nod);\n-      Func_Id    : constant Entity_Id  := Make_Temporary (Loc, 'V');\n-      Comp_Type  : constant Entity_Id  := Component_Type (A_Type);\n-      Body_Stmts : List_Id;\n-      Index_List : List_Id;\n-      Formals    : List_Id;\n-\n-      function Test_Component return List_Id;\n-      --  Create one statement to test validity of one component designated by\n-      --  a full set of indexes. Returns statement list containing test.\n-\n-      function Test_One_Dimension (N : Int) return List_Id;\n-      --  Create loop to test one dimension of the array. The single statement\n-      --  in the loop body tests the inner dimensions if any, or else the\n-      --  single component. Note that this procedure is called recursively,\n-      --  with N being the dimension to be initialized. A call with N greater\n-      --  than the number of dimensions simply generates the component test,\n-      --  terminating the recursion. Returns statement list containing tests.\n+      Loc : constant Source_Ptr := Sloc (Attr);\n+\n+      function Validate_Component\n+        (Obj_Id  : Entity_Id;\n+         Indexes : List_Id) return Node_Id;\n+      --  Process a single component denoted by indexes Indexes. Obj_Id denotes\n+      --  the entity of the validation parameter. Return the check associated\n+      --  with the component.\n+\n+      function Validate_Dimension\n+        (Obj_Id  : Entity_Id;\n+         Dim     : Int;\n+         Indexes : List_Id) return Node_Id;\n+      --  Process dimension Dim of the array type. Obj_Id denotes the entity\n+      --  of the validation parameter. Indexes is a list where each dimension\n+      --  deposits its loop variable, which will later identify a component.\n+      --  Return the loop associated with the current dimension.\n \n-      --------------------\n-      -- Test_Component --\n-      --------------------\n+      ------------------------\n+      -- Validate_Component --\n+      ------------------------\n \n-      function Test_Component return List_Id is\n-         Comp : Node_Id;\n-         Anam : Name_Id;\n+      function Validate_Component\n+        (Obj_Id  : Entity_Id;\n+         Indexes : List_Id) return Node_Id\n+      is\n+         Attr_Nam : Name_Id;\n \n       begin\n-         Comp :=\n-           Make_Indexed_Component (Loc,\n-             Prefix      => Make_Identifier (Loc, Name_uA),\n-             Expressions => Index_List);\n-\n-         if Is_Scalar_Type (Comp_Type) then\n-            Anam := Name_Valid;\n+         if Is_Scalar_Type (Comp_Typ) then\n+            Attr_Nam := Name_Valid;\n          else\n-            Anam := Name_Valid_Scalars;\n+            Attr_Nam := Name_Valid_Scalars;\n          end if;\n \n-         return New_List (\n+         --  Generate:\n+         --    if not Array_Typ (Obj_Id) (Indexes)'Valid[_Scalars] then\n+         --       return False;\n+         --    end if;\n+\n+         return\n            Make_If_Statement (Loc,\n              Condition =>\n                Make_Op_Not (Loc,\n                  Right_Opnd =>\n                    Make_Attribute_Reference (Loc,\n-                     Attribute_Name => Anam,\n-                     Prefix         => Comp)),\n+                     Prefix         =>\n+                       Make_Indexed_Component (Loc,\n+                         Prefix      =>\n+                           Unchecked_Convert_To (Array_Typ,\n+                             New_Occurrence_Of (Obj_Id, Loc)),\n+                         Expressions => Indexes),\n+                     Attribute_Name => Attr_Nam)),\n+\n              Then_Statements => New_List (\n                Make_Simple_Return_Statement (Loc,\n-                 Expression => New_Occurrence_Of (Standard_False, Loc)))));\n-      end Test_Component;\n+                 Expression => New_Occurrence_Of (Standard_False, Loc))));\n+      end Validate_Component;\n \n       ------------------------\n-      -- Test_One_Dimension --\n+      -- Validate_Dimension --\n       ------------------------\n \n-      function Test_One_Dimension (N : Int) return List_Id is\n+      function Validate_Dimension\n+        (Obj_Id  : Entity_Id;\n+         Dim     : Int;\n+         Indexes : List_Id) return Node_Id\n+      is\n          Index : Entity_Id;\n \n       begin\n-         --  If all dimensions dealt with, we simply test the component\n+         --  Validate the component once all dimensions have produced their\n+         --  individual loops.\n \n-         if N > Number_Dimensions (A_Type) then\n-            return Test_Component;\n+         if Dim > Number_Dimensions (Array_Typ) then\n+            return Validate_Component (Obj_Id, Indexes);\n \n-         --  Here we generate the required loop\n+         --  Process the current dimension\n \n          else\n             Index :=\n-              Make_Defining_Identifier (Loc, New_External_Name ('J', N));\n+              Make_Defining_Identifier (Loc, New_External_Name ('J', Dim));\n+\n+            Append_To (Indexes, New_Occurrence_Of (Index, Loc));\n \n-            Append (New_Occurrence_Of (Index, Loc), Index_List);\n+            --  Generate:\n+            --    for J1 in Array_Typ (Obj_Id)'Range (1) loop\n+            --       for JN in Array_Typ (Obj_Id)'Range (N) loop\n+            --          if not Array_Typ (Obj_Id) (Indexes)'Valid[_Scalars]\n+            --          then\n+            --             return False;\n+            --          end if;\n+            --       end loop;\n+            --    end loop;\n \n-            return New_List (\n-              Make_Implicit_Loop_Statement (Nod,\n-                Identifier => Empty,\n+            return\n+              Make_Implicit_Loop_Statement (Attr,\n+                Identifier       => Empty,\n                 Iteration_Scheme =>\n                   Make_Iteration_Scheme (Loc,\n                     Loop_Parameter_Specification =>\n                       Make_Loop_Parameter_Specification (Loc,\n-                        Defining_Identifier => Index,\n+                        Defining_Identifier         => Index,\n                         Discrete_Subtype_Definition =>\n                           Make_Attribute_Reference (Loc,\n-                            Prefix => Make_Identifier (Loc, Name_uA),\n+                            Prefix          =>\n+                              Unchecked_Convert_To (Array_Typ,\n+                                New_Occurrence_Of (Obj_Id, Loc)),\n                             Attribute_Name  => Name_Range,\n                             Expressions     => New_List (\n-                              Make_Integer_Literal (Loc, N))))),\n-                Statements =>  Test_One_Dimension (N + 1)),\n-              Make_Simple_Return_Statement (Loc,\n-                Expression => New_Occurrence_Of (Standard_True, Loc)));\n+                              Make_Integer_Literal (Loc, Dim))))),\n+                Statements       => New_List (\n+                  Validate_Dimension (Obj_Id, Dim + 1, Indexes)));\n          end if;\n-      end Test_One_Dimension;\n+      end Validate_Dimension;\n+\n+      --  Local variables\n+\n+      Func_Id : constant Entity_Id := Make_Temporary (Loc, 'V');\n+      Indexes : constant List_Id   := New_List;\n+      Obj_Id  : constant Entity_Id := Make_Temporary (Loc, 'A');\n+      Stmts   : List_Id;\n \n    --  Start of processing for Build_Array_VS_Func\n \n    begin\n-      Index_List := New_List;\n-      Body_Stmts := Test_One_Dimension (1);\n+      Stmts := New_List (Validate_Dimension (Obj_Id, 1, Indexes));\n \n-      --  Parameter is always (A : A_Typ)\n+      --  Generate:\n+      --    return True;\n \n-      Formals := New_List (\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => Make_Defining_Identifier (Loc, Name_uA),\n-          In_Present          => True,\n-          Out_Present         => False,\n-          Parameter_Type      => New_Occurrence_Of (A_Type, Loc)));\n+      Append_To (Stmts,\n+        Make_Simple_Return_Statement (Loc,\n+          Expression => New_Occurrence_Of (Standard_True, Loc)));\n \n-      --  Build body\n+      --  Generate:\n+      --    function Func_Id (Obj_Id : Formal_Typ) return Boolean is\n+      --    begin\n+      --       Stmts\n+      --    end Func_Id;\n \n       Set_Ekind       (Func_Id, E_Function);\n       Set_Is_Internal (Func_Id);\n+      Set_Is_Pure     (Func_Id);\n+\n+      if not Debug_Generated_Code then\n+         Set_Debug_Info_Off (Func_Id);\n+      end if;\n \n-      Insert_Action (Nod,\n+      Insert_Action (Attr,\n         Make_Subprogram_Body (Loc,\n           Specification              =>\n             Make_Function_Specification (Loc,\n               Defining_Unit_Name       => Func_Id,\n-              Parameter_Specifications => Formals,\n-                Result_Definition        =>\n-                  New_Occurrence_Of (Standard_Boolean, Loc)),\n+              Parameter_Specifications => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => Obj_Id,\n+                  In_Present          => True,\n+                  Out_Present         => False,\n+                  Parameter_Type      => New_Occurrence_Of (Formal_Typ, Loc))),\n+              Result_Definition        =>\n+                New_Occurrence_Of (Standard_Boolean, Loc)),\n           Declarations               => New_List,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => Body_Stmts)));\n+              Statements => Stmts)));\n \n-      if not Debug_Generated_Code then\n-         Set_Debug_Info_Off (Func_Id);\n-      end if;\n-\n-      Set_Is_Pure (Func_Id);\n       return Func_Id;\n    end Build_Array_VS_Func;\n \n@@ -379,281 +435,394 @@ package body Exp_Attr is\n    -- Build_Record_VS_Func --\n    --------------------------\n \n-   --  Generates:\n-\n-   --    function _Valid_Scalars (X : T) return Boolean is\n-   --    begin\n-   --       --  Check discriminants\n-\n-   --       if not X.D1'Valid_Scalars or else\n-   --          not X.D2'Valid_Scalars or else\n-   --         ...\n-   --       then\n-   --          return False;\n-   --       end if;\n-\n-   --       --  Check components\n-\n-   --       if not X.C1'Valid_Scalars or else\n-   --          not X.C2'Valid_Scalars or else\n-   --          ...\n-   --       then\n-   --          return False;\n-   --       end if;\n-\n-   --       --  Check variant part\n-\n-   --       case X.D1 is\n-   --          when V1 =>\n-   --             if not X.C2'Valid_Scalars or else\n-   --                not X.C3'Valid_Scalars or else\n-   --               ...\n-   --             then\n-   --                return False;\n-   --             end if;\n-   --          ...\n-   --          when Vn =>\n-   --             if not X.Cn'Valid_Scalars or else\n-   --               ...\n-   --             then\n-   --                return False;\n-   --             end if;\n-   --       end case;\n-\n-   --       return True;\n-   --    end _Valid_Scalars;\n-\n-   --  If the record type is an unchecked union, we can only check components\n-   --  in the invariant part, given that there are no discriminant values to\n-   --  select a variant.\n-\n    function Build_Record_VS_Func\n-     (R_Type : Entity_Id;\n-      Nod    : Node_Id) return Entity_Id\n+     (Attr       : Node_Id;\n+      Formal_Typ : Entity_Id;\n+      Rec_Typ    : Entity_Id) return Entity_Id\n    is\n-      Loc     : constant Source_Ptr := Sloc (R_Type);\n-      Func_Id : constant Entity_Id  := Make_Temporary (Loc, 'V');\n-      X       : constant Entity_Id  := Make_Defining_Identifier (Loc, Name_X);\n-\n-      function Make_VS_Case\n-        (E      : Entity_Id;\n-         CL     : Node_Id;\n-         Discrs : Elist_Id := New_Elmt_List) return List_Id;\n-      --  Building block for variant valid scalars. Given a Component_List node\n-      --  CL, it generates an 'if' followed by a 'case' statement that compares\n-      --  all components of local temporaries named X and Y (that are declared\n-      --  as formals at some upper level). E provides the Sloc to be used for\n-      --  the generated code.\n-\n-      function Make_VS_If\n-        (E : Entity_Id;\n-         L : List_Id) return Node_Id;\n-      --  Building block for variant validate scalars. Given the list, L, of\n-      --  components (or discriminants) L, it generates a return statement that\n-      --  compares all components of local temporaries named X and Y (that are\n-      --  declared as formals at some upper level). E provides the Sloc to be\n-      --  used for the generated code.\n+      --  NOTE: The logic of Build_Record_VS_Func is intentionally passive.\n+      --  It generates code only when there are components, discriminants,\n+      --  or variant parts to validate.\n+\n+      --  NOTE: The routines within Build_Record_VS_Func are intentionally\n+      --  unnested to avoid deep indentation of code.\n+\n+      Loc : constant Source_Ptr := Sloc (Attr);\n+\n+      procedure Validate_Component_List\n+        (Obj_Id    : Entity_Id;\n+         Comp_List : Node_Id;\n+         Stmts     : in out List_Id);\n+      --  Process all components and variant parts of component list Comp_List.\n+      --  Obj_Id denotes the entity of the validation parameter. All new code\n+      --  is added to list Stmts.\n+\n+      procedure Validate_Field\n+        (Obj_Id : Entity_Id;\n+         Field  : Node_Id;\n+         Cond   : in out Node_Id);\n+      --  Process component declaration or discriminant specification Field.\n+      --  Obj_Id denotes the entity of the validation parameter. Cond denotes\n+      --  an \"or else\" conditional expression which contains the new code (if\n+      --  any).\n+\n+      procedure Validate_Fields\n+        (Obj_Id : Entity_Id;\n+         Fields : List_Id;\n+         Stmts  : in out List_Id);\n+      --  Process component declarations or discriminant specifications in list\n+      --  Fields. Obj_Id denotes the entity of the validation parameter. All\n+      --  new code is added to list Stmts.\n+\n+      procedure Validate_Variant\n+        (Obj_Id : Entity_Id;\n+         Var    : Node_Id;\n+         Alts   : in out List_Id);\n+      --  Process variant Var. Obj_Id denotes the entity of the validation\n+      --  parameter. Alts denotes a list of case statement alternatives which\n+      --  contains the new code (if any).\n+\n+      procedure Validate_Variant_Part\n+        (Obj_Id   : Entity_Id;\n+         Var_Part : Node_Id;\n+         Stmts    : in out List_Id);\n+      --  Process variant part Var_Part. Obj_Id denotes the entity of the\n+      --  validation parameter. All new code is added to list Stmts.\n \n-      ------------------\n-      -- Make_VS_Case --\n-      ------------------\n+      -----------------------------\n+      -- Validate_Component_List --\n+      -----------------------------\n \n-      --  <Make_VS_If on shared components>\n+      procedure Validate_Component_List\n+        (Obj_Id    : Entity_Id;\n+         Comp_List : Node_Id;\n+         Stmts     : in out List_Id)\n+      is\n+         Var_Part : constant Node_Id := Variant_Part (Comp_List);\n \n-      --  case X.D1 is\n-      --     when V1 => <Make_VS_Case> on subcomponents\n-      --     ...\n-      --     when Vn => <Make_VS_Case> on subcomponents\n-      --  end case;\n+      begin\n+         --  Validate all components\n+\n+         Validate_Fields\n+           (Obj_Id => Obj_Id,\n+            Fields => Component_Items (Comp_List),\n+            Stmts  => Stmts);\n+\n+         --  Validate the variant part\n+\n+         if Present (Var_Part) then\n+            Validate_Variant_Part\n+              (Obj_Id   => Obj_Id,\n+               Var_Part => Var_Part,\n+               Stmts    => Stmts);\n+         end if;\n+      end Validate_Component_List;\n+\n+      --------------------\n+      -- Validate_Field --\n+      --------------------\n \n-      function Make_VS_Case\n-        (E      : Entity_Id;\n-         CL     : Node_Id;\n-         Discrs : Elist_Id := New_Elmt_List) return List_Id\n+      procedure Validate_Field\n+        (Obj_Id : Entity_Id;\n+         Field  : Node_Id;\n+         Cond   : in out Node_Id)\n       is\n-         Loc      : constant Source_Ptr := Sloc (E);\n-         Result   : constant List_Id    := New_List;\n-         Variant  : Node_Id;\n-         Alt_List : List_Id;\n+         Field_Id  : constant Entity_Id := Defining_Entity (Field);\n+         Field_Nam : constant Name_Id   := Chars (Field_Id);\n+         Field_Typ : constant Entity_Id := Validated_View (Etype (Field_Id));\n+         Attr_Nam  : Name_Id;\n \n       begin\n-         Append_To (Result, Make_VS_If (E, Component_Items (CL)));\n+         --  Do not process internally-generated fields. Note that checking for\n+         --  Comes_From_Source is not correct because this will eliminate the\n+         --  components within the corresponding record of a protected type.\n \n-         if No (Variant_Part (CL))\n-           or else Is_Unchecked_Union (R_Type)\n+         if Nam_In (Field_Nam, Name_uObject,\n+                               Name_uParent,\n+                               Name_uTag)\n          then\n-            return Result;\n-         end if;\n+            null;\n+\n+         --  Do not process fields without any scalar components\n \n-         Variant := First_Non_Pragma (Variants (Variant_Part (CL)));\n+         elsif not Scalar_Part_Present (Field_Typ) then\n+            null;\n+\n+         --  Otherwise the field needs to be validated. Use Make_Identifier\n+         --  rather than New_Occurrence_Of to identify the field because the\n+         --  wrong entity may be picked up when private types are involved.\n+\n+         --  Generate:\n+         --    [or else] not Rec_Typ (Obj_Id).Item_Nam'Valid[_Scalars]\n+\n+         else\n+            if Is_Scalar_Type (Field_Typ) then\n+               Attr_Nam := Name_Valid;\n+            else\n+               Attr_Nam := Name_Valid_Scalars;\n+            end if;\n \n-         if No (Variant) then\n-            return Result;\n+            Evolve_Or_Else (Cond,\n+              Make_Op_Not (Loc,\n+                Right_Opnd =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix        =>\n+                          Unchecked_Convert_To (Rec_Typ,\n+                            New_Occurrence_Of (Obj_Id, Loc)),\n+                        Selector_Name => Make_Identifier (Loc, Field_Nam)),\n+                    Attribute_Name => Attr_Nam)));\n          end if;\n+      end Validate_Field;\n \n-         Alt_List := New_List;\n-         while Present (Variant) loop\n-            Append_To (Alt_List,\n-              Make_Case_Statement_Alternative (Loc,\n-                Discrete_Choices => New_Copy_List (Discrete_Choices (Variant)),\n-                Statements       =>\n-                  Make_VS_Case (E, Component_List (Variant), Discrs)));\n-            Next_Non_Pragma (Variant);\n-         end loop;\n+      ---------------------\n+      -- Validate_Fields --\n+      ---------------------\n \n-         Append_To (Result,\n-           Make_Case_Statement (Loc,\n-             Expression   =>\n-               Make_Selected_Component (Loc,\n-                 Prefix        => Make_Identifier (Loc, Name_X),\n-                 Selector_Name => New_Copy (Name (Variant_Part (CL)))),\n-             Alternatives => Alt_List));\n+      procedure Validate_Fields\n+        (Obj_Id : Entity_Id;\n+         Fields : List_Id;\n+         Stmts  : in out List_Id)\n+      is\n+         Cond  : Node_Id;\n+         Field : Node_Id;\n+\n+      begin\n+         --  Assume that none of the fields are eligible for verification\n \n-         return Result;\n-      end Make_VS_Case;\n+         Cond := Empty;\n \n-      ----------------\n-      -- Make_VS_If --\n-      ----------------\n+         --  Validate all fields\n \n-      --  Generates:\n+         Field := First_Non_Pragma (Fields);\n+         while Present (Field) loop\n+            Validate_Field\n+              (Obj_Id => Obj_Id,\n+               Field  => Field,\n+               Cond   => Cond);\n \n-      --    if\n-      --      not X.C1'Valid_Scalars\n-      --        or else\n-      --      not X.C2'Valid_Scalars\n-      --        ...\n-      --    then\n-      --       return False;\n-      --    end if;\n+            Next_Non_Pragma (Field);\n+         end loop;\n \n-      --  or a null statement if the list L is empty\n+         --  Generate:\n+         --    if        not Rec_Typ (Obj_Id).Item_Nam_1'Valid[_Scalars]\n+         --      or else not Rec_Typ (Obj_Id).Item_Nam_N'Valid[_Scalars]\n+         --    then\n+         --       return False;\n+         --    end if;\n \n-      function Make_VS_If\n-        (E : Entity_Id;\n-         L : List_Id) return Node_Id\n-      is\n-         Loc        : constant Source_Ptr := Sloc (E);\n-         C          : Node_Id;\n-         Def_Id     : Entity_Id;\n-         Field_Name : Name_Id;\n-         Cond       : Node_Id;\n+         if Present (Cond) then\n+            Append_New_To (Stmts,\n+              Make_Implicit_If_Statement (Attr,\n+                Condition       => Cond,\n+                Then_Statements => New_List (\n+                  Make_Simple_Return_Statement (Loc,\n+                    Expression => New_Occurrence_Of (Standard_False, Loc)))));\n+         end if;\n+      end Validate_Fields;\n \n-      begin\n-         if No (L) then\n-            return Make_Null_Statement (Loc);\n+      ----------------------\n+      -- Validate_Variant --\n+      ----------------------\n \n-         else\n-            Cond := Empty;\n+      procedure Validate_Variant\n+        (Obj_Id : Entity_Id;\n+         Var    : Node_Id;\n+         Alts   : in out List_Id)\n+      is\n+         Stmts : List_Id;\n \n-            C := First_Non_Pragma (L);\n-            while Present (C) loop\n-               Def_Id := Defining_Identifier (C);\n-               Field_Name := Chars (Def_Id);\n+      begin\n+         --  Assume that none of the components and variants are eligible for\n+         --  verification.\n \n-               --  The tags need not be checked since they will always be valid\n+         Stmts := No_List;\n \n-               --  Note also that in the following, we use Make_Identifier for\n-               --  the component names. Use of New_Occurrence_Of to identify\n-               --  the components would be incorrect because wrong entities for\n-               --  discriminants could be picked up in the private type case.\n+         --  Validate componants\n \n-               --  Don't bother with abstract parent in interface case\n+         Validate_Component_List\n+           (Obj_Id    => Obj_Id,\n+            Comp_List => Component_List (Var),\n+            Stmts     => Stmts);\n \n-               if Field_Name = Name_uParent\n-                 and then Is_Interface (Etype (Def_Id))\n-               then\n-                  null;\n+         --  Generate a null statement in case none of the components were\n+         --  verified because this will otherwise eliminate an alternative\n+         --  from the variant case statement and render the generated code\n+         --  illegal.\n \n-               --  Don't bother with tag, always valid, and not scalar anyway\n+         if No (Stmts) then\n+            Append_New_To (Stmts, Make_Null_Statement (Loc));\n+         end if;\n \n-               elsif Field_Name = Name_uTag then\n-                  null;\n+         --  Generate:\n+         --    when Discrete_Choices =>\n+         --       Stmts\n+\n+         Append_New_To (Alts,\n+           Make_Case_Statement_Alternative (Loc,\n+             Discrete_Choices =>\n+               New_Copy_List_Tree (Discrete_Choices (Var)),\n+             Statements       => Stmts));\n+      end Validate_Variant;\n+\n+      ---------------------------\n+      -- Validate_Variant_Part --\n+      ---------------------------\n+\n+      procedure Validate_Variant_Part\n+        (Obj_Id   : Entity_Id;\n+         Var_Part : Node_Id;\n+         Stmts    : in out List_Id)\n+      is\n+         Vars : constant List_Id := Variants (Var_Part);\n+         Alts : List_Id;\n+         Var  : Node_Id;\n \n-               elsif Ekind (Def_Id) = E_Discriminant\n-                 and then Is_Unchecked_Union (R_Type)\n-               then\n-                  null;\n+      begin\n+         --  Assume that none of the variants are eligible for verification\n \n-               --  Don't bother with component with no scalar components\n+         Alts := No_List;\n \n-               elsif not Scalar_Part_Present (Etype (Def_Id)) then\n-                  null;\n+         --  Validate variants\n \n-               --  Normal case, generate Valid_Scalars attribute reference\n+         Var := First_Non_Pragma (Vars);\n+         while Present (Var) loop\n+            Validate_Variant\n+              (Obj_Id => Obj_Id,\n+               Var    => Var,\n+               Alts   => Alts);\n \n-               else\n-                  Evolve_Or_Else (Cond,\n-                    Make_Op_Not (Loc,\n-                      Right_Opnd =>\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix =>\n-                            Make_Selected_Component (Loc,\n-                              Prefix        =>\n-                                Make_Identifier (Loc, Name_X),\n-                              Selector_Name =>\n-                                Make_Identifier (Loc, Field_Name)),\n-                          Attribute_Name => Name_Valid_Scalars)));\n-               end if;\n+            Next_Non_Pragma (Var);\n+         end loop;\n \n-               Next_Non_Pragma (C);\n-            end loop;\n+         --  Even though individual variants may lack eligible components, the\n+         --  alternatives must still be generated.\n \n-            if No (Cond) then\n-               return Make_Null_Statement (Loc);\n+         pragma Assert (Present (Alts));\n \n-            else\n-               return\n-                 Make_Implicit_If_Statement (E,\n-                   Condition       => Cond,\n-                   Then_Statements => New_List (\n-                     Make_Simple_Return_Statement (Loc,\n-                       Expression =>\n-                         New_Occurrence_Of (Standard_False, Loc))));\n-            end if;\n-         end if;\n-      end Make_VS_If;\n+         --  Generate:\n+         --    case Rec_Typ (Obj_Id).Discriminant is\n+         --       when Discrete_Choices_1 =>\n+         --          Stmts_1\n+         --       when Discrete_Choices_N =>\n+         --          Stmts_N\n+         --    end case;\n+\n+         Append_New_To (Stmts,\n+           Make_Case_Statement (Loc,\n+             Expression   =>\n+               Make_Selected_Component (Loc,\n+                 Prefix        =>\n+                   Unchecked_Convert_To (Rec_Typ,\n+                     New_Occurrence_Of (Obj_Id, Loc)),\n+                 Selector_Name => New_Copy_Tree (Name (Var_Part))),\n+             Alternatives => Alts));\n+      end Validate_Variant_Part;\n \n       --  Local variables\n \n-      Def    : constant Node_Id := Parent (R_Type);\n-      Comps  : constant Node_Id := Component_List (Type_Definition (Def));\n-      Stmts  : constant List_Id := New_List;\n-      Pspecs : constant List_Id := New_List;\n+      Func_Id  : constant Entity_Id := Make_Temporary (Loc, 'V');\n+      Obj_Id   : constant Entity_Id := Make_Temporary (Loc, 'R');\n+      Rec_Decl : constant Node_Id   := Declaration_Node (Rec_Typ);\n+      Rec_Def  : constant Node_Id   := Type_Definition (Rec_Decl);\n+      Stmts    : List_Id;\n \n    --  Start of processing for Build_Record_VS_Func\n \n    begin\n-      Append_To (Pspecs,\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => X,\n-          Parameter_Type      => New_Occurrence_Of (R_Type, Loc)));\n+      --  The code generated by this routine is as follows:\n+      --\n+      --    function Func_Id (Obj_Id : Formal_Typ) return Boolean is\n+      --    begin\n+      --       if not        Rec_Typ (Obj_Id).Discriminant_1'Valid[_Scalars]\n+      --         or else not Rec_Typ (Obj_Id).Discriminant_N'Valid[_Scalars]\n+      --       then\n+      --          return False;\n+      --       end if;\n+      --\n+      --       if not        Rec_Typ (Obj_Id).Component_1'Valid[_Scalars]\n+      --         or else not Rec_Typ (Obj_Id).Component_N'Valid[_Scalars]\n+      --       then\n+      --          return False;\n+      --       end if;\n+      --\n+      --       case Discriminant_1 is\n+      --          when Choice_1 =>\n+      --             if not        Rec_Typ (Obj_Id).Component_1'Valid[_Scalars]\n+      --               or else not Rec_Typ (Obj_Id).Component_N'Valid[_Scalars]\n+      --             then\n+      --                return False;\n+      --             end if;\n+      --\n+      --             case Discriminant_N is\n+      --                ...\n+      --          when Choice_N =>\n+      --             ...\n+      --       end case;\n+      --\n+      --       return True;\n+      --    end Func_Id;\n \n-      Append_To (Stmts,\n-        Make_VS_If (R_Type, Discriminant_Specifications (Def)));\n-      Append_List_To (Stmts, Make_VS_Case (R_Type, Comps));\n+      --  Assume that the record type lacks eligible components, discriminants,\n+      --  and variant parts.\n \n-      Append_To (Stmts,\n+      Stmts := No_List;\n+\n+      --  Validate the discriminants\n+\n+      if not Is_Unchecked_Union (Rec_Typ) then\n+         Validate_Fields\n+           (Obj_Id => Obj_Id,\n+            Fields => Discriminant_Specifications (Rec_Decl),\n+            Stmts  => Stmts);\n+      end if;\n+\n+      --  Validate the components and variant parts\n+\n+      Validate_Component_List\n+        (Obj_Id    => Obj_Id,\n+         Comp_List => Component_List (Rec_Def),\n+         Stmts     => Stmts);\n+\n+      --  Generate:\n+      --    return True;\n+\n+      Append_New_To (Stmts,\n         Make_Simple_Return_Statement (Loc,\n           Expression => New_Occurrence_Of (Standard_True, Loc)));\n \n-      Insert_Action (Nod,\n+      --  Generate:\n+      --    function Func_Id (Obj_Id : Formal_Typ) return Boolean is\n+      --    begin\n+      --       Stmts\n+      --    end Func_Id;\n+\n+      Set_Ekind       (Func_Id, E_Function);\n+      Set_Is_Internal (Func_Id);\n+      Set_Is_Pure     (Func_Id);\n+\n+      if not Debug_Generated_Code then\n+         Set_Debug_Info_Off (Func_Id);\n+      end if;\n+\n+      Insert_Action (Attr,\n         Make_Subprogram_Body (Loc,\n           Specification =>\n             Make_Function_Specification (Loc,\n               Defining_Unit_Name       => Func_Id,\n-              Parameter_Specifications => Pspecs,\n-              Result_Definition => New_Occurrence_Of (Standard_Boolean, Loc)),\n+              Parameter_Specifications => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => Obj_Id,\n+                  Parameter_Type      => New_Occurrence_Of (Formal_Typ, Loc))),\n+              Result_Definition        =>\n+                New_Occurrence_Of (Standard_Boolean, Loc)),\n           Declarations               => New_List,\n           Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts)),\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => Stmts)),\n         Suppress => Discriminant_Check);\n \n-      if not Debug_Generated_Code then\n-         Set_Debug_Info_Off (Func_Id);\n-      end if;\n-\n-      Set_Is_Pure (Func_Id);\n       return Func_Id;\n    end Build_Record_VS_Func;\n \n@@ -6501,7 +6670,6 @@ package body Exp_Attr is\n \n       when Attribute_Valid => Valid : declare\n          Btyp : Entity_Id := Base_Type (Ptyp);\n-         Tst  : Node_Id;\n \n          Save_Validity_Checks_On : constant Boolean := Validity_Checks_On;\n          --  Save the validity checking mode. We always turn off validity\n@@ -6565,6 +6733,10 @@ package body Exp_Attr is\n                           Attribute_Name => Name_Last))));\n          end Make_Range_Test;\n \n+         --  Local variables\n+\n+         Tst : Node_Id;\n+\n       --  Start of processing for Attribute_Valid\n \n       begin\n@@ -6893,105 +7065,82 @@ package body Exp_Attr is\n       -------------------\n \n       when Attribute_Valid_Scalars => Valid_Scalars : declare\n-         Ftyp : Entity_Id;\n+         Val_Typ  : constant Entity_Id := Validated_View (Ptyp);\n+         Comp_Typ : Entity_Id;\n+         Expr     : Node_Id;\n \n       begin\n-         if Present (Underlying_Type (Ptyp)) then\n-            Ftyp := Underlying_Type (Ptyp);\n-         else\n-            Ftyp := Ptyp;\n-         end if;\n+         --  Assume that the prefix does not need validation\n \n-         --  Replace by True if no scalar parts\n+         Expr := Empty;\n \n-         if not Scalar_Part_Present (Ftyp) then\n-            Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n-\n-         --  For scalar types, Valid_Scalars is the same as Valid\n-\n-         elsif Is_Scalar_Type (Ftyp) then\n-            Rewrite (N,\n-              Make_Attribute_Reference (Loc,\n-                Attribute_Name => Name_Valid,\n-                Prefix         => Pref));\n+         --  Attribute 'Valid_Scalars is not supported on private tagged types\n \n-         --  For array types, we construct a function that determines if there\n-         --  are any non-valid scalar subcomponents, and call the function.\n-         --  We only do this for arrays whose component type needs checking\n+         if Is_Private_Type (Ptyp) and then Is_Tagged_Type (Ptyp) then\n+            null;\n \n-         elsif Is_Array_Type (Ftyp)\n-           and then Scalar_Part_Present (Component_Type (Ftyp))\n-         then\n-            Rewrite (N,\n-              Make_Function_Call (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of (Build_Array_VS_Func (Ftyp, N), Loc),\n-                Parameter_Associations => New_List (Pref)));\n+         --  Attribute 'Valid_Scalars evaluates to True when the type lacks\n+         --  scalars.\n \n-         --  For record types, we construct a function that determines if there\n-         --  are any non-valid scalar subcomponents, and call the function.\n+         elsif not Scalar_Part_Present (Val_Typ) then\n+            null;\n \n-         elsif Is_Record_Type (Ftyp)\n-           and then Present (Declaration_Node (Ftyp))\n-           and then Nkind (Type_Definition (Declaration_Node (Ftyp))) =\n-                      N_Record_Definition\n-         then\n-            Rewrite (N,\n-              Make_Function_Call (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of (Build_Record_VS_Func (Ftyp, N), Loc),\n-                Parameter_Associations => New_List (Pref)));\n+         --  Attribute 'Valid_Scalars is the same as attribute 'Valid when the\n+         --  validated type is a scalar type. Generate:\n \n-         --  Other record types or types with discriminants\n+         --    Val_Typ (Pref)'Valid\n \n-         elsif Is_Record_Type (Ftyp) or else Has_Discriminants (Ptyp) then\n+         elsif Is_Scalar_Type (Val_Typ) then\n+            Expr :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         =>\n+                  Unchecked_Convert_To (Val_Typ, New_Copy_Tree (Pref)),\n+                Attribute_Name => Name_Valid);\n \n-            --  Build expression with list of equality tests\n+         --  Validate the scalar components of an array by iterating over all\n+         --  dimensions of the array while checking individual components.\n \n-            declare\n-               C : Entity_Id;\n-               X : Node_Id;\n-               A : Name_Id;\n+         elsif Is_Array_Type (Val_Typ) then\n+            Comp_Typ := Validated_View (Component_Type (Val_Typ));\n \n-            begin\n-               X := New_Occurrence_Of (Standard_True, Loc);\n-               C := First_Component_Or_Discriminant (Ptyp);\n-               while Present (C) loop\n-                  if not Scalar_Part_Present (Etype (C)) then\n-                     goto Continue;\n-                  elsif Is_Scalar_Type (Etype (C)) then\n-                     A := Name_Valid;\n-                  else\n-                     A := Name_Valid_Scalars;\n-                  end if;\n+            if Scalar_Part_Present (Comp_Typ) then\n+               Expr :=\n+                 Make_Function_Call (Loc,\n+                   Name                   =>\n+                     New_Occurrence_Of\n+                       (Build_Array_VS_Func\n+                         (Attr       => N,\n+                          Formal_Typ => Ptyp,\n+                          Array_Typ  => Val_Typ,\n+                          Comp_Typ   => Comp_Typ),\n+                       Loc),\n+                   Parameter_Associations => New_List (Pref));\n+            end if;\n \n-                  X :=\n-                    Make_And_Then (Loc,\n-                      Left_Opnd   => X,\n-                      Right_Opnd  =>\n-                        Make_Attribute_Reference (Loc,\n-                          Attribute_Name => A,\n-                          Prefix         =>\n-                            Make_Selected_Component (Loc,\n-                              Prefix        =>\n-                                Duplicate_Subexpr (Pref, Name_Req => True),\n-                              Selector_Name =>\n-                                New_Occurrence_Of (C, Loc))));\n-               <<Continue>>\n-                  Next_Component_Or_Discriminant (C);\n-               end loop;\n+         --  Validate the scalar components, discriminants of a record type by\n+         --  examining the structure of a record type.\n \n-               Rewrite (N, X);\n-            end;\n+         elsif Is_Record_Type (Val_Typ) then\n+            Expr :=\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of\n+                    (Build_Record_VS_Func\n+                      (Attr       => N,\n+                       Formal_Typ => Ptyp,\n+                       Rec_Typ    => Val_Typ),\n+                    Loc),\n+                Parameter_Associations => New_List (Pref));\n+         end if;\n \n-         --  For all other types, result is True\n+         --  Default the attribute to True when the type of the prefix does not\n+         --  need validation.\n \n-         else\n-            Rewrite (N, New_Occurrence_Of (Standard_Boolean, Loc));\n+         if No (Expr) then\n+            Expr := New_Occurrence_Of (Standard_True, Loc);\n          end if;\n \n-         --  Result is always boolean, but never static\n-\n+         Rewrite (N, Expr);\n          Analyze_And_Resolve (N, Standard_Boolean);\n          Set_Is_Static_Expression (N, False);\n       end Valid_Scalars;"}, {"sha": "387e2a04d3ce5bccffbae3c7da6175a9b0a3ead7", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "patch": "@@ -11658,32 +11658,31 @@ which changes element (1,2) to 20 and (3,4) to 30.\n \n @geindex Valid_Scalars\n \n-The @code{'Valid_Scalars} attribute is intended to make it easier to\n-check the validity of scalar subcomponents of composite objects. It\n-is defined for any prefix @code{X} that denotes an object.\n-The value of this attribute is of the predefined type Boolean.\n-@code{X'Valid_Scalars} yields True if and only if evaluation of\n-@code{P'Valid} yields True for every scalar part P of X or if X has\n-no scalar parts. It is not specified in what order the scalar parts\n-are checked, nor whether any more are checked after any one of them\n-is determined to be invalid. If the prefix @code{X} is of a class-wide\n-type @code{T'Class} (where @code{T} is the associated specific type),\n-or if the prefix @code{X} is of a specific tagged type @code{T}, then\n-only the scalar parts of components of @code{T} are traversed; in other\n-words, components of extensions of @code{T} are not traversed even if\n-@code{T'Class (X)'Tag /= T'Tag} . The compiler will issue a warning if it can\n-be determined at compile time that the prefix of the attribute has no\n-scalar parts (e.g., if the prefix is of an access type, an interface type,\n-an undiscriminated task type, or an undiscriminated protected type).\n-\n-For scalar types, @code{Valid_Scalars} is equivalent to @code{Valid}. The use\n-of this attribute is not permitted for @code{Unchecked_Union} types for which\n-in general it is not possible to determine the values of the discriminants.\n-\n-Note: @code{Valid_Scalars} can generate a lot of code, especially in the case\n-of a large variant record. If the attribute is called in many places in the\n-same program applied to objects of the same type, it can reduce program size\n-to write a function with a single use of the attribute, and then call that\n+The @code{'Valid_Scalars} attribute is intended to make it easier to check the\n+validity of scalar subcomponents of composite objects. The attribute is defined\n+for any prefix @code{P} which denotes an object. Prefix @code{P} can be any type\n+except for tagged private or @code{Unchecked_Union} types. The value of the\n+attribute is of type @code{Boolean}.\n+\n+@code{P'Valid_Scalars} yields @code{True} if and only if the evaluation of\n+@code{C'Valid} yields @code{True} for every scalar subcomponent @code{C} of @code{P}, or if\n+@code{P} has no scalar subcomponents. Attribute @code{'Valid_Scalars} is equivalent\n+to attribute @code{'Valid} for scalar types.\n+\n+It is not specified in what order the subcomponents are checked, nor whether\n+any more are checked after any one of them is determined to be invalid. If the\n+prefix @code{P} is of a class-wide type @code{T'Class} (where @code{T} is the associated\n+specific type), or if the prefix @code{P} is of a specific tagged type @code{T}, then\n+only the subcomponents of @code{T} are checked; in other words, components of\n+extensions of @code{T} are not checked even if @code{T'Class (P)'Tag /= T'Tag}.\n+\n+The compiler will issue a warning if it can be determined at compile time that\n+the prefix of the attribute has no scalar subcomponents.\n+\n+Note: @code{Valid_Scalars} can generate a lot of code, especially in the case of\n+a large variant record. If the attribute is called in many places in the same\n+program applied to objects of the same type, it can reduce program size to\n+write a function with a single use of the attribute, and then call that\n function from multiple places.\n \n @node Attribute VADS_Size,Attribute Value_Size,Attribute Valid_Scalars,Implementation Defined Attributes"}, {"sha": "6e874530676fab778e8504522e9aa1e44b7980dc", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "patch": "@@ -2200,8 +2200,8 @@ package body Sem_Attr is\n          Rtyp : Entity_Id;\n \n       begin\n-         --  If we need an object, and we have a prefix that is the name of\n-         --  a function entity, convert it into a function call.\n+         --  If we need an object, and we have a prefix that is the name of a\n+         --  function entity, convert it into a function call.\n \n          if Is_Entity_Name (P)\n            and then Ekind (Entity (P)) = E_Function\n@@ -2601,7 +2601,7 @@ package body Sem_Attr is\n \n       procedure Error_Attr is\n       begin\n-         Set_Etype (N, Any_Type);\n+         Set_Etype  (N, Any_Type);\n          Set_Entity (N, Any_Type);\n          raise Bad_Attribute;\n       end Error_Attr;\n@@ -6863,7 +6863,10 @@ package body Sem_Attr is\n       -- Valid --\n       -----------\n \n-      when Attribute_Valid =>\n+      when Attribute_Valid => Valid : declare\n+         Pred_Func : constant Entity_Id := Predicate_Function (P_Type);\n+\n+      begin\n          Check_E0;\n \n          --  Ignore check for object if we have a 'Valid reference generated\n@@ -6872,54 +6875,77 @@ package body Sem_Attr is\n \n          if Comes_From_Source (N) then\n             Check_Object_Reference (P);\n-         end if;\n-\n-         if not Is_Scalar_Type (P_Type) then\n-            Error_Attr_P (\"object for % attribute must be of scalar type\");\n-         end if;\n \n-         --  If the attribute appears within the subtype's own predicate\n-         --  function, then issue a warning that this will cause infinite\n-         --  recursion.\n+            if not Is_Scalar_Type (P_Type) then\n+               Error_Attr_P (\"object for % attribute must be of scalar type\");\n+            end if;\n \n-         declare\n-            Pred_Func : constant Entity_Id := Predicate_Function (P_Type);\n+            --  If the attribute appears within the subtype's own predicate\n+            --  function, then issue a warning that this will cause infinite\n+            --  recursion.\n \n-         begin\n             if Present (Pred_Func) and then Current_Scope = Pred_Func then\n-               Error_Msg_N\n-                 (\"attribute Valid requires a predicate check??\", N);\n+               Error_Msg_N (\"attribute Valid requires a predicate check??\", N);\n                Error_Msg_N (\"\\and will result in infinite recursion??\", N);\n             end if;\n-         end;\n+         end if;\n \n          Set_Etype (N, Standard_Boolean);\n+      end Valid;\n \n       -------------------\n       -- Valid_Scalars --\n       -------------------\n \n-      when Attribute_Valid_Scalars =>\n+      when Attribute_Valid_Scalars => Valid_Scalars : declare\n+      begin\n          Check_E0;\n-         Check_Object_Reference (P);\n-         Set_Etype (N, Standard_Boolean);\n-\n-         --  Following checks are only for source types\n \n          if Comes_From_Source (N) then\n-            if not Scalar_Part_Present (P_Type) then\n-               Error_Attr_P\n-                 (\"??attribute % always True, no scalars to check\");\n-            end if;\n+            Check_Object_Reference (P);\n \n-            --  Not allowed for unchecked union type\n+            --  Do not emit any diagnostics related to private types to avoid\n+            --  disclosing the structure of the type.\n \n-            if Has_Unchecked_Union (P_Type) then\n-               Error_Attr_P\n-                 (\"attribute % not allowed for Unchecked_Union type\");\n+            if Is_Private_Type (P_Type) then\n+\n+               --  Attribute 'Valid_Scalars is not supported on private tagged\n+               --  types due to a code generation issue. Is_Visible_Component\n+               --  does not allow for a component of a private tagged type to\n+               --  be successfully retrieved.\n+\n+               --  Do not use Error_Attr_P because this bypasses any subsequent\n+               --  processing and leaves the attribute with type Any_Type. This\n+               --  in turn prevents the proper expansion of the attribute into\n+               --  True.\n+\n+               if Is_Tagged_Type (P_Type) then\n+                  Error_Msg_Name_1 := Aname;\n+                  Error_Msg_N (\"??effects of attribute % are ignored\", N);\n+               end if;\n+\n+            --  Otherwise the type is not private\n+\n+            else\n+               if not Scalar_Part_Present (P_Type) then\n+                  Error_Attr_P\n+                    (\"??attribute % always True, no scalars to check\");\n+               end if;\n+\n+               --  Attribute 'Valid_Scalars is illegal on unchecked union types\n+               --  because it is not always guaranteed that the components are\n+               --  retrievable based on whether the discriminants are inferable\n+\n+               if Has_Unchecked_Union (P_Type) then\n+                  Error_Attr_P\n+                    (\"attribute % not allowed for Unchecked_Union type\");\n+               end if;\n             end if;\n          end if;\n \n+         Set_Etype (N, Standard_Boolean);\n+      end Valid_Scalars;\n+\n       -----------\n       -- Value --\n       -----------"}, {"sha": "9708430794972cb8ab33428eda163a1b058b6f92", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "patch": "@@ -23312,24 +23312,25 @@ package body Sem_Util is\n    -- Scalar_Part_Present --\n    -------------------------\n \n-   function Scalar_Part_Present (T : Entity_Id) return Boolean is\n-      C : Entity_Id;\n+   function Scalar_Part_Present (Typ : Entity_Id) return Boolean is\n+      Val_Typ : constant Entity_Id := Validated_View (Typ);\n+      Field   : Entity_Id;\n \n    begin\n-      if Is_Scalar_Type (T) then\n+      if Is_Scalar_Type (Val_Typ) then\n          return True;\n \n-      elsif Is_Array_Type (T) then\n-         return Scalar_Part_Present (Component_Type (T));\n+      elsif Is_Array_Type (Val_Typ) then\n+         return Scalar_Part_Present (Component_Type (Val_Typ));\n \n-      elsif Is_Record_Type (T) or else Has_Discriminants (T) then\n-         C := First_Component_Or_Discriminant (T);\n-         while Present (C) loop\n-            if Scalar_Part_Present (Etype (C)) then\n+      elsif Is_Record_Type (Val_Typ) then\n+         Field := First_Component_Or_Discriminant (Val_Typ);\n+         while Present (Field) loop\n+            if Scalar_Part_Present (Etype (Field)) then\n                return True;\n-            else\n-               Next_Component_Or_Discriminant (C);\n             end if;\n+\n+            Next_Component_Or_Discriminant (Field);\n          end loop;\n       end if;\n \n@@ -24980,6 +24981,49 @@ package body Sem_Util is\n       end if;\n    end Unqual_Conv;\n \n+   --------------------\n+   -- Validated_View --\n+   --------------------\n+\n+   function Validated_View (Typ : Entity_Id) return Entity_Id is\n+      Continue : Boolean;\n+      Val_Typ  : Entity_Id;\n+\n+   begin\n+      Continue := True;\n+      Val_Typ  := Base_Type (Typ);\n+\n+      --  Obtain the full view of the input type by stripping away concurrency,\n+      --  derivations, and privacy.\n+\n+      while Continue loop\n+         Continue := False;\n+\n+         if Is_Concurrent_Type (Val_Typ) then\n+            if Present (Corresponding_Record_Type (Val_Typ)) then\n+               Continue := True;\n+               Val_Typ  := Corresponding_Record_Type (Val_Typ);\n+            end if;\n+\n+         elsif Is_Derived_Type (Val_Typ) then\n+            Continue := True;\n+            Val_Typ  := Etype (Val_Typ);\n+\n+         elsif Is_Private_Type (Val_Typ) then\n+            if Present (Underlying_Full_View (Val_Typ)) then\n+               Continue := True;\n+               Val_Typ  := Underlying_Full_View (Val_Typ);\n+\n+            elsif Present (Full_View (Val_Typ)) then\n+               Continue := True;\n+               Val_Typ  := Full_View (Val_Typ);\n+            end if;\n+         end if;\n+      end loop;\n+\n+      return Val_Typ;\n+   end Validated_View;\n+\n    -----------------------\n    -- Visible_Ancestors --\n    -----------------------"}, {"sha": "0283ad7a2dd14fef566b1795610afcf0caaab8ca", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f16cb8dfb93a424887b543015c1e0cfc73ec2fe3/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f16cb8dfb93a424887b543015c1e0cfc73ec2fe3", "patch": "@@ -2575,11 +2575,9 @@ package Sem_Util is\n    --  A result of False does not necessarily mean they have different values,\n    --  just that it is not possible to determine they have the same value.\n \n-   function Scalar_Part_Present (T : Entity_Id) return Boolean;\n-   --  Tests if type T can be determined at compile time to have at least one\n-   --  scalar part in the sense of the Valid_Scalars attribute. Returns True if\n-   --  this is the case, and False if no scalar parts are present (meaning that\n-   --  the result of Valid_Scalars applied to T is always vacuously True).\n+   function Scalar_Part_Present (Typ : Entity_Id) return Boolean;\n+   --  Determine whether arbitrary type Typ is a scalar type, or contains at\n+   --  least one scalar subcomponent.\n \n    function Scope_Within\n      (Inner : Entity_Id;\n@@ -2790,6 +2788,12 @@ package Sem_Util is\n    --  Similar to Unqualify, but removes qualified expressions, type\n    --  conversions, and unchecked conversions.\n \n+   function Validated_View (Typ : Entity_Id) return Entity_Id;\n+   --  Obtain the \"validated view\" of arbitrary type Typ which is suitable\n+   --  for verification by attributes 'Valid and 'Valid_Scalars. This view\n+   --  is the type itself or its full view while stripping away concurrency,\n+   --  derivations, and privacy.\n+\n    function Visible_Ancestors (Typ : Entity_Id) return Elist_Id;\n    --  [Ada 2012:AI-0125-1]: Collect all the visible parents and progenitors\n    --  of a type extension or private extension declaration. If the full-view"}]}