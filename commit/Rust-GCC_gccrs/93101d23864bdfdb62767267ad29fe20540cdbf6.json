{"sha": "93101d23864bdfdb62767267ad29fe20540cdbf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMxMDFkMjM4NjRiZGZkYjYyNzY3MjY3YWQyOWZlMjA1NDBjZGJmNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-01-26T16:07:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-01-26T16:07:47Z"}, "message": "trans.c (Regular_Loop_to_gnu): Use the SLOC of the iteration scheme, if present, throughout the translation.\n\n\t* gcc-interface/trans.c (Regular_Loop_to_gnu): Use the SLOC of the\n\titeration scheme, if present, throughout the translation.\n\nFrom-SVN: r268299", "tree": {"sha": "888b76cb38fb33ca66459613e24e988815809c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/888b76cb38fb33ca66459613e24e988815809c63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93101d23864bdfdb62767267ad29fe20540cdbf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93101d23864bdfdb62767267ad29fe20540cdbf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93101d23864bdfdb62767267ad29fe20540cdbf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93101d23864bdfdb62767267ad29fe20540cdbf6/comments", "author": null, "committer": null, "parents": [{"sha": "e54b62687aca823aebb15000d33ca59947204881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54b62687aca823aebb15000d33ca59947204881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e54b62687aca823aebb15000d33ca59947204881"}], "stats": {"total": 31, "additions": 21, "deletions": 10}, "files": [{"sha": "6e71b2505cefa8cd61220c621bbdc7d497e1d1e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93101d23864bdfdb62767267ad29fe20540cdbf6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93101d23864bdfdb62767267ad29fe20540cdbf6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=93101d23864bdfdb62767267ad29fe20540cdbf6", "patch": "@@ -1,3 +1,8 @@\n+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Regular_Loop_to_gnu): Use the SLOC of the\n+\titeration scheme, if present, throughout the translation.\n+\n 2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Use"}, {"sha": "3e326b432ed27b40f5681df1faf1d5c0bb81a186", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93101d23864bdfdb62767267ad29fe20540cdbf6/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93101d23864bdfdb62767267ad29fe20540cdbf6/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=93101d23864bdfdb62767267ad29fe20540cdbf6", "patch": "@@ -3501,25 +3501,29 @@ Acc_Loop_to_gnu (Node_Id gnat_loop)\n static tree\n Regular_Loop_to_gnu (Node_Id gnat_node, tree *gnu_cond_expr_p)\n {\n-  struct loop_info_d * const gnu_loop_info = gnu_loop_stack->last ();\n-  tree gnu_loop_stmt = gnu_loop_info->stmt;\n-\n   const Node_Id gnat_iter_scheme = Iteration_Scheme (gnat_node);\n-  tree gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n-\n+  struct loop_info_d *const gnu_loop_info = gnu_loop_stack->last ();\n+  tree gnu_loop_stmt = gnu_loop_info->stmt;\n+  tree gnu_loop_label = LOOP_STMT_LABEL (gnu_loop_stmt);\n   tree gnu_cond_expr = *gnu_cond_expr_p;\n+  tree gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n \n-  tree gnu_loop_label = LOOP_STMT_LABEL (gnu_loop_stmt);\n+  /* Set the condition under which the loop must keep going.  If we have an\n+     explicit condition, use it to set the location information throughout\n+     the translation of the loop statement to avoid having multiple SLOCs.\n \n-  /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n   if (No (gnat_iter_scheme))\n     ;\n \n   /* For the case \"WHILE condition LOOP ..... END LOOP;\" it's immediate.  */\n   else if (Present (Condition (gnat_iter_scheme)))\n-    LOOP_STMT_COND (gnu_loop_stmt)\n-      = gnat_to_gnu (Condition (gnat_iter_scheme));\n+    {\n+      LOOP_STMT_COND (gnu_loop_stmt)\n+\t= gnat_to_gnu (Condition (gnat_iter_scheme));\n+\n+      set_expr_location_from_node (gnu_loop_stmt, gnat_iter_scheme);\n+    }\n \n   /* Otherwise we have an iteration scheme and the condition is given by the\n      bounds of the subtype of the iteration variable.  */\n@@ -3673,7 +3677,7 @@ Regular_Loop_to_gnu (Node_Id gnat_node, tree *gnu_cond_expr_p)\n \t\t\t  build_binary_op (LE_EXPR, boolean_type_node,\n \t\t\t\t\t   gnu_low, gnu_high),\n \t\t\t  NULL_TREE, alloc_stmt_list ());\n-\t      set_expr_location_from_node (gnu_cond_expr, gnat_loop_spec);\n+\t      set_expr_location_from_node (gnu_cond_expr, gnat_iter_scheme);\n \t    }\n \t}\n \n@@ -3748,6 +3752,8 @@ Regular_Loop_to_gnu (Node_Id gnat_node, tree *gnu_cond_expr_p)\n \t  set_expr_location_from_node (gnu_stmt, gnat_iter_scheme);\n \t  LOOP_STMT_UPDATE (gnu_loop_stmt) = gnu_stmt;\n \t}\n+\n+      set_expr_location_from_node (gnu_loop_stmt, gnat_iter_scheme);\n     }\n \n   /* If the loop was named, have the name point to this loop.  In this case,"}]}