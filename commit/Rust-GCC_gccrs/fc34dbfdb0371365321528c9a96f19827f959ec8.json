{"sha": "fc34dbfdb0371365321528c9a96f19827f959ec8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMzNGRiZmRiMDM3MTM2NTMyMTUyOGM5YTk2ZjE5ODI3Zjk1OWVjOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-01T23:57:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-01T23:57:08Z"}, "message": "runtime: add hurd netpoll and semaphore support\n    \n    Patch by Svante Signell.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/160827\n\nFrom-SVN: r268465", "tree": {"sha": "eaab31f2d2a96db1a04ec55eb9f3688bcbfdd18b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaab31f2d2a96db1a04ec55eb9f3688bcbfdd18b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc34dbfdb0371365321528c9a96f19827f959ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc34dbfdb0371365321528c9a96f19827f959ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc34dbfdb0371365321528c9a96f19827f959ec8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc34dbfdb0371365321528c9a96f19827f959ec8/comments", "author": null, "committer": null, "parents": [{"sha": "73353297f3c7886c4c7811e02df792bc8c5af14f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73353297f3c7886c4c7811e02df792bc8c5af14f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73353297f3c7886c4c7811e02df792bc8c5af14f"}], "stats": {"total": 335, "additions": 331, "deletions": 4}, "files": [{"sha": "3b43b63b5d2a822d56b3dae5bd7ebd5ac94f85e0", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc34dbfdb0371365321528c9a96f19827f959ec8/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc34dbfdb0371365321528c9a96f19827f959ec8/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=fc34dbfdb0371365321528c9a96f19827f959ec8", "patch": "@@ -1,4 +1,4 @@\n-582392b80c07bd7e830e177b775dc4ef802b5fd6\n+047b0aa6a29d46fde99b3e5823339ac8866f797c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "6d391146a44ed88149a6af4041c19445d3baa55d", "filename": "libgo/go/runtime/netpoll.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc34dbfdb0371365321528c9a96f19827f959ec8/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc34dbfdb0371365321528c9a96f19827f959ec8/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll.go?ref=fc34dbfdb0371365321528c9a96f19827f959ec8", "patch": "@@ -102,7 +102,7 @@ func netpollinited() bool {\n // descriptor being used by netpoll.\n func poll_runtime_isPollServerDescriptor(fd uintptr) bool {\n \tfds := netpolldescriptor()\n-\tif GOOS != \"aix\" {\n+\tif GOOS != \"aix\" && GOOS != \"hurd\" {\n \t\treturn fd == fds\n \t} else {\n \t\t// AIX have a pipe in its netpoll implementation.\n@@ -178,8 +178,8 @@ func poll_runtime_pollWait(pd *pollDesc, mode int) int {\n \tif err != 0 {\n \t\treturn err\n \t}\n-\t// As for now only Solaris and AIX use level-triggered IO.\n-\tif GOOS == \"solaris\" || GOOS == \"aix\" {\n+\t// As for now only Solaris, AIX and Hurd use level-triggered IO.\n+\tif GOOS == \"solaris\" || GOOS == \"aix\" || GOOS == \"hurd\" {\n \t\tnetpollarm(pd, mode)\n \t}\n \tfor !netpollblock(pd, int32(mode), false) {"}, {"sha": "b74ad2fe1287fc1893abe446d11d254c652197e7", "filename": "libgo/go/runtime/netpoll_hurd.go", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc34dbfdb0371365321528c9a96f19827f959ec8/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc34dbfdb0371365321528c9a96f19827f959ec8/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go?ref=fc34dbfdb0371365321528c9a96f19827f959ec8", "patch": "@@ -0,0 +1,240 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+// FIXME: Improve network poller for hurd.\n+// This is based on the former libgo/runtime/netpoll_select.c implementation\n+// except that it uses poll instead of select and is written in Go.\n+// It's also based on Solaris implementation for the arming mechanisms\n+// Inspiration was also taken from netpoll_aix.go and netpoll_solaris.go\n+\n+//From /usr/include/x86_64-linux-gnu/sys/poll.h\n+//go:noescape\n+//extern poll\n+func libc_poll(pfds *pollfd, nfds int32, timeout int32) int32\n+\n+//go:noescape\n+//extern pipe2\n+func libc_pipe2(fd *int32, flags int32) int32\n+\n+//pollfd represents the poll structure for GNU/Hurd operating system.\n+type pollfd struct {\n+\tfd      int32 // File descriptor to poll.\n+\tevents  int16 // Types of events poller cares about.\n+\trevents int16 // Types of events that actually occurred.\n+}\n+\n+//From /usr/include/i386-gnu/bits/poll.h\n+const _POLLIN = 01    // There is data to read.\n+const _POLLPRI = 02   // There is urgent data to read.\n+const _POLLOUT = 04   // Writing now will not block.\n+const _POLLERR = 010  // Error condition.\n+const _POLLHUP = 020  // Hung up.\n+const _POLLNVAL = 040 // Invalid polling request.\n+\n+var (\n+\tpfds           []pollfd\n+\tpds            []*pollDesc\n+\tmtxpoll        mutex\n+\tmtxset         mutex\n+\trdwake         int32\n+\twrwake         int32\n+\tpendingUpdates int32\n+)\n+\n+const pollVerbose = false\n+\n+func netpollinit() {\n+\tvar p [2]int32\n+\n+\t// Create the pipe we use to wakeup poll.\n+\tif err := libc_pipe2(&p[0], _O_CLOEXEC|_O_NONBLOCK); err < 0 {\n+\t\tthrow(\"runtime:netpollinit(): failed to create pipe2\")\n+\t}\n+\trdwake = p[0]\n+\twrwake = p[1]\n+\n+\t// Pre-allocate array of pollfd structures for poll.\n+\tif pollVerbose {\n+\t\tprintln(\"*** allocating\")\n+\t}\n+\tpfds = make([]pollfd, 1, 128)\n+\tif pollVerbose {\n+\t\tprintln(\"*** allocating done\", &pfds[0])\n+\t}\n+\n+\t// Poll the read side of the pipe.\n+\tpfds[0].fd = int32(rdwake)\n+\tpfds[0].events = int16(_POLLIN)\n+\tpfds[0].revents = int16(0)\n+\n+\tpds = make([]*pollDesc, 1, 128)\n+\t// Checks for pd != nil are made in netpoll.\n+\tpds[0] = nil\n+}\n+\n+func netpolldescriptor() uintptr {\n+\t// Both fds must be returned.\n+\tif rdwake > 0xFFFF || wrwake > 0xFFFF {\n+\t\tthrow(\"netpolldescriptor: invalid fd number\")\n+\t}\n+\treturn uintptr(rdwake<<16 | wrwake)\n+}\n+\n+// netpollwakeup writes on wrwake to wakeup poll before any changes.\n+func netpollwakeup() {\n+\tif pendingUpdates == 0 {\n+\t\tpendingUpdates = 1\n+\t\tif pollVerbose {\n+\t\t\tprintln(\"*** writing 1 byte\")\n+\t\t}\n+\t\tb := [1]byte{0}\n+\t\twrite(uintptr(wrwake), unsafe.Pointer(&b[0]), 1)\n+\t}\n+}\n+\n+func netpollopen(fd uintptr, pd *pollDesc) int32 {\n+\tif pollVerbose {\n+\t\tprintln(\"*** netpollopen\", fd)\n+\t}\n+\tlock(&mtxpoll)\n+\tnetpollwakeup()\n+\n+\tlock(&mtxset)\n+\tunlock(&mtxpoll)\n+\n+\tpd.user = uint32(len(pfds))\n+\tpfds = append(pfds, pollfd{fd: int32(fd)})\n+\tpds = append(pds, pd)\n+\tunlock(&mtxset)\n+\treturn 0\n+}\n+\n+func netpollclose(fd uintptr) int32 {\n+\tif pollVerbose {\n+\t\tprintln(\"*** netpollclose\", fd)\n+\t}\n+\tlock(&mtxpoll)\n+\tnetpollwakeup()\n+\n+\tlock(&mtxset)\n+\tunlock(&mtxpoll)\n+\n+\tfor i := 0; i < len(pfds); i++ {\n+\t\tif pfds[i].fd == int32(fd) {\n+\t\t\tpfds[i] = pfds[len(pfds)-1]\n+\t\t\tpfds = pfds[:len(pfds)-1]\n+\n+\t\t\tpds[i] = pds[len(pds)-1]\n+\t\t\tpds[i].user = uint32(i)\n+\t\t\tpds = pds[:len(pds)-1]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tunlock(&mtxset)\n+\treturn 0\n+}\n+\n+func netpollarm(pd *pollDesc, mode int) {\n+\tif pollVerbose {\n+\t\tprintln(\"*** netpollarm\", pd.fd, mode)\n+\t}\n+\tlock(&mtxpoll)\n+\tnetpollwakeup()\n+\n+\tlock(&mtxset)\n+\tunlock(&mtxpoll)\n+\n+\tswitch mode {\n+\tcase 'r':\n+\t\tpfds[pd.user].events |= _POLLIN\n+\tcase 'w':\n+\t\tpfds[pd.user].events |= _POLLOUT\n+\t}\n+\tunlock(&mtxset)\n+}\n+\n+// polls for ready network connections\n+// returns list of goroutines that become runnable\n+//go:nowritebarrierrec\n+func netpoll(block bool) gList {\n+\ttimeout := int32(0)\n+\tif !block {\n+\t\ttimeout = 0\n+\t\treturn gList{}\n+\t}\n+\tif pollVerbose {\n+\t\tprintln(\"*** netpoll\", block)\n+\t}\n+retry:\n+\tlock(&mtxpoll)\n+\tlock(&mtxset)\n+\tpendingUpdates = 0\n+\tunlock(&mtxpoll)\n+\n+\tif pollVerbose {\n+\t\tprintln(\"*** netpoll before poll\")\n+\t}\n+\tn := libc_poll(&pfds[0], int32(len(pfds)), timeout)\n+\tif pollVerbose {\n+\t\tprintln(\"*** netpoll after poll\", n)\n+\t}\n+\tif n < 0 {\n+\t\te := errno()\n+\t\tif e != _EINTR {\n+\t\t\tprintln(\"errno=\", e, \" len(pfds)=\", len(pfds))\n+\t\t\tthrow(\"poll failed\")\n+\t\t}\n+\t\tif pollVerbose {\n+\t\t\tprintln(\"*** poll failed\")\n+\t\t}\n+\t\tunlock(&mtxset)\n+\t\tgoto retry\n+\t}\n+\t// Check if some descriptors need to be changed\n+\tif n != 0 && pfds[0].revents&(_POLLIN|_POLLHUP|_POLLERR) != 0 {\n+\t\tvar b [1]byte\n+\t\tfor read(rdwake, unsafe.Pointer(&b[0]), 1) == 1 {\n+\t\t\tif pollVerbose {\n+\t\t\t\tprintln(\"*** read 1 byte from pipe\")\n+\t\t\t}\n+\t\t}\n+\t\t// Do not look at the other fds in this case as the mode may have changed\n+\t\t// XXX only additions of flags are made, so maybe it is ok\n+\t\tunlock(&mtxset)\n+\t\tgoto retry\n+\t}\n+\tvar toRun gList\n+\tfor i := 0; i < len(pfds) && n > 0; i++ {\n+\t\tpfd := &pfds[i]\n+\n+\t\tvar mode int32\n+\t\tif pfd.revents&(_POLLIN|_POLLHUP|_POLLERR) != 0 {\n+\t\t\tmode += 'r'\n+\t\t\tpfd.events &= ^_POLLIN\n+\t\t}\n+\t\tif pfd.revents&(_POLLOUT|_POLLHUP|_POLLERR) != 0 {\n+\t\t\tmode += 'w'\n+\t\t\tpfd.events &= ^_POLLOUT\n+\t\t}\n+\t\tif mode != 0 {\n+\t\t\tif pollVerbose {\n+\t\t\t\tprintln(\"*** netpollready i=\", i, \"revents=\", pfd.revents, \"events=\", pfd.events, \"pd=\", pds[i])\n+\t\t\t}\n+\t\t\tnetpollready(&toRun, pds[i], mode)\n+\t\t\tn--\n+\t\t}\n+\t}\n+\tunlock(&mtxset)\n+\tif block && toRun.empty() {\n+\t\tgoto retry\n+\t}\n+\tif pollVerbose {\n+\t\tprintln(\"*** netpoll returning end\")\n+\t}\n+\treturn toRun\n+}"}, {"sha": "12825532a26a2ec72e183af3a2fd35edea3fec56", "filename": "libgo/go/runtime/os_hurd.go", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc34dbfdb0371365321528c9a96f19827f959ec8/libgo%2Fgo%2Fruntime%2Fos_hurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc34dbfdb0371365321528c9a96f19827f959ec8/libgo%2Fgo%2Fruntime%2Fos_hurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_hurd.go?ref=fc34dbfdb0371365321528c9a96f19827f959ec8", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file is derived from os_solaris.go.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+type mOS struct {\n+\twaitsema uintptr // semaphore for parking on locks\n+}\n+\n+//extern malloc\n+func libc_malloc(uintptr) unsafe.Pointer\n+\n+//go:noescape\n+//extern sem_init\n+func sem_init(sem *_sem_t, pshared int32, value uint32) int32\n+\n+//go:noescape\n+//extern sem_wait\n+func sem_wait(sem *_sem_t) int32\n+\n+//go:noescape\n+//extern sem_post\n+func sem_post(sem *_sem_t) int32\n+\n+//go:noescape\n+//extern sem_timedwait\n+func sem_timedwait(sem *_sem_t, timeout *timespec) int32\n+\n+//go:nosplit\n+func semacreate(mp *m) {\n+\tif mp.mos.waitsema != 0 {\n+\t\treturn\n+\t}\n+\n+\tvar sem *_sem_t\n+\n+\t// Call libc's malloc rather than malloc. This will\n+\t// allocate space on the C heap. We can't call malloc\n+\t// here because it could cause a deadlock.\n+\tsem = (*_sem_t)(libc_malloc(unsafe.Sizeof(*sem)))\n+\tif sem_init(sem, 0, 0) != 0 {\n+\t\tthrow(\"sem_init\")\n+\t}\n+\tmp.mos.waitsema = uintptr(unsafe.Pointer(sem))\n+}\n+\n+//go:nosplit\n+func semasleep(ns int64) int32 {\n+\t_m_ := getg().m\n+\tif ns >= 0 {\n+\t\tvar ts timespec\n+\t\tts.set_sec(ns / 1000000000)\n+\t\tts.set_nsec(int32(ns % 1000000000))\n+\n+\t\tif sem_timedwait((*_sem_t)(unsafe.Pointer(_m_.mos.waitsema)), &ts) != 0 {\n+\t\t\terr := errno()\n+\t\t\tif err == _ETIMEDOUT || err == _EAGAIN || err == _EINTR {\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\tthrow(\"sem_timedwait\")\n+\t\t}\n+\t\treturn 0\n+\t}\n+\tfor {\n+\t\tr1 := sem_wait((*_sem_t)(unsafe.Pointer(_m_.mos.waitsema)))\n+\t\tif r1 == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif errno() == _EINTR {\n+\t\t\tcontinue\n+\t\t}\n+\t\tthrow(\"sem_wait\")\n+\t}\n+\treturn 0\n+}\n+\n+//go:nosplit\n+func semawakeup(mp *m) {\n+\tif sem_post((*_sem_t)(unsafe.Pointer(mp.mos.waitsema))) != 0 {\n+\t\tthrow(\"sem_post\")\n+\t}\n+}"}]}