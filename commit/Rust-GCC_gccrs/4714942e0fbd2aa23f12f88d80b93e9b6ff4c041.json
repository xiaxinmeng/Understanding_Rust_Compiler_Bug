{"sha": "4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcxNDk0MmUwZmJkMmFhMjNmMTJmODhkODBiOTNlOWI2ZmY0YzA0MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-12-18T11:22:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-12-18T11:22:00Z"}, "message": "re PR target/88513 (FAIL: gcc.target/i386/pr59591-1.c)\n\n\tPR target/88513\n\tPR target/88514\n\t* optabs.def (vec_pack_sbool_trunc_optab, vec_unpacks_sbool_hi_optab,\n\tvec_unpacks_sbool_lo_optab): New optabs.\n\t* optabs.c (expand_widen_pattern_expr): Use vec_unpacks_sbool_*_optab\n\tand pass additional argument if both input and target have the same\n\tscalar mode of VECTOR_BOOLEAN_TYPE_P vectors.\n\t* expr.c (expand_expr_real_2) <case VEC_PACK_TRUNC_EXPR>: Handle\n\tVECTOR_BOOLEAN_TYPE_P pack where result has the same scalar mode\n\tas the operands using vec_pack_sbool_trunc_optab.\n\t* tree-vect-stmts.c (supportable_widening_operation): Use\n\tvec_unpacks_sbool_{lo,hi}_optab for VECTOR_BOOLEAN_TYPE_P conversions\n\twhere both wider_vectype and vectype have the same scalar mode.\n\t(supportable_narrowing_operation): Similarly use\n\tvec_pack_sbool_trunc_optab if narrow_vectype and vectype have the same\n\tscalar mode.\n\t* config/i386/i386.c (ix86_get_builtin)\n\t<case IX86_BUILTIN_GATHER3ALTDIV8SF>: Check for VECTOR_MODE_P\n\trather than non-VOIDmode.\n\t* config/i386/sse.md (vec_pack_trunc_qi, vec_pack_trunc_<mode>):\n\tRemove useless ()s around \"register_operand\", formatting fixes.\n\t(vec_pack_sbool_trunc_qi, vec_unpacks_sbool_lo_qi,\n\tvec_unpacks_sbool_hi_qi): New expanders.\n\t* doc/md.texi (vec_pack_sbool_trunc_M, vec_unpacks_sbool_hi_M,\n\tvec_unpacks_sbool_lo_M): Document.\n\n\t* gcc.target/i386/avx512f-pr88513-1.c: New test.\n\t* gcc.target/i386/avx512f-pr88513-2.c: New test.\n\t* gcc.target/i386/avx512vl-pr88464-1.c: New test.\n\t* gcc.target/i386/avx512vl-pr88464-2.c: New test.\n\t* gcc.target/i386/avx512vl-pr88464-3.c: New test.\n\t* gcc.target/i386/avx512vl-pr88464-4.c: New test.\n\t* gcc.target/i386/avx512vl-pr88513-1.c: New test.\n\t* gcc.target/i386/avx512vl-pr88513-2.c: New test.\n\t* gcc.target/i386/avx512vl-pr88513-3.c: New test.\n\t* gcc.target/i386/avx512vl-pr88513-4.c: New test.\n\t* gcc.target/i386/avx512vl-pr88514-1.c: New test.\n\t* gcc.target/i386/avx512vl-pr88514-2.c: New test.\n\t* gcc.target/i386/avx512vl-pr88514-3.c: New test.\n\nFrom-SVN: r267228", "tree": {"sha": "fe6f44463c394d04881a2c89fce4d2052ab22c43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe6f44463c394d04881a2c89fce4d2052ab22c43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a30d8c0a687baae0cea91ca6b3adbed32e84471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a30d8c0a687baae0cea91ca6b3adbed32e84471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a30d8c0a687baae0cea91ca6b3adbed32e84471"}], "stats": {"total": 504, "additions": 469, "deletions": 35}, "files": [{"sha": "6f7c79d31a11e33cdf1f525991b60cdb4c7a115f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -1,3 +1,31 @@\n+2018-12-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/88513\n+\tPR target/88514\n+\t* optabs.def (vec_pack_sbool_trunc_optab, vec_unpacks_sbool_hi_optab,\n+\tvec_unpacks_sbool_lo_optab): New optabs.\n+\t* optabs.c (expand_widen_pattern_expr): Use vec_unpacks_sbool_*_optab\n+\tand pass additional argument if both input and target have the same\n+\tscalar mode of VECTOR_BOOLEAN_TYPE_P vectors.\n+\t* expr.c (expand_expr_real_2) <case VEC_PACK_TRUNC_EXPR>: Handle\n+\tVECTOR_BOOLEAN_TYPE_P pack where result has the same scalar mode\n+\tas the operands using vec_pack_sbool_trunc_optab.\n+\t* tree-vect-stmts.c (supportable_widening_operation): Use\n+\tvec_unpacks_sbool_{lo,hi}_optab for VECTOR_BOOLEAN_TYPE_P conversions\n+\twhere both wider_vectype and vectype have the same scalar mode.\n+\t(supportable_narrowing_operation): Similarly use\n+\tvec_pack_sbool_trunc_optab if narrow_vectype and vectype have the same\n+\tscalar mode.\n+\t* config/i386/i386.c (ix86_get_builtin)\n+\t<case IX86_BUILTIN_GATHER3ALTDIV8SF>: Check for VECTOR_MODE_P\n+\trather than non-VOIDmode.\n+\t* config/i386/sse.md (vec_pack_trunc_qi, vec_pack_trunc_<mode>):\n+\tRemove useless ()s around \"register_operand\", formatting fixes.\n+\t(vec_pack_sbool_trunc_qi, vec_unpacks_sbool_lo_qi,\n+\tvec_unpacks_sbool_hi_qi): New expanders.\n+\t* doc/md.texi (vec_pack_sbool_trunc_M, vec_unpacks_sbool_hi_M,\n+\tvec_unpacks_sbool_lo_M): Document.\n+\n 2018-12-18  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* combine.c (update_rsp_from_reg_equal): Only look for the nonzero bits"}, {"sha": "1c36e12c79c801ad8d64bc17ab5e17865ea89a53", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -37625,7 +37625,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t    op0 = copy_to_mode_reg (GET_MODE (op0), op0);\n \t  emit_insn (gen (half, op0));\n \t  op0 = half;\n-\t  if (GET_MODE (op3) != VOIDmode)\n+\t  if (VECTOR_MODE_P (GET_MODE (op3)))\n \t    {\n \t      half = gen_reg_rtx (mode0);\n \t      if (!nonimmediate_operand (op3, GET_MODE (op3)))"}, {"sha": "3786afdf5e8087ad260aeb25a0e88c5323e64838", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 79, "deletions": 7, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -12435,22 +12435,59 @@\n })\n \n (define_expand \"vec_pack_trunc_qi\"\n-  [(set (match_operand:HI 0 (\"register_operand\"))\n-        (ior:HI (ashift:HI (zero_extend:HI (match_operand:QI 2 (\"register_operand\")))\n+  [(set (match_operand:HI 0 \"register_operand\")\n+\t(ior:HI (ashift:HI (zero_extend:HI (match_operand:QI 2 \"register_operand\"))\n                            (const_int 8))\n-                (zero_extend:HI (match_operand:QI 1 (\"register_operand\")))))]\n+\t\t(zero_extend:HI (match_operand:QI 1 \"register_operand\"))))]\n   \"TARGET_AVX512F\")\n \n (define_expand \"vec_pack_trunc_<mode>\"\n-  [(set (match_operand:<DOUBLEMASKMODE> 0 (\"register_operand\"))\n-        (ior:<DOUBLEMASKMODE> (ashift:<DOUBLEMASKMODE> (zero_extend:<DOUBLEMASKMODE> (match_operand:SWI24 2 (\"register_operand\")))\n-                           (match_dup 3))\n-                (zero_extend:<DOUBLEMASKMODE> (match_operand:SWI24 1 (\"register_operand\")))))]\n+  [(set (match_operand:<DOUBLEMASKMODE> 0 \"register_operand\")\n+\t(ior:<DOUBLEMASKMODE>\n+\t  (ashift:<DOUBLEMASKMODE>\n+\t    (zero_extend:<DOUBLEMASKMODE>\n+\t      (match_operand:SWI24 2 \"register_operand\"))\n+\t    (match_dup 3))\n+\t  (zero_extend:<DOUBLEMASKMODE>\n+\t    (match_operand:SWI24 1 \"register_operand\"))))]\n   \"TARGET_AVX512BW\"\n {\n   operands[3] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode));\n })\n \n+(define_expand \"vec_pack_sbool_trunc_qi\"\n+  [(match_operand:QI 0 \"register_operand\")\n+   (match_operand:QI 1 \"register_operand\")\n+   (match_operand:QI 2 \"register_operand\")\n+   (match_operand:QI 3 \"const_int_operand\")]\n+  \"TARGET_AVX512F\"\n+{\n+  HOST_WIDE_INT nunits = INTVAL (operands[3]);\n+  rtx mask, tem1, tem2;\n+  if (nunits != 8 && nunits != 4)\n+    FAIL;\n+  mask = gen_reg_rtx (QImode);\n+  emit_move_insn (mask, GEN_INT ((1 << (nunits / 2)) - 1));\n+  tem1 = gen_reg_rtx (QImode);\n+  emit_insn (gen_kandqi (tem1, operands[1], mask));\n+  if (TARGET_AVX512DQ)\n+    {\n+      tem2 = gen_reg_rtx (QImode);\n+      emit_insn (gen_kashiftqi (tem2, operands[2],\n+\t\t\t\tGEN_INT (nunits / 2)));\n+    }\n+  else\n+    {\n+      tem2 = gen_reg_rtx (HImode);\n+      emit_insn (gen_kashifthi (tem2, lowpart_subreg (HImode, operands[2],\n+\t\t\t\t\t\t      QImode),\n+\t\t\t\tGEN_INT (nunits / 2)));\n+      tem2 = lowpart_subreg (QImode, tem2, HImode);\n+    }\n+  emit_insn (gen_kiorqi (operands[0], tem1, tem2));\n+  DONE;\n+})\n+\n (define_insn \"<sse2_avx2>_packsswb<mask_name>\"\n   [(set (match_operand:VI1_AVX512 0 \"register_operand\" \"=x,x,v\")\n \t(vec_concat:VI1_AVX512\n@@ -14603,6 +14640,18 @@\n   \"TARGET_SSE2\"\n   \"ix86_expand_sse_unpack (operands[0], operands[1], true, false); DONE;\")\n \n+(define_expand \"vec_unpacks_sbool_lo_qi\"\n+  [(match_operand:QI 0 \"register_operand\")\n+   (match_operand:QI 1 \"register_operand\")\n+   (match_operand:QI 2 \"const_int_operand\")]\n+  \"TARGET_AVX512F\"\n+{\n+  if (INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 4)\n+    FAIL;\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n (define_expand \"vec_unpacks_lo_hi\"\n   [(set (subreg:HI (match_operand:QI 0 \"register_operand\") 0)\n         (match_operand:HI 1 \"register_operand\"))]\n@@ -14624,6 +14673,29 @@\n   \"TARGET_SSE2\"\n   \"ix86_expand_sse_unpack (operands[0], operands[1], true, true); DONE;\")\n \n+(define_expand \"vec_unpacks_sbool_hi_qi\"\n+  [(match_operand:QI 0 \"register_operand\")\n+   (match_operand:QI 1 \"register_operand\")\n+   (match_operand:QI 2 \"const_int_operand\")]\n+  \"TARGET_AVX512F\"\n+{\n+  HOST_WIDE_INT nunits = INTVAL (operands[2]);\n+  if (nunits != 8 && nunits != 4)\n+    FAIL;\n+  if (TARGET_AVX512DQ)\n+    emit_insn (gen_klshiftrtqi (operands[0], operands[1],\n+\t\t\t\tGEN_INT (nunits / 2)));\n+  else\n+    {\n+      rtx tem = gen_reg_rtx (HImode);\n+      emit_insn (gen_klshiftrthi (tem, lowpart_subreg (HImode, operands[1],\n+\t\t\t\t\t\t       QImode),\n+\t\t\t\t  GEN_INT (nunits / 2)));\n+      emit_move_insn (operands[0], lowpart_subreg (QImode, tem, HImode));\n+    }\n+  DONE;\n+})\n+\n (define_expand \"vec_unpacks_hi_hi\"\n   [(parallel\n      [(set (subreg:HI (match_operand:QI 0 \"register_operand\") 0)"}, {"sha": "197b6ba339f6f1f87c2883d58a36dc4df56f5b6e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -5428,6 +5428,16 @@ are vectors of the same mode having N integral or floating point elements\n of size S@.  Operand 0 is the resulting vector in which 2*N elements of\n size N/2 are concatenated after narrowing them down using truncation.\n \n+@cindex @code{vec_pack_sbool_trunc_@var{m}} instruction pattern\n+@item @samp{vec_pack_sbool_trunc_@var{m}}\n+Narrow and merge the elements of two vectors.  Operands 1 and 2 are vectors\n+of the same type having N boolean elements.  Operand 0 is the resulting\n+vector in which 2*N elements are concatenated.  The last operand (operand 3)\n+is the number of elements in the output vector 2*N as a @code{CONST_INT}.\n+This instruction pattern is used when all the vector input and output\n+operands have the same scalar mode @var{m} and thus using\n+@code{vec_pack_trunc_@var{m}} would be ambiguous.\n+\n @cindex @code{vec_pack_ssat_@var{m}} instruction pattern\n @cindex @code{vec_pack_usat_@var{m}} instruction pattern\n @item @samp{vec_pack_ssat_@var{m}}, @samp{vec_pack_usat_@var{m}}\n@@ -5470,6 +5480,17 @@ integral elements.  The input vector (operand 1) has N elements of size S.\n Widen (promote) the high/low elements of the vector using zero extension and\n place the resulting N/2 values of size 2*S in the output vector (operand 0).\n \n+@cindex @code{vec_unpacks_sbool_hi_@var{m}} instruction pattern\n+@cindex @code{vec_unpacks_sbool_lo_@var{m}} instruction pattern\n+@item @samp{vec_unpacks_sbool_hi_@var{m}}, @samp{vec_unpacks_sbool_lo_@var{m}}\n+Extract the high/low part of a vector of boolean elements that have scalar\n+mode @var{m}.  The input vector (operand 1) has N elements, the output\n+vector (operand 0) has N/2 elements.  The last operand (operand 2) is the\n+number of elements of the input vector N as a @code{CONST_INT}.  These\n+patterns are used if both the input and output vectors have the same scalar\n+mode @var{m} and thus using @code{vec_unpacks_hi_@var{m}} or\n+@code{vec_unpacks_lo_@var{m}} would be ambiguous.\n+\n @cindex @code{vec_unpacks_float_hi_@var{m}} instruction pattern\n @cindex @code{vec_unpacks_float_lo_@var{m}} instruction pattern\n @cindex @code{vec_unpacku_float_hi_@var{m}} instruction pattern"}, {"sha": "fe3647f0ac77e1a6bb2bb88ba368c00b21b3a135", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -9493,12 +9493,34 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       gcc_assert (target);\n       return target;\n \n-    case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (treeop0));\n       goto binop;\n \n+    case VEC_PACK_TRUNC_EXPR:\n+      if (VECTOR_BOOLEAN_TYPE_P (type)\n+\t  && VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (treeop0))\n+\t  && mode == TYPE_MODE (TREE_TYPE (treeop0))\n+\t  && SCALAR_INT_MODE_P (mode))\n+\t{\n+\t  struct expand_operand eops[4];\n+\t  machine_mode imode = TYPE_MODE (TREE_TYPE (treeop0));\n+\t  expand_operands (treeop0, treeop1,\n+\t\t\t   subtarget, &op0, &op1, EXPAND_NORMAL);\n+\t  this_optab = vec_pack_sbool_trunc_optab;\n+\t  enum insn_code icode = optab_handler (this_optab, imode);\n+\t  create_output_operand (&eops[0], target, mode);\n+\t  create_convert_operand_from (&eops[1], op0, imode, false);\n+\t  create_convert_operand_from (&eops[2], op1, imode, false);\n+\t  temp = GEN_INT (TYPE_VECTOR_SUBPARTS (type).to_constant ());\n+\t  create_input_operand (&eops[3], temp, imode);\n+\t  expand_insn (icode, 4, eops);\n+\t  return eops[0].value;\n+\t}\n+      mode = TYPE_MODE (TREE_TYPE (treeop0));\n+      goto binop;\n+\n     case VEC_PACK_FLOAT_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (treeop0));\n       expand_operands (treeop0, treeop1,"}, {"sha": "68270bdea98c227a8c95cf56cc0043f5af1caeec", "filename": "gcc/optabs.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -256,6 +256,7 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n   enum insn_code icode;\n   int nops = TREE_CODE_LENGTH (ops->code);\n   int op;\n+  bool sbool = false;\n \n   oprnd0 = ops->op0;\n   tmode0 = TYPE_MODE (TREE_TYPE (oprnd0));\n@@ -265,6 +266,22 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n        for these ops.  */\n     widen_pattern_optab\n       = optab_for_tree_code (ops->code, ops->type, optab_default);\n+  else if ((ops->code == VEC_UNPACK_HI_EXPR\n+\t    || ops->code == VEC_UNPACK_LO_EXPR)\n+\t   && VECTOR_BOOLEAN_TYPE_P (ops->type)\n+\t   && VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (oprnd0))\n+\t   && TYPE_MODE (ops->type) == TYPE_MODE (TREE_TYPE (oprnd0))\n+\t   && SCALAR_INT_MODE_P (TYPE_MODE (ops->type)))\n+    {\n+      /* For VEC_UNPACK_{LO,HI}_EXPR if the mode of op0 and result is\n+\t the same scalar mode for VECTOR_BOOLEAN_TYPE_P vectors, use\n+\t vec_unpacks_sbool_{lo,hi}_optab, so that we can pass in\n+\t the pattern number of elements in the wider vector.  */\n+      widen_pattern_optab\n+\t= (ops->code == VEC_UNPACK_HI_EXPR\n+\t   ? vec_unpacks_sbool_hi_optab : vec_unpacks_sbool_lo_optab);\n+      sbool = true;\n+    }\n   else\n     widen_pattern_optab\n       = optab_for_tree_code (ops->code, TREE_TYPE (oprnd0), optab_default);\n@@ -282,6 +299,12 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n       oprnd1 = ops->op1;\n       tmode1 = TYPE_MODE (TREE_TYPE (oprnd1));\n     }\n+  else if (sbool)\n+    {\n+      nops = 2;\n+      op1 = GEN_INT (TYPE_VECTOR_SUBPARTS (TREE_TYPE (oprnd0)).to_constant ());\n+      tmode1 = tmode0;\n+    }\n \n   /* The last operand is of a wider mode than the rest of the operands.  */\n   if (nops == 2)"}, {"sha": "3ede65bdaf4abc49053e41f24202d679322239b3", "filename": "gcc/optabs.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -338,6 +338,7 @@ OPTAB_D (vec_pack_sfix_trunc_optab, \"vec_pack_sfix_trunc_$a\")\n OPTAB_D (vec_pack_ssat_optab, \"vec_pack_ssat_$a\")\n OPTAB_D (vec_pack_trunc_optab, \"vec_pack_trunc_$a\")\n OPTAB_D (vec_pack_ufix_trunc_optab, \"vec_pack_ufix_trunc_$a\")\n+OPTAB_D (vec_pack_sbool_trunc_optab, \"vec_pack_sbool_trunc_$a\")\n OPTAB_D (vec_pack_usat_optab, \"vec_pack_usat_$a\")\n OPTAB_D (vec_packs_float_optab, \"vec_packs_float_$a\")\n OPTAB_D (vec_packu_float_optab, \"vec_packu_float_$a\")\n@@ -353,6 +354,8 @@ OPTAB_D (vec_unpacks_float_hi_optab, \"vec_unpacks_float_hi_$a\")\n OPTAB_D (vec_unpacks_float_lo_optab, \"vec_unpacks_float_lo_$a\")\n OPTAB_D (vec_unpacks_hi_optab, \"vec_unpacks_hi_$a\")\n OPTAB_D (vec_unpacks_lo_optab, \"vec_unpacks_lo_$a\")\n+OPTAB_D (vec_unpacks_sbool_hi_optab, \"vec_unpacks_sbool_hi_$a\")\n+OPTAB_D (vec_unpacks_sbool_lo_optab, \"vec_unpacks_sbool_lo_$a\")\n OPTAB_D (vec_unpacku_float_hi_optab, \"vec_unpacku_float_hi_$a\")\n OPTAB_D (vec_unpacku_float_lo_optab, \"vec_unpacku_float_lo_$a\")\n OPTAB_D (vec_unpacku_hi_optab, \"vec_unpacku_hi_$a\")"}, {"sha": "1ed54f4566d50d96610360bbf95e469989e50bb6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -1,3 +1,21 @@\n+2018-12-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/88513\n+\tPR target/88514\n+\t* gcc.target/i386/avx512f-pr88513-1.c: New test.\n+\t* gcc.target/i386/avx512f-pr88513-2.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88464-1.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88464-2.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88464-3.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88464-4.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88513-1.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88513-2.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88513-3.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88513-4.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88514-1.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88514-2.c: New test.\n+\t* gcc.target/i386/avx512vl-pr88514-3.c: New test.\n+\n 2018-12-18  Wei Xiao  <wei3.xiao@intel.com>\n \n \t* g++.target/i386/mv16.C: Handle new march."}, {"sha": "12bf70985dd86db352f2412408d34cfa51679463", "filename": "gcc/testsuite/gcc.target/i386/avx512f-pr88513-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88513-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88513-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88513-1.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,16 @@\n+/* PR target/88513 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512f -mtune=intel -mprefer-vector-width=512 -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+#define CHECK_H \"avx512f-check.h\"\n+\n+#include \"../../gcc.dg/vect/pr59591-1.c\"\n+\n+#include CHECK_H\n+\n+static void\n+test_512 (void)\n+{\n+  bar ();\n+}"}, {"sha": "9f4c2792a42b53b04cdcf4e106dd1ac3f3da782f", "filename": "gcc/testsuite/gcc.target/i386/avx512f-pr88513-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88513-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88513-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr88513-2.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,16 @@\n+/* PR target/88513 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512f -mtune=intel -mprefer-vector-width=512 -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+#define CHECK_H \"avx512f-check.h\"\n+\n+#include \"../../gcc.dg/vect/pr59591-2.c\"\n+\n+#include CHECK_H\n+\n+static void\n+test_512 (void)\n+{\n+  bar ();\n+}"}, {"sha": "55a28dddbf84ff0faf74177f0ab7667789a031a2", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88464-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-1.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,7 @@\n+/* PR tree-optimization/88464 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mavx512vl -mprefer-vector-width=256 -mtune=skylake-avx512 -fdump-tree-vect-details\" } */\n+/* { dg-final { scan-tree-dump-times \"loop vectorized using 32 byte vectors\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops in function\" 4 \"vect\" } } */\n+\n+#include \"avx512f-pr88464-1.c\""}, {"sha": "b5c8205e524751e4d0f99cb4bf5752d12c043884", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88464-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-2.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,20 @@\n+/* PR tree-optimization/88464 */\n+/* { dg-do run { target { avx512vl } } } */\n+/* { dg-options \"-O3 -mavx512vl -mprefer-vector-width=256 -mtune=skylake-avx512\" } */\n+\n+#define AVX512VL\n+#define AVX512F_LEN 512\n+#define AVX512F_LEN_HALF 256\n+\n+#include \"avx512f-pr88464-2.c\"\n+\n+static void\n+test_256 (void)\n+{\n+  avx512f_test ();\n+}\n+\n+static void\n+test_128 (void)\n+{\n+}"}, {"sha": "6b0c8a85957f0f8a83453c26552ee41dd54c857b", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88464-3.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-3.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,7 @@\n+/* PR tree-optimization/88464 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mavx512vl -mprefer-vector-width=128 -mtune=skylake-avx512 -fdump-tree-vect-details\" } */\n+/* { dg-final { scan-tree-dump-times \"loop vectorized using 16 byte vectors\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops in function\" 4 \"vect\" } } */\n+\n+#include \"avx512f-pr88464-1.c\""}, {"sha": "7df6ce3fadcb97fa3ebb3b98885cabd968d1e8cc", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88464-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88464-4.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,20 @@\n+/* PR tree-optimization/88464 */\n+/* { dg-do run { target { avx512vl } } } */\n+/* { dg-options \"-O3 -mavx512vl -mprefer-vector-width=128 -mtune=skylake-avx512\" } */\n+\n+#define AVX512VL\n+#define AVX512F_LEN 512\n+#define AVX512F_LEN_HALF 256\n+\n+#include \"avx512f-pr88464-2.c\"\n+\n+static void\n+test_256 (void)\n+{\n+  avx512f_test ();\n+}\n+\n+static void\n+test_128 (void)\n+{\n+}"}, {"sha": "a5d144ff8389c9d244e7541de8f9789001042427", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88513-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-1.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,24 @@\n+/* PR target/88513 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512vl -mtune=intel -mprefer-vector-width=128 -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx512vl } */\n+\n+#define AVX512VL\n+#define AVX512F_LEN 512\n+#define AVX512F_LEN_HALF 256\n+#define CHECK_H \"avx512f-check.h\"\n+\n+#include \"../../gcc.dg/vect/pr59591-1.c\"\n+\n+#include CHECK_H\n+\n+static void\n+test_256 (void)\n+{\n+  bar ();\n+}\n+\n+static void\n+test_128 (void)\n+{\n+}"}, {"sha": "6eef7dedfa2833e437a5339b5a379f7c136b2003", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88513-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-2.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,24 @@\n+/* PR target/88513 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512vl -mtune=intel -mprefer-vector-width=128 -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx512vl } */\n+\n+#define AVX512VL\n+#define AVX512F_LEN 512\n+#define AVX512F_LEN_HALF 256\n+#define CHECK_H \"avx512f-check.h\"\n+\n+#include \"../../gcc.dg/vect/pr59591-2.c\"\n+\n+#include CHECK_H\n+\n+static void\n+test_256 (void)\n+{\n+  bar ();\n+}\n+\n+static void\n+test_128 (void)\n+{\n+}"}, {"sha": "884682011db02846c04d47dcc21bc7c4c068e991", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88513-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-3.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,24 @@\n+/* PR target/88513 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512vl -mtune=intel -mprefer-vector-width=256 -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx512vl } */\n+\n+#define AVX512VL\n+#define AVX512F_LEN 512\n+#define AVX512F_LEN_HALF 256\n+#define CHECK_H \"avx512f-check.h\"\n+\n+#include \"../../gcc.dg/vect/pr59591-1.c\"\n+\n+#include CHECK_H\n+\n+static void\n+test_256 (void)\n+{\n+  bar ();\n+}\n+\n+static void\n+test_128 (void)\n+{\n+}"}, {"sha": "1f0ae18cbad01d9f4d1a2e38a99bb1e6922dfd23", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88513-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88513-4.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,24 @@\n+/* PR target/88513 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512vl -mtune=intel -mprefer-vector-width=256 -fno-vect-cost-model\" } */\n+/* { dg-require-effective-target avx512vl } */\n+\n+#define AVX512VL\n+#define AVX512F_LEN 512\n+#define AVX512F_LEN_HALF 256\n+#define CHECK_H \"avx512f-check.h\"\n+\n+#include \"../../gcc.dg/vect/pr59591-2.c\"\n+\n+#include CHECK_H\n+\n+static void\n+test_256 (void)\n+{\n+  bar ();\n+}\n+\n+static void\n+test_128 (void)\n+{\n+}"}, {"sha": "ba5b5dadf1f4767f826a105278abd0cefe56108c", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88514-1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-1.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,5 @@\n+/* PR target/88514 */\n+/* { dg-do assemble { target avx512vl } } */\n+/* { dg-options \"-Ofast -mavx512vl -mtune=intel -mprefer-vector-width=128\" } */\n+\n+#include \"avx512vl-pr79299-1.c\""}, {"sha": "6128390d43f0b282f52563a79fb7c9fcc9796a68", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88514-2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-2.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,5 @@\n+/* PR target/88514 */\n+/* { dg-do assemble { target avx512vl } } */\n+/* { dg-options \"-Ofast -mavx512vl -mtune=intel -mprefer-vector-width=256\" } */\n+\n+#include \"avx512vl-pr79299-1.c\""}, {"sha": "6614741b1b9c7647885521129a60d3af7d67a6a4", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr88514-3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr88514-3.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -0,0 +1,5 @@\n+/* PR target/88514 */\n+/* { dg-do assemble { target avx512vl } } */\n+/* { dg-options \"-Ofast -mavx512vl -mtune=intel -mprefer-vector-width=512\" } */\n+\n+#include \"avx512vl-pr79299-1.c\""}, {"sha": "7aa774a0f29bfbfddcb73373a3bc636b31dd3d99", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4714942e0fbd2aa23f12f88d80b93e9b6ff4c041/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4714942e0fbd2aa23f12f88d80b93e9b6ff4c041", "patch": "@@ -10313,6 +10313,17 @@ supportable_widening_operation (enum tree_code code, stmt_vec_info stmt_info,\n       optab1 = optab_for_tree_code (c1, vectype_out, optab_default);\n       optab2 = optab_for_tree_code (c2, vectype_out, optab_default);\n     }\n+  else if (CONVERT_EXPR_CODE_P (code)\n+\t   && VECTOR_BOOLEAN_TYPE_P (wide_vectype)\n+\t   && VECTOR_BOOLEAN_TYPE_P (vectype)\n+\t   && TYPE_MODE (wide_vectype) == TYPE_MODE (vectype)\n+\t   && SCALAR_INT_MODE_P (TYPE_MODE (vectype)))\n+    {\n+      /* If the input and result modes are the same, a different optab\n+\t is needed where we pass in the number of units in vectype.  */\n+      optab1 = vec_unpacks_sbool_lo_optab;\n+      optab2 = vec_unpacks_sbool_hi_optab;\n+    }\n   else\n     {\n       optab1 = optab_for_tree_code (c1, vectype, optab_default);\n@@ -10332,12 +10343,16 @@ supportable_widening_operation (enum tree_code code, stmt_vec_info stmt_info,\n \n   if (insn_data[icode1].operand[0].mode == TYPE_MODE (wide_vectype)\n       && insn_data[icode2].operand[0].mode == TYPE_MODE (wide_vectype))\n+    {\n+      if (!VECTOR_BOOLEAN_TYPE_P (vectype))\n+\treturn true;\n       /* For scalar masks we may have different boolean\n \t vector types having the same QImode.  Thus we\n \t add additional check for elements number.  */\n-    return (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-\t    || known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n-\t\t\t TYPE_VECTOR_SUBPARTS (wide_vectype) * 2));\n+      if (known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t    TYPE_VECTOR_SUBPARTS (wide_vectype) * 2))\n+\treturn true;\n+    }\n \n   /* Check if it's a multi-step conversion that can be done using intermediate\n      types.  */\n@@ -10367,8 +10382,21 @@ supportable_widening_operation (enum tree_code code, stmt_vec_info stmt_info,\n \t  = lang_hooks.types.type_for_mode (intermediate_mode,\n \t\t\t\t\t    TYPE_UNSIGNED (prev_type));\n \n-      optab3 = optab_for_tree_code (c1, intermediate_type, optab_default);\n-      optab4 = optab_for_tree_code (c2, intermediate_type, optab_default);\n+      if (VECTOR_BOOLEAN_TYPE_P (intermediate_type)\n+\t  && VECTOR_BOOLEAN_TYPE_P (prev_type)\n+\t  && intermediate_mode == prev_mode\n+\t  && SCALAR_INT_MODE_P (prev_mode))\n+\t{\n+\t  /* If the input and result modes are the same, a different optab\n+\t     is needed where we pass in the number of units in vectype.  */\n+\t  optab3 = vec_unpacks_sbool_lo_optab;\n+\t  optab4 = vec_unpacks_sbool_hi_optab;\n+\t}\n+      else\n+\t{\n+\t  optab3 = optab_for_tree_code (c1, intermediate_type, optab_default);\n+\t  optab4 = optab_for_tree_code (c2, intermediate_type, optab_default);\n+\t}\n \n       if (!optab3 || !optab4\n           || (icode1 = optab_handler (optab1, prev_mode)) == CODE_FOR_nothing\n@@ -10386,9 +10414,13 @@ supportable_widening_operation (enum tree_code code, stmt_vec_info stmt_info,\n \n       if (insn_data[icode1].operand[0].mode == TYPE_MODE (wide_vectype)\n \t  && insn_data[icode2].operand[0].mode == TYPE_MODE (wide_vectype))\n-\treturn (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-\t\t|| known_eq (TYPE_VECTOR_SUBPARTS (intermediate_type),\n-\t\t\t     TYPE_VECTOR_SUBPARTS (wide_vectype) * 2));\n+\t{\n+\t  if (!VECTOR_BOOLEAN_TYPE_P (vectype))\n+\t    return true;\n+\t  if (known_eq (TYPE_VECTOR_SUBPARTS (intermediate_type),\n+\t\t\tTYPE_VECTOR_SUBPARTS (wide_vectype) * 2))\n+\t    return true;\n+\t}\n \n       prev_type = intermediate_type;\n       prev_mode = intermediate_mode;\n@@ -10441,26 +10473,30 @@ supportable_narrowing_operation (enum tree_code code,\n     {\n     CASE_CONVERT:\n       c1 = VEC_PACK_TRUNC_EXPR;\n+      if (VECTOR_BOOLEAN_TYPE_P (narrow_vectype)\n+\t  && VECTOR_BOOLEAN_TYPE_P (vectype)\n+\t  && TYPE_MODE (narrow_vectype) == TYPE_MODE (vectype)\n+\t  && SCALAR_INT_MODE_P (TYPE_MODE (vectype)))\n+\toptab1 = vec_pack_sbool_trunc_optab;\n+      else\n+\toptab1 = optab_for_tree_code (c1, vectype, optab_default);\n       break;\n \n     case FIX_TRUNC_EXPR:\n       c1 = VEC_PACK_FIX_TRUNC_EXPR;\n+      /* The signedness is determined from output operand.  */\n+      optab1 = optab_for_tree_code (c1, vectype_out, optab_default);\n       break;\n \n     case FLOAT_EXPR:\n       c1 = VEC_PACK_FLOAT_EXPR;\n+      optab1 = optab_for_tree_code (c1, vectype, optab_default);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  if (code == FIX_TRUNC_EXPR)\n-    /* The signedness is determined from output operand.  */\n-    optab1 = optab_for_tree_code (c1, vectype_out, optab_default);\n-  else\n-    optab1 = optab_for_tree_code (c1, vectype, optab_default);\n-\n   if (!optab1)\n     return false;\n \n@@ -10471,12 +10507,16 @@ supportable_narrowing_operation (enum tree_code code,\n   *code1 = c1;\n \n   if (insn_data[icode1].operand[0].mode == TYPE_MODE (narrow_vectype))\n-    /* For scalar masks we may have different boolean\n-       vector types having the same QImode.  Thus we\n-       add additional check for elements number.  */\n-    return (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-\t    || known_eq (TYPE_VECTOR_SUBPARTS (vectype) * 2,\n-\t\t\t TYPE_VECTOR_SUBPARTS (narrow_vectype)));\n+    {\n+      if (!VECTOR_BOOLEAN_TYPE_P (vectype))\n+\treturn true;\n+      /* For scalar masks we may have different boolean\n+\t vector types having the same QImode.  Thus we\n+\t add additional check for elements number.  */\n+      if (known_eq (TYPE_VECTOR_SUBPARTS (vectype) * 2,\n+\t\t    TYPE_VECTOR_SUBPARTS (narrow_vectype)))\n+\treturn true;\n+    }\n \n   if (code == FLOAT_EXPR)\n     return false;\n@@ -10528,9 +10568,15 @@ supportable_narrowing_operation (enum tree_code code,\n       else\n \tintermediate_type\n \t  = lang_hooks.types.type_for_mode (intermediate_mode, uns);\n-      interm_optab\n-\t= optab_for_tree_code (VEC_PACK_TRUNC_EXPR, intermediate_type,\n-\t\t\t       optab_default);\n+      if (VECTOR_BOOLEAN_TYPE_P (intermediate_type)\n+\t  && VECTOR_BOOLEAN_TYPE_P (prev_type)\n+\t  && intermediate_mode == prev_mode\n+\t  && SCALAR_INT_MODE_P (prev_mode))\n+\tinterm_optab = vec_pack_sbool_trunc_optab;\n+      else\n+\tinterm_optab\n+\t  = optab_for_tree_code (VEC_PACK_TRUNC_EXPR, intermediate_type,\n+\t\t\t\t optab_default);\n       if (!interm_optab\n \t  || ((icode1 = optab_handler (optab1, prev_mode)) == CODE_FOR_nothing)\n \t  || insn_data[icode1].operand[0].mode != intermediate_mode\n@@ -10542,9 +10588,13 @@ supportable_narrowing_operation (enum tree_code code,\n       (*multi_step_cvt)++;\n \n       if (insn_data[icode1].operand[0].mode == TYPE_MODE (narrow_vectype))\n-\treturn (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-\t\t|| known_eq (TYPE_VECTOR_SUBPARTS (intermediate_type) * 2,\n-\t\t\t     TYPE_VECTOR_SUBPARTS (narrow_vectype)));\n+\t{\n+\t  if (!VECTOR_BOOLEAN_TYPE_P (vectype))\n+\t    return true;\n+\t  if (known_eq (TYPE_VECTOR_SUBPARTS (intermediate_type) * 2,\n+\t\t\tTYPE_VECTOR_SUBPARTS (narrow_vectype)))\n+\t    return true;\n+\t}\n \n       prev_mode = intermediate_mode;\n       prev_type = intermediate_type;"}]}