{"sha": "1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU4NzQyNzNmOGQ2ZThhN2JkZmU3YmM3NmZjZWI3ZDIwZDFmMWVmMg==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2011-09-13T12:48:33Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2011-09-13T12:48:33Z"}, "message": "arm.h (ASM_PREFERRED_EH_DATA_FORMAT): Define.\n\n2011-09-13  Paul Brook  <paul@codesourcery.com>\n \n\tgcc/\n\t* config/arm/arm.h (ASM_PREFERRED_EH_DATA_FORMAT): Define.\n\t(ARM_TARGET2_DWARF_FORMAT): Provide default definition.\n\t* config/arm/linux-eabi.h (ARM_TARGET2_DWARF_FORMAT): Define.\n\t* config/arm/symbian.h (ARM_TARGET2_DWARF_FORMAT): Define.\n\t* config/arm/uclinux-eabi.h(ARM_TARGET2_DWARF_FORMAT): Define.\n\t* config/arm/t-bpabi (EXTRA_HEADERS): Add unwind-arm-common.h.\n\t* config/arm/t-symbian (EXTRA_HEADERS): Add unwind-arm-common.h.\n\t* config/c6x/c6x.c (c6x_output_file_unwind): Don't rely on dwarf2 code\n\tenabling unwind tables.\n\t(c6x_debug_unwind_info): New function.\n\t(TARGET_ARM_EABI_UNWINDER): Define.\n\t(TARGET_DEBUG_UNWIND_INFO): Define.\n\t* config/c6x/c6x.h (DWARF_FRAME_RETURN_COLUMN): Define.\n\t(TARGET_EXTRA_CFI_SECTION): Remove.\n\t* config/c6x/t-c6x-elf (EXTRA_HEADERS): Set.\n\t* ginclude/unwind-arm-common.h: New file.\n\n\tlibgcc/\n\t* config.host (tic6x-*-*): Add c6x/t-c6x-elf.  Set unwind_header.\n\t* unwind-c.c (PERSONALITY_FUNCTION): Use UNWIND_POINTER_REG.\n\t* unwind-arm-common.inc: New file.\n\t* config/arm/unwind-arm.c: Use unwind-arm-common.inc.\n\t* config/arm/unwind-arm.h: Use unwind-arm-common.h.\n\t(_GLIBCXX_OVERRIDE_TTYPE_ENCODING): Define.\n\t* config/c6x/libunwind.S: New file.\n\t* config/c6x/pr-support.c: New file.\n\t* config/c6x/unwind-c6x.c: New file.\n\t* config/c6x/unwind-c6x.h: New file.\n\t* config/c6x/t-c6x-elf: New file.\n\n\n\tlibstdc++-v3/\n\t* libsupc++/eh_arm.cc (__cxa_end_cleanup): Add C6X implementation.\n\t* libsupc++/eh_call.cc (__cxa_call_unexpected): Set rtti_base.\n\t* libsupc++/eh_personality.cc (NO_SIZE_OF_ENCODED_VALUE): Remove\n\t__ARM_EABI_UNWINDER__ check.\n\t(parse_lsda_header): Check _GLIBCXX_OVERRIDE_TTYPE_ENCODING.\n\t(get_ttype_entry): Use generic implementation on ARM EABI.\n\t(check_exception_spec): Use _Unwind_decode_typeinfo_ptr and\n\tUNWIND_STACK_REG.\n\t(PERSONALITY_FUNCTION): Set ttype_base.\n\nFrom-SVN: r178808", "tree": {"sha": "919ab69e4bf163c2220a80d2baee8cd54fe40723", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/919ab69e4bf163c2220a80d2baee8cd54fe40723"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/comments", "author": null, "committer": null, "parents": [{"sha": "3e0cef6dddb0eeba482ef43bbca8eeac4b57666a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0cef6dddb0eeba482ef43bbca8eeac4b57666a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e0cef6dddb0eeba482ef43bbca8eeac4b57666a"}], "stats": {"total": 3253, "additions": 2226, "deletions": 1027}, "files": [{"sha": "010bb7bfafcbdaf22ee77dbf69da73076451b446", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -1,3 +1,22 @@\n+2011-09-13  Paul Brook  <paul@codesourcery.com>\n+ \n+\t* config/arm/arm.h (ASM_PREFERRED_EH_DATA_FORMAT): Define.\n+\t(ARM_TARGET2_DWARF_FORMAT): Provide default definition.\n+\t* config/arm/linux-eabi.h (ARM_TARGET2_DWARF_FORMAT): Define.\n+\t* config/arm/symbian.h (ARM_TARGET2_DWARF_FORMAT): Define.\n+\t* config/arm/uclinux-eabi.h(ARM_TARGET2_DWARF_FORMAT): Define.\n+\t* config/arm/t-bpabi (EXTRA_HEADERS): Add unwind-arm-common.h.\n+\t* config/arm/t-symbian (EXTRA_HEADERS): Add unwind-arm-common.h.\n+\t* config/c6x/c6x.c (c6x_output_file_unwind): Don't rely on dwarf2 code\n+\tenabling unwind tables.\n+\t(c6x_debug_unwind_info): New function.\n+\t(TARGET_ARM_EABI_UNWINDER): Define.\n+\t(TARGET_DEBUG_UNWIND_INFO): Define.\n+\t* config/c6x/c6x.h (DWARF_FRAME_RETURN_COLUMN): Define.\n+\t(TARGET_EXTRA_CFI_SECTION): Remove.\n+\t* config/c6x/t-c6x-elf (EXTRA_HEADERS): Set.\n+\t* ginclude/unwind-arm-common.h: New file.\n+\n 2011-09-13  Georg-Johann Lay  <avr@gjlay.de>\n \t\n \tPR target/50358"}, {"sha": "208ee517933a9bc734d24f2b77cacbe13296d67f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -825,6 +825,16 @@ extern int arm_arch_thumb_hwdiv;\n #define ARM_EH_STACKADJ_REGNUM\t2\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (SImode, ARM_EH_STACKADJ_REGNUM)\n \n+#ifndef ARM_TARGET2_DWARF_FORMAT\n+#define ARM_TARGET2_DWARF_FORMAT DW_EH_PE_pcrel\n+\n+/* ttype entries (the only interesting data references used)\n+   use TARGET2 relocations.  */\n+#define ASM_PREFERRED_EH_DATA_FORMAT(code, data) \\\n+  (((code) == 0 && (data) == 1 && ARM_UNWIND_INFO) ? ARM_TARGET2_DWARF_FORMAT \\\n+\t\t\t       : DW_EH_PE_absptr)\n+#endif\n+\n /* The native (Norcroft) Pascal compiler for the ARM passes the static chain\n    as an invisible last argument (possible since varargs don't exist in\n    Pascal), so the following is not true.  */"}, {"sha": "a38309559481382806c66f20e64a7de0bb53aaab", "filename": "gcc/config/arm/linux-eabi.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Flinux-eabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Flinux-eabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-eabi.h?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -101,3 +101,5 @@\n    is used.  */\n #undef  CLEAR_INSN_CACHE\n #define CLEAR_INSN_CACHE(BEG, END) not_used\n+\n+#define ARM_TARGET2_DWARF_FORMAT (DW_EH_PE_pcrel | DW_EH_PE_indirect)"}, {"sha": "fa2ed84ed66ff8c0bbf660ae2be9f65c42103f77", "filename": "gcc/config/arm/symbian.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Fsymbian.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Fsymbian.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsymbian.h?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -98,3 +98,5 @@\n #define TARGET_ARM_DYNAMIC_VAGUE_LINKAGE_P false\n \n #define TARGET_DEFAULT_WORD_RELOCATIONS 1\n+\n+#define ARM_TARGET2_DWARF_FORMAT DW_EH_PE_absptr"}, {"sha": "d8a1be45dcdcfd9c9c57b4b76b9fa419ed0df62f", "filename": "gcc/config/arm/t-bpabi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Ft-bpabi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Ft-bpabi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-bpabi?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -28,3 +28,4 @@ LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/arm/fp16.c\n # Add the BPABI names.\n SHLIB_MAPFILES += $(srcdir)/config/arm/libgcc-bpabi.ver\n \n+EXTRA_HEADERS += $(srcdir)/ginclude/unwind-arm-common.h"}, {"sha": "e37d473eca01ed9274814ca336789c11247c4cfa", "filename": "gcc/config/arm/t-symbian", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Ft-symbian", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Ft-symbian", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-symbian?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -30,6 +30,7 @@ LIB1ASMFUNCS += \\\n \t_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2 \\\n \t_fixsfsi _fixunssfsi\n \n+EXTRA_HEADERS += $(srcdir)/ginclude/unwind-arm-common.h\n # Include half-float helpers.\n LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/arm/fp16.c\n "}, {"sha": "c106c980203f75a0e28862d714635b4c51b67ed4", "filename": "gcc/config/arm/uclinux-eabi.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Fuclinux-eabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Farm%2Fuclinux-eabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fuclinux-eabi.h?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -64,3 +64,4 @@\n \t\t    : \"0\" (_beg), \"r\" (_end), \"r\" (_flg), \"r\" (_scno));\t\\\n }\n \n+#define ARM_TARGET2_DWARF_FORMAT DW_EH_PE_absptr"}, {"sha": "f2ab0b88aa9f9d341f9be50c84c3d1d73f6b19e3", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -402,12 +402,19 @@ c6x_output_file_unwind (FILE * f)\n   if (done_cfi_sections)\n     return;\n \n-  /* Output a .cfi_sections directive if we aren't\n-     already doing so for debug info.  */\n-  if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG\n-\t    && dwarf2out_do_frame ())\n+  /* Output a .cfi_sections directive.  */\n+  if (dwarf2out_do_frame ())\n     {\n-      asm_fprintf (f, \"\\t.cfi_sections .c6xabi.exidx\\n\");\n+      if (flag_unwind_tables || flag_exceptions)\n+\t{\n+\t  if (write_symbols == DWARF2_DEBUG\n+\t      || write_symbols == VMS_AND_DWARF2_DEBUG)\n+\t    asm_fprintf (f, \"\\t.cfi_sections .debug_frame, .c6xabi.exidx\\n\");\n+\t  else\n+\t    asm_fprintf (f, \"\\t.cfi_sections .c6xabi.exidx\\n\");\n+\t}\n+      else\n+\tasm_fprintf (f, \"\\t.cfi_sections .debug_frame\\n\");\n       done_cfi_sections = true;\n     }\n }\n@@ -5606,6 +5613,18 @@ c6x_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \n   gcc_unreachable ();\n }\n+\n+/* Target unwind frame info is generated from dwarf CFI directives, so\n+   always output dwarf2 unwind info.  */\n+\n+static enum unwind_info_type\n+c6x_debug_unwind_info (void)\n+{\n+  if (flag_unwind_tables || flag_exceptions)\n+    return UI_DWARF2;\n+\n+  return default_debug_unwind_info ();\n+}\n \f\n /* Target Structure.  */\n \n@@ -5746,6 +5765,13 @@ c6x_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n #undef TARGET_ASM_TTYPE\n #define TARGET_ASM_TTYPE c6x_output_ttype\n \n+/* The C6x ABI follows the ARM EABI exception handling rules.  */\n+#undef TARGET_ARM_EABI_UNWINDER\n+#define TARGET_ARM_EABI_UNWINDER true\n+\n+#undef TARGET_DEBUG_UNWIND_INFO\n+#define TARGET_DEBUG_UNWIND_INFO  c6x_debug_unwind_info\n+\n #undef TARGET_DWARF_REGISTER_SPAN\n #define TARGET_DWARF_REGISTER_SPAN c6x_dwarf_register_span\n "}, {"sha": "240f2f9ffc75418ff9a506ecec57f6828832e6e8", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -329,6 +329,7 @@ enum reg_class\n /* Before the prologue, the return address is in the B3 register.  */\n #define RETURN_ADDR_REGNO REG_B3\n #define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, RETURN_ADDR_REGNO)\n+#define DWARF_FRAME_RETURN_COLUMN\tDWARF_FRAME_REGNUM (RETURN_ADDR_REGNO)\n \n #define RETURN_ADDR_RTX(COUNT, FRAME) c6x_return_addr_rtx (COUNT)\n \n@@ -459,8 +460,6 @@ struct GTY(()) machine_function\n #define TARG_VEC_PERMUTE_COST        1\n #endif\n \n-/* Exception handling.  */\n-#define TARGET_EXTRA_CFI_SECTION(unwind) ((unwind) ? \".c6xabi.exidx\" : NULL)\n /* ttype entries (the only interesting data references used) are\n    sb-relative got-indirect (aka .ehtype).  */\n #define ASM_PREFERRED_EH_DATA_FORMAT(code, data) \\"}, {"sha": "030a39ce18c590cec4da45e2d253e00d674c8c3d", "filename": "gcc/config/c6x/t-c6x-elf", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Fc6x%2Ft-c6x-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fconfig%2Fc6x%2Ft-c6x-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Ft-c6x-elf?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -24,6 +24,7 @@ LIB1ASMFUNCS += _strasgi _strasgi_64plus _clzsi2 _clzdi2 _clz\n LIB1ASMFUNCS += _push_rts _pop_rts _call_stub\n \n LIB2FUNCS_EXCLUDE = _cmpdi2 _ucmpdi2 _gcc_bcmp _eprintf _clzsi _clzdi\n+EXTRA_HEADERS += $(srcdir)/ginclude/unwind-arm-common.h\n \n LIB2FUNCS_EXTRA = $(srcdir)/config/c6x/gef.c \\\n                   $(srcdir)/config/c6x/gtf.c \\"}, {"sha": "95872705e3f13b6782f984046e16e84253e10bea", "filename": "gcc/ginclude/unwind-arm-common.h", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fginclude%2Funwind-arm-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/gcc%2Fginclude%2Funwind-arm-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Funwind-arm-common.h?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -0,0 +1,251 @@\n+/* Header file for the ARM EABI and C6X unwinders\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Language-independent unwinder header public defines.  This contains both\n+   ABI defined objects, and GNU support routines.  */\n+\n+#ifndef UNWIND_ARM_COMMON_H\n+#define UNWIND_ARM_COMMON_H\n+\n+#define __ARM_EABI_UNWINDER__ 1\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+  typedef unsigned _Unwind_Word __attribute__((__mode__(__word__)));\n+  typedef signed _Unwind_Sword __attribute__((__mode__(__word__)));\n+  typedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));\n+  typedef unsigned _Unwind_Internal_Ptr __attribute__((__mode__(__pointer__)));\n+  typedef _Unwind_Word _uw;\n+  typedef unsigned _uw64 __attribute__((mode(__DI__)));\n+  typedef unsigned _uw16 __attribute__((mode(__HI__)));\n+  typedef unsigned _uw8 __attribute__((mode(__QI__)));\n+\n+  typedef enum\n+    {\n+      _URC_OK = 0,       /* operation completed successfully */\n+      _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+      _URC_END_OF_STACK = 5,\n+      _URC_HANDLER_FOUND = 6,\n+      _URC_INSTALL_CONTEXT = 7,\n+      _URC_CONTINUE_UNWIND = 8,\n+      _URC_FAILURE = 9   /* unspecified failure of some kind */\n+    }\n+  _Unwind_Reason_Code;\n+\n+  typedef enum\n+    {\n+      _US_VIRTUAL_UNWIND_FRAME = 0,\n+      _US_UNWIND_FRAME_STARTING = 1,\n+      _US_UNWIND_FRAME_RESUME = 2,\n+      _US_ACTION_MASK = 3,\n+      _US_FORCE_UNWIND = 8,\n+      _US_END_OF_STACK = 16\n+    }\n+  _Unwind_State;\n+\n+  /* Provided only for compatibility with existing code.  */\n+  typedef int _Unwind_Action;\n+#define _UA_SEARCH_PHASE\t1\n+#define _UA_CLEANUP_PHASE\t2\n+#define _UA_HANDLER_FRAME\t4\n+#define _UA_FORCE_UNWIND\t8\n+#define _UA_END_OF_STACK\t16\n+#define _URC_NO_REASON \t_URC_OK\n+\n+  typedef struct _Unwind_Control_Block _Unwind_Control_Block;\n+  typedef struct _Unwind_Context _Unwind_Context;\n+  typedef _uw _Unwind_EHT_Header;\n+\n+\n+  /* UCB: */\n+\n+  struct _Unwind_Control_Block\n+    {\n+      char exception_class[8];\n+      void (*exception_cleanup)(_Unwind_Reason_Code, _Unwind_Control_Block *);\n+      /* Unwinder cache, private fields for the unwinder's use */\n+      struct\n+\t{\n+\t  _uw reserved1;  /* Forced unwind stop fn, 0 if not forced */\n+\t  _uw reserved2;  /* Personality routine address */\n+\t  _uw reserved3;  /* Saved callsite address */\n+\t  _uw reserved4;  /* Forced unwind stop arg */\n+\t  _uw reserved5;\n+\t}\n+      unwinder_cache;\n+      /* Propagation barrier cache (valid after phase 1): */\n+      struct\n+\t{\n+\t  _uw sp;\n+\t  _uw bitpattern[5];\n+\t}\n+      barrier_cache;\n+      /* Cleanup cache (preserved over cleanup): */\n+      struct\n+\t{\n+\t  _uw bitpattern[4];\n+\t}\n+      cleanup_cache;\n+      /* Pr cache (for pr's benefit): */\n+      struct\n+\t{\n+\t  _uw fnstart;\t\t\t/* function start address */\n+\t  _Unwind_EHT_Header *ehtp;\t/* pointer to EHT entry header word */\n+\t  _uw additional;\t\t/* additional data */\n+\t  _uw reserved1;\n+\t}\n+      pr_cache;\n+      long long int :0;\t/* Force alignment to 8-byte boundary */\n+    };\n+\n+  /* Virtual Register Set*/\n+\n+  typedef enum\n+    {\n+      _UVRSC_CORE = 0,      /* integer register */\n+      _UVRSC_VFP = 1,       /* vfp */\n+      _UVRSC_FPA = 2,       /* fpa */\n+      _UVRSC_WMMXD = 3,     /* Intel WMMX data register */\n+      _UVRSC_WMMXC = 4      /* Intel WMMX control register */\n+    }\n+  _Unwind_VRS_RegClass;\n+\n+  typedef enum\n+    {\n+      _UVRSD_UINT32 = 0,\n+      _UVRSD_VFPX = 1,\n+      _UVRSD_FPAX = 2,\n+      _UVRSD_UINT64 = 3,\n+      _UVRSD_FLOAT = 4,\n+      _UVRSD_DOUBLE = 5\n+    }\n+  _Unwind_VRS_DataRepresentation;\n+\n+  typedef enum\n+    {\n+      _UVRSR_OK = 0,\n+      _UVRSR_NOT_IMPLEMENTED = 1,\n+      _UVRSR_FAILED = 2\n+    }\n+  _Unwind_VRS_Result;\n+\n+  /* Frame unwinding state.  */\n+  typedef struct\n+    {\n+      /* The current word (bytes packed msb first).  */\n+      _uw data;\n+      /* Pointer to the next word of data.  */\n+      _uw *next;\n+      /* The number of bytes left in this word.  */\n+      _uw8 bytes_left;\n+      /* The number of words pointed to by ptr.  */\n+      _uw8 words_left;\n+    }\n+  __gnu_unwind_state;\n+\n+  typedef _Unwind_Reason_Code (*personality_routine) (_Unwind_State,\n+      _Unwind_Control_Block *, _Unwind_Context *);\n+\n+  _Unwind_VRS_Result _Unwind_VRS_Set(_Unwind_Context *, _Unwind_VRS_RegClass,\n+                                     _uw, _Unwind_VRS_DataRepresentation,\n+                                     void *);\n+\n+  _Unwind_VRS_Result _Unwind_VRS_Get(_Unwind_Context *, _Unwind_VRS_RegClass,\n+                                     _uw, _Unwind_VRS_DataRepresentation,\n+                                     void *);\n+\n+  _Unwind_VRS_Result _Unwind_VRS_Pop(_Unwind_Context *, _Unwind_VRS_RegClass,\n+                                     _uw, _Unwind_VRS_DataRepresentation);\n+\n+\n+  /* Support functions for the PR.  */\n+#define _Unwind_Exception _Unwind_Control_Block\n+  typedef char _Unwind_Exception_Class[8];\n+\n+  void * _Unwind_GetLanguageSpecificData (_Unwind_Context *);\n+  _Unwind_Ptr _Unwind_GetRegionStart (_Unwind_Context *);\n+\n+  _Unwind_Ptr _Unwind_GetDataRelBase (_Unwind_Context *);\n+  /* This should never be used.  */\n+  _Unwind_Ptr _Unwind_GetTextRelBase (_Unwind_Context *);\n+\n+  /* Interface functions: */\n+  _Unwind_Reason_Code _Unwind_RaiseException(_Unwind_Control_Block *ucbp);\n+  void __attribute__((noreturn)) _Unwind_Resume(_Unwind_Control_Block *ucbp);\n+  _Unwind_Reason_Code _Unwind_Resume_or_Rethrow (_Unwind_Control_Block *ucbp);\n+\n+  typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)\n+       (int, _Unwind_Action, _Unwind_Exception_Class,\n+\t_Unwind_Control_Block *, struct _Unwind_Context *, void *);\n+  _Unwind_Reason_Code _Unwind_ForcedUnwind (_Unwind_Control_Block *,\n+\t\t\t\t\t    _Unwind_Stop_Fn, void *);\n+  /* @@@ Use unwind data to perform a stack backtrace.  The trace callback\n+     is called for every stack frame in the call chain, but no cleanup\n+     actions are performed.  */\n+  typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn) (_Unwind_Context *, void *);\n+  _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn,\n+\t\t\t\t\tvoid*);\n+\n+  _Unwind_Word _Unwind_GetCFA (struct _Unwind_Context *);\n+  void _Unwind_Complete(_Unwind_Control_Block *ucbp);\n+  void _Unwind_DeleteException (_Unwind_Exception *);\n+\n+  _Unwind_Reason_Code __gnu_unwind_frame (_Unwind_Control_Block *,\n+\t\t\t\t\t  _Unwind_Context *);\n+  _Unwind_Reason_Code __gnu_unwind_execute (_Unwind_Context *,\n+\t\t\t\t\t    __gnu_unwind_state *);\n+\n+  static inline _Unwind_Word\n+  _Unwind_GetGR (_Unwind_Context *context, int regno)\n+    {\n+      _uw val;\n+      _Unwind_VRS_Get (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);\n+      return val;\n+    }\n+\n+#define _Unwind_GetIPInfo(context, ip_before_insn) \\\n+  (*ip_before_insn = 0, _Unwind_GetIP (context))\n+\n+  static inline void\n+  _Unwind_SetGR (_Unwind_Context *context, int regno, _Unwind_Word val)\n+    {\n+      _Unwind_VRS_Set (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);\n+    }\n+\n+  _Unwind_Ptr _Unwind_GetRegionStart (_Unwind_Context *);\n+  void * _Unwind_GetLanguageSpecificData (_Unwind_Context *);\n+\n+/* leb128 type numbers have a potentially unlimited size.\n+   The target of the following definitions of _sleb128_t and _uleb128_t\n+   is to have efficient data types large enough to hold the leb128 type\n+   numbers used in the unwind code.  */\n+typedef long _sleb128_t;\n+typedef unsigned long _uleb128_t;\n+\n+#ifdef __cplusplus\n+}   /* extern \"C\" */\n+#endif\n+\n+#endif /* defined UNWIND_ARM_COMMON_H */"}, {"sha": "2f6973b7a8219a9c962a24b10476b94c9b1dbe8e", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -1,3 +1,17 @@\n+2011-09-13  Paul Brook  <paul@codesourcery.com>\n+ \n+\t* config.host (tic6x-*-*): Add c6x/t-c6x-elf.  Set unwind_header.\n+\t* unwind-c.c (PERSONALITY_FUNCTION): Use UNWIND_POINTER_REG.\n+\t* unwind-arm-common.inc: New file.\n+\t* config/arm/unwind-arm.c: Use unwind-arm-common.inc.\n+\t* config/arm/unwind-arm.h: Use unwind-arm-common.h.\n+\t(_GLIBCXX_OVERRIDE_TTYPE_ENCODING): Define.\n+\t* config/c6x/libunwind.S: New file.\n+\t* config/c6x/pr-support.c: New file.\n+\t* config/c6x/unwind-c6x.c: New file.\n+\t* config/c6x/unwind-c6x.h: New file.\n+\t* config/c6x/t-c6x-elf: New file.\n+\n 2011-08-23  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/64/sfp-machine.h (ASM_INVALID): New define."}, {"sha": "25afb378db25aec5edd320605839ed9664131921", "filename": "libgcc/config.host", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -790,7 +790,8 @@ spu-*-elf*)\n \ttmake_file=\"t-fdpbit spu/t-elf\"\n \t;;\n tic6x-*-*)\n-\ttmake_file=\"${tmake_file} t-softfp-sfdf t-softfp-excl t-softfp t-gnu-prefix\"\n+\ttmake_file=\"${tmake_file} t-softfp-sfdf t-softfp-excl t-softfp t-gnu-prefix c6x/t-c6x-elf\"\n+\tunwind_header=config/c6x/unwind-c6x.h\n \t;;\n v850*-*-*)\n \ttmake_file=t-fdpbit"}, {"sha": "1e8ca619ae2be189899d8f17d90934b99f0600e2", "filename": "libgcc/config/arm/unwind-arm.c", "status": "modified", "additions": 15, "deletions": 771, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Farm%2Funwind-arm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Farm%2Funwind-arm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Funwind-arm.c?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -23,44 +23,15 @@\n \n #include \"unwind.h\"\n \n-/* We add a prototype for abort here to avoid creating a dependency on\n-   target headers.  */\n-extern void abort (void);\n-\n-/* Definitions for C++ runtime support routines.  We make these weak\n-   declarations to avoid pulling in libsupc++ unnecessarily.  */\n-typedef unsigned char bool;\n-\n-typedef struct _ZSt9type_info type_info; /* This names C++ type_info type */\n-enum __cxa_type_match_result\n-  {\n-    ctm_failed = 0,\n-    ctm_succeeded = 1,\n-    ctm_succeeded_with_ptr_to_base = 2\n-  };\n-\n-void __attribute__((weak)) __cxa_call_unexpected(_Unwind_Control_Block *ucbp);\n-bool __attribute__((weak)) __cxa_begin_cleanup(_Unwind_Control_Block *ucbp);\n-enum __cxa_type_match_result __attribute__((weak)) __cxa_type_match\n-  (_Unwind_Control_Block *ucbp, const type_info *rttip,\n-   bool is_reference, void **matched_object);\n-\n-_Unwind_Ptr __attribute__((weak))\n-__gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);\n-\n /* Misc constants.  */\n #define R_IP\t12\n #define R_SP\t13\n #define R_LR\t14\n #define R_PC\t15\n \n-#define EXIDX_CANTUNWIND 1\n-#define uint32_highbit (((_uw) 1) << 31)\n-\n-#define UCB_FORCED_STOP_FN(ucbp) ((ucbp)->unwinder_cache.reserved1)\n-#define UCB_PR_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved2)\n-#define UCB_SAVED_CALLSITE_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved3)\n-#define UCB_FORCED_STOP_ARG(ucbp) ((ucbp)->unwinder_cache.reserved4)\n+#define VRS_PC(vrs) ((vrs)->core.r[R_PC])\n+#define VRS_SP(vrs) ((vrs)->core.r[R_SP])\n+#define VRS_RETURN(vrs) ((vrs)->core.r[R_LR])\n \n struct core_regs\n {\n@@ -102,20 +73,6 @@ struct wmmxc_regs\n   _uw wc[4];\n };\n \n-/* Unwind descriptors.  */\n-\n-typedef struct\n-{\n-  _uw16 length;\n-  _uw16 offset;\n-} EHT16;\n-\n-typedef struct\n-{\n-  _uw length;\n-  _uw offset;\n-} EHT32;\n-\n /* The ABI specifies that the unwind routines may only use core registers,\n    except when actually manipulating coprocessor state.  This allows\n    us to write one implementation that works on all platforms by\n@@ -154,21 +111,6 @@ typedef struct\n   struct core_regs core;\n } phase2_vrs;\n \n-\n-/* An exception index table entry.  */\n-\n-typedef struct __EIT_entry\n-{\n-  _uw fnoffset;\n-  _uw content;\n-} __EIT_entry;\n-\n-/* Assembly helper functions.  */\n-\n-/* Restore core register state.  Never returns.  */\n-void __attribute__((noreturn)) restore_core_regs (struct core_regs *);\n-\n-\n /* Coprocessor register state manipulation functions.  */\n \n /* Routines for FLDMX/FSTMX format...  */\n@@ -209,15 +151,7 @@ restore_non_core_regs (phase1_vrs * vrs)\n     __gnu_Unwind_Restore_WMMXC (&vrs->wmmxc);\n }\n \n-/* A better way to do this would probably be to compare the absolute address\n-   with a segment relative relocation of the same symbol.  */\n-\n-extern int __text_start;\n-extern int __data_start;\n-\n-/* The exception index table location.  */\n-extern __EIT_entry __exidx_start;\n-extern __EIT_entry __exidx_end;\n+#include \"unwind-arm-common.inc\"\n \n /* ABI defined personality routines.  */\n extern _Unwind_Reason_Code __aeabi_unwind_cpp_pr0 (_Unwind_State,\n@@ -547,715 +481,25 @@ selfrel_offset31 (const _uw *p)\n   return offset + (_uw) p;\n }\n \n-\n-/* Perform a binary search for RETURN_ADDRESS in TABLE.  The table contains\n-   NREC entries.  */\n-\n-static const __EIT_entry *\n-search_EIT_table (const __EIT_entry * table, int nrec, _uw return_address)\n+static _uw\n+__gnu_unwind_get_pr_addr (int idx)\n {\n-  _uw next_fn;\n-  _uw this_fn;\n-  int n, left, right;\n-\n-  if (nrec == 0)\n-    return (__EIT_entry *) 0;\n-\n-  left = 0;\n-  right = nrec - 1;\n-\n-  while (1)\n-    {\n-      n = (left + right) / 2;\n-      this_fn = selfrel_offset31 (&table[n].fnoffset);\n-      if (n != nrec - 1)\n-\tnext_fn = selfrel_offset31 (&table[n + 1].fnoffset) - 1;\n-      else\n-\tnext_fn = (_uw)0 - 1;\n-\n-      if (return_address < this_fn)\n-\t{\n-\t  if (n == left)\n-\t    return (__EIT_entry *) 0;\n-\t  right = n - 1;\n-\t}\n-      else if (return_address <= next_fn)\n-\treturn &table[n];\n-      else\n-\tleft = n + 1;\n-    }\n-}\n-\n-/* Find the exception index table eintry for the given address.\n-   Fill in the relevant fields of the UCB.\n-   Returns _URC_FAILURE if an error occurred, _URC_OK on success.  */\n-\n-static _Unwind_Reason_Code\n-get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n-{\n-  const __EIT_entry * eitp;\n-  int nrec;\n-  \n-  /* The return address is the address of the instruction following the\n-     call instruction (plus one in thumb mode).  If this was the last\n-     instruction in the function the address will lie in the following\n-     function.  Subtract 2 from the address so that it points within the call\n-     instruction itself.  */\n-  return_address -= 2;\n-\n-  if (__gnu_Unwind_Find_exidx)\n-    {\n-      eitp = (const __EIT_entry *) __gnu_Unwind_Find_exidx (return_address,\n-\t\t\t\t\t\t\t    &nrec);\n-      if (!eitp)\n-\t{\n-\t  UCB_PR_ADDR (ucbp) = 0;\n-\t  return _URC_FAILURE;\n-\t}\n-    }\n-  else\n+  switch (idx)\n     {\n-      eitp = &__exidx_start;\n-      nrec = &__exidx_end - &__exidx_start;\n-    }\n-\n-  eitp = search_EIT_table (eitp, nrec, return_address);\n+    case 0:\n+      return (_uw) &__aeabi_unwind_cpp_pr0;\n \n-  if (!eitp)\n-    {\n-      UCB_PR_ADDR (ucbp) = 0;\n-      return _URC_FAILURE;\n-    }\n-  ucbp->pr_cache.fnstart = selfrel_offset31 (&eitp->fnoffset);\n+    case 1:\n+      return (_uw) &__aeabi_unwind_cpp_pr1;\n \n-  /* Can this frame be unwound at all?  */\n-  if (eitp->content == EXIDX_CANTUNWIND)\n-    {\n-      UCB_PR_ADDR (ucbp) = 0;\n-      return _URC_END_OF_STACK;\n-    }\n-\n-  /* Obtain the address of the \"real\" __EHT_Header word.  */\n-\n-  if (eitp->content & uint32_highbit)\n-    {\n-      /* It is immediate data.  */\n-      ucbp->pr_cache.ehtp = (_Unwind_EHT_Header *)&eitp->content;\n-      ucbp->pr_cache.additional = 1;\n-    }\n-  else\n-    {\n-      /* The low 31 bits of the content field are a self-relative\n-\t offset to an _Unwind_EHT_Entry structure.  */\n-      ucbp->pr_cache.ehtp =\n-\t(_Unwind_EHT_Header *) selfrel_offset31 (&eitp->content);\n-      ucbp->pr_cache.additional = 0;\n-    }\n-\n-  /* Discover the personality routine address.  */\n-  if (*ucbp->pr_cache.ehtp & (1u << 31))\n-    {\n-      /* One of the predefined standard routines.  */\n-      _uw idx = (*(_uw *) ucbp->pr_cache.ehtp >> 24) & 0xf;\n-      if (idx == 0)\n-\tUCB_PR_ADDR (ucbp) = (_uw) &__aeabi_unwind_cpp_pr0;\n-      else if (idx == 1)\n-\tUCB_PR_ADDR (ucbp) = (_uw) &__aeabi_unwind_cpp_pr1;\n-      else if (idx == 2)\n-\tUCB_PR_ADDR (ucbp) = (_uw) &__aeabi_unwind_cpp_pr2;\n-      else\n-\t{ /* Failed */\n-\t  UCB_PR_ADDR (ucbp) = 0;\n-\t  return _URC_FAILURE;\n-\t}\n-    } \n-  else\n-    {\n-      /* Execute region offset to PR */\n-      UCB_PR_ADDR (ucbp) = selfrel_offset31 (ucbp->pr_cache.ehtp);\n-    }\n-  return _URC_OK;\n-}\n-\n-\n-/* Perform phase2 unwinding.  VRS is the initial virtual register state.  */\n-\n-static void __attribute__((noreturn))\n-unwind_phase2 (_Unwind_Control_Block * ucbp, phase2_vrs * vrs)\n-{\n-  _Unwind_Reason_Code pr_result;\n-\n-  do\n-    {\n-      /* Find the entry for this routine.  */\n-      if (get_eit_entry (ucbp, vrs->core.r[R_PC]) != _URC_OK)\n-\tabort ();\n-\n-      UCB_SAVED_CALLSITE_ADDR (ucbp) = vrs->core.r[R_PC];\n-\n-      /* Call the pr to decide what to do.  */\n-      pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n-\t(_US_UNWIND_FRAME_STARTING, ucbp, (_Unwind_Context *) vrs);\n-    }\n-  while (pr_result == _URC_CONTINUE_UNWIND);\n-  \n-  if (pr_result != _URC_INSTALL_CONTEXT)\n-    abort();\n-  \n-  restore_core_regs (&vrs->core);\n-}\n-\n-/* Perform phase2 forced unwinding.  */\n-\n-static _Unwind_Reason_Code\n-unwind_phase2_forced (_Unwind_Control_Block *ucbp, phase2_vrs *entry_vrs,\n-\t\t      int resuming)\n-{\n-  _Unwind_Stop_Fn stop_fn = (_Unwind_Stop_Fn) UCB_FORCED_STOP_FN (ucbp);\n-  void *stop_arg = (void *)UCB_FORCED_STOP_ARG (ucbp);\n-  _Unwind_Reason_Code pr_result = 0;\n-  /* We use phase1_vrs here even though we do not demand save, for the\n-     prev_sp field.  */\n-  phase1_vrs saved_vrs, next_vrs;\n-\n-  /* Save the core registers.  */\n-  saved_vrs.core = entry_vrs->core;\n-  /* We don't need to demand-save the non-core registers, because we\n-     unwind in a single pass.  */\n-  saved_vrs.demand_save_flags = 0;\n-\n-  /* Unwind until we reach a propagation barrier.  */\n-  do\n-    {\n-      _Unwind_State action;\n-      _Unwind_Reason_Code entry_code;\n-      _Unwind_Reason_Code stop_code;\n-\n-      /* Find the entry for this routine.  */\n-      entry_code = get_eit_entry (ucbp, saved_vrs.core.r[R_PC]);\n-\n-      if (resuming)\n-\t{\n-\t  action = _US_UNWIND_FRAME_RESUME | _US_FORCE_UNWIND;\n-\t  resuming = 0;\n-\t}\n-      else\n-\taction = _US_UNWIND_FRAME_STARTING | _US_FORCE_UNWIND;\n-\n-      if (entry_code == _URC_OK)\n-\t{\n-\t  UCB_SAVED_CALLSITE_ADDR (ucbp) = saved_vrs.core.r[R_PC];\n-\n-\t  next_vrs = saved_vrs;\n-\n-\t  /* Call the pr to decide what to do.  */\n-\t  pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n-\t    (action, ucbp, (void *) &next_vrs);\n-\n-\t  saved_vrs.prev_sp = next_vrs.core.r[R_SP];\n-\t}\n-      else\n-\t{\n-\t  /* Treat any failure as the end of unwinding, to cope more\n-\t     gracefully with missing EH information.  Mixed EH and\n-\t     non-EH within one object will usually result in failure,\n-\t     because the .ARM.exidx tables do not indicate the end\n-\t     of the code to which they apply; but mixed EH and non-EH\n-\t     shared objects should return an unwind failure at the\n-\t     entry of a non-EH shared object.  */\n-\t  action |= _US_END_OF_STACK;\n-\n-\t  saved_vrs.prev_sp = saved_vrs.core.r[R_SP];\n-\t}\n-\n-      stop_code = stop_fn (1, action, ucbp->exception_class, ucbp,\n-\t\t\t   (void *)&saved_vrs, stop_arg);\n-      if (stop_code != _URC_NO_REASON)\n-\treturn _URC_FAILURE;\n-\n-      if (entry_code != _URC_OK)\n-\treturn entry_code;\n-\n-      saved_vrs = next_vrs;\n-    }\n-  while (pr_result == _URC_CONTINUE_UNWIND);\n-\n-  if (pr_result != _URC_INSTALL_CONTEXT)\n-    {\n-      /* Some sort of failure has occurred in the pr and probably the\n-\t pr returned _URC_FAILURE.  */\n-      return _URC_FAILURE;\n-    }\n-\n-  restore_core_regs (&saved_vrs.core);\n-}\n-\n-/* This is a very limited implementation of _Unwind_GetCFA.  It returns\n-   the stack pointer as it is about to be unwound, and is only valid\n-   while calling the stop function during forced unwinding.  If the\n-   current personality routine result is going to run a cleanup, this\n-   will not be the CFA; but when the frame is really unwound, it will\n-   be.  */\n-\n-_Unwind_Word\n-_Unwind_GetCFA (_Unwind_Context *context)\n-{\n-  return ((phase1_vrs *) context)->prev_sp;\n-}\n-\n-/* Perform phase1 unwinding.  UCBP is the exception being thrown, and\n-   entry_VRS is the register state on entry to _Unwind_RaiseException.  */\n-\n-_Unwind_Reason_Code\n-__gnu_Unwind_RaiseException (_Unwind_Control_Block *, phase2_vrs *);\n-\n-_Unwind_Reason_Code\n-__gnu_Unwind_RaiseException (_Unwind_Control_Block * ucbp,\n-\t\t\t     phase2_vrs * entry_vrs)\n-{\n-  phase1_vrs saved_vrs;\n-  _Unwind_Reason_Code pr_result;\n-\n-  /* Set the pc to the call site.  */\n-  entry_vrs->core.r[R_PC] = entry_vrs->core.r[R_LR];\n-\n-  /* Save the core registers.  */\n-  saved_vrs.core = entry_vrs->core;\n-  /* Set demand-save flags.  */\n-  saved_vrs.demand_save_flags = ~(_uw) 0;\n-  \n-  /* Unwind until we reach a propagation barrier.  */\n-  do\n-    {\n-      /* Find the entry for this routine.  */\n-      if (get_eit_entry (ucbp, saved_vrs.core.r[R_PC]) != _URC_OK)\n-\treturn _URC_FAILURE;\n-\n-      /* Call the pr to decide what to do.  */\n-      pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n-\t(_US_VIRTUAL_UNWIND_FRAME, ucbp, (void *) &saved_vrs);\n-    }\n-  while (pr_result == _URC_CONTINUE_UNWIND);\n-\n-  /* We've unwound as far as we want to go, so restore the original\n-     register state.  */\n-  restore_non_core_regs (&saved_vrs);\n-  if (pr_result != _URC_HANDLER_FOUND)\n-    {\n-      /* Some sort of failure has occurred in the pr and probably the\n-\t pr returned _URC_FAILURE.  */\n-      return _URC_FAILURE;\n-    }\n-  \n-  unwind_phase2 (ucbp, entry_vrs);\n-}\n-\n-/* Resume unwinding after a cleanup has been run.  UCBP is the exception\n-   being thrown and ENTRY_VRS is the register state on entry to\n-   _Unwind_Resume.  */\n-_Unwind_Reason_Code\n-__gnu_Unwind_ForcedUnwind (_Unwind_Control_Block *,\n-\t\t\t   _Unwind_Stop_Fn, void *, phase2_vrs *);\n-\n-_Unwind_Reason_Code\n-__gnu_Unwind_ForcedUnwind (_Unwind_Control_Block *ucbp,\n-\t\t\t   _Unwind_Stop_Fn stop_fn, void *stop_arg,\n-\t\t\t   phase2_vrs *entry_vrs)\n-{\n-  UCB_FORCED_STOP_FN (ucbp) = (_uw) stop_fn;\n-  UCB_FORCED_STOP_ARG (ucbp) = (_uw) stop_arg;\n-\n-  /* Set the pc to the call site.  */\n-  entry_vrs->core.r[R_PC] = entry_vrs->core.r[R_LR];\n-\n-  return unwind_phase2_forced (ucbp, entry_vrs, 0);\n-}\n-\n-_Unwind_Reason_Code\n-__gnu_Unwind_Resume (_Unwind_Control_Block *, phase2_vrs *);\n-\n-_Unwind_Reason_Code\n-__gnu_Unwind_Resume (_Unwind_Control_Block * ucbp, phase2_vrs * entry_vrs)\n-{\n-  _Unwind_Reason_Code pr_result;\n-\n-  /* Recover the saved address.  */\n-  entry_vrs->core.r[R_PC] = UCB_SAVED_CALLSITE_ADDR (ucbp);\n-\n-  if (UCB_FORCED_STOP_FN (ucbp))\n-    {\n-      unwind_phase2_forced (ucbp, entry_vrs, 1);\n-\n-      /* We can't return failure at this point.  */\n-      abort ();\n-    }\n-\n-  /* Call the cached PR.  */\n-  pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n-\t(_US_UNWIND_FRAME_RESUME, ucbp, (_Unwind_Context *) entry_vrs);\n-\n-  switch (pr_result)\n-    {\n-    case _URC_INSTALL_CONTEXT:\n-      /* Upload the registers to enter the landing pad.  */\n-      restore_core_regs (&entry_vrs->core);\n-\n-    case _URC_CONTINUE_UNWIND:\n-      /* Continue unwinding the next frame.  */\n-      unwind_phase2 (ucbp, entry_vrs);\n+    case 2:\n+      return (_uw) &__aeabi_unwind_cpp_pr2;\n \n     default:\n-      abort ();\n-    }\n-}\n-\n-_Unwind_Reason_Code\n-__gnu_Unwind_Resume_or_Rethrow (_Unwind_Control_Block *, phase2_vrs *);\n-\n-_Unwind_Reason_Code\n-__gnu_Unwind_Resume_or_Rethrow (_Unwind_Control_Block * ucbp,\n-\t\t\t\tphase2_vrs * entry_vrs)\n-{\n-  if (!UCB_FORCED_STOP_FN (ucbp))\n-    return __gnu_Unwind_RaiseException (ucbp, entry_vrs);\n-\n-  /* Set the pc to the call site.  */\n-  entry_vrs->core.r[R_PC] = entry_vrs->core.r[R_LR];\n-  /* Continue unwinding the next frame.  */\n-  return unwind_phase2_forced (ucbp, entry_vrs, 0);\n-}\n-\n-/* Clean up an exception object when unwinding is complete.  */\n-void\n-_Unwind_Complete (_Unwind_Control_Block * ucbp __attribute__((unused)))\n-{\n-}\n-\n-\n-/* Get the _Unwind_Control_Block from an _Unwind_Context.  */\n-\n-static inline _Unwind_Control_Block *\n-unwind_UCB_from_context (_Unwind_Context * context)\n-{\n-  return (_Unwind_Control_Block *) _Unwind_GetGR (context, R_IP);\n-}\n-\n-\n-/* Free an exception.  */\n-\n-void\n-_Unwind_DeleteException (_Unwind_Exception * exc)\n-{\n-  if (exc->exception_cleanup)\n-    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);\n-}\n-\n-\n-/* Perform stack backtrace through unwind data.  */\n-_Unwind_Reason_Code\n-__gnu_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument,\n-\t\t       phase2_vrs * entry_vrs);\n-_Unwind_Reason_Code\n-__gnu_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument,\n-\t\t       phase2_vrs * entry_vrs)\n-{\n-  phase1_vrs saved_vrs;\n-  _Unwind_Reason_Code code;\n-\n-  _Unwind_Control_Block ucb;\n-  _Unwind_Control_Block *ucbp = &ucb;\n-\n-  /* Set the pc to the call site.  */\n-  entry_vrs->core.r[R_PC] = entry_vrs->core.r[R_LR];\n-\n-  /* Save the core registers.  */\n-  saved_vrs.core = entry_vrs->core;\n-  /* Set demand-save flags.  */\n-  saved_vrs.demand_save_flags = ~(_uw) 0;\n-  \n-  do\n-    {\n-      /* Find the entry for this routine.  */\n-      if (get_eit_entry (ucbp, saved_vrs.core.r[R_PC]) != _URC_OK)\n-\t{\n-\t  code = _URC_FAILURE;\n-\t  break;\n-\t}\n-\n-      /* The dwarf unwinder assumes the context structure holds things\n-\t like the function and LSDA pointers.  The ARM implementation\n-\t caches these in the exception header (UCB).  To avoid\n-\t rewriting everything we make the virtual IP register point at\n-\t the UCB.  */\n-      _Unwind_SetGR((_Unwind_Context *)&saved_vrs, 12, (_Unwind_Ptr) ucbp);\n-\n-      /* Call trace function.  */\n-      if ((*trace) ((_Unwind_Context *) &saved_vrs, trace_argument) \n-\t  != _URC_NO_REASON)\n-\t{\n-\t  code = _URC_FAILURE;\n-\t  break;\n-\t}\n-\n-      /* Call the pr to decide what to do.  */\n-      code = ((personality_routine) UCB_PR_ADDR (ucbp))\n-\t(_US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND, \n-\t ucbp, (void *) &saved_vrs);\n-    }\n-  while (code != _URC_END_OF_STACK\n-\t && code != _URC_FAILURE);\n-\n-  restore_non_core_regs (&saved_vrs);\n-  return code;\n-}\n-\n-\n-/* Common implementation for ARM ABI defined personality routines.\n-   ID is the index of the personality routine, other arguments are as defined\n-   by __aeabi_unwind_cpp_pr{0,1,2}.  */\n-\n-static _Unwind_Reason_Code\n-__gnu_unwind_pr_common (_Unwind_State state,\n-\t\t\t_Unwind_Control_Block *ucbp,\n-\t\t\t_Unwind_Context *context,\n-\t\t\tint id)\n-{\n-  __gnu_unwind_state uws;\n-  _uw *data;\n-  _uw offset;\n-  _uw len;\n-  _uw rtti_count;\n-  int phase2_call_unexpected_after_unwind = 0;\n-  int in_range = 0;\n-  int forced_unwind = state & _US_FORCE_UNWIND;\n-\n-  state &= _US_ACTION_MASK;\n-\n-  data = (_uw *) ucbp->pr_cache.ehtp;\n-  uws.data = *(data++);\n-  uws.next = data;\n-  if (id == 0)\n-    {\n-      uws.data <<= 8;\n-      uws.words_left = 0;\n-      uws.bytes_left = 3;\n-    }\n-  else\n-    {\n-      uws.words_left = (uws.data >> 16) & 0xff;\n-      uws.data <<= 16;\n-      uws.bytes_left = 2;\n-      data += uws.words_left;\n-    }\n-\n-  /* Restore the saved pointer.  */\n-  if (state == _US_UNWIND_FRAME_RESUME)\n-    data = (_uw *) ucbp->cleanup_cache.bitpattern[0];\n-\n-  if ((ucbp->pr_cache.additional & 1) == 0)\n-    {\n-      /* Process descriptors.  */\n-      while (*data)\n-\t{\n-\t  _uw addr;\n-\t  _uw fnstart;\n-\n-\t  if (id == 2)\n-\t    {\n-\t      len = ((EHT32 *) data)->length;\n-\t      offset = ((EHT32 *) data)->offset;\n-\t      data += 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      len = ((EHT16 *) data)->length;\n-\t      offset = ((EHT16 *) data)->offset;\n-\t      data++;\n-\t    }\n-\n-\t  fnstart = ucbp->pr_cache.fnstart + (offset & ~1);\n-\t  addr = _Unwind_GetGR (context, R_PC);\n-\t  in_range = (fnstart <= addr && addr < fnstart + (len & ~1));\n-\n-\t  switch (((offset & 1) << 1) | (len & 1))\n-\t    {\n-\t    case 0:\n-\t      /* Cleanup.  */\n-\t      if (state != _US_VIRTUAL_UNWIND_FRAME\n-\t\t  && in_range)\n-\t\t{\n-\t\t  /* Cleanup in range, and we are running cleanups.  */\n-\t\t  _uw lp;\n-\n-\t\t  /* Landing pad address is 31-bit pc-relative offset.  */\n-\t\t  lp = selfrel_offset31 (data);\n-\t\t  data++;\n-\t\t  /* Save the exception data pointer.  */\n-\t\t  ucbp->cleanup_cache.bitpattern[0] = (_uw) data;\n-\t\t  if (!__cxa_begin_cleanup (ucbp))\n-\t\t    return _URC_FAILURE;\n-\t\t  /* Setup the VRS to enter the landing pad.  */\n-\t\t  _Unwind_SetGR (context, R_PC, lp);\n-\t\t  return _URC_INSTALL_CONTEXT;\n-\t\t}\n-\t      /* Cleanup not in range, or we are in stage 1.  */\n-\t      data++;\n-\t      break;\n-\n-\t    case 1:\n-\t      /* Catch handler.  */\n-\t      if (state == _US_VIRTUAL_UNWIND_FRAME)\n-\t\t{\n-\t\t  if (in_range)\n-\t\t    {\n-\t\t      /* Check for a barrier.  */\n-\t\t      _uw rtti;\n-\t\t      bool is_reference = (data[0] & uint32_highbit) != 0;\n-\t\t      void *matched;\n-\t\t      enum __cxa_type_match_result match_type;\n-\n-\t\t      /* Check for no-throw areas.  */\n-\t\t      if (data[1] == (_uw) -2)\n-\t\t\treturn _URC_FAILURE;\n-\n-\t\t      /* The thrown object immediately follows the ECB.  */\n-\t\t      matched = (void *)(ucbp + 1);\n-\t\t      if (data[1] != (_uw) -1)\n-\t\t\t{\n-\t\t\t  /* Match a catch specification.  */\n-\t\t\t  rtti = _Unwind_decode_target2 ((_uw) &data[1]);\n-\t\t\t  match_type = __cxa_type_match (ucbp,\n-\t\t\t\t\t\t\t (type_info *) rtti,\n-\t\t\t\t\t\t\t is_reference,\n-\t\t\t\t\t\t\t &matched);\n-\t\t\t}\n-\t\t      else\n-\t\t\tmatch_type = ctm_succeeded;\n-\n-\t\t      if (match_type)\n-\t\t\t{\n-\t\t\t  ucbp->barrier_cache.sp =\n-\t\t\t    _Unwind_GetGR (context, R_SP);\n-\t\t\t  // ctm_succeeded_with_ptr_to_base really\n-\t\t\t  // means _c_t_m indirected the pointer\n-\t\t\t  // object.  We have to reconstruct the\n-\t\t\t  // additional pointer layer by using a temporary.\n-\t\t\t  if (match_type == ctm_succeeded_with_ptr_to_base)\n-\t\t\t    {\n-\t\t\t      ucbp->barrier_cache.bitpattern[2]\n-\t\t\t\t= (_uw) matched;\n-\t\t\t      ucbp->barrier_cache.bitpattern[0]\n-\t\t\t\t= (_uw) &ucbp->barrier_cache.bitpattern[2];\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    ucbp->barrier_cache.bitpattern[0] = (_uw) matched;\n-\t\t\t  ucbp->barrier_cache.bitpattern[1] = (_uw) data;\n-\t\t\t  return _URC_HANDLER_FOUND;\n-\t\t\t}\n-\t\t    }\n-\t\t  /* Handler out of range, or not matched.  */\n-\t\t}\n-\t      else if (ucbp->barrier_cache.sp == _Unwind_GetGR (context, R_SP)\n-\t\t       && ucbp->barrier_cache.bitpattern[1] == (_uw) data)\n-\t\t{\n-\t\t  /* Matched a previous propagation barrier.  */\n-\t\t  _uw lp;\n-\n-\t\t  /* Setup for entry to the handler.  */\n-\t\t  lp = selfrel_offset31 (data);\n-\t\t  _Unwind_SetGR (context, R_PC, lp);\n-\t\t  _Unwind_SetGR (context, 0, (_uw) ucbp);\n-\t\t  return _URC_INSTALL_CONTEXT;\n-\t\t}\n-\t      /* Catch handler not matched.  Advance to the next descriptor.  */\n-\t      data += 2;\n-\t      break;\n-\n-\t    case 2:\n-\t      rtti_count = data[0] & 0x7fffffff;\n-\t      /* Exception specification.  */\n-\t      if (state == _US_VIRTUAL_UNWIND_FRAME)\n-\t\t{\n-\t\t  if (in_range && (!forced_unwind || !rtti_count))\n-\t\t    {\n-\t\t      /* Match against the exception specification.  */\n-\t\t      _uw i;\n-\t\t      _uw rtti;\n-\t\t      void *matched;\n-\n-\t\t      for (i = 0; i < rtti_count; i++)\n-\t\t\t{\n-\t\t\t  matched = (void *)(ucbp + 1);\n-\t\t\t  rtti = _Unwind_decode_target2 ((_uw) &data[i + 1]);\n-\t\t\t  if (__cxa_type_match (ucbp, (type_info *) rtti, 0,\n-\t\t\t\t\t\t&matched))\n-\t\t\t    break;\n-\t\t\t}\n-\n-\t\t      if (i == rtti_count)\n-\t\t\t{\n-\t\t\t  /* Exception does not match the spec.  */\n-\t\t\t  ucbp->barrier_cache.sp =\n-\t\t\t    _Unwind_GetGR (context, R_SP);\n-\t\t\t  ucbp->barrier_cache.bitpattern[0] = (_uw) matched;\n-\t\t\t  ucbp->barrier_cache.bitpattern[1] = (_uw) data;\n-\t\t\t  return _URC_HANDLER_FOUND;\n-\t\t\t}\n-\t\t    }\n-\t\t  /* Handler out of range, or exception is permitted.  */\n-\t\t}\n-\t      else if (ucbp->barrier_cache.sp == _Unwind_GetGR (context, R_SP)\n-\t\t       && ucbp->barrier_cache.bitpattern[1] == (_uw) data)\n-\t\t{\n-\t\t  /* Matched a previous propagation barrier.  */\n-\t\t  _uw lp;\n-\t\t  /* Record the RTTI list for __cxa_call_unexpected.  */\n-\t\t  ucbp->barrier_cache.bitpattern[1] = rtti_count;\n-\t\t  ucbp->barrier_cache.bitpattern[2] = 0;\n-\t\t  ucbp->barrier_cache.bitpattern[3] = 4;\n-\t\t  ucbp->barrier_cache.bitpattern[4] = (_uw) &data[1];\n-\n-\t\t  if (data[0] & uint32_highbit)\n-\t\t    {\n-\t\t      data += rtti_count + 1;\n-\t\t      /* Setup for entry to the handler.  */\n-\t\t      lp = selfrel_offset31 (data);\n-\t\t      data++;\n-\t\t      _Unwind_SetGR (context, R_PC, lp);\n-\t\t      _Unwind_SetGR (context, 0, (_uw) ucbp);\n-\t\t      return _URC_INSTALL_CONTEXT;\n-\t\t    }\n-\t\t  else\n-\t\t    phase2_call_unexpected_after_unwind = 1;\n-\t\t}\n-\t      if (data[0] & uint32_highbit)\n-\t\tdata++;\n-\t      data += rtti_count + 1;\n-\t      break;\n-\n-\t    default:\n-\t      /* Should never happen.  */\n-\t      return _URC_FAILURE;\n-\t    }\n-\t  /* Finished processing this descriptor.  */\n-\t}\n-    }\n-\n-  if (__gnu_unwind_execute (context, &uws) != _URC_OK)\n-    return _URC_FAILURE;\n-\n-  if (phase2_call_unexpected_after_unwind)\n-    {\n-      /* Enter __cxa_unexpected as if called from the call site.  */\n-      _Unwind_SetGR (context, R_LR, _Unwind_GetGR (context, R_PC));\n-      _Unwind_SetGR (context, R_PC, (_uw) &__cxa_call_unexpected);\n-      return _URC_INSTALL_CONTEXT;\n-    }\n-\n-  return _URC_CONTINUE_UNWIND;\n+      return 0;\n+    } \n }\n \n-\n /* ABI defined personality routine entry points.  */\n \n _Unwind_Reason_Code"}, {"sha": "4300c8e31c65e4e894a1eb38246eff36499affeb", "filename": "libgcc/config/arm/unwind-arm.h", "status": "modified", "additions": 12, "deletions": 210, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Farm%2Funwind-arm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Farm%2Funwind-arm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Funwind-arm.h?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -28,198 +28,18 @@\n #ifndef UNWIND_ARM_H\n #define UNWIND_ARM_H\n \n-#define __ARM_EABI_UNWINDER__ 1\n+#include \"unwind-arm-common.h\"\n+\n+#define UNWIND_STACK_REG 13\n+/* Use IP as a scratch register within the personality routine.  */\n+#define UNWIND_POINTER_REG 12\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-  typedef unsigned _Unwind_Word __attribute__((__mode__(__word__)));\n-  typedef signed _Unwind_Sword __attribute__((__mode__(__word__)));\n-  typedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));\n-  typedef unsigned _Unwind_Internal_Ptr __attribute__((__mode__(__pointer__)));\n-  typedef _Unwind_Word _uw;\n-  typedef unsigned _uw64 __attribute__((mode(__DI__)));\n-  typedef unsigned _uw16 __attribute__((mode(__HI__)));\n-  typedef unsigned _uw8 __attribute__((mode(__QI__)));\n-\n-  typedef enum\n-    {\n-      _URC_OK = 0,       /* operation completed successfully */\n-      _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n-      _URC_END_OF_STACK = 5,\n-      _URC_HANDLER_FOUND = 6,\n-      _URC_INSTALL_CONTEXT = 7,\n-      _URC_CONTINUE_UNWIND = 8,\n-      _URC_FAILURE = 9   /* unspecified failure of some kind */\n-    }\n-  _Unwind_Reason_Code;\n-\n-  typedef enum\n-    {\n-      _US_VIRTUAL_UNWIND_FRAME = 0,\n-      _US_UNWIND_FRAME_STARTING = 1,\n-      _US_UNWIND_FRAME_RESUME = 2,\n-      _US_ACTION_MASK = 3,\n-      _US_FORCE_UNWIND = 8,\n-      _US_END_OF_STACK = 16\n-    }\n-  _Unwind_State;\n-\n-  /* Provided only for compatibility with existing code.  */\n-  typedef int _Unwind_Action;\n-#define _UA_SEARCH_PHASE\t1\n-#define _UA_CLEANUP_PHASE\t2\n-#define _UA_HANDLER_FRAME\t4\n-#define _UA_FORCE_UNWIND\t8\n-#define _UA_END_OF_STACK\t16\n-#define _URC_NO_REASON \t_URC_OK\n-\n-  typedef struct _Unwind_Control_Block _Unwind_Control_Block;\n-  typedef struct _Unwind_Context _Unwind_Context;\n-  typedef _uw _Unwind_EHT_Header;\n-\n-\n-  /* UCB: */\n-\n-  struct _Unwind_Control_Block\n-    {\n-      char exception_class[8];\n-      void (*exception_cleanup)(_Unwind_Reason_Code, _Unwind_Control_Block *);\n-      /* Unwinder cache, private fields for the unwinder's use */\n-      struct\n-\t{\n-\t  _uw reserved1;  /* Forced unwind stop fn, 0 if not forced */\n-\t  _uw reserved2;  /* Personality routine address */\n-\t  _uw reserved3;  /* Saved callsite address */\n-\t  _uw reserved4;  /* Forced unwind stop arg */\n-\t  _uw reserved5;\n-\t}\n-      unwinder_cache;\n-      /* Propagation barrier cache (valid after phase 1): */\n-      struct\n-\t{\n-\t  _uw sp;\n-\t  _uw bitpattern[5];\n-\t}\n-      barrier_cache;\n-      /* Cleanup cache (preserved over cleanup): */\n-      struct\n-\t{\n-\t  _uw bitpattern[4];\n-\t}\n-      cleanup_cache;\n-      /* Pr cache (for pr's benefit): */\n-      struct\n-\t{\n-\t  _uw fnstart;\t\t\t/* function start address */\n-\t  _Unwind_EHT_Header *ehtp;\t/* pointer to EHT entry header word */\n-\t  _uw additional;\t\t/* additional data */\n-\t  _uw reserved1;\n-\t}\n-      pr_cache;\n-      long long int :0;\t/* Force alignment to 8-byte boundary */\n-    };\n-\n-  /* Virtual Register Set*/\n-\n-  typedef enum\n-    {\n-      _UVRSC_CORE = 0,      /* integer register */\n-      _UVRSC_VFP = 1,       /* vfp */\n-      _UVRSC_FPA = 2,       /* fpa */\n-      _UVRSC_WMMXD = 3,     /* Intel WMMX data register */\n-      _UVRSC_WMMXC = 4      /* Intel WMMX control register */\n-    }\n-  _Unwind_VRS_RegClass;\n-\n-  typedef enum\n-    {\n-      _UVRSD_UINT32 = 0,\n-      _UVRSD_VFPX = 1,\n-      _UVRSD_FPAX = 2,\n-      _UVRSD_UINT64 = 3,\n-      _UVRSD_FLOAT = 4,\n-      _UVRSD_DOUBLE = 5\n-    }\n-  _Unwind_VRS_DataRepresentation;\n-\n-  typedef enum\n-    {\n-      _UVRSR_OK = 0,\n-      _UVRSR_NOT_IMPLEMENTED = 1,\n-      _UVRSR_FAILED = 2\n-    }\n-  _Unwind_VRS_Result;\n-\n-  /* Frame unwinding state.  */\n-  typedef struct\n-    {\n-      /* The current word (bytes packed msb first).  */\n-      _uw data;\n-      /* Pointer to the next word of data.  */\n-      _uw *next;\n-      /* The number of bytes left in this word.  */\n-      _uw8 bytes_left;\n-      /* The number of words pointed to by ptr.  */\n-      _uw8 words_left;\n-    }\n-  __gnu_unwind_state;\n-\n-  typedef _Unwind_Reason_Code (*personality_routine) (_Unwind_State,\n-      _Unwind_Control_Block *, _Unwind_Context *);\n-\n-  _Unwind_VRS_Result _Unwind_VRS_Set(_Unwind_Context *, _Unwind_VRS_RegClass,\n-                                     _uw, _Unwind_VRS_DataRepresentation,\n-                                     void *);\n-\n-  _Unwind_VRS_Result _Unwind_VRS_Get(_Unwind_Context *, _Unwind_VRS_RegClass,\n-                                     _uw, _Unwind_VRS_DataRepresentation,\n-                                     void *);\n-\n-  _Unwind_VRS_Result _Unwind_VRS_Pop(_Unwind_Context *, _Unwind_VRS_RegClass,\n-                                     _uw, _Unwind_VRS_DataRepresentation);\n-\n-\n-  /* Support functions for the PR.  */\n-#define _Unwind_Exception _Unwind_Control_Block\n-  typedef char _Unwind_Exception_Class[8];\n-\n-  void * _Unwind_GetLanguageSpecificData (_Unwind_Context *);\n-  _Unwind_Ptr _Unwind_GetRegionStart (_Unwind_Context *);\n-\n-  /* These two should never be used.  */\n-  _Unwind_Ptr _Unwind_GetDataRelBase (_Unwind_Context *);\n-  _Unwind_Ptr _Unwind_GetTextRelBase (_Unwind_Context *);\n-\n-  /* Interface functions: */\n-  _Unwind_Reason_Code _Unwind_RaiseException(_Unwind_Control_Block *ucbp);\n-  void __attribute__((noreturn)) _Unwind_Resume(_Unwind_Control_Block *ucbp);\n-  _Unwind_Reason_Code _Unwind_Resume_or_Rethrow (_Unwind_Control_Block *ucbp);\n-\n-  typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)\n-       (int, _Unwind_Action, _Unwind_Exception_Class,\n-\t_Unwind_Control_Block *, struct _Unwind_Context *, void *);\n-  _Unwind_Reason_Code _Unwind_ForcedUnwind (_Unwind_Control_Block *,\n-\t\t\t\t\t    _Unwind_Stop_Fn, void *);\n-  /* @@@ Use unwind data to perform a stack backtrace.  The trace callback\n-     is called for every stack frame in the call chain, but no cleanup\n-     actions are performed.  */\n-  typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn) (_Unwind_Context *, void *);\n-  _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn,\n-\t\t\t\t\tvoid*);\n-\n-  _Unwind_Word _Unwind_GetCFA (struct _Unwind_Context *);\n-  void _Unwind_Complete(_Unwind_Control_Block *ucbp);\n-  void _Unwind_DeleteException (_Unwind_Exception *);\n-\n-  _Unwind_Reason_Code __gnu_unwind_frame (_Unwind_Control_Block *,\n-\t\t\t\t\t  _Unwind_Context *);\n-  _Unwind_Reason_Code __gnu_unwind_execute (_Unwind_Context *,\n-\t\t\t\t\t    __gnu_unwind_state *);\n-\n   /* Decode an R_ARM_TARGET2 relocation.  */\n   static inline _Unwind_Word\n-  _Unwind_decode_target2 (_Unwind_Word ptr)\n+  _Unwind_decode_typeinfo_ptr (_Unwind_Word base, _Unwind_Word ptr)\n     {\n       _Unwind_Word tmp;\n \n@@ -230,50 +50,32 @@ extern \"C\" {\n \n #if (defined(linux) && !defined(__uClinux__)) || defined(__NetBSD__)\n       /* Pc-relative indirect.  */\n+#define _GLIBCXX_OVERRIDE_TTYPE_ENCODING (DW_EH_PE_pcrel | DW_EH_PE_indirect)\n       tmp += ptr;\n       tmp = *(_Unwind_Word *) tmp;\n #elif defined(__symbian__) || defined(__uClinux__)\n+#define _GLIBCXX_OVERRIDE_TTYPE_ENCODING (DW_EH_PE_absptr)\n       /* Absolute pointer.  Nothing more to do.  */\n #else\n+#define _GLIBCXX_OVERRIDE_TTYPE_ENCODING (DW_EH_PE_pcrel)\n       /* Pc-relative pointer.  */\n       tmp += ptr;\n #endif\n       return tmp;\n     }\n \n-  static inline _Unwind_Word\n-  _Unwind_GetGR (_Unwind_Context *context, int regno)\n+  static inline _Unwind_Reason_Code\n+  __gnu_unwind_24bit (_Unwind_Context * context, _uw data, int compact)\n     {\n-      _uw val;\n-      _Unwind_VRS_Get (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);\n-      return val;\n+      return _URC_FAILURE;\n     }\n-\n   /* Return the address of the instruction, not the actual IP value.  */\n #define _Unwind_GetIP(context) \\\n   (_Unwind_GetGR (context, 15) & ~(_Unwind_Word)1)\n \n-#define _Unwind_GetIPInfo(context, ip_before_insn) \\\n-  (*ip_before_insn = 0, _Unwind_GetGR (context, 15) & ~(_Unwind_Word)1)\n-\n-  static inline void\n-  _Unwind_SetGR (_Unwind_Context *context, int regno, _Unwind_Word val)\n-    {\n-      _Unwind_VRS_Set (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);\n-    }\n-\n-  /* The dwarf unwinder doesn't understand arm/thumb state.  We assume the\n-     landing pad uses the same instruction set as the call site.  */\n #define _Unwind_SetIP(context, val) \\\n   _Unwind_SetGR (context, 15, val | (_Unwind_GetGR (context, 15) & 1))\n \n-/* leb128 type numbers have a potentially unlimited size.\n-   The target of the following definitions of _sleb128_t and _uleb128_t\n-   is to have efficient data types large enough to hold the leb128 type\n-   numbers used in the unwind code.  */\n-typedef long _sleb128_t;\n-typedef unsigned long _uleb128_t;\n-\n #ifdef __cplusplus\n }   /* extern \"C\" */\n #endif"}, {"sha": "d37ea5730bf7f5e011d9d573f8286627a7c3089a", "filename": "libgcc/config/c6x/libunwind.S", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Flibunwind.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Flibunwind.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fc6x%2Flibunwind.S?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -0,0 +1,133 @@\n+.text\n+.macro do_call fn\n+#ifdef _TMS320C6400_PLUS\n+\tcallp\t.s2\t(\\fn), B3\n+#elif defined(_TMS320C6400)\n+\tcall\t.s2\t(\\fn)\n+\taddkpc\t.s2\t9f, B3, 0\n+\tnop\t\t4\n+9f:\n+#else\n+\tcall\t.s2\t(\\fn)\n+\tmhkl\t.s2\t9f, B3\n+\tmhkh\t.s2\t9f, B3\n+\tnop\t\t3\n+9f:\n+#endif\n+.endm\n+.align 2\n+.global restore_core_regs\n+.type restore_core_regs, STT_FUNC\n+restore_core_regs:\n+\tmv\t.s2x\tA4, B4\n+\tldw\t.d1t1\t*+A4[0], A0\n+\t|| ldw\t.d2t2\t*++B4[16], B0\n+\tldw\t.d1t1\t*+A4[1], A1\n+\t|| ldw\t.d2t2\t*+B4[1], B1\n+\tldw\t.d1t1\t*+A4[2], A2\n+\t|| ldw\t.d2t2\t*+B4[2], B2\n+\tldw\t.d1t1\t*+A4[3], A3\n+\t|| ldw\t.d2t2\t*+B4[3], B3\n+\t;; Base registers are loaded later\n+\tldw\t.d1t1\t*+A4[5], A5\n+\t|| ldw\t.d2t2\t*+B4[5], B5\n+\tldw\t.d1t1\t*+A4[6], A6\n+\t|| ldw\t.d2t2\t*+B4[6], B6\n+\tldw\t.d1t1\t*+A4[7], A7\n+\t|| ldw\t.d2t2\t*+B4[7], B7\n+\tldw\t.d1t1\t*+A4[8], A8\n+\t|| ldw\t.d2t2\t*+B4[8], B8\n+\tldw\t.d1t1\t*+A4[9], A9\n+\t|| ldw\t.d2t2\t*+B4[9], B9\n+\t;; load PC into B10 so that it is ready for the branch\n+\tldw\t.d2t2\t*+B4[16], B10\n+\tldw\t.d1t1\t*+A4[11], A11\n+\t|| ldw\t.d2t2\t*+B4[11], B11\n+\tldw\t.d1t1\t*+A4[12], A12\n+\t|| ldw\t.d2t2\t*+B4[12], B12\n+\tldw\t.d1t1\t*+A4[13], A13\n+\t|| ldw\t.d2t2\t*+B4[13], B13\n+\tldw\t.d1t1\t*+A4[14], A14\n+\t|| ldw\t.d2t2\t*+B4[14], B14\n+\t;; Loads have 4 delay slots.  Take advantage of this to restore the\n+\t;; scratch registers and stack pointer before the base registers\n+\t;; disappear.  We also need to make sure no interrupts occur,\n+\t;; so put the whole thing in the delay slots of a dummy branch\n+\t;; We can not move the ret earlier as that would cause it to occur\n+\t;; before the last load completes\n+\tb\t.s1\t(1f)\n+\tldw\t.d1t1\t*+A4[4], A4\n+\t|| ldw\t.d2t2\t*+B4[4], B4\n+\tldw\t.d1t1\t*+A4[15], A15\n+\t|| ldw\t.d2t2\t*+B4[15], B15\n+\tret\t.s2\tB10\n+\tldw\t.d1t1\t*+A4[10], A10\n+\t|| ldw\t.d2t2\t*+B4[10], B10\n+\tnop\t\t1\n+1:\n+\tnop\t\t3\n+.size restore_core_regs, . - restore_core_regs\n+\n+.macro UNWIND_WRAPPER name argreg argside\n+.global \\name\n+.type \\name, STT_FUNC\n+\\name:\n+\t# Create saved register state: flags,A0-A15,B0-B15,PC = 136 bytes.\n+\t# Plus 4 (rounded to 8) for saving return.\n+\taddk\t.s2\t-144, B15\n+\tstw\t.d2t1\tA0, *+B15[2]\n+\tstw\t.d2t1\tA1, *+B15[3]\n+\tstw\t.d2t1\tA2, *+B15[4]\n+\tstw\t.d2t1\tA3, *+B15[5]\n+\tstw\t.d2t1\tA4, *+B15[6]\n+\tstw\t.d2t1\tA5, *+B15[7]\n+\tstw\t.d2t1\tA6, *+B15[8]\n+\tstw\t.d2t1\tA7, *+B15[9]\n+\tstw\t.d2t1\tA8, *+B15[10]\n+\tstw\t.d2t1\tA9, *+B15[11]\n+\tstw\t.d2t1\tA10, *+B15[12]\n+\tstw\t.d2t1\tA11, *+B15[13]\n+\tstw\t.d2t1\tA12, *+B15[14]\n+\tstw\t.d2t1\tA13, *+B15[15]\n+\tstw\t.d2t1\tA14, *+B15[16]\n+\tstw\t.d2t1\tA15, *+B15[17]\n+\tmv\t.s1x\tB15, A0\n+\taddk\t.s1\t144, A0\n+\tstw\t.d2t2\tB0, *+B15[18]\n+\tstw\t.d2t2\tB1, *+B15[19]\n+\tstw\t.d2t2\tB2, *+B15[20]\n+\tstw\t.d2t2\tB3, *+B15[21]\n+\tstw\t.d2t2\tB4, *+B15[22]\n+\tstw\t.d2t2\tB5, *+B15[23]\n+\tstw\t.d2t2\tB6, *+B15[24]\n+\tstw\t.d2t2\tB7, *+B15[25]\n+\tstw\t.d2t2\tB8, *+B15[26]\n+\tstw\t.d2t2\tB9, *+B15[27]\n+\tstw\t.d2t2\tB10, *+B15[28]\n+\tstw\t.d2t2\tB11, *+B15[29]\n+\tstw\t.d2t2\tB12, *+B15[30]\n+\tstw\t.d2t2\tB13, *+B15[31]\n+\tstw\t.d2t2\tB14, *+B15[32]\n+\tstw\t.d2t1\tA0, *+B15[33]\n+\tstw\t.d2t1\tA0, *+B15[34]\n+\t# Zero demand saved flags\n+\tmvk\t.s1\t0, A0\n+\tstw\t.d2t1\tA0, *+B15[1]\n+\t# Save return address, setup additional argument and call fucntion\n+\tstw\t.d2t2\tB3, *+B15[35]\n+\tadd\t.d\\argside\tB15, 4, \\argreg\n+\tdo_call\t__gnu\\name\n+\t# Restore stack and return\n+\tldw\t.d2t2\t*+B15[35], B3\n+\taddk\t.s2\t144, B15\n+\tnop\t\t3\n+\tret\t.s2\tB3\n+\tnop\t\t5\n+.size \\name, . - \\name\n+.endm\n+\n+UNWIND_WRAPPER _Unwind_RaiseException B4 2\n+UNWIND_WRAPPER _Unwind_Resume B4 2\n+UNWIND_WRAPPER _Unwind_Resume_or_Rethrow B4 2\n+UNWIND_WRAPPER _Unwind_ForcedUnwind B6 2\n+UNWIND_WRAPPER _Unwind_Backtrace A6 1x"}, {"sha": "6375013cb6624aaa7481dd9d4af9d1c000c29303", "filename": "libgcc/config/c6x/pr-support.c", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Fpr-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Fpr-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fc6x%2Fpr-support.c?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -0,0 +1,534 @@\n+/* C6X ABI compliant unwinding routines\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+ \n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"unwind.h\"\n+\n+/* We add a prototype for abort here to avoid creating a dependency on\n+   target headers.  */\n+extern void abort (void);\n+\n+typedef struct _ZSt9type_info type_info; /* This names C++ type_info type */\n+\n+/* Misc constants.  */\n+#define R_A0 0\n+#define R_A1 1\n+#define R_A2 2\n+#define R_A3 3\n+#define R_A4 4\n+#define R_A5 5\n+#define R_A6 6\n+#define R_A7 7\n+#define R_A8 8\n+#define R_A9 9\n+#define R_A10 10\n+#define R_A11 11\n+#define R_A12 12\n+#define R_A13 13\n+#define R_A14 14\n+#define R_A15 15\n+#define R_B0 16\n+#define R_B1 17\n+#define R_B2 18\n+#define R_B3 19\n+#define R_B4 20\n+#define R_B5 21\n+#define R_B6 22\n+#define R_B7 23\n+#define R_B8 24\n+#define R_B9 25\n+#define R_B10 26\n+#define R_B11 27\n+#define R_B12 28\n+#define R_B13 29\n+#define R_B14 30\n+#define R_B15 31\n+\n+#define R_SP R_B15\n+#define R_PC 33\n+\n+#define uint32_highbit (((_uw) 1) << 31)\n+\n+void __attribute__((weak)) __cxa_call_unexpected(_Unwind_Control_Block *ucbp);\n+\n+/* Unwind descriptors.  */\n+\n+typedef struct\n+{\n+  _uw16 length;\n+  _uw16 offset;\n+} EHT16;\n+\n+typedef struct\n+{\n+  _uw length;\n+  _uw offset;\n+} EHT32;\n+\n+/* Calculate the address encoded by a 31-bit self-relative offset at address\n+   P.  Copy of routine in unwind-arm.c.  */\n+\n+static inline _uw\n+selfrel_offset31 (const _uw *p)\n+{\n+  _uw offset;\n+\n+  offset = *p;\n+  /* Sign extend to 32 bits.  */\n+  if (offset & (1 << 30))\n+    offset |= 1u << 31;\n+\n+  return offset + (_uw) p;\n+}\n+\n+\n+/* Personality routine helper functions.  */\n+\n+#define CODE_FINISH (0xe7)\n+\n+/* Return the next byte of unwinding information, or CODE_FINISH if there is\n+   no data remaining.  */\n+static inline _uw8\n+next_unwind_byte (__gnu_unwind_state * uws)\n+{\n+  _uw8 b;\n+\n+  if (uws->bytes_left == 0)\n+    {\n+      /* Load another word */\n+      if (uws->words_left == 0)\n+\treturn CODE_FINISH; /* Nothing left.  */\n+      uws->words_left--;\n+      uws->data = *(uws->next++);\n+      uws->bytes_left = 3;\n+    }\n+  else\n+    uws->bytes_left--;\n+\n+  /* Extract the most significant byte.  */\n+  b = (uws->data >> 24) & 0xff;\n+  uws->data <<= 8;\n+  return b;\n+}\n+\n+static void\n+unwind_restore_pair (_Unwind_Context * context, int reg, _uw *ptr)\n+{\n+#ifdef _BIG_ENDIAN\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, reg, _UVRSD_UINT32, ptr + 1);\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, reg + 1, _UVRSD_UINT32, ptr);\n+#else\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, reg, _UVRSD_UINT32, ptr);\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, reg + 1, _UVRSD_UINT32, ptr + 1);\n+#endif\n+}\n+\n+static const int\n+unwind_frame_regs[13] = \n+{\n+  R_A15, R_B15, R_B14, R_B13, R_B12, R_B11, R_B10, R_B3,\n+  R_A14, R_A13, R_A12, R_A11, R_A10\n+};\n+\n+static void\n+pop_compact_frame (_Unwind_Context * context, _uw mask, _uw *ptr, int inc_sp)\n+{\n+  int size;\n+  _uw test;\n+  int i;\n+  int regno;\n+  int regno2;\n+  int nregs;\n+\n+  size = 0;\n+  nregs = __builtin_popcount (mask);\n+  for (i = 0; i < 13; i++)\n+    {\n+      test = 1 << i;\n+      if ((mask & test) == 0)\n+\tcontinue;\n+\n+      regno = unwind_frame_regs[12 - i];\n+      /* The last slot is a sigle word, so cannot store a register pair.  */\n+      if (nregs > 2)\n+\tregno2 = unwind_frame_regs[13 - i];\n+      else\n+\tregno2 = 0xff;\n+\n+      if ((mask & (test << 1)) != 0 && regno2 == regno + 1 && (regno & 1) == 0)\n+\t{\n+\t  i++;\n+\t  nregs--;\n+\t}\n+\n+      nregs--;\n+      size += 2;\n+    }\n+\n+  if (!inc_sp)\n+    ptr -= size;\n+\n+  /* SP points just past the end of the stack.  */\n+  ptr += 2;\n+  nregs = __builtin_popcount (mask);\n+  for (i = 0; i < 13; i++)\n+    {\n+      test = 1 << i;\n+      if ((mask & test) == 0)\n+\tcontinue;\n+\n+      regno = unwind_frame_regs[12 - i];\n+      if (nregs > 2)\n+\tregno2 = unwind_frame_regs[13 - i];\n+      else\n+\tregno2 = 0xff;\n+\n+      if ((mask & (test << 1)) != 0 && regno2 == regno + 1 && (regno & 1) == 0)\n+\t{\n+\t  /* Register pair.  */\n+\t  unwind_restore_pair (context, regno, ptr);\n+\t  i++;\n+\t  nregs--;\n+\t}\n+      else\n+\t{\n+\t  /* Single register with padding.  */\n+\t  _Unwind_VRS_Set (context, _UVRSC_CORE, regno, _UVRSD_UINT32, ptr);\n+\t}\n+\n+      nregs--;\n+      ptr += 2;\n+    }\n+\n+  ptr -= 2;\n+  if ((mask & (1 << 11)) == 0)\n+    _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &ptr);\n+}\n+\n+static void\n+pop_frame (_Unwind_Context * context, _uw mask, _uw *ptr, int inc_sp)\n+{\n+  int i;\n+  int regno;\n+  int nregs;\n+\n+  nregs = __builtin_popcount (mask);\n+\n+  if (!inc_sp)\n+    ptr -= nregs;\n+  else if (nregs & 1)\n+    ptr++;\n+\n+  ptr++;\n+  for (i = 0; i < 13; i++)\n+    {\n+      if ((mask & (1 << i)) == 0)\n+\tcontinue;\n+      regno = unwind_frame_regs[12 - i];\n+      if (i < 12 && unwind_frame_regs[13 - i] == (regno + 1)\n+\t  && (mask & (1 << (i + 1))) != 0\n+\t  && (((_uw)ptr) & 4) == 0\n+\t  && (regno & 1) == 0)\n+\t{\n+\t  unwind_restore_pair (context, regno, ptr);\n+\t  i++;\n+\t  ptr += 2;\n+\t}\n+      else\n+\t{\n+\t  _Unwind_VRS_Set (context, _UVRSC_CORE, regno, _UVRSD_UINT32,\n+\t\t\t   ptr);\n+\t  ptr++;\n+\t}\n+    }\n+\n+  ptr--;\n+  if ((mask & (1 << 11)) == 0)\n+    _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &ptr);\n+}\n+\n+/* Unwind a 24-bit encoded frame.  */\n+_Unwind_Reason_Code\n+__gnu_unwind_24bit (_Unwind_Context * context, _uw data, int compact)\n+{\n+  _uw offset;\n+  _uw mask;\n+  _uw *ptr;\n+  _uw tmp;\n+\n+  mask = (data >> 4) & 0x1fff;\n+\n+  offset = (data >> 17) & 0x7f;\n+  if (offset == 0x7f)\n+    _Unwind_VRS_Get (context, _UVRSC_CORE, R_A15, _UVRSD_UINT32, &ptr);\n+  else\n+    {\n+      _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &ptr);\n+      ptr += offset * 2;\n+    }\n+\n+\n+  if (compact)\n+    pop_compact_frame (context, mask, ptr, offset != 0x7f);\n+  else\n+    pop_frame (context, mask, ptr, offset != 0x7f);\n+\n+  _Unwind_VRS_Get (context, _UVRSC_CORE, unwind_frame_regs[data & 0xf],\n+\t\t   _UVRSD_UINT32, &tmp);\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, R_PC, _UVRSD_UINT32, &tmp);\n+\n+  return _URC_OK;\n+}\n+\n+static void\n+unwind_pop_rts (_Unwind_Context * context)\n+{\n+  _uw *ptr;\n+\n+  _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &ptr);\n+#ifdef _BIG_ENDIAN\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, R_B3, _UVRSD_UINT32, ptr + 1);\n+#else\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, R_B3, _UVRSD_UINT32, ptr + 2);\n+#endif\n+  ptr += 3;\n+  unwind_restore_pair (context, R_A10, ptr);\n+  ptr += 2;\n+  unwind_restore_pair (context, R_B10, ptr);\n+  ptr += 2;\n+  unwind_restore_pair (context, R_A12, ptr);\n+  ptr += 2;\n+  unwind_restore_pair (context, R_B12, ptr);\n+  ptr += 2;\n+  unwind_restore_pair (context, R_A14, ptr);\n+  ptr += 2;\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, R_B14, _UVRSD_UINT32, ptr);\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &ptr);\n+  /* PC will be set by implicit RETURN opcode.  */\n+}\n+\n+/* Execute the unwinding instructions described by UWS.  */\n+_Unwind_Reason_Code\n+__gnu_unwind_execute (_Unwind_Context * context, __gnu_unwind_state * uws)\n+{\n+  _uw op;\n+  int inc_sp;\n+  _uw reg;\n+  _uw *ptr;\n+\n+  inc_sp = 1;\n+  for (;;)\n+    {\n+      op = next_unwind_byte (uws);\n+      if (op == CODE_FINISH)\n+\t{\n+\t  /* Drop out of the loop.  */\n+\t  break;\n+\t}\n+      if ((op & 0xc0) == 0)\n+\t{\n+\t  /* sp += (imm6 << 3) + 8.  */\n+\t  _uw offset;\n+\n+\t  offset = ((op & 0x3f) << 3) + 8;\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &reg);\n+\t  reg += offset;\n+\t  _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &reg);\n+\t  continue;\n+\t}\n+\n+      if (op == 0xd2)\n+\t{\n+\t  /* vsp = vsp + 0x204 + (uleb128 << 2).  */\n+\t  int shift;\n+\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &reg);\n+\t  op = next_unwind_byte (uws);\n+\t  shift = 3;\n+\t  while (op & 0x80)\n+\t    {\n+\t      reg += ((op & 0x7f) << shift);\n+\t      shift += 7;\n+\t      op = next_unwind_byte (uws);\n+\t    }\n+\t  reg += ((op & 0x7f) << shift) + 0x408;\n+\t  _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &reg);\n+\t  continue;\n+\t}\n+\n+      if ((op & 0xe0) == 0x80)\n+\t{\n+\t  /* POP bitmask */\n+\t  _uw mask = ((op & 0x1f) << 8) | next_unwind_byte (uws);\n+\n+\t  if (mask == 0)\n+\t    {\n+\t      /* CANTUNWIND */\n+\t      return _URC_FAILURE;\n+\t    }\n+\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &ptr);\n+\t  pop_frame (context, mask, ptr, inc_sp);\n+\t  continue;\n+\t}\n+\n+      if ((op & 0xe0) == 0xa0)\n+\t{\n+\t  /* POP bitmask (compact) */\n+\t  _uw mask = ((op & 0x1f) << 8) | next_unwind_byte (uws);\n+\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &ptr);\n+\t  pop_compact_frame (context, mask, ptr, inc_sp);\n+\t  continue;\n+\t}\n+\n+      if ((op & 0xf0) == 0xc0)\n+\t{\n+\t  /* POP registers */\n+\t  int nregs = op & 0xf;\n+\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &ptr);\n+\t  while (nregs > 0)\n+\t    {\n+\t      op = next_unwind_byte (uws);\n+\t      if ((op >> 4) != 0xf)\n+\t\t{\n+\t\t  reg = unwind_frame_regs[op >> 4];\n+\t\t  _Unwind_VRS_Set (context, _UVRSC_CORE, reg, _UVRSD_UINT32,\n+\t\t\t\t   ptr);\n+\t\t  nregs--;\n+\t\t}\n+\t      ptr--;\n+\t      if ((op & 0xf) != 0xf)\n+\t\t{\n+\t\t  reg = unwind_frame_regs[op & 0xf];\n+\t\t  _Unwind_VRS_Set (context, _UVRSC_CORE, reg, _UVRSD_UINT32,\n+\t\t\t\t   ptr);\n+\t\t  nregs--;\n+\t\t}\n+\t      ptr--;\n+\t    }\n+\n+\t  continue;\n+\t}\n+\n+      if (op == 0xd0)\n+\t{\n+\t  /* MV FP, SP */\n+\t  inc_sp = 0;\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, R_A15, _UVRSD_UINT32, &reg);\n+\t  _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &reg);\n+\t  continue;\n+\t}\n+\n+      if (op == 0xd1)\n+\t{\n+\t  /* __cx6abi_pop_rts */\n+\t  unwind_pop_rts (context);\n+\t  break;\n+\t}\n+\n+      if ((op & 0xf0) == 0xe0)\n+\t{\n+\t  /* B3 = reg.  RETURN case alreadh handled above.  */\n+\t  int regno = unwind_frame_regs[op & 0xf];\n+\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &reg);\n+\t  _Unwind_VRS_Set (context, _UVRSC_CORE, R_B3, _UVRSD_UINT32, &reg);\n+\t  continue;\n+\t}\n+      \n+      /* Reserved.  */\n+      return _URC_FAILURE;\n+    }\n+\n+  /* Implicit RETURN.  */\n+  _Unwind_VRS_Get (context, _UVRSC_CORE, R_B3, _UVRSD_UINT32, &reg);\n+  _Unwind_VRS_Set (context, _UVRSC_CORE, R_PC, _UVRSD_UINT32, &reg);\n+  return _URC_OK;\n+}\n+\n+\n+/* Execute the unwinding instructions associated with a frame.  UCBP and\n+   CONTEXT are the current exception object and virtual CPU state\n+   respectively.  */\n+\n+_Unwind_Reason_Code\n+__gnu_unwind_frame (_Unwind_Control_Block * ucbp, _Unwind_Context * context)\n+{\n+  _uw *ptr;\n+  __gnu_unwind_state uws;\n+\n+  ptr = (_uw *) ucbp->pr_cache.ehtp;\n+  /* Skip over the personality routine address.  */\n+  ptr++;\n+  /* Setup the unwinder state.  */\n+  uws.data = (*ptr) << 8;\n+  uws.next = ptr + 1;\n+  uws.bytes_left = 3;\n+  uws.words_left = ((*ptr) >> 24) & 0xff;\n+\n+  return __gnu_unwind_execute (context, &uws);\n+}\n+\n+/* Data segment base pointer corresponding to the function catching\n+   the exception.  */\n+\n+_Unwind_Ptr\n+_Unwind_GetDataRelBase (_Unwind_Context *context)\n+{\n+  return _Unwind_GetGR (context, R_B14);\n+}\n+\n+/* This should never be used.  */\n+\n+_Unwind_Ptr\n+_Unwind_GetTextRelBase (_Unwind_Context *context __attribute__ ((unused)))\n+{\n+  abort ();\n+}\n+\n+/* Only used by gcc personality routines, so can rely on a value they hid\n+   there earlier.  */\n+_Unwind_Ptr\n+_Unwind_GetRegionStart (_Unwind_Context *context)\n+{\n+  _Unwind_Control_Block *ucbp;\n+ \n+  ucbp = (_Unwind_Control_Block *) _Unwind_GetGR (context, UNWIND_POINTER_REG);\n+  return (_Unwind_Ptr) ucbp->pr_cache.fnstart;\n+}\n+\n+void *\n+_Unwind_GetLanguageSpecificData (_Unwind_Context *context)\n+{\n+  _Unwind_Control_Block *ucbp;\n+  _uw *ptr;\n+ \n+  ucbp = (_Unwind_Control_Block *) _Unwind_GetGR (context, UNWIND_POINTER_REG);\n+  ptr = (_uw *) ucbp->pr_cache.ehtp;\n+  /* Skip the personality routine address.  */\n+  ptr++;\n+  /* Skip the unwind opcodes.  */\n+  ptr += (((*ptr) >> 24) & 0xff) + 1;\n+\n+  return ptr;\n+}"}, {"sha": "445de9b322440a9d1536fddd0a653335db528194", "filename": "libgcc/config/c6x/t-c6x-elf", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Ft-c6x-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Ft-c6x-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fc6x%2Ft-c6x-elf?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -0,0 +1,4 @@\n+LIB2ADDEH = $(srcdir)/config/c6x/unwind-c6x.c \\\n+  $(srcdir)/config/c6x/libunwind.S \\\n+  $(srcdir)/config/c6x/pr-support.c $(srcdir)/unwind-c.c\n+"}, {"sha": "da2f79ba4e14b2b703b8a000c00935a8abdaa72c", "filename": "libgcc/config/c6x/unwind-c6x.c", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Funwind-c6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Funwind-c6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fc6x%2Funwind-c6x.c?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -0,0 +1,224 @@\n+/* C6X EABI compliant unwinding routines.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"unwind.h\"\n+\n+/* Misc constants.  */\n+#define NUM_SAVED_REGS 32\n+#define R_B0 16\n+#define R_B3 (R_B0 + 3)\n+#define R_B15 (R_B0 + 15)\n+#define R_SP R_B15\n+#define R_LR R_B3\n+#define R_PC 33\n+\n+#define VRS_PC(vrs) ((vrs)->core.pc)\n+#define VRS_SP(vrs) ((vrs)->core.reg[R_SP])\n+#define VRS_RETURN(vrs) ((vrs)->core.reg[R_B3])\n+\n+struct core_regs\n+{\n+  _uw reg[NUM_SAVED_REGS];\n+  _uw pc;\n+};\n+\n+typedef struct\n+{\n+  /* The first fields must be the same as a phase2_vrs.  */\n+  _uw demand_save_flags; /* Currently always zero.  */\n+  struct core_regs core;\n+  _uw prev_sp; /* Only valid during forced unwinding.  */\n+} phase1_vrs;\n+\n+/* This must match the structure created by the assembly wrappers.  */\n+typedef struct\n+{\n+  _uw demand_save_flags;\n+  struct core_regs core;\n+} phase2_vrs;\n+\n+/* Coprocessor register state manipulation functions.  */\n+\n+/* Restore coprocessor state after phase1 unwinding.  */\n+static void\n+restore_non_core_regs (phase1_vrs * vrs __attribute__((unused)))\n+{\n+}\n+\n+#include \"unwind-arm-common.inc\"\n+\n+/* ABI defined personality routines.  */\n+extern _Unwind_Reason_Code __c6xabi_unwind_cpp_pr0 (_Unwind_State,\n+    _Unwind_Control_Block *, _Unwind_Context *);// __attribute__((weak));\n+extern _Unwind_Reason_Code __c6xabi_unwind_cpp_pr1 (_Unwind_State,\n+    _Unwind_Control_Block *, _Unwind_Context *) __attribute__((weak));\n+extern _Unwind_Reason_Code __c6xabi_unwind_cpp_pr2 (_Unwind_State,\n+    _Unwind_Control_Block *, _Unwind_Context *) __attribute__((weak));\n+extern _Unwind_Reason_Code __c6xabi_unwind_cpp_pr3 (_Unwind_State,\n+    _Unwind_Control_Block *, _Unwind_Context *) __attribute__((weak));\n+extern _Unwind_Reason_Code __c6xabi_unwind_cpp_pr4 (_Unwind_State,\n+    _Unwind_Control_Block *, _Unwind_Context *) __attribute__((weak));\n+\n+/* ABI defined routine to store a virtual register to memory.  */\n+\n+_Unwind_VRS_Result _Unwind_VRS_Get (_Unwind_Context *context,\n+\t\t\t\t    _Unwind_VRS_RegClass regclass,\n+\t\t\t\t    _uw regno,\n+\t\t\t\t    _Unwind_VRS_DataRepresentation representation,\n+\t\t\t\t    void *valuep)\n+{\n+  phase1_vrs *vrs = (phase1_vrs *) context;\n+\n+  switch (regclass)\n+    {\n+    case _UVRSC_CORE:\n+      if (representation != _UVRSD_UINT32)\n+\treturn _UVRSR_FAILED;\n+      if (regno == R_PC)\n+\t{\n+\t  *(_uw *) valuep = vrs->core.pc;\n+\t  return _UVRSR_OK;\n+\t}\n+      if (regno >= NUM_SAVED_REGS)\n+\treturn _UVRSR_FAILED;\n+      *(_uw *) valuep = vrs->core.reg[regno];\n+      return _UVRSR_OK;\n+\n+    default:\n+      return _UVRSR_FAILED;\n+    }\n+}\n+\n+\n+/* ABI defined function to load a virtual register from memory.  */\n+\n+_Unwind_VRS_Result _Unwind_VRS_Set (_Unwind_Context *context,\n+\t\t\t\t    _Unwind_VRS_RegClass regclass,\n+\t\t\t\t    _uw regno,\n+\t\t\t\t    _Unwind_VRS_DataRepresentation representation,\n+\t\t\t\t    void *valuep)\n+{\n+  phase1_vrs *vrs = (phase1_vrs *) context;\n+\n+  switch (regclass)\n+    {\n+    case _UVRSC_CORE:\n+      if (representation != _UVRSD_UINT32)\n+\treturn _UVRSR_FAILED;\n+      if (regno == R_PC)\n+\t{\n+\t  vrs->core.pc = *(_uw *) valuep;\n+\t  return _UVRSR_OK;\n+\t}\n+      if (regno >= NUM_SAVED_REGS)\n+\treturn _UVRSR_FAILED;\n+\n+      vrs->core.reg[regno] = *(_uw *) valuep;\n+      return _UVRSR_OK;\n+\n+    default:\n+      return _UVRSR_FAILED;\n+    }\n+}\n+\n+\n+/* Core unwinding functions.  */\n+\n+/* Calculate the address encoded by a 31-bit self-relative offset at address\n+   P.  */\n+static inline _uw\n+selfrel_offset31 (const _uw *p)\n+{\n+  _uw offset;\n+\n+  offset = *p << 1;\n+  return offset + (_uw) p;\n+}\n+\n+\n+static _uw\n+__gnu_unwind_get_pr_addr (int idx)\n+{\n+  switch (idx)\n+    {\n+    case 0:\n+      return (_uw) &__c6xabi_unwind_cpp_pr0;\n+\n+    case 1:\n+      return (_uw) &__c6xabi_unwind_cpp_pr1;\n+\n+    case 2:\n+      return (_uw) &__c6xabi_unwind_cpp_pr2;\n+\n+    case 3:\n+      return (_uw) &__c6xabi_unwind_cpp_pr3;\n+\n+    case 4:\n+      return (_uw) &__c6xabi_unwind_cpp_pr4;\n+\n+    default:\n+       return 0;\n+    }\n+}\n+\n+\n+/* ABI defined personality routine entry points.  */\n+\n+_Unwind_Reason_Code\n+__c6xabi_unwind_cpp_pr0 (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context)\n+{\n+  return __gnu_unwind_pr_common (state, ucbp, context, 0);\n+}\n+\n+_Unwind_Reason_Code\n+__c6xabi_unwind_cpp_pr1 (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context)\n+{\n+  return __gnu_unwind_pr_common (state, ucbp, context, 1);\n+}\n+\n+_Unwind_Reason_Code\n+__c6xabi_unwind_cpp_pr2 (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context)\n+{\n+  return __gnu_unwind_pr_common (state, ucbp, context, 2);\n+}\n+\n+_Unwind_Reason_Code\n+__c6xabi_unwind_cpp_pr3 (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context)\n+{\n+  return __gnu_unwind_pr_common (state, ucbp, context, 3);\n+}\n+\n+_Unwind_Reason_Code\n+__c6xabi_unwind_cpp_pr4 (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context)\n+{\n+  return __gnu_unwind_pr_common (state, ucbp, context, 4);\n+}"}, {"sha": "3d6c73e7f9b99ce9442256cd9e13faa5ac22876d", "filename": "libgcc/config/c6x/unwind-c6x.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Funwind-c6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Fconfig%2Fc6x%2Funwind-c6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fc6x%2Funwind-c6x.h?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -0,0 +1,71 @@\n+/* Header file for the C6X EABI unwinder\n+   Copyright (C) 2011\n+   Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Language-independent unwinder header public defines.  This contains both\n+   ABI defined objects, and GNU support routines.  */\n+\n+#ifndef UNWIND_C6X_H\n+#define UNWIND_C6X_H\n+\n+/* Not really the ARM EABI, but pretty close.  */\n+#include \"unwind-arm-common.h\"\n+\n+#define UNWIND_STACK_REG 31\n+/* Use A0 as a scratch register within the personality routine.  */\n+#define UNWIND_POINTER_REG 0\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+  _Unwind_Reason_Code __gnu_unwind_24bit (_Unwind_Context *, _uw, int);\n+\n+  /* Decode an EH table reference to a typeinfo object.  */\n+  static inline _Unwind_Word\n+  _Unwind_decode_typeinfo_ptr (_Unwind_Ptr base, _Unwind_Word ptr)\n+    {\n+      _Unwind_Word tmp;\n+\n+      tmp = *(_Unwind_Word *) ptr;\n+      /* Zero values are always NULL.  */\n+      if (!tmp)\n+\treturn 0;\n+\n+      /* SB-relative indirect.  Propagate the bottom 2 bits, which can\n+\t contain referenceness information in gnu unwinding tables.  */\n+      tmp += base;\n+      tmp = *(_Unwind_Word *) (tmp & ~(_Unwind_Word)3) | (tmp & 3);\n+      return tmp;\n+    }\n+\n+#define _Unwind_GetIP(context) \\\n+  (_Unwind_GetGR (context, 33))\n+\n+\n+#define _Unwind_SetIP(context, val) \\\n+  _Unwind_SetGR (context, 33, val)\n+\n+#ifdef __cplusplus\n+}   /* extern \"C\" */\n+#endif\n+\n+#endif /* defined UNWIND_ARM_H */"}, {"sha": "04bfd8b7e57443cbf663a79b9d8d01d4a9b565b4", "filename": "libgcc/unwind-arm-common.inc", "status": "added", "additions": 810, "deletions": 0, "changes": 810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Funwind-arm-common.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Funwind-arm-common.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-arm-common.inc?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -0,0 +1,810 @@\n+/* Common unwinding code for ARM EABI and C6X.\n+   Copyright (C) 2004, 2005, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"unwind.h\"\n+\n+/* We add a prototype for abort here to avoid creating a dependency on\n+   target headers.  */\n+extern void abort (void);\n+\n+/* Definitions for C++ runtime support routines.  We make these weak\n+   declarations to avoid pulling in libsupc++ unnecessarily.  */\n+typedef unsigned char bool;\n+\n+typedef struct _ZSt9type_info type_info; /* This names C++ type_info type */\n+enum __cxa_type_match_result\n+  {\n+    ctm_failed = 0,\n+    ctm_succeeded = 1,\n+    ctm_succeeded_with_ptr_to_base = 2\n+  };\n+\n+void __attribute__((weak)) __cxa_call_unexpected(_Unwind_Control_Block *ucbp);\n+bool __attribute__((weak)) __cxa_begin_cleanup(_Unwind_Control_Block *ucbp);\n+enum __cxa_type_match_result __attribute__((weak)) __cxa_type_match\n+  (_Unwind_Control_Block *ucbp, const type_info *rttip,\n+   bool is_reference, void **matched_object);\n+\n+_Unwind_Ptr __attribute__((weak))\n+__gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);\n+\n+#define EXIDX_CANTUNWIND 1\n+#define uint32_highbit (((_uw) 1) << 31)\n+\n+#define UCB_FORCED_STOP_FN(ucbp) ((ucbp)->unwinder_cache.reserved1)\n+#define UCB_PR_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved2)\n+#define UCB_SAVED_CALLSITE_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved3)\n+#define UCB_FORCED_STOP_ARG(ucbp) ((ucbp)->unwinder_cache.reserved4)\n+\n+/* Unwind descriptors.  */\n+\n+typedef struct\n+{\n+  _uw16 length;\n+  _uw16 offset;\n+} EHT16;\n+\n+typedef struct\n+{\n+  _uw length;\n+  _uw offset;\n+} EHT32;\n+\n+/* An exception index table entry.  */\n+\n+typedef struct __EIT_entry\n+{\n+  _uw fnoffset;\n+  _uw content;\n+} __EIT_entry;\n+\n+/* Assembly helper functions.  */\n+\n+/* Restore core register state.  Never returns.  */\n+void __attribute__((noreturn)) restore_core_regs (struct core_regs *);\n+\n+\n+/* Restore coprocessor state after phase1 unwinding.  */\n+static void restore_non_core_regs (phase1_vrs * vrs);\n+\n+/* A better way to do this would probably be to compare the absolute address\n+   with a segment relative relocation of the same symbol.  */\n+\n+extern int __text_start;\n+extern int __data_start;\n+\n+/* The exception index table location.  */\n+extern __EIT_entry __exidx_start;\n+extern __EIT_entry __exidx_end;\n+\n+/* Core unwinding functions.  */\n+\n+/* Calculate the address encoded by a 31-bit self-relative offset at address\n+   P.  */\n+static inline _uw selfrel_offset31 (const _uw *p);\n+\n+static _uw __gnu_unwind_get_pr_addr (int idx);\n+\n+/* Perform a binary search for RETURN_ADDRESS in TABLE.  The table contains\n+   NREC entries.  */\n+\n+static const __EIT_entry *\n+search_EIT_table (const __EIT_entry * table, int nrec, _uw return_address)\n+{\n+  _uw next_fn;\n+  _uw this_fn;\n+  int n, left, right;\n+\n+  if (nrec == 0)\n+    return (__EIT_entry *) 0;\n+\n+  left = 0;\n+  right = nrec - 1;\n+\n+  while (1)\n+    {\n+      n = (left + right) / 2;\n+      this_fn = selfrel_offset31 (&table[n].fnoffset);\n+      if (n != nrec - 1)\n+\tnext_fn = selfrel_offset31 (&table[n + 1].fnoffset) - 1;\n+      else\n+\tnext_fn = (_uw)0 - 1;\n+\n+      if (return_address < this_fn)\n+\t{\n+\t  if (n == left)\n+\t    return (__EIT_entry *) 0;\n+\t  right = n - 1;\n+\t}\n+      else if (return_address <= next_fn)\n+\treturn &table[n];\n+      else\n+\tleft = n + 1;\n+    }\n+}\n+\n+/* Find the exception index table eintry for the given address.\n+   Fill in the relevant fields of the UCB.\n+   Returns _URC_FAILURE if an error occurred, _URC_OK on success.  */\n+\n+static _Unwind_Reason_Code\n+get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n+{\n+  const __EIT_entry * eitp;\n+  int nrec;\n+  \n+  /* The return address is the address of the instruction following the\n+     call instruction (plus one in thumb mode).  If this was the last\n+     instruction in the function the address will lie in the following\n+     function.  Subtract 2 from the address so that it points within the call\n+     instruction itself.  */\n+  return_address -= 2;\n+\n+  if (__gnu_Unwind_Find_exidx)\n+    {\n+      eitp = (const __EIT_entry *) __gnu_Unwind_Find_exidx (return_address,\n+\t\t\t\t\t\t\t    &nrec);\n+      if (!eitp)\n+\t{\n+\t  UCB_PR_ADDR (ucbp) = 0;\n+\t  return _URC_FAILURE;\n+\t}\n+    }\n+  else\n+    {\n+      eitp = &__exidx_start;\n+      nrec = &__exidx_end - &__exidx_start;\n+    }\n+\n+  eitp = search_EIT_table (eitp, nrec, return_address);\n+\n+  if (!eitp)\n+    {\n+      UCB_PR_ADDR (ucbp) = 0;\n+      return _URC_FAILURE;\n+    }\n+  ucbp->pr_cache.fnstart = selfrel_offset31 (&eitp->fnoffset);\n+\n+  /* Can this frame be unwound at all?  */\n+  if (eitp->content == EXIDX_CANTUNWIND)\n+    {\n+      UCB_PR_ADDR (ucbp) = 0;\n+      return _URC_END_OF_STACK;\n+    }\n+\n+  /* Obtain the address of the \"real\" __EHT_Header word.  */\n+\n+  if (eitp->content & uint32_highbit)\n+    {\n+      /* It is immediate data.  */\n+      ucbp->pr_cache.ehtp = (_Unwind_EHT_Header *)&eitp->content;\n+      ucbp->pr_cache.additional = 1;\n+    }\n+  else\n+    {\n+      /* The low 31 bits of the content field are a self-relative\n+\t offset to an _Unwind_EHT_Entry structure.  */\n+      ucbp->pr_cache.ehtp =\n+\t(_Unwind_EHT_Header *) selfrel_offset31 (&eitp->content);\n+      ucbp->pr_cache.additional = 0;\n+    }\n+\n+  /* Discover the personality routine address.  */\n+  if (*ucbp->pr_cache.ehtp & (1u << 31))\n+    {\n+      /* One of the predefined standard routines.  */\n+      _uw idx = (*(_uw *) ucbp->pr_cache.ehtp >> 24) & 0xf;\n+      UCB_PR_ADDR (ucbp) = __gnu_unwind_get_pr_addr (idx);\n+      if (UCB_PR_ADDR (ucbp) == 0)\n+\t{\n+\t  /* Failed */\n+\t  return _URC_FAILURE;\n+\t}\n+    } \n+  else\n+    {\n+      /* Execute region offset to PR */\n+      UCB_PR_ADDR (ucbp) = selfrel_offset31 (ucbp->pr_cache.ehtp);\n+    }\n+  return _URC_OK;\n+}\n+\n+\n+/* Perform phase2 unwinding.  VRS is the initial virtual register state.  */\n+\n+static void __attribute__((noreturn))\n+unwind_phase2 (_Unwind_Control_Block * ucbp, phase2_vrs * vrs)\n+{\n+  _Unwind_Reason_Code pr_result;\n+\n+  do\n+    {\n+      /* Find the entry for this routine.  */\n+      if (get_eit_entry (ucbp, VRS_PC(vrs)) != _URC_OK)\n+\tabort ();\n+\n+      UCB_SAVED_CALLSITE_ADDR (ucbp) = VRS_PC(vrs);\n+\n+      /* Call the pr to decide what to do.  */\n+      pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t(_US_UNWIND_FRAME_STARTING, ucbp, (_Unwind_Context *) vrs);\n+    }\n+  while (pr_result == _URC_CONTINUE_UNWIND);\n+  \n+  if (pr_result != _URC_INSTALL_CONTEXT)\n+    abort();\n+  \n+  restore_core_regs (&vrs->core);\n+}\n+\n+/* Perform phase2 forced unwinding.  */\n+\n+static _Unwind_Reason_Code\n+unwind_phase2_forced (_Unwind_Control_Block *ucbp, phase2_vrs *entry_vrs,\n+\t\t      int resuming)\n+{\n+  _Unwind_Stop_Fn stop_fn = (_Unwind_Stop_Fn) UCB_FORCED_STOP_FN (ucbp);\n+  void *stop_arg = (void *)UCB_FORCED_STOP_ARG (ucbp);\n+  _Unwind_Reason_Code pr_result = 0;\n+  /* We use phase1_vrs here even though we do not demand save, for the\n+     prev_sp field.  */\n+  phase1_vrs saved_vrs, next_vrs;\n+\n+  /* Save the core registers.  */\n+  saved_vrs.core = entry_vrs->core;\n+  /* We don't need to demand-save the non-core registers, because we\n+     unwind in a single pass.  */\n+  saved_vrs.demand_save_flags = 0;\n+\n+  /* Unwind until we reach a propagation barrier.  */\n+  do\n+    {\n+      _Unwind_State action;\n+      _Unwind_Reason_Code entry_code;\n+      _Unwind_Reason_Code stop_code;\n+\n+      /* Find the entry for this routine.  */\n+      entry_code = get_eit_entry (ucbp, VRS_PC (&saved_vrs));\n+\n+      if (resuming)\n+\t{\n+\t  action = _US_UNWIND_FRAME_RESUME | _US_FORCE_UNWIND;\n+\t  resuming = 0;\n+\t}\n+      else\n+\taction = _US_UNWIND_FRAME_STARTING | _US_FORCE_UNWIND;\n+\n+      if (entry_code == _URC_OK)\n+\t{\n+\t  UCB_SAVED_CALLSITE_ADDR (ucbp) = VRS_PC (&saved_vrs);\n+\n+\t  next_vrs = saved_vrs;\n+\n+\t  /* Call the pr to decide what to do.  */\n+\t  pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t    (action, ucbp, (void *) &next_vrs);\n+\n+\t  saved_vrs.prev_sp = VRS_SP (&next_vrs);\n+\t}\n+      else\n+\t{\n+\t  /* Treat any failure as the end of unwinding, to cope more\n+\t     gracefully with missing EH information.  Mixed EH and\n+\t     non-EH within one object will usually result in failure,\n+\t     because the .ARM.exidx tables do not indicate the end\n+\t     of the code to which they apply; but mixed EH and non-EH\n+\t     shared objects should return an unwind failure at the\n+\t     entry of a non-EH shared object.  */\n+\t  action |= _US_END_OF_STACK;\n+\n+\t  saved_vrs.prev_sp = VRS_SP (&saved_vrs);\n+\t}\n+\n+      stop_code = stop_fn (1, action, ucbp->exception_class, ucbp,\n+\t\t\t   (void *)&saved_vrs, stop_arg);\n+      if (stop_code != _URC_NO_REASON)\n+\treturn _URC_FAILURE;\n+\n+      if (entry_code != _URC_OK)\n+\treturn entry_code;\n+\n+      saved_vrs = next_vrs;\n+    }\n+  while (pr_result == _URC_CONTINUE_UNWIND);\n+\n+  if (pr_result != _URC_INSTALL_CONTEXT)\n+    {\n+      /* Some sort of failure has occurred in the pr and probably the\n+\t pr returned _URC_FAILURE.  */\n+      return _URC_FAILURE;\n+    }\n+\n+  restore_core_regs (&saved_vrs.core);\n+}\n+\n+/* This is a very limited implementation of _Unwind_GetCFA.  It returns\n+   the stack pointer as it is about to be unwound, and is only valid\n+   while calling the stop function during forced unwinding.  If the\n+   current personality routine result is going to run a cleanup, this\n+   will not be the CFA; but when the frame is really unwound, it will\n+   be.  */\n+\n+_Unwind_Word\n+_Unwind_GetCFA (_Unwind_Context *context)\n+{\n+  return ((phase1_vrs *) context)->prev_sp;\n+}\n+\n+/* Perform phase1 unwinding.  UCBP is the exception being thrown, and\n+   entry_VRS is the register state on entry to _Unwind_RaiseException.  */\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_RaiseException (_Unwind_Control_Block *, phase2_vrs *);\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_RaiseException (_Unwind_Control_Block * ucbp,\n+\t\t\t     phase2_vrs * entry_vrs)\n+{\n+  phase1_vrs saved_vrs;\n+  _Unwind_Reason_Code pr_result;\n+\n+  /* Set the pc to the call site.  */\n+  VRS_PC (entry_vrs) = VRS_RETURN(entry_vrs);\n+\n+  /* Save the core registers.  */\n+  saved_vrs.core = entry_vrs->core;\n+  /* Set demand-save flags.  */\n+  saved_vrs.demand_save_flags = ~(_uw) 0;\n+  \n+  /* Unwind until we reach a propagation barrier.  */\n+  do\n+    {\n+      /* Find the entry for this routine.  */\n+      if (get_eit_entry (ucbp, VRS_PC (&saved_vrs)) != _URC_OK)\n+\treturn _URC_FAILURE;\n+\n+      /* Call the pr to decide what to do.  */\n+      pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t(_US_VIRTUAL_UNWIND_FRAME, ucbp, (void *) &saved_vrs);\n+    }\n+  while (pr_result == _URC_CONTINUE_UNWIND);\n+\n+  /* We've unwound as far as we want to go, so restore the original\n+     register state.  */\n+  restore_non_core_regs (&saved_vrs);\n+  if (pr_result != _URC_HANDLER_FOUND)\n+    {\n+      /* Some sort of failure has occurred in the pr and probably the\n+\t pr returned _URC_FAILURE.  */\n+      return _URC_FAILURE;\n+    }\n+  \n+  unwind_phase2 (ucbp, entry_vrs);\n+}\n+\n+/* Resume unwinding after a cleanup has been run.  UCBP is the exception\n+   being thrown and ENTRY_VRS is the register state on entry to\n+   _Unwind_Resume.  */\n+_Unwind_Reason_Code\n+__gnu_Unwind_ForcedUnwind (_Unwind_Control_Block *,\n+\t\t\t   _Unwind_Stop_Fn, void *, phase2_vrs *);\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_ForcedUnwind (_Unwind_Control_Block *ucbp,\n+\t\t\t   _Unwind_Stop_Fn stop_fn, void *stop_arg,\n+\t\t\t   phase2_vrs *entry_vrs)\n+{\n+  UCB_FORCED_STOP_FN (ucbp) = (_uw) stop_fn;\n+  UCB_FORCED_STOP_ARG (ucbp) = (_uw) stop_arg;\n+\n+  /* Set the pc to the call site.  */\n+  VRS_PC (entry_vrs) = VRS_RETURN(entry_vrs);\n+\n+  return unwind_phase2_forced (ucbp, entry_vrs, 0);\n+}\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_Resume (_Unwind_Control_Block *, phase2_vrs *);\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_Resume (_Unwind_Control_Block * ucbp, phase2_vrs * entry_vrs)\n+{\n+  _Unwind_Reason_Code pr_result;\n+\n+  /* Recover the saved address.  */\n+  VRS_PC (entry_vrs) = UCB_SAVED_CALLSITE_ADDR (ucbp);\n+\n+  if (UCB_FORCED_STOP_FN (ucbp))\n+    {\n+      unwind_phase2_forced (ucbp, entry_vrs, 1);\n+\n+      /* We can't return failure at this point.  */\n+      abort ();\n+    }\n+\n+  /* Call the cached PR.  */\n+  pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t(_US_UNWIND_FRAME_RESUME, ucbp, (_Unwind_Context *) entry_vrs);\n+\n+  switch (pr_result)\n+    {\n+    case _URC_INSTALL_CONTEXT:\n+      /* Upload the registers to enter the landing pad.  */\n+      restore_core_regs (&entry_vrs->core);\n+\n+    case _URC_CONTINUE_UNWIND:\n+      /* Continue unwinding the next frame.  */\n+      unwind_phase2 (ucbp, entry_vrs);\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_Resume_or_Rethrow (_Unwind_Control_Block *, phase2_vrs *);\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_Resume_or_Rethrow (_Unwind_Control_Block * ucbp,\n+\t\t\t\tphase2_vrs * entry_vrs)\n+{\n+  if (!UCB_FORCED_STOP_FN (ucbp))\n+    return __gnu_Unwind_RaiseException (ucbp, entry_vrs);\n+\n+  /* Set the pc to the call site.  */\n+  VRS_PC (entry_vrs) = VRS_RETURN (entry_vrs);\n+  /* Continue unwinding the next frame.  */\n+  return unwind_phase2_forced (ucbp, entry_vrs, 0);\n+}\n+\n+/* Clean up an exception object when unwinding is complete.  */\n+void\n+_Unwind_Complete (_Unwind_Control_Block * ucbp __attribute__((unused)))\n+{\n+}\n+\n+\n+/* Free an exception.  */\n+\n+void\n+_Unwind_DeleteException (_Unwind_Exception * exc)\n+{\n+  if (exc->exception_cleanup)\n+    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);\n+}\n+\n+\n+/* Perform stack backtrace through unwind data.  */\n+_Unwind_Reason_Code\n+__gnu_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument,\n+\t\t       phase2_vrs * entry_vrs);\n+_Unwind_Reason_Code\n+__gnu_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument,\n+\t\t       phase2_vrs * entry_vrs)\n+{\n+  phase1_vrs saved_vrs;\n+  _Unwind_Reason_Code code;\n+\n+  _Unwind_Control_Block ucb;\n+  _Unwind_Control_Block *ucbp = &ucb;\n+\n+  /* Set the pc to the call site.  */\n+  VRS_PC (entry_vrs) = VRS_RETURN (entry_vrs);\n+\n+  /* Save the core registers.  */\n+  saved_vrs.core = entry_vrs->core;\n+  /* Set demand-save flags.  */\n+  saved_vrs.demand_save_flags = ~(_uw) 0;\n+  \n+  do\n+    {\n+      /* Find the entry for this routine.  */\n+      if (get_eit_entry (ucbp, VRS_PC (&saved_vrs)) != _URC_OK)\n+\t{\n+\t  code = _URC_FAILURE;\n+\t  break;\n+\t}\n+\n+      /* The dwarf unwinder assumes the context structure holds things\n+\t like the function and LSDA pointers.  The ARM implementation\n+\t caches these in the exception header (UCB).  To avoid\n+\t rewriting everything we make the virtual IP register point at\n+\t the UCB.  */\n+      _Unwind_SetGR((_Unwind_Context *)&saved_vrs, UNWIND_POINTER_REG, (_Unwind_Ptr) ucbp);\n+\n+      /* Call trace function.  */\n+      if ((*trace) ((_Unwind_Context *) &saved_vrs, trace_argument) \n+\t  != _URC_NO_REASON)\n+\t{\n+\t  code = _URC_FAILURE;\n+\t  break;\n+\t}\n+\n+      /* Call the pr to decide what to do.  */\n+      code = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t(_US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND, \n+\t ucbp, (void *) &saved_vrs);\n+    }\n+  while (code != _URC_END_OF_STACK\n+\t && code != _URC_FAILURE);\n+\n+  restore_non_core_regs (&saved_vrs);\n+  return code;\n+}\n+\n+\n+/* Common implementation for ARM ABI defined personality routines.\n+   ID is the index of the personality routine, other arguments are as defined\n+   by __aeabi_unwind_cpp_pr{0,1,2}.  */\n+\n+static _Unwind_Reason_Code\n+__gnu_unwind_pr_common (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context,\n+\t\t\tint id)\n+{\n+  __gnu_unwind_state uws;\n+  _uw *data;\n+  _uw offset;\n+  _uw len;\n+  _uw rtti_count;\n+  int phase2_call_unexpected_after_unwind = 0;\n+  int in_range = 0;\n+  int forced_unwind = state & _US_FORCE_UNWIND;\n+\n+  state &= _US_ACTION_MASK;\n+\n+  data = (_uw *) ucbp->pr_cache.ehtp;\n+  uws.data = *(data++);\n+  uws.next = data;\n+  if (id == 0)\n+    {\n+      uws.data <<= 8;\n+      uws.words_left = 0;\n+      uws.bytes_left = 3;\n+    }\n+  else\n+    {\n+      uws.words_left = (uws.data >> 16) & 0xff;\n+      uws.data <<= 16;\n+      uws.bytes_left = 2;\n+      data += uws.words_left;\n+    }\n+\n+  /* Restore the saved pointer.  */\n+  if (state == _US_UNWIND_FRAME_RESUME)\n+    data = (_uw *) ucbp->cleanup_cache.bitpattern[0];\n+\n+  if ((ucbp->pr_cache.additional & 1) == 0)\n+    {\n+      /* Process descriptors.  */\n+      while (*data)\n+\t{\n+\t  _uw addr;\n+\t  _uw fnstart;\n+\n+\t  if (id == 2)\n+\t    {\n+\t      len = ((EHT32 *) data)->length;\n+\t      offset = ((EHT32 *) data)->offset;\n+\t      data += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      len = ((EHT16 *) data)->length;\n+\t      offset = ((EHT16 *) data)->offset;\n+\t      data++;\n+\t    }\n+\n+\t  fnstart = ucbp->pr_cache.fnstart + (offset & ~1);\n+\t  addr = _Unwind_GetGR (context, R_PC);\n+\t  in_range = (fnstart <= addr && addr < fnstart + (len & ~1));\n+\n+\t  switch (((offset & 1) << 1) | (len & 1))\n+\t    {\n+\t    case 0:\n+\t      /* Cleanup.  */\n+\t      if (state != _US_VIRTUAL_UNWIND_FRAME\n+\t\t  && in_range)\n+\t\t{\n+\t\t  /* Cleanup in range, and we are running cleanups.  */\n+\t\t  _uw lp;\n+\n+\t\t  /* Landing pad address is 31-bit pc-relative offset.  */\n+\t\t  lp = selfrel_offset31 (data);\n+\t\t  data++;\n+\t\t  /* Save the exception data pointer.  */\n+\t\t  ucbp->cleanup_cache.bitpattern[0] = (_uw) data;\n+\t\t  if (!__cxa_begin_cleanup (ucbp))\n+\t\t    return _URC_FAILURE;\n+\t\t  /* Setup the VRS to enter the landing pad.  */\n+\t\t  _Unwind_SetGR (context, R_PC, lp);\n+\t\t  return _URC_INSTALL_CONTEXT;\n+\t\t}\n+\t      /* Cleanup not in range, or we are in stage 1.  */\n+\t      data++;\n+\t      break;\n+\n+\t    case 1:\n+\t      /* Catch handler.  */\n+\t      if (state == _US_VIRTUAL_UNWIND_FRAME)\n+\t\t{\n+\t\t  if (in_range)\n+\t\t    {\n+\t\t      /* Check for a barrier.  */\n+\t\t      _uw rtti;\n+\t\t      bool is_reference = (data[0] & uint32_highbit) != 0;\n+\t\t      void *matched;\n+\t\t      enum __cxa_type_match_result match_type;\n+\n+\t\t      /* Check for no-throw areas.  */\n+\t\t      if (data[1] == (_uw) -2)\n+\t\t\treturn _URC_FAILURE;\n+\n+\t\t      /* The thrown object immediately follows the ECB.  */\n+\t\t      matched = (void *)(ucbp + 1);\n+\t\t      if (data[1] != (_uw) -1)\n+\t\t\t{\n+\t\t\t  /* Match a catch specification.  */\n+\t\t\t  rtti = _Unwind_decode_typeinfo_ptr (0,\n+\t\t\t\t\t\t\t      (_uw) &data[1]);\n+\t\t\t  match_type = __cxa_type_match (ucbp,\n+\t\t\t\t\t\t\t (type_info *) rtti,\n+\t\t\t\t\t\t\t is_reference,\n+\t\t\t\t\t\t\t &matched);\n+\t\t\t}\n+\t\t      else\n+\t\t\tmatch_type = ctm_succeeded;\n+\n+\t\t      if (match_type)\n+\t\t\t{\n+\t\t\t  ucbp->barrier_cache.sp =\n+\t\t\t    _Unwind_GetGR (context, R_SP);\n+\t\t\t  // ctm_succeeded_with_ptr_to_base really\n+\t\t\t  // means _c_t_m indirected the pointer\n+\t\t\t  // object.  We have to reconstruct the\n+\t\t\t  // additional pointer layer by using a temporary.\n+\t\t\t  if (match_type == ctm_succeeded_with_ptr_to_base)\n+\t\t\t    {\n+\t\t\t      ucbp->barrier_cache.bitpattern[2]\n+\t\t\t\t= (_uw) matched;\n+\t\t\t      ucbp->barrier_cache.bitpattern[0]\n+\t\t\t\t= (_uw) &ucbp->barrier_cache.bitpattern[2];\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    ucbp->barrier_cache.bitpattern[0] = (_uw) matched;\n+\t\t\t  ucbp->barrier_cache.bitpattern[1] = (_uw) data;\n+\t\t\t  return _URC_HANDLER_FOUND;\n+\t\t\t}\n+\t\t    }\n+\t\t  /* Handler out of range, or not matched.  */\n+\t\t}\n+\t      else if (ucbp->barrier_cache.sp == _Unwind_GetGR (context, R_SP)\n+\t\t       && ucbp->barrier_cache.bitpattern[1] == (_uw) data)\n+\t\t{\n+\t\t  /* Matched a previous propagation barrier.  */\n+\t\t  _uw lp;\n+\n+\t\t  /* Setup for entry to the handler.  */\n+\t\t  lp = selfrel_offset31 (data);\n+\t\t  _Unwind_SetGR (context, R_PC, lp);\n+\t\t  _Unwind_SetGR (context, 0, (_uw) ucbp);\n+\t\t  return _URC_INSTALL_CONTEXT;\n+\t\t}\n+\t      /* Catch handler not matched.  Advance to the next descriptor.  */\n+\t      data += 2;\n+\t      break;\n+\n+\t    case 2:\n+\t      rtti_count = data[0] & 0x7fffffff;\n+\t      /* Exception specification.  */\n+\t      if (state == _US_VIRTUAL_UNWIND_FRAME)\n+\t\t{\n+\t\t  if (in_range && (!forced_unwind || !rtti_count))\n+\t\t    {\n+\t\t      /* Match against the exception specification.  */\n+\t\t      _uw i;\n+\t\t      _uw rtti;\n+\t\t      void *matched;\n+\n+\t\t      for (i = 0; i < rtti_count; i++)\n+\t\t\t{\n+\t\t\t  matched = (void *)(ucbp + 1);\n+\t\t\t  rtti = _Unwind_decode_typeinfo_ptr (0,\n+\t\t\t      (_uw) &data[i + 1]);\n+\t\t\t  if (__cxa_type_match (ucbp, (type_info *) rtti, 0,\n+\t\t\t\t\t\t&matched))\n+\t\t\t    break;\n+\t\t\t}\n+\n+\t\t      if (i == rtti_count)\n+\t\t\t{\n+\t\t\t  /* Exception does not match the spec.  */\n+\t\t\t  ucbp->barrier_cache.sp =\n+\t\t\t    _Unwind_GetGR (context, R_SP);\n+\t\t\t  ucbp->barrier_cache.bitpattern[0] = (_uw) matched;\n+\t\t\t  ucbp->barrier_cache.bitpattern[1] = (_uw) data;\n+\t\t\t  return _URC_HANDLER_FOUND;\n+\t\t\t}\n+\t\t    }\n+\t\t  /* Handler out of range, or exception is permitted.  */\n+\t\t}\n+\t      else if (ucbp->barrier_cache.sp == _Unwind_GetGR (context, R_SP)\n+\t\t       && ucbp->barrier_cache.bitpattern[1] == (_uw) data)\n+\t\t{\n+\t\t  /* Matched a previous propagation barrier.  */\n+\t\t  _uw lp;\n+\t\t  /* Record the RTTI list for __cxa_call_unexpected.  */\n+\t\t  ucbp->barrier_cache.bitpattern[1] = rtti_count;\n+\t\t  ucbp->barrier_cache.bitpattern[2] = 0;\n+\t\t  ucbp->barrier_cache.bitpattern[3] = 4;\n+\t\t  ucbp->barrier_cache.bitpattern[4] = (_uw) &data[1];\n+\n+\t\t  if (data[0] & uint32_highbit)\n+\t\t    {\n+\t\t      data += rtti_count + 1;\n+\t\t      /* Setup for entry to the handler.  */\n+\t\t      lp = selfrel_offset31 (data);\n+\t\t      data++;\n+\t\t      _Unwind_SetGR (context, R_PC, lp);\n+\t\t      _Unwind_SetGR (context, 0, (_uw) ucbp);\n+\t\t      return _URC_INSTALL_CONTEXT;\n+\t\t    }\n+\t\t  else\n+\t\t    phase2_call_unexpected_after_unwind = 1;\n+\t\t}\n+\t      if (data[0] & uint32_highbit)\n+\t\tdata++;\n+\t      data += rtti_count + 1;\n+\t      break;\n+\n+\t    default:\n+\t      /* Should never happen.  */\n+\t      return _URC_FAILURE;\n+\t    }\n+\t  /* Finished processing this descriptor.  */\n+\t}\n+    }\n+\n+  if (id >= 3)\n+    {\n+      /* 24-bit ecoding */\n+      if (__gnu_unwind_24bit (context, uws.data, id == 4) != _URC_OK)\n+\treturn _URC_FAILURE;\n+    }\n+  else\n+    {\n+      if (__gnu_unwind_execute (context, &uws) != _URC_OK)\n+\treturn _URC_FAILURE;\n+    }\n+    \n+  if (phase2_call_unexpected_after_unwind)\n+    {\n+      /* Enter __cxa_unexpected as if called from the call site.  */\n+      _Unwind_SetGR (context, R_LR, _Unwind_GetGR (context, R_PC));\n+      _Unwind_SetGR (context, R_PC, (_uw) &__cxa_call_unexpected);\n+      return _URC_INSTALL_CONTEXT;\n+    }\n+\n+  return _URC_CONTINUE_UNWIND;\n+}"}, {"sha": "bd4941db3e2d584489c70d13eb598e3a27268505", "filename": "libgcc/unwind-c.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Funwind-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libgcc%2Funwind-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-c.c?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -130,10 +130,10 @@ PERSONALITY_FUNCTION (int version,\n \n   /* The dwarf unwinder assumes the context structure holds things like the\n      function and LSDA pointers.  The ARM implementation caches these in\n-     the exception header (UCB).  To avoid rewriting everything we make the\n-     virtual IP register point at the UCB.  */\n+     the exception header (UCB).  To avoid rewriting everything we make a\n+     virtual scratch register point at the UCB.  */\n   ip = (_Unwind_Ptr) ue_header;\n-  _Unwind_SetGR (context, 12, ip);\n+  _Unwind_SetGR (context, UNWIND_POINTER_REG, ip);\n #else\n   if (version != 1)\n     return _URC_FATAL_PHASE1_ERROR;"}, {"sha": "4631abc69052de8f8008e6a3dd112d66c313f88c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -1,3 +1,15 @@\n+2011-09-13  Paul Brook  <paul@codesourcery.com>\n+ \n+\t* libsupc++/eh_arm.cc (__cxa_end_cleanup): Add C6X implementation.\n+\t* libsupc++/eh_call.cc (__cxa_call_unexpected): Set rtti_base.\n+\t* libsupc++/eh_personality.cc (NO_SIZE_OF_ENCODED_VALUE): Remove\n+\t__ARM_EABI_UNWINDER__ check.\n+\t(parse_lsda_header): Check _GLIBCXX_OVERRIDE_TTYPE_ENCODING.\n+\t(get_ttype_entry): Use generic implementation on ARM EABI.\n+\t(check_exception_spec): Use _Unwind_decode_typeinfo_ptr and\n+\tUNWIND_STACK_REG.\n+\t(PERSONALITY_FUNCTION): Set ttype_base.\n+\n 2011-09-12  Daniel Krugler  <daniel.kruegler@googlemail.com>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "0f0b026710104eb885eced9e43aba8c7812a4ed4", "filename": "libstdc++-v3/libsupc++/eh_arm.cc", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -155,6 +155,49 @@ __gnu_end_cleanup(void)\n   return &header->unwindHeader;\n }\n \n+#ifdef __TMS320C6X__\n+// Assembly wrapper to call __gnu_end_cleanup without clobbering\n+// function arguments to _Unwind_Resume.\n+asm (\".global __cxa_end_cleanup\\n\"\n+\"\t.type __cxa_end_cleanup, \\\"function\\\"\\n\"\n+\"__cxa_end_cleanup:\\n\"\n+\"\tstw\t.d2t2\tB9, *B15--[10]\\n\"\n+\"\tstw\t.d2t2\tB8, *+B15[9]\\n\"\n+\"\tstw\t.d2t2\tB7, *+B15[8]\\n\"\n+\"\tstw\t.d2t2\tB6, *+B15[7]\\n\"\n+\"\tstw\t.d2t2\tB5, *+B15[6]\\n\"\n+\"\tstw\t.d2t2\tB4, *+B15[5]\\n\"\n+\"\tstw\t.d2t1\tA9, *+B15[4]\\n\"\n+\"\tstw\t.d2t1\tA8, *+B15[3]\\n\"\n+\"\tstw\t.d2t1\tA7, *+B15[2]\\n\"\n+\"\tstw\t.d2t1\tA6, *+B15[1]\\n\"\n+#ifdef _TMS320C6400_PLUS\n+\"\tcallp\t.s2\t(__gnu_end_cleanup), B3\\n\"\n+#elif defined(_TMS320C6400)\n+\"\tcall\t.s2\t(__gnu_end_cleanup)\\n\"\n+\"\taddkpc\t.s2\t1f, B3, 0\\n\"\n+\"\tnop\t\t4\\n\"\n+\"1:\\n\"\n+#else\n+\"\tcall\t.s2\t(__gnu_end_cleanup)\\n\"\n+\"\tmvkl\t.s2\t1f, B3\\n\"\n+\"\tmvkh\t.s2\t1f, B3\\n\"\n+\"\tnop\t\t3\\n\"\n+\"1:\\n\"\n+#endif\n+\"\tldw\t.d2t1\t*+B15[1], A6\\n\"\n+\"\tldw\t.d2t1\t*+B15[2], A7\\n\"\n+\"\tldw\t.d2t1\t*+B15[3], A8\\n\"\n+\"\tldw\t.d2t1\t*+B15[4], A9\\n\"\n+\"\tldw\t.d2t2\t*+B15[5], B4\\n\"\n+\"\tldw\t.d2t2\t*+B15[6], B5\\n\"\n+\"\tldw\t.d2t2\t*+B15[7], B6\\n\"\n+\"\tldw\t.d2t2\t*+B15[8], B7\\n\"\n+\"\tldw\t.d2t2\t*+B15[9], B8\\n\"\n+\"\tldw\t.d2t2\t*++B15[10], B9\\n\"\n+\"\tb\t.s2\t_Unwind_Resume\\n\"\n+\"\tnop\t\t5\\n\");\n+#else\n // Assembly wrapper to call __gnu_end_cleanup without clobbering r1-r3.\n // Also push r4 to preserve stack alignment.\n #ifdef __thumb__\n@@ -179,5 +222,6 @@ asm (\"  .pushsection .text.__cxa_end_cleanup\\n\"\n \"\tbl\\t_Unwind_Resume @ Never returns\\n\"\n \"\t.popsection\\n\");\n #endif\n+#endif\n \n #endif"}, {"sha": "a6a55a4d9da73ce782a66236f695ee6a8ed1fd62", "filename": "libstdc++-v3/libsupc++/eh_call.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -73,6 +73,7 @@ __cxa_call_unexpected(void* exc_obj_in)\n   int rtti_count = 0;\n   _Unwind_Word rtti_stride = 0;\n   _Unwind_Word* rtti_list = NULL;\n+  _Unwind_Ptr rtti_base = 0;\n   bool foreign_exception;\n   std::unexpected_handler unexpectedHandler = NULL;\n   std::terminate_handler terminateHandler = NULL;\n@@ -84,7 +85,7 @@ __cxa_call_unexpected(void* exc_obj_in)\n       unexpectedHandler = xh->unexpectedHandler;\n       terminateHandler = xh->terminateHandler;\n       rtti_count = exc_obj->barrier_cache.bitpattern[1];\n-\n+      rtti_base = (_Unwind_Ptr) exc_obj->barrier_cache.bitpattern[2];\n       rtti_stride = exc_obj->barrier_cache.bitpattern[3];\n       rtti_list = (_Unwind_Word*) exc_obj->barrier_cache.bitpattern[4];\n       foreign_exception = false;\n@@ -134,7 +135,7 @@ __cxa_call_unexpected(void* exc_obj_in)\n \t  _Unwind_Word offset;\n \n \t  offset = (_Unwind_Word) &rtti_list[n * (rtti_stride >> 2)];\n-\t  offset = _Unwind_decode_target2(offset);\n+\t  offset = _Unwind_decode_typeinfo_ptr(rtti_base, offset);\n \t  catch_type = (const std::type_info*) (offset);\n \n \t  if (__cxa_type_match(&new_xh->unwindHeader, catch_type, false,"}, {"sha": "729d688d7c837cc637957ad72b6299521108700d", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=1e874273f8d6e8a7bdfe7bc76fceb7d20d1f1ef2", "patch": "@@ -30,11 +30,8 @@\n #include <cxxabi.h>\n #include \"unwind-cxx.h\"\n \n-using namespace __cxxabiv1;\n \n-#ifdef __ARM_EABI_UNWINDER__\n-#define NO_SIZE_OF_ENCODED_VALUE\n-#endif\n+using namespace __cxxabiv1;\n \n #include \"unwind-pe.h\"\n \n@@ -70,6 +67,11 @@ parse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n   info->ttype_encoding = *p++;\n   if (info->ttype_encoding != DW_EH_PE_omit)\n     {\n+#if _GLIBCXX_OVERRIDE_TTYPE_ENCODING\n+      /* Older ARM EABI toolchains set this value incorrectly, so use a\n+\t hardcoded OS-specific format.  */\n+      info->ttype_encoding = _GLIBCXX_OVERRIDE_TTYPE_ENCODING;\n+#endif\n       p = read_uleb128 (p, &tmp);\n       info->TType = p + tmp;\n     }\n@@ -85,21 +87,22 @@ parse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n   return p;\n }\n \n-#ifdef __ARM_EABI_UNWINDER__\n-\n // Return an element from a type table.\n \n-static const std::type_info*\n-get_ttype_entry(lsda_header_info* info, _uleb128_t i)\n+static const std::type_info *\n+get_ttype_entry (lsda_header_info *info, _uleb128_t i)\n {\n   _Unwind_Ptr ptr;\n \n-  ptr = (_Unwind_Ptr) (info->TType - (i * 4));\n-  ptr = _Unwind_decode_target2(ptr);\n-  \n+  i *= size_of_encoded_value (info->ttype_encoding);\n+  read_encoded_value_with_base (info->ttype_encoding, info->ttype_base,\n+\t\t\t\tinfo->TType - i, &ptr);\n+\n   return reinterpret_cast<const std::type_info *>(ptr);\n }\n \n+#ifdef __ARM_EABI_UNWINDER__\n+\n // The ABI provides a routine for matching exception object types.\n typedef _Unwind_Control_Block _throw_typet;\n #define get_adjusted_ptr(catch_type, throw_type, thrown_ptr_p) \\\n@@ -127,7 +130,7 @@ check_exception_spec(lsda_header_info* info, _throw_typet* throw_type,\n       if (tmp == 0)\n         return false;\n \n-      tmp = _Unwind_decode_target2((_Unwind_Word) e);\n+      tmp = _Unwind_decode_typeinfo_ptr(info->ttype_base, (_Unwind_Word) e);\n \n       // Match a ttype entry.\n       catch_type = reinterpret_cast<const std::type_info*>(tmp);\n@@ -157,7 +160,7 @@ save_caught_exception(struct _Unwind_Exception* ue_header,\n \t\t      const unsigned char* action_record\n \t\t\t__attribute__((__unused__)))\n {\n-    ue_header->barrier_cache.sp = _Unwind_GetGR(context, 13);\n+    ue_header->barrier_cache.sp = _Unwind_GetGR(context, UNWIND_STACK_REG);\n     ue_header->barrier_cache.bitpattern[0] = (_uw) thrown_ptr;\n     ue_header->barrier_cache.bitpattern[1]\n       = (_uw) handler_switch_value;\n@@ -205,20 +208,6 @@ empty_exception_spec (lsda_header_info *info, _Unwind_Sword filter_value)\n typedef const std::type_info _throw_typet;\n \n \n-// Return an element from a type table.\n-\n-static const std::type_info *\n-get_ttype_entry (lsda_header_info *info, _uleb128_t i)\n-{\n-  _Unwind_Ptr ptr;\n-\n-  i *= size_of_encoded_value (info->ttype_encoding);\n-  read_encoded_value_with_base (info->ttype_encoding, info->ttype_base,\n-\t\t\t\tinfo->TType - i, &ptr);\n-\n-  return reinterpret_cast<const std::type_info *>(ptr);\n-}\n-\n // Given the thrown type THROW_TYPE, pointer to a variable containing a\n // pointer to the exception object THROWN_PTR_P and a type CATCH_TYPE to\n // compare against, return whether or not there is a match and if so,\n@@ -390,7 +379,8 @@ PERSONALITY_FUNCTION (int version,\n     case _US_UNWIND_FRAME_STARTING:\n       actions = _UA_CLEANUP_PHASE;\n       if (!(state & _US_FORCE_UNWIND)\n-\t  && ue_header->barrier_cache.sp == _Unwind_GetGR(context, 13))\n+\t  && ue_header->barrier_cache.sp == _Unwind_GetGR(context,\n+\t\t\t\t\t\t\t  UNWIND_STACK_REG))\n \tactions |= _UA_HANDLER_FRAME;\n       break;\n \n@@ -410,10 +400,10 @@ PERSONALITY_FUNCTION (int version,\n \n   // The dwarf unwinder assumes the context structure holds things like the\n   // function and LSDA pointers.  The ARM implementation caches these in\n-  // the exception header (UCB).  To avoid rewriting everything we make the\n-  // virtual IP register point at the UCB.\n+  // the exception header (UCB).  To avoid rewriting everything we make a\n+  // virtual scratch register point at the UCB.\n   ip = (_Unwind_Ptr) ue_header;\n-  _Unwind_SetGR(context, 12, ip);\n+  _Unwind_SetGR(context, UNWIND_POINTER_REG, ip);\n #else\n   __cxa_exception* xh = __get_exception_header_from_ue(ue_header);\n \n@@ -679,6 +669,8 @@ PERSONALITY_FUNCTION (int version,\n       if (handler_switch_value < 0)\n \t{\n \t  parse_lsda_header (context, language_specific_data, &info);\n+\t  info.ttype_base = base_of_encoded_value (info.ttype_encoding,\n+\t\t\t\t\t\t   context);\n \n #ifdef __ARM_EABI_UNWINDER__\n \t  const _Unwind_Word* e;\n@@ -692,8 +684,8 @@ PERSONALITY_FUNCTION (int version,\n \n \t  // Count.\n \t  ue_header->barrier_cache.bitpattern[1] = n;\n-\t  // Base (obsolete)\n-\t  ue_header->barrier_cache.bitpattern[2] = 0;\n+\t  // Base\n+\t  ue_header->barrier_cache.bitpattern[2] = info.ttype_base;\n \t  // Stride.\n \t  ue_header->barrier_cache.bitpattern[3] = 4;\n \t  // List head."}]}