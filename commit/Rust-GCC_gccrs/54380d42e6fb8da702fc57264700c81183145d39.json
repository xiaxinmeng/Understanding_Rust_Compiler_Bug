{"sha": "54380d42e6fb8da702fc57264700c81183145d39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzODBkNDJlNmZiOGRhNzAyZmM1NzI2NDcwMGM4MTE4MzE0NWQzOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-27T16:59:15Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-27T17:07:32Z"}, "message": "c++: Kill nested_udts\n\nDuring the implementation of modules I added myself a note to\nimplement nested_udt handling.  It wasn't obvious to me what they were\nfor and nothing seemed to be broken in ignoring them.  I figured\nsomething would eventually pop up and I'd add support.  Nothing popped up.\n\nInvestigating on trunk discovered 3 places where we look at the\nnested-udts.  I couldn't figure how the one in lookup_field_r was\nneeded -- surely the regular lookup would find the type.  It turned\nout that code was unreachable.  So we can delete it.\n\nNext in do_type_instantiation, we walk the nested-utd table\ninstantiating types.  But those types are also on the TYPE_FIELDS\nlist, which we've just iterated over.  So I can move the handling into\nthat loop.\n\nThe final use is in handling structs that have a typedef name for\nlinkage purposes.  Again, we can just iterate over TYPE_FIELDS.  (As\ncommented, we probably don't need to do even that, as a DR, whose\nnumber I forget, requires such structs to only have C-like things in\nthem.  But I didn't go that far.\n\nHaving removed all the uses of nested-udts, I can remove their\ncreation from name-lookup, and as the only instance of a binding_table\nobject, we can remove all that code too.\n\n\tgcc/cp/\n\t* cp-tree.h (struct lang_type): Delete nested_udts field.\n\t(CLASSTYPE_NESTED_UTDS): Delete.\n\t* name-lookup.h (binding_table, binding_entry): Delete typedefs.\n\t(bt_foreach_proc): Likewise.\n\t(struct binding_entry_s): Delete.\n\t(SCOPE_DEFAULT_HT_SIZE, CLASS_SCOPE_HT_SIZE)\n\t(NAMESPACE_ORDINARY_HT_SIZE, NAMESPACE_STD_HT_SIZE)\n\t(GLOBAL_SCOPE_HT_SIZE): Delete.\n\t(binding_table_foreach, binding_table_find): Delete declarations.\n\t* name-lookup.c (ENTRY_INDEX): Delete.\n\t(free_binding_entry): Delete.\n\t(binding_entry_make, binding_entry_free): Delete.\n\t(struct binding_table_s): Delete.\n\t(binding_table_construct, binding_table_free): Delete.\n\t(binding_table_new, binding_table_expand): Delete.\n\t(binding_table_insert, binding_table_find): Delete.\n\t(binding_table_foreach): Delete.\n\t(maybe_process_template_type_declaration): Delete\n\tCLASSTYPE_NESTED_UTDS insertion.\n\t(do_pushtag): Likewise.\n\t* decl2.c (bt_reset_linkage_1): Fold into reset_type_linkage_1.\n\t(reset_type_linkage_2, bt_reset_linkage_2): Fold into\n\treset_type_linkage.\n\t* pt.c (instantiate_class_template_1): Delete NESTED_UTDs comment.\n\t(bt_instantiate_type_proc): Delete.\n\t(do_type_instantiation): Instantiate implicit typedef fields.\n\tDelete NESTED_UTD walk.\n\t* search.c (lookup_field_r): Delete unreachable NESTED_UTD\n\tsearch.", "tree": {"sha": "7600befe8aa03482a638a5ffaec27effcee5ccb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7600befe8aa03482a638a5ffaec27effcee5ccb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54380d42e6fb8da702fc57264700c81183145d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54380d42e6fb8da702fc57264700c81183145d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54380d42e6fb8da702fc57264700c81183145d39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54380d42e6fb8da702fc57264700c81183145d39/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f8b3dda534277feccb16ba055c01908db15873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f8b3dda534277feccb16ba055c01908db15873", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f8b3dda534277feccb16ba055c01908db15873"}], "stats": {"total": 323, "additions": 25, "deletions": 298}, "files": [{"sha": "4f9038eb201cc7e6e6fdf83d2404450d6acc5352", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=54380d42e6fb8da702fc57264700c81183145d39", "patch": "@@ -2219,7 +2219,6 @@ struct GTY(()) lang_type {\n   tree vtables;\n   tree typeinfo_var;\n   vec<tree, va_gc> *vbases;\n-  binding_table nested_udts;\n   tree as_base;\n   vec<tree, va_gc> *pure_virtuals;\n   tree friend_classes;\n@@ -2372,12 +2371,6 @@ struct GTY(()) lang_type {\n #define CLASSTYPE_DESTRUCTOR(NODE) \\\n   (get_class_binding_direct (NODE, dtor_identifier))\n \n-/* A dictionary of the nested user-defined-types (class-types, or enums)\n-   found within this class.  This table includes nested member class\n-   templates.  */\n-#define CLASSTYPE_NESTED_UTDS(NODE) \\\n-   (LANG_TYPE_CLASS_CHECK (NODE)->nested_udts)\n-\n /* Nonzero if NODE has a primary base class, i.e., a base class with\n    which it shares the virtual function table pointer.  */\n #define CLASSTYPE_HAS_PRIMARY_BASE_P(NODE) \\"}, {"sha": "6fd081463f7b00c000ab304efc50e468f5dfb58c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=54380d42e6fb8da702fc57264700c81183145d39", "patch": "@@ -2894,9 +2894,8 @@ constrain_class_visibility (tree type)\n /* Functions for adjusting the visibility of a tagged type and its nested\n    types and declarations when it gets a name for linkage purposes from a\n    typedef.  */\n-\n-static void bt_reset_linkage_1 (binding_entry, void *);\n-static void bt_reset_linkage_2 (binding_entry, void *);\n+// FIXME: It is now a DR for such a class type to contain anything\n+// other than C.  So at minium most of this can probably be deleted.\n \n /* First reset the visibility of all the types.  */\n \n@@ -2905,13 +2904,9 @@ reset_type_linkage_1 (tree type)\n {\n   set_linkage_according_to_type (type, TYPE_MAIN_DECL (type));\n   if (CLASS_TYPE_P (type))\n-    binding_table_foreach (CLASSTYPE_NESTED_UTDS (type),\n-\t\t\t   bt_reset_linkage_1, NULL);\n-}\n-static void\n-bt_reset_linkage_1 (binding_entry b, void */*data*/)\n-{\n-  reset_type_linkage_1 (b->type);\n+    for (tree member = TYPE_FIELDS (type); member; member = DECL_CHAIN (member))\n+      if (DECL_IMPLICIT_TYPEDEF_P (member))\n+\treset_type_linkage_1 (TREE_TYPE (member));\n }\n \n /* Then reset the visibility of any static data members or member\n@@ -2930,9 +2925,10 @@ reset_decl_linkage (tree decl)\n   tentative_decl_linkage (decl);\n }\n \n-static void\n-reset_type_linkage_2 (tree type)\n+void\n+reset_type_linkage (tree type)\n {\n+  reset_type_linkage_1 (type);\n   if (CLASS_TYPE_P (type))\n     {\n       if (tree vt = CLASSTYPE_VTABLES (type))\n@@ -2955,24 +2951,12 @@ reset_type_linkage_2 (tree type)\n \t  tree mem = STRIP_TEMPLATE (m);\n \t  if (TREE_CODE (mem) == VAR_DECL || TREE_CODE (mem) == FUNCTION_DECL)\n \t    reset_decl_linkage (mem);\n+\t  else if (DECL_IMPLICIT_TYPEDEF_P (mem))\n+\t    reset_type_linkage (TREE_TYPE (mem));\n \t}\n-      binding_table_foreach (CLASSTYPE_NESTED_UTDS (type),\n-\t\t\t     bt_reset_linkage_2, NULL);\n     }\n }\n \n-static void\n-bt_reset_linkage_2 (binding_entry b, void */*data*/)\n-{\n-  reset_type_linkage_2 (b->type);\n-}\n-void\n-reset_type_linkage (tree type)\n-{\n-  reset_type_linkage_1 (type);\n-  reset_type_linkage_2 (type);\n-}\n-\n /* Set up our initial idea of what the linkage of DECL should be.  */\n \n void"}, {"sha": "6a88e68c346b7231390d6a2e01652fc83ee7b57c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 210, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=54380d42e6fb8da702fc57264700c81183145d39", "patch": "@@ -1738,16 +1738,6 @@ insert_late_enum_def_bindings (tree klass, tree enumtype)\n     }\n }\n \n-/* Compute the chain index of a binding_entry given the HASH value of its\n-   name and the total COUNT of chains.  COUNT is assumed to be a power\n-   of 2.  */\n-\n-#define ENTRY_INDEX(HASH, COUNT) (((HASH) >> 3) & ((COUNT) - 1))\n-\n-/* A free list of \"binding_entry\"s awaiting for re-use.  */\n-\n-static GTY((deletable)) binding_entry free_binding_entry = NULL;\n-\n /* The binding oracle; see cp-tree.h.  */\n \n cp_binding_oracle_function *cp_binding_oracle;\n@@ -1770,180 +1760,6 @@ query_oracle (tree name)\n   cp_binding_oracle (CP_ORACLE_IDENTIFIER, name);\n }\n \n-/* Create a binding_entry object for (NAME, TYPE).  */\n-\n-static inline binding_entry\n-binding_entry_make (tree name, tree type)\n-{\n-  binding_entry entry;\n-\n-  if (free_binding_entry)\n-    {\n-      entry = free_binding_entry;\n-      free_binding_entry = entry->chain;\n-    }\n-  else\n-    entry = ggc_alloc<binding_entry_s> ();\n-\n-  entry->name = name;\n-  entry->type = type;\n-  entry->chain = NULL;\n-\n-  return entry;\n-}\n-\n-/* Put ENTRY back on the free list.  */\n-#if 0\n-static inline void\n-binding_entry_free (binding_entry entry)\n-{\n-  entry->name = NULL;\n-  entry->type = NULL;\n-  entry->chain = free_binding_entry;\n-  free_binding_entry = entry;\n-}\n-#endif\n-\n-/* The datatype used to implement the mapping from names to types at\n-   a given scope.  */\n-struct GTY(()) binding_table_s {\n-  /* Array of chains of \"binding_entry\"s  */\n-  binding_entry * GTY((length (\"%h.chain_count\"))) chain;\n-\n-  /* The number of chains in this table.  This is the length of the\n-     member \"chain\" considered as an array.  */\n-  size_t chain_count;\n-\n-  /* Number of \"binding_entry\"s in this table.  */\n-  size_t entry_count;\n-};\n-\n-/* Construct TABLE with an initial CHAIN_COUNT.  */\n-\n-static inline void\n-binding_table_construct (binding_table table, size_t chain_count)\n-{\n-  table->chain_count = chain_count;\n-  table->entry_count = 0;\n-  table->chain = ggc_cleared_vec_alloc<binding_entry> (table->chain_count);\n-}\n-\n-/* Make TABLE's entries ready for reuse.  */\n-#if 0\n-static void\n-binding_table_free (binding_table table)\n-{\n-  size_t i;\n-  size_t count;\n-\n-  if (table == NULL)\n-    return;\n-\n-  for (i = 0, count = table->chain_count; i < count; ++i)\n-    {\n-      binding_entry temp = table->chain[i];\n-      while (temp != NULL)\n-\t{\n-\t  binding_entry entry = temp;\n-\t  temp = entry->chain;\n-\t  binding_entry_free (entry);\n-\t}\n-      table->chain[i] = NULL;\n-    }\n-  table->entry_count = 0;\n-}\n-#endif\n-\n-/* Allocate a table with CHAIN_COUNT, assumed to be a power of two.  */\n-\n-static inline binding_table\n-binding_table_new (size_t chain_count)\n-{\n-  binding_table table = ggc_alloc<binding_table_s> ();\n-  table->chain = NULL;\n-  binding_table_construct (table, chain_count);\n-  return table;\n-}\n-\n-/* Expand TABLE to twice its current chain_count.  */\n-\n-static void\n-binding_table_expand (binding_table table)\n-{\n-  const size_t old_chain_count = table->chain_count;\n-  const size_t old_entry_count = table->entry_count;\n-  const size_t new_chain_count = 2 * old_chain_count;\n-  binding_entry *old_chains = table->chain;\n-  size_t i;\n-\n-  binding_table_construct (table, new_chain_count);\n-  for (i = 0; i < old_chain_count; ++i)\n-    {\n-      binding_entry entry = old_chains[i];\n-      for (; entry != NULL; entry = old_chains[i])\n-\t{\n-\t  const unsigned int hash = IDENTIFIER_HASH_VALUE (entry->name);\n-\t  const size_t j = ENTRY_INDEX (hash, new_chain_count);\n-\n-\t  old_chains[i] = entry->chain;\n-\t  entry->chain = table->chain[j];\n-\t  table->chain[j] = entry;\n-\t}\n-    }\n-  table->entry_count = old_entry_count;\n-}\n-\n-/* Insert a binding for NAME to TYPE into TABLE.  */\n-\n-static void\n-binding_table_insert (binding_table table, tree name, tree type)\n-{\n-  const unsigned int hash = IDENTIFIER_HASH_VALUE (name);\n-  const size_t i = ENTRY_INDEX (hash, table->chain_count);\n-  binding_entry entry = binding_entry_make (name, type);\n-\n-  entry->chain = table->chain[i];\n-  table->chain[i] = entry;\n-  ++table->entry_count;\n-\n-  if (3 * table->chain_count < 5 * table->entry_count)\n-    binding_table_expand (table);\n-}\n-\n-/* Return the binding_entry, if any, that maps NAME.  */\n-\n-binding_entry\n-binding_table_find (binding_table table, tree name)\n-{\n-  const unsigned int hash = IDENTIFIER_HASH_VALUE (name);\n-  binding_entry entry = table->chain[ENTRY_INDEX (hash, table->chain_count)];\n-\n-  while (entry != NULL && entry->name != name)\n-    entry = entry->chain;\n-\n-  return entry;\n-}\n-\n-/* Apply PROC -- with DATA -- to all entries in TABLE.  */\n-\n-void\n-binding_table_foreach (binding_table table, bt_foreach_proc proc, void *data)\n-{\n-  size_t chain_count;\n-  size_t i;\n-\n-  if (!table)\n-    return;\n-\n-  chain_count = table->chain_count;\n-  for (i = 0; i < chain_count; ++i)\n-    {\n-      binding_entry entry = table->chain[i];\n-      for (; entry != NULL; entry = entry->chain)\n-\tproc (entry, data);\n-    }\n-}\n-\f\n #ifndef ENABLE_SCOPE_CHECKING\n #  define ENABLE_SCOPE_CHECKING 0\n #else\n@@ -6884,10 +6700,6 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n \n       if (processing_template_decl)\n \t{\n-\t  /* This may change after the call to push_template_decl, but\n-\t     we want the original value.  */\n-\t  tree name = DECL_NAME (decl);\n-\n \t  decl = push_template_decl (decl, is_friend);\n \t  if (decl == error_mark_node)\n \t    return error_mark_node;\n@@ -6906,17 +6718,8 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n \t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n \n \t      if (!COMPLETE_TYPE_P (current_class_type))\n-\t\t{\n-\t\t  maybe_add_class_template_decl_list (current_class_type,\n-\t\t\t\t\t\t      type, /*friend_p=*/0);\n-\t\t  /* Put this UTD in the table of UTDs for the class.  */\n-\t\t  if (CLASSTYPE_NESTED_UTDS (current_class_type) == NULL)\n-\t\t    CLASSTYPE_NESTED_UTDS (current_class_type) =\n-\t\t      binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n-\n-\t\t  binding_table_insert\n-\t\t    (CLASSTYPE_NESTED_UTDS (current_class_type), name, type);\n-\t\t}\n+\t\tmaybe_add_class_template_decl_list (current_class_type,\n+\t\t\t\t\t\t    type, /*friend_p=*/0);\n \t    }\n \t}\n     }\n@@ -7077,17 +6880,8 @@ do_pushtag (tree name, tree type, TAG_how how)\n \n   if (b->kind == sk_class\n       && !COMPLETE_TYPE_P (current_class_type))\n-    {\n-      maybe_add_class_template_decl_list (current_class_type,\n-\t\t\t\t\t  type, /*friend_p=*/0);\n-\n-      if (CLASSTYPE_NESTED_UTDS (current_class_type) == NULL)\n-\tCLASSTYPE_NESTED_UTDS (current_class_type)\n-\t  = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n-\n-      binding_table_insert\n-\t(CLASSTYPE_NESTED_UTDS (current_class_type), name, type);\n-    }\n+    maybe_add_class_template_decl_list (current_class_type,\n+\t\t\t\t\ttype, /*friend_p=*/0);\n \n   decl = TYPE_NAME (type);\n   gcc_assert (TREE_CODE (decl) == TYPE_DECL);"}, {"sha": "6d18539e7308e7ff5eaf8840308e0e8a97636a19", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=54380d42e6fb8da702fc57264700c81183145d39", "patch": "@@ -23,29 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"c-family/c-common.h\"\n \n-/* The type of dictionary used to map names to types declared at\n-   a given scope.  */\n-typedef struct binding_table_s *binding_table;\n-typedef struct binding_entry_s *binding_entry;\n-\n-/* The type of a routine repeatedly called by binding_table_foreach.  */\n-typedef void (*bt_foreach_proc) (binding_entry, void *);\n-\n-struct GTY(()) binding_entry_s {\n-  binding_entry chain;\n-  tree name;\n-  tree type;\n-};\n-\n-/* These macros indicate the initial chains count for binding_table.  */\n-#define SCOPE_DEFAULT_HT_SIZE\t\t(1 << 3)\n-#define CLASS_SCOPE_HT_SIZE\t\t(1 << 3)\n-#define NAMESPACE_ORDINARY_HT_SIZE\t(1 << 5)\n-#define NAMESPACE_STD_HT_SIZE\t\t(1 << 8)\n-#define GLOBAL_SCOPE_HT_SIZE\t\t(1 << 8)\n-\n-extern void binding_table_foreach (binding_table, bt_foreach_proc, void *);\n-extern binding_entry binding_table_find (binding_table, tree);\n \f\n /* The datatype used to implement C++ scope.  */\n struct cp_binding_level;"}, {"sha": "7e401e1cb8aecd3eb431fd61dfc35c0ebaec1dbb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=54380d42e6fb8da702fc57264700c81183145d39", "patch": "@@ -11851,7 +11851,6 @@ instantiate_class_template_1 (tree type)\n \t\t   Ignore it; it will be regenerated when needed.  */\n \t\tcontinue;\n \n-\t      /* Build new CLASSTYPE_NESTED_UTDS.  */\n \t      bool class_template_p = (TREE_CODE (t) != ENUMERAL_TYPE\n \t\t\t\t       && TYPE_LANG_SPECIFIC (t)\n \t\t\t\t       && CLASSTYPE_IS_TEMPLATE (t));\n@@ -12009,10 +12008,10 @@ instantiate_class_template_1 (tree type)\n \t\t\t    TREE_TYPE (r) = error_mark_node;\n \t\t\t}\n \n-\t\t      /* If it is a TYPE_DECL for a class-scoped ENUMERAL_TYPE,\n-\t\t\t such a thing will already have been added to the field\n-\t\t\t list by tsubst_enum in finish_member_declaration in the\n-\t\t\t CLASSTYPE_NESTED_UTDS case above.  */\n+\t\t      /* If it is a TYPE_DECL for a class-scoped\n+\t\t\t ENUMERAL_TYPE, such a thing will already have\n+\t\t\t been added to the field list by tsubst_enum\n+\t\t\t in finish_member_declaration case above.  */\n \t\t      if (!(TREE_CODE (r) == TYPE_DECL\n \t\t\t    && TREE_CODE (TREE_TYPE (r)) == ENUMERAL_TYPE\n \t\t\t    && DECL_ARTIFICIAL (r)))\n@@ -24959,19 +24958,6 @@ mark_class_instantiated (tree t, int extern_p)\n     }\n }\n \n-/* Called from do_type_instantiation through binding_table_foreach to\n-   do recursive instantiation for the type bound in ENTRY.  */\n-static void\n-bt_instantiate_type_proc (binding_entry entry, void *data)\n-{\n-  tree storage = tree (data);\n-\n-  if (CLASS_TYPE_P (entry->type)\n-      && CLASSTYPE_TEMPLATE_INFO (entry->type)\n-      && !uses_template_parms (CLASSTYPE_TI_ARGS (entry->type)))\n-    do_type_instantiation (entry->type, storage, 0);\n-}\n-\n /* Perform an explicit instantiation of template class T.  STORAGE, if\n    non-null, is the RID for extern, inline or static.  COMPLAIN is\n    nonzero if this is called from the parser, zero if called recursively,\n@@ -25095,10 +25081,14 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \t  instantiate_decl (fld, /*defer_ok=*/true,\n \t\t\t    /*expl_inst_class_mem_p=*/true);\n       }\n+    else if (DECL_IMPLICIT_TYPEDEF_P (fld))\n+      {\n+\ttree type = TREE_TYPE (fld);\n \n-  if (CLASSTYPE_NESTED_UTDS (t))\n-    binding_table_foreach (CLASSTYPE_NESTED_UTDS (t),\n-\t\t\t   bt_instantiate_type_proc, storage);\n+\tif (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INFO (type)\n+\t    && !uses_template_parms (CLASSTYPE_TI_ARGS (type)))\n+\t  do_type_instantiation (type, storage, 0);\n+      }\n }\n \n /* Given a function DECL, which is a specialization of TMPL, modify"}, {"sha": "8a1de7c49aa68b653a7f3d41729707dfcba0f9e3", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54380d42e6fb8da702fc57264700c81183145d39/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=54380d42e6fb8da702fc57264700c81183145d39", "patch": "@@ -977,17 +977,6 @@ lookup_field_r (tree binfo, void *data)\n \n   nval = get_class_binding (type, lfi->name, lfi->want_type);\n \n-  /* If we're looking up a type (as with an elaborated type specifier)\n-     we ignore all non-types we find.  */\n-  if (lfi->want_type && nval && !DECL_DECLARES_TYPE_P (nval))\n-    {\n-      nval = NULL_TREE;\n-      if (CLASSTYPE_NESTED_UTDS (type))\n-\tif (binding_entry e = binding_table_find (CLASSTYPE_NESTED_UTDS (type),\n-\t\t\t\t\t\t  lfi->name))\n-\t  nval = TYPE_MAIN_DECL (e->type);\n-    }\n-\n   /* If there is no declaration with the indicated name in this type,\n      then there's nothing to do.  */\n   if (!nval)"}]}