{"sha": "8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5YTFiYTdiYmQ1YmY1YjdmNWNmZTFjODhkZDM4ZDcwYWM1NGJiYw==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-08T17:32:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-08T17:32:18Z"}, "message": "[multiple changes]\n\n2017-11-08  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* lib-xref.ads, lib-xref-spark_specific.adb\n\t(Traverse_Compilation_Unit): Move declaration to package body.\n\n2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_spark.adb (Expand_SPARK_N_Object_Renaming_Declaration): Obtain\n\tthe type of the renaming from its defining entity, rather then the\n\tsubtype mark as there may not be a subtype mark.\n\n2017-11-08  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* adaint.c, s-oscons-tmplt.c, init.c, libgnat/system-qnx-aarch64.ads,\n\tlibgnarl/a-intnam__qnx.ads, libgnarl/s-intman__qnx.adb,\n\tlibgnarl/s-osinte__qnx.ads, libgnarl/s-qnx.ads,\n\tlibgnarl/s-taprop__qnx.adb, s-oscons-tmplt.c, sigtramp-qnx.c,\n\tterminals.c: Initial port of GNAT for aarch64-qnx\n\n2017-11-08  Elisa Barboni  <barboni@adacore.com>\n\n\t* exp_util.adb (Find_DIC_Type): Move...\n\t* sem_util.ads, sem_util.adb (Find_DIC_Type): ... here.\n\n2017-11-08  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_res.adb (Resolve_Allocator): Add info messages corresponding to\n\tthe owner and corresponding coextension.\n\n2017-11-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Delta_Aggregate): Divide into the\n\tfollowing separate procedures.\n\t(Resolve_Delta_Array_Aggregate): Previous code form\n\tResolve_Delta_Aggregate.\n\t(Resolve_Delta_Record_Aggregate): Extend previous code to cover latest\n\tARG decisions on the legality rules for delta aggregates for records:\n\tin the case of a variant record, components from different variants\n\tcannot be specified in the delta aggregate, and this must be checked\n\tstatically.\n\nFrom-SVN: r254547", "tree": {"sha": "0d28abbe3786d9d0c64899f7a027fcd7065d8a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d28abbe3786d9d0c64899f7a027fcd7065d8a71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/comments", "author": null, "committer": null, "parents": [{"sha": "76b37a56d234f98a8f30c9e22f24cb02edb75e23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b37a56d234f98a8f30c9e22f24cb02edb75e23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b37a56d234f98a8f30c9e22f24cb02edb75e23"}], "stats": {"total": 3863, "additions": 3683, "deletions": 180}, "files": [{"sha": "ce7872b3ef422fe54215a970b41f7fb50a0881ee", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -1,3 +1,44 @@\n+2017-11-08  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* lib-xref.ads, lib-xref-spark_specific.adb\n+\t(Traverse_Compilation_Unit): Move declaration to package body.\n+\n+2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_spark.adb (Expand_SPARK_N_Object_Renaming_Declaration): Obtain\n+\tthe type of the renaming from its defining entity, rather then the\n+\tsubtype mark as there may not be a subtype mark.\n+\n+2017-11-08  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* adaint.c, s-oscons-tmplt.c, init.c, libgnat/system-qnx-aarch64.ads,\n+\tlibgnarl/a-intnam__qnx.ads, libgnarl/s-intman__qnx.adb,\n+\tlibgnarl/s-osinte__qnx.ads, libgnarl/s-qnx.ads,\n+\tlibgnarl/s-taprop__qnx.adb, s-oscons-tmplt.c, sigtramp-qnx.c,\n+\tterminals.c: Initial port of GNAT for aarch64-qnx\n+\n+2017-11-08  Elisa Barboni  <barboni@adacore.com>\n+\n+\t* exp_util.adb (Find_DIC_Type): Move...\n+\t* sem_util.ads, sem_util.adb (Find_DIC_Type): ... here.\n+\n+2017-11-08  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Allocator): Add info messages corresponding to\n+\tthe owner and corresponding coextension.\n+\n+2017-11-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Delta_Aggregate): Divide into the\n+\tfollowing separate procedures.\n+\t(Resolve_Delta_Array_Aggregate): Previous code form\n+\tResolve_Delta_Aggregate.\n+\t(Resolve_Delta_Record_Aggregate): Extend previous code to cover latest\n+\tARG decisions on the legality rules for delta aggregates for records:\n+\tin the case of a variant record, components from different variants\n+\tcannot be specified in the delta aggregate, and this must be checked\n+\tstatically.\n+\n 2017-11-08  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* spark_xrefs.ads (SPARK_Scope_Record): Remove File_Num component."}, {"sha": "cb0f4bb93b0b579d4ba2561086d5486aad49a366", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -1012,7 +1012,7 @@ __gnat_open_new_temp (char *path, int fmode)\n \n #if (defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \\\n   || defined (__linux__) || defined (__GLIBC__) || defined (__ANDROID__) \\\n-  || defined (__DragonFly__)) && !defined (__vxworks)\n+  || defined (__DragonFly__) || defined (__QNX__)) && !defined (__vxworks)\n   return mkstemp (path);\n #elif defined (__Lynx__)\n   mktemp (path);\n@@ -1185,7 +1185,7 @@ __gnat_tmp_name (char *tmp_filename)\n \n #elif defined (__linux__) || defined (__FreeBSD__) || defined (__NetBSD__) \\\n   || defined (__OpenBSD__) || defined (__GLIBC__) || defined (__ANDROID__) \\\n-  || defined (__DragonFly__)\n+  || defined (__DragonFly__) || defined (__QNX__)\n #define MAX_SAFE_PATH 1000\n   char *tmpdir = getenv (\"TMPDIR\");\n "}, {"sha": "43ca12f79404bde531633cb61c738bdf686ed571", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -349,7 +349,7 @@ package body Exp_SPARK is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Obj_Id : constant Entity_Id  := Defining_Entity (N);\n       Nam    : constant Node_Id    := Name (N);\n-      Typ    : constant Entity_Id  := Etype (Subtype_Mark (N));\n+      Typ    : constant Entity_Id  := Etype (Obj_Id);\n \n    begin\n       --  Transform a renaming of the form"}, {"sha": "d5e8e09c94183e45f05121428906d95b7ad6e0a8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -165,11 +165,6 @@ package body Exp_Util is\n    --  Force evaluation of bounds of a slice, which may be given by a range\n    --  or by a subtype indication with or without a constraint.\n \n-   function Find_DIC_Type (Typ : Entity_Id) return Entity_Id;\n-   --  Subsidiary to all Build_DIC_Procedure_xxx routines. Find the type which\n-   --  defines the Default_Initial_Condition pragma of type Typ. This is either\n-   --  Typ itself or a parent type when the pragma is inherited.\n-\n    function Make_CW_Equivalent_Type\n      (T : Entity_Id;\n       E : Node_Id) return Entity_Id;\n@@ -5389,66 +5384,6 @@ package body Exp_Util is\n       return TSS (Utyp, TSS_Finalize_Address);\n    end Finalize_Address;\n \n-   -------------------\n-   -- Find_DIC_Type --\n-   -------------------\n-\n-   function Find_DIC_Type (Typ : Entity_Id) return Entity_Id is\n-      Curr_Typ : Entity_Id;\n-      --  The current type being examined in the parent hierarchy traversal\n-\n-      DIC_Typ : Entity_Id;\n-      --  The type which carries the DIC pragma. This variable denotes the\n-      --  partial view when private types are involved.\n-\n-      Par_Typ : Entity_Id;\n-      --  The parent type of the current type. This variable denotes the full\n-      --  view when private types are involved.\n-\n-   begin\n-      --  The input type defines its own DIC pragma, therefore it is the owner\n-\n-      if Has_Own_DIC (Typ) then\n-         DIC_Typ := Typ;\n-\n-      --  Otherwise the DIC pragma is inherited from a parent type\n-\n-      else\n-         pragma Assert (Has_Inherited_DIC (Typ));\n-\n-         --  Climb the parent chain\n-\n-         Curr_Typ := Typ;\n-         loop\n-            --  Inspect the parent type. Do not consider subtypes as they\n-            --  inherit the DIC attributes from their base types.\n-\n-            DIC_Typ := Base_Type (Etype (Curr_Typ));\n-\n-            --  Look at the full view of a private type because the type may\n-            --  have a hidden parent introduced in the full view.\n-\n-            Par_Typ := DIC_Typ;\n-\n-            if Is_Private_Type (Par_Typ)\n-              and then Present (Full_View (Par_Typ))\n-            then\n-               Par_Typ := Full_View (Par_Typ);\n-            end if;\n-\n-            --  Stop the climb once the nearest parent type which defines a DIC\n-            --  pragma of its own is encountered or when the root of the parent\n-            --  chain is reached.\n-\n-            exit when Has_Own_DIC (DIC_Typ) or else Curr_Typ = Par_Typ;\n-\n-            Curr_Typ := Par_Typ;\n-         end loop;\n-      end if;\n-\n-      return DIC_Typ;\n-   end Find_DIC_Type;\n-\n    ------------------------\n    -- Find_Interface_ADT --\n    ------------------------"}, {"sha": "e1cf4fa660e98310b68a2bf780b50d43fe9cee91", "filename": "gcc/ada/init.c", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -2516,6 +2516,104 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n+#elif defined(__QNX__)\n+\n+/***************/\n+/* QNX Section */\n+/***************/\n+\n+#include <signal.h>\n+#include <unistd.h>\n+#include <string.h>\n+#include \"sigtramp.h\"\n+\n+void\n+__gnat_map_signal (int sig,\n+\t\t   siginfo_t *si ATTRIBUTE_UNUSED,\n+\t\t   void *mcontext ATTRIBUTE_UNUSED)\n+{\n+  struct Exception_Data *exception;\n+  const char *msg;\n+\n+  switch(sig)\n+  {\n+    case SIGFPE:\n+      exception = &constraint_error;\n+      msg = \"SIGFPE\";\n+      break;\n+    case SIGILL:\n+      exception = &constraint_error;\n+      msg = \"SIGILL\";\n+      break;\n+    case SIGSEGV:\n+      exception = &storage_error;\n+      msg = \"stack overflow or erroneous memory access\";\n+      break;\n+    case SIGBUS:\n+      exception = &constraint_error;\n+      msg = \"SIGBUS\";\n+      break;\n+    default:\n+      exception = &program_error;\n+      msg = \"unhandled signal\";\n+    }\n+\n+    Raise_From_Signal_Handler (exception, msg);\n+}\n+\n+static void\n+__gnat_error_handler (int sig, siginfo_t *si, void *ucontext)\n+{\n+  __gnat_sigtramp (sig, (void *) si, (void *) ucontext,\n+\t\t   (__sigtramphandler_t *)&__gnat_map_signal);\n+}\n+\n+void\n+__gnat_install_handler (void)\n+{\n+  struct sigaction act;\n+  int err;\n+\n+  act.sa_handler = __gnat_error_handler;\n+  act.sa_flags = SA_NODEFER | SA_SIGINFO;\n+  sigemptyset (&act.sa_mask);\n+\n+  /* Do not install handlers if interrupt state is \"System\" */\n+  if (__gnat_get_interrupt_state (SIGFPE) != 's') {\n+    err = sigaction (SIGFPE,  &act, NULL);\n+    if (err == -1) {\n+      err = errno;\n+      perror (\"error while attaching SIGFPE\");\n+      perror (strerror (err));\n+    }\n+  }\n+  if (__gnat_get_interrupt_state (SIGILL) != 's') {\n+    sigaction (SIGILL,  &act, NULL);\n+    if (err == -1) {\n+      err = errno;\n+      perror (\"error while attaching SIGFPE\");\n+      perror (strerror (err));\n+    }\n+  }\n+  if (__gnat_get_interrupt_state (SIGSEGV) != 's') {\n+    sigaction (SIGSEGV, &act, NULL);\n+    if (err == -1) {\n+      err = errno;\n+      perror (\"error while attaching SIGFPE\");\n+      perror (strerror (err));\n+    }\n+  }\n+  if (__gnat_get_interrupt_state (SIGBUS) != 's') {\n+    sigaction (SIGBUS,  &act, NULL);\n+    if (err == -1) {\n+      err = errno;\n+      perror (\"error while attaching SIGFPE\");\n+      perror (strerror (err));\n+    }\n+  }\n+  __gnat_handler_installed = 1;\n+}\n+\n #elif defined (__DJGPP__)\n \n void\n@@ -2648,7 +2746,7 @@ __gnat_install_handler (void)\n \n #if defined (_WIN32) || defined (__INTERIX) \\\n   || defined (__Lynx__) || defined(__NetBSD__) || defined(__FreeBSD__) \\\n-  || defined (__OpenBSD__) || defined (__DragonFly__)\n+  || defined (__OpenBSD__) || defined (__DragonFly__) || defined(__QNX__)\n \n #define HAVE_GNAT_INIT_FLOAT\n "}, {"sha": "48bb91da3db0cf52e025e906060dd74b207fbebb", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -96,6 +96,12 @@ package body SPARK_Specific is\n    function Entity_Hash (E : Entity_Id) return Entity_Hashed_Range;\n    --  Hash function for hash table\n \n+   generic\n+      with procedure Process (N : Node_Id) is <>;\n+   procedure Traverse_Compilation_Unit (CU : Node_Id);\n+   --  Call Process on all declarations within compilation unit CU. Bodies\n+   --  of stubs are also traversed, but generic declarations are ignored.\n+\n    --------------------\n    -- Add_SPARK_File --\n    --------------------"}, {"sha": "a01e9d3f3fb24c00de353cf5c60ddf5e040865eb", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -645,12 +645,6 @@ package Lib.Xref is\n       --  files and scopes) and from shared cross-references. Fill in the\n       --  tables in library package called SPARK_Xrefs.\n \n-      generic\n-         with procedure Process (N : Node_Id) is <>;\n-      procedure Traverse_Compilation_Unit (CU : Node_Id);\n-      --  Call Process on all declarations within compilation unit CU. Bodies\n-      --  of stubs are also traversed, but generic declarations are ignored.\n-\n    end SPARK_Specific;\n \n    -----------------"}, {"sha": "ab45b381863528330546532d65e218ff74123a4c", "filename": "gcc/ada/libgnarl/a-intnam__qnx.ads", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fa-intnam__qnx.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fa-intnam__qnx.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fa-intnam__qnx.ads?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -0,0 +1,146 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                   A D A . I N T E R R U P T S . N A M E S                --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--          Copyright (C) 1991-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a QNX version of this package\n+\n+--  The pragma Unreserve_All_Interrupts affects the following signal(s):\n+\n+--  SIGINT: made available for Ada handler\n+\n+--  This target-dependent package spec contains names of interrupts\n+--  supported by the local system.\n+\n+with System.OS_Interface;\n+\n+package Ada.Interrupts.Names is\n+\n+   --  All identifiers in this unit are implementation defined\n+\n+   pragma Implementation_Defined;\n+\n+   --  Beware that the mapping of names to signals may be many-to-one. There\n+   --  may be aliases. Also, for all signal names that are not supported on the\n+   --  current system the value of the corresponding constant will be zero.\n+\n+   SIGHUP : constant Interrupt_ID :=\n+     System.OS_Interface.SIGHUP;      --  hangup\n+\n+   SIGINT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGINT;      --  interrupt (rubout)\n+\n+   SIGQUIT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)\n+\n+   SIGILL : constant Interrupt_ID :=\n+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)\n+\n+   SIGTRAP : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)\n+\n+   SIGIOT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGIOT;      --  IOT instruction\n+\n+   SIGABRT : constant Interrupt_ID := --  used by abort,\n+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future\n+\n+   SIGFPE : constant Interrupt_ID :=\n+     System.OS_Interface.SIGFPE;      --  floating point exception\n+\n+   SIGKILL : constant Interrupt_ID :=\n+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)\n+\n+   SIGBUS : constant Interrupt_ID :=\n+     System.OS_Interface.SIGBUS;      --  bus error\n+\n+   SIGSEGV : constant Interrupt_ID :=\n+     System.OS_Interface.SIGSEGV;     --  segmentation violation\n+\n+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with\n+     System.OS_Interface.SIGPIPE;     --  no one to read it\n+\n+   SIGALRM : constant Interrupt_ID :=\n+     System.OS_Interface.SIGALRM;     --  alarm clock\n+\n+   SIGTERM : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTERM;     --  software termination signal from kill\n+\n+   SIGUSR1 : constant Interrupt_ID :=\n+     System.OS_Interface.SIGUSR1;     --  user defined signal 1\n+\n+   SIGUSR2 : constant Interrupt_ID :=\n+     System.OS_Interface.SIGUSR2;     --  user defined signal 2\n+\n+   SIGCLD : constant Interrupt_ID :=\n+     System.OS_Interface.SIGCLD;      --  child status change\n+\n+   SIGCHLD : constant Interrupt_ID :=\n+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD\n+\n+   SIGWINCH : constant Interrupt_ID :=\n+     System.OS_Interface.SIGWINCH;    --  window size change\n+\n+   SIGURG : constant Interrupt_ID :=\n+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel\n+\n+   SIGPOLL : constant Interrupt_ID :=\n+     System.OS_Interface.SIGPOLL;     --  pollable event occurred\n+\n+   SIGIO : constant Interrupt_ID :=   --  input/output possible,\n+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)\n+\n+   SIGSTOP : constant Interrupt_ID :=\n+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)\n+\n+   SIGTSTP : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty\n+\n+   SIGCONT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGCONT;     --  stopped process has been continued\n+\n+   SIGTTIN : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTTIN;     --  background tty read attempted\n+\n+   SIGTTOU : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTTOU;     --  background tty write attempted\n+\n+   SIGVTALRM : constant Interrupt_ID :=\n+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired\n+\n+   SIGPROF : constant Interrupt_ID :=\n+     System.OS_Interface.SIGPROF;     --  profiling timer expired\n+\n+   SIGXCPU : constant Interrupt_ID :=\n+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded\n+\n+   SIGXFSZ : constant Interrupt_ID :=\n+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded\n+\n+end Ada.Interrupts.Names;"}, {"sha": "ae33d69fae30203fb0873745831b5838792b7c07", "filename": "gcc/ada/libgnarl/s-intman__qnx.adb", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fs-intman__qnx.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fs-intman__qnx.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-intman__qnx.adb?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -0,0 +1,298 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the QNX/Neutrino threads version of this package\n+\n+--  Make a careful study of all signals available under the OS, to see which\n+--  need to be reserved, kept always unmasked, or kept always unmasked. Be on\n+--  the lookout for special signals that may be used by the thread library.\n+\n+--  Since this is a multi target file, the signal <-> exception mapping\n+--  is simple minded. If you need a more precise and target specific\n+--  signal handling, create a new s-intman.adb that will fit your needs.\n+\n+--  This file assumes that:\n+\n+--    SIGFPE, SIGILL, SIGSEGV and SIGBUS exist. They are mapped as follows:\n+--      SIGPFE  => Constraint_Error\n+--      SIGILL  => Program_Error\n+--      SIGSEGV => Storage_Error\n+--      SIGBUS  => Storage_Error\n+\n+--    SIGINT exists and will be kept unmasked unless the pragma\n+--     Unreserve_All_Interrupts is specified anywhere in the application.\n+\n+--    System.OS_Interface contains the following:\n+--      SIGADAABORT: the signal that will be used to abort tasks.\n+--      Unmasked: the OS specific set of signals that should be unmasked in\n+--                all the threads. SIGADAABORT is unmasked by\n+--                default\n+--      Reserved: the OS specific set of signals that are reserved.\n+\n+with System.Task_Primitives;\n+\n+package body System.Interrupt_Management is\n+\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+\n+   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n+   Exception_Interrupts : constant Interrupt_List :=\n+     (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n+\n+   Unreserve_All_Interrupts : Interfaces.C.int;\n+   pragma Import\n+     (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Signal_Trampoline\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address;\n+      handler  : System.Address);\n+   pragma Import (C, Signal_Trampoline, \"__gnat_sigtramp\");\n+   --  Pass the real handler to a speical function that handles unwinding by\n+   --  skipping over the kernel signal frame (which doesn't contain any unwind\n+   --  information).\n+\n+   procedure Map_Signal\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address);\n+   pragma Import (C, Map_Signal, \"__gnat_map_signal\");\n+\n+   function State (Int : Interrupt_ID) return Character;\n+   pragma Import (C, State, \"__gnat_get_interrupt_state\");\n+   --  Get interrupt state. Defined in init.c The input argument is the\n+   --  interrupt number, and the result is one of the following:\n+\n+   User    : constant Character := 'u';\n+   Runtime : constant Character := 'r';\n+   Default : constant Character := 's';\n+   --    'n'   this interrupt not set by any Interrupt_State pragma\n+   --    'u'   Interrupt_State pragma set state to User\n+   --    'r'   Interrupt_State pragma set state to Runtime\n+   --    's'   Interrupt_State pragma set state to System (use \"default\"\n+   --           system handler)\n+\n+   procedure Notify_Exception\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address);\n+   --  This function identifies the Ada exception to be raised using the\n+   --  information when the system received a synchronous signal. Since this\n+   --  function is machine and OS dependent, different code has to be provided\n+   --  for different target.\n+\n+   ----------------------\n+   -- Notify_Exception --\n+   ----------------------\n+\n+   Signal_Mask : aliased sigset_t;\n+   --  The set of signals handled by Notify_Exception\n+\n+   procedure Notify_Exception\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address)\n+   is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      --  With the __builtin_longjmp, the signal mask is not restored, so we\n+      --  need to restore it explicitly.\n+\n+      Result := pthread_sigmask (SIG_UNBLOCK, Signal_Mask'Access, null);\n+      pragma Assert (Result = 0);\n+\n+      --  Perform the necessary context adjustments prior to a raise\n+      --  from a signal handler.\n+\n+      Adjust_Context_For_Raise (signo, ucontext);\n+\n+      --  Check that treatment of exception propagation here is consistent with\n+      --  treatment of the abort signal in System.Task_Primitives.Operations.\n+\n+      Signal_Trampoline (signo, siginfo, ucontext, Map_Signal'Address);\n+   end Notify_Exception;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   Initialized : Boolean := False;\n+\n+   procedure Initialize is\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Result  : System.OS_Interface.int;\n+\n+      Use_Alternate_Stack : constant Boolean :=\n+                              System.Task_Primitives.Alternate_Stack_Size /= 0;\n+      --  Whether to use an alternate signal stack for stack overflows\n+\n+   begin\n+      if Initialized then\n+         return;\n+      end if;\n+\n+      Initialized := True;\n+\n+      --  Need to call pthread_init very early because it is doing signal\n+      --  initializations.\n+\n+      pthread_init;\n+\n+      Abort_Task_Interrupt := SIGADAABORT;\n+\n+      act.sa_handler := Notify_Exception'Address;\n+\n+      --  Setting SA_SIGINFO asks the kernel to pass more than just the signal\n+      --  number argument to the handler when it is called. The set of extra\n+      --  parameters includes a pointer to the interrupted context, which the\n+      --  ZCX propagation scheme needs.\n+\n+      --  Most man pages for sigaction mention that sa_sigaction should be set\n+      --  instead of sa_handler when SA_SIGINFO is on.  In practice, the two\n+      --  fields are actually union'ed and located at the same offset.\n+\n+      --  On some targets, we set sa_flags to SA_NODEFER so that during the\n+      --  handler execution we do not change the Signal_Mask to be masked for\n+      --  the Signal.\n+\n+      --  This is a temporary fix to the problem that the Signal_Mask is not\n+      --  restored after the exception (longjmp) from the handler. The right\n+      --  fix should be made in sigsetjmp so that we save the Signal_Set and\n+      --  restore it after a longjmp.\n+\n+      --  Since SA_NODEFER is obsolete, instead we reset explicitly the mask\n+      --  in the exception handler.\n+\n+      Result := sigemptyset (Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Add signals that map to Ada exceptions to the mask\n+\n+      for J in Exception_Interrupts'Range loop\n+         if State (Exception_Interrupts (J)) /= Default then\n+            Result :=\n+            sigaddset (Signal_Mask'Access, Signal (Exception_Interrupts (J)));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n+      act.sa_mask := Signal_Mask;\n+\n+      pragma Assert (Keep_Unmasked = (Interrupt_ID'Range => False));\n+      pragma Assert (Reserve = (Interrupt_ID'Range => False));\n+\n+      --  Process state of exception signals\n+\n+      for J in Exception_Interrupts'Range loop\n+         if State (Exception_Interrupts (J)) /= User then\n+            Keep_Unmasked (Exception_Interrupts (J)) := True;\n+            Reserve (Exception_Interrupts (J)) := True;\n+\n+            if State (Exception_Interrupts (J)) /= Default then\n+               act.sa_flags := SA_SIGINFO;\n+\n+               if Use_Alternate_Stack\n+                 and then Exception_Interrupts (J) = SIGSEGV\n+               then\n+                  act.sa_flags := act.sa_flags + SA_ONSTACK;\n+               end if;\n+\n+               Result :=\n+                 sigaction\n+                   (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n+                    old_act'Unchecked_Access);\n+               pragma Assert (Result = 0);\n+            end if;\n+         end if;\n+      end loop;\n+\n+      if State (Abort_Task_Interrupt) /= User then\n+         Keep_Unmasked (Abort_Task_Interrupt) := True;\n+         Reserve (Abort_Task_Interrupt) := True;\n+      end if;\n+\n+      --  Set SIGINT to unmasked state as long as it is not in \"User\" state.\n+      --  Check for Unreserve_All_Interrupts last.\n+\n+      if State (SIGINT) /= User then\n+         Keep_Unmasked (SIGINT) := True;\n+         Reserve (SIGINT) := True;\n+      end if;\n+\n+      --  Check all signals for state that requires keeping them unmasked and\n+      --  reserved.\n+\n+      for J in Interrupt_ID'Range loop\n+         if State (J) = Default or else State (J) = Runtime then\n+            Keep_Unmasked (J) := True;\n+            Reserve (J) := True;\n+         end if;\n+      end loop;\n+\n+      --  Add the set of signals that must always be unmasked for this target\n+\n+      for J in Unmasked'Range loop\n+         Keep_Unmasked (Interrupt_ID (Unmasked (J))) := True;\n+         Reserve (Interrupt_ID (Unmasked (J))) := True;\n+      end loop;\n+\n+      --  Add target-specific reserved signals\n+\n+      if Reserved'Length > 0 then\n+         for J in Reserved'Range loop\n+            Reserve (Interrupt_ID (Reserved (J))) := True;\n+         end loop;\n+      end if;\n+\n+      --  Process pragma Unreserve_All_Interrupts. This overrides any settings\n+      --  due to pragma Interrupt_State:\n+\n+      if Unreserve_All_Interrupts /= 0 then\n+         Keep_Unmasked (SIGINT) := False;\n+         Reserve (SIGINT) := False;\n+      end if;\n+\n+      --  We do not really have Signal 0. We just use this value to identify\n+      --  non-existent signals (see s-intnam.ads). Therefore, Signal should not\n+      --  be used in all signal related operations hence mark it as reserved.\n+\n+      Reserve (0) := True;\n+   end Initialize;\n+\n+end System.Interrupt_Management;"}, {"sha": "70478dfed10e072f93a28263ade97a3bc44e7c9e", "filename": "gcc/ada/libgnarl/s-osinte__qnx.ads", "status": "added", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fs-osinte__qnx.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fs-osinte__qnx.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-osinte__qnx.ads?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -0,0 +1,619 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--          Copyright (C) 1995-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a QNX/Neutrino version of this package\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by the tasking run-time (libgnarl).\n+\n+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n+\n+with Ada.Unchecked_Conversion;\n+with Interfaces.C;\n+with System.OS_Constants;\n+\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype char           is Interfaces.C.char;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EPERM     : constant := 1;\n+   EINTR     : constant := 4;\n+   EAGAIN    : constant := 11;\n+   ENOMEM    : constant := 12;\n+   EINVAL    : constant := 22;\n+   ETIMEDOUT : constant := 260;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 64;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP     : constant := 1;\n+   SIGINT     : constant := 2;\n+   SIGQUIT    : constant := 3;\n+   SIGILL     : constant := 4;\n+   SIGTRAP    : constant := 5;\n+   SIGIOT     : constant := 6;\n+   SIGABRT    : constant := 6;\n+   SIGDEADLK  : constant := 7;\n+   SIGFPE     : constant := 8;\n+   SIGKILL    : constant := 9;\n+   SIGBUS     : constant := 10;\n+   SIGSEGV    : constant := 11;\n+   SIGSYS     : constant := 12;\n+   SIGPIPE    : constant := 13;\n+   SIGALRM    : constant := 14;\n+   SIGTERM    : constant := 15;\n+   SIGUSR1    : constant := 16;\n+   SIGUSR2    : constant := 17;\n+   SIGCLD     : constant := 18;\n+   SIGCHLD    : constant := 18;\n+   SIGPWR     : constant := 19;\n+   SIGWINCH   : constant := 20;\n+   SIGURG     : constant := 21;\n+   SIGPOLL    : constant := 22;\n+   SIGIO      : constant := 22;\n+   SIGSTOP    : constant := 23;\n+   SIGTSTP    : constant := 24;\n+   SIGCONT    : constant := 25;\n+   SIGTTIN    : constant := 26;\n+   SIGTTOU    : constant := 27;\n+   SIGVTALRM  : constant := 28;\n+   SIGPROF    : constant := 29;\n+   SIGXCPU    : constant := 30;\n+   SIGXFSZ    : constant := 31;\n+\n+   SIGRTMIN   : constant := 41;\n+   SITRTMAX   : constant := 56;\n+\n+   SIGSELECT  : constant := 57;\n+   SIGPHOTON  : constant := 58;\n+\n+   SIGADAABORT : constant := SIGABRT;\n+   --  Change this to use another signal for task abort. SIGTERM might be a\n+   --  good one.\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked : constant Signal_Set := (\n+      SIGTRAP,\n+      --  To enable debugging on multithreaded applications, mark SIGTRAP to\n+      --  be kept unmasked.\n+\n+      SIGBUS,\n+\n+      SIGTTIN, SIGTTOU, SIGTSTP,\n+      --  Keep these three signals unmasked so that background processes and IO\n+      --  behaves as normal \"C\" applications\n+\n+      SIGPROF,\n+      --  To avoid confusing the profiler\n+\n+      SIGKILL, SIGSTOP);\n+      --  These two signals actually can't be masked (POSIX won't allow it)\n+\n+   Reserved : constant Signal_Set := (SIGKILL, SIGSTOP, SIGSEGV);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type union_type_3 is new String (1 .. 116);\n+   type siginfo_t is record\n+      si_signo : int;\n+      si_code  : int;\n+      si_errno : int;\n+      X_data   : union_type_3;\n+   end record;\n+   pragma Convention (C, siginfo_t);\n+\n+   type struct_sigaction is record\n+      sa_handler  : System.Address;\n+      sa_flags    : Interfaces.C.int;\n+      sa_mask     : sigset_t;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 0;\n+   SIG_UNBLOCK : constant := 1;\n+   SIG_SETMASK : constant := 2;\n+   SIG_PENDING : constant := 5;\n+\n+   SA_NOCLDSTOP : constant := 16#0001#;\n+   SA_SIGINFO   : constant := 16#0002#;\n+   SA_RESETHAND : constant := 16#0004#;\n+   SA_ONSTACK   : constant := 16#0008#;\n+   SA_NODEFER   : constant := 16#0010#;\n+   SA_NOCLDWAIT : constant := 16#0020#;\n+\n+   SS_ONSTACK   : constant := 1;\n+   SS_DISABLE   : constant := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := True;\n+   --  Indicates whether time slicing is supported\n+\n+   type timespec is private;\n+\n+   type clockid_t is new int;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t; tp : access timespec) return int;\n+   pragma Import (C, clock_gettime, \"clock_gettime\");\n+\n+   function clock_getres\n+     (clock_id : clockid_t;\n+      res      : access timespec) return int;\n+   pragma Import (C, clock_getres, \"clock_getres\");\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   function sysconf (name : int) return long;\n+   pragma Import (C, sysconf);\n+\n+   SC_CLK_TCK          : constant := 2;\n+   SC_NPROCESSORS_ONLN : constant := 84;\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_OTHER : constant := 0;\n+   SCHED_FIFO  : constant := 1;\n+   SCHED_RR    : constant := 2;\n+\n+   function To_Target_Priority\n+     (Prio : System.Any_Priority) return Interfaces.C.int\n+     with Inline_Always;\n+   --  Maps System.Any_Priority to a POSIX priority\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n+\n+   function Thread_Body_Access is new\n+     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n+\n+   type pthread_t is new unsigned_long;\n+   subtype Thread_Id is pthread_t;\n+\n+   function To_pthread_t is\n+     new Ada.Unchecked_Conversion (unsigned_long, pthread_t);\n+\n+   type pthread_mutex_t      is limited private;\n+   type pthread_cond_t       is limited private;\n+   type pthread_attr_t       is limited private;\n+   type pthread_mutexattr_t  is limited private;\n+   type pthread_condattr_t   is limited private;\n+   type pthread_key_t        is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 1;\n+\n+   PTHREAD_SCOPE_PROCESS : constant := 1;\n+   PTHREAD_SCOPE_SYSTEM  : constant := 0;\n+\n+   --  Read/Write lock not supported on Android.\n+\n+   subtype pthread_rwlock_t     is pthread_mutex_t;\n+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   type stack_t is record\n+      ss_sp    : System.Address;\n+      ss_flags : int;\n+      ss_size  : size_t;\n+   end record;\n+   pragma Convention (C, stack_t);\n+\n+   function sigaltstack\n+     (ss  : not null access stack_t;\n+      oss : access stack_t) return int;\n+   pragma Import (C, sigaltstack, \"sigaltstack\");\n+\n+   Alternate_Stack : aliased System.Address;\n+   --  Dummy definition: alternate stack not available due to missing\n+   --  sigaltstack\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  This must be in keeping with init.c:__gnat_alternate_stack\n+\n+   Stack_Base_Available : constant Boolean := False;\n+   --  Indicates whether the stack base is available on this target\n+\n+   function Get_Stack_Base (thread : pthread_t) return System.Address\n+     with Inline_Always;\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   function Get_Page_Size return int;\n+   pragma Import (C, Get_Page_Size, \"getpagesize\");\n+   --  Returns the size of a page\n+\n+   PROT_NONE  : constant := 0;\n+   PROT_READ  : constant := 1;\n+   PROT_WRITE : constant := 2;\n+   PROT_EXEC  : constant := 4;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n+   PROT_ON    : constant := PROT_READ;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init with Inline_Always;\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait (set : access sigset_t; sig : access Signal) return int;\n+   pragma Import (C, sigwait, \"sigwait\");\n+\n+   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : access sigset_t;\n+      oset : access sigset_t) return int;\n+   pragma Import (C, pthread_sigmask, \"sigprocmask\");\n+   --  pthread_sigmask maybe be broken due to mismatch between sigset_t and\n+   --  kernel_sigset_t, substitute sigprocmask temporarily.  ???\n+   --  pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   PTHREAD_PRIO_PROTECT : constant := 0;\n+   PTHREAD_PRIO_INHERIT : constant := 1;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int is (0);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr        : access pthread_mutexattr_t;\n+      prioceiling : int) return int is (0);\n+\n+   type struct_sched_param is record\n+      sched_priority : int;  --  scheduling priority\n+   end record;\n+   pragma Convention (C, struct_sched_param);\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n+\n+   function pthread_attr_setscope\n+     (attr  : access pthread_attr_t;\n+      scope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import\n+     (C, pthread_attr_setschedpolicy, \"pthread_attr_setschedpolicy\");\n+\n+   function sched_yield return int;\n+   pragma Import (C, sched_yield, \"sched_yield\");\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import\n+     (C, pthread_attr_setdetachstate, \"pthread_attr_setdetachstate\");\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   function lwp_self return System.Address;\n+   pragma Import (C, lwp_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+   CPU_SETSIZE : constant := 1_024;\n+   --  Size of the cpu_set_t mask on most linux systems (SUSE 11 uses 4_096).\n+   --  This is kept for backward compatibility (System.Task_Info uses it), but\n+   --  the run-time library does no longer rely on static masks, using\n+   --  dynamically allocated masks instead.\n+\n+   type bit_field is array (1 .. CPU_SETSIZE) of Boolean;\n+   for bit_field'Size use CPU_SETSIZE;\n+   pragma Pack (bit_field);\n+   pragma Convention (C, bit_field);\n+\n+   type cpu_set_t is record\n+      bits : bit_field;\n+   end record;\n+   pragma Convention (C, cpu_set_t);\n+\n+   type cpu_set_t_ptr is access all cpu_set_t;\n+   --  In the run-time library we use this pointer because the size of type\n+   --  cpu_set_t varies depending on the glibc version. Hence, objects of type\n+   --  cpu_set_t are allocated dynamically using the number of processors\n+   --  available in the target machine (value obtained at execution time).\n+\n+   function CPU_ALLOC (count : size_t) return cpu_set_t_ptr;\n+   pragma Import (C, CPU_ALLOC, \"__gnat_cpu_alloc\");\n+   --  Wrapper around the CPU_ALLOC C macro\n+\n+   function CPU_ALLOC_SIZE (count : size_t) return size_t;\n+   pragma Import (C, CPU_ALLOC_SIZE, \"__gnat_cpu_alloc_size\");\n+   --  Wrapper around the CPU_ALLOC_SIZE C macro\n+\n+   procedure CPU_FREE (cpuset : cpu_set_t_ptr);\n+   pragma Import (C, CPU_FREE, \"__gnat_cpu_free\");\n+   --  Wrapper around the CPU_FREE C macro\n+\n+   procedure CPU_ZERO (count : size_t; cpuset : cpu_set_t_ptr);\n+   pragma Import (C, CPU_ZERO, \"__gnat_cpu_zero\");\n+   --  Wrapper around the CPU_ZERO_S C macro\n+\n+   procedure CPU_SET (cpu : int; count : size_t; cpuset : cpu_set_t_ptr);\n+   pragma Import (C, CPU_SET, \"__gnat_cpu_set\");\n+   --  Wrapper around the CPU_SET_S C macro\n+\n+private\n+\n+   type sigset_t is new Interfaces.C.unsigned_long;\n+   pragma Convention (C, sigset_t);\n+   for sigset_t'Alignment use Interfaces.C.unsigned_long'Alignment;\n+\n+   type pid_t is new int;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type unsigned_long_long_t is mod 2 ** 64;\n+   --  Local type only used to get the alignment of this type below\n+\n+   subtype char_array is Interfaces.C.char_array;\n+\n+   type pthread_attr_t is record\n+      Data : char_array (1 .. OS_Constants.PTHREAD_ATTR_SIZE);\n+   end record;\n+   pragma Convention (C, pthread_attr_t);\n+   for pthread_attr_t'Alignment use Interfaces.C.unsigned_long'Alignment;\n+\n+   type pthread_condattr_t is record\n+      Data : char_array (1 .. OS_Constants.PTHREAD_CONDATTR_SIZE);\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+   for pthread_condattr_t'Alignment use Interfaces.C.int'Alignment;\n+\n+   type pthread_mutexattr_t is record\n+      Data : char_array (1 .. OS_Constants.PTHREAD_MUTEXATTR_SIZE);\n+   end  record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+   for pthread_mutexattr_t'Alignment use Interfaces.C.int'Alignment;\n+\n+   type pthread_mutex_t is record\n+      Data : char_array (1 .. OS_Constants.PTHREAD_MUTEX_SIZE);\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+   for pthread_mutex_t'Alignment use Interfaces.C.unsigned_long'Alignment;\n+\n+   type pthread_cond_t is record\n+      Data : char_array (1 .. OS_Constants.PTHREAD_COND_SIZE);\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+   for pthread_cond_t'Alignment use unsigned_long_long_t'Alignment;\n+\n+   type pthread_key_t is new unsigned;\n+\n+end System.OS_Interface;"}, {"sha": "2097f77862499e733f7f821d519f7096bff8dee4", "filename": "gcc/ada/libgnarl/s-qnx.ads", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fs-qnx.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fs-qnx.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-qnx.ads?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -0,0 +1,122 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                             S Y S T E M .  Q N X                         --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--             Copyright (C) 2017, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the default version of this package\n+\n+--  This package encapsulates cpu specific differences between implementations\n+--  of QNX, in order to share s-osinte-linux.ads.\n+\n+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n+--  Preelaborate. This package is designed to be a bottom-level (leaf) package\n+\n+with Interfaces.C;\n+\n+package System.QNX is\n+   pragma Preelaborate;\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   subtype long        is Interfaces.C.long;\n+   subtype suseconds_t is Interfaces.C.long;\n+   subtype time_t      is Interfaces.C.long;\n+   subtype clockid_t   is Interfaces.C.int;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : suseconds_t;\n+   end record;\n+   pragma Convention (C, timeval);\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   EPERM     : constant := 1;\n+   ETIMEDOUT : constant := 110;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGEMT     : constant := 7; --  EMT instruction\n+   SIGDEADLK  : constant := 7; --  Mutex deadlock\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 16; --  user defined signal 1\n+   SIGUSR2    : constant := 17; --  user defined signal 2\n+   SIGCHLD    : constant := 18; --  child status change\n+   SIGCLD     : constant := 18; --  alias for SIGCHLD\n+   SIGPWR     : constant := 19; --  power-fail restart\n+   SIGWINCH   : constant := 20; --  window size change\n+   SIGURG     : constant := 21; --  urgent condition on IO channel\n+   SIGPOLL    : constant := 22; --  pollable event occurred\n+   SIGIO      : constant := 22; --  I/O now possible (4.2 BSD)\n+   SIGSTOP    : constant := 23; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 24; --  user stop requested from tty\n+   SIGCONT    : constant := 25; --  stopped process has been continued\n+   SIGTTIN    : constant := 26; --  background tty read attempted\n+   SIGTTOU    : constant := 27; --  background tty write attempted\n+   SIGVTALRM  : constant := 28; --  virtual timer expired\n+   SIGPROF    : constant := 29; --  profiling timer expired\n+   SIGXCPU    : constant := 30; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 31; --  filesize limit exceeded\n+\n+   --  struct_sigaction offsets\n+\n+   sa_handler_pos : constant := 0;\n+   sa_mask_pos    : constant := Standard'Address_Size / 8;\n+   sa_flags_pos   : constant := 128 + sa_mask_pos;\n+\n+   SA_SIGINFO  : constant := 16#04#;\n+   SA_ONSTACK  : constant := 16#08000000#;\n+\n+end System.QNX;"}, {"sha": "85ebed799bd2a8aa55a6ebe08984275ee9111c4e", "filename": "gcc/ada/libgnarl/s-taprop__qnx.adb", "status": "added", "additions": 1546, "deletions": 0, "changes": 1546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -0,0 +1,1546 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the QNX/Neutrino version of this package\n+\n+--  This package contains all the GNULL primitives that interface directly with\n+--  the underlying OS.\n+\n+--  Note: this file can only be used for POSIX compliant systems that implement\n+--  SCHED_FIFO and Ceiling Locking correctly.\n+\n+--  For configurations where SCHED_FIFO and priority ceiling are not a\n+--  requirement, this file can also be used (e.g AiX threads)\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during tasking\n+--  operations. It causes infinite loops and other problems.\n+\n+with Ada.Unchecked_Conversion;\n+\n+with Interfaces.C;\n+\n+with System.Tasking.Debug;\n+with System.Interrupt_Management;\n+with System.OS_Constants;\n+with System.OS_Primitives;\n+with System.Task_Info;\n+\n+with System.Soft_Links;\n+--  We use System.Soft_Links instead of System.Tasking.Initialization\n+--  because the later is a higher level package that we shouldn't depend on.\n+--  For example when using the restricted run time, it is replaced by\n+--  System.Tasking.Restricted.Stages.\n+\n+package body System.Task_Primitives.Operations is\n+\n+   package OSC renames System.OS_Constants;\n+   package SSL renames System.Soft_Links;\n+\n+   use System.Tasking.Debug;\n+   use System.Tasking;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+   use System.Parameters;\n+   use System.OS_Primitives;\n+\n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task\n+\n+   Unblocked_Signal_Mask : aliased sigset_t;\n+   --  The set of signals that should be unblocked in all tasks\n+\n+   --  The followings are internal configuration constants needed\n+\n+   Next_Serial_Number : Task_Serial_Number := 100;\n+   --  We start at 100 (reserve some special values for using in error checks)\n+\n+   Time_Slice_Val : Integer;\n+   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n+\n+   Dispatching_Policy : Character;\n+   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+\n+   Locking_Policy : Character;\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+\n+   Foreign_Task_Elaborated : aliased Boolean := True;\n+   --  Used to identified fake tasks (i.e., non-Ada Threads)\n+\n+   Use_Alternate_Stack : constant Boolean := Alternate_Stack_Size /= 0;\n+   --  Whether to use an alternate signal stack for stack overflows\n+\n+   Abort_Handler_Installed : Boolean := False;\n+   --  True if a handler for the abort signal is installed\n+\n+   --------------------\n+   -- Local Packages --\n+   --------------------\n+\n+   package Specific is\n+\n+      procedure Initialize (Environment_Task : Task_Id);\n+      pragma Inline (Initialize);\n+      --  Initialize various data needed by this package\n+\n+      function Is_Valid_Task return Boolean;\n+      pragma Inline (Is_Valid_Task);\n+      --  Does executing thread have a TCB?\n+\n+      procedure Set (Self_Id : Task_Id);\n+      pragma Inline (Set);\n+      --  Set the self id for the current task\n+\n+      function Self return Task_Id;\n+      pragma Inline (Self);\n+      --  Return a pointer to the Ada Task Control Block of the calling task\n+\n+   end Specific;\n+\n+   package body Specific is separate;\n+   --  The body of this package is target specific\n+\n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n+   ---------------------------------\n+   -- Support for foreign threads --\n+   ---------------------------------\n+\n+   function Register_Foreign_Thread\n+     (Thread         : Thread_Id;\n+      Sec_Stack_Size : Size_Type := Unspecified_Size) return Task_Id;\n+   --  Allocate and initialize a new ATCB for the current Thread. The size of\n+   --  the secondary stack can be optionally specified.\n+\n+   function Register_Foreign_Thread\n+     (Thread         : Thread_Id;\n+      Sec_Stack_Size : Size_Type := Unspecified_Size)\n+     return Task_Id is separate;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Abort_Handler (Sig : Signal);\n+   --  Signal handler used to implement asynchronous abort.\n+   --  See also comment before body, below.\n+\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n+\n+   function GNAT_pthread_condattr_setup\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C,\n+     GNAT_pthread_condattr_setup, \"__gnat_pthread_condattr_setup\");\n+\n+   procedure Compute_Deadline\n+     (Time       : Duration;\n+      Mode       : ST.Delay_Modes;\n+      Check_Time : out Duration;\n+      Abs_Time   : out Duration;\n+      Rel_Time   : out Duration);\n+   --  Helper for Timed_Sleep and Timed_Delay: given a deadline specified by\n+   --  Time and Mode, compute the current clock reading (Check_Time), and the\n+   --  target absolute and relative clock readings (Abs_Time, Rel_Time). The\n+   --  epoch for Time depends on Mode; the epoch for Check_Time and Abs_Time\n+   --  is always that of CLOCK_RT_Ada.\n+\n+   -------------------\n+   -- Abort_Handler --\n+   -------------------\n+\n+   --  Target-dependent binding of inter-thread Abort signal to the raising of\n+   --  the Abort_Signal exception.\n+\n+   --  The technical issues and alternatives here are essentially the\n+   --  same as for raising exceptions in response to other signals\n+   --  (e.g. Storage_Error). See code and comments in the package body\n+   --  System.Interrupt_Management.\n+\n+   --  Some implementations may not allow an exception to be propagated out of\n+   --  a handler, and others might leave the signal or interrupt that invoked\n+   --  this handler masked after the exceptional return to the application\n+   --  code.\n+\n+   --  GNAT exceptions are originally implemented using setjmp()/longjmp(). On\n+   --  most UNIX systems, this will allow transfer out of a signal handler,\n+   --  which is usually the only mechanism available for implementing\n+   --  asynchronous handlers of this kind. However, some systems do not\n+   --  restore the signal mask on longjmp(), leaving the abort signal masked.\n+\n+   procedure Abort_Handler (Sig : Signal) is\n+      pragma Unreferenced (Sig);\n+\n+      T       : constant Task_Id := Self;\n+      Old_Set : aliased sigset_t;\n+\n+      Result : Interfaces.C.int;\n+      pragma Warnings (Off, Result);\n+\n+   begin\n+      --  It's not safe to raise an exception when using GCC ZCX mechanism.\n+      --  Note that we still need to install a signal handler, since in some\n+      --  cases (e.g. shutdown of the Server_Task in System.Interrupts) we\n+      --  need to send the Abort signal to a task.\n+\n+      if ZCX_By_Default then\n+         return;\n+      end if;\n+\n+      if T.Deferral_Level = 0\n+        and then T.Pending_ATC_Level < T.ATC_Nesting_Level and then\n+        not T.Aborting\n+      then\n+         T.Aborting := True;\n+\n+         --  Make sure signals used for RTS internal purpose are unmasked\n+\n+         Result := pthread_sigmask (SIG_UNBLOCK,\n+           Unblocked_Signal_Mask'Access, Old_Set'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Standard'Abort_Signal;\n+      end if;\n+   end Abort_Handler;\n+\n+   ----------------------\n+   -- Compute_Deadline --\n+   ----------------------\n+\n+   procedure Compute_Deadline\n+     (Time       : Duration;\n+      Mode       : ST.Delay_Modes;\n+      Check_Time : out Duration;\n+      Abs_Time   : out Duration;\n+      Rel_Time   : out Duration)\n+   is\n+   begin\n+      Check_Time := Monotonic_Clock;\n+\n+      --  Relative deadline\n+\n+      if Mode = Relative then\n+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n+\n+         if Relative_Timed_Wait then\n+            Rel_Time := Duration'Min (Max_Sensible_Delay, Time);\n+         end if;\n+\n+         pragma Warnings (Off);\n+         --  Comparison \"OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\" is compile\n+         --  time known.\n+\n+      --  Absolute deadline specified using the tasking clock (CLOCK_RT_Ada)\n+\n+      elsif Mode = Absolute_RT\n+        or else OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\n+      then\n+         pragma Warnings (On);\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+\n+         if Relative_Timed_Wait then\n+            Rel_Time := Duration'Min (Max_Sensible_Delay, Time - Check_Time);\n+         end if;\n+\n+      --  Absolute deadline specified using the calendar clock, in the\n+      --  case where it is not the same as the tasking clock: compensate for\n+      --  difference between clock epochs (Base_Time - Base_Cal_Time).\n+\n+      else\n+         declare\n+            Cal_Check_Time : constant Duration := OS_Primitives.Clock;\n+            RT_Time        : constant Duration :=\n+                               Time + Check_Time - Cal_Check_Time;\n+\n+         begin\n+            Abs_Time :=\n+              Duration'Min (Check_Time + Max_Sensible_Delay, RT_Time);\n+\n+            if Relative_Timed_Wait then\n+               Rel_Time :=\n+                 Duration'Min (Max_Sensible_Delay, RT_Time - Check_Time);\n+            end if;\n+         end;\n+      end if;\n+   end Compute_Deadline;\n+\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n+\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n+      Stack_Base : constant Address := Get_Stack_Base (T.Common.LL.Thread);\n+      Page_Size  : Address;\n+      Res        : Interfaces.C.int;\n+\n+   begin\n+      if Stack_Base_Available then\n+\n+         --  Compute the guard page address\n+\n+         Page_Size := Address (Get_Page_Size);\n+         Res :=\n+           mprotect\n+             (Stack_Base - (Stack_Base mod Page_Size) + Page_Size,\n+              size_t (Page_Size),\n+              prot => (if On then PROT_ON else PROT_OFF));\n+         pragma Assert (Res = 0);\n+      end if;\n+   end Stack_Guard;\n+\n+   --------------------\n+   -- Get_Thread_Id  --\n+   --------------------\n+\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n+   begin\n+      return T.Common.LL.Thread;\n+   end Get_Thread_Id;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   function Self return Task_Id renames Specific.Self;\n+\n+   ---------------------\n+   -- Initialize_Lock --\n+   ---------------------\n+\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore raising Storage_Error in the following\n+   --  routines should be able to be handled safely.\n+\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority;\n+      L    : not null access Lock)\n+   is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_mutexattr_setprioceiling\n+            (Attributes'Access, Interfaces.C.int (Prio));\n+         pragma Assert (Result = 0);\n+\n+      elsif Locking_Policy = 'I' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_INHERIT);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_mutex_init (L.WO'Access, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   procedure Initialize_Lock\n+     (L : not null access RTS_Lock; Level : Lock_Level)\n+   is\n+      pragma Unreferenced (Level);\n+\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_mutexattr_setprioceiling\n+            (Attributes'Access, Interfaces.C.int (System.Any_Priority'Last));\n+         pragma Assert (Result = 0);\n+\n+      elsif Locking_Policy = 'I' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_INHERIT);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   -------------------\n+   -- Finalize_Lock --\n+   -------------------\n+\n+   procedure Finalize_Lock (L : not null access Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_destroy (L.WO'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   procedure Finalize_Lock (L : not null access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   ----------------\n+   -- Write_Lock --\n+   ----------------\n+\n+   procedure Write_Lock\n+     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+   is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (L.WO'Access);\n+\n+      --  The cause of EINVAL is a priority ceiling violation\n+\n+      Ceiling_Violation := Result = EINVAL;\n+      pragma Assert (Result = 0 or else Ceiling_Violation);\n+   end Write_Lock;\n+\n+   procedure Write_Lock\n+     (L           : not null access RTS_Lock;\n+      Global_Lock : Boolean := False)\n+   is\n+      Result : Interfaces.C.int;\n+   begin\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Write_Lock;\n+\n+   procedure Write_Lock (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Write_Lock;\n+\n+   ---------------\n+   -- Read_Lock --\n+   ---------------\n+\n+   procedure Read_Lock\n+     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+   begin\n+      Write_Lock (L, Ceiling_Violation);\n+   end Read_Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock (L : not null access Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_unlock (L.WO'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock\n+     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n+      Result : Interfaces.C.int;\n+   begin\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Unlock;\n+\n+   procedure Unlock (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Unlock;\n+\n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n+   -----------\n+   -- Sleep --\n+   -----------\n+\n+   procedure Sleep\n+     (Self_ID : Task_Id;\n+      Reason  : System.Tasking.Task_States)\n+   is\n+      pragma Unreferenced (Reason);\n+\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => (if Single_Lock\n+                     then Single_RTS_Lock'Access\n+                     else Self_ID.Common.LL.L'Access));\n+\n+      --  EINTR is not considered a failure\n+\n+      pragma Assert (Result = 0 or else Result = EINTR);\n+   end Sleep;\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   --  This is for use within the run-time system, so abort is\n+   --  assumed to be already deferred, and the caller should be\n+   --  holding its own ATCB lock.\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : Task_Id;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean)\n+   is\n+      pragma Unreferenced (Reason);\n+\n+      Base_Time  : Duration;\n+      Check_Time : Duration;\n+      Abs_Time   : Duration;\n+      Rel_Time   : Duration;\n+\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Timedout := True;\n+      Yielded := False;\n+\n+      Compute_Deadline\n+        (Time       => Time,\n+         Mode       => Mode,\n+         Check_Time => Check_Time,\n+         Abs_Time   => Abs_Time,\n+         Rel_Time   => Rel_Time);\n+      Base_Time := Check_Time;\n+\n+      if Abs_Time > Check_Time then\n+         Request :=\n+           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n+\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n+\n+            if Result = 0 or Result = EINTR then\n+\n+               --  Somebody may have called Wakeup for us\n+\n+               Timedout := False;\n+               exit;\n+            end if;\n+\n+            pragma Assert (Result = ETIMEDOUT);\n+         end loop;\n+      end if;\n+   end Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so we assume the\n+   --  caller is abort-deferred but is holding no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID : Task_Id;\n+      Time    : Duration;\n+      Mode    : ST.Delay_Modes)\n+   is\n+      Base_Time  : Duration;\n+      Check_Time : Duration;\n+      Abs_Time   : Duration;\n+      Rel_Time   : Duration;\n+      Request    : aliased timespec;\n+\n+      Result : Interfaces.C.int;\n+      pragma Warnings (Off, Result);\n+\n+   begin\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n+      Write_Lock (Self_ID);\n+\n+      Compute_Deadline\n+        (Time       => Time,\n+         Mode       => Mode,\n+         Check_Time => Check_Time,\n+         Abs_Time   => Abs_Time,\n+         Rel_Time   => Rel_Time);\n+      Base_Time := Check_Time;\n+\n+      if Abs_Time > Check_Time then\n+         Request :=\n+           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n+         Self_ID.Common.State := Delay_Sleep;\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n+\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n+\n+            pragma Assert (Result = 0\n+                             or else Result = ETIMEDOUT\n+                             or else Result = EINTR);\n+         end loop;\n+\n+         Self_ID.Common.State := Runnable;\n+      end if;\n+\n+      Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n+      Result := sched_yield;\n+   end Timed_Delay;\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration is\n+      TS     : aliased timespec;\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := clock_gettime\n+        (clock_id => OSC.CLOCK_RT_Ada, tp => TS'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+      return To_Duration (TS);\n+   end Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration is\n+      TS     : aliased timespec;\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := clock_getres (OSC.CLOCK_REALTIME, TS'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+\n+      return To_Duration (TS);\n+   end RT_Resolution;\n+\n+   ------------\n+   -- Wakeup --\n+   ------------\n+\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n+      pragma Unreferenced (Reason);\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Wakeup;\n+\n+   -----------\n+   -- Yield --\n+   -----------\n+\n+   procedure Yield (Do_Yield : Boolean := True) is\n+      Result : Interfaces.C.int;\n+      pragma Unreferenced (Result);\n+   begin\n+      if Do_Yield then\n+         Result := sched_yield;\n+      end if;\n+   end Yield;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   procedure Set_Priority\n+     (T                   : Task_Id;\n+      Prio                : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      pragma Unreferenced (Loss_Of_Inheritance);\n+\n+      Result : Interfaces.C.int;\n+      Param  : aliased struct_sched_param;\n+\n+      function Get_Policy (Prio : System.Any_Priority) return Character;\n+      pragma Import (C, Get_Policy, \"__gnat_get_specific_dispatching\");\n+      --  Get priority specific dispatching policy\n+\n+      Priority_Specific_Policy : constant Character := Get_Policy (Prio);\n+      --  Upper case first character of the policy name corresponding to the\n+      --  task as set by a Priority_Specific_Dispatching pragma.\n+\n+   begin\n+      T.Common.Current_Priority := Prio;\n+      Param.sched_priority := To_Target_Priority (Prio);\n+\n+      if Time_Slice_Supported\n+        and then (Dispatching_Policy = 'R'\n+                  or else Priority_Specific_Policy = 'R'\n+                  or else Time_Slice_Val > 0)\n+      then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+\n+      elsif Dispatching_Policy = 'F'\n+        or else Priority_Specific_Policy = 'F'\n+        or else Time_Slice_Val = 0\n+      then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+\n+      else\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+      end if;\n+\n+      pragma Assert (Result = 0);\n+   end Set_Priority;\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n+   begin\n+      return T.Common.Current_Priority;\n+   end Get_Priority;\n+\n+   ----------------\n+   -- Enter_Task --\n+   ----------------\n+\n+   procedure Enter_Task (Self_ID : Task_Id) is\n+   begin\n+      Self_ID.Common.LL.Thread := pthread_self;\n+      Self_ID.Common.LL.LWP := lwp_self;\n+\n+      Specific.Set (Self_ID);\n+\n+      if Use_Alternate_Stack then\n+         declare\n+            Stack  : aliased stack_t;\n+            Result : Interfaces.C.int;\n+         begin\n+            Stack.ss_sp    := Self_ID.Common.Task_Alternate_Stack;\n+            Stack.ss_size  := Alternate_Stack_Size;\n+            Stack.ss_flags := 0;\n+            Result := sigaltstack (Stack'Access, null);\n+            pragma Assert (Result = 0);\n+         end;\n+      end if;\n+   end Enter_Task;\n+\n+   -------------------\n+   -- Is_Valid_Task --\n+   -------------------\n+\n+   function Is_Valid_Task return Boolean renames Specific.Is_Valid_Task;\n+\n+   -----------------------------\n+   -- Register_Foreign_Thread --\n+   -----------------------------\n+\n+   function Register_Foreign_Thread return Task_Id is\n+   begin\n+      if Is_Valid_Task then\n+         return Self;\n+      else\n+         return Register_Foreign_Thread (pthread_self);\n+      end if;\n+   end Register_Foreign_Thread;\n+\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n+\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+\n+   begin\n+      --  Give the task a unique serial number\n+\n+      Self_ID.Serial_Number := Next_Serial_Number;\n+      Next_Serial_Number := Next_Serial_Number + 1;\n+      pragma Assert (Next_Serial_Number /= 0);\n+\n+      if not Single_Lock then\n+         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+         if Result = 0 then\n+            if Locking_Policy = 'C' then\n+               Result :=\n+                 pthread_mutexattr_setprotocol\n+                   (Mutex_Attr'Access,\n+                    PTHREAD_PRIO_PROTECT);\n+               pragma Assert (Result = 0);\n+\n+               Result :=\n+                 pthread_mutexattr_setprioceiling\n+                   (Mutex_Attr'Access,\n+                    Interfaces.C.int (System.Any_Priority'Last));\n+               pragma Assert (Result = 0);\n+\n+            elsif Locking_Policy = 'I' then\n+               Result :=\n+                 pthread_mutexattr_setprotocol\n+                   (Mutex_Attr'Access,\n+                    PTHREAD_PRIO_INHERIT);\n+               pragma Assert (Result = 0);\n+            end if;\n+\n+            Result :=\n+              pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access,\n+                 Mutex_Attr'Access);\n+            pragma Assert (Result = 0 or else Result = ENOMEM);\n+         end if;\n+\n+         if Result /= 0 then\n+            Succeeded := False;\n+            return;\n+         end if;\n+\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         Result :=\n+           pthread_cond_init\n+             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n+\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n+         Succeeded := False;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_TCB;\n+\n+   -----------------\n+   -- Create_Task --\n+   -----------------\n+\n+   procedure Create_Task\n+     (T          : Task_Id;\n+      Wrapper    : System.Address;\n+      Stack_Size : System.Parameters.Size_Type;\n+      Priority   : System.Any_Priority;\n+      Succeeded  : out Boolean)\n+   is\n+      Attributes          : aliased pthread_attr_t;\n+      Adjusted_Stack_Size : Interfaces.C.size_t;\n+      Page_Size           : constant Interfaces.C.size_t :=\n+                              Interfaces.C.size_t (Get_Page_Size);\n+      Result              : Interfaces.C.int;\n+\n+      function Thread_Body_Access is new\n+        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n+\n+      use System.Task_Info;\n+\n+   begin\n+      Adjusted_Stack_Size :=\n+         Interfaces.C.size_t (Stack_Size + Alternate_Stack_Size);\n+\n+      if Stack_Base_Available then\n+\n+         --  If Stack Checking is supported then allocate 2 additional pages:\n+\n+         --  In the worst case, stack is allocated at something like\n+         --  N * Get_Page_Size - epsilon, we need to add the size for 2 pages\n+         --  to be sure the effective stack size is greater than what\n+         --  has been asked.\n+\n+         Adjusted_Stack_Size := Adjusted_Stack_Size + 2 * Page_Size;\n+      end if;\n+\n+      --  Round stack size as this is required by some OSes (Darwin)\n+\n+      Adjusted_Stack_Size := Adjusted_Stack_Size + Page_Size - 1;\n+      Adjusted_Stack_Size :=\n+        Adjusted_Stack_Size - Adjusted_Stack_Size mod Page_Size;\n+\n+      Result := pthread_attr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result :=\n+        pthread_attr_setdetachstate\n+          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      pragma Assert (Result = 0);\n+\n+      Result :=\n+        pthread_attr_setstacksize\n+          (Attributes'Access, Adjusted_Stack_Size);\n+      pragma Assert (Result = 0);\n+\n+      if T.Common.Task_Info /= Default_Scope then\n+         case T.Common.Task_Info is\n+            when System.Task_Info.Process_Scope =>\n+               Result :=\n+                 pthread_attr_setscope\n+                   (Attributes'Access, PTHREAD_SCOPE_PROCESS);\n+\n+            when System.Task_Info.System_Scope =>\n+               Result :=\n+                 pthread_attr_setscope\n+                   (Attributes'Access, PTHREAD_SCOPE_SYSTEM);\n+\n+            when System.Task_Info.Default_Scope =>\n+               Result := 0;\n+         end case;\n+\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      --  Note: the use of Unrestricted_Access in the following call is needed\n+      --  because otherwise we have an error of getting a access-to-volatile\n+      --  value which points to a non-volatile object. But in this case it is\n+      --  safe to do this, since we know we have no problems with aliasing and\n+      --  Unrestricted_Access bypasses this check.\n+\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Unrestricted_Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n+      pragma Assert (Result = 0 or else Result = EAGAIN);\n+\n+      Succeeded := Result = 0;\n+\n+      Result := pthread_attr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+\n+      if Succeeded then\n+         Set_Priority (T, Priority);\n+      end if;\n+   end Create_Task;\n+\n+   ------------------\n+   -- Finalize_TCB --\n+   ------------------\n+\n+   procedure Finalize_TCB (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+\n+      if T.Known_Tasks_Index /= -1 then\n+         Known_Tasks (T.Known_Tasks_Index) := null;\n+      end if;\n+\n+      ATCB_Allocation.Free_ATCB (T);\n+   end Finalize_TCB;\n+\n+   ---------------\n+   -- Exit_Task --\n+   ---------------\n+\n+   procedure Exit_Task is\n+   begin\n+      --  Mark this task as unknown, so that if Self is called, it won't\n+      --  return a dangling pointer.\n+\n+      Specific.Set (null);\n+   end Exit_Task;\n+\n+   ----------------\n+   -- Abort_Task --\n+   ----------------\n+\n+   procedure Abort_Task (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if Abort_Handler_Installed then\n+         Result :=\n+           pthread_kill\n+             (T.Common.LL.Thread,\n+              Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Abort_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      --  Initialize internal state (always to False (RM D.10 (6)))\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         --  Storage_Error is propagated as intended if the allocation of the\n+         --  underlying OS entities fails.\n+\n+         raise Storage_Error;\n+\n+      else\n+         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_condattr_destroy (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         --  Storage_Error is propagated as intended if the allocation of the\n+         --  underlying OS entities fails.\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      SSL.Abort_Undefer.all;\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in (RM D.10(9)). Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      SSL.Abort_Undefer.all;\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (RM D.10(10)).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         SSL.Abort_Undefer.all;\n+\n+         raise Program_Error;\n+\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+\n+            loop\n+               --  Loop in case pthread_cond_wait returns earlier than expected\n+               --  (e.g. in case of EINTR caused by a signal).\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n+         end if;\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         SSL.Abort_Undefer.all;\n+      end if;\n+   end Suspend_Until_True;\n+\n+   ----------------\n+   -- Check_Exit --\n+   ----------------\n+\n+   --  Dummy version\n+\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (Self_ID);\n+   begin\n+      return True;\n+   end Check_Exit;\n+\n+   --------------------\n+   -- Check_No_Locks --\n+   --------------------\n+\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (Self_ID);\n+   begin\n+      return True;\n+   end Check_No_Locks;\n+\n+   ----------------------\n+   -- Environment_Task --\n+   ----------------------\n+\n+   function Environment_Task return Task_Id is\n+   begin\n+      return Environment_Task_Id;\n+   end Environment_Task;\n+\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n+\n+   procedure Lock_RTS is\n+   begin\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n+\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n+\n+   procedure Unlock_RTS is\n+   begin\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n+\n+   ------------------\n+   -- Suspend_Task --\n+   ------------------\n+\n+   function Suspend_Task\n+     (T           : ST.Task_Id;\n+      Thread_Self : Thread_Id) return Boolean\n+   is\n+   begin\n+      if T.Common.LL.Thread /= Thread_Self then\n+         return pthread_kill (T.Common.LL.Thread, SIGSTOP) = 0;\n+      else\n+         return True;\n+      end if;\n+   end Suspend_Task;\n+\n+   -----------------\n+   -- Resume_Task --\n+   -----------------\n+\n+   function Resume_Task\n+     (T           : ST.Task_Id;\n+      Thread_Self : Thread_Id) return Boolean\n+   is\n+   begin\n+      if T.Common.LL.Thread /= Thread_Self then\n+         return pthread_kill (T.Common.LL.Thread, SIGCONT) = 0;\n+      else\n+         return True;\n+      end if;\n+   end Resume_Task;\n+\n+   --------------------\n+   -- Stop_All_Tasks --\n+   --------------------\n+\n+   procedure Stop_All_Tasks is\n+   begin\n+      null;\n+   end Stop_All_Tasks;\n+\n+   ---------------\n+   -- Stop_Task --\n+   ---------------\n+\n+   function Stop_Task (T : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (T);\n+   begin\n+      return False;\n+   end Stop_Task;\n+\n+   -------------------\n+   -- Continue_Task --\n+   -------------------\n+\n+   function Continue_Task (T : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (T);\n+   begin\n+      return False;\n+   end Continue_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_Id) is\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Tmp_Set : aliased sigset_t;\n+      Result  : Interfaces.C.int;\n+\n+      function State\n+        (Int : System.Interrupt_Management.Interrupt_ID) return Character;\n+      pragma Import (C, State, \"__gnat_get_interrupt_state\");\n+      --  Get interrupt state.  Defined in a-init.c\n+      --  The input argument is the interrupt number,\n+      --  and the result is one of the following:\n+\n+      Default : constant Character := 's';\n+      --    'n'   this interrupt not set by any Interrupt_State pragma\n+      --    'u'   Interrupt_State pragma set state to User\n+      --    'r'   Interrupt_State pragma set state to Runtime\n+      --    's'   Interrupt_State pragma set state to System (use \"default\"\n+      --           system handler)\n+\n+   begin\n+      Environment_Task_Id := Environment_Task;\n+\n+      Interrupt_Management.Initialize;\n+\n+      --  Prepare the set of signals that should unblocked in all tasks\n+\n+      Result := sigemptyset (Unblocked_Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      for J in Interrupt_Management.Interrupt_ID loop\n+         if System.Interrupt_Management.Keep_Unmasked (J) then\n+            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n+      --  Initialize the lock used to synchronize chain of all ATCBs\n+\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n+\n+      Specific.Initialize (Environment_Task);\n+\n+      if Use_Alternate_Stack then\n+         Environment_Task.Common.Task_Alternate_Stack :=\n+           Alternate_Stack'Address;\n+      end if;\n+\n+      --  Make environment task known here because it doesn't go through\n+      --  Activate_Tasks, which does it for all other tasks.\n+\n+      Known_Tasks (Known_Tasks'First) := Environment_Task;\n+      Environment_Task.Known_Tasks_Index := Known_Tasks'First;\n+\n+      Enter_Task (Environment_Task);\n+\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n+      then\n+         act.sa_flags := 0;\n+         act.sa_handler := Abort_Handler'Address;\n+\n+         Result := sigemptyset (Tmp_Set'Access);\n+         pragma Assert (Result = 0);\n+         act.sa_mask := Tmp_Set;\n+\n+         Result :=\n+           sigaction\n+             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+              act'Unchecked_Access,\n+              old_act'Unchecked_Access);\n+         pragma Assert (Result = 0);\n+         Abort_Handler_Installed := True;\n+      end if;\n+   end Initialize;\n+\n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      pragma Unreferenced (T);\n+\n+   begin\n+      --  Setting task affinity is not supported by the underlying system\n+\n+      null;\n+   end Set_Task_Affinity;\n+\n+end System.Task_Primitives.Operations;"}, {"sha": "421311d8531289fab7cb5678b3def0be54bff05d", "filename": "gcc/ada/libgnat/system-qnx-aarch64.ads", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -0,0 +1,157 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                         (QNX/Aarch64 Version)                            --\n+--                                                                          --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+   pragma Pure;\n+   --  Note that we take advantage of the implementation permission to make\n+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada\n+   --  2005, this is Pure in any case (AI-362).\n+\n+   pragma No_Elaboration_Code_All;\n+   --  Allow the use of that restriction in units that WITH this unit\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := 0.000_001;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   pragma Preelaborable_Initialization (Address);\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Long_Integer'Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order :=\n+                         Bit_Order'Val (Standard'Default_Bit_Order);\n+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   --  0 .. 98 corresponds to the system priority range 1 .. 99.\n+   --\n+   --  If the scheduling policy is SCHED_FIFO or SCHED_RR the runtime makes use\n+   --  of the entire range provided by the system.\n+   --\n+   --  If the scheduling policy is SCHED_OTHER the only valid system priority\n+   --  is 1 and other values are simply ignored.\n+\n+   Max_Priority           : constant Positive := 97;\n+   Max_Interrupt_Priority : constant Positive := 98;\n+\n+   subtype Any_Priority       is Integer      range  0 .. 98;\n+   subtype Priority           is Any_Priority range  0 .. 97;\n+   subtype Interrupt_Priority is Any_Priority range 98 .. 98;\n+\n+   Default_Priority : constant Priority := 48;\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := True;\n+   Command_Line_Args         : constant Boolean := True;\n+   Configurable_Run_Time     : constant Boolean := False;\n+   Denorm                    : constant Boolean := True;\n+   Duration_32_Bits          : constant Boolean := False;\n+   Exit_Status_Supported     : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n+   Frontend_Layout           : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   Preallocated_Stacks       : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := True;\n+   Stack_Check_Limits        : constant Boolean := False;\n+   Support_Aggregates        : constant Boolean := True;\n+   Support_Atomic_Primitives : constant Boolean := True;\n+   Support_Composite_Assign  : constant Boolean := True;\n+   Support_Composite_Compare : constant Boolean := True;\n+   Support_Long_Shifts       : constant Boolean := True;\n+   Always_Compatible_Rep     : constant Boolean := False;\n+   Suppress_Standard_Library : constant Boolean := False;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   Frontend_Exceptions       : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := True;\n+\n+end System;"}, {"sha": "95eadfc8854e55f8f11989eba4402bab0e99f9c5", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -157,7 +157,8 @@ pragma Style_Checks (\"M32766\");\n # include <_types.h>\n #endif\n \n-#if defined (__linux__) || defined (__ANDROID__) || defined (__rtems__)\n+#if defined (__linux__) || defined (__ANDROID__) || defined (__QNX__) \\\n+  || defined (__rtems__)\n # include <pthread.h>\n # include <signal.h>\n #endif\n@@ -1191,7 +1192,7 @@ CND(MSG_WAITALL, \"Wait for full reception\")\n #endif\n CND(MSG_NOSIGNAL, \"No SIGPIPE on send\")\n \n-#if defined (__linux__) || defined (__ANDROID__)\n+#if defined (__linux__) || defined (__ANDROID__) || defined (__QNX__)\n # define MSG_Forced_Flags \"MSG_NOSIGNAL\"\n #else\n # define MSG_Forced_Flags \"0\"\n@@ -1361,7 +1362,7 @@ CND(SIZEOF_struct_hostent, \"struct hostent\")\n #define SIZEOF_struct_servent (sizeof (struct servent))\n CND(SIZEOF_struct_servent, \"struct servent\")\n \n-#if defined (__linux__) || defined (__ANDROID__)\n+#if defined (__linux__) || defined (__ANDROID__) || defined (__QNX__)\n #define SIZEOF_sigset (sizeof (sigset_t))\n CND(SIZEOF_sigset, \"sigset\")\n #endif\n@@ -1464,7 +1465,7 @@ CNS(CLOCK_RT_Ada, \"\")\n #endif\n \n #if defined (__APPLE__) || defined (__linux__) || defined (__ANDROID__) \\\n-  || defined (__rtems__) || defined (DUMMY)\n+  || defined (__QNX__) || defined (__rtems__) || defined (DUMMY)\n /*\n \n    --  Sizes of pthread data types"}, {"sha": "62b59341069edb6e4bb934cef4d39814b3166ced", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 241, "deletions": 99, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -418,6 +418,13 @@ package body Sem_Aggr is\n    --  array of characters is expected. This procedure simply rewrites the\n    --  string as an aggregate, prior to resolution.\n \n+   ---------------------------------\n+   --  Delta aggregate processing --\n+   ---------------------------------\n+\n+   procedure Resolve_Delta_Array_Aggregate  (N : Node_Id; Typ : Entity_Id);\n+   procedure Resolve_Delta_Record_Aggregate (N : Node_Id; Typ : Entity_Id);\n+\n    ------------------------\n    -- Array_Aggr_Subtype --\n    ------------------------\n@@ -2759,143 +2766,278 @@ package body Sem_Aggr is\n \n    procedure Resolve_Delta_Aggregate (N : Node_Id; Typ : Entity_Id) is\n       Base   : constant Node_Id := Expression (N);\n+\n+   begin\n+      if not Is_Composite_Type (Typ) then\n+         Error_Msg_N (\"not a composite type\", N);\n+      end if;\n+\n+      Analyze_And_Resolve (Base, Typ);\n+\n+      if Is_Array_Type (Typ) then\n+         Resolve_Delta_Array_Aggregate (N, Typ);\n+      else\n+         Resolve_Delta_Record_Aggregate (N, Typ);\n+      end if;\n+\n+      Set_Etype (N, Typ);\n+   end Resolve_Delta_Aggregate;\n+\n+   -----------------------------------\n+   -- Resolve_Delta_Array_Aggregate --\n+   -----------------------------------\n+\n+   procedure Resolve_Delta_Array_Aggregate (N : Node_Id; Typ : Entity_Id) is\n       Deltas : constant List_Id := Component_Associations (N);\n+      Assoc      : Node_Id;\n+      Choice     : Node_Id;\n+      Index_Type : Entity_Id;\n \n-      function Get_Component_Type (Nam : Node_Id) return Entity_Id;\n+   begin\n+      Index_Type := Etype (First_Index (Typ));\n+      Assoc := First (Deltas);\n+      while Present (Assoc) loop\n+         if Nkind (Assoc) = N_Iterated_Component_Association then\n+            Choice := First (Choice_List (Assoc));\n+            while Present (Choice) loop\n+               if Nkind (Choice) = N_Others_Choice then\n+                  Error_Msg_N\n+                    (\"others not allowed in delta aggregate\", Choice);\n \n-      ------------------------\n-      -- Get_Component_Type --\n-      ------------------------\n+               else\n+                  Analyze_And_Resolve (Choice, Index_Type);\n+               end if;\n \n-      function Get_Component_Type (Nam : Node_Id) return Entity_Id is\n-         Comp : Entity_Id;\n+               Next (Choice);\n+            end loop;\n \n-      begin\n-         Comp := First_Entity (Typ);\n+            declare\n+               Id  : constant Entity_Id := Defining_Identifier (Assoc);\n+               Ent : constant Entity_Id :=\n+                       New_Internal_Entity\n+                         (E_Loop, Current_Scope, Sloc (Assoc), 'L');\n \n-         while Present (Comp) loop\n-            if Chars (Comp) = Chars (Nam) then\n-               if Ekind (Comp) = E_Discriminant then\n-                  Error_Msg_N (\"delta cannot apply to discriminant\", Nam);\n+            begin\n+               Set_Etype  (Ent, Standard_Void_Type);\n+               Set_Parent (Ent, Assoc);\n+\n+               if No (Scope (Id)) then\n+                  Enter_Name (Id);\n+                  Set_Etype (Id, Index_Type);\n+                  Set_Ekind (Id, E_Variable);\n+                  Set_Scope (Id, Ent);\n                end if;\n \n-               return Etype (Comp);\n-            end if;\n+               Push_Scope (Ent);\n+               Analyze_And_Resolve\n+                 (New_Copy_Tree (Expression (Assoc)), Component_Type (Typ));\n+               End_Scope;\n+            end;\n \n-            Comp := Next_Entity (Comp);\n-         end loop;\n+         else\n+            Choice := First (Choice_List (Assoc));\n+            while Present (Choice) loop\n+               if Nkind (Choice) = N_Others_Choice then\n+                  Error_Msg_N\n+                    (\"others not allowed in delta aggregate\", Choice);\n \n-         Error_Msg_NE (\"type& has no component with this name\", Nam, Typ);\n-         return Any_Type;\n-      end Get_Component_Type;\n+               else\n+                  Analyze (Choice);\n+                  if Is_Entity_Name (Choice)\n+                    and then Is_Type (Entity (Choice))\n+                  then\n+                     --  Choice covers a range of values.\n+                     if Base_Type (Entity (Choice)) /=\n+                        Base_Type (Index_Type)\n+                     then\n+                        Error_Msg_NE\n+                          (\"choice does mat match index type of\",\n+                           Choice, Typ);\n+                     end if;\n+                  else\n+                     Resolve (Choice, Index_Type);\n+                  end if;\n+               end if;\n \n-      --  Local variables\n+               Next (Choice);\n+            end loop;\n+\n+            Analyze_And_Resolve (Expression (Assoc), Component_Type (Typ));\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+   end Resolve_Delta_Array_Aggregate;\n \n+   ------------------------------------\n+   -- Resolve_Delta_Record_Aggregate --\n+   ------------------------------------\n+\n+   procedure Resolve_Delta_Record_Aggregate (N   : Node_Id; Typ : Entity_Id) is\n+      Deltas : constant List_Id := Component_Associations (N);\n       Assoc      : Node_Id;\n       Choice     : Node_Id;\n       Comp_Type  : Entity_Id;\n-      Index_Type : Entity_Id;\n \n-   --  Start of processing for Resolve_Delta_Aggregate\n+      --  Variables used to verify that discriminant-dependent components\n+      --  appear in the same variant.\n \n-   begin\n-      if not Is_Composite_Type (Typ) then\n-         Error_Msg_N (\"not a composite type\", N);\n-      end if;\n+      Variant  : Node_Id;\n+      Comp_Ref : Entity_Id;\n \n-      Analyze_And_Resolve (Base, Typ);\n+      procedure Check_Variant (Id : Entity_Id);\n+      --  If a given component of the delta aggregate appears in a variant\n+      --  part, verify that it is within the same variant as that of previous\n+      --  specified variant components of the delta.\n \n-      if Is_Array_Type (Typ) then\n-         Index_Type := Etype (First_Index (Typ));\n-         Assoc := First (Deltas);\n-         while Present (Assoc) loop\n-            if Nkind (Assoc) = N_Iterated_Component_Association then\n-               Choice := First (Choice_List (Assoc));\n-               while Present (Choice) loop\n-                  if Nkind (Choice) = N_Others_Choice then\n-                     Error_Msg_N\n-                       (\"others not allowed in delta aggregate\", Choice);\n+      function Nested_In (V1, V2 : Node_Id) return Boolean;\n+      --  Determine whether variant V1 is within variant V2.\n \n-                  else\n-                     Analyze_And_Resolve (Choice, Index_Type);\n-                  end if;\n+      function Get_Component_Type (Nam : Node_Id) return Entity_Id;\n+      --  Locate component with a given name and return its type. If none\n+      --  found report error.\n \n-                  Next (Choice);\n-               end loop;\n+      function Variant_Depth (N : Node_Id) return Integer;\n+      --  Determine the distance of a variant to the enclosing type\n+      --  declaration.\n+\n+      --------------------\n+      --  Check_Variant --\n+      --------------------\n+\n+      procedure Check_Variant (Id : Entity_Id) is\n+         Comp         : Entity_Id;\n+         Comp_Variant : Node_Id;\n+\n+      begin\n+         if not Has_Discriminants (Typ) then\n+            return;\n+         end if;\n+\n+         Comp := First_Entity (Typ);\n+         while Present (Comp) loop\n+            exit when Chars (Comp) = Chars (Id);\n+            Next_Component (Comp);\n+         end loop;\n \n+         --  Find the variant, if any, whose component list includes the\n+         --  component declaration.\n+\n+         Comp_Variant := Parent (Parent (List_Containing (Parent (Comp))));\n+         if Nkind (Comp_Variant) = N_Variant then\n+            if No (Variant) then\n+               Variant  := Comp_Variant;\n+               Comp_Ref := Comp;\n+\n+            elsif Variant /= Comp_Variant then\n                declare\n-                  Id  : constant Entity_Id := Defining_Identifier (Assoc);\n-                  Ent : constant Entity_Id :=\n-                          New_Internal_Entity\n-                            (E_Loop, Current_Scope, Sloc (Assoc), 'L');\n+                  D1 : constant Integer := Variant_Depth (Variant);\n+                  D2 : constant Integer := Variant_Depth (Comp_Variant);\n \n                begin\n-                  Set_Etype  (Ent, Standard_Void_Type);\n-                  Set_Parent (Ent, Assoc);\n-\n-                  if No (Scope (Id)) then\n-                     Enter_Name (Id);\n-                     Set_Etype (Id, Index_Type);\n-                     Set_Ekind (Id, E_Variable);\n-                     Set_Scope (Id, Ent);\n-                  end if;\n+                  if D1 = D2\n+                    or else\n+                     (D1 > D2 and then not Nested_In (Variant, Comp_Variant))\n+                    or else\n+                     (D2 > D1 and then not Nested_In (Comp_Variant, Variant))\n+                  then\n+                     Error_Msg_Node_2 := Comp_Ref;\n+                     Error_Msg_NE\n+                       (\"& and & appear in different variants\", Id, Comp);\n+\n+                  --  Otherwise retain the deeper variant for subsequent tests\n \n-                  Push_Scope (Ent);\n-                  Analyze_And_Resolve\n-                    (New_Copy_Tree (Expression (Assoc)), Component_Type (Typ));\n-                  End_Scope;\n+                  elsif D2 > D1 then\n+                     Variant := Comp_Variant;\n+                  end if;\n                end;\n+            end if;\n+         end if;\n+      end Check_Variant;\n \n-            else\n-               Choice := First (Choice_List (Assoc));\n-               while Present (Choice) loop\n-                  if Nkind (Choice) = N_Others_Choice then\n-                     Error_Msg_N\n-                       (\"others not allowed in delta aggregate\", Choice);\n+      ---------------\n+      -- Nested_In --\n+      ---------------\n \n-                  else\n-                     Analyze (Choice);\n-                     if Is_Entity_Name (Choice)\n-                       and then Is_Type (Entity (Choice))\n-                     then\n-                        --  Choice covers a range of values.\n-                        if Base_Type (Entity (Choice)) /=\n-                           Base_Type (Index_Type)\n-                        then\n-                           Error_Msg_NE\n-                             (\"choice does mat match index type of\",\n-                              Choice, Typ);\n-                        end if;\n-                     else\n-                        Resolve (Choice, Index_Type);\n-                     end if;\n-                  end if;\n+      function Nested_In (V1, V2 : Node_Id) return Boolean is\n+         Par : Node_Id;\n+      begin\n+         Par := Parent (V1);\n+         while Nkind (Par) /= N_Full_Type_Declaration loop\n+            if Par = V2 then\n+               return True;\n+            end if;\n+            Par := Parent (Par);\n+         end loop;\n \n-                  Next (Choice);\n-               end loop;\n+         return False;\n+      end Nested_In;\n \n-               Analyze_And_Resolve (Expression (Assoc), Component_Type (Typ));\n+      -------------------\n+      -- Variant_Depth --\n+      -------------------\n+\n+      function Variant_Depth (N : Node_Id) return Integer is\n+         Depth : Integer;\n+         Par   : Node_Id;\n+      begin\n+         Depth := 0;\n+         Par   := Parent (N);\n+         while Nkind (Par) /= N_Full_Type_Declaration loop\n+            Depth := Depth + 1;\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return Depth;\n+      end Variant_Depth;\n+\n+      ------------------------\n+      -- Get_Component_Type --\n+      ------------------------\n+\n+      function Get_Component_Type (Nam : Node_Id) return Entity_Id is\n+         Comp : Entity_Id;\n+\n+      begin\n+         Comp := First_Entity (Typ);\n+\n+         while Present (Comp) loop\n+            if Chars (Comp) = Chars (Nam) then\n+               if Ekind (Comp) = E_Discriminant then\n+                  Error_Msg_N (\"delta cannot apply to discriminant\", Nam);\n+               end if;\n+\n+               return Etype (Comp);\n             end if;\n \n-            Next (Assoc);\n+            Comp := Next_Entity (Comp);\n          end loop;\n \n-      else\n-         Assoc := First (Deltas);\n-         while Present (Assoc) loop\n-            Choice := First (Choice_List (Assoc));\n-            while Present (Choice) loop\n-               Comp_Type := Get_Component_Type (Choice);\n-               Next (Choice);\n-            end loop;\n+         Error_Msg_NE (\"type& has no component with this name\", Nam, Typ);\n+         return Any_Type;\n+      end Get_Component_Type;\n \n-            Analyze_And_Resolve (Expression (Assoc), Comp_Type);\n-            Next (Assoc);\n+   --  Start of processing for Resolve_Delta_Record_Aggregate\n+\n+   begin\n+      Variant := Empty;\n+      Assoc := First (Deltas);\n+\n+      while Present (Assoc) loop\n+         Choice := First (Choice_List (Assoc));\n+         while Present (Choice) loop\n+            Comp_Type := Get_Component_Type (Choice);\n+            if Comp_Type /= Any_Type then\n+               Check_Variant (Choice);\n+            end if;\n+\n+            Next (Choice);\n          end loop;\n-      end if;\n \n-      Set_Etype (N, Typ);\n-   end Resolve_Delta_Aggregate;\n+         Analyze_And_Resolve (Expression (Assoc), Comp_Type);\n+         Next (Assoc);\n+      end loop;\n+   end Resolve_Delta_Record_Aggregate;\n \n    ---------------------------------\n    -- Resolve_Extension_Aggregate --"}, {"sha": "214fb8ec3b7bbf3bbf4b0d2197a30fa2007df406", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -5143,6 +5143,38 @@ package body Sem_Res is\n \n             if not Is_Static_Coextension (N) then\n                Set_Is_Dynamic_Coextension (N);\n+\n+               --  ??? We currently do not handle finalization and deallocation\n+               --  of coextensions properly so let's at least warn the user\n+               --  about it.\n+\n+               if Is_Controlled_Active (Desig_T) then\n+                  if Is_Controlled_Active\n+                       (Defining_Identifier\n+                         (Parent (Associated_Node_For_Itype (Typ))))\n+                  then\n+                     Error_Msg_N\n+                       (\"info: coextension will not be finalized when its \"\n+                        & \"associated owner is finalized\", N);\n+                  else\n+                     Error_Msg_N\n+                       (\"info: coextension will not be finalized when its \"\n+                        & \"associated owner is deallocated\", N);\n+                  end if;\n+               else\n+                  if Is_Controlled_Active\n+                       (Defining_Identifier\n+                          (Parent (Associated_Node_For_Itype (Typ))))\n+                  then\n+                     Error_Msg_N\n+                       (\"info: coextension will not be deallocated when its \"\n+                        & \"associated owner is finalized\", N);\n+                  else\n+                     Error_Msg_N\n+                       (\"info: coextension will not be deallocated when its \"\n+                        & \"associated owner is deallocated\", N);\n+                  end if;\n+               end if;\n             end if;\n \n          --  Cleanup for potential static coextensions"}, {"sha": "317792a963d5890cebcdc99b7f8cabdcafd1131e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -7841,6 +7841,66 @@ package body Sem_Util is\n       raise Program_Error;\n    end Find_Corresponding_Discriminant;\n \n+   -------------------\n+   -- Find_DIC_Type --\n+   -------------------\n+\n+   function Find_DIC_Type (Typ : Entity_Id) return Entity_Id is\n+      Curr_Typ : Entity_Id;\n+      --  The current type being examined in the parent hierarchy traversal\n+\n+      DIC_Typ : Entity_Id;\n+      --  The type which carries the DIC pragma. This variable denotes the\n+      --  partial view when private types are involved.\n+\n+      Par_Typ : Entity_Id;\n+      --  The parent type of the current type. This variable denotes the full\n+      --  view when private types are involved.\n+\n+   begin\n+      --  The input type defines its own DIC pragma, therefore it is the owner\n+\n+      if Has_Own_DIC (Typ) then\n+         DIC_Typ := Typ;\n+\n+         --  Otherwise the DIC pragma is inherited from a parent type\n+\n+      else\n+         pragma Assert (Has_Inherited_DIC (Typ));\n+\n+         --  Climb the parent chain\n+\n+         Curr_Typ := Typ;\n+         loop\n+            --  Inspect the parent type. Do not consider subtypes as they\n+            --  inherit the DIC attributes from their base types.\n+\n+            DIC_Typ := Base_Type (Etype (Curr_Typ));\n+\n+            --  Look at the full view of a private type because the type may\n+            --  have a hidden parent introduced in the full view.\n+\n+            Par_Typ := DIC_Typ;\n+\n+            if Is_Private_Type (Par_Typ)\n+              and then Present (Full_View (Par_Typ))\n+            then\n+               Par_Typ := Full_View (Par_Typ);\n+            end if;\n+\n+            --  Stop the climb once the nearest parent type which defines a DIC\n+            --  pragma of its own is encountered or when the root of the parent\n+            --  chain is reached.\n+\n+            exit when Has_Own_DIC (DIC_Typ) or else Curr_Typ = Par_Typ;\n+\n+            Curr_Typ := Par_Typ;\n+         end loop;\n+      end if;\n+\n+      return DIC_Typ;\n+   end Find_DIC_Type;\n+\n    ----------------------------------\n    -- Find_Enclosing_Iterator_Loop --\n    ----------------------------------"}, {"sha": "9aaa1160ed7acc2d16a8751c4b8a291051f20f85", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -769,6 +769,11 @@ package Sem_Util is\n    --  analyzed. Subsequent uses of this id on a different type denotes the\n    --  discriminant at the same position in this new type.\n \n+   function Find_DIC_Type (Typ : Entity_Id) return Entity_Id;\n+   --  Subsidiary to all Build_DIC_Procedure_xxx routines. Find the type which\n+   --  defines the Default_Initial_Condition pragma of type Typ. This is either\n+   --  Typ itself or a parent type when the pragma is inherited.\n+\n    function Find_Enclosing_Iterator_Loop (Id : Entity_Id) return Entity_Id;\n    --  Find the nearest iterator loop which encloses arbitrary entity Id. If\n    --  such a loop exists, return the entity of its identifier (E_Loop scope),"}, {"sha": "60c98e1935b9076e0a6d23b0a452d9ebf8f27cf5", "filename": "gcc/ada/sigtramp-qnx.c", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsigtramp-qnx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fsigtramp-qnx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-qnx.c?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -0,0 +1,301 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             S I G T R A M P                              *\n+ *                                                                          *\n+ *                         Asm Implementation File                          *\n+ *                                                                          *\n+ *           Copyright (C) 2017, Free Software Foundation, Inc.             *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * In particular,  you can freely  distribute your programs  built with the *\n+ * GNAT Pro compiler, including any required library run-time units,  using *\n+ * any licensing terms  of your choosing.  See the AdaCore Software License *\n+ * for full details.                                                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/**********************************************\n+ * QNX version of the __gnat_sigtramp service *\n+ **********************************************/\n+\n+#include <ucontext.h>\n+\n+#include \"sigtramp.h\"\n+/* See sigtramp.h for a general explanation of functionality.  */\n+\n+extern void __gnat_sigtramp_common\n+  (int signo, void *siginfo, void *sigcontext,\n+   __sigtramphandler_t * handler);\n+\n+void __gnat_sigtramp (int signo, void *si, void *sc,\n+                      __sigtramphandler_t * handler)\n+     __attribute__((optimize(2)));\n+\n+void __gnat_sigtramp (int signo, void *si, void *ucontext,\n+                      __sigtramphandler_t * handler)\n+{\n+  struct sigcontext *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n+\n+  __gnat_sigtramp_common (signo, si, mcontext, handler);\n+}\n+\n+/* asm string construction helpers.  */\n+\n+#define STR(TEXT) #TEXT\n+/* stringify expanded TEXT, surrounding it with double quotes.  */\n+\n+#define S(E) STR(E)\n+/* stringify E, which will resolve as text but may contain macros\n+   still to be expanded.  */\n+\n+/* asm (TEXT) outputs <tab>TEXT. These facilitate the output of\n+   multiline contents:  */\n+#define TAB(S) \"\\t\" S\n+#define CR(S)  S \"\\n\"\n+\n+#undef TCR\n+#define TCR(S) TAB(CR(S))\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#ifdef __x86_64__\n+/*****************************************\n+ *               x86-64                  *\n+ *****************************************/\n+\n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_##REG)\n+\n+// CFI register numbers\n+#define REGNO_RAX 0\n+#define REGNO_RDX 1\n+#define REGNO_RCX 2\n+#define REGNO_RBX 3\n+#define REGNO_RSI 4\n+#define REGNO_RDI 5\n+#define REGNO_RBP 6\n+#define REGNO_RSP 7\n+#define REGNO_R8 8\n+#define REGNO_R9 9\n+#define REGNO_R10 10\n+#define REGNO_R11 11\n+#define REGNO_R12 12\n+#define REGNO_R13 13\n+#define REGNO_R14 14\n+#define REGNO_R15 15\n+#define REGNO_RPC 16 /* aka %rip */\n+\n+//  Registers offset from the regset structure\n+#define REG_RDI 0x00\n+#define REG_RSI 0x08\n+#define REG_RDX 0x10\n+#define REG_R10 0x18\n+#define REG_R8  0x20\n+#define REG_R9  0x28\n+#define REG_RAX 0x30\n+#define REG_RBX 0x38\n+#define REG_RBP 0x40\n+#define REG_RCX 0x48\n+#define REG_R11 0x50\n+#define REG_R12 0x58\n+#define REG_R13 0x60\n+#define REG_R14 0x68\n+#define REG_R15 0x70\n+#define REG_RPC 0x78 /* RIP */\n+#define REG_RSP 0x90\n+\n+#define CFI_COMMON_REGS \\\n+CR(\"# CFI for common registers\\n\") \\\n+TCR(COMMON_CFI(RSP)) \\\n+TCR(COMMON_CFI(R15)) \\\n+TCR(COMMON_CFI(R14)) \\\n+TCR(COMMON_CFI(R13)) \\\n+TCR(COMMON_CFI(R12)) \\\n+TCR(COMMON_CFI(R11)) \\\n+TCR(COMMON_CFI(RCX)) \\\n+TCR(COMMON_CFI(RBP)) \\\n+TCR(COMMON_CFI(RBX)) \\\n+TCR(COMMON_CFI(RAX)) \\\n+TCR(COMMON_CFI(R9)) \\\n+TCR(COMMON_CFI(R8)) \\\n+TCR(COMMON_CFI(R10)) \\\n+TCR(COMMON_CFI(RSI)) \\\n+TCR(COMMON_CFI(RDI)) \\\n+TCR(COMMON_CFI(RDX)) \\\n+TCR(COMMON_CFI(RPC)) \\\n+TCR(\".cfi_return_column \" S(REGNO_RPC))\n+\n+#define SIGTRAMP_BODY     \\\n+TCR(\".cfi_def_cfa 15, 0\") \\\n+CFI_COMMON_REGS \\\n+CR(\"\") \\\n+TCR(\"# Allocate frame and save the non-volatile\") \\\n+TCR(\"# registers we're going to modify\") \\\n+TCR(\"subq\t$8, %rsp\") \\\n+TCR(\"# Setup CFA_REG = context, which we'll retrieve as our CFA value\") \\\n+TCR(\"movq\t%rdx, %r15\") \\\n+TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n+TCR(\"# arguments are the same as those we received\") \\\n+TCR(\"call\t*%rcx\") \\\n+TCR(\"# This part should never be executed\") \\\n+TCR(\"addq\t$8, %rsp\") \\\n+TCR(\"ret\")\n+#endif\n+\n+#ifdef __aarch64__\n+/*****************************************\n+ *               Aarch64                 *\n+ *****************************************/\n+\n+#define UC_MCONTEXT_SS 16\n+\n+#define CFA_REG  19\n+#define BASE_REG 20\n+\n+#define DW_CFA_def_cfa    0x0c\n+#define DW_CFA_expression 0x10\n+\n+#define DW_OP_breg(n)     0x70+(n)\n+\n+#define REG_REGNO_GR(n)   n\n+#define REG_REGNO_PC      30\n+\n+/* The first byte of the SLEB128 value of the offset.  */\n+#define REG_OFFSET_GR(n)         (UC_MCONTEXT_SS + n * 8)\n+#define REG_OFFSET_LONG_GR(n)    (UC_MCONTEXT_SS + n * 8 + 128)\n+#define REG_OFFSET_LONG128_GR(n) (UC_MCONTEXT_SS + (n - 16) * 8 + 128)\n+#define REG_OFFSET_LONG256_GR(n) (UC_MCONTEXT_SS + (n - 32) * 8 + 128)\n+\n+#define REG_OFFSET_LONG256_PC    REG_OFFSET_LONG256_GR(32)\n+\n+#define CFI_DEF_CFA \\\n+  TCR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n+\n+/* We need 4 variants depending on the offset: 0+, 64+, 128+, 256+.  */\n+#define COMMON_CFI(REG) \\\n+  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",2,\" \\\n+  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_##REG)\n+\n+#define COMMON_LONG_CFI(REG) \\\n+  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n+  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG_##REG) \",0\"\n+\n+#define COMMON_LONG128_CFI(REG) \\\n+  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n+  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG128_##REG) \",1\"\n+\n+#define COMMON_LONG256_CFI(REG) \\\n+  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n+  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG256_##REG) \",2\"\n+\n+#define CFI_COMMON_REGS \\\n+  CR(\"# CFI for common registers\\n\") \\\n+  TCR(COMMON_CFI(GR(0)))  \\\n+  TCR(COMMON_CFI(GR(1)))  \\\n+  TCR(COMMON_CFI(GR(2)))  \\\n+  TCR(COMMON_CFI(GR(3)))  \\\n+  TCR(COMMON_CFI(GR(4)))  \\\n+  TCR(COMMON_CFI(GR(5)))  \\\n+  TCR(COMMON_LONG_CFI(GR(6)))  \\\n+  TCR(COMMON_LONG_CFI(GR(7)))  \\\n+  TCR(COMMON_LONG_CFI(GR(8)))  \\\n+  TCR(COMMON_LONG_CFI(GR(9)))  \\\n+  TCR(COMMON_LONG_CFI(GR(10))) \\\n+  TCR(COMMON_LONG_CFI(GR(11))) \\\n+  TCR(COMMON_LONG_CFI(GR(12))) \\\n+  TCR(COMMON_LONG_CFI(GR(13))) \\\n+  TCR(COMMON_LONG128_CFI(GR(14))) \\\n+  TCR(COMMON_LONG128_CFI(GR(15))) \\\n+  TCR(COMMON_LONG128_CFI(GR(16))) \\\n+  TCR(COMMON_LONG128_CFI(GR(17))) \\\n+  TCR(COMMON_LONG128_CFI(GR(18))) \\\n+  TCR(COMMON_LONG128_CFI(GR(19))) \\\n+  TCR(COMMON_LONG128_CFI(GR(20))) \\\n+  TCR(COMMON_LONG128_CFI(GR(21))) \\\n+  TCR(COMMON_LONG128_CFI(GR(22))) \\\n+  TCR(COMMON_LONG128_CFI(GR(23))) \\\n+  TCR(COMMON_LONG128_CFI(GR(24))) \\\n+  TCR(COMMON_LONG128_CFI(GR(25))) \\\n+  TCR(COMMON_LONG128_CFI(GR(26))) \\\n+  TCR(COMMON_LONG128_CFI(GR(27))) \\\n+  TCR(COMMON_LONG128_CFI(GR(28))) \\\n+  TCR(COMMON_LONG128_CFI(GR(29))) \\\n+  TCR(COMMON_LONG256_CFI(PC))\n+\n+#define SIGTRAMP_BODY \\\n+  CFI_DEF_CFA \\\n+  CFI_COMMON_REGS \\\n+  TCR(\"# Push FP and LR on stack\") \\\n+  TCR(\"stp x29, x30, [sp, #-32]!\") \\\n+  TCR(\"stp x\" S(CFA_REG) \", x\" S(BASE_REG) \", [sp, #16]\") \\\n+  TCR(\"mov x29, sp\") \\\n+  TCR(\"# Load the saved value of the stack pointer as CFA\") \\\n+  TCR(\"ldr x\" S(CFA_REG) \", [x2, #\" S(REG_OFFSET_GR(31)) \"]\") \\\n+  TCR(\"# Use x\" S(BASE_REG) \" as base register for the CFI\") \\\n+  TCR(\"mov x\" S(BASE_REG) \", x2\") \\\n+  TCR(\"# Call the handler\") \\\n+  TCR(\"blr x3\") \\\n+  TCR(\"# Release our frame and return (should never get here!).\") \\\n+  TCR(\"ldp x\" S(CFA_REG) \", x\" S(BASE_REG)\" , [sp, #16]\") \\\n+  TCR(\"ldp x29, x30, [sp], 32\") \\\n+  TCR(\"ret\")\n+\n+#endif /* AARCH64 */\n+\n+/* Symbol definition block\n+   -----------------------  */\n+\n+#if defined (__x86_64__) || defined (__aarch64__)\n+#define FUNC_ALIGN TCR(\".p2align 4,,15\")\n+#else\n+#define FUNC_ALIGN\n+#endif\n+\n+#define SIGTRAMP_START(SYM)       \\\n+CR(\"# \" S(SYM) \" cfi trampoline\") \\\n+TCR(\".type \" S(SYM) \", @function\") \\\n+CR(\"\") \\\n+FUNC_ALIGN \\\n+CR(S(SYM) \":\") \\\n+TCR(\".cfi_startproc\") \\\n+TCR(\".cfi_signal_frame\")\n+\n+/* Symbol termination block\n+   ------------------------  */\n+\n+#define SIGTRAMP_END(SYM) \\\n+CR(\".cfi_endproc\") \\\n+TCR(\".size \" S(SYM) \", .-\" S(SYM))\n+\n+/*----------------------------\n+  -- And now, the real code --\n+  ---------------------------- */\n+\n+/* Text section start.  The compiler isn't aware of that switch.  */\n+\n+asm (\".text\\n\"\n+     TCR(\".align 2\"));\n+\n+/* sigtramp stub for common registers.  */\n+\n+#define TRAMP_COMMON __gnat_sigtramp_common\n+\n+asm (SIGTRAMP_START(TRAMP_COMMON));\n+asm (SIGTRAMP_BODY);\n+asm (SIGTRAMP_END(TRAMP_COMMON));"}, {"sha": "9f300514ced8d50c2e6388a1a3ef72f583ca1602", "filename": "gcc/ada/terminals.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fterminals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc/gcc%2Fada%2Fterminals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fterminals.c?ref=8d9a1ba7bbd5bf5b7f5cfe1c88dd38d70ac54bbc", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *                     Copyright (C) 2008-2016, AdaCore                     *\n+ *                     Copyright (C) 2008-2017, AdaCore                     *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -1111,7 +1111,7 @@ __gnat_setup_winsize (void *desc, int rows, int columns)\n /* On some system termio is either absent or including it will disable termios\n    (HP-UX) */\n #if !defined (__hpux__) && !defined (BSD) && !defined (__APPLE__) \\\n-  && !defined (__rtems__)\n+  && !defined (__rtems__) && !defined (__QNXNTO__)\n #   include <termio.h>\n #endif\n "}]}