{"sha": "89c54dd3572f87d645c385d13357babda66de29a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODljNTRkZDM1NzJmODdkNjQ1YzM4NWQxMzM1N2JhYmRhNjZkZTI5YQ==", "commit": {"author": {"name": "John Marino", "email": "gnugcc@marino.st", "date": "2015-05-27T16:14:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-05-27T16:14:10Z"}, "message": "config.host (i[34567]86-*-freebsd*, [...]): Set md_unwind_header\n\n        * config.host (i[34567]86-*-freebsd*, x86_64-*-freebsd*): Set\n        md_unwind_header\n        * config/i386/freebsd-unwind.h: New.\n\nFrom-SVN: r223765", "tree": {"sha": "1cd825215384062a6828c4e49454cf3342509d09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cd825215384062a6828c4e49454cf3342509d09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89c54dd3572f87d645c385d13357babda66de29a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c54dd3572f87d645c385d13357babda66de29a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c54dd3572f87d645c385d13357babda66de29a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c54dd3572f87d645c385d13357babda66de29a/comments", "author": null, "committer": null, "parents": [{"sha": "ff771de3b4e4c8f2f521681e5151db773b768f80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff771de3b4e4c8f2f521681e5151db773b768f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff771de3b4e4c8f2f521681e5151db773b768f80"}], "stats": {"total": 181, "additions": 181, "deletions": 0}, "files": [{"sha": "fb4d2bad8f0f2e4c850983d5ed2ba570388e17d3", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c54dd3572f87d645c385d13357babda66de29a/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c54dd3572f87d645c385d13357babda66de29a/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=89c54dd3572f87d645c385d13357babda66de29a", "patch": "@@ -1,3 +1,9 @@\n+2015-05-27  John Marino <gnugcc@marino.st>\n+\n+\t* config.host (i[34567]86-*-freebsd*, x86_64-*-freebsd*): Set\n+\tmd_unwind_header\n+\t* config/i386/freebsd-unwind.h: New.\n+\n 2015-05-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config.host (i[34567]-*-*, x86_64-*-*): Add t-crtfm instead of"}, {"sha": "46666df87daebae03ed4dc14c294da4ef10107e7", "filename": "libgcc/config.host", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c54dd3572f87d645c385d13357babda66de29a/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c54dd3572f87d645c385d13357babda66de29a/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=89c54dd3572f87d645c385d13357babda66de29a", "patch": "@@ -578,9 +578,11 @@ x86_64-*-dragonfly*)\n \t;;\n i[34567]86-*-freebsd*)\n \ttmake_file=\"${tmake_file} i386/t-freebsd i386/t-crtstuff\"\n+\tmd_unwind_header=i386/freebsd-unwind.h\n \t;;\n x86_64-*-freebsd*)\n \ttmake_file=\"${tmake_file} i386/t-freebsd i386/t-crtstuff\"\n+\tmd_unwind_header=i386/freebsd-unwind.h\n \t;;\n i[34567]86-*-netbsdelf*)\n \t;;"}, {"sha": "b83ba0db5036954afd04e94ece99a355befbadb9", "filename": "libgcc/config/i386/freebsd-unwind.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c54dd3572f87d645c385d13357babda66de29a/libgcc%2Fconfig%2Fi386%2Ffreebsd-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c54dd3572f87d645c385d13357babda66de29a/libgcc%2Fconfig%2Fi386%2Ffreebsd-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ffreebsd-unwind.h?ref=89c54dd3572f87d645c385d13357babda66de29a", "patch": "@@ -0,0 +1,173 @@\n+/* DWARF2 EH unwinding support for FreeBSD: AMD x86-64 and x86.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by John Marino <gnugcc@marino.st>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs. */\n+\n+#include <sys/types.h>\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+#include <machine/sigframe.h>\n+\n+#define REG_NAME(reg)\tsf_uc.uc_mcontext.mc_## reg\n+\n+#ifdef __x86_64__\n+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_freebsd_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+x86_64_freebsd_fallback_frame_state\n+(struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  struct sigframe *sf;\n+  long new_cfa;\n+\n+  /* Prior to FreeBSD 9, the signal trampoline was located immediately\n+     before the ps_strings.  To support non-executable stacks on AMD64,\n+     the sigtramp was moved to a shared page for FreeBSD 9.  Unfortunately\n+     this means looking frame patterns again (sys/amd64/amd64/sigtramp.S)\n+     rather than using the robust and convenient KERN_PS_STRINGS trick.\n+\n+     <pc + 00>:  lea     0x10(%rsp),%rdi\n+     <pc + 05>:  pushq   $0x0\n+     <pc + 17>:  mov     $0x1a1,%rax\n+     <pc + 14>:  syscall\n+\n+     If we can't find this pattern, we're at the end of the stack.\n+  */\n+\n+  if (!(   *(unsigned int *)(context->ra)      == 0x247c8d48\n+        && *(unsigned int *)(context->ra +  4) == 0x48006a10\n+        && *(unsigned int *)(context->ra +  8) == 0x01a1c0c7\n+        && *(unsigned int *)(context->ra + 12) == 0x050f0000 ))\n+    return _URC_END_OF_STACK;\n+\n+  sf = (struct sigframe *) context->cfa;\n+  new_cfa = sf->REG_NAME(rsp);\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  /* Register 7 is rsp  */\n+  fs->regs.cfa_reg = 7;\n+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;\n+\n+  /* The SVR4 register numbering macros aren't usable in libgcc.  */\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(rax) - new_cfa;\n+  fs->regs.reg[1].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(rdx) - new_cfa;\n+  fs->regs.reg[2].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(rcx) - new_cfa;\n+  fs->regs.reg[3].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(rbx) - new_cfa;\n+  fs->regs.reg[4].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[4].loc.offset = (long)&sf->REG_NAME(rsi) - new_cfa;\n+  fs->regs.reg[5].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(rdi) - new_cfa;\n+  fs->regs.reg[6].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(rbp) - new_cfa;\n+  fs->regs.reg[8].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(r8) - new_cfa;\n+  fs->regs.reg[9].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[9].loc.offset = (long)&sf->REG_NAME(r9) - new_cfa;\n+  fs->regs.reg[10].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(r10) - new_cfa;\n+  fs->regs.reg[11].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(r11) - new_cfa;\n+  fs->regs.reg[12].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(r12) - new_cfa;\n+  fs->regs.reg[13].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(r13) - new_cfa;\n+  fs->regs.reg[14].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(r14) - new_cfa;\n+  fs->regs.reg[15].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(r15) - new_cfa;\n+  fs->regs.reg[16].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(rip) - new_cfa;\n+  fs->retaddr_column = 16;\n+  fs->signal_frame = 1;\n+  return _URC_NO_REASON;\n+}\n+\n+#else /* Next section is for i386  */\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR x86_freebsd_fallback_frame_state\n+\n+/*\n+ * We can't use KERN_PS_STRINGS anymore if we want to support FreeBSD32\n+ * compat on AMD64.  The sigtramp is in a shared page in that case so the\n+ * x86_sigtramp_range only works on a true i386 system.  We have to\n+ * search for the sigtramp frame if we want it working everywhere.\n+ */\n+\n+static _Unwind_Reason_Code\n+x86_freebsd_fallback_frame_state\n+(struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  struct sigframe *sf;\n+  long new_cfa;\n+\n+/*\n+ * i386 sigtramp frame we are looking for follows.\n+ * Apparently PSL_VM is variable, so we can't look past context->ra + 4\n+ * <sigcode>:\n+ *   0:\tff 54 24 10          \tcall   *0x10(%esp)          *SIGF_HANDLER\n+ *   4:\t8d 44 24 20          \tlea    0x20(%esp),%eax       SIGF_UC\n+ *   8:\t50                   \tpush   %eax\n+ *   9:\tf7 40 54 00 00 02 00 \ttestl  $0x20000,0x54(%eax)  $PSL_VM\n+ *  10:\t75 03                \tjne    15 <sigcode+0x15>\n+ *  12:\t8e 68 14             \tmov    0x14(%eax),%gs        UC_GS\n+ *  15:\tb8 a1 01 00 00       \tmov    0x1a1,%eax           $SYS_sigreturn\n+ */\n+\n+  if (!(   *(unsigned int *)(context->ra - 4) == 0x102454ff\n+        && *(unsigned int *)(context->ra)     == 0x2024448d ))\n+    return _URC_END_OF_STACK;\n+\n+  sf = (struct sigframe *) context->cfa;\n+  new_cfa = sf->REG_NAME(esp);\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = 4;\n+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;\n+\n+  /* The SVR4 register numbering macros aren't usable in libgcc.  */\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(eax) - new_cfa;\n+  fs->regs.reg[3].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(ebx) - new_cfa;\n+  fs->regs.reg[1].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ecx) - new_cfa;\n+  fs->regs.reg[2].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(edx) - new_cfa;\n+  fs->regs.reg[6].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(esi) - new_cfa;\n+  fs->regs.reg[7].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(edi) - new_cfa;\n+  fs->regs.reg[5].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(ebp) - new_cfa;\n+  fs->regs.reg[8].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(eip) - new_cfa;\n+  fs->retaddr_column = 8;\n+  fs->signal_frame = 1;\n+  return _URC_NO_REASON;\n+}\n+#endif /* ifdef __x86_64__  */"}]}