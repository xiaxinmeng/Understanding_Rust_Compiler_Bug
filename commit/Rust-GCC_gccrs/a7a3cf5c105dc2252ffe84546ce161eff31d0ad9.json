{"sha": "a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdhM2NmNWMxMDVkYzIyNTJmZmU4NDU0NmNlMTYxZWZmMzFkMGFkOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-24T13:31:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-24T13:31:46Z"}, "message": "[multiple changes]\n\n2009-04-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb: additional optimization to inhibit creation of\n\tredundant transient scopes.\n\n2009-04-24  Bob Duff  <duff@adacore.com>\n\n\t* rtsfind.ads: Minor comment fix\n\n2009-04-24  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-proc.adb, prj-nmsc.adb (Find_Ada_Sources,\n\tGet_Path_Name_And_Record_Ada_Sources): merged, since these were\n\tbasically doing the same work (for explicit or implicit sources).\n\t(Find_Explicit_Sources): renamed to Find_Sources to better reflect its\n\trole. Rewritten to share some code (testing that all explicit sources\n\thave been found) between ada_only and multi_language modes.\n\n2009-04-24  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* sem_prag.adb (Check_Form_Of_Interface_Name): Allow space in Ext_Name\n\tfor CLI imported types.\n\t(Analyze_Pragma): Allow CIL or Java imported functions returning\n\taccess-to-subprogram types.\n\nFrom-SVN: r146720", "tree": {"sha": "da97e37aa293ac609c71934f607369838d66319e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da97e37aa293ac609c71934f607369838d66319e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/comments", "author": null, "committer": null, "parents": [{"sha": "2324b3fd3862e466c3098c17eeb06b056f1d16ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2324b3fd3862e466c3098c17eeb06b056f1d16ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2324b3fd3862e466c3098c17eeb06b056f1d16ee"}], "stats": {"total": 578, "additions": 267, "deletions": 311}, "files": [{"sha": "383d65c9ed59b6bd7c3f3846046179c21df007b6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "patch": "@@ -1,3 +1,28 @@\n+2009-04-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb: additional optimization to inhibit creation of\n+\tredundant transient scopes.\n+\n+2009-04-24  Bob Duff  <duff@adacore.com>\n+\n+\t* rtsfind.ads: Minor comment fix\n+\n+2009-04-24  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-proc.adb, prj-nmsc.adb (Find_Ada_Sources,\n+\tGet_Path_Name_And_Record_Ada_Sources): merged, since these were\n+\tbasically doing the same work (for explicit or implicit sources).\n+\t(Find_Explicit_Sources): renamed to Find_Sources to better reflect its\n+\trole. Rewritten to share some code (testing that all explicit sources\n+\thave been found) between ada_only and multi_language modes.\n+\n+2009-04-24  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* sem_prag.adb (Check_Form_Of_Interface_Name): Allow space in Ext_Name\n+\tfor CLI imported types.\n+\t(Analyze_Pragma): Allow CIL or Java imported functions returning\n+\taccess-to-subprogram types.\n+\n 2009-04-24  Emmanuel Briot  <briot@adacore.com>\n \n \t* make.adb, prj.adb, prj.ads, makeutl.adb, makeutl.ads:"}, {"sha": "bc0cc3150a68613860adfbc1a02104e4f0bac937", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 181, "deletions": 298, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "patch": "@@ -351,13 +351,17 @@ package body Prj.Nmsc is\n    --  Debug_Name is the name representing the list, and is used for debug\n    --  output only.\n \n-   procedure Get_Path_Names_And_Record_Ada_Sources\n-     (Project     : Project_Id;\n-      In_Tree     : Project_Tree_Ref;\n-      Data        : in out Project_Data;\n-      Current_Dir : String);\n-   --  Find the path names of the source files in the Source_Names table\n-   --  in the source directories and record those that are Ada sources.\n+   procedure Find_Ada_Sources\n+     (Project               : Project_Id;\n+      In_Tree               : Project_Tree_Ref;\n+      Data                  : in out Project_Data;\n+      Current_Dir           : String;\n+      Explicit_Sources_Only : Boolean);\n+   --  Find all Ada sources by traversing all source directories.\n+   --  If Explicit_Sources_Only is True, then the sources found must belong to\n+   --  the list of sources specified explicitly in the project file.\n+   --  If Explicit_Sources_Only is False, then all sources matching the naming\n+   --  scheme are recorded.\n \n    function Compute_Directory_Last (Dir : String) return Natural;\n    --  Return the index of the last significant character in Dir. This is used\n@@ -372,15 +376,6 @@ package body Prj.Nmsc is\n    --  Prj.Err.Error_Msg. Otherwise, disregard Flag_Location and use\n    --  Error_Report.\n \n-   procedure Find_Ada_Sources\n-     (Project      : Project_Id;\n-      In_Tree      : Project_Tree_Ref;\n-      Data         : in out Project_Data;\n-      Current_Dir  : String);\n-   --  Find all the Ada sources in all of the source directories of a project\n-   --  Current_Dir should represent the current directory, and is passed for\n-   --  efficiency to avoid system calls to recompute it.\n-\n    procedure Search_Directories\n      (Project         : Project_Id;\n       In_Tree         : Project_Tree_Ref;\n@@ -468,16 +463,15 @@ package body Prj.Nmsc is\n    --  Get the list of sources from a text file and put them in hash table\n    --  Source_Names.\n \n-   procedure Find_Explicit_Sources\n+   procedure Find_Sources\n      (Current_Dir : String;\n       Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n       Data        : in out Project_Data);\n    --  Process the Source_Files and Source_List_File attributes, and store\n    --  the list of source files into the Source_Names htable.\n-   --\n-   --  Lang indicates which language is being processed when in Ada_Only mode\n-   --  (all languages are processed anyway when in Multi_Language mode).\n+   --  When these attributes are not defined, find all files matching the\n+   --  naming schemes in the source directories.\n \n    procedure Compute_Unit_Name\n      (File_Name       : File_Name_Type;\n@@ -5395,131 +5389,6 @@ package body Prj.Nmsc is\n       Error_Report (Error_Buffer (1 .. Error_Last), Project, In_Tree);\n    end Error_Msg;\n \n-   ----------------------\n-   -- Find_Ada_Sources --\n-   ----------------------\n-\n-   procedure Find_Ada_Sources\n-     (Project      : Project_Id;\n-      In_Tree      : Project_Tree_Ref;\n-      Data         : in out Project_Data;\n-      Current_Dir  : String)\n-   is\n-      Source_Dir      : String_List_Id := Data.Source_Dirs;\n-      Element         : String_Element;\n-      Dir             : Dir_Type;\n-      Current_Source  : String_List_Id := Nil_String;\n-      Source_Recorded : Boolean := False;\n-\n-   begin\n-      if Current_Verbosity = High then\n-         Write_Line (\"Looking for sources:\");\n-      end if;\n-\n-      --  For each subdirectory\n-\n-      while Source_Dir /= Nil_String loop\n-         begin\n-            Source_Recorded := False;\n-            Element := In_Tree.String_Elements.Table (Source_Dir);\n-            if Element.Value /= No_Name then\n-               Get_Name_String (Element.Display_Value);\n-\n-               declare\n-                  Source_Directory : constant String :=\n-                    Name_Buffer (1 .. Name_Len) & Directory_Separator;\n-                  Dir_Last  : constant Natural :=\n-                     Compute_Directory_Last (Source_Directory);\n-\n-               begin\n-                  if Current_Verbosity = High then\n-                     Write_Attr (\"Source_Dir\", Source_Directory);\n-                  end if;\n-\n-                  --  We look at every entry in the source directory\n-\n-                  Open (Dir,\n-                        Source_Directory (Source_Directory'First .. Dir_Last));\n-\n-                  loop\n-                     Read (Dir, Name_Buffer, Name_Len);\n-\n-                     if Current_Verbosity = High then\n-                        Write_Str  (\" Checking \");\n-                        Write_Line (Name_Buffer (1 .. Name_Len));\n-                     end if;\n-\n-                     exit when Name_Len = 0;\n-\n-                     declare\n-                        File_Name : constant File_Name_Type := Name_Find;\n-\n-                        --  ??? We could probably optimize the following call:\n-                        --  we need to resolve links only once for the\n-                        --  directory itself, and then do a single call to\n-                        --  readlink() for each file. Unfortunately that would\n-                        --  require a change in Normalize_Pathname so that it\n-                        --  has the option of not resolving links for its\n-                        --  Directory parameter, only for Name.\n-\n-                        Path : constant String :=\n-                                 Normalize_Pathname\n-                                   (Name      => Name_Buffer (1 .. Name_Len),\n-                                    Directory =>\n-                                      Source_Directory\n-                                        (Source_Directory'First .. Dir_Last),\n-                                    Resolve_Links =>\n-                                      Opt.Follow_Links_For_Files,\n-                                    Case_Sensitive => True);\n-\n-                        Path_Name : Path_Name_Type;\n-\n-                     begin\n-                        Name_Len := Path'Length;\n-                        Name_Buffer (1 .. Name_Len) := Path;\n-                        Path_Name := Name_Find;\n-\n-                        --  We attempt to register it as a source. However,\n-                        --  there is no error if the file does not contain a\n-                        --  valid source. But there is an error if we have a\n-                        --  duplicate unit name.\n-\n-                        Record_Ada_Source\n-                          (File_Name       => File_Name,\n-                           Path_Name       => Path_Name,\n-                           Project         => Project,\n-                           In_Tree         => In_Tree,\n-                           Data            => Data,\n-                           Location        => No_Location,\n-                           Current_Source  => Current_Source,\n-                           Source_Recorded => Source_Recorded,\n-                           Current_Dir     => Current_Dir);\n-                     end;\n-                  end loop;\n-\n-                  Close (Dir);\n-               end;\n-            end if;\n-\n-         exception\n-            when Directory_Error =>\n-               null;\n-         end;\n-\n-         if Source_Recorded then\n-            In_Tree.String_Elements.Table (Source_Dir).Flag :=\n-              True;\n-         end if;\n-\n-         Source_Dir := Element.Next;\n-      end loop;\n-\n-      if Current_Verbosity = High then\n-         Write_Line (\"end Looking for sources.\");\n-      end if;\n-\n-   end Find_Ada_Sources;\n-\n    --------------------------------\n    -- Free_Ada_Naming_Exceptions --\n    --------------------------------\n@@ -7021,11 +6890,11 @@ package body Prj.Nmsc is\n       end if;\n    end Find_Excluded_Sources;\n \n-   ---------------------------\n-   -- Find_Explicit_Sources --\n-   ---------------------------\n+   ------------------\n+   -- Find_Sources --\n+   ------------------\n \n-   procedure Find_Explicit_Sources\n+   procedure Find_Sources\n      (Current_Dir : String;\n       Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n@@ -7042,6 +6911,7 @@ package body Prj.Nmsc is\n                               Data.Decl.Attributes,\n                               In_Tree);\n       Name_Loc         : Name_Location;\n+      Has_Explicit_Sources : Boolean;\n \n    begin\n       pragma Assert (Sources.Kind = List, \"Source_Files is not a list\");\n@@ -7142,10 +7012,7 @@ package body Prj.Nmsc is\n                Current := Element.Next;\n             end loop;\n \n-            if Get_Mode = Ada_Only then\n-               Get_Path_Names_And_Record_Ada_Sources\n-                 (Project, In_Tree, Data, Current_Dir);\n-            end if;\n+            Has_Explicit_Sources := True;\n          end;\n \n          --  If we have no Source_Files attribute, check the Source_List_File\n@@ -7162,6 +7029,8 @@ package body Prj.Nmsc is\n                 (File_Name_Type (Source_List_File.Value), Data.Directory.Name);\n \n          begin\n+            Has_Explicit_Sources := True;\n+\n             if Source_File_Path_Name'Length = 0 then\n                Err_Vars.Error_Msg_File_1 :=\n                  File_Name_Type (Source_List_File.Value);\n@@ -7174,13 +7043,6 @@ package body Prj.Nmsc is\n                Get_Sources_From_File\n                  (Source_File_Path_Name, Source_List_File.Location,\n                   Project, In_Tree);\n-\n-               if Get_Mode = Ada_Only then\n-                  --  Look in the source directories to find those sources\n-\n-                  Get_Path_Names_And_Record_Ada_Sources\n-                    (Project, In_Tree, Data, Current_Dir);\n-               end if;\n             end if;\n          end;\n \n@@ -7189,69 +7051,83 @@ package body Prj.Nmsc is\n          --  specified. Find all the files that satisfy the naming\n          --  scheme in all the source directories.\n \n-         if Get_Mode = Ada_Only then\n-            Find_Ada_Sources (Project, In_Tree, Data, Current_Dir);\n-         end if;\n+         Has_Explicit_Sources := False;\n       end if;\n \n-      if Get_Mode = Multi_Language then\n+      if Get_Mode = Ada_Only then\n+         Find_Ada_Sources\n+           (Project, In_Tree, Data, Current_Dir,\n+            Explicit_Sources_Only => Has_Explicit_Sources);\n+\n+      else\n          Search_Directories\n            (Project, In_Tree, Data,\n             For_All_Sources =>\n               Sources.Default and then Source_List_File.Default);\n+      end if;\n \n-         --  Check if all exceptions have been found.\n-         --  For Ada, it is an error if an exception is not found.\n-         --  For other language, the source is simply removed.\n-\n-         declare\n-            Source : Source_Id;\n-            Iter   : Source_Iterator;\n+      --  Check if all exceptions have been found.\n+      --  For Ada, it is an error if an exception is not found.\n+      --  For other language, the source is simply removed.\n \n-         begin\n-            Iter := For_Each_Source (In_Tree, Project);\n-            loop\n-               Source := Prj.Element (Iter);\n-               exit when Source = No_Source;\n+      declare\n+         Source : Source_Id;\n+         Iter   : Source_Iterator;\n \n-               if Source.Naming_Exception\n-                 and then Source.Path = No_Path_Information\n-               then\n-                  if Source.Unit /= No_Name then\n-                     Error_Msg_Name_1 := Name_Id (Source.Display_File);\n-                     Error_Msg_Name_2 := Name_Id (Source.Unit);\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"source file %% for unit %% not found\",\n-                        No_Location);\n-                  end if;\n+      begin\n+         Iter := For_Each_Source (In_Tree, Project);\n+         loop\n+            Source := Prj.Element (Iter);\n+            exit when Source = No_Source;\n \n-                  Remove_Source (Source, No_Source);\n+            if Source.Naming_Exception\n+              and then Source.Path = No_Path_Information\n+            then\n+               if Source.Unit /= No_Name then\n+                  Error_Msg_Name_1 := Name_Id (Source.Display_File);\n+                  Error_Msg_Name_2 := Name_Id (Source.Unit);\n+                  Error_Msg\n+                    (Project, In_Tree,\n+                     \"source file %% for unit %% not found\",\n+                     No_Location);\n                end if;\n \n-               Next (Iter);\n-            end loop;\n-         end;\n+               Remove_Source (Source, No_Source);\n+            end if;\n+\n+            Next (Iter);\n+         end loop;\n+      end;\n \n-         --  Check that all sources in Source_Files or the file\n-         --  Source_List_File has been found.\n+      --  It is an error if a source file name in a source list or in a\n+      --  source list file is not found.\n \n+      if Has_Explicit_Sources then\n          declare\n-            Name_Loc : Name_Location;\n-\n+            NL          : Name_Location;\n+            First_Error : Boolean := True;\n          begin\n-            Name_Loc := Source_Names.Get_First;\n-            while Name_Loc /= No_Name_Location loop\n-               if (not Name_Loc.Except) and then (not Name_Loc.Found) then\n-                  Error_Msg_Name_1 := Name_Id (Name_Loc.Name);\n-                  Error_Msg\n-                    (Project,\n-                     In_Tree,\n-                     \"file %% not found\",\n-                     Name_Loc.Location);\n+            NL := Source_Names.Get_First;\n+            while NL /= No_Name_Location loop\n+               if not NL.Found then\n+                  Err_Vars.Error_Msg_File_1 := NL.Name;\n+\n+                  if First_Error then\n+                     Error_Msg\n+                       (Project, In_Tree,\n+                        \"source file { cannot be found\",\n+                        NL.Location);\n+                     First_Error := False;\n+\n+                  else\n+                     Error_Msg\n+                       (Project, In_Tree,\n+                        \"\\source file { cannot be found\",\n+                        NL.Location);\n+                  end if;\n                end if;\n \n-               Name_Loc := Source_Names.Get_Next;\n+               NL := Source_Names.Get_Next;\n             end loop;\n          end;\n       end if;\n@@ -7266,141 +7142,148 @@ package body Prj.Nmsc is\n               (Project, \"Ada\", In_Tree, Source_List_File.Location);\n          end if;\n       end if;\n+   end Find_Sources;\n \n-   end Find_Explicit_Sources;\n-\n-   -------------------------------------------\n-   -- Get_Path_Names_And_Record_Ada_Sources --\n-   -------------------------------------------\n+   ----------------------\n+   -- Find_Ada_Sources --\n+   ----------------------\n \n-   procedure Get_Path_Names_And_Record_Ada_Sources\n-     (Project     : Project_Id;\n-      In_Tree     : Project_Tree_Ref;\n-      Data        : in out Project_Data;\n-      Current_Dir : String)\n+   procedure Find_Ada_Sources\n+     (Project               : Project_Id;\n+      In_Tree               : Project_Tree_Ref;\n+      Data                  : in out Project_Data;\n+      Current_Dir           : String;\n+      Explicit_Sources_Only : Boolean)\n    is\n       Source_Dir      : String_List_Id;\n       Element         : String_Element;\n-      Path            : Path_Name_Type;\n       Dir             : Dir_Type;\n-      Name            : File_Name_Type;\n-      Canonical_Name  : File_Name_Type;\n-      Name_Str        : String (1 .. 1_024);\n-      Last            : Natural := 0;\n-      NL              : Name_Location;\n       Current_Source  : String_List_Id := Nil_String;\n-      First_Error     : Boolean := True;\n-      Source_Recorded : Boolean := False;\n+      Dir_Has_Source  : Boolean := False;\n+      NL              : Name_Location;\n \n    begin\n+      if Current_Verbosity = High then\n+         Write_Line (\"Looking for Ada sources:\");\n+      end if;\n+\n       --  We look in all source directories for the file names in the hash\n       --  table Source_Names.\n \n       Source_Dir := Data.Source_Dirs;\n       while Source_Dir /= Nil_String loop\n-         Source_Recorded := False;\n+         Dir_Has_Source := False;\n          Element := In_Tree.String_Elements.Table (Source_Dir);\n \n          declare\n             Dir_Path : constant String :=\n-              Get_Name_String (Element.Display_Value);\n+              Get_Name_String (Element.Display_Value) & Directory_Separator;\n+            Dir_Last  : constant Natural := Compute_Directory_Last (Dir_Path);\n          begin\n             if Current_Verbosity = High then\n-               Write_Str (\"checking directory \"\"\");\n-               Write_Str (Dir_Path);\n-               Write_Line (\"\"\"\");\n+               Write_Line (\"checking directory \"\"\" & Dir_Path & \"\"\"\");\n             end if;\n \n-            Open (Dir, Dir_Path);\n+            --  Look for all files in the current source directory\n \n-            loop\n-               Read (Dir, Name_Str, Last);\n-               exit when Last = 0;\n+            Open (Dir, Dir_Path (Dir_Path'First .. Dir_Last));\n \n-               Name_Len := Last;\n-               Name_Buffer (1 .. Name_Len) := Name_Str (1 .. Last);\n-               Name := Name_Find;\n+            loop\n+               Read (Dir, Name_Buffer, Name_Len);\n+               exit when Name_Len = 0;\n \n-               if Osint.File_Names_Case_Sensitive then\n-                  Canonical_Name := Name;\n-               else\n-                  Canonical_Case_File_Name (Name_Str (1 .. Last));\n-                  Name_Buffer (1 .. Name_Len) := Name_Str (1 .. Last);\n-                  Canonical_Name := Name_Find;\n+               if Current_Verbosity = High then\n+                  Write_Line (\" Checking \" & Name_Buffer (1 .. Name_Len));\n                end if;\n \n-               NL := Source_Names.Get (Canonical_Name);\n+               declare\n+                  Name : constant File_Name_Type := Name_Find;\n+                  Canonical_Name : File_Name_Type;\n+\n+                  --  ??? We could probably optimize the following call:\n+                  --  we need to resolve links only once for the\n+                  --  directory itself, and then do a single call to\n+                  --  readlink() for each file. Unfortunately that would\n+                  --  require a change in Normalize_Pathname so that it\n+                  --  has the option of not resolving links for its\n+                  --  Directory parameter, only for Name.\n+\n+                  Path : constant String :=\n+                    Normalize_Pathname\n+                      (Name           => Name_Buffer (1 .. Name_Len),\n+                       Directory      => Dir_Path (Dir_Path'First .. Dir_Last),\n+                       Resolve_Links  => Opt.Follow_Links_For_Files,\n+                       Case_Sensitive => True);\n+\n+                  Path_Name : Path_Name_Type;\n+                  To_Record : Boolean := False;\n+                  Location  : Source_Ptr;\n \n-               if NL /= No_Name_Location and then not NL.Found then\n-                  NL.Found := True;\n-                  Source_Names.Set (Canonical_Name, NL);\n-                  Name_Len := Dir_Path'Length;\n-                  Name_Buffer (1 .. Name_Len) := Dir_Path;\n+               begin\n+                  --  If the file was listed in the explicit list of sources,\n+                  --  mark it as such (since we'll need to report an error when\n+                  --  an explicit source was not found)\n+\n+                  if Explicit_Sources_Only then\n+                     Canonical_Name := Canonical_Case_File_Name\n+                       (Name_Id (Name));\n+                     NL := Source_Names.Get (Canonical_Name);\n+                     To_Record := NL /= No_Name_Location and then not NL.Found;\n+                     if To_Record then\n+                        NL.Found := True;\n+                        Location := NL.Location;\n+                        Source_Names.Set (Canonical_Name, NL);\n+                     end if;\n \n-                  if Name_Buffer (Name_Len) /= Directory_Separator then\n-                     Add_Char_To_Name_Buffer (Directory_Separator);\n+                  else\n+                     To_Record := True;\n+                     Location  := No_Location;\n                   end if;\n \n-                  Add_Str_To_Name_Buffer (Name_Str (1 .. Last));\n-                  Path := Name_Find;\n+                  if To_Record then\n+                     Name_Len := Path'Length;\n+                     Name_Buffer (1 .. Name_Len) := Path;\n+                     Path_Name := Name_Find;\n \n-                  if Current_Verbosity = High then\n-                     Write_Str  (\"  found \");\n-                     Write_Line (Get_Name_String (Name));\n-                  end if;\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"  recording \" & Get_Name_String (Name));\n+                     end if;\n \n-                  --  Register the source if it is an Ada compilation unit\n-\n-                  Record_Ada_Source\n-                    (File_Name       => Name,\n-                     Path_Name       => Path,\n-                     Project         => Project,\n-                     In_Tree         => In_Tree,\n-                     Data            => Data,\n-                     Location        => NL.Location,\n-                     Current_Source  => Current_Source,\n-                     Source_Recorded => Source_Recorded,\n-                     Current_Dir     => Current_Dir);\n-               end if;\n+                     --  Register the source if it is an Ada compilation unit\n+\n+                     Record_Ada_Source\n+                       (File_Name       => Name,\n+                        Path_Name       => Path_Name,\n+                        Project         => Project,\n+                        In_Tree         => In_Tree,\n+                        Data            => Data,\n+                        Location        => Location,\n+                        Current_Source  => Current_Source,\n+                        Source_Recorded => Dir_Has_Source,\n+                        Current_Dir     => Current_Dir);\n+                  end if;\n+               end;\n             end loop;\n \n             Close (Dir);\n+\n+         exception\n+            when others =>\n+               Close (Dir);\n+               raise;\n          end;\n \n-         if Source_Recorded then\n-            In_Tree.String_Elements.Table (Source_Dir).Flag :=\n-              True;\n+         if Dir_Has_Source then\n+            In_Tree.String_Elements.Table (Source_Dir).Flag := True;\n          end if;\n \n          Source_Dir := Element.Next;\n       end loop;\n \n-      --  It is an error if a source file name in a source list or\n-      --  in a source list file is not found.\n-\n-      NL := Source_Names.Get_First;\n-      while NL /= No_Name_Location loop\n-         if not NL.Found then\n-            Err_Vars.Error_Msg_File_1 := NL.Name;\n-\n-            if First_Error then\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"source file { cannot be found\",\n-                  NL.Location);\n-               First_Error := False;\n-\n-            else\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"\\source file { cannot be found\",\n-                  NL.Location);\n-            end if;\n-         end if;\n-\n-         NL := Source_Names.Get_Next;\n-      end loop;\n-   end Get_Path_Names_And_Record_Ada_Sources;\n+      if Current_Verbosity = High then\n+         Write_Line (\"End looking for sources\");\n+      end if;\n+   end Find_Ada_Sources;\n \n    -------------------------------\n    -- Check_File_Naming_Schemes --\n@@ -8230,7 +8113,7 @@ package body Prj.Nmsc is\n             Load_Naming_Exceptions (Project, In_Tree);\n          end if;\n \n-         Find_Explicit_Sources (Current_Dir, Project, In_Tree, Data);\n+         Find_Sources (Current_Dir, Project, In_Tree, Data);\n          Mark_Excluded_Sources;\n \n          if Get_Mode = Multi_Language then"}, {"sha": "078c592d7f1be65bf1637e1c8f6c543c0b9ddc7a", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "patch": "@@ -2391,8 +2391,7 @@ package body Prj.Proc is\n \n                Extending2 := Extending;\n                while Extending2 /= No_Project loop\n-                  if In_Tree.Projects.Table (Extending2).Ada_Sources /=\n-                    Nil_String\n+                  if Has_Ada_Sources (In_Tree.Projects.Table (Extending2))\n                     and then\n                       In_Tree.Projects.Table\n                         (Extending2).Object_Directory.Name = Obj_Dir"}, {"sha": "5439f4e0e172e9fc09682ccce29e8fa916e7e6fa", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2922,7 +2922,7 @@ package Rtsfind is\n    --  Returns True if the given Nam is an Expanded Name, whose Prefix is Ada,\n    --  and whose selector is either Text_IO.xxx or Wide_Text_IO.xxx or\n    --  Wide_Wide_Text_IO.xxx, where xxx is one of the subpackages of Text_IO\n-   --  that is specially handled as described above for Text_IO_Kludge.\n+   --  that is specially handled as described below for Text_IO_Kludge.\n \n    function RTE (E : RE_Id) return Entity_Id;\n    --  Given the entity defined in the above tables, as identified by the"}, {"sha": "daa607bb6efce3cceee8d2b63a8f60ba87b78c3f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "patch": "@@ -3929,20 +3929,21 @@ package body Sem_Prag is\n \n                if not In_Character_Range (C)\n \n-                  --  For all cases except external names on CLI target,\n+                  --  For all cases except CLI target,\n                   --  commas, spaces and slashes are dubious (in CLI, we use\n-                  --  spaces and commas in external names to specify assembly\n-                  --  version and public key, while slashes can be used in\n-                  --  names to mark nested classes).\n+                  --  commas and backslashes in external names to specify\n+                  --  assembly version and public key, while slashes and spaces\n+                  --  can be used in names to mark nested classes and\n+                  --  valuetypes).\n \n                   or else ((not Ext_Name_Case or else VM_Target /= CLI_Target)\n-                             and then (Get_Character (C) = ' '\n-                                         or else\n-                                       Get_Character (C) = ','\n+                             and then (Get_Character (C) = ','\n                                          or else\n                                        Get_Character (C) = '\\'))\n                  or else (VM_Target /= CLI_Target\n-                           and then Get_Character (C) = '/')\n+                            and then (Get_Character (C) = ' '\n+                                        or else\n+                                      Get_Character (C) = '/'))\n                then\n                   Error_Msg\n                     (\"?interface name contains illegal character\",\n@@ -8248,6 +8249,10 @@ package body Sem_Prag is\n                if Ekind (Def_Id) = E_Function\n                  and then\n                    (Is_Value_Type (Etype (Def_Id))\n+                     or else\n+                       (Ekind (Etype (Def_Id)) = E_Access_Subprogram_Type\n+                         and then\n+                          Atree.Convention (Etype (Def_Id)) = Convention)\n                      or else\n                        (Ekind (Etype (Def_Id)) in Access_Kind\n                          and then\n@@ -8271,7 +8276,7 @@ package body Sem_Prag is\n                      pragma Assert (Convention = Convention_CIL);\n                      Error_Pragma_Arg\n                        (\"pragma% requires function returning a \" &\n-                        \"'CIL access type\", Arg1);\n+                        \"'C'I'L access type\", Arg1);\n                   end if;\n                end if;\n "}, {"sha": "a3976bb7bdc1cf51731b01f9d6eaa7366d9b968b", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3cf5c105dc2252ffe84546ce161eff31d0ad9/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a7a3cf5c105dc2252ffe84546ce161eff31d0ad9", "patch": "@@ -2668,6 +2668,12 @@ package body Sem_Res is\n       --  common type. Used to enforce the restrictions on array conversions\n       --  of AI95-00246.\n \n+      function Static_Concatenation (N : Node_Id) return Boolean;\n+      --  Predicate to determine whether an actual that is a concatenation\n+      --  will be evaluated statically and does not need a transient scope.\n+      --  This must be determined before the actual is resolved and expanded\n+      --  because if needed the transient scope must be introduced earlier.\n+\n       --------------------------\n       -- Check_Argument_Order --\n       --------------------------\n@@ -3014,6 +3020,43 @@ package body Sem_Res is\n          return Root_Type (Base_Type (FT1)) = Root_Type (Base_Type (FT2));\n       end Same_Ancestor;\n \n+      --------------------------\n+      -- Static_Concatenation --\n+      --------------------------\n+\n+      function Static_Concatenation (N : Node_Id) return Boolean is\n+      begin\n+         if Nkind (N) /= N_Op_Concat\n+           or else Etype (N) /= Standard_String\n+         then\n+            return False;\n+\n+         elsif Nkind (Left_Opnd (N)) = N_String_Literal then\n+            return Static_Concatenation (Right_Opnd (N));\n+\n+         elsif Is_Entity_Name (Left_Opnd (N)) then\n+            declare\n+               Ent : constant Entity_Id := Entity (Left_Opnd (N));\n+\n+            begin\n+               if Ekind (Ent) = E_Constant\n+                 and then Present (Constant_Value (Ent))\n+                 and then Is_Static_Expression (Constant_Value (Ent))\n+               then\n+                  return Static_Concatenation (Right_Opnd (N));\n+               else\n+                  return False;\n+               end if;\n+            end;\n+\n+         elsif Static_Concatenation (Left_Opnd (N)) then\n+            return Static_Concatenation (Right_Opnd (N));\n+\n+         else\n+            return False;\n+         end if;\n+      end Static_Concatenation;\n+\n    --  Start of processing for Resolve_Actuals\n \n    begin\n@@ -3184,6 +3227,7 @@ package body Sem_Res is\n               and then\n                 not (Is_Intrinsic_Subprogram (Nam)\n                       and then Chars (Nam) = Name_Asm)\n+              and then not Static_Concatenation (A)\n             then\n                Establish_Transient_Scope (A, False);\n                Resolve (A, Etype (F));"}]}