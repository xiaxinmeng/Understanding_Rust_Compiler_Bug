{"sha": "b71b4522b534a93471f68f5ca1efd111315f5c5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcxYjQ1MjJiNTM0YTkzNDcxZjY4ZjVjYTFlZmQxMTEzMTVmNWM1ZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-07-07T22:23:26Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-07-07T22:23:26Z"}, "message": "Revert (note the sccvn portions are *not* reverted) 2007-07-06 Daniel Berlin <dberlin@dberlin.org>\n\n2007-07-07  Daniel Berlin  <dberlin@dberlin.org>\n\n\tRevert (note the sccvn portions are *not* reverted)\n\t2007-07-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/23488\n\n\t* tree-vn.c (set_value_handle): Use decl_vh_map for decl value\n\thandles.\n\t* tree-flow-inline.h (get_value_handle): Ditto.\n\t* tree-ssa-pre.c (decl_vh_map): New.\n\t(decl_node_pool): New.\n\t(can_value_number_operation): Support DECL_P.\n\t(can_PRE_operation): Ditto.\n\t(create_expression_by_pieces): Ditto.\n\t(find_existing_value_expr): Modify to differnetiate between\n\taddressing and top level.\n\t(create_value_handle_for_expr): Handle DECL's.\n\t(poolify_tree): Ditto.\n\t(make_values_for_phi): Don't insert into PHI_GEN during FRE.\n\t(make_values_for_stmt): Handle DECL's properly.\n\t(init_pre): Reorg to not init useless things during FRE.\n\t(fini_pre): Ditto.\n\t* tree-flow.h: Include pointer-set.h.\n\t(decl_vh_map): Declare.\n\t* Makefile.in (TREE_FLOW_H): Add pointer-set.h\n\nFrom-SVN: r126449", "tree": {"sha": "69e1814e576690f14ef7f3bcaba222527d7ee4e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69e1814e576690f14ef7f3bcaba222527d7ee4e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b71b4522b534a93471f68f5ca1efd111315f5c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b71b4522b534a93471f68f5ca1efd111315f5c5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b71b4522b534a93471f68f5ca1efd111315f5c5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b71b4522b534a93471f68f5ca1efd111315f5c5e/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e8eb4d81e74fbb97810ca6a3bd1a300deda24f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e8eb4d81e74fbb97810ca6a3bd1a300deda24f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e8eb4d81e74fbb97810ca6a3bd1a300deda24f0"}], "stats": {"total": 300, "additions": 130, "deletions": 170}, "files": [{"sha": "ce2a5143196056b7a91a3832bb80bd6249c23b32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b71b4522b534a93471f68f5ca1efd111315f5c5e", "patch": "@@ -1,3 +1,30 @@\n+2007-07-07  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tRevert (note the sccvn portions are *not* reverted)\n+\t2007-07-06  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/23488\n+\n+\t* tree-vn.c (set_value_handle): Use decl_vh_map for decl value\n+\thandles.\n+\t* tree-flow-inline.h (get_value_handle): Ditto.\n+\t* tree-ssa-pre.c (decl_vh_map): New.\n+\t(decl_node_pool): New.\n+\t(can_value_number_operation): Support DECL_P.\n+\t(can_PRE_operation): Ditto.\n+\t(create_expression_by_pieces): Ditto.\n+\t(find_existing_value_expr): Modify to differnetiate between\n+\taddressing and top level.\n+\t(create_value_handle_for_expr): Handle DECL's.\n+\t(poolify_tree): Ditto.\n+\t(make_values_for_phi): Don't insert into PHI_GEN during FRE.\n+\t(make_values_for_stmt): Handle DECL's properly.\n+\t(init_pre): Reorg to not init useless things during FRE.\n+\t(fini_pre): Ditto.\n+\t* tree-flow.h: Include pointer-set.h.\n+\t(decl_vh_map): Declare.\n+\t* Makefile.in (TREE_FLOW_H): Add pointer-set.h\n+\n 2007-07-07 Eric Weddington  <eweddington@cso.atmel.com>\n \n \t* config/avr/constraints.md (define_memory_constraint \"Q\"): Fix"}, {"sha": "c084f0a838bf5a3073f5909107c9bf0a033b25a7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b71b4522b534a93471f68f5ca1efd111315f5c5e", "patch": "@@ -805,7 +805,7 @@ TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H)\n TREE_GIMPLE_H = tree-gimple.h tree-iterator.h\n TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n \t\tbitmap.h $(BASIC_BLOCK_H) hard-reg-set.h $(TREE_GIMPLE_H) \\\n-\t\t$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H) pointer-set.h\n+\t\t$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H)\n TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H) vecprim.h\n PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)\n DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H) options.h"}, {"sha": "985607ac92d68543063105ba486c75757562b80f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b71b4522b534a93471f68f5ca1efd111315f5c5e", "patch": "@@ -1,3 +1,7 @@\n+2007-07-07  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* Revert add of gcc.dg/tree-ssa/ssa-pre-17.c.\n+\n 2007-07-07  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/32232"}, {"sha": "8fbfced3d5edf78c67b96dddc58c3f7996effb58", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-17.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e8eb4d81e74fbb97810ca6a3bd1a300deda24f0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e8eb4d81e74fbb97810ca6a3bd1a300deda24f0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c?ref=0e8eb4d81e74fbb97810ca6a3bd1a300deda24f0", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-pre-details\" } */\n-\n- int i; \n- int foo(int q) { \n-     int j;\n-     int p;\n-     for (j = 0; j < 9; j++)\n-       {\n-\t p = i + q;\n-       }\n-     return p;\n- }\n-/* We should replace p = a load from i that will pop into the loop, with a hoisted version.\n-   We should also replace i + q with a hoisted version.  */\n-/* { dg-final { scan-tree-dump-times \"Replaced \" 2 \"pre\" } } */\n-/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "cb2f6558943af67fcc76f63ba6d6f2b63eda41cb", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=b71b4522b534a93471f68f5ca1efd111315f5c5e", "patch": "@@ -1792,20 +1792,12 @@ get_value_handle (tree expr)\n {\n   if (TREE_CODE (expr) == SSA_NAME)\n     return SSA_NAME_VALUE (expr);\n-  else if (TREE_CODE (expr) == TREE_LIST\n+  else if (DECL_P (expr) || TREE_CODE (expr) == TREE_LIST\n \t   || TREE_CODE (expr) == CONSTRUCTOR)\n     {\n       tree_ann_common_t ann = tree_common_ann (expr);\n       return ((ann) ? ann->value_handle : NULL_TREE);\n     }\n-  else if (DECL_P (expr))\n-    {\n-      tree *result = (tree *)pointer_map_contains (decl_vh_map,\n-\t\t\t\t\t\t   expr);\n-      if (result)\n-\treturn *result;\n-      return NULL_TREE;\n-    }\n   else if (is_gimple_min_invariant (expr))\n     return expr;\n   else if (EXPR_P (expr))"}, {"sha": "542f5f85f3d56c82e571f97b7c4d0e4f160276c8", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b71b4522b534a93471f68f5ca1efd111315f5c5e", "patch": "@@ -31,7 +31,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-ssa-operands.h\"\n #include \"cgraph.h\"\n #include \"ipa-reference.h\"\n-#include \"pointer-set.h\"\n \n /* Forward declare structures for the garbage collector GTY markers.  */\n #ifndef GCC_BASIC_BLOCK_H\n@@ -1082,7 +1081,7 @@ extern bool maybe_clean_or_replace_eh_stmt (tree, tree);\n void add_to_value (tree, tree);\n void debug_value_expressions (tree);\n void print_value_expressions (FILE *, tree);\n-extern struct pointer_map_t *decl_vh_map;\n+\n \n /* In tree-vn.c  */\n tree make_value_handle (tree);"}, {"sha": "ce70a2609f5277df7180d154b50590de2d5a9203", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 95, "deletions": 131, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=b71b4522b534a93471f68f5ca1efd111315f5c5e", "patch": "@@ -46,7 +46,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"langhooks.h\"\n #include \"cfgloop.h\"\n #include \"tree-ssa-sccvn.h\"\n-#include \"pointer-set.h\"\n \n /* TODO:\n \n@@ -183,14 +182,6 @@ Boston, MA 02110-1301, USA.  */\n    useful only for debugging, since we don't do identity lookups.  */\n \n \n-/* Mapping from decl's to value handles, by pointer equality.  We\n-   \"unshare\" decls so we can give the same decl in different places\n-   different value handles.  */\n-struct pointer_map_t *decl_vh_map;\n-\n-/* Mapping from expressions to ids.  */\n-struct pointer_map_t *expression_id_map;\n-\n /* Next global expression id number.  */\n static unsigned int next_expression_id;\n \n@@ -202,14 +193,15 @@ static VEC(tree, heap) *expressions;\n static inline unsigned int\n alloc_expression_id (tree expr)\n {\n-  unsigned int *slot;\n+  tree_ann_common_t ann;\n+\n+  ann = get_tree_common_ann (expr);\n \n-  slot = (unsigned int *) pointer_map_insert (expression_id_map,\n-\t\t\t\t\t      expr);\n   /* Make sure we won't overflow. */\n   gcc_assert (next_expression_id + 1 > next_expression_id);\n \n-  *slot = next_expression_id++;\n+  ann->aux = XNEW (unsigned int);\n+  * ((unsigned int *)ann->aux) = next_expression_id++;\n   VEC_safe_push (tree, heap, expressions, expr);\n   return next_expression_id - 1;\n }\n@@ -219,10 +211,11 @@ alloc_expression_id (tree expr)\n static inline unsigned int\n get_expression_id (tree expr)\n {\n-  unsigned int *slot;\n-  slot = (unsigned int *) pointer_map_contains (expression_id_map,\n-\t\t\t\t\t\texpr);\n-  return *slot;\n+  tree_ann_common_t ann = tree_common_ann (expr);\n+  gcc_assert (ann);\n+  gcc_assert (ann->aux);\n+\n+  return  *((unsigned int *)ann->aux);\n }\n \n /* Return the existing expression id for EXPR, or create one if one\n@@ -231,13 +224,12 @@ get_expression_id (tree expr)\n static inline unsigned int\n get_or_alloc_expression_id (tree expr)\n {\n-  unsigned int *slot;\n-  slot = (unsigned int *) pointer_map_contains (expression_id_map,\n-\t\t\t\t\t\texpr);\n-  if (slot)\n-    return *slot;\n-  else\n+  tree_ann_common_t ann = tree_common_ann (expr);\n+\n+  if (ann == NULL || !ann->aux)\n     return alloc_expression_id (expr);\n+\n+  return get_expression_id (expr);\n }\n \n /* Return the expression that has expression id ID */\n@@ -248,6 +240,23 @@ expression_for_id (unsigned int id)\n   return VEC_index (tree, expressions, id);\n }\n \n+/* Free the expression id field in all of our expressions,\n+   and then destroy the expressions array.  */\n+\n+static void\n+clear_expression_ids (void)\n+{\n+  int i;\n+  tree expr;\n+\n+  for (i = 0; VEC_iterate (tree, expressions, i, expr); i++)\n+    {\n+      free (tree_common_ann (expr)->aux);\n+      tree_common_ann (expr)->aux = NULL;\n+    }\n+  VEC_free (tree, heap, expressions);\n+}\n+\n static bool in_fre = false;\n \n /* An unordered bitmap set.  One bitmap tracks values, the other,\n@@ -360,7 +369,6 @@ static alloc_pool unary_node_pool;\n static alloc_pool reference_node_pool;\n static alloc_pool comparison_node_pool;\n static alloc_pool modify_expr_node_pool;\n-static alloc_pool decl_node_pool;\n static bitmap_obstack grand_bitmap_obstack;\n \n /* We can't use allocation pools to hold temporary CALL_EXPR objects, since\n@@ -946,8 +954,7 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n     return expr;\n \n   /* Phi translations of a given expression don't change.  */\n-  if (EXPR_P (expr) || GIMPLE_STMT_P (expr) || REFERENCE_CLASS_P (expr)\n-      || DECL_P (expr))\n+  if (EXPR_P (expr) || GIMPLE_STMT_P (expr))\n     {\n       tree vh;\n \n@@ -1094,13 +1101,7 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\t\t\t\t\t    pred);\n \n \tif (oldvuses != newvuses)\n-\t  {\n-\t    tree newexpr = (tree) pool_alloc (decl_node_pool);\n-\t    memcpy (newexpr, expr, tree_size (expr));\n-\t    vn_lookup_or_add_with_vuses (newexpr, newvuses);\n-\t    expr = newexpr;\n-\t    phi_trans_add (expr, expr, pred, newvuses);\n-\t  }\n+\t  vn_lookup_or_add_with_vuses (expr, newvuses);\n \n \tphi_trans_add (oldexpr, expr, pred, newvuses);\n       }\n@@ -2064,7 +2065,6 @@ can_value_number_operation (tree op)\n     || BINARY_CLASS_P (op)\n     || COMPARISON_CLASS_P (op)\n     || REFERENCE_CLASS_P (op)\n-    || DECL_P (op)\n     || (TREE_CODE (op) == CALL_EXPR\n \t&& can_value_number_call (op));\n }\n@@ -2080,7 +2080,6 @@ can_PRE_operation (tree op)\n   return UNARY_CLASS_P (op)\n     || BINARY_CLASS_P (op)\n     || COMPARISON_CLASS_P (op)\n-    || DECL_P (op)\n     || TREE_CODE (op) == INDIRECT_REF\n     || TREE_CODE (op) == COMPONENT_REF\n     || TREE_CODE (op) == CALL_EXPR\n@@ -2317,14 +2316,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t\t\t      genop1, genop2);\n \tbreak;\n       }\n-    case tcc_declaration:\n-      {\n-\t/* Get the \"shared\" version of the DECL, that we didn't create\n-\t   using a pool.  */\n-\tfolded = referenced_var_lookup (DECL_UID (expr));\n-      }\n-      break;\n-      \n+\n     case tcc_unary:\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n@@ -2965,15 +2957,10 @@ find_existing_value_expr (tree t, tree stmt)\n    replaced with the value handles of each of the operands of EXPR.\n \n    VUSES represent the virtual use operands associated with EXPR (if\n-   any). Insert EXPR's operands into the EXP_GEN set for BLOCK.\n-\n-   TOP_LEVEL is true if we are at the top of the original\n-   expression.  This is used to differentiate between addressing and\n-   actual loads of globals.  IE a = t vs a = t[0].  */\n+   any). Insert EXPR's operands into the EXP_GEN set for BLOCK. */\n \n static inline tree\n-create_value_expr_from (tree expr, basic_block block, tree stmt,\n-\t\t\tbool top_level)\n+create_value_expr_from (tree expr, basic_block block, tree stmt)\n {\n   int i;\n   enum tree_code code = TREE_CODE (expr);\n@@ -2998,8 +2985,6 @@ create_value_expr_from (tree expr, basic_block block, tree stmt,\n     pool = binary_node_pool;\n   else if (TREE_CODE_CLASS (code) == tcc_comparison)\n     pool = comparison_node_pool;\n-  else if (TREE_CODE_CLASS (code) == tcc_declaration)\n-    pool = decl_node_pool;\n   else\n     gcc_assert (code == CALL_EXPR);\n \n@@ -3010,23 +2995,20 @@ create_value_expr_from (tree expr, basic_block block, tree stmt,\n       vexpr = (tree) pool_alloc (pool);\n       memcpy (vexpr, expr, tree_size (expr));\n     }\n-  \n+\n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n     {\n       tree val = NULL_TREE;\n       tree op;\n-      \n-      if (i != 0)\n-\ttop_level = false;\n-      \n+\n       op = TREE_OPERAND (expr, i);\n       if (op == NULL_TREE)\n \tcontinue;\n \n       /* Recursively value-numberize reference ops and tree lists.  */\n       if (REFERENCE_CLASS_P (op))\n \t{\n-\t  tree tempop = create_value_expr_from (op, block, stmt, false);\n+\t  tree tempop = create_value_expr_from (op, block, stmt);\n \t  op = tempop ? tempop : op;\n \t  val = vn_lookup_or_add_with_stmt (op, stmt);\n \t}\n@@ -3077,15 +3059,13 @@ poolify_tree (tree node)\n \treturn temp;\n       }\n       break;\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-    case VAR_DECL:\n-    case CONST_DECL:\n-    case FUNCTION_DECL:\n     case SSA_NAME:\n     case INTEGER_CST:\n     case STRING_CST:\n     case REAL_CST:\n+    case PARM_DECL:\n+    case VAR_DECL:\n+    case RESULT_DECL:\n       return node;\n     default:\n       gcc_unreachable ();\n@@ -3300,8 +3280,7 @@ make_values_for_phi (tree phi, basic_block block)\n       if (sccvnval)\n \t{\n \t  vn_add (result, sccvnval);\n-\t  if (!in_fre)\n-\t    bitmap_insert_into_set (PHI_GEN (block), result);\n+\t  bitmap_insert_into_set (PHI_GEN (block), result);\n \t  bitmap_value_insert_into_set (AVAIL_OUT (block), result);\n \t}\n       else\n@@ -3369,7 +3348,7 @@ make_values_for_stmt (tree stmt, basic_block block)\n       /* For value numberable operation, create a\n \t duplicate expression with the operands replaced\n \t with the value handles of the original RHS.  */\n-      tree newt = create_value_expr_from (rhs, block, stmt, true);\n+      tree newt = create_value_expr_from (rhs, block, stmt);\n       if (newt)\n \t{\n \t  /* If we already have a value number for the LHS, reuse\n@@ -3397,7 +3376,8 @@ make_values_for_stmt (tree stmt, basic_block block)\n \t    && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs))\n \t   || is_gimple_min_invariant (rhs)\n \t   || TREE_CODE (rhs) == ADDR_EXPR\n-\t   || TREE_INVARIANT (rhs))\n+\t   || TREE_INVARIANT (rhs)\n+\t   || DECL_P (rhs))\n     {\n       \n       if (lhsval)\n@@ -3805,8 +3785,7 @@ static void\n init_pre (bool do_fre)\n {\n   basic_block bb;\n-  unsigned int max_decl_size;\n-\n+  \n   next_expression_id = 0;\n   expressions = NULL;\n   in_fre = do_fre;\n@@ -3817,63 +3796,52 @@ init_pre (bool do_fre)\n   storetemp = NULL_TREE;\n   prephitemp = NULL_TREE;\n \n-  memset (&pre_stats, 0, sizeof (pre_stats));\n-  bitmap_obstack_initialize (&grand_bitmap_obstack);\n-  \n   if (!do_fre)\n-    {\n-      loop_optimizer_init (LOOPS_NORMAL);\n-      connect_infinite_loops_to_exit ();\n-      postorder = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n-      post_order_compute (postorder, false, false);\n-      calculate_dominance_info (CDI_POST_DOMINATORS);\n-      phi_translate_table = htab_create (5110, expr_pred_trans_hash,\n-\t\t\t\t\t expr_pred_trans_eq, free);\n-      seen_during_translate = BITMAP_ALLOC (&grand_bitmap_obstack);\n-      binary_node_pool = create_alloc_pool (\"Binary tree nodes\",\n-\t\t\t\t\t    tree_code_size (PLUS_EXPR), 30);\n-      unary_node_pool = create_alloc_pool (\"Unary tree nodes\",\n-\t\t\t\t\t   tree_code_size (NEGATE_EXPR), 30);\n-      reference_node_pool = create_alloc_pool (\"Reference tree nodes\",\n-\t\t\t\t\t       tree_code_size (ARRAY_REF), 30);\n-      comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n-\t\t\t\t\t\ttree_code_size (EQ_EXPR), 30);\n-      modify_expr_node_pool = create_alloc_pool (\"GIMPLE_MODIFY_STMT nodes\",\n-\t\t\t\t\t\t tree_code_size (GIMPLE_MODIFY_STMT),\n-\t\t\t\t\t\t 30);  \n-      max_decl_size = MAX (tree_code_size (VAR_DECL), tree_code_size (PARM_DECL));\n-      max_decl_size = MAX (max_decl_size, tree_code_size (RESULT_DECL));\n-      max_decl_size = MAX (max_decl_size, tree_code_size (CONST_DECL));\n-      max_decl_size = MAX (max_decl_size, tree_code_size (FUNCTION_DECL));\n-      decl_node_pool = create_alloc_pool (\"_DECL nodes\", max_decl_size, 30);\n-      \n-      obstack_init (&temp_call_expr_obstack);\n-      modify_expr_template = NULL;\n-    }\n- \n+    loop_optimizer_init (LOOPS_NORMAL);\n+\n+  connect_infinite_loops_to_exit ();\n+  memset (&pre_stats, 0, sizeof (pre_stats));\n+\n+\n+  postorder = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n+  post_order_compute (postorder, false, false);\n+\n   FOR_ALL_BB (bb)\n     bb->aux = xcalloc (1, sizeof (struct bb_bitmap_sets));\n \n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n   calculate_dominance_info (CDI_DOMINATORS);\n \n+  bitmap_obstack_initialize (&grand_bitmap_obstack);\n+  phi_translate_table = htab_create (5110, expr_pred_trans_hash,\n+\t\t\t\t     expr_pred_trans_eq, free);\n+  seen_during_translate = BITMAP_ALLOC (&grand_bitmap_obstack);\n   bitmap_set_pool = create_alloc_pool (\"Bitmap sets\",\n \t\t\t\t       sizeof (struct bitmap_set), 30);\n+  binary_node_pool = create_alloc_pool (\"Binary tree nodes\",\n+\t\t\t\t\ttree_code_size (PLUS_EXPR), 30);\n+  unary_node_pool = create_alloc_pool (\"Unary tree nodes\",\n+\t\t\t\t       tree_code_size (NEGATE_EXPR), 30);\n+  reference_node_pool = create_alloc_pool (\"Reference tree nodes\",\n+\t\t\t\t\t   tree_code_size (ARRAY_REF), 30);\n+  comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n+\t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n+  modify_expr_node_pool = create_alloc_pool (\"GIMPLE_MODIFY_STMT nodes\",\n+\t\t\t\t\t     tree_code_size (GIMPLE_MODIFY_STMT),\n+\t\t\t\t\t     30);\n+  obstack_init (&temp_call_expr_obstack);\n+  modify_expr_template = NULL;\n \n   FOR_ALL_BB (bb)\n     {\n-      if (!do_fre)\n-\t{\n-\t  EXP_GEN (bb) = bitmap_set_new ();\n-\t  PHI_GEN (bb) = bitmap_set_new ();\n-\t  TMP_GEN (bb) = bitmap_set_new ();\n-\t}\n+      EXP_GEN (bb) = bitmap_set_new ();\n+      PHI_GEN (bb) = bitmap_set_new ();\n+      TMP_GEN (bb) = bitmap_set_new ();\n       AVAIL_OUT (bb) = bitmap_set_new ();\n     }\n-  maximal_set = do_fre ? NULL : bitmap_set_new ();\n+  maximal_set = in_fre ? NULL : bitmap_set_new ();\n \n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n-  decl_vh_map = pointer_map_create ();\n-  expression_id_map = pointer_map_create ();\n }\n \n \n@@ -3884,41 +3852,36 @@ fini_pre (void)\n {\n   basic_block bb;\n   unsigned int i;\n-  \n-  if (!in_fre)\n-    {\n-      free (postorder);\n-      VEC_free (tree, heap, inserted_exprs);\n-      VEC_free (tree, heap, need_creation);\n-      free_alloc_pool (binary_node_pool);\n-      free_alloc_pool (reference_node_pool);\n-      free_alloc_pool (unary_node_pool);\n-      free_alloc_pool (comparison_node_pool);\n-      free_alloc_pool (modify_expr_node_pool);\n-      free_alloc_pool (decl_node_pool);\n-      htab_delete (phi_translate_table);\n-      remove_fake_exit_edges ();\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-    }\n+\n+  free (postorder);\n+  VEC_free (tree, heap, inserted_exprs);\n+  VEC_free (tree, heap, need_creation);\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (bitmap_set_pool);\n+  free_alloc_pool (binary_node_pool);\n+  free_alloc_pool (reference_node_pool);\n+  free_alloc_pool (unary_node_pool);\n+  free_alloc_pool (comparison_node_pool);\n+  free_alloc_pool (modify_expr_node_pool);\n+  htab_delete (phi_translate_table);\n+  remove_fake_exit_edges ();\n \n   FOR_ALL_BB (bb)\n     {\n       free (bb->aux);\n       bb->aux = NULL;\n     }\n \n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n   if (!bitmap_empty_p (need_eh_cleanup))\n     {\n       tree_purge_all_dead_eh_edges (need_eh_cleanup);\n       cleanup_tree_cfg ();\n     }\n \n   BITMAP_FREE (need_eh_cleanup);\n-  pointer_map_destroy (decl_vh_map);\n-  pointer_map_destroy (expression_id_map);\n-  \n+\n   /* Wipe out pointers to VALUE_HANDLEs.  In the not terribly distant\n      future we will want them to be persistent though.  */\n   for (i = 0; i < num_ssa_names; i++)\n@@ -3932,7 +3895,7 @@ fini_pre (void)\n \t  && TREE_CODE (SSA_NAME_VALUE (name)) == VALUE_HANDLE)\n \tSSA_NAME_VALUE (name) = NULL;\n     }\n-  if (current_loops != NULL && !in_fre)\n+  if (current_loops != NULL)\n     loop_optimizer_finalize ();\n }\n \n@@ -3993,6 +3956,7 @@ execute_pre (bool do_fre)\n   bsi_commit_edge_inserts ();\n \n   free_scc_vn ();\n+  clear_expression_ids ();\n   if (!do_fre)\n     {\n       remove_dead_inserted_code ();"}, {"sha": "d62aeea9398664022dc44ef0f6e50e86f6bca55a", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71b4522b534a93471f68f5ca1efd111315f5c5e/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=b71b4522b534a93471f68f5ca1efd111315f5c5e", "patch": "@@ -83,10 +83,6 @@ expressions_equal_p (tree e1, tree e2)\n       return true;\n \n     }\n-  else if (TREE_CODE (e1) == TREE_CODE (e2)\n-\t   && DECL_P (e1)\n-\t   && te1 == te2)\n-    return DECL_UID (e1) == DECL_UID (e2);\n   else if (TREE_CODE (e1) == TREE_CODE (e2) \n \t   && (te1 == te2\n \t       || types_compatible_p (te1, te2))\n@@ -103,12 +99,7 @@ set_value_handle (tree e, tree v)\n {\n   if (TREE_CODE (e) == SSA_NAME)\n     SSA_NAME_VALUE (e) = v;\n-  else if (DECL_P (e))\n-    {\n-      tree *slot = (tree *)pointer_map_insert (decl_vh_map, e);\n-      *slot = v;\n-    }\n-  else if (EXPR_P (e) || TREE_CODE (e) == TREE_LIST\n+  else if (EXPR_P (e) || DECL_P (e) || TREE_CODE (e) == TREE_LIST\n \t   || GIMPLE_STMT_P (e)\n \t   || TREE_CODE (e) == CONSTRUCTOR)\n     get_tree_common_ann (e)->value_handle = v;"}]}