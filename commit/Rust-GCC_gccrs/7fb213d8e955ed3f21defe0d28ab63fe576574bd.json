{"sha": "7fb213d8e955ed3f21defe0d28ab63fe576574bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZiMjEzZDhlOTU1ZWQzZjIxZGVmZTBkMjhhYjYzZmU1NzY1NzRiZA==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-07-12T10:07:30Z"}, "committer": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-07-12T10:07:30Z"}, "message": "re PR c++/2204 (G++ doesn't check (member) function parameter for abstract-ness.)\n\n\tPR c++/2204\n\t* config-lang.in (gtfiles): Add typeck2.c.\n\t* Make-lang.in: Tweak typeck2.c dependencies, and add rule for\n\tgt-cp-typeck2.h.\n\t* cp-tree.h: Declare complete_type_check_abstract.\n\t* typeck2.c (pat_calc_hash, pat_compare,\n\tcomplete_type_check_abstract): New functions.\n\t(abstract_virtuals_error): If the type is abstract, register the\n\tdeclaration within abstract_pending_vars for further checks.\n\tInspect also dependent types. Handle IDENTIFIER_NODEs as decl.\n\t* decl.c (cp_finish_decl): Do not strip array types.\n\t(create_array_type_for_decl): Check for abstractness of the element\n\ttype.\n\t(complete_vars): Call complete_type_check_abstract.\n\t* class.c (finish_struct): Prepare a list of virtual functions for\n\ttemplate types, and call complete_vars on it to check for abstractness.\n\n\tPR c++/2204\n\t* g++.dg/other/abstract2.C: New test.\n\nFrom-SVN: r84552", "tree": {"sha": "ddb750a9ae79ad0985920a74ed9e30cdf7fa664a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddb750a9ae79ad0985920a74ed9e30cdf7fa664a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fb213d8e955ed3f21defe0d28ab63fe576574bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb213d8e955ed3f21defe0d28ab63fe576574bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fb213d8e955ed3f21defe0d28ab63fe576574bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb213d8e955ed3f21defe0d28ab63fe576574bd/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b55e3aad633bd6e8de2b41b1a6ce41e5241878ac"}], "stats": {"total": 295, "additions": 273, "deletions": 22}, "files": [{"sha": "4b80aa6d5aa48a9269e3b175320497af1211585a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -1,3 +1,22 @@\n+2004-07-12  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/2204\n+\t* config-lang.in (gtfiles): Add typeck2.c.\n+\t* Make-lang.in: Tweak typeck2.c dependencies, and add rule for\n+\tgt-cp-typeck2.h.\n+\t* cp-tree.h: Declare complete_type_check_abstract.\n+\t* typeck2.c (pat_calc_hash, pat_compare,\n+\tcomplete_type_check_abstract): New functions.\n+\t(abstract_virtuals_error): If the type is abstract, register the\n+\tdeclaration within abstract_pending_vars for further checks.\n+\tInspect also dependent types. Handle IDENTIFIER_NODEs as decl.\n+\t* decl.c (cp_finish_decl): Do not strip array types.\n+\t(create_array_type_for_decl): Check for abstractness of the element\n+\ttype.\n+\t(complete_vars): Call complete_type_check_abstract.\n+\t* class.c (finish_struct): Prepare a list of virtual functions for\n+\ttemplate types, and call complete_vars on it to check for abstractness.\n+\n 2004-07-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR tree-optimization/14107"}, {"sha": "1ce05dac03c95f5a60e3a70e235a05ef811e09d7", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -99,7 +99,7 @@ $(srcdir)/cp/cfns.h: $(srcdir)/cp/cfns.gperf\n \n gtype-cp.h gt-cp-call.h gt-cp-decl.h gt-cp-decl2.h : s-gtype; @true\n gt-cp-pt.h gt-cp-repo.h gt-cp-parser.h gt-cp-method.h : s-gtype; @true\n-gt-cp-tree.h gt-cp-mangle.h gt-cp-name-lookup.h: s-gtype; @true\n+gt-cp-tree.h gt-cp-mangle.h gt-cp-name-lookup.h gt-cp-typeck2.h: s-gtype; @true\n \n #\f\n # Build hooks:\n@@ -231,7 +231,7 @@ cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h stack.h \\\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h cgraph.h\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h $(TM_P_H) \\\n-   diagnostic.h\n+   diagnostic.h gt-cp-typeck2.h\n cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n    diagnostic.h convert.h\n cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) $(TARGET_H) convert.h"}, {"sha": "080e5e9bfa9c19cd7f722f27e388bd25ae52cb95", "filename": "gcc/cp/class.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -5270,8 +5270,24 @@ finish_struct (tree t, tree attributes)\n \n   if (processing_template_decl)\n     {\n+      tree x;\n+\n       finish_struct_methods (t);\n       TYPE_SIZE (t) = bitsize_zero_node;\n+\n+      /* We need to emit an error message if this type was used as a parameter\n+\t and it is an abstract type, even if it is a template. We construct\n+\t a simple CLASSTYPE_PURE_VIRTUALS list without taking bases into\n+\t account and we call complete_vars with this type, which will check\n+\t the PARM_DECLS. Note that while the type is being defined,\n+\t CLASSTYPE_PURE_VIRTUALS contains the list of the inline friends\n+\t (see CLASSTYPE_INLINE_FRIENDS) so we need to clear it.  */\n+      CLASSTYPE_PURE_VIRTUALS (t) = NULL_TREE;\n+      for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n+\tif (DECL_PURE_VIRTUAL_P (x))\n+\t  CLASSTYPE_PURE_VIRTUALS (t)\n+\t    = tree_cons (NULL_TREE, x, CLASSTYPE_PURE_VIRTUALS (t));\n+      complete_vars (t);\n     }\n   else\n     finish_struct_1 (t);"}, {"sha": "563cfb4d1c02e231aa64b30b0c29deca53827336", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -34,4 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3 target-gperf\"\n \n-gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c\"\n+gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c\""}, {"sha": "500ad112f45dab5badbf3af44cde6cb04a4ed51c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -4315,6 +4315,7 @@ extern void cxx_incomplete_type_error\t\t(tree, tree);\n extern tree error_not_base_type\t\t\t(tree, tree);\n extern tree binfo_or_else\t\t\t(tree, tree);\n extern void readonly_error\t\t\t(tree, const char *, int);\n+extern void complete_type_check_abstract\t(tree);\n extern int abstract_virtuals_error\t\t(tree, tree);\n \n extern tree store_init_value\t\t\t(tree, tree);"}, {"sha": "cc905eb251120321212493bb0f3c1b7f0a809c35", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -4821,21 +4821,12 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \n       make_rtl_for_nonlocal_decl (decl, init, asmspec);\n \n+      /* Check for abstractness of the type. Notice that there is no\n+\t need to strip array types here since the check for those types\n+\t is already done within create_array_type_for_decl.  */\n       if (TREE_CODE (type) == FUNCTION_TYPE\n \t  || TREE_CODE (type) == METHOD_TYPE)\n-\tabstract_virtuals_error (decl,\n-\t\t\t\t strip_array_types (TREE_TYPE (type)));\n-      else if (POINTER_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n-      {\n-\t/* If it's either a pointer or an array type, strip through all\n-\t   of them but the last one. If the last is an array type, issue \n-\t   an error if the element type is abstract.  */\n-\twhile (POINTER_TYPE_P (TREE_TYPE (type)) \n-\t       || TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n-\t  type = TREE_TYPE (type);\n-\tif (TREE_CODE (type) == ARRAY_TYPE)\n-\t  abstract_virtuals_error (decl, TREE_TYPE (type));\n-      }\n+\tabstract_virtuals_error (decl, TREE_TYPE (type));\n       else\n \tabstract_virtuals_error (decl, type);\n \n@@ -6162,6 +6153,11 @@ create_array_type_for_decl (tree name, tree type, tree size)\n   if (size)\n     itype = compute_array_index_type (name, size);\n \n+  /* [dcl.array]\n+     T is called the array element type; this type shall not be [...] an\n+     abstract class type.  */\n+  abstract_virtuals_error (name, type);\n+\n   return build_cplus_array_type (type, itype);\n }\n \n@@ -10592,6 +10588,9 @@ complete_vars (tree type)\n       else\n \tlist = &TREE_CHAIN (*list);\n     }\n+\n+  /* Check for pending declarations which may have abstract type.  */\n+  complete_type_check_abstract (type);\n }\n \n /* If DECL is of a type which needs a cleanup, build that cleanup"}, {"sha": "6e32377c4a35f70c0eae3ed42f8359bb761fed6c", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 159, "deletions": 6, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -114,6 +114,119 @@ readonly_error (tree arg, const char* string, int soft)\n     (*fn) (\"%s of read-only location\", string);\n }\n \n+\f\n+/* Structure that holds information about declarations whose type was\n+   incomplete and we could not check whether it was abstract or not.  */\n+\n+struct pending_abstract_type GTY((chain_next (\"%h.next\")))\n+{\n+  /* Declaration which we are checking for abstractness. It is either\n+     a DECL node, or an IDENTIFIER_NODE if we do not have a full\n+     declaration available.  */\n+  tree decl;\n+\n+  /* Type which will be checked for abstractness.  */\n+  tree type;\n+\n+  /* Position of the declaration. This is only needed for IDENTIFIER_NODEs,\n+     because DECLs already carry locus information.  */\n+  location_t locus;\n+\n+  /* Link to the next element in list.  */\n+  struct pending_abstract_type* next;\n+};\n+\n+\n+/* Compute the hash value of the node VAL. This function is used by the\n+   hash table abstract_pending_vars.  */\n+\n+static hashval_t\n+pat_calc_hash (const void* val)\n+{\n+  const struct pending_abstract_type* pat = val;\n+  return (hashval_t) TYPE_UID (pat->type);\n+}\n+\n+\n+/* Compare node VAL1 with the type VAL2. This function is used by the\n+   hash table abstract_pending_vars.  */\n+\n+static int\n+pat_compare (const void* val1, const void* val2)\n+{\n+  const struct pending_abstract_type* pat1 = val1;\n+  tree type2 = (tree)val2;\n+\n+  return (pat1->type == type2);\n+}\n+\n+/* Hash table that maintains pending_abstract_type nodes, for which we still\n+   need to check for type abstractness.  The key of the table is the type\n+   of the declaration.  */\n+static GTY ((param_is (struct pending_abstract_type)))\n+htab_t abstract_pending_vars = NULL;\n+\n+\n+/* This function is called after TYPE is completed, and will check if there\n+   are pending declarations for which we still need to verify the abstractness\n+   of TYPE, and emit a diagnostic (through abstract_virtuals_error) if TYPE\n+   turned out to be incomplete.  */\n+\n+void\n+complete_type_check_abstract (tree type)\n+{\n+  void **slot;\n+  struct pending_abstract_type *pat;\n+  location_t cur_loc = input_location;\n+\n+  my_friendly_assert (COMPLETE_TYPE_P (type), 20040620_3);\n+\n+  if (!abstract_pending_vars)\n+    return;\n+\n+  /* Retrieve the list of pending declarations for this type.  */\n+  slot = htab_find_slot_with_hash (abstract_pending_vars, type,\n+\t\t\t\t   (hashval_t)TYPE_UID (type), NO_INSERT);\n+  if (!slot)\n+    return;\n+  pat = (struct pending_abstract_type*)*slot;\n+  my_friendly_assert (pat, 20040620_2);\n+\n+  /* If the type is not abstract, do not do anything.  */\n+  if (CLASSTYPE_PURE_VIRTUALS (type))\n+    {\n+      struct pending_abstract_type *prev = 0, *next;\n+\n+      /* Reverse the list to emit the errors in top-down order.  */\n+      for (; pat; pat = next)\n+\t{\n+\t  next = pat->next;\n+\t  pat->next = prev;\n+\t  prev = pat;\n+\t}\n+      pat = prev;\n+\n+      /* Go through the list, and call abstract_virtuals_error for each\n+\telement: it will issue a diagostic if the type is abstract.  */\n+      while (pat)\n+\t{\n+\t  my_friendly_assert (type == pat->type, 20040620_4);\n+\n+\t  /* Tweak input_location so that the diagnostic appears at the correct\n+\t    location. Notice that this is only needed if the decl is an\n+\t    IDENTIFIER_NODE, otherwise cp_error_at. */\n+\t  input_location = pat->locus;\n+\t  abstract_virtuals_error (pat->decl, pat->type);\n+\t  pat = pat->next;\n+\t}\n+    }\n+\n+  htab_clear_slot (abstract_pending_vars, slot);\n+\n+  input_location = cur_loc;\n+}\n+\n+\n /* If TYPE has abstract virtual functions, issue an error about trying\n    to create an object of that type.  DECL is the object declared, or\n    NULL_TREE if the declaration is unavailable.  Returns 1 if an error\n@@ -125,19 +238,52 @@ abstract_virtuals_error (tree decl, tree type)\n   tree u;\n   tree tu;\n \n-  if (!CLASS_TYPE_P (type) || !CLASSTYPE_PURE_VIRTUALS (type))\n+  /* This function applies only to classes. Any other entity can never\n+     be abstract.  */\n+  if (!CLASS_TYPE_P (type))\n+    return 0;\n+\n+  /* If the type is incomplete, we register it within a hash table,\n+     so that we can check again once it is completed. This makes sense\n+     only for objects for which we have a declaration or at least a\n+     name.  */\n+  if (!COMPLETE_TYPE_P (type))\n+    {\n+      void **slot;\n+      struct pending_abstract_type *pat;\n+\n+      my_friendly_assert (!decl || (DECL_P (decl) \n+\t\t\t\t    || TREE_CODE (decl) == IDENTIFIER_NODE),\n+\t\t\t  20040620_1);\n+\n+      if (!abstract_pending_vars)\n+\tabstract_pending_vars = htab_create_ggc (31, &pat_calc_hash, \n+\t\t\t\t\t\t&pat_compare, NULL);\n+\n+      slot = htab_find_slot_with_hash (abstract_pending_vars, type,\n+\t\t\t\t      (hashval_t)TYPE_UID (type), INSERT);\n+\n+      pat = ggc_alloc (sizeof (struct pending_abstract_type));\n+      pat->type = type;\n+      pat->decl = decl;\n+      pat->locus = ((decl && DECL_P (decl))\n+\t\t    ? DECL_SOURCE_LOCATION (decl)\n+\t\t    : input_location);\n+\n+      pat->next = *slot;\n+      *slot = pat;\n+\n+      return 0;\n+    }\n+\n+  if (!CLASSTYPE_PURE_VIRTUALS (type))\n     return 0;\n \n   if (!TYPE_SIZE (type))\n     /* TYPE is being defined, and during that time\n        CLASSTYPE_PURE_VIRTUALS holds the inline friends.  */\n     return 0;\n \n-  if (dependent_type_p (type))\n-    /* For a dependent type, we do not yet know which functions are pure\n-       virtuals.  */\n-    return 0;\n-\n   u = CLASSTYPE_PURE_VIRTUALS (type);\n   if (decl)\n     {\n@@ -160,6 +306,10 @@ abstract_virtuals_error (tree decl, tree type)\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n \tcp_error_at (\"invalid abstract return type for function `%+#D'\", \n \t\t     decl);\n+      else if (TREE_CODE (decl) == IDENTIFIER_NODE)\n+\t/* Here we do not have location information, so use error instead\n+\t   of cp_error_at.  */\n+\terror (\"invalid abstract type `%T' for `%E'\", type, decl);\n       else\n \tcp_error_at (\"invalid abstract type for `%+D'\", decl);\n     }\n@@ -1405,3 +1555,6 @@ require_complete_eh_spec_types (tree fntype, tree decl)\n \t}\n     }\n }\n+\n+\f\n+#include \"gt-cp-typeck2.h\""}, {"sha": "e9d788d1739e32b397dc3f3fe40335467faee066", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -1,3 +1,8 @@\n+2004-07-12  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/2204\n+\t* g++.dg/other/abstract2.C: New test.\n+\n 2004-07-12  Paul Brook  <paul@codesourcery.com>\n \n \t* gfortran.dg/pointer_init_1.f90: New test."}, {"sha": "d242ffdc0b39599d54f9c5496cc5855a79624621", "filename": "gcc/testsuite/g++.dg/other/abstract2.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb213d8e955ed3f21defe0d28ab63fe576574bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract2.C?ref=7fb213d8e955ed3f21defe0d28ab63fe576574bd", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do compile }\n+// Contributed by Gabriel Dos Reis <gdr at integrable-solutions dot net>\n+// PR c++/2204: Check for parameters of abstract type in function declarations.\n+\n+namespace N1 {\n+  struct X;\n+\n+  struct Y1 {\n+    void g(X parm1);         // { dg-error \"abstract\" }\n+    void g(X parm2[2]);      // { dg-error \"abstract\" }\n+    void g(X (*parm3)[2]);   // { dg-error \"abstract\" }\n+  };\n+\n+\n+  template <int N>\n+  struct Y2 {\n+    void g(X parm4);         // { dg-error \"abstract\" }\n+    void g(X parm5[2]);      // { dg-error \"abstract\" }\n+    void g(X (*parm6)[2]);   // { dg-error \"abstract\" }\n+  };\n+\n+  struct X {  // { dg-error \"note\" }\n+    virtual void xfunc(void) = 0;  // { dg-error \"note\" }\n+  };\n+}\n+\n+namespace N2 {\n+  struct X1 { // { dg-error \"note\" }\n+    virtual void xfunc(void) = 0;  // { dg-error \"note\" }\n+    void g(X1 parm7);        // { dg-error \"abstract\" }\n+    void g(X1 parm8[2]);     // { dg-error \"abstract\" }\n+    void g(X1 (*parm9)[2]);  // { dg-error \"abstract\" }\n+  };\n+\n+  template <int N>\n+  struct X2 { // { dg-error \"note\" }\n+    virtual void xfunc(void) = 0; // { dg-error \"note\" }\n+    void g(X2 parm10);        // { dg-error \"abstract\" }\n+    void g(X2 parm11[2]);     // { dg-error \"abstract\" }\n+    void g(X2 (*parm12)[2]);  // { dg-error \"abstract\" }\n+  };\n+}\n+\n+namespace N3 {\n+  struct X { // { dg-error \"note\" \"\" }\n+    virtual void xfunc(void) = 0;  // { dg-error \"note\" }\n+  };\n+  void g(X parm13);          // { dg-error \"abstract\" }\n+  void g(X parm14[2]);       // { dg-error \"abstract\" }\n+  void g(X (*parm15)[2]);    // { dg-error \"abstract\" }\n+\n+  template <int N> \n+  void g(X parm16);          // { dg-error \"abstract\" }\n+  template <int N> \n+  void g(X parm17[2]);       // { dg-error \"abstract\" }\n+  template <int N> \n+  void g(X (*parm18)[2]);    // { dg-error \"abstract\" }\n+}"}]}