{"sha": "d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVlZWEwZjdjYzQ5ZDNiOTZiOTAwMzdlMzBkNDM3ZjRjZWI2YTI3MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-01-08T21:49:37Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-01-08T21:49:37Z"}, "message": "quad-float128.h (IBM128_TYPE): Explicitly use __ibm128, instead of trying to use long double.\n\n2018-01-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/quad-float128.h (IBM128_TYPE): Explicitly use\n\t__ibm128, instead of trying to use long double.\n\t(CVT_FLOAT128_TO_IBM128): Use TFtype instead of __float128 to\n\taccomidate -mabi=ieeelongdouble multilibs.\n\t(CVT_IBM128_TO_FLOAT128): Likewise.\n\t* config/rs6000/ibm-ldouble.c (IBM128_TYPE): New macro to define\n\tthe appropriate IBM extended double type.\n\t(__gcc_qadd): Change all occurances of long double to IBM128_TYPE.\n\t(__gcc_qsub): Likewise.\n\t(__gcc_qmul): Likewise.\n\t(__gcc_qdiv): Likewise.\n\t(pack_ldouble): Likewise.\n\t(__gcc_qneg): Likewise.\n\t(__gcc_qeq): Likewise.\n\t(__gcc_qne): Likewise.\n\t(__gcc_qge): Likewise.\n\t(__gcc_qle): Likewise.\n\t(__gcc_stoq): Likewise.\n\t(__gcc_dtoq): Likewise.\n\t(__gcc_itoq): Likewise.\n\t(__gcc_utoq): Likewise.\n\t(__gcc_qunord): Likewise.\n\t* config/rs6000/_mulkc3.c (toplevel): Include soft-fp.h and\n\tquad-float128.h for the definitions.\n\t(COPYSIGN): Use the f128 version instead of the q version.\n\t(INFINITY): Likewise.\n\t(__mulkc3): Use TFmode/TCmode for float128 scalar/complex types.\n\t* config/rs6000/_divkc3.c (toplevel): Include soft-fp.h and\n\tquad-float128.h for the definitions.\n\t(COPYSIGN): Use the f128 version instead of the q version.\n\t(INFINITY): Likewise.\n\t(FABS): Likewise.\n\t(__divkc3): Use TFmode/TCmode for float128 scalar/complex types.\n\t* config/rs6000/extendkftf2-sw.c (__extendkftf2_sw): Likewise.\n\t* config/rs6000/trunctfkf2-sw.c (__trunctfkf2_sw): Likewise.\n\nFrom-SVN: r256353", "tree": {"sha": "cd464f1fd35654a32ac317ae1ceb00db98009c77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd464f1fd35654a32ac317ae1ceb00db98009c77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/comments", "author": null, "committer": null, "parents": [{"sha": "a4f759de239b9b524c283e5889d3c2d640b8d4b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f759de239b9b524c283e5889d3c2d640b8d4b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f759de239b9b524c283e5889d3c2d640b8d4b7"}], "stats": {"total": 148, "additions": 74, "deletions": 74}, "files": [{"sha": "13bd5bdc7a33da2639a7cfb3e83050d7d6448b4c", "filename": "libgcc/config/rs6000/_divkc3.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2F_divkc3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2F_divkc3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2F_divkc3.c?ref=d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "patch": "@@ -23,12 +23,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* This is a temporary specialization of code from libgcc/libgcc2.c.  */\n \n-typedef float KFtype __attribute__ ((mode (KF)));\n-typedef __complex float KCtype __attribute__ ((mode (KC)));\n+#include \"soft-fp.h\"\n+#include \"quad-float128.h\"\n \n-#define COPYSIGN(x,y) __builtin_copysignq (x, y)\n-#define INFINITY __builtin_infq ()\n-#define FABS __builtin_fabsq\n+#define COPYSIGN(x,y) __builtin_copysignf128 (x, y)\n+#define INFINITY __builtin_inff128 ()\n+#define FABS __builtin_fabsf128\n #define isnan __builtin_isnan\n #define isinf __builtin_isinf\n #define isfinite __builtin_isfinite\n@@ -37,13 +37,11 @@ typedef __complex float KCtype __attribute__ ((mode (KC)));\n #define __divkc3 __divkc3_sw\n #endif\n \n-extern KCtype __divkc3 (KFtype, KFtype, KFtype, KFtype);\n-\n-KCtype\n-__divkc3 (KFtype a, KFtype b, KFtype c, KFtype d)\n+TCtype\n+__divkc3 (TFtype a, TFtype b, TFtype c, TFtype d)\n {\n-  KFtype denom, ratio, x, y;\n-  KCtype res;\n+  TFtype denom, ratio, x, y;\n+  TCtype res;\n \n   /* ??? We can get better behavior from logarithmic scaling instead of\n      the division.  But that would mean starting to link libgcc against"}, {"sha": "da03e657d1f49d3a17c79586957bf8f18ba5d415", "filename": "libgcc/config/rs6000/_mulkc3.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2F_mulkc3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2F_mulkc3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2F_mulkc3.c?ref=d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "patch": "@@ -23,25 +23,23 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* This is a temporary specialization of code from libgcc/libgcc2.c.  */\n \n-typedef float KFtype __attribute__ ((mode (KF)));\n-typedef __complex float KCtype __attribute__ ((mode (KC)));\n+#include \"soft-fp.h\"\n+#include \"quad-float128.h\"\n \n-#define COPYSIGN(x,y) __builtin_copysignq (x, y)\n-#define INFINITY __builtin_infq ()\n+#define COPYSIGN(x,y) __builtin_copysignf128 (x, y)\n+#define INFINITY __builtin_inff128 ()\n #define isnan __builtin_isnan\n #define isinf __builtin_isinf\n \n #if defined(FLOAT128_HW_INSNS) && !defined(__mulkc3)\n #define __mulkc3 __mulkc3_sw\n #endif\n \n-extern KCtype __mulkc3 (KFtype, KFtype, KFtype, KFtype);\n-\n-KCtype\n-__mulkc3 (KFtype a, KFtype b, KFtype c, KFtype d)\n+TCtype\n+__mulkc3 (TFtype a, TFtype b, TFtype c, TFtype d)\n {\n-  KFtype ac, bd, ad, bc, x, y;\n-  KCtype res;\n+  TFtype ac, bd, ad, bc, x, y;\n+  TCtype res;\n \n   ac = a * c;\n   bd = b * d;"}, {"sha": "afaf419734aa4924e5a566ddf500a317361cdb11", "filename": "libgcc/config/rs6000/extendkftf2-sw.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c?ref=d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "patch": "@@ -44,7 +44,7 @@\n #endif\n \n IBM128_TYPE\n-__extendkftf2_sw (__float128 value)\n+__extendkftf2_sw (TFtype value)\n {\n   IBM128_TYPE ret;\n "}, {"sha": "9b9e94c0e8fbc69ed0c7f220fb1587c7b57544e7", "filename": "libgcc/config/rs6000/ibm-ldouble.c", "status": "modified", "additions": 48, "deletions": 39, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2Fibm-ldouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2Fibm-ldouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fibm-ldouble.c?ref=d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "patch": "@@ -56,6 +56,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #define nonfinite(a) unlikely (! isless (fabs (a), inf ()))\n \n+/* If we have __float128/_Float128, use __ibm128 instead of long double.  On\n+   other systems, use long double, because __ibm128 might not have been\n+   created.  */\n+#ifdef __FLOAT128__\n+#define IBM128_TYPE __ibm128\n+#else\n+#define IBM128_TYPE long double\n+#endif\n+\n /* Define ALIASNAME as a strong alias for NAME.  */\n # define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n # define _strong_alias(name, aliasname) \\\n@@ -65,10 +74,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    but GCC currently generates poor code when a union is used to turn\n    a long double into a pair of doubles.  */\n \n-long double __gcc_qadd (double, double, double, double);\n-long double __gcc_qsub (double, double, double, double);\n-long double __gcc_qmul (double, double, double, double);\n-long double __gcc_qdiv (double, double, double, double);\n+IBM128_TYPE __gcc_qadd (double, double, double, double);\n+IBM128_TYPE __gcc_qsub (double, double, double, double);\n+IBM128_TYPE __gcc_qmul (double, double, double, double);\n+IBM128_TYPE __gcc_qdiv (double, double, double, double);\n \n #if defined __ELF__ && defined SHARED \\\n     && (defined __powerpc64__ || !(defined __linux__ || defined __gnu_hurd__))\n@@ -88,17 +97,17 @@ __asm__ (\".symver __gcc_qadd,_xlqadd@GCC_3.4\\n\\t\"\n \t \".symver .__gcc_qdiv,._xlqdiv@GCC_3.4\");\n #endif\n \n-/* Combine two 'double' values into one 'long double' and return the result.  */\n-static inline long double\n+/* Combine two 'double' values into one 'IBM128_TYPE' and return the result.  */\n+static inline IBM128_TYPE\n pack_ldouble (double dh, double dl)\n {\n-#if defined (__LONG_DOUBLE_128__) \\\n+#if defined (__LONG_DOUBLE_128__) && defined (__LONG_DOUBLE_IBM128__)\t\\\n     && !(defined (_SOFT_FLOAT) || defined (__NO_FPRS__))\n   return __builtin_pack_longdouble (dh, dl);\n #else\n   union\n   {\n-    long double ldval;\n+    IBM128_TYPE ldval;\n     double dval[2];\n   } x;\n   x.dval[0] = dh;\n@@ -107,8 +116,8 @@ pack_ldouble (double dh, double dl)\n #endif\n }\n \n-/* Add two 'long double' values and return the result.\t*/\n-long double\n+/* Add two 'IBM128_TYPE' values and return the result.\t*/\n+IBM128_TYPE\n __gcc_qadd (double a, double aa, double c, double cc)\n {\n   double xh, xl, z, q, zz;\n@@ -147,7 +156,7 @@ __gcc_qadd (double a, double aa, double c, double cc)\n   return pack_ldouble (xh, xl);\n }\n \n-long double\n+IBM128_TYPE\n __gcc_qsub (double a, double b, double c, double d)\n {\n   return __gcc_qadd (a, b, -c, -d);\n@@ -157,7 +166,7 @@ __gcc_qsub (double a, double b, double c, double d)\n static double fmsub (double, double, double);\n #endif\n \n-long double\n+IBM128_TYPE\n __gcc_qmul (double a, double b, double c, double d)\n {\n   double xh, xl, t, tau, u, v, w;\n@@ -181,15 +190,15 @@ __gcc_qmul (double a, double b, double c, double d)\n   tau += v + w;\t    /* Add in other second-order terms.\t */\n   u = t + tau;\n \n-  /* Construct long double result.  */\n+  /* Construct IBM128_TYPE result.  */\n   if (nonfinite (u))\n     return u;\n   xh = u;\n   xl = (t - u) + tau;\n   return pack_ldouble (xh, xl);\n }\n \n-long double\n+IBM128_TYPE\n __gcc_qdiv (double a, double b, double c, double d)\n {\n   double xh, xl, s, sigma, t, tau, u, v, w;\n@@ -226,7 +235,7 @@ __gcc_qdiv (double a, double b, double c, double d)\n   tau = ((v-sigma)+w)/c;   /* Correction to t.  */\n   u = t + tau;\n \n-  /* Construct long double result.  */\n+  /* Construct IBM128_TYPE result.  */\n   if (nonfinite (u))\n     return u;\n   xh = u;\n@@ -236,32 +245,32 @@ __gcc_qdiv (double a, double b, double c, double d)\n \n #if defined (_SOFT_DOUBLE) && defined (__LONG_DOUBLE_128__)\n \n-long double __gcc_qneg (double, double);\n+IBM128_TYPE __gcc_qneg (double, double);\n int __gcc_qeq (double, double, double, double);\n int __gcc_qne (double, double, double, double);\n int __gcc_qge (double, double, double, double);\n int __gcc_qle (double, double, double, double);\n-long double __gcc_stoq (float);\n-long double __gcc_dtoq (double);\n+IBM128_TYPE __gcc_stoq (float);\n+IBM128_TYPE __gcc_dtoq (double);\n float __gcc_qtos (double, double);\n double __gcc_qtod (double, double);\n int __gcc_qtoi (double, double);\n unsigned int __gcc_qtou (double, double);\n-long double __gcc_itoq (int);\n-long double __gcc_utoq (unsigned int);\n+IBM128_TYPE __gcc_itoq (int);\n+IBM128_TYPE __gcc_utoq (unsigned int);\n \n extern int __eqdf2 (double, double);\n extern int __ledf2 (double, double);\n extern int __gedf2 (double, double);\n \n-/* Negate 'long double' value and return the result.\t*/\n-long double\n+/* Negate 'IBM128_TYPE' value and return the result.\t*/\n+IBM128_TYPE\n __gcc_qneg (double a, double aa)\n {\n   return pack_ldouble (-a, -aa);\n }\n \n-/* Compare two 'long double' values for equality.  */\n+/* Compare two 'IBM128_TYPE' values for equality.  */\n int\n __gcc_qeq (double a, double aa, double c, double cc)\n {\n@@ -272,7 +281,7 @@ __gcc_qeq (double a, double aa, double c, double cc)\n \n strong_alias (__gcc_qeq, __gcc_qne);\n \n-/* Compare two 'long double' values for less than or equal.  */\n+/* Compare two 'IBM128_TYPE' values for less than or equal.  */\n int\n __gcc_qle (double a, double aa, double c, double cc)\n {\n@@ -283,7 +292,7 @@ __gcc_qle (double a, double aa, double c, double cc)\n \n strong_alias (__gcc_qle, __gcc_qlt);\n \n-/* Compare two 'long double' values for greater than or equal.  */\n+/* Compare two 'IBM128_TYPE' values for greater than or equal.  */\n int\n __gcc_qge (double a, double aa, double c, double cc)\n {\n@@ -294,59 +303,59 @@ __gcc_qge (double a, double aa, double c, double cc)\n \n strong_alias (__gcc_qge, __gcc_qgt);\n \n-/* Convert single to long double.  */\n-long double\n+/* Convert single to IBM128_TYPE.  */\n+IBM128_TYPE\n __gcc_stoq (float a)\n {\n   return pack_ldouble ((double) a, 0.0);\n }\n \n-/* Convert double to long double.  */\n-long double\n+/* Convert double to IBM128_TYPE.  */\n+IBM128_TYPE\n __gcc_dtoq (double a)\n {\n   return pack_ldouble (a, 0.0);\n }\n \n-/* Convert long double to single.  */\n+/* Convert IBM128_TYPE to single.  */\n float\n __gcc_qtos (double a, double aa __attribute__ ((__unused__)))\n {\n   return (float) a;\n }\n \n-/* Convert long double to double.  */\n+/* Convert IBM128_TYPE to double.  */\n double\n __gcc_qtod (double a, double aa __attribute__ ((__unused__)))\n {\n   return a;\n }\n \n-/* Convert long double to int.  */\n+/* Convert IBM128_TYPE to int.  */\n int\n __gcc_qtoi (double a, double aa)\n {\n   double z = a + aa;\n   return (int) z;\n }\n \n-/* Convert long double to unsigned int.  */\n+/* Convert IBM128_TYPE to unsigned int.  */\n unsigned int\n __gcc_qtou (double a, double aa)\n {\n   double z = a + aa;\n   return (unsigned int) z;\n }\n \n-/* Convert int to long double.  */\n-long double\n+/* Convert int to IBM128_TYPE.  */\n+IBM128_TYPE\n __gcc_itoq (int a)\n {\n   return __gcc_dtoq ((double) a);\n }\n \n-/* Convert unsigned int to long double.  */\n-long double\n+/* Convert unsigned int to IBM128_TYPE.  */\n+IBM128_TYPE\n __gcc_utoq (unsigned int a)\n {\n   return __gcc_dtoq ((double) a);\n@@ -361,7 +370,7 @@ int __gcc_qunord (double, double, double, double);\n extern int __eqdf2 (double, double);\n extern int __unorddf2 (double, double);\n \n-/* Compare two 'long double' values for unordered.  */\n+/* Compare two 'IBM128_TYPE' values for unordered.  */\n int\n __gcc_qunord (double a, double aa, double c, double cc)\n {\n@@ -389,7 +398,7 @@ fmsub (double a, double b, double c)\n     FP_DECL_Q(V);\n     FP_DECL_D(R);\n     double r;\n-    long double u, x, y, z;\n+    IBM128_TYPE u, x, y, z;\n \n     FP_INIT_ROUNDMODE;\n     FP_UNPACK_RAW_D (A, a);"}, {"sha": "e10b25fec1ff8d97ffe4d0a48ae2839f3aa6c502", "filename": "libgcc/config/rs6000/quad-float128.h", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h?ref=d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "patch": "@@ -51,12 +51,7 @@ typedef __complex float TCtype __attribute__ ((mode (TC)));\n \n #include <quad.h>\n \n-#ifdef __LONG_DOUBLE_IEEE128__\n-#define IBM128_TYPE\t\t__ibm128\n-\n-#else\n-#define IBM128_TYPE\t\tlong double\n-#endif\n+#define IBM128_TYPE\t__ibm128\n \n /* Add prototypes of the library functions created.  In case the appropriate\n    int/long types are not declared in scope by the time quad.h is included,\n@@ -185,7 +180,7 @@ union ibm128_union {\n #define CVT_FLOAT128_TO_IBM128(RESULT, VALUE)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   double __high, __low;\t\t\t\t\t\t\t\\\n-  __float128 __value = (VALUE);\t\t\t\t\t\t\\\n+  TFtype __value = (VALUE);\t\t\t\t\t\t\\\n   union ibm128_union u;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   __high = (double) __value;\t\t\t\t\t\t\\\n@@ -196,7 +191,7 @@ union ibm128_union {\n     {\t\t\t\t\t\t\t\t\t\\\n       double __high_temp;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      __low = (double) (__value - (__float128) __high);\t\t\t\\\n+      __low = (double) (__value - (TFtype) __high);\t\t\t\\\n       /* Renormalize low/high and move them into canonical IBM long\t\\\n \t double form.  */\t\t\t\t\t\t\\\n       __high_temp = __high + __low;\t\t\t\t\t\\\n@@ -220,13 +215,13 @@ union ibm128_union {\n \t\t\t\t\t\t\t\t\t\\\n   /* Handle the special cases of NAN and infinity.  */\t\t\t\\\n   if (__builtin_isnan (__high) || __builtin_isinf (__high))\t\t\\\n-    RESULT = (__float128) __high;\t\t\t\t\t\\\n+    RESULT = (TFtype) __high;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* If low is 0.0, there no need to do the add.  In addition,\t\t\\\n      avoiding the add produces the correct sign if high is -0.0.  */\t\\\n   else if (__low == 0.0)\t\t\t\t\t\t\\\n-    RESULT = (__float128) __high;\t\t\t\t\t\\\n+    RESULT = (TFtype) __high;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n-    RESULT = ((__float128) __high) + ((__float128) __low);\t\t\\\n+    RESULT = ((TFtype) __high) + ((TFtype) __low);\t\t\t\\\n }"}, {"sha": "cb716c5f4c8d57c5af1f4f2df2ff9a1207c376a7", "filename": "libgcc/config/rs6000/trunctfkf2-sw.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5eea0f7cc49d3b96b90037e30d437f4ceb6a271/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c?ref=d5eea0f7cc49d3b96b90037e30d437f4ceb6a271", "patch": "@@ -43,10 +43,10 @@\n #define __trunctfkf2_sw __trunctfkf2\n #endif\n \n-__float128\n+TFtype\n __trunctfkf2_sw (IBM128_TYPE value)\n {\n-  __float128 ret;\n+  TFtype ret;\n \n   CVT_IBM128_TO_FLOAT128 (ret, value);\n   return ret;"}]}