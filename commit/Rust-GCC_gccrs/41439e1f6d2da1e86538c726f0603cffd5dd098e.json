{"sha": "41439e1f6d2da1e86538c726f0603cffd5dd098e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE0MzllMWY2ZDJkYTFlODY1MzhjNzI2ZjA2MDNjZmZkNWRkMDk4ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-27T07:47:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-27T07:51:26Z"}, "message": "tree-optimization/45178 - DCE of dead control flow in infinite loop\n\nThis fixes DCE to be able to elide dead control flow in an\ninfinite loop without an exit edge.  This special situation is\nhandled well by the code finding an edge to preserve since there's\nno chance it will find the exit edge and make the loop finite.\n\n2021-08-27  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/45178\n\t* tree-ssa-dce.c (find_obviously_necessary_stmts): For\n\tinfinite loops without exit do not mark control dependent\n\tedges of the latch necessary.\n\n\t* gcc.dg/tree-ssa/ssa-dce-3.c: Adjust testcase.", "tree": {"sha": "65fca8bcd2717417c16756e02f9a2270e859da91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65fca8bcd2717417c16756e02f9a2270e859da91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41439e1f6d2da1e86538c726f0603cffd5dd098e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41439e1f6d2da1e86538c726f0603cffd5dd098e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41439e1f6d2da1e86538c726f0603cffd5dd098e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41439e1f6d2da1e86538c726f0603cffd5dd098e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44a545a6abdd330083c1d12ad70092defbba702a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a545a6abdd330083c1d12ad70092defbba702a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a545a6abdd330083c1d12ad70092defbba702a"}], "stats": {"total": 23, "additions": 14, "deletions": 9}, "files": [{"sha": "fdfe37e0abd7dd99e5ddd8d94b5793da58e8ddf4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-3.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41439e1f6d2da1e86538c726f0603cffd5dd098e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dce-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41439e1f6d2da1e86538c726f0603cffd5dd098e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dce-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dce-3.c?ref=41439e1f6d2da1e86538c726f0603cffd5dd098e", "patch": "@@ -21,11 +21,12 @@ int main(void)\n   return 0;\n }\n \n-/* We now can prove the infiniteness of the loop during CCP and fail\n-   to eliminate the code inside the infinite loop because we start\n-   by marking the j % 7 condition as useful.  See PR45178.  */\n+/* We now can prove the infiniteness of the loop during CCP but we\n+   still want to eliminate the code inside the infinite loop.  See PR45178.  */\n \n /* We should eliminate the inner condition, but the loop must be preserved\n-   as it is infinite.  Therefore there should be just one goto and no PHI.  */\n+   as it is infinite.  Therefore there should be just one goto and no PHI\n+   and no if.  */\n /* { dg-final { scan-tree-dump-times \"PHI \" 0 \"cddce1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 0 \"cddce1\" } } */\n /* { dg-final { scan-tree-dump-times \"goto\" 1 \"cddce1\" } } */"}, {"sha": "c4907af923cb5c21991d6fbcf64577ad3bc2be2c", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41439e1f6d2da1e86538c726f0603cffd5dd098e/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41439e1f6d2da1e86538c726f0603cffd5dd098e/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=41439e1f6d2da1e86538c726f0603cffd5dd098e", "patch": "@@ -414,7 +414,9 @@ find_obviously_necessary_stmts (bool aggressive)\n   if ((flags & (ECF_CONST|ECF_PURE)) && !(flags & ECF_LOOPING_CONST_OR_PURE))\n     return;\n \n-  /* Prevent the empty possibly infinite loops from being removed.  */\n+  /* Prevent the empty possibly infinite loops from being removed.  This is\n+     needed to make the logic in remove_dead_stmt work to identify the\n+     correct edge to keep when removing a controlling condition.  */\n   if (aggressive)\n     {\n       if (mark_irreducible_loops ())\n@@ -426,17 +428,19 @@ find_obviously_necessary_stmts (bool aggressive)\n \t\t  && (e->flags & EDGE_IRREDUCIBLE_LOOP))\n \t\t{\n \t          if (dump_file)\n-\t            fprintf (dump_file, \"Marking back edge of irreducible loop %i->%i\\n\",\n-\t\t    \t     e->src->index, e->dest->index);\n+\t\t    fprintf (dump_file, \"Marking back edge of irreducible \"\n+\t\t\t     \"loop %i->%i\\n\", e->src->index, e->dest->index);\n \t\t  mark_control_dependent_edges_necessary (e->dest, false);\n \t\t}\n \t  }\n \n       for (auto loop : loops_list (cfun, 0))\n-\tif (!finite_loop_p (loop))\n+\t/* For loops without an exit do not mark any condition.  */\n+\tif (loop->exits->next && !finite_loop_p (loop))\n \t  {\n \t    if (dump_file)\n-\t      fprintf (dump_file, \"cannot prove finiteness of loop %i\\n\", loop->num);\n+\t      fprintf (dump_file, \"cannot prove finiteness of loop %i\\n\",\n+\t\t       loop->num);\n \t    mark_control_dependent_edges_necessary (loop->latch, false);\n \t  }\n     }"}]}