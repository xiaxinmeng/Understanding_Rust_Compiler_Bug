{"sha": "516a2dfd6f337bb262112331fa8a9c8fe19463eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE2YTJkZmQ2ZjMzN2JiMjYyMTEyMzMxZmE4YTljOGZlMTk0NjNlYg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-04T18:02:46Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-04T18:02:46Z"}, "message": "(__PTR_TO_INT, __INT_TO_PTR): Delete.\n\n(enum processor_type): Add R8000.\n(mips_isa_string, CC1_SPEC): Add mips4 to comment.\n(CONDITIONAL_REGISTER_USAGE): Use SUBTARGET_CONDITIONAL_REGISTER_USAGE.\n(SUBTARGET_CONDITIONAL_REGISTER_USAGE): New macro.\n(ASM_SPEC, LINK_SPEC, CPP_SPEC): Add mips4 support.\n(MIPS_TEMP[12]_REGNUM): Change to avoid clobbering 64bit abi\nparameter registers.\n(SMALL_INT, SMALL_INT_UNSIGNED, CONST_OK_FOR_LETTER_P): Fix for 64\nbit host.\n(ABI_64BIT): New macro.\n(REG_PARM_STACK_SPACE): Use UNITS_PER_WORD not 4.\n(GO_IF_LEGITIMATE_ADDRESS, CONSTANT_ADDRESS_P, LEGITIMATE_CONSTANT,\nLEGITIMIZE_ADDRESS): Don't allow CONST addresses for Irix6.\n(ASM_OUTPUT_FILENAME): New macro.\n(ASM_OUTPUT_ADDR_DIFF_ELT): Add 64 bit ABI support.\n\nFrom-SVN: r8862", "tree": {"sha": "a1fc67f21b2acc5e8afd70865041741b143cbc94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1fc67f21b2acc5e8afd70865041741b143cbc94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/516a2dfd6f337bb262112331fa8a9c8fe19463eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516a2dfd6f337bb262112331fa8a9c8fe19463eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/516a2dfd6f337bb262112331fa8a9c8fe19463eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516a2dfd6f337bb262112331fa8a9c8fe19463eb/comments", "author": null, "committer": null, "parents": [{"sha": "36f9f6c1e4047178e1bcb034db0173fd1141eb8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f9f6c1e4047178e1bcb034db0173fd1141eb8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f9f6c1e4047178e1bcb034db0173fd1141eb8a"}], "stats": {"total": 119, "additions": 75, "deletions": 44}, "files": [{"sha": "fd6e25d6e0fc326592ea986d3fe6e14b7173b272", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 75, "deletions": 44, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516a2dfd6f337bb262112331fa8a9c8fe19463eb/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516a2dfd6f337bb262112331fa8a9c8fe19463eb/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=516a2dfd6f337bb262112331fa8a9c8fe19463eb", "patch": "@@ -22,12 +22,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n-/* Make Saber happier on obstack.[ch].  */\n-#if defined(__mips__) || defined(mips)\n-#define __PTR_TO_INT(P) ((int)(P))\n-#define __INT_TO_PTR(P) ((char *)(P))\n-#endif\n-\n /* Standard GCC variables that we reference.  */\n \n extern char    *asm_file_name;\n@@ -71,7 +65,8 @@ enum processor_type {\n   PROCESSOR_R3000,\n   PROCESSOR_R6000,\n   PROCESSOR_R4000,\n-  PROCESSOR_R4600\n+  PROCESSOR_R4600,\n+  PROCESSOR_R8000\n };\n \n /* Recast the cpu class to be the cpu attribute.  */\n@@ -121,7 +116,7 @@ extern enum processor_type mips_cpu;\t/* which cpu are we scheduling for */\n extern enum mips_abicalls_type mips_abicalls;/* for svr4 abi pic calls */\n extern int mips_isa;\t\t\t/* architectural level */\n extern char *mips_cpu_string;\t\t/* for -mcpu=<xxx> */\n-extern char *mips_isa_string;\t\t/* for -mips{1,2,3} */\n+extern char *mips_isa_string;\t\t/* for -mips{1,2,3,4} */\n extern int dslots_load_total;\t\t/* total # load related delay slots */\n extern int dslots_load_filled;\t\t/* # filled load delay slots */\n extern int dslots_jump_total;\t\t/* total # jump related delay slots */\n@@ -456,8 +451,8 @@ extern char\t       *mktemp ();\n #define BRANCH_LIKELY_P()\t(mips_isa >= 2)\n #define HAVE_SQRT_P()\t\t(mips_isa >= 2)\n \n-/* CC1_SPEC causes -mips3 to set -mfp64 and -mgp64; -mips1 or -mips2\n-   sets -mfp32 and -mgp32.  This can be overridden by an explicit\n+/* CC1_SPEC causes -mips3 and -mips4 to set -mfp64 and -mgp64; -mips1 or\n+   -mips2 sets -mfp32 and -mgp32.  This can be overridden by an explicit\n    -mfp32, -mfp64, -mgp32 or -mgp64.  -mfp64 sets MASK_FLOAT64 in\n    target_flags, and -mgp64 sets MASK_64BIT.\n \n@@ -525,9 +520,13 @@ do\t\t\t\t\t\t\t\t\t\\\n \tfor (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\t\\\n \t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n+    SUBTARGET_CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n+/* This is meant to be redefined in the host dependent files */\n+#define SUBTARGET_CONDITIONAL_REGISTER_USAGE\n+\n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n \f\n@@ -586,7 +585,7 @@ while (0)\n \t%{K}} \\\n %{!mmips-as: \\\n \t%{mcpu=*} %{m4650} %{mmad:-m4650}} \\\n-%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{v} \\\n+%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} %{v} \\\n %{noasmopt:-O0} \\\n %{!noasmopt:%{O:-O2} %{O1:-O2} %{O2:-O2} %{O3:-O3}} \\\n %{g} %{g0} %{g1} %{g2} %{g3} \\\n@@ -605,7 +604,7 @@ while (0)\n \t%{K}} \\\n %{mgas: \\\n \t%{mcpu=*} %{m4650} %{mmad:-m4650}} \\\n-%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{v} \\\n+%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} %{v} \\\n %{noasmopt:-O0} \\\n %{!noasmopt:%{O:-O2} %{O1:-O2} %{O2:-O2} %{O3:-O3}} \\\n %{g} %{g0} %{g1} %{g2} %{g3} \\\n@@ -663,7 +662,7 @@ while (0)\n \n #ifndef LINK_SPEC\n #define LINK_SPEC \"\\\n-%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} \\\n+%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} \\\n %{bestGnum} %{shared} %{non_shared}\"\n #endif\t/* LINK_SPEC defined */\n \n@@ -674,6 +673,7 @@ while (0)\n %{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}} \\\n %{mips1:-mfp32 -mgp32}%{mips2:-mfp32 -mgp32}\\\n %{mips3:%{!msingle-float:%{!m4650:-mfp64}} -mgp64} \\\n+%{mips4:%{!msingle-float:%{!m4650:-mfp64}} -mgp64} \\\n %{mfp64:%{msingle-float:%emay not use both -mfp64 and -msingle-float}} \\\n %{mfp64:%{m4650:%emay not use both -mfp64 and -m4650}} \\\n %{m4650:-mcpu=r4650} \\\n@@ -699,6 +699,7 @@ while (0)\n %{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n %{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n %{mips3:-U__mips -D__mips=3} \\\n+%{mips4:-U__mips -D__mips=4} \\\n %{EB:-UMIPSEL -U_MIPSEL -U__MIPSEL -U__MIPSEL__ -D_MIPSEB -D__MIPSEB -D__MIPSEB__ %{!ansi:-DMIPSEB}} \\\n %{EL:-UMIPSEB -U_MIPSEB -U__MIPSEB -U__MIPSEB__ -D_MIPSEL -D__MIPSEL -D__MIPSEL__ %{!ansi:-DMIPSEL}}\"\n #endif\n@@ -1175,10 +1176,7 @@ do {\t\t\t\t\t\t\t\\\n \n /* Internal macros to classify a register number as to whether it's a\n    general purpose register, a floating point register, a\n-   multiply/divide register, or a status register.\n-\n-   The macro FP_CALL_REG_P also allows registers $4 and $6 as floating\n-   point registers to pass floating point as per MIPS spec. */\n+   multiply/divide register, or a status register.  */\n \n #define GP_REG_FIRST 0\n #define GP_REG_LAST  31\n@@ -1208,11 +1206,6 @@ do {\t\t\t\t\t\t\t\\\n #define MD_REG_P(REGNO) ((unsigned) ((REGNO) - MD_REG_FIRST) < MD_REG_NUM)\n #define ST_REG_P(REGNO) ((REGNO) == ST_REG_FIRST)\n \n-#define FP_CALL_REG_P(REGNO)\t\t\t\t\t\\\n-  (FP_REG_P (REGNO)\t\t\t\t\t\t\\\n-   || (REGNO) == (4 + GP_REG_FIRST)\t\t\t\t\\\n-   || (REGNO) == (6 + GP_REG_FIRST))\n-\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n@@ -1293,10 +1286,11 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n    is larger than 32K bytes.  These registers must come from the\n    scratch register set, and not used for passing and returning\n    arguments and any other information used in the calling sequence\n-   (such as pic).  */\n+   (such as pic).  Must start at 12, since t0/t3 are parameter passing\n+   registers in the 64 bit ABI.  */\n \n-#define MIPS_TEMP1_REGNUM (GP_REG_FIRST + 8)\n-#define MIPS_TEMP2_REGNUM (GP_REG_FIRST + 9)\n+#define MIPS_TEMP1_REGNUM (GP_REG_FIRST + 12)\n+#define MIPS_TEMP2_REGNUM (GP_REG_FIRST + 13)\n \n /* Define this macro if it is as good or better to call a constant\n    function address than to call an address kept in a register.  */\n@@ -1467,13 +1461,13 @@ extern enum reg_class mips_char_to_class[];\n \n    `P'\tis used for positive 16 bit constants.  */\n \n-#define SMALL_INT(X) ((unsigned) (INTVAL (X) + 0x8000) < 0x10000)\n-#define SMALL_INT_UNSIGNED(X) ((unsigned) (INTVAL (X)) < 0x10000)\n+#define SMALL_INT(X) ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n+#define SMALL_INT_UNSIGNED(X) ((unsigned HOST_WIDE_INT) (INTVAL (X)) < 0x10000)\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-  ((C) == 'I' ? ((unsigned) ((VALUE) + 0x8000) < 0x10000)\t\t\\\n+  ((C) == 'I' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000)\t\\\n    : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n-   : (C) == 'K' ? ((unsigned) (VALUE) < 0x10000)\t\t\t\\\n+   : (C) == 'K' ? ((unsigned HOST_WIDE_INT) (VALUE) < 0x10000)\t\t\\\n    : (C) == 'L' ? (((VALUE) & 0x0000ffff) == 0\t\t\t\t\\\n \t\t   && (((VALUE) & ~2147483647) == 0\t\t\t\\\n \t\t       || ((VALUE) & ~2147483647) == ~2147483647))\t\\\n@@ -1589,6 +1583,10 @@ extern enum reg_class\tmips_secondary_reload_class ();\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n+/* Don't enable support for the 64 bit ABI calling convention.\n+   Some embedded code depends on the old 64 bit calling convention.  */\n+#define ABI_64BIT 0\n+\n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n #define STACK_GROWS_DOWNWARD\n@@ -1772,7 +1770,8 @@ extern struct mips_frame_info current_frame_info;\n    in register. In case an argument list is of form GF used registers\n    are a0 (a2,a3), but we should push over a1...  */\n \n-#define REG_PARM_STACK_SPACE(FNDECL) ((4*UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL))\n+#define REG_PARM_STACK_SPACE(FNDECL)\t\\\n+  ((MAX_ARGS_IN_REGISTERS*UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL))\n \n /* Define this if it is the responsibility of the caller to\n    allocate the area reserved for arguments passed in registers. \n@@ -2288,7 +2287,10 @@ typedef struct mips_args {\n \t  /* Reject combining an embedded PIC text segment reference\t\\\n \t     with a register.  That requires an additional\t\t\\\n \t     instruction.  */\t\t\t\t\t\t\\\n+          /* ??? Reject combining an address with a register for the MIPS  \\\n+\t     64 bit ABI, because the SGI assembler can not handle this.  */ \\\n \t  if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\\\n+\t      && ! ABI_64BIT\t\t\t\t\t\t\\\n \t      && CONSTANT_ADDRESS_P (xplus1)\t\t\t\t\\\n \t      && (!TARGET_EMBEDDED_PIC\t\t\t\t\t\\\n \t\t  || code1 != CONST\t\t\t\t\t\\\n@@ -2311,11 +2313,13 @@ typedef struct mips_args {\n    assembler would use $at as a temp to load in the large offset.  In this\n    case $at is already in use.  We convert such problem addresses to\n    `la $5,s;sw $4,70000($5)' via LEGITIMIZE_ADDRESS.  */\n+/* ??? SGI Irix 6 assembler fails for CONST address, so reject them.  */\n #define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n   ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n     || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n     || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t&& ! (flag_pic && pic_address_needs_scratch (X))))\t\t\\\n+\t&& ! (flag_pic && pic_address_needs_scratch (X))\t\t\\\n+\t&& ! ABI_64BIT))\t\t\t\t\t\t\\\n    && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))\n \n /* Define this, so that when PIC, reload won't try to reload invalid\n@@ -2330,9 +2334,11 @@ typedef struct mips_args {\n    to be generated at present.  Also, the MIPS assembler does not\n    grok li.d Infinity.  */\n \n+/* ??? SGI Irix 6 assembler fails for CONST address, so reject them.  */\n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\t\\\n-  (GET_CODE (X) != CONST_DOUBLE || mips_const_double_ok (X, GET_MODE (X)))\n-\n+  ((GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n+    || mips_const_double_ok (X, GET_MODE (X)))\t\t\t\t\\\n+   && ! (GET_CODE (X) == CONST && ABI_64BIT))\n \n /* A C compound statement that attempts to replace X with a valid\n    memory address for an operand of mode MODE.  WIN will be a C\n@@ -2383,6 +2389,24 @@ typedef struct mips_args {\n       GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (xinsn) == CONST\t\t\t\t\t\t\\\n+      && ((flag_pic && pic_address_needs_scratch (xinsn))\t\t\\\n+\t  /* ??? SGI's Irix 6 assembler can't handle CONST.  */\t\t\\\n+\t  || ABI_64BIT))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n+      rtx constant = XEXP (XEXP (xinsn, 0), 1);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      emit_move_insn (ptr_reg, XEXP (XEXP (xinsn, 0), 0));\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      X = gen_rtx (PLUS, Pmode, ptr_reg, constant);\t\t\t\\\n+      if (SMALL_INT (constant))\t\t\t\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      /* Otherwise we fall through so the code below will fix the\t\\\n+\t constant.  */\t\t\t\t\t\t\t\\\n+      xinsn = X;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       register rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\\\n@@ -2417,16 +2441,6 @@ typedef struct mips_args {\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  if (flag_pic && pic_address_needs_scratch (xinsn))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      emit_move_insn (ptr_reg, XEXP (XEXP (xinsn, 0), 0));\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      X = gen_rtx (PLUS, Pmode, ptr_reg, XEXP (XEXP (xinsn, 0), 1));\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n     GO_PRINTF (\"LEGITIMIZE_ADDRESS could not fix.\\n\");\t\t\t\\\n }\n@@ -2656,6 +2670,7 @@ while (0)\n    strength reduction, and also makes it easier to identify what the\n    compiler is doing.  */\n \n+/* ??? Fix this to be right for the R8000.  */\n #define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n   case MEM:\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -2858,12 +2873,14 @@ while (0)\n       && (FROM) == GR_REGS) ? 6\t\t\t\t\t\t\\\n    : 12)\n \n+/* ??? Fix this to be right for the R8000.  */\n #define MEMORY_MOVE_COST(MODE) \\\n   ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 6 : 4)\n \n /* A C expression for the cost of a branch instruction.  A value of\n    1 is the default; other values are interpreted relative to that.  */\n \n+/* ??? Fix this to be right for the R8000.  */\n #define BRANCH_COST \\\n   ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 2 : 1)\n \n@@ -3261,6 +3278,16 @@ while (0)\n #define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)\t\t\t\\\n   mips_output_filename (STREAM, NAME)\n \n+/* This is defined so that it can be overriden in iris6.h.  */\n+#define ASM_OUTPUT_FILENAME(STREAM, NUM_SOURCE_FILENAMES, NAME) \\\n+do\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.file\\t%d \", NUM_SOURCE_FILENAMES);\t\\\n+    output_quoted_string (STREAM, NAME);\t\t\t\\\n+    fputs (\"\\n\", STREAM);\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n /* This is how to output a note the debugger telling it the line number\n    to which the following sequence of instructions corresponds.\n    Silicon graphics puts a label after each .loc.  */\n@@ -3474,10 +3501,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t$L%d-$LS%d\\n\",\t\t\t\t\\\n \t     TARGET_LONG64 ? \".dword\" : \".word\",\t\t\t\\\n \t     VALUE, REL);\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n+  else if (! ABI_64BIT)\t\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t$L%d\\n\",\t\t\t\t\t\\\n \t     TARGET_LONG64 ? \".gpdword\" : \".gpword\",\t\t\t\\\n \t     VALUE);\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t%s\\t.L%d\\n\",\t\t\t\t\t\\\n+\t     TARGET_LONG64 ? \".dword\" : \".word\",\t\t\t\\\n+\t     VALUE);\t\t\t\t\t\t\t\\\n } while (0)\n \n /* When generating embedded PIC code we want to put the jump table in"}]}