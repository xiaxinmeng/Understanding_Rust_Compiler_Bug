{"sha": "29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "node_id": "C_kwDOANBUbNoAKDI5ZmM1MDc1ZDdlMWRkMDE4NTk5ZmMzOTFlZWE0MjU5ZWY1ZTRiNmM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-07-13T10:54:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-08-05T13:57:31Z"}, "message": "libstdc++: Implement <experimental/scope> from LFTSv3\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/experimental/scope: New file.\n\t* testsuite/experimental/scopeguard/uniqueres.cc: New test.\n\t* testsuite/experimental/scopeguard/exit.cc: New test.", "tree": {"sha": "eaded1180eb83b199b5906d308e1f8511ca86225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaded1180eb83b199b5906d308e1f8511ca86225"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1878ab3650d8c646a4db364df388adaec2a29870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1878ab3650d8c646a4db364df388adaec2a29870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1878ab3650d8c646a4db364df388adaec2a29870"}], "stats": {"total": 1157, "additions": 1157, "deletions": 0}, "files": [{"sha": "3eeb407a57f0903b7850255832425d118fa5456b", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "patch": "@@ -757,6 +757,7 @@ experimental_headers = \\\n \t${experimental_srcdir}/random \\\n \t${experimental_srcdir}/ratio \\\n \t${experimental_srcdir}/regex \\\n+\t${experimental_srcdir}/scope \\\n \t${experimental_srcdir}/set \\\n \t${experimental_srcdir}/simd \\\n \t${experimental_srcdir}/socket \\"}, {"sha": "e24563caaeda61d2e14d8017dd0077e36a7da1f6", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "patch": "@@ -1115,6 +1115,7 @@ experimental_headers = \\\n \t${experimental_srcdir}/random \\\n \t${experimental_srcdir}/ratio \\\n \t${experimental_srcdir}/regex \\\n+\t${experimental_srcdir}/scope \\\n \t${experimental_srcdir}/set \\\n \t${experimental_srcdir}/simd \\\n \t${experimental_srcdir}/socket \\"}, {"sha": "37a57b38af73f702be2cf9de79257e482541e02e", "filename": "libstdc++-v3/include/experimental/scope", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fscope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fscope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fscope?ref=29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "patch": "@@ -0,0 +1,495 @@\n+// <experimental/scope> -*- C++ -*-\n+\n+// Copyright The GNU Toolchain Authors.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/scope\n+ *  This is a TS C++ Library header.\n+ *  @ingroup libfund-ts\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_SCOPE\n+#define _GLIBCXX_EXPERIMENTAL_SCOPE 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 202002L\n+\n+#include <concepts>\n+#include <exception> // uncaught_exceptions\n+#include <bits/refwrap.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace experimental::inline fundamentals_v3\n+{\n+  template<typename _Tp, typename _Up>\n+    concept __not_same_as = !same_as<_Tp, _Up>;\n+\n+  template<typename _Tp>\n+    concept __not_lvalue_ref = !is_lvalue_reference_v<_Tp>;\n+\n+  template<typename _Ef>\n+    class [[nodiscard]] scope_exit\n+    {\n+    public:\n+      template<typename _Efp>\n+\trequires __not_same_as<remove_cvref_t<_Efp>, scope_exit>\n+\t      && constructible_from<_Ef, _Efp>\n+\t[[nodiscard]] explicit\n+\tscope_exit(_Efp&& __f) noexcept(is_nothrow_constructible_v<_Ef, _Efp&>)\n+#ifdef __cpp_exceptions\n+\ttry\n+#endif\n+\t: _M_exit_function(__f)\n+\t{ }\n+#ifdef __cpp_exceptions\n+\tcatch (...) { __f(); }\n+#endif\n+\n+      template<typename _Efp>\n+\trequires __not_same_as<remove_cvref_t<_Efp>, scope_exit>\n+\t      && constructible_from<_Ef, _Efp>\n+\t      && __not_lvalue_ref<_Efp>\n+\t      && is_nothrow_constructible_v<_Ef, _Efp>\n+\texplicit\n+\tscope_exit(_Efp&& __f) noexcept\n+\t: _M_exit_function(std::forward<_Efp>(__f))\n+\t{ }\n+\n+      scope_exit(scope_exit&& __rhs) noexcept\n+      requires is_nothrow_move_constructible_v<_Ef>\n+      : _M_exit_function(std::forward<_Ef>(__rhs._M_exit_function))\n+      { __rhs.release(); }\n+\n+      scope_exit(scope_exit&& __rhs)\n+      noexcept(is_nothrow_copy_constructible_v<_Ef>)\n+      requires (!is_nothrow_move_constructible_v<_Ef>)\n+\t    && is_copy_constructible_v<_Ef>\n+      : _M_exit_function(__rhs._M_exit_function)\n+      { __rhs.release(); }\n+\n+      scope_exit(const scope_exit&) = delete;\n+      scope_exit& operator=(const scope_exit&) = delete;\n+      scope_exit& operator=(scope_exit&&) = delete;\n+\n+      ~scope_exit() noexcept(noexcept(this->_M_exit_function))\n+      {\n+\tif (_M_execute_on_destruction)\n+\t  _M_exit_function();\n+      }\n+\n+      void release() noexcept { _M_execute_on_destruction = false; }\n+\n+    private:\n+      [[no_unique_address]] _Ef _M_exit_function;\n+      bool _M_execute_on_destruction = true;\n+    };\n+\n+  template<typename _Ef>\n+    scope_exit(_Ef) -> scope_exit<_Ef>;\n+\n+  template<typename _Ef>\n+    class [[nodiscard]] scope_fail\n+    {\n+    public:\n+      template<typename _Efp>\n+\trequires __not_same_as<remove_cvref_t<_Efp>, scope_fail>\n+\t      && constructible_from<_Ef, _Efp>\n+\texplicit\n+\tscope_fail(_Efp&& __f) noexcept(is_nothrow_constructible_v<_Ef, _Efp&>)\n+#ifdef __cpp_exceptions\n+\ttry\n+#endif\n+\t: _M_exit_function(__f)\n+\t{ }\n+#ifdef __cpp_exceptions\n+\tcatch (...) { __f(); }\n+#endif\n+\n+      template<typename _Efp>\n+\trequires __not_same_as<remove_cvref_t<_Efp>, scope_fail>\n+\t      && constructible_from<_Ef, _Efp>\n+\t      && __not_lvalue_ref<_Efp>\n+\t      && is_nothrow_constructible_v<_Ef, _Efp>\n+\texplicit\n+\tscope_fail(_Efp&& __f) noexcept\n+\t: _M_exit_function(std::forward<_Efp>(__f))\n+\t{ }\n+\n+      scope_fail(scope_fail&& __rhs) noexcept\n+      requires is_nothrow_move_constructible_v<_Ef>\n+      : _M_exit_function(std::forward<_Ef>(__rhs._M_exit_function))\n+      { __rhs.release(); }\n+\n+      scope_fail(scope_fail&& __rhs)\n+      noexcept(is_nothrow_copy_constructible_v<_Ef>)\n+      requires (!is_nothrow_move_constructible_v<_Ef>)\n+\t    && is_copy_constructible_v<_Ef>\n+      : _M_exit_function(__rhs._M_exit_function)\n+      { __rhs.release(); }\n+\n+      scope_fail(const scope_fail&) = delete;\n+      scope_fail& operator=(const scope_fail&) = delete;\n+      scope_fail& operator=(scope_fail&&) = delete;\n+\n+      ~scope_fail() noexcept(noexcept(this->_M_exit_function))\n+      {\n+\tif (std::uncaught_exceptions() > _M_uncaught_init)\n+\t  _M_exit_function();\n+      }\n+\n+      void release() noexcept { _M_uncaught_init = __INT_MAX__; }\n+\n+    private:\n+      [[no_unique_address]] _Ef _M_exit_function;\n+      int _M_uncaught_init = std::uncaught_exceptions();\n+    };\n+\n+  template<typename _Ef>\n+    scope_fail(_Ef) -> scope_fail<_Ef>;\n+\n+  template<typename _Ef>\n+    class [[nodiscard]] scope_success\n+    {\n+    public:\n+      template<typename _Efp>\n+\trequires __not_same_as<remove_cvref_t<_Efp>, scope_success>\n+\t      && constructible_from<_Ef, _Efp>\n+\texplicit\n+\tscope_success(_Efp&& __f) noexcept(is_nothrow_constructible_v<_Ef, _Efp&>)\n+\t: _M_exit_function(__f)\n+\t{ }\n+\n+      template<typename _Efp>\n+\trequires __not_same_as<remove_cvref_t<_Efp>, scope_success>\n+\t      && constructible_from<_Ef, _Efp>\n+\t      && __not_lvalue_ref<_Efp>\n+\t      && is_nothrow_constructible_v<_Ef, _Efp>\n+\texplicit\n+\tscope_success(_Efp&& __f) noexcept\n+\t: _M_exit_function(std::forward<_Efp>(__f))\n+\t{ }\n+\n+      scope_success(scope_success&& __rhs) noexcept\n+      requires is_nothrow_move_constructible_v<_Ef>\n+      : _M_exit_function(std::forward<_Ef>(__rhs._M_exit_function))\n+      { __rhs.release(); }\n+\n+      scope_success(scope_success&& __rhs)\n+      noexcept(is_nothrow_copy_constructible_v<_Ef>)\n+      requires (!is_nothrow_move_constructible_v<_Ef>)\n+\t    && is_copy_constructible_v<_Ef>\n+      : _M_exit_function(__rhs._M_exit_function)\n+      { __rhs.release(); }\n+\n+      scope_success(const scope_success&) = delete;\n+      scope_success& operator=(const scope_success&) = delete;\n+      scope_success& operator=(scope_success&&) = delete;\n+\n+      ~scope_success() noexcept(noexcept(this->_M_exit_function))\n+      {\n+\tif (std::uncaught_exceptions() <= _M_uncaught_init)\n+\t  _M_exit_function();\n+      }\n+\n+      void release() noexcept { _M_uncaught_init = -__INT_MAX__; }\n+\n+    private:\n+      [[no_unique_address]] _Ef _M_exit_function;\n+      int _M_uncaught_init = std::uncaught_exceptions();\n+    };\n+\n+  template<typename _Ef>\n+    scope_success(_Ef) -> scope_success<_Ef>;\n+\n+  template<typename _Resrc, typename _Del>\n+    class [[nodiscard]] unique_resource\n+    {\n+      static_assert(!is_rvalue_reference_v<_Resrc>);\n+      static_assert(!is_reference_v<_Del>);\n+\n+      struct _Dummy { constexpr void release() { } };\n+\n+      template<typename _Tp>\n+\tstruct _Wrap\n+\t{\n+\t  template<typename _Up>\n+\t    requires is_constructible_v<_Tp, _Up>\n+\t    _Wrap(_Up&&)\n+\t    noexcept(is_nothrow_constructible_v<_Tp, _Up>);\n+\n+\t  template<typename _Up, typename _Del2>\n+\t    requires is_constructible_v<_Tp, _Up>\n+\t    _Wrap(_Up&& __r, _Del2&& __d)\n+\t    noexcept(is_nothrow_constructible_v<_Tp, _Up>)\n+\t    : _M_t(std::forward<_Up>(__r))\n+\t    { __d.release(); }\n+\n+\t  _Wrap() = default;\n+\n+\t  _Wrap(_Wrap&&) = default;\n+\n+\t  _Wrap(_Wrap&& __rhs) noexcept(is_nothrow_constructible_v<_Tp, _Tp&>)\n+\t  requires (!is_nothrow_move_constructible_v<_Tp>)\n+\t  : _M_t(__rhs._M_t)\n+\t  { }\n+\n+\t  _Wrap& operator=(const _Wrap&) = default;\n+\n+\t  _Wrap& operator=(_Wrap&&) = default;\n+\n+\t  constexpr _Tp& get() noexcept { return _M_t; }\n+\t  constexpr const _Tp& get() const noexcept { return _M_t; }\n+\n+\t  [[no_unique_address]] _Tp _M_t{};\n+\t};\n+\n+      template<typename _Tp>\n+\tstruct _Wrap<_Tp&>\n+\t{\n+\t  template<typename _Up>\n+\t    requires is_constructible_v<reference_wrapper<_Tp>, _Up>\n+\t    _Wrap(_Up&&)\n+\t    noexcept(is_nothrow_constructible_v<reference_wrapper<_Tp>, _Up>);\n+\n+\t  template<typename _Up, typename _Del2>\n+\t    _Wrap(_Up&& __r, _Del2&& __d)\n+\t    noexcept(is_nothrow_constructible_v<reference_wrapper<_Tp>, _Up>)\n+\t    : _M_p(__builtin_addressof(static_cast<_Tp&>(__r)))\n+\t    { __d.release(); }\n+\n+\t  _Wrap() = delete;\n+\n+\t  _Wrap(const _Wrap&) = default;\n+\n+\t  _Wrap& operator=(const _Wrap&) = default;\n+\n+\t  _Tp& get() noexcept { return *_M_p; }\n+\t  const _Tp& get() const noexcept { return *_M_p; }\n+\n+\t  _Tp* _M_p = nullptr;\n+\t};\n+\n+      using _Res1 = _Wrap<_Resrc>;\n+\n+      template<typename _Tp, typename _Up>\n+\trequires is_constructible_v<_Tp, _Up>\n+\t  && (is_nothrow_constructible_v<_Tp, _Up>\n+\t\t|| is_constructible_v<_Tp, _Up&>)\n+\tusing _Fwd_t\n+\t  = __conditional_t<is_nothrow_constructible_v<_Tp, _Up>, _Up, _Up&>;\n+\n+      template<typename _Tp, typename _Up>\n+\tstatic constexpr _Fwd_t<_Tp, _Up>\n+\t_S_fwd(_Up& __u)\n+\t{ return static_cast<_Fwd_t<_Tp, _Up>&&>(__u); }\n+\n+      template<typename _Tp, typename _Up, typename _Del2, typename _Res2>\n+\tstatic constexpr auto\n+\t_S_guard(_Del2& __d, _Res2& __r)\n+\t{\n+\t  if constexpr (is_nothrow_constructible_v<_Tp, _Up>)\n+\t    return _Dummy{};\n+\t  else\n+\t    return scope_fail{[&] { __d(__r); }};\n+\t}\n+\n+    public:\n+      unique_resource() = default;\n+\n+      template<typename _Res2, typename _Del2>\n+\trequires requires {\n+\t  typename _Fwd_t<_Res1, _Res2>;\n+\t  typename _Fwd_t<_Del, _Del2>;\n+\t}\n+\tunique_resource(_Res2&& __r, _Del2&& __d)\n+\tnoexcept((is_nothrow_constructible_v<_Res1, _Res2>\n+\t\t    || is_nothrow_constructible_v<_Res1, _Res2&>)\n+\t\t  &&\n+\t\t (is_nothrow_constructible_v<_Del, _Del2>\n+\t\t    || is_nothrow_constructible_v<_Del, _Del2&>))\n+\t: _M_res(_S_fwd<_Res1, _Res2>(__r),\n+\t\t _S_guard<_Res1, _Res2>(__d, __r)),\n+\t  _M_del(_S_fwd<_Del, _Del2>(__d),\n+\t\t _S_guard<_Del, _Del2>(__d, _M_res.get())),\n+\t  _M_exec_on_reset(true)\n+\t{ }\n+\n+      unique_resource(unique_resource&& __rhs) noexcept\n+      requires is_nothrow_move_constructible_v<_Res1>\n+\t    && is_nothrow_move_constructible_v<_Del>\n+      : _M_res(std::move(__rhs._M_res)),\n+\t_M_del(std::move(__rhs._M_del)),\n+\t_M_exec_on_reset(std::__exchange(__rhs._M_exec_on_reset, false))\n+      { }\n+\n+      unique_resource(unique_resource&& __rhs)\n+      requires is_nothrow_move_constructible_v<_Res1>\n+\t    && (!is_nothrow_move_constructible_v<_Del>)\n+      : _M_res(std::move(__rhs._M_res)),\n+\t_M_del(_S_fwd<_Del, _Del>(__rhs._M_del.get()),\n+\t       scope_fail([&]{\n+\t\t if (__rhs._M_exec_on_reset)\n+\t\t   {\n+\t\t     __rhs._M_del.get()(_M_res.get());\n+\t\t     __rhs.release();\n+\t\t   }\n+\t       })),\n+\t_M_exec_on_reset(std::__exchange(__rhs._M_exec_on_reset, false))\n+      { }\n+\n+      unique_resource(unique_resource&& __rhs)\n+      requires (!is_nothrow_move_constructible_v<_Res1>)\n+      : unique_resource(__rhs._M_res.get(), __rhs._M_del.get(), _Dummy{})\n+      {\n+\tif (__rhs._M_exec_on_reset)\n+\t  {\n+\t    _M_exec_on_reset = true;\n+\t    __rhs._M_exec_on_reset = false;\n+\t  }\n+      }\n+\n+      // 3.3.3.3, Destructor\n+      ~unique_resource() { reset(); }\n+\n+      // 3.3.3.4, Assignment\n+      unique_resource&\n+      operator=(unique_resource&& __rhs)\n+      noexcept(is_nothrow_move_assignable_v<_Res1>\n+\t\t&& is_nothrow_move_assignable_v<_Del>)\n+      {\n+\treset();\n+\tif constexpr (is_nothrow_move_assignable_v<_Res1>)\n+\t  {\n+\t    if constexpr (is_nothrow_move_assignable_v<_Del>)\n+\t      {\n+\t\t_M_res = std::move(__rhs._M_res);\n+\t\t_M_del = std::move(__rhs._M_del);\n+\t      }\n+\t    else\n+\t      {\n+\t\t_M_del = __rhs._M_del;\n+\t\t_M_res = std::move(__rhs._M_res);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if constexpr (is_nothrow_move_assignable_v<_Del>)\n+\t      {\n+\t\t_M_res = __rhs._M_res;\n+\t\t_M_del = std::move(__rhs._M_del);\n+\t      }\n+\t    else\n+\t      {\n+\t\t_M_res = __rhs._M_res;\n+\t\t_M_del = __rhs._M_del;\n+\t      }\n+\t  }\n+\t_M_exec_on_reset = std::__exchange(__rhs._M_exec_on_reset, false);\n+\treturn *this;\n+      }\n+\n+      // 3.3.3.5, Other member functions\n+      void\n+      reset() noexcept\n+      {\n+\tif (_M_exec_on_reset)\n+\t  {\n+\t    _M_exec_on_reset = false;\n+\t    _M_del.get()(_M_res.get());\n+\t  }\n+      }\n+\n+      template<typename _Res2>\n+\tvoid\n+\treset(_Res2&& __r)\n+\t{\n+\t  reset();\n+\t  if constexpr (is_nothrow_assignable_v<_Res1&, _Res2>)\n+\t    _M_res.get() = std::forward<_Res2>(__r);\n+\t  else\n+\t    _M_res.get() = const_cast<const remove_reference_t<_Res2>&>(__r);\n+\t  _M_exec_on_reset = true;\n+\t}\n+\n+      void\n+      release() noexcept\n+      { _M_exec_on_reset = false; }\n+\n+      const _Resrc&\n+      get() const noexcept\n+      { return _M_res.get(); }\n+\n+      add_lvalue_reference_t<remove_pointer_t<_Resrc>>\n+      operator*() const noexcept\n+      requires is_pointer_v<_Resrc> && (!is_void_v<remove_pointer_t<_Resrc>>)\n+      { return *get(); }\n+\n+      _Resrc operator->() const noexcept\n+      requires is_pointer_v<_Resrc>\n+      { return _M_res.get(); }\n+\n+      const _Del&\n+      get_deleter() const noexcept\n+      { return _M_del.get(); }\n+\n+    private:\n+      [[no_unique_address]] _Res1 _M_res{};\n+      [[no_unique_address]] _Wrap<_Del> _M_del{};\n+      bool _M_exec_on_reset = false;\n+\n+      template<typename _Res2, typename _Del2, typename _St>\n+\tfriend unique_resource<decay_t<_Res2>, decay_t<_Del2>>\n+\tmake_unique_resource_checked(_Res2&&, const _St&, _Del2&&)\n+\tnoexcept(is_nothrow_constructible_v<decay_t<_Res2>, _Res2>\n+\t\t  && is_nothrow_constructible_v<decay_t<_Del2>, _Del2>);\n+\n+      template<typename _Res2, typename _Del2>\n+\tunique_resource(_Res2&& __r, _Del2&& __d, _Dummy __noop)\n+\tnoexcept(is_nothrow_constructible_v<_Resrc, _Res2>\n+\t\t  && is_nothrow_constructible_v<_Del, _Del2>)\n+\t: _M_res(std::forward<_Res2>(__r), __noop),\n+\t  _M_del(std::forward<_Del>(__d), __noop)\n+\t{ }\n+    };\n+\n+  template<typename _Resrc, typename _Del>\n+    unique_resource(_Resrc, _Del) -> unique_resource<_Resrc, _Del>;\n+\n+  template<typename _Resrc, typename _Del, typename _St = decay_t<_Resrc>>\n+    unique_resource<decay_t<_Resrc>, decay_t<_Del>>\n+    make_unique_resource_checked(_Resrc&& __r, const _St& __invalid, _Del&& __d)\n+    noexcept(is_nothrow_constructible_v<decay_t<_Resrc>, _Resrc>\n+\t      && is_nothrow_constructible_v<decay_t<_Del>, _Del>)\n+    {\n+      if (__r == __invalid)\n+\treturn { std::forward<_Resrc>(__r), std::forward<_Del>(__d), {} };\n+      return { std::forward<_Resrc>(__r), std::forward<_Del>(__d) };\n+    }\n+\n+} // namespace experimental::fundamentals_v3\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // C++20\n+#endif // _GLIBCXX_EXPERIMENTAL_SCOPE"}, {"sha": "60616d1a93f29e11f21b2e14b1d0d3e613471d92", "filename": "libstdc++-v3/testsuite/experimental/scopeguard/exit.cc", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fscopeguard%2Fexit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fscopeguard%2Fexit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fscopeguard%2Fexit.cc?ref=29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "patch": "@@ -0,0 +1,300 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <experimental/scope>\n+#include <testsuite_hooks.h>\n+\n+int da_funk = 0;\n+void funk() { ++da_funk; }\n+\n+struct ThrowingCopy\n+{\n+  ThrowingCopy() = default;\n+  ThrowingCopy(ThrowingCopy&&) noexcept(false) { VERIFY(false); }\n+  ThrowingCopy(const ThrowingCopy&) { if (nocopy) throw 1; }\n+\n+  void operator()() const noexcept { ++counter; }\n+\n+  static ThrowingCopy create() noexcept { nocopy = false; return {}; }\n+\n+  static bool nocopy;\n+  static int counter;\n+};\n+\n+bool ThrowingCopy::nocopy = false;\n+int ThrowingCopy::counter = 0;\n+\n+void\n+test_exit()\n+{\n+  using std::experimental::scope_exit;\n+\n+  int counter = 0;\n+  auto d = [&counter] () { ++counter; };\n+\n+  {\n+    scope_exit e(d);\n+  }\n+  VERIFY( counter == 1 );\n+\n+  try\n+  {\n+    scope_exit e(d);\n+    throw 1;\n+  }\n+  catch (int)\n+  {\n+  }\n+  VERIFY( counter == 2 );\n+\n+  {\n+    scope_exit e(d);\n+    scope_exit e2(std::move(e));\n+  }\n+  VERIFY( counter == 3 );\n+\n+  {\n+    scope_exit e(d);\n+    e.release();\n+  }\n+  VERIFY( counter == 3 );\n+\n+  try\n+  {\n+    scope_exit e(d);\n+    e.release();\n+    throw 1;\n+  }\n+  catch (int)\n+  {\n+  }\n+  VERIFY( counter == 3 );\n+\n+  {\n+    da_funk = 0;\n+    scope_exit<void(&)()> e(funk);\n+  }\n+  VERIFY( da_funk == 1 );\n+\n+  static_assert(!std::is_move_assignable_v<scope_exit<void(*)()>>);\n+  static_assert(!std::is_move_assignable_v<scope_exit<void(&)()>>);\n+  static_assert(!std::is_move_assignable_v<scope_exit<ThrowingCopy>>);\n+  static_assert(!std::is_move_assignable_v<scope_exit<decltype(d)>>);\n+\n+  {\n+    ThrowingCopy::counter = 0;\n+    try\n+    {\n+      scope_exit<ThrowingCopy> e(ThrowingCopy::create());\n+      ThrowingCopy::nocopy = true;\n+      scope_exit<ThrowingCopy> e2(std::move(e));\n+      VERIFY(false);\n+    }\n+    catch (int)\n+    {\n+    }\n+    VERIFY( ThrowingCopy::counter == 1 );\n+\n+    scope_exit<ThrowingCopy> e(ThrowingCopy::create());\n+    try\n+    {\n+      ThrowingCopy::nocopy = true;\n+      scope_exit<ThrowingCopy> e2(std::move(e));\n+      VERIFY(false);\n+    }\n+    catch (int)\n+    {\n+    }\n+    VERIFY( ThrowingCopy::counter == 1 );\n+  }\n+  VERIFY( ThrowingCopy::counter == 2 );\n+}\n+\n+void\n+test_fail()\n+{\n+  using std::experimental::scope_fail;\n+  \n+  int counter = 0;\n+  auto d = [&counter] () { ++counter; };\n+\n+  {\n+    scope_fail f(d);\n+  }\n+  VERIFY( counter == 0 );\n+\n+  try\n+  {\n+    scope_fail f(d);\n+    throw 1;\n+  }\n+  catch (int)\n+  {\n+  }\n+  VERIFY( counter == 1 );\n+\n+  {\n+    scope_fail f(d);\n+    f.release();\n+  }\n+  VERIFY( counter == 1 );\n+\n+  try\n+  {\n+    scope_fail f(d);\n+    scope_fail f2(std::move(f));\n+    throw 1;\n+  }\n+  catch(int)\n+  {\n+  }\n+  VERIFY( counter == 2 );\n+\n+  try\n+  {\n+    scope_fail f(d);\n+    f.release();\n+    throw 1;\n+  }\n+  catch (int)\n+  {\n+  }\n+  VERIFY( counter == 2 );\n+\n+  try\n+  {\n+    da_funk = 0;\n+    scope_fail<void(&)()> e(funk);\n+    throw 1;\n+  }\n+  catch (int)\n+  {\n+  }\n+  VERIFY( da_funk == 1 );\n+\n+  static_assert(!std::is_move_assignable_v<scope_fail<void(*)()>>);\n+  static_assert(!std::is_move_assignable_v<scope_fail<void(&)()>>);\n+  static_assert(!std::is_move_assignable_v<scope_fail<ThrowingCopy>>);\n+  static_assert(!std::is_move_assignable_v<scope_fail<decltype(d)>>);\n+\n+  {\n+    ThrowingCopy::counter = 0;\n+    try\n+    {\n+      scope_fail<ThrowingCopy> f(ThrowingCopy::create());\n+      ThrowingCopy::nocopy = true;\n+      scope_fail<ThrowingCopy> f2(std::move(f));\n+      VERIFY(false);\n+    }\n+    catch (int)\n+    {\n+    }\n+    VERIFY( ThrowingCopy::counter == 1 );\n+\n+    scope_fail<ThrowingCopy> f(ThrowingCopy::create());\n+    try\n+    {\n+      ThrowingCopy::nocopy = true;\n+      scope_fail<ThrowingCopy> f2(std::move(f));\n+      VERIFY(false);\n+    }\n+    catch (int)\n+    {\n+    }\n+    VERIFY( ThrowingCopy::counter == 1 );\n+  }\n+  VERIFY( ThrowingCopy::counter == 1 );\n+}\n+\n+void\n+test_success()\n+{\n+  using std::experimental::scope_success;\n+\n+  int counter = 0;\n+  auto d = [&counter] () { ++counter; };\n+\n+  {\n+    scope_success s(d);\n+  }\n+  VERIFY( counter == 1 );\n+\n+  try\n+  {\n+    scope_success s(d);\n+    throw 1;\n+  }\n+  catch (int)\n+  {\n+  }\n+  VERIFY( counter == 1 );\n+\n+  {\n+    scope_success s(d);\n+    scope_success s2(std::move(s));\n+  }\n+  VERIFY( counter == 2 );\n+\n+  {\n+    scope_success s(d);\n+    s.release();\n+  }\n+  VERIFY( counter == 2 );\n+\n+  try\n+  {\n+    scope_success s(d);\n+    s.release();\n+    throw 1;\n+  }\n+  catch (int)\n+  {\n+  }\n+  VERIFY( counter == 2 );\n+\n+  {\n+    da_funk = 0;\n+    scope_success<void(&)()> e(funk);\n+  }\n+  VERIFY( da_funk == 1 );\n+\n+  static_assert(!std::is_move_assignable_v<scope_success<void(*)()>>);\n+  static_assert(!std::is_move_assignable_v<scope_success<void(&)()>>);\n+  static_assert(!std::is_move_assignable_v<scope_success<ThrowingCopy>>);\n+  static_assert(!std::is_move_assignable_v<scope_success<decltype(d)>>);\n+\n+  {\n+    ThrowingCopy::counter = 0;\n+    try\n+    {\n+      scope_success<ThrowingCopy> s(ThrowingCopy::create());\n+      ThrowingCopy::nocopy = true;\n+      scope_success<ThrowingCopy> s2(std::move(s));\n+      VERIFY(false);\n+    }\n+    catch (int)\n+    {\n+    }\n+    VERIFY( ThrowingCopy::counter == 0 );\n+\n+    scope_success<ThrowingCopy> s(ThrowingCopy::create());\n+    try\n+    {\n+      ThrowingCopy::nocopy = true;\n+      scope_success<ThrowingCopy> s2(std::move(s));\n+      VERIFY(false);\n+    }\n+    catch (int)\n+    {\n+    }\n+    VERIFY( ThrowingCopy::counter == 0 );\n+  }\n+  VERIFY( ThrowingCopy::counter == 1 );\n+}\n+\n+int main()\n+{\n+  test_exit();\n+  test_fail();\n+  test_success();\n+}"}, {"sha": "7690572ab190f45ecf489c72f74b6a8310712ebd", "filename": "libstdc++-v3/testsuite/experimental/scopeguard/uniqueres.cc", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fscopeguard%2Funiqueres.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29fc5075d7e1dd018599fc391eea4259ef5e4b6c/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fscopeguard%2Funiqueres.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fscopeguard%2Funiqueres.cc?ref=29fc5075d7e1dd018599fc391eea4259ef5e4b6c", "patch": "@@ -0,0 +1,360 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <experimental/scope>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::unique_resource;\n+\n+void\n+test_default_cons()\n+{\n+  struct val { int i; };\n+\n+  struct del\n+  {\n+    void operator()(val) const { VERIFY(false); }\n+    int i;\n+  };\n+\n+  static_assert( std::is_default_constructible_v<unique_resource<val, del>> );\n+  static_assert( !std::is_default_constructible_v<unique_resource<val&, del>> );\n+  // GCC extension:\n+  static_assert( std::is_nothrow_default_constructible_v<unique_resource<val, del>> );\n+  struct exval : val { exval() noexcept(false) { } };\n+  static_assert( !std::is_nothrow_default_constructible_v<unique_resource<exval, del>> );\n+\n+  unique_resource<val, del> res;\n+  VERIFY( res.get().i == 0 ); // value-initialized\n+  VERIFY( res.get_deleter().i == 0 ); // value-initialized\n+}\n+\n+void\n+test_cons()\n+{\n+  struct val { int i; };\n+\n+  struct del\n+  {\n+    void operator()(val v) const { VERIFY(v.i == i); }\n+    int i;\n+  };\n+\n+  auto r1 = unique_resource<val, del>(val{}, del{});\n+  VERIFY( r1.get().i == 0 );\n+  VERIFY( r1.get_deleter().i == 0 );\n+\n+  auto r2 = unique_resource<val, del>(1, 2);\n+  VERIFY( r2.get().i == 1 );\n+  VERIFY( r2.get_deleter().i == 2 );\n+  r2.release();\n+\n+  val v{3};\n+  auto r3 = unique_resource<val&, del>(v, 3);\n+\n+  static_assert( !std::is_constructible_v<unique_resource<val&, del>, val, del> );\n+  static_assert( !std::is_constructible_v<unique_resource<val&, del>, int, del> );\n+  static_assert( !std::is_constructible_v<unique_resource<val&, del>, const val&, del> );\n+\n+  del d4{4};\n+  auto r4 = unique_resource(std::ref(v), std::ref(d4));\n+  --d4.i;\n+\n+  static_assert( std::is_same_v<decltype(r4),\n+\t\t\t\tunique_resource<std::reference_wrapper<val>,\n+\t\t\t\t\t\tstd::reference_wrapper<del>>> );\n+  static_assert( !std::is_constructible_v<decltype(r4), val, del> );\n+\n+  int counter = 0, dcounter = 99;\n+  {\n+    unique_resource r(std::ref(counter),\n+\t\t      [&dcounter] (int& i) { ++dcounter; ++i; });\n+  }\n+  VERIFY( counter == 1 );\n+  VERIFY( dcounter == 100 );\n+\n+  {\n+    struct NothrowMove\n+    {\n+      NothrowMove() noexcept { }\n+      NothrowMove(NothrowMove&&) noexcept(true) { }\n+      NothrowMove(const NothrowMove&) { throw 1; }\n+    };\n+\n+    unique_resource r(NothrowMove{},\n+\t\t      [&dcounter] (NothrowMove&) { ++dcounter; });\n+  }\n+  VERIFY( dcounter == 101 );\n+\n+  {\n+    struct ThrowOnCopy\n+    {\n+      ThrowOnCopy() noexcept { }\n+      ThrowOnCopy(ThrowOnCopy&&) noexcept(false) { VERIFY(false); };\n+      ThrowOnCopy(const ThrowOnCopy&) { throw 1; }\n+      explicit ThrowOnCopy(val) noexcept(false) { VERIFY(false); }\n+      explicit ThrowOnCopy(val&) noexcept(false) { }\n+    };\n+    auto d = [&dcounter] (auto&) { ++dcounter; };\n+\n+    unique_resource r(val(1), d); // uses ThrowOnCopy(val&)\n+\n+    try {\n+      unique_resource r(ThrowOnCopy{}, d); // uses copy constructor\n+      VERIFY( false );\n+    } catch (int) {\n+      VERIFY( dcounter == 102 );\n+    }\n+  }\n+  VERIFY( dcounter == 103 );\n+\n+  {\n+    struct CopyVal\n+    {\n+      explicit CopyVal(const val& v) : i(v.i) { }\n+      int i;\n+    };\n+\n+    struct Del\n+    {\n+      void operator()(const val&) { VERIFY(false); }\n+      void operator()(const CopyVal& c) { ref = c.i; }\n+      int& ref;\n+    };\n+\n+    struct CopyDel\n+    {\n+      explicit CopyDel(Del&&) noexcept(false) { VERIFY(false); }\n+      explicit CopyDel(const Del&) noexcept(false) { throw 1; }\n+      void operator()(const val&) = delete;\n+      void operator()(const CopyVal&) { VERIFY(false); }\n+    };\n+\n+    try {\n+      // CopyVal is constructed from val(11), then initializing CopyDel throws.\n+      // The CopyVal member is passed to the Del argument to be freed.\n+      unique_resource<CopyVal, CopyDel> r(val(11), Del{dcounter});\n+      VERIFY( false );\n+    } catch (int) {\n+      VERIFY( dcounter == 11 );\n+    }\n+  }\n+}\n+\n+void\n+test_move_cons()\n+{\n+  {\n+    struct Del\n+    {\n+      void operator()(int) const { VERIFY(false); }\n+    };\n+\n+    unique_resource<int, Del> r0;\n+    auto rr0 = std::move(r0);\n+    VERIFY( r0.get() == 0 );\n+    VERIFY( rr0.get() == 0 );\n+\n+    struct DelThrowingCopy\n+    {\n+      DelThrowingCopy() = default;\n+      DelThrowingCopy(const DelThrowingCopy&) { throw 1; }\n+      void operator()(int) const { VERIFY(false); }\n+    };\n+\n+    unique_resource<int, DelThrowingCopy> r1;\n+    try {\n+      auto rr1 = std::move(r1); // Initializing deleter throws.\n+      VERIFY( false );\n+    } catch (int) {\n+    }\n+  }\n+\n+  {\n+    struct Res\n+    {\n+      Res() = default;\n+      Res(Res&& r) noexcept : moved(r.moved) { r.moved = true; }\n+      Res(Res& r) : moved(r.moved) { }\n+      bool moved = false;\n+    };\n+\n+    unique_resource r(Res{}, [](const auto&) { });\n+    auto rr = std::move(r);\n+    VERIFY( r.get().moved == true );\n+    VERIFY( rr.get().moved == false );\n+  }\n+\n+  {\n+    struct Res2\n+    {\n+      Res2() = default;\n+      Res2(Res2&& r) noexcept(false) : moved(r.moved) { r.moved = false; }\n+      Res2(Res2& r) : moved(r.moved) { }\n+      bool moved = false;\n+    };\n+\n+    unique_resource r2(Res2{}, [](const auto&) { });\n+    auto rr2 = std::move(r2);\n+    VERIFY( r2.get().moved == false );\n+    VERIFY( rr2.get().moved == false );\n+  }\n+\n+  {\n+    struct ThrowingCopy\n+    {\n+      ThrowingCopy(int) { }\n+      ThrowingCopy(const ThrowingCopy&) { throw 1; }\n+    };\n+\n+    int dcounter = 0;\n+    {\n+      auto d = [&dcounter] (const auto&) { ++dcounter; };\n+      unique_resource<ThrowingCopy, decltype(d)> r(1, d);\n+      try {\n+\tauto rr = std::move(r); // Ownership of resource left with 'r'\n+\tVERIFY(false);\n+      } catch (int) {\n+\tVERIFY( dcounter == 0 );\n+      }\n+    }\n+    VERIFY( dcounter == 1 );\n+  }\n+}\n+\n+int called1 = 0;\n+\n+void\n+test_assign()\n+{\n+  struct ThrowingDel\n+  {\n+    ThrowingDel() = default;\n+    ThrowingDel(int& called) : called(called) { }\n+    ThrowingDel(const ThrowingDel&) = default;\n+    ThrowingDel& operator=(const ThrowingDel&) { throw 1; }\n+\n+    void operator()(int i) const noexcept { ++called; }\n+    int& called = called1;\n+  };\n+\n+  int called2 = 0;\n+  {\n+    unique_resource<int, ThrowingDel> r1;\n+    VERIFY( r1.get() == 0 );\n+    unique_resource<int, ThrowingDel> r2(2, ThrowingDel{called2});\n+    VERIFY( r2.get() == 2 );\n+    try\n+    {\n+      r1 = std::move(r2);\n+      VERIFY( false );\n+    }\n+    catch (int)\n+    {\n+    }\n+    VERIFY( called1 == 0 ); // r1.reset() was called, but did nothing.\n+    VERIFY( called2 == 0 ); // r2.reset() not called.\n+    VERIFY( r1.get() == 0 );\n+    VERIFY( r2.get() == 2 );\n+  }\n+  VERIFY( called1 == 0 ); // r1.reset() was called, but did nothing.\n+  VERIFY( called2 == 1 ); // r2 destructor invoked its deleter.\n+}\n+\n+void\n+test_modifiers()\n+{\n+  int dcounter = 0;\n+  auto d = [&dcounter] (int i) { dcounter += i; };\n+  unique_resource<int, decltype(d)> r(1, d);\n+  r.reset();\n+  VERIFY( dcounter == 1 );\n+  r.reset(2);\n+  VERIFY( dcounter == 1 );\n+  r.release();\n+  VERIFY( dcounter == 1 );\n+  r.release();\n+  VERIFY( dcounter == 1 );\n+  r.reset(3);\n+  VERIFY( dcounter == 1 );\n+  r.reset(4);\n+  VERIFY( dcounter == 4 );\n+}\n+\n+template<typename T> concept has_star = requires (T& t) { *t; };\n+template<typename T> concept has_arrow = requires (T& t) { t.operator->(); };\n+\n+void\n+test_observers()\n+{\n+  struct D { void operator()(int* p) const noexcept { delete p; } };\n+  int* p = new int(3);\n+  unique_resource<int*, D> r(p, D{});\n+  VERIFY( r.get() == p );\n+  VERIFY( *r == 3 );\n+  VERIFY( r.operator->() == p );\n+  (void) r.get_deleter();\n+\n+  using R1 = unique_resource<int, void(*)(int)>;\n+  static_assert( ! has_star<R1> );\n+  static_assert( ! has_arrow<R1> );\n+  using R2 = unique_resource<const void*, void(*)(const void*)>;\n+  static_assert( ! has_star<R2> );\n+  static_assert( has_arrow<R2> );\n+}\n+\n+void\n+test_make_checked()\n+{\n+  struct Boolish {\n+    explicit operator bool() const noexcept { return val; }\n+    bool val;\n+  };\n+\n+  using std::experimental::make_unique_resource_checked;\n+\n+  {\n+    struct ThrowingCopy\n+    {\n+      ThrowingCopy(int i) : val(i) { }\n+      ThrowingCopy(const ThrowingCopy&) { throw 1; }\n+      Boolish operator==(int i) const noexcept { return {i == val}; }\n+      int val;\n+    };\n+\n+    int dcounter = 0;\n+    auto d = [&dcounter] (const auto&) { ++dcounter; };\n+\n+    try\n+    {\n+      (void) make_unique_resource_checked(ThrowingCopy(1), 0, d);\n+      VERIFY(false);\n+    }\n+    catch (int)\n+    {\n+      VERIFY(dcounter == 1);\n+    }\n+\n+    dcounter = 0;\n+    try\n+    {\n+      (void) make_unique_resource_checked(ThrowingCopy(1), 1, d);\n+      VERIFY(false);\n+    }\n+    catch (int)\n+    {\n+      VERIFY(dcounter == 0);\n+    }\n+  }\n+}\n+\n+int main()\n+{\n+  test_default_cons();\n+  test_cons();\n+  test_move_cons();\n+  test_assign();\n+  test_modifiers();\n+  test_observers();\n+  test_make_checked();\n+}"}]}