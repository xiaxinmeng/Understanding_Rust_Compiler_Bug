{"sha": "58c55a329a8fff3e4e206b1b944572795821b518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThjNTVhMzI5YThmZmYzZTRlMjA2YjFiOTQ0NTcyNzk1ODIxYjUxOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-11-14T22:13:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-11-14T22:13:41Z"}, "message": "compiler: Use backend interface for comparisons.\n\nFrom-SVN: r204827", "tree": {"sha": "7f60baf8e448102979a63c736e336bca5f8c7a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f60baf8e448102979a63c736e336bca5f8c7a04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58c55a329a8fff3e4e206b1b944572795821b518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c55a329a8fff3e4e206b1b944572795821b518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c55a329a8fff3e4e206b1b944572795821b518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c55a329a8fff3e4e206b1b944572795821b518/comments", "author": null, "committer": null, "parents": [{"sha": "1726bd6ea3e474cb7ce68ac5adc047c4455d5adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1726bd6ea3e474cb7ce68ac5adc047c4455d5adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1726bd6ea3e474cb7ce68ac5adc047c4455d5adf"}], "stats": {"total": 259, "additions": 110, "deletions": 149}, "files": [{"sha": "4d2fbfd5a58458f6036942f4bb0b270deca3e793", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 105, "deletions": 146, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c55a329a8fff3e4e206b1b944572795821b518/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c55a329a8fff3e4e206b1b944572795821b518/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=58c55a329a8fff3e4e206b1b944572795821b518", "patch": "@@ -5321,14 +5321,19 @@ Binary_expression::do_lower(Gogo* gogo, Named_object*,\n \t}\n     }\n \n-  // Lower struct and array comparisons.\n+  // Lower struct, array, and some interface comparisons.\n   if (op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ)\n     {\n       if (left->type()->struct_type() != NULL)\n \treturn this->lower_struct_comparison(gogo, inserter);\n       else if (left->type()->array_type() != NULL\n \t       && !left->type()->is_slice_type())\n \treturn this->lower_array_comparison(gogo, inserter);\n+      else if ((left->type()->interface_type() != NULL\n+                && right->type()->interface_type() == NULL)\n+               || (left->type()->interface_type() == NULL\n+                   && right->type()->interface_type() != NULL))\n+\treturn this->lower_interface_value_comparison(gogo, inserter);\n     }\n \n   return this;\n@@ -5457,6 +5462,57 @@ Binary_expression::lower_array_comparison(Gogo* gogo,\n   return ret;\n }\n \n+// Lower an interface to value comparison.\n+\n+Expression*\n+Binary_expression::lower_interface_value_comparison(Gogo*,\n+                                                    Statement_inserter* inserter)\n+{\n+  Type* left_type = this->left_->type();\n+  Type* right_type = this->right_->type();\n+  Interface_type* ift;\n+  if (left_type->interface_type() != NULL)\n+    {\n+      ift = left_type->interface_type();\n+      if (!ift->implements_interface(right_type, NULL))\n+        return this;\n+    }\n+  else\n+    {\n+      ift = right_type->interface_type();\n+      if (!ift->implements_interface(left_type, NULL))\n+        return this;\n+    }\n+  if (!Type::are_compatible_for_comparison(true, left_type, right_type, NULL))\n+    return this;\n+\n+  Location loc = this->location();\n+\n+  if (left_type->interface_type() == NULL\n+      && left_type->points_to() == NULL\n+      && !this->left_->is_addressable())\n+    {\n+      Temporary_statement* temp =\n+          Statement::make_temporary(left_type, NULL, loc);\n+      inserter->insert(temp);\n+      this->left_ =\n+          Expression::make_set_and_use_temporary(temp, this->left_, loc);\n+    }\n+\n+  if (right_type->interface_type() == NULL\n+      && right_type->points_to() == NULL\n+      && !this->right_->is_addressable())\n+    {\n+      Temporary_statement* temp =\n+          Statement::make_temporary(right_type, NULL, loc);\n+      inserter->insert(temp);\n+      this->right_ =\n+          Expression::make_set_and_use_temporary(temp, this->right_, loc);\n+    }\n+\n+  return this;\n+}\n+\n // Lower a struct or array comparison to a call to memcmp.\n \n Expression*\n@@ -5919,8 +5975,7 @@ Binary_expression::do_get_tree(Translate_context* context)\n     case OPERATOR_GT:\n     case OPERATOR_GE:\n       return Expression::comparison_tree(context, this->type_, this->op_,\n-\t\t\t\t\t this->left_->type(), left,\n-\t\t\t\t\t this->right_->type(), right,\n+\t\t\t\t\t this->left_, this->right_,\n \t\t\t\t\t this->location());\n \n     case OPERATOR_OROR:\n@@ -6417,12 +6472,16 @@ Expression::make_binary(Operator op, Expression* left, Expression* right,\n \n tree\n Expression::comparison_tree(Translate_context* context, Type* result_type,\n-\t\t\t    Operator op, Type* left_type, tree left_tree,\n-\t\t\t    Type* right_type, tree right_tree,\n-\t\t\t    Location location)\n+\t\t\t    Operator op, Expression* left_expr,\n+\t\t\t    Expression* right_expr, Location location)\n {\n-  Type* int_type = Type::lookup_integer_type(\"int\");\n-  tree int_type_tree = type_to_tree(int_type->get_backend(context->gogo()));\n+  Type* left_type = left_expr->type();\n+  Type* right_type = right_expr->type();\n+\n+  mpz_t zval;\n+  mpz_init_set_ui(zval, 0UL);\n+  Expression* zexpr = Expression::make_integer(&zval, NULL, location);\n+  mpz_clear(zval);\n \n   enum tree_code code;\n   switch (op)\n@@ -6449,21 +6508,17 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n       go_unreachable();\n     }\n \n+  // FIXME: Computing the tree here means it will be computed multiple times,\n+  // which is wasteful.  This is a temporary modification until all tree code\n+  // here can be replaced with frontend expressions.\n+  tree left_tree = left_expr->get_tree(context);\n+  tree right_tree = right_expr->get_tree(context);\n   if (left_type->is_string_type() && right_type->is_string_type())\n     {\n-      Type* st = Type::make_string_type();\n-      tree string_type = type_to_tree(st->get_backend(context->gogo()));\n-      static tree string_compare_decl;\n-      left_tree = Gogo::call_builtin(&string_compare_decl,\n-\t\t\t\t     location,\n-\t\t\t\t     \"__go_strcmp\",\n-\t\t\t\t     2,\n-\t\t\t\t     int_type_tree,\n-\t\t\t\t     string_type,\n-\t\t\t\t     left_tree,\n-\t\t\t\t     string_type,\n-\t\t\t\t     right_tree);\n-      right_tree = build_int_cst_type(int_type_tree, 0);\n+      Expression* strcmp_call = Runtime::make_call(Runtime::STRCMP, location, 2,\n+                                                   left_expr, right_expr);\n+      left_tree = strcmp_call->get_tree(context);\n+      right_tree = zexpr->get_tree(context);\n     }\n   else if ((left_type->interface_type() != NULL\n \t    && right_type->interface_type() == NULL\n@@ -6476,154 +6531,61 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n       if (left_type->interface_type() == NULL)\n \t{\n \t  std::swap(left_type, right_type);\n-\t  std::swap(left_tree, right_tree);\n+\t  std::swap(left_expr, right_expr);\n \t}\n \n       // The right operand is not an interface.  We need to take its\n       // address if it is not a pointer.\n-      tree make_tmp;\n-      tree arg;\n+      Expression* pointer_arg = NULL;\n       if (right_type->points_to() != NULL)\n-\t{\n-\t  make_tmp = NULL_TREE;\n-\t  arg = right_tree;\n-\t}\n-      else if (TREE_ADDRESSABLE(TREE_TYPE(right_tree))\n-\t       || (TREE_CODE(right_tree) != CONST_DECL\n-\t\t   && DECL_P(right_tree)))\n-\t{\n-\t  make_tmp = NULL_TREE;\n-\t  arg = build_fold_addr_expr_loc(location.gcc_location(), right_tree);\n-\t  if (DECL_P(right_tree))\n-\t    TREE_ADDRESSABLE(right_tree) = 1;\n-\t}\n-      else\n-\t{\n-\t  tree tmp = create_tmp_var(TREE_TYPE(right_tree),\n-\t\t\t\t    get_name(right_tree));\n-\t  DECL_IGNORED_P(tmp) = 0;\n-\t  DECL_INITIAL(tmp) = right_tree;\n-\t  TREE_ADDRESSABLE(tmp) = 1;\n-\t  make_tmp = build1(DECL_EXPR, void_type_node, tmp);\n-\t  SET_EXPR_LOCATION(make_tmp, location.gcc_location());\n-\t  arg = build_fold_addr_expr_loc(location.gcc_location(), tmp);\n-\t}\n-      arg = fold_convert_loc(location.gcc_location(), ptr_type_node, arg);\n-\n-      Bexpression* descriptor_bexpr =\n-          right_type->type_descriptor_pointer(context->gogo(), location);\n-      tree descriptor = expr_to_tree(descriptor_bexpr);\n-\n-      if (left_type->interface_type()->is_empty())\n-\t{\n-\t  static tree empty_interface_value_compare_decl;\n-\t  left_tree = Gogo::call_builtin(&empty_interface_value_compare_decl,\n-\t\t\t\t\t location,\n-\t\t\t\t\t \"__go_empty_interface_value_compare\",\n-\t\t\t\t\t 3,\n-\t\t\t\t\t int_type_tree,\n-\t\t\t\t\t TREE_TYPE(left_tree),\n-\t\t\t\t\t left_tree,\n-\t\t\t\t\t TREE_TYPE(descriptor),\n-\t\t\t\t\t descriptor,\n-\t\t\t\t\t ptr_type_node,\n-\t\t\t\t\t arg);\n-\t  if (left_tree == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if the type is not comparable.\n-\t  TREE_NOTHROW(empty_interface_value_compare_decl) = 0;\n-\t}\n+        pointer_arg = right_expr;\n       else\n \t{\n-\t  static tree interface_value_compare_decl;\n-\t  left_tree = Gogo::call_builtin(&interface_value_compare_decl,\n-\t\t\t\t\t location,\n-\t\t\t\t\t \"__go_interface_value_compare\",\n-\t\t\t\t\t 3,\n-\t\t\t\t\t int_type_tree,\n-\t\t\t\t\t TREE_TYPE(left_tree),\n-\t\t\t\t\t left_tree,\n-\t\t\t\t\t TREE_TYPE(descriptor),\n-\t\t\t\t\t descriptor,\n-\t\t\t\t\t ptr_type_node,\n-\t\t\t\t\t arg);\n-\t  if (left_tree == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if the type is not comparable.\n-\t  TREE_NOTHROW(interface_value_compare_decl) = 0;\n+          go_assert(right_expr->is_addressable());\n+          pointer_arg = Expression::make_unary(OPERATOR_AND, right_expr,\n+                                               location);\n \t}\n-      right_tree = build_int_cst_type(int_type_tree, 0);\n \n-      if (make_tmp != NULL_TREE)\n-\tleft_tree = build2(COMPOUND_EXPR, TREE_TYPE(left_tree), make_tmp,\n-\t\t\t   left_tree);\n+      Expression* descriptor_expr = Expression::make_type_descriptor(right_type,\n+                                                                     location);\n+      Call_expression* iface_valcmp =\n+          Runtime::make_call((left_type->interface_type()->is_empty()\n+                              ? Runtime::EMPTY_INTERFACE_VALUE_COMPARE\n+                              : Runtime::INTERFACE_VALUE_COMPARE),\n+                             location, 3, left_expr, descriptor_expr,\n+                             pointer_arg);\n+      left_tree = iface_valcmp->get_tree(context);\n+      right_tree = zexpr->get_tree(context);\n     }\n   else if (left_type->interface_type() != NULL\n \t   && right_type->interface_type() != NULL)\n     {\n+      Runtime::Function compare_function;\n       if (left_type->interface_type()->is_empty()\n \t  && right_type->interface_type()->is_empty())\n-\t{\n-\t  static tree empty_interface_compare_decl;\n-\t  left_tree = Gogo::call_builtin(&empty_interface_compare_decl,\n-\t\t\t\t\t location,\n-\t\t\t\t\t \"__go_empty_interface_compare\",\n-\t\t\t\t\t 2,\n-\t\t\t\t\t int_type_tree,\n-\t\t\t\t\t TREE_TYPE(left_tree),\n-\t\t\t\t\t left_tree,\n-\t\t\t\t\t TREE_TYPE(right_tree),\n-\t\t\t\t\t right_tree);\n-\t  if (left_tree == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if the type is uncomparable.\n-\t  TREE_NOTHROW(empty_interface_compare_decl) = 0;\n-\t}\n+\tcompare_function = Runtime::EMPTY_INTERFACE_COMPARE;\n       else if (!left_type->interface_type()->is_empty()\n \t       && !right_type->interface_type()->is_empty())\n-\t{\n-\t  static tree interface_compare_decl;\n-\t  left_tree = Gogo::call_builtin(&interface_compare_decl,\n-\t\t\t\t\t location,\n-\t\t\t\t\t \"__go_interface_compare\",\n-\t\t\t\t\t 2,\n-\t\t\t\t\t int_type_tree,\n-\t\t\t\t\t TREE_TYPE(left_tree),\n-\t\t\t\t\t left_tree,\n-\t\t\t\t\t TREE_TYPE(right_tree),\n-\t\t\t\t\t right_tree);\n-\t  if (left_tree == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if the type is uncomparable.\n-\t  TREE_NOTHROW(interface_compare_decl) = 0;\n-\t}\n+\tcompare_function = Runtime::INTERFACE_COMPARE;\n       else\n \t{\n \t  if (left_type->interface_type()->is_empty())\n \t    {\n \t      go_assert(op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ);\n \t      std::swap(left_type, right_type);\n-\t      std::swap(left_tree, right_tree);\n+\t      std::swap(left_expr, right_expr);\n \t    }\n \t  go_assert(!left_type->interface_type()->is_empty());\n \t  go_assert(right_type->interface_type()->is_empty());\n-\t  static tree interface_empty_compare_decl;\n-\t  left_tree = Gogo::call_builtin(&interface_empty_compare_decl,\n-\t\t\t\t\t location,\n-\t\t\t\t\t \"__go_interface_empty_compare\",\n-\t\t\t\t\t 2,\n-\t\t\t\t\t int_type_tree,\n-\t\t\t\t\t TREE_TYPE(left_tree),\n-\t\t\t\t\t left_tree,\n-\t\t\t\t\t TREE_TYPE(right_tree),\n-\t\t\t\t\t right_tree);\n-\t  if (left_tree == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if the type is uncomparable.\n-\t  TREE_NOTHROW(interface_empty_compare_decl) = 0;\n+\t  compare_function = Runtime::INTERFACE_EMPTY_COMPARE;\n \t}\n \n-      right_tree = build_int_cst_type(int_type_tree, 0);\n+      Call_expression* ifacecmp_call =\n+          Runtime::make_call(compare_function, location, 2,\n+                             left_expr, right_expr);\n+\n+      left_tree = ifacecmp_call->get_tree(context);\n+      right_tree = zexpr->get_tree(context);\n     }\n \n   if (left_type->is_nil_type()\n@@ -11908,14 +11870,11 @@ Interface_field_reference_expression::do_get_tree(Translate_context* context)\n   // Note that we are evaluating this->expr_ twice, but that is OK\n   // because in the lowering pass we forced it into a temporary\n   // variable.\n-  tree expr_tree = this->expr_->get_tree(context);\n   tree nil_check_tree = Expression::comparison_tree(context,\n \t\t\t\t\t\t    Type::lookup_bool_type(),\n \t\t\t\t\t\t    OPERATOR_EQEQ,\n-\t\t\t\t\t\t    this->expr_->type(),\n-\t\t\t\t\t\t    expr_tree,\n-\t\t\t\t\t\t    Type::make_nil_type(),\n-\t\t\t\t\t\t    null_pointer_node,\n+\t\t\t\t\t\t    this->expr_,\n+\t\t\t\t\t\t    Expression::make_nil(loc),\n \t\t\t\t\t\t    loc);\n   tree crash = context->gogo()->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n \t\t\t\t\t      loc);"}, {"sha": "e447418b949e97acd8bea1d030ea777aa6f2686b", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c55a329a8fff3e4e206b1b944572795821b518/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c55a329a8fff3e4e206b1b944572795821b518/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=58c55a329a8fff3e4e206b1b944572795821b518", "patch": "@@ -655,12 +655,11 @@ class Expression\n \t\t\t\t Type* rhs_type, tree rhs_tree,\n \t\t\t\t bool for_type_guard, Location);\n \n-  // Return a tree implementing the comparison LHS_TREE OP RHS_TREE.\n+  // Return a tree implementing the comparison LHS_EXPR OP RHS_EXPR.\n   // TYPE is the type of both sides.\n   static tree\n   comparison_tree(Translate_context*, Type* result_type, Operator op,\n-\t\t  Type* left_type, tree left_tree, Type* right_type,\n-\t\t  tree right_tree, Location);\n+\t\t  Expression* left_expr, Expression* right_expr, Location);\n \n   // Return the backend expression for the numeric constant VAL.\n   static Bexpression*\n@@ -1305,6 +1304,9 @@ class Binary_expression : public Expression\n   Expression*\n   lower_array_comparison(Gogo*, Statement_inserter*);\n \n+  Expression*\n+  lower_interface_value_comparison(Gogo*, Statement_inserter*);\n+\n   Expression*\n   lower_compare_to_memcmp(Gogo*, Statement_inserter*);\n "}]}