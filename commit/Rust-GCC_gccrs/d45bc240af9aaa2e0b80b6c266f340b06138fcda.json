{"sha": "d45bc240af9aaa2e0b80b6c266f340b06138fcda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ1YmMyNDBhZjlhYWEyZTBiODBiNmMyNjZmMzQwYjA2MTM4ZmNkYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:42:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:42:28Z"}, "message": "[multiple changes]\n\n2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Entity_Of): Moved to Exp_Util.\n\t* exp_util.ads, exp_util.adb (Entity_Of): New routine.\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* g-spipat.ads: Minor comment fix.\n\nFrom-SVN: r197778", "tree": {"sha": "dc5271b5520bf0b3ff50957683b5757ff79ed82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc5271b5520bf0b3ff50957683b5757ff79ed82f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d45bc240af9aaa2e0b80b6c266f340b06138fcda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45bc240af9aaa2e0b80b6c266f340b06138fcda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d45bc240af9aaa2e0b80b6c266f340b06138fcda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45bc240af9aaa2e0b80b6c266f340b06138fcda/comments", "author": null, "committer": null, "parents": [{"sha": "b25021611e702a13cc4db4c213fba0072043cdc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25021611e702a13cc4db4c213fba0072043cdc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25021611e702a13cc4db4c213fba0072043cdc3"}], "stats": {"total": 121, "additions": 67, "deletions": 54}, "files": [{"sha": "5dd4491c5d8b88ee2ea607d3018917544059298c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d45bc240af9aaa2e0b80b6c266f340b06138fcda", "patch": "@@ -1,3 +1,12 @@\n+2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Entity_Of): Moved to Exp_Util.\n+\t* exp_util.ads, exp_util.adb (Entity_Of): New routine.\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-spipat.ads: Minor comment fix.\n+\n 2013-04-11  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_prag.adb, sem_util.adb, sem_res.adb, exp_ch4.adb: Minor"}, {"sha": "059cd092e4887ec56f1715d3b81d04554ee5e1d3", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d45bc240af9aaa2e0b80b6c266f340b06138fcda", "patch": "@@ -1774,6 +1774,35 @@ package body Exp_Util is\n       end if;\n    end Ensure_Defined;\n \n+   ---------------\n+   -- Entity_Of --\n+   ---------------\n+\n+   function Entity_Of (N : Node_Id) return Entity_Id is\n+      Id : Entity_Id;\n+\n+   begin\n+      Id := Empty;\n+\n+      if Is_Entity_Name (N) then\n+         Id := Entity (N);\n+\n+         --  Follow a possible chain of renamings to reach the root renamed\n+         --  object.\n+\n+         while Present (Renamed_Object (Id)) loop\n+            if Is_Entity_Name (Renamed_Object (Id)) then\n+               Id := Entity (Renamed_Object (Id));\n+            else\n+               Id := Empty;\n+               exit;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      return Id;\n+   end Entity_Of;\n+\n    --------------------\n    -- Entry_Names_OK --\n    --------------------"}, {"sha": "68dc1882e0e8eb1297189e502b1708582db3a256", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=d45bc240af9aaa2e0b80b6c266f340b06138fcda", "patch": "@@ -349,6 +349,10 @@ package Exp_Util is\n    --  used to ensure that an Itype is properly defined outside a conditional\n    --  construct when it is referenced in more than one branch.\n \n+   function Entity_Of (N : Node_Id) return Entity_Id;\n+   --  Return the entity of N or Empty. If N is a renaming, return the entity\n+   --  of the root renamed object.\n+\n    function Entry_Names_OK return Boolean;\n    --  Determine whether it is appropriate to dynamically allocate strings\n    --  which represent entry [family member] names. These strings are created"}, {"sha": "27cd8d564e1eb1ca65fc93e138ef0c415916f29e", "filename": "gcc/ada/g-spipat.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2Fg-spipat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2Fg-spipat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.ads?ref=d45bc240af9aaa2e0b80b6c266f340b06138fcda", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1997-2010, AdaCore                     --\n+--                     Copyright (C) 1997-2013, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -729,7 +729,7 @@ package GNAT.Spitbol.Patterns is\n    function \"*\" (P : PString; Var : VString_Var)  return Pattern;\n    function \"*\" (P : PChar;   Var : VString_Var)  return Pattern;\n    --  Matches P, and if the match succeeds, assigns the matched substring\n-   --  to the given VString variable S. This assignment happens as soon as\n+   --  to the given VString variable Var. This assignment happens as soon as\n    --  the substring is matched, and if the pattern P1 is matched more than\n    --  once during the course of the match, then the assignment will occur\n    --  more than once."}, {"sha": "c581fc6fed9c2b5c48c49bef96eac362c9f484d0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 23, "deletions": 52, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45bc240af9aaa2e0b80b6c266f340b06138fcda/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d45bc240af9aaa2e0b80b6c266f340b06138fcda", "patch": "@@ -8917,11 +8917,6 @@ package body Sem_Prag is\n             --  Verify the legality of a single dependency clause. Flag Is_Last\n             --  denotes whether Clause is the last clause in the relation.\n \n-            function Entity_Of (N : Node_Id) return Entity_Id;\n-            --  Return the entity of N or Empty. If N is a renaming, find the\n-            --  entity of the root renamed object.\n-            --  Surely this should not be buried here??? exp_util???\n-\n             procedure Normalize_Clause (Clause : Node_Id);\n             --  Remove a self-dependency \"+\" from the input list of a clause.\n             --  Depending on the contents of the relation, either split the\n@@ -9202,34 +9197,6 @@ package body Sem_Prag is\n                Analyze_Input_List (Inputs);\n             end Analyze_Dependency_Clause;\n \n-            ---------------\n-            -- Entity_Of --\n-            ---------------\n-\n-            function Entity_Of (N : Node_Id) return Entity_Id is\n-               Id : Entity_Id;\n-\n-            begin\n-               --  Follow a possible chain of renamings to reach the root\n-               --  renamed object.\n-\n-               Id := Entity (N);\n-               while Present (Renamed_Object (Id)) loop\n-                  if Is_Entity_Name (Renamed_Object (Id)) then\n-                     Id := Entity (Renamed_Object (Id));\n-\n-                  --  The root of the renaming is not an entire object or\n-                  --  variable, return Empty.\n-\n-                  else\n-                     Id := Empty;\n-                     exit;\n-                  end if;\n-               end loop;\n-\n-               return Id;\n-            end Entity_Of;\n-\n             ----------------------\n             -- Normalize_Clause --\n             ----------------------\n@@ -9279,38 +9246,39 @@ package body Sem_Prag is\n                     (Output : Node_Id;\n                      Inputs : Node_Id)\n                   is\n-                     function Contains\n-                       (List : List_Id;\n-                        Id   : Entity_Id) return Boolean;\n-                     --  Determine whether List contains element Id\n-                     --  Surely this should not be buried here??? exp_Util???\n-\n-                     --------------\n-                     -- Contains --\n-                     --------------\n-\n-                     function Contains\n-                       (List : List_Id;\n-                        Id   : Entity_Id) return Boolean\n+                     function In_Input_List\n+                       (Item   : Entity_Id;\n+                        Inputs : List_Id) return Boolean;\n+                     --  Determine whether a particulat item appears in the\n+                     --  input list of a clause.\n+\n+                     -------------------\n+                     -- In_Input_List --\n+                     -------------------\n+\n+                     function In_Input_List\n+                       (Item   : Entity_Id;\n+                        Inputs : List_Id) return Boolean\n                      is\n                         Elmt : Node_Id;\n \n                      begin\n-                        Elmt := First (List);\n+                        Elmt := First (Inputs);\n                         while Present (Elmt) loop\n-                           if Entity_Of (Elmt) = Id then\n+                           if Entity_Of (Elmt) = Item then\n                               return True;\n                            end if;\n \n                            Next (Elmt);\n                         end loop;\n \n                         return False;\n-                     end Contains;\n+                     end In_Input_List;\n \n                      --  Local variables\n \n-                     Grouped : List_Id;\n+                     Output_Id : constant Entity_Id := Entity_Of (Output);\n+                     Grouped   : List_Id;\n \n                   --  Start of processing for Propagate_Output\n \n@@ -9340,7 +9308,10 @@ package body Sem_Prag is\n                      elsif Nkind (Inputs) = N_Aggregate then\n                         Grouped := Expressions (Inputs);\n \n-                        if not Contains (Grouped, Entity_Of (Output)) then\n+                        if not In_Input_List\n+                                 (Item   => Output_Id,\n+                                  Inputs => Grouped)\n+                        then\n                            Prepend_To (Grouped, New_Copy_Tree (Output));\n                         end if;\n \n@@ -9353,7 +9324,7 @@ package body Sem_Prag is\n \n                      --    (Output => (Output, Input))\n \n-                     elsif Entity_Of (Output) /= Entity_Of (Inputs) then\n+                     elsif Entity_Of (Inputs) /= Output_Id then\n                         Rewrite (Inputs,\n                           Make_Aggregate (Loc,\n                             Expressions => New_List ("}]}