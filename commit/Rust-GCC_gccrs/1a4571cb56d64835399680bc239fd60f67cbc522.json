{"sha": "1a4571cb56d64835399680bc239fd60f67cbc522", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0NTcxY2I1NmQ2NDgzNTM5OTY4MGJjMjM5ZmQ2MGY2N2NiYzUyMg==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2011-11-16T15:01:47Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2011-11-16T15:01:47Z"}, "message": "re PR tree-optimization/49960 (inconsistent outputs when enabling autopar for a self -dependence testcase)\n\n\tPR tree-optimization/49960\n\n\t* tree-data-ref.c (initialize_data_dependence_relation): Add initializations. \n\tRemove call to compute_self_dependence.\n\t(compute_affine_dependence): Remove the !DDR_SELF_REFERENCE condition.\n\t(compute_self_dependence): Remove old code. Add call to compute_affine_dependence.\n\t(compute_all_dependences): Remove call to compute_self_dependence. \n\tAdd call to compute_affine_dependence.\n\nFrom-SVN: r181411", "tree": {"sha": "d1032885f663e72fc38ff79f74fb1d4ca1fbe518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1032885f663e72fc38ff79f74fb1d4ca1fbe518"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a4571cb56d64835399680bc239fd60f67cbc522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4571cb56d64835399680bc239fd60f67cbc522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4571cb56d64835399680bc239fd60f67cbc522", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4571cb56d64835399680bc239fd60f67cbc522/comments", "author": null, "committer": null, "parents": [{"sha": "4122ed2b77469397257b997e9b0e41ad2fe2945f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4122ed2b77469397257b997e9b0e41ad2fe2945f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4122ed2b77469397257b997e9b0e41ad2fe2945f"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "f787912a5a1b190ff97c566b4fc2ce694df0c401", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4571cb56d64835399680bc239fd60f67cbc522/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4571cb56d64835399680bc239fd60f67cbc522/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a4571cb56d64835399680bc239fd60f67cbc522", "patch": "@@ -1,3 +1,13 @@\n+2011-11-16  Razya Ladelsky  <razya@il.ibm.com>\n+\t\n+\tPR tree-optimization/49960\n+\t* tree-data-ref.c (initialize_data_dependence_relation): Add initializations. \n+\tRemove call to compute_self_dependence.\n+\t(compute_affine_dependence): Remove the !DDR_SELF_REFERENCE condition.\n+\t(compute_self_dependence): Remove old code. Add call to compute_affine_dependence.\n+\t(compute_all_dependences): Remove call to compute_self_dependence. \n+\tAdd call to compute_affine_dependence.\n+\n 2011-11-16  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \tPR middle-end/50325"}, {"sha": "565bf57b7522b150e6b0b5ad8466a4c188eba360", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4571cb56d64835399680bc239fd60f67cbc522/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4571cb56d64835399680bc239fd60f67cbc522/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=1a4571cb56d64835399680bc239fd60f67cbc522", "patch": "@@ -1389,13 +1389,30 @@ initialize_data_dependence_relation (struct data_reference *a,\n      the data dependence tests, just initialize the ddr and return.  */\n   if (operand_equal_p (DR_REF (a), DR_REF (b), 0))\n     {\n+     if (loop_nest\n+        && !object_address_invariant_in_loop_p (VEC_index (loop_p, loop_nest, 0),\n+       \t\t\t\t\t        DR_BASE_OBJECT (a)))\n+      {\n+        DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n+        return res;\n+      }\n       DDR_AFFINE_P (res) = true;\n       DDR_ARE_DEPENDENT (res) = NULL_TREE;\n       DDR_SUBSCRIPTS (res) = VEC_alloc (subscript_p, heap, DR_NUM_DIMENSIONS (a));\n       DDR_LOOP_NEST (res) = loop_nest;\n       DDR_INNER_LOOP (res) = 0;\n       DDR_SELF_REFERENCE (res) = true;\n-      compute_self_dependence (res);\n+      for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n+       {\n+         struct subscript *subscript;\n+\n+         subscript = XNEW (struct subscript);\n+         SUB_CONFLICTS_IN_A (subscript) = conflict_fn_not_known ();\n+         SUB_CONFLICTS_IN_B (subscript) = conflict_fn_not_known ();\n+         SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n+         SUB_DISTANCE (subscript) = chrec_dont_know;\n+         VEC_safe_push (subscript_p, heap, DDR_SUBSCRIPTS (res), subscript);\n+       }\n       return res;\n     }\n \n@@ -4040,8 +4057,7 @@ compute_affine_dependence (struct data_dependence_relation *ddr,\n     }\n \n   /* Analyze only when the dependence relation is not yet known.  */\n-  if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE\n-      && !DDR_SELF_REFERENCE (ddr))\n+  if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n     {\n       dependence_stats.num_dependence_tests++;\n \n@@ -4122,31 +4138,11 @@ compute_affine_dependence (struct data_dependence_relation *ddr,\n void\n compute_self_dependence (struct data_dependence_relation *ddr)\n {\n-  unsigned int i;\n-  struct subscript *subscript;\n-\n   if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n     return;\n \n-  for (i = 0; VEC_iterate (subscript_p, DDR_SUBSCRIPTS (ddr), i, subscript);\n-       i++)\n-    {\n-      if (SUB_CONFLICTS_IN_A (subscript))\n-\tfree_conflict_function (SUB_CONFLICTS_IN_A (subscript));\n-      if (SUB_CONFLICTS_IN_B (subscript))\n-\tfree_conflict_function (SUB_CONFLICTS_IN_B (subscript));\n-\n-      /* The accessed index overlaps for each iteration.  */\n-      SUB_CONFLICTS_IN_A (subscript)\n-\t= conflict_fn (1, affine_fn_cst (integer_zero_node));\n-      SUB_CONFLICTS_IN_B (subscript)\n-\t= conflict_fn (1, affine_fn_cst (integer_zero_node));\n-      SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n-    }\n-\n-  /* The distance vector is the zero vector.  */\n-  save_dist_v (ddr, lambda_vector_new (DDR_NB_LOOPS (ddr)));\n-  save_dir_v (ddr, lambda_vector_new (DDR_NB_LOOPS (ddr)));\n+  if (DDR_LOOP_NEST (ddr))\n+    compute_affine_dependence (ddr, VEC_index (loop_p, DDR_LOOP_NEST (ddr), 0));\n }\n \n /* Compute in DEPENDENCE_RELATIONS the data dependence graph for all\n@@ -4179,7 +4175,8 @@ compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n       {\n \tddr = initialize_data_dependence_relation (a, a, loop_nest);\n \tVEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n-\tcompute_self_dependence (ddr);\n+        if (loop_nest)\n+   \t  compute_affine_dependence (ddr, VEC_index (loop_p, loop_nest, 0));\n       }\n }\n "}]}