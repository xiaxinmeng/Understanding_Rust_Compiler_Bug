{"sha": "8e7ffe126debfbc59e2d359ef3c37899327e2055", "node_id": "C_kwDOANBUbNoAKDhlN2ZmZTEyNmRlYmZiYzU5ZTJkMzU5ZWYzYzM3ODk5MzI3ZTIwNTU", "commit": {"author": {"name": "Christoph M\u00fcllner", "email": "christoph.muellner@vrull.eu", "date": "2022-08-08T15:48:20Z"}, "committer": {"name": "Philipp Tomsich", "email": "philipp.tomsich@vrull.eu", "date": "2023-03-15T08:58:18Z"}, "message": "riscv: thead: Add support for the XTheadCondMov ISA extensions\n\nThis patch adds support for XTheadCondMov ISA extension.\nThe extension brings a one-sided conditional move (no else-assignment).\nGiven that GCC has a great if-conversion pass, we don't need to do much,\nbesides properly expanding mov<mode>cc accordingly and adjust the cost\nmodel.\n\ngcc/ChangeLog:\n\n\t* config/riscv/iterators.md (TARGET_64BIT): Add GPR2 iterator.\n\t* config/riscv/riscv-protos.h (riscv_expand_conditional_move):\n\tAdd prototype.\n\t* config/riscv/riscv.cc (riscv_rtx_costs): Add costs for\n\tXTheadCondMov.\n\t(riscv_expand_conditional_move): New function.\n\t(riscv_expand_conditional_move_onesided): New function.\n\t* config/riscv/riscv.md: Add support for XTheadCondMov.\n\t* config/riscv/thead.md (*th_cond_mov<GPR:mode><GPR2:mode>): Add\n\tsupport for XTheadCondMov.\n\t(*th_cond_gpr_mov<GPR:mode><GPR2:mode>): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/riscv/xtheadcondmov-mveqz-imm-eqz.c: New test.\n\t* gcc.target/riscv/xtheadcondmov-mveqz-imm-not.c: New test.\n\t* gcc.target/riscv/xtheadcondmov-mveqz-reg-eqz.c: New test.\n\t* gcc.target/riscv/xtheadcondmov-mveqz-reg-not.c: New test.\n\t* gcc.target/riscv/xtheadcondmov-mvnez-imm-cond.c: New test.\n\t* gcc.target/riscv/xtheadcondmov-mvnez-imm-nez.c: New test.\n\t* gcc.target/riscv/xtheadcondmov-mvnez-reg-cond.c: New test.\n\t* gcc.target/riscv/xtheadcondmov-mvnez-reg-nez.c: New test.\n\nSigned-off-by: Christoph M\u00fcllner <christoph.muellner@vrull.eu>", "tree": {"sha": "a29473c96d4abd643c63ddaa1e9f7b520dde9359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a29473c96d4abd643c63ddaa1e9f7b520dde9359"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e7ffe126debfbc59e2d359ef3c37899327e2055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7ffe126debfbc59e2d359ef3c37899327e2055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7ffe126debfbc59e2d359ef3c37899327e2055", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7ffe126debfbc59e2d359ef3c37899327e2055/comments", "author": {"login": "cmuellner", "id": 92810, "node_id": "MDQ6VXNlcjkyODEw", "avatar_url": "https://avatars.githubusercontent.com/u/92810?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cmuellner", "html_url": "https://github.com/cmuellner", "followers_url": "https://api.github.com/users/cmuellner/followers", "following_url": "https://api.github.com/users/cmuellner/following{/other_user}", "gists_url": "https://api.github.com/users/cmuellner/gists{/gist_id}", "starred_url": "https://api.github.com/users/cmuellner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cmuellner/subscriptions", "organizations_url": "https://api.github.com/users/cmuellner/orgs", "repos_url": "https://api.github.com/users/cmuellner/repos", "events_url": "https://api.github.com/users/cmuellner/events{/privacy}", "received_events_url": "https://api.github.com/users/cmuellner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ptomsich", "id": 14983582, "node_id": "MDQ6VXNlcjE0OTgzNTgy", "avatar_url": "https://avatars.githubusercontent.com/u/14983582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptomsich", "html_url": "https://github.com/ptomsich", "followers_url": "https://api.github.com/users/ptomsich/followers", "following_url": "https://api.github.com/users/ptomsich/following{/other_user}", "gists_url": "https://api.github.com/users/ptomsich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptomsich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptomsich/subscriptions", "organizations_url": "https://api.github.com/users/ptomsich/orgs", "repos_url": "https://api.github.com/users/ptomsich/repos", "events_url": "https://api.github.com/users/ptomsich/events{/privacy}", "received_events_url": "https://api.github.com/users/ptomsich/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c493fa3892487c22d0bdd817361a02bd523fc2e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c493fa3892487c22d0bdd817361a02bd523fc2e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c493fa3892487c22d0bdd817361a02bd523fc2e7"}], "stats": {"total": 464, "additions": 440, "deletions": 24}, "files": [{"sha": "9b7670384523722dbfa985e7b0e9285008609254", "filename": "gcc/config/riscv/iterators.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fiterators.md?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -26,6 +26,10 @@\n ;; from the same template.\n (define_mode_iterator GPR [SI (DI \"TARGET_64BIT\")])\n \n+;; A copy of GPR that can be used when a pattern has two independent\n+;; modes.\n+(define_mode_iterator GPR2 [SI (DI \"TARGET_64BIT\")])\n+\n ;; This mode iterator allows :P to be used for patterns that operate on\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n (define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])"}, {"sha": "ac70d9c841a39aa4aab37a2c15497f8ad1bcdb9e", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -58,8 +58,8 @@ extern const char *riscv_output_return ();\n extern void riscv_expand_int_scc (rtx, enum rtx_code, rtx, rtx);\n extern void riscv_expand_float_scc (rtx, enum rtx_code, rtx, rtx);\n extern void riscv_expand_conditional_branch (rtx, enum rtx_code, rtx, rtx);\n-extern void riscv_expand_conditional_move (rtx, rtx, rtx, rtx_code, rtx, rtx);\n #endif\n+extern bool riscv_expand_conditional_move (rtx, rtx, rtx, rtx);\n extern rtx riscv_legitimize_call_address (rtx);\n extern void riscv_set_return_address (rtx, rtx);\n extern bool riscv_expand_block_move (rtx, rtx, rtx);"}, {"sha": "f5d83d72efa65abd9e81156a187461ea33998c24", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 86, "deletions": 14, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -2312,8 +2312,8 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN\n       return false;\n \n     case IF_THEN_ELSE:\n-      if (TARGET_SFB_ALU\n-\t  && register_operand (XEXP (x, 1), mode)\n+      if ((TARGET_SFB_ALU || TARGET_XTHEADCONDMOV)\n+\t  && reg_or_0_operand (XEXP (x, 1), mode)\n \t  && sfb_alu_operand (XEXP (x, 2), mode)\n \t  && comparison_operator (XEXP (x, 0), VOIDmode))\n \t{\n@@ -3111,13 +3111,30 @@ riscv_extend_comparands (rtx_code code, rtx *op0, rtx *op1)\n     }\n }\n \n-/* Convert a comparison into something that can be used in a branch.  On\n-   entry, *OP0 and *OP1 are the values being compared and *CODE is the code\n-   used to compare them.  Update them to describe the final comparison.  */\n+/* Convert a comparison into something that can be used in a branch or\n+   conditional move.  On entry, *OP0 and *OP1 are the values being\n+   compared and *CODE is the code used to compare them.\n+\n+   Update *CODE, *OP0 and *OP1 so that they describe the final comparison.\n+   If NEED_EQ_NE_P, then only EQ or NE comparisons against zero are\n+   emitted.  */\n \n static void\n-riscv_emit_int_compare (enum rtx_code *code, rtx *op0, rtx *op1)\n+riscv_emit_int_compare (enum rtx_code *code, rtx *op0, rtx *op1,\n+\t\t\tbool need_eq_ne_p = false)\n {\n+  if (need_eq_ne_p)\n+    {\n+      rtx cmp_op0 = *op0;\n+      rtx cmp_op1 = *op1;\n+      if (*code == EQ || *code == NE)\n+\t{\n+\t  *op0 = riscv_zero_if_equal (cmp_op0, cmp_op1);\n+\t  *op1 = const0_rtx;\n+\t  return;\n+\t}\n+    }\n+\n   if (splittable_const_int_operand (*op1, VOIDmode))\n     {\n       HOST_WIDE_INT rhs = INTVAL (*op1);\n@@ -3303,16 +3320,71 @@ riscv_expand_conditional_branch (rtx label, rtx_code code, rtx op0, rtx op1)\n   emit_jump_insn (gen_condjump (condition, label));\n }\n \n-/* If (CODE OP0 OP1) holds, move CONS to DEST; else move ALT to DEST.  */\n+/* Helper to emit two one-sided conditional moves for the movecc.  */\n \n-void\n-riscv_expand_conditional_move (rtx dest, rtx cons, rtx alt, rtx_code code,\n-\t\t\t       rtx op0, rtx op1)\n+static void\n+riscv_expand_conditional_move_onesided (rtx dest, rtx cons, rtx alt,\n+\t\t\t\t\trtx_code code, rtx op0, rtx op1)\n {\n-  riscv_emit_int_compare (&code, &op0, &op1);\n-  rtx cond = gen_rtx_fmt_ee (code, GET_MODE (op0), op0, op1);\n-  emit_insn (gen_rtx_SET (dest, gen_rtx_IF_THEN_ELSE (GET_MODE (dest), cond,\n-\t\t\t\t\t\t      cons, alt)));\n+  machine_mode mode = GET_MODE (dest);\n+\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n+  gcc_assert (reg_or_0_operand (cons, mode));\n+  gcc_assert (reg_or_0_operand (alt, mode));\n+\n+  riscv_emit_int_compare (&code, &op0, &op1, true);\n+  rtx cond = gen_rtx_fmt_ee (code, mode, op0, op1);\n+\n+  rtx tmp1 = gen_reg_rtx (mode);\n+  rtx tmp2 = gen_reg_rtx (mode);\n+\n+  emit_insn (gen_rtx_SET (tmp1, gen_rtx_IF_THEN_ELSE (mode, cond,\n+\t\t\t\t\t\t      cons, const0_rtx)));\n+\n+  /* We need to expand a sequence for both blocks and we do that such,\n+     that the second conditional move will use the inverted condition.\n+     We use temporaries that are or'd to the dest register.  */\n+  cond = gen_rtx_fmt_ee ((code == EQ) ? NE : EQ, mode, op0, op1);\n+  emit_insn (gen_rtx_SET (tmp2, gen_rtx_IF_THEN_ELSE (mode, cond,\n+\t\t\t\t\t\t      alt, const0_rtx)));\n+\n+  emit_insn (gen_rtx_SET (dest, gen_rtx_IOR (mode, tmp1, tmp2)));\n+ }\n+\n+/* Emit a cond move: If OP holds, move CONS to DEST; else move ALT to DEST.\n+   Return 0 if expansion failed.  */\n+\n+bool\n+riscv_expand_conditional_move (rtx dest, rtx op, rtx cons, rtx alt)\n+{\n+  machine_mode mode = GET_MODE (dest);\n+  rtx_code code = GET_CODE (op);\n+  rtx op0 = XEXP (op, 0);\n+  rtx op1 = XEXP (op, 1);\n+\n+  if (TARGET_XTHEADCONDMOV\n+      && GET_MODE_CLASS (mode) == MODE_INT\n+      && reg_or_0_operand (cons, mode)\n+      && reg_or_0_operand (alt, mode)\n+      && GET_MODE (op) == mode\n+      && GET_MODE (op0) == mode\n+      && GET_MODE (op1) == mode\n+      && (code == EQ || code == NE))\n+    {\n+      riscv_expand_conditional_move_onesided (dest, cons, alt, code, op0, op1);\n+      return true;\n+    }\n+  else if (TARGET_SFB_ALU\n+\t   && mode == word_mode)\n+    {\n+      riscv_emit_int_compare (&code, &op0, &op1);\n+      rtx cond = gen_rtx_fmt_ee (code, GET_MODE (op0), op0, op1);\n+      emit_insn (gen_rtx_SET (dest, gen_rtx_IF_THEN_ELSE (GET_MODE (dest),\n+\t\t\t\t\t\t\t  cond, cons, alt)));\n+      return true;\n+    }\n+\n+  return false;\n }\n \n /* Implement TARGET_FUNCTION_ARG_BOUNDARY.  Every parameter gets at"}, {"sha": "34d4a20dcf4437ab192e60a4283114f842fb4afa", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -242,6 +242,7 @@\n ;; bitmanip\tbit manipulation instructions\n ;; rotate   rotation instructions\n ;; atomic   atomic instructions\n+;; condmove\tconditional moves\n ;; crypto cryptography instructions\n ;; Classification of RVV instructions which will be added to each RVV .md pattern and used by scheduler.\n ;; rdvlenb     vector byte length vlenb csrr read\n@@ -339,7 +340,7 @@\n   \"unknown,branch,jump,call,load,fpload,store,fpstore,\n    mtc,mfc,const,arith,logical,shift,slt,imul,idiv,move,fmove,fadd,fmul,\n    fmadd,fdiv,fcmp,fcvt,fsqrt,multi,auipc,sfb_alu,nop,ghost,bitmanip,rotate,\n-   atomic,crypto,rdvlenb,rdvl,vsetvl,vlde,vste,vldm,vstm,vlds,vsts,\n+   atomic,condmove,crypto,rdvlenb,rdvl,vsetvl,vlde,vste,vldm,vstm,vlds,vsts,\n    vldux,vldox,vstux,vstox,vldff,vldr,vstr,\n    vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,viminmax,\n    vimul,vidiv,viwmul,vimuladd,viwmuladd,vimerge,vimov,\n@@ -2317,17 +2318,15 @@\n (define_expand \"mov<mode>cc\"\n   [(set (match_operand:GPR 0 \"register_operand\")\n \t(if_then_else:GPR (match_operand 1 \"comparison_operator\")\n-\t\t\t  (match_operand:GPR 2 \"register_operand\")\n+\t\t\t  (match_operand:GPR 2 \"reg_or_0_operand\")\n \t\t\t  (match_operand:GPR 3 \"sfb_alu_operand\")))]\n-  \"TARGET_SFB_ALU\"\n+  \"TARGET_SFB_ALU || TARGET_XTHEADCONDMOV\"\n {\n-  rtx cmp = operands[1];\n-  /* We only handle word mode integer compares for now.  */\n-  if (GET_MODE (XEXP (cmp, 0)) != word_mode)\n+  if (riscv_expand_conditional_move (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]))\n+    DONE;\n+  else\n     FAIL;\n-  riscv_expand_conditional_move (operands[0], operands[2], operands[3],\n-\t\t\t\t GET_CODE (cmp), XEXP (cmp, 0), XEXP (cmp, 1));\n-  DONE;\n })\n \n (define_insn \"*mov<GPR:mode><X:mode>cc\""}, {"sha": "88b6a95e993005c7157ff4fd0dc6af06687283b1", "filename": "gcc/config/riscv/thead.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Fthead.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Fconfig%2Friscv%2Fthead.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fthead.md?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -101,3 +101,40 @@\n   \"TARGET_XTHEADBS && UINTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode)\"\n   \"th.tst\\t%0,%1,%2\"\n   [(set_attr \"type\" \"bitmanip\")])\n+\n+;; XTheadCondMov\n+\n+(define_insn \"*th_cond_mov<GPR:mode><GPR2:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r,r\")\n+\t(if_then_else:GPR\n+\t (match_operator 4 \"equality_operator\"\n+\t\t[(match_operand:GPR2 1 \"register_operand\" \"r,r\")\n+\t\t (const_int 0)])\n+\t (match_operand:GPR 2 \"reg_or_0_operand\" \"rJ,0\")\n+\t (match_operand:GPR 3 \"reg_or_0_operand\" \"0,rJ\")))]\n+  \"TARGET_XTHEADCONDMOV\"\n+{\n+  if (which_alternative == 0)\n+    return \"th.mv%C4z\\t%0,%z2,%1\";\n+\n+  /* Invert the condition and take else-block.  */\n+  rtx_code code = GET_CODE (operands[4]);\n+  code = (code == EQ) ? NE : EQ;\n+  operands[4] = gen_rtx_fmt_ee (code, VOIDmode, const0_rtx, const0_rtx);\n+  return \"th.mv%C4z\\t%0,%z3,%1\";\n+}\n+  [(set_attr \"type\" \"condmove\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n+\n+(define_insn \"*th_cond_gpr_mov<GPR:mode><GPR2:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r,r\")\n+\t(if_then_else:GPR\n+\t (match_operand:GPR2 1 \"register_operand\" \"r,r\")\n+\t (match_operand:GPR 2 \"reg_or_0_operand\" \"rJ,0\")\n+\t (match_operand:GPR 3 \"reg_or_0_operand\" \"0,rJ\")))]\n+  \"TARGET_XTHEADCONDMOV\"\n+  \"@\n+   th.mvnez\\t%0,%z2,%1\n+   th.mveqz\\t%0,%z3,%1\"\n+  [(set_attr \"type\" \"condmove\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")])"}, {"sha": "913ae43f21b525d03dc540aeabfa88bac8a868f3", "filename": "gcc/testsuite/gcc.target/riscv/xtheadcondmov-mveqz-imm-eqz.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-imm-eqz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-imm-eqz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-imm-eqz.c?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc_xtheadcondmov\" { target { rv32 } } } */\n+/* { dg-options \"-march=rv64gc_xtheadcondmov\" { target { rv64 } } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Og\" } } */\n+\n+int\n+not_int_int (int x, int cond)\n+{\n+  if (cond == 0)\n+    return 1025;\n+  return x;\n+}\n+\n+long\n+not_long_int (long x, int cond)\n+{\n+  if (cond == 0)\n+    return 1025l;\n+  return x;\n+}\n+\n+int\n+not_int_long (int x, long cond)\n+{\n+  if (cond == 0)\n+    return 1025;\n+  return x;\n+}\n+\n+long\n+not_long_long (long x, int cond)\n+{\n+  if (cond == 0)\n+    return 1025l;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.mveqz\" 4 } } */"}, {"sha": "1bc8b83823359231c21e322e2f935703ad838db1", "filename": "gcc/testsuite/gcc.target/riscv/xtheadcondmov-mveqz-imm-not.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-imm-not.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-imm-not.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-imm-not.c?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc_xtheadcondmov\" { target { rv32 } } } */\n+/* { dg-options \"-march=rv64gc_xtheadcondmov\" { target { rv64 } } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Og\" } } */\n+\n+int\n+not_int_int (int x, int cond)\n+{\n+  if (!cond)\n+    return 1025;\n+  return x;\n+}\n+\n+long\n+not_long_int (long x, int cond)\n+{\n+  if (!cond)\n+    return 1025l;\n+  return x;\n+}\n+\n+int\n+not_int_long (int x, long cond)\n+{\n+  if (!cond)\n+    return 1025;\n+  return x;\n+}\n+\n+long\n+not_long_long (long x, int cond)\n+{\n+  if (!cond)\n+    return 1025l;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.mveqz\" 4 } } */"}, {"sha": "8ef5869a89b687720a3771469c35aac03d037640", "filename": "gcc/testsuite/gcc.target/riscv/xtheadcondmov-mveqz-reg-eqz.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-reg-eqz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-reg-eqz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-reg-eqz.c?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc_xtheadcondmov\" { target { rv32 } } } */\n+/* { dg-options \"-march=rv64gc_xtheadcondmov\" { target { rv64 } } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Og\" } } */\n+\n+int\n+not_int_int (int x, int cond, int v)\n+{\n+  if (cond == 0)\n+    return v;\n+  return x;\n+}\n+\n+long\n+not_long_int (long x, int cond, long v)\n+{\n+  if (cond == 0)\n+    return v;\n+  return x;\n+}\n+\n+int\n+not_int_long (int x, long cond, int v)\n+{\n+  if (cond == 0)\n+    return v;\n+  return x;\n+}\n+\n+long\n+not_long_long (long x, int cond, long v)\n+{\n+  if (cond == 0)\n+    return v;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.mveqz\" 4 } } */"}, {"sha": "f9568bee27fc5286bf3fa6834a6a89fb61db8232", "filename": "gcc/testsuite/gcc.target/riscv/xtheadcondmov-mveqz-reg-not.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-reg-not.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-reg-not.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mveqz-reg-not.c?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc_xtheadcondmov\" { target { rv32 } } } */\n+/* { dg-options \"-march=rv64gc_xtheadcondmov\" { target { rv64 } } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Og\" } } */\n+\n+int\n+not_int_int (int x, int cond, int v)\n+{\n+  if (!cond)\n+    return v;\n+  return x;\n+}\n+\n+long\n+not_long_int (long x, int cond, long v)\n+{\n+  if (!cond)\n+    return v;\n+  return x;\n+}\n+\n+int\n+not_int_long (int x, long cond, int v)\n+{\n+  if (!cond)\n+    return v;\n+  return x;\n+}\n+\n+long\n+not_long_long (long x, int cond, long v)\n+{\n+  if (!cond)\n+    return v;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.mveqz\" 4 } } */"}, {"sha": "8feddbeb79d906a00570be40c87cca57342ccf77", "filename": "gcc/testsuite/gcc.target/riscv/xtheadcondmov-mvnez-imm-cond.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-imm-cond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-imm-cond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-imm-cond.c?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc_xtheadcondmov\" { target { rv32 } } } */\n+/* { dg-options \"-march=rv64gc_xtheadcondmov\" { target { rv64 } } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Og\" } } */\n+\n+int\n+not_int_int (int x, int cond)\n+{\n+  if (cond)\n+    return 1025;\n+  return x;\n+}\n+\n+long\n+not_long_int (long x, int cond)\n+{\n+  if (cond)\n+    return 1025l;\n+  return x;\n+}\n+\n+int\n+not_int_long (int x, long cond)\n+{\n+  if (cond)\n+    return 1025;\n+  return x;\n+}\n+\n+long\n+not_long_long (long x, int cond)\n+{\n+  if (cond)\n+    return 1025l;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.mvnez\" 4 } } */"}, {"sha": "7c08e20c25dbcd703efb61e278ae170d96578e6f", "filename": "gcc/testsuite/gcc.target/riscv/xtheadcondmov-mvnez-imm-nez.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-imm-nez.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-imm-nez.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-imm-nez.c?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc_xtheadcondmov\" { target { rv32 } } } */\n+/* { dg-options \"-march=rv64gc_xtheadcondmov\" { target { rv64 } } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Og\" } } */\n+\n+int\n+not_int_int (int x, int cond)\n+{\n+  if (cond != 0)\n+    return 1025;\n+  return x;\n+}\n+\n+long\n+not_long_int (long x, int cond)\n+{\n+  if (cond != 0)\n+    return 1025l;\n+  return x;\n+}\n+\n+int\n+not_int_long (int x, long cond)\n+{\n+  if (cond != 0)\n+    return 1025;\n+  return x;\n+}\n+\n+long\n+not_long_long (long x, int cond)\n+{\n+  if (cond != 0)\n+    return 1025l;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.mvnez\" 4 } } */"}, {"sha": "c1619509af93c64d826ee9ddeba6a3b96890589f", "filename": "gcc/testsuite/gcc.target/riscv/xtheadcondmov-mvnez-reg-cond.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-reg-cond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-reg-cond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-reg-cond.c?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc_xtheadcondmov\" { target { rv32 } } } */\n+/* { dg-options \"-march=rv64gc_xtheadcondmov\" { target { rv64 } } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Og\" } } */\n+\n+int\n+not_int_int (int x, int cond, int v)\n+{\n+  if (cond)\n+    return v;\n+  return x;\n+}\n+\n+long\n+not_long_int (long x, int cond, long v)\n+{\n+  if (cond)\n+    return v;\n+  return x;\n+}\n+\n+int\n+not_int_long (int x, long cond, int v)\n+{\n+  if (cond)\n+    return v;\n+  return x;\n+}\n+\n+long\n+not_long_long (long x, int cond, long v)\n+{\n+  if (cond)\n+    return v;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.mvnez\" 4 } } */"}, {"sha": "ff95a57927a665c8ea181e3d9379a5292576729e", "filename": "gcc/testsuite/gcc.target/riscv/xtheadcondmov-mvnez-reg-nez.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-reg-nez.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7ffe126debfbc59e2d359ef3c37899327e2055/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-reg-nez.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadcondmov-mvnez-reg-nez.c?ref=8e7ffe126debfbc59e2d359ef3c37899327e2055", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gc_xtheadcondmov\" { target { rv32 } } } */\n+/* { dg-options \"-march=rv64gc_xtheadcondmov\" { target { rv64 } } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Og\" } } */\n+\n+int\n+not_int_int (int x, int cond, int v)\n+{\n+  if (cond != 0)\n+    return v;\n+  return x;\n+}\n+\n+long\n+not_long_int (long x, int cond, long v)\n+{\n+  if (cond != 0)\n+    return v;\n+  return x;\n+}\n+\n+int\n+not_int_long (int x, long cond, int v)\n+{\n+  if (cond != 0)\n+    return v;\n+  return x;\n+}\n+\n+long\n+not_long_long (long x, int cond, long v)\n+{\n+  if (cond != 0)\n+    return v;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.mvnez\" 4 } } */"}]}