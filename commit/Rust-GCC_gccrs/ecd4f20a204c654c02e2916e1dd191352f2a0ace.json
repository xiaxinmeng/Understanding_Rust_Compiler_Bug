{"sha": "ecd4f20a204c654c02e2916e1dd191352f2a0ace", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNkNGYyMGEyMDRjNjU0YzAyZTI5MTZlMWRkMTkxMzUyZjJhMGFjZQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2013-03-08T14:41:14Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2013-03-08T14:41:14Z"}, "message": "re PR tree-optimization/56478 (ICE: Floating point exception in tree_estimate_probability)\n\nPR tree-optimization/56478\n* predict.c (is_comparison_with_loop_invariant_p): Change the \ntype of loop_step to tree.\n(predict_loops): Adjust.\n(predict_iv_comparison): Perform the computations on double_ints.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r196547", "tree": {"sha": "47714c3957a3de74b77615d27f99e3a15998170a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47714c3957a3de74b77615d27f99e3a15998170a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecd4f20a204c654c02e2916e1dd191352f2a0ace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecd4f20a204c654c02e2916e1dd191352f2a0ace", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecd4f20a204c654c02e2916e1dd191352f2a0ace", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecd4f20a204c654c02e2916e1dd191352f2a0ace/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64366d35581a1d81d77b8ae5f8e0b393f2636852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64366d35581a1d81d77b8ae5f8e0b393f2636852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64366d35581a1d81d77b8ae5f8e0b393f2636852"}], "stats": {"total": 128, "additions": 99, "deletions": 29}, "files": [{"sha": "762bc08792f3b392c3a17567a732055fe243e251", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd4f20a204c654c02e2916e1dd191352f2a0ace/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd4f20a204c654c02e2916e1dd191352f2a0ace/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecd4f20a204c654c02e2916e1dd191352f2a0ace", "patch": "@@ -1,3 +1,12 @@\n+2013-03-08  Marek Polacek  <polacek@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/56478\n+\t* predict.c (is_comparison_with_loop_invariant_p): Change the\n+\ttype of loop_step to tree.\n+\t(predict_loops): Adjust.\n+\t(predict_iv_comparison): Perform the computations on double_ints.\n+\n 2013-03-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/56570"}, {"sha": "57975d18da0bbedc93ff49cc8d695cbb8d52cb76", "filename": "gcc/predict.c", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd4f20a204c654c02e2916e1dd191352f2a0ace/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd4f20a204c654c02e2916e1dd191352f2a0ace/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ecd4f20a204c654c02e2916e1dd191352f2a0ace", "patch": "@@ -1028,13 +1028,13 @@ static bool\n is_comparison_with_loop_invariant_p (gimple stmt, struct loop *loop,\n \t\t\t\t     tree *loop_invariant,\n \t\t\t\t     enum tree_code *compare_code,\n-\t\t\t\t     int *loop_step,\n+\t\t\t\t     tree *loop_step,\n \t\t\t\t     tree *loop_iv_base)\n {\n   tree op0, op1, bound, base;\n   affine_iv iv0, iv1;\n   enum tree_code code;\n-  int step;\n+  tree step;\n \n   code = gimple_cond_code (stmt);\n   *loop_invariant = NULL;\n@@ -1077,7 +1077,7 @@ is_comparison_with_loop_invariant_p (gimple stmt, struct loop *loop,\n       bound = iv0.base;\n       base = iv1.base;\n       if (host_integerp (iv1.step, 0))\n-\tstep = tree_low_cst (iv1.step, 0);\n+\tstep = iv1.step;\n       else\n \treturn false;\n     }\n@@ -1086,7 +1086,7 @@ is_comparison_with_loop_invariant_p (gimple stmt, struct loop *loop,\n       bound = iv1.base;\n       base = iv0.base;\n       if (host_integerp (iv0.step, 0))\n-\tstep = tree_low_cst (iv0.step, 0);  \n+\tstep = iv0.step;\n       else\n \treturn false;\n     }\n@@ -1178,7 +1178,7 @@ predict_iv_comparison (struct loop *loop, basic_block bb,\n   gimple stmt;\n   tree compare_var, compare_base;\n   enum tree_code compare_code;\n-  int compare_step;\n+  tree compare_step_var;\n   edge then_edge;\n   edge_iterator ei;\n \n@@ -1192,7 +1192,7 @@ predict_iv_comparison (struct loop *loop, basic_block bb,\n     return;\n   if (!is_comparison_with_loop_invariant_p (stmt, loop, &compare_var,\n \t\t\t\t\t    &compare_code,\n-\t\t\t\t\t    &compare_step,\n+\t\t\t\t\t    &compare_step_var,\n \t\t\t\t\t    &compare_base))\n     return;\n \n@@ -1224,34 +1224,78 @@ predict_iv_comparison (struct loop *loop, basic_block bb,\n       && host_integerp (compare_base, 0))\n     {\n       int probability;\n-      HOST_WIDE_INT compare_count;\n-      HOST_WIDE_INT loop_bound = tree_low_cst (loop_bound_var, 0);\n-      HOST_WIDE_INT compare_bound = tree_low_cst (compare_var, 0);\n-      HOST_WIDE_INT base = tree_low_cst (compare_base, 0);\n-      HOST_WIDE_INT loop_count = (loop_bound - base) / compare_step;\n-\n-      if ((compare_step > 0)\n+      bool of, overflow = false;\n+      double_int mod, compare_count, tem, loop_count;\n+\n+      double_int loop_bound = tree_to_double_int (loop_bound_var);\n+      double_int compare_bound = tree_to_double_int (compare_var);\n+      double_int base = tree_to_double_int (compare_base);\n+      double_int compare_step = tree_to_double_int (compare_step_var);\n+\n+      /* (loop_bound - base) / compare_step */\n+      tem = loop_bound.sub_with_overflow (base, &of);\n+      overflow |= of;\n+      loop_count = tem.divmod_with_overflow (compare_step,\n+\t\t\t\t\t      0, TRUNC_DIV_EXPR,\n+\t\t\t\t\t      &mod, &of);\n+      overflow |= of;\n+\n+      if ((!compare_step.is_negative ())\n           ^ (compare_code == LT_EXPR || compare_code == LE_EXPR))\n-\tcompare_count = (loop_bound - compare_bound) / compare_step;\n+\t{\n+\t  /* (loop_bound - compare_bound) / compare_step */\n+\t  tem = loop_bound.sub_with_overflow (compare_bound, &of);\n+\t  overflow |= of;\n+\t  compare_count = tem.divmod_with_overflow (compare_step,\n+\t\t\t\t\t\t     0, TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t     &mod, &of);\n+\t  overflow |= of;\n+\t}\n       else\n-\tcompare_count = (compare_bound - base) / compare_step;\n-\n+        {\n+\t  /* (compare_bound - base) / compare_step */\n+\t  tem = compare_bound.sub_with_overflow (base, &of);\n+\t  overflow |= of;\n+          compare_count = tem.divmod_with_overflow (compare_step,\n+\t\t\t\t\t\t     0, TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t     &mod, &of);\n+\t  overflow |= of;\n+\t}\n       if (compare_code == LE_EXPR || compare_code == GE_EXPR)\n-\tcompare_count ++;\n+\t++compare_count;\n       if (loop_bound_code == LE_EXPR || loop_bound_code == GE_EXPR)\n-\tloop_count ++;\n-      if (compare_count < 0)\n-\tcompare_count = 0;\n-      if (loop_count < 0)\n-\tloop_count = 0;\n-\n-      if (loop_count == 0)\n+\t++loop_count;\n+      if (compare_count.is_negative ())\n+        compare_count = double_int_zero;\n+      if (loop_count.is_negative ())\n+        loop_count = double_int_zero;\n+      if (loop_count.is_zero ())\n \tprobability = 0;\n-      else if (compare_count > loop_count)\n+      else if (compare_count.scmp (loop_count) == 1)\n \tprobability = REG_BR_PROB_BASE;\n       else\n-\tprobability = (double) REG_BR_PROB_BASE * compare_count / loop_count;\n-      predict_edge (then_edge, PRED_LOOP_IV_COMPARE, probability);\n+        {\n+\t  /* If loop_count is too big, such that REG_BR_PROB_BASE * loop_count\n+\t     could overflow, shift both loop_count and compare_count right\n+\t     a bit so that it doesn't overflow.  Note both counts are known not\n+\t     to be negative at this point.  */\n+\t  int clz_bits = clz_hwi (loop_count.high);\n+\t  gcc_assert (REG_BR_PROB_BASE < 32768);\n+\t  if (clz_bits < 16)\n+\t    {\n+\t      loop_count.arshift (16 - clz_bits, HOST_BITS_PER_DOUBLE_INT);\n+\t      compare_count.arshift (16 - clz_bits, HOST_BITS_PER_DOUBLE_INT);\n+\t    }\n+\t  tem = compare_count.mul_with_sign (double_int::from_shwi\n+\t\t\t\t\t    (REG_BR_PROB_BASE), true, &of);\n+\t  gcc_assert (!of);\n+\t  tem = tem.divmod (loop_count, true, TRUNC_DIV_EXPR, &mod);\n+\t  probability = tem.to_uhwi ();\n+\t}\n+\n+      if (!overflow)\n+        predict_edge (then_edge, PRED_LOOP_IV_COMPARE, probability);\n+\n       return;\n     }\n \n@@ -1402,7 +1446,7 @@ predict_loops (void)\n       edge ex;\n       struct nb_iter_bound *nb_iter;\n       enum tree_code loop_bound_code = ERROR_MARK;\n-      int loop_bound_step = 0;\n+      tree loop_bound_step = NULL;\n       tree loop_bound_var = NULL;\n       tree loop_iv_base = NULL;\n       gimple stmt = NULL;\n@@ -1549,7 +1593,7 @@ predict_loops (void)\n \t  if (loop_bound_var)\n \t    predict_iv_comparison (loop, bb, loop_bound_var, loop_iv_base,\n \t\t\t\t   loop_bound_code,\n-\t\t\t\t   loop_bound_step);\n+\t\t\t\t   tree_low_cst (loop_bound_step, 0));\n \t}\n \n       /* Free basic blocks from get_loop_body.  */"}, {"sha": "feb546f083cfa14e35725bb2535869c4b51dff25", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd4f20a204c654c02e2916e1dd191352f2a0ace/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd4f20a204c654c02e2916e1dd191352f2a0ace/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ecd4f20a204c654c02e2916e1dd191352f2a0ace", "patch": "@@ -1,3 +1,8 @@\n+2013-03-08  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR tree-optimization/56478\n+\t* gcc.dg/torture/pr56478.c: New test.\n+\n 2013-03-08  Kai Tietz  <ktietz@redhat.com>\n \n \t* gcc.c-torture/execute/builtins/builtins.exp: Add for mingw"}, {"sha": "506204e8b5413864b9ea4231cd6f7d51b0201f2d", "filename": "gcc/testsuite/gcc.dg/torture/pr56478.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd4f20a204c654c02e2916e1dd191352f2a0ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56478.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd4f20a204c654c02e2916e1dd191352f2a0ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56478.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56478.c?ref=ecd4f20a204c654c02e2916e1dd191352f2a0ace", "patch": "@@ -0,0 +1,12 @@\n+/* PR tree-optimization/56478 */\n+/* { dg-do compile } */\n+\n+int a;\n+\n+void\n+foo ()\n+{\n+  int b;\n+  for (b = 0;; b++)\n+    a = 0 < -__LONG_LONG_MAX__ - 1 - b ? : 0;\n+}"}]}