{"sha": "7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkxM2YzZDAyOGFhYTQ5MGJiNmNhZDg4MTdmMWQwYmEyNWQ1OTcwZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-01-26T02:06:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-26T02:06:21Z"}, "message": "tree.def (UNNE_EXPR): Remove.\n\n        * tree.def (UNNE_EXPR): Remove.\n        * c-typeck.c (build_binary_op): Don't handle it.\n        * expr.c (expand_expr, do_jump, do_store_flag): Likewise.\n        * cp/typeck.c (build_binary_op_nodefault): Likewise.\n\n        * rtl.def (UNNE): Remove.\n        (LTGT): Add.\n        * jump.c (reverse_condition): Update accordingly.\n        (swap_condition): Likewise.\n        (comparison_dominates_p): Handle unordered comparisons.\n        (reverse_condition_maybe_unordered): New.\n        * rtl.h (reverse_condition_maybe_unordered): Declare.\n\n        * sparc.c (select_cc_mode): Update for UNNE/LTGT.\n        (output_cbranch): Use reverse_condition_maybe_unordered and LTGT.\n        * sparc.h (REVERSIBLE_CC_MODE): Always true.  Update docs.\n        * sparc.md (bltgt): New.\n\nFrom-SVN: r31624", "tree": {"sha": "c6229116cfdf9e594c081b7617483b79b2816773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6229116cfdf9e594c081b7617483b79b2816773"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/comments", "author": null, "committer": null, "parents": [{"sha": "78340c9f9f483059136fd427139050754e210bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78340c9f9f483059136fd427139050754e210bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78340c9f9f483059136fd427139050754e210bf4"}], "stats": {"total": 212, "additions": 133, "deletions": 79}, "files": [{"sha": "644ba3ed1484cb800af218080d67478a0ed40729", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -1,3 +1,22 @@\n+2000-01-25  Richard Henderson  <rth@cygnus.com>\n+\n+\t* tree.def (UNNE_EXPR): Remove.\n+\t* c-typeck.c (build_binary_op): Don't handle it.\n+\t* expr.c (expand_expr, do_jump, do_store_flag): Likewise.\n+\n+\t* rtl.def (UNNE): Remove.\n+\t(LTGT): Add.\n+\t* jump.c (reverse_condition): Update accordingly.\n+\t(swap_condition): Likewise.\n+\t(comparison_dominates_p): Handle unordered comparisons.\n+\t(reverse_condition_maybe_unordered): New.\n+\t* rtl.h (reverse_condition_maybe_unordered): Declare.\n+\n+\t* sparc.c (select_cc_mode): Update for UNNE/LTGT.\n+\t(output_cbranch): Use reverse_condition_maybe_unordered and LTGT.\n+\t* sparc.h (REVERSIBLE_CC_MODE): Always true.  Update docs.\n+\t* sparc.md (bltgt): New.\n+\n 2000-01-25  Nick Clifton  <nickc@redhat.com>\n \n \t* emit-rtl.c (emit_insn): Only check machine class insns for"}, {"sha": "8bf54cbcdf4fdc103d2428f1f2ecd1f30dd1a3d6", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -2233,7 +2233,6 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n-    case UNNE_EXPR:\n       build_type = integer_type_node;\n       if (code0 != REAL_TYPE || code1 != REAL_TYPE)\n \t{"}, {"sha": "cbf246f8a1be24657e213fcd02bb892b0696f0ac", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -2097,7 +2097,7 @@ select_cc_mode (op, x, y)\n \tcase UNGT:\n \tcase UNGE:\n \tcase UNEQ:\n-\tcase UNNE:\n+\tcase LTGT:\n \t  return CCFPmode;\n \n \tcase LT:\n@@ -4655,54 +4655,7 @@ output_cbranch (op, label, reversed, annul, noop, insn)\n       /* Reversal of FP compares takes care -- an ordered compare\n \t becomes an unordered compare and vice versa.  */\n       if (mode == CCFPmode || mode == CCFPEmode)\n-\t{\n-\t  switch (code)\n-\t    {\n-\t    case EQ:\n-\t      code = NE;\n-\t      break;\n-\t    case NE:\n-\t      code = EQ;\n-\t      break;\n-\t    case GE:\n-\t      code = UNLT;\n-\t      break;\n-\t    case GT:\n-\t      code = UNLE;\n-\t      break;\n-\t    case LE:\n-\t      code = UNGT;\n-\t      break;\n-\t    case LT:\n-\t      code = UNGE;\n-\t      break;\n-\t    case UNORDERED:\n-\t      code = ORDERED;\n-\t      break;\n-\t    case ORDERED:\n-\t      code = UNORDERED;\n-\t      break;\n-\t    case UNGT:\n-\t      code = LE;\n-\t      break;\n-\t    case UNLT:\n-\t      code = GE;\n-\t      break;\n-\t    case UNEQ:\n-\t      /* ??? We don't have a \"less or greater\" rtx code.  */\n-\t      code = UNKNOWN;\n-\t      break;\n-\t    case UNGE:\n-\t      code = LT;\n-\t      break;\n-\t    case UNLE:\n-\t      code = GT;\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t}\n+\tcode = reverse_condition_maybe_unordered (code);\n       else\n \tcode = reverse_condition (code);\n     }\n@@ -4750,7 +4703,7 @@ output_cbranch (op, label, reversed, annul, noop, insn)\n       case UNLE:\n \tbranch = \"fbule\";\n \tbreak;\n-      case UNKNOWN:\n+      case LTGT:\n \tbranch = \"fblg\";\n \tbreak;\n "}, {"sha": "03317bd60c3e4fa850edd4ad89268fc9af49934c", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -2669,15 +2669,15 @@ do {                                                                    \\\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,\n-   CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand is a\n-   PLUS, MINUS, NEG, or ASHIFT.  CCmode should be used when no special\n+   CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand\n+   is a PLUS, MINUS, NEG, or ASHIFT.  CCmode should be used when no special\n    processing is needed.  */\n #define SELECT_CC_MODE(OP,X,Y)  select_cc_mode ((OP), (X), (Y))\n \n-/* Return non-zero if SELECT_CC_MODE will never return MODE for a\n-   floating point inequality comparison.  */\n-\n-#define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPEmode && (MODE) != CCFPmode)\n+/* Return non-zero if MODE implies a floating point inequality can be\n+   reversed.  For Sparc this is always true because we have a full\n+   compliment of ordered and unordered comparisons.  */\n+#define REVERSIBLE_CC_MODE(MODE) 1\n \n /* A function address in a call instruction\n    is a byte address (for indexing purposes)"}, {"sha": "950d9ae4718b5e589bbbe5b4cbb277aeee002fd9", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -1923,6 +1923,24 @@\n     }\n   operands[1] = gen_compare_reg (UNLE, sparc_compare_op0, sparc_compare_op1);\n }\")\n+\n+(define_expand \"bltgt\"\n+  [(set (pc)\n+\t(if_then_else (ltgt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (sparc_compare_op0) == TFmode\n+      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LTGT);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n+  operands[1] = gen_compare_reg (LTGT, sparc_compare_op0, sparc_compare_op1);\n+}\")\n \f\n ;; Now match both normal and inverted jump.\n "}, {"sha": "d6eea728a521b8ec50d167c088449d1e59eb18b4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -1,3 +1,7 @@\n+2000-01-25  Richard Henderson  <rth@cygnus.com>\n+\n+\t* typeck.c (build_binary_op_nodefault): Remove UNNE_EXPR.\n+\n 2000-01-25  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (vcall_offset_in_vtable_p): New macro."}, {"sha": "04feacfa31bc4b2f37226ff521e7adc83f44563f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -3786,7 +3786,6 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n-    case UNNE_EXPR:\n       build_type = integer_type_node;\n       if (code0 != REAL_TYPE || code1 != REAL_TYPE)\n \t{"}, {"sha": "41b0188f9ba3bb19f6db62dbcec8f7031da93894", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -7626,7 +7626,6 @@ expand_expr (exp, target, tmode, modifier)\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n-    case UNNE_EXPR:\n       preexpand_calls (exp);\n       temp = do_store_flag (exp, target, tmode != VOIDmode ? tmode : mode, 0);\n       if (temp != 0)\n@@ -9556,9 +9555,7 @@ do_jump (exp, if_false_label, if_true_label)\n \trcode1 = UNEQ;\n \ttcode2 = EQ_EXPR;\n \tgoto unordered_bcc;\n-      case UNNE_EXPR:\n-\trcode1 = UNNE;\n-\ttcode2 = NE_EXPR;\n+\n       unordered_bcc:\n         mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n \tif (can_compare_p (rcode1, mode, ccp_jump))\n@@ -10165,9 +10162,6 @@ do_store_flag (exp, target, mode, only_cheap)\n     case UNEQ_EXPR:\n       code = UNEQ;\n       break;\n-    case UNNE_EXPR:\n-      code = UNNE;\n-      break;\n \n     default:\n       abort ();"}, {"sha": "26cc01112518fe5e7fe9fecf9338d31b6a653c3a", "filename": "gcc/jump.c", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -3473,14 +3473,70 @@ reverse_condition (code)\n     case UNGT:\n     case UNGE:\n     case UNEQ:\n-    case UNNE:\n+    case LTGT:\n       return UNKNOWN;\n \n     default:\n       abort ();\n     }\n }\n \n+/* Similar, but we're allowed to generate unordered comparisons, which\n+   makes it safe for IEEE floating-point.  Of course, we have to recognize\n+   that the target will support them too...  */\n+\n+enum rtx_code\n+reverse_condition_maybe_unordered (code)\n+     enum rtx_code code;\n+{\n+  /* Non-IEEE formats don't have unordered conditions.  */\n+  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n+    return reverse_condition (code);\n+\n+  switch (code)\n+    {\n+    case EQ:\n+      return NE;\n+    case NE:\n+      return EQ;\n+    case GT:\n+      return UNLE;\n+    case GE:\n+      return UNLT;\n+    case LT:\n+      return UNGE;\n+    case LE:\n+      return UNGT;\n+    case LTGT:\n+      return UNEQ;\n+    case GTU:\n+      return LEU;\n+    case GEU:\n+      return LTU;\n+    case LTU:\n+      return GEU;\n+    case LEU:\n+      return GTU;\n+    case UNORDERED:\n+      return ORDERED;\n+    case ORDERED:\n+      return UNORDERED;\n+    case UNLT:\n+      return GE;\n+    case UNLE:\n+      return GT;\n+    case UNGT:\n+      return LE;\n+    case UNGE:\n+      return LT;\n+    case UNEQ:\n+      return LTGT;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Similar, but return the code when two operands of a comparison are swapped.\n    This IS safe for IEEE floating-point.  */\n \n@@ -3495,7 +3551,7 @@ swap_condition (code)\n     case UNORDERED:\n     case ORDERED:\n     case UNEQ:\n-    case UNNE:\n+    case LTGT:\n       return code;\n \n     case GT:\n@@ -3514,7 +3570,6 @@ swap_condition (code)\n       return GTU;\n     case LEU:\n       return GEU;\n-\n     case UNLT:\n       return UNGT;\n     case UNLE:\n@@ -3549,13 +3604,10 @@ unsigned_condition (code)\n \n     case GT:\n       return GTU;\n-\n     case GE:\n       return GEU;\n-\n     case LT:\n       return LTU;\n-\n     case LE:\n       return LEU;\n \n@@ -3582,13 +3634,10 @@ signed_condition (code)\n \n     case GTU:\n       return GT;\n-\n     case GEU:\n       return GE;\n-\n     case LTU:\n       return LT;\n-\n     case LEU:\n       return LE;\n \n@@ -3610,17 +3659,29 @@ comparison_dominates_p (code1, code2)\n   switch (code1)\n     {\n     case EQ:\n-      if (code2 == LE || code2 == LEU || code2 == GE || code2 == GEU)\n+      if (code2 == LE || code2 == LEU || code2 == GE || code2 == GEU\n+\t  || code2 == ORDERED)\n \treturn 1;\n       break;\n \n     case LT:\n-      if (code2 == LE || code2 == NE)\n+      if (code2 == LE || code2 == NE || code2 == ORDERED)\n \treturn 1;\n       break;\n \n     case GT:\n-      if (code2 == GE || code2 == NE)\n+      if (code2 == GE || code2 == NE || code2 == ORDERED)\n+\treturn 1;\n+      break;\n+\n+    case GE:\n+    case LE:\n+      if (code2 == ORDERED)\n+\treturn 1;\n+      break;\n+\n+    case LTGT:\n+      if (code2 == NE || code2 == ORDERED)\n \treturn 1;\n       break;\n \n@@ -3633,6 +3694,11 @@ comparison_dominates_p (code1, code2)\n       if (code2 == GEU || code2 == NE)\n \treturn 1;\n       break;\n+\n+    case UNORDERED:\n+      if (code2 == NE)\n+\treturn 1;\n+      break;\n       \n     default:\n       break;"}, {"sha": "996a38e9e9eda2b16307fe6a13c974050cce5930", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -742,13 +742,15 @@ DEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", '<')\n DEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", '<')\n \n /* These are equivalent to unordered or ... */\n-DEF_RTL_EXPR(UNNE, \"unne\", \"ee\", '<')\n DEF_RTL_EXPR(UNEQ, \"uneq\", \"ee\", '<')\n DEF_RTL_EXPR(UNGE, \"unge\", \"ee\", '<')\n DEF_RTL_EXPR(UNGT, \"ungt\", \"ee\", '<')\n DEF_RTL_EXPR(UNLE, \"unle\", \"ee\", '<')\n DEF_RTL_EXPR(UNLT, \"unlt\", \"ee\", '<')\n \n+/* This is an ordered NE, ie !UNEQ, ie false for NaN.  */\n+DEF_RTL_EXPR(LTGT, \"ltgt\", \"ee\", '<')\n+\n /* Represents the result of sign-extending the sole operand.\n    The machine modes of the operand and of the SIGN_EXTEND expression\n    determine how much sign-extension is going on.  */"}, {"sha": "d286bf86378d5d32222a268c6a3fb0fcd65b5861", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -1056,6 +1056,7 @@ extern rtx next_cc0_user\t\tPARAMS ((rtx));\n extern rtx prev_cc0_setter\t\tPARAMS ((rtx));\n extern rtx next_nondeleted_insn\t\tPARAMS ((rtx));\n extern enum rtx_code reverse_condition\tPARAMS ((enum rtx_code));\n+extern enum rtx_code reverse_condition_maybe_unordered PARAMS ((enum rtx_code));\n extern enum rtx_code swap_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code unsigned_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code signed_condition\tPARAMS ((enum rtx_code));"}, {"sha": "eadf1f50d67446a0fca80231f50530b5538fd780", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7913f3d028aaa490bb6cad8817f1d0ba25d5970e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=7913f3d028aaa490bb6cad8817f1d0ba25d5970e", "patch": "@@ -651,7 +651,6 @@ DEFTREECODE (UNLE_EXPR, \"unle_expr\", '<', 2)\n DEFTREECODE (UNGT_EXPR, \"ungt_expr\", '<', 2)\n DEFTREECODE (UNGE_EXPR, \"unge_expr\", '<', 2)\n DEFTREECODE (UNEQ_EXPR, \"uneq_expr\", '<', 2)\n-DEFTREECODE (UNNE_EXPR, \"unne_expr\", '<', 2)\n \n /* Operations for Pascal sets.  Not used now.  */\n DEFTREECODE (IN_EXPR, \"in_expr\", '2', 2)"}]}