{"sha": "c671684018a1b1a6029eb48fea018f2eaf90c2c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY3MTY4NDAxOGExYjFhNjAyOWViNDhmZWEwMThmMmVhZjkwYzJjMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-22T22:36:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-22T22:36:25Z"}, "message": "(find_valid_class): New function.\n\n(push_reload): Use it in cases where a SUBREG and its contents\nboth need to be reloaded.\n\nFrom-SVN: r10833", "tree": {"sha": "5281d5569d238ca46e94c95761414ba98b2eb41c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5281d5569d238ca46e94c95761414ba98b2eb41c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c671684018a1b1a6029eb48fea018f2eaf90c2c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c671684018a1b1a6029eb48fea018f2eaf90c2c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c671684018a1b1a6029eb48fea018f2eaf90c2c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c671684018a1b1a6029eb48fea018f2eaf90c2c2/comments", "author": null, "committer": null, "parents": [{"sha": "da0ae67f753942119eb4e70a1947b985ff92d7d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da0ae67f753942119eb4e70a1947b985ff92d7d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da0ae67f753942119eb4e70a1947b985ff92d7d9"}], "stats": {"total": 46, "additions": 42, "deletions": 4}, "files": [{"sha": "3e8e8d2dd8a855b52f17c1f1ecff733efcf703b0", "filename": "gcc/reload.c", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c671684018a1b1a6029eb48fea018f2eaf90c2c2/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c671684018a1b1a6029eb48fea018f2eaf90c2c2/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c671684018a1b1a6029eb48fea018f2eaf90c2c2", "patch": "@@ -291,6 +291,7 @@ static int output_reloadnum;\n static int push_secondary_reload PROTO((int, rtx, int, int, enum reg_class,\n \t\t\t\t\tenum machine_mode, enum reload_type,\n \t\t\t\t\tenum insn_code *));\n+static enum reg_class find_valid_class PROTO((enum machine_mode, int));\n static int push_reload\t\tPROTO((rtx, rtx, rtx *, rtx *, enum reg_class,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       int, int, int, enum reload_type));\n@@ -691,6 +692,38 @@ clear_secondary_mem ()\n }\n #endif /* SECONDARY_MEMORY_NEEDED */\n \f\n+/* Find the largest class for which every register number plus N is valid in\n+   M1 (if in range).  Abort if no such class exists.  */\n+\n+static enum reg_class\n+find_valid_class (m1, n)\n+     enum machine_mode  m1;\n+     int n;\n+{\n+  int class;\n+  int regno;\n+  enum reg_class best_class;\n+  int best_size = 0;\n+\n+  for (class = 1; class < N_REG_CLASSES; class++)\n+    {\n+      int bad = 0;\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER && ! bad; regno++)\n+\tif (TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n+\t    && TEST_HARD_REG_BIT (reg_class_contents[class], regno + n)\n+\t    && ! HARD_REGNO_MODE_OK (regno + n, m1))\n+\t  bad = 1;\n+\n+      if (! bad && reg_class_size[class] > best_size)\n+\tbest_class = class, best_size = reg_class_size[class];\n+    }\n+\n+  if (best_size == 0)\n+    abort ();\n+\n+  return best_class;\n+}\n+\f\n /* Record one reload that needs to be performed.\n    IN is an rtx saying where the data are to be found before this instruction.\n    OUT says where they must be stored after the instruction.\n@@ -896,7 +929,8 @@ push_reload (in, out, inloc, outloc, class,\n   if (in != 0 && GET_CODE (in) == SUBREG\n       && GET_CODE (SUBREG_REG (in)) == REG\n       && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n-      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (in)), inmode)\n+      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (in)) + SUBREG_WORD (in),\n+\t\t\t\tinmode)\n \t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n \t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t  > UNITS_PER_WORD)\n@@ -911,7 +945,8 @@ push_reload (in, out, inloc, outloc, class,\n \t RELOAD_OTHER, we are guaranteed that this inner reload will be\n \t output before the outer reload.  */\n       push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), NULL_PTR,\n-\t\t   GENERAL_REGS, VOIDmode, VOIDmode, 0, 0, opnum, type);\n+\t\t   find_valid_class (inmode, SUBREG_WORD (in)),\n+\t\t   VOIDmode, VOIDmode, 0, 0, opnum, type);\n       dont_remove_subreg = 1;\n     }\n \n@@ -984,7 +1019,8 @@ push_reload (in, out, inloc, outloc, class,\n   if (out != 0 && GET_CODE (out) == SUBREG\n       && GET_CODE (SUBREG_REG (out)) == REG\n       && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n-      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (out)), outmode)\n+      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (out)) + SUBREG_WORD (out),\n+\t\t\t\toutmode)\n \t  || (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n \t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n \t\t  > UNITS_PER_WORD)\n@@ -1000,7 +1036,9 @@ push_reload (in, out, inloc, outloc, class,\n \t output after the outer reload.  */\n       dont_remove_subreg = 1;\n       push_reload (SUBREG_REG (out), SUBREG_REG (out), &SUBREG_REG (out),\n-\t\t   &SUBREG_REG (out), ALL_REGS, VOIDmode, VOIDmode, 0, 0,\n+\t\t   &SUBREG_REG (out),\n+\t\t   find_valid_class (outmode, SUBREG_WORD (out)),\n+\t\t   VOIDmode, VOIDmode, 0, 0,\n \t\t   opnum, RELOAD_OTHER);\n     }\n "}]}