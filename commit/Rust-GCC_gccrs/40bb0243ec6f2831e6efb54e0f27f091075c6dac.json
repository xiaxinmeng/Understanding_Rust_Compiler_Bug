{"sha": "40bb0243ec6f2831e6efb54e0f27f091075c6dac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiYjAyNDNlYzZmMjgzMWU2ZWZiNTRlMGYyN2YwOTEwNzVjNmRhYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-25T21:14:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-25T21:14:40Z"}, "message": "compiler: Don't create a closure if not needed.\n\nFrom-SVN: r187897", "tree": {"sha": "564c9d279db8a9f4a46e0b3dd5146cf62b86af45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/564c9d279db8a9f4a46e0b3dd5146cf62b86af45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40bb0243ec6f2831e6efb54e0f27f091075c6dac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bb0243ec6f2831e6efb54e0f27f091075c6dac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40bb0243ec6f2831e6efb54e0f27f091075c6dac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bb0243ec6f2831e6efb54e0f27f091075c6dac/comments", "author": null, "committer": null, "parents": [{"sha": "31a18a7e231474e40309e930e8705d62a38ffdd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a18a7e231474e40309e930e8705d62a38ffdd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31a18a7e231474e40309e930e8705d62a38ffdd5"}], "stats": {"total": 34, "additions": 11, "deletions": 23}, "files": [{"sha": "e609be9cfcef9d483402bae126423f191de75d6b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bb0243ec6f2831e6efb54e0f27f091075c6dac/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bb0243ec6f2831e6efb54e0f27f091075c6dac/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=40bb0243ec6f2831e6efb54e0f27f091075c6dac", "patch": "@@ -1312,30 +1312,18 @@ Func_expression::do_get_tree(Translate_context* context)\n \t     && TREE_CODE(TREE_OPERAND(fnaddr, 0)) == FUNCTION_DECL);\n   TREE_ADDRESSABLE(TREE_OPERAND(fnaddr, 0)) = 1;\n \n-  // For a normal non-nested function call, that is all we have to do.\n-  if (!this->function_->is_function()\n-      || this->function_->func_value()->enclosing() == NULL)\n-    {\n-      go_assert(this->closure_ == NULL);\n-      return fnaddr;\n-    }\n+  // If there is no closure, that is all have to do.\n+  if (this->closure_ == NULL)\n+    return fnaddr;\n \n-  // For a nested function call, we have to always allocate a\n-  // trampoline.  If we don't always allocate, then closures will not\n-  // be reliably distinct.\n-  Expression* closure = this->closure_;\n-  tree closure_tree;\n-  if (closure == NULL)\n-    closure_tree = null_pointer_node;\n-  else\n-    {\n-      // Get the value of the closure.  This will be a pointer to\n-      // space allocated on the heap.\n-      closure_tree = closure->get_tree(context);\n-      if (closure_tree == error_mark_node)\n-\treturn error_mark_node;\n-      go_assert(POINTER_TYPE_P(TREE_TYPE(closure_tree)));\n-    }\n+  go_assert(this->function_->func_value()->enclosing() != NULL);\n+\n+  // Get the value of the closure.  This will be a pointer to space\n+  // allocated on the heap.\n+  tree closure_tree = this->closure_->get_tree(context);\n+  if (closure_tree == error_mark_node)\n+    return error_mark_node;\n+  go_assert(POINTER_TYPE_P(TREE_TYPE(closure_tree)));\n \n   // Now we need to build some code on the heap.  This code will load\n   // the static chain pointer with the closure and then jump to the"}]}