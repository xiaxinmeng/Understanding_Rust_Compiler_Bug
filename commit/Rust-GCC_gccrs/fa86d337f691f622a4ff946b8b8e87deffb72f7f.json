{"sha": "fa86d337f691f622a4ff946b8b8e87deffb72f7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE4NmQzMzdmNjkxZjYyMmE0ZmY5NDZiOGI4ZTg3ZGVmZmI3MmY3Zg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-14T01:56:32Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-14T01:56:32Z"}, "message": "ira-int.h (ira_object_conflict_iterator): Rename from ira_allocno_conflict_iterator.\n\n\t* ira-int.h (ira_object_conflict_iterator): Rename from\n\tira_allocno_conflict_iterator.\n\t(ira_object_conflict_iter_init): Rename from\n\tira_allocno_conflict_iter_init, second arg changed to\n\t* ira.c (check_allocation): Use FOR_EACH_OBJECT_CONFLICT rather than\n\tFOR_EACH_ALLOCNO_CONFLICT.\n\t* ira-color.c (assign_hard_reg, push_allocno_to_stack)\n\tsetup_allocno_left_conflicts_size, coalesced_allocno_conflict_p,\n\tira_reassign_conflict_allocnos, ira_reassign_pseudos): Likewise.\n\t* ira-conflicts.c (print_allocno_conflicts): Likewise.\n\nFrom-SVN: r162168", "tree": {"sha": "bf075ab760c9643d5d25be8ef2552f0bf9631b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf075ab760c9643d5d25be8ef2552f0bf9631b4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa86d337f691f622a4ff946b8b8e87deffb72f7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa86d337f691f622a4ff946b8b8e87deffb72f7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa86d337f691f622a4ff946b8b8e87deffb72f7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa86d337f691f622a4ff946b8b8e87deffb72f7f/comments", "author": null, "committer": null, "parents": [{"sha": "9140d27b2a52d6f3f0422c3391fbce84efad4442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9140d27b2a52d6f3f0422c3391fbce84efad4442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9140d27b2a52d6f3f0422c3391fbce84efad4442"}], "stats": {"total": 297, "additions": 172, "deletions": 125}, "files": [{"sha": "f4d1cc2e8a5ebf688ef4dda2e45df5ce8e1c8e71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa86d337f691f622a4ff946b8b8e87deffb72f7f", "patch": "@@ -126,6 +126,17 @@\n \tremove_some_program_points_and_update_live_ranges,\n \tira_debug_live_range_list): Likewise.\n \n+\t* ira-int.h (ira_object_conflict_iterator): Rename from\n+\tira_allocno_conflict_iterator.\n+\t(ira_object_conflict_iter_init): Rename from\n+\tira_allocno_conflict_iter_init, second arg changed to\n+\t* ira.c (check_allocation): Use FOR_EACH_OBJECT_CONFLICT rather than\n+\tFOR_EACH_ALLOCNO_CONFLICT.\n+\t* ira-color.c (assign_hard_reg, push_allocno_to_stack)\n+\tsetup_allocno_left_conflicts_size, coalesced_allocno_conflict_p,\n+\tira_reassign_conflict_allocnos, ira_reassign_pseudos): Likewise.\n+\t* ira-conflicts.c (print_allocno_conflicts): Likewise.\n+\n 2010-07-13  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR other/44874"}, {"sha": "09e5bd068b2d854237d54c5d2b5e939e0df747e4", "filename": "gcc/ira-color.c", "status": "modified", "additions": 117, "deletions": 86, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=fa86d337f691f622a4ff946b8b8e87deffb72f7f", "patch": "@@ -449,8 +449,7 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n   int *conflict_costs;\n   enum reg_class cover_class, conflict_cover_class;\n   enum machine_mode mode;\n-  ira_allocno_t a, conflict_allocno;\n-  ira_allocno_conflict_iterator aci;\n+  ira_allocno_t a;\n   static int costs[FIRST_PSEUDO_REGISTER], full_costs[FIRST_PSEUDO_REGISTER];\n #ifndef HONOR_REG_ALLOC_ORDER\n   enum reg_class rclass;\n@@ -480,6 +479,8 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n       ira_object_t obj = ALLOCNO_OBJECT (a);\n+      ira_object_t conflict_obj;\n+      ira_object_conflict_iterator oci;\n \n       mem_cost += ALLOCNO_UPDATED_MEMORY_COST (a);\n       IOR_HARD_REG_SET (conflicting_regs,\n@@ -503,60 +504,64 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n \t    full_costs[i] += cost;\n \t  }\n       /* Take preferences of conflicting allocnos into account.  */\n-      FOR_EACH_ALLOCNO_CONFLICT (a, conflict_allocno, aci)\n-\t/* Reload can give another class so we need to check all\n-\t   allocnos.  */\n-\tif (retry_p || bitmap_bit_p (consideration_allocno_bitmap,\n-\t\t\t\t     ALLOCNO_NUM (conflict_allocno)))\n-\t  {\n-\t    conflict_cover_class = ALLOCNO_COVER_CLASS (conflict_allocno);\n-\t    ira_assert (ira_reg_classes_intersect_p\n-\t\t\t[cover_class][conflict_cover_class]);\n-\t    if (allocno_coalesced_p)\n-\t      {\n-\t\tif (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n-\t\t\t\t  ALLOCNO_NUM (conflict_allocno)))\n-\t\t  continue;\n-\t\tbitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t\tALLOCNO_NUM (conflict_allocno));\n-\t      }\n-\t    if (ALLOCNO_ASSIGNED_P (conflict_allocno))\n-\t      {\n-\t\tif ((hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno)) >= 0\n-\t\t    && ira_class_hard_reg_index[cover_class][hard_regno] >= 0)\n-\t\t  {\n-\t\t    IOR_HARD_REG_SET\n-\t\t      (conflicting_regs,\n-\t\t       ira_reg_mode_hard_regset\n-\t\t       [hard_regno][ALLOCNO_MODE (conflict_allocno)]);\n-\t\t    if (hard_reg_set_subset_p (reg_class_contents[cover_class],\n-\t\t\t\t\t       conflicting_regs))\n-\t\t      goto fail;\n-\t\t  }\n-\t      }\n-\t    else if (! ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n-\t\t\t\t\t\t (conflict_allocno)))\n-\t      {\n-\t\tira_allocate_and_copy_costs\n-\t\t  (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno),\n-\t\t   conflict_cover_class,\n-\t\t   ALLOCNO_CONFLICT_HARD_REG_COSTS (conflict_allocno));\n-\t\tconflict_costs\n-\t\t  = ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno);\n-\t\tif (conflict_costs != NULL)\n-\t\t  for (j = class_size - 1; j >= 0; j--)\n- \t\t    {\n- \t\t      hard_regno = ira_class_hard_regs[cover_class][j];\n- \t\t      ira_assert (hard_regno >= 0);\n- \t\t      k = (ira_class_hard_reg_index\n- \t\t\t   [conflict_cover_class][hard_regno]);\n- \t\t      if (k < 0)\n- \t\t\tcontinue;\n- \t\t      full_costs[j] -= conflict_costs[k];\n- \t\t    }\n-\t\tqueue_update_cost (conflict_allocno, COST_HOP_DIVISOR);\n-\t      }\n-\t  }\n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t{\n+\t  ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\n+\t  /* Reload can give another class so we need to check all\n+\t     allocnos.  */\n+\t  if (retry_p || bitmap_bit_p (consideration_allocno_bitmap,\n+\t\t\t\t       ALLOCNO_NUM (conflict_allocno)))\n+\t    {\n+\t      conflict_cover_class = ALLOCNO_COVER_CLASS (conflict_allocno);\n+\t      ira_assert (ira_reg_classes_intersect_p\n+\t\t\t  [cover_class][conflict_cover_class]);\n+\t      if (allocno_coalesced_p)\n+\t\t{\n+\t\t  if (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n+\t\t\t\t    ALLOCNO_NUM (conflict_allocno)))\n+\t\t    continue;\n+\t\t  bitmap_set_bit (processed_coalesced_allocno_bitmap,\n+\t\t\t\t  ALLOCNO_NUM (conflict_allocno));\n+\t\t}\n+\t      if (ALLOCNO_ASSIGNED_P (conflict_allocno))\n+\t\t{\n+\t\t  if ((hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno)) >= 0\n+\t\t      && ira_class_hard_reg_index[cover_class][hard_regno] >= 0)\n+\t\t    {\n+\t\t      IOR_HARD_REG_SET\n+\t\t\t(conflicting_regs,\n+\t\t\t ira_reg_mode_hard_regset\n+\t\t\t [hard_regno][ALLOCNO_MODE (conflict_allocno)]);\n+\t\t      if (hard_reg_set_subset_p (reg_class_contents[cover_class],\n+\t\t\t\t\t\t conflicting_regs))\n+\t\t\tgoto fail;\n+\t\t    }\n+\t\t}\n+\t      else if (! ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n+\t\t\t\t\t\t   (conflict_allocno)))\n+\t\t{\n+\t\t  ira_allocate_and_copy_costs\n+\t\t    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno),\n+\t\t     conflict_cover_class,\n+\t\t     ALLOCNO_CONFLICT_HARD_REG_COSTS (conflict_allocno));\n+\t\t  conflict_costs\n+\t\t    = ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno);\n+\t\t  if (conflict_costs != NULL)\n+\t\t    for (j = class_size - 1; j >= 0; j--)\n+\t\t      {\n+\t\t\thard_regno = ira_class_hard_regs[cover_class][j];\n+\t\t\tira_assert (hard_regno >= 0);\n+\t\t\tk = (ira_class_hard_reg_index\n+\t\t\t     [conflict_cover_class][hard_regno]);\n+\t\t\tif (k < 0)\n+\t\t\t  continue;\n+\t\t\tfull_costs[j] -= conflict_costs[k];\n+\t\t      }\n+\t\t  queue_update_cost (conflict_allocno, COST_HOP_DIVISOR);\n+\t\t}\n+\t    }\n+\t}\n       if (a == allocno)\n \tbreak;\n     }\n@@ -872,9 +877,8 @@ static void\n push_allocno_to_stack (ira_allocno_t allocno)\n {\n   int left_conflicts_size, conflict_size, size;\n-  ira_allocno_t a, conflict_allocno;\n+  ira_allocno_t a;\n   enum reg_class cover_class;\n-  ira_allocno_conflict_iterator aci;\n \n   ALLOCNO_IN_GRAPH_P (allocno) = false;\n   VEC_safe_push (ira_allocno_t, heap, allocno_stack_vec, allocno);\n@@ -887,8 +891,14 @@ push_allocno_to_stack (ira_allocno_t allocno)\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      FOR_EACH_ALLOCNO_CONFLICT (a, conflict_allocno, aci)\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n+      ira_object_t conflict_obj;\n+      ira_object_conflict_iterator oci;\n+\n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t{\n+\t  ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\n \t  conflict_allocno = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n \t  if (bitmap_bit_p (coloring_allocno_bitmap,\n \t\t\t    ALLOCNO_NUM (conflict_allocno)))\n@@ -1405,10 +1415,9 @@ static void\n setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n {\n   int i, hard_regs_num, hard_regno, conflict_allocnos_size;\n-  ira_allocno_t a, conflict_allocno;\n+  ira_allocno_t a;\n   enum reg_class cover_class;\n   HARD_REG_SET temp_set;\n-  ira_allocno_conflict_iterator aci;\n \n   cover_class = ALLOCNO_COVER_CLASS (allocno);\n   hard_regs_num = ira_class_hard_regs_num[cover_class];\n@@ -1444,8 +1453,14 @@ setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n     for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n \t a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n       {\n-\tFOR_EACH_ALLOCNO_CONFLICT (a, conflict_allocno, aci)\n+\tira_object_t obj = ALLOCNO_OBJECT (a);\n+\tira_object_t conflict_obj;\n+\tira_object_conflict_iterator oci;\n+\n+\tFOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t  {\n+\t    ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\n \t    conflict_allocno\n \t      = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n \t    if (bitmap_bit_p (consideration_allocno_bitmap,\n@@ -1563,8 +1578,7 @@ static bool\n coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2,\n \t\t\t      bool reload_p)\n {\n-  ira_allocno_t a, conflict_allocno;\n-  ira_allocno_conflict_iterator aci;\n+  ira_allocno_t a;\n \n   if (allocno_coalesced_p)\n     {\n@@ -1582,6 +1596,7 @@ coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2,\n     {\n       if (reload_p)\n \t{\n+\t  ira_allocno_t conflict_allocno;\n \t  for (conflict_allocno = ALLOCNO_NEXT_COALESCED_ALLOCNO (a1);;\n \t       conflict_allocno\n \t\t = ALLOCNO_NEXT_COALESCED_ALLOCNO (conflict_allocno))\n@@ -1595,12 +1610,19 @@ coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2,\n \t}\n       else\n \t{\n-\t  FOR_EACH_ALLOCNO_CONFLICT (a, conflict_allocno, aci)\n-\t    if (conflict_allocno == a1\n-\t\t|| (allocno_coalesced_p\n-\t\t    && bitmap_bit_p (processed_coalesced_allocno_bitmap,\n-\t\t\t\t     ALLOCNO_NUM (conflict_allocno))))\n-\t      return true;\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t  ira_object_t conflict_obj;\n+\t  ira_object_conflict_iterator oci;\n+\n+\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t    {\n+\t      ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\t      if (conflict_allocno == a1\n+\t\t  || (allocno_coalesced_p\n+\t\t      && bitmap_bit_p (processed_coalesced_allocno_bitmap,\n+\t\t\t\t       ALLOCNO_NUM (conflict_allocno))))\n+\t\treturn true;\n+\t    }\n \t}\n       if (a == a2)\n \tbreak;\n@@ -2291,8 +2313,7 @@ void\n ira_reassign_conflict_allocnos (int start_regno)\n {\n   int i, allocnos_to_color_num;\n-  ira_allocno_t a, conflict_a;\n-  ira_allocno_conflict_iterator aci;\n+  ira_allocno_t a;\n   enum reg_class cover_class;\n   bitmap allocnos_to_color;\n   ira_allocno_iterator ai;\n@@ -2301,6 +2322,10 @@ ira_reassign_conflict_allocnos (int start_regno)\n   allocnos_to_color_num = 0;\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n+      ira_object_t conflict_obj;\n+      ira_object_conflict_iterator oci;\n+\n       if (! ALLOCNO_ASSIGNED_P (a)\n \t  && ! bitmap_bit_p (allocnos_to_color, ALLOCNO_NUM (a)))\n \t{\n@@ -2318,8 +2343,9 @@ ira_reassign_conflict_allocnos (int start_regno)\n       if (ALLOCNO_REGNO (a) < start_regno\n \t  || (cover_class = ALLOCNO_COVER_CLASS (a)) == NO_REGS)\n \tcontinue;\n-      FOR_EACH_ALLOCNO_CONFLICT (a, conflict_a, aci)\n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t{\n+\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n \t  ira_assert (ira_reg_classes_intersect_p\n \t\t      [cover_class][ALLOCNO_COVER_CLASS (conflict_a)]);\n \t  if (bitmap_bit_p (allocnos_to_color, ALLOCNO_NUM (conflict_a)))\n@@ -2877,9 +2903,8 @@ ira_reassign_pseudos (int *spilled_pseudo_regs, int num,\n {\n   int i, n, regno;\n   bool changed_p;\n-  ira_allocno_t a, conflict_a;\n+  ira_allocno_t a;\n   HARD_REG_SET forbidden_regs;\n-  ira_allocno_conflict_iterator aci;\n   bitmap temp = BITMAP_ALLOC (NULL);\n \n   /* Add pseudos which conflict with pseudos already in\n@@ -2891,21 +2916,27 @@ ira_reassign_pseudos (int *spilled_pseudo_regs, int num,\n \n   for (i = 0, n = num; i < n; i++)\n     {\n+      ira_object_t obj, conflict_obj;\n+      ira_object_conflict_iterator oci;\n       int regno = spilled_pseudo_regs[i];\n       bitmap_set_bit (temp, regno);\n \n       a = ira_regno_allocno_map[regno];\n-      FOR_EACH_ALLOCNO_CONFLICT (a, conflict_a, aci)\n-\tif (ALLOCNO_HARD_REGNO (conflict_a) < 0\n-\t    && ! ALLOCNO_DONT_REASSIGN_P (conflict_a)\n-\t    && ! bitmap_bit_p (temp, ALLOCNO_REGNO (conflict_a)))\n-\t  {\n-\t    spilled_pseudo_regs[num++] = ALLOCNO_REGNO (conflict_a);\n-\t    bitmap_set_bit (temp, ALLOCNO_REGNO (conflict_a));\n-\t    /* ?!? This seems wrong.  */\n-\t    bitmap_set_bit (consideration_allocno_bitmap,\n-\t\t\t    ALLOCNO_NUM (conflict_a));\n-\t  }\n+      obj = ALLOCNO_OBJECT (a);\n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t{\n+\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t  if (ALLOCNO_HARD_REGNO (conflict_a) < 0\n+\t      && ! ALLOCNO_DONT_REASSIGN_P (conflict_a)\n+\t      && ! bitmap_bit_p (temp, ALLOCNO_REGNO (conflict_a)))\n+\t    {\n+\t      spilled_pseudo_regs[num++] = ALLOCNO_REGNO (conflict_a);\n+\t      bitmap_set_bit (temp, ALLOCNO_REGNO (conflict_a));\n+\t      /* ?!? This seems wrong.  */\n+\t      bitmap_set_bit (consideration_allocno_bitmap,\n+\t\t\t      ALLOCNO_NUM (conflict_a));\n+\t    }\n+\t}\n     }\n \n   if (num > 1)"}, {"sha": "c75069da5c4f532e7df4530540353579218e8384", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=fa86d337f691f622a4ff946b8b8e87deffb72f7f", "patch": "@@ -700,9 +700,8 @@ static void\n print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n {\n   HARD_REG_SET conflicting_hard_regs;\n-  ira_object_t obj;\n-  ira_allocno_t conflict_a;\n-  ira_allocno_conflict_iterator aci;\n+  ira_object_t obj, conflict_obj;\n+  ira_object_conflict_iterator oci;\n   basic_block bb;\n \n   if (reg_p)\n@@ -720,8 +719,9 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n   fputs (\" conflicts:\", file);\n   obj = ALLOCNO_OBJECT (a);\n   if (OBJECT_CONFLICT_ARRAY (obj) != NULL)\n-    FOR_EACH_ALLOCNO_CONFLICT (a, conflict_a, aci)\n+    FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n       {\n+\tira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n         if (reg_p)\n           fprintf (file, \" r%d,\", ALLOCNO_REGNO (conflict_a));\n         else"}, {"sha": "182203d3d8e5a8894f077c890176c90e6a49f363", "filename": "gcc/ira-int.h", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=fa86d337f691f622a4ff946b8b8e87deffb72f7f", "patch": "@@ -1159,14 +1159,13 @@ typedef struct {\n   /* The word of bit vector currently visited.  It is defined only if\n      OBJECT_CONFLICT_VEC_P is FALSE.  */\n   unsigned IRA_INT_TYPE word;\n-} ira_allocno_conflict_iterator;\n+} ira_object_conflict_iterator;\n \n /* Initialize the iterator I with ALLOCNO conflicts.  */\n static inline void\n-ira_allocno_conflict_iter_init (ira_allocno_conflict_iterator *i,\n-\t\t\t\tira_allocno_t allocno)\n+ira_object_conflict_iter_init (ira_object_conflict_iterator *i,\n+\t\t\t       ira_object_t obj)\n {\n-  ira_object_t obj = ALLOCNO_OBJECT (allocno);\n   i->conflict_vec_p = OBJECT_CONFLICT_VEC_P (obj);\n   i->vec = OBJECT_CONFLICT_ARRAY (obj);\n   i->word_num = 0;\n@@ -1190,8 +1189,8 @@ ira_allocno_conflict_iter_init (ira_allocno_conflict_iterator *i,\n    case *A is set to the allocno to be visited.  Otherwise, return\n    FALSE.  */\n static inline bool\n-ira_allocno_conflict_iter_cond (ira_allocno_conflict_iterator *i,\n-\t\t\t\tira_allocno_t *a)\n+ira_object_conflict_iter_cond (ira_object_conflict_iterator *i,\n+\t\t\t       ira_object_t *pobj)\n {\n   ira_object_t obj;\n \n@@ -1222,13 +1221,13 @@ ira_allocno_conflict_iter_cond (ira_allocno_conflict_iterator *i,\n       obj = ira_object_id_map[i->bit_num + i->base_conflict_id];\n     }\n \n-  *a = OBJECT_ALLOCNO (obj);\n+  *pobj = obj;\n   return true;\n }\n \n /* Advance to the next conflicting allocno.  */\n static inline void\n-ira_allocno_conflict_iter_next (ira_allocno_conflict_iterator *i)\n+ira_object_conflict_iter_next (ira_object_conflict_iterator *i)\n {\n   if (i->conflict_vec_p)\n     i->word_num++;\n@@ -1239,14 +1238,13 @@ ira_allocno_conflict_iter_next (ira_allocno_conflict_iterator *i)\n     }\n }\n \n-/* Loop over all allocnos conflicting with ALLOCNO.  In each\n-   iteration, A is set to the next conflicting allocno.  ITER is an\n-   instance of ira_allocno_conflict_iterator used to iterate the\n-   conflicts.  */\n-#define FOR_EACH_ALLOCNO_CONFLICT(ALLOCNO, A, ITER)\t\t\t\\\n-  for (ira_allocno_conflict_iter_init (&(ITER), (ALLOCNO));\t\t\\\n-       ira_allocno_conflict_iter_cond (&(ITER), &(A));\t\t\t\\\n-       ira_allocno_conflict_iter_next (&(ITER)))\n+/* Loop over all objects conflicting with OBJ.  In each iteration,\n+   CONF is set to the next conflicting object.  ITER is an instance\n+   of ira_object_conflict_iterator used to iterate the conflicts.  */\n+#define FOR_EACH_OBJECT_CONFLICT(OBJ, CONF, ITER)\t\t\t\\\n+  for (ira_object_conflict_iter_init (&(ITER), (OBJ));\t\t\t\\\n+       ira_object_conflict_iter_cond (&(ITER), &(CONF));\t\t\\\n+       ira_object_conflict_iter_next (&(ITER)))\n \n \f\n "}, {"sha": "943b06bd391a1a0b64188a17943fb312800e8faf", "filename": "gcc/ira.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa86d337f691f622a4ff946b8b8e87deffb72f7f/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=fa86d337f691f622a4ff946b8b8e87deffb72f7f", "patch": "@@ -1609,33 +1609,40 @@ calculate_allocation_cost (void)\n static void\n check_allocation (void)\n {\n-  ira_allocno_t a, conflict_a;\n-  int hard_regno, conflict_hard_regno, nregs, conflict_nregs;\n-  ira_allocno_conflict_iterator aci;\n+  ira_allocno_t a;\n+  int hard_regno, nregs;\n   ira_allocno_iterator ai;\n \n   FOR_EACH_ALLOCNO (a, ai)\n     {\n+      ira_object_t obj, conflict_obj;\n+      ira_object_conflict_iterator oci;\n+\n       if (ALLOCNO_CAP_MEMBER (a) != NULL\n \t  || (hard_regno = ALLOCNO_HARD_REGNO (a)) < 0)\n \tcontinue;\n       nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (a)];\n-      FOR_EACH_ALLOCNO_CONFLICT (a, conflict_a, aci)\n-\tif ((conflict_hard_regno = ALLOCNO_HARD_REGNO (conflict_a)) >= 0)\n-\t  {\n-\t    conflict_nregs\n-\t      = (hard_regno_nregs\n-\t\t [conflict_hard_regno][ALLOCNO_MODE (conflict_a)]);\n-\t    if ((conflict_hard_regno <= hard_regno\n-\t\t && hard_regno < conflict_hard_regno + conflict_nregs)\n-\t\t|| (hard_regno <= conflict_hard_regno\n-\t\t    && conflict_hard_regno < hard_regno + nregs))\n-\t      {\n-\t\tfprintf (stderr, \"bad allocation for %d and %d\\n\",\n-\t\t\t ALLOCNO_REGNO (a), ALLOCNO_REGNO (conflict_a));\n-\t\tgcc_unreachable ();\n-\t      }\n-\t  }\n+      obj = ALLOCNO_OBJECT (a);\n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t{\n+\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t  int conflict_hard_regno = ALLOCNO_HARD_REGNO (conflict_a);\n+\t  if (conflict_hard_regno >= 0)\n+\t    {\n+\t      int conflict_nregs\n+\t\t= (hard_regno_nregs\n+\t\t   [conflict_hard_regno][ALLOCNO_MODE (conflict_a)]);\n+\t      if ((conflict_hard_regno <= hard_regno\n+\t\t   && hard_regno < conflict_hard_regno + conflict_nregs)\n+\t\t  || (hard_regno <= conflict_hard_regno\n+\t\t      && conflict_hard_regno < hard_regno + nregs))\n+\t\t{\n+\t\t  fprintf (stderr, \"bad allocation for %d and %d\\n\",\n+\t\t\t   ALLOCNO_REGNO (a), ALLOCNO_REGNO (conflict_a));\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t    }\n+\t}\n     }\n }\n #endif"}]}