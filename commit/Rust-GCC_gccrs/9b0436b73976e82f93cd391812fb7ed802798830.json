{"sha": "9b0436b73976e82f93cd391812fb7ed802798830", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIwNDM2YjczOTc2ZTgyZjkzY2QzOTE4MTJmYjdlZDgwMjc5ODgzMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-19T09:43:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-19T09:43:53Z"}, "message": "cgraph.c (cgraph_remove_node): Fix removal from linked list.\n\n\n\t* cgraph.c (cgraph_remove_node): Fix removal from linked list.\n\t* cgraphunit.c (cgraph_finalize_compilation_unit): Clear next_needed\n\tlist.\n\t(cgraph_remove_unreachable_nodes): New function\n\t(cgraph_decide_inlining_of_small_function): Fix pasto.\n\t(cgraph_decide_inlining_incrementally): Fix pasto.\n\t(cgrpah_decide_inlining): Likewise; remove unreachable nodes.\n\nFrom-SVN: r76142", "tree": {"sha": "248adc79dc4e8a0017745b4c303cb2506b6ee0b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/248adc79dc4e8a0017745b4c303cb2506b6ee0b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b0436b73976e82f93cd391812fb7ed802798830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0436b73976e82f93cd391812fb7ed802798830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b0436b73976e82f93cd391812fb7ed802798830", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0436b73976e82f93cd391812fb7ed802798830/comments", "author": null, "committer": null, "parents": [{"sha": "954b12d2dc0c85814de90bbe9e01869ded7bba1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954b12d2dc0c85814de90bbe9e01869ded7bba1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954b12d2dc0c85814de90bbe9e01869ded7bba1a"}], "stats": {"total": 161, "additions": 144, "deletions": 17}, "files": [{"sha": "5287af437ac91bc5c0648d793ac2318fc8c2b6e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0436b73976e82f93cd391812fb7ed802798830/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0436b73976e82f93cd391812fb7ed802798830/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b0436b73976e82f93cd391812fb7ed802798830", "patch": "@@ -1,3 +1,13 @@\n+2004-01-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_remove_node): Fix removal from linked list.\n+\t* cgraphunit.c (cgraph_finalize_compilation_unit): Clear next_needed\n+\tlist.\n+\t(cgraph_remove_unreachable_nodes): New function\n+\t(cgraph_decide_inlining_of_small_function): Fix pasto.\n+\t(cgraph_decide_inlining_incrementally): Fix pasto.\n+\t(cgrpah_decide_inlining): Likewise; remove unreachable nodes.\n+\n 2004-01-19  Steven Bosscher  <stevenb@suse.de>\n \n \t* gengtype.c (header_file): Make it static."}, {"sha": "57d0844beae22203921457c98192232fafc06bd1", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0436b73976e82f93cd391812fb7ed802798830/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0436b73976e82f93cd391812fb7ed802798830/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=9b0436b73976e82f93cd391812fb7ed802798830", "patch": "@@ -231,7 +231,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   if (node->previous)\n     node->previous->next = node->next;\n   else\n-    cgraph_nodes = node;\n+    cgraph_nodes = node->next;\n   if (node->next)\n     node->next->previous = node->previous;\n   DECL_SAVED_TREE (node->decl) = NULL;"}, {"sha": "a883ebf6728ddb5ac5f8487cd437226ad4306e28", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 133, "deletions": 16, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0436b73976e82f93cd391812fb7ed802798830/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0436b73976e82f93cd391812fb7ed802798830/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9b0436b73976e82f93cd391812fb7ed802798830", "patch": "@@ -436,6 +436,8 @@ cgraph_finalize_compilation_unit (void)\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n \t}\n+      else\n+\tnode->next_needed = NULL;\n     }\n   if (cgraph_dump_file)\n     {\n@@ -792,6 +794,105 @@ cgraph_inlined_callees (struct cgraph_node *node, struct cgraph_node **array)\n   return nfound;\n }\n \n+/* Perform reachability analysis and reclaim all unreachable nodes.\n+   This function also remove unneeded bodies of extern inline functions\n+   and thus needs to be done only after inlining decisions has been made.  */\n+static bool\n+cgraph_remove_unreachable_nodes (void)\n+{\n+  struct cgraph_node *first = (void *) 1;\n+  struct cgraph_node *node;\n+  bool changed = false;\n+  int insns = 0;\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"\\nReclaiming functions:\");\n+#ifdef ENABLE_CHECKING\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->aux)\n+      abort ();\n+#endif\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->needed && (!DECL_EXTERNAL (node->decl) || !node->analyzed))\n+      {\n+\tnode->aux = first;\n+\tfirst = node;\n+      }\n+    else if (node->aux)\n+      abort ();\n+\n+  /* Perform reachability analysis.  As a special case do not consider\n+     extern inline functions not inlined as live because we won't output\n+     them at all.  */\n+  while (first != (void *) 1)\n+    {\n+      struct cgraph_edge *e;\n+      node = first;\n+      first = first->aux;\n+\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (!e->callee->aux\n+\t    && node->analyzed\n+\t    && (!e->inline_failed || !e->callee->analyzed\n+\t\t|| !DECL_EXTERNAL (e->callee->decl)))\n+\t  {\n+\t    e->callee->aux = first;\n+\t    first = e->callee;\n+\t  }\n+    }\n+\n+  /* Remove unreachable nodes.  Extern inline functions need special care;\n+     Unreachable extern inline functions shall be removed.\n+     Reachable extern inline functions we never inlined shall get their bodies\n+     elliminated\n+     Reachable extern inline functions we sometimes inlined will be turned into\n+     unanalyzed nodes so they look like for true extern functions to the rest\n+     of code.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (!node->aux)\n+\t{\n+\t  int local_insns;\n+\t  tree decl = node->decl;\n+\n+\t  if (DECL_SAVED_INSNS (decl))\n+\t    local_insns = node->local.self_insns;\n+\t  else\n+\t    local_insns = 0;\n+\t  if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n+\t  if (!node->analyzed || !DECL_EXTERNAL (node->decl))\n+\t    cgraph_remove_node (node);\n+\t  else\n+\t    {\n+\t      struct cgraph_edge *e;\n+\n+\t      for (e = node->callers; e; e = e->next_caller)\n+\t\tif (e->caller->aux)\n+\t\t  break;\n+\t      if (e || node->needed)\n+\t\t{\n+\t\t  DECL_SAVED_TREE (node->decl) = NULL_TREE;\n+\t\t  while (node->callees)\n+\t\t    cgraph_remove_edge (node, node->callees->callee);\n+\t\t  node->analyzed = false;\n+\t\t}\n+\t      else\n+\t\tcgraph_remove_node (node);\n+\t    }\n+\t  if (!DECL_SAVED_TREE (decl))\n+\t    insns += local_insns;\n+\t  changed = true;\n+\t}\n+    }\n+  for (node = cgraph_nodes; node; node = node->next)\n+    node->aux = NULL;\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"\\nReclaimed %i insns\", insns);\n+  return changed;\n+}\n+\n+\n /* Estimate size of the function after inlining WHAT into TO.  */\n \n static int\n@@ -1055,7 +1156,7 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t\t\t\t\t\tninlined, &e->inline_failed))\n \t      {\n \t\tfor (i = 0; i < ninlined; i++)\n-\t\t  inlined[i]->output = 0, node->aux = 0;\n+\t\t  inlined[i]->output = 0, inlined[i]->aux = 0;\n \t\tif (cgraph_dump_file)\n \t\t  fprintf (cgraph_dump_file, \" Not inlining into %s.\\n\",\n \t\t\t   cgraph_node_name (e->caller));\n@@ -1071,17 +1172,16 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t       the keys.  */\n \t    for (i = 0; i < ninlined; i++)\n \t      {\n-\t\tinlined[i]->output = 0, node->aux = 0;\n+\t\tinlined[i]->output = 0, inlined[i]->aux = 0;\n \t\tif (heap_node[inlined[i]->uid])\n \t\t  fibheap_replace_key (heap, heap_node[inlined[i]->uid],\n \t\t\t\t       cgraph_estimate_growth (inlined[i]));\n \t      }\n-\tif (cgraph_dump_file)\n-\t  fprintf (cgraph_dump_file, \n-\t\t   \" Inlined into %s which now has %i insns.\\n\",\n-\t\t   cgraph_node_name (e->caller),\n-\t\t   e->caller->global.insns);\n-\n+\t    if (cgraph_dump_file)\n+\t      fprintf (cgraph_dump_file, \n+\t\t       \" Inlined into %s which now has %i insns.\\n\",\n+\t\t       cgraph_node_name (e->caller),\n+\t\t       e->caller->global.insns);\n \t  }\n \n       /* Similarly all functions called by the function we just inlined\n@@ -1101,7 +1201,8 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t      fibheap_replace_key (heap, heap_node[e->callee->uid],\n \t\t\t\t   cgraph_estimate_growth (e->callee));\n \n-\t  inlined_callees[i]->output = 0, node->aux = 0;\n+\t  inlined_callees[i]->output = 0;\n+\t  inlined_callees[i]->aux = 0;\n \t}\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file, \n@@ -1150,6 +1251,11 @@ cgraph_decide_inlining (void)\n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\nInlining always_inline functions:\\n\");\n+#ifdef ENABLE_CHECKING\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->aux || node->output)\n+      abort ();\n+#endif\n \n   /* In the first pass mark all always_inline edges.  Do this with a priority\n      so none of our later choices will make this impossible.  */\n@@ -1185,7 +1291,7 @@ cgraph_decide_inlining (void)\n \t  cgraph_mark_inline (node, e->callee, inlined, ninlined,\n \t\t\t      inlined_callees, ninlined_callees);\n \t  for (y = 0; y < ninlined_callees; y++)\n-\t    inlined_callees[y]->output = 0, node->aux = 0;\n+\t    inlined_callees[y]->output = 0, inlined_callees[y]->aux = 0;\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \n \t\t     \" Inlined into %s which now has %i insns.\\n\",\n@@ -1197,12 +1303,22 @@ cgraph_decide_inlining (void)\n \t\t \" Inlined %i times for a net change of %+i insns.\\n\",\n \t\t node->global.cloned_times, overall_insns - old_insns);\n       for (y = 0; y < ninlined; y++)\n-\tinlined[y]->output = 0, node->aux = 0;\n+\tinlined[y]->output = 0, inlined[y]->aux = 0;\n     }\n+#ifdef ENABLE_CHECKING\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->aux || node->output)\n+      abort ();\n+#endif\n \n   if (!flag_really_no_inline)\n     {\n       cgraph_decide_inlining_of_small_functions (inlined, inlined_callees);\n+#ifdef ENABLE_CHECKING\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->aux || node->output)\n+\t  abort ();\n+#endif\n \n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file, \"\\nDeciding on functions called once:\\n\");\n@@ -1251,7 +1367,7 @@ cgraph_decide_inlining (void)\n \t\t\t\t\t  ninlined, inlined_callees,\n \t\t\t\t\t  ninlined_callees);\n \t\t      for (y = 0; y < ninlined_callees; y++)\n-\t\t\tinlined_callees[y]->output = 0, node->aux = 0;\n+\t\t\tinlined_callees[y]->output = 0, inlined_callees[y]->aux = 0;\n \t\t      if (cgraph_dump_file)\n \t\t\tfprintf (cgraph_dump_file,\n \t\t\t\t \" Inlined into %s which now has %i insns\"\n@@ -1267,11 +1383,12 @@ cgraph_decide_inlining (void)\n \t\t\t\t \" Inline limit reached, not inlined.\\n\");\n \t\t    }\n \t\t  for (y = 0; y < ninlined; y++)\n-\t\t    inlined[y]->output = 0, node->aux = 0;\n+\t\t    inlined[y]->output = 0, inlined[y]->aux = 0;\n \t\t}\n \t    }\n \t}\n     }\n+  cgraph_remove_unreachable_nodes ();\n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n@@ -1317,7 +1434,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n \tcgraph_mark_inline (node, e->callee, inlined, ninlined,\n \t\t\t    inlined_callees, ninlined_callees);\n \tfor (y = 0; y < ninlined_callees; y++)\n-\t  inlined_callees[y]->output = 0, node->aux = 0;\n+\t  inlined_callees[y]->output = 0, inlined_callees[y]->aux = 0;\n       }\n \n   if (!flag_really_no_inline)\n@@ -1342,13 +1459,13 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n \t    cgraph_mark_inline (node, e->callee, inlined, ninlined,\n \t\t\t\tinlined_callees, ninlined_callees);\n \t    for (y = 0; y < ninlined_callees; y++)\n-\t      inlined_callees[y]->output = 0, node->aux = 0;\n+\t      inlined_callees[y]->output = 0, inlined_callees[y]->aux = 0;\n \t  }\n     }\n \n   /* Clear the flags set by cgraph_inlined_into.  */\n   for (y = 0; y < ninlined; y++)\n-    inlined[y]->output = 0, node->aux = 0;\n+    inlined[y]->output = 0, inlined[y]->aux = 0;\n \n   free (inlined);\n   free (inlined_callees);"}]}