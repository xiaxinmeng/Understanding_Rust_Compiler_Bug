{"sha": "935f1d7da3ea82980bed642c6eea06d69de5fdf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM1ZjFkN2RhM2VhODI5ODBiZWQ2NDJjNmVlYTA2ZDY5ZGU1ZmRmNg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-05T21:33:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-05T21:33:47Z"}, "message": "Merge #609\n\n609: Initial TypeBounds support r=philberty a=philberty\n\nThis allows us to specify bounds on type parameters that influence\r\npath resolution to allow us to resolve to trait items. More error\r\nchecking is required to actually enforce the trait constraint but\r\nthis patch is getting rather large and does not cause regressions.\r\n\r\nFixes #583 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "bb7172a61dc354681743d86f708e021b4613cc9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb7172a61dc354681743d86f708e021b4613cc9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/935f1d7da3ea82980bed642c6eea06d69de5fdf6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhDFk7CRBK7hj4Ov3rIwAA6n4IACmEfkCtuWrmjhs3BoMtsXv6\nDTlO4iz8lqpzjm73YsemeMS3F7RgQhnf7Lvzi3KoG73eJfw698Ep47Vcw+8sIEvX\ngp6ltwRPG4Yy2ntykcGP6azEHAIWI3wRch9+cO8kuBrYqFodY7mAZx4Fmirn/Lsk\nllLEl97pDijtijfgcq6Ey/dtlZoY6aIUg6ZgltjBrNui1efDANCUFc36SURRVtW/\nZMb8Ru4dVeZvnP9WoxGZHc6rC/R7OiWNPP3rkdQ3W831eG/p4ZUYdwaGzGc/iBhc\nkrfXWfV82IZC3+jd2G44VEZK91YOrnDpVK5VpYwMcwgJZRwSBgE1uZ2yV3PO/b4=\n=5Dpn\n-----END PGP SIGNATURE-----\n", "payload": "tree bb7172a61dc354681743d86f708e021b4613cc9f\nparent 074c070c02e61033694f2f969a33a795036ad540\nparent 65ef30eb84314ae7525be4a4d7dd79d2868e3e3c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628199227 +0000\ncommitter GitHub <noreply@github.com> 1628199227 +0000\n\nMerge #609\n\n609: Initial TypeBounds support r=philberty a=philberty\n\nThis allows us to specify bounds on type parameters that influence\r\npath resolution to allow us to resolve to trait items. More error\r\nchecking is required to actually enforce the trait constraint but\r\nthis patch is getting rather large and does not cause regressions.\r\n\r\nFixes #583 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935f1d7da3ea82980bed642c6eea06d69de5fdf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/935f1d7da3ea82980bed642c6eea06d69de5fdf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935f1d7da3ea82980bed642c6eea06d69de5fdf6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "074c070c02e61033694f2f969a33a795036ad540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/074c070c02e61033694f2f969a33a795036ad540", "html_url": "https://github.com/Rust-GCC/gccrs/commit/074c070c02e61033694f2f969a33a795036ad540"}, {"sha": "65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65ef30eb84314ae7525be4a4d7dd79d2868e3e3c"}], "stats": {"total": 1464, "additions": 1200, "deletions": 264}, "files": [{"sha": "f4bc9eaba1cd249102edf888ae7644e76e82d1ad", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -79,6 +79,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\\n+    rust/rust-tyty-bounds.o \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-lint-marklive.o \\\n     $(END)"}, {"sha": "e376488de8c80432f33d81ca107a5779ee35edaa", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -1126,9 +1126,17 @@ class TypeParamBound\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  virtual Location get_locus_slow () const = 0;\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual TypeParamBound *clone_type_param_bound_impl () const = 0;\n+\n+  TypeParamBound (NodeId node_id) : node_id (node_id) {}\n+\n+  NodeId node_id;\n };\n \n // Represents a lifetime (and is also a kind of type param bound)\n@@ -1144,22 +1152,22 @@ class Lifetime : public TypeParamBound\n \n private:\n   LifetimeType lifetime_type;\n-\n-  // TODO: LIFETIME_OR_LABEL (aka lifetime token) is only field\n-  // find way of enclosing token or something\n   std::string lifetime_name;\n-  // only applies for NAMED lifetime_type\n-\n   Location locus;\n-\n   NodeId node_id;\n \n public:\n   // Constructor\n   Lifetime (LifetimeType type, std::string name = std::string (),\n \t    Location locus = Location ())\n-    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus),\n-      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+    : TypeParamBound (Analysis::Mappings::get ()->get_next_node_id ()),\n+      lifetime_type (type), lifetime_name (std::move (name)), locus (locus)\n+  {}\n+\n+  Lifetime (NodeId id, LifetimeType type, std::string name = std::string (),\n+\t    Location locus = Location ())\n+    : TypeParamBound (id), lifetime_type (type),\n+      lifetime_name (std::move (name)), locus (locus)\n   {}\n \n   // Creates an \"error\" lifetime.\n@@ -1177,18 +1185,18 @@ class Lifetime : public TypeParamBound\n \n   LifetimeType get_lifetime_type () { return lifetime_type; }\n \n-  Location get_locus () { return locus; }\n+  Location get_locus () const { return locus; }\n \n-  std::string get_lifetime_name () const { return lifetime_name; }\n+  Location get_locus_slow () const override final { return get_locus (); }\n \n-  NodeId get_node_id () const { return node_id; }\n+  std::string get_lifetime_name () const { return lifetime_name; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   Lifetime *clone_type_param_bound_impl () const override\n   {\n-    return new Lifetime (*this);\n+    return new Lifetime (node_id, lifetime_type, lifetime_name, locus);\n   }\n };\n "}, {"sha": "b658a532b988809f7cb9a23a5d4daee33110c943", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -50,7 +50,18 @@ class TraitBound : public TypeParamBound\n \t      bool opening_question_mark = false,\n \t      std::vector<LifetimeParam> for_lifetimes\n \t      = std::vector<LifetimeParam> ())\n-    : in_parens (in_parens), opening_question_mark (opening_question_mark),\n+    : TypeParamBound (Analysis::Mappings::get ()->get_next_node_id ()),\n+      in_parens (in_parens), opening_question_mark (opening_question_mark),\n+      for_lifetimes (std::move (for_lifetimes)),\n+      type_path (std::move (type_path)), locus (locus)\n+  {}\n+\n+  TraitBound (NodeId id, TypePath type_path, Location locus,\n+\t      bool in_parens = false, bool opening_question_mark = false,\n+\t      std::vector<LifetimeParam> for_lifetimes\n+\t      = std::vector<LifetimeParam> ())\n+    : TypeParamBound (id), in_parens (in_parens),\n+      opening_question_mark (opening_question_mark),\n       for_lifetimes (std::move (for_lifetimes)),\n       type_path (std::move (type_path)), locus (locus)\n   {}\n@@ -59,18 +70,24 @@ class TraitBound : public TypeParamBound\n \n   Location get_locus () const { return locus; }\n \n+  Location get_locus_slow () const override final { return get_locus (); }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: this mutable getter seems kinda dodgy\n   TypePath &get_type_path () { return type_path; }\n   const TypePath &get_type_path () const { return type_path; }\n \n+  bool is_in_parens () const { return in_parens; }\n+  bool has_opening_question_mark () const { return opening_question_mark; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TraitBound *clone_type_param_bound_impl () const override\n   {\n-    return new TraitBound (*this);\n+    return new TraitBound (node_id, type_path, locus, in_parens,\n+\t\t\t   opening_question_mark, for_lifetimes);\n   }\n };\n "}, {"sha": "c87b47732847f856f66816732c8750120a305549", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 75, "deletions": 9, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -20,6 +20,8 @@\n #include \"rust-backend.h\"\n #include \"rust-compile-resolve-path.h\"\n #include \"rust-compile-item.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -94,7 +96,76 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t  HIR::ImplItem *resolved_item\n \t    = ctx->get_mappings ()->lookup_hir_implitem (\n \t      expr.get_mappings ().get_crate_num (), ref, &parent_impl_id);\n-\t  if (resolved_item != nullptr)\n+\n+\t  if (resolved_item == nullptr)\n+\t    {\n+\t      // it might be resolved to a trait item\n+\t      HIR::TraitItem *trait_item\n+\t\t= ctx->get_mappings ()->lookup_hir_trait_item (\n+\t\t  expr.get_mappings ().get_crate_num (), ref);\n+\t      HIR::Trait *trait\n+\t\t= ctx->get_mappings ()->lookup_trait_item_mapping (\n+\t\t  trait_item->get_mappings ().get_hirid ());\n+\n+\t      Resolver::TraitReference &trait_ref\n+\t\t= Resolver::TraitResolver::error_node ();\n+\t      bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+\t\ttrait->get_mappings ().get_defid (), trait_ref);\n+\t      rust_assert (ok);\n+\n+\t      TyTy::BaseType *receiver = nullptr;\n+\t      ok = ctx->get_tyctx ()->lookup_receiver (\n+\t\texpr.get_mappings ().get_hirid (), &receiver);\n+\t      rust_assert (ok);\n+\n+\t      if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n+\t\t{\n+\t\t  TyTy::ParamType *p\n+\t\t    = static_cast<TyTy::ParamType *> (receiver);\n+\t\t  receiver = p->resolve ();\n+\t\t}\n+\n+\t      // the type resolver can only resolve type bounds to their trait\n+\t      // item so its up to us to figure out if this path should resolve\n+\t      // to an trait-impl-block-item or if it can be defaulted to the\n+\t      // trait-impl-item's definition\n+\t      std::vector<Resolver::PathProbeCandidate> candidates\n+\t\t= Resolver::PathProbeType::Probe (\n+\t\t  receiver, expr.get_final_segment ().get_segment (), true,\n+\t\t  false, true);\n+\n+\t      if (candidates.size () == 0)\n+\t\t{\n+\t\t  // this means we are defaulting back to the trait_item if\n+\t\t  // possible\n+\t\t  // TODO\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  Resolver::PathProbeCandidate &candidate = candidates.at (0);\n+\t\t  rust_assert (candidate.is_impl_candidate ());\n+\n+\t\t  HIR::ImplBlock *impl = candidate.item.impl.parent;\n+\t\t  HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+\n+\t\t  TyTy::BaseType *self = nullptr;\n+\t\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t\t    impl->get_type ()->get_mappings ().get_hirid (), &self);\n+\t\t  rust_assert (ok);\n+\n+\t\t  if (!lookup->has_subsititions_defined ())\n+\t\t    CompileInherentImplItem::Compile (self, impl_item, ctx,\n+\t\t\t\t\t\t      true);\n+\t\t  else\n+\t\t    CompileInherentImplItem::Compile (self, impl_item, ctx,\n+\t\t\t\t\t\t      true, lookup);\n+\n+\t\t  lookup->set_ty_ref (\n+\t\t    impl_item->get_impl_mappings ().get_hirid ());\n+\t\t}\n+\t    }\n+\t  else\n \t    {\n \t      rust_assert (parent_impl_id != UNKNOWN_HIRID);\n \t      HIR::Item *impl_ref = ctx->get_mappings ()->lookup_hir_item (\n@@ -114,18 +185,13 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\tCompileInherentImplItem::Compile (self, resolved_item, ctx,\n \t\t\t\t\t\t  true, lookup);\n \t    }\n-\t  else\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"failed to lookup definition declaration\");\n-\t      return;\n-\t    }\n \t}\n \n       if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n \t{\n-\t  rust_fatal_error (expr.get_locus (),\n-\t\t\t    \"forward declaration was not compiled\");\n+\t  resolved = ctx->get_backend ()->error_expression ();\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"forward declaration was not compiled\");\n \t  return;\n \t}\n     }"}, {"sha": "f422572d020361e07ef4fd0c2a63ee75aebe9323", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 97, "deletions": 21, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -20,6 +20,8 @@\n #include \"rust-compile-item.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n #include \"fnv-hash.h\"\n \n namespace Rust {\n@@ -141,31 +143,105 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \texpr.get_mappings ().get_crate_num (), ref, nullptr);\n       if (resolved_item == nullptr)\n \t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"failed to lookup forward declaration\");\n-\t  return;\n-\t}\n+\t  // it might be resolved to a trait item\n+\t  HIR::TraitItem *trait_item\n+\t    = ctx->get_mappings ()->lookup_hir_trait_item (\n+\t      expr.get_mappings ().get_crate_num (), ref);\n+\t  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+\t    trait_item->get_mappings ().get_hirid ());\n+\n+\t  Resolver::TraitReference &trait_ref\n+\t    = Resolver::TraitResolver::error_node ();\n+\t  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+\t    trait->get_mappings ().get_defid (), trait_ref);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *receiver = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_receiver (\n+\t    expr.get_mappings ().get_hirid (), &receiver);\n+\t  rust_assert (ok);\n+\n+\t  if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n+\t    {\n+\t      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+\t      receiver = p->resolve ();\n+\t    }\n \n-      TyTy::BaseType *self_type = nullptr;\n-      if (!ctx->get_tyctx ()->lookup_type (\n-\t    expr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n-\t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"failed to resolve type for self param\");\n-\t  return;\n-\t}\n+\t  // the type resolver can only resolve type bounds to their trait\n+\t  // item so its up to us to figure out if this path should resolve\n+\t  // to an trait-impl-block-item or if it can be defaulted to the\n+\t  // trait-impl-item's definition\n+\t  std::vector<Resolver::PathProbeCandidate> candidates\n+\t    = Resolver::PathProbeType::Probe (\n+\t      receiver, expr.get_method_name ().get_segment (), true, false,\n+\t      true);\n \n-      if (!fntype->has_subsititions_defined ())\n-\tCompileInherentImplItem::Compile (self_type, resolved_item, ctx, true);\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      // this means we are defaulting back to the trait_item if\n+\t      // possible\n+\t      // TODO\n+\t      gcc_unreachable ();\n+\t    }\n+\t  else\n+\t    {\n+\t      Resolver::PathProbeCandidate &candidate = candidates.at (0);\n+\t      rust_assert (candidate.is_impl_candidate ());\n+\n+\t      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+\n+\t      TyTy::BaseType *self_type = nullptr;\n+\t      if (!ctx->get_tyctx ()->lookup_type (\n+\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n+\t\t    &self_type))\n+\t\t{\n+\t\t  rust_error_at (expr.get_locus (),\n+\t\t\t\t \"failed to resolve type for self param\");\n+\t\t  return;\n+\t\t}\n+\n+\t      if (!fntype->has_subsititions_defined ())\n+\t\tCompileInherentImplItem::Compile (self_type, impl_item, ctx,\n+\t\t\t\t\t\t  true);\n+\t      else\n+\t\tCompileInherentImplItem::Compile (self_type, impl_item, ctx,\n+\t\t\t\t\t\t  true, fntype);\n+\n+\t      if (!ctx->lookup_function_decl (\n+\t\t    impl_item->get_impl_mappings ().get_hirid (), &fn))\n+\t\t{\n+\t\t  translated = ctx->get_backend ()->error_expression ();\n+\t\t  rust_error_at (expr.get_locus (),\n+\t\t\t\t \"forward declaration was not compiled\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n       else\n-\tCompileInherentImplItem::Compile (self_type, resolved_item, ctx, true,\n-\t\t\t\t\t  fntype);\n-\n-      if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"forward declaration was not compiled\");\n-\t  return;\n+\t  TyTy::BaseType *self_type = nullptr;\n+\t  if (!ctx->get_tyctx ()->lookup_type (\n+\t\texpr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n+\t    {\n+\t      rust_error_at (expr.get_locus (),\n+\t\t\t     \"failed to resolve type for self param\");\n+\t      return;\n+\t    }\n+\n+\t  if (!fntype->has_subsititions_defined ())\n+\t    CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n+\t\t\t\t\t      true);\n+\t  else\n+\t    CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n+\t\t\t\t\t      true, fntype);\n+\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t    {\n+\t      translated = ctx->get_backend ()->error_expression ();\n+\t      rust_error_at (expr.get_locus (),\n+\t\t\t     \"forward declaration was not compiled\");\n+\t      return;\n+\t    }\n \t}\n     }\n "}, {"sha": "b1d0df36f4a706e4406d346d90fec76fad7e77a8", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -245,29 +245,15 @@ class ASTLoweringBase : public AST::ASTVisitor\n \n   HIR::Lifetime lower_lifetime (AST::Lifetime &lifetime)\n   {\n-    HIR::Lifetime::LifetimeType type = HIR::Lifetime::LifetimeType::NAMED;\n-    switch (lifetime.get_lifetime_type ())\n-      {\n-      case AST::Lifetime::LifetimeType::NAMED:\n-\ttype = HIR::Lifetime::LifetimeType::NAMED;\n-\tbreak;\n-      case AST::Lifetime::LifetimeType::STATIC:\n-\ttype = HIR::Lifetime::LifetimeType::STATIC;\n-\tbreak;\n-      case AST::Lifetime::LifetimeType::WILDCARD:\n-\ttype = HIR::Lifetime::LifetimeType::WILDCARD;\n-\tbreak;\n-      }\n-\n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, lifetime.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   UNKNOWN_LOCAL_DEFID);\n     mappings->insert_node_to_hir (mapping.get_crate_num (),\n \t\t\t\t  mapping.get_nodeid (), mapping.get_hirid ());\n \n-    return HIR::Lifetime (mapping, type, lifetime.get_lifetime_name (),\n-\t\t\t  lifetime.get_locus ());\n+    return HIR::Lifetime (mapping, lifetime.get_lifetime_type (),\n+\t\t\t  lifetime.get_lifetime_name (), lifetime.get_locus ());\n   }\n \n   HIR::LoopLabel lower_loop_label (AST::LoopLabel &loop_label)\n@@ -296,6 +282,8 @@ class ASTLoweringBase : public AST::ASTVisitor\n   HIR::SelfParam lower_self (AST::SelfParam &self);\n \n   HIR::Type *lower_type_no_bounds (AST::TypeNoBounds *type);\n+\n+  HIR::TypeParamBound *lower_bound (AST::TypeParamBound *bound);\n };\n \n } // namespace HIR"}, {"sha": "30835547e075996f66ccd015f3b8a1a737e3f4ca", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -496,28 +496,37 @@ class ASTLoweringItem : public ASTLoweringBase\n     std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n \n     std::vector<std::unique_ptr<HIR::TraitItem> > trait_items;\n+    std::vector<HirId> trait_item_ids;\n     for (auto &item : trait.get_trait_items ())\n       {\n \tHIR::TraitItem *lowered = ASTLowerTraitItem::translate (item.get ());\n \ttrait_items.push_back (std::unique_ptr<HIR::TraitItem> (lowered));\n+\ttrait_item_ids.push_back (lowered->get_mappings ().get_hirid ());\n       }\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, trait.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    translated = new HIR::Trait (mapping, trait.get_identifier (),\n-\t\t\t\t trait.is_unsafe (), std::move (generic_params),\n-\t\t\t\t std::move (type_param_bounds), where_clause,\n-\t\t\t\t std::move (trait_items), vis,\n-\t\t\t\t trait.get_outer_attrs (), trait.get_locus ());\n+    HIR::Trait *hir_trait\n+      = new HIR::Trait (mapping, trait.get_identifier (), trait.is_unsafe (),\n+\t\t\tstd::move (generic_params),\n+\t\t\tstd::move (type_param_bounds), where_clause,\n+\t\t\tstd::move (trait_items), vis, trait.get_outer_attrs (),\n+\t\t\ttrait.get_locus ());\n+    translated = hir_trait;\n \n     mappings->insert_defid_mapping (mapping.get_defid (), translated);\n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n \t\t\t       translated);\n     mappings->insert_location (crate_num, mapping.get_hirid (),\n \t\t\t       trait.get_locus ());\n+\n+    for (auto trait_item_id : trait_item_ids)\n+      {\n+\tmappings->insert_trait_item_mapping (trait_item_id, hir_trait);\n+      }\n   }\n \n   void visit (AST::TraitImpl &impl_block) override"}, {"sha": "9b5ec0a4df78ff8d13ec93d57765ebe2871d1d06", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 64, "deletions": 17, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -284,6 +284,9 @@ class ASTLowerGenericParam : public ASTLoweringBase\n       resolver.translated->get_mappings ().get_crate_num (),\n       resolver.translated->get_mappings ().get_hirid (),\n       param->get_locus_slow ());\n+    resolver.mappings->insert_hir_generic_param (\n+      resolver.translated->get_mappings ().get_crate_num (),\n+      resolver.translated->get_mappings ().get_hirid (), resolver.translated);\n \n     return resolver.translated;\n   }\n@@ -294,24 +297,9 @@ class ASTLowerGenericParam : public ASTLoweringBase\n     Analysis::NodeMapping mapping (crate_num, param.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-    HIR::Lifetime::LifetimeType ltt;\n \n-    switch (param.get_lifetime ().get_lifetime_type ())\n-      {\n-      case AST::Lifetime::LifetimeType::NAMED:\n-\tltt = HIR::Lifetime::LifetimeType::NAMED;\n-\tbreak;\n-      case AST::Lifetime::LifetimeType::STATIC:\n-\tltt = HIR::Lifetime::LifetimeType::STATIC;\n-\tbreak;\n-      case AST::Lifetime::LifetimeType::WILDCARD:\n-\tltt = HIR::Lifetime::LifetimeType::WILDCARD;\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-      }\n-\n-    HIR::Lifetime lt (mapping, ltt, param.get_lifetime ().get_lifetime_name (),\n+    HIR::Lifetime lt (mapping, param.get_lifetime ().get_lifetime_type (),\n+\t\t      param.get_lifetime ().get_lifetime_name (),\n \t\t      param.get_lifetime ().get_locus ());\n \n     translated = new HIR::LifetimeParam (mapping, lt, param.get_locus (),\n@@ -322,6 +310,16 @@ class ASTLowerGenericParam : public ASTLoweringBase\n   {\n     AST::Attribute outer_attr = AST::Attribute::create_empty ();\n     std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n+    if (param.has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : param.get_type_param_bounds ())\n+\t  {\n+\t    HIR::TypeParamBound *lowered_bound = lower_bound (bound.get ());\n+\t    type_param_bounds.push_back (\n+\t      std::unique_ptr<HIR::TypeParamBound> (lowered_bound));\n+\t  }\n+      }\n+\n     HIR::Type *type = param.has_type ()\n \t\t\t? ASTLoweringType::translate (param.get_type ().get ())\n \t\t\t: nullptr;\n@@ -344,6 +342,55 @@ class ASTLowerGenericParam : public ASTLoweringBase\n   HIR::GenericParam *translated;\n };\n \n+class ASTLoweringTypeBounds : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::TypeParamBound *translate (AST::TypeParamBound *type)\n+  {\n+    ASTLoweringTypeBounds resolver;\n+    type->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_crate_num (),\n+      resolver.translated->get_mappings ().get_hirid (),\n+      resolver.translated->get_locus_slow ());\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TraitBound &bound) override\n+  {\n+    // FIXME\n+    std::vector<HIR::LifetimeParam> lifetimes;\n+\n+    AST::TypePath &ast_trait_path = bound.get_type_path ();\n+    HIR::TypePath *trait_path = ASTLowerTypePath::translate (ast_trait_path);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, bound.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::TraitBound (mapping, *trait_path, bound.get_locus (),\n+\t\t\t\t      bound.is_in_parens (),\n+\t\t\t\t      bound.has_opening_question_mark ());\n+  }\n+\n+  void visit (AST::Lifetime &bound) override\n+  {\n+    HIR::Lifetime lifetime = lower_lifetime (bound);\n+    translated = new HIR::Lifetime (lifetime);\n+  }\n+\n+private:\n+  ASTLoweringTypeBounds () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::TypeParamBound *translated;\n+};\n+\n } // namespace HIR\n } // namespace Rust\n "}, {"sha": "ed597774550efd2273f83fd70635383e30c60671", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -263,6 +263,12 @@ ASTLowerPathInExpression::visit (AST::PathInExpression &expr)\n   std::vector<HIR::PathExprSegment> path_segments;\n   expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n     path_segments.push_back (lower_path_expr_seg (s));\n+\n+    // insert the mappings for the segment\n+    HIR::PathExprSegment *lowered_seg = &path_segments.back ();\n+    mappings->insert_hir_path_expr_seg (\n+      lowered_seg->get_mappings ().get_crate_num (),\n+      lowered_seg->get_mappings ().get_hirid (), lowered_seg);\n     return true;\n   });\n \n@@ -403,5 +409,11 @@ ASTLoweringBase::lower_type_no_bounds (AST::TypeNoBounds *type)\n   return ASTLoweringType::translate (type);\n }\n \n+HIR::TypeParamBound *\n+ASTLoweringBase::lower_bound (AST::TypeParamBound *bound)\n+{\n+  return ASTLoweringTypeBounds::translate (bound);\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "dee2827a346debdf6c4d8a6494b369bc67d0a44f", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -2113,11 +2113,11 @@ Lifetime::as_string () const\n \n   switch (lifetime_type)\n     {\n-    case NAMED:\n+    case AST::Lifetime::LifetimeType::NAMED:\n       return \"'\" + lifetime_name;\n-    case STATIC:\n+    case AST::Lifetime::LifetimeType::STATIC:\n       return \"'static\";\n-    case WILDCARD:\n+    case AST::Lifetime::LifetimeType::WILDCARD:\n       return \"'_\";\n     default:\n       return \"ERROR-MARK-STRING: lifetime type failure\";\n@@ -2747,7 +2747,8 @@ TypePath::to_trait_bound (bool in_parens) const\n   // create clone FIXME is this required? or is copy constructor automatically\n   // called?\n   TypePath copy (*this);\n-  return new TraitBound (std::move (copy), copy.get_locus (), in_parens);\n+  return new TraitBound (mappings, std::move (copy), copy.get_locus (),\n+\t\t\t in_parens);\n }\n \n std::string"}, {"sha": "ba043390e9060e878159bfd092dd2e8ec43f84da", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -124,6 +124,11 @@ class TypeParam : public GenericParam\n     return type->get_mappings ();\n   }\n \n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeParam *clone_generic_param_impl () const override\n@@ -333,7 +338,8 @@ struct SelfParam\n   SelfParam (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n \t     bool is_mut, Location locus)\n     : self_kind (is_mut ? ImplicitSelfKind::MUT : ImplicitSelfKind::IMM),\n-      lifetime (Lifetime (mappings, Lifetime::LifetimeType::NAMED, \"\", locus)),\n+      lifetime (\n+\tLifetime (mappings, AST::Lifetime::LifetimeType::NAMED, \"\", locus)),\n       type (std::move (type)), locus (locus), mappings (mappings)\n   {}\n "}, {"sha": "8d75d0285d397f87f60dc6ae034ca034e757df44", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -33,26 +33,23 @@ class TraitBound : public TypeParamBound\n {\n   bool in_parens;\n   bool opening_question_mark;\n-\n-  // bool has_for_lifetimes;\n-  // LifetimeParams for_lifetimes;\n-  std::vector<LifetimeParam> for_lifetimes; // inlined LifetimeParams\n-\n+  std::vector<LifetimeParam> for_lifetimes;\n   TypePath type_path;\n-\n   Location locus;\n \n+  Analysis::NodeMapping mappings;\n+\n public:\n   // Returns whether trait bound has \"for\" lifetimes\n   bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n \n-  TraitBound (TypePath type_path, Location locus, bool in_parens = false,\n-\t      bool opening_question_mark = false,\n+  TraitBound (Analysis::NodeMapping mapping, TypePath type_path, Location locus,\n+\t      bool in_parens = false, bool opening_question_mark = false,\n \t      std::vector<LifetimeParam> for_lifetimes\n \t      = std::vector<LifetimeParam> ())\n     : in_parens (in_parens), opening_question_mark (opening_question_mark),\n       for_lifetimes (std::move (for_lifetimes)),\n-      type_path (std::move (type_path)), locus (locus)\n+      type_path (std::move (type_path)), locus (locus), mappings (mapping)\n   {}\n \n   std::string as_string () const override;\n@@ -61,6 +58,19 @@ class TraitBound : public TypeParamBound\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  Location get_locus_slow () const override final { return get_locus (); }\n+\n+  BoundType get_bound_type () const final override { return TRAITBOUND; }\n+\n+  TypePath &get_path () { return type_path; }\n+\n+  const TypePath &get_path () const { return type_path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "20408bb677411516a8405c8488e0ad5b710df07c", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -406,6 +406,12 @@ class TypeNoBounds : public Type\n class TypeParamBound\n {\n public:\n+  enum BoundType\n+  {\n+    LIFETIME,\n+    TRAITBOUND\n+  };\n+\n   virtual ~TypeParamBound () {}\n \n   // Unique pointer custom clone function\n@@ -418,6 +424,12 @@ class TypeParamBound\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  virtual Analysis::NodeMapping get_mappings () const = 0;\n+\n+  virtual Location get_locus_slow () const = 0;\n+\n+  virtual BoundType get_bound_type () const = 0;\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual TypeParamBound *clone_type_param_bound_impl () const = 0;\n@@ -426,44 +438,31 @@ class TypeParamBound\n // Represents a lifetime (and is also a kind of type param bound)\n class Lifetime : public TypeParamBound\n {\n-public:\n-  enum LifetimeType\n-  {\n-    NAMED,   // corresponds to LIFETIME_OR_LABEL\n-    STATIC,  // corresponds to 'static\n-    WILDCARD // corresponds to '_\n-  };\n-\n private:\n-  LifetimeType lifetime_type;\n-\n-  // TODO: LIFETIME_OR_LABEL (aka lifetime token) is only field\n-  // find way of enclosing token or something\n+  AST::Lifetime::LifetimeType lifetime_type;\n   std::string lifetime_name;\n-  // only applies for NAMED lifetime_type\n-\n   Location locus;\n-\n   Analysis::NodeMapping mappings;\n \n public:\n   // Constructor\n-  Lifetime (Analysis::NodeMapping mapping, LifetimeType type, std::string name,\n-\t    Location locus)\n+  Lifetime (Analysis::NodeMapping mapping, AST::Lifetime::LifetimeType type,\n+\t    std::string name, Location locus)\n     : lifetime_type (type), lifetime_name (std::move (name)), locus (locus),\n       mappings (mapping)\n   {}\n \n   // Returns true if the lifetime is in an error state.\n   bool is_error () const\n   {\n-    return lifetime_type == NAMED && lifetime_name.empty ();\n+    return lifetime_type == AST::Lifetime::LifetimeType::NAMED\n+\t   && lifetime_name.empty ();\n   }\n \n   static Lifetime error ()\n   {\n-    return Lifetime (Analysis::NodeMapping::get_error (), LifetimeType::NAMED,\n-\t\t     \"\", Location ());\n+    return Lifetime (Analysis::NodeMapping::get_error (),\n+\t\t     AST::Lifetime::LifetimeType::NAMED, \"\", Location ());\n   }\n \n   std::string as_string () const override;\n@@ -472,11 +471,21 @@ class Lifetime : public TypeParamBound\n \n   std::string get_name () const { return lifetime_name; }\n \n-  LifetimeType get_lifetime_type () const { return lifetime_type; }\n+  AST::Lifetime::LifetimeType get_lifetime_type () const\n+  {\n+    return lifetime_type;\n+  }\n \n   Location get_locus () const { return locus; }\n \n-  Analysis::NodeMapping get_mappings () const { return mappings; }\n+  Analysis::NodeMapping get_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  Location get_locus_slow () const override final { return get_locus (); }\n+\n+  BoundType get_bound_type () const final override { return LIFETIME; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather"}, {"sha": "46ebdc42d9a5f59ddb8762f930dd1a8dcb8a8a80", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -297,6 +297,42 @@ class ResolveType : public ResolverBase\n   bool ok;\n };\n \n+class ResolveTypeBound : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static NodeId go (AST::TypeParamBound *type, NodeId parent,\n+\t\t    bool canonicalize_type_with_generics = false)\n+  {\n+    ResolveTypeBound resolver (parent, canonicalize_type_with_generics);\n+    type->accept_vis (resolver);\n+    if (!resolver.ok)\n+      rust_error_at (type->get_locus_slow (), \"unresolved type bound\");\n+\n+    return resolver.resolved_node;\n+  };\n+\n+  void visit (AST::TraitBound &bound) override\n+  {\n+    resolved_node = ResolveType::go (&bound.get_type_path (), parent,\n+\t\t\t\t     canonicalize_type_with_generics);\n+    ok = resolved_node != UNKNOWN_NODEID;\n+  }\n+\n+  void visit (AST::Lifetime &bound) override { ok = true; }\n+\n+private:\n+  ResolveTypeBound (NodeId parent, bool canonicalize_type_with_generics)\n+    : ResolverBase (parent),\n+      canonicalize_type_with_generics (canonicalize_type_with_generics),\n+      ok (false)\n+  {}\n+\n+  bool canonicalize_type_with_generics;\n+  bool ok;\n+};\n+\n class ResolveGenericParam : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n@@ -326,6 +362,14 @@ class ResolveGenericParam : public ResolverBase\n     if (param.has_type ())\n       ResolveType::go (param.get_type ().get (), param.get_node_id ());\n \n+    if (param.has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : param.get_type_param_bounds ())\n+\t  {\n+\t    ResolveTypeBound::go (bound.get (), param.get_node_id ());\n+\t  }\n+      }\n+\n     // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n     resolver->get_type_scope ().insert (\n       CanonicalPath::new_seg (param.get_node_id (),"}, {"sha": "8e3ca313e232d39ae24e80c10943e728bacbe6cb", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 246, "deletions": 31, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-full.h\"\n #include \"rust-tyty.h\"\n #include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-type-bounds.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -34,12 +35,80 @@ struct PathProbeCandidate\n     IMPL_CONST,\n     IMPL_TYPE_ALIAS,\n     IMPL_FUNC,\n+\n+    TRAIT_ITEM_CONST,\n+    TRAIT_TYPE_ALIAS,\n+    TRAIT_FUNC,\n+  };\n+\n+  struct ImplItemCandidate\n+  {\n+    HIR::ImplItem *impl_item;\n+    HIR::ImplBlock *parent;\n+  };\n+\n+  struct TraitItemCandidate\n+  {\n+    const TraitReference &trait_ref;\n+    const TraitItemReference &item_ref;\n   };\n \n   CandidateType type;\n-  HIR::ImplItem *impl_item;\n   TyTy::BaseType *ty;\n-  HIR::ImplBlock *parent;\n+  Location locus;\n+  union Candidate\n+  {\n+    ImplItemCandidate impl;\n+    TraitItemCandidate trait;\n+\n+    Candidate (ImplItemCandidate impl) : impl (impl) {}\n+    Candidate (TraitItemCandidate trait) : trait (trait) {}\n+  } item;\n+\n+  PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n+\t\t      ImplItemCandidate impl)\n+    : type (type), ty (ty), item (impl)\n+  {}\n+\n+  PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n+\t\t      TraitItemCandidate trait)\n+    : type (type), ty (ty), item (trait)\n+  {}\n+\n+  std::string as_string () const\n+  {\n+    return \"PathProbe candidate TODO - as_string\";\n+  }\n+\n+  bool is_impl_candidate () const\n+  {\n+    switch (type)\n+      {\n+      case IMPL_CONST:\n+      case IMPL_TYPE_ALIAS:\n+      case IMPL_FUNC:\n+\treturn true;\n+\n+      default:\n+\treturn false;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  bool is_trait_candidate () const\n+  {\n+    switch (type)\n+      {\n+      case TRAIT_ITEM_CONST:\n+      case TRAIT_TYPE_ALIAS:\n+      case TRAIT_FUNC:\n+\treturn true;\n+\n+      default:\n+\treturn false;\n+      }\n+    gcc_unreachable ();\n+  }\n };\n \n class PathProbeType : public TypeCheckBase\n@@ -48,32 +117,33 @@ class PathProbeType : public TypeCheckBase\n \n public:\n   static std::vector<PathProbeCandidate>\n-  Probe (TyTy::BaseType *receiver, const HIR::PathIdentSegment &segment_name)\n+  Probe (const TyTy::BaseType *receiver,\n+\t const HIR::PathIdentSegment &segment_name, bool probe_impls,\n+\t bool probe_bounds, bool ignore_mandatory_trait_items)\n   {\n     PathProbeType probe (receiver, segment_name);\n-    probe.mappings->iterate_impl_items (\n-      [&] (HirId id, HIR::ImplItem *item,\n-\t   HIR::ImplBlock *impl) mutable -> bool {\n-\tprobe.process_candidate (id, item, impl);\n-\treturn true;\n-      });\n+    if (probe_impls)\n+      probe.process_impl_items_for_candidates ();\n \n-    return probe.candidates;\n-  }\n+    if (!probe_bounds)\n+      return probe.candidates;\n \n-  void process_candidate (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl)\n-  {\n-    current_impl = impl;\n-    HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n-    TyTy::BaseType *impl_block_ty = nullptr;\n-    bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n-    rust_assert (ok);\n+    std::vector<std::reference_wrapper<TraitReference>> probed_bounds\n+      = TypeBoundsProbe::Probe (receiver);\n \n-    if (!receiver->can_eq (impl_block_ty, false))\n-      return;\n+    std::vector<std::reference_wrapper<const TraitReference>> specified_bounds;\n+    for (const TyTy::TypeBoundPredicate &predicate :\n+\t receiver->get_specified_bounds ())\n+      {\n+\tconst TraitReference *trait_item = predicate.get ();\n+\tspecified_bounds.push_back (*trait_item);\n+      }\n \n-    // lets visit the impl_item\n-    item->accept_vis (*this);\n+    std::vector<std::reference_wrapper<const TraitReference>> union_type_bounds\n+      = probe.union_bounds (probed_bounds, specified_bounds);\n+    probe.process_traits_for_candidates (union_type_bounds,\n+\t\t\t\t\t ignore_mandatory_trait_items);\n+    return probe.candidates;\n   }\n \n   void visit (HIR::TypeAlias &alias) override\n@@ -86,9 +156,11 @@ class PathProbeType : public TypeCheckBase\n \tbool ok = context->lookup_type (tyid, &ty);\n \trust_assert (ok);\n \n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&alias,\n+\t\t\t\t\t\t\t\t  current_impl};\n \tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, &alias, ty,\n-\t  current_impl};\n+\t  PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, ty,\n+\t  alias.get_locus (), impl_item_candidate};\n \tcandidates.push_back (std::move (candidate));\n       }\n   }\n@@ -103,9 +175,11 @@ class PathProbeType : public TypeCheckBase\n \tbool ok = context->lookup_type (tyid, &ty);\n \trust_assert (ok);\n \n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&constant,\n+\t\t\t\t\t\t\t\t  current_impl};\n \tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_CONST, &constant, ty,\n-\t  current_impl};\n+\t  PathProbeCandidate::CandidateType::IMPL_CONST, ty,\n+\t  constant.get_locus (), impl_item_candidate};\n \tcandidates.push_back (std::move (candidate));\n       }\n   }\n@@ -120,20 +194,146 @@ class PathProbeType : public TypeCheckBase\n \tbool ok = context->lookup_type (tyid, &ty);\n \trust_assert (ok);\n \n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&function,\n+\t\t\t\t\t\t\t\t  current_impl};\n \tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_FUNC, &function, ty,\n-\t  current_impl};\n+\t  PathProbeCandidate::CandidateType::IMPL_FUNC, ty,\n+\t  function.get_locus (), impl_item_candidate};\n \tcandidates.push_back (std::move (candidate));\n       }\n   }\n \n private:\n-  PathProbeType (TyTy::BaseType *receiver, const HIR::PathIdentSegment &query)\n+  void process_impl_items_for_candidates ()\n+  {\n+    mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n+\t\t\t\t       HIR::ImplBlock *impl) mutable -> bool {\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+  }\n+\n+  void process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n+\t\t\t\t    HIR::ImplBlock *impl)\n+  {\n+    current_impl = impl;\n+    HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n+    TyTy::BaseType *impl_block_ty = nullptr;\n+    bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n+    rust_assert (ok);\n+\n+    if (!receiver->can_eq (impl_block_ty, false))\n+      return;\n+\n+    // lets visit the impl_item\n+    item->accept_vis (*this);\n+  }\n+\n+  void process_traits_for_candidates (\n+    const std::vector<std::reference_wrapper<const TraitReference>> traits,\n+    bool ignore_mandatory_trait_items)\n+  {\n+    for (const TraitReference &trait_ref : traits)\n+      {\n+\tconst TraitItemReference &trait_item_ref\n+\t  = trait_ref.lookup_trait_item (search.as_string ());\n+\tif (trait_item_ref.is_error ())\n+\t  continue;\n+\n+\tbool trait_item_needs_implementation = !trait_item_ref.is_optional ();\n+\tif (ignore_mandatory_trait_items && trait_item_needs_implementation)\n+\t  continue;\n+\n+\tPathProbeCandidate::CandidateType candidate_type;\n+\tswitch (trait_item_ref.get_trait_item_type ())\n+\t  {\n+\t  case TraitItemReference::TraitItemType::FN:\n+\t    candidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\t    break;\n+\t  case TraitItemReference::TraitItemType::CONST:\n+\t    candidate_type\n+\t      = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+\t    break;\n+\t  case TraitItemReference::TraitItemType::TYPE:\n+\t    candidate_type\n+\t      = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+\t    break;\n+\n+\t  case TraitItemReference::TraitItemType::ERROR:\n+\t    gcc_unreachable ();\n+\t    break;\n+\t  }\n+\n+\tTyTy::BaseType *trait_item_tyty = trait_item_ref.get_tyty ();\n+\n+\t// we can substitute the Self with the receiver here\n+\tif (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t  {\n+\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+\t    TyTy::SubstitutionParamMapping *param = nullptr;\n+\t    for (auto &param_mapping : fn->get_substs ())\n+\t      {\n+\t\tconst HIR::TypeParam &type_param\n+\t\t  = param_mapping.get_generic_param ();\n+\t\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t\t  {\n+\t\t    param = &param_mapping;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    rust_assert (param != nullptr);\n+\n+\t    std::vector<TyTy::SubstitutionArg> mappings;\n+\t    mappings.push_back (\n+\t      TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+\t    Location locus; // FIXME\n+\t    TyTy::SubstitutionArgumentMappings args (std::move (mappings),\n+\t\t\t\t\t\t     locus);\n+\t    trait_item_tyty\n+\t      = SubstMapperInternal::Resolve (trait_item_tyty, args);\n+\t  }\n+\n+\tPathProbeCandidate::TraitItemCandidate trait_item_candidate{\n+\t  trait_ref, trait_item_ref};\n+\tPathProbeCandidate candidate{candidate_type,\n+\t\t\t\t     trait_item_tyty,\n+\t\t\t\t     trait_ref.get_locus (),\n+\t\t\t\t     {trait_item_candidate}};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+private:\n+  PathProbeType (const TyTy::BaseType *receiver,\n+\t\t const HIR::PathIdentSegment &query)\n     : TypeCheckBase (), receiver (receiver), search (query),\n       current_impl (nullptr)\n   {}\n \n-  TyTy::BaseType *receiver;\n+  std::vector<std::reference_wrapper<const TraitReference>> union_bounds (\n+    const std::vector<std::reference_wrapper</*const*/ TraitReference>> a,\n+    const std::vector<std::reference_wrapper<const TraitReference>> b) const\n+  {\n+    std::map<DefId, std::reference_wrapper<const TraitReference>> mapper;\n+    for (const TraitReference &ref : a)\n+      {\n+\tmapper.insert ({ref.get_mappings ().get_defid (), ref});\n+      }\n+    for (const TraitReference &ref : b)\n+      {\n+\tmapper.insert ({ref.get_mappings ().get_defid (), ref});\n+      }\n+\n+    std::vector<std::reference_wrapper<const TraitReference>> union_set;\n+    for (auto it = mapper.begin (); it != mapper.end (); it++)\n+      {\n+\tunion_set.push_back (it->second);\n+      }\n+    return union_set;\n+  }\n+\n+  const TyTy::BaseType *receiver;\n   const HIR::PathIdentSegment &search;\n   std::vector<PathProbeCandidate> candidates;\n   HIR::ImplBlock *current_impl;\n@@ -150,7 +350,22 @@ class ReportMultipleCandidateError : private TypeCheckBase\n     RichLocation r (query_locus);\n     ReportMultipleCandidateError visitor (r);\n     for (auto &c : candidates)\n-      c.impl_item->accept_vis (visitor);\n+      {\n+\tswitch (c.type)\n+\t  {\n+\t  case PathProbeCandidate::CandidateType::IMPL_CONST:\n+\t  case PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS:\n+\t  case PathProbeCandidate::CandidateType::IMPL_FUNC:\n+\t    c.item.impl.impl_item->accept_vis (visitor);\n+\t    break;\n+\n+\t  case PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST:\n+\t  case PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS:\n+\t  case PathProbeCandidate::CandidateType::TRAIT_FUNC:\n+\t    r.add_range (c.item.trait.item_ref.get_locus ());\n+\t    break;\n+\t  }\n+      }\n \n     rust_error_at (r, \"multiple applicable items in scope for: %s\",\n \t\t   query.as_string ().c_str ());"}, {"sha": "b19c38a39c1b72f71d879f464f714ea579f93623", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -56,6 +56,7 @@ class TraitItemReference\n     locus = other.locus;\n     context = other.context;\n \n+    inherited_substitutions.clear ();\n     inherited_substitutions.reserve (other.inherited_substitutions.size ());\n     for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n       inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n@@ -221,6 +222,21 @@ class TraitReference\n \t   + \"]\";\n   }\n \n+  const Analysis::NodeMapping &get_mappings () const\n+  {\n+    return hir_trait_ref->get_mappings ();\n+  }\n+\n+  const TraitItemReference &lookup_trait_item (const std::string &ident) const\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  return item;\n+      }\n+    return TraitItemReference::error_node ();\n+  }\n+\n   const TraitItemReference &\n   lookup_trait_item (const std::string &ident,\n \t\t     TraitItemReference::TraitItemType type) const"}, {"sha": "6d7c8645f3457025410375283c5de796a5b7a097", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -121,17 +121,15 @@ class TraitResolver : public TypeCheckBase\n     if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n \t\t\t\t\t &ref))\n       {\n-\trust_fatal_error (path.get_locus (),\n-\t\t\t  \"Failed to resolve path to node-id\");\n+\trust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n \treturn error_node ();\n       }\n \n     HirId hir_node = UNKNOWN_HIRID;\n     if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n \t\t\t\t       &hir_node))\n       {\n-\trust_fatal_error (path.get_locus (),\n-\t\t\t  \"Failed to resolve path to hir-id\");\n+\trust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n \treturn error_node ();\n       }\n "}, {"sha": "d97c0f561abcbc72a8a7b8d63170a0202da44e46", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_BOUNDS_H\n+#define RUST_HIR_TYPE_BOUNDS_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeBoundsProbe : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static std::vector<std::reference_wrapper<TraitReference>>\n+  Probe (const TyTy::BaseType *receiver)\n+  {\n+    TypeBoundsProbe probe (receiver);\n+    probe.scan ();\n+    return probe.trait_references;\n+  }\n+\n+private:\n+  void scan ();\n+\n+private:\n+  TypeBoundsProbe (const TyTy::BaseType *receiver)\n+    : TypeCheckBase (), receiver (receiver)\n+  {}\n+\n+  const TyTy::BaseType *receiver;\n+  std::vector<std::reference_wrapper<TraitReference>> trait_references;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_BOUNDS_H"}, {"sha": "f05ab86bc9d91981a12289b7a25d860ef2c5b455", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -28,6 +28,8 @@\n namespace Rust {\n namespace Resolver {\n \n+class TraitReference;\n+\n // base class to allow derivatives to overload as needed\n class TypeCheckBase : public HIR::HIRVisitor\n {\n@@ -200,6 +202,8 @@ class TypeCheckBase : public HIR::HIRVisitor\n       context (TypeCheckContext::get ())\n   {}\n \n+  TraitReference &resolve_trait_path (HIR::TypePath &);\n+\n   Analysis::Mappings *mappings;\n   Resolver *resolver;\n   TypeCheckContext *context;"}, {"sha": "7f1a83df025b372a22ad245047c7e133826f4780", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -205,15 +205,25 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n+    context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n+\n     // https://doc.rust-lang.org/reference/expressions/method-call-expr.html\n     // method resolution is complex in rust once we start handling generics and\n     // traits. For now we only support looking up the valid name in impl blocks\n     // which is simple. There will need to be adjustments to ensure we can turn\n     // the receiver into borrowed references etc\n \n+    bool reciever_is_generic\n+      = receiver_tyty->get_kind () == TyTy::TypeKind::PARAM;\n+    bool probe_bounds = true;\n+    bool probe_impls = !reciever_is_generic;\n+    bool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n     auto candidates\n       = PathProbeType::Probe (receiver_tyty,\n-\t\t\t      expr.get_method_name ().get_segment ());\n+\t\t\t      expr.get_method_name ().get_segment (),\n+\t\t\t      probe_impls, probe_bounds,\n+\t\t\t      ignore_mandatory_trait_items);\n     if (candidates.size () == 0)\n       {\n \trust_error_at (expr.get_locus (),\n@@ -229,13 +239,18 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     auto resolved_candidate = candidates.at (0);\n-    HIR::ImplItem *resolved_method = resolved_candidate.impl_item;\n     TyTy::BaseType *lookup_tyty = resolved_candidate.ty;\n+    NodeId resolved_node_id\n+      = resolved_candidate.is_impl_candidate ()\n+\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t      .get_nodeid ()\n+\t  : resolved_candidate.item.trait.item_ref.get_mappings ()\n+\t      .get_nodeid ();\n \n     if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n       {\n \tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_method->get_impl_locus ());\n+\tr.add_range (resolved_candidate.locus);\n \trust_error_at (r, \"associated impl item is not a method\");\n \treturn;\n       }\n@@ -245,7 +260,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!fn->is_method ())\n       {\n \tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_method->get_impl_locus ());\n+\tr.add_range (resolved_candidate.locus);\n \trust_error_at (r, \"associated function is not a method\");\n \treturn;\n       }\n@@ -303,20 +318,25 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n-    // apply any remaining generic arguments\n-    if (expr.get_method_name ().has_generic_args ())\n-      {\n-\tHIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-\tlookup\n-\t  = SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n-\t\t\t\t  &args);\n-\tif (lookup->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n-    else if (lookup->needs_generic_substitutions ())\n+    if (!reciever_is_generic)\n       {\n-\tlookup = SubstMapper::InferSubst (lookup,\n-\t\t\t\t\t  expr.get_method_name ().get_locus ());\n+\t// apply any remaining generic arguments\n+\tif (expr.get_method_name ().has_generic_args ())\n+\t  {\n+\t    HIR::GenericArgs &args\n+\t      = expr.get_method_name ().get_generic_args ();\n+\t    lookup = SubstMapper::Resolve (lookup,\n+\t\t\t\t\t   expr.get_method_name ().get_locus (),\n+\t\t\t\t\t   &args);\n+\t    if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n+\telse if (lookup->needs_generic_substitutions ())\n+\t  {\n+\t    lookup\n+\t      = SubstMapper::InferSubst (lookup,\n+\t\t\t\t\t expr.get_method_name ().get_locus ());\n+\t  }\n       }\n \n     TyTy::BaseType *function_ret_tyty\n@@ -333,9 +353,8 @@ class TypeCheckExpr : public TypeCheckBase\n     context->insert_type (expr.get_method_name ().get_mappings (), lookup);\n \n     // set up the resolved name on the path\n-    resolver->insert_resolved_name (\n-      expr.get_mappings ().get_nodeid (),\n-      resolved_method->get_impl_mappings ().get_nodeid ());\n+    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t    resolved_node_id);\n \n     // return the result of the function back\n     infered = function_ret_tyty;\n@@ -429,7 +448,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n \t\t\t\t       ref_node_id, &ref))\n       {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\trust_error_at (expr.get_locus (), \"123 reverse lookup failure\");\n \treturn;\n       }\n \n@@ -937,8 +956,16 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n \n+\tbool reciever_is_generic\n+\t  = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !reciever_is_generic;\n+\tbool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n \t// probe the path\n-\tauto candidates = PathProbeType::Probe (tyseg, seg.get_segment ());\n+\tauto candidates\n+\t  = PathProbeType::Probe (tyseg, seg.get_segment (), probe_impls,\n+\t\t\t\t  probe_bounds, ignore_mandatory_trait_items);\n \tif (candidates.size () == 0)\n \t  {\n \t    rust_error_at (\n@@ -954,11 +981,21 @@ class TypeCheckExpr : public TypeCheckBase\n \t    return;\n \t  }\n \n-\tauto candidate = candidates.at (0);\n+\tauto &candidate = candidates.at (0);\n \tprev_segment = tyseg;\n \ttyseg = candidate.ty;\n-\tresolved_node_id\n-\t  = candidate.impl_item->get_impl_mappings ().get_nodeid ();\n+\n+\tif (candidate.is_impl_candidate ())\n+\t  {\n+\t    resolved_node_id\n+\t      = candidate.item.impl.impl_item->get_impl_mappings ()\n+\t\t  .get_nodeid ();\n+\t  }\n+\telse\n+\t  {\n+\t    resolved_node_id\n+\t      = candidate.item.trait.item_ref.get_mappings ().get_nodeid ();\n+\t  }\n \n \tif (seg.has_generic_args ())\n \t  {\n@@ -977,15 +1014,17 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n+    context->insert_receiver (expr.get_mappings ().get_hirid (), prev_segment);\n     if (tyseg->needs_generic_substitutions ())\n       {\n \tLocation locus = expr.get_segments ().back ().get_locus ();\n \tif (!prev_segment->needs_generic_substitutions ())\n \t  {\n \t    auto used_args_in_prev_segment\n \t      = GetUsedSubstArgs::From (prev_segment);\n-\t    tyseg\n-\t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n+\t    if (!used_args_in_prev_segment.is_error ())\n+\t      tyseg = SubstMapperInternal::Resolve (tyseg,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n \t  }\n \telse\n \t  {\n@@ -1214,7 +1253,13 @@ class TypeCheckExpr : public TypeCheckBase\n \t  {\n \t    if (is_root)\n \t      {\n-\t\trust_error_at (seg.get_locus (), \"reverse lookup failure\");\n+\t\trust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n+\t\trust_debug_loc (\n+\t\t  seg.get_locus (),\n+\t\t  \"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\t  seg.as_string ().c_str (),\n+\t\t  seg.get_mappings ().as_string ().c_str (), ref_node_id);\n+\n \t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t      }\n \t    return root_tyty;"}, {"sha": "91d9c53ac2e332f41b7caf8e118dabf667ebf745", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -215,7 +215,7 @@ class TypeCheckType : public TypeCheckBase\n   {}\n \n   void\n-  check_for_unconstrained (std::vector<std::unique_ptr<HIR::Type> > &type_args)\n+  check_for_unconstrained (std::vector<std::unique_ptr<HIR::Type>> &type_args)\n   {\n     std::map<std::string, Location> param_location_map;\n     std::set<std::string> param_tys;\n@@ -270,8 +270,31 @@ class TypeResolveGenericParam : public TypeCheckBase\n     if (param.has_type ())\n       TypeCheckType::Resolve (param.get_type ().get ());\n \n+    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+    if (param.has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : param.get_type_param_bounds ())\n+\t  {\n+\t    switch (bound->get_bound_type ())\n+\t      {\n+\t\tcase HIR::TypeParamBound::BoundType::TRAITBOUND: {\n+\t\t  HIR::TraitBound *b\n+\t\t    = static_cast<HIR::TraitBound *> (bound.get ());\n+\t\t  TyTy::TypeBoundPredicate predicate (\n+\t\t    &resolve_trait_path (b->get_path ()));\n+\t\t  specified_bounds.push_back (std::move (predicate));\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n     resolved = new TyTy::ParamType (param.get_type_representation (),\n-\t\t\t\t    param.get_mappings ().get_hirid (), param);\n+\t\t\t\t    param.get_mappings ().get_hirid (), param,\n+\t\t\t\t    specified_bounds);\n   }\n \n private:"}, {"sha": "4b66fdbd6e65e506a247f6f05108261a4062b08c", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -418,6 +418,7 @@ TraitItemReference::TraitItemReference (TraitItemReference const &other)\n     type (other.type), hir_trait_item (other.hir_trait_item),\n     locus (other.locus), self (other.self), context (TypeCheckContext::get ())\n {\n+  inherited_substitutions.clear ();\n   inherited_substitutions.reserve (other.inherited_substitutions.size ());\n   for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n     inherited_substitutions.push_back (other.inherited_substitutions.at (i));"}, {"sha": "b171123e122b160baaeec4cde2d20f87c6c745ae", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -102,6 +102,21 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_receiver (HirId id, TyTy::BaseType *t)\n+  {\n+    receiver_context[id] = t;\n+  }\n+\n+  bool lookup_receiver (HirId id, TyTy::BaseType **ref)\n+  {\n+    auto it = receiver_context.find (id);\n+    if (it == receiver_context.end ())\n+      return false;\n+\n+    *ref = it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n@@ -111,6 +126,7 @@ class TypeCheckContext\n   std::vector<TyTy::BaseType *> return_type_stack;\n   std::vector<TyTy::BaseType *> loop_type_stack;\n   std::map<DefId, TraitReference> trait_context;\n+  std::map<HirId, TyTy::BaseType *> receiver_context;\n };\n \n class TypeResolution"}, {"sha": "a3c00da611137e645a346c328472a777345451f5", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -280,24 +280,24 @@ class GetUsedSubstArgs : public TyTy::TyVisitor\n     args = type.get_substitution_arguments ();\n   }\n \n-  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n-  void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n-  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n-  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &) override { gcc_unreachable (); }\n-  void visit (TyTy::USizeType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ISizeType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n-  void visit (TyTy::CharType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n-  void visit (TyTy::PointerType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n-  void visit (TyTy::StrType &) override { gcc_unreachable (); }\n-  void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (TyTy::InferType &) override {}\n+  void visit (TyTy::TupleType &) override {}\n+  void visit (TyTy::FnPtr &) override {}\n+  void visit (TyTy::ArrayType &) override {}\n+  void visit (TyTy::BoolType &) override {}\n+  void visit (TyTy::IntType &) override {}\n+  void visit (TyTy::UintType &) override {}\n+  void visit (TyTy::FloatType &) override {}\n+  void visit (TyTy::USizeType &) override {}\n+  void visit (TyTy::ISizeType &) override {}\n+  void visit (TyTy::ErrorType &) override {}\n+  void visit (TyTy::CharType &) override {}\n+  void visit (TyTy::ReferenceType &) override {}\n+  void visit (TyTy::PointerType &) override {}\n+  void visit (TyTy::ParamType &) override {}\n+  void visit (TyTy::StrType &) override {}\n+  void visit (TyTy::NeverType &) override {}\n+  void visit (TyTy::PlaceholderType &) override {}\n \n private:\n   GetUsedSubstArgs () : args (TyTy::SubstitutionArgumentMappings::error ()) {}"}, {"sha": "a480155b2feb7f94f614a41b7e5224bb1ab72fba", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -0,0 +1,75 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeBoundsProbe::scan ()\n+{\n+  std::vector<HIR::TypePath *> possible_trait_paths;\n+  mappings->iterate_impl_blocks (\n+    [&] (HirId id, HIR::ImplBlock *impl) mutable -> bool {\n+      // we are filtering for trait-impl-blocks\n+      if (!impl->has_trait_ref ())\n+\treturn true;\n+\n+      TyTy::BaseType *impl_type = nullptr;\n+      bool ok\n+\t= context->lookup_type (impl->get_type ()->get_mappings ().get_hirid (),\n+\t\t\t\t&impl_type);\n+      if (!ok)\n+\treturn true;\n+\n+      if (!receiver->can_eq (impl_type, false))\n+\treturn true;\n+\n+      possible_trait_paths.push_back (impl->get_trait_ref ().get ());\n+      return true;\n+    });\n+\n+  for (auto &trait_path : possible_trait_paths)\n+    {\n+      TraitReference &trait_ref = TraitResolver::Resolve (*trait_path);\n+\n+      if (!trait_ref.is_error ())\n+\ttrait_references.push_back (trait_ref);\n+    }\n+}\n+\n+TraitReference &\n+TypeCheckBase::resolve_trait_path (HIR::TypePath &path)\n+{\n+  return TraitResolver::Resolve (path);\n+}\n+\n+} // namespace Resolver\n+\n+namespace TyTy {\n+\n+std::string\n+TypeBoundPredicate::as_string () const\n+{\n+  return reference->as_string ();\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "a2ae4fa26ef725a9b34b7d19fcec1ea7e64f9479", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -127,7 +127,7 @@ InferType::cast (BaseType *other)\n }\n \n BaseType *\n-InferType::clone ()\n+InferType::clone () const\n {\n   return new InferType (get_ref (), get_ty_ref (), get_infer_kind (),\n \t\t\tget_combined_refs ());\n@@ -201,7 +201,7 @@ ErrorType::cast (BaseType *other)\n }\n \n BaseType *\n-ErrorType::clone ()\n+ErrorType::clone () const\n {\n   return new ErrorType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n@@ -243,6 +243,7 @@ SubstitutionParamMapping::override_context ()\n \n   auto mappings = Analysis::Mappings::get ();\n   auto context = Resolver::TypeCheckContext::get ();\n+\n   context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n \t\t\t\t\t       UNKNOWN_NODEID,\n \t\t\t\t\t       param->get_ref (),\n@@ -531,7 +532,7 @@ ADTType::is_equal (const BaseType &other) const\n }\n \n BaseType *\n-ADTType::clone ()\n+ADTType::clone () const\n {\n   std::vector<StructFieldType *> cloned_fields;\n   for (auto &f : fields)\n@@ -687,7 +688,7 @@ TupleType::is_equal (const BaseType &other) const\n }\n \n BaseType *\n-TupleType::clone ()\n+TupleType::clone () const\n {\n   return new TupleType (get_ref (), get_ty_ref (), fields,\n \t\t\tget_combined_refs ());\n@@ -808,7 +809,7 @@ FnType::is_equal (const BaseType &other) const\n }\n \n BaseType *\n-FnType::clone ()\n+FnType::clone () const\n {\n   std::vector<std::pair<HIR::Pattern *, BaseType *> > cloned_params;\n   for (auto &p : params)\n@@ -1011,7 +1012,7 @@ FnPtr::is_equal (const BaseType &other) const\n }\n \n BaseType *\n-FnPtr::clone ()\n+FnPtr::clone () const\n {\n   std::vector<TyVar> cloned_params;\n   for (auto &p : params)\n@@ -1097,7 +1098,7 @@ ArrayType::get_element_type () const\n }\n \n BaseType *\n-ArrayType::clone ()\n+ArrayType::clone () const\n {\n   return new ArrayType (get_ref (), get_ty_ref (), get_capacity (),\n \t\t\telement_type, get_combined_refs ());\n@@ -1150,7 +1151,7 @@ BoolType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-BoolType::clone ()\n+BoolType::clone () const\n {\n   return new BoolType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n@@ -1216,7 +1217,7 @@ IntType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-IntType::clone ()\n+IntType::clone () const\n {\n   return new IntType (get_ref (), get_ty_ref (), get_int_kind (),\n \t\t      get_combined_refs ());\n@@ -1293,7 +1294,7 @@ UintType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-UintType::clone ()\n+UintType::clone () const\n {\n   return new UintType (get_ref (), get_ty_ref (), get_uint_kind (),\n \t\t       get_combined_refs ());\n@@ -1364,7 +1365,7 @@ FloatType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-FloatType::clone ()\n+FloatType::clone () const\n {\n   return new FloatType (get_ref (), get_ty_ref (), get_float_kind (),\n \t\t\tget_combined_refs ());\n@@ -1427,7 +1428,7 @@ USizeType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-USizeType::clone ()\n+USizeType::clone () const\n {\n   return new USizeType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n@@ -1479,7 +1480,7 @@ ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-ISizeType::clone ()\n+ISizeType::clone () const\n {\n   return new ISizeType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n@@ -1531,7 +1532,7 @@ CharType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-CharType::clone ()\n+CharType::clone () const\n {\n   return new CharType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n@@ -1600,7 +1601,7 @@ ReferenceType::get_base () const\n }\n \n BaseType *\n-ReferenceType::clone ()\n+ReferenceType::clone () const\n {\n   return new ReferenceType (get_ref (), get_ty_ref (), base, is_mutable (),\n \t\t\t    get_combined_refs ());\n@@ -1686,7 +1687,7 @@ PointerType::get_base () const\n }\n \n BaseType *\n-PointerType::clone ()\n+PointerType::clone () const\n {\n   return new PointerType (get_ref (), get_ty_ref (), base, is_mutable (),\n \t\t\t  get_combined_refs ());\n@@ -1765,10 +1766,10 @@ ParamType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-ParamType::clone ()\n+ParamType::clone () const\n {\n-  return new ParamType (get_symbol (), get_ref (), get_ty_ref (),\n-\t\t\tget_generic_param (), get_combined_refs ());\n+  return new ParamType (get_symbol (), get_ref (), get_ty_ref (), param,\n+\t\t\tget_specified_bounds (), get_combined_refs ());\n }\n \n std::string\n@@ -1780,8 +1781,6 @@ ParamType::get_symbol () const\n BaseType *\n ParamType::resolve () const\n {\n-  rust_assert (can_resolve ());\n-\n   TyVar var (get_ty_ref ());\n   BaseType *r = var.get_tyty ();\n \n@@ -1795,7 +1794,10 @@ ParamType::resolve () const\n       r = v.get_tyty ();\n     }\n \n-  return TyVar (r->get_ty_ref ()).get_tyty ();\n+  if (r->get_kind () == TypeKind::PARAM && (r->get_ref () == r->get_ty_ref ()))\n+    return TyVar (r->get_ty_ref ()).get_tyty ();\n+\n+  return r;\n }\n \n bool\n@@ -1833,7 +1835,7 @@ ParamType::handle_substitions (SubstitutionArgumentMappings mappings)\n }\n \n BaseType *\n-StrType::clone ()\n+StrType::clone () const\n {\n   return new StrType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n@@ -1937,7 +1939,7 @@ NeverType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-NeverType::clone ()\n+NeverType::clone () const\n {\n   return new NeverType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n@@ -1989,7 +1991,7 @@ PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n }\n \n BaseType *\n-PlaceholderType::clone ()\n+PlaceholderType::clone () const\n {\n   return new PlaceholderType (get_ref (), get_ty_ref (), get_combined_refs ());\n }"}, {"sha": "13bab904def5bfe06de6b42a4a1679ace23c6cab", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 99, "deletions": 38, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -25,6 +25,10 @@\n #include \"rust-diagnostics.h\"\n \n namespace Rust {\n+namespace Resolver {\n+class TraitReference;\n+}\n+\n namespace TyTy {\n \n // https://rustc-dev-guide.rust-lang.org/type-inference.html#inference-variables\n@@ -125,9 +129,56 @@ class TypeKindFormat\n   }\n };\n \n+class TypeBoundPredicate\n+{\n+public:\n+  TypeBoundPredicate (Resolver::TraitReference *reference)\n+    : reference (reference)\n+  {}\n+\n+  TypeBoundPredicate (const TypeBoundPredicate &other)\n+    : reference (other.reference)\n+  {}\n+\n+  TypeBoundPredicate &operator= (const TypeBoundPredicate &other)\n+  {\n+    reference = other.reference;\n+    return *this;\n+  }\n+\n+  std::string as_string () const;\n+\n+  const Resolver::TraitReference *get () const { return reference; }\n+\n+private:\n+  Resolver::TraitReference *reference;\n+};\n+\n+class TypeBoundsMappings\n+{\n+protected:\n+  TypeBoundsMappings (std::vector<TypeBoundPredicate> specified_bounds)\n+    : specified_bounds (specified_bounds)\n+  {}\n+\n+public:\n+  std::vector<TypeBoundPredicate> &get_specified_bounds ()\n+  {\n+    return specified_bounds;\n+  }\n+\n+  const std::vector<TypeBoundPredicate> &get_specified_bounds () const\n+  {\n+    return specified_bounds;\n+  }\n+\n+protected:\n+  std::vector<TypeBoundPredicate> specified_bounds;\n+};\n+\n class TyVisitor;\n class TyConstVisitor;\n-class BaseType\n+class BaseType : public TypeBoundsMappings\n {\n public:\n   virtual ~BaseType () {}\n@@ -194,10 +245,10 @@ class BaseType\n \n   /* Returns a pointer to a clone of this. The caller is responsible for\n    * releasing the memory of the returned ty. */\n-  virtual BaseType *clone () = 0;\n+  virtual BaseType *clone () const = 0;\n \n   // get_combined_refs returns the chain of node refs involved in unification\n-  std::set<HirId> get_combined_refs () { return combined; }\n+  std::set<HirId> get_combined_refs () const { return combined; }\n \n   void append_reference (HirId id) { combined.insert (id); }\n \n@@ -240,8 +291,15 @@ class BaseType\n protected:\n   BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n \t    std::set<HirId> refs = std::set<HirId> ())\n-    : kind (kind), ref (ref), ty_ref (ty_ref), combined (refs),\n-      mappings (Analysis::Mappings::get ())\n+    : TypeBoundsMappings ({}), kind (kind), ref (ref), ty_ref (ty_ref),\n+      combined (refs), mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n+\t    std::vector<TypeBoundPredicate> specified_bounds,\n+\t    std::set<HirId> refs = std::set<HirId> ())\n+    : TypeBoundsMappings (specified_bounds), kind (kind), ref (ref),\n+      ty_ref (ty_ref), combined (refs), mappings (Analysis::Mappings::get ())\n   {}\n \n   TypeKind kind;\n@@ -300,7 +358,7 @@ class InferType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   InferTypeKind get_infer_kind () const { return infer_kind; }\n \n@@ -337,7 +395,7 @@ class ErrorType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   std::string get_name () const override final { return as_string (); }\n };\n@@ -347,15 +405,18 @@ class ParamType : public BaseType\n {\n public:\n   ParamType (std::string symbol, HirId ref, HIR::GenericParam &param,\n+\t     std::vector<TypeBoundPredicate> specified_bounds,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PARAM, refs), symbol (symbol), param (param)\n+    : BaseType (ref, ref, TypeKind::PARAM, specified_bounds, refs),\n+      symbol (symbol), param (param)\n   {}\n \n   ParamType (std::string symbol, HirId ref, HirId ty_ref,\n \t     HIR::GenericParam &param,\n+\t     std::vector<TypeBoundPredicate> specified_bounds,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PARAM, refs), symbol (symbol),\n-      param (param)\n+    : BaseType (ref, ty_ref, TypeKind::PARAM, specified_bounds, refs),\n+      symbol (symbol), param (param)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -368,7 +429,7 @@ class ParamType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   std::string get_symbol () const;\n \n@@ -462,7 +523,7 @@ class TupleType : public BaseType\n \n   BaseType *get_field (size_t index) const;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   bool is_concrete () const override final\n   {\n@@ -527,7 +588,7 @@ class SubstitutionParamMapping\n       }\n   }\n \n-  SubstitutionParamMapping clone ()\n+  SubstitutionParamMapping clone () const\n   {\n     return SubstitutionParamMapping (generic, static_cast<ParamType *> (\n \t\t\t\t\t\tparam->clone ()));\n@@ -728,7 +789,7 @@ class SubstitutionRef\n     return substitutions;\n   }\n \n-  std::vector<SubstitutionParamMapping> clone_substs ()\n+  std::vector<SubstitutionParamMapping> clone_substs () const\n   {\n     std::vector<SubstitutionParamMapping> clone;\n \n@@ -885,9 +946,9 @@ class ADTType : public BaseType, public SubstitutionRef\n       identifier (identifier), fields (fields), adt_kind (adt_kind)\n   {}\n \n-  ADTKind get_adt_kind () { return adt_kind; }\n-  bool is_tuple_struct () { return adt_kind == TUPLE_STRUCT; }\n-  bool is_union () { return adt_kind == UNION; }\n+  ADTKind get_adt_kind () const { return adt_kind; }\n+  bool is_tuple_struct () const { return adt_kind == TUPLE_STRUCT; }\n+  bool is_union () const { return adt_kind == UNION; }\n \n   bool is_unit () const override { return this->fields.empty (); }\n \n@@ -942,7 +1003,7 @@ class ADTType : public BaseType, public SubstitutionRef\n     return nullptr;\n   }\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   std::vector<StructFieldType *> &get_fields () { return fields; }\n   const std::vector<StructFieldType *> &get_fields () const { return fields; }\n@@ -986,7 +1047,7 @@ class FnType : public BaseType, public SubstitutionRef\n #define FNTYPE_IS_VARADIC_FLAG 0X04\n \n   FnType (HirId ref, DefId id, std::string identifier, uint8_t flags,\n-\t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n+\t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::FNDEF, refs),\n@@ -1001,7 +1062,7 @@ class FnType : public BaseType, public SubstitutionRef\n \n   FnType (HirId ref, HirId ty_ref, DefId id, std::string identifier,\n \t  uint8_t flags,\n-\t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n+\t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::FNDEF, refs),\n@@ -1054,12 +1115,12 @@ class FnType : public BaseType, public SubstitutionRef\n     return get_params ().at (0).second;\n   }\n \n-  std::vector<std::pair<HIR::Pattern *, BaseType *> > &get_params ()\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> &get_params ()\n   {\n     return params;\n   }\n \n-  const std::vector<std::pair<HIR::Pattern *, BaseType *> > &get_params () const\n+  const std::vector<std::pair<HIR::Pattern *, BaseType *>> &get_params () const\n   {\n     return params;\n   }\n@@ -1076,7 +1137,7 @@ class FnType : public BaseType, public SubstitutionRef\n \n   BaseType *get_return_type () const { return type; }\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   bool needs_generic_substitutions () const override final\n   {\n@@ -1094,7 +1155,7 @@ class FnType : public BaseType, public SubstitutionRef\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n private:\n-  std::vector<std::pair<HIR::Pattern *, BaseType *> > params;\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> params;\n   BaseType *type;\n   uint8_t flags;\n   std::string identifier;\n@@ -1136,7 +1197,7 @@ class FnPtr : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   void iterate_params (std::function<bool (BaseType *)> cb) const\n   {\n@@ -1186,7 +1247,7 @@ class ArrayType : public BaseType\n \n   BaseType *get_element_type () const;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   bool is_concrete () const final override\n   {\n@@ -1221,7 +1282,7 @@ class BoolType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n };\n \n class IntType : public BaseType\n@@ -1259,7 +1320,7 @@ class IntType : public BaseType\n \n   IntKind get_int_kind () const { return int_kind; }\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1302,7 +1363,7 @@ class UintType : public BaseType\n \n   UintKind get_uint_kind () const { return uint_kind; }\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1343,7 +1404,7 @@ class FloatType : public BaseType\n \n   FloatKind get_float_kind () const { return float_kind; }\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1374,7 +1435,7 @@ class USizeType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n };\n \n class ISizeType : public BaseType\n@@ -1400,7 +1461,7 @@ class ISizeType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n };\n \n class CharType : public BaseType\n@@ -1426,7 +1487,7 @@ class CharType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n };\n \n class ReferenceType : public BaseType\n@@ -1458,7 +1519,7 @@ class ReferenceType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   bool contains_type_parameters () const override final\n   {\n@@ -1504,7 +1565,7 @@ class PointerType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   bool contains_type_parameters () const override final\n   {\n@@ -1547,7 +1608,7 @@ class StrType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n };\n \n // https://doc.rust-lang.org/std/primitive.never.html\n@@ -1581,7 +1642,7 @@ class NeverType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   std::string get_name () const override final { return as_string (); }\n \n@@ -1612,7 +1673,7 @@ class PlaceholderType : public BaseType\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n-  BaseType *clone () final override;\n+  BaseType *clone () const final override;\n \n   std::string get_name () const override final { return as_string (); }\n "}, {"sha": "4ffbff053745953f2ad0ed9e4611f2ccce5323cb", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -382,6 +382,56 @@ Mappings::lookup_hir_expr (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_path_expr_seg (CrateNum crateNum, HirId id,\n+\t\t\t\t    HIR::PathExprSegment *expr)\n+{\n+  rust_assert (lookup_hir_path_expr_seg (crateNum, id) == nullptr);\n+\n+  hirPathSegMappings[crateNum][id] = expr;\n+  nodeIdToHirMappings[crateNum][expr->get_mappings ().get_nodeid ()] = id;\n+  insert_location (crateNum, id, expr->get_locus ());\n+}\n+\n+HIR::PathExprSegment *\n+Mappings::lookup_hir_path_expr_seg (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirPathSegMappings.find (crateNum);\n+  if (it == hirPathSegMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_hir_generic_param (CrateNum crateNum, HirId id,\n+\t\t\t\t    HIR::GenericParam *param)\n+{\n+  rust_assert (lookup_hir_generic_param (crateNum, id) == nullptr);\n+\n+  hirGenericParamMappings[crateNum][id] = param;\n+  nodeIdToHirMappings[crateNum][param->get_mappings ().get_nodeid ()] = id;\n+  insert_location (crateNum, id, param->get_locus_slow ());\n+}\n+\n+HIR::GenericParam *\n+Mappings::lookup_hir_generic_param (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirGenericParamMappings.find (crateNum);\n+  if (it == hirGenericParamMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_hir_type (CrateNum crateNum, HirId id, HIR::Type *type)\n {"}, {"sha": "ccc873bb5a64f77a66523d9dc644ca68726a3457", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -148,6 +148,14 @@ class Mappings\n   void insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr);\n   HIR::Expr *lookup_hir_expr (CrateNum crateNum, HirId id);\n \n+  void insert_hir_path_expr_seg (CrateNum crateNum, HirId id,\n+\t\t\t\t HIR::PathExprSegment *expr);\n+  HIR::PathExprSegment *lookup_hir_path_expr_seg (CrateNum crateNum, HirId id);\n+\n+  void insert_hir_generic_param (CrateNum crateNum, HirId id,\n+\t\t\t\t HIR::GenericParam *expr);\n+  HIR::GenericParam *lookup_hir_generic_param (CrateNum crateNum, HirId id);\n+\n   void insert_hir_type (CrateNum crateNum, HirId id, HIR::Type *type);\n   HIR::Type *lookup_hir_type (CrateNum crateNum, HirId id);\n \n@@ -215,6 +223,20 @@ class Mappings\n \t   != nullptr;\n   }\n \n+  void insert_trait_item_mapping (HirId trait_item_id, HIR::Trait *trait)\n+  {\n+    rust_assert (hirTraitItemsToTraitMappings.find (trait_item_id)\n+\t\t == hirTraitItemsToTraitMappings.end ());\n+    hirTraitItemsToTraitMappings[trait_item_id] = trait;\n+  }\n+\n+  HIR::Trait *lookup_trait_item_mapping (HirId trait_item_id)\n+  {\n+    auto lookup = hirTraitItemsToTraitMappings.find (trait_item_id);\n+    rust_assert (lookup != hirTraitItemsToTraitMappings.end ());\n+    return lookup->second;\n+  }\n+\n private:\n   Mappings ();\n \n@@ -245,6 +267,11 @@ class Mappings\n   std::map<CrateNum, std::map<HirId, HIR::TraitItem *> > hirTraitItemMappings;\n   std::map<CrateNum, std::map<HirId, HIR::ExternalItem *> >\n     hirExternItemMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::PathExprSegment *> >\n+    hirPathSegMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::GenericParam *> >\n+    hirGenericParamMappings;\n+  std::map<HirId, HIR::Trait *> hirTraitItemsToTraitMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;"}, {"sha": "0e83a7d3163a1188dc41b774f064afc3256ff889", "filename": "gcc/testsuite/rust/compile/torture/traits8.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits8.rs?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -0,0 +1,22 @@\n+trait Foo {\n+    fn default() -> i32;\n+}\n+\n+struct Bar(i32);\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl Foo for Bar {\n+    fn default() -> i32 {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        123\n+    }\n+}\n+\n+fn type_bound_test<T: Foo>() -> i32 {\n+    T::default()\n+}\n+\n+fn main() {\n+    let a;\n+    a = type_bound_test::<Bar>();\n+}"}, {"sha": "075a2192033535e640098195501aa78caf5466b2", "filename": "gcc/testsuite/rust/compile/torture/traits9.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935f1d7da3ea82980bed642c6eea06d69de5fdf6/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits9.rs?ref=935f1d7da3ea82980bed642c6eea06d69de5fdf6", "patch": "@@ -0,0 +1,30 @@\n+trait Foo {\n+    fn default() -> i32;\n+    fn get(self) -> i32;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct Bar(i32);\n+impl Foo for Bar {\n+    fn default() -> i32 {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        123\n+    }\n+\n+    fn get(self) -> i32 {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.0\n+    }\n+}\n+\n+fn type_bound_test<T: Foo>(a: T) -> i32 {\n+    T::default() + a.get()\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar(456);\n+\n+    let b;\n+    b = type_bound_test(a);\n+}"}]}