{"sha": "e57bbcb24146139c48911deced919939f69b0646", "node_id": "C_kwDOANBUbNoAKGU1N2JiY2IyNDE0NjEzOWM0ODkxMWRlY2VkOTE5OTM5ZjY5YjA2NDY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-08-11T12:59:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-11T12:59:01Z"}, "message": "Merge #1458 #1463\n\n1458: Refactor type resolution pass to use fine grained visitors r=philberty a=philberty\n\nThanks for `@dkm` work on fine-grained HIR visitors this patch takes advantage of this\r\nand moves most implementation into CC files and takes advantage of fine-grained visitors\r\nthis will help with the maintainability of the code and it also makes it clear what classes do\r\nand don't do.\r\n\r\nIt's part of an incremental refactor to get rid of the awkward top-level scan pass in the\r\ntype resolution pass. This will allow us to move towards a more query-based model\r\nlike the code generation pass so that we can support the forward declared items.\r\n\r\nThe problem is that we our name resolution pass supports forward declared items but our\r\ntype resolution pass does not. We know the HIR nodes when type paths or path expressions\r\nresolve to but when it comes to actually resolve this we just fail when we reuse our mappings\r\nclass to look up the item.\n\n1463: Remove unused backend wrapper r=philberty a=philberty\n\nThis removes the unused switch statement wrapper\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "b1d8f4aa974d1c157be4c92bda88fd4e6e536233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1d8f4aa974d1c157be4c92bda88fd4e6e536233"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e57bbcb24146139c48911deced919939f69b0646", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi9P0VCRBK7hj4Ov3rIwAAOsgIADGntXk44p3v0VInWJ+B/Xdb\nw22rFqNDHFTbiSNYE0UND9KoIgZbV90QVWmXe5NPoLFf7EDDWT9RhOoaQFDG30cN\nw+s27h63TtdDfLWTKZ5yGDduXReyPFRKczu71vK5WKFgmSMYZOGL8isN7arExlVd\nukUT59EbW0ckFLR6+N/yFm0qZS/3X/MvHtFt6yxiqYsWGSxkKWNZH6ra3Gk9Rhlp\n+qkyOlHlPZd/uyn0zHi1BaXptWyaeAKxt+l6RJSJKKl7LYLcvgNEvU+4E4ehn2X6\nHb/wGRs6azH78P5uTZRGzSEqFM1MoA1wbv1/3TbjqKPll4g0VpEU80Aje5uRFVg=\n=BdyH\n-----END PGP SIGNATURE-----\n", "payload": "tree b1d8f4aa974d1c157be4c92bda88fd4e6e536233\nparent b28f1384830dcd2bad277208157710364e28797e\nparent 2ad0cde0a506d3a8a284a7e1178830f53648f9c3\nparent d91796f90d437ed003cae88a7d9f8eb7a573f21b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1660222741 +0000\ncommitter GitHub <noreply@github.com> 1660222741 +0000\n\nMerge #1458 #1463\n\n1458: Refactor type resolution pass to use fine grained visitors r=philberty a=philberty\n\nThanks for `@dkm` work on fine-grained HIR visitors this patch takes advantage of this\r\nand moves most implementation into CC files and takes advantage of fine-grained visitors\r\nthis will help with the maintainability of the code and it also makes it clear what classes do\r\nand don't do.\r\n\r\nIt's part of an incremental refactor to get rid of the awkward top-level scan pass in the\r\ntype resolution pass. This will allow us to move towards a more query-based model\r\nlike the code generation pass so that we can support the forward declared items.\r\n\r\nThe problem is that we our name resolution pass supports forward declared items but our\r\ntype resolution pass does not. We know the HIR nodes when type paths or path expressions\r\nresolve to but when it comes to actually resolve this we just fail when we reuse our mappings\r\nclass to look up the item.\n\n1463: Remove unused backend wrapper r=philberty a=philberty\n\nThis removes the unused switch statement wrapper\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57bbcb24146139c48911deced919939f69b0646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e57bbcb24146139c48911deced919939f69b0646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57bbcb24146139c48911deced919939f69b0646/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b28f1384830dcd2bad277208157710364e28797e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28f1384830dcd2bad277208157710364e28797e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b28f1384830dcd2bad277208157710364e28797e"}, {"sha": "2ad0cde0a506d3a8a284a7e1178830f53648f9c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad0cde0a506d3a8a284a7e1178830f53648f9c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ad0cde0a506d3a8a284a7e1178830f53648f9c3"}, {"sha": "d91796f90d437ed003cae88a7d9f8eb7a573f21b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91796f90d437ed003cae88a7d9f8eb7a573f21b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91796f90d437ed003cae88a7d9f8eb7a573f21b"}], "stats": {"total": 5087, "additions": 2716, "deletions": 2371}, "files": [{"sha": "23dad26e8c4a3fe5138935a8e597e050c2cca047", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -117,6 +117,9 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-struct.o \\\n     rust/rust-hir-type-check-pattern.o \\\n     rust/rust-hir-type-check-expr.o \\\n+    rust/rust-hir-type-check-stmt.o \\\n+    rust/rust-hir-type-check-enumitem.o \\\n+    rust/rust-hir-type-check-implitem.o \\\n     rust/rust-hir-dot-operator.o \\\n     rust/rust-coercion.o \\\n     rust/rust-hir-type-check-base.o \\"}, {"sha": "832785296460661714d4d1d3565a433440bd4682", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -1409,6 +1409,13 @@ struct StructBase\n class StructExprField\n {\n public:\n+  enum StructExprFieldKind\n+  {\n+    IDENTIFIER_VALUE,\n+    IDENTIFIER,\n+    INDEX_VALUE,\n+  };\n+\n   virtual ~StructExprField () {}\n \n   // Unique pointer custom clone function\n@@ -1426,6 +1433,8 @@ class StructExprField\n \n   Location get_locus () { return locus; }\n \n+  virtual StructExprFieldKind get_kind () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual StructExprField *clone_struct_expr_field_impl () const = 0;\n@@ -1441,11 +1450,11 @@ class StructExprField\n // Identifier-only variant of StructExprField HIR node\n class StructExprFieldIdentifier : public StructExprField\n {\n-public:\n+private:\n   Identifier field_name;\n \n   // TODO: should this store location data?\n-\n+public:\n   StructExprFieldIdentifier (Analysis::NodeMapping mapping,\n \t\t\t     Identifier field_identifier, Location locus)\n     : StructExprField (mapping, locus),\n@@ -1459,6 +1468,11 @@ class StructExprFieldIdentifier : public StructExprField\n \n   Identifier get_field_name () const { return field_name; }\n \n+  StructExprFieldKind get_kind () const override\n+  {\n+    return StructExprFieldKind::IDENTIFIER;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1527,6 +1541,11 @@ class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRExpressionVisitor &vis) override;\n \n+  StructExprFieldKind get_kind () const override\n+  {\n+    return StructExprFieldKind::IDENTIFIER_VALUE;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1558,6 +1577,11 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRExpressionVisitor &vis) override;\n \n+  StructExprFieldKind get_kind () const override\n+  {\n+    return StructExprFieldKind::INDEX_VALUE;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "126283c1a54f38e7f1763c3f35abe812fbcdd880", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -306,18 +306,6 @@ class Backend\n   // exit expressions\n   virtual tree exit_expression (tree condition, Location) = 0;\n \n-  // Create a switch statement where the case values are constants.\n-  // CASES and STATEMENTS must have the same number of entries.  If\n-  // VALUE matches any of the list in CASES[i], which will all be\n-  // integers, then STATEMENTS[i] is executed.  STATEMENTS[i] will\n-  // either end with a goto statement or will fall through into\n-  // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n-  // which need not be last.  FUNCTION is the current function.\n-  virtual tree switch_statement (tree function, tree value,\n-\t\t\t\t const std::vector<std::vector<tree> > &cases,\n-\t\t\t\t const std::vector<tree> &statements, Location)\n-    = 0;\n-\n   // Create a single statement from two statements.\n   virtual tree compound_statement (tree, tree) = 0;\n "}, {"sha": "c8eee0f4684cc62782972e866a27cbd866a19591", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -264,10 +264,6 @@ class Gcc_backend : public Backend\n   tree if_statement (tree, tree condition, tree then_block, tree else_block,\n \t\t     Location);\n \n-  tree switch_statement (tree function, tree value,\n-\t\t\t const std::vector<std::vector<tree>> &cases,\n-\t\t\t const std::vector<tree> &statements, Location);\n-\n   tree compound_statement (tree, tree);\n \n   tree statement_list (const std::vector<tree> &);\n@@ -327,10 +323,6 @@ class Gcc_backend : public Backend\n   bool function_set_parameters (tree function,\n \t\t\t\tconst std::vector<Bvariable *> &);\n \n-  tree lookup_gcc_builtin (const std::string &);\n-\n-  tree lookup_builtin_by_rust_name (const std::string &);\n-\n   void write_global_definitions (const std::vector<tree> &,\n \t\t\t\t const std::vector<tree> &,\n \t\t\t\t const std::vector<tree> &,\n@@ -2057,67 +2049,6 @@ Gcc_backend::exit_expression (tree cond_tree, Location locus)\n \t\t\t  cond_tree);\n }\n \n-// Switch.\n-\n-tree\n-Gcc_backend::switch_statement (tree decl, tree value,\n-\t\t\t       const std::vector<std::vector<tree>> &cases,\n-\t\t\t       const std::vector<tree> &statements,\n-\t\t\t       Location switch_location)\n-{\n-  gcc_assert (cases.size () == statements.size ());\n-\n-  if (DECL_STRUCT_FUNCTION (decl) == NULL)\n-    push_struct_function (decl);\n-  else\n-    push_cfun (DECL_STRUCT_FUNCTION (decl));\n-\n-  tree stmt_list = NULL_TREE;\n-  std::vector<std::vector<tree>>::const_iterator pc = cases.begin ();\n-  for (std::vector<tree>::const_iterator ps = statements.begin ();\n-       ps != statements.end (); ++ps, ++pc)\n-    {\n-      if (pc->empty ())\n-\t{\n-\t  location_t loc\n-\t    = (*ps != NULL ? EXPR_LOCATION (*ps) : UNKNOWN_LOCATION);\n-\t  tree label = create_artificial_label (loc);\n-\t  tree c = build_case_label (NULL_TREE, NULL_TREE, label);\n-\t  append_to_statement_list (c, &stmt_list);\n-\t}\n-      else\n-\t{\n-\t  for (std::vector<tree>::const_iterator pcv = pc->begin ();\n-\t       pcv != pc->end (); ++pcv)\n-\t    {\n-\t      tree t = (*pcv);\n-\t      if (t == error_mark_node)\n-\t\treturn error_mark_node;\n-\t      location_t loc = EXPR_LOCATION (t);\n-\t      tree label = create_artificial_label (loc);\n-\t      tree c = build_case_label ((*pcv), NULL_TREE, label);\n-\t      append_to_statement_list (c, &stmt_list);\n-\t    }\n-\t}\n-\n-      if (*ps != NULL)\n-\t{\n-\t  tree t = (*ps);\n-\t  if (t == error_mark_node)\n-\t    return error_mark_node;\n-\t  append_to_statement_list (t, &stmt_list);\n-\t}\n-    }\n-  pop_cfun ();\n-\n-  tree tv = value;\n-  if (tv == error_mark_node)\n-    return error_mark_node;\n-  tree t = build2_loc (switch_location.gcc_location (), SWITCH_EXPR, NULL_TREE,\n-\t\t       tv, stmt_list);\n-  return t;\n-}\n-\n // Pair of statements.\n \n tree"}, {"sha": "2890b54a00de6924b213208cbd9fe2a838067aa6", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -25,10 +25,8 @@\n namespace Rust {\n namespace Resolver {\n \n-class ImplItemToName : public TypeCheckBase\n+class ImplItemToName : private TypeCheckBase, private HIR::HIRImplVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static bool resolve (HIR::ImplItem *item, std::string &name_result)\n   {\n@@ -66,8 +64,6 @@ class ImplItemToName : public TypeCheckBase\n \n class OverlappingImplItemPass : public TypeCheckBase\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static void go ()\n   {"}, {"sha": "bd4f91e49bf266e8bda2f947adf4f91c8ea55d64", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -125,11 +125,8 @@ struct PathProbeCandidate\n   bool is_error () const { return type == ERROR; }\n };\n \n-class PathProbeType : public TypeCheckBase\n+class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n {\n-protected:\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static std::vector<PathProbeCandidate>\n   Probe (const TyTy::BaseType *receiver,\n@@ -452,10 +449,9 @@ class PathProbeType : public TypeCheckBase\n   DefId specific_trait_id;\n };\n \n-class ReportMultipleCandidateError : private TypeCheckBase\n+class ReportMultipleCandidateError : private TypeCheckBase,\n+\t\t\t\t     private HIR::HIRImplVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static void Report (std::vector<PathProbeCandidate> &candidates,\n \t\t      const HIR::PathIdentSegment &query, Location query_locus)"}, {"sha": "c4aaf42b141e12fb243db93bd512803ec0731536", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -20,19 +20,15 @@\n #define RUST_HIR_TRAIT_RESOLVE_H\n \n #include \"rust-hir-type-check-base.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-tyty-visitor.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-trait-ref.h\"\n-#include \"rust-expr.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-class ResolveTraitItemToRef : public TypeCheckBase\n+class ResolveTraitItemToRef : public TypeCheckBase,\n+\t\t\t      private HIR::HIRTraitItemVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static TraitItemReference\n   Resolve (HIR::TraitItem &item, TyTy::BaseType *self,\n@@ -59,9 +55,9 @@ class ResolveTraitItemToRef : public TypeCheckBase\n   std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n \n-class TraitResolver : public TypeCheckBase\n+class TraitResolver : public TypeCheckBase, private HIR::HIRFullVisitorBase\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n+  using HIR::HIRFullVisitorBase::visit;\n \n public:\n   static TraitReference *Resolve (HIR::TypePath &path);"}, {"sha": "44400efbbf7e68a87a25b21c7a91ecd309b99bc1", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -28,8 +28,6 @@ namespace Resolver {\n \n class TypeBoundsProbe : public TypeCheckBase\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static std::vector<std::pair<TraitReference *, HIR::ImplBlock *>>\n   Probe (const TyTy::BaseType *receiver)"}, {"sha": "e263056a82c1bcd4baf9f63e7f8365fc7c79e901", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -17,6 +17,8 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n #include \"rust-coercion.h\"\n \n namespace Rust {\n@@ -349,5 +351,49 @@ TypeCheckBase::coercion_site (HirId id, TyTy::BaseType *expected,\n   return expected->coerce (expr);\n }\n \n+void\n+TypeCheckBase::resolve_generic_params (\n+  const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n+  std::vector<TyTy::SubstitutionParamMapping> &substitutions)\n+{\n+  for (auto &generic_param : generic_params)\n+    {\n+      switch (generic_param.get ()->get_kind ())\n+\t{\n+\tcase HIR::GenericParam::GenericKind::LIFETIME:\n+\t  // FIXME: Skipping Lifetime completely until better\n+\t  // handling.\n+\t  break;\n+\t  case HIR::GenericParam::GenericKind::CONST: {\n+\t    auto param\n+\t      = static_cast<HIR::ConstGenericParam *> (generic_param.get ());\n+\t    auto specified_type\n+\t      = TypeCheckType::Resolve (param->get_type ().get ());\n+\n+\t    if (param->has_default_expression ())\n+\t      {\n+\t\tauto expr_type = TypeCheckExpr::Resolve (\n+\t\t  param->get_default_expression ().get ());\n+\t\tspecified_type->coerce (expr_type);\n+\t      }\n+\n+\t    context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t  specified_type);\n+\t  }\n+\t  break;\n+\n+\t  case HIR::GenericParam::GenericKind::TYPE: {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t      static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t  }\n+\t  break;\n+\t}\n+    }\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "449ff6ab92a778d3aa2077b13d9dd6fafb7f70e9", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -30,13 +30,9 @@ namespace Rust {\n namespace Resolver {\n \n class TraitReference;\n-\n-// base class to allow derivatives to overload as needed\n-class TypeCheckBase : public HIR::HIRFullVisitorBase\n+class TypeCheckBase\n {\n public:\n-  using Rust::HIR::HIRFullVisitorBase::visit;\n-\n   virtual ~TypeCheckBase () {}\n \n   static TyTy::BaseType *coercion_site (HirId id, TyTy::BaseType *lhs,\n@@ -64,6 +60,10 @@ class TypeCheckBase : public HIR::HIRFullVisitorBase\n   TyTy::ADTType::ReprOptions parse_repr_options (const AST::AttrVec &attrs,\n \t\t\t\t\t\t Location locus);\n \n+  void resolve_generic_params (\n+    const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n+    std::vector<TyTy::SubstitutionParamMapping> &substitutions);\n+\n   Analysis::Mappings *mappings;\n   Resolver *resolver;\n   TypeCheckContext *context;"}, {"sha": "e65b2011d36257da33312a3378c0fd8e543859af", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.cc", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -0,0 +1,213 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TyTy::VariantDef *\n+TypeCheckEnumItem::Resolve (HIR::EnumItem *item, int64_t last_discriminant)\n+{\n+  TypeCheckEnumItem resolver (last_discriminant);\n+  switch (item->get_enum_item_kind ())\n+    {\n+    case HIR::EnumItem::EnumItemKind::Named:\n+      resolver.visit (static_cast<HIR::EnumItem &> (*item));\n+      break;\n+\n+    case HIR::EnumItem::EnumItemKind::Tuple:\n+      resolver.visit (static_cast<HIR::EnumItemTuple &> (*item));\n+      break;\n+\n+    case HIR::EnumItem::EnumItemKind::Struct:\n+      resolver.visit (static_cast<HIR::EnumItemStruct &> (*item));\n+      break;\n+\n+    case HIR::EnumItem::EnumItemKind::Discriminant:\n+      resolver.visit (static_cast<HIR::EnumItemDiscriminant &> (*item));\n+      break;\n+    }\n+  return resolver.variant;\n+}\n+\n+TypeCheckEnumItem::TypeCheckEnumItem (int64_t last_discriminant)\n+  : TypeCheckBase (), variant (nullptr), last_discriminant (last_discriminant)\n+{}\n+\n+void\n+TypeCheckEnumItem::visit (HIR::EnumItem &item)\n+{\n+  if (last_discriminant == INT64_MAX)\n+    rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+  Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n+\t\t\t\t item.get_mappings ().get_nodeid (),\n+\t\t\t\t mappings->get_next_hir_id (\n+\t\t\t\t   item.get_mappings ().get_crate_num ()),\n+\t\t\t\t item.get_mappings ().get_local_defid ());\n+  HIR::LiteralExpr *discim_expr\n+    = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n+\t\t\t    HIR::Literal::LitType::INT,\n+\t\t\t    PrimitiveCoreType::CORETYPE_I64, item.get_locus (),\n+\t\t\t    {});\n+\n+  TyTy::BaseType *isize = nullptr;\n+  bool ok = context->lookup_builtin (\"isize\", &isize);\n+  rust_assert (ok);\n+  context->insert_type (mapping, isize);\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n+\t\t\t\t\t&canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, item.get_locus ()};\n+  variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_identifier (), ident, discim_expr);\n+}\n+\n+void\n+TypeCheckEnumItem::visit (HIR::EnumItemDiscriminant &item)\n+{\n+  if (last_discriminant == INT64_MAX)\n+    rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+  auto &discriminant = item.get_discriminant_expression ();\n+  auto capacity_type = TypeCheckExpr::Resolve (discriminant.get ());\n+  if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::ISizeType *expected_ty\n+    = new TyTy::ISizeType (discriminant->get_mappings ().get_hirid ());\n+  context->insert_type (discriminant->get_mappings (), expected_ty);\n+\n+  auto unified = expected_ty->unify (capacity_type);\n+  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n+\t\t\t\t\t     &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, item.get_locus ()};\n+  variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_identifier (), ident,\n+\t\t\t\t  item.get_discriminant_expression ().get ());\n+}\n+\n+void\n+TypeCheckEnumItem::visit (HIR::EnumItemTuple &item)\n+{\n+  if (last_discriminant == INT64_MAX)\n+    rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  size_t idx = 0;\n+  for (auto &field : item.get_tuple_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+      idx++;\n+    }\n+\n+  Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n+\t\t\t\t item.get_mappings ().get_nodeid (),\n+\t\t\t\t mappings->get_next_hir_id (\n+\t\t\t\t   item.get_mappings ().get_crate_num ()),\n+\t\t\t\t item.get_mappings ().get_local_defid ());\n+  HIR::LiteralExpr *discim_expr\n+    = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n+\t\t\t    HIR::Literal::LitType::INT,\n+\t\t\t    PrimitiveCoreType::CORETYPE_I64, item.get_locus (),\n+\t\t\t    {});\n+\n+  TyTy::BaseType *isize = nullptr;\n+  bool ok = context->lookup_builtin (\"isize\", &isize);\n+  rust_assert (ok);\n+  context->insert_type (mapping, isize);\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n+\t\t\t\t\t&canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, item.get_locus ()};\n+  variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_identifier (), ident,\n+\t\t\t\t  TyTy::VariantDef::VariantType::TUPLE,\n+\t\t\t\t  discim_expr, fields);\n+}\n+\n+void\n+TypeCheckEnumItem::visit (HIR::EnumItemStruct &item)\n+{\n+  if (last_discriminant == INT64_MAX)\n+    rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &field : item.get_struct_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+    }\n+\n+  Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n+\t\t\t\t item.get_mappings ().get_nodeid (),\n+\t\t\t\t mappings->get_next_hir_id (\n+\t\t\t\t   item.get_mappings ().get_crate_num ()),\n+\t\t\t\t item.get_mappings ().get_local_defid ());\n+  HIR::LiteralExpr *discrim_expr\n+    = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n+\t\t\t    HIR::Literal::LitType::INT,\n+\t\t\t    PrimitiveCoreType::CORETYPE_I64, item.get_locus (),\n+\t\t\t    {});\n+\n+  TyTy::BaseType *isize = nullptr;\n+  bool ok = context->lookup_builtin (\"isize\", &isize);\n+  rust_assert (ok);\n+  context->insert_type (mapping, isize);\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n+\t\t\t\t\t&canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, item.get_locus ()};\n+  variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_identifier (), ident,\n+\t\t\t\t  TyTy::VariantDef::VariantType::STRUCT,\n+\t\t\t\t  discrim_expr, fields);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "c771ea3782de4aa1307ca227b020990fedcf52ee", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.h", "status": "modified", "additions": 7, "deletions": 170, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -21,187 +21,24 @@\n \n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n-#include \"rust-hir-type-check-type.h\"\n-#include \"rust-hir-type-check-expr.h\"\n-\n-extern ::Backend *\n-rust_get_backend ();\n \n namespace Rust {\n namespace Resolver {\n \n class TypeCheckEnumItem : public TypeCheckBase\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static TyTy::VariantDef *Resolve (HIR::EnumItem *item,\n-\t\t\t\t    int64_t last_discriminant)\n-  {\n-    TypeCheckEnumItem resolver (last_discriminant);\n-    item->accept_vis (resolver);\n-    return resolver.variant;\n-  }\n-\n-  void visit (HIR::EnumItem &item) override\n-  {\n-    if (last_discriminant == INT64_MAX)\n-      rust_error_at (item.get_locus (), \"discriminant too big\");\n-\n-    Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n-\t\t\t\t   item.get_mappings ().get_nodeid (),\n-\t\t\t\t   mappings->get_next_hir_id (\n-\t\t\t\t     item.get_mappings ().get_crate_num ()),\n-\t\t\t\t   item.get_mappings ().get_local_defid ());\n-    HIR::LiteralExpr *discim_expr\n-      = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n-\t\t\t      HIR::Literal::LitType::INT,\n-\t\t\t      PrimitiveCoreType::CORETYPE_I64,\n-\t\t\t      item.get_locus (), {});\n-\n-    TyTy::BaseType *isize = nullptr;\n-    bool ok = context->lookup_builtin (\"isize\", &isize);\n-    rust_assert (ok);\n-    context->insert_type (mapping, isize);\n-\n-    const CanonicalPath *canonical_path = nullptr;\n-    ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n-\t\t\t\t\t  &canonical_path);\n-    rust_assert (ok);\n-\n-    RustIdent ident{*canonical_path, item.get_locus ()};\n-    variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t\t    item.get_identifier (), ident, discim_expr);\n-  }\n-\n-  void visit (HIR::EnumItemDiscriminant &item) override\n-  {\n-    if (last_discriminant == INT64_MAX)\n-      rust_error_at (item.get_locus (), \"discriminant too big\");\n-\n-    auto &discriminant = item.get_discriminant_expression ();\n-    auto capacity_type = TypeCheckExpr::Resolve (discriminant.get ());\n-    if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    TyTy::ISizeType *expected_ty\n-      = new TyTy::ISizeType (discriminant->get_mappings ().get_hirid ());\n-    context->insert_type (discriminant->get_mappings (), expected_ty);\n-\n-    auto unified = expected_ty->unify (capacity_type);\n-    if (unified->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok\n-      = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n-\t\t\t\t\t &canonical_path);\n-    rust_assert (ok);\n-\n-    RustIdent ident{*canonical_path, item.get_locus ()};\n-    variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t\t    item.get_identifier (), ident,\n-\t\t\t\t    item.get_discriminant_expression ().get ());\n-  }\n-\n-  void visit (HIR::EnumItemTuple &item) override\n-  {\n-    if (last_discriminant == INT64_MAX)\n-      rust_error_at (item.get_locus (), \"discriminant too big\");\n-\n-    std::vector<TyTy::StructFieldType *> fields;\n-    size_t idx = 0;\n-    for (auto &field : item.get_tuple_fields ())\n-      {\n-\tTyTy::BaseType *field_type\n-\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n-\tTyTy::StructFieldType *ty_field\n-\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t       std::to_string (idx), field_type);\n-\tfields.push_back (ty_field);\n-\tcontext->insert_type (field.get_mappings (),\n-\t\t\t      ty_field->get_field_type ());\n-\tidx++;\n-      }\n-\n-    Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n-\t\t\t\t   item.get_mappings ().get_nodeid (),\n-\t\t\t\t   mappings->get_next_hir_id (\n-\t\t\t\t     item.get_mappings ().get_crate_num ()),\n-\t\t\t\t   item.get_mappings ().get_local_defid ());\n-    HIR::LiteralExpr *discim_expr\n-      = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n-\t\t\t      HIR::Literal::LitType::INT,\n-\t\t\t      PrimitiveCoreType::CORETYPE_I64,\n-\t\t\t      item.get_locus (), {});\n-\n-    TyTy::BaseType *isize = nullptr;\n-    bool ok = context->lookup_builtin (\"isize\", &isize);\n-    rust_assert (ok);\n-    context->insert_type (mapping, isize);\n-\n-    const CanonicalPath *canonical_path = nullptr;\n-    ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n-\t\t\t\t\t  &canonical_path);\n-    rust_assert (ok);\n-\n-    RustIdent ident{*canonical_path, item.get_locus ()};\n-    variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t\t    item.get_identifier (), ident,\n-\t\t\t\t    TyTy::VariantDef::VariantType::TUPLE,\n-\t\t\t\t    discim_expr, fields);\n-  }\n-\n-  void visit (HIR::EnumItemStruct &item) override\n-  {\n-    if (last_discriminant == INT64_MAX)\n-      rust_error_at (item.get_locus (), \"discriminant too big\");\n-\n-    std::vector<TyTy::StructFieldType *> fields;\n-    for (auto &field : item.get_struct_fields ())\n-      {\n-\tTyTy::BaseType *field_type\n-\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n-\tTyTy::StructFieldType *ty_field\n-\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t       field.get_field_name (), field_type);\n-\tfields.push_back (ty_field);\n-\tcontext->insert_type (field.get_mappings (),\n-\t\t\t      ty_field->get_field_type ());\n-      }\n-\n-    Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n-\t\t\t\t   item.get_mappings ().get_nodeid (),\n-\t\t\t\t   mappings->get_next_hir_id (\n-\t\t\t\t     item.get_mappings ().get_crate_num ()),\n-\t\t\t\t   item.get_mappings ().get_local_defid ());\n-    HIR::LiteralExpr *discrim_expr\n-      = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n-\t\t\t      HIR::Literal::LitType::INT,\n-\t\t\t      PrimitiveCoreType::CORETYPE_I64,\n-\t\t\t      item.get_locus (), {});\n-\n-    TyTy::BaseType *isize = nullptr;\n-    bool ok = context->lookup_builtin (\"isize\", &isize);\n-    rust_assert (ok);\n-    context->insert_type (mapping, isize);\n-\n-    const CanonicalPath *canonical_path = nullptr;\n-    ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n-\t\t\t\t\t  &canonical_path);\n-    rust_assert (ok);\n+\t\t\t\t    int64_t last_discriminant);\n \n-    RustIdent ident{*canonical_path, item.get_locus ()};\n-    variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t\t    item.get_identifier (), ident,\n-\t\t\t\t    TyTy::VariantDef::VariantType::STRUCT,\n-\t\t\t\t    discrim_expr, fields);\n-  }\n+protected:\n+  void visit (HIR::EnumItem &item);\n+  void visit (HIR::EnumItemDiscriminant &item);\n+  void visit (HIR::EnumItemTuple &item);\n+  void visit (HIR::EnumItemStruct &item);\n \n private:\n-  TypeCheckEnumItem (int64_t last_discriminant)\n-    : TypeCheckBase (), variant (nullptr), last_discriminant (last_discriminant)\n-  {}\n+  TypeCheckEnumItem (int64_t last_discriminant);\n \n   TyTy::VariantDef *variant;\n   int64_t last_discriminant;"}, {"sha": "03999baffa448b86807accb333db3fd66acff3af", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 966, "deletions": 0, "changes": 966, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -16,11 +16,555 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty-call.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-dot-operator.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-stmt.h\"\n \n namespace Rust {\n namespace Resolver {\n \n+TypeCheckExpr::TypeCheckExpr () : TypeCheckBase (), infered (nullptr) {}\n+\n+// Perform type checking on expr. Also runs type unification algorithm.\n+// Returns the unified type of expr\n+TyTy::BaseType *\n+TypeCheckExpr::Resolve (HIR::Expr *expr)\n+{\n+  TypeCheckExpr resolver;\n+  expr->accept_vis (resolver);\n+\n+  if (resolver.infered == nullptr)\n+    {\n+      // FIXME\n+      // this is an internal error message for debugging and should be removed\n+      // at some point\n+      rust_error_at (expr->get_locus (), \"failed to type resolve expression\");\n+      return new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n+    }\n+\n+  auto ref = expr->get_mappings ().get_hirid ();\n+  resolver.infered->set_ref (ref);\n+  resolver.context->insert_type (expr->get_mappings (), resolver.infered);\n+\n+  return resolver.infered;\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::TupleIndexExpr &expr)\n+{\n+  auto resolved = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get ());\n+  if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_tuple_expr ()->get_locus (),\n+\t\t     \"failed to resolve TupleIndexExpr receiver\");\n+      return;\n+    }\n+\n+  // FIXME does this require autoderef here?\n+  if (resolved->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (resolved);\n+      resolved = r->get_base ();\n+    }\n+\n+  bool is_valid_type = resolved->get_kind () == TyTy::TypeKind::ADT\n+\t\t       || resolved->get_kind () == TyTy::TypeKind::TUPLE;\n+  if (!is_valid_type)\n+    {\n+      rust_error_at (expr.get_tuple_expr ()->get_locus (),\n+\t\t     \"Expected Tuple or ADT got: %s\",\n+\t\t     resolved->as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (resolved->get_kind () == TyTy::TypeKind::TUPLE)\n+    {\n+      TyTy::TupleType *tuple = static_cast<TyTy::TupleType *> (resolved);\n+      TupleIndex index = expr.get_tuple_index ();\n+      if ((size_t) index >= tuple->num_fields ())\n+\t{\n+\t  rust_error_at (expr.get_locus (), \"unknown field at index %i\", index);\n+\t  return;\n+\t}\n+\n+      auto field_tyty = tuple->get_field ((size_t) index);\n+      if (field_tyty == nullptr)\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"failed to lookup field type at index %i\", index);\n+\t  return;\n+\t}\n+\n+      infered = field_tyty;\n+      return;\n+    }\n+\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (resolved);\n+  rust_assert (!adt->is_enum ());\n+  rust_assert (adt->number_of_variants () == 1);\n+\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+  TupleIndex index = expr.get_tuple_index ();\n+  if ((size_t) index >= variant->num_fields ())\n+    {\n+      rust_error_at (expr.get_locus (), \"unknown field at index %i\", index);\n+      return;\n+    }\n+\n+  auto field_tyty = variant->get_field_at_index ((size_t) index);\n+  if (field_tyty == nullptr)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup field type at index %i\", index);\n+      return;\n+    }\n+\n+  infered = field_tyty->get_field_type ();\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::TupleExpr &expr)\n+{\n+  if (expr.is_unit ())\n+    {\n+      auto unit_node_id = resolver->get_unit_type_node_id ();\n+      if (!context->lookup_builtin (unit_node_id, &infered))\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"failed to lookup builtin unit type\");\n+\t}\n+      return;\n+    }\n+\n+  std::vector<TyTy::TyVar> fields;\n+  for (auto &elem : expr.get_tuple_elems ())\n+    {\n+      auto field_ty = TypeCheckExpr::Resolve (elem.get ());\n+      fields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n+    }\n+  infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t expr.get_locus (), fields);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ReturnExpr &expr)\n+{\n+  auto fn_return_tyty = context->peek_return_type ();\n+  rust_assert (fn_return_tyty != nullptr);\n+\n+  TyTy::BaseType *expr_ty\n+    = expr.has_return_expr ()\n+\t? TypeCheckExpr::Resolve (expr.get_expr ())\n+\t: TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+\n+  infered = fn_return_tyty->unify (expr_ty);\n+  fn_return_tyty->append_reference (expr_ty->get_ref ());\n+  for (auto &ref : infered->get_combined_refs ())\n+    fn_return_tyty->append_reference (ref);\n+\n+  infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::CallExpr &expr)\n+{\n+  TyTy::BaseType *function_tyty = TypeCheckExpr::Resolve (expr.get_fnexpr ());\n+\n+  bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n+\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNPTR;\n+  if (!valid_tyty)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"Failed to resolve expression of function call\");\n+      return;\n+    }\n+\n+  TyTy::VariantDef &variant = TyTy::VariantDef::get_error_node ();\n+  if (function_tyty->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (function_tyty);\n+      if (adt->is_enum ())\n+\t{\n+\t  // lookup variant id\n+\t  HirId variant_id;\n+\t  bool ok = context->lookup_variant_definition (\n+\t    expr.get_fnexpr ()->get_mappings ().get_hirid (), &variant_id);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::VariantDef *lookup_variant = nullptr;\n+\t  ok = adt->lookup_variant_by_id (variant_id, &lookup_variant);\n+\t  rust_assert (ok);\n+\n+\t  variant = *lookup_variant;\n+\t}\n+      else\n+\t{\n+\t  rust_assert (adt->number_of_variants () == 1);\n+\t  variant = *adt->get_variants ().at (0);\n+\t}\n+    }\n+\n+  infered = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::AssignmentExpr &expr)\n+{\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+  coercion_site (expr.get_mappings ().get_hirid (), lhs, rhs,\n+\t\t expr.get_locus ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::CompoundAssignmentExpr &expr)\n+{\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get ());\n+\n+  // we dont care about the result of the unify from a compound assignment\n+  // since this is a unit-type expr\n+  auto result = lhs->unify (rhs);\n+  if (result->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  auto lang_item_type\n+    = Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+      expr.get_expr_type ());\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+  if (operator_overloaded)\n+    return;\n+\n+  bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+  bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+  bool valid = valid_lhs && valid_rhs;\n+  if (!valid)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"cannot apply this operator to types %s and %s\",\n+\t\t     lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+      return;\n+    }\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IdentifierExpr &expr)\n+{\n+  NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+  // then lookup the reference_node_id\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    {\n+      resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+    }\n+\n+  if (ref_node_id == UNKNOWN_NODEID)\n+    {\n+      // FIXME this needs to go away and just return error node\n+      rust_error_at (expr.get_locus (), \"unresolved node: %s\",\n+\t\t     expr.as_string ().c_str ());\n+      return;\n+    }\n+\n+  // node back to HIR\n+  HirId ref;\n+  if (!mappings->lookup_node_to_hir (ref_node_id, &ref))\n+    {\n+      // FIXME\n+      // this is an internal error\n+      rust_error_at (expr.get_locus (), \"123 reverse lookup failure\");\n+      return;\n+    }\n+\n+  // the base reference for this name _must_ have a type set\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (ref, &lookup))\n+    {\n+      // FIXME\n+      // this is an internal error\n+      rust_error_at (mappings->lookup_location (ref),\n+\t\t     \"Failed to resolve IdentifierExpr type: %s\",\n+\t\t     expr.as_string ().c_str ());\n+      return;\n+    }\n+\n+  infered = lookup->clone ();\n+\n+  // Generic unit structs look like an identifier but they actually need be\n+  // handled as a path-in-expression so this gives us a chance to infer the\n+  // generic parameters.\n+  // see https://github.com/Rust-GCC/gccrs/issues/1447\n+  bool is_unit_struct\n+    = infered->get_kind () == TyTy::TypeKind::ADT && infered->is_unit ();\n+  if (is_unit_struct && infered->needs_generic_substitutions ())\n+    {\n+      infered = SubstMapper::InferSubst (infered, expr.get_locus ());\n+    }\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::LiteralExpr &expr)\n+{\n+  infered = resolve_literal (expr.get_mappings (), expr.get_literal (),\n+\t\t\t     expr.get_locus ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n+{\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+  auto lang_item_type\n+    = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+  if (operator_overloaded)\n+    return;\n+\n+  bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+  bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+  bool valid = valid_lhs && valid_rhs;\n+  if (!valid)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"cannot apply this operator to types %s and %s\",\n+\t\t     lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+      return;\n+    }\n+\n+  switch (expr.get_expr_type ())\n+    {\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      infered = rhs->cast (lhs);\n+      break;\n+\n+    default:\n+      infered = lhs->unify (rhs);\n+      break;\n+    }\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ComparisonExpr &expr)\n+{\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+  auto result = lhs->unify (rhs);\n+  if (result == nullptr || result->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  bool ok = context->lookup_builtin (\"bool\", &infered);\n+  rust_assert (ok);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::LazyBooleanExpr &expr)\n+{\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+  // we expect the lhs and rhs must be bools at this point\n+  TyTy::BoolType elhs (expr.get_mappings ().get_hirid ());\n+  lhs = elhs.unify (lhs);\n+  if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::BoolType rlhs (expr.get_mappings ().get_hirid ());\n+  rhs = elhs.unify (rhs);\n+  if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  infered = lhs->unify (rhs);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::NegationExpr &expr)\n+{\n+  auto negated_expr_ty = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+\n+  // check for operator overload\n+  auto lang_item_type = Analysis::RustLangItem::NegationOperatorToLangItem (\n+    expr.get_expr_type ());\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, negated_expr_ty,\n+\t\t\t\t nullptr);\n+  if (operator_overloaded)\n+    return;\n+\n+  // https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators\n+  switch (expr.get_expr_type ())\n+    {\n+      case NegationOperator::NEGATE: {\n+\tbool valid\n+\t  = (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::FLOAT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::ISIZE)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::USIZE)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t&& (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t    == TyTy::InferType::INTEGRAL))\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t&& (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t    == TyTy::InferType::FLOAT));\n+\tif (!valid)\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"cannot apply unary - to %s\",\n+\t\t\t   negated_expr_ty->as_string ().c_str ());\n+\t    return;\n+\t  }\n+      }\n+      break;\n+\n+      case NegationOperator::NOT: {\n+\tbool valid\n+\t  = (negated_expr_ty->get_kind () == TyTy::TypeKind::BOOL)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t&& (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t    == TyTy::InferType::INTEGRAL));\n+\tif (!valid)\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"cannot apply unary %<!%> to %s\",\n+\t\t\t   negated_expr_ty->as_string ().c_str ());\n+\t    return;\n+\t  }\n+      }\n+      break;\n+    }\n+\n+  infered = negated_expr_ty->clone ();\n+  infered->append_reference (negated_expr_ty->get_ref ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IfExpr &expr)\n+{\n+  TypeCheckExpr::Resolve (expr.get_if_condition ());\n+  TypeCheckExpr::Resolve (expr.get_if_block ());\n+\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IfExprConseqElse &expr)\n+{\n+  TypeCheckExpr::Resolve (expr.get_if_condition ());\n+  auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n+  auto else_blk_resolved = TypeCheckExpr::Resolve (expr.get_else_block ());\n+\n+  if (if_blk_resolved->get_kind () == TyTy::NEVER)\n+    infered = else_blk_resolved;\n+  else if (else_blk_resolved->get_kind () == TyTy::NEVER)\n+    infered = if_blk_resolved;\n+  else\n+    infered = if_blk_resolved->unify (else_blk_resolved);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IfExprConseqIf &expr)\n+{\n+  TypeCheckExpr::Resolve (expr.get_if_condition ());\n+  auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n+  auto else_blk_resolved = TypeCheckExpr::Resolve (expr.get_conseq_if_expr ());\n+\n+  if (if_blk_resolved->get_kind () == TyTy::NEVER)\n+    infered = else_blk_resolved;\n+  else if (else_blk_resolved->get_kind () == TyTy::NEVER)\n+    infered = if_blk_resolved;\n+  else\n+    infered = if_blk_resolved->unify (else_blk_resolved);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IfLetExpr &expr)\n+{\n+  // this needs to perform a least upper bound coercion on the blocks and then\n+  // unify the scruintee and arms\n+  TyTy::BaseType *scrutinee_tyty\n+    = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get ());\n+\n+  for (auto &pattern : expr.get_patterns ())\n+    {\n+      TyTy::BaseType *kase_arm_ty\n+\t= TypeCheckPattern::Resolve (pattern.get (), scrutinee_tyty);\n+\n+      TyTy::BaseType *checked_kase = scrutinee_tyty->unify (kase_arm_ty);\n+      if (checked_kase->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+\n+  TypeCheckExpr::Resolve (expr.get_if_block ());\n+\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::UnsafeBlockExpr &expr)\n+{\n+  infered = TypeCheckExpr::Resolve (expr.get_block_expr ().get ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::BlockExpr &expr)\n+{\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (!s->is_item ())\n+\tcontinue;\n+\n+      TypeCheckStmt::Resolve (s.get ());\n+    }\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (s->is_item ())\n+\tcontinue;\n+\n+      auto resolved = TypeCheckStmt::Resolve (s.get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (s->get_locus (), \"failure to resolve type\");\n+\t  return;\n+\t}\n+\n+      if (s->is_unit_check_needed () && !resolved->is_unit ())\n+\t{\n+\t  auto unit\n+\t    = TyTy::TupleType::get_unit_type (s->get_mappings ().get_hirid ());\n+\t  resolved = unit->unify (resolved);\n+\t}\n+    }\n+\n+  if (expr.has_expr ())\n+    infered = TypeCheckExpr::Resolve (expr.get_final_expr ().get ())->clone ();\n+  else if (expr.is_tail_reachable ())\n+    infered\n+      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+  else\n+    infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n+}\n+\n void\n TypeCheckExpr::visit (HIR::RangeFromToExpr &expr)\n {\n@@ -304,6 +848,146 @@ TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n \t\t index_expr_ty->get_name ().c_str ());\n }\n \n+void\n+TypeCheckExpr::visit (HIR::ArrayExpr &expr)\n+{\n+  HIR::ArrayElems &elements = *expr.get_internal_elements ();\n+\n+  HIR::Expr *capacity_expr = nullptr;\n+  TyTy::BaseType *element_type = nullptr;\n+  switch (elements.get_array_expr_type ())\n+    {\n+      case HIR::ArrayElems::ArrayExprType::COPIED: {\n+\tHIR::ArrayElemsCopied &elems\n+\t  = static_cast<HIR::ArrayElemsCopied &> (elements);\n+\telement_type = TypeCheckExpr::Resolve (elems.get_elem_to_copy ());\n+\n+\tauto capacity_type\n+\t  = TypeCheckExpr::Resolve (elems.get_num_copies_expr ());\n+\n+\tTyTy::BaseType *expected_ty = nullptr;\n+\tbool ok = context->lookup_builtin (\"usize\", &expected_ty);\n+\trust_assert (ok);\n+\tcontext->insert_type (elems.get_num_copies_expr ()->get_mappings (),\n+\t\t\t      expected_ty);\n+\n+\tauto unified = expected_ty->unify (capacity_type);\n+\tif (unified->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+\n+\tcapacity_expr = elems.get_num_copies_expr ();\n+      }\n+      break;\n+\n+      case HIR::ArrayElems::ArrayExprType::VALUES: {\n+\tHIR::ArrayElemsValues &elems\n+\t  = static_cast<HIR::ArrayElemsValues &> (elements);\n+\n+\tstd::vector<TyTy::BaseType *> types;\n+\tfor (auto &elem : elems.get_values ())\n+\t  {\n+\t    types.push_back (TypeCheckExpr::Resolve (elem.get ()));\n+\t  }\n+\n+\telement_type\n+\t  = TyTy::TyVar::get_implicit_infer_var (expr.get_locus ()).get_tyty ();\n+\tfor (auto &type : types)\n+\t  {\n+\t    element_type = element_type->unify (type);\n+\t  }\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\tstd::string capacity_str = std::to_string (elems.get_num_elements ());\n+\tcapacity_expr = new HIR::LiteralExpr (mapping, capacity_str,\n+\t\t\t\t\t      HIR::Literal::LitType::INT,\n+\t\t\t\t\t      PrimitiveCoreType::CORETYPE_USIZE,\n+\t\t\t\t\t      Location (), {});\n+\n+\t// mark the type for this implicit node\n+\tTyTy::BaseType *expected_ty = nullptr;\n+\tbool ok = context->lookup_builtin (\"usize\", &expected_ty);\n+\trust_assert (ok);\n+\tcontext->insert_type (mapping, expected_ty);\n+      }\n+      break;\n+    }\n+\n+  infered = new TyTy::ArrayType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t expr.get_locus (), *capacity_expr,\n+\t\t\t\t TyTy::TyVar (element_type->get_ref ()));\n+}\n+\n+// empty struct\n+void\n+TypeCheckExpr::visit (HIR::StructExprStruct &struct_expr)\n+{\n+  TyTy::BaseType *struct_path_ty\n+    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name ());\n+  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n+    {\n+      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n+\t\t     \"expected an ADT type for constructor\");\n+      return;\n+    }\n+\n+  infered = struct_path_ty;\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::StructExprStructFields &struct_expr)\n+{\n+  infered = TypeCheckStructExpr::Resolve (&struct_expr);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::GroupedExpr &expr)\n+{\n+  infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::FieldAccessExpr &expr)\n+{\n+  auto struct_base = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get ());\n+\n+  // FIXME does this require autoderef here?\n+  if (struct_base->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (struct_base);\n+      struct_base = r->get_base ();\n+    }\n+\n+  bool is_valid_type = struct_base->get_kind () == TyTy::TypeKind::ADT;\n+  if (!is_valid_type)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"expected algebraic data type got: [%s]\",\n+\t\t     struct_base->as_string ().c_str ());\n+      return;\n+    }\n+\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (struct_base);\n+  rust_assert (!adt->is_enum ());\n+  rust_assert (adt->number_of_variants () == 1);\n+\n+  TyTy::VariantDef *vaiant = adt->get_variants ().at (0);\n+\n+  TyTy::StructFieldType *lookup = nullptr;\n+  bool found = vaiant->lookup_field (expr.get_field_name (), &lookup, nullptr);\n+  if (!found)\n+    {\n+      rust_error_at (expr.get_locus (), \"unknown field [%s] for type [%s]\",\n+\t\t     expr.get_field_name ().c_str (),\n+\t\t     adt->as_string ().c_str ());\n+      return;\n+    }\n+\n+  infered = lookup->get_field_type ();\n+}\n+\n void\n TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n {\n@@ -459,6 +1143,232 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n   infered = function_ret_tyty;\n }\n \n+void\n+TypeCheckExpr::visit (HIR::LoopExpr &expr)\n+{\n+  context->push_new_loop_context (expr.get_mappings ().get_hirid (),\n+\t\t\t\t  expr.get_locus ());\n+  TyTy::BaseType *block_expr\n+    = TypeCheckExpr::Resolve (expr.get_loop_block ().get ());\n+  if (!block_expr->is_unit ())\n+    {\n+      rust_error_at (expr.get_loop_block ()->get_locus (),\n+\t\t     \"expected %<()%> got %s\",\n+\t\t     block_expr->as_string ().c_str ());\n+      return;\n+    }\n+\n+  TyTy::BaseType *loop_context_type = context->pop_loop_context ();\n+\n+  bool loop_context_type_infered\n+    = (loop_context_type->get_kind () != TyTy::TypeKind::INFER)\n+      || ((loop_context_type->get_kind () == TyTy::TypeKind::INFER)\n+\t  && (((TyTy::InferType *) loop_context_type)->get_infer_kind ()\n+\t      != TyTy::InferType::GENERAL));\n+\n+  infered\n+    = loop_context_type_infered\n+\t? loop_context_type\n+\t: TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::WhileLoopExpr &expr)\n+{\n+  context->push_new_while_loop_context (expr.get_mappings ().get_hirid ());\n+\n+  TypeCheckExpr::Resolve (expr.get_predicate_expr ().get ());\n+  TyTy::BaseType *block_expr\n+    = TypeCheckExpr::Resolve (expr.get_loop_block ().get ());\n+\n+  if (!block_expr->is_unit ())\n+    {\n+      rust_error_at (expr.get_loop_block ()->get_locus (),\n+\t\t     \"expected %<()%> got %s\",\n+\t\t     block_expr->as_string ().c_str ());\n+      return;\n+    }\n+\n+  context->pop_loop_context ();\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::BreakExpr &expr)\n+{\n+  if (!context->have_loop_context ())\n+    {\n+      rust_error_at (expr.get_locus (), \"cannot %<break%> outside of a loop\");\n+      return;\n+    }\n+\n+  if (expr.has_break_expr ())\n+    {\n+      TyTy::BaseType *break_expr_tyty\n+\t= TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+\n+      TyTy::BaseType *loop_context = context->peek_loop_context ();\n+      if (loop_context->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"can only break with a value inside %<loop%>\");\n+\t  return;\n+\t}\n+\n+      TyTy::BaseType *unified_ty = loop_context->unify (break_expr_tyty);\n+      context->swap_head_loop_context (unified_ty);\n+    }\n+\n+  infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ContinueExpr &expr)\n+{\n+  if (!context->have_loop_context ())\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"cannot %<continue%> outside of a loop\");\n+      return;\n+    }\n+\n+  infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::BorrowExpr &expr)\n+{\n+  TyTy::BaseType *resolved_base\n+    = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+\n+  // In Rust this is valid because of DST's\n+  //\n+  // fn test() {\n+  //     let a:&str = \"TEST 1\";\n+  //     let b:&str = &\"TEST 2\";\n+  // }\n+  if (resolved_base->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      const TyTy::ReferenceType *ref\n+\t= static_cast<const TyTy::ReferenceType *> (resolved_base);\n+\n+      // this might end up being a more generic is_dyn object check but lets\n+      // double check dyn traits type-layout first\n+      if (ref->is_dyn_str_type ())\n+\t{\n+\t  infered = resolved_base;\n+\t  return;\n+\t}\n+    }\n+\n+  if (expr.get_is_double_borrow ())\n+    {\n+      // FIXME double_reference\n+      gcc_unreachable ();\n+    }\n+\n+  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t     TyTy::TyVar (resolved_base->get_ref ()),\n+\t\t\t\t     expr.get_mut ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::DereferenceExpr &expr)\n+{\n+  TyTy::BaseType *resolved_base\n+    = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::DEREF;\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, resolved_base, nullptr);\n+  if (operator_overloaded)\n+    {\n+      // operator overloaded deref always refurns a reference type lets assert\n+      // this\n+      rust_assert (infered->get_kind () == TyTy::TypeKind::REF);\n+      resolved_base = infered;\n+    }\n+\n+  bool is_valid_type = resolved_base->get_kind () == TyTy::TypeKind::REF\n+\t\t       || resolved_base->get_kind () == TyTy::TypeKind::POINTER;\n+  if (!is_valid_type)\n+    {\n+      rust_error_at (expr.get_locus (), \"expected reference type got %s\",\n+\t\t     resolved_base->as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (resolved_base->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *ref_base\n+\t= static_cast<TyTy::ReferenceType *> (resolved_base);\n+      infered = ref_base->get_base ()->clone ();\n+    }\n+  else\n+    {\n+      TyTy::PointerType *ref_base\n+\t= static_cast<TyTy::PointerType *> (resolved_base);\n+      infered = ref_base->get_base ()->clone ();\n+    }\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::TypeCastExpr &expr)\n+{\n+  TyTy::BaseType *expr_to_convert\n+    = TypeCheckExpr::Resolve (expr.get_casted_expr ().get ());\n+  TyTy::BaseType *tyty_to_convert_to\n+    = TypeCheckType::Resolve (expr.get_type_to_convert_to ().get ());\n+\n+  infered = expr_to_convert->cast (tyty_to_convert_to);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::MatchExpr &expr)\n+{\n+  // this needs to perform a least upper bound coercion on the blocks and then\n+  // unify the scruintee and arms\n+  TyTy::BaseType *scrutinee_tyty\n+    = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get ());\n+\n+  std::vector<TyTy::BaseType *> kase_block_tys;\n+  for (auto &kase : expr.get_match_cases ())\n+    {\n+      // lets check the arms\n+      HIR::MatchArm &kase_arm = kase.get_arm ();\n+      for (auto &pattern : kase_arm.get_patterns ())\n+\t{\n+\t  TyTy::BaseType *kase_arm_ty\n+\t    = TypeCheckPattern::Resolve (pattern.get (), scrutinee_tyty);\n+\n+\t  TyTy::BaseType *checked_kase = scrutinee_tyty->unify (kase_arm_ty);\n+\t  if (checked_kase->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return;\n+\t}\n+\n+      // check the kase type\n+      TyTy::BaseType *kase_block_ty\n+\t= TypeCheckExpr::Resolve (kase.get_expr ().get ());\n+      kase_block_tys.push_back (kase_block_ty);\n+    }\n+\n+  if (kase_block_tys.size () == 0)\n+    {\n+      infered\n+\t= TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+      return;\n+    }\n+\n+  infered = kase_block_tys.at (0);\n+  for (size_t i = 1; i < kase_block_tys.size (); i++)\n+    {\n+      TyTy::BaseType *kase_ty = kase_block_tys.at (i);\n+      infered = infered->unify (kase_ty);\n+      if (infered->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+}\n+\n bool\n TypeCheckExpr::resolve_operator_overload (\n   Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,\n@@ -644,5 +1554,61 @@ TypeCheckExpr::resolve_operator_overload (\n   return true;\n }\n \n+bool\n+TypeCheckExpr::validate_arithmetic_type (\n+  const TyTy::BaseType *tyty, HIR::ArithmeticOrLogicalExpr::ExprType expr_type)\n+{\n+  const TyTy::BaseType *type = tyty->destructure ();\n+\n+  // https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators\n+  // this will change later when traits are added\n+  switch (expr_type)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n+    case ArithmeticOrLogicalOperator::MODULUS:\n+      return (type->get_kind () == TyTy::TypeKind::INT)\n+\t     || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t     || (type->get_kind () == TyTy::TypeKind::FLOAT)\n+\t     || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::ISIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t && (((const TyTy::InferType *) type)->get_infer_kind ()\n+\t\t     == TyTy::InferType::INTEGRAL))\n+\t     || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t && (((const TyTy::InferType *) type)->get_infer_kind ()\n+\t\t     == TyTy::InferType::FLOAT));\n+\n+      // integers or bools\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      return (type->get_kind () == TyTy::TypeKind::INT)\n+\t     || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t     || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::ISIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::BOOL)\n+\t     || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t && (((const TyTy::InferType *) type)->get_infer_kind ()\n+\t\t     == TyTy::InferType::INTEGRAL));\n+\n+      // integers only\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      return (type->get_kind () == TyTy::TypeKind::INT)\n+\t     || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t     || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::ISIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t && (((const TyTy::InferType *) type)->get_infer_kind ()\n+\t\t     == TyTy::InferType::INTEGRAL));\n+    }\n+\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "01cb213f0020cef45e6750216f3a6ccd42e3fa6e", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 61, "deletions": 916, "changes": 977, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -20,896 +20,93 @@\n #define RUST_HIR_TYPE_CHECK_EXPR\n \n #include \"rust-hir-type-check-base.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-system.h\"\n #include \"rust-tyty.h\"\n-#include \"rust-tyty-call.h\"\n-#include \"rust-hir-type-check-struct-field.h\"\n-#include \"rust-hir-path-probe.h\"\n-#include \"rust-substitution-mapper.h\"\n-#include \"rust-hir-trait-resolve.h\"\n-#include \"rust-hir-type-bounds.h\"\n-#include \"rust-hir-dot-operator.h\"\n-#include \"rust-hir-type-check-pattern.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-class TypeCheckExpr : public TypeCheckBase\n+class TypeCheckExpr : public TypeCheckBase, private HIR::HIRExpressionVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  // Perform type checking on expr. Also runs type unification algorithm.\n-  // Returns the unified type of expr\n-  static TyTy::BaseType *Resolve (HIR::Expr *expr)\n-  {\n-    TypeCheckExpr resolver;\n-    expr->accept_vis (resolver);\n-\n-    if (resolver.infered == nullptr)\n-      {\n-\t// FIXME\n-\t// this is an internal error message for debugging and should be removed\n-\t// at some point\n-\trust_error_at (expr->get_locus (), \"failed to type resolve expression\");\n-\treturn new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n-      }\n-\n-    auto ref = expr->get_mappings ().get_hirid ();\n-    resolver.infered->set_ref (ref);\n-    resolver.context->insert_type (expr->get_mappings (), resolver.infered);\n-\n-    return resolver.infered;\n-  }\n-\n-  void visit (HIR::TupleIndexExpr &expr) override\n-  {\n-    auto resolved = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get ());\n-    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (expr.get_tuple_expr ()->get_locus (),\n-\t\t       \"failed to resolve TupleIndexExpr receiver\");\n-\treturn;\n-      }\n-\n-    // FIXME does this require autoderef here?\n-    if (resolved->get_kind () == TyTy::TypeKind::REF)\n-      {\n-\tTyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (resolved);\n-\tresolved = r->get_base ();\n-      }\n-\n-    bool is_valid_type = resolved->get_kind () == TyTy::TypeKind::ADT\n-\t\t\t || resolved->get_kind () == TyTy::TypeKind::TUPLE;\n-    if (!is_valid_type)\n-      {\n-\trust_error_at (expr.get_tuple_expr ()->get_locus (),\n-\t\t       \"Expected Tuple or ADT got: %s\",\n-\t\t       resolved->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    if (resolved->get_kind () == TyTy::TypeKind::TUPLE)\n-      {\n-\tTyTy::TupleType *tuple = static_cast<TyTy::TupleType *> (resolved);\n-\tTupleIndex index = expr.get_tuple_index ();\n-\tif ((size_t) index >= tuple->num_fields ())\n-\t  {\n-\t    rust_error_at (expr.get_locus (), \"unknown field at index %i\",\n-\t\t\t   index);\n-\t    return;\n-\t  }\n-\n-\tauto field_tyty = tuple->get_field ((size_t) index);\n-\tif (field_tyty == nullptr)\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"failed to lookup field type at index %i\", index);\n-\t    return;\n-\t  }\n-\n-\tinfered = field_tyty;\n-\treturn;\n-      }\n-\n-    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (resolved);\n-    rust_assert (!adt->is_enum ());\n-    rust_assert (adt->number_of_variants () == 1);\n-\n-    TyTy::VariantDef *variant = adt->get_variants ().at (0);\n-    TupleIndex index = expr.get_tuple_index ();\n-    if ((size_t) index >= variant->num_fields ())\n-      {\n-\trust_error_at (expr.get_locus (), \"unknown field at index %i\", index);\n-\treturn;\n-      }\n-\n-    auto field_tyty = variant->get_field_at_index ((size_t) index);\n-    if (field_tyty == nullptr)\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to lookup field type at index %i\", index);\n-\treturn;\n-      }\n-\n-    infered = field_tyty->get_field_type ();\n-  }\n-\n-  void visit (HIR::TupleExpr &expr) override\n-  {\n-    if (expr.is_unit ())\n-      {\n-\tauto unit_node_id = resolver->get_unit_type_node_id ();\n-\tif (!context->lookup_builtin (unit_node_id, &infered))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"failed to lookup builtin unit type\");\n-\t  }\n-\treturn;\n-      }\n-\n-    std::vector<TyTy::TyVar> fields;\n-    for (auto &elem : expr.get_tuple_elems ())\n-      {\n-\tauto field_ty = TypeCheckExpr::Resolve (elem.get ());\n-\tfields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n-      }\n-    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t   expr.get_locus (), fields);\n-  }\n-\n-  void visit (HIR::ReturnExpr &expr) override\n-  {\n-    auto fn_return_tyty = context->peek_return_type ();\n-    rust_assert (fn_return_tyty != nullptr);\n-\n-    TyTy::BaseType *expr_ty\n-      = expr.has_return_expr ()\n-\t  ? TypeCheckExpr::Resolve (expr.get_expr ())\n-\t  : TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-\n-    infered = fn_return_tyty->unify (expr_ty);\n-    fn_return_tyty->append_reference (expr_ty->get_ref ());\n-    for (auto &ref : infered->get_combined_refs ())\n-      fn_return_tyty->append_reference (ref);\n-\n-    infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n-  }\n-\n-  void visit (HIR::CallExpr &expr) override\n-  {\n-    TyTy::BaseType *function_tyty = TypeCheckExpr::Resolve (expr.get_fnexpr ());\n-\n-    bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n-\t\t      || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n-\t\t      || function_tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-    if (!valid_tyty)\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to resolve expression of function call\");\n-\treturn;\n-      }\n-\n-    TyTy::VariantDef &variant = TyTy::VariantDef::get_error_node ();\n-    if (function_tyty->get_kind () == TyTy::TypeKind::ADT)\n-      {\n-\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (function_tyty);\n-\tif (adt->is_enum ())\n-\t  {\n-\t    // lookup variant id\n-\t    HirId variant_id;\n-\t    bool ok = context->lookup_variant_definition (\n-\t      expr.get_fnexpr ()->get_mappings ().get_hirid (), &variant_id);\n-\t    rust_assert (ok);\n-\n-\t    TyTy::VariantDef *lookup_variant = nullptr;\n-\t    ok = adt->lookup_variant_by_id (variant_id, &lookup_variant);\n-\t    rust_assert (ok);\n-\n-\t    variant = *lookup_variant;\n-\t  }\n-\telse\n-\t  {\n-\t    rust_assert (adt->number_of_variants () == 1);\n-\t    variant = *adt->get_variants ().at (0);\n-\t  }\n-      }\n-\n-    infered\n-      = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n-  }\n+  static TyTy::BaseType *Resolve (HIR::Expr *expr);\n \n+  void visit (HIR::TupleIndexExpr &expr) override;\n+  void visit (HIR::TupleExpr &expr) override;\n+  void visit (HIR::ReturnExpr &expr) override;\n+  void visit (HIR::CallExpr &expr) override;\n   void visit (HIR::MethodCallExpr &expr) override;\n-\n-  void visit (HIR::AssignmentExpr &expr) override\n-  {\n-    infered\n-      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n-\n-    coercion_site (expr.get_mappings ().get_hirid (), lhs, rhs,\n-\t\t   expr.get_locus ());\n-  }\n-\n-  void visit (HIR::CompoundAssignmentExpr &expr) override\n-  {\n-    infered\n-      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get ());\n-\n-    // we dont care about the result of the unify from a compound assignment\n-    // since this is a unit-type expr\n-    auto result = lhs->unify (rhs);\n-    if (result->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    auto lang_item_type\n-      = Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n-\texpr.get_expr_type ());\n-    bool operator_overloaded\n-      = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n-    if (operator_overloaded)\n-      return;\n-\n-    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n-    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n-    bool valid = valid_lhs && valid_rhs;\n-    if (!valid)\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"cannot apply this operator to types %s and %s\",\n-\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n-\treturn;\n-      }\n-  }\n-\n-  void visit (HIR::IdentifierExpr &expr) override\n-  {\n-    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n-\n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-      {\n-\tresolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n-      }\n-\n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\t// FIXME this needs to go away and just return error node\n-\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (ref_node_id, &ref))\n-      {\n-\t// FIXME\n-\t// this is an internal error\n-\trust_error_at (expr.get_locus (), \"123 reverse lookup failure\");\n-\treturn;\n-      }\n-\n-    // the base reference for this name _must_ have a type set\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (ref, &lookup))\n-      {\n-\t// FIXME\n-\t// this is an internal error\n-\trust_error_at (mappings->lookup_location (ref),\n-\t\t       \"Failed to resolve IdentifierExpr type: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    infered = lookup->clone ();\n-\n-    // Generic unit structs look like an identifier but they actually need be\n-    // handled as a path-in-expression so this gives us a chance to infer the\n-    // generic parameters.\n-    // see https://github.com/Rust-GCC/gccrs/issues/1447\n-    bool is_unit_struct\n-      = infered->get_kind () == TyTy::TypeKind::ADT && infered->is_unit ();\n-    if (is_unit_struct && infered->needs_generic_substitutions ())\n-      {\n-\tinfered = SubstMapper::InferSubst (infered, expr.get_locus ());\n-      }\n-  }\n-\n-  void visit (HIR::LiteralExpr &expr) override\n-  {\n-    infered = resolve_literal (expr.get_mappings (), expr.get_literal (),\n-\t\t\t       expr.get_locus ());\n-  }\n-\n-  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n-\n-    auto lang_item_type\n-      = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n-    bool operator_overloaded\n-      = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n-    if (operator_overloaded)\n-      return;\n-\n-    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n-    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n-    bool valid = valid_lhs && valid_rhs;\n-    if (!valid)\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"cannot apply this operator to types %s and %s\",\n-\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    switch (expr.get_expr_type ())\n-      {\n-      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n-      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n-\tinfered = rhs->cast (lhs);\n-\tbreak;\n-\n-      default:\n-\tinfered = lhs->unify (rhs);\n-\tbreak;\n-      }\n-  }\n-\n-  void visit (HIR::ComparisonExpr &expr) override\n-  {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n-\n-    auto result = lhs->unify (rhs);\n-    if (result == nullptr || result->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    bool ok = context->lookup_builtin (\"bool\", &infered);\n-    rust_assert (ok);\n-  }\n-\n-  void visit (HIR::LazyBooleanExpr &expr) override\n-  {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n-\n-    // we expect the lhs and rhs must be bools at this point\n-    TyTy::BoolType elhs (expr.get_mappings ().get_hirid ());\n-    lhs = elhs.unify (lhs);\n-    if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    TyTy::BoolType rlhs (expr.get_mappings ().get_hirid ());\n-    rhs = elhs.unify (rhs);\n-    if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    infered = lhs->unify (rhs);\n-  }\n-\n-  void visit (HIR::NegationExpr &expr) override\n-  {\n-    auto negated_expr_ty = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n-\n-    // check for operator overload\n-    auto lang_item_type = Analysis::RustLangItem::NegationOperatorToLangItem (\n-      expr.get_expr_type ());\n-    bool operator_overloaded\n-      = resolve_operator_overload (lang_item_type, expr, negated_expr_ty,\n-\t\t\t\t   nullptr);\n-    if (operator_overloaded)\n-      return;\n-\n-    // https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators\n-    switch (expr.get_expr_type ())\n-      {\n-\tcase NegationOperator::NEGATE: {\n-\t  bool valid\n-\t    = (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::FLOAT)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::ISIZE)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::USIZE)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n-\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n-\t\t      == TyTy::InferType::INTEGRAL))\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n-\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n-\t\t      == TyTy::InferType::FLOAT));\n-\t  if (!valid)\n-\t    {\n-\t      rust_error_at (expr.get_locus (), \"cannot apply unary - to %s\",\n-\t\t\t     negated_expr_ty->as_string ().c_str ());\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-\n-\tcase NegationOperator::NOT: {\n-\t  bool valid\n-\t    = (negated_expr_ty->get_kind () == TyTy::TypeKind::BOOL)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n-\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n-\t\t      == TyTy::InferType::INTEGRAL));\n-\t  if (!valid)\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"cannot apply unary %<!%> to %s\",\n-\t\t\t     negated_expr_ty->as_string ().c_str ());\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-      }\n-\n-    infered = negated_expr_ty->clone ();\n-    infered->append_reference (negated_expr_ty->get_ref ());\n-  }\n-\n-  void visit (HIR::IfExpr &expr) override\n-  {\n-    TypeCheckExpr::Resolve (expr.get_if_condition ());\n-    TypeCheckExpr::Resolve (expr.get_if_block ());\n-\n-    infered\n-      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-  }\n-\n-  void visit (HIR::IfExprConseqElse &expr) override\n-  {\n-    TypeCheckExpr::Resolve (expr.get_if_condition ());\n-    auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n-    auto else_blk_resolved = TypeCheckExpr::Resolve (expr.get_else_block ());\n-\n-    if (if_blk_resolved->get_kind () == TyTy::NEVER)\n-      infered = else_blk_resolved;\n-    else if (else_blk_resolved->get_kind () == TyTy::NEVER)\n-      infered = if_blk_resolved;\n-    else\n-      infered = if_blk_resolved->unify (else_blk_resolved);\n-  }\n-\n-  void visit (HIR::IfExprConseqIf &expr) override\n-  {\n-    TypeCheckExpr::Resolve (expr.get_if_condition ());\n-    auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n-    auto else_blk_resolved\n-      = TypeCheckExpr::Resolve (expr.get_conseq_if_expr ());\n-\n-    if (if_blk_resolved->get_kind () == TyTy::NEVER)\n-      infered = else_blk_resolved;\n-    else if (else_blk_resolved->get_kind () == TyTy::NEVER)\n-      infered = if_blk_resolved;\n-    else\n-      infered = if_blk_resolved->unify (else_blk_resolved);\n-  }\n-\n-  void visit (HIR::IfLetExpr &expr) override\n-  {\n-    // this needs to perform a least upper bound coercion on the blocks and then\n-    // unify the scruintee and arms\n-    TyTy::BaseType *scrutinee_tyty\n-      = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get ());\n-\n-    for (auto &pattern : expr.get_patterns ())\n-      {\n-\tTyTy::BaseType *kase_arm_ty\n-\t  = TypeCheckPattern::Resolve (pattern.get (), scrutinee_tyty);\n-\n-\tTyTy::BaseType *checked_kase = scrutinee_tyty->unify (kase_arm_ty);\n-\tif (checked_kase->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n-\n-    TypeCheckExpr::Resolve (expr.get_if_block ());\n-\n-    infered\n-      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-  }\n-\n+  void visit (HIR::AssignmentExpr &expr) override;\n+  void visit (HIR::CompoundAssignmentExpr &expr) override;\n+  void visit (HIR::IdentifierExpr &expr) override;\n+  void visit (HIR::LiteralExpr &expr) override;\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override;\n+  void visit (HIR::ComparisonExpr &expr) override;\n+  void visit (HIR::LazyBooleanExpr &expr) override;\n+  void visit (HIR::NegationExpr &expr) override;\n+  void visit (HIR::IfExpr &expr) override;\n+  void visit (HIR::IfExprConseqElse &expr) override;\n+  void visit (HIR::IfExprConseqIf &expr) override;\n+  void visit (HIR::IfLetExpr &expr) override;\n   void visit (HIR::BlockExpr &expr) override;\n-\n-  void visit (HIR::UnsafeBlockExpr &expr) override\n-  {\n-    infered = TypeCheckExpr::Resolve (expr.get_block_expr ().get ());\n-  }\n-\n+  void visit (HIR::UnsafeBlockExpr &expr) override;\n   void visit (HIR::ArrayIndexExpr &expr) override;\n-\n-  void visit (HIR::ArrayExpr &expr) override\n-  {\n-    HIR::ArrayElems &elements = *expr.get_internal_elements ();\n-\n-    HIR::Expr *capacity_expr = nullptr;\n-    TyTy::BaseType *element_type = nullptr;\n-    switch (elements.get_array_expr_type ())\n-      {\n-\tcase HIR::ArrayElems::ArrayExprType::COPIED: {\n-\t  HIR::ArrayElemsCopied &elems\n-\t    = static_cast<HIR::ArrayElemsCopied &> (elements);\n-\t  element_type = TypeCheckExpr::Resolve (elems.get_elem_to_copy ());\n-\n-\t  auto capacity_type\n-\t    = TypeCheckExpr::Resolve (elems.get_num_copies_expr ());\n-\n-\t  TyTy::BaseType *expected_ty = nullptr;\n-\t  bool ok = context->lookup_builtin (\"usize\", &expected_ty);\n-\t  rust_assert (ok);\n-\t  context->insert_type (elems.get_num_copies_expr ()->get_mappings (),\n-\t\t\t\texpected_ty);\n-\n-\t  auto unified = expected_ty->unify (capacity_type);\n-\t  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n-\t    return;\n-\n-\t  capacity_expr = elems.get_num_copies_expr ();\n-\t}\n-\tbreak;\n-\n-\tcase HIR::ArrayElems::ArrayExprType::VALUES: {\n-\t  HIR::ArrayElemsValues &elems\n-\t    = static_cast<HIR::ArrayElemsValues &> (elements);\n-\n-\t  std::vector<TyTy::BaseType *> types;\n-\t  for (auto &elem : elems.get_values ())\n-\t    {\n-\t      types.push_back (TypeCheckExpr::Resolve (elem.get ()));\n-\t    }\n-\n-\t  element_type = TyTy::TyVar::get_implicit_infer_var (expr.get_locus ())\n-\t\t\t   .get_tyty ();\n-\t  for (auto &type : types)\n-\t    {\n-\t      element_type = element_type->unify (type);\n-\t    }\n-\n-\t  auto crate_num = mappings->get_current_crate ();\n-\t  Analysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n-\t\t\t\t\t mappings->get_next_hir_id (crate_num),\n-\t\t\t\t\t UNKNOWN_LOCAL_DEFID);\n-\t  std::string capacity_str = std::to_string (elems.get_num_elements ());\n-\t  capacity_expr\n-\t    = new HIR::LiteralExpr (mapping, capacity_str,\n-\t\t\t\t    HIR::Literal::LitType::INT,\n-\t\t\t\t    PrimitiveCoreType::CORETYPE_USIZE,\n-\t\t\t\t    Location (), {});\n-\n-\t  // mark the type for this implicit node\n-\t  TyTy::BaseType *expected_ty = nullptr;\n-\t  bool ok = context->lookup_builtin (\"usize\", &expected_ty);\n-\t  rust_assert (ok);\n-\t  context->insert_type (mapping, expected_ty);\n-\t}\n-\tbreak;\n-      }\n-\n-    infered = new TyTy::ArrayType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t   expr.get_locus (), *capacity_expr,\n-\t\t\t\t   TyTy::TyVar (element_type->get_ref ()));\n-  }\n-\n-  // empty struct\n-  void visit (HIR::StructExprStruct &struct_expr) override\n-  {\n-    TyTy::BaseType *struct_path_ty\n-      = TypeCheckExpr::Resolve (&struct_expr.get_struct_name ());\n-    if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n-      {\n-\trust_error_at (struct_expr.get_struct_name ().get_locus (),\n-\t\t       \"expected an ADT type for constructor\");\n-\treturn;\n-      }\n-\n-    infered = struct_path_ty;\n-  }\n-\n-  void visit (HIR::StructExprStructFields &struct_expr) override\n-  {\n-    infered = TypeCheckStructExpr::Resolve (&struct_expr);\n-  }\n-\n-  void visit (HIR::GroupedExpr &expr) override\n-  {\n-    infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get ());\n-  }\n-\n-  void visit (HIR::FieldAccessExpr &expr) override\n-  {\n-    auto struct_base\n-      = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get ());\n-\n-    // FIXME does this require autoderef here?\n-    if (struct_base->get_kind () == TyTy::TypeKind::REF)\n-      {\n-\tTyTy::ReferenceType *r\n-\t  = static_cast<TyTy::ReferenceType *> (struct_base);\n-\tstruct_base = r->get_base ();\n-      }\n-\n-    bool is_valid_type = struct_base->get_kind () == TyTy::TypeKind::ADT;\n-    if (!is_valid_type)\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"expected algebraic data type got: [%s]\",\n-\t\t       struct_base->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (struct_base);\n-    rust_assert (!adt->is_enum ());\n-    rust_assert (adt->number_of_variants () == 1);\n-\n-    TyTy::VariantDef *vaiant = adt->get_variants ().at (0);\n-\n-    TyTy::StructFieldType *lookup = nullptr;\n-    bool found\n-      = vaiant->lookup_field (expr.get_field_name (), &lookup, nullptr);\n-    if (!found)\n-      {\n-\trust_error_at (expr.get_locus (), \"unknown field [%s] for type [%s]\",\n-\t\t       expr.get_field_name ().c_str (),\n-\t\t       adt->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    infered = lookup->get_field_type ();\n-  }\n-\n+  void visit (HIR::ArrayExpr &expr) override;\n+  void visit (HIR::StructExprStruct &struct_expr) override;\n+  void visit (HIR::StructExprStructFields &struct_expr) override;\n+  void visit (HIR::GroupedExpr &expr) override;\n+  void visit (HIR::FieldAccessExpr &expr) override;\n   void visit (HIR::QualifiedPathInExpression &expr) override;\n-\n   void visit (HIR::PathInExpression &expr) override;\n-\n-  void visit (HIR::LoopExpr &expr) override\n-  {\n-    context->push_new_loop_context (expr.get_mappings ().get_hirid (),\n-\t\t\t\t    expr.get_locus ());\n-    TyTy::BaseType *block_expr\n-      = TypeCheckExpr::Resolve (expr.get_loop_block ().get ());\n-    if (!block_expr->is_unit ())\n-      {\n-\trust_error_at (expr.get_loop_block ()->get_locus (),\n-\t\t       \"expected %<()%> got %s\",\n-\t\t       block_expr->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *loop_context_type = context->pop_loop_context ();\n-\n-    bool loop_context_type_infered\n-      = (loop_context_type->get_kind () != TyTy::TypeKind::INFER)\n-\t|| ((loop_context_type->get_kind () == TyTy::TypeKind::INFER)\n-\t    && (((TyTy::InferType *) loop_context_type)->get_infer_kind ()\n-\t\t!= TyTy::InferType::GENERAL));\n-\n-    infered\n-      = loop_context_type_infered\n-\t  ? loop_context_type\n-\t  : TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-  }\n-\n-  void visit (HIR::WhileLoopExpr &expr) override\n-  {\n-    context->push_new_while_loop_context (expr.get_mappings ().get_hirid ());\n-\n-    TypeCheckExpr::Resolve (expr.get_predicate_expr ().get ());\n-    TyTy::BaseType *block_expr\n-      = TypeCheckExpr::Resolve (expr.get_loop_block ().get ());\n-\n-    if (!block_expr->is_unit ())\n-      {\n-\trust_error_at (expr.get_loop_block ()->get_locus (),\n-\t\t       \"expected %<()%> got %s\",\n-\t\t       block_expr->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    context->pop_loop_context ();\n-    infered\n-      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-  }\n-\n-  void visit (HIR::BreakExpr &expr) override\n-  {\n-    if (!context->have_loop_context ())\n-      {\n-\trust_error_at (expr.get_locus (), \"cannot %<break%> outside of a loop\");\n-\treturn;\n-      }\n-\n-    if (expr.has_break_expr ())\n-      {\n-\tTyTy::BaseType *break_expr_tyty\n-\t  = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n-\n-\tTyTy::BaseType *loop_context = context->peek_loop_context ();\n-\tif (loop_context->get_kind () == TyTy::TypeKind::ERROR)\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"can only break with a value inside %<loop%>\");\n-\t    return;\n-\t  }\n-\n-\tTyTy::BaseType *unified_ty = loop_context->unify (break_expr_tyty);\n-\tcontext->swap_head_loop_context (unified_ty);\n-      }\n-\n-    infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n-  }\n-\n-  void visit (HIR::ContinueExpr &expr) override\n-  {\n-    if (!context->have_loop_context ())\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"cannot %<continue%> outside of a loop\");\n-\treturn;\n-      }\n-\n-    infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n-  }\n-\n-  void visit (HIR::BorrowExpr &expr) override\n-  {\n-    TyTy::BaseType *resolved_base\n-      = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n-\n-    // In Rust this is valid because of DST's\n-    //\n-    // fn test() {\n-    //     let a:&str = \"TEST 1\";\n-    //     let b:&str = &\"TEST 2\";\n-    // }\n-    if (resolved_base->get_kind () == TyTy::TypeKind::REF)\n-      {\n-\tconst TyTy::ReferenceType *ref\n-\t  = static_cast<const TyTy::ReferenceType *> (resolved_base);\n-\n-\t// this might end up being a more generic is_dyn object check but lets\n-\t// double check dyn traits type-layout first\n-\tif (ref->is_dyn_str_type ())\n-\t  {\n-\t    infered = resolved_base;\n-\t    return;\n-\t  }\n-      }\n-\n-    if (expr.get_is_double_borrow ())\n-      {\n-\t// FIXME double_reference\n-\tgcc_unreachable ();\n-      }\n-\n-    infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       TyTy::TyVar (resolved_base->get_ref ()),\n-\t\t\t\t       expr.get_mut ());\n-  }\n-\n-  void visit (HIR::DereferenceExpr &expr) override\n+  void visit (HIR::LoopExpr &expr) override;\n+  void visit (HIR::BreakExpr &expr) override;\n+  void visit (HIR::ContinueExpr &expr) override;\n+  void visit (HIR::BorrowExpr &expr) override;\n+  void visit (HIR::DereferenceExpr &expr) override;\n+  void visit (HIR::TypeCastExpr &expr) override;\n+  void visit (HIR::MatchExpr &expr) override;\n+  void visit (HIR::RangeFromToExpr &expr) override;\n+  void visit (HIR::RangeFromExpr &expr) override;\n+  void visit (HIR::RangeToExpr &expr) override;\n+  void visit (HIR::RangeFullExpr &expr) override;\n+  void visit (HIR::RangeFromToInclExpr &expr) override;\n+  void visit (HIR::WhileLoopExpr &expr) override;\n+\n+  // TODO\n+  void visit (HIR::ClosureExprInnerTyped &) override {}\n+  void visit (HIR::ClosureExprInner &expr) override {}\n+  void visit (HIR::ErrorPropagationExpr &expr) override {}\n+  void visit (HIR::RangeToInclExpr &expr) override {}\n+  void visit (HIR::WhileLetLoopExpr &expr) override {}\n+  void visit (HIR::ForLoopExpr &expr) override {}\n+  void visit (HIR::IfExprConseqIfLet &expr) override {}\n+  void visit (HIR::IfLetExprConseqElse &expr) override {}\n+  void visit (HIR::IfLetExprConseqIf &expr) override {}\n+  void visit (HIR::IfLetExprConseqIfLet &expr) override {}\n+  void visit (HIR::AwaitExpr &expr) override {}\n+  void visit (HIR::AsyncBlockExpr &expr) override {}\n+\n+  // don't need to implement these see rust-hir-type-check-struct-field.h\n+  void visit (HIR::StructExprFieldIdentifier &field) override\n   {\n-    TyTy::BaseType *resolved_base\n-      = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n-\n-    auto lang_item_type = Analysis::RustLangItem::ItemType::DEREF;\n-    bool operator_overloaded\n-      = resolve_operator_overload (lang_item_type, expr, resolved_base,\n-\t\t\t\t   nullptr);\n-    if (operator_overloaded)\n-      {\n-\t// operator overloaded deref always refurns a reference type lets assert\n-\t// this\n-\trust_assert (infered->get_kind () == TyTy::TypeKind::REF);\n-\tresolved_base = infered;\n-      }\n-\n-    bool is_valid_type\n-      = resolved_base->get_kind () == TyTy::TypeKind::REF\n-\t|| resolved_base->get_kind () == TyTy::TypeKind::POINTER;\n-    if (!is_valid_type)\n-      {\n-\trust_error_at (expr.get_locus (), \"expected reference type got %s\",\n-\t\t       resolved_base->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    if (resolved_base->get_kind () == TyTy::TypeKind::REF)\n-      {\n-\tTyTy::ReferenceType *ref_base\n-\t  = static_cast<TyTy::ReferenceType *> (resolved_base);\n-\tinfered = ref_base->get_base ()->clone ();\n-      }\n-    else\n-      {\n-\tTyTy::PointerType *ref_base\n-\t  = static_cast<TyTy::PointerType *> (resolved_base);\n-\tinfered = ref_base->get_base ()->clone ();\n-      }\n+    gcc_unreachable ();\n   }\n-\n-  void visit (HIR::TypeCastExpr &expr) override\n+  void visit (HIR::StructExprFieldIdentifierValue &field) override\n   {\n-    TyTy::BaseType *expr_to_convert\n-      = TypeCheckExpr::Resolve (expr.get_casted_expr ().get ());\n-    TyTy::BaseType *tyty_to_convert_to\n-      = TypeCheckType::Resolve (expr.get_type_to_convert_to ().get ());\n-\n-    infered = expr_to_convert->cast (tyty_to_convert_to);\n+    gcc_unreachable ();\n   }\n-\n-  void visit (HIR::MatchExpr &expr) override\n+  void visit (HIR::StructExprFieldIndexValue &field) override\n   {\n-    // this needs to perform a least upper bound coercion on the blocks and then\n-    // unify the scruintee and arms\n-    TyTy::BaseType *scrutinee_tyty\n-      = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get ());\n-\n-    std::vector<TyTy::BaseType *> kase_block_tys;\n-    for (auto &kase : expr.get_match_cases ())\n-      {\n-\t// lets check the arms\n-\tHIR::MatchArm &kase_arm = kase.get_arm ();\n-\tfor (auto &pattern : kase_arm.get_patterns ())\n-\t  {\n-\t    TyTy::BaseType *kase_arm_ty\n-\t      = TypeCheckPattern::Resolve (pattern.get (), scrutinee_tyty);\n-\n-\t    TyTy::BaseType *checked_kase = scrutinee_tyty->unify (kase_arm_ty);\n-\t    if (checked_kase->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-\n-\t// check the kase type\n-\tTyTy::BaseType *kase_block_ty\n-\t  = TypeCheckExpr::Resolve (kase.get_expr ().get ());\n-\tkase_block_tys.push_back (kase_block_ty);\n-      }\n-\n-    if (kase_block_tys.size () == 0)\n-      {\n-\tinfered\n-\t  = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-\treturn;\n-      }\n-\n-    infered = kase_block_tys.at (0);\n-    for (size_t i = 1; i < kase_block_tys.size (); i++)\n-      {\n-\tTyTy::BaseType *kase_ty = kase_block_tys.at (i);\n-\tinfered = infered->unify (kase_ty);\n-\tif (infered->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n+    gcc_unreachable ();\n   }\n \n-  void visit (HIR::RangeFromToExpr &expr) override;\n-\n-  void visit (HIR::RangeFromExpr &expr) override;\n-\n-  void visit (HIR::RangeToExpr &expr) override;\n-\n-  void visit (HIR::RangeFullExpr &expr) override;\n-\n-  void visit (HIR::RangeFromToInclExpr &expr) override;\n-\n protected:\n   bool\n   resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n \t\t\t     HIR::OperatorExprMeta expr, TyTy::BaseType *lhs,\n \t\t\t     TyTy::BaseType *rhs);\n \n private:\n-  TypeCheckExpr () : TypeCheckBase (), infered (nullptr) {}\n+  TypeCheckExpr ();\n \n   TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n \t\t\t\t     size_t *offset,\n@@ -923,59 +120,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   bool\n   validate_arithmetic_type (const TyTy::BaseType *tyty,\n-\t\t\t    HIR::ArithmeticOrLogicalExpr::ExprType expr_type)\n-  {\n-    const TyTy::BaseType *type = tyty->destructure ();\n-\n-    // https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators\n-    // this will change later when traits are added\n-    switch (expr_type)\n-      {\n-      case ArithmeticOrLogicalOperator::ADD:\n-      case ArithmeticOrLogicalOperator::SUBTRACT:\n-      case ArithmeticOrLogicalOperator::MULTIPLY:\n-      case ArithmeticOrLogicalOperator::DIVIDE:\n-      case ArithmeticOrLogicalOperator::MODULUS:\n-\treturn (type->get_kind () == TyTy::TypeKind::INT)\n-\t       || (type->get_kind () == TyTy::TypeKind::UINT)\n-\t       || (type->get_kind () == TyTy::TypeKind::FLOAT)\n-\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n-\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n-\t       || (type->get_kind () == TyTy::TypeKind::INFER\n-\t\t   && (((const TyTy::InferType *) type)->get_infer_kind ()\n-\t\t       == TyTy::InferType::INTEGRAL))\n-\t       || (type->get_kind () == TyTy::TypeKind::INFER\n-\t\t   && (((const TyTy::InferType *) type)->get_infer_kind ()\n-\t\t       == TyTy::InferType::FLOAT));\n-\n-\t// integers or bools\n-      case ArithmeticOrLogicalOperator::BITWISE_AND:\n-      case ArithmeticOrLogicalOperator::BITWISE_OR:\n-      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n-\treturn (type->get_kind () == TyTy::TypeKind::INT)\n-\t       || (type->get_kind () == TyTy::TypeKind::UINT)\n-\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n-\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n-\t       || (type->get_kind () == TyTy::TypeKind::BOOL)\n-\t       || (type->get_kind () == TyTy::TypeKind::INFER\n-\t\t   && (((const TyTy::InferType *) type)->get_infer_kind ()\n-\t\t       == TyTy::InferType::INTEGRAL));\n-\n-\t// integers only\n-      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n-      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n-\treturn (type->get_kind () == TyTy::TypeKind::INT)\n-\t       || (type->get_kind () == TyTy::TypeKind::UINT)\n-\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n-\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n-\t       || (type->get_kind () == TyTy::TypeKind::INFER\n-\t\t   && (((const TyTy::InferType *) type)->get_infer_kind ()\n-\t\t       == TyTy::InferType::INTEGRAL));\n-      }\n-\n-    gcc_unreachable ();\n-    return false;\n-  }\n+\t\t\t    HIR::ArithmeticOrLogicalExpr::ExprType expr_type);\n \n   /* The return value of TypeCheckExpr::Resolve */\n   TyTy::BaseType *infered;"}, {"sha": "784e4990409c3797b44307b62e75fc9e26ad0225", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.cc", "status": "added", "additions": 583, "deletions": 0, "changes": 583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -0,0 +1,583 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-implitem.h\"\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckTopLevelExternItem::TypeCheckTopLevelExternItem (\n+  const HIR::ExternBlock &parent)\n+  : TypeCheckBase (), parent (parent)\n+{}\n+\n+void\n+TypeCheckTopLevelExternItem::Resolve (HIR::ExternalItem *item,\n+\t\t\t\t      const HIR::ExternBlock &parent)\n+{\n+  TypeCheckTopLevelExternItem resolver (parent);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckTopLevelExternItem::visit (HIR::ExternalStaticItem &item)\n+{\n+  TyTy::BaseType *actual_type\n+    = TypeCheckType::Resolve (item.get_item_type ().get ());\n+\n+  context->insert_type (item.get_mappings (), actual_type);\n+}\n+\n+void\n+TypeCheckTopLevelExternItem::visit (HIR::ExternalFunctionItem &function)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ().get ());\n+\n+      // these are implicit mappings and not used\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      HIR::IdentifierPattern *param_pattern\n+\t= new HIR::IdentifierPattern (mapping, param.get_param_name (),\n+\t\t\t\t      Location (), false, Mutability::Imm,\n+\t\t\t\t      std::unique_ptr<HIR::Pattern> (nullptr));\n+\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param_pattern,\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+\n+      // FIXME do we need error checking for patterns here?\n+      // see https://github.com/Rust-GCC/gccrs/issues/995\n+    }\n+\n+  uint8_t flags = TyTy::FnType::FNTYPE_IS_EXTERN_FLAG;\n+  if (function.is_variadic ())\n+    flags |= TyTy::FnType::FNTYPE_IS_VARADIC_FLAG;\n+\n+  RustIdent ident{\n+    CanonicalPath::new_seg (function.get_mappings ().get_nodeid (),\n+\t\t\t    function.get_item_name ()),\n+    function.get_locus ()};\n+\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_item_name (), ident, flags,\n+\t\t\t\t  parent.get_abi (), std::move (params),\n+\t\t\t\t  ret_type, std::move (substitutions));\n+\n+  context->insert_type (function.get_mappings (), fnType);\n+}\n+\n+TypeCheckTopLevelImplItem::TypeCheckTopLevelImplItem (\n+  TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+  : TypeCheckBase (), self (self), substitutions (substitutions)\n+{}\n+\n+void\n+TypeCheckTopLevelImplItem::Resolve (\n+  HIR::ImplItem *item, TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+{\n+  TypeCheckTopLevelImplItem resolver (self, substitutions);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckTopLevelImplItem::visit (HIR::TypeAlias &alias)\n+{\n+  TyTy::BaseType *actual_type\n+    = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n+\n+  context->insert_type (alias.get_mappings (), actual_type);\n+\n+  for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+}\n+\n+void\n+TypeCheckTopLevelImplItem::visit (HIR::ConstantItem &constant)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+  context->insert_type (constant.get_mappings (), type->unify (expr_type));\n+}\n+\n+void\n+TypeCheckTopLevelImplItem::visit (HIR::Function &function)\n+{\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_function_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  if (function.is_method ())\n+    {\n+      // these are implicit mappings and not used\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      // add the synthetic self param at the front, this is a placeholder for\n+      // compilation to know parameter names. The types are ignored but we\n+      // reuse the HIR identifier pattern which requires it\n+      HIR::SelfParam &self_param = function.get_self_param ();\n+      HIR::IdentifierPattern *self_pattern\n+\t= new HIR::IdentifierPattern (mapping, \"self\", self_param.get_locus (),\n+\t\t\t\t      self_param.is_ref (),\n+\t\t\t\t      self_param.get_mut (),\n+\t\t\t\t      std::unique_ptr<HIR::Pattern> (nullptr));\n+\n+      // might have a specified type\n+      TyTy::BaseType *self_type = nullptr;\n+      if (self_param.has_type ())\n+\t{\n+\t  std::unique_ptr<HIR::Type> &specified_type = self_param.get_type ();\n+\t  self_type = TypeCheckType::Resolve (specified_type.get ());\n+\t}\n+      else\n+\t{\n+\t  switch (self_param.get_self_kind ())\n+\t    {\n+\t    case HIR::SelfParam::IMM:\n+\t    case HIR::SelfParam::MUT:\n+\t      self_type = self->clone ();\n+\t      break;\n+\n+\t    case HIR::SelfParam::IMM_REF:\n+\t      self_type = new TyTy::ReferenceType (\n+\t\tself_param.get_mappings ().get_hirid (),\n+\t\tTyTy::TyVar (self->get_ref ()), Mutability::Imm);\n+\t      break;\n+\n+\t    case HIR::SelfParam::MUT_REF:\n+\t      self_type = new TyTy::ReferenceType (\n+\t\tself_param.get_mappings ().get_hirid (),\n+\t\tTyTy::TyVar (self->get_ref ()), Mutability::Mut);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t      return;\n+\t    }\n+\t}\n+\n+      context->insert_type (self_param.get_mappings (), self_type);\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern, self_type));\n+    }\n+\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n+    }\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, function.get_locus ()};\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_function_name (), ident,\n+\t\t\t\t  function.is_method ()\n+\t\t\t\t    ? TyTy::FnType::FNTYPE_IS_METHOD_FLAG\n+\t\t\t\t    : TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n+\t\t\t\t  ABI::RUST, std::move (params), ret_type,\n+\t\t\t\t  std::move (substitutions));\n+\n+  context->insert_type (function.get_mappings (), fnType);\n+}\n+\n+TypeCheckImplItem::TypeCheckImplItem (HIR::ImplBlock *parent,\n+\t\t\t\t      TyTy::BaseType *self)\n+  : TypeCheckBase (), parent (parent), self (self)\n+{}\n+\n+void\n+TypeCheckImplItem::Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item,\n+\t\t\t    TyTy::BaseType *self)\n+{\n+  TypeCheckImplItem resolver (parent, self);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckImplItem::visit (HIR::Function &function)\n+{\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+    {\n+      rust_error_at (function.get_locus (), \"failed to lookup function type\");\n+      return;\n+    }\n+\n+  if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      rust_error_at (function.get_locus (),\n+\t\t     \"found invalid type for function [%s]\",\n+\t\t     lookup->as_string ().c_str ());\n+      return;\n+    }\n+\n+  // need to get the return type from this\n+  TyTy::FnType *resolve_fn_type = static_cast<TyTy::FnType *> (lookup);\n+  auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n+  context->push_return_type (TypeCheckContextItem (parent, &function),\n+\t\t\t     expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n+\n+  context->pop_return_type ();\n+  expected_ret_tyty->unify (block_expr_ty);\n+}\n+\n+void\n+TypeCheckImplItem::visit (HIR::ConstantItem &const_item)\n+{}\n+\n+void\n+TypeCheckImplItem::visit (HIR::TypeAlias &type_alias)\n+{}\n+\n+TypeCheckImplItemWithTrait::TypeCheckImplItemWithTrait (\n+  HIR::ImplBlock *parent, TyTy::BaseType *self,\n+  TyTy::TypeBoundPredicate &trait_reference,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+  : TypeCheckImplItem (parent, self), trait_reference (trait_reference),\n+    resolved_trait_item (TyTy::TypeBoundPredicateItem::error ()),\n+    substitutions (substitutions)\n+{\n+  rust_assert (is_trait_impl_block ());\n+}\n+\n+TyTy::TypeBoundPredicateItem\n+TypeCheckImplItemWithTrait::Resolve (\n+  HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n+  TyTy::TypeBoundPredicate &trait_reference,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+{\n+  TypeCheckImplItemWithTrait resolver (parent, self, trait_reference,\n+\t\t\t\t       substitutions);\n+  item->accept_vis (resolver);\n+  return resolver.resolved_trait_item;\n+}\n+\n+void\n+TypeCheckImplItemWithTrait::visit (HIR::ConstantItem &constant)\n+{\n+  // normal resolution of the item\n+  TypeCheckImplItem::visit (constant);\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n+    return;\n+\n+  // map the impl item to the associated trait item\n+  const auto tref = trait_reference.get ();\n+  const TraitItemReference *raw_trait_item = nullptr;\n+  bool found\n+    = tref->lookup_trait_item_by_type (constant.get_identifier (),\n+\t\t\t\t       TraitItemReference::TraitItemType::CONST,\n+\t\t\t\t       &raw_trait_item);\n+\n+  // unknown trait item\n+  if (!found || raw_trait_item->is_error ())\n+    {\n+      RichLocation r (constant.get_locus ());\n+      r.add_range (trait_reference.get_locus ());\n+      rust_error_at (r, \"constant %<%s%> is not a member of trait %<%s%>\",\n+\t\t     constant.get_identifier ().c_str (),\n+\t\t     trait_reference.get_name ().c_str ());\n+      return;\n+    }\n+\n+  // get the item from the predicate\n+  resolved_trait_item = trait_reference.lookup_associated_item (raw_trait_item);\n+  rust_assert (!resolved_trait_item.is_error ());\n+\n+  // merge the attributes\n+  const HIR::TraitItem *hir_trait_item\n+    = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n+  merge_attributes (constant.get_outer_attrs (), *hir_trait_item);\n+\n+  // check the types are compatible\n+  auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+  if (!trait_item_type->can_eq (lookup, true))\n+    {\n+      RichLocation r (constant.get_locus ());\n+      r.add_range (resolved_trait_item.get_locus ());\n+\n+      rust_error_at (\n+\tr, \"constant %<%s%> has an incompatible type for trait %<%s%>\",\n+\tconstant.get_identifier ().c_str (),\n+\ttrait_reference.get_name ().c_str ());\n+    }\n+}\n+\n+void\n+TypeCheckImplItemWithTrait::visit (HIR::TypeAlias &type)\n+{\n+  // normal resolution of the item\n+  TypeCheckImplItem::visit (type);\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+    return;\n+\n+  // map the impl item to the associated trait item\n+  const auto tref = trait_reference.get ();\n+  const TraitItemReference *raw_trait_item = nullptr;\n+  bool found\n+    = tref->lookup_trait_item_by_type (type.get_new_type_name (),\n+\t\t\t\t       TraitItemReference::TraitItemType::TYPE,\n+\t\t\t\t       &raw_trait_item);\n+\n+  // unknown trait item\n+  if (!found || raw_trait_item->is_error ())\n+    {\n+      RichLocation r (type.get_locus ());\n+      r.add_range (trait_reference.get_locus ());\n+      rust_error_at (r, \"type alias %<%s%> is not a member of trait %<%s%>\",\n+\t\t     type.get_new_type_name ().c_str (),\n+\t\t     trait_reference.get_name ().c_str ());\n+      return;\n+    }\n+\n+  // get the item from the predicate\n+  resolved_trait_item = trait_reference.lookup_associated_item (raw_trait_item);\n+  rust_assert (!resolved_trait_item.is_error ());\n+\n+  // merge the attributes\n+  const HIR::TraitItem *hir_trait_item\n+    = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n+  merge_attributes (type.get_outer_attrs (), *hir_trait_item);\n+\n+  // check the types are compatible\n+  auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+  if (!trait_item_type->can_eq (lookup, true))\n+    {\n+      RichLocation r (type.get_locus ());\n+      r.add_range (resolved_trait_item.get_locus ());\n+\n+      rust_error_at (\n+\tr, \"type alias %<%s%> has an incompatible type for trait %<%s%>\",\n+\ttype.get_new_type_name ().c_str (),\n+\ttrait_reference.get_name ().c_str ());\n+    }\n+\n+  // its actually a projection, since we need a way to actually bind the\n+  // generic substitutions to the type itself\n+  TyTy::ProjectionType *projection\n+    = new TyTy::ProjectionType (type.get_mappings ().get_hirid (), lookup, tref,\n+\t\t\t\traw_trait_item->get_mappings ().get_defid (),\n+\t\t\t\tsubstitutions);\n+\n+  context->insert_type (type.get_mappings (), projection);\n+  raw_trait_item->associated_type_set (projection);\n+}\n+\n+void\n+TypeCheckImplItemWithTrait::visit (HIR::Function &function)\n+{\n+  // we get the error checking from the base method here\n+  TypeCheckImplItem::visit (function);\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+    return;\n+\n+  // map the impl item to the associated trait item\n+  const auto tref = trait_reference.get ();\n+  const TraitItemReference *raw_trait_item = nullptr;\n+  bool found\n+    = tref->lookup_trait_item_by_type (function.get_function_name (),\n+\t\t\t\t       TraitItemReference::TraitItemType::FN,\n+\t\t\t\t       &raw_trait_item);\n+\n+  // unknown trait item\n+  if (!found || raw_trait_item->is_error ())\n+    {\n+      RichLocation r (function.get_locus ());\n+      r.add_range (trait_reference.get_locus ());\n+      rust_error_at (r, \"method %<%s%> is not a member of trait %<%s%>\",\n+\t\t     function.get_function_name ().c_str (),\n+\t\t     trait_reference.get_name ().c_str ());\n+      return;\n+    }\n+\n+  // get the item from the predicate\n+  resolved_trait_item = trait_reference.lookup_associated_item (raw_trait_item);\n+  rust_assert (!resolved_trait_item.is_error ());\n+\n+  // merge the attributes\n+  const HIR::TraitItem *hir_trait_item\n+    = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n+  merge_attributes (function.get_outer_attrs (), *hir_trait_item);\n+\n+  // check the types are compatible\n+  auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+  if (!trait_item_type->can_eq (lookup, true))\n+    {\n+      RichLocation r (function.get_locus ());\n+      r.add_range (resolved_trait_item.get_locus ());\n+\n+      rust_error_at (r,\n+\t\t     \"method %<%s%> has an incompatible type for trait %<%s%>\",\n+\t\t     function.get_function_name ().c_str (),\n+\t\t     trait_reference.get_name ().c_str ());\n+    }\n+}\n+\n+void\n+TypeCheckImplItemWithTrait::merge_attributes (AST::AttrVec &impl_item_attrs,\n+\t\t\t\t\t      const HIR::TraitItem &trait_item)\n+{\n+  for (const auto &attr : trait_item.get_outer_attrs ())\n+    {\n+      impl_item_attrs.push_back (attr);\n+    }\n+}\n+\n+bool\n+TypeCheckImplItemWithTrait::is_trait_impl_block () const\n+{\n+  return !trait_reference.is_error ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "f2f3faab9e00c4f1b3fef8ecab9dc047e72f69e5", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 26, "deletions": 514, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -20,576 +20,88 @@\n #define RUST_HIR_TYPE_CHECK_IMPLITEM_H\n \n #include \"rust-hir-type-check-base.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-hir-type-check-type.h\"\n-#include \"rust-hir-type-check-expr.h\"\n-#include \"rust-tyty.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-class TypeCheckTopLevelExternItem : public TypeCheckBase\n+class TypeCheckTopLevelExternItem : public TypeCheckBase,\n+\t\t\t\t    public HIR::HIRExternalItemVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  static void Resolve (HIR::ExternalItem *item, const HIR::ExternBlock &parent)\n-  {\n-    TypeCheckTopLevelExternItem resolver (parent);\n-    item->accept_vis (resolver);\n-  }\n-\n-  void visit (HIR::ExternalStaticItem &item) override\n-  {\n-    TyTy::BaseType *actual_type\n-      = TypeCheckType::Resolve (item.get_item_type ().get ());\n-\n-    context->insert_type (item.get_mappings (), actual_type);\n-  }\n-\n-  void visit (HIR::ExternalFunctionItem &function) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic_param : function.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    TyTy::BaseType *ret_type = nullptr;\n-    if (!function.has_return_type ())\n-      ret_type = TyTy::TupleType::get_unit_type (\n-\tfunction.get_mappings ().get_hirid ());\n-    else\n-      {\n-\tauto resolved\n-\t  = TypeCheckType::Resolve (function.get_return_type ().get ());\n-\tif (resolved == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_locus (),\n-\t\t\t   \"failed to resolve return type\");\n-\t    return;\n-\t  }\n-\n-\tret_type = resolved->clone ();\n-\tret_type->set_ref (\n-\t  function.get_return_type ()->get_mappings ().get_hirid ());\n-      }\n-\n-    std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-    for (auto &param : function.get_function_params ())\n-      {\n-\t// get the name as well required for later on\n-\tauto param_tyty = TypeCheckType::Resolve (param.get_type ().get ());\n-\n-\t// these are implicit mappings and not used\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n-\n-\tHIR::IdentifierPattern *param_pattern = new HIR::IdentifierPattern (\n-\t  mapping, param.get_param_name (), Location (), false, Mutability::Imm,\n-\t  std::unique_ptr<HIR::Pattern> (nullptr));\n-\n-\tparams.push_back (\n-\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (param_pattern,\n-\t\t\t\t\t\t       param_tyty));\n-\n-\tcontext->insert_type (param.get_mappings (), param_tyty);\n-\n-\t// FIXME do we need error checking for patterns here?\n-\t// see https://github.com/Rust-GCC/gccrs/issues/995\n-      }\n-\n-    uint8_t flags = TyTy::FnType::FNTYPE_IS_EXTERN_FLAG;\n-    if (function.is_variadic ())\n-      flags |= TyTy::FnType::FNTYPE_IS_VARADIC_FLAG;\n-\n-    RustIdent ident{\n-      CanonicalPath::new_seg (function.get_mappings ().get_nodeid (),\n-\t\t\t      function.get_item_name ()),\n-      function.get_locus ()};\n-\n-    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_item_name (), ident, flags,\n-\t\t\t\t    parent.get_abi (), std::move (params),\n-\t\t\t\t    ret_type, std::move (substitutions));\n+  static void Resolve (HIR::ExternalItem *item, const HIR::ExternBlock &parent);\n \n-    context->insert_type (function.get_mappings (), fnType);\n-  }\n+  void visit (HIR::ExternalStaticItem &item) override;\n+  void visit (HIR::ExternalFunctionItem &function) override;\n \n private:\n-  TypeCheckTopLevelExternItem (const HIR::ExternBlock &parent)\n-    : TypeCheckBase (), parent (parent)\n-  {}\n+  TypeCheckTopLevelExternItem (const HIR::ExternBlock &parent);\n \n   const HIR::ExternBlock &parent;\n };\n \n-class TypeCheckTopLevelImplItem : public TypeCheckBase\n+class TypeCheckTopLevelImplItem : public TypeCheckBase,\n+\t\t\t\t  public HIR::HIRImplVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static void\n   Resolve (HIR::ImplItem *item, TyTy::BaseType *self,\n-\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-  {\n-    TypeCheckTopLevelImplItem resolver (self, substitutions);\n-    item->accept_vis (resolver);\n-  }\n-\n-  void visit (HIR::TypeAlias &alias) override\n-  {\n-    TyTy::BaseType *actual_type\n-      = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n-\n-    context->insert_type (alias.get_mappings (), actual_type);\n-\n-    for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n-      {\n-\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-      }\n-  }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n-    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n-\n-    context->insert_type (constant.get_mappings (), type->unify (expr_type));\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic_param : function.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    for (auto &where_clause_item : function.get_where_clause ().get_items ())\n-      {\n-\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-      }\n-\n-    TyTy::BaseType *ret_type = nullptr;\n-    if (!function.has_function_return_type ())\n-      ret_type = TyTy::TupleType::get_unit_type (\n-\tfunction.get_mappings ().get_hirid ());\n-    else\n-      {\n-\tauto resolved\n-\t  = TypeCheckType::Resolve (function.get_return_type ().get ());\n-\tif (resolved == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_locus (),\n-\t\t\t   \"failed to resolve return type\");\n-\t    return;\n-\t  }\n-\n-\tret_type = resolved->clone ();\n-\tret_type->set_ref (\n-\t  function.get_return_type ()->get_mappings ().get_hirid ());\n-      }\n-\n-    std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-    if (function.is_method ())\n-      {\n-\t// these are implicit mappings and not used\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n-\n-\t// add the synthetic self param at the front, this is a placeholder for\n-\t// compilation to know parameter names. The types are ignored but we\n-\t// reuse the HIR identifier pattern which requires it\n-\tHIR::SelfParam &self_param = function.get_self_param ();\n-\tHIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n-\t  mapping, \"self\", self_param.get_locus (), self_param.is_ref (),\n-\t  self_param.get_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n-\n-\t// might have a specified type\n-\tTyTy::BaseType *self_type = nullptr;\n-\tif (self_param.has_type ())\n-\t  {\n-\t    std::unique_ptr<HIR::Type> &specified_type = self_param.get_type ();\n-\t    self_type = TypeCheckType::Resolve (specified_type.get ());\n-\t  }\n-\telse\n-\t  {\n-\t    switch (self_param.get_self_kind ())\n-\t      {\n-\t      case HIR::SelfParam::IMM:\n-\t      case HIR::SelfParam::MUT:\n-\t\tself_type = self->clone ();\n-\t\tbreak;\n-\n-\t      case HIR::SelfParam::IMM_REF:\n-\t\tself_type = new TyTy::ReferenceType (\n-\t\t  self_param.get_mappings ().get_hirid (),\n-\t\t  TyTy::TyVar (self->get_ref ()), Mutability::Imm);\n-\t\tbreak;\n-\n-\t      case HIR::SelfParam::MUT_REF:\n-\t\tself_type = new TyTy::ReferenceType (\n-\t\t  self_param.get_mappings ().get_hirid (),\n-\t\t  TyTy::TyVar (self->get_ref ()), Mutability::Mut);\n-\t\tbreak;\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions);\n \n-\t      default:\n-\t\tgcc_unreachable ();\n-\t\treturn;\n-\t      }\n-\t  }\n-\n-\tcontext->insert_type (self_param.get_mappings (), self_type);\n-\tparams.push_back (\n-\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n-\t\t\t\t\t\t       self_type));\n-      }\n-\n-    for (auto &param : function.get_function_params ())\n-      {\n-\t// get the name as well required for later on\n-\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n-\tparams.push_back (\n-\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n-\t\t\t\t\t\t       param_tyty));\n-\n-\tcontext->insert_type (param.get_mappings (), param_tyty);\n-\tTypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n-      }\n-\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok\n-      = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n-\t\t\t\t\t &canonical_path);\n-    rust_assert (ok);\n-\n-    RustIdent ident{*canonical_path, function.get_locus ()};\n-    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_function_name (), ident,\n-\t\t\t\t    function.is_method ()\n-\t\t\t\t      ? TyTy::FnType::FNTYPE_IS_METHOD_FLAG\n-\t\t\t\t      : TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n-\t\t\t\t    ABI::RUST, std::move (params), ret_type,\n-\t\t\t\t    std::move (substitutions));\n-\n-    context->insert_type (function.get_mappings (), fnType);\n-  }\n+  void visit (HIR::TypeAlias &alias) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::Function &function) override;\n \n private:\n   TypeCheckTopLevelImplItem (\n     TyTy::BaseType *self,\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-    : TypeCheckBase (), self (self), substitutions (substitutions)\n-  {}\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions);\n \n   TyTy::BaseType *self;\n   std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n \n-class TypeCheckImplItem : public TypeCheckBase\n+class TypeCheckImplItem : public TypeCheckBase, public HIR::HIRImplVisitor\n {\n public:\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n   static void Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item,\n-\t\t       TyTy::BaseType *self)\n-  {\n-    TypeCheckImplItem resolver (parent, self);\n-    item->accept_vis (resolver);\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n-      {\n-\trust_error_at (function.get_locus (), \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (function.get_locus (),\n-\t\t       \"found invalid type for function [%s]\",\n-\t\t       lookup->as_string ().c_str ());\n-\treturn;\n-      }\n+\t\t       TyTy::BaseType *self);\n \n-    // need to get the return type from this\n-    TyTy::FnType *resolve_fn_type = static_cast<TyTy::FnType *> (lookup);\n-    auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n-    context->push_return_type (TypeCheckContextItem (parent, &function),\n-\t\t\t       expected_ret_tyty);\n-\n-    auto block_expr_ty\n-      = TypeCheckExpr::Resolve (function.get_definition ().get ());\n-\n-    context->pop_return_type ();\n-    expected_ret_tyty->unify (block_expr_ty);\n-  }\n+  void visit (HIR::Function &function) override;\n+  void visit (HIR::ConstantItem &const_item) override;\n+  void visit (HIR::TypeAlias &type_alias) override;\n \n protected:\n-  TypeCheckImplItem (HIR::ImplBlock *parent, TyTy::BaseType *self)\n-    : TypeCheckBase (), parent (parent), self (self)\n-  {}\n+  TypeCheckImplItem (HIR::ImplBlock *parent, TyTy::BaseType *self);\n \n   HIR::ImplBlock *parent;\n   TyTy::BaseType *self;\n };\n \n class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static TyTy::TypeBoundPredicateItem\n   Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n \t   TyTy::TypeBoundPredicate &trait_reference,\n-\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-  {\n-    TypeCheckImplItemWithTrait resolver (parent, self, trait_reference,\n-\t\t\t\t\t substitutions);\n-    item->accept_vis (resolver);\n-    return resolver.resolved_trait_item;\n-  }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    // normal resolution of the item\n-    TypeCheckImplItem::visit (constant);\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    // map the impl item to the associated trait item\n-    const auto tref = trait_reference.get ();\n-    const TraitItemReference *raw_trait_item = nullptr;\n-    bool found = tref->lookup_trait_item_by_type (\n-      constant.get_identifier (), TraitItemReference::TraitItemType::CONST,\n-      &raw_trait_item);\n-\n-    // unknown trait item\n-    if (!found || raw_trait_item->is_error ())\n-      {\n-\tRichLocation r (constant.get_locus ());\n-\tr.add_range (trait_reference.get_locus ());\n-\trust_error_at (r, \"constant %<%s%> is not a member of trait %<%s%>\",\n-\t\t       constant.get_identifier ().c_str (),\n-\t\t       trait_reference.get_name ().c_str ());\n-\treturn;\n-      }\n-\n-    // get the item from the predicate\n-    resolved_trait_item\n-      = trait_reference.lookup_associated_item (raw_trait_item);\n-    rust_assert (!resolved_trait_item.is_error ());\n-\n-    // merge the attributes\n-    const HIR::TraitItem *hir_trait_item\n-      = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n-    merge_attributes (constant.get_outer_attrs (), *hir_trait_item);\n-\n-    // check the types are compatible\n-    auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n-    if (!trait_item_type->can_eq (lookup, true))\n-      {\n-\tRichLocation r (constant.get_locus ());\n-\tr.add_range (resolved_trait_item.get_locus ());\n-\n-\trust_error_at (\n-\t  r, \"constant %<%s%> has an incompatible type for trait %<%s%>\",\n-\t  constant.get_identifier ().c_str (),\n-\t  trait_reference.get_name ().c_str ());\n-      }\n-  }\n-\n-  void visit (HIR::TypeAlias &type) override\n-  {\n-    // normal resolution of the item\n-    TypeCheckImplItem::visit (type);\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    // map the impl item to the associated trait item\n-    const auto tref = trait_reference.get ();\n-    const TraitItemReference *raw_trait_item = nullptr;\n-    bool found = tref->lookup_trait_item_by_type (\n-      type.get_new_type_name (), TraitItemReference::TraitItemType::TYPE,\n-      &raw_trait_item);\n-\n-    // unknown trait item\n-    if (!found || raw_trait_item->is_error ())\n-      {\n-\tRichLocation r (type.get_locus ());\n-\tr.add_range (trait_reference.get_locus ());\n-\trust_error_at (r, \"type alias %<%s%> is not a member of trait %<%s%>\",\n-\t\t       type.get_new_type_name ().c_str (),\n-\t\t       trait_reference.get_name ().c_str ());\n-\treturn;\n-      }\n-\n-    // get the item from the predicate\n-    resolved_trait_item\n-      = trait_reference.lookup_associated_item (raw_trait_item);\n-    rust_assert (!resolved_trait_item.is_error ());\n-\n-    // merge the attributes\n-    const HIR::TraitItem *hir_trait_item\n-      = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n-    merge_attributes (type.get_outer_attrs (), *hir_trait_item);\n-\n-    // check the types are compatible\n-    auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n-    if (!trait_item_type->can_eq (lookup, true))\n-      {\n-\tRichLocation r (type.get_locus ());\n-\tr.add_range (resolved_trait_item.get_locus ());\n-\n-\trust_error_at (\n-\t  r, \"type alias %<%s%> has an incompatible type for trait %<%s%>\",\n-\t  type.get_new_type_name ().c_str (),\n-\t  trait_reference.get_name ().c_str ());\n-      }\n-\n-    // its actually a projection, since we need a way to actually bind the\n-    // generic substitutions to the type itself\n-    TyTy::ProjectionType *projection\n-      = new TyTy::ProjectionType (type.get_mappings ().get_hirid (), lookup,\n-\t\t\t\t  tref,\n-\t\t\t\t  raw_trait_item->get_mappings ().get_defid (),\n-\t\t\t\t  substitutions);\n-\n-    context->insert_type (type.get_mappings (), projection);\n-    raw_trait_item->associated_type_set (projection);\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    // we get the error checking from the base method here\n-    TypeCheckImplItem::visit (function);\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    // map the impl item to the associated trait item\n-    const auto tref = trait_reference.get ();\n-    const TraitItemReference *raw_trait_item = nullptr;\n-    bool found\n-      = tref->lookup_trait_item_by_type (function.get_function_name (),\n-\t\t\t\t\t TraitItemReference::TraitItemType::FN,\n-\t\t\t\t\t &raw_trait_item);\n-\n-    // unknown trait item\n-    if (!found || raw_trait_item->is_error ())\n-      {\n-\tRichLocation r (function.get_locus ());\n-\tr.add_range (trait_reference.get_locus ());\n-\trust_error_at (r, \"method %<%s%> is not a member of trait %<%s%>\",\n-\t\t       function.get_function_name ().c_str (),\n-\t\t       trait_reference.get_name ().c_str ());\n-\treturn;\n-      }\n-\n-    // get the item from the predicate\n-    resolved_trait_item\n-      = trait_reference.lookup_associated_item (raw_trait_item);\n-    rust_assert (!resolved_trait_item.is_error ());\n-\n-    // merge the attributes\n-    const HIR::TraitItem *hir_trait_item\n-      = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n-    merge_attributes (function.get_outer_attrs (), *hir_trait_item);\n-\n-    // check the types are compatible\n-    auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n-    if (!trait_item_type->can_eq (lookup, true))\n-      {\n-\tRichLocation r (function.get_locus ());\n-\tr.add_range (resolved_trait_item.get_locus ());\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions);\n \n-\trust_error_at (\n-\t  r, \"method %<%s%> has an incompatible type for trait %<%s%>\",\n-\t  function.get_function_name ().c_str (),\n-\t  trait_reference.get_name ().c_str ());\n-      }\n-  }\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::TypeAlias &type) override;\n+  void visit (HIR::Function &function) override;\n \n protected:\n   // this allows us to inherit the must_use specified on a trait definition onto\n   // its implementation\n   void merge_attributes (AST::AttrVec &impl_item_attrs,\n-\t\t\t const HIR::TraitItem &trait_item)\n-  {\n-    for (const auto &attr : trait_item.get_outer_attrs ())\n-      {\n-\timpl_item_attrs.push_back (attr);\n-      }\n-  }\n+\t\t\t const HIR::TraitItem &trait_item);\n \n private:\n   TypeCheckImplItemWithTrait (\n     HIR::ImplBlock *parent, TyTy::BaseType *self,\n     TyTy::TypeBoundPredicate &trait_reference,\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-    : TypeCheckImplItem (parent, self), trait_reference (trait_reference),\n-      resolved_trait_item (TyTy::TypeBoundPredicateItem::error ()),\n-      substitutions (substitutions)\n-  {\n-    rust_assert (is_trait_impl_block ());\n-  }\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions);\n \n-  bool is_trait_impl_block () const { return !trait_reference.is_error (); }\n+  bool is_trait_impl_block () const;\n \n   TyTy::TypeBoundPredicate &trait_reference;\n   TyTy::TypeBoundPredicateItem resolved_trait_item;"}, {"sha": "d31a6df47779c10c897769b54d3687e3dc52a22e", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -17,15 +17,26 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-hir-type-check-item.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-stmt.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n \n namespace Rust {\n-\n namespace Resolver {\n+\n+TypeCheckItem::TypeCheckItem () : TypeCheckBase () {}\n+\n void\n-TypeCheckItem::Resolve (HIR::Item *item)\n+TypeCheckItem::Resolve (HIR::Item &item)\n {\n+  rust_assert (item.get_hir_kind () == HIR::Node::BaseKind::VIS_ITEM);\n+  HIR::VisItem &vis_item = static_cast<HIR::VisItem &> (item);\n+\n   TypeCheckItem resolver;\n-  item->accept_vis (resolver);\n+  vis_item.accept_vis (resolver);\n }\n \n void\n@@ -213,7 +224,7 @@ void\n TypeCheckItem::visit (HIR::Module &module)\n {\n   for (auto &item : module.get_items ())\n-    TypeCheckItem::Resolve (item.get ());\n+    TypeCheckItem::Resolve (*item.get ());\n }\n \n void"}, {"sha": "ba4de19c9c7389a5fe98523dcb304c9d241e9151", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -20,30 +20,36 @@\n #define RUST_HIR_TYPE_CHECK_ITEM\n \n #include \"rust-hir-type-check-base.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-hir-type-check-implitem.h\"\n-#include \"rust-hir-type-check-type.h\"\n-#include \"rust-hir-type-check-stmt.h\"\n-#include \"rust-hir-trait-resolve.h\"\n-#include \"rust-tyty-visitor.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-class TypeCheckItem : public TypeCheckBase\n+class TypeCheckItem : private TypeCheckBase, private HIR::HIRVisItemVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  static void Resolve (HIR::Item *item);\n+  static void Resolve (HIR::Item &item);\n \n   void visit (HIR::ImplBlock &impl_block) override;\n   void visit (HIR::Function &function) override;\n   void visit (HIR::Module &module) override;\n   void visit (HIR::Trait &trait) override;\n \n+  // FIXME - get rid of toplevel pass\n+  void visit (HIR::TypeAlias &alias) override{};\n+  void visit (HIR::TupleStruct &struct_decl) override{};\n+  void visit (HIR::StructStruct &struct_decl) override{};\n+  void visit (HIR::Enum &enum_decl) override{};\n+  void visit (HIR::Union &union_decl) override{};\n+  void visit (HIR::StaticItem &var) override{};\n+  void visit (HIR::ConstantItem &constant) override{};\n+  void visit (HIR::ExternBlock &extern_block) override{};\n+\n+  // nothing to do\n+  void visit (HIR::ExternCrate &crate) override {}\n+  void visit (HIR::UseDeclaration &use_decl) override {}\n+\n private:\n-  TypeCheckItem () : TypeCheckBase () {}\n+  TypeCheckItem ();\n };\n \n } // namespace Resolver"}, {"sha": "fd0ca3ea16b71b1320b03a708192f3dfeec9ba13", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -17,6 +17,8 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-trait-resolve.h\"\n \n namespace Rust {\n namespace Resolver {"}, {"sha": "a62fbc96a0867896b393d108f67baf3d930ccecd", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.cc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -22,6 +22,24 @@\n namespace Rust {\n namespace Resolver {\n \n+TypeCheckPattern::TypeCheckPattern (TyTy::BaseType *parent)\n+  : TypeCheckBase (), parent (parent), infered (nullptr)\n+{}\n+\n+TyTy::BaseType *\n+TypeCheckPattern::Resolve (HIR::Pattern *pattern, TyTy::BaseType *parent)\n+{\n+  TypeCheckPattern resolver (parent);\n+  pattern->accept_vis (resolver);\n+\n+  if (resolver.infered == nullptr)\n+    return new TyTy::ErrorType (pattern->get_pattern_mappings ().get_hirid ());\n+\n+  resolver.context->insert_type (pattern->get_pattern_mappings (),\n+\t\t\t\t resolver.infered);\n+  return resolver.infered;\n+}\n+\n void\n TypeCheckPattern::visit (HIR::PathInExpression &pattern)\n {\n@@ -357,5 +375,33 @@ TypeCheckPattern::visit (HIR::IdentifierPattern &pattern)\n   infered = parent;\n }\n \n+void\n+TypeCheckPattern::visit (HIR::GroupedPattern &pattern)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::QualifiedPathInExpression &pattern)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::ReferencePattern &pattern)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::SlicePattern &pattern)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "8af106033b7d1bae9b0147d013b7214058c32b13", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.h", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -25,45 +25,27 @@\n namespace Rust {\n namespace Resolver {\n \n-class TypeCheckPattern : public TypeCheckBase\n+class TypeCheckPattern : public TypeCheckBase, public HIR::HIRPatternVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  static TyTy::BaseType *Resolve (HIR::Pattern *pattern, TyTy::BaseType *parent)\n-  {\n-    TypeCheckPattern resolver (parent);\n-    pattern->accept_vis (resolver);\n-\n-    if (resolver.infered == nullptr)\n-      return new TyTy::ErrorType (\n-\tpattern->get_pattern_mappings ().get_hirid ());\n-\n-    resolver.context->insert_type (pattern->get_pattern_mappings (),\n-\t\t\t\t   resolver.infered);\n-    return resolver.infered;\n-  }\n+  static TyTy::BaseType *Resolve (HIR::Pattern *pattern,\n+\t\t\t\t  TyTy::BaseType *parent);\n \n   void visit (HIR::PathInExpression &pattern) override;\n-\n   void visit (HIR::StructPattern &pattern) override;\n-\n   void visit (HIR::TupleStructPattern &pattern) override;\n-\n   void visit (HIR::WildcardPattern &pattern) override;\n-\n   void visit (HIR::TuplePattern &pattern) override;\n-\n   void visit (HIR::LiteralPattern &pattern) override;\n-\n   void visit (HIR::RangePattern &pattern) override;\n-\n   void visit (HIR::IdentifierPattern &pattern) override;\n+  void visit (HIR::GroupedPattern &pattern) override;\n+  void visit (HIR::QualifiedPathInExpression &pattern) override;\n+  void visit (HIR::ReferencePattern &pattern) override;\n+  void visit (HIR::SlicePattern &pattern) override;\n \n private:\n-  TypeCheckPattern (TyTy::BaseType *parent)\n-    : TypeCheckBase (), parent (parent), infered (nullptr)\n-  {}\n+  TypeCheckPattern (TyTy::BaseType *parent);\n \n   static TyTy::BaseType *\n   typecheck_range_pattern_bound (HIR::RangePatternBound *bound,"}, {"sha": "9f34ed49165d0933ffadb79dce75140c373522cb", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.cc", "status": "added", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -0,0 +1,498 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-stmt.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TyTy::BaseType *\n+TypeCheckStmt::Resolve (HIR::Stmt *stmt)\n+{\n+  TypeCheckStmt resolver;\n+  stmt->accept_vis (resolver);\n+  return resolver.infered;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::ExprStmtWithBlock &stmt)\n+{\n+  infered = TypeCheckExpr::Resolve (stmt.get_expr ());\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::ExprStmtWithoutBlock &stmt)\n+{\n+  infered = TypeCheckExpr::Resolve (stmt.get_expr ());\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::EmptyStmt &stmt)\n+{\n+  infered = TyTy::TupleType::get_unit_type (stmt.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      TypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n+    }\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::ConstantItem &constant)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+  infered = type->unify (expr_type);\n+  context->insert_type (constant.get_mappings (), infered);\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::LetStmt &stmt)\n+{\n+  infered = TyTy::TupleType::get_unit_type (stmt.get_mappings ().get_hirid ());\n+\n+  const HIR::Pattern &stmt_pattern = *stmt.get_pattern ();\n+  TyTy::BaseType *init_expr_ty = nullptr;\n+  if (stmt.has_init_expr ())\n+    {\n+      init_expr_ty = TypeCheckExpr::Resolve (stmt.get_init_expr ());\n+      if (init_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+\n+      init_expr_ty->append_reference (\n+\tstmt_pattern.get_pattern_mappings ().get_hirid ());\n+    }\n+\n+  TyTy::BaseType *specified_ty = nullptr;\n+  if (stmt.has_type ())\n+    specified_ty = TypeCheckType::Resolve (stmt.get_type ());\n+\n+  // let x:i32 = 123;\n+  if (specified_ty != nullptr && init_expr_ty != nullptr)\n+    {\n+      // FIXME use this result and look at the regressions\n+      coercion_site (stmt.get_mappings ().get_hirid (), specified_ty,\n+\t\t     init_expr_ty, stmt.get_locus ());\n+      context->insert_type (stmt_pattern.get_pattern_mappings (), specified_ty);\n+    }\n+  else\n+    {\n+      // let x:i32;\n+      if (specified_ty != nullptr)\n+\t{\n+\t  context->insert_type (stmt_pattern.get_pattern_mappings (),\n+\t\t\t\tspecified_ty);\n+\t}\n+      // let x = 123;\n+      else if (init_expr_ty != nullptr)\n+\t{\n+\t  context->insert_type (stmt_pattern.get_pattern_mappings (),\n+\t\t\t\tinit_expr_ty);\n+\t}\n+      // let x;\n+      else\n+\t{\n+\t  context->insert_type (\n+\t    stmt_pattern.get_pattern_mappings (),\n+\t    new TyTy::InferType (\n+\t      stmt_pattern.get_pattern_mappings ().get_hirid (),\n+\t      TyTy::InferType::InferTypeKind::GENERAL, stmt.get_locus ()));\n+\t}\n+    }\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::TupleStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    {\n+      for (auto &generic_param : struct_decl.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  size_t idx = 0;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+      idx++;\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n+\n+  // Process #[repr(...)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::Enum &enum_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (enum_decl.has_generics ())\n+    {\n+      for (auto &generic_param : enum_decl.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<TyTy::VariantDef *> variants;\n+  int64_t discriminant_value = 0;\n+  for (auto &variant : enum_decl.get_variants ())\n+    {\n+      TyTy::VariantDef *field_type\n+\t= TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+      discriminant_value++;\n+      variants.push_back (field_type);\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (enum_decl.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t enum_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (enum_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::StructStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    {\n+      for (auto &generic_param : struct_decl.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  // Process #[repr(...)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::Union &union_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (union_decl.has_generics ())\n+    {\n+      for (auto &generic_param : union_decl.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &variant : union_decl.get_variants ())\n+    {\n+      TyTy::BaseType *variant_type\n+\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_variant\n+\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t     variant.get_field_name (), variant_type);\n+      fields.push_back (ty_variant);\n+      context->insert_type (variant.get_mappings (),\n+\t\t\t    ty_variant->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (union_decl.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, union_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t union_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::UNION, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (union_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::Function &function)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_function_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, function.get_locus ()};\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_function_name (), ident,\n+\t\t\t\t  TyTy::FnType::FNTYPE_DEFAULT_FLAGS, ABI::RUST,\n+\t\t\t\t  std::move (params), ret_type,\n+\t\t\t\t  std::move (substitutions));\n+  context->insert_type (function.get_mappings (), fnType);\n+\n+  TyTy::FnType *resolved_fn_type = fnType;\n+  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+  context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t     expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n+\n+  context->pop_return_type ();\n+\n+  if (block_expr_ty->get_kind () != TyTy::NEVER)\n+    expected_ret_tyty->unify (block_expr_ty);\n+\n+  infered = fnType;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "a79f17a59cec2f6399068ae1c477426b94edd40e", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 45, "deletions": 466, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -20,489 +20,68 @@\n #define RUST_HIR_TYPE_CHECK_STMT\n \n #include \"rust-hir-type-check-base.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-hir-type-check-type.h\"\n-#include \"rust-hir-type-check-expr.h\"\n-#include \"rust-hir-type-check-enumitem.h\"\n-#include \"rust-hir-type-check-implitem.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-class TypeCheckStmt : public TypeCheckBase\n+class TypeCheckStmt : private TypeCheckBase, private HIR::HIRStmtVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  static TyTy::BaseType *Resolve (HIR::Stmt *stmt)\n-  {\n-    TypeCheckStmt resolver;\n-    stmt->accept_vis (resolver);\n-    return resolver.infered;\n+  static TyTy::BaseType *Resolve (HIR::Stmt *stmt);\n+\n+  void visit (HIR::ExprStmtWithBlock &stmt) override;\n+  void visit (HIR::ExprStmtWithoutBlock &stmt) override;\n+  void visit (HIR::EmptyStmt &stmt) override;\n+  void visit (HIR::ExternBlock &extern_block) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::LetStmt &stmt) override;\n+  void visit (HIR::TupleStruct &struct_decl) override;\n+  void visit (HIR::Enum &enum_decl) override;\n+  void visit (HIR::StructStruct &struct_decl) override;\n+  void visit (HIR::Union &union_decl) override;\n+  void visit (HIR::Function &function) override;\n+\n+  void visit (HIR::EnumItemTuple &) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::ExprStmtWithBlock &stmt) override\n-  {\n-    infered = TypeCheckExpr::Resolve (stmt.get_expr ());\n+  void visit (HIR::EnumItemStruct &) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::ExprStmtWithoutBlock &stmt) override\n-  {\n-    infered = TypeCheckExpr::Resolve (stmt.get_expr ());\n+  void visit (HIR::EnumItem &item) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::EmptyStmt &stmt) override\n-  {\n-    infered\n-      = TyTy::TupleType::get_unit_type (stmt.get_mappings ().get_hirid ());\n+  void visit (HIR::EnumItemDiscriminant &) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::ExternBlock &extern_block) override\n-  {\n-    for (auto &item : extern_block.get_extern_items ())\n-      {\n-\tTypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n-      }\n+  void visit (HIR::TypePathSegmentFunction &segment) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n-    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n-\n-    infered = type->unify (expr_type);\n-    context->insert_type (constant.get_mappings (), infered);\n+  void visit (HIR::TypePath &path) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::LetStmt &stmt) override\n-  {\n-    infered\n-      = TyTy::TupleType::get_unit_type (stmt.get_mappings ().get_hirid ());\n-\n-    const HIR::Pattern &stmt_pattern = *stmt.get_pattern ();\n-    TyTy::BaseType *init_expr_ty = nullptr;\n-    if (stmt.has_init_expr ())\n-      {\n-\tinit_expr_ty = TypeCheckExpr::Resolve (stmt.get_init_expr ());\n-\tif (init_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-\n-\tinit_expr_ty->append_reference (\n-\t  stmt_pattern.get_pattern_mappings ().get_hirid ());\n-      }\n-\n-    TyTy::BaseType *specified_ty = nullptr;\n-    if (stmt.has_type ())\n-      specified_ty = TypeCheckType::Resolve (stmt.get_type ());\n-\n-    // let x:i32 = 123;\n-    if (specified_ty != nullptr && init_expr_ty != nullptr)\n-      {\n-\t// FIXME use this result and look at the regressions\n-\tcoercion_site (stmt.get_mappings ().get_hirid (), specified_ty,\n-\t\t       init_expr_ty, stmt.get_locus ());\n-\tcontext->insert_type (stmt_pattern.get_pattern_mappings (),\n-\t\t\t      specified_ty);\n-      }\n-    else\n-      {\n-\t// let x:i32;\n-\tif (specified_ty != nullptr)\n-\t  {\n-\t    context->insert_type (stmt_pattern.get_pattern_mappings (),\n-\t\t\t\t  specified_ty);\n-\t  }\n-\t// let x = 123;\n-\telse if (init_expr_ty != nullptr)\n-\t  {\n-\t    context->insert_type (stmt_pattern.get_pattern_mappings (),\n-\t\t\t\t  init_expr_ty);\n-\t  }\n-\t// let x;\n-\telse\n-\t  {\n-\t    context->insert_type (\n-\t      stmt_pattern.get_pattern_mappings (),\n-\t      new TyTy::InferType (\n-\t\tstmt_pattern.get_pattern_mappings ().get_hirid (),\n-\t\tTyTy::InferType::InferTypeKind::GENERAL, stmt.get_locus ()));\n-\t  }\n-      }\n+  void visit (HIR::QualifiedPathInType &path) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::TupleStruct &struct_decl) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (struct_decl.has_generics ())\n-      {\n-\tfor (auto &generic_param : struct_decl.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    std::vector<TyTy::StructFieldType *> fields;\n-    size_t idx = 0;\n-    for (auto &field : struct_decl.get_fields ())\n-      {\n-\tTyTy::BaseType *field_type\n-\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n-\tTyTy::StructFieldType *ty_field\n-\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t       std::to_string (idx), field_type);\n-\tfields.push_back (ty_field);\n-\tcontext->insert_type (field.get_mappings (),\n-\t\t\t      ty_field->get_field_type ());\n-\tidx++;\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n-\n-    // there is only a single variant\n-    std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (\n-      new TyTy::VariantDef (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t    struct_decl.get_identifier (), ident,\n-\t\t\t    TyTy::VariantDef::VariantType::TUPLE, nullptr,\n-\t\t\t    std::move (fields)));\n-\n-    // Process #[repr(...)] attribute, if any\n-    const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n-    TyTy::ADTType::ReprOptions repr\n-      = parse_repr_options (attrs, struct_decl.get_locus ());\n-\n-    TyTy::BaseType *type\n-      = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (), ident,\n-\t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n-\t\t\t   std::move (variants), std::move (substitutions),\n-\t\t\t   repr);\n-\n-    context->insert_type (struct_decl.get_mappings (), type);\n-    infered = type;\n+  void visit (HIR::Module &module) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::Enum &enum_decl) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (enum_decl.has_generics ())\n-      {\n-\tfor (auto &generic_param : enum_decl.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    std::vector<TyTy::VariantDef *> variants;\n-    int64_t discriminant_value = 0;\n-    for (auto &variant : enum_decl.get_variants ())\n-      {\n-\tTyTy::VariantDef *field_type\n-\t  = TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n-\n-\tdiscriminant_value++;\n-\tvariants.push_back (field_type);\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      enum_decl.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n-\n-    TyTy::BaseType *type\n-      = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n-\t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   enum_decl.get_identifier (), ident,\n-\t\t\t   TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n-\t\t\t   std::move (substitutions));\n-\n-    context->insert_type (enum_decl.get_mappings (), type);\n-    infered = type;\n+  void visit (HIR::ExternCrate &crate) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::StructStruct &struct_decl) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (struct_decl.has_generics ())\n-      {\n-\tfor (auto &generic_param : struct_decl.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    std::vector<TyTy::StructFieldType *> fields;\n-    for (auto &field : struct_decl.get_fields ())\n-      {\n-\tTyTy::BaseType *field_type\n-\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n-\tTyTy::StructFieldType *ty_field\n-\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t       field.get_field_name (), field_type);\n-\tfields.push_back (ty_field);\n-\tcontext->insert_type (field.get_mappings (),\n-\t\t\t      ty_field->get_field_type ());\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n-\n-    // there is only a single variant\n-    std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (\n-      new TyTy::VariantDef (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t    struct_decl.get_identifier (), ident,\n-\t\t\t    TyTy::VariantDef::VariantType::STRUCT, nullptr,\n-\t\t\t    std::move (fields)));\n-\n-    // Process #[repr(...)] attribute, if any\n-    const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n-    TyTy::ADTType::ReprOptions repr\n-      = parse_repr_options (attrs, struct_decl.get_locus ());\n-\n-    TyTy::BaseType *type\n-      = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (), ident,\n-\t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n-\t\t\t   std::move (variants), std::move (substitutions),\n-\t\t\t   repr);\n-\n-    context->insert_type (struct_decl.get_mappings (), type);\n-    infered = type;\n+  void visit (HIR::UseDeclaration &use_decl) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::Union &union_decl) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (union_decl.has_generics ())\n-      {\n-\tfor (auto &generic_param : union_decl.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    std::vector<TyTy::StructFieldType *> fields;\n-    for (auto &variant : union_decl.get_variants ())\n-      {\n-\tTyTy::BaseType *variant_type\n-\t  = TypeCheckType::Resolve (variant.get_field_type ().get ());\n-\tTyTy::StructFieldType *ty_variant\n-\t  = new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n-\t\t\t\t       variant.get_field_name (), variant_type);\n-\tfields.push_back (ty_variant);\n-\tcontext->insert_type (variant.get_mappings (),\n-\t\t\t      ty_variant->get_field_type ());\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      union_decl.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    RustIdent ident{*canonical_path, union_decl.get_locus ()};\n-\n-    // there is only a single variant\n-    std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (\n-      new TyTy::VariantDef (union_decl.get_mappings ().get_hirid (),\n-\t\t\t    union_decl.get_identifier (), ident,\n-\t\t\t    TyTy::VariantDef::VariantType::STRUCT, nullptr,\n-\t\t\t    std::move (fields)));\n-\n-    TyTy::BaseType *type\n-      = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n-\t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   union_decl.get_identifier (), ident,\n-\t\t\t   TyTy::ADTType::ADTKind::UNION, std::move (variants),\n-\t\t\t   std::move (substitutions));\n-\n-    context->insert_type (union_decl.get_mappings (), type);\n-    infered = type;\n+  void visit (HIR::TypeAlias &type_alias) override\n+  { /* TODO? */\n   }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic_param : function.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    TyTy::BaseType *ret_type = nullptr;\n-    if (!function.has_function_return_type ())\n-      ret_type = TyTy::TupleType::get_unit_type (\n-\tfunction.get_mappings ().get_hirid ());\n-    else\n-      {\n-\tauto resolved\n-\t  = TypeCheckType::Resolve (function.get_return_type ().get ());\n-\tif (resolved == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_locus (),\n-\t\t\t   \"failed to resolve return type\");\n-\t    return;\n-\t  }\n-\n-\tret_type = resolved->clone ();\n-\tret_type->set_ref (\n-\t  function.get_return_type ()->get_mappings ().get_hirid ());\n-      }\n-\n-    std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-    for (auto &param : function.get_function_params ())\n-      {\n-\t// get the name as well required for later on\n-\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n-\tparams.push_back (\n-\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n-\t\t\t\t\t\t       param_tyty));\n-\n-\tcontext->insert_type (param.get_mappings (), param_tyty);\n-\tTypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok\n-      = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n-\t\t\t\t\t &canonical_path);\n-    rust_assert (ok);\n-\n-    RustIdent ident{*canonical_path, function.get_locus ()};\n-    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_function_name (), ident,\n-\t\t\t\t    TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n-\t\t\t\t    ABI::RUST, std::move (params), ret_type,\n-\t\t\t\t    std::move (substitutions));\n-    context->insert_type (function.get_mappings (), fnType);\n-\n-    TyTy::FnType *resolved_fn_type = fnType;\n-    auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-    context->push_return_type (TypeCheckContextItem (&function),\n-\t\t\t       expected_ret_tyty);\n-\n-    auto block_expr_ty\n-      = TypeCheckExpr::Resolve (function.get_definition ().get ());\n-\n-    context->pop_return_type ();\n-\n-    if (block_expr_ty->get_kind () != TyTy::NEVER)\n-      expected_ret_tyty->unify (block_expr_ty);\n-\n-    infered = fnType;\n+  void visit (HIR::StaticItem &static_item) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::Trait &trait) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::ImplBlock &impl) override\n+  { /* TODO? */\n   }\n \n private:"}, {"sha": "22af1aad4c31314b67b04bf442b987720472bde1", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -29,31 +29,18 @@ namespace Resolver {\n \n class TypeCheckStructExpr : public TypeCheckBase\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  static TyTy::BaseType *Resolve (HIR::StructExprStructFields *expr)\n-  {\n-    TypeCheckStructExpr resolver (expr);\n-    expr->accept_vis (resolver);\n-    return resolver.resolved;\n-  }\n-\n-  void visit (HIR::StructExprStructFields &struct_expr) override;\n-\n-  void visit (HIR::StructExprFieldIdentifierValue &field) override;\n+  static TyTy::BaseType *Resolve (HIR::StructExprStructFields *expr);\n \n-  void visit (HIR::StructExprFieldIndexValue &field) override;\n+protected:\n+  void resolve (HIR::StructExprStructFields &struct_expr);\n \n-  void visit (HIR::StructExprFieldIdentifier &field) override;\n+  void visit (HIR::StructExprFieldIdentifierValue &field);\n+  void visit (HIR::StructExprFieldIndexValue &field);\n+  void visit (HIR::StructExprFieldIdentifier &field);\n \n private:\n-  TypeCheckStructExpr (HIR::Expr *e)\n-    : TypeCheckBase (),\n-      resolved (new TyTy::ErrorType (e->get_mappings ().get_hirid ())),\n-      struct_path_resolved (nullptr),\n-      variant (&TyTy::VariantDef::get_error_node ())\n-  {}\n+  TypeCheckStructExpr (HIR::Expr *e);\n \n   // result\n   TyTy::BaseType *resolved;"}, {"sha": "ec82442beb2e1ef352f1c77e169a0b5f53660689", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct.cc", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -24,8 +24,23 @@\n namespace Rust {\n namespace Resolver {\n \n+TypeCheckStructExpr::TypeCheckStructExpr (HIR::Expr *e)\n+  : TypeCheckBase (),\n+    resolved (new TyTy::ErrorType (e->get_mappings ().get_hirid ())),\n+    struct_path_resolved (nullptr),\n+    variant (&TyTy::VariantDef::get_error_node ())\n+{}\n+\n+TyTy::BaseType *\n+TypeCheckStructExpr::Resolve (HIR::StructExprStructFields *expr)\n+{\n+  TypeCheckStructExpr resolver (expr);\n+  resolver.resolve (*expr);\n+  return resolver.resolved;\n+}\n+\n void\n-TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n+TypeCheckStructExpr::resolve (HIR::StructExprStructFields &struct_expr)\n {\n   TyTy::BaseType *struct_path_ty\n     = TypeCheckExpr::Resolve (&struct_expr.get_struct_name ());\n@@ -77,7 +92,23 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n   for (auto &field : struct_expr.get_fields ())\n     {\n       resolved_field_value_expr = nullptr;\n-      field->accept_vis (*this);\n+\n+      switch (field->get_kind ())\n+\t{\n+\tcase HIR::StructExprField::StructExprFieldKind::IDENTIFIER:\n+\t  visit (static_cast<HIR::StructExprFieldIdentifier &> (*field.get ()));\n+\t  break;\n+\n+\tcase HIR::StructExprField::StructExprFieldKind::IDENTIFIER_VALUE:\n+\t  visit (\n+\t    static_cast<HIR::StructExprFieldIdentifierValue &> (*field.get ()));\n+\t  break;\n+\n+\tcase HIR::StructExprField::StructExprFieldKind::INDEX_VALUE:\n+\t  visit (static_cast<HIR::StructExprFieldIndexValue &> (*field.get ()));\n+\t  break;\n+\t}\n+\n       if (resolved_field_value_expr == nullptr)\n \t{\n \t  rust_fatal_error (field->get_locus (),\n@@ -294,7 +325,7 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n   if (resolved_field_value_expr != nullptr)\n \n     {\n-      fields_assigned.insert (field.field_name);\n+      fields_assigned.insert (field.get_field_name ());\n       adtFieldIndexToField[field_index] = &field;\n     }\n }"}, {"sha": "27f36b642fc72227444b6bef01430224096a5abd", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.cc", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -17,59 +17,25 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-hir-type-check-toplevel.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-void\n-TypeCheckTopLevel::Resolve (HIR::Item *item)\n-{\n-  TypeCheckTopLevel resolver;\n-  item->accept_vis (resolver);\n-}\n+TypeCheckTopLevel::TypeCheckTopLevel () : TypeCheckBase () {}\n \n void\n-TypeCheckTopLevel::resolve_generic_params (\n-  const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n-  std::vector<TyTy::SubstitutionParamMapping> &substitutions)\n+TypeCheckTopLevel::Resolve (HIR::Item &item)\n {\n-  for (auto &generic_param : generic_params)\n-    {\n-      switch (generic_param.get ()->get_kind ())\n-\t{\n-\tcase HIR::GenericParam::GenericKind::LIFETIME:\n-\t  // FIXME: Skipping Lifetime completely until better\n-\t  // handling.\n-\t  break;\n-\t  case HIR::GenericParam::GenericKind::CONST: {\n-\t    auto param\n-\t      = static_cast<HIR::ConstGenericParam *> (generic_param.get ());\n-\t    auto specified_type\n-\t      = TypeCheckType::Resolve (param->get_type ().get ());\n-\n-\t    if (param->has_default_expression ())\n-\t      {\n-\t\tauto expr_type = TypeCheckExpr::Resolve (\n-\t\t  param->get_default_expression ().get ());\n-\t\tspecified_type->coerce (expr_type);\n-\t      }\n-\n-\t    context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t  specified_type);\n-\t  }\n-\t  break;\n-\n-\t  case HIR::GenericParam::GenericKind::TYPE: {\n-\t    auto param_type\n-\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t    context->insert_type (generic_param->get_mappings (), param_type);\n-\n-\t    substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t      static_cast<HIR::TypeParam &> (*generic_param), param_type));\n-\t  }\n-\t  break;\n-\t}\n-    }\n+  rust_assert (item.get_hir_kind () == HIR::Node::BaseKind::VIS_ITEM);\n+  HIR::VisItem &vis_item = static_cast<HIR::VisItem &> (item);\n+\n+  TypeCheckTopLevel resolver;\n+  vis_item.accept_vis (resolver);\n }\n \n void\n@@ -144,7 +110,7 @@ void\n TypeCheckTopLevel::visit (HIR::Module &module)\n {\n   for (auto &item : module.get_items ())\n-    TypeCheckTopLevel::Resolve (item.get ());\n+    TypeCheckTopLevel::Resolve (*item.get ());\n }\n \n void"}, {"sha": "d0db07d7281749aada1c3697f29e48d6647a24a7", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -20,41 +20,34 @@\n #define RUST_HIR_TYPE_CHECK_TOPLEVEL\n \n #include \"rust-hir-type-check-base.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-hir-type-check-implitem.h\"\n-#include \"rust-hir-type-check-type.h\"\n-#include \"rust-hir-type-check-expr.h\"\n-#include \"rust-hir-type-check-enumitem.h\"\n-#include \"rust-tyty.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-class TypeCheckTopLevel : public TypeCheckBase\n+class TypeCheckTopLevel : private TypeCheckBase, public HIR::HIRVisItemVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  static void Resolve (HIR::Item *item);\n+  static void Resolve (HIR::Item &item);\n \n+  void visit (HIR::Module &module) override;\n+  void visit (HIR::Function &function) override;\n   void visit (HIR::TypeAlias &alias) override;\n   void visit (HIR::TupleStruct &struct_decl) override;\n-  void visit (HIR::Module &module) override;\n   void visit (HIR::StructStruct &struct_decl) override;\n   void visit (HIR::Enum &enum_decl) override;\n   void visit (HIR::Union &union_decl) override;\n   void visit (HIR::StaticItem &var) override;\n   void visit (HIR::ConstantItem &constant) override;\n-  void visit (HIR::Function &function) override;\n   void visit (HIR::ImplBlock &impl_block) override;\n   void visit (HIR::ExternBlock &extern_block) override;\n \n-private:\n-  TypeCheckTopLevel () : TypeCheckBase () {}\n+  // nothing to do\n+  void visit (HIR::Trait &trait_block) override {}\n+  void visit (HIR::ExternCrate &crate) override {}\n+  void visit (HIR::UseDeclaration &use_decl) override {}\n \n-  void resolve_generic_params (\n-    const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n-    std::vector<TyTy::SubstitutionParamMapping> &substitutions);\n+private:\n+  TypeCheckTopLevel ();\n };\n \n } // namespace Resolver"}, {"sha": "3538d77b220225ca274cfe3eba0f37599fcd7e51", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -27,7 +27,15 @@ HIR::GenericArgs\n TypeCheckResolveGenericArguments::resolve (HIR::TypePathSegment *segment)\n {\n   TypeCheckResolveGenericArguments resolver (segment->get_locus ());\n-  segment->accept_vis (resolver);\n+  switch (segment->get_type ())\n+    {\n+    case HIR::TypePathSegment::SegmentType::GENERIC:\n+      resolver.visit (static_cast<HIR::TypePathSegmentGeneric &> (*segment));\n+      break;\n+\n+    default:\n+      break;\n+    }\n   return resolver.args;\n }\n \n@@ -674,17 +682,35 @@ TyTy::ParamType *\n TypeResolveGenericParam::Resolve (HIR::GenericParam *param)\n {\n   TypeResolveGenericParam resolver;\n-  param->accept_vis (resolver);\n-\n-  if (resolver.resolved == nullptr)\n+  switch (param->get_kind ())\n     {\n-      rust_error_at (param->get_locus (), \"failed to setup generic parameter\");\n-      return nullptr;\n-    }\n+    case HIR::GenericParam::GenericKind::TYPE:\n+      resolver.visit (static_cast<HIR::TypeParam &> (*param));\n+      break;\n \n+    case HIR::GenericParam::GenericKind::CONST:\n+      resolver.visit (static_cast<HIR::ConstGenericParam &> (*param));\n+      break;\n+\n+    case HIR::GenericParam::GenericKind::LIFETIME:\n+      resolver.visit (static_cast<HIR::LifetimeParam &> (*param));\n+      break;\n+    }\n   return resolver.resolved;\n }\n \n+void\n+TypeResolveGenericParam::visit (HIR::LifetimeParam &param)\n+{\n+  // nothing to do\n+}\n+\n+void\n+TypeResolveGenericParam::visit (HIR::ConstGenericParam &param)\n+{\n+  // TODO\n+}\n+\n void\n TypeResolveGenericParam::visit (HIR::TypeParam &param)\n {\n@@ -725,11 +751,20 @@ void\n ResolveWhereClauseItem::Resolve (HIR::WhereClauseItem &item)\n {\n   ResolveWhereClauseItem resolver;\n-  item.accept_vis (resolver);\n+  switch (item.get_item_type ())\n+    {\n+    case HIR::WhereClauseItem::LIFETIME:\n+      resolver.visit (static_cast<HIR::LifetimeWhereClauseItem &> (item));\n+      break;\n+\n+    case HIR::WhereClauseItem::TYPE_BOUND:\n+      resolver.visit (static_cast<HIR::TypeBoundWhereClauseItem &> (item));\n+      break;\n+    }\n }\n \n void\n-ResolveWhereClauseItem::visit (HIR::LifetimeWhereClauseItem &)\n+ResolveWhereClauseItem::visit (HIR::LifetimeWhereClauseItem &item)\n {}\n \n void"}, {"sha": "90d5ddbb411c892b2ce44e7961812e193eab830c", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -27,14 +27,15 @@\n namespace Rust {\n namespace Resolver {\n \n+// FIXME\n+// This simply fetches the HIR:::GenericArgs from the base class. Check to see\n+// if we can get rid of this class\n class TypeCheckResolveGenericArguments : public TypeCheckBase\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static HIR::GenericArgs resolve (HIR::TypePathSegment *segment);\n \n-  void visit (HIR::TypePathSegmentGeneric &generic) override;\n+  void visit (HIR::TypePathSegmentGeneric &generic);\n \n private:\n   TypeCheckResolveGenericArguments (Location locus)\n@@ -44,10 +45,8 @@ class TypeCheckResolveGenericArguments : public TypeCheckBase\n   HIR::GenericArgs args;\n };\n \n-class TypeCheckType : public TypeCheckBase\n+class TypeCheckType : public TypeCheckBase, public HIR::HIRTypeVisitor\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static TyTy::BaseType *Resolve (HIR::Type *type);\n \n@@ -63,6 +62,22 @@ class TypeCheckType : public TypeCheckBase\n   void visit (HIR::NeverType &type) override;\n   void visit (HIR::TraitObjectType &type) override;\n \n+  void visit (HIR::TypePathSegmentFunction &segment) override\n+  { /* TODO */\n+  }\n+  void visit (HIR::TraitBound &bound) override\n+  { /* TODO */\n+  }\n+  void visit (HIR::ImplTraitType &type) override\n+  { /* TODO */\n+  }\n+  void visit (HIR::ParenthesisedType &type) override\n+  { /* TODO */\n+  }\n+  void visit (HIR::ImplTraitTypeOneBound &type) override\n+  { /* TODO */\n+  }\n+\n private:\n   TypeCheckType (HirId id)\n     : TypeCheckBase (), translated (new TyTy::ErrorType (id))\n@@ -82,12 +97,13 @@ class TypeCheckType : public TypeCheckBase\n \n class TypeResolveGenericParam : public TypeCheckBase\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static TyTy::ParamType *Resolve (HIR::GenericParam *param);\n \n-  void visit (HIR::TypeParam &param) override;\n+protected:\n+  void visit (HIR::TypeParam &param);\n+  void visit (HIR::LifetimeParam &param);\n+  void visit (HIR::ConstGenericParam &param);\n \n private:\n   TypeResolveGenericParam () : TypeCheckBase (), resolved (nullptr) {}\n@@ -97,13 +113,12 @@ class TypeResolveGenericParam : public TypeCheckBase\n \n class ResolveWhereClauseItem : public TypeCheckBase\n {\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n   static void Resolve (HIR::WhereClauseItem &item);\n \n-  void visit (HIR::LifetimeWhereClauseItem &) override;\n-  void visit (HIR::TypeBoundWhereClauseItem &item) override;\n+protected:\n+  void visit (HIR::LifetimeWhereClauseItem &item);\n+  void visit (HIR::TypeBoundWhereClauseItem &item);\n \n private:\n   ResolveWhereClauseItem () : TypeCheckBase () {}"}, {"sha": "c314585cd3d40c3f917a2409a36543bf9bd81c49", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 3, "deletions": 43, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -21,6 +21,7 @@\n #include \"rust-hir-type-check-toplevel.h\"\n #include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n #include \"rust-hir-inherent-impl-overlap.h\"\n \n@@ -34,7 +35,7 @@ void\n TypeResolution::Resolve (HIR::Crate &crate)\n {\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    TypeCheckTopLevel::Resolve (it->get ());\n+    TypeCheckTopLevel::Resolve (*it->get ());\n \n   if (saw_errors ())\n     return;\n@@ -44,7 +45,7 @@ TypeResolution::Resolve (HIR::Crate &crate)\n     return;\n \n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    TypeCheckItem::Resolve (it->get ());\n+    TypeCheckItem::Resolve (*it->get ());\n \n   if (saw_errors ())\n     return;\n@@ -81,47 +82,6 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   });\n }\n \n-// RUST_HIR_TYPE_CHECK_EXPR\n-void\n-TypeCheckExpr::visit (HIR::BlockExpr &expr)\n-{\n-  for (auto &s : expr.get_statements ())\n-    {\n-      if (!s->is_item ())\n-\tcontinue;\n-\n-      TypeCheckStmt::Resolve (s.get ());\n-    }\n-\n-  for (auto &s : expr.get_statements ())\n-    {\n-      if (s->is_item ())\n-\tcontinue;\n-\n-      auto resolved = TypeCheckStmt::Resolve (s.get ());\n-      if (resolved == nullptr)\n-\t{\n-\t  rust_error_at (s->get_locus (), \"failure to resolve type\");\n-\t  return;\n-\t}\n-\n-      if (s->is_unit_check_needed () && !resolved->is_unit ())\n-\t{\n-\t  auto unit\n-\t    = TyTy::TupleType::get_unit_type (s->get_mappings ().get_hirid ());\n-\t  resolved = unit->unify (resolved);\n-\t}\n-    }\n-\n-  if (expr.has_expr ())\n-    infered = TypeCheckExpr::Resolve (expr.get_final_expr ().get ())->clone ();\n-  else if (expr.is_tail_reachable ())\n-    infered\n-      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n-  else\n-    infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n-}\n-\n // rust-hir-trait-ref.h\n \n TraitItemReference::TraitItemReference ("}, {"sha": "f66d7eb4b8c6afcaa6517341ae8b762e9b65246f", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57bbcb24146139c48911deced919939f69b0646/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=e57bbcb24146139c48911deced919939f69b0646", "patch": "@@ -25,9 +25,9 @@\n namespace Rust {\n namespace Resolver {\n \n-class TypeResolverDump : public TypeCheckBase\n+class TypeResolverDump : private TypeCheckBase, private HIR::HIRFullVisitorBase\n {\n-  using Rust::HIR::HIRFullVisitorBase::visit;\n+  using HIR::HIRFullVisitorBase::visit;\n \n public:\n   static void go (HIR::Crate &crate, std::ofstream &out)"}]}