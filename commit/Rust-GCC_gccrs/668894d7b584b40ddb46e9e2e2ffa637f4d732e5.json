{"sha": "668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY4ODk0ZDdiNTg0YjQwZGRiNDZlOWUyZTJmZmE2MzdmNGQ3MzJlNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-10-24T21:47:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-10-27T20:58:02Z"}, "message": "libgo: update to Go 1.15.3 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/265717", "tree": {"sha": "6c97d325215c8462f375f142d1e91099cc4edb68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c97d325215c8462f375f142d1e91099cc4edb68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b3e722a3ca1b9dcfff1c016e651d0d681de1af0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3e722a3ca1b9dcfff1c016e651d0d681de1af0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b3e722a3ca1b9dcfff1c016e651d0d681de1af0"}], "stats": {"total": 554, "additions": 366, "deletions": 188}, "files": [{"sha": "1f65809fc81f010934229a167c3ade92ac2ca92d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -1,4 +1,4 @@\n-957591b8a054b692d92203a2420851689875f9c5\n+be0d2cc2df9f98d967c242594838f86362dae2e7\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4b158c05c6e12188ab748b7bf1f31352027746cc", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -1,4 +1,4 @@\n-9706f510a5e2754595d716bd64be8375997311fb\n+1984ee00048b63eacd2155cd6d74a2d13e998272\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "93c7b2d3d7865886f0961fe6d2bf582985e48b9e", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -1 +1 @@\n-go1.15.2\n+go1.15.3"}, {"sha": "ce52649f132bb9575beacdca5af912f97478bb32", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -227,19 +227,26 @@ func IndexAny(s []byte, chars string) int {\n \t\t\tcontinue\n \t\t}\n \t\tr, width = utf8.DecodeRune(s[i:])\n-\t\tif r == utf8.RuneError {\n-\t\t\tfor _, r = range chars {\n-\t\t\t\tif r == utf8.RuneError {\n+\t\tif r != utf8.RuneError {\n+\t\t\t// r is 2 to 4 bytes\n+\t\t\tif len(chars) == width {\n+\t\t\t\tif chars == string(r) {\n \t\t\t\t\treturn i\n \t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// Use bytealg.IndexString for performance if available.\n+\t\t\tif bytealg.MaxLen >= width {\n+\t\t\t\tif bytealg.IndexString(chars, string(r)) >= 0 {\n+\t\t\t\t\treturn i\n+\t\t\t\t}\n+\t\t\t\tcontinue\n \t\t\t}\n-\t\t\tcontinue\n \t\t}\n-\t\t// r is 2 to 4 bytes. Using strings.Index is more reasonable, but as the bytes\n-\t\t// package should not import the strings package, use bytealg.IndexString\n-\t\t// instead. And this does not seem to lose much performance.\n-\t\tif chars == string(r) || bytealg.IndexString(chars, string(r)) >= 0 {\n-\t\t\treturn i\n+\t\tfor _, ch := range chars {\n+\t\t\tif r == ch {\n+\t\t\t\treturn i\n+\t\t\t}\n \t\t}\n \t}\n \treturn -1\n@@ -304,19 +311,26 @@ func LastIndexAny(s []byte, chars string) int {\n \t\t}\n \t\tr, size := utf8.DecodeLastRune(s[:i])\n \t\ti -= size\n-\t\tif r == utf8.RuneError {\n-\t\t\tfor _, r = range chars {\n-\t\t\t\tif r == utf8.RuneError {\n+\t\tif r != utf8.RuneError {\n+\t\t\t// r is 2 to 4 bytes\n+\t\t\tif len(chars) == size {\n+\t\t\t\tif chars == string(r) {\n \t\t\t\t\treturn i\n \t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// Use bytealg.IndexString for performance if available.\n+\t\t\tif bytealg.MaxLen >= size {\n+\t\t\t\tif bytealg.IndexString(chars, string(r)) >= 0 {\n+\t\t\t\t\treturn i\n+\t\t\t\t}\n+\t\t\t\tcontinue\n \t\t\t}\n-\t\t\tcontinue\n \t\t}\n-\t\t// r is 2 to 4 bytes. Using strings.Index is more reasonable, but as the bytes\n-\t\t// package should not import the strings package, use bytealg.IndexString\n-\t\t// instead. And this does not seem to lose much performance.\n-\t\tif chars == string(r) || bytealg.IndexString(chars, string(r)) >= 0 {\n-\t\t\treturn i\n+\t\tfor _, ch := range chars {\n+\t\t\tif r == ch {\n+\t\t\t\treturn i\n+\t\t\t}\n \t\t}\n \t}\n \treturn -1"}, {"sha": "37bafcf189e55ea33e18805bc885eceb1a501e75", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -2459,6 +2459,18 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\ttt := *t\n \t\t\ttt.C = &TypeRepr{\"%s %s\", []interface{}{dt.Kind, tag}}\n \t\t\ttt.Go = c.Ident(\"struct{}\")\n+\t\t\tif dt.Kind == \"struct\" {\n+\t\t\t\t// We don't know what the representation of this struct is, so don't let\n+\t\t\t\t// anyone allocate one on the Go side. As a side effect of this annotation,\n+\t\t\t\t// pointers to this type will not be considered pointers in Go. They won't\n+\t\t\t\t// get writebarrier-ed or adjusted during a stack copy. This should handle\n+\t\t\t\t// all the cases badPointerTypedef used to handle, but hopefully will\n+\t\t\t\t// continue to work going forward without any more need for cgo changes.\n+\t\t\t\ttt.NotInHeap = true\n+\t\t\t\t// TODO: we should probably do the same for unions. Unions can't live\n+\t\t\t\t// on the Go heap, right? It currently doesn't work for unions because\n+\t\t\t\t// they are defined as a type alias for struct{}, not a defined type.\n+\t\t\t}\n \t\t\ttypedef[name.Name] = &tt\n \t\t\tbreak\n \t\t}\n@@ -2529,6 +2541,7 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t}\n \t\tt.Go = name\n \t\tt.BadPointer = sub.BadPointer\n+\t\tt.NotInHeap = sub.NotInHeap\n \t\tif unionWithPointer[sub.Go] {\n \t\t\tunionWithPointer[t.Go] = true\n \t\t}\n@@ -2539,6 +2552,7 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\ttt := *t\n \t\t\ttt.Go = sub.Go\n \t\t\ttt.BadPointer = sub.BadPointer\n+\t\t\ttt.NotInHeap = sub.NotInHeap\n \t\t\ttypedef[name.Name] = &tt\n \t\t}\n \n@@ -3047,6 +3061,7 @@ func (c *typeConv) anonymousStructTypedef(dt *dwarf.TypedefType) bool {\n // non-pointers in this type.\n // TODO: Currently our best solution is to find these manually and list them as\n // they come up. A better solution is desired.\n+// Note: DEPRECATED. There is now a better solution. Search for NotInHeap in this file.\n func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n \tif c.badCFType(dt) {\n \t\treturn true"}, {"sha": "7fc2508021be0598c4321682defddf341fb96f30", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -151,7 +151,8 @@ type Type struct {\n \tGo         ast.Expr\n \tEnumValues map[string]int64\n \tTypedef    string\n-\tBadPointer bool\n+\tBadPointer bool // this pointer type should be represented as a uintptr (deprecated)\n+\tNotInHeap  bool // this type should have a go:notinheap annotation\n }\n \n // A FuncType collects information about a function type in both the C and Go worlds."}, {"sha": "dd03f7d67a5f093b1fede677baf68f4a693d3cbb", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -113,6 +113,9 @@ func (p *Package) writeDefs() {\n \tsort.Strings(typedefNames)\n \tfor _, name := range typedefNames {\n \t\tdef := typedef[name]\n+\t\tif def.NotInHeap {\n+\t\t\tfmt.Fprintf(fgo2, \"//go:notinheap\\n\")\n+\t\t}\n \t\tfmt.Fprintf(fgo2, \"type %s \", name)\n \t\t// We don't have source info for these types, so write them out without source info.\n \t\t// Otherwise types would look like:"}, {"sha": "f29cc3cf9a5d0d7be56a42cd50cc8e2108ccf00a", "filename": "libgo/go/cmd/go/internal/base/goflags.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -153,3 +153,20 @@ func SetFromGOFLAGS(flags *flag.FlagSet) {\n \t\t}\n \t}\n }\n+\n+// InGOFLAGS returns whether GOFLAGS contains the given flag, such as \"-mod\".\n+func InGOFLAGS(flag string) bool {\n+\tfor _, goflag := range GOFLAGS() {\n+\t\tname := goflag\n+\t\tif strings.HasPrefix(name, \"--\") {\n+\t\t\tname = name[1:]\n+\t\t}\n+\t\tif i := strings.Index(name, \"=\"); i >= 0 {\n+\t\t\tname = name[:i]\n+\t\t}\n+\t\tif name == flag {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "a5b13653cd6d39ce929f7ea96fc3aa55b2677411", "filename": "libgo/go/cmd/go/internal/version/version.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -53,7 +53,14 @@ var (\n \n func runVersion(cmd *base.Command, args []string) {\n \tif len(args) == 0 {\n-\t\tif *versionM || *versionV {\n+\t\t// If any of this command's flags were passed explicitly, error\n+\t\t// out, because they only make sense with arguments.\n+\t\t//\n+\t\t// Don't error if the flags came from GOFLAGS, since that can be\n+\t\t// a reasonable use case. For example, imagine GOFLAGS=-v to\n+\t\t// turn \"verbose mode\" on for all Go commands, which should not\n+\t\t// break \"go version\".\n+\t\tif (!base.InGOFLAGS(\"-m\") && *versionM) || (!base.InGOFLAGS(\"-v\") && *versionV) {\n \t\t\tfmt.Fprintf(os.Stderr, \"go version: flags can only be used with arguments\\n\")\n \t\t\tbase.SetExitStatus(2)\n \t\t\treturn"}, {"sha": "c168364cd173a52ba19dee73ebb94383affd31ad", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -254,34 +254,18 @@ func buildModeInit() {\n \tcase \"\":\n \t\t// ok\n \tcase \"readonly\", \"vendor\", \"mod\":\n-\t\tif !cfg.ModulesEnabled && !inGOFLAGS(\"-mod\") {\n+\t\tif !cfg.ModulesEnabled && !base.InGOFLAGS(\"-mod\") {\n \t\t\tbase.Fatalf(\"build flag -mod=%s only valid when using modules\", cfg.BuildMod)\n \t\t}\n \tdefault:\n \t\tbase.Fatalf(\"-mod=%s not supported (can be '', 'mod', 'readonly', or 'vendor')\", cfg.BuildMod)\n \t}\n \tif !cfg.ModulesEnabled {\n-\t\tif cfg.ModCacheRW && !inGOFLAGS(\"-modcacherw\") {\n+\t\tif cfg.ModCacheRW && !base.InGOFLAGS(\"-modcacherw\") {\n \t\t\tbase.Fatalf(\"build flag -modcacherw only valid when using modules\")\n \t\t}\n-\t\tif cfg.ModFile != \"\" && !inGOFLAGS(\"-mod\") {\n+\t\tif cfg.ModFile != \"\" && !base.InGOFLAGS(\"-mod\") {\n \t\t\tbase.Fatalf(\"build flag -modfile only valid when using modules\")\n \t\t}\n \t}\n }\n-\n-func inGOFLAGS(flag string) bool {\n-\tfor _, goflag := range base.GOFLAGS() {\n-\t\tname := goflag\n-\t\tif strings.HasPrefix(name, \"--\") {\n-\t\t\tname = name[1:]\n-\t\t}\n-\t\tif i := strings.Index(name, \"=\"); i >= 0 {\n-\t\t\tname = name[:i]\n-\t\t}\n-\t\tif name == flag {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}"}, {"sha": "87cb6befe932683733df2faac2270cc8bd3c8950", "filename": "libgo/go/cmd/go/testdata/script/version.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -9,6 +9,12 @@ stderr 'with arguments'\n ! go version -v\n stderr 'with arguments'\n \n+# Neither of the two flags above should be an issue via GOFLAGS.\n+env GOFLAGS='-m -v'\n+go version\n+stdout '^go version'\n+env GOFLAGS=\n+\n env GO111MODULE=on\n # Skip the builds below if we are running in short mode.\n [short] skip"}, {"sha": "c595c231cf019c4c88446c2f0fa311648f5f19f5", "filename": "libgo/go/internal/bytealg/index_generic.go", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Finternal%2Fbytealg%2Findex_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Finternal%2Fbytealg%2Findex_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fbytealg%2Findex_generic.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -17,42 +17,8 @@ func Index(a, b []byte) int {\n \n // IndexString returns the index of the first instance of b in a, or -1 if b is not present in a.\n // Requires 2 <= len(b) <= MaxLen.\n-func IndexString(s, substr string) int {\n-\t// This is a partial copy of strings.Index, here because bytes.IndexAny and bytes.LastIndexAny\n-\t// call bytealg.IndexString. Some platforms have an optimized assembly version of this function.\n-\t// This implementation is used for those that do not. Although the pure Go implementation here\n-\t// works for the case of len(b) > MaxLen, we do not require that its assembly implementation also\n-\t// supports the case of len(b) > MaxLen. And we do not guarantee that this function supports the\n-\t// case of len(b) > MaxLen.\n-\tn := len(substr)\n-\tc0 := substr[0]\n-\tc1 := substr[1]\n-\ti := 0\n-\tt := len(s) - n + 1\n-\tfails := 0\n-\tfor i < t {\n-\t\tif s[i] != c0 {\n-\t\t\to := IndexByteString(s[i:t], c0)\n-\t\t\tif o < 0 {\n-\t\t\t\treturn -1\n-\t\t\t}\n-\t\t\ti += o\n-\t\t}\n-\t\tif s[i+1] == c1 && s[i:i+n] == substr {\n-\t\t\treturn i\n-\t\t}\n-\t\ti++\n-\t\tfails++\n-\t\tif fails >= 4+i>>4 && i < t {\n-\t\t\t// See comment in src/bytes/bytes.go.\n-\t\t\tj := IndexRabinKarp(s[i:], substr)\n-\t\t\tif j < 0 {\n-\t\t\t\treturn -1\n-\t\t\t}\n-\t\t\treturn i + j\n-\t\t}\n-\t}\n-\treturn -1\n+func IndexString(a, b string) int {\n+\tpanic(\"unimplemented\")\n }\n \n // Cutover reports the number of failures of IndexByte we should tolerate"}, {"sha": "10cf1735d6acb043b53c9edf10ff6d3a3d962083", "filename": "libgo/go/internal/poll/fd_unix.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -152,7 +152,7 @@ func (fd *FD) Read(p []byte) (int, error) {\n \t\tp = p[:maxRW]\n \t}\n \tfor {\n-\t\tn, err := ignoringEINTR(syscall.Read, fd.Sysfd, p)\n+\t\tn, err := ignoringEINTR(func() (int, error) { return syscall.Read(fd.Sysfd, p) })\n \t\tif err != nil {\n \t\t\tn = 0\n \t\t\tif err == syscall.EAGAIN && fd.pd.pollable() {\n@@ -264,7 +264,7 @@ func (fd *FD) Write(p []byte) (int, error) {\n \t\tif fd.IsStream && max-nn > maxRW {\n \t\t\tmax = nn + maxRW\n \t\t}\n-\t\tn, err := ignoringEINTR(syscall.Write, fd.Sysfd, p[nn:max])\n+\t\tn, err := ignoringEINTR(func() (int, error) { return syscall.Write(fd.Sysfd, p[nn:max]) })\n \t\tif n > 0 {\n \t\t\tnn += n\n \t\t}\n@@ -423,7 +423,7 @@ func (fd *FD) ReadDirent(buf []byte) (int, error) {\n \t}\n \tdefer fd.decref()\n \tfor {\n-\t\tn, err := ignoringEINTR(syscall.ReadDirent, fd.Sysfd, buf)\n+\t\tn, err := ignoringEINTR(func() (int, error) { return syscall.ReadDirent(fd.Sysfd, buf) })\n \t\tif err != nil {\n \t\t\tn = 0\n \t\t\tif err == syscall.EAGAIN && fd.pd.pollable() {\n@@ -514,7 +514,7 @@ func (fd *FD) WriteOnce(p []byte) (int, error) {\n \t\treturn 0, err\n \t}\n \tdefer fd.writeUnlock()\n-\treturn ignoringEINTR(syscall.Write, fd.Sysfd, p)\n+\treturn ignoringEINTR(func() (int, error) { return syscall.Write(fd.Sysfd, p) })\n }\n \n // RawRead invokes the user-defined function f for a read operation.\n@@ -562,9 +562,9 @@ func (fd *FD) RawWrite(f func(uintptr) bool) error {\n // installed without setting SA_RESTART. None of these are the common case,\n // but there are enough of them that it seems that we can't avoid\n // an EINTR loop.\n-func ignoringEINTR(fn func(fd int, p []byte) (int, error), fd int, p []byte) (int, error) {\n+func ignoringEINTR(fn func() (int, error)) (int, error) {\n \tfor {\n-\t\tn, err := fn(fd, p)\n+\t\tn, err := fn()\n \t\tif err != syscall.EINTR {\n \t\t\treturn n, err\n \t\t}"}, {"sha": "b909d478d266153ff70ce5bf4cca6db579da04b8", "filename": "libgo/go/runtime/chan.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -267,6 +267,11 @@ func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n \tgp.waiting = mysg\n \tgp.param = nil\n \tc.sendq.enqueue(mysg)\n+\t// Signal to anyone trying to shrink our stack that we're about\n+\t// to park on a channel. The window between when this G's status\n+\t// changes and when we set gp.activeStackChans is not safe for\n+\t// stack shrinking.\n+\tatomic.Store8(&gp.parkingOnChan, 1)\n \tgopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)\n \t// Ensure the value being sent is kept alive until the\n \t// receiver copies it out. The sudog has a pointer to the\n@@ -586,6 +591,11 @@ func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)\n \tmysg.c = c\n \tgp.param = nil\n \tc.recvq.enqueue(mysg)\n+\t// Signal to anyone trying to shrink our stack that we're about\n+\t// to park on a channel. The window between when this G's status\n+\t// changes and when we set gp.activeStackChans is not safe for\n+\t// stack shrinking.\n+\tatomic.Store8(&gp.parkingOnChan, 1)\n \tgopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)\n \n \t// someone woke us up\n@@ -663,7 +673,19 @@ func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {\n func chanparkcommit(gp *g, chanLock unsafe.Pointer) bool {\n \t// There are unlocked sudogs that point into gp's stack. Stack\n \t// copying must lock the channels of those sudogs.\n+\t// Set activeStackChans here instead of before we try parking\n+\t// because we could self-deadlock in stack growth on the\n+\t// channel lock.\n \tgp.activeStackChans = true\n+\t// Mark that it's safe for stack shrinking to occur now,\n+\t// because any thread acquiring this G's stack for shrinking\n+\t// is guaranteed to observe activeStackChans after this store.\n+\tatomic.Store8(&gp.parkingOnChan, 0)\n+\t// Make sure we unlock after setting activeStackChans and\n+\t// unsetting parkingOnChan. The moment we unlock chanLock\n+\t// we risk gp getting readied by a channel operation and\n+\t// so gp could continue running before everything before\n+\t// the unlock is visible (even to gp itself).\n \tunlock((*mutex)(chanLock))\n \treturn true\n }"}, {"sha": "85d3e04ffff4a26d54db4692c340544346787873", "filename": "libgo/go/runtime/chan_test.go", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fchan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fchan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan_test.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -628,6 +628,62 @@ func TestShrinkStackDuringBlockedSend(t *testing.T) {\n \t<-done\n }\n \n+func TestNoShrinkStackWhileParking(t *testing.T) {\n+\t// The goal of this test is to trigger a \"racy sudog adjustment\"\n+\t// throw. Basically, there's a window between when a goroutine\n+\t// becomes available for preemption for stack scanning (and thus,\n+\t// stack shrinking) but before the goroutine has fully parked on a\n+\t// channel. See issue 40641 for more details on the problem.\n+\t//\n+\t// The way we try to induce this failure is to set up two\n+\t// goroutines: a sender and a reciever that communicate across\n+\t// a channel. We try to set up a situation where the sender\n+\t// grows its stack temporarily then *fully* blocks on a channel\n+\t// often. Meanwhile a GC is triggered so that we try to get a\n+\t// mark worker to shrink the sender's stack and race with the\n+\t// sender parking.\n+\t//\n+\t// Unfortunately the race window here is so small that we\n+\t// either need a ridiculous number of iterations, or we add\n+\t// \"usleep(1000)\" to park_m, just before the unlockf call.\n+\tconst n = 10\n+\tsend := func(c chan<- int, done chan struct{}) {\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tc <- i\n+\t\t\t// Use lots of stack briefly so that\n+\t\t\t// the GC is going to want to shrink us\n+\t\t\t// when it scans us. Make sure not to\n+\t\t\t// do any function calls otherwise\n+\t\t\t// in order to avoid us shrinking ourselves\n+\t\t\t// when we're preempted.\n+\t\t\tstackGrowthRecursive(20)\n+\t\t}\n+\t\tdone <- struct{}{}\n+\t}\n+\trecv := func(c <-chan int, done chan struct{}) {\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\t// Sleep here so that the sender always\n+\t\t\t// fully blocks.\n+\t\t\ttime.Sleep(10 * time.Microsecond)\n+\t\t\t<-c\n+\t\t}\n+\t\tdone <- struct{}{}\n+\t}\n+\tfor i := 0; i < n*20; i++ {\n+\t\tc := make(chan int)\n+\t\tdone := make(chan struct{})\n+\t\tgo recv(c, done)\n+\t\tgo send(c, done)\n+\t\t// Wait a little bit before triggering\n+\t\t// the GC to make sure the sender and\n+\t\t// reciever have gotten into their groove.\n+\t\ttime.Sleep(50 * time.Microsecond)\n+\t\truntime.GC()\n+\t\t<-done\n+\t\t<-done\n+\t}\n+}\n+\n func TestSelectDuplicateChannel(t *testing.T) {\n \t// This test makes sure we can queue a G on\n \t// the same channel multiple times."}, {"sha": "369230a8b7b023d2b050b3e504d3e6322485be27", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -355,7 +355,11 @@ func ReadMemStatsSlow() (base, slow MemStats) {\n \t\t}\n \n \t\tfor i := mheap_.pages.start; i < mheap_.pages.end; i++ {\n-\t\t\tpg := mheap_.pages.chunkOf(i).scavenged.popcntRange(0, pallocChunkPages)\n+\t\t\tchunk := mheap_.pages.tryChunkOf(i)\n+\t\t\tif chunk == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tpg := chunk.scavenged.popcntRange(0, pallocChunkPages)\n \t\t\tslow.HeapReleased += uint64(pg) * pageSize\n \t\t}\n \t\tfor _, p := range allp {\n@@ -752,11 +756,7 @@ func (p *PageAlloc) InUse() []AddrRange {\n // Returns nil if the PallocData's L2 is missing.\n func (p *PageAlloc) PallocData(i ChunkIdx) *PallocData {\n \tci := chunkIdx(i)\n-\tl2 := (*pageAlloc)(p).chunks[ci.l1()]\n-\tif l2 == nil {\n-\t\treturn nil\n-\t}\n-\treturn (*PallocData)(&l2[ci.l2()])\n+\treturn (*PallocData)((*pageAlloc)(p).tryChunkOf(ci))\n }\n \n // AddrRange represents a range over addresses.\n@@ -896,7 +896,10 @@ func CheckScavengedBitsCleared(mismatches []BitsMismatch) (n int, ok bool) {\n \t\tlock(&mheap_.lock)\n \tchunkLoop:\n \t\tfor i := mheap_.pages.start; i < mheap_.pages.end; i++ {\n-\t\t\tchunk := mheap_.pages.chunkOf(i)\n+\t\t\tchunk := mheap_.pages.tryChunkOf(i)\n+\t\t\tif chunk == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tfor j := 0; j < pallocChunkPages/64; j++ {\n \t\t\t\t// Run over each 64-bit bitmap section and ensure\n \t\t\t\t// scavenged is being cleared properly on allocation.\n@@ -977,10 +980,9 @@ func MapHashCheck(m interface{}, k interface{}) (uintptr, uintptr) {\n }\n \n func MSpanCountAlloc(bits []byte) int {\n-\ts := mspan{\n-\t\tnelems:     uintptr(len(bits) * 8),\n-\t\tgcmarkBits: (*gcBits)(unsafe.Pointer(&bits[0])),\n-\t}\n+\ts := (*mspan)(mheap_.spanalloc.alloc())\n+\ts.nelems = uintptr(len(bits) * 8)\n+\ts.gcmarkBits = (*gcBits)(unsafe.Pointer(&bits[0]))\n \treturn s.countAlloc()\n }\n "}, {"sha": "b0a8fa06103ff2bf5e6c0c694e67d5e1190b08a9", "filename": "libgo/go/runtime/internal/atomic/atomic_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic_test.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -220,3 +220,13 @@ func TestBitwiseContended(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestStorepNoWB(t *testing.T) {\n+\tvar p [2]*int\n+\tfor i := range p {\n+\t\tatomic.StorepNoWB(unsafe.Pointer(&p[i]), unsafe.Pointer(new(int)))\n+\t}\n+\tif p[0] == p[1] {\n+\t\tt.Error(\"Bad escape analysis of StorepNoWB\")\n+\t}\n+}"}, {"sha": "c90a6378bdacecaaa65370e5cc6c0a91d3eb3622", "filename": "libgo/go/runtime/mpagealloc.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fmpagealloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fmpagealloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagealloc.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -326,7 +326,20 @@ func (s *pageAlloc) init(mheapLock *mutex, sysStat *uint64) {\n \ts.scav.scavLWM = maxSearchAddr\n }\n \n+// tryChunkOf returns the bitmap data for the given chunk.\n+//\n+// Returns nil if the chunk data has not been mapped.\n+func (s *pageAlloc) tryChunkOf(ci chunkIdx) *pallocData {\n+\tl2 := s.chunks[ci.l1()]\n+\tif l2 == nil {\n+\t\treturn nil\n+\t}\n+\treturn &l2[ci.l2()]\n+}\n+\n // chunkOf returns the chunk at the given chunk index.\n+//\n+// The chunk index must be valid or this method may throw.\n func (s *pageAlloc) chunkOf(ci chunkIdx) *pallocData {\n \treturn &s.chunks[ci.l1()][ci.l2()]\n }"}, {"sha": "a8f0dc39c0c7da39c44dbd2a394cd46066c689e8", "filename": "libgo/go/runtime/proc_test.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fproc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fproc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc_test.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -529,9 +529,17 @@ func BenchmarkPingPongHog(b *testing.B) {\n \t<-done\n }\n \n+var padData [128]uint64\n+\n func stackGrowthRecursive(i int) {\n \tvar pad [128]uint64\n-\tif i != 0 && pad[0] == 0 {\n+\tpad = padData\n+\tfor j := range pad {\n+\t\tif pad[j] != 0 {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tif i != 0 {\n \t\tstackGrowthRecursive(i - 1)\n \t}\n }"}, {"sha": "bf3fbac14c8fc5b6a675860735aad72f4aad53e2", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -450,6 +450,10 @@ type g struct {\n \t// copying needs to acquire channel locks to protect these\n \t// areas of the stack.\n \tactiveStackChans bool\n+\t// parkingOnChan indicates that the goroutine is about to\n+\t// park on a chansend or chanrecv. Used to signal an unsafe point\n+\t// for stack shrinking. It's a boolean value, but is updated atomically.\n+\tparkingOnChan uint8\n \n \traceignore     int8     // ignore race detection events\n \tsysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine\n@@ -940,11 +944,6 @@ type _defer struct {\n \n // panics\n // This is the gccgo version.\n-//\n-// This is marked go:notinheap because _panic values must only ever\n-// live on the stack.\n-//\n-//go:notinheap\n type _panic struct {\n \t// The next entry in the stack.\n \tlink *_panic"}, {"sha": "c8910b8dc237f7a5fc2cc375f3ced8fc08c0ba10", "filename": "libgo/go/runtime/select.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fselect.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -7,6 +7,7 @@ package runtime\n // This file contains the implementation of Go select statements.\n \n import (\n+\t\"runtime/internal/atomic\"\n \t\"unsafe\"\n )\n \n@@ -72,7 +73,20 @@ func selunlock(scases []scase, lockorder []uint16) {\n func selparkcommit(gp *g, _ unsafe.Pointer) bool {\n \t// There are unlocked sudogs that point into gp's stack. Stack\n \t// copying must lock the channels of those sudogs.\n+\t// Set activeStackChans here instead of before we try parking\n+\t// because we could self-deadlock in stack growth on a\n+\t// channel lock.\n \tgp.activeStackChans = true\n+\t// Mark that it's safe for stack shrinking to occur now,\n+\t// because any thread acquiring this G's stack for shrinking\n+\t// is guaranteed to observe activeStackChans after this store.\n+\tatomic.Store8(&gp.parkingOnChan, 0)\n+\t// Make sure we unlock after setting activeStackChans and\n+\t// unsetting parkingOnChan. The moment we unlock any of the\n+\t// channel locks we risk gp getting readied by a channel operation\n+\t// and so gp could continue running before everything before the\n+\t// unlock is visible (even to gp itself).\n+\n \t// This must not access gp's stack (see gopark). In\n \t// particular, it must not access the *hselect. That's okay,\n \t// because by the time this is called, gp.waiting has all\n@@ -313,6 +327,11 @@ loop:\n \n \t// wait for someone to wake us up\n \tgp.param = nil\n+\t// Signal to anyone trying to shrink our stack that we're about\n+\t// to park on a channel. The window between when this G's status\n+\t// changes and when we set gp.activeStackChans is not safe for\n+\t// stack shrinking.\n+\tatomic.Store8(&gp.parkingOnChan, 1)\n \tgopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1)\n \tgp.activeStackChans = false\n "}, {"sha": "f856fdcd010f1e98cd692c36825f121df31b961e", "filename": "libgo/go/runtime/trace/trace_stack_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_stack_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_stack_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_stack_test.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -252,6 +252,7 @@ func TestTraceSymbolize(t *testing.T) {\n \t\t\t{trace.EvGoSysCall, []frame{\n \t\t\t\t{\"syscall.read\", 0},\n \t\t\t\t{\"syscall.Read\", 0},\n+\t\t\t\t{\"internal/poll.(*FD).Read.func1\", 0},\n \t\t\t\t{\"internal/poll.ignoringEINTR\", 0},\n \t\t\t\t{\"internal/poll.(*FD).Read\", 0},\n \t\t\t\t{\"os.(*File).read\", 0},"}, {"sha": "e9687bf26def25a3b91beebda27529a507cf3e22", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -242,7 +242,7 @@ func (b *B) run1() bool {\n \t\tif b.skipped {\n \t\t\ttag = \"SKIP\"\n \t\t}\n-\t\tif b.chatty && (len(b.output) > 0 || b.finished) {\n+\t\tif b.chatty != nil && (len(b.output) > 0 || b.finished) {\n \t\t\tb.trimOutput()\n \t\t\tfmt.Fprintf(b.w, \"--- %s: %s\\n%s\", tag, b.name, b.output)\n \t\t}\n@@ -523,10 +523,9 @@ func runBenchmarks(importPath string, matchString func(pat, str string) (bool, e\n \t}\n \tmain := &B{\n \t\tcommon: common{\n-\t\t\tname:   \"Main\",\n-\t\t\tw:      os.Stdout,\n-\t\t\tchatty: *chatty,\n-\t\t\tbench:  true,\n+\t\t\tname:  \"Main\",\n+\t\t\tw:     os.Stdout,\n+\t\t\tbench: true,\n \t\t},\n \t\timportPath: importPath,\n \t\tbenchFunc: func(b *B) {\n@@ -537,6 +536,9 @@ func runBenchmarks(importPath string, matchString func(pat, str string) (bool, e\n \t\tbenchTime: benchTime,\n \t\tcontext:   ctx,\n \t}\n+\tif Verbose() {\n+\t\tmain.chatty = newChattyPrinter(main.w)\n+\t}\n \tmain.runN(1)\n \treturn !main.failed\n }\n@@ -549,7 +551,7 @@ func (ctx *benchContext) processBench(b *B) {\n \t\t\tbenchName := benchmarkName(b.name, procs)\n \n \t\t\t// If it's chatty, we've already printed this information.\n-\t\t\tif !b.chatty {\n+\t\t\tif b.chatty == nil {\n \t\t\t\tfmt.Fprintf(b.w, \"%-*s\\t\", ctx.maxLen, benchName)\n \t\t\t}\n \t\t\t// Recompute the running time for all but the first iteration.\n@@ -576,7 +578,7 @@ func (ctx *benchContext) processBench(b *B) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tresults := r.String()\n-\t\t\tif b.chatty {\n+\t\t\tif b.chatty != nil {\n \t\t\t\tfmt.Fprintf(b.w, \"%-*s\\t\", ctx.maxLen, benchName)\n \t\t\t}\n \t\t\tif *benchmarkMemory || b.showAllocResult {\n@@ -639,7 +641,7 @@ func (b *B) Run(name string, f func(b *B)) bool {\n \t\tatomic.StoreInt32(&sub.hasSub, 1)\n \t}\n \n-\tif b.chatty {\n+\tif b.chatty != nil {\n \t\tlabelsOnce.Do(func() {\n \t\t\tfmt.Printf(\"goos: %s\\n\", runtime.GOOS)\n \t\t\tfmt.Printf(\"goarch: %s\\n\", runtime.GOARCH)"}, {"sha": "5ed3fc4afec78856254c9e4bf3f5369a77716ed4", "filename": "libgo/go/testing/sub_test.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Ftesting%2Fsub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Ftesting%2Fsub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fsub_test.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -483,10 +483,12 @@ func TestTRun(t *T) {\n \t\t\t\t\tsignal: make(chan bool),\n \t\t\t\t\tname:   \"Test\",\n \t\t\t\t\tw:      buf,\n-\t\t\t\t\tchatty: tc.chatty,\n \t\t\t\t},\n \t\t\t\tcontext: ctx,\n \t\t\t}\n+\t\t\tif tc.chatty {\n+\t\t\t\troot.chatty = newChattyPrinter(root.w)\n+\t\t\t}\n \t\t\tok := root.Run(tc.desc, tc.f)\n \t\t\tctx.release()\n \n@@ -665,11 +667,13 @@ func TestBRun(t *T) {\n \t\t\t\t\tsignal: make(chan bool),\n \t\t\t\t\tname:   \"root\",\n \t\t\t\t\tw:      buf,\n-\t\t\t\t\tchatty: tc.chatty,\n \t\t\t\t},\n \t\t\t\tbenchFunc: func(b *B) { ok = b.Run(\"test\", tc.f) }, // Use Run to catch failure.\n \t\t\t\tbenchTime: benchTimeFlag{d: 1 * time.Microsecond},\n \t\t\t}\n+\t\t\tif tc.chatty {\n+\t\t\t\troot.chatty = newChattyPrinter(root.w)\n+\t\t\t}\n \t\t\troot.runN(1)\n \t\t\tif ok != !tc.failed {\n \t\t\t\tt.Errorf(\"%s:ok: got %v; want %v\", tc.desc, ok, !tc.failed)\n@@ -741,9 +745,13 @@ func TestParallelSub(t *T) {\n \t}\n }\n \n-type funcWriter func([]byte) (int, error)\n+type funcWriter struct {\n+\twrite func([]byte) (int, error)\n+}\n \n-func (fw funcWriter) Write(b []byte) (int, error) { return fw(b) }\n+func (fw *funcWriter) Write(b []byte) (int, error) {\n+\treturn fw.write(b)\n+}\n \n func TestRacyOutput(t *T) {\n \tvar runs int32  // The number of running Writes\n@@ -761,9 +769,10 @@ func TestRacyOutput(t *T) {\n \n \tvar wg sync.WaitGroup\n \troot := &T{\n-\t\tcommon:  common{w: funcWriter(raceDetector), chatty: true},\n+\t\tcommon:  common{w: &funcWriter{raceDetector}},\n \t\tcontext: newTestContext(1, newMatcher(regexp.MatchString, \"\", \"\")),\n \t}\n+\troot.chatty = newChattyPrinter(root.w)\n \troot.Run(\"\", func(t *T) {\n \t\tfor i := 0; i < 100; i++ {\n \t\t\twg.Add(1)"}, {"sha": "80282fca60f39ab71ce1902f54fa3fe17a4bb247", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 64, "deletions": 74, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -325,7 +325,6 @@ var (\n \tcpuListStr           *string\n \tparallel             *int\n \ttestlog              *string\n-\tprinter              *testPrinter\n \n \thaveExamples bool // are there examples?\n \n@@ -335,55 +334,45 @@ var (\n \tnumFailed uint32 // number of test failures\n )\n \n-type testPrinter struct {\n-\tchatty bool\n-\n+type chattyPrinter struct {\n+\tw          io.Writer\n \tlastNameMu sync.Mutex // guards lastName\n \tlastName   string     // last printed test name in chatty mode\n }\n \n-func newTestPrinter(chatty bool) *testPrinter {\n-\treturn &testPrinter{\n-\t\tchatty: chatty,\n-\t}\n+func newChattyPrinter(w io.Writer) *chattyPrinter {\n+\treturn &chattyPrinter{w: w}\n }\n \n-func (p *testPrinter) Print(testName, out string) {\n-\tp.Fprint(os.Stdout, testName, out)\n+// Updatef prints a message about the status of the named test to w.\n+//\n+// The formatted message must include the test name itself.\n+func (p *chattyPrinter) Updatef(testName, format string, args ...interface{}) {\n+\tp.lastNameMu.Lock()\n+\tdefer p.lastNameMu.Unlock()\n+\n+\t// Since the message already implies an association with a specific new test,\n+\t// we don't need to check what the old test name was or log an extra CONT line\n+\t// for it. (We're updating it anyway, and the current message already includes\n+\t// the test name.)\n+\tp.lastName = testName\n+\tfmt.Fprintf(p.w, format, args...)\n }\n \n-func (p *testPrinter) Fprint(w io.Writer, testName, out string) {\n+// Printf prints a message, generated by the named test, that does not\n+// necessarily mention that tests's name itself.\n+func (p *chattyPrinter) Printf(testName, format string, args ...interface{}) {\n \tp.lastNameMu.Lock()\n \tdefer p.lastNameMu.Unlock()\n \n-\tif !p.chatty ||\n-\t\tstrings.HasPrefix(out, \"--- PASS: \") ||\n-\t\tstrings.HasPrefix(out, \"--- FAIL: \") ||\n-\t\tstrings.HasPrefix(out, \"--- SKIP: \") ||\n-\t\tstrings.HasPrefix(out, \"=== RUN   \") ||\n-\t\tstrings.HasPrefix(out, \"=== CONT  \") ||\n-\t\tstrings.HasPrefix(out, \"=== PAUSE \") {\n-\t\t// If we're buffering test output (!p.chatty), we don't really care which\n-\t\t// test is emitting which line so long as they are serialized.\n-\t\t//\n-\t\t// If the message already implies an association with a specific new test,\n-\t\t// we don't need to check what the old test name was or log an extra CONT\n-\t\t// line for it. (We're updating it anyway, and the current message already\n-\t\t// includes the test name.)\n-\t\tp.lastName = testName\n-\t\tfmt.Fprint(w, out)\n-\t\treturn\n-\t}\n-\n \tif p.lastName == \"\" {\n \t\tp.lastName = testName\n \t} else if p.lastName != testName {\n-\t\t// Always printed as-is, with 0 decoration or indentation. So, we skip\n-\t\t// printing to w.\n-\t\tfmt.Printf(\"=== CONT  %s\\n\", testName)\n+\t\tfmt.Fprintf(p.w, \"=== CONT  %s\\n\", testName)\n \t\tp.lastName = testName\n \t}\n-\tfmt.Fprint(w, out)\n+\n+\tfmt.Fprintf(p.w, format, args...)\n }\n \n // The maximum number of stack frames to go through when skipping helper functions for\n@@ -405,12 +394,12 @@ type common struct {\n \tcleanupName string              // Name of the cleanup function.\n \tcleanupPc   []uintptr           // The stack trace at the point where Cleanup was called.\n \n-\tchatty     bool   // A copy of the chatty flag.\n-\tbench      bool   // Whether the current test is a benchmark.\n-\tfinished   bool   // Test function has completed.\n-\thasSub     int32  // Written atomically.\n-\traceErrors int    // Number of races detected during test.\n-\trunner     string // Function name of tRunner running the test.\n+\tchatty     *chattyPrinter // A copy of chattyPrinter, if the chatty flag is set.\n+\tbench      bool           // Whether the current test is a benchmark.\n+\tfinished   bool           // Test function has completed.\n+\thasSub     int32          // Written atomically.\n+\traceErrors int            // Number of races detected during test.\n+\trunner     string         // Function name of tRunner running the test.\n \n \tparent   *common\n \tlevel    int       // Nesting depth of test or benchmark.\n@@ -572,12 +561,31 @@ func (c *common) flushToParent(testName, format string, args ...interface{}) {\n \tp.mu.Lock()\n \tdefer p.mu.Unlock()\n \n-\tprinter.Fprint(p.w, testName, fmt.Sprintf(format, args...))\n-\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n-\tio.Copy(p.w, bytes.NewReader(c.output))\n-\tc.output = c.output[:0]\n+\n+\tif len(c.output) > 0 {\n+\t\tformat += \"%s\"\n+\t\targs = append(args[:len(args):len(args)], c.output)\n+\t\tc.output = c.output[:0] // but why?\n+\t}\n+\n+\tif c.chatty != nil && p.w == c.chatty.w {\n+\t\t// We're flushing to the actual output, so track that this output is\n+\t\t// associated with a specific test (and, specifically, that the next output\n+\t\t// is *not* associated with that test).\n+\t\t//\n+\t\t// Moreover, if c.output is non-empty it is important that this write be\n+\t\t// atomic with respect to the output of other tests, so that we don't end up\n+\t\t// with confusing '=== CONT' lines in the middle of our '--- PASS' block.\n+\t\t// Neither humans nor cmd/test2json can parse those easily.\n+\t\t// (See https://golang.org/issue/40771.)\n+\t\tc.chatty.Updatef(testName, format, args...)\n+\t} else {\n+\t\t// We're flushing to the output buffer of the parent test, which will\n+\t\t// itself follow a test-name header when it is finally flushed to stdout.\n+\t\tfmt.Fprintf(p.w, format, args...)\n+\t}\n }\n \n type indenter struct {\n@@ -746,13 +754,13 @@ func (c *common) logDepth(s string, depth int) {\n \t\t}\n \t\tpanic(\"Log in goroutine after \" + c.name + \" has completed\")\n \t} else {\n-\t\tif c.chatty {\n+\t\tif c.chatty != nil {\n \t\t\tif c.bench {\n \t\t\t\t// Benchmarks don't print === CONT, so we should skip the test\n \t\t\t\t// printer and just print straight to stdout.\n \t\t\t\tfmt.Print(c.decorate(s, depth+1))\n \t\t\t} else {\n-\t\t\t\tprinter.Print(c.name, c.decorate(s, depth+1))\n+\t\t\t\tc.chatty.Printf(c.name, \"%s\", c.decorate(s, depth+1))\n \t\t\t}\n \n \t\t\treturn\n@@ -1019,34 +1027,22 @@ func (t *T) Parallel() {\n \tt.parent.sub = append(t.parent.sub, t)\n \tt.raceErrors += race.Errors()\n \n-\tif t.chatty {\n-\t\t// Print directly to root's io.Writer so there is no delay.\n-\t\troot := t.parent\n-\t\tfor ; root.parent != nil; root = root.parent {\n-\t\t}\n-\t\troot.mu.Lock()\n+\tif t.chatty != nil {\n \t\t// Unfortunately, even though PAUSE indicates that the named test is *no\n \t\t// longer* running, cmd/test2json interprets it as changing the active test\n \t\t// for the purpose of log parsing. We could fix cmd/test2json, but that\n \t\t// won't fix existing deployments of third-party tools that already shell\n \t\t// out to older builds of cmd/test2json \u2014 so merely fixing cmd/test2json\n \t\t// isn't enough for now.\n-\t\tprinter.Fprint(root.w, t.name, fmt.Sprintf(\"=== PAUSE %s\\n\", t.name))\n-\t\troot.mu.Unlock()\n+\t\tt.chatty.Updatef(t.name, \"=== PAUSE %s\\n\", t.name)\n \t}\n \n \tt.signal <- true   // Release calling test.\n \t<-t.parent.barrier // Wait for the parent test to complete.\n \tt.context.waitParallel()\n \n-\tif t.chatty {\n-\t\t// Print directly to root's io.Writer so there is no delay.\n-\t\troot := t.parent\n-\t\tfor ; root.parent != nil; root = root.parent {\n-\t\t}\n-\t\troot.mu.Lock()\n-\t\tprinter.Fprint(root.w, t.name, fmt.Sprintf(\"=== CONT  %s\\n\", t.name))\n-\t\troot.mu.Unlock()\n+\tif t.chatty != nil {\n+\t\tt.chatty.Updatef(t.name, \"=== CONT  %s\\n\", t.name)\n \t}\n \n \tt.start = time.Now()\n@@ -1197,14 +1193,8 @@ func (t *T) Run(name string, f func(t *T)) bool {\n \t}\n \tt.w = indenter{&t.common}\n \n-\tif t.chatty {\n-\t\t// Print directly to root's io.Writer so there is no delay.\n-\t\troot := t.parent\n-\t\tfor ; root.parent != nil; root = root.parent {\n-\t\t}\n-\t\troot.mu.Lock()\n-\t\tprinter.Fprint(root.w, t.name, fmt.Sprintf(\"=== RUN   %s\\n\", t.name))\n-\t\troot.mu.Unlock()\n+\tif t.chatty != nil {\n+\t\tt.chatty.Updatef(t.name, \"=== RUN   %s\\n\", t.name)\n \t}\n \t// Instead of reducing the running count of this test before calling the\n \t// tRunner and increasing it afterwards, we rely on tRunner keeping the\n@@ -1369,8 +1359,6 @@ func (m *M) Run() (code int) {\n \t\tflag.Parse()\n \t}\n \n-\tprinter = newTestPrinter(Verbose())\n-\n \tif *parallel < 1 {\n \t\tfmt.Fprintln(os.Stderr, \"testing: -parallel can only be given a positive integer\")\n \t\tflag.Usage()\n@@ -1415,7 +1403,7 @@ func (t *T) report() {\n \tformat := \"--- %s: %s (%s)\\n\"\n \tif t.Failed() {\n \t\tt.flushToParent(t.name, format, \"FAIL\", t.name, dstr)\n-\t} else if t.chatty {\n+\t} else if t.chatty != nil {\n \t\tif t.Skipped() {\n \t\t\tt.flushToParent(t.name, format, \"SKIP\", t.name, dstr)\n \t\t} else {\n@@ -1476,10 +1464,12 @@ func runTests(matchString func(pat, str string) (bool, error), tests []InternalT\n \t\t\t\t\tsignal:  make(chan bool),\n \t\t\t\t\tbarrier: make(chan bool),\n \t\t\t\t\tw:       os.Stdout,\n-\t\t\t\t\tchatty:  *chatty,\n \t\t\t\t},\n \t\t\t\tcontext: ctx,\n \t\t\t}\n+\t\t\tif Verbose() {\n+\t\t\t\tt.chatty = newChattyPrinter(t.w)\n+\t\t\t}\n \t\t\ttRunner(t, func(t *T) {\n \t\t\t\tfor _, test := range tests {\n \t\t\t\t\tt.Run(test.Name, test.F)"}, {"sha": "919c7492510096d6b245002a86618a055a56e422", "filename": "libgo/misc/cgo/test/testdata/issue41761.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue41761.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue41761.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue41761.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+   typedef struct S S;\n+*/\n+import \"C\"\n+\n+import (\n+\t\"cgotest/issue41761a\"\n+\t\"testing\"\n+)\n+\n+func test41761(t *testing.T) {\n+\tvar x issue41761a.T\n+\t_ = (*C.struct_S)(x.X)\n+}"}, {"sha": "ca5c18191eb31de331d99da51e51fe692ec4f209", "filename": "libgo/misc/cgo/test/testdata/issue41761a/a.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue41761a%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668894d7b584b40ddb46e9e2e2ffa637f4d732e5/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue41761a%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue41761a%2Fa.go?ref=668894d7b584b40ddb46e9e2e2ffa637f4d732e5", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue41761a\n+\n+/*\n+   typedef struct S S;\n+*/\n+import \"C\"\n+\n+type T struct {\n+\tX *C.S\n+}"}]}