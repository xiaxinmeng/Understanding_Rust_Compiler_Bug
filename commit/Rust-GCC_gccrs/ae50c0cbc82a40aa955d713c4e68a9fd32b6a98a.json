{"sha": "ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU1MGMwY2JjODJhNDBhYTk1NWQ3MTNjNGU2OGE5ZmQzMmI2YTk4YQ==", "commit": {"author": {"name": "Thomas Neumann", "email": "tneumann@gcc.gnu.org", "date": "2007-06-05T15:41:04Z"}, "committer": {"name": "Thomas Neumann", "email": "tneumann@gcc.gnu.org", "date": "2007-06-05T15:41:04Z"}, "message": "cfg.c (init_flow): Use type safe memory macros.\n\n\t* cfg.c (init_flow): Use type safe memory macros.\n\t(alloc_block): Likewise.\n\t(unchecked_make_edge): Likewise.\n\t(dump_flow_info): Avoid using C++ keywords as variable names.\n\t(copy_original_table_clear): Cast according to the coding conventions.\n\t(copy_original_table_set): Likewise.\n\t* cfgexpand (label_rtx_for_bb): Likewise.\n\t(expand_gim\u00fcle_basic_block): Likewise.\n\t* cfghooks.c (dump_bb): Likewise.\n\t(lv_adjust_loop_header_phi): Avoid using C++ keywords as variable names.\n\t(lv_add_condition_to_bb): Likewise.\n\t* cfglayout (relink_block_chain): Cast according to the coding\n\tconventions.\n\t(fixup_reorder_chain): Likewise.\n\t(fixup_fallthru_exit_predecessor): Likewise.\n\t* cfgloop.c (glb_enum_p): Likewise.\n\t(get_exit_description): Likewise.\n\t(dump_recorded_exit): Likewise.\n\t* cfgloop.h (enum loop_estimation): Move out of struct scope...\n\t(struct loop): ... from here.\n\t* cfgloopmanip (rpe_enum_p): Cast according to the coding conventions.\n\t* cfgrtl.c (rtl_create_basic_block): Likewise.\n\t(rtl_split_block): Likewise.\n\t(rtl_dump_bb): Likewise.\n\t(cfg_layout_split_block): Likewise.\n\t(init_rtl_bb_info): Use typesafe memory macros.\n\n\t* graphds.h (struct graph_edge): Renamed edge to graph_edge.\n\t* graphds.h: Updated all usages of edge to graph_edge.\n\t* graphds.c: Likewise.\n\t* cfgloopanal.c: Likewise.\n\nFrom-SVN: r125336", "tree": {"sha": "f12abaf00f4ac040bcdbeb67b7ce6b482e1ffff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f12abaf00f4ac040bcdbeb67b7ce6b482e1ffff4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/comments", "author": null, "committer": null, "parents": [{"sha": "3fe5bcaf11efc74817ef5b4d0b612b6f5cb21388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe5bcaf11efc74817ef5b4d0b612b6f5cb21388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fe5bcaf11efc74817ef5b4d0b612b6f5cb21388"}], "stats": {"total": 181, "additions": 110, "deletions": 71}, "files": [{"sha": "dd3b451854be485c4faa290acd0c451cad887c9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -1,3 +1,37 @@\n+2007-06-05  Thomas Neumann  <tneumann@users.sourceforge.net>\n+\n+\t* cfg.c (init_flow): Use type safe memory macros.\n+\t(alloc_block): Likewise.\n+\t(unchecked_make_edge): Likewise.\n+\t(dump_flow_info): Avoid using C++ keywords as variable names.\n+\t(copy_original_table_clear): Cast according to the coding conventions.\n+\t(copy_original_table_set): Likewise.\n+\t* cfgexpand (label_rtx_for_bb): Likewise.\n+\t(expand_gim\u00fcle_basic_block): Likewise.\n+\t* cfghooks.c (dump_bb): Likewise.\n+\t(lv_adjust_loop_header_phi): Avoid using C++ keywords as variable names.\n+\t(lv_add_condition_to_bb): Likewise.\n+\t* cfglayout (relink_block_chain): Cast according to the coding\n+\tconventions.\n+\t(fixup_reorder_chain): Likewise.\n+\t(fixup_fallthru_exit_predecessor): Likewise.\n+\t* cfgloop.c (glb_enum_p): Likewise.\n+\t(get_exit_description): Likewise.\n+\t(dump_recorded_exit): Likewise.\n+\t* cfgloop.h (enum loop_estimation): Move out of struct scope...\n+\t(struct loop): ... from here.\n+\t* cfgloopmanip (rpe_enum_p): Cast according to the coding conventions.\n+\t* cfgrtl.c (rtl_create_basic_block): Likewise.\n+\t(rtl_split_block): Likewise.\n+\t(rtl_dump_bb): Likewise.\n+\t(cfg_layout_split_block): Likewise.\n+\t(init_rtl_bb_info): Use typesafe memory macros.\n+\n+\t* graphds.h (struct graph_edge): Renamed edge to graph_edge.\n+\t* graphds.h: Updated all usages of edge to graph_edge.\n+\t* graphds.c: Likewise.\n+\t* cfgloopanal.c: Likewise.\n+\n 2007-06-05  Ian Lance Taylor  <iant@google.com>\n \n \t* tree-vrp.c (compare_values_warnv): Check TREE_NO_WARNING on a\n@@ -7216,7 +7250,7 @@\n \n \t* c-common.c (warn_logical_operator): Fix condition.\n \n-2007-03-10  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+2007-03-10  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \t* config/i386/darwin.h (DARWIN_MINVERSION_SPEC): Add missing\n \tquotation mark."}, {"sha": "cbaf8f658aa1998520cec3558722157dd29b8f55", "filename": "gcc/cfg.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -83,11 +83,11 @@ void\n init_flow (void)\n {\n   if (!cfun->cfg)\n-    cfun->cfg = ggc_alloc_cleared (sizeof (struct control_flow_graph));\n+    cfun->cfg = GGC_CNEW (struct control_flow_graph);\n   n_edges = 0;\n-  ENTRY_BLOCK_PTR = ggc_alloc_cleared (sizeof (struct basic_block_def));\n+  ENTRY_BLOCK_PTR = GGC_CNEW (struct basic_block_def);\n   ENTRY_BLOCK_PTR->index = ENTRY_BLOCK;\n-  EXIT_BLOCK_PTR = ggc_alloc_cleared (sizeof (struct basic_block_def));\n+  EXIT_BLOCK_PTR = GGC_CNEW (struct basic_block_def);\n   EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n   ENTRY_BLOCK_PTR->next_bb = EXIT_BLOCK_PTR;\n   EXIT_BLOCK_PTR->prev_bb = ENTRY_BLOCK_PTR;\n@@ -134,7 +134,7 @@ basic_block\n alloc_block (void)\n {\n   basic_block bb;\n-  bb = ggc_alloc_cleared (sizeof (*bb));\n+  bb = GGC_CNEW (struct basic_block_def);\n   return bb;\n }\n \n@@ -264,7 +264,7 @@ edge\n unchecked_make_edge (basic_block src, basic_block dst, int flags)\n {\n   edge e;\n-  e = ggc_alloc_cleared (sizeof (*e));\n+  e = GGC_CNEW (struct edge_def);\n   n_edges++;\n \n   e->src = src;\n@@ -542,7 +542,7 @@ dump_flow_info (FILE *file, int flags)\n       for (i = FIRST_PSEUDO_REGISTER; i < max; i++)\n \tif (REG_N_REFS (i))\n \t  {\n-\t    enum reg_class class, altclass;\n+\t    enum reg_class prefclass, altclass;\n \n \t    fprintf (file, \"\\nRegister %d used %d times across %d insns\",\n \t\t     i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n@@ -563,17 +563,17 @@ dump_flow_info (FILE *file, int flags)\n \t\t&& PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n \t      fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n \n-\t    class = reg_preferred_class (i);\n+\t    prefclass = reg_preferred_class (i);\n \t    altclass = reg_alternate_class (i);\n-\t    if (class != GENERAL_REGS || altclass != ALL_REGS)\n+\t    if (prefclass != GENERAL_REGS || altclass != ALL_REGS)\n \t      {\n-\t\tif (altclass == ALL_REGS || class == ALL_REGS)\n-\t\t  fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n+\t\tif (altclass == ALL_REGS || prefclass == ALL_REGS)\n+\t\t  fprintf (file, \"; pref %s\", reg_class_names[(int) prefclass]);\n \t\telse if (altclass == NO_REGS)\n-\t\t  fprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n+\t\t  fprintf (file, \"; %s or none\", reg_class_names[(int) prefclass]);\n \t\telse\n \t\t  fprintf (file, \"; pref %s, else %s\",\n-\t\t\t   reg_class_names[(int) class],\n+\t\t\t   reg_class_names[(int) prefclass],\n \t\t\t   reg_class_names[(int) altclass]);\n \t      }\n \n@@ -1107,7 +1107,7 @@ copy_original_table_clear (htab_t tab, unsigned obj)\n   if (!slot)\n     return;\n \n-  elt = *slot;\n+  elt = (struct htab_bb_copy_original_entry *) *slot;\n   htab_clear_slot (tab, slot);\n   pool_free (original_copy_bb_pool, elt);\n }\n@@ -1129,7 +1129,8 @@ copy_original_table_set (htab_t tab, unsigned obj, unsigned val)\n \t\thtab_find_slot (tab, &key, INSERT);\n   if (!*slot)\n     {\n-      *slot = pool_alloc (original_copy_bb_pool);\n+      *slot = (struct htab_bb_copy_original_entry *)\n+\t\tpool_alloc (original_copy_bb_pool);\n       (*slot)->index1 = obj;\n     }\n   (*slot)->index2 = val;"}, {"sha": "24ec32d76c090b1cd368d4375a8185350cd00b3e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -1262,7 +1262,7 @@ label_rtx_for_bb (basic_block bb)\n \n   elt = pointer_map_contains (lab_rtx_for_bb, bb);\n   if (elt)\n-    return *elt;\n+    return (rtx) *elt;\n \n   /* Find the tree label if it is present.  */\n      \n@@ -1281,7 +1281,7 @@ label_rtx_for_bb (basic_block bb)\n \n   elt = pointer_map_insert (lab_rtx_for_bb, bb);\n   *elt = gen_label_rtx ();\n-  return *elt;\n+  return (rtx) *elt;\n }\n \n /* A subroutine of expand_gimple_basic_block.  Expand one COND_EXPR.\n@@ -1538,7 +1538,7 @@ expand_gimple_basic_block (basic_block bb)\n \t}\n \n       if (elt)\n-\temit_label (*elt);\n+\temit_label ((rtx) *elt);\n \n       /* Java emits line number notes in the top of labels.\n \t ??? Make this go away once line number notes are obsoleted.  */"}, {"sha": "8852ca91f4f771d697242fa16dbd09843a3737b8", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -259,7 +259,7 @@ dump_bb (basic_block bb, FILE *outf, int indent)\n   edge_iterator ei;\n   char *s_indent;\n \n-  s_indent = alloca ((size_t) indent + 1);\n+  s_indent = (char *) alloca ((size_t) indent + 1);\n   memset (s_indent, ' ', (size_t) indent);\n   s_indent[indent] = '\\0';\n \n@@ -1043,19 +1043,19 @@ extract_cond_bb_edges (basic_block b, edge *e1, edge *e2)\n    new condition basic block that guards the versioned loop.  */\n void\n lv_adjust_loop_header_phi (basic_block first, basic_block second,\n-\t\t\t   basic_block new, edge e)\n+\t\t\t   basic_block new_block, edge e)\n {\n   if (cfg_hooks->lv_adjust_loop_header_phi)\n-    cfg_hooks->lv_adjust_loop_header_phi (first, second, new, e);\n+    cfg_hooks->lv_adjust_loop_header_phi (first, second, new_block, e);\n }\n \n /* Conditions in trees and RTL are different so we need\n    a different handling when we add the condition to the\n    versioning code.  */\n void\n lv_add_condition_to_bb (basic_block first, basic_block second,\n-\t\t\tbasic_block new, void *cond)\n+\t\t\tbasic_block new_block, void *cond)\n {\n   gcc_assert (cfg_hooks->lv_add_condition_to_bb);\n-  cfg_hooks->lv_add_condition_to_bb (first, second, new, cond);\n+  cfg_hooks->lv_add_condition_to_bb (first, second, new_block, cond);\n }"}, {"sha": "3c3654d0459efe2fe036ca4d01783698ed9cb6ab", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -627,7 +627,7 @@ relink_block_chain (bool stay_in_cfglayout_mode)\n       fprintf (dump_file, \"Reordered sequence:\\n\");\n       for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n \t   bb;\n-\t   bb = bb->aux, index++)\n+\t   bb = (basic_block) bb->aux, index++)\n \t{\n \t  fprintf (dump_file, \" %i \", index);\n \t  if (get_bb_original (bb))\n@@ -645,7 +645,7 @@ relink_block_chain (bool stay_in_cfglayout_mode)\n   /* Now reorder the blocks.  */\n   prev_bb = ENTRY_BLOCK_PTR;\n   bb = ENTRY_BLOCK_PTR->next_bb;\n-  for (; bb; prev_bb = bb, bb = bb->aux)\n+  for (; bb; prev_bb = bb, bb = (basic_block) bb->aux)\n     {\n       bb->prev_bb = prev_bb;\n       prev_bb->next_bb = bb;\n@@ -693,7 +693,7 @@ fixup_reorder_chain (void)\n   /* First do the bulk reordering -- rechain the blocks without regard to\n      the needed changes to jumps and labels.  */\n \n-  for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = bb->aux)\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = (basic_block) bb->aux)\n     {\n       if (bb->il.rtl->header)\n \t{\n@@ -736,7 +736,7 @@ fixup_reorder_chain (void)\n   /* Now add jumps and labels as needed to match the blocks new\n      outgoing edges.  */\n \n-  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = bb->aux)\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = (basic_block) bb->aux)\n     {\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n@@ -951,11 +951,11 @@ fixup_fallthru_exit_predecessor (void)\n \t}\n \n       while (c->aux != bb)\n-\tc = c->aux;\n+\tc = (basic_block) c->aux;\n \n       c->aux = bb->aux;\n       while (c->aux)\n-\tc = c->aux;\n+\tc = (basic_block) c->aux;\n \n       c->aux = bb;\n       bb->aux = NULL;"}, {"sha": "8e1edbddc68811804a2d661caf6c6c0586293b72", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -776,7 +776,7 @@ flow_bb_inside_loop_p (const struct loop *loop, const basic_block bb)\n static bool\n glb_enum_p (basic_block bb, void *glb_loop)\n {\n-  struct loop *loop = glb_loop;\n+  struct loop *loop = (struct loop *) glb_loop;\n   return (bb != loop->header\n \t  && dominated_by_p (CDI_DOMINATORS, bb, loop->header));\n }\n@@ -974,8 +974,8 @@ loop_exit_free (void *ex)\n static struct loop_exit *\n get_exit_descriptions (edge e)\n {\n-  return htab_find_with_hash (current_loops->exits, e,\n-\t\t\t      htab_hash_pointer (e));\n+  return (struct loop_exit *) htab_find_with_hash (current_loops->exits, e,\n+\t\t\t                           htab_hash_pointer (e));\n }\n \n /* Updates the lists of loop exits in that E appears.\n@@ -1075,14 +1075,14 @@ record_loop_exits (void)\n static int\n dump_recorded_exit (void **slot, void *file)\n {\n-  struct loop_exit *exit = *slot;\n+  struct loop_exit *exit = (struct loop_exit *) *slot;\n   unsigned n = 0;\n   edge e = exit->e;\n \n   for (; exit != NULL; exit = exit->next_e)\n     n++;\n \n-  fprintf (file, \"Edge %d->%d exits %u loops\\n\",\n+  fprintf ((FILE*) file, \"Edge %d->%d exits %u loops\\n\",\n \t   e->src->index, e->dest->index, n);\n \n   return 1;"}, {"sha": "7b042ebe462dd65cb91d961617d4985354e810a6", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -90,6 +90,16 @@ DEF_VEC_P (loop_p);\n DEF_VEC_ALLOC_P (loop_p, heap);\n DEF_VEC_ALLOC_P (loop_p, gc);\n \n+/* An integer estimation of the number of iterations.  Estimate_state\n+   describes what is the state of the estimation.  */\n+enum loop_estimation\n+{\n+  /* Estimate was not computed yet.  */\n+  EST_NOT_COMPUTED,\n+  /* Estimate is ready.  */\n+  EST_AVAILABLE\n+};\n+\n /* Structure to hold information for each natural loop.  */\n struct loop GTY ((chain_next (\"%h.next\")))\n {\n@@ -135,13 +145,7 @@ struct loop GTY ((chain_next (\"%h.next\")))\n \n   /* An integer estimation of the number of iterations.  Estimate_state\n      describes what is the state of the estimation.  */\n-  enum\n-    {\n-      /* Estimate was not computed yet.  */\n-      EST_NOT_COMPUTED,\n-      /* Estimate is ready.  */\n-      EST_AVAILABLE\n-    } estimate_state;\n+  enum loop_estimation estimate_state;\n \n   /* An integer guaranteed to bound the number of iterations of the loop\n      from above.  */"}, {"sha": "53d36d94ffccab812386c2a950b4f6e133e64be1", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -55,9 +55,9 @@ just_once_each_iteration_p (const struct loop *loop, basic_block bb)\n    same scc.  */\n \n static void\n-check_irred (struct graph *g, struct edge *e)\n+check_irred (struct graph *g, struct graph_edge *e)\n {\n-  edge real = e->data;\n+  edge real = (edge) e->data;\n \n   /* All edges should lead from a component with higher number to the\n      one with lower one.  */"}, {"sha": "92ab088ea40fd78319e1d984b026f498449b0e65", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -49,7 +49,7 @@ static void unloop (struct loop *, bool *);\n static bool\n rpe_enum_p (basic_block bb, void *data)\n {\n-  return dominated_by_p (CDI_DOMINATORS, bb, data);\n+  return dominated_by_p (CDI_DOMINATORS, bb, (basic_block) data);\n }\n \n /* Remove basic blocks BBS.  NBBS is the number of the basic blocks.  */"}, {"sha": "11deebc2cd945ee1df92939e58b81c451dc8558b", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -321,7 +321,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n static basic_block\n rtl_create_basic_block (void *headp, void *endp, basic_block after)\n {\n-  rtx head = headp, end = endp;\n+  rtx head = (rtx) headp, end = (rtx) endp;\n   basic_block bb;\n \n   /* Grow the basic block array if needed.  */\n@@ -474,7 +474,7 @@ static basic_block\n rtl_split_block (basic_block bb, void *insnp)\n {\n   basic_block new_bb;\n-  rtx insn = insnp;\n+  rtx insn = (rtx) insnp;\n   edge e;\n   edge_iterator ei;\n \n@@ -1519,7 +1519,7 @@ rtl_dump_bb (basic_block bb, FILE *outf, int indent)\n   rtx last;\n   char *s_indent;\n \n-  s_indent = alloca ((size_t) indent + 1);\n+  s_indent = (char *) alloca ((size_t) indent + 1);\n   memset (s_indent, ' ', (size_t) indent);\n   s_indent[indent] = '\\0';\n \n@@ -2300,7 +2300,7 @@ purge_all_dead_edges (void)\n static basic_block\n cfg_layout_split_block (basic_block bb, void *insnp)\n {\n-  rtx insn = insnp;\n+  rtx insn = (rtx) insnp;\n   basic_block new_bb = rtl_split_block (bb, insn);\n \n   new_bb->il.rtl->footer = bb->il.rtl->footer;\n@@ -2879,7 +2879,7 @@ void\n init_rtl_bb_info (basic_block bb)\n {\n   gcc_assert (!bb->il.rtl);\n-  bb->il.rtl = ggc_alloc_cleared (sizeof (struct rtl_bb_info));\n+  bb->il.rtl = GGC_CNEW (struct rtl_bb_info);\n }\n \n "}, {"sha": "da5a4e52e0b6274e2c4fbac15b39d0bb73787a42", "filename": "gcc/graphds.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fgraphds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fgraphds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.c?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -34,7 +34,7 @@ void\n dump_graph (FILE *f, struct graph *g)\n {\n   int i;\n-  struct edge *e;\n+  struct graph_edge *e;\n \n   for (i = 0; i < g->n_vertices; i++)\n     {\n@@ -69,10 +69,10 @@ new_graph (int n_vertices)\n \n /* Adds an edge from F to T to graph G.  The new edge is returned.  */\n \n-struct edge *\n+struct graph_edge *\n add_edge (struct graph *g, int f, int t)\n {\n-  struct edge *e = XNEW (struct edge);\n+  struct graph_edge *e = XNEW (struct graph_edge);\n   struct vertex *vf = &g->vertices[f], *vt = &g->vertices[t];\n \n \n@@ -95,7 +95,7 @@ identify_vertices (struct graph *g, int v, int u)\n {\n   struct vertex *vv = &g->vertices[v];\n   struct vertex *uu = &g->vertices[u];\n-  struct edge *e, *next;\n+  struct graph_edge *e, *next;\n \n   for (e = uu->succ; e; e = next)\n     {\n@@ -122,7 +122,7 @@ identify_vertices (struct graph *g, int v, int u)\n    direction given by FORWARD.  */\n \n static inline int\n-dfs_edge_src (struct edge *e, bool forward)\n+dfs_edge_src (struct graph_edge *e, bool forward)\n {\n   return forward ? e->src : e->dest;\n }\n@@ -131,16 +131,16 @@ dfs_edge_src (struct edge *e, bool forward)\n    the direction given by FORWARD.  */\n \n static inline int\n-dfs_edge_dest (struct edge *e, bool forward)\n+dfs_edge_dest (struct graph_edge *e, bool forward)\n {\n   return forward ? e->dest : e->src;\n }\n \n /* Helper function for graphds_dfs.  Returns the first edge after E (including\n    E), in the graph direction given by FORWARD, that belongs to SUBGRAPH.  */\n \n-static inline struct edge *\n-foll_in_subgraph (struct edge *e, bool forward, bitmap subgraph)\n+static inline struct graph_edge *\n+foll_in_subgraph (struct graph_edge *e, bool forward, bitmap subgraph)\n {\n   int d;\n \n@@ -162,10 +162,10 @@ foll_in_subgraph (struct edge *e, bool forward, bitmap subgraph)\n /* Helper function for graphds_dfs.  Select the first edge from V in G, in the\n    direction given by FORWARD, that belongs to SUBGRAPH.  */\n \n-static inline struct edge *\n+static inline struct graph_edge *\n dfs_fst_edge (struct graph *g, int v, bool forward, bitmap subgraph)\n {\n-  struct edge *e;\n+  struct graph_edge *e;\n \n   e = (forward ? g->vertices[v].succ : g->vertices[v].pred);\n   return foll_in_subgraph (e, forward, subgraph);\n@@ -174,8 +174,8 @@ dfs_fst_edge (struct graph *g, int v, bool forward, bitmap subgraph)\n /* Helper function for graphds_dfs.  Returns the next edge after E, in the\n    graph direction given by FORWARD, that belongs to SUBGRAPH.  */\n \n-static inline struct edge *\n-dfs_next_edge (struct edge *e, bool forward, bitmap subgraph)\n+static inline struct graph_edge *\n+dfs_next_edge (struct graph_edge *e, bool forward, bitmap subgraph)\n {\n   return foll_in_subgraph (forward ? e->succ_next : e->pred_next,\n \t\t\t   forward, subgraph);\n@@ -192,8 +192,8 @@ graphds_dfs (struct graph *g, int *qs, int nq, VEC (int, heap) **qt,\n \t     bool forward, bitmap subgraph)\n {\n   int i, tick = 0, v, comp = 0, top;\n-  struct edge *e;\n-  struct edge **stack = XNEWVEC (struct edge *, g->n_vertices);\n+  struct graph_edge *e;\n+  struct graph_edge **stack = XNEWVEC (struct graph_edge *, g->n_vertices);\n   bitmap_iterator bi;\n   unsigned av;\n \n@@ -314,7 +314,7 @@ graphds_scc (struct graph *g, bitmap subgraph)\n void\n for_each_edge (struct graph *g, graphds_edge_callback callback)\n {\n-  struct edge *e;\n+  struct graph_edge *e;\n   int i;\n \n   for (i = 0; i < g->n_vertices; i++)\n@@ -327,7 +327,7 @@ for_each_edge (struct graph *g, graphds_edge_callback callback)\n void\n free_graph (struct graph *g)\n {\n-  struct edge *e, *n;\n+  struct graph_edge *e, *n;\n   struct vertex *v;\n   int i;\n \n@@ -406,7 +406,7 @@ graphds_domtree (struct graph *g, int entry,\n   int *marks = XCNEWVEC (int, g->n_vertices);\n   int mark = 1, i, v, idom;\n   bool changed = true;\n-  struct edge *e;\n+  struct graph_edge *e;\n \n   /* We use a slight modification of the standard iterative algorithm, as\n      described in"}, {"sha": "23f7fb93784dee2d7df7bb862f9f54efcbad3968", "filename": "gcc/graphds.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fgraphds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a/gcc%2Fgraphds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.h?ref=ae50c0cbc82a40aa955d713c4e68a9fd32b6a98a", "patch": "@@ -21,10 +21,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* Structure representing edge of a graph.  */\n \n-struct edge\n+struct graph_edge\n {\n   int src, dest;\t/* Source and destination.  */\n-  struct edge *pred_next, *succ_next;\n+  struct graph_edge *pred_next, *succ_next;\n \t\t\t/* Next edge in predecessor and successor lists.  */\n   void *data;\t\t/* Data attached to the edge.  */\n };\n@@ -33,7 +33,7 @@ struct edge\n \n struct vertex\n {\n-  struct edge *pred, *succ;\n+  struct graph_edge *pred, *succ;\n \t\t\t/* Lists of predecessors and successors.  */\n   int component;\t/* Number of dfs restarts before reaching the\n \t\t\t   vertex.  */\n@@ -52,12 +52,12 @@ struct graph\n \n struct graph *new_graph (int);\n void dump_graph (FILE *, struct graph *);\n-struct edge *add_edge (struct graph *, int, int);\n+struct graph_edge *add_edge (struct graph *, int, int);\n void identify_vertices (struct graph *, int, int);\n int graphds_dfs (struct graph *, int *, int,\n \t\t VEC (int, heap) **, bool, bitmap);\n int graphds_scc (struct graph *, bitmap);\n void graphds_domtree (struct graph *, int, int *, int *, int *);\n-typedef void (*graphds_edge_callback) (struct graph *, struct edge *);\n+typedef void (*graphds_edge_callback) (struct graph *, struct graph_edge *);\n void for_each_edge (struct graph *, graphds_edge_callback);\n void free_graph (struct graph *g);"}]}