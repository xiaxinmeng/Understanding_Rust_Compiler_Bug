{"sha": "bb88593883c783c600c89b8d1e5d7973c90d3f5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI4ODU5Mzg4M2M3ODNjNjAwYzg5YjhkMWU1ZDc5NzNjOTBkM2Y1YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-10-24T07:59:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-10-24T07:59:41Z"}, "message": "PR c++/12698, c++/12699, c++/12700, c++/12566\n\ncp:\n\tPR c++/12698, c++/12699, c++/12700, c++/12566\n\t* cp-tree.h (THUNK_ALIAS_P, THUNK_ALIAS): New.\n\t(debug_class, debug_thunks): New.\n\t* class.c (dump_class_hierarchy_1): New break out from ...\n\t(dump_class_hierarchy): ... here.\n\t(dump_thunk, debug_thunks, debug_class): New.\n\t(update_vtable_entry_for_fn): Add ssizetype casts. Correct\n\tcontinued search for primary binfo via virtual.\n\t(build_vtbl_initializer): Follow covariant thunk alias.\n\t* method.c (make_thunk): Clear DECL_THUNKS of the thunk.\n\t(finish_thunk): Look for an alias of the covariant thunk and point\n\tto it.\n\t(use_thunk): We should never use an alias.\n\t* semantics.c (emit_associated_thunks): Do not emit aliases.\n\n\tPR c++/12566\n\t* cp-tree.h (cp_fname_init): Add TYPE pointer param.\n\t* decl.c (cp_fname_init): Add TYPE pointer param. Set it. Don't\n\tcreate an ad-hoc ERROR_MARK.\n\t(cp_make_fname_decl): Adjust.\n\t* pt.c (tsubst_expr): Adjust.\ntestsuite:\n\tPR c++/12698, c++/12699, c++/12700, c++/12566\n\t* g++.dg/inherit/covariant9.C: New test.\n\t* g++.dg/inherit/covariant10.C: New test.\n\t* g++.dg/inherit/covariant11.C: New test.\n\nFrom-SVN: r72882", "tree": {"sha": "30f00d7a2377783a5112afcd6c22c5508f1c6309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30f00d7a2377783a5112afcd6c22c5508f1c6309"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb88593883c783c600c89b8d1e5d7973c90d3f5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb88593883c783c600c89b8d1e5d7973c90d3f5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb88593883c783c600c89b8d1e5d7973c90d3f5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb88593883c783c600c89b8d1e5d7973c90d3f5a/comments", "author": null, "committer": null, "parents": [{"sha": "0f3340356d5a1b7847301b0d20161b242cfc5dbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f3340356d5a1b7847301b0d20161b242cfc5dbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f3340356d5a1b7847301b0d20161b242cfc5dbd"}], "stats": {"total": 317, "additions": 274, "deletions": 43}, "files": [{"sha": "536feec51ed7c1a0c2af1f01fdeb594cd52da4bf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -1,3 +1,27 @@\n+2003-10-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/12698, c++/12699, c++/12700, c++/12566\n+\t* cp-tree.h (THUNK_ALIAS_P, THUNK_ALIAS): New.\n+\t(debug_class, debug_thunks): New.\n+\t* class.c (dump_class_hierarchy_1): New break out from ...\n+\t(dump_class_hierarchy): ... here.\n+\t(dump_thunk, debug_thunks, debug_class): New.\n+\t(update_vtable_entry_for_fn): Add ssizetype casts. Correct\n+\tcontinued search for primary binfo via virtual.\n+\t(build_vtbl_initializer): Follow covariant thunk alias.\n+\t* method.c (make_thunk): Clear DECL_THUNKS of the thunk.\n+\t(finish_thunk): Look for an alias of the covariant thunk and point\n+\tto it.\n+\t(use_thunk): We should never use an alias.\n+\t* semantics.c (emit_associated_thunks): Do not emit aliases.\n+\n+\tPR c++/12566\n+\t* cp-tree.h (cp_fname_init): Add TYPE pointer param.\n+\t* decl.c (cp_fname_init): Add TYPE pointer param. Set it. Don't\n+\tcreate an ad-hoc ERROR_MARK.\n+\t(cp_make_fname_decl): Adjust.\n+\t* pt.c (tsubst_expr): Adjust.\n+\n 2003-10-23  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/12726"}, {"sha": "123d1a4ea0f7270e3c56b5cc592480f6a35c5ea7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 91, "deletions": 23, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -166,9 +166,11 @@ static int make_new_vtable (tree, tree);\n static int maybe_indent_hierarchy (FILE *, int, int);\n static tree dump_class_hierarchy_r (FILE *, int, tree, tree, int);\n static void dump_class_hierarchy (tree);\n+static void dump_class_hierarchy_1 (FILE *, int, tree);\n static void dump_array (FILE *, tree);\n static void dump_vtable (tree, tree, tree);\n static void dump_vtt (tree, tree);\n+static void dump_thunk (FILE *, int, tree);\n static tree build_vtable (tree, tree, tree);\n static void initialize_vtable (tree, tree);\n static void initialize_array (tree, tree);\n@@ -2178,7 +2180,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t  if (thunk_binfo && (kind == bk_via_virtual\n \t\t\t      || !BINFO_OFFSET_ZEROP (thunk_binfo)))\n \t    {\n-\t      tree offset = BINFO_OFFSET (thunk_binfo);\n+\t      tree offset = convert (ssizetype, BINFO_OFFSET (thunk_binfo));\n \n \t      if (kind == bk_via_virtual)\n \t\t{\n@@ -2188,8 +2190,9 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t\t    thunk_binfo = BINFO_INHERITANCE_CHAIN (thunk_binfo);\n \n \t\t  virtual_offset = thunk_binfo;\n-\t\t  offset = size_binop (MINUS_EXPR, offset,\n-\t\t\t\t       BINFO_OFFSET (virtual_offset));\n+\t\t  offset = size_diffop\n+\t\t    (offset, convert\n+\t\t     (ssizetype, BINFO_OFFSET (virtual_offset)));\n \t\t}\n \t      if (fixed_offset)\n \t\t/* There was an existing fixed offset, this must be\n@@ -2251,15 +2254,13 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n    \t primary binfo which first introduced the function into the\n    \t vtable.  If that enters a virtual base, we must use a vcall\n    \t this-adjusting thunk.  Bleah! */\n-      tree probe;\n+      tree probe = first_defn;\n+\n+      while ((probe = get_primary_binfo (probe))\n+\t     && (unsigned) list_length (BINFO_VIRTUALS (probe)) > ix)\n+\tif (TREE_VIA_VIRTUAL (probe))\n+\t  virtual_base = probe;\n       \n-      for (probe = first_defn; (probe = get_primary_binfo (probe));)\n-\t{\n-\t  if (TREE_VIA_VIRTUAL (probe))\n-\t    virtual_base = probe;\n-\t  if ((unsigned) list_length (BINFO_VIRTUALS (probe)) <= ix)\n-\t    break;\n-\t}\n       if (virtual_base)\n \t/* Even if we find a virtual base, the correct delta is\n \t   between the overrider and the binfo we're building a vtable\n@@ -2273,8 +2274,8 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n   if (virtual_base)\n     /* The `this' pointer needs to be adjusted from the declaration to\n        the nearest virtual base.  */\n-    delta = size_diffop (BINFO_OFFSET (virtual_base),\n-\t\t\t BINFO_OFFSET (first_defn));\n+    delta = size_diffop (convert (ssizetype, BINFO_OFFSET (virtual_base)),\n+\t\t\t convert (ssizetype, BINFO_OFFSET (first_defn)));\n   else if (lost)\n     /* If the nearest definition is in a lost primary, we don't need an\n        entry in our vtable.  Except possibly in a constructor vtable,\n@@ -2286,8 +2287,9 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n        BINFO to pointing at the base where the final overrider\n        appears.  */\n     virtual_covariant:\n-    delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)),\n-\t\t\t BINFO_OFFSET (binfo));\n+    delta = size_diffop (convert (ssizetype,\n+\t\t\t\t  BINFO_OFFSET (TREE_VALUE (overrider))),\n+\t\t\t convert (ssizetype, BINFO_OFFSET (binfo)));\n \n   modify_vtable_entry (t, binfo, overrider_fn, delta, virtuals);\n \n@@ -6575,14 +6577,8 @@ dump_class_hierarchy_r (FILE *stream,\n /* Dump the BINFO hierarchy for T.  */\n \n static void\n-dump_class_hierarchy (tree t)\n+dump_class_hierarchy_1 (FILE *stream, int flags, tree t)\n {\n-  int flags;\n-  FILE *stream = dump_begin (TDI_class, &flags);\n-\n-  if (!stream)\n-    return;\n-  \n   fprintf (stream, \"Class %s\\n\", type_as_string (t, TFF_PLAIN_IDENTIFIER));\n   fprintf (stream, \"   size=%lu align=%lu\\n\",\n \t   (unsigned long)(tree_low_cst (TYPE_SIZE (t), 0) / BITS_PER_UNIT),\n@@ -6594,7 +6590,27 @@ dump_class_hierarchy (tree t)\n \t\t\t   / BITS_PER_UNIT));\n   dump_class_hierarchy_r (stream, flags, TYPE_BINFO (t), TYPE_BINFO (t), 0);\n   fprintf (stream, \"\\n\");\n-  dump_end (TDI_class, stream);\n+}\n+\n+/* Debug interface to heirarchy dumping.  */\n+\n+extern void\n+debug_class (tree t)\n+{\n+  dump_class_hierarchy_1 (stderr, TDF_SLIM, t);\n+}\n+\n+static void\n+dump_class_hierarchy (tree t)\n+{\n+  int flags;\n+  FILE *stream = dump_begin (TDI_class, &flags);\n+\n+  if (stream)\n+    {\n+      dump_class_hierarchy_1 (stream, flags, t);\n+      dump_end (TDI_class, stream);\n+    }\n }\n \n static void\n@@ -6669,6 +6685,53 @@ dump_vtt (tree t, tree vtt)\n   dump_end (TDI_class, stream);\n }\n \n+/* Dump a function or thunk and its thunkees.  */\n+\n+static void\n+dump_thunk (FILE *stream, int indent, tree thunk)\n+{\n+  static const char spaces[] = \"        \";\n+  tree name = DECL_NAME (thunk);\n+  tree thunks;\n+      \n+  fprintf (stream, \"%.*s%p %s %s\", indent, spaces,\n+\t   (void *)thunk,\n+\t   !DECL_THUNK_P (thunk) ? \"function\"\n+\t   : DECL_THIS_THUNK_P (thunk) ? \"this-thunk\" : \"covariant-thunk\",\n+\t   name ? IDENTIFIER_POINTER (name) : \"<unset>\");\n+  if (!DECL_THUNK_P (thunk))\n+    /*NOP*/;\n+  else if (THUNK_ALIAS_P (thunk))\n+    fprintf (stream, \" alias to %p\", (void *)THUNK_ALIAS (thunk));\n+  else\n+    {\n+      HOST_WIDE_INT fixed_adjust = THUNK_FIXED_OFFSET (thunk);\n+      tree virtual_adjust = THUNK_VIRTUAL_OFFSET (thunk);\n+\n+      fprintf (stream, \" fixed=\" HOST_WIDE_INT_PRINT_DEC, fixed_adjust);\n+      if (!virtual_adjust)\n+\t/*NOP*/;\n+      else if (DECL_THIS_THUNK_P (thunk))\n+\tfprintf (stream, \" vcall=\"  HOST_WIDE_INT_PRINT_DEC,\n+\t\t tree_low_cst (virtual_adjust, 0));\n+      else\n+\tfprintf (stream, \" vbase=\" HOST_WIDE_INT_PRINT_DEC \"(%s)\",\n+\t\t tree_low_cst (BINFO_VPTR_FIELD (virtual_adjust), 0),\n+\t\t type_as_string (BINFO_TYPE (virtual_adjust), TFF_SCOPE));\n+    }\n+  fprintf (stream, \"\\n\");\n+  for (thunks = DECL_THUNKS (thunk); thunks; thunks = TREE_CHAIN (thunks))\n+    dump_thunk (stream, indent + 2, thunks);\n+}\n+\n+/* Dump the thunks for FN.  */\n+\n+extern void\n+debug_thunks (tree fn)\n+{\n+  dump_thunk (stderr, 0, fn);\n+}\n+\n /* Virtual function table initialization.  */\n \n /* Create all the necessary vtables for T and its base classes.  */\n@@ -7327,6 +7390,11 @@ build_vtbl_initializer (tree binfo,\n \t{\n \t  if (!DECL_NAME (fn))\n \t    finish_thunk (fn);\n+\t  if (THUNK_ALIAS_P (fn))\n+\t    {\n+\t      fn = THUNK_ALIAS (fn);\n+\t      BV_FN (v) = fn;\n+\t    }\n \t  fn_original = THUNK_TARGET (fn);\n \t}\n       "}, {"sha": "060316002393ef00ea6662e1fa884af89b7f0754", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -2855,7 +2855,11 @@ struct lang_decl GTY(())\n \n    The constant adjustment is given by THUNK_FIXED_OFFSET.  If the\n    vcall or vbase offset is required, the index into the vtable is given by\n-   THUNK_VIRTUAL_OFFSET.  */\n+   THUNK_VIRTUAL_OFFSET.\n+\n+   Due to ordering constraints in class layout, it is possible to have\n+   equivalent covariant thunks. THUNK_ALIAS_P and THUNK_ALIAS are used\n+   in those cases.  */\n \n /* An integer indicating how many bytes should be subtracted from the\n    this or result pointer when this function is called.  */\n@@ -2868,13 +2872,21 @@ struct lang_decl GTY(())\n    binfo of the relevant virtual base.  If NULL, then there is no\n    virtual adjust.  (The vptr is always located at offset zero from\n    the this or result pointer.)  (If the covariant type is within the\n-   class hierarchy being layed out, the vbase index is not yet known\n+   class hierarchy being laid out, the vbase index is not yet known\n    at the point we need to create the thunks, hence the need to use\n    binfos.)  */\n \n #define THUNK_VIRTUAL_OFFSET(DECL) \\\n   (LANG_DECL_U2_CHECK (VAR_OR_FUNCTION_DECL_CHECK (DECL), 0)->virtual_offset)\n \n+/* A thunk which is equivalent to another thunk. */\n+#define THUNK_ALIAS_P(DECL) \\\n+  (THUNK_VIRTUAL_OFFSET (DECL) && DECL_P (THUNK_VIRTUAL_OFFSET (DECL)))\n+\n+/* When THUNK_ALIAS_P is true, this indicates the thunk which is\n+   aliased.  */\n+#define THUNK_ALIAS(DECL) THUNK_VIRTUAL_OFFSET (DECL)\n+\n /* For thunk NODE, this is the FUNCTION_DECL thunked to.  */\n #define THUNK_TARGET(NODE)\t\t\t\t\\\n   (DECL_LANG_SPECIFIC (NODE)->u.f.befriending_classes)\n@@ -3566,6 +3578,8 @@ extern void note_name_declared_in_class         (tree, tree);\n extern tree get_vtbl_decl_for_binfo             (tree);\n extern tree get_vtt_name                        (tree);\n extern tree get_primary_binfo                   (tree);\n+extern void debug_class\t\t\t\t(tree);\n+extern void debug_thunks \t\t\t(tree);\n \n /* in cvt.c */\n extern tree convert_to_reference (tree, tree, int, int, tree);\n@@ -3681,7 +3695,7 @@ extern int nonstatic_local_decl_p               (tree);\n extern tree declare_global_var                  (tree, tree);\n extern void register_dtor_fn                    (tree);\n extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n-extern tree cp_fname_init\t\t\t(const char *);\n+extern tree cp_fname_init\t\t\t(const char *, tree *);\n extern tree check_elaborated_type_specifier     (enum tag_types, tree, bool);\n extern tree cxx_builtin_type_decls              (void);\n extern void warn_extern_redeclared_static (tree, tree);"}, {"sha": "2bd6ff335bc43829063be650caae6f2ce035b256", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -3097,11 +3097,11 @@ cxx_init_decl_processing (void)\n }\n \n /* Generate an initializer for a function naming variable from\n-   NAME. NAME may be NULL, in which case we generate a special\n-   ERROR_MARK node which should be replaced later.  */\n+   NAME. NAME may be NULL, to indicate a dependent name.  TYPE_P is\n+   filled in with the type of the init. */\n \n tree\n-cp_fname_init (const char* name)\n+cp_fname_init (const char* name, tree *type_p)\n {\n   tree domain = NULL_TREE;\n   tree type;\n@@ -3118,12 +3118,12 @@ cp_fname_init (const char* name)\n   type = build_qualified_type (char_type_node, TYPE_QUAL_CONST);\n   type = build_cplus_array_type (type, domain);\n \n+  *type_p = type;\n+  \n   if (init)\n     TREE_TYPE (init) = type;\n   else\n-    /* We don't know the value until instantiation time. Make\n-       something which will be digested now, but replaced later.  */\n-    init = build (ERROR_MARK, type);\n+    init = error_mark_node;\n   \n   return init;\n }\n@@ -3139,8 +3139,9 @@ cp_make_fname_decl (tree id, int type_dep)\n {\n   const char *const name = (type_dep && processing_template_decl\n \t\t\t    ? NULL : fname_as_string (type_dep));\n-  tree init = cp_fname_init (name);\n-  tree decl = build_decl (VAR_DECL, id, TREE_TYPE (init));\n+  tree type;\n+  tree init = cp_fname_init (name, &type);\n+  tree decl = build_decl (VAR_DECL, id, type);\n \n   /* As we're using pushdecl_with_scope, we must set the context.  */\n   DECL_CONTEXT (decl) = current_function_decl;"}, {"sha": "c6651e84880c00e22b4431822c8a302464d33266", "filename": "gcc/cp/method.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -107,6 +107,8 @@ make_thunk (tree function, bool this_adjusting,\n   my_friendly_assert (TREE_CODE (function) == FUNCTION_DECL, 20021025);\n   /* We can have this thunks to covariant thunks, but not vice versa.  */\n   my_friendly_assert (!DECL_THIS_THUNK_P (function), 20021127);\n+  my_friendly_assert (!DECL_RESULT_THUNK_P (function) || this_adjusting,\n+\t\t      20031123);\n   \n   /* Scale the VIRTUAL_OFFSET to be in terms of bytes.  */\n   if (this_adjusting && virtual_offset)\n@@ -140,6 +142,8 @@ make_thunk (tree function, bool this_adjusting,\n   thunk = build_decl (FUNCTION_DECL, NULL_TREE, TREE_TYPE (function));\n   DECL_LANG_SPECIFIC (thunk) = DECL_LANG_SPECIFIC (function);\n   cxx_dup_lang_specific_decl (thunk);\n+  DECL_THUNKS (thunk) = NULL_TREE;\n+  \n   DECL_CONTEXT (thunk) = DECL_CONTEXT (function);\n   TREE_READONLY (thunk) = TREE_READONLY (function);\n   TREE_THIS_VOLATILE (thunk) = TREE_THIS_VOLATILE (function);\n@@ -171,6 +175,7 @@ make_thunk (tree function, bool this_adjusting,\n   DECL_DECLARED_INLINE_P (thunk) = 0;\n   /* Nor has it been deferred.  */\n   DECL_DEFERRED_FN (thunk) = 0;\n+  \n   /* Add it to the list of thunks associated with FUNCTION.  */\n   TREE_CHAIN (thunk) = DECL_THUNKS (function);\n   DECL_THUNKS (function) = thunk;\n@@ -193,6 +198,27 @@ finish_thunk (tree thunk)\n   function = THUNK_TARGET (thunk);\n   name = mangle_thunk (function, DECL_THIS_THUNK_P (thunk),\n \t\t       fixed_offset, virtual_offset);\n+\n+  /* We can end up with declarations of (logically) different\n+     covariant thunks, that do identical adjustments.  The two thunks\n+     will be adjusting between within different hierarchies, which\n+     happen to have the same layout.  We must nullify one of them to\n+     refer to the other.  */\n+  if (DECL_RESULT_THUNK_P (thunk))\n+    {\n+      tree cov_probe;\n+\n+      for (cov_probe = DECL_THUNKS (function);\n+\t   cov_probe; cov_probe = TREE_CHAIN (cov_probe))\n+\tif (DECL_NAME (cov_probe) == name)\n+\t  {\n+\t    my_friendly_assert (!DECL_THUNKS (thunk), 20031023);\n+\t    THUNK_ALIAS (thunk) = (THUNK_ALIAS_P (cov_probe)\n+\t\t\t\t   ? THUNK_ALIAS (cov_probe) : cov_probe);\n+\t    break;\n+\t  }\n+    }\n+  \n   DECL_NAME (thunk) = name;\n   SET_DECL_ASSEMBLER_NAME (thunk, name);\n }\n@@ -307,6 +333,10 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   /* We should have called finish_thunk to give it a name.  */\n   my_friendly_assert (DECL_NAME (thunk_fndecl), 20021127);\n \n+  /* We should never be using an alias, always refer to the\n+     aliased thunk.  */\n+  my_friendly_assert (!THUNK_ALIAS_P (thunk_fndecl), 20031023);\n+\n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;\n   "}, {"sha": "600d2402f3e2bbb3d540c25769d096c84424db22", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -7627,8 +7627,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t   initializer.  */\n \t\t\tconst char *const name\n \t\t\t  = cxx_printable_name (current_function_decl, 2);\n-\t\t\tinit = cp_fname_init (name);\n-\t\t\tTREE_TYPE (decl) = TREE_TYPE (init);\n+\t\t\tinit = cp_fname_init (name, &TREE_TYPE (decl));\n \t\t      }\n \t\t    else\n \t\t      init = tsubst_expr (init, args, complain, in_decl);"}, {"sha": "b55059dbc64c7daec569933155d3ecc7dbdec24e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -2827,15 +2827,20 @@ emit_associated_thunks (tree fn)\n       \n       for (thunk = DECL_THUNKS (fn); thunk; thunk = TREE_CHAIN (thunk))\n \t{\n-\t  use_thunk (thunk, /*emit_p=*/1);\n-\t  if (DECL_RESULT_THUNK_P (thunk))\n+\t  if (!THUNK_ALIAS_P (thunk))\n \t    {\n-\t      tree probe;\n-\n-\t      for (probe = DECL_THUNKS (thunk);\n-\t\t   probe; probe = TREE_CHAIN (probe))\n-\t\tuse_thunk (probe, /*emit_p=*/1);\n+\t      use_thunk (thunk, /*emit_p=*/1);\n+\t      if (DECL_RESULT_THUNK_P (thunk))\n+\t\t{\n+\t\t  tree probe;\n+\t\t  \n+\t\t  for (probe = DECL_THUNKS (thunk);\n+\t\t       probe; probe = TREE_CHAIN (probe))\n+\t\t    use_thunk (probe, /*emit_p=*/1);\n+\t\t}\n \t    }\n+\t  else\n+\t    my_friendly_assert (!DECL_THUNKS (thunk), 20031023);\n \t}\n     }\n }"}, {"sha": "26eec79ce031be734660565eeb960965d8515d15", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -1,3 +1,10 @@\n+2003-10-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/12698, c++/12699, c++/12700, c++/12566\n+\t* g++.dg/inherit/covariant9.C: New test.\n+\t* g++.dg/inherit/covariant10.C: New test.\n+\t* g++.dg/inherit/covariant11.C: New test.\n+\n 2003-10-20  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* gcc.dg/old-style-asm-1.c: Also check for (set (pc) on lines"}, {"sha": "4fcf7ead234ad0cd91e736f5a8da900a8d2c0bc7", "filename": "gcc/testsuite/g++.dg/inherit/covariant10.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant10.C?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+// Contributed by Nathan Sidwell 23 Oct 2003 <nathan@codesourcery.com>\n+// Origin: grigory@stl.sarov.ru\n+// PR c++/12699 ICE with covariancy\n+\n+struct c1 {\n+  virtual void f1() const {};\n+};\n+\n+struct c5 {};\n+\n+struct c6 : virtual c1 {\n+  virtual c5* f33() const {};\n+};\n+\n+struct c13 : virtual c5 { };\n+\n+struct c17 : virtual c6\n+{\n+  virtual c13* f33() const {};\n+};"}, {"sha": "f82c4187984425a51caf5978528ca6f4229f7f6d", "filename": "gcc/testsuite/g++.dg/inherit/covariant11.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant11.C?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+\n+// Contributed by Nathan Sidwell 23 Oct 2003 <nathan@codesourcery.com>\n+// Origin: grigory@stl.sarov.ru\n+// PR c++/12700 ICE with covariancy\n+\n+struct c2 { int i; };\n+\n+struct c1 {\n+  virtual c2& f8() {};\n+};\n+\n+struct c3 : c1, c2 {\n+  virtual c2& f8() {};\n+};\n+\n+struct c11 : public c1 {\n+  virtual c3& f8() {};\n+};\n+\n+struct c15 : virtual c3 {\n+  virtual c2& f8() {};\n+};\n+\n+struct c18 : virtual c11 {\n+  virtual c15& f8();\n+};\n+\n+c15& c18::f8() { throw 0; }"}, {"sha": "3266c75a768446df5f9c2a3c5e4b52cc1a73ccbb", "filename": "gcc/testsuite/g++.dg/inherit/covariant9.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb88593883c783c600c89b8d1e5d7973c90d3f5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant9.C?ref=bb88593883c783c600c89b8d1e5d7973c90d3f5a", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do link }\n+// { dg-options \"-w -ansi -pedantic\" }\n+\n+// Contributed by Nathan Sidwell 23 Oct 2003 <nathan@codesourcery.com>\n+// Origin: grigory@stl.sarov.ru\n+// PR c++/12698. Duplicate covariant thunks emitted.\n+\n+struct c1 {};\n+\n+struct c0 {\n+  int i;\n+  virtual c1& f10() {};\n+};\n+\n+struct c2 : virtual c1, c0 { };\n+\n+struct c6 : virtual c2, c0 {\n+  virtual c2& f10() {};\n+};\n+\n+struct c14 : virtual c2 { };\n+\n+struct c19 : virtual ::c6 {\n+  virtual class ::c14& f10() {};\n+};\n+\n+int main ()\n+{\n+  c19 obj;\n+}\n+\n+  "}]}