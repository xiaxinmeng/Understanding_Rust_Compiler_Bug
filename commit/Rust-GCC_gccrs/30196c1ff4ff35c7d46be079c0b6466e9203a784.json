{"sha": "30196c1ff4ff35c7d46be079c0b6466e9203a784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAxOTZjMWZmNGZmMzVjN2Q0NmJlMDc5YzBiNjQ2NmU5MjAzYTc4NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-27T20:10:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-27T20:10:38Z"}, "message": "function.c (thread_prologue_epilogue_insns): Don't move the line note at the head of the chain.\n\n        * function.c (thread_prologue_epilogue_insns): Don't move the\n        line note at the head of the chain.  Only force a lineno note\n        before the end of block 0.\n\nFrom-SVN: r34207", "tree": {"sha": "505a94fbe12c6bc641f5eef7af5da579dd6d4d3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/505a94fbe12c6bc641f5eef7af5da579dd6d4d3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30196c1ff4ff35c7d46be079c0b6466e9203a784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30196c1ff4ff35c7d46be079c0b6466e9203a784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30196c1ff4ff35c7d46be079c0b6466e9203a784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30196c1ff4ff35c7d46be079c0b6466e9203a784/comments", "author": null, "committer": null, "parents": [{"sha": "892ecf921f5bb5af0e03290433dc2e7dce487ff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/892ecf921f5bb5af0e03290433dc2e7dce487ff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/892ecf921f5bb5af0e03290433dc2e7dce487ff7"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "6dfc95421f16bf3b9c469e03ec1344e77ca84523", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196c1ff4ff35c7d46be079c0b6466e9203a784/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196c1ff4ff35c7d46be079c0b6466e9203a784/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30196c1ff4ff35c7d46be079c0b6466e9203a784", "patch": "@@ -1,3 +1,9 @@\n+2000-05-27  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (thread_prologue_epilogue_insns): Don't move the\n+\tline note at the head of the chain.  Only force a lineno note\n+\tbefore the end of block 0.\n+\n 2000-05-27  Richard Henderson  <rth@cygnus.com>\n \n \t* gensupport.c (collect_insn_data): Record the maximum number"}, {"sha": "a59de4b3467738b4cb268464b2f26b2e017bf92b", "filename": "gcc/function.c", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196c1ff4ff35c7d46be079c0b6466e9203a784/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196c1ff4ff35c7d46be079c0b6466e9203a784/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=30196c1ff4ff35c7d46be079c0b6466e9203a784", "patch": "@@ -7038,10 +7038,11 @@ thread_prologue_and_epilogue_insns (f)\n       rtx insn, prev;\n \n       /* GDB handles `break f' by setting a breakpoint on the first\n-\t line note *after* the prologue.  Which means (1) that if\n+\t line note after the prologue.  Which means (1) that if\n \t there are line number notes before where we inserted the\n-\t prologue we should move them, and (2) if there is no such\n-\t note, then we should generate one at the prologue.  */\n+\t prologue we should move them, and (2) we should generate a\n+\t note before the end of the first basic block, if there isn't\n+\t one already there.  */\n \n       for (insn = prologue_end; insn ; insn = prev)\n \t{\n@@ -7050,32 +7051,34 @@ thread_prologue_and_epilogue_insns (f)\n \t    {\n \t      /* Note that we cannot reorder the first insn in the\n \t\t chain, since rest_of_compilation relies on that\n-\t\t remaining constant.  Do the next best thing.  */\n+\t\t remaining constant.  */\n \t      if (prev == NULL)\n-\t\t{\n-\t\t  emit_line_note_after (NOTE_SOURCE_FILE (insn),\n-\t\t\t\t\tNOTE_LINE_NUMBER (insn),\n-\t\t\t\t\tprologue_end);\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t}\n-\t      else\n-\t\treorder_insns (insn, insn, prologue_end);\n+\t\tbreak;\n+\t      reorder_insns (insn, insn, prologue_end);\n \t    }\n \t}\n \n-      insn = NEXT_INSN (prologue_end);\n-      if (! insn || GET_CODE (insn) != NOTE || NOTE_LINE_NUMBER (insn) <= 0)\n+      /* Find the last line number note in the first block.  */\n+      for (insn = BASIC_BLOCK (0)->end;\n+\t   insn != prologue_end;\n+\t   insn = PREV_INSN (insn))\n+\tif (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\t  break;\n+\n+      /* If we didn't find one, make a copy of the first line number\n+\t we run across.  */\n+      if (! insn)\n \t{\n-\t  for (insn = next_active_insn (f); insn ; insn = PREV_INSN (insn))\n-\t    {\n-\t      if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n-\t\t{\n-\t\t  emit_line_note_after (NOTE_SOURCE_FILE (insn),\n-\t\t\t\t\tNOTE_LINE_NUMBER (insn),\n-\t\t\t\t\tprologue_end);\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t  for (insn = next_active_insn (prologue_end);\n+\t       insn;\n+\t       insn = PREV_INSN (insn))\n+\t    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\t      {\n+\t\temit_line_note_after (NOTE_SOURCE_FILE (insn),\n+\t\t\t\t      NOTE_LINE_NUMBER (insn),\n+\t\t\t\t      prologue_end);\n+\t\tbreak;\n+\t      }\n \t}\n     }\n #endif"}]}