{"sha": "070a1983b3abcec2f457443961ae64d97975cfd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcwYTE5ODNiM2FiY2VjMmY0NTc0NDM5NjFhZTY0ZDk3OTc1Y2ZkNA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T17:48:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T17:48:40Z"}, "message": "ira: Use rtx_insn in various places\n\ngcc/\n\t* ira-int.h (struct ira_allocno_copy): Strengthen field \"insn\"\n\tfrom rtx to rtx_insn *insn.\n\t(ira_create_copy): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(ira_add_allocno_copy): Likewise.\n\t* ira-build.c (find_allocno_copy): Strengthen param \"insn\" from\n\trtx to rtx_insn *.\n\t(ira_create_copy): Likewise.\n\t(ira_add_allocno_copy): Likewise.\n\t(create_bb_allocnos): Likewise for local \"insn\".\n\t* ira-conflicts.c (process_regs_for_copy): Likewise for param \"insn\".\n\t(process_reg_shuffles): Update NULL_RTX to NULL in invocation of\n\tprocess_regs_for_copy for rtx_insn * param.\n\t(add_insn_allocno_copies): Strengthen param \"insn\" from rtx to\n\trtx_insn *insn.  Update NULL_RTX to NULL in invocation of\n\tprocess_regs_for_copy for rtx_insn * param.\n\t(add_copies): Strengthen local \"insn\" from rtx to rtx_insn *insn.\n\t* ira-costs.c (record_reg_classes): Likewise for param \"insn\".\n\t(record_operand_costs): Likewise.\n\t(scan_one_insn): Likewise for return type, and for param \"insn\".\n\t(process_bb_for_costs): Likewise for local \"insn\".\n\t(process_bb_node_for_hard_reg_moves): Likewise.\n\t* ira-emit.c (struct move): Likewise for field \"insn\".\n\t(create_move): Eliminate use of NULL_RTX when dealing with an\n\trtx_insn *.\n\t(emit_move_list): Strengthen return type and locals \"result\",\n\t\"insn\" from rtx to rtx_insn *insn.\n\t(emit_moves): Likewise for locals \"insns\", \"tmp\".\n\t(ira_emit): Likewise for local \"insn\".\n\t* ira-lives.c (mark_hard_reg_early_clobbers): Likewise for param\n\t\"insn\".\n\t(find_call_crossed_cheap_reg): Likewise.\n\t(process_bb_node_lives): Likewise for local \"insn\".\n\t* ira.c (decrease_live_ranges_number): Likewise.\n\t(compute_regs_asm_clobbered): Likewise.\n\t(build_insn_chain): Likewise.\n\t(find_moveable_pseudos): Likewise, also locals \"def_insn\",\n\t\"use_insn\", \"x\".  Also strengthen local \"closest_uses\" from rtx *\n\tto rtx_insn **.  Add a checked cast when assigning from\n\t\"closest_use\" into closest_uses array in a region where we know\n\tit's a non-NULL insn.\n\t(interesting_dest_for_shprep): Strengthen param \"insn\" from rtx\n\tto rtx_insn *.\n\t(split_live_ranges_for_shrink_wrap): Likewise for locals \"insn\",\n\t\"last_interesting_insn\", \"uin\".\n\t(move_unallocated_pseudos): Likewise for locals \"def_insn\",\n\t\"move_insn\", \"newinsn\".\n\nFrom-SVN: r214339", "tree": {"sha": "6189c1fa149163c80ab3f905256542a39adaed40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6189c1fa149163c80ab3f905256542a39adaed40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/070a1983b3abcec2f457443961ae64d97975cfd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070a1983b3abcec2f457443961ae64d97975cfd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070a1983b3abcec2f457443961ae64d97975cfd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070a1983b3abcec2f457443961ae64d97975cfd4/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da66454436b819c50d0901a4da66aac3181f11de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da66454436b819c50d0901a4da66aac3181f11de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da66454436b819c50d0901a4da66aac3181f11de"}], "stats": {"total": 149, "additions": 103, "deletions": 46}, "files": [{"sha": "950ac49bc1a5e6c0ecbd0503f9f52ea0491664ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=070a1983b3abcec2f457443961ae64d97975cfd4", "patch": "@@ -1,3 +1,52 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ira-int.h (struct ira_allocno_copy): Strengthen field \"insn\"\n+\tfrom rtx to rtx_insn *insn.\n+\t(ira_create_copy): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(ira_add_allocno_copy): Likewise.\n+\t* ira-build.c (find_allocno_copy): Strengthen param \"insn\" from\n+\trtx to rtx_insn *.\n+\t(ira_create_copy): Likewise.\n+\t(ira_add_allocno_copy): Likewise.\n+\t(create_bb_allocnos): Likewise for local \"insn\".\n+\t* ira-conflicts.c (process_regs_for_copy): Likewise for param \"insn\".\n+\t(process_reg_shuffles): Update NULL_RTX to NULL in invocation of\n+\tprocess_regs_for_copy for rtx_insn * param.\n+\t(add_insn_allocno_copies): Strengthen param \"insn\" from rtx to\n+\trtx_insn *insn.  Update NULL_RTX to NULL in invocation of\n+\tprocess_regs_for_copy for rtx_insn * param.\n+\t(add_copies): Strengthen local \"insn\" from rtx to rtx_insn *insn.\n+\t* ira-costs.c (record_reg_classes): Likewise for param \"insn\".\n+\t(record_operand_costs): Likewise.\n+\t(scan_one_insn): Likewise for return type, and for param \"insn\".\n+\t(process_bb_for_costs): Likewise for local \"insn\".\n+\t(process_bb_node_for_hard_reg_moves): Likewise.\n+\t* ira-emit.c (struct move): Likewise for field \"insn\".\n+\t(create_move): Eliminate use of NULL_RTX when dealing with an\n+\trtx_insn *.\n+\t(emit_move_list): Strengthen return type and locals \"result\",\n+\t\"insn\" from rtx to rtx_insn *insn.\n+\t(emit_moves): Likewise for locals \"insns\", \"tmp\".\n+\t(ira_emit): Likewise for local \"insn\".\n+\t* ira-lives.c (mark_hard_reg_early_clobbers): Likewise for param\n+\t\"insn\".\n+\t(find_call_crossed_cheap_reg): Likewise.\n+\t(process_bb_node_lives): Likewise for local \"insn\".\n+\t* ira.c (decrease_live_ranges_number): Likewise.\n+\t(compute_regs_asm_clobbered): Likewise.\n+\t(build_insn_chain): Likewise.\n+\t(find_moveable_pseudos): Likewise, also locals \"def_insn\",\n+\t\"use_insn\", \"x\".  Also strengthen local \"closest_uses\" from rtx *\n+\tto rtx_insn **.  Add a checked cast when assigning from\n+\t\"closest_use\" into closest_uses array in a region where we know\n+\tit's a non-NULL insn.\n+\t(interesting_dest_for_shprep): Strengthen param \"insn\" from rtx\n+\tto rtx_insn *.\n+\t(split_live_ranges_for_shrink_wrap): Likewise for locals \"insn\",\n+\t\"last_interesting_insn\", \"uin\".\n+\t(move_unallocated_pseudos): Likewise for locals \"def_insn\",\n+\t\"move_insn\", \"newinsn\".\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* internal-fn.c (ubsan_expand_si_overflow_addsub_check):"}, {"sha": "3f2ab17fd82c0c4c9d6a5253e4d5a26256a6aed7", "filename": "gcc/ira-build.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=070a1983b3abcec2f457443961ae64d97975cfd4", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira-int.h\"\n #include \"emit-rtl.h\"  /* FIXME: Can go away once crtl is moved to rtl.h.  */\n \n-static ira_copy_t find_allocno_copy (ira_allocno_t, ira_allocno_t, rtx,\n+static ira_copy_t find_allocno_copy (ira_allocno_t, ira_allocno_t, rtx_insn *,\n \t\t\t\t     ira_loop_tree_node_t);\n \n /* The root of the loop tree corresponding to the all function.  */\n@@ -1385,7 +1385,7 @@ initiate_copies (void)\n /* Return copy connecting A1 and A2 and originated from INSN of\n    LOOP_TREE_NODE if any.  */\n static ira_copy_t\n-find_allocno_copy (ira_allocno_t a1, ira_allocno_t a2, rtx insn,\n+find_allocno_copy (ira_allocno_t a1, ira_allocno_t a2, rtx_insn *insn,\n \t\t   ira_loop_tree_node_t loop_tree_node)\n {\n   ira_copy_t cp, next_cp;\n@@ -1416,7 +1416,7 @@ find_allocno_copy (ira_allocno_t a1, ira_allocno_t a2, rtx insn,\n    SECOND, FREQ, CONSTRAINT_P, and INSN.  */\n ira_copy_t\n ira_create_copy (ira_allocno_t first, ira_allocno_t second, int freq,\n-\t\t bool constraint_p, rtx insn,\n+\t\t bool constraint_p, rtx_insn *insn,\n \t\t ira_loop_tree_node_t loop_tree_node)\n {\n   ira_copy_t cp;\n@@ -1493,7 +1493,7 @@ swap_allocno_copy_ends_if_necessary (ira_copy_t cp)\n    LOOP_TREE_NODE.  */\n ira_copy_t\n ira_add_allocno_copy (ira_allocno_t first, ira_allocno_t second, int freq,\n-\t\t      bool constraint_p, rtx insn,\n+\t\t      bool constraint_p, rtx_insn *insn,\n \t\t      ira_loop_tree_node_t loop_tree_node)\n {\n   ira_copy_t cp;\n@@ -1927,7 +1927,7 @@ static void\n create_bb_allocnos (ira_loop_tree_node_t bb_node)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n   unsigned int i;\n   bitmap_iterator bi;\n "}, {"sha": "011a8657db2b0612a0601c4f744699ddee6eb734", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=070a1983b3abcec2f457443961ae64d97975cfd4", "patch": "@@ -244,7 +244,7 @@ go_through_subreg (rtx x, int *offset)\n    FALSE.  */\n static bool\n process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n-\t\t       rtx insn, int freq)\n+\t\t       rtx_insn *insn, int freq)\n {\n   int allocno_preferenced_hard_regno, cost, index, offset1, offset2;\n   bool only_regs_p;\n@@ -345,15 +345,15 @@ process_reg_shuffles (rtx reg, int op_num, int freq, bool *bound_p)\n \t  || bound_p[i])\n \tcontinue;\n \n-      process_regs_for_copy (reg, another_reg, false, NULL_RTX, freq);\n+      process_regs_for_copy (reg, another_reg, false, NULL, freq);\n     }\n }\n \n /* Process INSN and create allocno copies if necessary.  For example,\n    it might be because INSN is a pseudo-register move or INSN is two\n    operand insn.  */\n static void\n-add_insn_allocno_copies (rtx insn)\n+add_insn_allocno_copies (rtx_insn *insn)\n {\n   rtx set, operand, dup;\n   bool bound_p[MAX_RECOG_OPERANDS];\n@@ -396,7 +396,7 @@ add_insn_allocno_copies (rtx insn)\n \t\t\t\tREG_P (operand)\n \t\t\t\t? operand\n \t\t\t\t: SUBREG_REG (operand)) != NULL_RTX)\n-\t    process_regs_for_copy (operand, dup, true, NULL_RTX,\n+\t    process_regs_for_copy (operand, dup, true, NULL,\n \t\t\t\t   freq);\n \t}\n     }\n@@ -421,7 +421,7 @@ static void\n add_copies (ira_loop_tree_node_t loop_tree_node)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   bb = loop_tree_node->bb;\n   if (bb == NULL)"}, {"sha": "774a958e353c996281dbde3b38d4ad2386672545", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=070a1983b3abcec2f457443961ae64d97975cfd4", "patch": "@@ -403,7 +403,7 @@ copy_cost (rtx x, enum machine_mode mode, reg_class_t rclass, bool to_p,\n static void\n record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t    enum machine_mode *modes, const char **constraints,\n-\t\t    rtx insn, enum reg_class *pref)\n+\t\t    rtx_insn *insn, enum reg_class *pref)\n {\n   int alt;\n   int i, j, k;\n@@ -1168,7 +1168,7 @@ record_address_regs (enum machine_mode mode, addr_space_t as, rtx x,\n \n /* Calculate the costs of insn operands.  */\n static void\n-record_operand_costs (rtx insn, enum reg_class *pref)\n+record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   enum machine_mode modes[MAX_RECOG_OPERANDS];\n@@ -1312,8 +1312,8 @@ record_operand_costs (rtx insn, enum reg_class *pref)\n /* Process one insn INSN.  Scan it and record each time it would save\n    code to put a certain allocnos in a certain class.  Return the last\n    insn processed, so that the scan can be continued from there.  */\n-static rtx\n-scan_one_insn (rtx insn)\n+static rtx_insn *\n+scan_one_insn (rtx_insn *insn)\n {\n   enum rtx_code pat_code;\n   rtx set, note;\n@@ -1496,7 +1496,7 @@ print_pseudo_costs (FILE *f)\n static void\n process_bb_for_costs (basic_block bb)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   frequency = REG_FREQ_FROM_BB (bb);\n   if (frequency == 0)\n@@ -1903,7 +1903,8 @@ process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n   ira_loop_tree_node_t curr_loop_tree_node;\n   enum reg_class rclass;\n   basic_block bb;\n-  rtx insn, set, src, dst;\n+  rtx_insn *insn;\n+  rtx set, src, dst;\n \n   bb = loop_tree_node->bb;\n   if (bb == NULL)"}, {"sha": "445b386b67fc6d2c729379895b40761a3b45d0f6", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=070a1983b3abcec2f457443961ae64d97975cfd4", "patch": "@@ -172,7 +172,7 @@ struct move\n      dependencies.  */\n   move_t *deps;\n   /* First insn generated for the move.  */\n-  rtx insn;\n+  rtx_insn *insn;\n };\n \n /* Array of moves (indexed by BB index) which should be put at the\n@@ -196,7 +196,7 @@ create_move (ira_allocno_t to, ira_allocno_t from)\n   move->to = to;\n   move->from = from;\n   move->next = NULL;\n-  move->insn = NULL_RTX;\n+  move->insn = NULL;\n   move->visited_p = false;\n   return move;\n }\n@@ -893,12 +893,13 @@ modify_move_list (move_t list)\n \n /* Generate RTX move insns from the move list LIST.  This updates\n    allocation cost using move execution frequency FREQ.  */\n-static rtx\n+static rtx_insn *\n emit_move_list (move_t list, int freq)\n {\n   rtx to, from, dest;\n   int to_regno, from_regno, cost, regno;\n-  rtx result, insn, set;\n+  rtx_insn *result, *insn;\n+  rtx set;\n   enum machine_mode mode;\n   enum reg_class aclass;\n \n@@ -984,7 +985,7 @@ emit_moves (void)\n   basic_block bb;\n   edge_iterator ei;\n   edge e;\n-  rtx insns, tmp;\n+  rtx_insn *insns, *tmp;\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -1234,7 +1235,7 @@ void\n ira_emit (bool loops_p)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n   edge_iterator ei;\n   edge e;\n   ira_allocno_t a;"}, {"sha": "3d1a1d38015138ec554d6f6bd825513bb3f58306", "filename": "gcc/ira-int.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=070a1983b3abcec2f457443961ae64d97975cfd4", "patch": "@@ -571,7 +571,7 @@ struct ira_allocno_copy\n      for the copy created to remove register shuffle is NULL.  In last\n      case the copy frequency is smaller than the corresponding insn\n      execution frequency.  */\n-  rtx insn;\n+  rtx_insn *insn;\n   /* All copies with the same allocno as FIRST are linked by the two\n      following members.  */\n   ira_copy_t prev_first_allocno_copy, next_first_allocno_copy;\n@@ -1009,9 +1009,11 @@ extern void ira_add_allocno_pref (ira_allocno_t, int, int);\n extern void ira_remove_pref (ira_pref_t);\n extern void ira_remove_allocno_prefs (ira_allocno_t);\n extern ira_copy_t ira_create_copy (ira_allocno_t, ira_allocno_t,\n-\t\t\t\t   int, bool, rtx, ira_loop_tree_node_t);\n+\t\t\t\t   int, bool, rtx_insn *,\n+\t\t\t\t   ira_loop_tree_node_t);\n extern ira_copy_t ira_add_allocno_copy (ira_allocno_t, ira_allocno_t, int,\n-\t\t\t\t\tbool, rtx, ira_loop_tree_node_t);\n+\t\t\t\t\tbool, rtx_insn *,\n+\t\t\t\t\tira_loop_tree_node_t);\n \n extern int *ira_allocate_cost_vector (reg_class_t);\n extern void ira_free_cost_vector (int *, reg_class_t);"}, {"sha": "916f49224c4ed47223691168701adf60afecdfef", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=070a1983b3abcec2f457443961ae64d97975cfd4", "patch": "@@ -723,7 +723,7 @@ make_early_clobber_and_input_conflicts (void)\n /* Mark early clobber hard registers of the current INSN as live (if\n    LIVE_P) or dead.  Return true if there are such registers.  */\n static bool\n-mark_hard_reg_early_clobbers (rtx insn, bool live_p)\n+mark_hard_reg_early_clobbers (rtx_insn *insn, bool live_p)\n {\n   df_ref def;\n   bool set_p = false;\n@@ -985,7 +985,7 @@ bb_has_abnormal_call_pred (basic_block bb)\n    we find a SET rtx that we can use to deduce that a register can be cheaply\n    caller-saved.  Return such a register, or NULL_RTX if none is found.  */\n static rtx\n-find_call_crossed_cheap_reg (rtx insn)\n+find_call_crossed_cheap_reg (rtx_insn *insn)\n {\n   rtx cheap_reg = NULL_RTX;\n   rtx exp = CALL_INSN_FUNCTION_USAGE (insn);\n@@ -1052,7 +1052,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n   int i, freq;\n   unsigned int j;\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n   bitmap_iterator bi;\n   bitmap reg_live_out;\n   unsigned int px;"}, {"sha": "478509a262cea265f89bdc3926223f501507722d", "filename": "gcc/ira.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070a1983b3abcec2f457443961ae64d97975cfd4/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=070a1983b3abcec2f457443961ae64d97975cfd4", "patch": "@@ -2014,7 +2014,8 @@ static void\n decrease_live_ranges_number (void)\n {\n   basic_block bb;\n-  rtx insn, set, src, dest, dest_death, p, q, note;\n+  rtx_insn *insn;\n+  rtx set, src, dest, dest_death, p, q, note;\n   int sregno, dregno;\n \n   if (! flag_expensive_optimizations)\n@@ -2229,7 +2230,7 @@ compute_regs_asm_clobbered (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n \t  df_ref def;\n@@ -3998,7 +3999,7 @@ build_insn_chain (void)\n   FOR_EACH_BB_REVERSE_FN (bb, cfun)\n     {\n       bitmap_iterator bi;\n-      rtx insn;\n+      rtx_insn *insn;\n \n       CLEAR_REG_SET (live_relevant_regs);\n       bitmap_clear (live_subregs_used);\n@@ -4370,7 +4371,7 @@ find_moveable_pseudos (void)\n   int max_uid = get_max_uid ();\n   basic_block bb;\n   int *uid_luid = XNEWVEC (int, max_uid);\n-  rtx *closest_uses = XNEWVEC (rtx, max_regs);\n+  rtx_insn **closest_uses = XNEWVEC (rtx_insn *, max_regs);\n   /* A set of registers which are live but not modified throughout a block.  */\n   bitmap_head *bb_transp_live = XNEWVEC (bitmap_head,\n \t\t\t\t\t last_basic_block_for_fn (cfun));\n@@ -4399,7 +4400,7 @@ find_moveable_pseudos (void)\n   bitmap_initialize (&unusable_as_input, 0);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       bitmap transp = bb_transp_live + bb->index;\n       bitmap moveable = bb_moveable_reg_sets + bb->index;\n       bitmap local = bb_local + bb->index;\n@@ -4462,13 +4463,14 @@ find_moveable_pseudos (void)\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       bitmap local = bb_local + bb->index;\n-      rtx insn;\n+      rtx_insn *insn;\n \n       FOR_BB_INSNS (bb, insn)\n \tif (NONDEBUG_INSN_P (insn))\n \t  {\n \t    df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-\t    rtx def_insn, closest_use, note;\n+\t    rtx_insn *def_insn;\n+\t    rtx closest_use, note;\n \t    df_ref def, use;\n \t    unsigned regno;\n \t    bool all_dominated, all_local;\n@@ -4510,7 +4512,7 @@ find_moveable_pseudos (void)\n \t    closest_use = NULL_RTX;\n \t    for (; use; use = DF_REF_NEXT_REG (use))\n \t      {\n-\t\trtx insn;\n+\t\trtx_insn *insn;\n \t\tif (!DF_REF_INSN_INFO (use))\n \t\t  {\n \t\t    all_dominated = false;\n@@ -4562,7 +4564,9 @@ find_moveable_pseudos (void)\n \t      }\n #endif\n \t    bitmap_set_bit (&interesting, regno);\n-\t    closest_uses[regno] = closest_use;\n+\t    /* If we get here, we know closest_use is a non-NULL insn\n+\t       (as opposed to const_0_rtx).  */\n+\t    closest_uses[regno] = as_a <rtx_insn *> (closest_use);\n \n \t    if (dump_file && (all_local || all_dominated))\n \t      {\n@@ -4581,13 +4585,13 @@ find_moveable_pseudos (void)\n   EXECUTE_IF_SET_IN_BITMAP (&interesting, 0, i, bi)\n     {\n       df_ref def = DF_REG_DEF_CHAIN (i);\n-      rtx def_insn = DF_REF_INSN (def);\n+      rtx_insn *def_insn = DF_REF_INSN (def);\n       basic_block def_block = BLOCK_FOR_INSN (def_insn);\n       bitmap def_bb_local = bb_local + def_block->index;\n       bitmap def_bb_moveable = bb_moveable_reg_sets + def_block->index;\n       bitmap def_bb_transp = bb_transp_live + def_block->index;\n       bool local_to_bb_p = bitmap_bit_p (def_bb_local, i);\n-      rtx use_insn = closest_uses[i];\n+      rtx_insn *use_insn = closest_uses[i];\n       df_ref use;\n       bool all_ok = true;\n       bool all_transp = true;\n@@ -4640,7 +4644,7 @@ find_moveable_pseudos (void)\n \t\t{\n \t\t  if (modified_between_p (DF_REF_REG (use), def_insn, use_insn))\n \t\t    {\n-\t\t      rtx x = NEXT_INSN (def_insn);\n+\t\t      rtx_insn *x = NEXT_INSN (def_insn);\n \t\t      while (!modified_in_p (DF_REF_REG (use), x))\n \t\t\t{\n \t\t\t  gcc_assert (x != use_insn);\n@@ -4733,7 +4737,7 @@ interesting_dest_for_shprep_1 (rtx set, basic_block call_dom)\n    Otherwise return NULL.  */\n \n static rtx\n-interesting_dest_for_shprep (rtx insn, basic_block call_dom)\n+interesting_dest_for_shprep (rtx_insn *insn, basic_block call_dom)\n {\n   if (!INSN_P (insn))\n     return NULL;\n@@ -4771,7 +4775,7 @@ split_live_ranges_for_shrink_wrap (void)\n {\n   basic_block bb, call_dom = NULL;\n   basic_block first = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  rtx insn, last_interesting_insn = NULL;\n+  rtx_insn *insn, *last_interesting_insn = NULL;\n   bitmap_head need_new, reachable;\n   vec<basic_block> queue;\n \n@@ -4888,7 +4892,7 @@ split_live_ranges_for_shrink_wrap (void)\n       df_ref use, next;\n       for (use = DF_REG_USE_CHAIN (REGNO (dest)); use; use = next)\n \t{\n-\t  rtx uin = DF_REF_INSN (use);\n+\t  rtx_insn *uin = DF_REF_INSN (use);\n \t  next = DF_REF_NEXT_REG (use);\n \n \t  basic_block ubb = BLOCK_FOR_INSN (uin);\n@@ -4934,12 +4938,12 @@ move_unallocated_pseudos (void)\n       {\n \tint idx = i - first_moveable_pseudo;\n \trtx other_reg = pseudo_replaced_reg[idx];\n-\trtx def_insn = DF_REF_INSN (DF_REG_DEF_CHAIN (i));\n+\trtx_insn *def_insn = DF_REF_INSN (DF_REG_DEF_CHAIN (i));\n \t/* The use must follow all definitions of OTHER_REG, so we can\n \t   insert the new definition immediately after any of them.  */\n \tdf_ref other_def = DF_REG_DEF_CHAIN (REGNO (other_reg));\n-\trtx move_insn = DF_REF_INSN (other_def);\n-\trtx newinsn = emit_insn_after (PATTERN (def_insn), move_insn);\n+\trtx_insn *move_insn = DF_REF_INSN (other_def);\n+\trtx_insn *newinsn = emit_insn_after (PATTERN (def_insn), move_insn);\n \trtx set;\n \tint success;\n "}]}