{"sha": "234bef96a1cff5d8ad577777fae051105ec01b6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM0YmVmOTZhMWNmZjVkOGFkNTc3Nzc3ZmFlMDUxMTA1ZWMwMWI2ZQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-11-14T16:59:52Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-11-14T16:59:52Z"}, "message": "semantics.c (end_maybe_infinite_loop): Use fold_non_dependent_expr.\n\n2014-11-14  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* semantics.c (end_maybe_infinite_loop): Use fold_non_dependent_expr.\n\t* parser.c (cp_parser_omp_clause_collapse): Likewise.\n\t(cp_parser_enumerator_definition): Don't call\n\tinstantiate_non_dependent_expr...\n\t* decl.c (build_enumerator): ... call fold_non_dependent_expr here.\n\t* typeck2.c (massage_init_elt): Use fold_non_dependent_expr.\n\t* constexpr.c (maybe_constant_value): Allow VIEW_CONVERT_EXPR in\n\tthe final gcc_assert.\n\n\t* constexpr.c (fold_non_dependent_expr): Add.\n\t* cp-tree.h (fold_non_dependent_expr): Declare it.\n\t* call.c (null_ptr_cst_p): Use it.\n\t* pt.c (tsubst_copy_and_build, build_non_dependent_expr): Likewise.\n\t* semantics.c (begin_maybe_infinite_loop): Likewise.\n\t* typeck.c (cp_build_binary_op): Likewise.\n\t* typeck2.c (check_narrowing): Likewise.\n\n\t* pt.c (fold_non_dependent_expr): Rename to\n\tinstantiate_non_dependent_expr.\n\t(fold_non_dependent_expr_sfinae): Rename to\n\tinstantiate_non_dependent_expr_sfinae.\n\t(convert_nontype_argument, build_non_dependent_expr): Adjust.\n\t* decl.c (compute_array_index_type): Likewise.\n\t* parser.c (cp_parser_parenthesized_expression_list,\n\tcp_parser_enumerator_definition, cp_parser_omp_clause_collapse):\n\tLikewise.\n\t* semantics.c (end_maybe_infinite_loop, finish_static_assert):\n\tLikewise.\n\t* typeck.c (cxx_alignas_expr): Likewise.\n\t* typeck2.c (store_init_value, massage_init_elt): Likewise.\n\t* call.c: Adjust comments.\n\t* class.c: Likewise.\n\t* constexpr.c: Likewise.\n\t* decl2.c: Likewise.\n\t* tree.c: Likewise.\n\nFrom-SVN: r217577", "tree": {"sha": "bb9b15a5c0dabd6abb40f5da82c60cf13379472d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb9b15a5c0dabd6abb40f5da82c60cf13379472d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/234bef96a1cff5d8ad577777fae051105ec01b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/234bef96a1cff5d8ad577777fae051105ec01b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/234bef96a1cff5d8ad577777fae051105ec01b6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/234bef96a1cff5d8ad577777fae051105ec01b6e/comments", "author": null, "committer": null, "parents": [{"sha": "2c59c2d1a2c4903513e6978655eac9159912762d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c59c2d1a2c4903513e6978655eac9159912762d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c59c2d1a2c4903513e6978655eac9159912762d"}], "stats": {"total": 199, "additions": 151, "deletions": 48}, "files": [{"sha": "5311649d12dc15a47181642e6b27a1f0cc8dea5d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -1,3 +1,41 @@\n+2014-11-14  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* semantics.c (end_maybe_infinite_loop): Use fold_non_dependent_expr.\n+\t* parser.c (cp_parser_omp_clause_collapse): Likewise.\n+\t(cp_parser_enumerator_definition): Don't call\n+\tinstantiate_non_dependent_expr...\n+\t* decl.c (build_enumerator): ... call fold_non_dependent_expr here.\n+\t* typeck2.c (massage_init_elt): Use fold_non_dependent_expr.\n+\t* constexpr.c (maybe_constant_value): Allow VIEW_CONVERT_EXPR in\n+\tthe final gcc_assert.\n+\n+\t* constexpr.c (fold_non_dependent_expr): Add.\n+\t* cp-tree.h (fold_non_dependent_expr): Declare it.\n+\t* call.c (null_ptr_cst_p): Use it.\n+\t* pt.c (tsubst_copy_and_build, build_non_dependent_expr): Likewise.\n+\t* semantics.c (begin_maybe_infinite_loop): Likewise.\n+\t* typeck.c (cp_build_binary_op): Likewise.\n+\t* typeck2.c (check_narrowing): Likewise.\n+\n+\t* pt.c (fold_non_dependent_expr): Rename to\n+\tinstantiate_non_dependent_expr.\n+\t(fold_non_dependent_expr_sfinae): Rename to\n+\tinstantiate_non_dependent_expr_sfinae.\n+\t(convert_nontype_argument, build_non_dependent_expr): Adjust.\n+\t* decl.c (compute_array_index_type): Likewise.\n+\t* parser.c (cp_parser_parenthesized_expression_list,\n+\tcp_parser_enumerator_definition, cp_parser_omp_clause_collapse):\n+\tLikewise.\n+\t* semantics.c (end_maybe_infinite_loop, finish_static_assert):\n+\tLikewise.\n+\t* typeck.c (cxx_alignas_expr): Likewise.\n+\t* typeck2.c (store_init_value, massage_init_elt): Likewise.\n+\t* call.c: Adjust comments.\n+\t* class.c: Likewise.\n+\t* constexpr.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* tree.c: Likewise.\n+\n 2014-11-14  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* mangle.c (find_substitution): Look for abi_tag on class templates."}, {"sha": "4f0b1725da2e945c71907f21af4e2e09f83def33", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -572,7 +572,7 @@ null_ptr_cst_p (tree t)\n     {\n       /* Core issue 903 says only literal 0 is a null pointer constant.  */\n       if (cxx_dialect < cxx11)\n-\tt = maybe_constant_value (fold_non_dependent_expr_sfinae (t, tf_none));\n+\tt = fold_non_dependent_expr (t);\n       STRIP_NOPS (t);\n       if (integer_zerop (t) && !TREE_OVERFLOW (t))\n \treturn true;\n@@ -7437,8 +7437,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     return error_mark_node;\n \n   if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0\n-      /* Don't mess with virtual lookup in fold_non_dependent_expr; virtual\n-\t functions can't be constexpr.  */\n+      /* Don't mess with virtual lookup in instantiate_non_dependent_expr;\n+\t virtual functions can't be constexpr.  */\n       && !in_template_function ())\n     {\n       tree t;\n@@ -9361,7 +9361,7 @@ perform_implicit_conversion_flags (tree type, tree expr,\n \t type of non-dependent expressions, so we do not have to\n \t perform the actual conversion.  But for initializers, we\n \t need to be able to perform it at instantiation\n-\t (or fold_non_dependent_expr) time.  */\n+\t (or instantiate_non_dependent_expr) time.  */\n       expr = build1 (IMPLICIT_CONV_EXPR, type, expr);\n       if (!(flags & LOOKUP_ONLYCONVERTING))\n \tIMPLICIT_CONV_EXPR_DIRECT_INIT (expr) = true;"}, {"sha": "c83c8adfab278dfc81543745f54b79c8dad7bcc7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -359,9 +359,9 @@ build_base_path (enum tree_code code,\n \n   /* Don't bother with the calculations inside sizeof; they'll ICE if the\n      source type is incomplete and the pointer value doesn't matter.  In a\n-     template (even in fold_non_dependent_expr), we don't have vtables set\n-     up properly yet, and the value doesn't matter there either; we're just\n-     interested in the result of overload resolution.  */\n+     template (even in instantiate_non_dependent_expr), we don't have vtables\n+     set up properly yet, and the value doesn't matter there either; we're\n+     just interested in the result of overload resolution.  */\n   if (cp_unevaluated_operand != 0\n       || in_template_function ())\n     {\n@@ -6933,7 +6933,8 @@ resolves_to_fixed_type_p (tree instance, int* nonnull)\n   tree fixed;\n \n   /* processing_template_decl can be false in a template if we're in\n-     fold_non_dependent_expr, but we still want to suppress this check.  */\n+     instantiate_non_dependent_expr, but we still want to suppress\n+     this check.  */\n   if (in_template_function ())\n     {\n       /* In a template we only care about the type of the result.  */"}, {"sha": "d30bf635d84d0dfd5701400b838a052d5e829dea", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -2908,12 +2908,83 @@ maybe_constant_value (tree t, tree decl)\n   /* cp_tree_equal looks through NOPs, so allow them.  */\n   gcc_assert (r == t\n \t      || CONVERT_EXPR_P (t)\n+\t      || TREE_CODE (t) == VIEW_CONVERT_EXPR\n \t      || (TREE_CONSTANT (t) && !TREE_CONSTANT (r))\n \t      || !cp_tree_equal (r, t));\n #endif\n   return r;\n }\n \n+/* Like maybe_constant_value but first fully instantiate the argument.\n+\n+   Note: this is equivalent to instantiate_non_dependent_expr_sfinae\n+   (t, tf_none) followed by maybe_constant_value but is more efficient,\n+   because calls instantiation_dependent_expression_p and\n+   potential_constant_expression at most once.  */\n+\n+tree\n+fold_non_dependent_expr (tree t)\n+{\n+  if (t == NULL_TREE)\n+    return NULL_TREE;\n+\n+  /* If we're in a template, but T isn't value dependent, simplify\n+     it.  We're supposed to treat:\n+\n+       template <typename T> void f(T[1 + 1]);\n+       template <typename T> void f(T[2]);\n+\n+     as two declarations of the same function, for example.  */\n+  if (processing_template_decl)\n+    {\n+      if (!instantiation_dependent_expression_p (t)\n+\t  && potential_constant_expression (t))\n+\t{\n+\t  HOST_WIDE_INT saved_processing_template_decl;\n+\n+\t  saved_processing_template_decl = processing_template_decl;\n+\t  processing_template_decl = 0;\n+\t  t = tsubst_copy_and_build (t,\n+\t\t\t\t     /*args=*/NULL_TREE,\n+\t\t\t\t     tf_none,\n+\t\t\t\t     /*in_decl=*/NULL_TREE,\n+\t\t\t\t     /*function_p=*/false,\n+\t\t\t\t     /*integral_constant_expression_p=*/true);\n+\t  processing_template_decl = saved_processing_template_decl;\n+\n+\t  if (type_unknown_p (t)\n+\t      || BRACE_ENCLOSED_INITIALIZER_P (t))\n+\t    {\n+\t      if (TREE_OVERFLOW_P (t))\n+\t\t{\n+\t\t  t = build_nop (TREE_TYPE (t), t);\n+\t\t  TREE_CONSTANT (t) = false;\n+\t\t}\n+\t      return t;\n+\t    }\n+\n+\t  tree r = cxx_eval_outermost_constant_expr (t, true, NULL_TREE);\n+#ifdef ENABLE_CHECKING\n+\t  /* cp_tree_equal looks through NOPs, so allow them.  */\n+\t  gcc_assert (r == t\n+\t\t      || CONVERT_EXPR_P (t)\n+\t\t      || TREE_CODE (t) == VIEW_CONVERT_EXPR\n+\t\t      || (TREE_CONSTANT (t) && !TREE_CONSTANT (r))\n+\t\t      || !cp_tree_equal (r, t));\n+#endif\n+\t  return r;\n+\t}\n+      else if (TREE_OVERFLOW_P (t))\n+\t{\n+\t  t = build_nop (TREE_TYPE (t), t);\n+\t  TREE_CONSTANT (t) = false;\n+\t}\n+      return t;\n+    }\n+\n+  return maybe_constant_value (t);\n+}\n+\n /* Like maybe_constant_value, but returns a CONSTRUCTOR directly, rather\n    than wrapped in a TARGET_EXPR.  */\n \n@@ -3386,7 +3457,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \tif (!potential_constant_expression_1 (denom, rval, flags))\n \t  return false;\n \t/* We can't call cxx_eval_outermost_constant_expr on an expression\n-\t   that hasn't been through fold_non_dependent_expr yet.  */\n+\t   that hasn't been through instantiate_non_dependent_expr yet.  */\n \tif (!processing_template_decl)\n \t  denom = cxx_eval_outermost_constant_expr (denom, true);\n \tif (integer_zerop (denom))"}, {"sha": "b69c73695890c7f5994cb83947ccebda5d0d4877", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -5690,8 +5690,8 @@ extern tree template_for_substitution\t\t(tree);\n extern tree build_non_dependent_expr\t\t(tree);\n extern void make_args_non_dependent\t\t(vec<tree, va_gc> *);\n extern bool reregister_specialization\t\t(tree, tree, tree);\n-extern tree fold_non_dependent_expr\t\t(tree);\n-extern tree fold_non_dependent_expr_sfinae\t(tree, tsubst_flags_t);\n+extern tree instantiate_non_dependent_expr\t(tree);\n+extern tree instantiate_non_dependent_expr_sfinae (tree, tsubst_flags_t);\n extern bool alias_type_or_template_p            (tree);\n extern bool alias_template_specialization_p     (const_tree);\n extern bool dependent_alias_template_spec_p     (const_tree);\n@@ -6331,6 +6331,7 @@ extern bool require_potential_rvalue_constant_expression (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE);\n+extern tree fold_non_dependent_expr\t\t(tree);\n extern bool is_sub_constant_expr                (tree);\n extern bool reduced_constant_expression_p       (tree);\n extern bool is_instantiation_of_constexpr       (tree);"}, {"sha": "1ef97637426d859fd79034fad393138b4fe93355", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -8356,7 +8356,7 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n \t   NOP_EXPR with TREE_SIDE_EFFECTS; don't fold in that case.  */;\n       else\n \t{\n-\t  size = fold_non_dependent_expr_sfinae (size, complain);\n+\t  size = instantiate_non_dependent_expr_sfinae (size, complain);\n \n \t  if (CLASS_TYPE_P (type)\n \t      && CLASSTYPE_LITERAL_P (type))\n@@ -12999,6 +12999,11 @@ build_enumerator (tree name, tree value, tree enumtype, location_t loc)\n   tree context;\n   tree type;\n \n+  /* integral_constant_value will pull out this expression, so make sure\n+     it's folded as appropriate.  */\n+  if (processing_template_decl)\n+    value = fold_non_dependent_expr (value);\n+\n   /* If the VALUE was erroneous, pretend it wasn't there; that will\n      result in the enum being assigned the next value in sequence.  */\n   if (value == error_mark_node)"}, {"sha": "1b686ef95ae10e5d4af6f5e8faa3220828d0e15e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -4951,7 +4951,7 @@ mark_used (tree decl, tsubst_flags_t complain)\n   if (processing_template_decl)\n     return true;\n \n-  /* Check this too in case we're within fold_non_dependent_expr.  */\n+  /* Check this too in case we're within instantiate_non_dependent_expr.  */\n   if (DECL_TEMPLATE_INFO (decl)\n       && uses_template_parms (DECL_TI_ARGS (decl)))\n     return true;"}, {"sha": "3ab65a915565ad90a64e9a681c5d1db1e4c8ce90", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -6886,7 +6886,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t      }\n \n \t    if (fold_expr_p)\n-\t      expr = fold_non_dependent_expr (expr);\n+\t      expr = instantiate_non_dependent_expr (expr);\n \n             /* If we have an ellipsis, then this is an expression\n \t       expansion.  */\n@@ -15996,10 +15996,6 @@ cp_parser_enumerator_definition (cp_parser* parser, tree type)\n   if (check_for_bare_parameter_packs (value))\n     value = error_mark_node;\n \n-  /* integral_constant_value will pull out this expression, so make sure\n-     it's folded as appropriate.  */\n-  value = fold_non_dependent_expr (value);\n-\n   /* Create the enumerator.  */\n   build_enumerator (identifier, value, type, loc);\n }"}, {"sha": "1ee3dc1190635fbc196bc019d8d521c2458590bf", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -5216,7 +5216,7 @@ redeclare_class_template (tree type, tree parms)\n    (possibly simplified) expression.  */\n \n tree\n-fold_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n+instantiate_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n {\n   if (expr == NULL_TREE)\n     return NULL_TREE;\n@@ -5248,9 +5248,9 @@ fold_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n }\n \n tree\n-fold_non_dependent_expr (tree expr)\n+instantiate_non_dependent_expr (tree expr)\n {\n-  return fold_non_dependent_expr_sfinae (expr, tf_error);\n+  return instantiate_non_dependent_expr_sfinae (expr, tf_error);\n }\n \n /* Return TRUE iff T is a type alias, a TEMPLATE_DECL for an alias\n@@ -5740,7 +5740,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n       && has_value_dependent_address (expr))\n     /* If we want the address and it's value-dependent, don't fold.  */;\n   else if (!type_unknown_p (expr))\n-    expr = fold_non_dependent_expr_sfinae (expr, complain);\n+    expr = instantiate_non_dependent_expr_sfinae (expr, complain);\n   if (error_operand_p (expr))\n     return error_mark_node;\n   expr_type = TREE_TYPE (expr);\n@@ -8314,7 +8314,7 @@ uses_template_parms (tree t)\n \n /* Returns true iff current_function_decl is an incompletely instantiated\n    template.  Useful instead of processing_template_decl because the latter\n-   is set to 0 during fold_non_dependent_expr.  */\n+   is set to 0 during instantiate_non_dependent_expr.  */\n \n bool\n in_template_function (void)\n@@ -15138,8 +15138,7 @@ tsubst_copy_and_build (tree t,\n     case COND_EXPR:\n       {\n \ttree cond = RECUR (TREE_OPERAND (t, 0));\n-\ttree folded_cond = (maybe_constant_value\n-\t\t\t    (fold_non_dependent_expr_sfinae (cond, tf_none)));\n+\ttree folded_cond = fold_non_dependent_expr (cond);\n \ttree exp1, exp2;\n \n \tif (TREE_CODE (folded_cond) == INTEGER_CST)\n@@ -21110,7 +21109,7 @@ value_dependent_expression_p (tree expression)\n \n     case STMT_EXPR:\n       /* Treat a GNU statement expression as dependent to avoid crashing\n-\t under fold_non_dependent_expr; it can't be constant.  */\n+\t under instantiate_non_dependent_expr; it can't be constant.  */\n       return true;\n \n     default:\n@@ -21864,7 +21863,7 @@ build_non_dependent_expr (tree expr)\n   /* Try to get a constant value for all non-dependent expressions in\n       order to expose bugs in *_dependent_expression_p and constexpr.  */\n   if (cxx_dialect >= cxx11)\n-    maybe_constant_value (fold_non_dependent_expr_sfinae (expr, tf_none));\n+    fold_non_dependent_expr (expr);\n #endif\n \n   /* Preserve OVERLOADs; the functions must be available to resolve"}, {"sha": "6888121d5d0cd89587700920dd76ef1d13642f29", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -511,8 +511,7 @@ begin_maybe_infinite_loop (tree cond)\n   bool maybe_infinite = true;\n   if (cond)\n     {\n-      cond = fold_non_dependent_expr_sfinae (cond, tf_none);\n-      cond = maybe_constant_value (cond);\n+      cond = fold_non_dependent_expr (cond);\n       maybe_infinite = integer_nonzerop (cond);\n     }\n   vec_safe_push (cp_function_chain->infinite_loops,\n@@ -543,7 +542,6 @@ end_maybe_infinite_loop (tree cond)\n   if (current != NULL_TREE)\n     {\n       cond = fold_non_dependent_expr (cond);\n-      cond = maybe_constant_value (cond);\n       if (integer_nonzerop (cond))\n \tcurrent_function_infinite_loop = 1;\n     }\n@@ -7043,7 +7041,7 @@ finish_static_assert (tree condition, tree message, location_t location,\n     }\n \n   /* Fold the expression and convert it to a boolean value. */\n-  condition = fold_non_dependent_expr (condition);\n+  condition = instantiate_non_dependent_expr (condition);\n   condition = cp_convert (boolean_type_node, condition, tf_warning_or_error);\n   condition = maybe_constant_value (condition);\n "}, {"sha": "21cecc2e39c8da17813be99ab125c2607475564d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -4143,7 +4143,7 @@ fold_if_not_in_template (tree expr)\n   /* In the body of a template, there is never any need to call\n      \"fold\".  We will call fold later when actually instantiating the\n      template.  Integral constant expressions in templates will be\n-     evaluated via fold_non_dependent_expr, as necessary.  */\n+     evaluated via instantiate_non_dependent_expr, as necessary.  */\n   if (processing_template_decl)\n     return expr;\n "}, {"sha": "05bc916cdc7188eb59812e4baee0c90163020597", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -1787,7 +1787,7 @@ cxx_alignas_expr (tree e)\n     /* Leave value-dependent expression alone for now. */\n     return e;\n \n-  e = fold_non_dependent_expr (e);\n+  e = instantiate_non_dependent_expr (e);\n   e = mark_rvalue_use (e);\n \n   /* [dcl.align]/2 says:\n@@ -4135,8 +4135,7 @@ cp_build_binary_op (location_t location,\n \t      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))\n \t{\n \t  enum tree_code tcode0 = code0, tcode1 = code1;\n-\t  tree cop1 = fold_non_dependent_expr_sfinae (op1, tf_none);\n-\t  cop1 = maybe_constant_value (cop1);\n+\t  tree cop1 = fold_non_dependent_expr (op1);\n \t  doing_div_or_mod = true;\n \t  warn_for_div_by_zero (location, cop1);\n \n@@ -4175,8 +4174,7 @@ cp_build_binary_op (location_t location,\n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n       {\n-\ttree cop1 = fold_non_dependent_expr_sfinae (op1, tf_none);\n-\tcop1 = maybe_constant_value (cop1);\n+\ttree cop1 = fold_non_dependent_expr (op1);\n \tdoing_div_or_mod = true;\n \twarn_for_div_by_zero (location, cop1);\n       }\n@@ -4270,8 +4268,7 @@ cp_build_binary_op (location_t location,\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  tree const_op1 = fold_non_dependent_expr_sfinae (op1, tf_none);\n-\t  const_op1 = maybe_constant_value (const_op1);\n+\t  tree const_op1 = fold_non_dependent_expr (op1);\n \t  if (TREE_CODE (const_op1) != INTEGER_CST)\n \t    const_op1 = op1;\n \t  result_type = type0;\n@@ -4320,8 +4317,7 @@ cp_build_binary_op (location_t location,\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  tree const_op1 = fold_non_dependent_expr_sfinae (op1, tf_none);\n-\t  const_op1 = maybe_constant_value (const_op1);\n+\t  tree const_op1 = fold_non_dependent_expr (op1);\n \t  if (TREE_CODE (const_op1) != INTEGER_CST)\n \t    const_op1 = op1;\n \t  result_type = type0;\n@@ -4993,10 +4989,8 @@ cp_build_binary_op (location_t location,\n       /* OP0 and/or OP1 might have side-effects.  */\n       op0 = cp_save_expr (op0);\n       op1 = cp_save_expr (op1);\n-      op0 = maybe_constant_value (fold_non_dependent_expr_sfinae (op0,\n-\t\t\t\t\t\t\t\t  tf_none));\n-      op1 = maybe_constant_value (fold_non_dependent_expr_sfinae (op1,\n-\t\t\t\t\t\t\t\t  tf_none));\n+      op0 = fold_non_dependent_expr (op0);\n+      op1 = fold_non_dependent_expr (op1);\n       if (doing_div_or_mod && (flag_sanitize & (SANITIZE_DIVIDE\n \t\t\t\t\t\t| SANITIZE_FLOAT_DIVIDE)))\n \t{"}, {"sha": "01a0671341eb774483966168960fc54150953a0b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/234bef96a1cff5d8ad577777fae051105ec01b6e/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=234bef96a1cff5d8ad577777fae051105ec01b6e", "patch": "@@ -797,7 +797,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n   if (decl_maybe_constant_var_p (decl) || TREE_STATIC (decl))\n     {\n       bool const_init;\n-      value = fold_non_dependent_expr (value);\n+      value = instantiate_non_dependent_expr (value);\n       if (DECL_DECLARED_CONSTEXPR_P (decl)\n \t  || DECL_IN_AGGR_P (decl))\n \t{\n@@ -872,7 +872,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n       return ok;\n     }\n \n-  init = maybe_constant_value (fold_non_dependent_expr_sfinae (init, tf_none));\n+  init = fold_non_dependent_expr (init);\n \n   if (TREE_CODE (type) == INTEGER_TYPE\n       && TREE_CODE (ftype) == REAL_TYPE)\n@@ -1176,7 +1176,7 @@ massage_init_elt (tree type, tree init, tsubst_flags_t complain)\n     init = TARGET_EXPR_INITIAL (init);\n   /* When we defer constant folding within a statement, we may want to\n      defer this folding as well.  */\n-  tree t = fold_non_dependent_expr_sfinae (init, complain);\n+  tree t = fold_non_dependent_expr (init);\n   t = maybe_constant_init (t);\n   if (TREE_CONSTANT (t))\n     init = t;"}]}