{"sha": "8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "node_id": "C_kwDOANBUbNoAKDhiMDE3ODI5ZjFkMjJlYTZlZjBjZDljYjA1YzI5ZTA0YjU3NzZkZTA", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-04-03T15:22:57Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-04-04T12:05:02Z"}, "message": "ast: Move rust-path implementation out of rust-ast\n\nMove rust-path implementation details out of rust-ast.cc file. This will\nhopefully decrease compile time and make things clearer.\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: Add new file for rust-path implementation.\n\t* ast/rust-ast.cc (PathInExpression::as_string): Move function\n\tto the new file.\n\t(PathPattern::as_string): Likewise.\n\t(QualifiedPathInExpression::as_string): Likewise.\n\t(ConstGenericParam::as_string): Likewise.\n\t(QualifiedPathInType::as_string): Likewise.\n\t(TypePath::as_string): Likewise.\n\t(PathPattern::convert_to_simple_path): Likewise.\n\t(TypePath::as_simple_path): Likewise.\n\t(PathExprSegment::as_string): Likewise.\n\t(GenericArgs::as_string): Likewise.\n\t(GenericArgsBinding::as_string): Likewise.\n\t(TypePath::to_trait_bound): Likewise.\n\t(TypePathSegmentGeneric::as_string): Likewise.\n\t(TypePathFunction::as_string): Likewise.\n\t(TypePathSegmentFunction::as_string): Likewise.\n\t(ConstGenericParam::accept_vis): Likewise.\n\t(PathInExpression::accept_vis): Likewise.\n\t(TypePathSegment::accept_vis): Likewise.\n\t(TypePathSegmentGeneric::accept_vis): Likewise.\n\t(TypePathSegmentFunction::accept_vis): Likewise.\n\t(TypePath::accept_vis): Likewise.\n\t(QualifiedPathInExpression::accept_vis): Likewise.\n\t(QualifiedPathInType::accept_vis): Likewise.\n\t(GenericArg::disambiguate_to_const): Likewise.\n\t(GenericArg::disambiguate_to_type): Likewise.\n\t* ast/rust-path.cc: New file.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "19d1558c1912441768a50e1d729ef6bf82fcd079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19d1558c1912441768a50e1d729ef6bf82fcd079"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b99448f4b02957c71ceb1adc3fb8cfa2a7602ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99448f4b02957c71ceb1adc3fb8cfa2a7602ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b99448f4b02957c71ceb1adc3fb8cfa2a7602ab9"}], "stats": {"total": 687, "additions": 361, "deletions": 326}, "files": [{"sha": "6b5861ac6f746170824dfe0dc92c6b611485b388", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "patch": "@@ -73,6 +73,7 @@ GRS_OBJS = \\\n     rust/rust-cfg-parser.o \\\n     rust/rust-parse.o \\\n     rust/rust-ast.o \\\n+    rust/rust-path.o \\\n     rust/rust-ast-fragment.o \\\n     rust/rust-ast-dump.o \\\n     rust/rust-ast-tokenstream.o \\"}, {"sha": "c0a54a5763884fc774b1d0dae02b657ddcbf7cb9", "filename": "gcc/rust/ast/rust-ast.cc", "status": "modified", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0/gcc%2Frust%2Fast%2Frust-ast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0/gcc%2Frust%2Fast%2Frust-ast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.cc?ref=8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "patch": "@@ -1356,17 +1356,6 @@ MacroInvocData::as_string () const\n   return path.as_string () + \"!\" + token_tree.as_string ();\n }\n \n-std::string\n-PathInExpression::as_string () const\n-{\n-  std::string str;\n-\n-  if (has_opening_scope_resolution)\n-    str = \"::\";\n-\n-  return str + PathPattern::as_string ();\n-}\n-\n std::string\n ExprStmtWithBlock::as_string () const\n {\n@@ -1437,20 +1426,6 @@ ClosureExprInnerTyped::as_string () const\n   return str;\n }\n \n-std::string\n-PathPattern::as_string () const\n-{\n-  std::string str;\n-\n-  for (const auto &segment : segments)\n-    str += segment.as_string () + \"::\";\n-\n-  // basically a hack - remove last two characters of string (remove final ::)\n-  str.erase (str.length () - 2);\n-\n-  return str;\n-}\n-\n std::string\n QualifiedPathType::as_string () const\n {\n@@ -1463,12 +1438,6 @@ QualifiedPathType::as_string () const\n   return str + \">\";\n }\n \n-std::string\n-QualifiedPathInExpression::as_string () const\n-{\n-  return path_type.as_string () + \"::\" + PathPattern::as_string ();\n-}\n-\n std::string\n BorrowExpr::as_string () const\n {\n@@ -2372,38 +2341,12 @@ LifetimeParam::as_string () const\n   return str;\n }\n \n-std::string\n-ConstGenericParam::as_string () const\n-{\n-  std::string str (\"ConstGenericParam: \");\n-  str += \"const \" + name + \": \" + type->as_string ();\n-\n-  if (has_default_value ())\n-    str += \" = \" + get_default_value ().as_string ();\n-\n-  return str;\n-}\n-\n std::string\n MacroMatchFragment::as_string () const\n {\n   return \"$\" + ident + \": \" + frag_spec.as_string ();\n }\n \n-std::string\n-QualifiedPathInType::as_string () const\n-{\n-  /* TODO: this may need adjusting if segments (e.g. with functions) can't be\n-   * literalised */\n-  std::string str = path_type.as_string ();\n-\n-  str += \"::\" + associated_segment->as_string ();\n-  for (const auto &segment : segments)\n-    str += \"::\" + segment->as_string ();\n-\n-  return str;\n-}\n-\n std::string\n MacroMatchRepetition::as_string () const\n {\n@@ -2467,25 +2410,6 @@ Lifetime::as_string () const\n     }\n }\n \n-std::string\n-TypePath::as_string () const\n-{\n-  /* TODO: this may need to be rewritten if a segment (e.g. function) can't be\n-   * literalised */\n-  std::string str;\n-\n-  if (has_opening_scope_resolution)\n-    str = \"::\";\n-\n-  for (const auto &segment : segments)\n-    str += segment->as_string () + \"::\";\n-\n-  // kinda hack - remove last 2 '::' characters\n-  str.erase (str.length () - 2);\n-\n-  return str;\n-}\n-\n std::string\n TypeParam::as_string () const\n {\n@@ -2519,136 +2443,6 @@ TypeParam::as_string () const\n   return str;\n }\n \n-SimplePath\n-PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n-{\n-  if (!has_segments ())\n-    return SimplePath::create_empty ();\n-\n-  // create vector of reserved size (to minimise reallocations)\n-  std::vector<SimplePathSegment> simple_segments;\n-  simple_segments.reserve (segments.size ());\n-\n-  for (const auto &segment : segments)\n-    {\n-      // return empty path if doesn't meet simple path segment requirements\n-      if (segment.is_error () || segment.has_generic_args ()\n-\t  || segment.as_string () == \"Self\")\n-\treturn SimplePath::create_empty ();\n-\n-      // create segment and add to vector\n-      std::string segment_str = segment.as_string ();\n-      simple_segments.push_back (\n-\tSimplePathSegment (std::move (segment_str), segment.get_locus ()));\n-    }\n-\n-  // kind of a HACK to get locus depending on opening scope resolution\n-  Location locus = Linemap::unknown_location ();\n-  if (with_opening_scope_resolution)\n-    locus = simple_segments[0].get_locus () - 2; // minus 2 chars for ::\n-  else\n-    locus = simple_segments[0].get_locus ();\n-  // FIXME: this hack probably doesn't actually work\n-\n-  return SimplePath (std::move (simple_segments), with_opening_scope_resolution,\n-\t\t     locus);\n-}\n-\n-SimplePath\n-TypePath::as_simple_path () const\n-{\n-  if (segments.empty ())\n-    return SimplePath::create_empty ();\n-\n-  // create vector of reserved size (to minimise reallocations)\n-  std::vector<SimplePathSegment> simple_segments;\n-  simple_segments.reserve (segments.size ());\n-\n-  for (const auto &segment : segments)\n-    {\n-      // return empty path if doesn't meet simple path segment requirements\n-      if (segment == nullptr || segment->is_error ()\n-\t  || !segment->is_ident_only () || segment->as_string () == \"Self\")\n-\treturn SimplePath::create_empty ();\n-\n-      // create segment and add to vector\n-      std::string segment_str = segment->as_string ();\n-      simple_segments.push_back (\n-\tSimplePathSegment (std::move (segment_str), segment->get_locus ()));\n-    }\n-\n-  return SimplePath (std::move (simple_segments), has_opening_scope_resolution,\n-\t\t     locus);\n-}\n-\n-std::string\n-PathExprSegment::as_string () const\n-{\n-  // TODO: rewrite dump to work with non-literalisable types\n-  std::string ident_str = segment_name.as_string ();\n-  if (has_generic_args ())\n-    ident_str += \"::<\" + generic_args.as_string () + \">\";\n-\n-  return ident_str;\n-}\n-\n-std::string\n-GenericArgs::as_string () const\n-{\n-  std::string args;\n-\n-  // lifetime args\n-  if (!lifetime_args.empty ())\n-    {\n-      auto i = lifetime_args.begin ();\n-      auto e = lifetime_args.end ();\n-\n-      for (; i != e; i++)\n-\t{\n-\t  args += (*i).as_string ();\n-\t  if (e != i + 1)\n-\t    args += \", \";\n-\t}\n-    }\n-\n-  // type args\n-  if (!generic_args.empty ())\n-    {\n-      auto i = generic_args.begin ();\n-      auto e = generic_args.end ();\n-\n-      for (; i != e; i++)\n-\t{\n-\t  args += (*i).as_string ();\n-\t  if (e != i + 1)\n-\t    args += \", \";\n-\t}\n-    }\n-\n-  // binding args\n-  if (!binding_args.empty ())\n-    {\n-      auto i = binding_args.begin ();\n-      auto e = binding_args.end ();\n-\n-      for (; i != e; i++)\n-\t{\n-\t  args += (*i).as_string ();\n-\t  if (e != i + 1)\n-\t    args += \", \";\n-\t}\n-    }\n-\n-  return args;\n-}\n-\n-std::string\n-GenericArgsBinding::as_string () const\n-{\n-  // TODO: rewrite to work with non-literalisable types\n-  return identifier + \" = \" + type->as_string ();\n-}\n-\n std::string\n ForLoopExpr::as_string () const\n {\n@@ -2968,13 +2762,6 @@ LetStmt::as_string () const\n   return str;\n }\n \n-// hopefully definition here will prevent circular dependency issue\n-TraitBound *\n-TypePath::to_trait_bound (bool in_parens) const\n-{\n-  return new TraitBound (TypePath (*this), get_locus (), in_parens);\n-}\n-\n std::string\n InferredType::as_string () const\n {\n@@ -3122,13 +2909,6 @@ ImplTraitTypeOneBound::as_string () const\n   return str + trait_bound.as_string ();\n }\n \n-std::string\n-TypePathSegmentGeneric::as_string () const\n-{\n-  // TODO: rewrite to work with non-linearisable types\n-  return TypePathSegment::as_string () + \"<\" + generic_args.as_string () + \">\";\n-}\n-\n std::string\n TraitObjectTypeOneBound::as_string () const\n {\n@@ -3144,40 +2924,6 @@ TraitObjectTypeOneBound::as_string () const\n   return str;\n }\n \n-std::string\n-TypePathFunction::as_string () const\n-{\n-  // TODO: rewrite to work with non-linearisable types\n-  std::string str (\"(\");\n-\n-  if (has_inputs ())\n-    {\n-      auto i = inputs.begin ();\n-      auto e = inputs.end ();\n-\n-      for (; i != e; i++)\n-\t{\n-\t  str += (*i)->as_string ();\n-\t  if (e != i + 1)\n-\t    str += \", \";\n-\t}\n-    }\n-\n-  str += \")\";\n-\n-  if (has_return_type ())\n-    str += \" -> \" + return_type->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-TypePathSegmentFunction::as_string () const\n-{\n-  // TODO: rewrite to work with non-linearisable types\n-  return TypePathSegment::as_string () + function_path.as_string ();\n-}\n-\n std::string\n ArrayType::as_string () const\n {\n@@ -4933,54 +4679,6 @@ LifetimeParam::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-ConstGenericParam::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-PathInExpression::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TypePathSegment::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TypePathSegmentGeneric::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TypePathSegmentFunction::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TypePath::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-QualifiedPathInExpression::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-QualifiedPathInType::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n LiteralExpr::accept_vis (ASTVisitor &vis)\n {\n@@ -5839,29 +5537,5 @@ MetaWord::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-GenericArg\n-GenericArg::disambiguate_to_const () const\n-{\n-  rust_assert (get_kind () == Kind::Either);\n-\n-  // FIXME: is it fine to have no outer attributes?\n-  return GenericArg::create_const (\n-    std::unique_ptr<Expr> (new IdentifierExpr (path, {}, locus)));\n-}\n-\n-GenericArg\n-GenericArg::disambiguate_to_type () const\n-{\n-  rust_assert (get_kind () == Kind::Either);\n-\n-  auto segment = std::unique_ptr<TypePathSegment> (\n-    new TypePathSegment (path, false, locus));\n-  auto segments = std::vector<std::unique_ptr<TypePathSegment>> ();\n-  segments.emplace_back (std::move (segment));\n-\n-  return GenericArg::create_type (\n-    std::unique_ptr<Type> (new TypePath (std::move (segments), locus)));\n-}\n-\n } // namespace AST\n } // namespace Rust"}, {"sha": "9a3489b15f7c29c4b778437688592715ea282b41", "filename": "gcc/rust/ast/rust-path.cc", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0/gcc%2Frust%2Fast%2Frust-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0/gcc%2Frust%2Fast%2Frust-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.cc?ref=8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "patch": "@@ -0,0 +1,360 @@\n+/* General AST-related method implementations for Rust frontend.\n+   Copyright (C) 2009-2023 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-macro.h\"\n+#include \"rust-session-manager.h\"\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-operators.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+std::string\n+GenericArgs::as_string () const\n+{\n+  std::string args;\n+\n+  // lifetime args\n+  if (!lifetime_args.empty ())\n+    {\n+      auto i = lifetime_args.begin ();\n+      auto e = lifetime_args.end ();\n+\n+      for (; i != e; i++)\n+\t{\n+\t  args += (*i).as_string ();\n+\t  if (e != i + 1)\n+\t    args += \", \";\n+\t}\n+    }\n+\n+  // type args\n+  if (!generic_args.empty ())\n+    {\n+      auto i = generic_args.begin ();\n+      auto e = generic_args.end ();\n+\n+      for (; i != e; i++)\n+\t{\n+\t  args += (*i).as_string ();\n+\t  if (e != i + 1)\n+\t    args += \", \";\n+\t}\n+    }\n+\n+  // binding args\n+  if (!binding_args.empty ())\n+    {\n+      auto i = binding_args.begin ();\n+      auto e = binding_args.end ();\n+\n+      for (; i != e; i++)\n+\t{\n+\t  args += (*i).as_string ();\n+\t  if (e != i + 1)\n+\t    args += \", \";\n+\t}\n+    }\n+\n+  return args;\n+}\n+\n+GenericArg\n+GenericArg::disambiguate_to_const () const\n+{\n+  rust_assert (get_kind () == Kind::Either);\n+\n+  // FIXME: is it fine to have no outer attributes?\n+  return GenericArg::create_const (\n+    std::unique_ptr<Expr> (new IdentifierExpr (path, {}, locus)));\n+}\n+\n+GenericArg\n+GenericArg::disambiguate_to_type () const\n+{\n+  rust_assert (get_kind () == Kind::Either);\n+\n+  auto segment = std::unique_ptr<TypePathSegment> (\n+    new TypePathSegment (path, false, locus));\n+  auto segments = std::vector<std::unique_ptr<TypePathSegment>> ();\n+  segments.emplace_back (std::move (segment));\n+\n+  return GenericArg::create_type (\n+    std::unique_ptr<Type> (new TypePath (std::move (segments), locus)));\n+}\n+\n+std::string\n+GenericArgsBinding::as_string () const\n+{\n+  // TODO: rewrite to work with non-literalisable types\n+  return identifier + \" = \" + type->as_string ();\n+}\n+\n+std::string\n+ConstGenericParam::as_string () const\n+{\n+  std::string str (\"ConstGenericParam: \");\n+  str += \"const \" + name + \": \" + type->as_string ();\n+\n+  if (has_default_value ())\n+    str += \" = \" + get_default_value ().as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+PathExprSegment::as_string () const\n+{\n+  // TODO: rewrite dump to work with non-literalisable types\n+  std::string ident_str = segment_name.as_string ();\n+  if (has_generic_args ())\n+    ident_str += \"::<\" + generic_args.as_string () + \">\";\n+\n+  return ident_str;\n+}\n+\n+std::string\n+PathPattern::as_string () const\n+{\n+  std::string str;\n+\n+  for (const auto &segment : segments)\n+    str += segment.as_string () + \"::\";\n+\n+  // basically a hack - remove last two characters of string (remove final ::)\n+  str.erase (str.length () - 2);\n+\n+  return str;\n+}\n+\n+SimplePath\n+PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n+{\n+  if (!has_segments ())\n+    return SimplePath::create_empty ();\n+\n+  // create vector of reserved size (to minimise reallocations)\n+  std::vector<SimplePathSegment> simple_segments;\n+  simple_segments.reserve (segments.size ());\n+\n+  for (const auto &segment : segments)\n+    {\n+      // return empty path if doesn't meet simple path segment requirements\n+      if (segment.is_error () || segment.has_generic_args ()\n+\t  || segment.as_string () == \"Self\")\n+\treturn SimplePath::create_empty ();\n+\n+      // create segment and add to vector\n+      std::string segment_str = segment.as_string ();\n+      simple_segments.push_back (\n+\tSimplePathSegment (std::move (segment_str), segment.get_locus ()));\n+    }\n+\n+  // kind of a HACK to get locus depending on opening scope resolution\n+  Location locus = Linemap::unknown_location ();\n+  if (with_opening_scope_resolution)\n+    locus = simple_segments[0].get_locus () - 2; // minus 2 chars for ::\n+  else\n+    locus = simple_segments[0].get_locus ();\n+  // FIXME: this hack probably doesn't actually work\n+\n+  return SimplePath (std::move (simple_segments), with_opening_scope_resolution,\n+\t\t     locus);\n+}\n+\n+void\n+PathInExpression::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+PathInExpression::as_string () const\n+{\n+  std::string str;\n+\n+  if (has_opening_scope_resolution)\n+    str = \"::\";\n+\n+  return str + PathPattern::as_string ();\n+}\n+\n+std::string\n+TypePathSegmentGeneric::as_string () const\n+{\n+  // TODO: rewrite to work with non-linearisable types\n+  return TypePathSegment::as_string () + \"<\" + generic_args.as_string () + \">\";\n+}\n+\n+std::string\n+TypePathSegmentFunction::as_string () const\n+{\n+  // TODO: rewrite to work with non-linearisable types\n+  return TypePathSegment::as_string () + function_path.as_string ();\n+}\n+\n+std::string\n+TypePath::as_string () const\n+{\n+  /* TODO: this may need to be rewritten if a segment (e.g. function) can't be\n+   * literalised */\n+  std::string str;\n+\n+  if (has_opening_scope_resolution)\n+    str = \"::\";\n+\n+  for (const auto &segment : segments)\n+    str += segment->as_string () + \"::\";\n+\n+  // kinda hack - remove last 2 '::' characters\n+  str.erase (str.length () - 2);\n+\n+  return str;\n+}\n+\n+SimplePath\n+TypePath::as_simple_path () const\n+{\n+  if (segments.empty ())\n+    return SimplePath::create_empty ();\n+\n+  // create vector of reserved size (to minimise reallocations)\n+  std::vector<SimplePathSegment> simple_segments;\n+  simple_segments.reserve (segments.size ());\n+\n+  for (const auto &segment : segments)\n+    {\n+      // return empty path if doesn't meet simple path segment requirements\n+      if (segment == nullptr || segment->is_error ()\n+\t  || !segment->is_ident_only () || segment->as_string () == \"Self\")\n+\treturn SimplePath::create_empty ();\n+\n+      // create segment and add to vector\n+      std::string segment_str = segment->as_string ();\n+      simple_segments.push_back (\n+\tSimplePathSegment (std::move (segment_str), segment->get_locus ()));\n+    }\n+\n+  return SimplePath (std::move (simple_segments), has_opening_scope_resolution,\n+\t\t     locus);\n+}\n+\n+// hopefully definition here will prevent circular dependency issue\n+TraitBound *\n+TypePath::to_trait_bound (bool in_parens) const\n+{\n+  return new TraitBound (TypePath (*this), get_locus (), in_parens);\n+}\n+\n+std::string\n+TypePathFunction::as_string () const\n+{\n+  // TODO: rewrite to work with non-linearisable types\n+  std::string str (\"(\");\n+\n+  if (has_inputs ())\n+    {\n+      auto i = inputs.begin ();\n+      auto e = inputs.end ();\n+\n+      for (; i != e; i++)\n+\t{\n+\t  str += (*i)->as_string ();\n+\t  if (e != i + 1)\n+\t    str += \", \";\n+\t}\n+    }\n+\n+  str += \")\";\n+\n+  if (has_return_type ())\n+    str += \" -> \" + return_type->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+QualifiedPathInExpression::as_string () const\n+{\n+  return path_type.as_string () + \"::\" + PathPattern::as_string ();\n+}\n+\n+std::string\n+QualifiedPathInType::as_string () const\n+{\n+  /* TODO: this may need adjusting if segments (e.g. with functions) can't be\n+   * literalised */\n+  std::string str = path_type.as_string ();\n+\n+  str += \"::\" + associated_segment->as_string ();\n+  for (const auto &segment : segments)\n+    str += \"::\" + segment->as_string ();\n+\n+  return str;\n+}\n+\n+void\n+ConstGenericParam::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TypePathSegment::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TypePathSegmentGeneric::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TypePathSegmentFunction::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TypePath::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+QualifiedPathInExpression::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+QualifiedPathInType::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}]}