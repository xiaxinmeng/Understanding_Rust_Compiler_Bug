{"sha": "6447f6f983ffeaecb8753ef685d702bf2594968b", "node_id": "C_kwDOANBUbNoAKDY0NDdmNmY5ODNmZmVhZWNiODc1M2VmNjg1ZDcwMmJmMjU5NDk2OGI", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2022-01-03T16:47:38Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2022-01-03T16:47:38Z"}, "message": "Fortran: Fix array copy-in/copy-out for BIND(C) functions [PR103390]\n\nThe Fortran front end was generating invalid code for the array\ncopy-out after a call to a BIND(C) function for a dummy with the\nCONTIGUOUS attribute when the actual argument was a call to the SHAPE\nintrinsic or other array expressions that are not lvalues.  It was\nalso generating code to evaluate the argument expression multiple\ntimes on copy-in.  This patch teaches it to recognize that a copy is\nnot needed in these cases.\n\n2022-01-03  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tPR fortran/103390\n\n\tgcc/fortran/\n\t* expr.c (gfc_is_simply_contiguous): Make it smarter about\n\tfunction calls.\n\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Do not generate\n\tcopy loops for array expressions that are not \"variables\" (lvalues).\n\n\tgcc/testsuite/\n\t* gfortran.dg/c-interop/pr103390-1.f90: New.\n\t* gfortran.dg/c-interop/pr103390-2.f90: New.\n\t* gfortran.dg/c-interop/pr103390-3.f90: New.\n\t* gfortran.dg/c-interop/pr103390-4.f90: New.\n\t* gfortran.dg/c-interop/pr103390-6.f90: New.\n\t* gfortran.dg/c-interop/pr103390-7.f90: New.\n\t* gfortran.dg/c-interop/pr103390-8.f90: New.\n\t* gfortran.dg/c-interop/pr103390-9.f90: New.", "tree": {"sha": "9594a3a4dd0b3474603be8838f7b6292ab6e6a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9594a3a4dd0b3474603be8838f7b6292ab6e6a23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6447f6f983ffeaecb8753ef685d702bf2594968b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6447f6f983ffeaecb8753ef685d702bf2594968b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6447f6f983ffeaecb8753ef685d702bf2594968b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6447f6f983ffeaecb8753ef685d702bf2594968b/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6362627b27f395b054f359244fcfcb15ac0ac2ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6362627b27f395b054f359244fcfcb15ac0ac2ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6362627b27f395b054f359244fcfcb15ac0ac2ab"}], "stats": {"total": 232, "additions": 228, "deletions": 4}, "files": [{"sha": "96a2cd70900f1be6027df924486bbcddd433cb55", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -5883,8 +5883,16 @@ gfc_is_simply_contiguous (gfc_expr *expr, bool strict, bool permit_element)\n \n   if (expr->expr_type == EXPR_FUNCTION)\n     {\n-      if (expr->value.function.esym)\n-\treturn expr->value.function.esym->result->attr.contiguous;\n+      if (expr->value.function.isym)\n+\t/* TRANSPOSE is the only intrinsic that may return a\n+\t   non-contiguous array.  It's treated as a special case in\n+\t   gfc_conv_expr_descriptor too.  */\n+\treturn (expr->value.function.isym->id != GFC_ISYM_TRANSPOSE);\n+      else if (expr->value.function.esym)\n+\t/* Only a pointer to an array without the contiguous attribute\n+\t   can be non-contiguous as a result value.  */\n+\treturn (expr->value.function.esym->result->attr.contiguous\n+\t\t|| !expr->value.function.esym->result->attr.pointer);\n       else\n \t{\n \t  /* Type-bound procedures.  */"}, {"sha": "381915e2a766658b1d83bbf36ca3915a1e845380", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -5536,13 +5536,17 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n     {\n       /* If the actual argument can be noncontiguous, copy-in/out is required,\n \t if the dummy has either the CONTIGUOUS attribute or is an assumed-\n-\t length assumed-length/assumed-size CHARACTER array.  */\n+\t length assumed-length/assumed-size CHARACTER array.  This only\n+\t applies if the actual argument is a \"variable\"; if it's some\n+\t non-lvalue expression, we are going to evaluate it to a\n+\t temporary below anyway.  */\n       se.force_no_tmp = 1;\n       if ((fsym->attr.contiguous\n \t   || (fsym->ts.type == BT_CHARACTER && !fsym->ts.u.cl->length\n \t       && (fsym->as->type == AS_ASSUMED_SIZE\n \t\t   || fsym->as->type == AS_EXPLICIT)))\n-\t  && !gfc_is_simply_contiguous (e, false, true))\n+\t  && !gfc_is_simply_contiguous (e, false, true)\n+\t  && gfc_expr_is_variable (e))\n \t{\n \t  bool optional = fsym->attr.optional;\n \t  fsym->attr.optional = 0;\n@@ -6841,6 +6845,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t\t     fsym->attr.pointer);\n \t\t}\n \t      else\n+\t\t/* This is where we introduce a temporary to store the\n+\t\t   result of a non-lvalue array expression.  */\n \t\tgfc_conv_array_parameter (&parmse, e, nodesc_arg, fsym,\n \t\t\t\t\t  sym->name, NULL);\n "}, {"sha": "52d8835b1649a8aa00cf5e5066f2c2fc912f61ce", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-1.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! This program used to ICE in gimplification on the call to S, because it\n+! was trying to copy out the array after the call to something that wasn't\n+! an lvalue.\n+\n+program p\n+   integer, pointer :: z(:)\n+   integer, target :: x(3) = [1, 2, 3]\n+   z => x\n+   call s(shape(z))\n+contains\n+   subroutine s(x) bind(c)\n+      integer, contiguous :: x(:)\n+   end\n+end\n+\n+! It should not emit any copy loops, just the loop for inlining SHAPE.\n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 1 \"original\" } }\n+\n+! It should not emit code to check the contiguous property.\n+! { dg-final { scan-tree-dump-not \"contiguous\\\\.\\[0-9\\]+\" \"original\" } }"}, {"sha": "771d81d2310deac8d617dac8249fd2decdf2e65d", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-2.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check that copy loops to ensure contiguity of transpose result are\n+! still generated after fixing pr103390, and that it does not ICE.\n+\n+program p\n+   integer, pointer :: z(:,:)\n+   integer, target :: x(3,3) = reshape ([1, 2, 3, 4, 5, 6, 7, 8, 9], shape(x))\n+   z => x\n+   call s(transpose(z))\n+contains\n+   subroutine s(x) bind(c)\n+      integer, contiguous :: x(:,:)\n+   end\n+end\n+\n+! Expect 2 nested copy loops both before and after the call to S.  \n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 4 \"original\" } }\n+"}, {"sha": "bd350114bb3c0940f474a544f267edc4dccdf193", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-3.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-3.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check that copy loops to ensure contiguity of the result of a function\n+! that returns a non-pointer array are generated properly after fixing\n+! pr103390, and that it does not ICE.  In this case no copying is required.\n+\n+program p\n+   integer, pointer :: z(:)\n+   integer, target :: x(3) = [1, 2, 3]\n+   z => x\n+   call s(i(z))\n+contains\n+   function i(x)\n+      integer :: i(3)\n+      integer, pointer :: x(:)\n+      i = x\n+   end\n+   subroutine s(x) bind(c)\n+      integer, contiguous :: x(:)\n+   end\n+end\n+\n+! Expect one loop to copy the array contents to a temporary in function i.\n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 1 \"original\" } }\n+\n+! It should not emit code to check the contiguous property.\n+! { dg-final { scan-tree-dump-not \"contiguous\\\\.\\[0-9\\]+\" \"original\" } }\n+"}, {"sha": "b8b64edf81719b082d7d15ed50da623e2d6e7a82", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-4.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-4.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check that copy loops to ensure contiguity of the result of a function\n+! that returns a pointer to an array are generated properly after fixing\n+! pr103390, and that it does not ICE.\n+\n+program p\n+   integer, pointer :: z(:)\n+   integer, target :: x(3) = [1, 2, 3]\n+   z => x\n+   call s(i(z))\n+contains\n+   function i(x)\n+      integer, pointer :: i(:)\n+      integer, pointer :: x(:)\n+      i => x\n+   end\n+   subroutine s(x) bind(c)\n+      integer, contiguous :: x(:)\n+   end\n+end\n+\n+! Expect a copy loop both before and after the call to S.  \n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 2 \"original\" } }"}, {"sha": "c87b9793533fa8e6699bd531a2780c804fb39f96", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-5.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-5.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check that copy loops to ensure contiguity of the result of a function\n+! that returns a pointer to an array are generated properly after fixing\n+! pr103390, and that it does not ICE.  This variant is for an intent(in)\n+! dummy argument so no copy-out is needed, only copy-in.\n+\n+program p\n+   integer, pointer :: z(:)\n+   integer, target :: x(3) = [1, 2, 3]\n+   z => x\n+   call s(i(z))\n+contains\n+   function i(x)\n+      integer, pointer :: i(:)\n+      integer, pointer :: x(:)\n+      i => x\n+   end\n+   subroutine s(x) bind(c)\n+      integer, contiguous, intent(in) :: x(:)\n+   end\n+end\n+\n+! Expect a copy loop before the call to S.  \n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 1 \"original\" } }"}, {"sha": "394525b667522da39e39f435461707802dcffa6c", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-6.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-6.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check that copy loops to ensure contiguity of transpose result are\n+! generated properly after fixing pr103390, and that it does not ICE.\n+! This variant is for an intent(in) dummy argument so no copy-out\n+! is needed, only copy-in.\n+\n+program p\n+   integer, pointer :: z(:,:)\n+   integer, target :: x(3,3) = reshape ([1, 2, 3, 4, 5, 6, 7, 8, 9], shape(x))\n+   z => x\n+   call s(transpose(z))\n+contains\n+   subroutine s(x) bind(c)\n+      integer, contiguous, intent(in) :: x(:,:)\n+   end\n+end\n+\n+! Expect 2 nested copy loops before the call to S.  \n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 2 \"original\" } }\n+"}, {"sha": "d86dc79e19db36a8a56980fb10d5c5c842e8d0bf", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-7.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-7.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check that copy loops to ensure contiguity of the result of an array\n+! section expression are generated properly after fixing pr103390, and\n+! that it does not ICE.\n+\n+program p\n+   integer, pointer :: z(:)\n+   integer :: A(5) = [1, 2, 3, 4, 5]\n+   call s(A(::2))\n+contains\n+   subroutine s(x) bind(c)\n+      integer, contiguous :: x(:)\n+   end\n+end\n+\n+! Expect copy loops before and after the call to S.  \n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 2 \"original\" } }"}, {"sha": "3a3b3a8def57b098133622c327472e9242e368ef", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-8.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-8.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check that copy loops to ensure contiguity of the result of an array\n+! section expression are generated properly after fixing pr103390,\n+! and that it does not ICE.  This case is for an intent(in)\n+! dummy so no copy-out should occur, only copy-in.\n+\n+program p\n+   integer, pointer :: z(:)\n+   integer, parameter :: A(5) = [1, 2, 3, 4, 5]\n+   call s(A(::2))\n+contains\n+   subroutine s(x) bind(c)\n+      integer, contiguous, intent(in) :: x(:)\n+   end\n+end\n+\n+! Expect a copy loop before the call to S.  \n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 1 \"original\" } }"}, {"sha": "0d655b53883ba25ca0738227ad3b5ad038fb7cfc", "filename": "gcc/testsuite/gfortran.dg/c-interop/pr103390-9.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6447f6f983ffeaecb8753ef685d702bf2594968b/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fpr103390-9.f90?ref=6447f6f983ffeaecb8753ef685d702bf2594968b", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check that copy loops to ensure contiguity of the result of an elemental\n+! array-valued expression are generated properly after fixing pr103390,\n+! and that it does not ICE.\n+\n+program p\n+   integer, pointer :: z(:)\n+   integer :: a(3) = [1, 2, 3];\n+   integer :: b(3) = [4, 5, 6];\n+   call s(a + b);\n+contains\n+   subroutine s(x) bind(c)\n+      integer, contiguous :: x(:)\n+   end\n+end\n+\n+! We only expect one loop before the call, to fill in the contiguous\n+! temporary.  No copy-out is needed since the temporary is effectively\n+! an rvalue.\n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 1 \"original\" } }\n+\n+! It should not emit code to check the contiguous property.\n+! { dg-final { scan-tree-dump-not \"contiguous\\\\.\\[0-9\\]+\" \"original\" } }\n+"}]}