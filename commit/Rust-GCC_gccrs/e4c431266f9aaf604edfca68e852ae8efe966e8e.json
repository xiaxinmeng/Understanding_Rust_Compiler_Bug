{"sha": "e4c431266f9aaf604edfca68e852ae8efe966e8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRjNDMxMjY2ZjlhYWY2MDRlZGZjYTY4ZTg1MmFlOGVmZTk2NmU4ZQ==", "commit": {"author": {"name": "Jeff Chapman II", "email": "jchapman@lock3software.com", "date": "2019-10-31T02:31:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-10-31T02:31:48Z"}, "message": "PR c++/84810 - constraints on lambdas\n\nAttached is a patch that adds parsing of the optional requires-clause in a\nlambda-expression and lambda-declarator. Additionally, shorthand constraints\nfrom the template-parameter-list are now actually applied and constrain the\nsynthesized operator().\n\nPreviously we were not parsing the requires clauses at all and not saving\nthe shorthand constraints in the place expected by grokfndecl.\n\nThe trailing requires-clause is now also used to suppress synthesis of the\nconversion to function pointer for non-capturing non-generic lambdas as per\nexpr.prim.lambda.closure/7.\n\nThis includes a fix to template_class_depth. Previously it was computing the\nwrong depth for lambdas in the initializer of a static member of a class\ntemplate, exhibited by the concepts-lambda4 test which currently fails on\ntrunk. The bug was causing grokfndecl to use the constraints from the\ntemplate class for the lambda.\n\ngcc/cp/\n2019-10-30  Jeff Chapman II  <jchapman@lock3software.com>\n\n\tPR c++/84810 - constraints on lambdas\n\t* lambda.c (maybe_add_lambda_conv_op): Do not synthesize\n\tconversion if the call operator does not satisfy its constraints.\n\t* parser.c (cp_parser_lambda_declarator_opt): Parse\n\trequires-clause on generic lambdas; combine with shorthand\n\tconstraints. Parse trailing requires-clause and attach to the\n\tsynthesized call operator.\n\t* pt.c (template_class_depth): Only inspect\n\tLAMBDA_TYPE_EXTRA_SCOPE if it is present. This fixes an\n\tincorrect depth calculation for lambdas inside the initializer\n\tof a static data member of a template class.\n\ngcc/testsuite/\n2019-10-30  Jeff Chapman II  <jchapman@lock3software.com>\n\n\tPR c++/84810 - constraints on lambdas\n\t* g++.dg/cpp2a/concepts-lambda2.C: New test.\n\t* g++.dg/cpp2a/concepts-lambda3.C: Ditto.\n\t* g++.dg/cpp2a/concepts-lambda4.C: Ditto.\n\t* g++.dg/cpp2a/concepts-pr84810.C: Ditto.\n\nFrom-SVN: r277655", "tree": {"sha": "7f8442e216b2d8722a38b040707deedc3c3da7cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f8442e216b2d8722a38b040707deedc3c3da7cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4c431266f9aaf604edfca68e852ae8efe966e8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c431266f9aaf604edfca68e852ae8efe966e8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4c431266f9aaf604edfca68e852ae8efe966e8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c431266f9aaf604edfca68e852ae8efe966e8e/comments", "author": {"login": "JAChapmanII", "id": 290834, "node_id": "MDQ6VXNlcjI5MDgzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/290834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JAChapmanII", "html_url": "https://github.com/JAChapmanII", "followers_url": "https://api.github.com/users/JAChapmanII/followers", "following_url": "https://api.github.com/users/JAChapmanII/following{/other_user}", "gists_url": "https://api.github.com/users/JAChapmanII/gists{/gist_id}", "starred_url": "https://api.github.com/users/JAChapmanII/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JAChapmanII/subscriptions", "organizations_url": "https://api.github.com/users/JAChapmanII/orgs", "repos_url": "https://api.github.com/users/JAChapmanII/repos", "events_url": "https://api.github.com/users/JAChapmanII/events{/privacy}", "received_events_url": "https://api.github.com/users/JAChapmanII/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "56e0346dcb882b07199b8b19616b52f9667e356f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e0346dcb882b07199b8b19616b52f9667e356f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56e0346dcb882b07199b8b19616b52f9667e356f"}], "stats": {"total": 273, "additions": 270, "deletions": 3}, "files": [{"sha": "d621beca2ebb2817270c971f9d25f0ced71af03d", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=e4c431266f9aaf604edfca68e852ae8efe966e8e", "patch": "@@ -1046,6 +1046,12 @@ maybe_add_lambda_conv_op (tree type)\n       return;\n     }\n \n+  /* Non-generic non-capturing lambdas only have a conversion function to\n+     pointer to function when the trailing requires-clause's constraints are\n+     satisfied.  */\n+  if (!generic_lambda_p && !constraints_satisfied_p (callop))\n+    return;\n+\n   /* Non-template conversion operators are defined directly with build_call_a\n      and using DIRECT_ARGVEC for arguments (including 'this').  Templates are\n      deferred and the CALL is built in-place.  In the case of a deduced return"}, {"sha": "f1664e66087fce28a21def7c0b45feb54109f01e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e4c431266f9aaf604edfca68e852ae8efe966e8e", "patch": "@@ -10835,11 +10835,13 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \n    lambda-declarator:\n      < template-parameter-list [opt] >\n+       requires-clause [opt]\n      ( parameter-declaration-clause [opt] )\n        attribute-specifier [opt]\n        decl-specifier-seq [opt]\n        exception-specification [opt]\n        lambda-return-type-clause [opt]\n+       requires-clause [opt]\n \n    LAMBDA_EXPR is the current representation of the lambda expression.  */\n \n@@ -10858,6 +10860,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n   tree template_param_list = NULL_TREE;\n   tree tx_qual = NULL_TREE;\n   tree return_type = NULL_TREE;\n+  tree trailing_requires_clause = NULL_TREE;\n   cp_decl_specifier_seq lambda_specs;\n   clear_decl_specs (&lambda_specs);\n \n@@ -10877,9 +10880,20 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       cp_lexer_consume_token (parser->lexer);\n \n       template_param_list = cp_parser_template_parameter_list (parser);\n-\n       cp_parser_skip_to_end_of_template_parameter_list (parser);\n \n+      /* We may have a constrained generic lambda; parse the requires-clause\n+\t immediately after the template-parameter-list and combine with any\n+\t shorthand constraints present.  */\n+      tree dreqs = cp_parser_requires_clause_opt (parser);\n+      if (flag_concepts)\n+\t{\n+\t  tree reqs = get_shorthand_constraints (current_template_parms);\n+\t  if (dreqs)\n+\t    reqs = combine_constraint_expressions (reqs, dreqs);\n+\t  TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n+\t}\n+\n       /* We just processed one more parameter list.  */\n       ++parser->num_template_parameter_lists;\n     }\n@@ -10943,6 +10957,9 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       if (cp_next_tokens_can_be_gnu_attribute_p (parser))\n \tgnu_attrs = cp_parser_gnu_attributes_opt (parser);\n \n+      /* Parse optional trailing requires clause.  */\n+      trailing_requires_clause = cp_parser_requires_clause_opt (parser);\n+\n       /* The function parameters must be in scope all the way until after the\n          trailing-return-type in case of decltype.  */\n       pop_bindings_and_leave_scope ();\n@@ -10989,7 +11006,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \t\t\t\t       tx_qual,\n \t\t\t\t       exception_spec,\n                                        return_type,\n-                                       /*requires_clause*/NULL_TREE);\n+\t\t\t\t       trailing_requires_clause);\n     declarator->std_attributes = std_attrs;\n \n     fco = grokmethod (&return_type_specs,"}, {"sha": "419e8b8fcd76af59124a705f83db4cf4fef61235", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e4c431266f9aaf604edfca68e852ae8efe966e8e", "patch": "@@ -383,7 +383,7 @@ template_class_depth (tree type)\n \n       if (DECL_P (type))\n \ttype = CP_DECL_CONTEXT (type);\n-      else if (LAMBDA_TYPE_P (type))\n+      else if (LAMBDA_TYPE_P (type) && LAMBDA_TYPE_EXTRA_SCOPE (type))\n \ttype = LAMBDA_TYPE_EXTRA_SCOPE (type);\n       else\n \ttype = CP_TYPE_CONTEXT (type);"}, {"sha": "ffad95cb77ae59a4927f6ad501f50ec7331785bc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda2.C", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda2.C?ref=e4c431266f9aaf604edfca68e852ae8efe966e8e", "patch": "@@ -0,0 +1,153 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept False = false;\n+\n+template<typename T>\n+concept C1 = __is_same_as(T, int)\n+  || __is_same_as(T, long long)\n+  || __is_same_as(T, char);\n+\n+template<typename T>\n+concept IsNotLarge = !__is_same_as(T, long long);\n+\n+template<typename T>\n+concept IsNotTiny = !__is_same_as(T, char);\n+\n+template<IsNotLarge T>\n+struct Foo\n+{\n+  static constexpr auto a = [](auto n) { return n; };\n+  template<IsNotTiny S>\n+  auto b()\n+  {\n+    return [](False auto n) { return n; };\n+  }\n+};\n+\n+template<IsNotTiny T>\n+struct Bar\n+{\n+  static constexpr auto a =\n+    []<IsNotTiny R>(R t) { return t; }('a'); // { dg-error \"no match\" }\n+  char b =\n+    []<IsNotTiny R>(R t) { return t; }('b'); // { dg-error \"no match\" }\n+\n+  static constexpr auto a2 =\n+    [](char t) requires false { return t; }('a'); // { dg-error \"no match\" }\n+  char b2 =\n+    [](char t) requires false { return t; }('b'); // { dg-error \"no match\" }\n+};\n+\n+template<IsNotLarge S>\n+S c =\n+  []<IsNotTiny R>(R t) { return t; }('c'); // { dg-error \"no match\" }\n+template<IsNotLarge S>\n+S c2 =\n+  [](char t) requires false { return t; }('c'); // { dg-error \"no match\" }\n+\n+Bar<long long> bar;\n+\n+void test0()\n+{\n+  auto bar_a = bar.a;\n+  auto bar_b = bar.b;\n+  auto c = ::c<char>;\n+  auto bar_a2 = bar.a2;\n+  auto bar_b2 = bar.b2;\n+  auto c2 = ::c2<char>;\n+\n+  auto g0 = []<False T>(T t) { return t; };\n+  auto g1 = []<typename T> requires False<T> (T t) { return t; };\n+  auto g2 = []<typename T>(T t) requires False<decltype(t)> { return t; };\n+  auto g3 = [](int t) requires False<decltype(t)> { return t; };\n+  auto g4 = [](False auto t) { return t; };\n+  auto g5 = [](auto t) requires False<decltype(t)> { return t; };\n+  auto g6 = [](int t) requires False<int> { return t; };\n+  auto g7 = [](int t) requires false { return t; };\n+  g0(0); // { dg-error \"no match\" }\n+  g1(0); // { dg-error \"no match\" }\n+  g2(0); // { dg-error \"no match\" }\n+  g3(0); // { dg-error \"no match\" }\n+  g4(0); // { dg-error \"no match\" }\n+  g5(0); // { dg-error \"no match\" }\n+  g6(0); // { dg-error \"no match\" }\n+  g7(0); // { dg-error \"no match\" }\n+}\n+\n+void test1()\n+{\n+  int var{-1};\n+  auto g0 = [&]<False T>(T t) { return t; };\n+  auto g1 = [&]<typename T> requires False<T> (T t) { return t; };\n+  auto g2 = [&]<typename T>(T t) requires False<decltype(t)> { return t; };\n+  auto g3 = [&](int t) requires False<decltype(t)> { return t; };\n+  auto g4 = [&](False auto t) { return t; };\n+  auto g5 = [&](auto t) requires False<decltype(t)> { return t; };\n+  auto g6 = [&](int t) requires False<int> { return t; };\n+  auto g7 = [&](int t) requires false { return t; };\n+  g0(0); // { dg-error \"no match\" }\n+  g1(0); // { dg-error \"no match\" }\n+  g2(0); // { dg-error \"no match\" }\n+  g3(0); // { dg-error \"no match\" }\n+  g4(0); // { dg-error \"no match\" }\n+  g5(0); // { dg-error \"no match\" }\n+  g6(0); // { dg-error \"no match\" }\n+  g7(0); // { dg-error \"no match\" }\n+}\n+\n+void test2()\n+{\n+  auto x = []<IsNotTiny T>(auto a, T t, auto b)\n+    requires IsNotTiny<decltype(a)> && IsNotLarge<decltype(b)>\n+    { return a + t + (T)b; };\n+  x(5LL, 2LL, 1);\n+\n+  x('0', 2LL, 1LL); // { dg-error \"no match\" }\n+  x(5LL, '0', 1LL); // { dg-error \"no match\" }\n+  x(5LL, 2LL, 1LL); // { dg-error \"no match\" }\n+}\n+\n+void test3()\n+{\n+  auto x = []<IsNotTiny T>(IsNotTiny auto a, T t, IsNotLarge auto b)\n+    { return a + t + (T)b; };\n+  x(5LL, 2LL, 1);\n+\n+  x('0', 2LL, 1LL); // { dg-error \"no match\" }\n+  x(5LL, '0', 1LL); // { dg-error \"no match\" }\n+  x(5LL, 2LL, 1LL); // { dg-error \"no match\" }\n+}\n+\n+void test4()\n+{\n+  auto g = []<C1 T> requires IsNotTiny<T>(T t) -> T\n+    requires IsNotLarge<decltype(t)> { return t; };\n+  g(5.5); // { dg-error \"no match\" }\n+  g('a'); // { dg-error \"no match\" }\n+  g(1LL); // { dg-error \"no match\" }\n+}\n+\n+void test5()\n+{\n+  Foo<int> foo1;\n+  foo1.a(5.5);\n+  foo1.a(1LL);\n+  foo1.b<char>(); // { dg-error \"no match\" }\n+  foo1.b<long long>()(5); // { dg-error \"no match\" }\n+\n+  Foo<double> foo2;\n+  foo2.a(5.5);\n+  foo2.a(1LL);\n+  foo2.b<char>(); // { dg-error \"no match\" }\n+  foo2.b<long long>()(5); // { dg-error \"no match\" }\n+}\n+\n+using Func = int(*)(int);\n+\n+void test6()\n+{\n+  Func f1 = [](int a) requires false { return a; }; // { dg-error \"cannot convert\" }\n+  Func f2 = [](auto a) requires false { return a; }; // { dg-error \"cannot convert\" }\n+}\n+"}, {"sha": "7e668ffeddd346efa0d6eb901adf135dd73a49c4", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda3.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda3.C?ref=e4c431266f9aaf604edfca68e852ae8efe966e8e", "patch": "@@ -0,0 +1,64 @@\n+// { dg-do run { target c++2a } }\n+\n+template<typename T>\n+concept C1 = __is_same_as(T, int)\n+  || __is_same_as(T, long long)\n+  || __is_same_as(T, char);\n+\n+template<typename T>\n+concept IsNotLarge = !__is_same_as(T, long long);\n+\n+template<typename T>\n+concept IsNotTiny = !__is_same_as(T, char);\n+\n+template<IsNotLarge T>\n+struct Foo\n+{\n+  static constexpr auto a = [](auto n) { return n; };\n+  template<IsNotTiny S>\n+  auto b()\n+  {\n+    return [](auto n) { return n; };\n+  }\n+};\n+\n+using Func = int(*)(int);\n+\n+int main(int, char**)\n+{\n+  auto g = []<C1 T> requires IsNotTiny<T>(T t) -> T\n+    requires IsNotLarge<decltype(t)> { return t; };\n+  g(5);\n+  g.operator()<int>(5.5);\n+\n+  auto z = []<typename T, int N = 5>(T t) requires (N < 4) { return t; };\n+  z.operator()<int, 3>(5);\n+\n+  [](int t) requires true { return t; }(5);\n+  [](C1 auto t) { return t; }(5);\n+\n+  auto a0 = [](IsNotLarge auto a) { return [](auto b){ return b; }; };\n+  auto a1 = a0(1);\n+  auto a2 = a1(5LL);\n+\n+  auto b0 = [](auto a) { return [](IsNotLarge auto b){ return b; }; };\n+  auto b1 = b0(5LL);\n+  auto b2 = b1(1);\n+\n+  Foo<int> foo1;\n+  foo1.a(5.5);\n+  foo1.a(1LL);\n+  foo1.b<int>()(5);\n+  foo1.b<long long>()(5);\n+\n+  Foo<double> foo2;\n+  foo2.a(5.5);\n+  foo2.a(1LL);\n+  foo2.b<int>()(5);\n+  foo2.b<long long>()(5);\n+\n+  Func m1 = [](int a) -> int requires true { return a; };\n+\n+  return 0;\n+}\n+"}, {"sha": "dfb5f3bcc5e85fd63fcd435d123b1ee26614db18", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda4.C?ref=e4c431266f9aaf604edfca68e852ae8efe966e8e", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct a {};\n+template <bool> using b = a;\n+\n+template <typename> struct c;\n+template <typename d>\n+  requires requires(d e) { e[0]; }\n+struct c<d> {\n+  static constexpr bool f = [] { return false; }.operator()();\n+};\n+\n+b<c<unsigned[]>::f> b0{};\n+"}, {"sha": "b330e4be051cce8ed7d09996e3e14fa7e9a97008", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr84810.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84810.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c431266f9aaf604edfca68e852ae8efe966e8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84810.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr84810.C?ref=e4c431266f9aaf604edfca68e852ae8efe966e8e", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++2a } }\n+template<class> constexpr bool is_int = false;\n+template<> constexpr bool is_int<int> = true;\n+\n+template <class T>\n+concept Int = is_int<T>;\n+\n+int main() {\n+    auto x = []<Int T>(T t) { return 42; };\n+    auto y = x(42);\n+    auto z = x(\"\"); // { dg-error \"no match\" }\n+    return z;\n+}"}]}