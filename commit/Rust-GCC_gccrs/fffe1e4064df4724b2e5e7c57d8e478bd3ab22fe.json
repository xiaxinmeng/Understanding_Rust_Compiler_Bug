{"sha": "fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmZTFlNDA2NGRmNDcyNGIyZTVlN2M1N2Q4ZTQ3OGJkM2FiMjJmZQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-09-09T23:28:27Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-09-09T23:28:27Z"}, "message": "re PR tree-optimization/44972 (ICE: in load_assign_lhs_subreplacements, at tree-sra.c:2475)\n\n2010-09-10  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/44972\n\t* ipa-prop.c (ipa_modify_call_arguments): Build MEM_REF instead of\n\tcalling build_ref_for_offset.\n\n\t* testsuite/g++.dg/torture/pr34850.C: Remove expected warning.\n\nFrom-SVN: r164135", "tree": {"sha": "d7ee5188de8d6ec3eb3b71b2622e67165443cd84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7ee5188de8d6ec3eb3b71b2622e67165443cd84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "508371fe2189f852f4c63ec5e7e312c25bb366c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508371fe2189f852f4c63ec5e7e312c25bb366c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508371fe2189f852f4c63ec5e7e312c25bb366c4"}], "stats": {"total": 112, "additions": 80, "deletions": 32}, "files": [{"sha": "1128ae9f302fc6f774b54a0fd475579964e2c0fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "patch": "@@ -1,3 +1,9 @@\n+2010-09-10  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/44972\n+\t* ipa-prop.c (ipa_modify_call_arguments): Build MEM_REF instead of\n+\tcalling build_ref_for_offset.\n+\n 2010-09-09  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n         * config/arm/bpabi.h (BE8_LINK_SPEC): Handle Cortex-a15."}, {"sha": "0ad732456e9f9960db207ff8eada59c4c3b5b098", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 68, "deletions": 31, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "patch": "@@ -2153,40 +2153,77 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \t}\n       else if (!adj->remove_param)\n \t{\n-\t  tree expr, orig_expr;\n-\t  bool allow_ptr, repl_found;\n-\n-\t  orig_expr = expr = gimple_call_arg (stmt, adj->base_index);\n-\t  if (TREE_CODE (expr) == ADDR_EXPR)\n-\t    {\n-\t      allow_ptr = false;\n-\t      expr = TREE_OPERAND (expr, 0);\n-\t    }\n+\t  tree expr, base, off;\n+\t  location_t loc;\n+\n+\t  /* We create a new parameter out of the value of the old one, we can\n+\t     do the following kind of transformations:\n+\n+\t     - A scalar passed by reference is converted to a scalar passed by\n+               value.  (adj->by_ref is false and the type of the original\n+               actual argument is a pointer to a scalar).\n+\n+             - A part of an aggregate is passed instead of the whole aggregate.\n+               The part can be passed either by value or by reference, this is\n+               determined by value of adj->by_ref.  Moreover, the code below\n+               handles both situations when the original aggregate is passed by\n+               value (its type is not a pointer) and when it is passed by\n+               reference (it is a pointer to an aggregate).\n+\n+\t     When the new argument is passed by reference (adj->by_ref is true)\n+\t     it must be a part of an aggregate and therefore we form it by\n+\t     simply taking the address of a reference inside the original\n+\t     aggregate.  */\n+\n+\t  gcc_checking_assert (adj->offset % BITS_PER_UNIT == 0);\n+\t  base = gimple_call_arg (stmt, adj->base_index);\n+\t  loc = EXPR_LOCATION (base);\n+\n+\t  if (TREE_CODE (base) == ADDR_EXPR\n+\t      && DECL_P (TREE_OPERAND (base, 0)))\n+\t    off = build_int_cst (reference_alias_ptr_type (base),\n+\t\t\t\t adj->offset / BITS_PER_UNIT);\n+\t  else if (TREE_CODE (base) != ADDR_EXPR\n+\t\t   && POINTER_TYPE_P (TREE_TYPE (base)))\n+\t    off = build_int_cst (TREE_TYPE (base), adj->offset / BITS_PER_UNIT);\n \t  else\n-\t    allow_ptr = true;\n-\n-\t  repl_found = build_ref_for_offset (&expr, TREE_TYPE (expr),\n-\t\t\t\t\t     adj->offset, adj->type,\n-\t\t\t\t\t     allow_ptr);\n-\t  if (repl_found)\n \t    {\n-\t      if (adj->by_ref)\n-\t\texpr = build_fold_addr_expr (expr);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree ptrtype = build_pointer_type (adj->type);\n-\t      expr = orig_expr;\n-\t      if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n-\t\texpr = build_fold_addr_expr (expr);\n-\t      if (!useless_type_conversion_p (ptrtype, TREE_TYPE (expr)))\n-\t\texpr = fold_convert (ptrtype, expr);\n-\t      expr = fold_build2 (POINTER_PLUS_EXPR, ptrtype, expr,\n-\t\t\t\t  build_int_cst (sizetype,\n-\t\t\t\t\t\t adj->offset / BITS_PER_UNIT));\n-\t      if (!adj->by_ref)\n-\t\texpr = fold_build1 (INDIRECT_REF, adj->type, expr);\n+\t      HOST_WIDE_INT base_offset;\n+\t      tree prev_base;\n+\n+\t      if (TREE_CODE (base) == ADDR_EXPR)\n+\t\tbase = TREE_OPERAND (base, 0);\n+\t      prev_base = base;\n+\t      base = get_addr_base_and_unit_offset (base, &base_offset);\n+\t      /* Aggregate arguments can have non-invariant addresses.  */\n+\t      if (!base)\n+\t\t{\n+\t\t  base = build_fold_addr_expr (prev_base);\n+\t\t  off = build_int_cst (reference_alias_ptr_type (prev_base),\n+\t\t\t\t       adj->offset / BITS_PER_UNIT);\n+\t\t}\n+\t      else if (TREE_CODE (base) == MEM_REF)\n+\t\t{\n+\t\t  off = build_int_cst (TREE_TYPE (TREE_OPERAND (base,1)),\n+\t\t\t\t       base_offset\n+\t\t\t\t       + adj->offset / BITS_PER_UNIT);\n+\t\t  off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1),\n+\t\t\t\t\t off, 0);\n+\t\t  base = TREE_OPERAND (base, 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  off = build_int_cst (reference_alias_ptr_type (base),\n+\t\t\t\t       base_offset\n+\t\t\t\t       + adj->offset / BITS_PER_UNIT);\n+\t\t  base = build_fold_addr_expr (base);\n+\t\t}\n \t    }\n+\n+\t  expr = fold_build2_loc (loc, MEM_REF, adj->type, base, off);\n+\t  if (adj->by_ref)\n+\t    expr = build_fold_addr_expr (expr);\n+\n \t  expr = force_gimple_operand_gsi (&gsi, expr,\n \t\t\t\t\t   adj->by_ref\n \t\t\t\t\t   || is_gimple_reg_type (adj->type),"}, {"sha": "0478d9a4d854b6ec3df0bed138e259dff6c8b68b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "patch": "@@ -1,3 +1,8 @@\n+2010-09-10  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/44972\n+\t* g++.dg/torture/pr34850.C: Remove expected warning.\n+\n 2010-09-09  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.dg/dummy_optional_arg.f90: New test."}, {"sha": "05f895c6dc0e20c48e448027df33d42b1d8ed3ab", "filename": "gcc/testsuite/g++.dg/torture/pr34850.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34850.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34850.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34850.C?ref=fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "patch": "@@ -11,7 +11,7 @@ extern \"C\" {\n     extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__))\n     void * memset (void *__dest, int __ch, size_t __len) throw () {\n \tif (__builtin_constant_p (__len) && __len == 0)\n-\t    __warn_memset_zero_len (); /* { dg-warning \"\" } */\n+\t    __warn_memset_zero_len ();\n     }\n }\n inline void clear_mem(void* ptr, u32bit n)    {"}]}