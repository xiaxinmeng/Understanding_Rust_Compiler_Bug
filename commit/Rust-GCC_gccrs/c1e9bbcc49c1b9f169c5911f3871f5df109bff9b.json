{"sha": "c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlOWJiY2M0OWMxYjlmMTY5YzU5MTFmMzg3MWY1ZGYxMDliZmY5Yg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-01-13T19:53:16Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-01-13T19:53:16Z"}, "message": "Revert r244448\n\nFrom-SVN: r244454", "tree": {"sha": "bf815e2471d2b7f7e44d76a31e98cc1d05e07b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf815e2471d2b7f7e44d76a31e98cc1d05e07b34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/comments", "author": null, "committer": null, "parents": [{"sha": "be4aa83d6ff4720fffd2c9f62c6e3082ece1937f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be4aa83d6ff4720fffd2c9f62c6e3082ece1937f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be4aa83d6ff4720fffd2c9f62c6e3082ece1937f"}], "stats": {"total": 693, "additions": 194, "deletions": 499}, "files": [{"sha": "191bfc816a71178eb4e1de04bcf672233a2dfb08", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -1,85 +1,3 @@\n-2017-01-13  Janne Blomqvist  <jb@gcc.gnu.org>\n-\n-\tPR fortran/78534\n-\tPR fortran/66310\n-\t* class.c (gfc_find_derived_vtab): Use gfc_size_kind instead of\n-\thardcoded kind.\n-\t(find_intrinsic_vtab): Likewise.\n-\t* expr.c (gfc_get_character_expr): Length parameter of type\n-\tgfc_charlen_t.\n-\t(gfc_get_int_expr): Value argument of type HOST_WIDE_INT.\n-\t(gfc_extract_hwi): New function.\n-\t(simplify_const_ref): Make string_len of type gfc_charlen_t.\n-\t(gfc_simplify_expr): Use HOST_WIDE_INT for substring refs.\n-\t* gfortran.h (gfc_mpz_get_hwi): New prototype.\n-\t(gfc_mpz_set_hwi): Likewise.\n-\t(gfc_charlen_t): New typedef.\n-\t(gfc_expr): Use gfc_charlen_t for character lengths.\n-\t(gfc_size_kind): New extern variable.\n-\t(gfc_extract_hwi): New prototype.\n-\t(gfc_get_character_expr): Use gfc_charlen_t for character length.\n-\t(gfc_get_int_expr): Use HOST_WIDE_INT type for value argument.\n-\t* iresolve.c (gfc_resolve_repeat): Pass string length directly without\n-\ttemporary, use gfc_charlen_int_kind.\n-\t* match.c (select_intrinsic_set_tmp): Use HOST_WIDE_INT for charlen.\n-\t* misc.c (gfc_mpz_get_hwi): New function.\n-\t(gfc_mpz_set_hwi): New function.\n-\t* module.c (atom_int): Change type from int to HOST_WIDE_INT.\n-\t(parse_integer): Don't complain about large integers.\n-\t(write_atom): Use HOST_WIDE_INT for integers.\n-\t(mio_integer): Handle integer type mismatch.\n-\t(mio_hwi): New function.\n-\t(mio_intrinsic_op): Use HOST_WIDE_INT.\n-\t(mio_array_ref): Likewise.\n-\t(mio_expr): Likewise.\n-\t* resolve.c (resolve_select_type): Use HOST_WIDE_INT for charlen,\n-\tuse snprintf.\n-\t(resolve_substring_charlen): Use gfc_charlen_int_kind.\n-\t(resolve_charlen): Use mpz_sgn to determine sign.\n-\t* simplify.c (gfc_simplify_repeat): Use HOST_WIDE_INT/gfc_charlen_t\n-\tinstead of long.\n-\t* target-memory.c (size_character): Length argument of type\n-\tgfc_charlen_t.\n-\t(gfc_encode_character): Likewise.\n-\t(gfc_interpret_character): Use gfc_charlen_t.\n-\t* target-memory.h (gfc_encode_character): Modify prototype.\n-\t* trans-array.c (get_array_ctor_var_strlen): Use\n-\tgfc_conv_mpz_to_tree_type.\n-\t* trans-const.c (gfc_conv_mpz_to_tree_type): New function.\n-\t* trans-const.h (gfc_conv_mpz_to_tree_type): New prototype.\n-\t* trans-expr.c (gfc_class_len_or_zero_get): Build const of type\n-\tgfc_charlen_type_node.\n-\t(gfc_conv_intrinsic_to_class): Use gfc_charlen_int_kind instead of\n-\t4, fold_convert to correct type.\n-\t(gfc_conv_class_to_class): Build const of type size_type_node for\n-\tsize.\n-\t(gfc_copy_class_to_class): Likewise.\n-\t(gfc_conv_string_length): Use same type in expression.\n-\t(gfc_conv_substring): Likewise, use HOST_WIDE_INT for charlen.\n-\t(gfc_conv_string_tmp): Make sure len is of the right type.\n-\t(gfc_conv_concat_op): Use same type in expression.\n-\t(gfc_conv_procedure_call): Likewise.\n-\t(alloc_scalar_allocatable_for_subcomponent_assignment):\n-\tfold_convert to right type.\n-\t(gfc_trans_subcomponent_assign): Likewise.\n-\t(trans_class_vptr_len_assignment): Build const of correct type.\n-\t(gfc_trans_pointer_assignment): Likewise.\n-\t(alloc_scalar_allocatable_for_assignment): fold_convert to right\n-\ttype in expr.\n-\t(trans_class_assignment): Build const of correct type.\n-\t* trans-intrinsic.c (gfc_conv_associated): Likewise.\n-\t(gfc_conv_intrinsic_repeat): Do calculation in sizetype.\n-\t* trans-io.c (gfc_build_io_library_fndecls): Use\n-\tgfc_charlen_type_node for character lengths.\n-\t* trans-stmt.c (gfc_trans_label_assign): Build const of\n-\tgfc_charlen_type_node.\n-\t(gfc_trans_character_select): Likewise.\n-\t(gfc_trans_allocate): Likewise, don't typecast strlen result.\n-\t(gfc_trans_deallocate): Don't typecast strlen result.\n-\t* trans-types.c (gfc_size_kind): New variable.\n-\t(gfc_init_types): Determine gfc_charlen_int_kind and gfc_size_kind\n-\tfrom size_type_node.\n-\n 2017-01-13  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/70697"}, {"sha": "d507e22ce0947bd26436c247e6429073b28abc93", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n     * _vptr: A pointer to the vtable entry (see below) of the dynamic type.\n \n     Only for unlimited polymorphic classes:\n-    * _len:  An integer(C_SIZE_T) to store the string length when the unlimited\n+    * _len:  An integer(4) to store the string length when the unlimited\n              polymorphic pointer is used to point to a char array.  The '_len'\n              component will be zero when no character array is stored in\n              '_data'.\n@@ -2310,13 +2310,13 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      if (!gfc_add_component (vtype, \"_size\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n-\t      c->ts.kind = gfc_size_kind;\n+\t      c->ts.kind = 4;\n \t      c->attr.access = ACCESS_PRIVATE;\n \t      /* Remember the derived type in ts.u.derived,\n \t\t so that the correct initializer can be set later on\n \t\t (in gfc_conv_structure).  */\n \t      c->ts.u.derived = derived;\n-\t      c->initializer = gfc_get_int_expr (gfc_size_kind,\n+\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n \t\t\t\t\t\t NULL, 0);\n \n \t      /* Add component _extends.  */\n@@ -2676,7 +2676,7 @@ find_intrinsic_vtab (gfc_typespec *ts)\n \t      if (!gfc_add_component (vtype, \"_size\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n-\t      c->ts.kind = gfc_size_kind;\n+\t      c->ts.kind = 4;\n \t      c->attr.access = ACCESS_PRIVATE;\n \n \t      /* Build a minimal expression to make use of\n@@ -2687,11 +2687,11 @@ find_intrinsic_vtab (gfc_typespec *ts)\n \t      e = gfc_get_expr ();\n \t      e->ts = *ts;\n \t      e->expr_type = EXPR_VARIABLE;\n-\t      c->initializer = gfc_get_int_expr (gfc_size_kind,\n+\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n \t\t\t\t\t\t NULL,\n \t\t\t\t\t\t ts->type == BT_CHARACTER\n \t\t\t\t\t\t ? ts->kind\n-\t\t\t\t\t\t : gfc_element_size (e));\n+\t\t\t\t\t\t : (int)gfc_element_size (e));\n \t      gfc_free_expr (e);\n \n \t      /* Add component _extends.  */"}, {"sha": "36fc4cc096984219e0d6b2e67204f5caf271bc9a", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -348,10 +348,12 @@ show_constructor (gfc_constructor_base base)\n \n \n static void\n-show_char_const (const gfc_char_t *c, gfc_charlen_t length)\n+show_char_const (const gfc_char_t *c, int length)\n {\n+  int i;\n+\n   fputc ('\\'', dumpfile);\n-  for (size_t i = 0; i < (size_t) length; i++)\n+  for (i = 0; i < length; i++)\n     {\n       if (c[i] == '\\'')\n \tfputs (\"''\", dumpfile);\n@@ -463,8 +465,7 @@ show_expr (gfc_expr *p)\n \t  break;\n \n \tcase BT_HOLLERITH:\n-\t  fprintf (dumpfile, HOST_WIDE_INT_PRINT_DEC \"H\",\n-\t\t   p->representation.length);\n+\t  fprintf (dumpfile, \"%dH\", p->representation.length);\n \t  c = p->representation.string;\n \t  for (i = 0; i < p->representation.length; i++, c++)\n \t    {"}, {"sha": "7b95d206c538c46ee35513532e062a94cfc4b7a4", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -27,7 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"match.h\"\n #include \"target-memory.h\" /* for gfc_convert_boz */\n #include \"constructor.h\"\n-#include \"tree.h\"\n \n \n /* The following set of functions provide access to gfc_expr* of\n@@ -185,7 +184,7 @@ gfc_get_constant_expr (bt type, int kind, locus *where)\n    blanked and null-terminated.  */\n \n gfc_expr *\n-gfc_get_character_expr (int kind, locus *where, const char *src, gfc_charlen_t len)\n+gfc_get_character_expr (int kind, locus *where, const char *src, int len)\n {\n   gfc_expr *e;\n   gfc_char_t *dest;\n@@ -211,14 +210,13 @@ gfc_get_character_expr (int kind, locus *where, const char *src, gfc_charlen_t l\n /* Get a new expression node that is an integer constant.  */\n \n gfc_expr *\n-gfc_get_int_expr (int kind, locus *where, HOST_WIDE_INT value)\n+gfc_get_int_expr (int kind, locus *where, int value)\n {\n   gfc_expr *p;\n   p = gfc_get_constant_expr (BT_INTEGER, kind,\n \t\t\t     where ? where : &gfc_current_locus);\n \n-  const wide_int w = wi::shwi (value, kind * BITS_PER_UNIT);\n-  wi::to_mpz (w, p->value.integer, SIGNED);\n+  mpz_set_si (p->value.integer, value);\n \n   return p;\n }\n@@ -638,32 +636,6 @@ gfc_extract_int (gfc_expr *expr, int *result)\n }\n \n \n-/* Same as gfc_extract_int, but use a HWI.  */\n-\n-const char *\n-gfc_extract_hwi (gfc_expr *expr, HOST_WIDE_INT *result)\n-{\n-  if (expr->expr_type != EXPR_CONSTANT)\n-    return _(\"Constant expression required at %C\");\n-\n-  if (expr->ts.type != BT_INTEGER)\n-    return _(\"Integer expression required at %C\");\n-\n-  /* Use long_long_integer_type_node to determine when to saturate.  */\n-  const wide_int val = wi::from_mpz (long_long_integer_type_node,\n-\t\t\t\t     expr->value.integer, false);\n-\n-  if (!wi::fits_shwi_p (val))\n-    {\n-      return _(\"Integer value too large in expression at %C\");\n-    }\n-\n-  *result = val.to_shwi ();\n-\n-  return NULL;\n-}\n-\n-\n /* Recursively copy a list of reference structures.  */\n \n gfc_ref *\n@@ -1683,7 +1655,7 @@ simplify_const_ref (gfc_expr *p)\n \t\t\t a substring out of it, update the type-spec's\n \t\t\t character length according to the first element\n \t\t\t (as all should have the same length).  */\n-\t\t      gfc_charlen_t string_len;\n+\t\t      int string_len;\n \t\t      if ((c = gfc_constructor_first (p->value.constructor)))\n \t\t\t{\n \t\t\t  const gfc_expr* first = c->expr;\n@@ -1852,18 +1824,18 @@ gfc_simplify_expr (gfc_expr *p, int type)\n       if (gfc_is_constant_expr (p))\n \t{\n \t  gfc_char_t *s;\n-\t  HOST_WIDE_INT start, end;\n+\t  int start, end;\n \n \t  start = 0;\n \t  if (p->ref && p->ref->u.ss.start)\n \t    {\n-\t      gfc_extract_hwi (p->ref->u.ss.start, &start);\n+\t      gfc_extract_int (p->ref->u.ss.start, &start);\n \t      start--;  /* Convert from one-based to zero-based.  */\n \t    }\n \n \t  end = p->value.character.length;\n \t  if (p->ref && p->ref->u.ss.end)\n-\t    gfc_extract_hwi (p->ref->u.ss.end, &end);\n+\t    gfc_extract_int (p->ref->u.ss.end, &end);\n \n \t  if (end < start)\n \t    end = start;"}, {"sha": "f01a290e28f5087a1cc5ddc8fc397c6b50864176", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -2064,14 +2064,6 @@ gfc_intrinsic_sym;\n \n typedef splay_tree gfc_constructor_base;\n \n-\n-/* This should be an unsigned variable of type size_t.  But to handle\n-   compiling to a 64-bit target from a 32-bit host, we need to use a\n-   HOST_WIDE_INT.  Also, occasionally the string length field is used\n-   as a flag with values -1 and -2, see e.g. gfc_add_assign_aux_vars.\n-   So it needs to be signed.  */\n-typedef HOST_WIDE_INT gfc_charlen_t;\n-\n typedef struct gfc_expr\n {\n   expr_t expr_type;\n@@ -2117,7 +2109,7 @@ typedef struct gfc_expr\n      the value.  */\n   struct\n   {\n-    gfc_charlen_t length;\n+    int length;\n     char *string;\n   }\n   representation;\n@@ -2173,7 +2165,7 @@ typedef struct gfc_expr\n \n     struct\n     {\n-      gfc_charlen_t length;\n+      int length;\n       gfc_char_t *string;\n     }\n     character;\n@@ -2767,9 +2759,6 @@ void gfc_done_2 (void);\n \n int get_c_kind (const char *, CInteropKind_t *);\n \n-HOST_WIDE_INT gfc_mpz_get_hwi (mpz_t);\n-void gfc_mpz_set_hwi (mpz_t, const HOST_WIDE_INT);\n-\n /* options.c */\n unsigned int gfc_option_lang_mask (void);\n void gfc_init_options_struct (struct gcc_options *);\n@@ -2861,7 +2850,6 @@ extern int gfc_atomic_int_kind;\n extern int gfc_atomic_logical_kind;\n extern int gfc_intio_kind;\n extern int gfc_charlen_int_kind;\n-extern int gfc_size_kind;\n extern int gfc_numeric_storage_size;\n extern int gfc_character_storage_size;\n \n@@ -3093,7 +3081,6 @@ void gfc_resolve_oacc_blocks (gfc_code *, gfc_namespace *);\n void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n const char *gfc_extract_int (gfc_expr *, int *);\n-const char *gfc_extract_hwi (gfc_expr *, HOST_WIDE_INT *);\n bool is_subref_array (gfc_expr *);\n bool gfc_is_simply_contiguous (gfc_expr *, bool, bool);\n bool gfc_check_init_expr (gfc_expr *);\n@@ -3111,8 +3098,8 @@ gfc_expr *gfc_get_null_expr (locus *);\n gfc_expr *gfc_get_operator_expr (locus *, gfc_intrinsic_op,gfc_expr *, gfc_expr *);\n gfc_expr *gfc_get_structure_constructor_expr (bt, int, locus *);\n gfc_expr *gfc_get_constant_expr (bt, int, locus *);\n-gfc_expr *gfc_get_character_expr (int, locus *, const char *, gfc_charlen_t len);\n-gfc_expr *gfc_get_int_expr (int, locus *, HOST_WIDE_INT);\n+gfc_expr *gfc_get_character_expr (int, locus *, const char *, int len);\n+gfc_expr *gfc_get_int_expr (int, locus *, int);\n gfc_expr *gfc_get_logical_expr (int, locus *, bool);\n gfc_expr *gfc_get_iokind_expr (locus *, io_kind);\n "}, {"sha": "9a263171e475f2838684354621d3c2a1359cac24", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -3810,42 +3810,12 @@ front ends of GCC, e.g. to GCC's C99 compiler for @code{_Bool}\n or GCC's Ada compiler for @code{Boolean}.)\n \n For arguments of @code{CHARACTER} type, the character length is passed\n-as a hidden argument at the end of the argument list.  For\n-deferred-length strings, the value is passed by reference, otherwise\n-by value.  The character length has the C type @code{size_t} (or\n-@code{INTEGER(kind=C_SIZE_T)} in Fortran).  Note that this is\n-different to older versions of the GNU Fortran compiler, where the\n-type of the hidden character length argument was a C @code{int}.  In\n-order to retain compatibility with older versions, one can e.g. for\n-the following Fortran procedure\n-\n-@smallexample\n-subroutine fstrlen (s, a)\n-   character(len=*) :: s\n-   integer :: a\n-   print*, len(s)\n-end subroutine fstrlen\n-@end smallexample\n-\n-define the corresponding C prototype as follows:\n-\n-@smallexample\n-#if __GNUC__ > 6\n-typedef size_t fortran_charlen_t;\n-#else\n-typedef int fortran_charlen_t;\n-#endif\n-\n-void fstrlen_ (char*, int*, fortran_charlen_t);\n-@end smallexample\n-\n-In order to avoid such compiler-specific details, for new code it is\n-instead recommended to use the ISO_C_BINDING feature.\n-\n-Note with C binding, @code{CHARACTER(len=1)} result variables are\n-returned according to the platform ABI and no hidden length argument\n-is used for dummy arguments; with @code{VALUE}, those variables are\n-passed by value.\n+as hidden argument.  For deferred-length strings, the value is passed\n+by reference, otherwise by value.  The character length has the type\n+@code{INTEGER(kind=4)}.  Note with C binding, @code{CHARACTER(len=1)}\n+result variables are returned according to the platform ABI and no\n+hidden length argument is used for dummy arguments; with @code{VALUE},\n+those variables are passed by value.\n \n For @code{OPTIONAL} dummy arguments, an absent argument is denoted\n by a NULL pointer, except for scalar dummy arguments of type"}, {"sha": "5c3ad42990b08c05bac1c42123c568268252e8d4", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -2147,6 +2147,7 @@ void\n gfc_resolve_repeat (gfc_expr *f, gfc_expr *string,\n \t\t    gfc_expr *ncopies)\n {\n+  int len;\n   gfc_expr *tmp;\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = string->ts.kind;\n@@ -2159,8 +2160,8 @@ gfc_resolve_repeat (gfc_expr *f, gfc_expr *string,\n   tmp = NULL;\n   if (string->expr_type == EXPR_CONSTANT)\n     {\n-      tmp = gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n-\t\t\t      string->value.character.length);\n+      len = string->value.character.length;\n+      tmp = gfc_get_int_expr (gfc_default_integer_kind, NULL , len);\n     }\n   else if (string->ts.u.cl && string->ts.u.cl->length)\n     {"}, {"sha": "ea9d315d7cf6206b6606b6b4fc9f6d37fc2093b1", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -5765,7 +5765,7 @@ select_intrinsic_set_tmp (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_symtree *tmp;\n-  HOST_WIDE_INT charlen = 0;\n+  int charlen = 0;\n \n   if (ts->type == BT_CLASS || ts->type == BT_DERIVED)\n     return NULL;\n@@ -5776,14 +5776,14 @@ select_intrinsic_set_tmp (gfc_typespec *ts)\n \n   if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length\n       && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n-    charlen = gfc_mpz_get_hwi (ts->u.cl->length->value.integer);\n+    charlen = mpz_get_si (ts->u.cl->length->value.integer);\n \n   if (ts->type != BT_CHARACTER)\n     sprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (ts->type),\n \t     ts->kind);\n   else\n-    snprintf (name, sizeof (name), \"__tmp_%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n-\t      gfc_basic_typename (ts->type), charlen, ts->kind);\n+    sprintf (name, \"__tmp_%s_%d_%d\", gfc_basic_typename (ts->type),\n+\t     charlen, ts->kind);\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n   gfc_add_type (tmp->n.sym, ts, NULL);"}, {"sha": "a2c199efb56a06bf8e93b2734b3d50f821814066", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"gfortran.h\"\n-#include \"tree.h\"\n \n \n /* Initialize a typespec to unknown.  */\n@@ -281,24 +280,3 @@ get_c_kind(const char *c_kind_name, CInteropKind_t kinds_table[])\n \n   return ISOCBINDING_INVALID;\n }\n-\n-\n-/* Convert between GMP integers (mpz_t) and HOST_WIDE_INT.  */\n-\n-HOST_WIDE_INT\n-gfc_mpz_get_hwi (mpz_t op)\n-{\n-  /* Using long_long_integer_type_node as that is the integer type\n-     node that closest matches HOST_WIDE_INT; both are guaranteed to\n-     be at least 64 bits.  */\n-  const wide_int w = wi::from_mpz (long_long_integer_type_node, op, true);\n-  return w.to_shwi ();\n-}\n-\n-\n-void\n-gfc_mpz_set_hwi (mpz_t rop, const HOST_WIDE_INT op)\n-{\n-  const wide_int w = wi::shwi (op, HOST_BITS_PER_WIDE_INT);\n-  wi::to_mpz (w, rop, SIGNED);\n-}"}, {"sha": "b3b09672aca2c593f43a2cbb051bf854cdefd649", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -1141,7 +1141,7 @@ static atom_type last_atom;\n \n #define MAX_ATOM_SIZE 100\n \n-static HOST_WIDE_INT atom_int;\n+static int atom_int;\n static char *atom_string, atom_name[MAX_ATOM_SIZE];\n \n \n@@ -1271,7 +1271,7 @@ parse_string (void)\n }\n \n \n-/* Parse an integer. Should fit in a HOST_WIDE_INT.  */\n+/* Parse a small integer.  */\n \n static void\n parse_integer (int c)\n@@ -1288,6 +1288,8 @@ parse_integer (int c)\n \t}\n \n       atom_int = 10 * atom_int + c - '0';\n+      if (atom_int > 99999999)\n+\tbad_module (\"Integer overflow\");\n     }\n \n }\n@@ -1629,12 +1631,11 @@ write_char (char out)\n static void\n write_atom (atom_type atom, const void *v)\n {\n-  char buffer[32];\n+  char buffer[20];\n \n   /* Workaround -Wmaybe-uninitialized false positive during\n      profiledbootstrap by initializing them.  */\n-  int len;\n-  HOST_WIDE_INT i = 0;\n+  int i = 0, len;\n   const char *p;\n \n   switch (atom)\n@@ -1653,9 +1654,11 @@ write_atom (atom_type atom, const void *v)\n       break;\n \n     case ATOM_INTEGER:\n-      i = *((const HOST_WIDE_INT *) v);\n+      i = *((const int *) v);\n+      if (i < 0)\n+\tgfc_internal_error (\"write_atom(): Writing negative integer\");\n \n-      snprintf (buffer, sizeof (buffer), HOST_WIDE_INT_PRINT_DEC, i);\n+      sprintf (buffer, \"%d\", i);\n       p = buffer;\n       break;\n \n@@ -1763,29 +1766,14 @@ static void\n mio_integer (int *ip)\n {\n   if (iomode == IO_OUTPUT)\n-    {\n-      HOST_WIDE_INT hwi = *ip;\n-      write_atom (ATOM_INTEGER, &hwi);\n-    }\n+    write_atom (ATOM_INTEGER, ip);\n   else\n     {\n       require_atom (ATOM_INTEGER);\n       *ip = atom_int;\n     }\n }\n \n-static void\n-mio_hwi (HOST_WIDE_INT *hwi)\n-{\n-  if (iomode == IO_OUTPUT)\n-    write_atom (ATOM_INTEGER, hwi);\n-  else\n-    {\n-      require_atom (ATOM_INTEGER);\n-      *hwi = atom_int;\n-    }\n-}\n-\n \n /* Read or write a gfc_intrinsic_op value.  */\n \n@@ -1795,7 +1783,7 @@ mio_intrinsic_op (gfc_intrinsic_op* op)\n   /* FIXME: Would be nicer to do this via the operators symbolic name.  */\n   if (iomode == IO_OUTPUT)\n     {\n-      HOST_WIDE_INT converted = (HOST_WIDE_INT) *op;\n+      int converted = (int) *op;\n       write_atom (ATOM_INTEGER, &converted);\n     }\n   else\n@@ -2692,7 +2680,7 @@ mio_array_ref (gfc_array_ref *ar)\n     {\n       for (i = 0; i < ar->dimen; i++)\n \t{\n-\t  HOST_WIDE_INT tmp = (HOST_WIDE_INT)ar->dimen_type[i];\n+\t  int tmp = (int)ar->dimen_type[i];\n \t  write_atom (ATOM_INTEGER, &tmp);\n \t}\n     }\n@@ -3394,7 +3382,6 @@ fix_mio_expr (gfc_expr *e)\n static void\n mio_expr (gfc_expr **ep)\n {\n-  HOST_WIDE_INT hwi;\n   gfc_expr *e;\n   atom_type t;\n   int flag;\n@@ -3609,9 +3596,7 @@ mio_expr (gfc_expr **ep)\n \t  break;\n \n \tcase BT_CHARACTER:\n-\t  hwi = e->value.character.length;\n-\t  mio_hwi (&hwi);\n-\t  e->value.character.length = hwi;\n+\t  mio_integer (&e->value.character.length);\n \t  e->value.character.string\n \t    = CONST_CAST (gfc_char_t *,\n \t\t\t  mio_allocated_wide_string (e->value.character.string,"}, {"sha": "a5fe2314372c702c92e0304c5cd57ecd2de3faa3", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -4726,7 +4726,7 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n   /* Length = (end - start + 1).  */\n   e->ts.u.cl->length = gfc_subtract (end, start);\n   e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,\n-\t\t\t\tgfc_get_int_expr (gfc_charlen_int_kind,\n+\t\t\t\tgfc_get_int_expr (gfc_default_integer_kind,\n \t\t\t\t\t\t  NULL, 1));\n \n   /* F2008, 6.4.1:  Both the starting point and the ending point shall\n@@ -8469,6 +8469,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_namespace *ns;\n   int error = 0;\n+  int charlen = 0;\n   int rank = 0;\n   gfc_ref* ref = NULL;\n   gfc_expr *selector_expr = NULL;\n@@ -8716,13 +8717,11 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \tsprintf (name, \"__tmp_type_%s\", c->ts.u.derived->name);\n       else if (c->ts.type == BT_CHARACTER)\n \t{\n-\t  HOST_WIDE_INT charlen = 0;\n \t  if (c->ts.u.cl && c->ts.u.cl->length\n \t      && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n-\t    charlen = gfc_mpz_get_hwi (c->ts.u.cl->length->value.integer);\n-\t  snprintf (name, sizeof (name),\n-\t\t    \"__tmp_%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n-\t\t    gfc_basic_typename (c->ts.type), charlen, c->ts.kind);\n+\t    charlen = mpz_get_si (c->ts.u.cl->length->value.integer);\n+\t  sprintf (name, \"__tmp_%s_%d_%d\", gfc_basic_typename (c->ts.type),\n+\t           charlen, c->ts.kind);\n \t}\n       else\n \tsprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (c->ts.type),\n@@ -11387,7 +11386,7 @@ resolve_index_expr (gfc_expr *e)\n static bool\n resolve_charlen (gfc_charlen *cl)\n {\n-  int k;\n+  int i, k;\n   bool saved_specification_expr;\n \n   if (cl->resolved)\n@@ -11423,10 +11422,9 @@ resolve_charlen (gfc_charlen *cl)\n \n   /* F2008, 4.4.3.2:  If the character length parameter value evaluates to\n      a negative value, the length of character entities declared is zero.  */\n-  if (cl->length && cl->length->expr_type == EXPR_CONSTANT\n-      && mpz_sgn (cl->length->value.integer) < 0)\n+  if (cl->length && !gfc_extract_int (cl->length, &i) && i < 0)\n     gfc_replace_expr (cl->length,\n-\t\t      gfc_get_int_expr (gfc_charlen_int_kind, NULL, 0));\n+\t\t      gfc_get_int_expr (gfc_default_integer_kind, NULL, 0));\n \n   /* Check that the character length is not too large.  */\n   k = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);"}, {"sha": "942b40154471266e4a5d89dea74fa000d43afe31", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -5198,7 +5198,7 @@ gfc_expr *\n gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n {\n   gfc_expr *result;\n-  gfc_charlen_t len;\n+  int i, j, len, ncop, nlen;\n   mpz_t ncopies;\n   bool have_length = false;\n \n@@ -5218,7 +5218,7 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n   if (e->ts.u.cl && e->ts.u.cl->length\n \t&& e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n     {\n-      len = gfc_mpz_get_hwi (e->ts.u.cl->length->value.integer);\n+      len = mpz_get_si (e->ts.u.cl->length->value.integer);\n       have_length = true;\n     }\n   else if (e->expr_type == EXPR_CONSTANT\n@@ -5254,8 +5254,7 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n \t}\n       else\n \t{\n-\t  mpz_init (mlen);\n-\t  gfc_mpz_set_hwi (mlen, len);\n+\t  mpz_init_set_si (mlen, len);\n \t  mpz_tdiv_q (max, gfc_integer_kinds[i].huge, mlen);\n \t  mpz_clear (mlen);\n \t}\n@@ -5279,12 +5278,11 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  HOST_WIDE_INT ncop;\n   if (len ||\n       (e->ts.u.cl->length &&\n        mpz_sgn (e->ts.u.cl->length->value.integer) != 0))\n     {\n-      const char *res = gfc_extract_hwi (n, &ncop);\n+      const char *res = gfc_extract_int (n, &ncop);\n       gcc_assert (res == NULL);\n     }\n   else\n@@ -5294,18 +5292,11 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n     return gfc_get_character_expr (e->ts.kind, &e->where, NULL, 0);\n \n   len = e->value.character.length;\n-  gfc_charlen_t nlen = ncop * len;\n-\n-  /* Here's a semi-arbitrary limit. If the string is longer than 32 MB\n-     (8 * 2**20 elements * 4 bytes (wide chars) per element) defer to\n-     runtime instead of consuming (unbounded) memory and CPU at\n-     compile time.  */\n-  if (nlen > 8388608)\n-    return NULL;\n+  nlen = ncop * len;\n \n   result = gfc_get_character_expr (e->ts.kind, &e->where, NULL, nlen);\n-  for (size_t i = 0; i < (size_t) ncop; i++)\n-    for (size_t j = 0; j < (size_t) len; j++)\n+  for (i = 0; i < ncop; i++)\n+    for (j = 0; j < len; j++)\n       result->value.character.string[j+i*len]= e->value.character.string[j];\n \n   result->value.character.string[nlen] = '\\0';\t/* For debugger */"}, {"sha": "d239cf114e12a1a756aec99179c6452d127961db", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -65,7 +65,7 @@ size_logical (int kind)\n \n \n static size_t\n-size_character (gfc_charlen_t length, int kind)\n+size_character (int length, int kind)\n {\n   int i = gfc_validate_kind (BT_CHARACTER, kind, false);\n   return length * gfc_character_kinds[i].bit_size / 8;\n@@ -97,9 +97,9 @@ gfc_element_size (gfc_expr *e)\n \t       && e->ts.u.cl->length->expr_type == EXPR_CONSTANT\n \t       && e->ts.u.cl->length->ts.type == BT_INTEGER)\n \t{\n-\t  HOST_WIDE_INT length;\n+\t  int length;\n \n-\t  gfc_extract_hwi (e->ts.u.cl->length, &length);\n+\t  gfc_extract_int (e->ts.u.cl->length, &length);\n \t  return size_character (length, e->ts.kind);\n \t}\n       else\n@@ -217,15 +217,16 @@ encode_logical (int kind, int logical, unsigned char *buffer, size_t buffer_size\n \n \n int\n-gfc_encode_character (int kind, gfc_charlen_t length, const gfc_char_t *string,\n+gfc_encode_character (int kind, int length, const gfc_char_t *string,\n \t\t      unsigned char *buffer, size_t buffer_size)\n {\n   size_t elsize = size_character (1, kind);\n   tree type = gfc_get_char_type (kind);\n+  int i;\n \n   gcc_assert (buffer_size >= size_character (length, kind));\n \n-  for (size_t i = 0; i < (size_t) length; i++)\n+  for (i = 0; i < length; i++)\n     native_encode_expr (build_int_cst (type, string[i]), &buffer[i*elsize],\n \t\t\telsize);\n \n@@ -437,17 +438,19 @@ int\n gfc_interpret_character (unsigned char *buffer, size_t buffer_size,\n \t\t\t gfc_expr *result)\n {\n+  int i;\n+\n   if (result->ts.u.cl && result->ts.u.cl->length)\n     result->value.character.length =\n-      gfc_mpz_get_hwi (result->ts.u.cl->length->value.integer);\n+      (int) mpz_get_ui (result->ts.u.cl->length->value.integer);\n \n   gcc_assert (buffer_size >= size_character (result->value.character.length,\n \t\t\t\t\t     result->ts.kind));\n   result->value.character.string =\n     gfc_get_wide_string (result->value.character.length + 1);\n \n   if (result->ts.kind == gfc_default_character_kind)\n-    for (size_t i = 0; i < (size_t) result->value.character.length; i++)\n+    for (i = 0; i < result->value.character.length; i++)\n       result->value.character.string[i] = (gfc_char_t) buffer[i];\n   else\n     {\n@@ -456,7 +459,7 @@ gfc_interpret_character (unsigned char *buffer, size_t buffer_size,\n       mpz_init (integer);\n       gcc_assert (bytes <= sizeof (unsigned long));\n \n-      for (size_t i = 0; i < (size_t) result->value.character.length; i++)\n+      for (i = 0; i < result->value.character.length; i++)\n \t{\n \t  gfc_conv_tree_to_mpz (integer,\n \t    native_interpret_expr (gfc_get_char_type (result->ts.kind),"}, {"sha": "5d4655352cc785b107c3c1fc63cf191ee89b32c3", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -28,7 +28,7 @@ size_t gfc_element_size (gfc_expr *);\n size_t gfc_target_expr_size (gfc_expr *);\n \n /* Write a constant expression in binary form to a target buffer.  */\n-int gfc_encode_character (int, gfc_charlen_t, const gfc_char_t *, unsigned char *,\n+int gfc_encode_character (int, int, const gfc_char_t *, unsigned char *,\n \t\t\t  size_t);\n unsigned HOST_WIDE_INT gfc_target_encode_expr (gfc_expr *, unsigned char *,\n \t\t\t\t\t       size_t);"}, {"sha": "a3aab8e45286ed61c5b1cffadeabcfeb73f4ddf8", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -1909,7 +1909,8 @@ get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)\n \t  mpz_init_set_ui (char_len, 1);\n \t  mpz_add (char_len, char_len, ref->u.ss.end->value.integer);\n \t  mpz_sub (char_len, char_len, ref->u.ss.start->value.integer);\n-\t  *len = gfc_conv_mpz_to_tree_type (char_len, gfc_charlen_type_node);\n+\t  *len = gfc_conv_mpz_to_tree (char_len, gfc_default_integer_kind);\n+\t  *len = convert (gfc_charlen_type_node, *len);\n \t  mpz_clear (char_len);\n \t  return;\n "}, {"sha": "128d47d0fa31648501d2b3115e4968b76a4ec3ed", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -206,18 +206,6 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n   return wide_int_to_tree (gfc_get_int_type (kind), val);\n }\n \n-\n-/* Convert a GMP integer into a tree node of type given by the type\n-   argument.  */\n-\n-tree\n-gfc_conv_mpz_to_tree_type (mpz_t i, const tree type)\n-{\n-  const wide_int val = wi::from_mpz (type, i, true);\n-  return wide_int_to_tree (type, val);\n-}\n-\n-\n /* Converts a backend tree into a GMP integer.  */\n \n void"}, {"sha": "97308676d16aa4b5e2fc28a02c8af1a3d5296d8c", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -20,7 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Converts between INT_CST and GMP integer representations.  */\n tree gfc_conv_mpz_to_tree (mpz_t, int);\n-tree gfc_conv_mpz_to_tree_type (mpz_t, const tree);\n void gfc_conv_tree_to_mpz (mpz_t, tree);\n \n /* Converts between REAL_CST and MPFR floating-point representations.  */"}, {"sha": "01b7dd27dced2dafe11d236c67c380abdf97a3d6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -250,7 +250,7 @@ gfc_class_len_or_zero_get (tree decl)\n   return len != NULL_TREE ? fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t\t     TREE_TYPE (len), decl, len,\n \t\t\t\t\t     NULL_TREE)\n-    : build_zero_cst (gfc_charlen_type_node);\n+\t\t\t  : integer_zero_node;\n }\n \n \n@@ -884,8 +884,7 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t{\n \t\t  /* Amazingly all data is present to compute the length of a\n \t\t   constant string, but the expression is not yet there.  */\n-\t\t  e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER,\n-\t\t\t\t\t\t\t      gfc_charlen_int_kind,\n+\t\t  e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER, 4,\n \t\t\t\t\t\t\t      &e->where);\n \t\t  mpz_set_ui (e->ts.u.cl->length->value.integer,\n \t\t\t      e->value.character.length);\n@@ -903,7 +902,7 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n       else\n \ttmp = integer_zero_node;\n \n-      gfc_add_modify (&parmse->pre, ctree, fold_convert (TREE_TYPE (ctree), tmp));\n+      gfc_add_modify (&parmse->pre, ctree, tmp);\n     }\n   else if (class_ts.type == BT_CLASS\n \t   && class_ts.u.derived->components\n@@ -1042,7 +1041,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n       if (DECL_LANG_SPECIFIC (tmp) && GFC_DECL_SAVED_DESCRIPTOR (tmp))\n \ttmp = GFC_DECL_SAVED_DESCRIPTOR (tmp);\n \n-      slen = build_zero_cst (size_type_node);\n+      slen = integer_zero_node;\n     }\n   else\n     {\n@@ -1089,7 +1088,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n \t  tmp = slen;\n \t}\n       else\n-\ttmp = build_zero_cst (size_type_node);\n+\ttmp = integer_zero_node;\n       gfc_add_modify (&parmse->pre, ctree,\n \t\t      fold_convert (TREE_TYPE (ctree), tmp));\n \n@@ -1228,7 +1227,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n       if (from != NULL_TREE && unlimited)\n \tfrom_len = gfc_class_len_or_zero_get (from);\n       else\n-\tfrom_len = build_zero_cst (size_type_node);\n+\tfrom_len = integer_zero_node;\n     }\n \n   if (GFC_CLASS_TYPE_P (TREE_TYPE (to)))\n@@ -1340,7 +1339,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t boolean_type_node, from_len,\n-\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n+\t\t\t\t integer_zero_node);\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n \t  gfc_add_expr_to_block (&body, tmp);\n@@ -1368,7 +1367,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \t  extcopy = build_call_vec (fcn_type, fcn, args);\n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t boolean_type_node, from_len,\n-\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n+\t\t\t\t integer_zero_node);\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n \t}\n@@ -2200,7 +2199,7 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)\n \n   gfc_conv_expr_type (&se, cl->length, gfc_charlen_type_node);\n   se.expr = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node,\n-\t\t\t     se.expr, build_zero_cst (TREE_TYPE (se.expr)));\n+\t\t\t     se.expr, build_int_cst (gfc_charlen_type_node, 0));\n   gfc_add_block_to_block (pblock, &se.pre);\n \n   if (cl->backend_decl)\n@@ -2272,7 +2271,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       /* Check lower bound.  */\n       fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n \t\t\t       start.expr,\n-\t\t\t       build_one_cst (TREE_TYPE (start.expr)));\n+\t\t\t       build_int_cst (gfc_charlen_type_node, 1));\n       fault = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n \t\t\t       boolean_type_node, nonempty, fault);\n       if (name)\n@@ -2308,9 +2307,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n   if (ref->u.ss.end\n       && gfc_dep_difference (ref->u.ss.end, ref->u.ss.start, &length))\n     {\n-      HOST_WIDE_INT i_len;\n+      int i_len;\n \n-      i_len = gfc_mpz_get_hwi (length) + 1;\n+      i_len = mpz_get_si (length) + 1;\n       if (i_len < 0)\n \ti_len = 0;\n \n@@ -2320,8 +2319,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n   else\n     {\n       tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_charlen_type_node,\n-\t\t\t     fold_convert (gfc_charlen_type_node, end.expr),\n-\t\t\t     fold_convert (gfc_charlen_type_node, start.expr));\n+\t\t\t     end.expr, start.expr);\n       tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_charlen_type_node,\n \t\t\t     build_int_cst (gfc_charlen_type_node, 1), tmp);\n       tmp = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node,\n@@ -3121,10 +3119,9 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n     {\n       /* Create a temporary variable to hold the result.  */\n       tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t     gfc_charlen_type_node,\n-\t\t\t     fold_convert (gfc_charlen_type_node, len),\n+\t\t\t     gfc_charlen_type_node, len,\n \t\t\t     build_int_cst (gfc_charlen_type_node, 1));\n-      tmp = build_range_type (gfc_charlen_type_node, gfc_index_zero_node, tmp);\n+      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n \n       if (TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n \ttmp = build_array_type (TREE_TYPE (TREE_TYPE (type)), tmp);\n@@ -3187,9 +3184,7 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n     {\n       len = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t     TREE_TYPE (lse.string_length),\n-\t\t\t     lse.string_length,\n-\t\t\t     fold_convert (TREE_TYPE (lse.string_length),\n-\t\t\t\t\t   rse.string_length));\n+\t\t\t     lse.string_length, rse.string_length);\n     }\n \n   type = build_pointer_type (type);\n@@ -5881,7 +5876,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  tmp = fold_convert (gfc_charlen_type_node, parmse.expr);\n \t  tmp = fold_build2_loc (input_location, MAX_EXPR,\n \t\t\t\t gfc_charlen_type_node, tmp,\n-\t\t\t\t build_zero_cst (TREE_TYPE (tmp)));\n+\t\t\t\t build_int_cst (gfc_charlen_type_node, 0));\n \t  cl.backend_decl = tmp;\n \t}\n \n@@ -7210,8 +7205,7 @@ alloc_scalar_allocatable_for_subcomponent_assignment (stmtblock_t *block,\n \n   if (cm->ts.type == BT_CHARACTER && cm->ts.deferred)\n     /* Update the lhs character length.  */\n-    gfc_add_modify (block, lhs_cl_size,\n-\t\t    fold_convert (TREE_TYPE (lhs_cl_size), size));\n+    gfc_add_modify (block, lhs_cl_size, size);\n }\n \n \n@@ -7450,8 +7444,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n \t\t\t\t     1, size);\n \t  gfc_add_modify (&block, dest,\n \t\t\t  fold_convert (TREE_TYPE (dest), tmp));\n-\t  gfc_add_modify (&block, strlen,\n-\t\t\t  fold_convert (TREE_TYPE (strlen), se.string_length));\n+\t  gfc_add_modify (&block, strlen, se.string_length);\n \t  tmp = gfc_build_memcpy_call (dest, se.expr, size);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n@@ -8118,7 +8111,7 @@ trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,\n \t\t  from_len = gfc_evaluate_now (se.expr, block);\n \t\t}\n \t      else\n-\t\tfrom_len = build_zero_cst (gfc_charlen_type_node);\n+\t\tfrom_len = integer_zero_node;\n \t    }\n \t  gfc_add_modify (pre, to_len, fold_convert (TREE_TYPE (to_len),\n \t\t\t\t\t\t     from_len));\n@@ -8293,7 +8286,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t    gfc_add_modify (&block, lse.string_length, rse.string_length);\n \t  else if (lse.string_length != NULL)\n \t    gfc_add_modify (&block, lse.string_length,\n-\t\t\t    build_zero_cst (TREE_TYPE (lse.string_length)));\n+\t\t\t    build_int_cst (gfc_charlen_type_node, 0));\n \t}\n \n       gfc_add_modify (&block, lse.expr,\n@@ -9553,9 +9546,7 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n   if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n     {\n       cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t      lse.string_length,\n-\t\t\t      fold_convert (TREE_TYPE (lse.string_length),\n-\t\t\t\t\t    size));\n+\t\t\t      lse.string_length, size);\n       /* Jump past the realloc if the lengths are the same.  */\n       tmp = build3_v (COND_EXPR, cond,\n \t\t      build1_v (GOTO_EXPR, jump_label2),\n@@ -9572,8 +9563,7 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n \n       /* Update the lhs character length.  */\n       size = string_length;\n-      gfc_add_modify (block, lse.string_length,\n-\t\t      fold_convert (TREE_TYPE (lse.string_length), size));\n+      gfc_add_modify (block, lse.string_length, size);\n     }\n }\n \n@@ -9755,7 +9745,7 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n \n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t boolean_type_node, from_len,\n-\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n+\t\t\t\t integer_zero_node);\n \t  return fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t  void_type_node, tmp,\n \t\t\t\t  extcopy, stdcopy);"}, {"sha": "14781ac48146f9aeafedebb8ee299960db6bcfa7", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -7497,12 +7497,10 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \n       nonzero_charlen = NULL_TREE;\n       if (arg1->expr->ts.type == BT_CHARACTER)\n-\tnonzero_charlen\n-\t  = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t     boolean_type_node,\n-\t\t\t     arg1->expr->ts.u.cl->backend_decl,\n-\t\t\t     build_zero_cst\n-\t\t\t     (TREE_TYPE (arg1->expr->ts.u.cl->backend_decl)));\n+\tnonzero_charlen = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   arg1->expr->ts.u.cl->backend_decl,\n+\t\t\t\t\t   integer_zero_node);\n       if (scalar)\n         {\n \t  /* A pointer to a scalar.  */\n@@ -7792,11 +7790,11 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \n   /* We store in charsize the size of a character.  */\n   i = gfc_validate_kind (BT_CHARACTER, expr->ts.kind, false);\n-  size = build_int_cst (sizetype, gfc_character_kinds[i].bit_size / 8);\n+  size = build_int_cst (size_type_node, gfc_character_kinds[i].bit_size / 8);\n \n   /* Get the arguments.  */\n   gfc_conv_intrinsic_function_args (se, expr, args, 3);\n-  slen = fold_convert (sizetype, gfc_evaluate_now (args[0], &se->pre));\n+  slen = fold_convert (size_type_node, gfc_evaluate_now (args[0], &se->pre));\n   src = args[1];\n   ncopies = gfc_evaluate_now (args[2], &se->pre);\n   ncopies_type = TREE_TYPE (ncopies);\n@@ -7813,7 +7811,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n      is valid, and nothing happens.  */\n   n = gfc_create_var (ncopies_type, \"ncopies\");\n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, slen,\n-\t\t\t  size_zero_node);\n+\t\t\t  build_int_cst (size_type_node, 0));\n   tmp = fold_build3_loc (input_location, COND_EXPR, ncopies_type, cond,\n \t\t\t build_int_cst (ncopies_type, 0), ncopies);\n   gfc_add_modify (&se->pre, n, tmp);\n@@ -7823,17 +7821,17 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n      (or equal to) MAX / slen, where MAX is the maximal integer of\n      the gfc_charlen_type_node type.  If slen == 0, we need a special\n      case to avoid the division by zero.  */\n-  max = fold_build2_loc (input_location, TRUNC_DIV_EXPR, sizetype,\n-\t\t\t fold_convert (sizetype,\n-\t\t\t\t       TYPE_MAX_VALUE (gfc_charlen_type_node)),\n-\t\t\t slen);\n-  largest = TYPE_PRECISION (sizetype) > TYPE_PRECISION (ncopies_type)\n-\t      ? sizetype : ncopies_type;\n+  i = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);\n+  max = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, gfc_charlen_int_kind);\n+  max = fold_build2_loc (input_location, TRUNC_DIV_EXPR, size_type_node,\n+\t\t\t  fold_convert (size_type_node, max), slen);\n+  largest = TYPE_PRECISION (size_type_node) > TYPE_PRECISION (ncopies_type)\n+\t      ? size_type_node : ncopies_type;\n   cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n \t\t\t  fold_convert (largest, ncopies),\n \t\t\t  fold_convert (largest, max));\n   tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, slen,\n-\t\t\t size_zero_node);\n+\t\t\t build_int_cst (size_type_node, 0));\n   cond = fold_build3_loc (input_location, COND_EXPR, boolean_type_node, tmp,\n \t\t\t  boolean_false_node, cond);\n   gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n@@ -7850,39 +7848,42 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n        for (i = 0; i < ncopies; i++)\n          memmove (dest + (i * slen * size), src, slen*size);  */\n   gfc_start_block (&block);\n-  count = gfc_create_var (sizetype, \"count\");\n-  gfc_add_modify (&block, count, size_zero_node);\n+  count = gfc_create_var (ncopies_type, \"count\");\n+  gfc_add_modify (&block, count, build_int_cst (ncopies_type, 0));\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n   /* Start the loop body.  */\n   gfc_start_block (&body);\n \n   /* Exit the loop if count >= ncopies.  */\n   cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, count,\n-\t\t\t  fold_convert (sizetype, ncopies));\n+\t\t\t  ncopies);\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n \t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Call memmove (dest + (i*slen*size), src, slen*size).  */\n-  tmp = fold_build2_loc (input_location, MULT_EXPR, sizetype, slen,\n-\t\t\t count);\n-  tmp = fold_build2_loc (input_location, MULT_EXPR, sizetype, tmp,\n-\t\t\t size);\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n+\t\t\t fold_convert (gfc_charlen_type_node, slen),\n+\t\t\t fold_convert (gfc_charlen_type_node, count));\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n+\t\t\t tmp, fold_convert (gfc_charlen_type_node, size));\n   tmp = fold_build_pointer_plus_loc (input_location,\n \t\t\t\t     fold_convert (pvoid_type_node, dest), tmp);\n   tmp = build_call_expr_loc (input_location,\n \t\t\t     builtin_decl_explicit (BUILT_IN_MEMMOVE),\n \t\t\t     3, tmp, src,\n \t\t\t     fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t\t      size_type_node, slen, size));\n+\t\t\t\t\t      size_type_node, slen,\n+\t\t\t\t\t      fold_convert (size_type_node,\n+\t\t\t\t\t\t\t    size)));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Increment count.  */\n-  tmp = fold_build2_loc (input_location, PLUS_EXPR, sizetype,\n-\t\t\t count, size_one_node);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, ncopies_type,\n+\t\t\t count, build_int_cst (TREE_TYPE (count), 1));\n   gfc_add_modify (&body, count, tmp);\n \n   /* Build the loop.  */"}, {"sha": "fbbad46de672a4801105b7817f424c1136069342", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -339,11 +339,11 @@ gfc_build_io_library_fndecls (void)\n \n   iocall[IOCALL_X_CHARACTER] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character\")), \".wW\",\n-\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_charlen_type_node);\n+\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_int4_type_node);\n \n   iocall[IOCALL_X_CHARACTER_WRITE] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character_write\")), \".wR\",\n-\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_charlen_type_node);\n+\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_int4_type_node);\n \n   iocall[IOCALL_X_CHARACTER_WIDE] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character_wide\")), \".wW\","}, {"sha": "856008779babb6c82bcdb480758d39d4a21ae067", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -112,7 +112,7 @@ gfc_trans_label_assign (gfc_code * code)\n       || code->label1->defined == ST_LABEL_DO_TARGET)\n     {\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n-      len_tree = build_int_cst (gfc_charlen_type_node, -1);\n+      len_tree = integer_minus_one_node;\n     }\n   else\n     {\n@@ -125,7 +125,7 @@ gfc_trans_label_assign (gfc_code * code)\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n     }\n \n-  gfc_add_modify (&se.pre, len, fold_convert (TREE_TYPE (len), len_tree));\n+  gfc_add_modify (&se.pre, len, len_tree);\n   gfc_add_modify (&se.pre, addr, label_tree);\n \n   return gfc_finish_block (&se.pre);\n@@ -2750,7 +2750,7 @@ gfc_trans_character_select (gfc_code *code)\n     {\n       for (d = cp; d; d = d->right)\n \t{\n-\t  gfc_charlen_t i;\n+\t  int i;\n \t  if (d->low)\n \t    {\n \t      gcc_assert (d->low->expr_type == EXPR_CONSTANT\n@@ -2955,7 +2955,7 @@ gfc_trans_character_select (gfc_code *code)\n       if (d->low == NULL)\n         {\n           CONSTRUCTOR_APPEND_ELT (node, ss_string1[k], null_pointer_node);\n-          CONSTRUCTOR_APPEND_ELT (node, ss_string1_len[k], build_zero_cst (gfc_charlen_type_node));\n+          CONSTRUCTOR_APPEND_ELT (node, ss_string1_len[k], integer_zero_node);\n         }\n       else\n         {\n@@ -2968,7 +2968,7 @@ gfc_trans_character_select (gfc_code *code)\n       if (d->high == NULL)\n         {\n           CONSTRUCTOR_APPEND_ELT (node, ss_string2[k], null_pointer_node);\n-          CONSTRUCTOR_APPEND_ELT (node, ss_string2_len[k], build_zero_cst (gfc_charlen_type_node));\n+          CONSTRUCTOR_APPEND_ELT (node, ss_string2_len[k], integer_zero_node);\n         }\n       else\n         {\n@@ -5640,7 +5640,7 @@ gfc_trans_allocate (gfc_code * code)\n \t{\n \t  gfc_init_se (&se, NULL);\n \t  temp_var_needed = false;\n-\t  expr3_len = build_zero_cst (gfc_charlen_type_node);\n+\t  expr3_len = integer_zero_node;\n \t  e3_is = E3_MOLD;\n \t}\n       /* Prevent aliasing, i.e., se.expr may be already a\n@@ -6036,8 +6036,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t     e.g., a string.  */\n \t\t  memsz = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t\t   boolean_type_node, expr3_len,\n-\t\t\t\t\t   build_zero_cst\n-\t\t\t\t\t   (TREE_TYPE (expr3_len)));\n+\t\t\t\t\t   integer_zero_node);\n \t\t  memsz = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t\t TREE_TYPE (expr3_esize),\n \t\t\t\t\t memsz, tmp, expr3_esize);\n@@ -6367,7 +6366,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\tgfc_build_addr_expr (pchar_type_node,\n \t\t\tgfc_build_localized_cstring_const (msg)));\n \n-      slen = build_int_cst (gfc_charlen_type_node, strlen (msg));\n+      slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n       dlen = gfc_get_expr_charlen (code->expr2);\n       slen = fold_build2_loc (input_location, MIN_EXPR,\n \t\t\t      TREE_TYPE (slen), dlen, slen);\n@@ -6649,7 +6648,7 @@ gfc_trans_deallocate (gfc_code *code)\n       gfc_add_modify (&errmsg_block, errmsg_str,\n \t\tgfc_build_addr_expr (pchar_type_node,\n                         gfc_build_localized_cstring_const (msg)));\n-      slen = build_int_cst (gfc_charlen_type_node, strlen (msg));\n+      slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n       dlen = gfc_get_expr_charlen (code->expr2);\n \n       gfc_trans_string_copy (&errmsg_block, dlen, errmsg, code->expr2->ts.kind,"}, {"sha": "759b80eecaa044daf2f77d14d96e591c007dbe4d", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -118,9 +118,6 @@ int gfc_intio_kind;\n /* The integer kind used to store character lengths.  */\n int gfc_charlen_int_kind;\n \n-/* Kind of internal integer for storing object sizes.  */\n-int gfc_size_kind;\n-\n /* The size of the numeric storage unit and character storage unit.  */\n int gfc_numeric_storage_size;\n int gfc_character_storage_size;\n@@ -964,13 +961,9 @@ gfc_init_types (void)\n \t\t\twi::mask (n, UNSIGNED,\n \t\t\t\t  TYPE_PRECISION (size_type_node)));\n \n-  /* Character lengths are of type size_t, except signed.  */\n-  gfc_charlen_int_kind = get_int_kind_from_node (size_type_node);\n+  /* ??? Shouldn't this be based on gfc_index_integer_kind or so?  */\n+  gfc_charlen_int_kind = 4;\n   gfc_charlen_type_node = gfc_get_int_type (gfc_charlen_int_kind);\n-\n-  /* Fortran kind number of size_type_node (size_t). This is used for\n-     the _size member in vtables.  */\n-  gfc_size_kind = get_int_kind_from_node (size_type_node);\n }\n \n /* Get the type node for the given type and kind.  */"}, {"sha": "2974e4513049288cf8242a7b48dcffe7fea1ac9d", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -23,7 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GFC_BACKEND_H\n #define GFC_BACKEND_H\n \n-\n extern GTY(()) tree gfc_array_index_type;\n extern GTY(()) tree gfc_array_range_type;\n extern GTY(()) tree gfc_character1_type_node;\n@@ -36,9 +35,10 @@ extern GTY(()) tree gfc_complex_float128_type_node;\n \n /* This is the type used to hold the lengths of character variables.\n    It must be the same as the corresponding definition in gfortran.h.  */\n+/* TODO: This is still hardcoded as kind=4 in some bits of the compiler\n+   and runtime library.  */\n extern GTY(()) tree gfc_charlen_type_node;\n \n-\n /* The following flags give us information on the correspondence of\n    real (and complex) kinds with C floating-point types long double\n    and __float128.  */"}, {"sha": "02b877ddf827a176187cca79f4c4dc592773417a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -19,18 +19,6 @@\n \tPR c++/71166\n \t* g++.dg/cpp0x/constexpr-array18.C: New test.\n \n-2017-01-13  Janne Blomqvist  <jb@gcc.gnu.org>\n-\n-\tPR fortran/78534\n-\tPR fortran/66310\n-\t* gfortran.dg/repeat_4.f90: Use integers of kind C_SIZE_T.\n-\t* gfortran.dg/repeat_7.f90: New test for PR 66310.\n-\t* gfortran.dg/scan_2.f90: Handle potential cast in assignment.\n-\t* gfortran.dg/string_1.f90: Limit to ilp32 targets.\n-\t* gfortran.dg/string_1_lp64.f90: New test.\n-\t* gfortran.dg/string_3.f90: Limit to ilp32 targets.\n-\t* gfortran.dg/string_3_lp64.f90: New test.\n-\n 2017-01-13  Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/tree-ssa/ssa-dse-25.c: New test."}, {"sha": "e5b5acc60ce6be47887b9478e9c35190701242a5", "filename": "gcc/testsuite/gfortran.dg/repeat_4.f90", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -2,7 +2,6 @@\n !\n ! { dg-do compile }\n program test\n-  use iso_c_binding, only: k => c_size_t\n   implicit none\n   character(len=0), parameter :: s0 = \"\" \n   character(len=1), parameter :: s1 = \"a\"\n@@ -22,18 +21,18 @@ program test\n   print *, repeat(t2, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n \n   ! Check for too large NCOPIES argument and limit cases\n-  print *, repeat(t0, huge(0_k))\n-  print *, repeat(t1, huge(0_k))\n-  print *, repeat(t2, huge(0_k)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n-  print *, repeat(s2, huge(0_k)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(t0, huge(0))\n+  print *, repeat(t1, huge(0))\n+  print *, repeat(t2, huge(0)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(s2, huge(0)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n \n-  print *, repeat(t0, huge(0_k)/2)\n-  print *, repeat(t1, huge(0_k)/2)\n-  print *, repeat(t2, huge(0_k)/2)\n+  print *, repeat(t0, huge(0)/2)\n+  print *, repeat(t1, huge(0)/2)\n+  print *, repeat(t2, huge(0)/2)\n \n-  print *, repeat(t0, huge(0_k)/2+1)\n-  print *, repeat(t1, huge(0_k)/2+1)\n-  print *, repeat(t2, huge(0_k)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n-  print *, repeat(s2, huge(0_k)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(t0, huge(0)/2+1)\n+  print *, repeat(t1, huge(0)/2+1)\n+  print *, repeat(t2, huge(0)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(s2, huge(0)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n \n end program test"}, {"sha": "82f8dbf4deaab62625f7aa1c7c2dedb6b3c7128d", "filename": "gcc/testsuite/gfortran.dg/repeat_7.f90", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4aa83d6ff4720fffd2c9f62c6e3082ece1937f/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4aa83d6ff4720fffd2c9f62c6e3082ece1937f/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90?ref=be4aa83d6ff4720fffd2c9f62c6e3082ece1937f", "patch": "@@ -1,8 +0,0 @@\n-! { dg-do compile }\n-! PR 66310\n-! Make sure there is a limit to how large arrays we try to handle at\n-! compile time.\n-program p\n-  character, parameter :: z = 'z'\n-  print *, repeat(z, huge(1_4))\n-end program p"}, {"sha": "c58a3a21a7fefa3a93532ee9156ef7784a995445", "filename": "gcc/testsuite/gfortran.dg/scan_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -30,5 +30,5 @@ program p1\n    call s1(.TRUE.)\n end program p1\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_string_scan \\\\(2,\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_string_verify \\\\(2,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"iscan = _gfortran_string_scan \\\\(2,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"iverify = _gfortran_string_verify \\\\(2,\" 1 \"original\" } }"}, {"sha": "11dc5b7a3401150ae062423ef649c1b172a526de", "filename": "gcc/testsuite/gfortran.dg/string_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -1,5 +1,4 @@\n ! { dg-do compile }\n-! { dg-require-effective-target ilp32 }\n !\n program main\n   implicit none"}, {"sha": "a0edbefc53e4cb8df3148b41556f568f588fe782", "filename": "gcc/testsuite/gfortran.dg/string_1_lp64.f90", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4aa83d6ff4720fffd2c9f62c6e3082ece1937f/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4aa83d6ff4720fffd2c9f62c6e3082ece1937f/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90?ref=be4aa83d6ff4720fffd2c9f62c6e3082ece1937f", "patch": "@@ -1,15 +0,0 @@\n-! { dg-do compile }\n-! { dg-require-effective-target lp64 }\n-! { dg-require-effective-target fortran_integer_16 }\n-program main\n-  implicit none\n-  integer(kind=16), parameter :: l1 = 2_16**64_16\n-  character (len=2_16**64_16+4_16), parameter :: s = \"\" ! { dg-error \"too large\" }\n-  character (len=2_16**64_8+4_16) :: ch ! { dg-error \"too large\" }\n-  character (len=l1 + 1_16) :: v ! { dg-error \"too large\" }\n-  character (len=int(huge(0_8),kind=16) + 1_16) :: z ! { dg-error \"too large\" }\n-  character (len=int(huge(0_8),kind=16) + 0_16) :: w\n-\n-  print *, len(s)\n-\n-end program main"}, {"sha": "7daf8d31ae665285594f99314ce182f0aaf664fe", "filename": "gcc/testsuite/gfortran.dg/string_3.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -1,5 +1,4 @@\n ! { dg-do compile }\n-! { dg-require-effective-target ilp32 }\n !\n subroutine foo(i)\n   implicit none"}, {"sha": "162561fad00b1778e05c63a3b6eaad751f6c0998", "filename": "gcc/testsuite/gfortran.dg/string_3_lp64.f90", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4aa83d6ff4720fffd2c9f62c6e3082ece1937f/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4aa83d6ff4720fffd2c9f62c6e3082ece1937f/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90?ref=be4aa83d6ff4720fffd2c9f62c6e3082ece1937f", "patch": "@@ -1,20 +0,0 @@\n-! { dg-do compile }\n-! { dg-require-effective-target lp64 }\n-! { dg-require-effective-target fortran_integer_16 }\n-subroutine foo(i)\n-  implicit none\n-  integer, intent(in) :: i\n-  character(len=i) :: s\n-\n-  s = ''\n-  print *, s(1:2_16**64_16+3_16) ! { dg-error \"too large\" }\n-  print *, s(2_16**64_16+3_16:2_16**64_16+4_16) ! { dg-error \"too large\" }\n-  print *, len(s(1:2_16**64_16+3_16)) ! { dg-error \"too large\" }\n-  print *, len(s(2_16**64_16+3_16:2_16**64_16+4_16)) ! { dg-error \"too large\" }\n-\n-  print *, s(2_16**64_16+3_16:1)\n-  print *, s(2_16**64_16+4_16:2_16**64_16+3_16)\n-  print *, len(s(2_16**64_16+3_16:1))\n-  print *, len(s(2_16**64_16+4_16:2_16**64_16+3_16))\n-\n-end subroutine"}, {"sha": "1a687300a78faa70b0b828cc62bdc9168f67dc9a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -1,28 +1,3 @@\n-2017-01-13  Janne Blomqvist  <jb@gcc.gnu.org>\n-\n-\tPR fortran/78534\n-\t* intrinsics/args.c (getarg_i4): Use gfc_charlen_type.\n-\t(get_command_argument_i4): Likewise.\n-\t(get_command_i4): Likewise.\n-\t* intrinsics/chmod.c (chmod_internal): Likewise.\n-\t* intrinsics/env.c (get_environment_variable_i4): Likewise.\n-\t* intrinsics/extends_type_of.c (struct vtype): Use size_t for size\n-\tmember.\n-\t* intrinsics/gerror.c (gerror): Use gfc_charlen_type.\n-\t* intrinsics/getlog.c (getlog): Likewise.\n-\t* intrinsics/hostnm.c (hostnm_0): Likewise.\n-\t* intrinsics/string_intrinsics_inc.c (string_len_trim): Rework to\n-\twork if gfc_charlen_type is unsigned.\n-\t(string_scan): Likewise.\n-\t* io/transfer.c (transfer_character): Modify prototype.\n-\t(transfer_character_write): Likewise.\n-\t(transfer_character_wide): Likewise.\n-\t(transfer_character_wide_write): Likewise.\n-\t(transfer_array): Typecast to avoid signed-unsigned comparison.\n-\t* io/unit.c (is_trim_ok): Use gfc_charlen_type.\n-\t* io/write.c (namelist_write): Likewise.\n-\t* libgfortran.h (gfc_charlen_type): Change typedef to size_t.\n-\n 2017-01-13  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/70696"}, {"sha": "c07181f31139c386018cb093babda888e8a011ad", "filename": "libgfortran/intrinsics/args.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fargs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fargs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fargs.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -37,6 +37,7 @@ void\n getarg_i4 (GFC_INTEGER_4 *pos, char  *val, gfc_charlen_type val_len)\n {\n   int argc;\n+  int arglen;\n   char **argv;\n \n   get_args (&argc, &argv);\n@@ -48,7 +49,7 @@ getarg_i4 (GFC_INTEGER_4 *pos, char  *val, gfc_charlen_type val_len)\n \n   if ((*pos) + 1 <= argc  && *pos >=0 )\n     {\n-      gfc_charlen_type arglen = strlen (argv[*pos]);\n+      arglen = strlen (argv[*pos]);\n       if (arglen > val_len)\n \targlen = val_len;\n       memcpy (val, argv[*pos], arglen);\n@@ -118,8 +119,7 @@ get_command_argument_i4 (GFC_INTEGER_4 *number, char *value,\n \t\t\t GFC_INTEGER_4 *length, GFC_INTEGER_4 *status, \n \t\t\t gfc_charlen_type value_len)\n {\n-  int argc, stat_flag = GFC_GC_SUCCESS;\n-  gfc_charlen_type arglen = 0;\n+  int argc, arglen = 0, stat_flag = GFC_GC_SUCCESS;\n   char **argv;\n \n   if (number == NULL )\n@@ -195,10 +195,10 @@ void\n get_command_i4 (char *command, GFC_INTEGER_4 *length, GFC_INTEGER_4 *status,\n \t\tgfc_charlen_type command_len)\n {\n-  int i, argc, thisarg;\n+  int i, argc, arglen, thisarg;\n   int stat_flag = GFC_GC_SUCCESS;\n+  int tot_len = 0;\n   char **argv;\n-  gfc_charlen_type arglen, tot_len = 0;\n \n   if (command == NULL && length == NULL && status == NULL)\n     return; /* No need to do anything.  */"}, {"sha": "d08418d773f898960db5540dbdd3da35bd322e3c", "filename": "libgfortran/intrinsics/chmod.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fchmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fchmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fchmod.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -64,6 +64,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n static int\n chmod_internal (char *file, char *mode, gfc_charlen_type mode_len)\n {\n+  int i;\n   bool ugo[3];\n   bool rwxXstugo[9];\n   int set_mode, part;\n@@ -103,7 +104,7 @@ chmod_internal (char *file, char *mode, gfc_charlen_type mode_len)\n   honor_umask = false;\n #endif\n \n-  for (gfc_charlen_type i = 0; i < mode_len; i++)\n+  for (i = 0; i < mode_len; i++)\n     {\n       if (!continue_clause)\n \t{"}, {"sha": "f8e376e9dfe32e1e2a26190317fe02e4d6a78bb5", "filename": "libgfortran/intrinsics/env.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fenv.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -93,8 +93,7 @@ get_environment_variable_i4 (char *name, char *value, GFC_INTEGER_4 *length,\n \t\t\t     gfc_charlen_type name_len,\n \t\t\t     gfc_charlen_type value_len)\n {\n-  int stat = GFC_SUCCESS;\n-  gfc_charlen_type res_len = 0;\n+  int stat = GFC_SUCCESS, res_len = 0;\n   char *name_nt;\n   char *res;\n "}, {"sha": "8177e0eefebbf666bcb4b0f8ee2d09365d2919e0", "filename": "libgfortran/intrinsics/extends_type_of.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fextends_type_of.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fextends_type_of.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fextends_type_of.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -30,7 +30,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n typedef struct vtype\n {\n   GFC_INTEGER_4 hash;\n-  size_t size;\n+  GFC_INTEGER_4 size;\n   struct vtype *extends;\n }\n vtype;"}, {"sha": "34ea1dfb73febb0fa45b7a86c2dd6db874fbc04c", "filename": "libgfortran/intrinsics/gerror.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fgerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fgerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fgerror.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -39,7 +39,7 @@ export_proto_np(PREFIX(gerror));\n void \n PREFIX(gerror) (char * msg, gfc_charlen_type msg_len)\n {\n-  gfc_charlen_type p_len;\n+  int p_len;\n   char *p;\n \n   p = gf_strerror (errno, msg, msg_len);"}, {"sha": "a856cd1eee8d86ab7eb04087149720a3466b3005", "filename": "libgfortran/intrinsics/getlog.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fgetlog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fgetlog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fgetlog.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -70,6 +70,7 @@ export_proto_np(PREFIX(getlog));\n void\n PREFIX(getlog) (char * login, gfc_charlen_type login_len)\n {\n+  int p_len;\n   char *p;\n \n   memset (login, ' ', login_len); /* Blank the string.  */\n@@ -106,7 +107,7 @@ PREFIX(getlog) (char * login, gfc_charlen_type login_len)\n   if (p == NULL)\n     goto cleanup;\n \n-  gfc_charlen_type p_len = strlen (p);\n+  p_len = strlen (p);\n   if (login_len < p_len)\n     p_len = login_len;\n   memcpy (login, p, p_len);"}, {"sha": "2ccb5bdb3713379afce09be7763797440f2ab5fa", "filename": "libgfortran/intrinsics/hostnm.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fhostnm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fhostnm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fhostnm.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -88,8 +88,8 @@ w32_gethostname (char *name, size_t len)\n static int\n hostnm_0 (char *name, gfc_charlen_type name_len)\n {\n+  int val, i;\n   char p[HOST_NAME_MAX + 1];\n-  int val;\n \n   memset (name, ' ', name_len);\n \n@@ -99,7 +99,8 @@ hostnm_0 (char *name, gfc_charlen_type name_len)\n \n   if (val == 0)\n   {\n-    for (gfc_charlen_type i = 0; i < name_len && p[i] != '\\0'; i++)\n+    i = -1;\n+    while (i < name_len && p[++i] != '\\0')\n       name[i] = p[i];\n   }\n "}, {"sha": "f514f4c6a3ee40f45d6ff900a314c7833c18c264", "filename": "libgfortran/intrinsics/string_intrinsics_inc.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -224,15 +224,14 @@ string_len_trim (gfc_charlen_type len, const CHARTYPE *s)\n \t      break;\n \t    }\n \t}\n+\n+      /* Now continue for the last characters with naive approach below.  */\n+      assert (i >= 0);\n     }\n \n   /* Simply look for the first non-blank character.  */\n-  while (s[i] == ' ')\n-    {\n-      if (i == 0)\n-\treturn 0;\n-      --i;\n-    }\n+  while (i >= 0 && s[i] == ' ')\n+    --i;\n   return i + 1;\n }\n \n@@ -328,12 +327,12 @@ string_scan (gfc_charlen_type slen, const CHARTYPE *str,\n \n   if (back)\n     {\n-      for (i = slen; i != 0; i--)\n+      for (i = slen - 1; i >= 0; i--)\n \t{\n \t  for (j = 0; j < setlen; j++)\n \t    {\n-\t      if (str[i - 1] == set[j])\n-\t\treturn i;\n+\t      if (str[i] == set[j])\n+\t\treturn (i + 1);\n \t    }\n \t}\n     }"}, {"sha": "b47f4e07c82cf16481e4dc14cfb55385c84efae0", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -93,17 +93,17 @@ export_proto(transfer_logical);\n extern void transfer_logical_write (st_parameter_dt *, void *, int);\n export_proto(transfer_logical_write);\n \n-extern void transfer_character (st_parameter_dt *, void *, gfc_charlen_type);\n+extern void transfer_character (st_parameter_dt *, void *, int);\n export_proto(transfer_character);\n \n-extern void transfer_character_write (st_parameter_dt *, void *, gfc_charlen_type);\n+extern void transfer_character_write (st_parameter_dt *, void *, int);\n export_proto(transfer_character_write);\n \n-extern void transfer_character_wide (st_parameter_dt *, void *, gfc_charlen_type, int);\n+extern void transfer_character_wide (st_parameter_dt *, void *, int, int);\n export_proto(transfer_character_wide);\n \n extern void transfer_character_wide_write (st_parameter_dt *,\n-\t\t\t\t\t   void *, gfc_charlen_type, int);\n+\t\t\t\t\t   void *, int, int);\n export_proto(transfer_character_wide_write);\n \n extern void transfer_complex (st_parameter_dt *, void *, int);\n@@ -2272,7 +2272,7 @@ transfer_logical_write (st_parameter_dt *dtp, void *p, int kind)\n }\n \n void\n-transfer_character (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n+transfer_character (st_parameter_dt *dtp, void *p, int len)\n {\n   static char *empty_string[0];\n \n@@ -2290,13 +2290,13 @@ transfer_character (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n }\n \n void\n-transfer_character_write (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n+transfer_character_write (st_parameter_dt *dtp, void *p, int len)\n {\n   transfer_character (dtp, p, len);\n }\n \n void\n-transfer_character_wide (st_parameter_dt *dtp, void *p, gfc_charlen_type len, int kind)\n+transfer_character_wide (st_parameter_dt *dtp, void *p, int len, int kind)\n {\n   static char *empty_string[0];\n \n@@ -2314,7 +2314,7 @@ transfer_character_wide (st_parameter_dt *dtp, void *p, gfc_charlen_type len, in\n }\n \n void\n-transfer_character_wide_write (st_parameter_dt *dtp, void *p, gfc_charlen_type len, int kind)\n+transfer_character_wide_write (st_parameter_dt *dtp, void *p, int len, int kind)\n {\n   transfer_character_wide (dtp, p, len, kind);\n }\n@@ -2351,7 +2351,7 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n     return;\n \n   iotype = (bt) GFC_DESCRIPTOR_TYPE (desc);\n-  size = iotype == BT_CHARACTER ? (index_type) charlen : GFC_DESCRIPTOR_SIZE (desc);\n+  size = iotype == BT_CHARACTER ? charlen : GFC_DESCRIPTOR_SIZE (desc);\n \n   rank = GFC_DESCRIPTOR_RANK (desc);\n   for (n = 0; n < rank; n++)"}, {"sha": "ed3bc3231ec350b840534a675a7d12cb0c2ede37", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -439,9 +439,10 @@ is_trim_ok (st_parameter_dt *dtp)\n   if (dtp->common.flags & IOPARM_DT_HAS_FORMAT)\n     {\n       char *p = dtp->format;\n+      off_t i;\n       if (dtp->common.flags & IOPARM_DT_HAS_BLANK)\n \treturn false;\n-      for (gfc_charlen_type i = 0; i < dtp->format_len; i++)\n+      for (i = 0; i < dtp->format_len; i++)\n \t{\n \t  if (p[i] == '/') return false;\n \t  if (p[i] == 'b' || p[i] == 'B')"}, {"sha": "47970d42de19d0a7fd015cb4420e562d074afd49", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -2380,6 +2380,7 @@ void\n namelist_write (st_parameter_dt *dtp)\n {\n   namelist_info * t1, *t2, *dummy = NULL;\n+  index_type i;\n   index_type dummy_offset = 0;\n   char c;\n   char * dummy_name = NULL;\n@@ -2401,7 +2402,7 @@ namelist_write (st_parameter_dt *dtp)\n   write_character (dtp, \"&\", 1, 1, NODELIM);\n \n   /* Write namelist name in upper case - f95 std.  */\n-  for (gfc_charlen_type i = 0; i < dtp->namelist_name_len; i++ )\n+  for (i = 0 ;i < dtp->namelist_name_len ;i++ )\n     {\n       c = toupper ((int) dtp->namelist_name[i]);\n       write_character (dtp, &c, 1 ,1, NODELIM);"}, {"sha": "cfe04760fe500e3ade38664619af2fcc56dd16db", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e9bbcc49c1b9f169c5911f3871f5df109bff9b/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=c1e9bbcc49c1b9f169c5911f3871f5df109bff9b", "patch": "@@ -250,7 +250,7 @@ typedef GFC_INTEGER_4 GFC_IO_INT;\n typedef ptrdiff_t index_type;\n \n /* The type used for the lengths of character variables.  */\n-typedef size_t gfc_charlen_type;\n+typedef GFC_INTEGER_4 gfc_charlen_type;\n \n /* Definitions of CHARACTER data types:\n      - CHARACTER(KIND=1) corresponds to the C char type,"}]}