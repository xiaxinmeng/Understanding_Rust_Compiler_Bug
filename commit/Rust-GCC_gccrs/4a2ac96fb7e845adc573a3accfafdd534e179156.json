{"sha": "4a2ac96fb7e845adc573a3accfafdd534e179156", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEyYWM5NmZiN2U4NDVhZGM1NzNhM2FjY2ZhZmRkNTM0ZTE3OTE1Ng==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-06-13T14:14:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-06-13T14:14:17Z"}, "message": "lto-streamer-in.c (lto_input_ts_type_tree_pointers): Do not stream but initialize TYPE_CANONICAL to NULL.\n\n2010-06-13  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-streamer-in.c (lto_input_ts_type_tree_pointers):\n\tDo not stream but initialize TYPE_CANONICAL to NULL.\n\t(lto_output_ts_type_tree_pointers): Do not stream TYPE_CANONICAL.\n\t* gimple.c (gimple_types_compatible_p): Disregard\n\tTYPE_STRUCTURAL_EQUALITY_P.\n\t(gimple_register_type): Use TYPE_CANONICAL as cache.\n\t* lto-streamer.c (lto_record_common_node): Zero TYPE_CANONICAL\n\tbefore registering common types.\n\t* config/i386/i386.c (ix86_function_arg_boundary): Do not\n\tuse TYPE_CANONICAL, instead use TYPE_MAIN_VARIANT.\n\t* tree.h (TYPE_CANONICAL): Clarify documentation.\n\n\tlto/\n\t* lto.c (lto_fixup_type): Do not register or fixup TYPE_CANONICAL.\n\nFrom-SVN: r160679", "tree": {"sha": "35daaa9972d65e4f2ede54da386f2214ce5ac3cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35daaa9972d65e4f2ede54da386f2214ce5ac3cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a2ac96fb7e845adc573a3accfafdd534e179156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2ac96fb7e845adc573a3accfafdd534e179156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a2ac96fb7e845adc573a3accfafdd534e179156", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2ac96fb7e845adc573a3accfafdd534e179156/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba90d838257853023abae85f8c393eda41c50189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba90d838257853023abae85f8c393eda41c50189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba90d838257853023abae85f8c393eda41c50189"}], "stats": {"total": 87, "additions": 63, "deletions": 24}, "files": [{"sha": "72297411352a6a0f578c9cf9a774a6652bae08ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -1,3 +1,17 @@\n+2010-06-13  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-streamer-in.c (lto_input_ts_type_tree_pointers):\n+\tDo not stream but initialize TYPE_CANONICAL to NULL.\n+\t(lto_output_ts_type_tree_pointers): Do not stream TYPE_CANONICAL.\n+\t* gimple.c (gimple_types_compatible_p): Disregard\n+\tTYPE_STRUCTURAL_EQUALITY_P.\n+\t(gimple_register_type): Use TYPE_CANONICAL as cache.\n+\t* lto-streamer.c (lto_record_common_node): Zero TYPE_CANONICAL\n+\tbefore registering common types.\n+\t* config/i386/i386.c (ix86_function_arg_boundary): Do not\n+\tuse TYPE_CANONICAL, instead use TYPE_MAIN_VARIANT.\n+\t* tree.h (TYPE_CANONICAL): Clarify documentation.\n+\n 2010-06-13  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/ia64/ia64.h (FUNCTION_VALUE_REGNO_P, FUNCTION_VALUE,"}, {"sha": "657e55a27650be7c55d679d59362210e195523ca", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -6398,10 +6398,9 @@ ix86_function_arg_boundary (enum machine_mode mode, tree type)\n   int align;\n   if (type)\n     {\n-      /* Since canonical type is used for call, we convert it to\n-\t canonical type if needed.  */\n-      if (!TYPE_STRUCTURAL_EQUALITY_P (type))\n-\ttype = TYPE_CANONICAL (type);\n+      /* Since the main variant type is used for call, we convert it to\n+\t the main variant type.  */\n+      type = TYPE_MAIN_VARIANT (type);\n       align = TYPE_ALIGN (type);\n     }\n   else"}, {"sha": "1a10f31a4051a38918c430ad43cf774a72e64dc0", "filename": "gcc/gimple.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -3593,12 +3593,6 @@ gimple_types_compatible_p (tree t1, tree t2)\n       {\n \ttree f1, f2;\n \n-\t/* If one type requires structural equality checks and the\n-\t   other doesn't, do not merge the types.  */\n-\tif (TYPE_STRUCTURAL_EQUALITY_P (t1)\n-\t    != TYPE_STRUCTURAL_EQUALITY_P (t2))\n-\t  goto different_types;\n-\n \t/* The struct tags shall compare equal.  */\n \tif (!compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n \t\t\t\t   TYPE_MAIN_VARIANT (t2), false))\n@@ -3955,6 +3949,11 @@ gimple_register_type (tree t)\n \n   gcc_assert (TYPE_P (t));\n \n+  /* In TYPE_CANONICAL we cache the result of gimple_register_type.\n+     It is initially set to NULL during LTO streaming.  */\n+  if (TYPE_CANONICAL (t))\n+    return TYPE_CANONICAL (t);\n+\n   /* Always register the main variant first.  This is important so we\n      pick up the non-typedef variants as canonical, otherwise we'll end\n      up taking typedef ids for structure tags during comparison.  */\n@@ -4018,10 +4017,14 @@ gimple_register_type (tree t)\n \t  TYPE_NEXT_REF_TO (t) = NULL_TREE;\n \t}\n \n+      TYPE_CANONICAL (t) = new_type;\n       t = new_type;\n     }\n   else\n-    *slot = (void *) t;\n+    {\n+      TYPE_CANONICAL (t) = t;\n+      *slot = (void *) t;\n+    }\n \n   return t;\n }"}, {"sha": "d56cf5d90b1f0d2bdbe6e01c7c920119270e7232", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -2192,7 +2192,8 @@ lto_input_ts_type_tree_pointers (struct lto_input_block *ib,\n   if (RECORD_OR_UNION_TYPE_P (expr))\n     TYPE_BINFO (expr) = lto_input_tree (ib, data_in);\n   TYPE_CONTEXT (expr) = lto_input_tree (ib, data_in);\n-  TYPE_CANONICAL (expr) = lto_input_tree (ib, data_in);\n+  /* TYPE_CANONICAL gets re-computed during type merging.  */\n+  TYPE_CANONICAL (expr) = NULL_TREE;\n   TYPE_STUB_DECL (expr) = lto_input_tree (ib, data_in);\n }\n "}, {"sha": "e6475456ecaf833a27b86534fcc3847a9ea7239d", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -986,7 +986,8 @@ lto_output_ts_type_tree_pointers (struct output_block *ob, tree expr,\n   if (RECORD_OR_UNION_TYPE_P (expr))\n     lto_output_tree_or_ref (ob, TYPE_BINFO (expr), ref_p);\n   lto_output_tree_or_ref (ob, TYPE_CONTEXT (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_CANONICAL (expr), ref_p);\n+  /* TYPE_CANONICAL is re-computed during type merging, so no need\n+     to stream it here.  */\n   lto_output_tree_or_ref (ob, TYPE_STUB_DECL (expr), ref_p);\n }\n "}, {"sha": "5b0e7748b2f8e2d8253b78515447ecc37ccadfec", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -674,7 +674,12 @@ lto_record_common_node (tree *nodep, VEC(tree, heap) **common_nodes,\n     return;\n \n   if (TYPE_P (node))\n-    *nodep = node = gimple_register_type (node);\n+    {\n+      /* Type merging will get confused by the canonical types as they\n+\t are set by the middle-end.  */\n+      TYPE_CANONICAL (node) = NULL_TREE;\n+      *nodep = node = gimple_register_type (node);\n+    }\n \n   /* Return if node is already seen.  */\n   if (pointer_set_insert (seen_nodes, node))"}, {"sha": "c3618b6ab4a89f5c2bf27f46926cda9cb0935467", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -1,3 +1,7 @@\n+2010-06-13  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (lto_fixup_type): Do not register or fixup TYPE_CANONICAL.\n+\n 2010-06-09  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* lto.c (lto_resolution_read):  Pre-initialize local variable r."}, {"sha": "d969a1042d7803f9271e8c2f123f813c41640cfa", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -1087,7 +1087,11 @@ lto_fixup_type (tree t, void *data)\n       else\n \tLTO_FIXUP_SUBTREE (TYPE_CONTEXT (t));\n     }\n-  LTO_REGISTER_TYPE_AND_FIXUP_SUBTREE (TYPE_CANONICAL (t));\n+\n+  /* TYPE_CANONICAL does not need to be fixed up, instead it should\n+     always point to ourselves at this time as we never fixup\n+     non-canonical ones.  */\n+  gcc_assert (TYPE_CANONICAL (t) == t);\n \n   /* The following re-creates proper variant lists while fixing up\n      the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the"}, {"sha": "bd86f44e1e029987eb444fa1af8b82a3efc5951f", "filename": "gcc/tree.h", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2ac96fb7e845adc573a3accfafdd534e179156/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4a2ac96fb7e845adc573a3accfafdd534e179156", "patch": "@@ -2090,26 +2090,34 @@ extern enum machine_mode vector_type_mode (const_tree);\n #define SET_TYPE_MODE(NODE, MODE) \\\n   (TYPE_CHECK (NODE)->type.mode = (MODE))\n \n-/* The \"canonical\" type for this type node, which can be used to\n-   compare the type for equality with another type. If two types are\n+/* The \"canonical\" type for this type node, which is used by frontends to\n+   compare the type for equality with another type.  If two types are\n    equal (based on the semantics of the language), then they will have\n    equivalent TYPE_CANONICAL entries.\n \n-   As a special case, if TYPE_CANONICAL is NULL_TREE, then it cannot\n-   be used for comparison against other types. Instead, the type is\n+   As a special case, if TYPE_CANONICAL is NULL_TREE, and thus\n+   TYPE_STRUCTURAL_EQUALITY_P is true, then it cannot\n+   be used for comparison against other types.  Instead, the type is\n    said to require structural equality checks, described in\n-   TYPE_STRUCTURAL_EQUALITY_P. */\n+   TYPE_STRUCTURAL_EQUALITY_P.\n+\n+   For unqualified aggregate and function types the middle-end relies on\n+   TYPE_CANONICAL to tell whether two variables can be assigned\n+   to each other without a conversion.  The middle-end also makes sure\n+   to assign the same alias-sets to the type partition with equal\n+   TYPE_CANONICAL of their unqualified variants.  */\n #define TYPE_CANONICAL(NODE) (TYPE_CHECK (NODE)->type.canonical)\n /* Indicates that the type node requires structural equality\n-   checks. The compiler will need to look at the composition of the\n+   checks.  The compiler will need to look at the composition of the\n    type to determine whether it is equal to another type, rather than\n-   just comparing canonical type pointers. For instance, we would need\n+   just comparing canonical type pointers.  For instance, we would need\n    to look at the return and parameter types of a FUNCTION_TYPE\n-   node. */\n+   node.  */\n #define TYPE_STRUCTURAL_EQUALITY_P(NODE) (TYPE_CANONICAL (NODE) == NULL_TREE)\n /* Sets the TYPE_CANONICAL field to NULL_TREE, indicating that the\n-   type node requires structural equality. */\n+   type node requires structural equality.  */\n #define SET_TYPE_STRUCTURAL_EQUALITY(NODE) (TYPE_CANONICAL (NODE) = NULL_TREE)\n+\n #define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n #define TYPE_IBIT(NODE) (GET_MODE_IBIT (TYPE_MODE (NODE)))\n #define TYPE_FBIT(NODE) (GET_MODE_FBIT (TYPE_MODE (NODE)))"}]}