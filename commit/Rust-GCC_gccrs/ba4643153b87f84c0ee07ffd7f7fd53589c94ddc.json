{"sha": "ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0NjQzMTUzYjg3Zjg0YzBlZTA3ZmZkN2Y3ZmQ1MzU4OWM5NGRkYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-09-14T07:21:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-09-14T07:21:38Z"}, "message": "gigi.h (ref_filename): Delete.\n\n\t* gcc-interface/gigi.h (ref_filename): Delete.\n\t(Sloc_to_locus): Add clean_column parameter defaulting to false.\n\t(build_call_raise): Adjust comment.\n\t(build_call_raise_range): Move around.\n\t* gcc-interface/trans.c (ref_filename): Delete.\n\t(gigi): Fix formatting.\n\t(block_end_locus_sink): Delete.\n\t(Sloc_to_locus1): Tidy up and reformat.  Rename into...\n\t(Sloc_to_locus): ...this.  Add default for clean_colmun parameter.\n\t(set_expr_location_from_node1): Rename into...\n\t(set_expr_location_from_node): ...this.\n\t(set_end_locus_from_node): Move around.  Adjust for renaming.\n\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n\t(add_cleanup): Likewise.\n\t* gcc-interface/utils2.c (expand_sloc): New static function.\n\t(build_call_raise): Call it.\n\t(build_call_raise_column): Likewise.\n\t(build_call_raise_range): Likewise.  Move around.\n\nFrom-SVN: r227736", "tree": {"sha": "83fbdae90cd7856085145cac723fa634819cb318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83fbdae90cd7856085145cac723fa634819cb318"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/comments", "author": null, "committer": null, "parents": [{"sha": "92d5f5ab3c36e05f10fc3445f0bf4b38e48be8fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d5f5ab3c36e05f10fc3445f0bf4b38e48be8fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d5f5ab3c36e05f10fc3445f0bf4b38e48be8fb"}], "stats": {"total": 442, "additions": 189, "deletions": 253}, "files": [{"sha": "e3d0e2289f90046e9ba2a58f1c0d7ec6bdedb163", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "patch": "@@ -1,3 +1,24 @@\n+2015-09-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (ref_filename): Delete.\n+\t(Sloc_to_locus): Add clean_column parameter defaulting to false.\n+\t(build_call_raise): Adjust comment.\n+\t(build_call_raise_range): Move around.\n+\t* gcc-interface/trans.c (ref_filename): Delete.\n+\t(gigi): Fix formatting.\n+\t(block_end_locus_sink): Delete.\n+\t(Sloc_to_locus1): Tidy up and reformat.  Rename into...\n+\t(Sloc_to_locus): ...this.  Add default for clean_colmun parameter.\n+\t(set_expr_location_from_node1): Rename into...\n+\t(set_expr_location_from_node): ...this.\n+\t(set_end_locus_from_node): Move around.  Adjust for renaming.\n+\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n+\t(add_cleanup): Likewise.\n+\t* gcc-interface/utils2.c (expand_sloc): New static function.\n+\t(build_call_raise): Call it.\n+\t(build_call_raise_column): Likewise.\n+\t(build_call_raise_range): Likewise.  Move around.\n+\n 2015-09-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils2.c (gnat_rewrite_reference) <COMPOUND_EXPR>: Add"}, {"sha": "cb3d7788346eec7e10246dd6868e26f2e5f90c69", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "patch": "@@ -6241,7 +6241,7 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \t Returning the variable ensures the caller will use it in generated\n \t code.  Note that there is no need for a location if the debug info\n \t contains an integer constant.\n-\t FIXME: when the encoding-based debug scheme is dropped, move this\n+\t TODO: when the encoding-based debug scheme is dropped, move this\n \t condition to the top-level IF block: we will not need to create a\n \t variable anymore in such cases, then.  */\n       if (use_variable || (need_debug && !TREE_CONSTANT (gnu_expr)))"}, {"sha": "9420fd83f7579ab34f53581d461ffc2a86c2037e", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "patch": "@@ -227,9 +227,6 @@ extern Node_Id error_gnat_node;\n    types with representation information.  */\n extern bool type_annotate_only;\n \n-/* Current file name without path.  */\n-extern const char *ref_filename;\n-\n /* This structure must be kept synchronized with Call_Back_End.  */\n struct File_Info_Type\n {\n@@ -288,9 +285,10 @@ extern int gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n extern void process_type (Entity_Id gnat_entity);\n \n /* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n-   location and false if it doesn't.  In the former case, set the Gigi global\n-   variable REF_FILENAME to the simple debug file name as given by sinput.  */\n-extern bool Sloc_to_locus (Source_Ptr Sloc, location_t *locus);\n+   location and false if it doesn't.  If CLEAR_COLUMN is true, set the column\n+   information to 0.  */\n+extern bool Sloc_to_locus (Source_Ptr Sloc, location_t *locus,\n+\t\t\t   bool clear_column = false);\n \n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n@@ -874,27 +872,23 @@ extern tree build_compound_expr (tree result_type, tree stmt_operand,\n    this doesn't fold the call, hence it will always return a CALL_EXPR.  */\n extern tree build_call_n_expr (tree fndecl, int n, ...);\n \n-/* Call a function that raises an exception and pass the line number and file\n-   name, if requested.  MSG says which exception function to call.\n-\n-   GNAT_NODE is the gnat node conveying the source location for which the\n-   error should be signaled, or Empty in which case the error is signaled on\n-   the current ref_file_name/input_line.\n-\n-   KIND says which kind of exception this is for\n-    (N_Raise_{Constraint,Storage,Program}_Error).  */\n+/* Build a call to a function that raises an exception and passes file name\n+   and line number, if requested.  MSG says which exception function to call.\n+   GNAT_NODE is the node conveying the source location for which the error\n+   should be signaled, or Empty in which case the error is signaled for the\n+   current location.  KIND says which kind of exception node this is for,\n+   among N_Raise_{Constraint,Storage,Program}_Error.  */\n extern tree build_call_raise (int msg, Node_Id gnat_node, char kind);\n \n-/* Similar to build_call_raise, for an index or range check exception as\n-   determined by MSG, with extra information generated of the form\n-   \"INDEX out of range FIRST..LAST\".  */\n-extern tree build_call_raise_range (int msg, Node_Id gnat_node,\n-\t\t\t\t    tree index, tree first, tree last);\n-\n /* Similar to build_call_raise, with extra information about the column\n    where the check failed.  */\n extern tree build_call_raise_column (int msg, Node_Id gnat_node);\n \n+/* Similar to build_call_raise_column, for an index or range check exception ,\n+   with extra information of the form \"INDEX out of range FIRST..LAST\".  */\n+extern tree build_call_raise_range (int msg, Node_Id gnat_node,\n+\t\t\t\t    tree index, tree first, tree last);\n+\n /* Return a CONSTRUCTOR of TYPE whose elements are V.  This is not the\n    same as build_constructor in the language-independent tree.c.  */\n extern tree gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v);"}, {"sha": "9d8d2621c45d521fa1b62297b9b6cf35ae35cd60", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "patch": "@@ -658,7 +658,7 @@ gnat_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   info->ndimensions = i;\n   convention_fortran_p = TYPE_CONVENTION_FORTRAN_P (type);\n \n-  /* TODO: For row major ordering, we probably want to emit nothing and\n+  /* TODO: for row major ordering, we probably want to emit nothing and\n      instead specify it as the default in Dw_TAG_compile_unit.  */\n   info->ordering = (convention_fortran_p\n \t\t    ? array_descr_ordering_column_major"}, {"sha": "fea8e15c5d3ff32bb8606c776308f488771b2b49", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 81, "deletions": 117, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "patch": "@@ -75,13 +75,6 @@\n    instead.  */\n #define ALLOCA_THRESHOLD 1000\n \n-/* In configurations where blocks have no end_locus attached, just\n-   sink assignments into a dummy global.  */\n-#ifndef BLOCK_SOURCE_END_LOCATION\n-static location_t block_end_locus_sink;\n-#define BLOCK_SOURCE_END_LOCATION(BLOCK) block_end_locus_sink\n-#endif\n-\n /* Pointers to front-end tables accessed through macros.  */\n struct Node *Nodes_Ptr;\n struct Flags *Flags_Ptr;\n@@ -104,10 +97,6 @@ Node_Id error_gnat_node;\n    types with representation information.  */\n bool type_annotate_only;\n \n-/* Current filename without path.  */\n-const char *ref_filename;\n-\n-\n /* List of N_Validate_Unchecked_Conversion nodes in the unit.  */\n static vec<Node_Id> gnat_validate_uc_list;\n \n@@ -255,11 +244,9 @@ static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static void validate_unchecked_conversion (Node_Id);\n static tree maybe_implicit_deref (tree);\n-static void set_expr_location_from_node (tree, Node_Id);\n-static void set_expr_location_from_node1 (tree, Node_Id, bool);\n-static bool Sloc_to_locus1 (Source_Ptr, location_t *, bool);\n-static bool set_end_locus_from_node (tree, Node_Id);\n+static void set_expr_location_from_node (tree, Node_Id, bool = false);\n static void set_gnu_expr_location_from_node (tree, Node_Id);\n+static bool set_end_locus_from_node (tree, Node_Id);\n static int lvalue_required_p (Node_Id, tree, bool, bool, bool);\n static tree build_raise_check (int, enum exception_info_kind);\n static tree create_init_temporary (const char *, tree, tree *, Node_Id);\n@@ -5014,7 +5001,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n            implicit transient block does not incorrectly inherit the slocs\n            of a decision, which would otherwise confuse control flow based\n            coverage analysis tools.  */\n-\tset_expr_location_from_node1 (gnu_result, gnat_node, true);\n+\tset_expr_location_from_node (gnu_result, gnat_node, true);\n     }\n   else\n     gnu_result = gnu_inner_block;\n@@ -7772,7 +7759,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n     add_stmt_with_node (gnu_stmt, gnat_entity);\n \n   /* If this is a variable and an initializer is attached to it, it must be\n-     valid for the context.  Similar to init_const in create_var_decl_1.  */\n+     valid for the context.  Similar to init_const in create_var_decl.  */\n   if (TREE_CODE (gnu_decl) == VAR_DECL\n       && (gnu_init = DECL_INITIAL (gnu_decl)) != NULL_TREE\n       && (!gnat_types_compatible_p (type, TREE_TYPE (gnu_init))\n@@ -7840,7 +7827,7 @@ static void\n add_cleanup (tree gnu_cleanup, Node_Id gnat_node)\n {\n   if (Present (gnat_node))\n-    set_expr_location_from_node1 (gnu_cleanup, gnat_node, true);\n+    set_expr_location_from_node (gnu_cleanup, gnat_node, true);\n   append_to_statement_list (gnu_cleanup, &current_stmt_group->cleanups);\n }\n \n@@ -9507,12 +9494,11 @@ maybe_implicit_deref (tree exp)\n }\n \f\n /* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n-   location and false if it doesn't.  In the former case, set the Gigi global\n-   variable REF_FILENAME to the simple debug file name as given by sinput.\n-   If clear_column is true, set column information to 0.  */\n+   location and false if it doesn't.  If CLEAR_COLUMN is true, set the column\n+   information to 0.  */\n \n-static bool\n-Sloc_to_locus1 (Source_Ptr Sloc, location_t *locus, bool clear_column)\n+bool\n+Sloc_to_locus (Source_Ptr Sloc, location_t *locus, bool clear_column)\n {\n   if (Sloc == No_Location)\n     return false;\n@@ -9522,59 +9508,37 @@ Sloc_to_locus1 (Source_Ptr Sloc, location_t *locus, bool clear_column)\n       *locus = BUILTINS_LOCATION;\n       return false;\n     }\n-  else\n-    {\n-      Source_File_Index file = Get_Source_File_Index (Sloc);\n-      Logical_Line_Number line = Get_Logical_Line_Number (Sloc);\n-      Column_Number column = (clear_column ? 0 : Get_Column_Number (Sloc));\n-      line_map_ordinary *map = LINEMAPS_ORDINARY_MAP_AT (line_table, file - 1);\n \n-      /* We can have zero if pragma Source_Reference is in effect.  */\n-      if (line < 1)\n-\tline = 1;\n+  Source_File_Index file = Get_Source_File_Index (Sloc);\n+  Logical_Line_Number line = Get_Logical_Line_Number (Sloc);\n+  Column_Number column = (clear_column ? 0 : Get_Column_Number (Sloc));\n+  line_map_ordinary *map = LINEMAPS_ORDINARY_MAP_AT (line_table, file - 1);\n \n-      /* Translate the location.  */\n-      *locus = linemap_position_for_line_and_column (map, line, column);\n-    }\n+  /* We can have zero if pragma Source_Reference is in effect.  */\n+  if (line < 1)\n+    line = 1;\n \n-  ref_filename\n-    = IDENTIFIER_POINTER\n-      (get_identifier\n-       (Get_Name_String (Debug_Source_Name (Get_Source_File_Index (Sloc)))));;\n+  /* Translate the location.  */\n+  *locus = linemap_position_for_line_and_column (map, line, column);\n \n   return true;\n }\n \n-/* Similar to the above, not clearing the column information.  */\n-\n-bool\n-Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n-{\n-  return Sloc_to_locus1 (Sloc, locus, false);\n-}\n-\n /* Similar to set_expr_location, but start with the Sloc of GNAT_NODE and\n-   don't do anything if it doesn't correspond to a source location.  */\n+   don't do anything if it doesn't correspond to a source location.  And,\n+   if CLEAR_COLUMN is true, set the column information to 0.  */\n \n static void\n-set_expr_location_from_node1 (tree node, Node_Id gnat_node, bool clear_column)\n+set_expr_location_from_node (tree node, Node_Id gnat_node, bool clear_column)\n {\n   location_t locus;\n \n-  if (!Sloc_to_locus1 (Sloc (gnat_node), &locus, clear_column))\n+  if (!Sloc_to_locus (Sloc (gnat_node), &locus, clear_column))\n     return;\n \n   SET_EXPR_LOCATION (node, locus);\n }\n \n-/* Similar to the above, not clearing the column information.  */\n-\n-static void\n-set_expr_location_from_node (tree node, Node_Id gnat_node)\n-{\n-  set_expr_location_from_node1 (node, gnat_node, false);\n-}\n-\n /* More elaborate version of set_expr_location_from_node to be used in more\n    general contexts, for example the result of the translation of a generic\n    GNAT node.  */\n@@ -9609,6 +9573,65 @@ set_gnu_expr_location_from_node (tree node, Node_Id gnat_node)\n       break;\n     }\n }\n+\n+/* Set the end_locus information for GNU_NODE, if any, from an explicit end\n+   location associated with GNAT_NODE or GNAT_NODE itself, whichever makes\n+   most sense.  Return true if a sensible assignment was performed.  */\n+\n+static bool\n+set_end_locus_from_node (tree gnu_node, Node_Id gnat_node)\n+{\n+  Node_Id gnat_end_label;\n+  location_t end_locus;\n+\n+  /* Pick the GNAT node of which we'll take the sloc to assign to the GCC node\n+     end_locus when there is one.  We consider only GNAT nodes with a possible\n+     End_Label attached.  If the End_Label actually was unassigned, fallback\n+     on the original node.  We'd better assign an explicit sloc associated with\n+     the outer construct in any case.  */\n+\n+  switch (Nkind (gnat_node))\n+    {\n+    case N_Package_Body:\n+    case N_Subprogram_Body:\n+    case N_Block_Statement:\n+      gnat_end_label = End_Label (Handled_Statement_Sequence (gnat_node));\n+      break;\n+\n+    case N_Package_Declaration:\n+      gnat_end_label = End_Label (Specification (gnat_node));\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+\n+  if (Present (gnat_end_label))\n+    gnat_node = gnat_end_label;\n+\n+  /* Some expanded subprograms have neither an End_Label nor a Sloc\n+     attached.  Notify that to callers.  For a block statement with no\n+     End_Label, clear column information, so that the tree for a\n+     transient block does not receive the sloc of a source condition.  */\n+  if (!Sloc_to_locus (Sloc (gnat_node), &end_locus,\n+                      No (gnat_end_label)\n+                      && (Nkind (gnat_node) == N_Block_Statement)))\n+    return false;\n+\n+  switch (TREE_CODE (gnu_node))\n+    {\n+    case BIND_EXPR:\n+      BLOCK_SOURCE_END_LOCATION (BIND_EXPR_BLOCK (gnu_node)) = end_locus;\n+      return true;\n+\n+    case FUNCTION_DECL:\n+      DECL_STRUCT_FUNCTION (gnu_node)->function_end_locus = end_locus;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n \f\n /* Return a colon-separated list of encodings contained in encoded Ada\n    name.  */\n@@ -9679,65 +9702,6 @@ post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent, int num)\n   post_error_ne (msg, node, ent);\n }\n \n-/* Set the end_locus information for GNU_NODE, if any, from an explicit end\n-   location associated with GNAT_NODE or GNAT_NODE itself, whichever makes\n-   most sense.  Return true if a sensible assignment was performed.  */\n-\n-static bool\n-set_end_locus_from_node (tree gnu_node, Node_Id gnat_node)\n-{\n-  Node_Id gnat_end_label = Empty;\n-  location_t end_locus;\n-\n-  /* Pick the GNAT node of which we'll take the sloc to assign to the GCC node\n-     end_locus when there is one.  We consider only GNAT nodes with a possible\n-     End_Label attached.  If the End_Label actually was unassigned, fallback\n-     on the original node.  We'd better assign an explicit sloc associated with\n-     the outer construct in any case.  */\n-\n-  switch (Nkind (gnat_node))\n-    {\n-    case N_Package_Body:\n-    case N_Subprogram_Body:\n-    case N_Block_Statement:\n-      gnat_end_label = End_Label (Handled_Statement_Sequence (gnat_node));\n-      break;\n-\n-    case N_Package_Declaration:\n-      gnat_end_label = End_Label (Specification (gnat_node));\n-      break;\n-\n-    default:\n-      return false;\n-    }\n-\n-  gnat_node = Present (gnat_end_label) ? gnat_end_label : gnat_node;\n-\n-  /* Some expanded subprograms have neither an End_Label nor a Sloc\n-     attached.  Notify that to callers.  For a block statement with no\n-     End_Label, clear column information, so that the tree for a\n-     transient block does not receive the sloc of a source condition.  */\n-\n-  if (!Sloc_to_locus1 (Sloc (gnat_node), &end_locus,\n-                       No (gnat_end_label) &&\n-                       (Nkind (gnat_node) == N_Block_Statement)))\n-    return false;\n-\n-  switch (TREE_CODE (gnu_node))\n-    {\n-    case BIND_EXPR:\n-      BLOCK_SOURCE_END_LOCATION (BIND_EXPR_BLOCK (gnu_node)) = end_locus;\n-      return true;\n-\n-    case FUNCTION_DECL:\n-      DECL_STRUCT_FUNCTION (gnu_node)->function_end_locus = end_locus;\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\f\n /* Similar to post_error_ne, but T is a GCC tree representing the number to\n    write.  If T represents a constant, the text inside curly brackets in\n    MSG will be output (presumably including a '^').  Otherwise it will not"}, {"sha": "f54f2f02694510806636c40bd0362be6304d923d", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "patch": "@@ -5278,7 +5278,7 @@ builtin_decl_for (tree name)\n    heavily inspired from the \"C\" family implementation, with chunks copied\n    verbatim from there.\n \n-   Two obvious TODO candidates are\n+   Two obvious improvement candidates are:\n    o Use a more efficient name/decl mapping scheme\n    o Devise a middle-end infrastructure to avoid having to copy\n      pieces between front-ends.  */\n@@ -5627,7 +5627,7 @@ handle_pure_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     DECL_PURE_P (*node) = 1;\n-  /* ??? TODO: Support types.  */\n+  /* TODO: support types.  */\n   else\n     {\n       warning (OPT_Wattributes, \"%qs attribute ignored\","}, {"sha": "70737a9990be65fa435ffebfc297cef601401bb7", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 68, "deletions": 111, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4643153b87f84c0ee07ffd7f7fd53589c94ddc/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=ba4643153b87f84c0ee07ffd7f7fd53589c94ddc", "patch": "@@ -1754,34 +1754,66 @@ build_call_n_expr (tree fndecl, int n, ...)\n   return fn;\n }\n \f\n-/* Call a function that raises an exception and pass the line number and file\n-   name, if requested.  MSG says which exception function to call.\n+/* Expand the SLOC of GNAT_NODE, if present, into tree location information\n+   pointed to by FILENAME, LINE and COL.  Fall back to the current location\n+   if GNAT_NODE is absent or has no SLOC.  */\n \n-   GNAT_NODE is the gnat node conveying the source location for which the\n-   error should be signaled, or Empty in which case the error is signaled on\n-   the current ref_file_name/input_line.\n+static void\n+expand_sloc (Node_Id gnat_node, tree *filename, tree *line, tree *col)\n+{\n+  const char *str;\n+  int line_number, column_number;\n+\n+  if (Debug_Flag_NN || Exception_Locations_Suppressed)\n+    {\n+      str = \"\";\n+      line_number = 0;\n+      column_number = 0;\n+    }\n+  else if (Present (gnat_node) && Sloc (gnat_node) != No_Location)\n+    {\n+      str = Get_Name_String\n+\t    (Debug_Source_Name (Get_Source_File_Index (Sloc (gnat_node))));\n+      line_number = Get_Logical_Line_Number (Sloc (gnat_node));\n+      column_number = Get_Column_Number (Sloc (gnat_node));\n+    }\n+  else\n+    {\n+      str = lbasename (LOCATION_FILE (input_location));\n+      line_number = LOCATION_LINE (input_location);\n+      column_number = LOCATION_COLUMN (input_location);\n+    }\n \n-   KIND says which kind of exception this is for\n-   (N_Raise_{Constraint,Storage,Program}_Error).  */\n+  const int len = strlen (str);\n+  *filename = build_string (len, str);\n+  TREE_TYPE (*filename) = build_array_type (unsigned_char_type_node,\n+\t\t\t\t\t    build_index_type (size_int (len)));\n+  *line = build_int_cst (NULL_TREE, line_number);\n+  if (col)\n+    *col = build_int_cst (NULL_TREE, column_number);\n+}\n+\n+/* Build a call to a function that raises an exception and passes file name\n+   and line number, if requested.  MSG says which exception function to call.\n+   GNAT_NODE is the node conveying the source location for which the error\n+   should be signaled, or Empty in which case the error is signaled for the\n+   current location.  KIND says which kind of exception node this is for,\n+   among N_Raise_{Constraint,Storage,Program}_Error.  */\n \n tree\n build_call_raise (int msg, Node_Id gnat_node, char kind)\n {\n   tree fndecl = gnat_raise_decls[msg];\n   tree label = get_exception_label (kind);\n-  tree filename;\n-  int line_number;\n-  const char *str;\n-  int len;\n+  tree filename, line;\n \n   /* If this is to be done as a goto, handle that case.  */\n   if (label)\n     {\n       Entity_Id local_raise = Get_Local_Raise_Call_Entity ();\n       tree gnu_result = build1 (GOTO_EXPR, void_type_node, label);\n \n-      /* If Local_Raise is present, generate\n-\t Local_Raise (exception'Identity);  */\n+      /* If Local_Raise is present, build Local_Raise (Exception'Identity).  */\n       if (Present (local_raise))\n \t{\n \t  tree gnu_local_raise\n@@ -1792,138 +1824,63 @@ build_call_raise (int msg, Node_Id gnat_node, char kind)\n \t    = build_call_n_expr (gnu_local_raise, 1,\n \t\t\t\t build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t\t gnu_exception_entity));\n-\n-\t  gnu_result = build2 (COMPOUND_EXPR, void_type_node,\n-\t\t\t       gnu_call, gnu_result);}\n+\t  gnu_result\n+\t    = build2 (COMPOUND_EXPR, void_type_node, gnu_call, gnu_result);\n+\t}\n \n       return gnu_result;\n     }\n \n-  str\n-    = (Debug_Flag_NN || Exception_Locations_Suppressed)\n-      ? \"\"\n-      : (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n-        ? IDENTIFIER_POINTER\n-          (get_identifier (Get_Name_String\n-\t\t\t   (Debug_Source_Name\n-\t\t\t    (Get_Source_File_Index (Sloc (gnat_node))))))\n-        : ref_filename;\n-\n-  len = strlen (str);\n-  filename = build_string (len, str);\n-  line_number\n-    = (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n-      ? Get_Logical_Line_Number (Sloc(gnat_node))\n-      : LOCATION_LINE (input_location);\n-\n-  TREE_TYPE (filename) = build_array_type (unsigned_char_type_node,\n-\t\t\t\t\t   build_index_type (size_int (len)));\n+  expand_sloc (gnat_node, &filename, &line, NULL);\n \n   return\n     build_call_n_expr (fndecl, 2,\n \t\t       build1 (ADDR_EXPR,\n \t\t\t       build_pointer_type (unsigned_char_type_node),\n \t\t\t       filename),\n-\t\t       build_int_cst (NULL_TREE, line_number));\n+\t\t       line);\n }\n \n-/* Similar to build_call_raise, for an index or range check exception as\n-   determined by MSG, with extra information generated of the form\n-   \"INDEX out of range FIRST..LAST\".  */\n+/* Similar to build_call_raise, with extra information about the column\n+   where the check failed.  */\n \n tree\n-build_call_raise_range (int msg, Node_Id gnat_node,\n-\t\t\ttree index, tree first, tree last)\n+build_call_raise_column (int msg, Node_Id gnat_node)\n {\n   tree fndecl = gnat_raise_decls_ext[msg];\n-  tree filename;\n-  int line_number, column_number;\n-  const char *str;\n-  int len;\n-\n-  str\n-    = (Debug_Flag_NN || Exception_Locations_Suppressed)\n-      ? \"\"\n-      : (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n-        ? IDENTIFIER_POINTER\n-          (get_identifier (Get_Name_String\n-\t\t\t   (Debug_Source_Name\n-\t\t\t    (Get_Source_File_Index (Sloc (gnat_node))))))\n-        : ref_filename;\n-\n-  len = strlen (str);\n-  filename = build_string (len, str);\n-  if (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n-    {\n-      line_number = Get_Logical_Line_Number (Sloc (gnat_node));\n-      column_number = Get_Column_Number (Sloc (gnat_node));\n-    }\n-  else\n-    {\n-      line_number = LOCATION_LINE (input_location);\n-      column_number = 0;\n-    }\n+  tree filename, line, col;\n \n-  TREE_TYPE (filename) = build_array_type (unsigned_char_type_node,\n-\t\t\t\t\t   build_index_type (size_int (len)));\n+  expand_sloc (gnat_node, &filename, &line, &col);\n \n   return\n-    build_call_n_expr (fndecl, 6,\n+    build_call_n_expr (fndecl, 3,\n \t\t       build1 (ADDR_EXPR,\n \t\t\t       build_pointer_type (unsigned_char_type_node),\n \t\t\t       filename),\n-\t\t       build_int_cst (NULL_TREE, line_number),\n-\t\t       build_int_cst (NULL_TREE, column_number),\n-\t\t       convert (integer_type_node, index),\n-\t\t       convert (integer_type_node, first),\n-\t\t       convert (integer_type_node, last));\n+\t\t       line, col);\n }\n \n-/* Similar to build_call_raise, with extra information about the column\n-   where the check failed.  */\n+/* Similar to build_call_raise_column, for an index or range check exception ,\n+   with extra information of the form \"INDEX out of range FIRST..LAST\".  */\n \n tree\n-build_call_raise_column (int msg, Node_Id gnat_node)\n+build_call_raise_range (int msg, Node_Id gnat_node,\n+\t\t\ttree index, tree first, tree last)\n {\n   tree fndecl = gnat_raise_decls_ext[msg];\n-  tree filename;\n-  int line_number, column_number;\n-  const char *str;\n-  int len;\n-\n-  str\n-    = (Debug_Flag_NN || Exception_Locations_Suppressed)\n-      ? \"\"\n-      : (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n-        ? IDENTIFIER_POINTER\n-          (get_identifier (Get_Name_String\n-\t\t\t   (Debug_Source_Name\n-\t\t\t    (Get_Source_File_Index (Sloc (gnat_node))))))\n-        : ref_filename;\n-\n-  len = strlen (str);\n-  filename = build_string (len, str);\n-  if (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n-    {\n-      line_number = Get_Logical_Line_Number (Sloc (gnat_node));\n-      column_number = Get_Column_Number (Sloc (gnat_node));\n-    }\n-  else\n-    {\n-      line_number = LOCATION_LINE (input_location);\n-      column_number = 0;\n-    }\n+  tree filename, line, col;\n \n-  TREE_TYPE (filename) = build_array_type (unsigned_char_type_node,\n-\t\t\t\t\t   build_index_type (size_int (len)));\n+  expand_sloc (gnat_node, &filename, &line, &col);\n \n   return\n-    build_call_n_expr (fndecl, 3,\n+    build_call_n_expr (fndecl, 6,\n \t\t       build1 (ADDR_EXPR,\n \t\t\t       build_pointer_type (unsigned_char_type_node),\n \t\t\t       filename),\n-\t\t       build_int_cst (NULL_TREE, line_number),\n-\t\t       build_int_cst (NULL_TREE, column_number));\n+\t\t       line, col,\n+\t\t       convert (integer_type_node, index),\n+\t\t       convert (integer_type_node, first),\n+\t\t       convert (integer_type_node, last));\n }\n \f\n /* qsort comparer for the bit positions of two constructor elements"}]}