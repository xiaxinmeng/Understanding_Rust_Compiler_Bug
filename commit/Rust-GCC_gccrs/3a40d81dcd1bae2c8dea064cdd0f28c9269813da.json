{"sha": "3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E0MGQ4MWRjZDFiYWUyYzhkZWEwNjRjZGQwZjI4YzkyNjk4MTNkYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-10T00:27:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-10T00:27:26Z"}, "message": "omp-low.h (replace_oacc_fn_attrib, [...]): Declare.\n\n\t* omp-low.h (replace_oacc_fn_attrib, build_oacc_routine_dims): Declare.\n\t* omp-low.c (build_oacc_routine_dims): New.\n\n\tc/\n\t* c-parser.c (c_parser_declaration_or_fndef): Add OpenACC\n\troutine arg.\n\t(c_parser_declaration_or_fndef): Call c_finish_oacc_routine.\n\t(c_parser_pragma): Parse 'acc routine'.\n\t(OACC_ROUTINE_CLAUSE_MARK): Define.\n\t(c_parser_oacc_routine, (c_finish_oacc_routine): New.\n\n\tc-family/\n\t* c-pragma.c (oacc_pragmas): Add \"routine\".\n\t* c-pragma.h (pragma_kind): Add PRAGMA_OACC_ROUTINE.\n\n\tcp/\n\t* parser.h (struct cp_parser): Add oacc_routine field.\n\t* parser.c (cp_ensure_no_oacc_routine): New.\n\t(cp_parser_new): Initialize oacc_routine field.\n\t(cp_parser_linkage_specification): Call cp_ensure_no_oacc_routine.\n\t(cp_parser_namespace_definition,\n\tcp_parser_class_specifier_1): Likewise.\n\t(cp_parser_init_declarator): Call cp_finalize_oacc_routine.\n\t(cp_parser_function_definition,\n\tcp_parser_save_member_function_body): Likewise.\n\t(OACC_ROUTINE_CLAUSE_MASK): New.\n\t(cp_parser_finish_oacc_routine, cp_parser_oacc_routine,\n\tcp_finalize_oacc_routine): New.\n\t(cp_parser_pragma): Adjust omp_declare_simd checking.  Call\n\tcp_ensure_no_oacc_routine.\n\t(cp_parser_pragma): Add OpenACC routine handling.\n\nFrom-SVN: r230072", "tree": {"sha": "818660aba49a5506f8de09d3955230367824e3ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/818660aba49a5506f8de09d3955230367824e3ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/comments", "author": null, "committer": null, "parents": [{"sha": "7441dcf4be09d772b92d42840ace9d604c8f3226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7441dcf4be09d772b92d42840ace9d604c8f3226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7441dcf4be09d772b92d42840ace9d604c8f3226"}], "stats": {"total": 412, "additions": 408, "deletions": 4}, "files": [{"sha": "bf785384ec862b5466ba1b01f1b8db8633318bea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -1,3 +1,8 @@\n+2015-11-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* omp-low.h (replace_oacc_fn_attrib, build_oacc_routine_dims): Declare.\n+\t* omp-low.c (build_oacc_routine_dims): New.\n+\n 2015-11-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/constraints.md (wF constraint): New constraints"}, {"sha": "4188535df7836497510eab30bc43f61184fb69a6", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -1,3 +1,12 @@\n+2015-11-09  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* c-pragma.c (oacc_pragmas): Add \"routine\".\n+\t* c-pragma.h (pragma_kind): Add PRAGMA_OACC_ROUTINE.\n+\n 2015-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-common.c (c_common_attributes): Add scalar_storage_order."}, {"sha": "50324b82498ff0d1edac618ed4e730aa80ce56f7", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -1257,6 +1257,7 @@ static const struct omp_pragma_def oacc_pragmas[] = {\n   { \"kernels\", PRAGMA_OACC_KERNELS },\n   { \"loop\", PRAGMA_OACC_LOOP },\n   { \"parallel\", PRAGMA_OACC_PARALLEL },\n+  { \"routine\", PRAGMA_OACC_ROUTINE },\n   { \"update\", PRAGMA_OACC_UPDATE },\n   { \"wait\", PRAGMA_OACC_WAIT }\n };"}, {"sha": "afeceff1edbcfc4616ec6bd7bab5c66bcb9b8aad", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -35,6 +35,7 @@ enum pragma_kind {\n   PRAGMA_OACC_KERNELS,\n   PRAGMA_OACC_LOOP,\n   PRAGMA_OACC_PARALLEL,\n+  PRAGMA_OACC_ROUTINE,\n   PRAGMA_OACC_UPDATE,\n   PRAGMA_OACC_WAIT,\n "}, {"sha": "0124dcc578d6bf4b579296f81d6fb325f90356ae", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -1,3 +1,17 @@\n+2015-11-09  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tc/\n+\t* c-parser.c (c_parser_declaration_or_fndef): Add OpenACC\n+\troutine arg.\n+\t(c_parser_declaration_or_fndef): Call c_finish_oacc_routine.\n+\t(c_parser_pragma): Parse 'acc routine'.\n+\t(OACC_ROUTINE_CLAUSE_MARK): Define.\n+\t(c_parser_oacc_routine, (c_finish_oacc_routine): New.\n+\n 2015-11-09  Andreas Arnez  <arnez@linux.vnet.ibm.com>\n \n \tPR debug/67192"}, {"sha": "dd4434dc7aea56a11eb30c90a3aefe90e96c6e1f", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 138, "deletions": 3, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -1162,7 +1162,8 @@ enum c_parser_prec {\n static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n-\t\t\t\t\t   bool, bool, tree *, vec<c_token>);\n+\t\t\t\t\t   bool, bool, tree *, vec<c_token>,\n+\t\t\t\t\t   tree = NULL_TREE);\n static void c_parser_static_assert_declaration_no_semi (c_parser *);\n static void c_parser_static_assert_declaration (c_parser *);\n static void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n@@ -1251,6 +1252,7 @@ static bool c_parser_omp_target (c_parser *, enum pragma_context);\n static void c_parser_omp_end_declare_target (c_parser *);\n static void c_parser_omp_declare (c_parser *, enum pragma_context);\n static bool c_parser_omp_ordered (c_parser *, enum pragma_context);\n+static void c_parser_oacc_routine (c_parser *parser, enum pragma_context);\n \n /* These Objective-C parser functions are only ever called when\n    compiling Objective-C.  */\n@@ -1436,6 +1438,7 @@ c_parser_external_declaration (c_parser *parser)\n }\n \n static void c_finish_omp_declare_simd (c_parser *, tree, tree, vec<c_token>);\n+static void c_finish_oacc_routine (c_parser *, tree, tree, bool, bool, bool);\n \n /* Parse a declaration or function definition (C90 6.5, 6.7.1, C99\n    6.7, 6.9.1).  If FNDEF_OK is true, a function definition is\n@@ -1513,7 +1516,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t       bool static_assert_ok, bool empty_ok,\n \t\t\t       bool nested, bool start_attr_ok,\n \t\t\t       tree *objc_foreach_object_declaration,\n-\t\t\t       vec<c_token> omp_declare_simd_clauses)\n+\t\t\t       vec<c_token> omp_declare_simd_clauses,\n+\t\t\t       tree oacc_routine_clauses)\n {\n   struct c_declspecs *specs;\n   tree prefix_attrs;\n@@ -1583,6 +1587,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  pedwarn (here, 0, \"empty declaration\");\n \t}\n       c_parser_consume_token (parser);\n+      if (oacc_routine_clauses)\n+\tc_finish_oacc_routine (parser, NULL_TREE,\n+\t\t\t       oacc_routine_clauses, false, true, false);\n       return;\n     }\n \n@@ -1680,7 +1687,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n   prefix_attrs = specs->attrs;\n   all_prefix_attrs = prefix_attrs;\n   specs->attrs = NULL_TREE;\n-  while (true)\n+  for (bool first = true;; first = false)\n     {\n       struct c_declarator *declarator;\n       bool dummy = false;\n@@ -1699,6 +1706,10 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n \t    c_finish_omp_declare_simd (parser, NULL_TREE, NULL_TREE,\n \t\t\t\t       omp_declare_simd_clauses);\n+\t  if (oacc_routine_clauses)\n+\t    c_finish_oacc_routine (parser, NULL_TREE,\n+\t\t\t\t   oacc_routine_clauses,\n+\t\t\t\t   false, first, false);\n \t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t  return;\n \t}\n@@ -1813,6 +1824,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  init = c_parser_initializer (parser);\n \t\t  finish_init ();\n \t\t}\n+\t      if (oacc_routine_clauses)\n+\t\tc_finish_oacc_routine (parser, d, oacc_routine_clauses,\n+\t\t\t\t       false, first, false);\n \t      if (d != error_mark_node)\n \t\t{\n \t\t  maybe_warn_string_init (init_loc, TREE_TYPE (d), init);\n@@ -1856,6 +1870,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  if (parms)\n \t\t    temp_pop_parm_decls ();\n \t\t}\n+\t      if (oacc_routine_clauses)\n+\t\tc_finish_oacc_routine (parser, d, oacc_routine_clauses,\n+\t\t\t\t       false, first, false);\n \t      if (d)\n \t\tfinish_decl (d, UNKNOWN_LOCATION, NULL_TREE,\n \t\t\t     NULL_TREE, asm_name);\n@@ -1966,6 +1983,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n \tc_finish_omp_declare_simd (parser, current_function_decl, NULL_TREE,\n \t\t\t\t   omp_declare_simd_clauses);\n+      if (oacc_routine_clauses)\n+\tc_finish_oacc_routine (parser, current_function_decl,\n+\t\t\t       oacc_routine_clauses, false, first, true);\n       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus\n \t= c_parser_peek_token (parser)->location;\n       fnbody = c_parser_compound_statement (parser);\n@@ -9706,6 +9726,10 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       c_parser_oacc_enter_exit_data (parser, false);\n       return false;\n \n+    case PRAGMA_OACC_ROUTINE:\n+      c_parser_oacc_routine (parser, context);\n+      return false;\n+\n     case PRAGMA_OACC_UPDATE:\n       if (context != pragma_compound)\n \t{\n@@ -13399,6 +13423,117 @@ c_parser_oacc_kernels_parallel (location_t loc, c_parser *parser,\n   return c_finish_omp_construct (loc, code, block, clauses);\n }\n \n+/* OpenACC 2.0:\n+   # pragma acc routine oacc-routine-clause[optseq] new-line\n+     function-definition\n+\n+   # pragma acc routine ( name ) oacc-routine-clause[optseq] new-line\n+*/\n+\n+#define OACC_ROUTINE_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_GANG)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WORKER)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_VECTOR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_SEQ) )\n+\n+/* Parse an OpenACC routine directive.  For named directives, we apply\n+   immediately to the named function.  For unnamed ones we then parse\n+   a declaration or definition, which must be for a function.  */\n+\n+static void\n+c_parser_oacc_routine (c_parser *parser, enum pragma_context context)\n+{\n+  tree decl = NULL_TREE;\n+  /* Create a dummy claue, to record location.  */\n+  tree c_head = build_omp_clause (c_parser_peek_token (parser)->location,\n+\t\t\t\t  OMP_CLAUSE_SEQ);\n+  \n+  if (context != pragma_external)\n+    c_parser_error (parser, \"%<#pragma acc routine%> not at file scope\");\n+\n+  c_parser_consume_pragma (parser);\n+\n+  /* Scan for optional '( name )'.  */\n+  if (c_parser_peek_token (parser)->type == CPP_OPEN_PAREN)\n+    {\n+      c_parser_consume_token (parser);\n+\n+      c_token *token = c_parser_peek_token (parser);\n+\n+      if (token->type == CPP_NAME && (token->id_kind == C_ID_ID\n+\t\t\t\t      || token->id_kind == C_ID_TYPENAME))\n+\t{\n+\t  decl = lookup_name (token->value);\n+\t  if (!decl)\n+\t    {\n+\t      error_at (token->location, \"%qE has not been declared\",\n+\t\t\ttoken->value);\n+\t      decl = error_mark_node;\n+\t    }\n+\t}\n+      else\n+\tc_parser_error (parser, \"expected function name\");\n+\n+      if (token->type != CPP_CLOSE_PAREN)\n+\tc_parser_consume_token (parser);\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, 0);\n+    }\n+\n+  /* Build a chain of clauses.  */\n+  parser->in_pragma = true;\n+  tree clauses = c_parser_oacc_all_clauses\n+    (parser, OACC_ROUTINE_CLAUSE_MASK, \"#pragma acc routine\");\n+\n+  /* Force clauses to be non-null, by attaching context to it.  */\n+  clauses = tree_cons (c_head, clauses, NULL_TREE);\n+  \n+  if (decl)\n+    c_finish_oacc_routine (parser, decl, clauses, true, true, false);\n+  else if (c_parser_peek_token (parser)->type == CPP_PRAGMA)\n+    /* This will emit an error.  */\n+    c_finish_oacc_routine (parser, NULL_TREE, clauses, false, true, false);\n+  else\n+    c_parser_declaration_or_fndef (parser, true, false, false, false,\n+\t\t\t\t   true, NULL, vNULL, clauses);\n+}\n+\n+/* Finalize an OpenACC routine pragma, applying it to FNDECL.  CLAUSES\n+   are the parsed clauses.  IS_DEFN is true if we're applying it to\n+   the definition (so expect FNDEF to look somewhat defined.  */\n+\n+static void\n+c_finish_oacc_routine (c_parser *ARG_UNUSED (parser), tree fndecl,\n+\t\t       tree clauses, bool named, bool first, bool is_defn)\n+{\n+  location_t loc = OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses));\n+\n+  if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL || !first)\n+    {\n+      if (fndecl != error_mark_node)\n+\terror_at (loc, \"%<#pragma acc routine%> %s\",\n+\t\t  named ? \"does not refer to a function\"\n+\t\t  : \"not followed by single function\");\n+      return;\n+    }\n+\n+  if (get_oacc_fn_attrib (fndecl))\n+    error_at (loc, \"%<#pragma acc routine%> already applied to %D\", fndecl);\n+\n+  if (TREE_USED (fndecl) || (!is_defn && DECL_SAVED_TREE (fndecl)))\n+    error_at (loc, \"%<#pragma acc routine%> must be applied before %s\",\n+\t      TREE_USED (fndecl) ? \"use\" : \"definition\");\n+\n+  /* Process for function attrib  */\n+  tree dims = build_oacc_routine_dims (TREE_VALUE (clauses));\n+  replace_oacc_fn_attrib (fndecl, dims);\n+\n+  /* Also attach as a declare.  */\n+  DECL_ATTRIBUTES (fndecl)\n+    = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t clauses, DECL_ATTRIBUTES (fndecl));\n+}\n+\n /* OpenACC 2.0:\n    # pragma acc update oacc-update-clause[optseq] new-line\n */"}, {"sha": "91cbf067dba3a83f47e056629e73b6c9cfc180f0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -1,3 +1,25 @@\n+2015-11-09  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* parser.h (struct cp_parser): Add oacc_routine field.\n+\t* parser.c (cp_ensure_no_oacc_routine): New.\n+\t(cp_parser_new): Initialize oacc_routine field.\n+\t(cp_parser_linkage_specification): Call cp_ensure_no_oacc_routine.\n+\t(cp_parser_namespace_definition,\n+\tcp_parser_class_specifier_1): Likewise.\n+\t(cp_parser_init_declarator): Call cp_finalize_oacc_routine.\n+\t(cp_parser_function_definition,\n+\tcp_parser_save_member_function_body): Likewise.\n+\t(OACC_ROUTINE_CLAUSE_MASK): New.\n+\t(cp_parser_finish_oacc_routine, cp_parser_oacc_routine,\n+\tcp_finalize_oacc_routine): New.\n+\t(cp_parser_pragma): Adjust omp_declare_simd checking.  Call\n+\tcp_ensure_no_oacc_routine.\n+\t(cp_parser_pragma): Add OpenACC routine handling.\n+\t\n 2015-11-08  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/67942 "}, {"sha": "6fc2c6af389b7d046a7ef7c654b8c22c48034055", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 169, "deletions": 1, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -245,6 +245,8 @@ static bool cp_parser_omp_declare_reduction_exprs\n   (tree, cp_parser *);\n static tree cp_parser_cilk_simd_vectorlength \n   (cp_parser *, tree, bool);\n+static void cp_finalize_oacc_routine\n+  (cp_parser *, tree, bool);\n \n /* Manifest constants.  */\n #define CP_LEXER_BUFFER_SIZE ((256 * 1024) / sizeof (cp_token))\n@@ -1320,6 +1322,15 @@ cp_finalize_omp_declare_simd (cp_parser *parser, tree fndecl)\n \t}\n     }\n }\n+\n+/* Diagnose if #pragma omp routine isn't followed immediately\n+   by function declaration or definition.   */\n+\n+static inline void\n+cp_ensure_no_oacc_routine (cp_parser *parser)\n+{\n+  cp_finalize_oacc_routine (parser, NULL_TREE, false);\n+}\n \f\n /* Decl-specifiers.  */\n \n@@ -3620,6 +3631,9 @@ cp_parser_new (void)\n   parser->implicit_template_parms = 0;\n   parser->implicit_template_scope = 0;\n \n+  /* Active OpenACC routine clauses.  */\n+  parser->oacc_routine = NULL;\n+\n   /* Allow constrained-type-specifiers. */\n   parser->prevent_constrained_type_specifiers = 0;\n \n@@ -12541,6 +12555,7 @@ cp_parser_linkage_specification (cp_parser* parser)\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n       cp_ensure_no_omp_declare_simd (parser);\n+      cp_ensure_no_oacc_routine (parser);\n \n       /* Consume the `{' token.  */\n       cp_lexer_consume_token (parser->lexer);\n@@ -17058,6 +17073,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n   int nested_definition_count = 0;\n \n   cp_ensure_no_omp_declare_simd (parser);\n+  cp_ensure_no_oacc_routine (parser);\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_INLINE))\n     {\n       maybe_warn_cpp0x (CPP0X_INLINE_NAMESPACES);\n@@ -18081,6 +18097,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t range_for_decl_p? SD_INITIALIZED : is_initialized,\n \t\t\t attributes, prefix_attributes, &pushed_scope);\n       cp_finalize_omp_declare_simd (parser, decl);\n+      cp_finalize_oacc_routine (parser, decl, false);\n       /* Adjust location of decl if declarator->id_loc is more appropriate:\n \t set, and decl wasn't merged with another decl, in which case its\n \t location would be different from input_location, and more accurate.  */\n@@ -18194,6 +18211,7 @@ cp_parser_init_declarator (cp_parser* parser,\n       if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n \tcp_parser_save_default_args (parser, decl);\n       cp_finalize_omp_declare_simd (parser, decl);\n+      cp_finalize_oacc_routine (parser, decl, false);\n     }\n \n   /* Finish processing the declaration.  But, skip member\n@@ -20800,6 +20818,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n     }\n \n   cp_ensure_no_omp_declare_simd (parser);\n+  cp_ensure_no_oacc_routine (parser);\n \n   /* Issue an error message if type-definitions are forbidden here.  */\n   cp_parser_check_type_definition (parser);\n@@ -22113,6 +22132,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t    }\n \n \t  cp_finalize_omp_declare_simd (parser, decl);\n+\t  cp_finalize_oacc_routine (parser, decl, false);\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n \t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n@@ -24716,6 +24736,7 @@ cp_parser_function_definition_from_specifiers_and_declarator\n     {\n       cp_finalize_omp_declare_simd (parser, current_function_decl);\n       parser->omp_declare_simd = NULL;\n+      cp_finalize_oacc_routine (parser, current_function_decl, true);\n     }\n \n   if (!success_p)\n@@ -25398,6 +25419,7 @@ cp_parser_save_member_function_body (cp_parser* parser,\n   /* Create the FUNCTION_DECL.  */\n   fn = grokmethod (decl_specifiers, declarator, attributes);\n   cp_finalize_omp_declare_simd (parser, fn);\n+  cp_finalize_oacc_routine (parser, fn, true);\n   /* If something went badly wrong, bail out now.  */\n   if (fn == error_mark_node)\n     {\n@@ -35584,6 +35606,147 @@ cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n   return ret;\n }\n \n+\n+/* OpenACC 2.0:\n+   # pragma acc routine oacc-routine-clause[optseq] new-line\n+     function-definition\n+\n+   # pragma acc routine ( name ) oacc-routine-clause[optseq] new-line\n+*/\n+\n+#define OACC_ROUTINE_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_GANG)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WORKER)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_VECTOR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_SEQ))\n+\n+/* Finalize #pragma acc routine clauses after direct declarator has\n+   been parsed, and put that into \"omp declare target\" attribute.  */\n+\n+static void\n+cp_parser_finish_oacc_routine (cp_parser *ARG_UNUSED (parser), tree fndecl,\n+\t\t\t       tree clauses, bool named, bool is_defn)\n+{\n+  location_t loc  = OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses));\n+\n+  if (named && fndecl && is_overloaded_fn (fndecl)\n+      && (TREE_CODE (fndecl) != FUNCTION_DECL\n+\t  || DECL_FUNCTION_TEMPLATE_P  (fndecl)))\n+    {\n+      error_at (loc, \"%<#pragma acc routine%> names a set of overloads\");\n+      return;\n+    }\n+\n+  if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL)\n+    {\n+      error_at (loc, \"%<#pragma acc routine%> %s\",\n+\t\tnamed ? \"does not refer to a function\"\n+\t\t: \"not followed by single function\");\n+      return;\n+    }\n+\n+  /* Perhaps we should use the same rule as declarations in different\n+     namespaces?  */\n+  if (named && !DECL_NAMESPACE_SCOPE_P (fndecl))\n+    {\n+      error_at (loc, \"%<#pragma acc routine%> does not refer to a\"\n+\t\t\" namespace scope function\");\n+      return;\n+    }\n+\n+  if (get_oacc_fn_attrib (fndecl))\n+    error_at (loc, \"%<#pragma acc routine%> already applied to %D\", fndecl);\n+\n+  if (TREE_USED (fndecl) || (!is_defn && DECL_SAVED_TREE (fndecl)))\n+    error_at (OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses)),\n+\t      \"%<#pragma acc routine%> must be applied before %s\",\n+\t      TREE_USED (fndecl) ? \"use\" : \"definition\");\n+\n+  /* Process for function attrib  */\n+  tree dims = build_oacc_routine_dims (TREE_VALUE (clauses));\n+  replace_oacc_fn_attrib (fndecl, dims);\n+\n+  /* Also attach as a declare.  */\n+  DECL_ATTRIBUTES (fndecl)\n+    = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t clauses, DECL_ATTRIBUTES (fndecl));\n+}\n+\n+/* Parse the OpenACC routine pragma.  This has an optional '( name )'\n+   component, which must resolve to a declared namespace-scope\n+   function.  The clauses are either processed directly (for a named\n+   function), or defered until the immediatley following declaration\n+   is parsed.  */\n+\n+static void\n+cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n+\t\t\tenum pragma_context context)\n+{\n+  tree decl = NULL_TREE;\n+  /* Create a dummy claue, to record location.  */\n+  tree c_head = build_omp_clause (pragma_tok->location, OMP_CLAUSE_SEQ);\n+\n+  if (context != pragma_external)\n+    cp_parser_error (parser, \"%<#pragma acc routine%> not at file scope\");\n+  \n+  /* Look for optional '( name )'.  */\n+  if (cp_lexer_next_token_is (parser->lexer,CPP_OPEN_PAREN))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+      /* We parse the name as an id-expression.  If it resolves to\n+\t anything other than a non-overloaded function at namespace\n+\t scope, it's an error.  */\n+      tree id = cp_parser_id_expression (parser,\n+\t\t\t\t\t /*template_keyword_p=*/false,\n+\t\t\t\t\t /*check_dependency_p=*/false,\n+\t\t\t\t\t /*template_p=*/NULL,\n+\t\t\t\t\t /*declarator_p=*/false,\n+\t\t\t\t\t /*optional_p=*/false);\n+      decl = cp_parser_lookup_name_simple (parser, id, token->location);\n+      if (id != error_mark_node && decl == error_mark_node)\n+\tcp_parser_name_lookup_error (parser, id, decl, NLE_NULL,\n+\t\t\t\t     token->location);\n+\n+      if (decl == error_mark_node\n+\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\t{\n+\t  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Build a chain of clauses.  */\n+  parser->lexer->in_pragma = true;\n+  tree clauses = NULL_TREE;\n+  clauses = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma acc routine\",\n+\t\t\t\t\tcp_lexer_peek_token (parser->lexer));\n+\n+  /* Force clauses to be non-null, by attaching context to it.  */\n+  clauses = tree_cons (c_head, clauses, NULL_TREE);\n+\n+  if (decl)\n+    cp_parser_finish_oacc_routine (parser, decl, clauses, true, false);\n+  else\n+    parser->oacc_routine = clauses;\n+}\n+\n+/* Apply any saved OpenACC routine clauses to a just-parsed\n+   declaration.  */\n+\n+static void\n+cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)\n+{\n+  if (parser->oacc_routine)\n+    {\n+      cp_parser_finish_oacc_routine (parser, fndecl, parser->oacc_routine,\n+\t\t\t\t     false, is_defn);\n+      parser->oacc_routine = NULL_TREE;\n+    }\n+}\n+\n /* Main entry point to OpenMP statement pragmas.  */\n \n static void\n@@ -36063,8 +36226,9 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n   parser->lexer->in_pragma = true;\n \n   id = pragma_tok->pragma_kind;\n-  if (id != PRAGMA_OMP_DECLARE_REDUCTION)\n+  if (id != PRAGMA_OMP_DECLARE_REDUCTION && id != PRAGMA_OACC_ROUTINE)\n     cp_ensure_no_omp_declare_simd (parser);\n+  cp_ensure_no_oacc_routine (parser);\n   switch (id)\n     {\n     case PRAGMA_GCC_PCH_PREPROCESS:\n@@ -36174,6 +36338,10 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n       cp_parser_omp_declare (parser, pragma_tok, context);\n       return false;\n \n+    case PRAGMA_OACC_ROUTINE:\n+      cp_parser_oacc_routine (parser, pragma_tok, context);\n+      return false;\n+\n     case PRAGMA_OACC_ATOMIC:\n     case PRAGMA_OACC_CACHE:\n     case PRAGMA_OACC_DATA:"}, {"sha": "fdbff6664ef3268c23549e6d3e4c72e35df93d7d", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -371,6 +371,9 @@ struct GTY(()) cp_parser {\n      necessary.  */\n   cp_omp_declare_simd_data * GTY((skip)) cilk_simd_fn_info;\n \n+  /* OpenACC routine clauses for subsequent decl/defn.  */\n+  tree oacc_routine;\n+  \n   /* Nonzero if parsing a parameter list where 'auto' should trigger an implicit\n      template parameter.  */\n   bool auto_is_implicit_function_template_parm_p;"}, {"sha": "2a552da1e5b39421e0f35811244ab6cb3b315f42", "filename": "gcc/omp-low.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -12350,6 +12350,50 @@ set_oacc_fn_attrib (tree fn, tree clauses, vec<tree> *args)\n     }\n }\n \n+/*  Process the routine's dimension clauess to generate an attribute\n+    value.  Issue diagnostics as appropriate.  We default to SEQ\n+    (OpenACC 2.5 clarifies this). All dimensions have a size of zero\n+    (dynamic).  TREE_PURPOSE is set to indicate whether that dimension\n+    can have a loop partitioned on it.  non-zero indicates\n+    yes, zero indicates no.  By construction once a non-zero has been\n+    reached, further inner dimensions must also be non-zero.  We set\n+    TREE_VALUE to zero for the dimensions that may be partitioned and\n+    1 for the other ones -- if a loop is (erroneously) spawned at\n+    an outer level, we don't want to try and partition it.  */\n+\n+tree\n+build_oacc_routine_dims (tree clauses)\n+{\n+  /* Must match GOMP_DIM ordering.  */\n+  static const omp_clause_code ids[] = \n+    {OMP_CLAUSE_GANG, OMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR, OMP_CLAUSE_SEQ};\n+  int ix;\n+  int level = -1;\n+\n+  for (; clauses; clauses = OMP_CLAUSE_CHAIN (clauses))\n+    for (ix = GOMP_DIM_MAX + 1; ix--;)\n+      if (OMP_CLAUSE_CODE (clauses) == ids[ix])\n+\t{\n+\t  if (level >= 0)\n+\t    error_at (OMP_CLAUSE_LOCATION (clauses),\n+\t\t      \"multiple loop axes specified for routine\");\n+\t  level = ix;\n+\t  break;\n+\t}\n+\n+  /* Default to SEQ.  */\n+  if (level < 0)\n+    level = GOMP_DIM_MAX;\n+  \n+  tree dims = NULL_TREE;\n+\n+  for (ix = GOMP_DIM_MAX; ix--;)\n+    dims = tree_cons (build_int_cst (boolean_type_node, ix >= level),\n+\t\t      build_int_cst (integer_type_node, ix < level), dims);\n+\n+  return dims;\n+}\n+\n /* Retrieve the oacc function attrib and return it.  Non-oacc\n    functions will return NULL.  */\n "}, {"sha": "194b3d14d6be0cb5f50e1690161545817ee4e5cf", "filename": "gcc/omp-low.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fomp-low.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a40d81dcd1bae2c8dea064cdd0f28c9269813da/gcc%2Fomp-low.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.h?ref=3a40d81dcd1bae2c8dea064cdd0f28c9269813da", "patch": "@@ -30,6 +30,8 @@ extern tree omp_reduction_init (tree, tree);\n extern bool make_gimple_omp_edges (basic_block, struct omp_region **, int *);\n extern void omp_finish_file (void);\n extern tree omp_member_access_dummy_var (tree);\n+extern void replace_oacc_fn_attrib (tree, tree);\n+extern tree build_oacc_routine_dims (tree);\n extern tree get_oacc_fn_attrib (tree);\n extern int get_oacc_ifn_dim_arg (const gimple *);\n extern int get_oacc_fn_dim_size (tree, int);"}]}