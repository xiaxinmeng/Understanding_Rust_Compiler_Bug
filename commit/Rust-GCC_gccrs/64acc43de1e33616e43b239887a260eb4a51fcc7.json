{"sha": "64acc43de1e33616e43b239887a260eb4a51fcc7", "node_id": "C_kwDOANBUbNoAKDY0YWNjNDNkZTFlMzM2MTZlNDNiMjM5ODg3YTI2MGViNGE1MWZjYzc", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-08T12:35:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-08T23:57:47Z"}, "message": "libstdc++: Avoid instantiation of _Hash_node before it's needed\n\nThis is a step towards restoring support for incomplete types in\nunordered containers (PR 53339).\n\nWe do not need to instantiate the node type to get its value_type\nmember, because we know that the value type is the first template\nparameter. We can deduce that template argument using a custom trait and\na partial specialization for _Hash_node. If we wanted to support custom\nhash node types we could still use typename _Tp::value_type in the\nprimary template of that trait, but that seems unnecessary.\n\nThe other change needed is to defer a static assert at class scope, so\nthat it is done when the types are complete. We must have a complete\ntype in the destructor, so we can do it there instead.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/hashtable.h: Move static assertion to destructor.\n\t* include/bits/hashtable_policy.h: Deduce value type from node\n\ttype without instantiating it.", "tree": {"sha": "3ee405bdbd2670a548a32ebc2d3636e16bf1feb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ee405bdbd2670a548a32ebc2d3636e16bf1feb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64acc43de1e33616e43b239887a260eb4a51fcc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64acc43de1e33616e43b239887a260eb4a51fcc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64acc43de1e33616e43b239887a260eb4a51fcc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64acc43de1e33616e43b239887a260eb4a51fcc7/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7afb61087d2cb7a6d27463bab5a7567fac69f97a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7afb61087d2cb7a6d27463bab5a7567fac69f97a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7afb61087d2cb7a6d27463bab5a7567fac69f97a"}], "stats": {"total": 26, "additions": 17, "deletions": 9}, "files": [{"sha": "ff8af2201cd1ec174fb7ad5c03c31590403a88ee", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64acc43de1e33616e43b239887a260eb4a51fcc7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64acc43de1e33616e43b239887a260eb4a51fcc7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=64acc43de1e33616e43b239887a260eb4a51fcc7", "patch": "@@ -329,14 +329,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       struct __hash_code_base_access : __hash_code_base\n       { using __hash_code_base::_M_bucket_index; };\n \n-      // Getting a bucket index from a node shall not throw because it is used\n-      // in methods (erase, swap...) that shall not throw.\n-      static_assert(noexcept(declval<const __hash_code_base_access&>()\n-\t\t\t._M_bucket_index(declval<const __node_value_type&>(),\n-\t\t\t\t\t (std::size_t)0)),\n-\t\t    \"Cache the hash code or qualify your functors involved\"\n-\t\t    \" in hash code and bucket index computation with noexcept\");\n-\n       // To get bucket index we need _RangeHash not to throw.\n       static_assert(is_nothrow_default_constructible<_RangeHash>::value,\n \t\t    \"Functor used to map hash code to bucket index\"\n@@ -1556,6 +1548,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     ~_Hashtable() noexcept\n     {\n+      // Getting a bucket index from a node shall not throw because it is used\n+      // in methods (erase, swap...) that shall not throw. Need a complete\n+      // type to check this, so do it in the destructor not at class scope.\n+      static_assert(noexcept(declval<const __hash_code_base_access&>()\n+\t\t\t._M_bucket_index(declval<const __node_value_type&>(),\n+\t\t\t\t\t (std::size_t)0)),\n+\t\t    \"Cache the hash code or qualify your functors involved\"\n+\t\t    \" in hash code and bucket index computation with noexcept\");\n+\n       clear();\n       _M_deallocate_buckets();\n     }"}, {"sha": "75488da13f7db5c51afb1789b049f6d95b6fc9bd", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64acc43de1e33616e43b239887a260eb4a51fcc7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64acc43de1e33616e43b239887a260eb4a51fcc7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=64acc43de1e33616e43b239887a260eb4a51fcc7", "patch": "@@ -1840,14 +1840,21 @@ namespace __detail\n     {\n     private:\n       using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;\n+\n+      template<typename>\n+\tstruct __get_value_type;\n+      template<typename _Val, bool _Cache_hash_code>\n+\tstruct __get_value_type<_Hash_node<_Val, _Cache_hash_code>>\n+\t{ using type = _Val; };\n+\n     public:\n       using __node_type = typename _NodeAlloc::value_type;\n       using __node_alloc_type = _NodeAlloc;\n       // Use __gnu_cxx to benefit from _S_always_equal and al.\n       using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;\n \n       using __value_alloc_traits = typename __node_alloc_traits::template\n-\trebind_traits<typename __node_type::value_type>;\n+\trebind_traits<typename __get_value_type<__node_type>::type>;\n \n       using __node_ptr = __node_type*;\n       using __node_base = _Hash_node_base;"}]}