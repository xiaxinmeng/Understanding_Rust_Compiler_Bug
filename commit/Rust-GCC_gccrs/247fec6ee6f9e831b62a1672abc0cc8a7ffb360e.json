{"sha": "247fec6ee6f9e831b62a1672abc0cc8a7ffb360e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ3ZmVjNmVlNmY5ZTgzMWI2MmExNjcyYWJjMGNjOGE3ZmZiMzYwZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-12T01:05:28Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-12T01:05:28Z"}, "message": "expr.c (java_truthvalue_conversion, [...]): Convert calls to \"build\" into calls to the prefered \"buildN\" functions.\n\n\n\t* expr.c (java_truthvalue_conversion, flush_quick_stack,\n\tjava_stack_swap, java_stack_dup, build_java_athrow, build_java_jsr,\n\tbuild_java_ret, build_java_throw_out_of_bounds_exception,\n\tbuild_java_array_length_access, java_check_reference,\n\tbuild_java_arrayaccess, build_java_arraystore_check, build_newarray,\n\tbuild_anewarray, expand_java_multianewarray, expand_java_arraystore,\n\texpand_java_arrayload, build_java_monitor, expand_java_return,\n\texpand_load_internal, expand_java_NEW, build_get_class,\n\tbuild_instanceof, expand_java_CHECKCAST, expand_iinc,\n\tbuild_java_soft_divmod, build_java_binop, build_field_ref,\n\texpand_compare, expand_java_goto, expand_java_switch,\n\texpand_java_add_case, build_class_init, build_known_method_ref,\n\tinvoke_build_dtable, build_invokevirtual, build_invokeinterface,\n\texpand_invoke, build_jni_stub, expand_java_field_op,\n\tjava_expand_expr, expand_byte_code, STORE_INTERNAL,\n\tforce_evaluation_order, emit_init_test_initialization): Convert\n\tcalls to \"build\" into calls to the prefered \"buildN\" functions.\n\nFrom-SVN: r84541", "tree": {"sha": "0aa82b83b259ad8cc072354ecdf6169ce41fa8fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aa82b83b259ad8cc072354ecdf6169ce41fa8fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/247fec6ee6f9e831b62a1672abc0cc8a7ffb360e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/247fec6ee6f9e831b62a1672abc0cc8a7ffb360e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/247fec6ee6f9e831b62a1672abc0cc8a7ffb360e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/247fec6ee6f9e831b62a1672abc0cc8a7ffb360e/comments", "author": null, "committer": null, "parents": [{"sha": "186af37b4d21add3cdf6fb92dbf2d6d18092c9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/186af37b4d21add3cdf6fb92dbf2d6d18092c9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/186af37b4d21add3cdf6fb92dbf2d6d18092c9a2"}], "stats": {"total": 519, "additions": 272, "deletions": 247}, "files": [{"sha": "d73e68df601536c9a935f55c7ac15f9a8a6e4b1b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247fec6ee6f9e831b62a1672abc0cc8a7ffb360e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247fec6ee6f9e831b62a1672abc0cc8a7ffb360e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=247fec6ee6f9e831b62a1672abc0cc8a7ffb360e", "patch": "@@ -1,3 +1,23 @@\n+2004-07-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expr.c (java_truthvalue_conversion, flush_quick_stack,\n+\tjava_stack_swap, java_stack_dup, build_java_athrow, build_java_jsr,\n+\tbuild_java_ret, build_java_throw_out_of_bounds_exception,\n+\tbuild_java_array_length_access, java_check_reference,\n+\tbuild_java_arrayaccess, build_java_arraystore_check, build_newarray,\n+\tbuild_anewarray, expand_java_multianewarray, expand_java_arraystore,\n+\texpand_java_arrayload, build_java_monitor, expand_java_return,\n+\texpand_load_internal, expand_java_NEW, build_get_class,\n+\tbuild_instanceof, expand_java_CHECKCAST, expand_iinc,\n+\tbuild_java_soft_divmod, build_java_binop, build_field_ref,\n+\texpand_compare, expand_java_goto, expand_java_switch,\n+\texpand_java_add_case, build_class_init, build_known_method_ref,\n+\tinvoke_build_dtable, build_invokevirtual, build_invokeinterface,\n+\texpand_invoke, build_jni_stub, expand_java_field_op,\n+\tjava_expand_expr, expand_byte_code, STORE_INTERNAL,\n+\tforce_evaluation_order, emit_init_test_initialization): Convert\n+\tcalls to \"build\" into calls to the prefered \"buildN\" functions.\n+\n 2004-07-11  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* java-tree.h (set_block): Remove."}, {"sha": "a6bc5759a63243f4abce824f18a15fd96518410c", "filename": "gcc/java/expr.c", "status": "modified", "additions": 252, "deletions": 247, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247fec6ee6f9e831b62a1672abc0cc8a7ffb360e/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247fec6ee6f9e831b62a1672abc0cc8a7ffb360e/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=247fec6ee6f9e831b62a1672abc0cc8a7ffb360e", "patch": "@@ -186,9 +186,10 @@ java_truthvalue_conversion (tree expr)\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      return fold (build (COND_EXPR, boolean_type_node, TREE_OPERAND (expr, 0),\n-                          java_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n-                          java_truthvalue_conversion (TREE_OPERAND (expr, 2))));\n+      return fold\n+\t       (build3 (COND_EXPR, boolean_type_node, TREE_OPERAND (expr, 0),\n+\t\t\tjava_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n+\t\t\tjava_truthvalue_conversion (TREE_OPERAND (expr, 2))));\n \n     case NOP_EXPR:\n       /* If this is widening the argument, we can ignore it.  */\n@@ -198,7 +199,8 @@ java_truthvalue_conversion (tree expr)\n       /* fall through to default */\n \n     default:\n-      return fold (build (NE_EXPR, boolean_type_node, expr, boolean_false_node));\n+      return fold (build2 (NE_EXPR, boolean_type_node,\n+\t\t\t   expr, boolean_false_node));\n     }\n }\n \n@@ -237,7 +239,7 @@ flush_quick_stack (void)\n \n       decl = find_stack_slot (stack_index, type);\n       if (decl != node)\n-\tjava_add_stmt (build (MODIFY_EXPR, TREE_TYPE (node), decl, node));\n+\tjava_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (node), decl, node));\n       stack_index += 1 + TYPE_IS_WIDE (type);\n     }\n }\n@@ -512,13 +514,13 @@ java_stack_swap (void)\n   decl2 = find_stack_slot (stack_pointer - 2, type2);\n   temp = build_decl (VAR_DECL, NULL_TREE, type1);\n   java_add_local_var (temp);\n-  java_add_stmt (build (MODIFY_EXPR, type1, temp, decl1));\n-  java_add_stmt (build (MODIFY_EXPR, type2, \n-\t\t\tfind_stack_slot (stack_pointer - 1, type2),\n-\t\t\tdecl2));\n-  java_add_stmt (build (MODIFY_EXPR, type1, \n-\t\t\tfind_stack_slot (stack_pointer - 2, type1),\n-\t\t\ttemp));\n+  java_add_stmt (build2 (MODIFY_EXPR, type1, temp, decl1));\n+  java_add_stmt (build2 (MODIFY_EXPR, type2, \n+\t\t\t find_stack_slot (stack_pointer - 1, type2),\n+\t\t\t decl2));\n+  java_add_stmt (build2 (MODIFY_EXPR, type1, \n+\t\t\t find_stack_slot (stack_pointer - 2, type1),\n+\t\t\t temp));\n   stack_type_map[stack_pointer - 1] = type2;\n   stack_type_map[stack_pointer - 2] = type1;\n }\n@@ -564,7 +566,7 @@ java_stack_dup (int size, int offset)\n \t  tree dst_decl = find_stack_slot (dst_index, type);\n \n \t  java_add_stmt \n-\t    (build (MODIFY_EXPR, TREE_TYPE (dst_decl), dst_decl, src_decl));\n+\t    (build2 (MODIFY_EXPR, TREE_TYPE (dst_decl), dst_decl, src_decl));\n \t  stack_type_map[dst_index] = type;\n \t}\n     }\n@@ -578,11 +580,11 @@ build_java_athrow (tree node)\n {\n   tree call;\n \n-  call = build (CALL_EXPR,\n-\t\tvoid_type_node,\n-\t\tbuild_address_of (throw_node),\n-\t\tbuild_tree_list (NULL_TREE, node),\n-\t\tNULL_TREE);\n+  call = build3 (CALL_EXPR,\n+\t\t void_type_node,\n+\t\t build_address_of (throw_node),\n+\t\t build_tree_list (NULL_TREE, node),\n+\t\t NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n   java_add_stmt (call);\n   java_stack_pop (stack_pointer);\n@@ -598,7 +600,7 @@ build_java_jsr (int target_pc, int return_pc)\n   tree ret_label = fold (build1 (ADDR_EXPR, return_address_type_node, ret));\n   push_value (ret_label);\n   flush_quick_stack ();\n-  java_add_stmt (build (GOTO_EXPR, void_type_node, where));\n+  java_add_stmt (build1 (GOTO_EXPR, void_type_node, where));\n \n   /* Do not need to emit the label here.  We noted the existance of the\n      label as a jump target in note_instructions; we'll emit the label\n@@ -608,7 +610,7 @@ build_java_jsr (int target_pc, int return_pc)\n static void\n build_java_ret (tree location)\n {\n-  java_add_stmt (build (GOTO_EXPR, void_type_node, location));\n+  java_add_stmt (build1 (GOTO_EXPR, void_type_node, location));\n }\n  \n /* Implementation of operations on array: new, load, store, length */\n@@ -661,9 +663,9 @@ encode_newarray_type (tree type)\n static tree\n build_java_throw_out_of_bounds_exception (tree index)\n {\n-  tree node = build (CALL_EXPR, int_type_node,\n-\t\t     build_address_of (soft_badarrayindex_node), \n-\t\t     build_tree_list (NULL_TREE, index), NULL_TREE);\n+  tree node = build3 (CALL_EXPR, int_type_node,\n+\t\t      build_address_of (soft_badarrayindex_node), \n+\t\t      build_tree_list (NULL_TREE, index), NULL_TREE);\n   TREE_SIDE_EFFECTS (node) = 1;\t/* Allows expansion within ANDIF */\n   return (node);\n }\n@@ -683,9 +685,9 @@ build_java_array_length_access (tree node)\n      of type ptr_type_node at this point is `aconst_null; arraylength'\n      or something equivalent.  */\n   if (type == ptr_type_node)\n-    return build (CALL_EXPR, int_type_node, \n-\t\t  build_address_of (soft_nullpointer_node),\n-\t\t  NULL_TREE, NULL_TREE);\n+    return build3 (CALL_EXPR, int_type_node, \n+\t\t   build_address_of (soft_nullpointer_node),\n+\t\t   NULL_TREE, NULL_TREE);\n \n   if (!is_array_type_p (type))\n     abort ();\n@@ -694,11 +696,11 @@ build_java_array_length_access (tree node)\n   if (length >= 0)\n     return build_int_2 (length, 0);\n \n-  node = build (COMPONENT_REF, int_type_node,\n-\t\tbuild_java_indirect_ref (array_type, node,\n-\t\t\t\t\t flag_check_references),\n-\t\tlookup_field (&array_type, get_identifier (\"length\")),\n-\t\tNULL_TREE);\n+  node = build3 (COMPONENT_REF, int_type_node,\n+\t\t build_java_indirect_ref (array_type, node,\n+\t\t\t\t\t  flag_check_references),\n+\t\t lookup_field (&array_type, get_identifier (\"length\")),\n+\t\t NULL_TREE);\n   IS_ARRAY_LENGTH_ACCESS (node) = 1;\n   return node;\n }\n@@ -713,12 +715,13 @@ java_check_reference (tree expr, int check)\n   if (!flag_syntax_only && check)\n     {\n       expr = save_expr (expr);\n-      expr = build (COND_EXPR, TREE_TYPE (expr),\n-\t\t    build (EQ_EXPR, boolean_type_node, expr, null_pointer_node),\n-\t\t    build (CALL_EXPR, void_type_node, \n-\t\t\t   build_address_of (soft_nullpointer_node),\n-\t\t\t   NULL_TREE, NULL_TREE),\n-\t\t    expr);\n+      expr = build3 (COND_EXPR, TREE_TYPE (expr),\n+\t\t     build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t     expr, null_pointer_node),\n+\t\t     build3 (CALL_EXPR, void_type_node, \n+\t\t\t     build_address_of (soft_nullpointer_node),\n+\t\t\t     NULL_TREE, NULL_TREE),\n+\t\t     expr);\n     }\n \n   return expr;\n@@ -758,13 +761,13 @@ build_java_arrayaccess (tree array, tree type, tree index)\n       tree test;\n       tree len = build_java_array_length_access (array);\n       TREE_TYPE (len) = unsigned_int_type_node;\n-      test = fold (build (GE_EXPR, boolean_type_node, \n-\t\t\t       convert (unsigned_int_type_node, index),\n-\t\t\t       len));\n+      test = fold (build2 (GE_EXPR, boolean_type_node, \n+\t\t\t   convert (unsigned_int_type_node, index),\n+\t\t\t   len));\n       if (! integer_zerop (test))\n \t{\n-\t  throw = build (TRUTH_ANDIF_EXPR, int_type_node, test,\n-\t\t\t build_java_throw_out_of_bounds_exception (index));\n+\t  throw = build2 (TRUTH_ANDIF_EXPR, int_type_node, test,\n+\t\t\t  build_java_throw_out_of_bounds_exception (index));\n \t  /* allows expansion within COMPOUND */\n \t  TREE_SIDE_EFFECTS( throw ) = 1;\n \t}\n@@ -773,16 +776,16 @@ build_java_arrayaccess (tree array, tree type, tree index)\n   /* If checking bounds, wrap the index expr with a COMPOUND_EXPR in order\n      to have the bounds check evaluated first. */\n   if (throw != NULL_TREE)\n-    index = build (COMPOUND_EXPR, int_type_node, throw, index);\n+    index = build2 (COMPOUND_EXPR, int_type_node, throw, index);\n  \n   data_field = lookup_field (&array_type, get_identifier (\"data\"));\n \n-  ref = build (COMPONENT_REF, TREE_TYPE (data_field),    \n-\t       build_java_indirect_ref (array_type, array, \n-\t\t\t\t\tflag_check_references),\n-\t       data_field, NULL_TREE);\n+  ref = build3 (COMPONENT_REF, TREE_TYPE (data_field),    \n+\t\tbuild_java_indirect_ref (array_type, array, \n+\t\t\t\t\t flag_check_references),\n+\t\tdata_field, NULL_TREE);\n   \n-  node = build (ARRAY_REF, type, ref, index, NULL_TREE, NULL_TREE);\n+  node = build4 (ARRAY_REF, type, ref, index, NULL_TREE, NULL_TREE);\n   return node;\n }\n \n@@ -844,11 +847,11 @@ build_java_arraystore_check (tree array, tree object)\n     }\n \n   /* Build an invocation of _Jv_CheckArrayStore */\n-  check = build (CALL_EXPR, void_type_node,\n-\t\t build_address_of (soft_checkarraystore_node),\n-\t\t tree_cons (NULL_TREE, array,\n-\t\t \t    build_tree_list (NULL_TREE, object)),\n-\t\t NULL_TREE);\n+  check = build3 (CALL_EXPR, void_type_node,\n+\t\t  build_address_of (soft_checkarraystore_node),\n+\t\t  tree_cons (NULL_TREE, array,\n+\t\t\t     build_tree_list (NULL_TREE, object)),\n+\t\t  NULL_TREE);\n   TREE_SIDE_EFFECTS (check) = 1;\n \n   return check;\n@@ -907,12 +910,12 @@ build_newarray (int atype_value, tree length)\n   else\n     type_arg = build_class_ref (prim_type);\n \n-  return build (CALL_EXPR, promote_type (type),\n-\t\tbuild_address_of (soft_newarray_node),\n-\t\ttree_cons (NULL_TREE, \n-\t\t\t   type_arg,\n-\t\t\t   build_tree_list (NULL_TREE, length)),\n-\t\tNULL_TREE);\n+  return build3 (CALL_EXPR, promote_type (type),\n+\t\t build_address_of (soft_newarray_node),\n+\t\t tree_cons (NULL_TREE, \n+\t\t\t    type_arg,\n+\t\t\t    build_tree_list (NULL_TREE, length)),\n+\t\t NULL_TREE);\n }\n \n /* Generates anewarray from a given CLASS_TYPE. Gets from the stack the size\n@@ -926,13 +929,13 @@ build_anewarray (tree class_type, tree length)\n \t\t\t     host_integerp (length, 0)\n \t\t\t     ? tree_low_cst (length, 0) : -1);\n \n-  return build (CALL_EXPR, promote_type (type),\n-\t\tbuild_address_of (soft_anewarray_node),\n-\t\ttree_cons (NULL_TREE, length,\n-\t\t\t   tree_cons (NULL_TREE, build_class_ref (class_type),\n-\t\t\t\t      build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t       null_pointer_node))),\n-\t\tNULL_TREE);\n+  return build3 (CALL_EXPR, promote_type (type),\n+\t\t build_address_of (soft_anewarray_node),\n+\t\t tree_cons (NULL_TREE, length,\n+\t\t\t    tree_cons (NULL_TREE, build_class_ref (class_type),\n+\t\t\t\t       build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\tnull_pointer_node))),\n+\t\t NULL_TREE);\n }\n \n /* Return a node the evaluates 'new TYPE[LENGTH]'. */\n@@ -959,13 +962,13 @@ expand_java_multianewarray (tree class_type, int ndim)\n   for( i = 0; i < ndim; i++ )\n     args = tree_cons (NULL_TREE, pop_value (int_type_node), args);\n \n-  push_value (build (CALL_EXPR,\n-\t\t     promote_type (class_type),\n-\t\t     build_address_of (soft_multianewarray_node),\n-\t\t     tree_cons (NULL_TREE, build_class_ref (class_type),\n-\t\t\t\ttree_cons (NULL_TREE, \n-\t\t\t\t\t   build_int_2 (ndim, 0), args )),\n-\t\t     NULL_TREE));\n+  push_value (build3 (CALL_EXPR,\n+\t\t      promote_type (class_type),\n+\t\t      build_address_of (soft_multianewarray_node),\n+\t\t      tree_cons (NULL_TREE, build_class_ref (class_type),\n+\t\t\t\t tree_cons (NULL_TREE, \n+\t\t\t\t\t    build_int_2 (ndim, 0), args)),\n+\t\t      NULL_TREE));\n }\n \n /*  ARRAY[INDEX] <- RHS. build_java_check_indexed_type makes sure that\n@@ -1001,7 +1004,7 @@ expand_java_arraystore (tree rhs_type_node)\n     }\n   \n   array = build_java_arrayaccess (array, rhs_type_node, index);\n-  java_add_stmt (build (MODIFY_EXPR, TREE_TYPE (array), array, rhs_node));  \n+  java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (array), array, rhs_node));  \n }\n \n /* Expand the evaluation of ARRAY[INDEX]. build_java_check_indexed_type makes \n@@ -1025,9 +1028,9 @@ expand_java_arrayload (tree lhs_type_node )\n     /* The only way we could get a node of type ptr_type_node at this\n        point is `aconst_null; arraylength' or something equivalent, so\n        unconditionally throw NullPointerException.  */    \n-    load_node = build (CALL_EXPR, lhs_type_node, \n-\t\t       build_address_of (soft_nullpointer_node),\n-\t\t       NULL_TREE, NULL_TREE);\n+    load_node = build3 (CALL_EXPR, lhs_type_node, \n+\t\t\tbuild_address_of (soft_nullpointer_node),\n+\t\t\tNULL_TREE, NULL_TREE);\n   else\n     {\n       lhs_type_node = build_java_check_indexed_type (array_node, lhs_type_node);\n@@ -1058,11 +1061,11 @@ expand_java_array_length (void)\n static tree\n build_java_monitor (tree call, tree object)\n {\n-  return (build (CALL_EXPR,\n+  return build3 (CALL_EXPR,\n \t\t void_type_node,\n \t\t build_address_of (call),\n \t\t build_tree_list (NULL_TREE, object),\n-\t\t NULL_TREE));\n+\t\t NULL_TREE);\n }\n \n /* Emit code for one of the PUSHC instructions. */\n@@ -1094,12 +1097,12 @@ static void\n expand_java_return (tree type)\n {\n   if (type == void_type_node)\n-    java_add_stmt (build (RETURN_EXPR, void_type_node, NULL));   \n+    java_add_stmt (build1 (RETURN_EXPR, void_type_node, NULL));   \n   else\n     {\n       tree retval = pop_value (type);\n       tree res = DECL_RESULT (current_function_decl);\n-      retval = build (MODIFY_EXPR, TREE_TYPE (res), res, retval);\n+      retval = build2 (MODIFY_EXPR, TREE_TYPE (res), res, retval);\n \n       /* Handle the situation where the native integer type is smaller\n \t than the JVM integer. It can happen for many cross compilers.\n@@ -1111,7 +1114,7 @@ expand_java_return (tree type)\n \tretval = build1(NOP_EXPR, TREE_TYPE(res), retval);\n       \n       TREE_SIDE_EFFECTS (retval) = 1;\n-      java_add_stmt (build (RETURN_EXPR, TREE_TYPE (retval), retval));\n+      java_add_stmt (build1 (RETURN_EXPR, TREE_TYPE (retval), retval));\n     }\n }\n \n@@ -1129,7 +1132,7 @@ expand_load_internal (int index, tree type, int pc)\n      Hopefully this all gets optimized out.  */\n   copy = build_decl (VAR_DECL, NULL_TREE, type);\n   java_add_local_var (copy);\n-  java_add_stmt (build (MODIFY_EXPR, TREE_TYPE (var), copy, var));\n+  java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (var), copy, var));\n   \n   push_value (copy);\n }\n@@ -1162,10 +1165,10 @@ expand_java_NEW (tree type)\n   if (! CLASS_LOADED_P (type))\n     load_class (type, 1);\n   safe_layout_class (type);\n-  push_value (build (CALL_EXPR, promote_type (type),\n-\t\t     build_address_of (alloc_node),\n-\t\t     build_tree_list (NULL_TREE, build_class_ref (type)),\n-\t\t     NULL_TREE));\n+  push_value (build3 (CALL_EXPR, promote_type (type),\n+\t\t      build_address_of (alloc_node),\n+\t\t      build_tree_list (NULL_TREE, build_class_ref (type)),\n+\t\t      NULL_TREE));\n }\n \n /* This returns an expression which will extract the class of an\n@@ -1177,13 +1180,13 @@ build_get_class (tree value)\n   tree class_field = lookup_field (&dtable_type, get_identifier (\"class\"));\n   tree vtable_field = lookup_field (&object_type_node,\n \t\t\t\t    get_identifier (\"vtable\"));\n-  return build (COMPONENT_REF, class_ptr_type,\n-\t\tbuild1 (INDIRECT_REF, dtable_type,\n-\t\t\tbuild (COMPONENT_REF, dtable_ptr_type,\n-\t\t\t       build_java_indirect_ref (object_type_node, value,\n-\t\t\t\t\t\t\tflag_check_references),\n-\t\t\t       vtable_field, NULL_TREE)),\n-\t\tclass_field, NULL_TREE);\n+  tree tmp = build3 (COMPONENT_REF, dtable_ptr_type,\n+\t\t     build_java_indirect_ref (object_type_node, value,\n+\t\t\t\t\t      flag_check_references),\n+\t\t     vtable_field, NULL_TREE);\n+  return build3 (COMPONENT_REF, class_ptr_type,\n+\t\t build1 (INDIRECT_REF, dtable_type, tmp),\n+\t\t class_field, NULL_TREE);\n }\n \n /* This builds the tree representation of the `instanceof' operator.\n@@ -1215,7 +1218,7 @@ build_instanceof (tree value, tree type)\n       /* Anything except `null' is an instance of Object.  Likewise,\n \t if the object is known to be an instance of the class, then\n \t we only need to check for `null'.  */\n-      expr = build (NE_EXPR, itype, value, null_pointer_node);\n+      expr = build2 (NE_EXPR, itype, value, null_pointer_node);\n     }\n   else if (! TYPE_ARRAY_P (type)\n \t   && ! TYPE_ARRAY_P (valtype)\n@@ -1233,22 +1236,22 @@ build_instanceof (tree value, tree type)\n   else if (DECL_P (klass) && CLASS_FINAL (klass))\n     {\n       tree save = save_expr (value);\n-      expr = build (COND_EXPR, itype,\n-\t\t    build (NE_EXPR, boolean_type_node,\n-\t\t\t   save, null_pointer_node),\n-\t\t    build (EQ_EXPR, itype,\n-\t\t\t   build_get_class (save),\n-\t\t\t   build_class_ref (type)),\n-\t\t    boolean_false_node);\n+      expr = build3 (COND_EXPR, itype,\n+\t\t     build2 (NE_EXPR, boolean_type_node,\n+\t\t\t     save, null_pointer_node),\n+\t\t     build2 (EQ_EXPR, itype,\n+\t\t\t     build_get_class (save),\n+\t\t\t     build_class_ref (type)),\n+\t\t     boolean_false_node);\n     }\n   else\n     {\n-      expr = build (CALL_EXPR, itype,\n-\t\t    build_address_of (soft_instanceof_node),\n-\t\t    tree_cons (NULL_TREE, value,\n-\t\t\t       build_tree_list (NULL_TREE,\n-\t\t\t\t\t\tbuild_class_ref (type))),\n-\t\t    NULL_TREE);\n+      expr = build3 (CALL_EXPR, itype,\n+\t\t     build_address_of (soft_instanceof_node),\n+\t\t     tree_cons (NULL_TREE, value,\n+\t\t\t\tbuild_tree_list (NULL_TREE,\n+\t\t\t\t\t\t build_class_ref (type))),\n+\t\t     NULL_TREE);\n     }\n   TREE_SIDE_EFFECTS (expr) = TREE_SIDE_EFFECTS (value);\n   return expr;\n@@ -1266,26 +1269,26 @@ static void\n expand_java_CHECKCAST (tree type)\n {\n   tree value = pop_value (ptr_type_node);\n-  value = build (CALL_EXPR, promote_type (type),\n-\t\t build_address_of (soft_checkcast_node),\n-\t\t tree_cons (NULL_TREE, build_class_ref (type),\n-\t\t\t    build_tree_list (NULL_TREE, value)),\n-\t\t NULL_TREE);\n+  value = build3 (CALL_EXPR, promote_type (type),\n+\t\t  build_address_of (soft_checkcast_node),\n+\t\t  tree_cons (NULL_TREE, build_class_ref (type),\n+\t\t\t     build_tree_list (NULL_TREE, value)),\n+\t\t  NULL_TREE);\n   push_value (value);\n }\n \n static void\n expand_iinc (unsigned int local_var_index, int ival, int pc)\n {\n-    tree local_var, res;\n-    tree constant_value;\n+  tree local_var, res;\n+  tree constant_value;\n \n-    flush_quick_stack ();\n-    local_var = find_local_variable (local_var_index, int_type_node, pc);\n-    constant_value = build_int_2 (ival, ival < 0 ? -1 : 0);\n-    res = fold (build (PLUS_EXPR, int_type_node, local_var, constant_value));\n-    java_add_stmt (build (MODIFY_EXPR, TREE_TYPE (local_var), local_var, res));\n-    update_aliases (local_var, local_var_index);\n+  flush_quick_stack ();\n+  local_var = find_local_variable (local_var_index, int_type_node, pc);\n+  constant_value = build_int_2 (ival, ival < 0 ? -1 : 0);\n+  res = fold (build2 (PLUS_EXPR, int_type_node, local_var, constant_value));\n+  java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (local_var), local_var, res));\n+  update_aliases (local_var, local_var_index);\n }\n \n       \n@@ -1328,11 +1331,11 @@ build_java_soft_divmod (enum tree_code op, tree type, tree op1, tree op2)\n   if (! call)\n     abort ();\n \t\t  \n-  call = build (CALL_EXPR, type,\n-\t\tbuild_address_of (call),\n-\t\ttree_cons (NULL_TREE, arg1,\n-\t\t\t   build_tree_list (NULL_TREE, arg2)),\n-\t\tNULL_TREE);\n+  call = build3 (CALL_EXPR, type,\n+\t\t build_address_of (call),\n+\t\t tree_cons (NULL_TREE, arg1,\n+\t\t\t    build_tree_list (NULL_TREE, arg2)),\n+\t\t NULL_TREE);\n \t  \n   return call;\n }\n@@ -1353,36 +1356,36 @@ build_java_binop (enum tree_code op, tree type, tree arg1, tree arg2)\n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n       mask = build_int_2 (TYPE_PRECISION (TREE_TYPE (arg1)) - 1, 0);\n-      arg2 = fold (build (BIT_AND_EXPR, int_type_node, arg2, mask));\n+      arg2 = fold (build2 (BIT_AND_EXPR, int_type_node, arg2, mask));\n       break;\n \n     case COMPARE_L_EXPR:  /* arg1 > arg2 ?  1 : arg1 == arg2 ? 0 : -1 */\n     case COMPARE_G_EXPR:  /* arg1 < arg2 ? -1 : arg1 == arg2 ? 0 :  1 */\n       arg1 = save_expr (arg1);  arg2 = save_expr (arg2);\n       {\n-\ttree ifexp1 = fold ( build (op == COMPARE_L_EXPR ? GT_EXPR : LT_EXPR,\n+\ttree ifexp1 = fold (build2 (op == COMPARE_L_EXPR ? GT_EXPR : LT_EXPR,\n \t\t\t\t    boolean_type_node, arg1, arg2));\n-\ttree ifexp2 = fold ( build (EQ_EXPR, boolean_type_node, arg1, arg2));\n-\ttree second_compare = fold (build (COND_EXPR, int_type_node,\n-\t\t\t\t\t   ifexp2, integer_zero_node,\n-\t\t\t\t\t   op == COMPARE_L_EXPR\n-\t\t\t\t\t   ? integer_minus_one_node\n-\t\t\t\t\t   : integer_one_node));\n-\treturn fold (build (COND_EXPR, int_type_node, ifexp1,\n-\t\t\t    op == COMPARE_L_EXPR ? integer_one_node\n-\t\t\t    : integer_minus_one_node,\n-\t\t\t    second_compare));\n+\ttree ifexp2 = fold (build2 (EQ_EXPR, boolean_type_node, arg1, arg2));\n+\ttree second_compare = fold (build3 (COND_EXPR, int_type_node,\n+\t\t\t\t\t    ifexp2, integer_zero_node,\n+\t\t\t\t\t    op == COMPARE_L_EXPR\n+\t\t\t\t\t    ? integer_minus_one_node\n+\t\t\t\t\t    : integer_one_node));\n+\treturn fold (build3 (COND_EXPR, int_type_node, ifexp1,\n+\t\t\t     op == COMPARE_L_EXPR ? integer_one_node\n+\t\t\t     : integer_minus_one_node,\n+\t\t\t     second_compare));\n       }\n     case COMPARE_EXPR:\n       arg1 = save_expr (arg1);  arg2 = save_expr (arg2);\n       {\n-\ttree ifexp1 = fold ( build (LT_EXPR, boolean_type_node, arg1, arg2));\n-\ttree ifexp2 = fold ( build (GT_EXPR, boolean_type_node, arg1, arg2));\n-\ttree second_compare = fold ( build (COND_EXPR, int_type_node,\n+\ttree ifexp1 = fold (build2 (LT_EXPR, boolean_type_node, arg1, arg2));\n+\ttree ifexp2 = fold (build2 (GT_EXPR, boolean_type_node, arg1, arg2));\n+\ttree second_compare = fold (build3 (COND_EXPR, int_type_node,\n \t\t\t\t\t    ifexp2, integer_one_node,\n \t\t\t\t\t    integer_zero_node));\n-\treturn fold (build (COND_EXPR, int_type_node,\n-\t\t\t    ifexp1, integer_minus_one_node, second_compare));\n+\treturn fold (build3 (COND_EXPR, int_type_node,\n+\t\t\t     ifexp1, integer_minus_one_node, second_compare));\n       }      \n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n@@ -1395,11 +1398,11 @@ build_java_binop (enum tree_code op, tree type, tree arg1, tree arg2)\n \t      arg1 = convert (double_type_node, arg1);\n \t      arg2 = convert (double_type_node, arg2);\n \t    }\n-\t  call = build (CALL_EXPR, double_type_node,\n-\t\t\tbuild_address_of (soft_fmod_node),\n-\t\t\ttree_cons (NULL_TREE, arg1,\n-\t\t\t\t   build_tree_list (NULL_TREE, arg2)),\n-\t\t\tNULL_TREE);\n+\t  call = build3 (CALL_EXPR, double_type_node,\n+\t\t\t build_address_of (soft_fmod_node),\n+\t\t\t tree_cons (NULL_TREE, arg1,\n+\t\t\t\t    build_tree_list (NULL_TREE, arg2)),\n+\t\t\t NULL_TREE);\n \t  if (type != double_type_node)\n \t    call = convert (type, call);\n \t  return call;\n@@ -1413,7 +1416,7 @@ build_java_binop (enum tree_code op, tree type, tree arg1, tree arg2)\n       break;\n     default:  ;\n     }\n-  return fold (build (op, type, arg1, arg2));\n+  return fold (build2 (op, type, arg1, arg2));\n }\n \n static void\n@@ -1537,23 +1540,23 @@ build_field_ref (tree self_value, tree self_class, tree name)\n \t\t\t   (field_decl, &TYPE_OTABLE_METHODS (output_class)),\n \t\t\t   0);\n \t  tree field_offset\n-\t    = build (ARRAY_REF, integer_type_node,\n-\t\t     TYPE_OTABLE_DECL (output_class), otable_index,\n-\t\t     NULL_TREE, NULL_TREE);\n+\t    = build4 (ARRAY_REF, integer_type_node,\n+\t\t      TYPE_OTABLE_DECL (output_class), otable_index,\n+\t\t      NULL_TREE, NULL_TREE);\n \t  tree address;\n \n \t  field_offset = fold (convert (sizetype, field_offset));\n \t  address \n-\t    = fold (build (PLUS_EXPR, \n-\t\t\t   build_pointer_type (TREE_TYPE (field_decl)),\n-\t\t\t   self_value, field_offset));\n+\t    = fold (build2 (PLUS_EXPR, \n+\t\t\t    build_pointer_type (TREE_TYPE (field_decl)),\n+\t\t\t    self_value, field_offset));\n \t  return fold (build1 (INDIRECT_REF, TREE_TYPE (field_decl), address));\n \t}\n \n       self_value = build_java_indirect_ref (TREE_TYPE (TREE_TYPE (self_value)),\n \t\t\t\t\t    self_value, check);\n-      return fold (build (COMPONENT_REF, TREE_TYPE (field_decl),\n-\t\t\t  self_value, field_decl, NULL_TREE));\n+      return fold (build3 (COMPONENT_REF, TREE_TYPE (field_decl),\n+\t\t\t   self_value, field_decl, NULL_TREE));\n     }\n }\n \n@@ -1617,11 +1620,11 @@ expand_compare (enum tree_code condition, tree value1, tree value2,\n \t\tint target_pc)\n {\n   tree target = lookup_label (target_pc);\n-  tree cond = fold (build (condition, boolean_type_node, value1, value2));\n+  tree cond = fold (build2 (condition, boolean_type_node, value1, value2));\n   java_add_stmt \n-    (build (COND_EXPR, void_type_node, java_truthvalue_conversion (cond),\n-\t    build (GOTO_EXPR, void_type_node, target), \n-\t    build_java_empty_stmt ()));\n+    (build3 (COND_EXPR, void_type_node, java_truthvalue_conversion (cond),\n+\t     build1 (GOTO_EXPR, void_type_node, target), \n+\t     build_java_empty_stmt ()));\n }\n \n /* Emit code for a TEST-type opcode. */\n@@ -1655,7 +1658,7 @@ expand_java_goto (int target_pc)\n {\n   tree target_label = lookup_label (target_pc);\n   flush_quick_stack ();\n-  java_add_stmt (build  (GOTO_EXPR, void_type_node, target_label));\n+  java_add_stmt (build1 (GOTO_EXPR, void_type_node, target_label));\n }\n \n static tree\n@@ -1664,15 +1667,15 @@ expand_java_switch (tree selector, int default_pc)\n   tree switch_expr, x;\n \n   flush_quick_stack ();\n-  switch_expr = build (SWITCH_EXPR, TREE_TYPE (selector), selector,\n-\t\t       NULL_TREE, NULL_TREE);\n+  switch_expr = build3 (SWITCH_EXPR, TREE_TYPE (selector), selector,\n+\t\t\tNULL_TREE, NULL_TREE);\n   java_add_stmt (switch_expr);\n \n-  x = build (CASE_LABEL_EXPR, void_type_node, NULL_TREE, NULL_TREE,\n-\t     create_artificial_label ());\n+  x = build3 (CASE_LABEL_EXPR, void_type_node, NULL_TREE, NULL_TREE,\n+\t      create_artificial_label ());\n   append_to_statement_list (x, &SWITCH_BODY (switch_expr));\n \n-  x = build (GOTO_EXPR, void_type_node, lookup_label (default_pc));\n+  x = build1 (GOTO_EXPR, void_type_node, lookup_label (default_pc));\n   append_to_statement_list (x, &SWITCH_BODY (switch_expr));\n \n   return switch_expr;\n@@ -1686,11 +1689,11 @@ expand_java_add_case (tree switch_expr, int match, int target_pc)\n   value = build_int_2 (match, match < 0 ? -1 : 0);\n   TREE_TYPE (value) = TREE_TYPE (switch_expr);\n   \n-  x = build (CASE_LABEL_EXPR, void_type_node, value, NULL_TREE,\n-\t     create_artificial_label ());\n+  x = build3 (CASE_LABEL_EXPR, void_type_node, value, NULL_TREE,\n+\t      create_artificial_label ());\n   append_to_statement_list (x, &SWITCH_BODY (switch_expr));\n \n-  x = build (GOTO_EXPR, void_type_node, lookup_label (target_pc));\n+  x = build1 (GOTO_EXPR, void_type_node, lookup_label (target_pc));\n   append_to_statement_list (x, &SWITCH_BODY (switch_expr));\n }\n \n@@ -1756,10 +1759,10 @@ build_class_init (tree clas, tree expr)\n \n   if (always_initialize_class_p)\n     {\n-      init = build (CALL_EXPR, void_type_node,\n-\t\t    build_address_of (soft_initclass_node),\n-\t\t    build_tree_list (NULL_TREE, build_class_ref (clas)),\n-\t\t    NULL_TREE);\n+      init = build3 (CALL_EXPR, void_type_node,\n+\t\t     build_address_of (soft_initclass_node),\n+\t\t     build_tree_list (NULL_TREE, build_class_ref (clas)),\n+\t\t     NULL_TREE);\n       TREE_SIDE_EFFECTS (init) = 1;\n     }\n   else\n@@ -1787,25 +1790,25 @@ build_class_init (tree clas, tree expr)\n \t  DECL_IGNORED_P (*init_test_decl) = 1;\n \t}\n \n-      init = build (CALL_EXPR, void_type_node,\n-\t\t    build_address_of (soft_initclass_node),\n-\t\t    build_tree_list (NULL_TREE, build_class_ref (clas)),\n-\t\t    NULL_TREE);\n+      init = build3 (CALL_EXPR, void_type_node,\n+\t\t     build_address_of (soft_initclass_node),\n+\t\t     build_tree_list (NULL_TREE, build_class_ref (clas)),\n+\t\t     NULL_TREE);\n       TREE_SIDE_EFFECTS (init) = 1;\n-      init = build (COND_EXPR, void_type_node,\n-\t\t    build (EQ_EXPR, boolean_type_node, \n-\t\t\t   *init_test_decl, boolean_false_node),\n-\t\t    init, integer_zero_node);\n+      init = build3 (COND_EXPR, void_type_node,\n+\t\t     build2 (EQ_EXPR, boolean_type_node, \n+\t\t\t     *init_test_decl, boolean_false_node),\n+\t\t     init, integer_zero_node);\n       TREE_SIDE_EFFECTS (init) = 1;\n-      init = build (COMPOUND_EXPR, TREE_TYPE (expr), init, \n-\t\t    build (MODIFY_EXPR, boolean_type_node,\n-\t\t\t   *init_test_decl, boolean_true_node));\n+      init = build2 (COMPOUND_EXPR, TREE_TYPE (expr), init, \n+\t\t     build2 (MODIFY_EXPR, boolean_type_node,\n+\t\t\t     *init_test_decl, boolean_true_node));\n       TREE_SIDE_EFFECTS (init) = 1;\n     }\n \n   if (expr != NULL_TREE)\n     {\n-      expr = build (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n+      expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n       TREE_SIDE_EFFECTS (expr) = 1;\n       return expr;\n     }\n@@ -1832,9 +1835,9 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t  tree table_index\n \t    = build_int_2 (get_symbol_table_index \n \t\t\t   (method, &TYPE_ATABLE_METHODS (output_class)), 0);\n-\t  func = build (ARRAY_REF,  method_ptr_type_node, \n-\t\t\tTYPE_ATABLE_DECL (output_class), table_index,\n-\t\t\tNULL_TREE, NULL_TREE);\n+\t  func = build4 (ARRAY_REF,  method_ptr_type_node, \n+\t\t\t TYPE_ATABLE_DECL (output_class), table_index,\n+\t\t\t NULL_TREE, NULL_TREE);\n \t}\n       func = convert (method_ptr_type_node, func);\n     }\n@@ -1860,8 +1863,9 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \tncode_ident = get_identifier (\"ncode\");\n       if (methods_ident == NULL_TREE)\n \tmethods_ident = get_identifier (\"methods\");\n-      ref = build (COMPONENT_REF, method_ptr_type_node, ref,\n-\t\t   lookup_field (&class_type_node, methods_ident), NULL_TREE);\n+      ref = build3 (COMPONENT_REF, method_ptr_type_node, ref,\n+\t\t    lookup_field (&class_type_node, methods_ident),\n+\t\t    NULL_TREE);\n       for (meth = TYPE_METHODS (self_type);\n \t   ; meth = TREE_CHAIN (meth))\n \t{\n@@ -1873,12 +1877,12 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t  method_index++;\n \t}\n       method_index *= int_size_in_bytes (method_type_node);\n-      ref = fold (build (PLUS_EXPR, method_ptr_type_node,\n-\t\t\t ref, build_int_2 (method_index, 0)));\n+      ref = fold (build2 (PLUS_EXPR, method_ptr_type_node,\n+\t\t\t  ref, build_int_2 (method_index, 0)));\n       ref = build1 (INDIRECT_REF, method_type_node, ref);\n-      func = build (COMPONENT_REF, nativecode_ptr_type_node,\n-\t\t    ref, lookup_field (&method_type_node, ncode_ident),\n-\t\t    NULL_TREE);\n+      func = build3 (COMPONENT_REF, nativecode_ptr_type_node,\n+\t\t     ref, lookup_field (&method_type_node, ncode_ident),\n+\t\t     NULL_TREE);\n     }\n   return func;\n }\n@@ -1901,8 +1905,8 @@ invoke_build_dtable (int is_invoke_interface, tree arg_list)\n     dtable_ident = get_identifier (\"vtable\");\n   dtable = build_java_indirect_ref (object_type_node, objectref, \n \t\t\t\t    flag_check_references);\n-  dtable = build (COMPONENT_REF, dtable_ptr_type, dtable,\n-\t\t  lookup_field (&object_type_node, dtable_ident), NULL_TREE);\n+  dtable = build3 (COMPONENT_REF, dtable_ptr_type, dtable,\n+\t\t   lookup_field (&object_type_node, dtable_ident), NULL_TREE);\n \n   return dtable;\n }\n@@ -1956,9 +1960,9 @@ build_invokevirtual (tree dtable, tree method)\n       otable_index \n \t= build_int_2 (get_symbol_table_index \n \t\t       (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n-      method_index = build (ARRAY_REF, integer_type_node, \n-\t\t\t    TYPE_OTABLE_DECL (output_class), \n-\t\t\t    otable_index, NULL_TREE, NULL_TREE);\n+      method_index = build4 (ARRAY_REF, integer_type_node, \n+\t\t\t     TYPE_OTABLE_DECL (output_class), \n+\t\t\t     otable_index, NULL_TREE, NULL_TREE);\n     }\n   else\n     {\n@@ -1974,8 +1978,8 @@ build_invokevirtual (tree dtable, tree method)\n \t\t\t\t   size_int (TARGET_VTABLE_USES_DESCRIPTORS));\n     }\n \n-  func = fold (build (PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n-\t\t      convert (nativecode_ptr_ptr_type_node, method_index)));\n+  func = fold (build2 (PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n+\t\t       convert (nativecode_ptr_ptr_type_node, method_index)));\n \n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     func = build1 (NOP_EXPR, nativecode_ptr_type_node, func);\n@@ -2003,8 +2007,8 @@ build_invokeinterface (tree dtable, tree method)\n \n   dtable = build_java_indirect_ref (dtable_type, dtable,\n \t\t\t\t    flag_check_references);\n-  dtable = build (COMPONENT_REF, class_ptr_type, dtable,\n-\t\t  lookup_field (&dtable_type, class_ident), NULL_TREE);\n+  dtable = build3 (COMPONENT_REF, class_ptr_type, dtable,\n+\t\t   lookup_field (&dtable_type, class_ident), NULL_TREE);\n \n   interface = DECL_CONTEXT (method);\n   if (! CLASS_INTERFACE (TYPE_NAME (interface)))\n@@ -2016,9 +2020,9 @@ build_invokeinterface (tree dtable, tree method)\n       otable_index\n \t= build_int_2 (get_symbol_table_index \n \t\t       (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n-      idx = build (ARRAY_REF, integer_type_node,\n-\t\t   TYPE_OTABLE_DECL (output_class), otable_index,\n-\t\t   NULL_TREE, NULL_TREE);\n+      idx = build4 (ARRAY_REF, integer_type_node,\n+\t\t    TYPE_OTABLE_DECL (output_class), otable_index,\n+\t\t    NULL_TREE, NULL_TREE);\n     }\n   else\n     idx = build_int_2 (get_interface_method_index (method, interface), 0);\n@@ -2027,9 +2031,9 @@ build_invokeinterface (tree dtable, tree method)\n                           tree_cons (NULL_TREE, build_class_ref (interface),\n \t\t\t             build_tree_list (NULL_TREE, idx)));\n \t\t\t\t     \t\t\t  \n-  return build (CALL_EXPR, ptr_type_node, \n-\t\tbuild_address_of (soft_lookupinterfacemethod_node),\n-\t\tlookup_arg, NULL_TREE);\n+  return build3 (CALL_EXPR, ptr_type_node, \n+\t\t build_address_of (soft_lookupinterfacemethod_node),\n+\t\t lookup_arg, NULL_TREE);\n }\n   \n /* Expand one of the invoke_* opcodes.\n@@ -2150,13 +2154,14 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n   else\n     func = build1 (NOP_EXPR, build_pointer_type (method_type), func);\n \n-  call = build (CALL_EXPR, TREE_TYPE (method_type), func, arg_list, NULL_TREE);\n+  call = build3 (CALL_EXPR, TREE_TYPE (method_type),\n+\t\t func, arg_list, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n   call = check_for_builtin (method, call);\n \n   if (check != NULL_TREE)\n     {\n-      call = build (COMPOUND_EXPR, TREE_TYPE (call), check, call);\n+      call = build2 (COMPOUND_EXPR, TREE_TYPE (call), check, call);\n       TREE_SIDE_EFFECTS (call) = 1;\n     }\n \n@@ -2231,11 +2236,11 @@ build_jni_stub (tree method)\n     TREE_TYPE (block) = TREE_TYPE (TREE_TYPE (method));\n \n   /* Compute the local `env' by calling _Jv_GetJNIEnvNewFrame.  */\n-  body = build (MODIFY_EXPR, ptr_type_node, env_var,\n-\t\tbuild (CALL_EXPR, ptr_type_node,\n-\t\t       build_address_of (soft_getjnienvnewframe_node),\n-\t\t       build_tree_list (NULL_TREE, klass),\n-\t\t       NULL_TREE));\n+  body = build2 (MODIFY_EXPR, ptr_type_node, env_var,\n+\t\t build3 (CALL_EXPR, ptr_type_node,\n+\t\t\t build_address_of (soft_getjnienvnewframe_node),\n+\t\t\t build_tree_list (NULL_TREE, klass),\n+\t\t\t NULL_TREE));\n   CAN_COMPLETE_NORMALLY (body) = 1;\n \n   /* All the arguments to this method become arguments to the\n@@ -2294,40 +2299,40 @@ build_jni_stub (tree method)\n \n   jni_func_type = build_pointer_type (tem);\n \n-  jnifunc = build (COND_EXPR, ptr_type_node,\n-\t\t   meth_var, meth_var,\n-\t\t   build (MODIFY_EXPR, ptr_type_node,\n-\t\t\t  meth_var,\n-\t\t\t  build (CALL_EXPR, ptr_type_node,\n-\t\t\t\t build_address_of (soft_lookupjnimethod_node),\n-\t\t\t\t lookup_arg, NULL_TREE)));\n+  jnifunc = build3 (COND_EXPR, ptr_type_node,\n+\t\t    meth_var, meth_var,\n+\t\t    build2 (MODIFY_EXPR, ptr_type_node, meth_var,\n+\t\t\t    build3 (CALL_EXPR, ptr_type_node,\n+\t\t\t\t    build_address_of\n+\t\t\t\t      (soft_lookupjnimethod_node),\n+\t\t\t\t    lookup_arg, NULL_TREE)));\n \n   /* Now we make the actual JNI call via the resulting function\n      pointer.    */\n-  call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (method)),\n-\t\tbuild1 (NOP_EXPR, jni_func_type, jnifunc),\n-\t\targs, NULL_TREE);\n+  call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (method)),\n+\t\t build1 (NOP_EXPR, jni_func_type, jnifunc),\n+\t\t args, NULL_TREE);\n \n   /* If the JNI call returned a result, capture it here.  If we had to\n      unwrap JNI object results, we would do that here.  */\n   if (res_var != NULL_TREE)\n-    call = build (MODIFY_EXPR, TREE_TYPE (TREE_TYPE (method)),\n-\t\t  res_var, call);\n+    call = build2 (MODIFY_EXPR, TREE_TYPE (TREE_TYPE (method)),\n+\t\t   res_var, call);\n \n   TREE_SIDE_EFFECTS (call) = 1;\n   CAN_COMPLETE_NORMALLY (call) = 1;\n \n-  body = build (COMPOUND_EXPR, void_type_node, body, call);\n+  body = build2 (COMPOUND_EXPR, void_type_node, body, call);\n   TREE_SIDE_EFFECTS (body) = 1;\n \n   /* Now free the environment we allocated.  */\n-  call = build (CALL_EXPR, ptr_type_node,\n-\t\tbuild_address_of (soft_jnipopsystemframe_node),\n-\t\tbuild_tree_list (NULL_TREE, env_var),\n-\t\tNULL_TREE);\n+  call = build3 (CALL_EXPR, ptr_type_node,\n+\t\t build_address_of (soft_jnipopsystemframe_node),\n+\t\t build_tree_list (NULL_TREE, env_var),\n+\t\t NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n   CAN_COMPLETE_NORMALLY (call) = 1;\n-  body = build (COMPOUND_EXPR, void_type_node, body, call);\n+  body = build2 (COMPOUND_EXPR, void_type_node, body, call);\n   TREE_SIDE_EFFECTS (body) = 1;\n \n   /* Finally, do the return.  */\n@@ -2344,16 +2349,16 @@ build_jni_stub (tree method)\n       drt = TREE_TYPE (DECL_RESULT (method));\n       if (drt != TREE_TYPE (res_var))\n \tres_var = build1 (CONVERT_EXPR, drt, res_var);\n-      res_var = build (MODIFY_EXPR, drt, DECL_RESULT (method), res_var);\n+      res_var = build2 (MODIFY_EXPR, drt, DECL_RESULT (method), res_var);\n       TREE_SIDE_EFFECTS (res_var) = 1;\n     }\n \n-  body = build (COMPOUND_EXPR, void_type_node, body,\n-\t\tbuild1 (RETURN_EXPR, res_type, res_var));\n+  body = build2 (COMPOUND_EXPR, void_type_node, body,\n+\t\t build1 (RETURN_EXPR, res_type, res_var));\n   TREE_SIDE_EFFECTS (body) = 1;\n   \n-  bind = build (BIND_EXPR, void_type_node, BLOCK_VARS (block), \n-\t\tbody, block);\n+  bind = build3 (BIND_EXPR, void_type_node, BLOCK_VARS (block), \n+\t\t body, block);\n   return bind;\n }\n \n@@ -2435,8 +2440,8 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n \t\t\t field_decl, field_decl);\n \t    }\n \t}\n-      java_add_stmt (build (MODIFY_EXPR, \n-\t\t\t    TREE_TYPE (field_ref), field_ref, new_value));\n+      java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (field_ref),\n+\t\t\t     field_ref, new_value));\n     }\n   else\n     push_value (field_ref);\n@@ -2642,7 +2647,7 @@ expand_byte_code (JCF *jcf, tree method)\n \t  tree label = lookup_label (PC);\n           flush_quick_stack ();\n \t  if ((instruction_bits [PC] & BCODE_TARGET) != 0)\n-\t    java_add_stmt (build (LABEL_EXPR, void_type_node, label));\n+\t    java_add_stmt (build1 (LABEL_EXPR, void_type_node, label));\n \t  if (LABEL_VERIFIED (label) || PC == 0)\n \t    load_type_state (label);\n \t}\n@@ -2931,7 +2936,7 @@ process_jvm_instruction (int PC, const unsigned char* byte_ops,\n     type = TREE_TYPE (value);\t\t\t\t\t\\\n     decl = find_local_variable (index, type, oldpc);\t\t\\\n     set_local_type (index, type);\t\t\t\t\\\n-    java_add_stmt (build (MODIFY_EXPR, type, decl, value));\t\\\n+    java_add_stmt (build2 (MODIFY_EXPR, type, decl, value));\t\\\n     update_aliases (decl, index);\t\t\t\t\\\n   }\n \n@@ -3191,7 +3196,7 @@ force_evaluation_order (tree node)\n \t{\n \t  tree saved = save_expr (force_evaluation_order (TREE_VALUE (arg)));\n \t  cmp = (cmp == NULL_TREE ? saved :\n-\t\t build (COMPOUND_EXPR, void_type_node, cmp, saved));\n+\t\t build2 (COMPOUND_EXPR, void_type_node, cmp, saved));\n \t  TREE_VALUE (arg) = saved;\n \t}\n       \n@@ -3200,7 +3205,7 @@ force_evaluation_order (tree node)\n \n       if (cmp)\n \t{\n-\t  cmp = build (COMPOUND_EXPR, TREE_TYPE (node), cmp, node);\n+\t  cmp = build2 (COMPOUND_EXPR, TREE_TYPE (node), cmp, node);\n \t  if (TREE_TYPE (cmp) != void_type_node)\n \t    cmp = save_expr (cmp);\n \t  CAN_COMPLETE_NORMALLY (cmp) = CAN_COMPLETE_NORMALLY (node);"}]}