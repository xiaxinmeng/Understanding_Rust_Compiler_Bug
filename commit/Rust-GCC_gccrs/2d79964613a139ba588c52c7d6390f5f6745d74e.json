{"sha": "2d79964613a139ba588c52c7d6390f5f6745d74e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ3OTk2NDYxM2ExMzliYTU4OGM1MmM3ZDYzOTBmNWY2NzQ1ZDc0ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-21T14:03:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-21T14:03:57Z"}, "message": "re PR tree-optimization/66948 (Performance regression in bit manipulation code)\n\n2015-07-21  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/66948\n\t* genmatch.c (capture_info::walk_match): Also recurse to\n\tcaptures.  Properly compute expr state from captures of\n\tcaptures.\n\t* match.pd: Add single-use guards to\n\t(X & C2) >> C1 into (X >> C1) & (C2 >> C1) transform.\n\nFrom-SVN: r226041", "tree": {"sha": "9d1fbe883757df7ca019c76a26b10b1a9cb1fa9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d1fbe883757df7ca019c76a26b10b1a9cb1fa9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d79964613a139ba588c52c7d6390f5f6745d74e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d79964613a139ba588c52c7d6390f5f6745d74e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d79964613a139ba588c52c7d6390f5f6745d74e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d79964613a139ba588c52c7d6390f5f6745d74e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51"}], "stats": {"total": 36, "additions": 28, "deletions": 8}, "files": [{"sha": "fa9d3ef40e8beefe4f221aa977b944dc384ef499", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d79964613a139ba588c52c7d6390f5f6745d74e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d79964613a139ba588c52c7d6390f5f6745d74e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d79964613a139ba588c52c7d6390f5f6745d74e", "patch": "@@ -1,3 +1,12 @@\n+2015-07-21  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66948\n+\t* genmatch.c (capture_info::walk_match): Also recurse to\n+\tcaptures.  Properly compute expr state from captures of\n+\tcaptures.\n+\t* match.pd: Add single-use guards to\n+\t(X & C2) >> C1 into (X >> C1) & (C2 >> C1) transform.\n+\n 2015-07-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/nvptx/mkoffload.c (process): Add static destructor call."}, {"sha": "8f1fbcd47e14277f7d1135bd6fac4ca673994260", "filename": "gcc/genmatch.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d79964613a139ba588c52c7d6390f5f6745d74e/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d79964613a139ba588c52c7d6390f5f6745d74e/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=2d79964613a139ba588c52c7d6390f5f6745d74e", "patch": "@@ -1622,17 +1622,28 @@ capture_info::walk_match (operand *o, unsigned toplevel_arg,\n {\n   if (capture *c = dyn_cast <capture *> (o))\n     {\n-      info[c->where].toplevel_msk |= 1 << toplevel_arg;\n-      info[c->where].force_no_side_effects_p |= conditional_p;\n-      info[c->where].cond_expr_cond_p |= cond_expr_cond_p;\n-      /* Mark expr (non-leaf) captures and recurse.  */\n+      unsigned where = c->where;\n+      info[where].toplevel_msk |= 1 << toplevel_arg;\n+      info[where].force_no_side_effects_p |= conditional_p;\n+      info[where].cond_expr_cond_p |= cond_expr_cond_p;\n+      if (!c->what)\n+\treturn;\n+      /* Recurse to exprs and captures.  */\n+      if (is_a <capture *> (c->what)\n+\t  || is_a <expr *> (c->what))\n+\twalk_match (c->what, toplevel_arg, conditional_p, false);\n+      /* We need to look past multiple captures to find a captured\n+\t expression as with conditional converts two captures\n+\t can be collapsed onto the same expression.  */\n+      while (c->what && is_a <capture *> (c->what))\n+\tc = as_a <capture *> (c->what);\n+      /* Mark expr (non-leaf) captures and forced single-use exprs.  */\n       expr *e;\n       if (c->what\n \t  && (e = dyn_cast <expr *> (c->what)))\n \t{\n-\t  info[c->where].expr_p = true;\n-\t  info[c->where].force_single_use |= e->force_single_use;\n-\t  walk_match (c->what, toplevel_arg, conditional_p, false);\n+\t  info[where].expr_p = true;\n+\t  info[where].force_single_use |= e->force_single_use;\n \t}\n     }\n   else if (expr *e = dyn_cast <expr *> (o))"}, {"sha": "9a66f5274bb6316ded3f9afece86a7566797c4a0", "filename": "gcc/match.pd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d79964613a139ba588c52c7d6390f5f6745d74e/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d79964613a139ba588c52c7d6390f5f6745d74e/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=2d79964613a139ba588c52c7d6390f5f6745d74e", "patch": "@@ -1052,7 +1052,7 @@ along with GCC; see the file COPYING3.  If not see\n    (X & C2) >> C1 into (X >> C1) & (C2 >> C1).  */\n (for shift (lshift rshift)\n  (simplify\n-  (shift (convert? (bit_and @0 INTEGER_CST@2)) INTEGER_CST@1)\n+  (shift (convert?:s (bit_and:s @0 INTEGER_CST@2)) INTEGER_CST@1)\n   (if (tree_nop_conversion_p (type, TREE_TYPE (@0)))\n    (with { tree mask = int_const_binop (shift, fold_convert (type, @2), @1); }\n     (bit_and (shift (convert @0) @1) { mask; })))))"}]}