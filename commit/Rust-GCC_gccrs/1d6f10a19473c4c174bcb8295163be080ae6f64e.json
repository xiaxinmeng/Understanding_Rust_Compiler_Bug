{"sha": "1d6f10a19473c4c174bcb8295163be080ae6f64e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ2ZjEwYTE5NDczYzRjMTc0YmNiODI5NTE2M2JlMDgwYWU2ZjY0ZQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-08-14T08:46:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:46:03Z"}, "message": "table.adb, [...] (Append): Reimplement in terms of Set_Item.\n\n2007-08-14  Thomas Quinot  <quinot@adacore.com>\n\n\t* table.adb, g-table.adb, g-dyntab.adb (Append): Reimplement in terms\n\tof Set_Item.\n\t(Set_Item): When the new item is an element of the currently allocated\n\ttable passed by reference, save a copy on the stack if we're going\n\tto reallocate. Also, in Table.Set_Item, make sure we test the proper\n\tvariable to determine whether to call Set_Last.\n\n\t* sinput-d.adb, sinput-l.adb, stringt.adb, switch-m.adb,\n\tsymbols-vms.adb, symbols-processing-vms-alpha.adb,\n\tsymbols-processing-vms-ia64.adb, sem_elab.adb, repinfo.adb: Replace\n\tsome occurrences of the pattern\n\t   T.Increment_Last;\n\t   T.Table (T.Last) := Value;\n\twith a cleaner call to\n\t   T.Append (Value);\n\nFrom-SVN: r127442", "tree": {"sha": "e043ad5b7ca9b739ced688a5040d0ff234515f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e043ad5b7ca9b739ced688a5040d0ff234515f08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d6f10a19473c4c174bcb8295163be080ae6f64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6f10a19473c4c174bcb8295163be080ae6f64e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d6f10a19473c4c174bcb8295163be080ae6f64e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6f10a19473c4c174bcb8295163be080ae6f64e/comments", "author": null, "committer": null, "parents": [{"sha": "f97ccb3a84b27374661fd1f9540efb360d976019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f97ccb3a84b27374661fd1f9540efb360d976019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f97ccb3a84b27374661fd1f9540efb360d976019"}], "stats": {"total": 308, "additions": 215, "deletions": 93}, "files": [{"sha": "a6a61a432ea799d4aeadf495e26d92e7bd5d6a58", "filename": "gcc/ada/g-dyntab.adb", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -82,8 +82,7 @@ package body GNAT.Dynamic_Tables is\n \n    procedure Append (T : in out Instance; New_Val : Table_Component_Type) is\n    begin\n-      Increment_Last (T);\n-      T.Table (Table_Index_Type (T.P.Last_Val)) := New_Val;\n+      Set_Item (T, Table_Index_Type (T.P.Last_Val + 1), New_Val);\n    end Append;\n \n    --------------------\n@@ -227,16 +226,67 @@ package body GNAT.Dynamic_Tables is\n    --------------\n \n    procedure Set_Item\n-     (T     : in out Instance;\n-      Index : Table_Index_Type;\n-      Item  : Table_Component_Type)\n+      (T     : in out Instance;\n+       Index : Table_Index_Type;\n+       Item  : Table_Component_Type)\n    is\n+      --  If Item is a value within the current allocation, and we are going to\n+      --  reallocate, then we must preserve an intermediate copy here before\n+      --  calling Increment_Last. Otherwise, if Table_Component_Type is passed\n+      --  by reference, we are going to end up copying from storage that might\n+      --  have been deallocated from Increment_Last calling Reallocate.\n+\n+      subtype Allocated_Table_T is\n+        Table_Type (T.Table'First .. Table_Index_Type (T.P.Max + 1));\n+      --  A constrained table subtype one element larger than the currently\n+      --  allocated table.\n+\n+      Allocated_Table_Address : constant System.Address :=\n+                                  T.Table.all'Address;\n+      --  Used for address clause below (we can't use non-static expression\n+      --  Table.all'Address directly in the clause because some older versions\n+      --  of the compiler do not allow it).\n+\n+      Allocated_Table : Allocated_Table_T;\n+      pragma Import (Ada, Allocated_Table);\n+      for Allocated_Table'Address use Allocated_Table_Address;\n+      --  Allocated_Table represents the currently allocated array, plus one\n+      --  element (the supplementary element is used to have a convenient way\n+      --  to the address just past the end of the current allocation).\n+\n+      Need_Realloc : constant Boolean := Integer (Index) > T.P.Max;\n+      --  True if this operation requires storage reallocation (which may\n+      --  involve moving table contents around).\n+\n    begin\n-      if Integer (Index) > T.P.Last_Val then\n-         Set_Last (T, Index);\n-      end if;\n+      --  If we're going to reallocate, check wheter Item references an\n+      --  element of the currently allocated table.\n+\n+      if Need_Realloc\n+        and then Allocated_Table'Address <= Item'Address\n+        and then Item'Address <\n+                   Allocated_Table (Table_Index_Type (T.P.Max + 1))'Address\n+      then\n+         --  If so, save a copy on the stack because Increment_Last will\n+         --  reallocate storage and might deallocate the current table.\n+\n+         declare\n+            Item_Copy : constant Table_Component_Type := Item;\n+         begin\n+            Set_Last (T, Index);\n+            T.Table (Index) := Item_Copy;\n+         end;\n+\n+      else\n+         --  Here we know that either we won't reallocate (case of Index < Max)\n+         --  or that Item is not in the currently allocated table.\n \n-      T.Table (Index) := Item;\n+         if Integer (Index) > T.P.Last_Val then\n+            Set_Last (T, Index);\n+         end if;\n+\n+         T.Table (Index) := Item;\n+      end if;\n    end Set_Item;\n \n    --------------"}, {"sha": "2fd5d320034ae5d0fa00c96413e5c89fa42e7348", "filename": "gcc/ada/g-table.adb", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fg-table.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fg-table.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-table.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -93,8 +93,7 @@ package body GNAT.Table is\n \n    procedure Append (New_Val : Table_Component_Type) is\n    begin\n-      Increment_Last;\n-      Table (Table_Index_Type (Last_Val)) := New_Val;\n+      Set_Item (Table_Index_Type (Last_Val + 1), New_Val);\n    end Append;\n \n    --------------------\n@@ -227,15 +226,67 @@ package body GNAT.Table is\n    --------------\n \n    procedure Set_Item\n-     (Index : Table_Index_Type;\n-      Item  : Table_Component_Type)\n+      (Index : Table_Index_Type;\n+       Item  : Table_Component_Type)\n    is\n+      --  If Item is a value within the current allocation, and we are going to\n+      --  reallocate, then we must preserve an intermediate copy here before\n+      --  calling Increment_Last. Otherwise, if Table_Component_Type is passed\n+      --  by reference, we are going to end up copying from storage that might\n+      --  have been deallocated from Increment_Last calling Reallocate.\n+\n+      subtype Allocated_Table_T is\n+        Table_Type (Table'First .. Table_Index_Type (Max + 1));\n+      --  A constrained table subtype one element larger than the currently\n+      --  allocated table.\n+\n+      Allocated_Table_Address : constant System.Address :=\n+                                  Table.all'Address;\n+      --  Used for address clause below (we can't use non-static expression\n+      --  Table.all'Address directly in the clause because some older versions\n+      --  of the compiler do not allow it).\n+\n+      Allocated_Table : Allocated_Table_T;\n+      pragma Import (Ada, Allocated_Table);\n+      for Allocated_Table'Address use Allocated_Table_Address;\n+      --  Allocated_Table represents the currently allocated array, plus\n+      --  one element (the supplementary element is used to have a\n+      --  convenient way of computing the address just past the end of the\n+      --  current allocation).\n+\n+      Need_Realloc : constant Boolean := Integer (Index) > Max;\n+      --  True if this operation requires storage reallocation (which may\n+      --  involve moving table contents around).\n+\n    begin\n-      if Integer (Index) > Last_Val then\n-         Set_Last (Index);\n-      end if;\n+      --  If we're going to reallocate, check wheter Item references an\n+      --  element of the currently allocated table.\n+\n+      if Need_Realloc\n+        and then Allocated_Table'Address <= Item'Address\n+        and then Item'Address <\n+                   Allocated_Table (Table_Index_Type (Max + 1))'Address\n+      then\n+         --  If so, save a copy on the stack because Increment_Last will\n+         --  reallocate storage and might deallocate the current table.\n+\n+         declare\n+            Item_Copy : constant Table_Component_Type := Item;\n+         begin\n+            Set_Last (Index);\n+            Table (Index) := Item_Copy;\n+         end;\n+\n+      else\n+         --  Here we know that either we won't reallocate (case of Index < Max)\n+         --  or that Item is not in the currently allocated table.\n \n-      Table (Index) := Item;\n+         if Integer (Index) > Last_Val then\n+            Set_Last (Index);\n+         end if;\n+\n+         Table (Index) := Item;\n+      end if;\n    end Set_Item;\n \n    --------------"}, {"sha": "a36fb5902e61e7b82dfe2fd4fa0d2de277c8c0f8", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -212,29 +212,20 @@ package body Repinfo is\n    ------------------------\n \n    function Create_Discrim_Ref (Discr : Entity_Id) return Node_Ref is\n-      N : constant Uint := Discriminant_Number (Discr);\n-      T : Nat;\n    begin\n-      Rep_Table.Increment_Last;\n-      T := Rep_Table.Last;\n-      Rep_Table.Table (T).Expr := Discrim_Val;\n-      Rep_Table.Table (T).Op1  := N;\n-      Rep_Table.Table (T).Op2  := No_Uint;\n-      Rep_Table.Table (T).Op3  := No_Uint;\n-      return UI_From_Int (-T);\n+      return Create_Node\n+        (Expr => Discrim_Val,\n+         Op1  => Discriminant_Number (Discr));\n    end Create_Discrim_Ref;\n \n    ---------------------------\n    -- Create_Dynamic_SO_Ref --\n    ---------------------------\n \n    function Create_Dynamic_SO_Ref (E : Entity_Id) return Dynamic_SO_Ref is\n-      T : Nat;\n    begin\n-      Dynamic_SO_Entity_Table.Increment_Last;\n-      T := Dynamic_SO_Entity_Table.Last;\n-      Dynamic_SO_Entity_Table.Table (T) := E;\n-      return UI_From_Int (-T);\n+      Dynamic_SO_Entity_Table.Append (E);\n+      return UI_From_Int (-Dynamic_SO_Entity_Table.Last);\n    end Create_Dynamic_SO_Ref;\n \n    -----------------\n@@ -247,15 +238,13 @@ package body Repinfo is\n       Op2  : Node_Ref_Or_Val := No_Uint;\n       Op3  : Node_Ref_Or_Val := No_Uint) return Node_Ref\n    is\n-      T : Nat;\n    begin\n-      Rep_Table.Increment_Last;\n-      T := Rep_Table.Last;\n-      Rep_Table.Table (T).Expr := Expr;\n-      Rep_Table.Table (T).Op1  := Op1;\n-      Rep_Table.Table (T).Op2  := Op2;\n-      Rep_Table.Table (T).Op3  := Op3;\n-      return UI_From_Int (-T);\n+      Rep_Table.Append (\n+        (Expr => Expr,\n+         Op1  => Op1,\n+         Op2  => Op2,\n+         Op3  => Op3));\n+      return UI_From_Int (-Rep_Table.Last);\n    end Create_Node;\n \n    ---------------------------"}, {"sha": "137ac4ea364c1977d07d9d5c4ccc3ee291211de9", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -1906,14 +1906,13 @@ package body Sem_Elab is\n       --  Delay this call if we are still delaying calls\n \n       if Delaying_Elab_Checks then\n-         Delay_Check.Increment_Last;\n-         Delay_Check.Table (Delay_Check.Last) :=\n+         Delay_Check.Append (\n            (N              => N,\n             E              => E,\n             Orig_Ent       => Orig_Ent,\n             Curscop        => Current_Scope,\n             Outer_Scope    => Outer_Scope,\n-            From_Elab_Code => From_Elab_Code);\n+            From_Elab_Code => From_Elab_Code));\n          return;\n \n       --  Otherwise, call phase 2 continuation right now\n@@ -2031,8 +2030,7 @@ package body Sem_Elab is\n          Outer_Level_Sloc := Loc;\n       end if;\n \n-      Elab_Visited.Increment_Last;\n-      Elab_Visited.Table (Elab_Visited.Last) := E;\n+      Elab_Visited.Append (E);\n \n       --  If the call is to a function that renames a literal, no check\n       --  is needed.\n@@ -2076,9 +2074,7 @@ package body Sem_Elab is\n       else\n          pragma Assert (Nkind (Sbody) = N_Subprogram_Body);\n \n-         Elab_Call.Increment_Last;\n-         Elab_Call.Table (Elab_Call.Last).Cloc := Loc;\n-         Elab_Call.Table (Elab_Call.Last).Ent  := E;\n+         Elab_Call.Append ((Cloc => Loc, Ent => E));\n \n          if Debug_Flag_LL then\n             Write_Str (\"Elab_Call.Last = \");"}, {"sha": "9b13e55d94456efbfdcbe053ebd3e71f7062cd51", "filename": "gcc/ada/sinput-d.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsinput-d.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsinput-d.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-d.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,14 +62,13 @@ package body Sinput.D is\n    is\n    begin\n       Loc := Source_File.Table (Source_File.Last).Source_Last + 1;\n-      Source_File.Increment_Last;\n+      Source_File.Append (Source_File.Table (Source));\n       Dfile := Source_File.Last;\n \n       declare\n          S : Source_File_Record renames Source_File.Table (Dfile);\n \n       begin\n-         S := Source_File.Table (Source);\n          S.Full_Debug_Name   := Create_Debug_File (S.File_Name);\n          S.Debug_Source_Name := Strip_Directory (S.Full_Debug_Name);\n          S.Source_First      := Loc;"}, {"sha": "385bd8d2af3a362f757af0e5594c7a78c0d2913a", "filename": "gcc/ada/sinput-l.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -132,10 +132,9 @@ package body Sinput.L is\n       A.Lo := Source_File.Table (Xold).Source_First;\n       A.Hi := Source_File.Table (Xold).Source_Last;\n \n-      Source_File.Increment_Last;\n+      Source_File.Append (Source_File.Table (Xold));\n       Xnew := Source_File.Last;\n \n-      Source_File.Table (Xnew)               := Source_File.Table (Xold);\n       Source_File.Table (Xnew).Inlined_Body  := Inlined_Body;\n       Source_File.Table (Xnew).Instantiation := Sloc (Inst_Node);\n       Source_File.Table (Xnew).Template      := Xold;\n@@ -148,6 +147,7 @@ package body Sinput.L is\n         Source_File.Table (Xnew - 1).Source_Last + 1;\n       A.Adjust := Source_File.Table (Xnew).Source_First - A.Lo;\n       Source_File.Table (Xnew).Source_Last := A.Hi + A.Adjust;\n+\n       Set_Source_File_Index_Table (Xnew);\n \n       Source_File.Table (Xnew).Sloc_Adjust :="}, {"sha": "e27200902641b468756fdcefe76a6a88f09b5626", "filename": "gcc/ada/stringt.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fstringt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fstringt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -139,9 +139,7 @@ package body Stringt is\n \n    procedure Start_String is\n    begin\n-      Strings.Increment_Last;\n-      Strings.Table (Strings.Last).String_Index := String_Chars.Last + 1;\n-      Strings.Table (Strings.Last).Length := 0;\n+      Strings.Append ((String_Index => String_Chars.Last + 1, Length => 0));\n    end Start_String;\n \n    --  Version to start from initially stored string\n@@ -166,9 +164,8 @@ package body Stringt is\n            String_Chars.Last + 1;\n \n          for J in 1 .. Strings.Table (S).Length loop\n-            String_Chars.Increment_Last;\n-            String_Chars.Table (String_Chars.Last) :=\n-              String_Chars.Table (Strings.Table (S).String_Index + (J - 1));\n+            String_Chars.Append\n+              (String_Chars.Table (Strings.Table (S).String_Index + (J - 1)));\n          end loop;\n       end if;\n \n@@ -183,8 +180,7 @@ package body Stringt is\n \n    procedure Store_String_Char (C : Char_Code) is\n    begin\n-      String_Chars.Increment_Last;\n-      String_Chars.Table (String_Chars.Last) := C;\n+      String_Chars.Append (C);\n       Strings.Table (Strings.Last).Length :=\n         Strings.Table (Strings.Last).Length + 1;\n    end Store_String_Char;"}, {"sha": "ded1a94ff24e0885be16b4cc26df9a79571089ea", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -119,9 +119,7 @@ package body Switch.M is\n          --  Add a new component in the table.\n \n          Switches (Last) := new String'(S);\n-         Normalized_Switches.Increment_Last;\n-         Normalized_Switches.Table (Normalized_Switches.Last) :=\n-           Switches (Last);\n+         Normalized_Switches.Append (Switches (Last));\n       end Add_Switch_Component;\n \n    --  Start of processing for Normalize_Compiler_Switches"}, {"sha": "cb88fe9ca6f5dafbc131d57c0b963beb0499552d", "filename": "gcc/ada/symbols-processing-vms-alpha.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -212,9 +212,7 @@ package body Processing is\n \n                         --  Put the new symbol in the table\n \n-                        Symbol_Table.Increment_Last (Complete_Symbols);\n-                        Complete_Symbols.Table\n-                          (Symbol_Table.Last (Complete_Symbols)) := S_Data;\n+                        Symbol_Table.Append (Complete_Symbols, S_Data);\n                      end;\n                   end if;\n "}, {"sha": "80b0762f663b9f1a8f290d7044e27790cc2944b7", "filename": "gcc/ada/symbols-processing-vms-ia64.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -362,9 +362,7 @@ package body Processing is\n \n                   --  Put the new symbol in the table\n \n-                  Symbol_Table.Increment_Last (Complete_Symbols);\n-                  Complete_Symbols.Table\n-                    (Symbol_Table.Last (Complete_Symbols)) := S_Data;\n+                  Symbol_Table.Append (Complete_Symbols, S_Data);\n                end;\n             end if;\n          end if;"}, {"sha": "2b955ca22fbc883fc8d7d6f6fa3649c4606fa4f6", "filename": "gcc/ada/symbols-vms.adb", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsymbols-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Fsymbols-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-vms.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -246,14 +246,12 @@ package body Symbols is\n                if Last > Symbol_Vector'Length + Equal_Data'Length and then\n                  Line (Last - Equal_Data'Length + 1 .. Last) = Equal_Data\n                then\n-                  Symbol_Table.Increment_Last (Original_Symbols);\n-                  Original_Symbols.Table\n-                    (Symbol_Table.Last (Original_Symbols)) :=\n-                      (Name =>\n-                         new String'(Line (Symbol_Vector'Length + 1 ..\n-                                           Last - Equal_Data'Length)),\n-                       Kind => Data,\n-                       Present => True);\n+                  Symbol_Table.Append (Original_Symbols,\n+                    (Name =>\n+                       new String'(Line (Symbol_Vector'Length + 1 ..\n+                                         Last - Equal_Data'Length)),\n+                     Kind => Data,\n+                     Present => True));\n \n                --  SYMBOL_VECTOR=(<symbol>=PROCEDURE)\n \n@@ -262,14 +260,12 @@ package body Symbols is\n                   Line (Last - Equal_Procedure'Length + 1 .. Last) =\n                                                               Equal_Procedure\n                then\n-                  Symbol_Table.Increment_Last (Original_Symbols);\n-                  Original_Symbols.Table\n-                    (Symbol_Table.Last (Original_Symbols)) :=\n+                  Symbol_Table.Append (Original_Symbols,\n                     (Name =>\n                        new String'(Line (Symbol_Vector'Length + 1 ..\n                                          Last - Equal_Procedure'Length)),\n                      Kind => Proc,\n-                     Present => True);\n+                     Present => True));\n \n                --  Anything else is incorrectly formatted\n \n@@ -536,9 +532,7 @@ package body Symbols is\n                      Soft_Minor_ID := False;\n                   end if;\n \n-                  Symbol_Table.Increment_Last (Original_Symbols);\n-                  Original_Symbols.Table\n-                    (Symbol_Table.Last (Original_Symbols)) := S_Data;\n+                  Symbol_Table.Append (Original_Symbols, S_Data);\n                   Complete_Symbols.Table (Index).Present := False;\n                end if;\n             end loop;"}, {"sha": "273be819e2e565db32241b4543d09a558318ff2e", "filename": "gcc/ada/table.adb", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Ftable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6f10a19473c4c174bcb8295163be080ae6f64e/gcc%2Fada%2Ftable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.adb?ref=1d6f10a19473c4c174bcb8295163be080ae6f64e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -82,8 +82,7 @@ package body Table is\n \n       procedure Append (New_Val : Table_Component_Type) is\n       begin\n-         Increment_Last;\n-         Table (Table_Index_Type (Last_Val)) := New_Val;\n+         Set_Item (Table_Index_Type (Last_Val + 1), New_Val);\n       end Append;\n \n       --------------------\n@@ -268,12 +267,65 @@ package body Table is\n          (Index : Table_Index_Type;\n           Item  : Table_Component_Type)\n       is\n+         --  If Item is a value within the current allocation, and we are going\n+         --  to reallocate, then we must preserve an intermediate copy here\n+         --  before calling Increment_Last. Otherwise, if Table_Component_Type\n+         --  is passed by reference, we are going to end up copying from\n+         --  storage that might have been deallocated from Increment_Last\n+         --  calling Reallocate.\n+\n+         subtype Allocated_Table_T is\n+           Table_Type (Table'First .. Table_Index_Type (Max + 1));\n+         --  A constrained table subtype one element larger than the currently\n+         --  allocated table.\n+\n+         Allocated_Table_Address : constant System.Address :=\n+                                     Table.all'Address;\n+         --  Used for address clause below (we can't use non-static expression\n+         --  Table.all'Address directly in the clause because some older\n+         --  versions of the compiler do not allow it).\n+\n+         Allocated_Table : Allocated_Table_T;\n+         pragma Import (Ada, Allocated_Table);\n+         for Allocated_Table'Address use Allocated_Table_Address;\n+         --  Allocated_Table represents the currently allocated array, plus one\n+         --  element (the supplementary element is used to have a convenient\n+         --  way of computing the address just past the end of the current\n+         --  allocation).\n+\n+         Need_Realloc : constant Boolean := Int (Index) > Max;\n+         --  True if this operation requires storage reallocation (which may\n+         --  involve moving table contents around).\n+\n       begin\n-         if Int (Index) > Max then\n-            Set_Last (Index);\n-         end if;\n+         --  If we're going to reallocate, check wheter Item references an\n+         --  element of the currently allocated table.\n+\n+         if Need_Realloc\n+           and then Allocated_Table'Address <= Item'Address\n+           and then Item'Address <\n+                      Allocated_Table (Table_Index_Type (Max + 1))'Address\n+         then\n+            --  If so, save a copy on the stack because Increment_Last will\n+            --  reallocate storage and might deallocate the current table.\n+\n+            declare\n+               Item_Copy : constant Table_Component_Type := Item;\n+            begin\n+               Set_Last (Index);\n+               Table (Index) := Item_Copy;\n+            end;\n+\n+         else\n+            --  Here we know that either we won't reallocate (case of Index <\n+            --  Max) or that Item is not in the currently allocated table.\n \n-         Table (Index) := Item;\n+            if Int (Index) > Last_Val then\n+               Set_Last (Index);\n+            end if;\n+\n+            Table (Index) := Item;\n+         end if;\n       end Set_Item;\n \n       --------------\n@@ -284,6 +336,7 @@ package body Table is\n       begin\n          if Int (New_Val) < Last_Val then\n             Last_Val := Int (New_Val);\n+\n          else\n             Last_Val := Int (New_Val);\n "}]}