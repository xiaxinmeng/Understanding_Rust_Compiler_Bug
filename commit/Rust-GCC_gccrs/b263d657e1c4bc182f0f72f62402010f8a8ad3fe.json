{"sha": "b263d657e1c4bc182f0f72f62402010f8a8ad3fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI2M2Q2NTdlMWM0YmMxODJmMGY3MmY2MjQwMjAxMGY4YThhZDNmZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2017-08-17T02:03:03Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2017-08-17T02:03:03Z"}, "message": "[RS6000] PR 80938, Don't emit frame info for regs that don't need saving\n\nIt is possible when using out-of-line register saves or store multiple\nto save some registers unnecessarily, for example one reg in the block\nsaved might be unused.  We don't need to emit frame info for those\nregisters as that just bloats the info, and also can result in an ICE\nwhen shrink-wrap gives multiple paths through the function saving\ndifferent sets of registers.  Join points need to have identical frame\nregister save state regardless of the path taken.\n\nThis patch reverts the previous fix for PR80939 \"Use SAVE_MULTIPLE\nonly if we restore what it saves (PR80938)\" and instead fixes the PR\nby correcting the frame info.  The change to rs6000_savres_strategy\nis an optimization, but note that it hides the underlying problem in\nthe PR testcase.\n\n\tPR target/80938\n\t* config/rs6000/rs6000.c (rs6000_savres_strategy): Revert 2017-08-09.\n\tDon't use store multiple if only one reg needs saving.\n\t(interesting_frame_related_regno): New function.\n\t(rs6000_frame_related): Don't emit frame info for regs that\n\tdon't need saving.\n\t(rs6000_emit_epilogue): Likewise.\n\nFrom-SVN: r251140", "tree": {"sha": "1ccbea2a987c2a4b66260de8cd45d3235925df34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ccbea2a987c2a4b66260de8cd45d3235925df34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b263d657e1c4bc182f0f72f62402010f8a8ad3fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b263d657e1c4bc182f0f72f62402010f8a8ad3fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b263d657e1c4bc182f0f72f62402010f8a8ad3fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b263d657e1c4bc182f0f72f62402010f8a8ad3fe/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "706028a50700ab9d1155b88a59b3e3eac74241e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/706028a50700ab9d1155b88a59b3e3eac74241e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/706028a50700ab9d1155b88a59b3e3eac74241e6"}], "stats": {"total": 129, "additions": 86, "deletions": 43}, "files": [{"sha": "658a8e28588afb60cf086dbad3e8c5df81479336", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b263d657e1c4bc182f0f72f62402010f8a8ad3fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b263d657e1c4bc182f0f72f62402010f8a8ad3fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b263d657e1c4bc182f0f72f62402010f8a8ad3fe", "patch": "@@ -1,3 +1,13 @@\n+2017-08-17  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/80938\n+\t* config/rs6000/rs6000.c (rs6000_savres_strategy): Revert 2017-08-09.\n+\tDon't use store multiple if only one reg needs saving.\n+\t(interesting_frame_related_regno): New function.\n+\t(rs6000_frame_related): Don't emit frame info for regs that\n+\tdon't need saving.\n+\t(rs6000_emit_epilogue): Likewise.\n+\n 2017-08-16  Nathan Sidwell  <nathan@acm.org>\n \n \t* tree-core.h (tree_type_non_common): Rename binfo to lang_1."}, {"sha": "5ae76136c2464dcc0434b9a73df629f7271a885a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 76, "deletions": 43, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b263d657e1c4bc182f0f72f62402010f8a8ad3fe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b263d657e1c4bc182f0f72f62402010f8a8ad3fe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b263d657e1c4bc182f0f72f62402010f8a8ad3fe", "patch": "@@ -24445,20 +24445,36 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t   && flag_shrink_wrap_separate\n \t   && optimize_function_for_speed_p (cfun)))\n     {\n-      /* Prefer store multiple for saves over out-of-line routines,\n-\t since the store-multiple instruction will always be smaller.  */\n-      strategy |= SAVE_INLINE_GPRS | SAVE_MULTIPLE;\n-\n-      /* The situation is more complicated with load multiple.  We'd\n-\t prefer to use the out-of-line routines for restores, since the\n-\t \"exit\" out-of-line routines can handle the restore of LR and the\n-\t frame teardown.  However if doesn't make sense to use the\n-\t out-of-line routine if that is the only reason we'd need to save\n-\t LR, and we can't use the \"exit\" out-of-line gpr restore if we\n-\t have saved some fprs; In those cases it is advantageous to use\n-\t load multiple when available.  */\n-      if (info->first_fp_reg_save != 64 || !lr_save_p)\n-\tstrategy |= REST_INLINE_GPRS | REST_MULTIPLE;\n+      int count = 0;\n+      for (int i = info->first_gp_reg_save; i < 32; i++)\n+\tif (save_reg_p (i))\n+\t  count++;\n+\n+      if (count <= 1)\n+\t/* Don't use store multiple if only one reg needs to be\n+\t   saved.  This can occur for example when the ABI_V4 pic reg\n+\t   (r30) needs to be saved to make calls, but r31 is not\n+\t   used.  */\n+\tstrategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;\n+      else\n+\t{\n+\t  /* Prefer store multiple for saves over out-of-line\n+\t     routines, since the store-multiple instruction will\n+\t     always be smaller.  */\n+\t  strategy |= SAVE_INLINE_GPRS | SAVE_MULTIPLE;\n+\n+\t  /* The situation is more complicated with load multiple.\n+\t     We'd prefer to use the out-of-line routines for restores,\n+\t     since the \"exit\" out-of-line routines can handle the\n+\t     restore of LR and the frame teardown.  However if doesn't\n+\t     make sense to use the out-of-line routine if that is the\n+\t     only reason we'd need to save LR, and we can't use the\n+\t     \"exit\" out-of-line gpr restore if we have saved some\n+\t     fprs; In those cases it is advantageous to use load\n+\t     multiple when available.  */\n+\t  if (info->first_fp_reg_save != 64 || !lr_save_p)\n+\t    strategy |= REST_INLINE_GPRS | REST_MULTIPLE;\n+\t}\n     }\n \n   /* Using the \"exit\" out-of-line routine does not improve code size\n@@ -24467,21 +24483,6 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n   else if (!lr_save_p && info->first_gp_reg_save > 29)\n     strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;\n \n-  /* We can only use save multiple if we need to save all the registers from\n-     first_gp_reg_save.  Otherwise, the CFI gets messed up (we save some\n-     register we do not restore).  */\n-  if (strategy & SAVE_MULTIPLE)\n-    {\n-      int i;\n-\n-      for (i = info->first_gp_reg_save; i < 32; i++)\n-\tif (fixed_reg_p (i) || !save_reg_p (i))\n-\t  {\n-\t    strategy &= ~SAVE_MULTIPLE;\n-\t    break;\n-\t  }\n-    }\n-\n   /* Don't ever restore fixed regs.  */\n   if ((strategy & (REST_INLINE_GPRS | REST_MULTIPLE)) != REST_INLINE_GPRS)\n     for (int i = info->first_gp_reg_save; i < 32; i++)\n@@ -25654,6 +25655,38 @@ output_probe_stack_range (rtx reg1, rtx reg2)\n   return \"\";\n }\n \n+/* This function is called when rs6000_frame_related is processing\n+   SETs within a PARALLEL, and returns whether the REGNO save ought to\n+   be marked RTX_FRAME_RELATED_P.  The PARALLELs involved are those\n+   for out-of-line register save functions, store multiple, and the\n+   Darwin world_save.  They may contain registers that don't really\n+   need saving.  */\n+\n+static bool\n+interesting_frame_related_regno (unsigned int regno)\n+{\n+  /* Saves apparently of r0 are actually saving LR.  It doesn't make\n+     sense to substitute the regno here to test save_reg_p (LR_REGNO).\n+     We *know* LR needs saving, and dwarf2cfi.c is able to deduce that\n+     (set (mem) (r0)) is saving LR from a prior (set (r0) (lr)) marked\n+     as frame related.  */\n+  if (regno == 0)\n+    return true;\n+  /* If we see CR2 then we are here on a Darwin world save.  Saves of\n+     CR2 signify the whole CR is being saved.  This is a long-standing\n+     ABI wart fixed by ELFv2.  As for r0/lr there is no need to check\n+     that CR needs to be saved.  */\n+  if (regno == CR2_REGNO)\n+    return true;\n+  /* Omit frame info for any user-defined global regs.  If frame info\n+     is supplied for them, frame unwinding will restore a user reg.\n+     Also omit frame info for any reg we don't need to save, as that\n+     bloats frame info and can cause problems with shrink wrapping.\n+     Since global regs won't be seen as needing to be saved, both of\n+     these conditions are covered by save_reg_p.  */\n+  return save_reg_p (regno);\n+}\n+\n /* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced\n    with (plus:P (reg 1) VAL), and with REG2 replaced with REPL2 if REG2\n    is not NULL.  It would be nice if dwarf2out_frame_debug_expr could\n@@ -25688,13 +25721,8 @@ rs6000_frame_related (rtx_insn *insn, rtx reg, HOST_WIDE_INT val,\n \t    {\n \t      rtx set = XVECEXP (pat, 0, i);\n \n-\t      /* If this PARALLEL has been emitted for out-of-line\n-\t\t register save functions, or store multiple, then omit\n-\t\t eh_frame info for any user-defined global regs.  If\n-\t\t eh_frame info is supplied, frame unwinding will\n-\t\t restore a user reg.  */\n \t      if (!REG_P (SET_SRC (set))\n-\t\t  || !fixed_reg_p (REGNO (SET_SRC (set))))\n+\t\t  || interesting_frame_related_regno (REGNO (SET_SRC (set))))\n \t\tRTX_FRAME_RELATED_P (set) = 1;\n \t    }\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -25731,9 +25759,8 @@ rs6000_frame_related (rtx_insn *insn, rtx reg, HOST_WIDE_INT val,\n \t      set = simplify_replace_rtx (set, reg2, repl2);\n \t    XVECEXP (pat, 0, i) = set;\n \n-\t    /* Omit eh_frame info for any user-defined global regs.  */\n \t    if (!REG_P (SET_SRC (set))\n-\t\t|| !fixed_reg_p (REGNO (SET_SRC (set))))\n+\t\t|| interesting_frame_related_regno (REGNO (SET_SRC (set))))\n \t      RTX_FRAME_RELATED_P (set) = 1;\n \t  }\n     }\n@@ -27956,7 +27983,8 @@ rs6000_emit_epilogue (int sibcall)\n \t  RTVEC_ELT (p, j++)\n \t    = gen_frame_load (reg,\n \t\t\t      frame_reg_rtx, info->gp_save_offset + reg_size * i);\n-\t  if (flag_shrink_wrap)\n+\t  if (flag_shrink_wrap\n+\t      && save_reg_p (info->first_gp_reg_save + i))\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n       for (i = 0; info->first_altivec_reg_save + i <= LAST_ALTIVEC_REGNO; i++)\n@@ -27965,7 +27993,8 @@ rs6000_emit_epilogue (int sibcall)\n \t  RTVEC_ELT (p, j++)\n \t    = gen_frame_load (reg,\n \t\t\t      frame_reg_rtx, info->altivec_save_offset + 16 * i);\n-\t  if (flag_shrink_wrap)\n+\t  if (flag_shrink_wrap\n+\t      && save_reg_p (info->first_altivec_reg_save + i))\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n       for (i = 0; info->first_fp_reg_save + i <= 63; i++)\n@@ -27975,7 +28004,8 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t info->first_fp_reg_save + i);\n \t  RTVEC_ELT (p, j++)\n \t    = gen_frame_load (reg, frame_reg_rtx, info->fp_save_offset + 8 * i);\n-\t  if (flag_shrink_wrap)\n+\t  if (flag_shrink_wrap\n+\t      && save_reg_p (info->first_fp_reg_save + i))\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n       RTVEC_ELT (p, j++)\n@@ -28096,7 +28126,8 @@ rs6000_emit_epilogue (int sibcall)\n \t    && (flag_shrink_wrap\n \t\t|| (offset_below_red_zone_p\n \t\t    (info->altivec_save_offset\n-\t\t     + 16 * (i - info->first_altivec_reg_save)))))\n+\t\t     + 16 * (i - info->first_altivec_reg_save))))\n+\t    && save_reg_p (i))\n \t  {\n \t    rtx reg = gen_rtx_REG (V4SImode, i);\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n@@ -28308,7 +28339,8 @@ rs6000_emit_epilogue (int sibcall)\n       for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n \tif (((strategy & REST_INLINE_VRS) == 0\n \t     || (info->vrsave_mask & ALTIVEC_REG_BIT (i)) != 0)\n-\t    && (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap))\n+\t    && (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n+\t    && save_reg_p (i))\n \t  {\n \t    rtx reg = gen_rtx_REG (V4SImode, i);\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n@@ -28654,7 +28686,8 @@ rs6000_emit_epilogue (int sibcall)\n \n \t  RTVEC_ELT (p, elt++)\n \t    = gen_frame_load (reg, sp_reg_rtx, info->fp_save_offset + 8 * i);\n-\t  if (flag_shrink_wrap)\n+\t  if (flag_shrink_wrap\n+\t      && save_reg_p (info->first_fp_reg_save + i))\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n "}]}