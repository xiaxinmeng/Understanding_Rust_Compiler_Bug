{"sha": "245f1bfacf4af13a28da3700f110090c20139b4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ1ZjFiZmFjZjRhZjEzYTI4ZGEzNzAwZjExMDA5MGMyMDEzOWI0ZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-20T16:50:36Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-20T16:50:36Z"}, "message": "bb-reorder.c, [...]: Replace calls via (*targetm.foo) () with targetm.foo ().\n\n\t* bb-reorder.c, bt-load.c, c-decl.c, cfgcleanup.c, coverage.c,\n\tdwarf2asm.c, ifcvt.c, stor-layout.c, varasm.c: Replace calls\n\tvia (*targetm.foo) () with targetm.foo ().\n\nFrom-SVN: r79750", "tree": {"sha": "5727d10bba8606030ca18bedde7b44e13e841310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5727d10bba8606030ca18bedde7b44e13e841310"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/245f1bfacf4af13a28da3700f110090c20139b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245f1bfacf4af13a28da3700f110090c20139b4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/245f1bfacf4af13a28da3700f110090c20139b4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245f1bfacf4af13a28da3700f110090c20139b4d/comments", "author": null, "committer": null, "parents": [{"sha": "09b844e33c3f479d9f60b001bcb081521d911629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b844e33c3f479d9f60b001bcb081521d911629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09b844e33c3f479d9f60b001bcb081521d911629"}], "stats": {"total": 50, "additions": 28, "deletions": 22}, "files": [{"sha": "dc9178444dab3ab76467868c02a2e9c450836bc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -1,3 +1,9 @@\n+2004-03-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* bb-reorder.c, bt-load.c, c-decl.c, cfgcleanup.c, coverage.c,\n+\tdwarf2asm.c, ifcvt.c, stor-layout.c, varasm.c: Replace calls\n+\tvia (*targetm.foo) () with targetm.foo ().\n+\n 2004-03-20  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR other/14630"}, {"sha": "74f93203f23c6fdadbd1257f9635cb0a4e361ccb", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -1075,7 +1075,7 @@ reorder_basic_blocks (void)\n   if (n_basic_blocks <= 1)\n     return;\n \n-  if ((* targetm.cannot_modify_jumps_p) ())\n+  if (targetm.cannot_modify_jumps_p ())\n     return;\n \n   timevar_push (TV_REORDER_BLOCKS);"}, {"sha": "1a81c456e3a72784bbdb1e8fd7da87d7ba1375bc", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -1435,7 +1435,7 @@ branch_target_load_optimize (rtx insns, bool after_prologue_epilogue_gen)\n       /* Dominator info is also needed for migrate_btr_def.  */\n       calculate_dominance_info (CDI_DOMINATORS);\n       migrate_btr_defs (class,\n-\t\t       ((*targetm.branch_target_register_callee_saved)\n+\t\t       (targetm.branch_target_register_callee_saved\n \t\t\t(after_prologue_epilogue_gen)));\n \n       free_dominance_info (CDI_DOMINATORS);"}, {"sha": "46f352b3a62637c75dba2b6181bd86bd1432e86d", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -6137,17 +6137,17 @@ c_expand_body_1 (tree fndecl, int nested_p)\n   if (DECL_STATIC_CONSTRUCTOR (fndecl))\n     {\n       if (targetm.have_ctors_dtors)\n-\t(* targetm.asm_out.constructor) (XEXP (DECL_RTL (fndecl), 0),\n-\t\t\t\t         DEFAULT_INIT_PRIORITY);\n+\ttargetm.asm_out.constructor (XEXP (DECL_RTL (fndecl), 0),\n+\t\t\t\t     DEFAULT_INIT_PRIORITY);\n       else\n \tstatic_ctors = tree_cons (NULL_TREE, fndecl, static_ctors);\n     }\n \n   if (DECL_STATIC_DESTRUCTOR (fndecl))\n     {\n       if (targetm.have_ctors_dtors)\n-\t(* targetm.asm_out.destructor) (XEXP (DECL_RTL (fndecl), 0),\n-\t\t\t\t        DEFAULT_INIT_PRIORITY);\n+\ttargetm.asm_out.destructor (XEXP (DECL_RTL (fndecl), 0),\n+\t\t\t\t    DEFAULT_INIT_PRIORITY);\n       else\n \tstatic_dtors = tree_cons (NULL_TREE, fndecl, static_dtors);\n     }"}, {"sha": "f40d2c1525bff2c49910eaad0c6c419df9c17bff", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -1751,7 +1751,7 @@ try_optimize_cfg (int mode)\n   if (mode & (CLEANUP_UPDATE_LIFE | CLEANUP_CROSSJUMP | CLEANUP_THREADING))\n     clear_bb_flags ();\n \n-  if (! (* targetm.cannot_modify_jumps_p) ())\n+  if (! targetm.cannot_modify_jumps_p ())\n     {\n       first_pass = true;\n       /* Attempt to merge blocks as made possible by edge removal.  If"}, {"sha": "88d677c78b84d2b8acb55725bbb4573bbb707e48", "filename": "gcc/coverage.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -926,8 +926,8 @@ create_coverage (void)\n   current_function_decl = NULL_TREE;\n \n   if (targetm.have_ctors_dtors)\n-    (* targetm.asm_out.constructor) (XEXP (DECL_RTL (ctor), 0),\n-\t\t\t\t     DEFAULT_INIT_PRIORITY);\n+    targetm.asm_out.constructor (XEXP (DECL_RTL (ctor), 0),\n+\t\t\t\t DEFAULT_INIT_PRIORITY);\n }\n \f\n /* Perform file-level initialization. Read in data file, generate name"}, {"sha": "73aaabe2c165b4ef7e2e8f84cf80d2566dbe9413", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -707,7 +707,7 @@ dw2_force_const_mem (rtx x)\n   if (GET_CODE (x) != SYMBOL_REF)\n     abort ();\n \n-  str = (* targetm.strip_name_encoding) (XSTR (x, 0));\n+  str = targetm.strip_name_encoding (XSTR (x, 0));\n   node = splay_tree_lookup (indirect_pool, (splay_tree_key) str);\n   if (node)\n     decl = (tree) node->value;"}, {"sha": "651f2a691a5d55ca3d196b3793be73bacc1e4b54", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -3263,7 +3263,7 @@ if_convert (int x_life_data_ok)\n   num_true_changes = 0;\n   life_data_ok = (x_life_data_ok != 0);\n \n-  if (! (* targetm.cannot_modify_jumps_p) ())\n+  if (! targetm.cannot_modify_jumps_p ())\n     mark_loop_exit_edges ();\n \n   /* Free up basic_block_for_insn so that we don't have to keep it"}, {"sha": "ab5345cf0d1b9f9e48ea0c28d1fe8dd54f64bd45", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -694,7 +694,7 @@ update_alignment_for_field (record_layout_info rli, tree field,\n   /* Record must have at least as much alignment as any field.\n      Otherwise, the alignment of the field within the record is\n      meaningless.  */\n-  if (is_bitfield && (* targetm.ms_bitfield_layout_p) (rli->t))\n+  if (is_bitfield && targetm.ms_bitfield_layout_p (rli->t))\n     {\n       /* Here, the alignment of the underlying type of a bitfield can\n \t affect the alignment of a record; even a zero-sized field\n@@ -914,7 +914,7 @@ place_field (record_layout_info rli, tree field)\n      variable-sized fields, we need not worry about compatibility.  */\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n   if (PCC_BITFIELD_TYPE_MATTERS\n-      && ! (* targetm.ms_bitfield_layout_p) (rli->t)\n+      && ! targetm.ms_bitfield_layout_p (rli->t)\n       && TREE_CODE (field) == FIELD_DECL\n       && type != error_mark_node\n       && DECL_BIT_FIELD (field)\n@@ -947,7 +947,7 @@ place_field (record_layout_info rli, tree field)\n \n #ifdef BITFIELD_NBYTES_LIMITED\n   if (BITFIELD_NBYTES_LIMITED\n-      && ! (* targetm.ms_bitfield_layout_p) (rli->t)\n+      && ! targetm.ms_bitfield_layout_p (rli->t)\n       && TREE_CODE (field) == FIELD_DECL\n       && type != error_mark_node\n       && DECL_BIT_FIELD_TYPE (field)\n@@ -998,7 +998,7 @@ place_field (record_layout_info rli, tree field)\n      Note: for compatibility, we use the type size, not the type alignment\n      to determine alignment, since that matches the documentation */\n \n-  if ((* targetm.ms_bitfield_layout_p) (rli->t)\n+  if (targetm.ms_bitfield_layout_p (rli->t)\n        && ((DECL_BIT_FIELD_TYPE (field) && ! DECL_PACKED (field))\n \t  || (rli->prev_field && ! DECL_PACKED (rli->prev_field))))\n     {"}, {"sha": "a518dd765ae48baa313755a8cd9e7d457fc08129", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f1bfacf4af13a28da3700f110090c20139b4d/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=245f1bfacf4af13a28da3700f110090c20139b4d", "patch": "@@ -375,7 +375,7 @@ named_section (tree decl, const char *name, int reloc)\n   if (name == NULL)\n     name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n \n-  flags = (* targetm.section_type_flags) (decl, name, reloc);\n+  flags = targetm.section_type_flags (decl, name, reloc);\n \n   /* Sanity check user variables for flag changes.  Non-user\n      section flag changes will abort in named_section_flags.\n@@ -727,7 +727,7 @@ make_decl_rtl (tree decl, const char *asmspec)\n       /* Let the target reassign the RTL if it wants.\n \t This is necessary, for example, when one machine specific\n \t decl attribute overrides another.  */\n-      (* targetm.encode_section_info) (decl, DECL_RTL (decl), false);\n+      targetm.encode_section_info (decl, DECL_RTL (decl), false);\n       return;\n     }\n \n@@ -827,7 +827,7 @@ make_decl_rtl (tree decl, const char *asmspec)\n      such as that it is a function name.\n      If the name is changed, the macro ASM_OUTPUT_LABELREF\n      will have to know how to strip this information.  */\n-  (* targetm.encode_section_info) (decl, DECL_RTL (decl), true);\n+  targetm.encode_section_info (decl, DECL_RTL (decl), true);\n }\n \n /* Make the rtl for variable VAR be volatile.\n@@ -1013,7 +1013,7 @@ notice_global_symbol (tree decl)\n       char *name;\n       rtx decl_rtl = DECL_RTL (decl);\n \n-      p = (* targetm.strip_name_encoding) (XSTR (XEXP (decl_rtl, 0), 0));\n+      p = targetm.strip_name_encoding (XSTR (XEXP (decl_rtl, 0), 0));\n       name = xstrdup (p);\n \n       *type = name;\n@@ -1657,7 +1657,7 @@ assemble_name (FILE *file, const char *name)\n   const char *real_name;\n   tree id;\n \n-  real_name = (* targetm.strip_name_encoding) (name);\n+  real_name = targetm.strip_name_encoding (name);\n \n   id = maybe_get_identifier (real_name);\n   if (id)\n@@ -4204,7 +4204,7 @@ maybe_assemble_visibility (tree decl)\n   enum symbol_visibility vis = DECL_VISIBILITY (decl);\n \n   if (vis != VISIBILITY_DEFAULT)\n-    (* targetm.asm_out.visibility) (decl, vis);\n+    targetm.asm_out.visibility (decl, vis);\n }\n \n /* Returns 1 if the target configuration supports defining public symbols\n@@ -4754,7 +4754,7 @@ default_unique_section_1 (tree decl, int reloc, int shlib)\n   plen = strlen (prefix);\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  name = (* targetm.strip_name_encoding) (name);\n+  name = targetm.strip_name_encoding (name);\n   nlen = strlen (name);\n \n   string = alloca (nlen + plen + 1);"}]}