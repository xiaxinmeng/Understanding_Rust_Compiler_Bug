{"sha": "43e84ce7d62be121445e17cc0ee009a81fb285d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNlODRjZTdkNjJiZTEyMTQ0NWUxN2NjMGVlMDA5YTgxZmIyODVkNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-05T00:30:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-05T00:30:08Z"}, "message": "c++: Fix constexpr access to union member through pointer-to-member [PR98122]\n\nWe currently incorrectly reject the first testcase, because\ncxx_fold_indirect_ref_1 doesn't attempt to handle UNION_TYPEs.\nAs the second testcase shows, it isn't that easy, because I believe we need\nto take into account the active member and prefer that active member over\nother members, because if we pick a non-active one, we might reject valid\nprograms.\n\n2020-12-05  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/98122\n\t* constexpr.c (cxx_union_active_member): New function.\n\t(cxx_fold_indirect_ref_1): Add ctx argument, pass it through to\n\trecursive call.  Handle UNION_TYPE.\n\t(cxx_fold_indirect_ref): Add ctx argument, pass it to recursive calls\n\tand cxx_fold_indirect_ref_1.\n\t(cxx_eval_indirect_ref): Adjust cxx_fold_indirect_ref calls.\n\n\t* g++.dg/cpp1y/constexpr-98122.C: New test.\n\t* g++.dg/cpp2a/constexpr-98122.C: New test.", "tree": {"sha": "4c30da1fb62d47cc0934531732b7335b6eb9b3ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c30da1fb62d47cc0934531732b7335b6eb9b3ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43e84ce7d62be121445e17cc0ee009a81fb285d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e84ce7d62be121445e17cc0ee009a81fb285d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e84ce7d62be121445e17cc0ee009a81fb285d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e84ce7d62be121445e17cc0ee009a81fb285d7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5fd8a9157c440c2039e7c7015f012800d1e524d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5fd8a9157c440c2039e7c7015f012800d1e524d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5fd8a9157c440c2039e7c7015f012800d1e524d"}], "stats": {"total": 103, "additions": 90, "deletions": 13}, "files": [{"sha": "cb477c848d111af602bebd4757791114498aa9c5", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e84ce7d62be121445e17cc0ee009a81fb285d7/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e84ce7d62be121445e17cc0ee009a81fb285d7/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=43e84ce7d62be121445e17cc0ee009a81fb285d7", "patch": "@@ -4611,11 +4611,32 @@ same_type_ignoring_tlq_and_bounds_p (tree type1, tree type2)\n   return same_type_ignoring_top_level_qualifiers_p (type1, type2);\n }\n \n+/* Try to determine the currently active union member for an expression\n+   with UNION_TYPE.  If it can be determined, return the FIELD_DECL,\n+   otherwise return NULL_TREE.  */\n+\n+static tree\n+cxx_union_active_member (const constexpr_ctx *ctx, tree t)\n+{\n+  constexpr_ctx new_ctx = *ctx;\n+  new_ctx.quiet = true;\n+  bool non_constant_p = false, overflow_p = false;\n+  tree ctor = cxx_eval_constant_expression (&new_ctx, t, false,\n+\t\t\t\t\t    &non_constant_p,\n+\t\t\t\t\t    &overflow_p);\n+  if (TREE_CODE (ctor) == CONSTRUCTOR\n+      && CONSTRUCTOR_NELTS (ctor) == 1\n+      && CONSTRUCTOR_ELT (ctor, 0)->index\n+      && TREE_CODE (CONSTRUCTOR_ELT (ctor, 0)->index) == FIELD_DECL)\n+    return CONSTRUCTOR_ELT (ctor, 0)->index;\n+  return NULL_TREE;\n+}\n+\n /* Helper function for cxx_fold_indirect_ref_1, called recursively.  */\n \n static tree\n-cxx_fold_indirect_ref_1 (location_t loc, tree type, tree op,\n-\t\t\t unsigned HOST_WIDE_INT off, bool *empty_base)\n+cxx_fold_indirect_ref_1 (const constexpr_ctx *ctx, location_t loc, tree type,\n+\t\t\t tree op, unsigned HOST_WIDE_INT off, bool *empty_base)\n {\n   tree optype = TREE_TYPE (op);\n   unsigned HOST_WIDE_INT const_nunits;\n@@ -4674,13 +4695,29 @@ cxx_fold_indirect_ref_1 (location_t loc, tree type, tree op,\n \t  tree index = size_int (idx + tree_to_uhwi (min_val));\n \t  op = build4_loc (loc, ARRAY_REF, TREE_TYPE (optype), op, index,\n \t\t\t   NULL_TREE, NULL_TREE);\n-\t  return cxx_fold_indirect_ref_1 (loc, type, op, rem,\n+\t  return cxx_fold_indirect_ref_1 (ctx, loc, type, op, rem,\n \t\t\t\t\t  empty_base);\n \t}\n     }\n   /* ((foo *)&struct_with_foo_field)[x] => COMPONENT_REF */\n-  else if (TREE_CODE (optype) == RECORD_TYPE)\n+  else if (TREE_CODE (optype) == RECORD_TYPE\n+\t   || TREE_CODE (optype) == UNION_TYPE)\n     {\n+      if (TREE_CODE (optype) == UNION_TYPE)\n+\t/* For unions prefer the currently active member.  */\n+\tif (tree field = cxx_union_active_member (ctx, op))\n+\t  {\n+\t    unsigned HOST_WIDE_INT el_sz\n+\t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\t    if (off < el_sz)\n+\t      {\n+\t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t\t   op, field, NULL_TREE);\n+\t\tif (tree ret = cxx_fold_indirect_ref_1 (ctx, loc, type, cop,\n+\t\t\t\t\t\t\toff, empty_base))\n+\t\t  return ret;\n+\t      }\n+\t  }\n       for (tree field = TYPE_FIELDS (optype);\n \t   field; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL\n@@ -4691,13 +4728,13 @@ cxx_fold_indirect_ref_1 (location_t loc, tree type, tree op,\n \t    if (!tree_fits_uhwi_p (pos))\n \t      continue;\n \t    unsigned HOST_WIDE_INT upos = tree_to_uhwi (pos);\n-\t    unsigned el_sz\n+\t    unsigned HOST_WIDE_INT el_sz\n \t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n \t    if (upos <= off && off < upos + el_sz)\n \t      {\n \t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field),\n \t\t\t\t   op, field, NULL_TREE);\n-\t\tif (tree ret = cxx_fold_indirect_ref_1 (loc, type, cop,\n+\t\tif (tree ret = cxx_fold_indirect_ref_1 (ctx, loc, type, cop,\n \t\t\t\t\t\t\toff - upos,\n \t\t\t\t\t\t\tempty_base))\n \t\t  return ret;\n@@ -4718,7 +4755,8 @@ cxx_fold_indirect_ref_1 (location_t loc, tree type, tree op,\n    with TBAA in fold_indirect_ref_1.  */\n \n static tree\n-cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n+cxx_fold_indirect_ref (const constexpr_ctx *ctx, location_t loc, tree type,\n+\t\t       tree op0, bool *empty_base)\n {\n   tree sub = op0;\n   tree subtype;\n@@ -4756,7 +4794,7 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \t    return op;\n \t}\n       else\n-\treturn cxx_fold_indirect_ref_1 (loc, type, op, 0, empty_base);\n+\treturn cxx_fold_indirect_ref_1 (ctx, loc, type, op, 0, empty_base);\n     }\n   else if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n \t   && tree_fits_uhwi_p (TREE_OPERAND (sub, 1)))\n@@ -4766,7 +4804,7 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \n       STRIP_NOPS (op00);\n       if (TREE_CODE (op00) == ADDR_EXPR)\n-\treturn cxx_fold_indirect_ref_1 (loc, type, TREE_OPERAND (op00, 0),\n+\treturn cxx_fold_indirect_ref_1 (ctx, loc, type, TREE_OPERAND (op00, 0),\n \t\t\t\t\ttree_to_uhwi (op01), empty_base);\n     }\n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n@@ -4776,7 +4814,7 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n       tree type_domain;\n       tree min_val = size_zero_node;\n       tree newsub\n-\t= cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);\n+\t= cxx_fold_indirect_ref (ctx, loc, TREE_TYPE (subtype), sub, NULL);\n       if (newsub)\n \tsub = newsub;\n       else\n@@ -4811,8 +4849,8 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n     }\n \n   /* First try to simplify it directly.  */\n-  tree r = cxx_fold_indirect_ref (EXPR_LOCATION (t), TREE_TYPE (t), orig_op0,\n-\t\t\t\t  &empty_base);\n+  tree r = cxx_fold_indirect_ref (ctx, EXPR_LOCATION (t), TREE_TYPE (t),\n+\t\t\t\t  orig_op0, &empty_base);\n   if (!r)\n     {\n       /* If that didn't work, evaluate the operand first.  */\n@@ -4831,7 +4869,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \t  return t;\n \t}\n \n-      r = cxx_fold_indirect_ref (EXPR_LOCATION (t), TREE_TYPE (t), op0,\n+      r = cxx_fold_indirect_ref (ctx, EXPR_LOCATION (t), TREE_TYPE (t), op0,\n \t\t\t\t &empty_base);\n       if (r == NULL_TREE)\n \t{"}, {"sha": "86b8aa9c5dec448d3b554e40069efe6661b608e9", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-98122.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e84ce7d62be121445e17cc0ee009a81fb285d7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-98122.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e84ce7d62be121445e17cc0ee009a81fb285d7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-98122.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-98122.C?ref=43e84ce7d62be121445e17cc0ee009a81fb285d7", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/98122\n+// { dg-do compile { target c++14 } }\n+\n+union U { int a; };\n+\n+constexpr bool\n+foo ()\n+{\n+  U f { 42 };\n+  constexpr auto m = &U::a;\n+  return (f.*m) == 42;\n+}\n+\n+static_assert (foo (), \"\");"}, {"sha": "01bdfa5bd4d2d7cdddc293fddfebe1bcce53d4ce", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-98122.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e84ce7d62be121445e17cc0ee009a81fb285d7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-98122.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e84ce7d62be121445e17cc0ee009a81fb285d7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-98122.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-98122.C?ref=43e84ce7d62be121445e17cc0ee009a81fb285d7", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/98122\n+// { dg-do compile { target c++20 } }\n+\n+union V { int a; char b; };\n+union W { int a; int b; };\n+\n+constexpr bool\n+bar ()\n+{\n+  V f { .b = 42 };\n+  constexpr auto m = &V::a;\n+  return (f.*m) == 42;\n+}\n+\n+constexpr bool\n+baz ()\n+{\n+  W f { .b = 42 };\n+  constexpr auto m = &W::b;\n+  return (f.*m) == 42;\n+}\n+\n+static_assert (bar (), \"\");\t// { dg-error \"non-constant condition for static assertion\" }\n+\t\t\t\t// { dg-error \"accessing 'V::a' member instead of initialized 'V::b' member in constant expression\" \"\" { target *-*-* } .-1 }\n+static_assert (baz (), \"\");"}]}