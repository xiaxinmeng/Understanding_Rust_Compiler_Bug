{"sha": "3e322b77d60784b418c7f03d5bf9911992ffcf40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UzMjJiNzdkNjA3ODRiNDE4YzdmMDNkNWJmOTkxMTk5MmZmY2Y0MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-09-22T15:12:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-09-22T15:12:23Z"}, "message": "cris.c (TARGET_ASM_TRAMPOLINE_TEMPLATE, [...]): New.\n\n\t* config/cris/cris.c (TARGET_ASM_TRAMPOLINE_TEMPLATE,\n\tTARGET_TRAMPOLINE_INIT, cris_asm_trampoline_template,\n\tcris_trampoline_init): New.\n\t* config/cris/cris.h (TRAMPOLINE_TEMPLATE): Move code to\n\tcris_asm_trampoline_template.\n\t(INITIALIZE_TRAMPOLINE): Move code to cris_trampoline_init;\n\tadjust for target hook parameters.\n\nFrom-SVN: r151989", "tree": {"sha": "c2bc9a19b43019ebebd71ad29fbb36881d7bee5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2bc9a19b43019ebebd71ad29fbb36881d7bee5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e322b77d60784b418c7f03d5bf9911992ffcf40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e322b77d60784b418c7f03d5bf9911992ffcf40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e322b77d60784b418c7f03d5bf9911992ffcf40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e322b77d60784b418c7f03d5bf9911992ffcf40/comments", "author": null, "committer": null, "parents": [{"sha": "92910d774d50640ec270c2386a96cfa78f1663ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92910d774d50640ec270c2386a96cfa78f1663ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92910d774d50640ec270c2386a96cfa78f1663ae"}], "stats": {"total": 212, "additions": 114, "deletions": 98}, "files": [{"sha": "042d8647c8b169b8150864234d640cda32b783f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e322b77d60784b418c7f03d5bf9911992ffcf40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e322b77d60784b418c7f03d5bf9911992ffcf40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e322b77d60784b418c7f03d5bf9911992ffcf40", "patch": "@@ -79,6 +79,14 @@\n \tbfin_asm_trampoline_template.\n \t(INITIALIZE_TRAMPOLINE): Remove.\n \n+\t* config/cris/cris.c (TARGET_ASM_TRAMPOLINE_TEMPLATE,\n+\tTARGET_TRAMPOLINE_INIT, cris_asm_trampoline_template,\n+\tcris_trampoline_init): New.\n+\t* config/cris/cris.h (TRAMPOLINE_TEMPLATE): Move code to\n+\tcris_asm_trampoline_template.\n+\t(INITIALIZE_TRAMPOLINE): Move code to cris_trampoline_init;\n+\tadjust for target hook parameters.\n+\n 2009-09-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/rs6000/rs6000.c (bdesc_2arg): Fix CODE_FOR_vector_gt* codes"}, {"sha": "bf00a57a3b6aa1939f4275c8b6fa6beb86246724", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e322b77d60784b418c7f03d5bf9911992ffcf40/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e322b77d60784b418c7f03d5bf9911992ffcf40/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=3e322b77d60784b418c7f03d5bf9911992ffcf40", "patch": "@@ -127,6 +127,9 @@ static bool cris_handle_option (size_t, const char *, int);\n \n static bool cris_frame_pointer_required (void);\n \n+static void cris_asm_trampoline_template (FILE *);\n+static void cris_trampoline_init (rtx, tree, rtx);\n+\n /* This is the parsed result of the \"-max-stack-stackframe=\" option.  If\n    it (still) is zero, then there was no such option given.  */\n int cris_max_stackframe = 0;\n@@ -189,6 +192,11 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED cris_frame_pointer_required\n \n+#undef TARGET_ASM_TRAMPOLINE_TEMPLATE\n+#define TARGET_ASM_TRAMPOLINE_TEMPLATE cris_asm_trampoline_template\n+#undef TARGET_TRAMPOLINE_INIT\n+#define TARGET_TRAMPOLINE_INIT cris_trampoline_init\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Helper for cris_load_multiple_op and cris_ret_movem_op.  */\n@@ -3853,6 +3861,103 @@ cris_frame_pointer_required (void)\n   return !current_function_sp_is_unchanging;\n }\n \n+/* Implement TARGET_ASM_TRAMPOLINE_TEMPLATE.\n+\n+   This looks too complicated, and it is.  I assigned r7 to be the\n+   static chain register, but it is call-saved, so we have to save it,\n+   and come back to restore it after the call, so we have to save srp...\n+   Anyway, trampolines are rare enough that we can cope with this\n+   somewhat lack of elegance.\n+    (Do not be tempted to \"straighten up\" whitespace in the asms; the\n+   assembler #NO_APP state mandates strict spacing).  */\n+/* ??? See the i386 regparm=3 implementation that pushes the static\n+   chain value to the stack in the trampoline, and uses a call-saved\n+   register when called directly.  */\n+\n+static void\n+cris_asm_trampoline_template (FILE *f)\n+{\n+  if (TARGET_V32)\n+    {\n+      /* This normally-unused nop insn acts as an instruction to\n+\t the simulator to flush its instruction cache.  None of\n+\t the other instructions in the trampoline template suits\n+\t as a trigger for V32.  The pc-relative addressing mode\n+\t works nicely as a trigger for V10.\n+\t FIXME: Have specific V32 template (possibly avoiding the\n+\t use of a special instruction).  */\n+      fprintf (f, \"\\tclearf x\\n\");\n+      /* We have to use a register as an intermediate, choosing\n+\t semi-randomly R1 (which has to not be the STATIC_CHAIN_REGNUM),\n+\t so we can use it for address indirection and jsr target.  */\n+      fprintf (f, \"\\tmove $r1,$mof\\n\");\n+      /* +4 */\n+      fprintf (f, \"\\tmove.d 0,$r1\\n\");\n+      fprintf (f, \"\\tmove.d $%s,[$r1]\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+      fprintf (f, \"\\taddq 6,$r1\\n\");\n+      fprintf (f, \"\\tmove $mof,[$r1]\\n\");\n+      fprintf (f, \"\\taddq 6,$r1\\n\");\n+      fprintf (f, \"\\tmove $srp,[$r1]\\n\");\n+      /* +20 */\n+      fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+      /* +26 */\n+      fprintf (f, \"\\tmove.d 0,$r1\\n\");\n+      fprintf (f, \"\\tjsr $r1\\n\");\n+      fprintf (f, \"\\tsetf\\n\");\n+      /* +36 */\n+      fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+      /* +42 */\n+      fprintf (f, \"\\tmove.d 0,$r1\\n\");\n+      /* +48 */\n+      fprintf (f, \"\\tmove.d 0,$r9\\n\");\n+      fprintf (f, \"\\tjump $r9\\n\");\n+      fprintf (f, \"\\tsetf\\n\");\n+    }\n+  else\n+    {\n+      fprintf (f, \"\\tmove.d $%s,[$pc+20]\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+      fprintf (f, \"\\tmove $srp,[$pc+22]\\n\");\n+      fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+      fprintf (f, \"\\tjsr 0\\n\");\n+      fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+      fprintf (f, \"\\tjump 0\\n\");\n+    }\n+}\n+\n+/* Implement TARGET_TRAMPOLINE_INIT.  */\n+\n+static void\n+cris_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n+{\n+  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n+  rtx tramp = XEXP (m_tramp, 0);\n+  rtx mem;\n+\n+  emit_block_move (m_tramp, assemble_trampoline_template (),\n+\t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n+\n+  if (TARGET_V32)\n+    {\n+      mem = adjust_address (m_tramp, SImode, 6);\n+      emit_move_insn (mem, plus_constant (tramp, 38));\n+      mem = adjust_address (m_tramp, SImode, 22);\n+      emit_move_insn (mem, chain_value);\n+      mem = adjust_address (m_tramp, SImode, 28);\n+      emit_move_insn (mem, fnaddr);\n+    }\n+  else\n+    {\n+      mem = adjust_address (m_tramp, SImode, 10);\n+      emit_move_insn (mem, chain_value);\n+      mem = adjust_address (m_tramp, SImode, 16);\n+      emit_move_insn (mem, fnaddr);\n+    }\n+\n+  /* Note that there is no need to do anything with the cache for\n+     sake of a trampoline.  */\n+}\n+\n+\n #if 0\n /* Various small functions to replace macros.  Only called from a\n    debugger.  They might collide with gcc functions or system functions,"}, {"sha": "586f7ff2077b02e62a29250afee452efd3751d9f", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 98, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e322b77d60784b418c7f03d5bf9911992ffcf40/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e322b77d60784b418c7f03d5bf9911992ffcf40/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=3e322b77d60784b418c7f03d5bf9911992ffcf40", "patch": "@@ -935,108 +935,11 @@ struct cum_args {int regs;};\n \n /* Node: Trampolines */\n \n-/* This looks too complicated, and it is.  I assigned r7 to be the\n-   static chain register, but it is call-saved, so we have to save it,\n-   and come back to restore it after the call, so we have to save srp...\n-   Anyway, trampolines are rare enough that we can cope with this\n-   somewhat lack of elegance.\n-    (Do not be tempted to \"straighten up\" whitespace in the asms; the\n-   assembler #NO_APP state mandates strict spacing).  */\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t       \\\n-  do\t\t\t\t\t\t\t\t       \\\n-    {\t\t\t\t\t\t\t\t       \\\n-      if (TARGET_V32)\t\t\t\t\t\t       \\\n-       {\t\t\t\t\t\t\t       \\\n-\t /* This normally-unused nop insn acts as an instruction to    \\\n-\t    the simulator to flush its instruction cache.  None of     \\\n-\t    the other instructions in the trampoline template suits    \\\n-\t    as a trigger for V32.  The pc-relative addressing mode     \\\n-\t    works nicely as a trigger for V10.\t\t\t       \\\n-\t    FIXME: Have specific V32 template (possibly avoiding the   \\\n-\t    use of a special instruction).  */\t\t\t       \\\n-\t fprintf (FILE, \"\\tclearf x\\n\");\t\t\t       \\\n-\t /* We have to use a register as an intermediate, choosing     \\\n-\t    semi-randomly R1 (which has to not be the\t\t       \\\n-\t    STATIC_CHAIN_REGNUM), so we can use it for address\t       \\\n-\t    indirection and jsr target.\t */\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove $r1,$mof\\n\");\t\t\t       \\\n-\t /* +4 */\t\t\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d 0,$r1\\n\");\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d $%s,[$r1]\\n\",\t\t\t       \\\n-\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n-\t fprintf (FILE, \"\\taddq 6,$r1\\n\");\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove $mof,[$r1]\\n\");\t\t\t       \\\n-\t fprintf (FILE, \"\\taddq 6,$r1\\n\");\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove $srp,[$r1]\\n\");\t\t\t       \\\n-\t /* +20 */\t\t\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\t\t       \\\n-\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n-\t /* +26 */\t\t\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d 0,$r1\\n\");\t\t\t       \\\n-\t fprintf (FILE, \"\\tjsr $r1\\n\");\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tsetf\\n\");\t\t\t\t       \\\n-\t /* +36 */\t\t\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\t\t       \\\n-\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n-\t /* +42 */\t\t\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d 0,$r1\\n\");\t\t\t       \\\n-\t /* +48 */\t\t\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d 0,$r9\\n\");\t\t\t       \\\n-\t fprintf (FILE, \"\\tjump $r9\\n\");\t\t\t       \\\n-\t fprintf (FILE, \"\\tsetf\\n\");\t\t\t\t       \\\n-       }\t\t\t\t\t\t\t       \\\n-      else\t\t\t\t\t\t\t       \\\n-       {\t\t\t\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d $%s,[$pc+20]\\n\",\t\t       \\\n-\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n-\t fprintf (FILE, \"\\tmove $srp,[$pc+22]\\n\");\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\t\t       \\\n-\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n-\t fprintf (FILE, \"\\tjsr 0\\n\");\t\t\t\t       \\\n-\t fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\t\t       \\\n-\t\t  reg_names[STATIC_CHAIN_REGNUM]);\t\t       \\\n-\t fprintf (FILE, \"\\tjump 0\\n\");\t\t\t\t       \\\n-       }\t\t\t\t\t\t\t       \\\n-    }\t\t\t\t\t\t\t\t       \\\n-  while (0)\n-\n #define TRAMPOLINE_SIZE (TARGET_V32 ? 58 : 32)\n \n-/* CRIS wants instructions on word-boundary.\n-   Note that due to a bug (reported) in 2.7.2 and earlier, this is\n-   actually treated as alignment in _bytes_, not _bits_.  (Obviously\n-   this is not fatal, only a slight waste of stack space).  */\n+/* CRIS wants instructions on word-boundary.  */\n #define TRAMPOLINE_ALIGNMENT 16\n \n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_V32)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n-\t\t\t\t     plus_constant (TRAMP, 6)),\t\t\\\n-\t\t \tplus_constant (TRAMP, 38));\t\t\t\\\n-\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n-\t\t\t\t     plus_constant (TRAMP, 22)),\t\\\n-\t\t\tCXT);\t\t\t\t\t\t\\\n-\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n-\t\t\t\t     plus_constant (TRAMP, 28)),\t\\\n-\t\t \tFNADDR);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n-\t\t\t\t     plus_constant (TRAMP, 10)),\t\\\n-\t\t\tCXT);\t\t\t\t\t\t\\\n-\temit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n-\t\t\t\t     plus_constant (TRAMP, 16)),\t\\\n-\t\t \tFNADDR);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Note that there is no need to do anything with the cache for sake of\n-   a trampoline.  */\n-\n-\n /* Node: Library Calls */\n \n /* If you change this, you have to check whatever libraries and systems"}]}