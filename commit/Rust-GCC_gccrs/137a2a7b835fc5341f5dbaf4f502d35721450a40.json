{"sha": "137a2a7b835fc5341f5dbaf4f502d35721450a40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM3YTJhN2I4MzVmYzUzNDFmNWRiYWY0ZjUwMmQzNTcyMTQ1MGE0MA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-04-19T19:25:29Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-04-19T19:25:29Z"}, "message": "(assign_parms): Use new FUNCTION_ARG_CALLEE_COPIES macro.\n\nFrom-SVN: r4184", "tree": {"sha": "8f7f5625e87a162468a11ee32efd281bbbc95031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f7f5625e87a162468a11ee32efd281bbbc95031"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/137a2a7b835fc5341f5dbaf4f502d35721450a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137a2a7b835fc5341f5dbaf4f502d35721450a40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/137a2a7b835fc5341f5dbaf4f502d35721450a40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137a2a7b835fc5341f5dbaf4f502d35721450a40/comments", "author": null, "committer": null, "parents": [{"sha": "5e0de251204954b4a332a2ed7417623ed826de3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0de251204954b4a332a2ed7417623ed826de3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e0de251204954b4a332a2ed7417623ed826de3e"}], "stats": {"total": 47, "additions": 47, "deletions": 0}, "files": [{"sha": "21111db3e061ee80670083be30db7e6fb553b6e7", "filename": "gcc/function.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137a2a7b835fc5341f5dbaf4f502d35721450a40/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137a2a7b835fc5341f5dbaf4f502d35721450a40/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=137a2a7b835fc5341f5dbaf4f502d35721450a40", "patch": "@@ -3178,6 +3178,53 @@ assign_parms (fndecl, second_time)\n \t      emit_move_insn (parmreg, DECL_RTL (parm));\n \t      DECL_RTL (parm) = parmreg;\n \t    }\n+#ifdef FUNCTION_ARG_CALLEE_COPIES\n+\t  /* If we are passed an arg by reference and it is our responsibility\n+\t     to make a copy, do it now.\n+\t     PASSED_TYPE and PASSED mode now refer to the pointer, not the\n+\t     original argument, so we must recreate them in the call to\n+\t     FUNCTION_ARG_CALLEE_COPIES.  */\n+\t  /* ??? Later add code to handle the case that if the argument isn't\n+\t     modified, don't do the copy.  */\n+\n+\t  else if (passed_pointer\n+\t\t   && FUNCTION_ARG_CALLEE_COPIES (args_so_far,\n+\t\t\t\t\t\t  TYPE_MODE (DECL_ARG_TYPE (parm)),\n+\t\t\t\t\t\t  DECL_ARG_TYPE (parm),\n+\t\t\t\t\t\t  ! last_named))\n+\t    {\n+\t      rtx copy;\n+\t      tree type = DECL_ARG_TYPE (parm);\n+\n+\t      /* This sequence may involve a library call perhaps clobbering\n+\t\t registers that haven't been copied to pseudos yet.  */\n+\n+\t      push_to_sequence (conversion_insns);\n+\n+\t      if (TYPE_SIZE (type) == 0\n+\t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t\t{\n+\t\t  /* This is a variable sized object.  */\n+\t\t  /* ??? Can we use expr_size here?  */\n+\t\t  rtx size_rtx = expand_expr (size_in_bytes (type), NULL_RTX,\n+\t\t\t\t\t      TYPE_MODE(sizetype), 0);\n+\n+\t\t  copy = gen_rtx (MEM, BLKmode,\n+\t\t\t\t  allocate_dynamic_stack_space (size_rtx, NULL_RTX,\n+\t\t\t\t\t\t\t\tTYPE_ALIGN (type)));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int size = int_size_in_bytes (type);\n+\t\t  copy = assign_stack_temp (BLKmode, size, 1);\n+\t\t}\n+\n+\t      store_expr (parm, copy, 0);\n+\t      emit_move_insn (parmreg, XEXP (copy, 0));\n+\t      conversion_insns = get_insns ();\n+\t      end_sequence ();\n+\t    }\n+#endif /* FUNCTION_ARG_CALLEE_COPIES */\n \n \t  /* In any case, record the parm's desired stack location\n \t     in case we later discover it must live in the stack.  */"}]}