{"sha": "67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc0NjBkNDU3NTdhNzljZGM5MWZkZGUxZGMxYjFhMThlNGFiYTZiMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-07-23T08:13:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-23T08:13:32Z"}, "message": "[Ada] Plug small loophole in Generate_Range_Check\n\nThe Generate_Range_Check routine is responsible for generating range\nchecks in the scalar case.  It automatically deals with possible\noverflow in the process when the source and the target base types are\ndifferent.\n\nHowever there is one case where overflow is not dealt with correctly,\nnamely when the target base type is narrower than the source base type\nand both are floating-point types. In this case, the routine will\nconvert the source type to the target base type without checking for\noverflow. In practice this does not matter much because the conversion\nwould yield an infinity on overflow, which would then fail the\nsubsequent range check. However it's more correct to have a proper\noverflow check with -gnateF than relying on the infinity.\n\n2019-07-23  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* checks.adb (Convert_And_Check_Range): Add Suppress parameter\n\tand pass it in the call to Insert_Actions.  Rename local\n\tvariable.\n\t(Generate_Range_Check): Minor comment fixes.  Pass Range_Check\n\tin the first call to Convert_And_Check_Range and All_Checks in\n\tthe second call.\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Reset the\n\tDo_Overflow_Check flag in the float-to-float case too if there\n\tis also a range check.\n\ngcc/testsuite/\n\n\t* gnat.dg/range_check5.adb: New testcase.\n\nFrom-SVN: r273725", "tree": {"sha": "0876647d905aa74a9b990478eec99495ac5572c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0876647d905aa74a9b990478eec99495ac5572c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/comments", "author": null, "committer": null, "parents": [{"sha": "a7191e01187b6ff6429699f09fed8f3fbb018b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7191e01187b6ff6429699f09fed8f3fbb018b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7191e01187b6ff6429699f09fed8f3fbb018b74"}], "stats": {"total": 110, "additions": 75, "deletions": 35}, "files": [{"sha": "86a5491ad34550ae11fd33f06f0d5a063c8fb265", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "patch": "@@ -1,3 +1,15 @@\n+2019-07-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* checks.adb (Convert_And_Check_Range): Add Suppress parameter\n+\tand pass it in the call to Insert_Actions.  Rename local\n+\tvariable.\n+\t(Generate_Range_Check): Minor comment fixes.  Pass Range_Check\n+\tin the first call to Convert_And_Check_Range and All_Checks in\n+\tthe second call.\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Reset the\n+\tDo_Overflow_Check flag in the float-to-float case too if there\n+\tis also a range check.\n+\n 2019-07-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* checks.adb (Activate_Overflow_Check): Remove redundant"}, {"sha": "708bd9e66f70ce067a9cd28726ffb1f68a1dd6b0", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "patch": "@@ -6841,18 +6841,19 @@ package body Checks is\n       Source_Base_Type : constant Entity_Id  := Base_Type (Source_Type);\n       Target_Base_Type : constant Entity_Id  := Base_Type (Target_Type);\n \n-      procedure Convert_And_Check_Range;\n-      --  Convert the conversion operand to the target base type and save in\n-      --  a temporary. Then check the converted value against the range of the\n-      --  target subtype.\n+      procedure Convert_And_Check_Range (Suppress : Check_Id);\n+      --  Convert N to the target base type and save the result in a temporary.\n+      --  The action is analyzed using the default checks as modified by the\n+      --  given Suppress argument. Then check the converted value against the\n+      --  range of the target subtype.\n \n       -----------------------------\n       -- Convert_And_Check_Range --\n       -----------------------------\n \n-      procedure Convert_And_Check_Range is\n-         Tnn       : constant Entity_Id := Make_Temporary (Loc, 'T', N);\n-         Conv_Node : Node_Id;\n+      procedure Convert_And_Check_Range (Suppress : Check_Id) is\n+         Tnn    : constant Entity_Id := Make_Temporary (Loc, 'T', N);\n+         Conv_N : Node_Id;\n \n       begin\n          --  For enumeration types with non-standard representation this is a\n@@ -6867,44 +6868,34 @@ package body Checks is\n            and then Present (Enum_Pos_To_Rep (Source_Base_Type))\n            and then Is_Integer_Type (Target_Base_Type)\n          then\n-            Conv_Node :=\n-              OK_Convert_To\n-                (Typ  => Target_Base_Type,\n-                 Expr => Duplicate_Subexpr (N));\n-\n-         --  Common case\n-\n+            Conv_N := OK_Convert_To (Target_Base_Type, Duplicate_Subexpr (N));\n          else\n-            Conv_Node :=\n-              Make_Type_Conversion (Loc,\n-                Subtype_Mark => New_Occurrence_Of (Target_Base_Type, Loc),\n-                Expression   => Duplicate_Subexpr (N));\n+            Conv_N := Convert_To (Target_Base_Type, Duplicate_Subexpr (N));\n          end if;\n \n-         --  We make a temporary to hold the value of the converted value\n-         --  (converted to the base type), and then do the test against this\n-         --  temporary. The conversion itself is replaced by an occurrence of\n-         --  Tnn and followed by the explicit range check. Note that checks\n-         --  are suppressed for this code, since we don't want a recursive\n-         --  range check popping up.\n+         --  We make a temporary to hold the value of the conversion to the\n+         --  target base type, and then do the test against this temporary.\n+         --  N itself is replaced by an occurrence of Tnn and followed by\n+         --  the explicit range check.\n \n          --     Tnn : constant Target_Base_Type := Target_Base_Type (N);\n          --     [constraint_error when Tnn not in Target_Type]\n+         --     Tnn\n \n          Insert_Actions (N, New_List (\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Tnn,\n              Object_Definition   => New_Occurrence_Of (Target_Base_Type, Loc),\n              Constant_Present    => True,\n-             Expression          => Conv_Node),\n+             Expression          => Conv_N),\n \n            Make_Raise_Constraint_Error (Loc,\n              Condition =>\n                Make_Not_In (Loc,\n                  Left_Opnd  => New_Occurrence_Of (Tnn, Loc),\n                  Right_Opnd => New_Occurrence_Of (Target_Type, Loc)),\n              Reason => Reason)),\n-           Suppress => All_Checks);\n+           Suppress => Suppress);\n \n          Rewrite (N, New_Occurrence_Of (Tnn, Loc));\n \n@@ -6921,7 +6912,7 @@ package body Checks is\n       --  First special case, if the source type is already within the range\n       --  of the target type, then no check is needed (probably we should have\n       --  stopped Do_Range_Check from being set in the first place, but better\n-      --  late than never in preventing junk code and junk flag settings.\n+      --  late than never in preventing junk code and junk flag settings).\n \n       if In_Subrange_Of (Source_Type, Target_Type)\n \n@@ -6998,7 +6989,8 @@ package body Checks is\n \n       --  Next test for the case where the target type is within the bounds\n       --  of the base type of the source type, since in this case we can\n-      --  simply convert these bounds to the base type of T to do the test.\n+      --  simply convert the bounds of the target type to this base bype\n+      --  to do the test.\n \n       --    [constraint_error when N not in\n       --       Source_Base_Type (Target_Type'First)\n@@ -7047,14 +7039,18 @@ package body Checks is\n               Suppress => All_Checks);\n \n          --  For conversions involving at least one type that is not discrete,\n-         --  first convert to target type and then generate the range check.\n-         --  This avoids problems with values that are close to a bound of the\n-         --  target type that would fail a range check when done in a larger\n-         --  source type before converting but would pass if converted with\n+         --  first convert to the target base type and then generate the range\n+         --  check. This avoids problems with values that are close to a bound\n+         --  of the target type that would fail a range check when done in a\n+         --  larger source type before converting but pass if converted with\n          --  rounding and then checked (such as in float-to-float conversions).\n \n+         --  Note that overflow checks are not suppressed for this code because\n+         --  we do not know whether the source type is in range of the target\n+         --  base type (unlike in the next case below).\n+\n          else\n-            Convert_And_Check_Range;\n+            Convert_And_Check_Range (Suppress => Range_Check);\n          end if;\n \n       --  Note that at this stage we know that the Target_Base_Type is not in\n@@ -7063,10 +7059,12 @@ package body Checks is\n       --  in range of the target base type since we have not checked that case.\n \n       --  If that is the case, we can freely convert the source to the target,\n-      --  and then test the target result against the bounds.\n+      --  and then test the target result against the bounds. Note that checks\n+      --  are suppressed for this code, since we don't want a recursive range\n+      --  check popping up.\n \n       elsif In_Subrange_Of (Source_Type, Target_Base_Type) then\n-         Convert_And_Check_Range;\n+         Convert_And_Check_Range (Suppress => All_Checks);\n \n       --  At this stage, we know that we have two scalar types, which are\n       --  directly convertible, and where neither scalar type has a base"}, {"sha": "e4dc06b5d6a896beedef5c67750f7d2f432482fa", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "patch": "@@ -12090,6 +12090,11 @@ package body Exp_Ch4 is\n          if Is_Floating_Point_Type (Target_Type)\n            and then Is_Floating_Point_Type (Etype (Expression (N)))\n          then\n+            --  Reset overflow flag, since the range check will include\n+            --  dealing with possible overflow, and generate the check.\n+\n+            Set_Do_Overflow_Check (N, False);\n+\n             Generate_Range_Check\n               (Expression (N), Target_Type, CE_Range_Check_Failed);\n "}, {"sha": "883befdbf67965b8bd6bf4df012bebef014b2b73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "patch": "@@ -1,3 +1,7 @@\n+2019-07-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/range_check5.adb: New testcase.\n+\n 2019-07-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat.dg/iter5.adb: Add an expected error."}, {"sha": "dd622964d46d3836ab5dd025def1a473ea8c7750", "filename": "gcc/testsuite/gnat.dg/range_check5.adb", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Ftestsuite%2Fgnat.dg%2Frange_check5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67460d45757a79cdc91fdde1dc1b1a18e4aba6b2/gcc%2Ftestsuite%2Fgnat.dg%2Frange_check5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Frange_check5.adb?ref=67460d45757a79cdc91fdde1dc1b1a18e4aba6b2", "patch": "@@ -0,0 +1,21 @@\n+--  { dg-do run }\n+--  { dg-options \"-gnateF -O0\" }\n+\n+procedure Range_Check5 is\n+\n+  subtype Small_Float is Float range -100.0 .. 100.0;\n+\n+  function Conv (F : Long_Float) return Small_Float is\n+  begin\n+    return Small_Float (F);\n+  end;\n+\n+  R : Small_Float;\n+\n+begin\n+  R := Conv (4.0E+38);\n+  raise Program_Error;\n+exception\n+   when Constraint_Error =>\n+      null;\n+end;"}]}