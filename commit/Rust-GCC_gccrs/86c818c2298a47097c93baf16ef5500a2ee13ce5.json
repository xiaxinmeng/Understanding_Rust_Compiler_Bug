{"sha": "86c818c2298a47097c93baf16ef5500a2ee13ce5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjODE4YzIyOThhNDcwOTdjOTNiYWYxNmVmNTUwMGEyZWUxM2NlNQ==", "commit": {"author": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2012-11-20T10:51:02Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2012-11-20T10:51:02Z"}, "message": "Fix revision 193651.\n\ngcc/\n\t* config/aarch64/atomics.md: Actually add this file.\n\nFrom-SVN: r193653", "tree": {"sha": "d5f414aebdfe24581ee6e80ff9a952ac221ee3f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5f414aebdfe24581ee6e80ff9a952ac221ee3f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86c818c2298a47097c93baf16ef5500a2ee13ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c818c2298a47097c93baf16ef5500a2ee13ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86c818c2298a47097c93baf16ef5500a2ee13ce5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c818c2298a47097c93baf16ef5500a2ee13ce5/comments", "author": null, "committer": null, "parents": [{"sha": "0462169c731de56fdcbb99d96f31707daceee29c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0462169c731de56fdcbb99d96f31707daceee29c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0462169c731de56fdcbb99d96f31707daceee29c"}], "stats": {"total": 382, "additions": 382, "deletions": 0}, "files": [{"sha": "a9a18440e895c88f252ba9ccd88e11c56a030a5f", "filename": "gcc/config/aarch64/atomics.md", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c818c2298a47097c93baf16ef5500a2ee13ce5/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c818c2298a47097c93baf16ef5500a2ee13ce5/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=86c818c2298a47097c93baf16ef5500a2ee13ce5", "patch": "@@ -0,0 +1,382 @@\n+;; Machine description for AArch64 processor synchronization primitives.\n+;; Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+;; Contributed by ARM Ltd.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_c_enum \"unspecv\"\n+ [\n+    UNSPECV_LX\t\t\t\t; Represent a load-exclusive.\n+    UNSPECV_SX\t\t\t\t; Represent a store-exclusive.\n+    UNSPECV_LDA\t\t\t\t; Represent an atomic load or load-acquire.\n+    UNSPECV_STL\t\t\t\t; Represent an atomic store or store-release.\n+    UNSPECV_ATOMIC_CMPSW\t\t; Represent an atomic compare swap.\n+    UNSPECV_ATOMIC_EXCHG\t\t; Represent an atomic exchange.\n+    UNSPECV_ATOMIC_OP\t\t\t; Represent an atomic operation.\n+])\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\t\t\t;; bool out\n+   (match_operand:ALLI 1 \"register_operand\" \"\")\t\t\t;; val out\n+   (match_operand:ALLI 2 \"aarch64_sync_memory_operand\" \"\")\t;; memory\n+   (match_operand:ALLI 3 \"general_operand\" \"\")\t\t\t;; expected\n+   (match_operand:ALLI 4 \"register_operand\" \"\")\t\t\t;; desired\n+   (match_operand:SI 5 \"const_int_operand\")\t\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\")\t\t\t;; mod_s\n+   (match_operand:SI 7 \"const_int_operand\")]\t\t\t;; mod_f\n+  \"\"\n+  {\n+    aarch64_expand_compare_and_swap (operands);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_compare_and_swap<mode>_1\"\n+  [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n+    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n+   (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t\t;; val out\n+    (zero_extend:SI\n+      (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\"))) ;; memory\n+   (set (match_dup 1)\n+    (unspec_volatile:SHORT\n+      [(match_operand:SI 2 \"aarch64_plus_operand\" \"rI\")\t;; expected\n+       (match_operand:SHORT 3 \"register_operand\" \"r\")\t;; desired\n+       (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n+       (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n+       (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n+      UNSPECV_ATOMIC_CMPSW))\n+   (clobber (match_scratch:SI 7 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_compare_and_swap (operands);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_compare_and_swap<mode>_1\"\n+  [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n+    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n+   (set (match_operand:GPI 0 \"register_operand\" \"=&r\")\t\t;; val out\n+    (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\")) ;; memory\n+   (set (match_dup 1)\n+    (unspec_volatile:GPI\n+      [(match_operand:GPI 2 \"aarch64_plus_operand\" \"rI\")\t;; expect\n+       (match_operand:GPI 3 \"register_operand\" \"r\")\t\t;; desired\n+       (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n+       (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n+       (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n+      UNSPECV_ATOMIC_CMPSW))\n+   (clobber (match_scratch:SI 7 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_compare_and_swap (operands);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_exchange<mode>\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\t\t;; output\n+    (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\")) ;; memory\n+   (set (match_dup 1)\n+    (unspec_volatile:ALLI\n+      [(match_operand:ALLI 2 \"register_operand\" \"r\")\t;; input\n+       (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+      UNSPECV_ATOMIC_EXCHG))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_atomic_op (SET, operands[0], NULL, operands[1],\n+\t\t\t    operands[2], operands[3], operands[4]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_<atomic_optab><mode>\"\n+  [(set (match_operand:ALLI 0 \"aarch64_sync_memory_operand\" \"+Q\")\n+    (unspec_volatile:ALLI\n+      [(atomic_op:ALLI (match_dup 0)\n+\t(match_operand:ALLI 1 \"<atomic_op_operand>\" \"rn\"))\n+       (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n+      UNSPECV_ATOMIC_OP))\n+       (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:ALLI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_atomic_op (<CODE>, NULL, operands[3], operands[0],\n+\t\t\t    operands[1], operands[2], operands[4]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_nand<mode>\"\n+  [(set (match_operand:ALLI 0 \"aarch64_sync_memory_operand\" \"+Q\")\n+    (unspec_volatile:ALLI\n+      [(not:ALLI\n+\t(and:ALLI (match_dup 0)\n+\t  (match_operand:ALLI 1 \"aarch64_logical_operand\" \"rn\")))\n+       (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n+      UNSPECV_ATOMIC_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:ALLI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+     aarch64_split_atomic_op (NOT, NULL, operands[3], operands[0],\n+\t\t\t     operands[1], operands[2], operands[4]);\n+     DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_fetch_<atomic_optab><mode>\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n+    (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n+   (set (match_dup 1)\n+    (unspec_volatile:ALLI\n+      [(atomic_op:ALLI (match_dup 1)\n+\t(match_operand:ALLI 2 \"<atomic_op_operand>\" \"rn\"))\n+       (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+      UNSPECV_ATOMIC_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:ALLI 4 \"=&r\"))\n+   (clobber (match_scratch:SI 5 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_atomic_op (<CODE>, operands[0], operands[4], operands[1],\n+\t\t\t     operands[2], operands[3], operands[5]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_fetch_nand<mode>\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n+    (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n+   (set (match_dup 1)\n+    (unspec_volatile:ALLI\n+      [(not:ALLI\n+\t (and:ALLI (match_dup 1)\n+\t   (match_operand:ALLI 2 \"aarch64_logical_operand\" \"rn\")))\n+       (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+      UNSPECV_ATOMIC_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:ALLI 4 \"=&r\"))\n+   (clobber (match_scratch:SI 5 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_atomic_op (NOT, operands[0], operands[4], operands[1],\n+\t\t\t    operands[2], operands[3], operands[5]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_<atomic_optab>_fetch<mode>\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n+    (atomic_op:ALLI\n+      (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\")\n+      (match_operand:ALLI 2 \"<atomic_op_operand>\" \"rn\")))\n+   (set (match_dup 1)\n+    (unspec_volatile:ALLI\n+      [(match_dup 1) (match_dup 2)\n+       (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+      UNSPECV_ATOMIC_OP))\n+    (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_atomic_op (<CODE>, NULL, operands[0], operands[1],\n+\t\t\t     operands[2], operands[3], operands[4]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"atomic_nand_fetch<mode>\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n+    (not:ALLI\n+      (and:ALLI\n+\t(match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\")\n+\t(match_operand:ALLI 2 \"aarch64_logical_operand\" \"rn\"))))\n+   (set (match_dup 1)\n+    (unspec_volatile:ALLI\n+      [(match_dup 1) (match_dup 2)\n+       (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+      UNSPECV_ATOMIC_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_atomic_op (NOT, NULL, operands[0], operands[1],\n+\t\t\t    operands[2], operands[3], operands[4]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"atomic_load<mode>\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=r\")\n+    (unspec_volatile:ALLI\n+      [(match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"Q\")\n+       (match_operand:SI 2 \"const_int_operand\")]\t\t\t;; model\n+      UNSPECV_LDA))]\n+  \"\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+    if (model == MEMMODEL_RELAXED\n+\t|| model == MEMMODEL_CONSUME\n+\t|| model == MEMMODEL_RELEASE)\n+      return \"ldr<atomic_sfx>\\t%<w>0, %1\";\n+    else\n+      return \"ldar<atomic_sfx>\\t%<w>0, %1\";\n+  }\n+)\n+\n+(define_insn \"atomic_store<mode>\"\n+  [(set (match_operand:ALLI 0 \"memory_operand\" \"=Q\")\n+    (unspec_volatile:ALLI\n+      [(match_operand:ALLI 1 \"general_operand\" \"rZ\")\n+       (match_operand:SI 2 \"const_int_operand\")]\t\t\t;; model\n+      UNSPECV_STL))]\n+  \"\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+    if (model == MEMMODEL_RELAXED\n+\t|| model == MEMMODEL_CONSUME\n+\t|| model == MEMMODEL_ACQUIRE)\n+      return \"str<atomic_sfx>\\t%<w>1, %0\";\n+    else\n+      return \"stlr<atomic_sfx>\\t%<w>1, %0\";\n+  }\n+)\n+\n+(define_insn \"aarch64_load_exclusive<mode>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+    (zero_extend:SI\n+      (unspec_volatile:SHORT\n+\t[(match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"Q\")\n+\t (match_operand:SI 2 \"const_int_operand\")]\n+\tUNSPECV_LX)))]\n+  \"\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+    if (model == MEMMODEL_RELAXED\n+\t|| model == MEMMODEL_CONSUME\n+\t|| model == MEMMODEL_RELEASE)\n+      return \"ldxr<atomic_sfx>\\t%w0, %1\";\n+    else\n+      return \"ldaxr<atomic_sfx>\\t%w0, %1\";\n+  }\n+)\n+\n+(define_insn \"aarch64_load_exclusive<mode>\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=r\")\n+    (unspec_volatile:GPI\n+      [(match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"Q\")\n+       (match_operand:SI 2 \"const_int_operand\")]\n+      UNSPECV_LX))]\n+  \"\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+    if (model == MEMMODEL_RELAXED\n+\t|| model == MEMMODEL_CONSUME\n+\t|| model == MEMMODEL_RELEASE)\n+      return \"ldxr\\t%<w>0, %1\";\n+    else\n+      return \"ldaxr\\t%<w>0, %1\";\n+  }\n+)\n+\n+(define_insn \"aarch64_store_exclusive<mode>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+    (unspec_volatile:SI [(const_int 0)] UNSPECV_SX))\n+   (set (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"=Q\")\n+    (unspec_volatile:ALLI\n+      [(match_operand:ALLI 2 \"register_operand\" \"r\")\n+       (match_operand:SI 3 \"const_int_operand\")]\n+      UNSPECV_SX))]\n+  \"\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n+    if (model == MEMMODEL_RELAXED\n+\t|| model == MEMMODEL_CONSUME\n+\t|| model == MEMMODEL_ACQUIRE)\n+      return \"stxr<atomic_sfx>\\t%w0, %<w>2, %1\";\n+    else\n+      return \"stlxr<atomic_sfx>\\t%w0, %<w>2, %1\";\n+  }\n+)\n+\n+(define_expand \"mem_thread_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\" \"\")]\n+  \"\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[0]);\n+    if (model != MEMMODEL_RELAXED && model != MEMMODEL_CONSUME)\n+      emit_insn (gen_dmb (operands[0]));\n+    DONE;\n+  }\n+)\n+\n+(define_expand \"dmb\"\n+  [(set (match_dup 1)\n+    (unspec:BLK [(match_dup 1) (match_operand:SI 0 \"const_int_operand\")]\n+     UNSPEC_MB))]\n+   \"\"\n+   {\n+    operands[1] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+    MEM_VOLATILE_P (operands[1]) = 1;\n+  }\n+)\n+\n+(define_insn \"*dmb\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+    (unspec:BLK [(match_dup 0) (match_operand:SI 1 \"const_int_operand\")]\n+     UNSPEC_MB))]\n+  \"\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[1]);\n+    if (model == MEMMODEL_ACQUIRE)\n+      return \"dmb\\\\tishld\";\n+    else\n+      return \"dmb\\\\tish\";\n+  }\n+)"}]}