{"sha": "844ae01db8ad6b8e57daa9575efbe1ff167f816e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ0YWUwMWRiOGFkNmI4ZTU3ZGFhOTU3NWVmYmUxZmYxNjdmODE2ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-07-31T05:07:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-07-31T05:07:10Z"}, "message": "re PR c++/11309 (Testsuite failures in g++.dg/expr/anew1.C (and anew2.C anew3.C anew4.c))\n\n        PR c++/11309\n        * tree.c (build_aggr_init_expr): Split out...\n        (build_cplus_new): ...from here.\n        (stabilize_init): Don't mess with AGGR_INIT_EXPR either.\n        * init.c (build_new_1): new T() means value-initialization,\n        not default-initialization.\n        (build_vec_init): Likewise.\n        (build_value_init_1): Use build_aggr_init_expr.\n\nFrom-SVN: r138355", "tree": {"sha": "4c377201cbda61af3498bf53c2cea3af56936cd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c377201cbda61af3498bf53c2cea3af56936cd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/844ae01db8ad6b8e57daa9575efbe1ff167f816e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844ae01db8ad6b8e57daa9575efbe1ff167f816e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/844ae01db8ad6b8e57daa9575efbe1ff167f816e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844ae01db8ad6b8e57daa9575efbe1ff167f816e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "636b71b99ca087d00936621b9c518b3451254a2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b71b99ca087d00936621b9c518b3451254a2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636b71b99ca087d00936621b9c518b3451254a2c"}], "stats": {"total": 163, "additions": 117, "deletions": 46}, "files": [{"sha": "f01593df6dfec452a8158c6da7694b1efa506893", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -1,3 +1,14 @@\n+2008-07-31  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/11309\n+\t* tree.c (build_aggr_init_expr): Split out...\n+\t(build_cplus_new): ...from here.\n+\t(stabilize_init): Don't mess with AGGR_INIT_EXPR either.\n+\t* init.c (build_new_1): new T() means value-initialization, \n+\tnot default-initialization.\n+\t(build_vec_init): Likewise.\n+\t(build_value_init_1): Use build_aggr_init_expr.\n+\t\n 2008-07-30  Dodji Seketeli  <dseketel@redhat.com>\n \n \tPR c++/36767"}, {"sha": "02d358a8fe6f652cbcb64307dd217b459a9455a6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -4742,6 +4742,7 @@ extern tree build_min_nt\t\t\t(enum tree_code, ...);\n extern tree build_min_non_dep\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_non_dep_call_list\t\t(tree, tree, tree);\n extern tree build_cplus_new\t\t\t(tree, tree);\n+extern tree build_aggr_init_expr\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);\n extern tree build_cplus_array_type\t\t(tree, tree);\n extern tree build_array_of_n_type\t\t(tree, int);"}, {"sha": "5535033e1be6f3b52ccf194532f772dd905537f8", "filename": "gcc/cp/init.c", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -347,7 +347,7 @@ build_value_init_1 (tree type, bool have_ctor)\n   if (CLASS_TYPE_P (type))\n     {\n       if (type_has_user_provided_constructor (type) && !have_ctor)\n-\treturn build_cplus_new\n+\treturn build_aggr_init_expr\n \t  (type,\n \t   build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t      NULL_TREE, type, LOOKUP_NORMAL,\n@@ -511,7 +511,7 @@ perform_member_init (tree member, tree init)\n \t{\n \t  /* Initialization of one array from another.  */\n \t  finish_expr_stmt (build_vec_init (decl, NULL_TREE, TREE_VALUE (init),\n-\t\t\t\t\t    /*explicit_default_init_p=*/false,\n+\t\t\t\t\t    /*explicit_value_init_p=*/false,\n \t\t\t\t\t    /* from_array=*/1,\n                                             tf_warning_or_error));\n \t}\n@@ -1286,7 +1286,7 @@ build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)\n       if (itype && cp_type_quals (itype) != TYPE_UNQUALIFIED)\n \titype = TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);\n       stmt_expr = build_vec_init (exp, NULL_TREE, init,\n-\t\t\t\t  /*explicit_default_init_p=*/false,\n+\t\t\t\t  /*explicit_value_init_p=*/false,\n \t\t\t\t  itype && same_type_p (itype,\n \t\t\t\t\t\t\tTREE_TYPE (exp)),\n                                   complain);\n@@ -2154,19 +2154,19 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   if (is_initialized)\n     {\n       bool stable;\n+      bool explicit_value_init_p = false;\n \n       init_expr = cp_build_indirect_ref (data_addr, NULL, complain);\n \n-      if (array_p)\n+      if (init == void_zero_node)\n \t{\n-\t  bool explicit_default_init_p = false;\n+\t  init = NULL_TREE;\n+\t  explicit_value_init_p = true;\n+\t}\n \n-\t  if (init == void_zero_node)\n-\t    {\n-\t      init = NULL_TREE;\n-\t      explicit_default_init_p = true;\n-\t    }\n-\t  else if (init)\n+      if (array_p)\n+\t{\n+\t  if (init)\n             {\n               if (complain & tf_error)\n                 permerror (\"ISO C++ forbids initialization in array new\");\n@@ -2179,7 +2179,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t\t\t\t\t\t  integer_one_node,\n \t\t\t\t\t\t  complain),\n \t\t\t      init,\n-\t\t\t      explicit_default_init_p,\n+\t\t\t      explicit_value_init_p,\n \t\t\t      /*from_array=*/0,\n                               complain);\n \n@@ -2190,17 +2190,19 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t}\n       else\n \t{\n-\t  if (init == void_zero_node)\n-\t    init = build_default_init (full_type, nelts);\n-\n-\t  if (TYPE_NEEDS_CONSTRUCTING (type))\n+\t  if (TYPE_NEEDS_CONSTRUCTING (type) && !explicit_value_init_p)\n \t    {\n \t      init_expr = build_special_member_call (init_expr,\n \t\t\t\t\t\t     complete_ctor_identifier,\n \t\t\t\t\t\t     init, elt_type,\n \t\t\t\t\t\t     LOOKUP_NORMAL,\n                                                      complain);\n-\t      stable = stabilize_init (init_expr, &init_preeval_expr);\n+\t    }\n+\t  else if (explicit_value_init_p)\n+\t    {\n+\t      /* Something like `new int()'.  */\n+\t      init_expr = build2 (INIT_EXPR, full_type,\n+\t\t\t\t  init_expr, build_value_init (full_type));\n \t    }\n \t  else\n \t    {\n@@ -2216,8 +2218,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n \t      init_expr = cp_build_modify_expr (init_expr, INIT_EXPR, init,\n \t\t\t\t\t\tcomplain);\n-\t      stable = stabilize_init (init_expr, &init_preeval_expr);\n \t    }\n+\t  stable = stabilize_init (init_expr, &init_preeval_expr);\n \t}\n \n       if (init_expr == error_mark_node)\n@@ -2662,8 +2664,8 @@ get_temp_regvar (tree type, tree init)\n \n    INIT is the (possibly NULL) initializer.\n \n-   If EXPLICIT_DEFAULT_INIT_P is true, then INIT must be NULL.  All\n-   elements in the array are default-initialized.\n+   If EXPLICIT_VALUE_INIT_P is true, then INIT must be NULL.  All\n+   elements in the array are value-initialized.\n \n    FROM_ARRAY is 0 if we should init everything with INIT\n    (i.e., every element initialized from INIT).\n@@ -2674,7 +2676,7 @@ get_temp_regvar (tree type, tree init)\n \n tree\n build_vec_init (tree base, tree maxindex, tree init,\n-\t\tbool explicit_default_init_p,\n+\t\tbool explicit_value_init_p,\n \t\tint from_array, tsubst_flags_t complain)\n {\n   tree rval;\n@@ -2704,7 +2706,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   if (maxindex == NULL_TREE || maxindex == error_mark_node)\n     return error_mark_node;\n \n-  if (explicit_default_init_p)\n+  if (explicit_value_init_p)\n     gcc_assert (!init);\n \n   inner_elt_type = strip_array_types (atype);\n@@ -2840,7 +2842,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n      We do need to keep going if we're copying an array.  */\n \n   if (from_array\n-      || ((TYPE_NEEDS_CONSTRUCTING (type) || explicit_default_init_p)\n+      || ((TYPE_NEEDS_CONSTRUCTING (type) || explicit_value_init_p)\n \t  && ! (host_integerp (maxindex, 0)\n \t\t&& (num_initialized_elts\n \t\t    == tree_low_cst (maxindex, 0) + 1))))\n@@ -2889,17 +2891,17 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t      (\"cannot initialize multi-dimensional array with initializer\");\n \t  elt_init = build_vec_init (build1 (INDIRECT_REF, type, base),\n \t\t\t\t     0, 0,\n-\t\t\t\t     /*explicit_default_init_p=*/false,\n+\t\t\t\t     explicit_value_init_p,\n \t\t\t\t     0, complain);\n \t}\n-      else if (!TYPE_NEEDS_CONSTRUCTING (type))\n-\telt_init = (cp_build_modify_expr\n-\t\t    (to, INIT_EXPR,\n-\t\t     build_zero_init (type, size_one_node,\n-\t\t\t\t      /*static_storage_p=*/false),\n-\t\t     complain));\n+      else if (explicit_value_init_p)\n+\telt_init = build2 (INIT_EXPR, type, to,\n+\t\t\t   build_value_init (type));\n       else\n-\telt_init = build_aggr_init (to, init, 0, complain);\n+\t{\n+\t  gcc_assert (TYPE_NEEDS_CONSTRUCTING (type));\n+\t  elt_init = build_aggr_init (to, init, 0, complain);\n+\t}\n \n       current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n       finish_expr_stmt (elt_init);"}, {"sha": "4114f868d41e3aada9aa4c6b952bae140046c250", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -339,15 +339,17 @@ build_aggr_init_array (tree return_type, tree fn, tree slot, int nargs,\n }\n \n /* INIT is a CALL_EXPR or AGGR_INIT_EXPR which needs info about its\n-   target.  TYPE is the type that this initialization should appear to\n-   have.\n+   target.  TYPE is the type to be initialized.\n \n-   Build an encapsulation of the initialization to perform\n-   and return it so that it can be processed by language-independent\n-   and language-specific expression expanders.  */\n+   Build an AGGR_INIT_EXPR to represent the initialization.  This function\n+   differs from build_cplus_new in that an AGGR_INIT_EXPR can only be used\n+   to initialize another object, whereas a TARGET_EXPR can either\n+   initialize another object or create its own temporary object, and as a\n+   result building up a TARGET_EXPR requires that the type's destructor be\n+   callable.  */\n \n tree\n-build_cplus_new (tree type, tree init)\n+build_aggr_init_expr (tree type, tree init)\n {\n   tree fn;\n   tree slot;\n@@ -369,8 +371,6 @@ build_cplus_new (tree type, tree init)\n \t     && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n \t     && DECL_CONSTRUCTOR_P (TREE_OPERAND (fn, 0)));\n \n-  slot = build_local_temp (type);\n-\n   /* We split the CALL_EXPR into its function and its arguments here.\n      Then, in expand_expr, we put them back together.  The reason for\n      this is that this expression might be a default argument\n@@ -384,6 +384,8 @@ build_cplus_new (tree type, tree init)\n      type, don't mess with AGGR_INIT_EXPR.  */\n   if (is_ctor || TREE_ADDRESSABLE (type))\n     {\n+      slot = build_local_temp (type);\n+\n       if (TREE_CODE(init) == CALL_EXPR)\n \trval = build_aggr_init_array (void_type_node, fn, slot,\n \t\t\t\t      call_expr_nargs (init),\n@@ -398,6 +400,30 @@ build_cplus_new (tree type, tree init)\n   else\n     rval = init;\n \n+  return rval;\n+}\n+\n+/* INIT is a CALL_EXPR or AGGR_INIT_EXPR which needs info about its\n+   target.  TYPE is the type that this initialization should appear to\n+   have.\n+\n+   Build an encapsulation of the initialization to perform\n+   and return it so that it can be processed by language-independent\n+   and language-specific expression expanders.  */\n+\n+tree\n+build_cplus_new (tree type, tree init)\n+{\n+  tree rval = build_aggr_init_expr (type, init);\n+  tree slot;\n+\n+  if (TREE_CODE (rval) == AGGR_INIT_EXPR)\n+    slot = AGGR_INIT_EXPR_SLOT (rval);\n+  else if (TREE_CODE (rval) == CALL_EXPR)\n+    slot = build_local_temp (type);\n+  else\n+    return rval;\n+\n   rval = build_target_expr (slot, rval);\n   TARGET_EXPR_IMPLICIT_P (rval) = 1;\n \n@@ -2687,7 +2713,8 @@ stabilize_init (tree init, tree *initp)\n     return true;\n \n   if (TREE_CODE (t) == INIT_EXPR\n-      && TREE_CODE (TREE_OPERAND (t, 1)) != TARGET_EXPR)\n+      && TREE_CODE (TREE_OPERAND (t, 1)) != TARGET_EXPR\n+      && TREE_CODE (TREE_OPERAND (t, 1)) != AGGR_INIT_EXPR)\n     {\n       TREE_OPERAND (t, 1) = stabilize_expr (TREE_OPERAND (t, 1), initp);\n       return true;"}, {"sha": "feb6b5f8f547d00bb38f8f56459baeb0e9074815", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -6114,7 +6114,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n       from_array = TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n \t\t   ? 1 + (modifycode != INIT_EXPR): 0;\n       return build_vec_init (lhs, NULL_TREE, newrhs,\n-\t\t\t     /*explicit_default_init_p=*/false,\n+\t\t\t     /*explicit_value_init_p=*/false,\n \t\t\t     from_array, complain);\n     }\n "}, {"sha": "4ce1d8899f96b7f6a99916f0f523b229438b06d7", "filename": "gcc/testsuite/g++.dg/expr/anew4.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fanew4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fanew4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fanew4.C?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -1,5 +1,4 @@\n-// { dg-do run { xfail *-*-* } }\n-// XFAILed until PR2123 is fixed\n+// { dg-do run }\n // PR 11228: array operator new, with zero-initialization and a variable sized array.\n // Regression test for PR \n // Author: Matt Austern <austern@apple.com>"}, {"sha": "487baabeceb68af3f3eb91c37f6e54fb58b1b041", "filename": "gcc/testsuite/g++.dg/init/value3.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fvalue3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fvalue3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fvalue3.C?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -0,0 +1,31 @@\n+// Testcase for value-initialization in new-expressions.\n+// { dg-do run }\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+// Make sure that we return memory that isn't already set to 0.\n+void *operator new(size_t s)\n+{\n+  void *p = malloc (s);\n+  memset (p, 42, s);\n+  return p;\n+}\n+\n+struct A { A() {} ~A() {} };\n+struct B { A a; int i; };\n+\n+int main()\n+{\n+  B *p = new B();\n+  if (p->i != 0)\n+    abort();\n+\n+  p = new B[2]();\n+  if (p[0].i != 0 || p[1].i != 0)\n+    abort();\n+\n+  B(*p2)[2] = new B[2][2]();\n+  if (p2[0][0].i != 0 || p2[0][1].i != 0)\n+    abort();\n+}"}, {"sha": "ae1121339cf5c7f7f7bfc701a8f8a7efc5d35842", "filename": "gcc/testsuite/g++.dg/lookup/new1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fnew1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fnew1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fnew1.C?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -4,10 +4,10 @@\n \n int main() {\n   int i;\n-  void* operator new(unsigned s, int* p);\n+  void* operator new(__SIZE_TYPE__ s, int* p);\n   int* e = new(&i) int;                    // { dg-error \"no matching function\" }\n   int* f = new int;\n   return 0;\n }\n \n-// { dg-excess-errors \"operator new\" }\n+// { dg-error \"candidate\" \"\" { target *-*-* } 0 }"}, {"sha": "d2edb1953a348e90d4267a027de870c215dfe132", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr31146-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/844ae01db8ad6b8e57daa9575efbe1ff167f816e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146-2.C?ref=844ae01db8ad6b8e57daa9575efbe1ff167f816e", "patch": "@@ -20,5 +20,5 @@ double foo (void)\n   return v.a[2];\n }\n \n-/* { dg-final { scan-tree-dump \"Replaced .*iftmp.* != 0B. with .1\" \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced .* != 0B. with .1\" \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}]}