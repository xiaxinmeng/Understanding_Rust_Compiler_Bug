{"sha": "9a182ef9ee011935d827ab5c6c9a7cd8e22257d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWExODJlZjllZTAxMTkzNWQ4MjdhYjVjNmM5YTdjZDhlMjIyNTdkOA==", "commit": {"author": {"name": "Fei Yang", "email": "felix.yang@huawei.com", "date": "2020-06-05T09:34:59Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-06-05T09:34:59Z"}, "message": "expand: Simplify removing subregs when expanding a copy [PR95254]\n\nIn rtl expand, if we have a copy that matches one of the following patterns:\n  (set (subreg:M1 (reg:M2 ...)) (subreg:M1 (reg:M2 ...)))\n  (set (subreg:M1 (reg:M2 ...)) (mem:M1 ADDR))\n  (set (mem:M1 ADDR) (subreg:M1 (reg:M2 ...)))\n  (set (subreg:M1 (reg:M2 ...)) (constant C))\nwhere mode M1 is equal in size to M2, try to detect whether the mode change\ninvolves an implicit round trip through memory.  If so, see if we can avoid\nthat by removing the subregs and doing the move in mode M2 instead.\n\n2020-06-05  Felix Yang  <felix.yang@huawei.com>\n\ngcc/\n\tPR target/95254\n\t* expr.c (emit_move_insn): Check src and dest of the copy to see\n\tif one or both of them are subregs, try to remove the subregs when\n\tinnermode and outermode are equal in size and the mode change involves\n\tan implicit round trip through memory.\n\ngcc/testsuite/\n\tPR target/95254\n\t* gcc.target/aarch64/pr95254.c: New test.\n\t* gcc.target/i386/pr67609.c: Check \"movq\\t%xmm0\" instead of \"movdqa\".", "tree": {"sha": "b887ecf2cc31b2256c9326d2d5ff45f71e819fd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b887ecf2cc31b2256c9326d2d5ff45f71e819fd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8/comments", "author": null, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "892b51cb73f24157391cd18c2215e8d703af97e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/892b51cb73f24157391cd18c2215e8d703af97e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/892b51cb73f24157391cd18c2215e8d703af97e7"}], "stats": {"total": 95, "additions": 94, "deletions": 1}, "files": [{"sha": "ca6b1c1291e794620f41d7c4d8b1bec860963314", "filename": "gcc/expr.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9a182ef9ee011935d827ab5c6c9a7cd8e22257d8", "patch": "@@ -3814,6 +3814,80 @@ emit_move_insn (rtx x, rtx y)\n   gcc_assert (mode != BLKmode\n \t      && (GET_MODE (y) == mode || GET_MODE (y) == VOIDmode));\n \n+  /* If we have a copy that looks like one of the following patterns:\n+       (set (subreg:M1 (reg:M2 ...)) (subreg:M1 (reg:M2 ...)))\n+       (set (subreg:M1 (reg:M2 ...)) (mem:M1 ADDR))\n+       (set (mem:M1 ADDR) (subreg:M1 (reg:M2 ...)))\n+       (set (subreg:M1 (reg:M2 ...)) (constant C))\n+     where mode M1 is equal in size to M2, try to detect whether the\n+     mode change involves an implicit round trip through memory.\n+     If so, see if we can avoid that by removing the subregs and\n+     doing the move in mode M2 instead.  */\n+\n+  rtx x_inner = NULL_RTX;\n+  rtx y_inner = NULL_RTX;\n+\n+  auto candidate_subreg_p = [&](rtx subreg) {\n+    return (REG_P (SUBREG_REG (subreg))\n+\t    && known_eq (GET_MODE_SIZE (GET_MODE (SUBREG_REG (subreg))),\n+\t\t\t GET_MODE_SIZE (GET_MODE (subreg)))\n+\t    && optab_handler (mov_optab, GET_MODE (SUBREG_REG (subreg)))\n+\t       != CODE_FOR_nothing);\n+  };\n+\n+  auto candidate_mem_p = [&](machine_mode innermode, rtx mem) {\n+    return (!targetm.can_change_mode_class (innermode, GET_MODE (mem), ALL_REGS)\n+\t    && !push_operand (mem, GET_MODE (mem))\n+\t    /* Not a candiate if innermode requires too much alignment.  */\n+\t    && (MEM_ALIGN (mem) >= GET_MODE_ALIGNMENT (innermode)\n+\t\t|| targetm.slow_unaligned_access (GET_MODE (mem),\n+\t\t\t\t\t\t  MEM_ALIGN (mem))\n+\t\t|| !targetm.slow_unaligned_access (innermode,\n+\t\t\t\t\t\t   MEM_ALIGN (mem))));\n+  };\n+\n+  if (SUBREG_P (x) && candidate_subreg_p (x))\n+    x_inner = SUBREG_REG (x);\n+\n+  if (SUBREG_P (y) && candidate_subreg_p (y))\n+    y_inner = SUBREG_REG (y);\n+\n+  if (x_inner != NULL_RTX\n+      && y_inner != NULL_RTX\n+      && GET_MODE (x_inner) == GET_MODE (y_inner)\n+      && !targetm.can_change_mode_class (GET_MODE (x_inner), mode, ALL_REGS))\n+    {\n+      x = x_inner;\n+      y = y_inner;\n+      mode = GET_MODE (x_inner);\n+    }\n+  else if (x_inner != NULL_RTX\n+\t   && MEM_P (y)\n+\t   && candidate_mem_p (GET_MODE (x_inner), y))\n+    {\n+      x = x_inner;\n+      y = adjust_address (y, GET_MODE (x_inner), 0);\n+      mode = GET_MODE (x_inner);\n+    }\n+  else if (y_inner != NULL_RTX\n+\t   && MEM_P (x)\n+\t   && candidate_mem_p (GET_MODE (y_inner), x))\n+    {\n+      x = adjust_address (x, GET_MODE (y_inner), 0);\n+      y = y_inner;\n+      mode = GET_MODE (y_inner);\n+    }\n+  else if (x_inner != NULL_RTX\n+\t   && CONSTANT_P (y)\n+\t   && !targetm.can_change_mode_class (GET_MODE (x_inner),\n+\t\t\t\t\t      mode, ALL_REGS)\n+\t   && (y_inner = simplify_subreg (GET_MODE (x_inner), y, mode, 0)))\n+    {\n+      x = x_inner;\n+      y = y_inner;\n+      mode = GET_MODE (x_inner);\n+    }\n+\n   if (CONSTANT_P (y))\n     {\n       if (optimize"}, {"sha": "10bfc868197a11e249713e7fb9e8e3ff33f411bb", "filename": "gcc/testsuite/gcc.target/aarch64/pr95254.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr95254.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr95254.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr95254.c?ref=9a182ef9ee011935d827ab5c6c9a7cd8e22257d8", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-slp-vectorize -march=armv8.2-a+sve -msve-vector-bits=256\" } */\n+\n+typedef short __attribute__((vector_size (8))) v4hi;\n+\n+typedef union U4HI { v4hi v; short a[4]; } u4hi;\n+\n+short b[4];\n+\n+void pass_v4hi (v4hi v)\n+{\n+    int i;\n+    u4hi u;\n+    u.v = v;\n+    for (i = 0; i < 4; i++)\n+      b[i] = u.a[i];\n+};\n+\n+/* { dg-final { scan-assembler-not \"ptrue\" } } */"}, {"sha": "398cdba5d5f1d20c6673354d86d1cc0bbe04c64e", "filename": "gcc/testsuite/gcc.target/i386/pr67609.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67609.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a182ef9ee011935d827ab5c6c9a7cd8e22257d8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67609.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67609.c?ref=9a182ef9ee011935d827ab5c6c9a7cd8e22257d8", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -msse2\" } */\n /* { dg-require-effective-target lp64 } */\n-/* { dg-final { scan-assembler \"movdqa\" } } */\n+/* { dg-final { scan-assembler \"movq\\t%xmm0\" } } */\n \n #include <emmintrin.h>\n __m128d reg;"}]}