{"sha": "056a3b121c17e7614fadc394c00383b35460f142", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU2YTNiMTIxYzE3ZTc2MTRmYWRjMzk0YzAwMzgzYjM1NDYwZjE0Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-20T12:30:50Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-20T12:30:50Z"}, "message": "* class.c (maybe_warn_about_overly_private_class): Reformat.\n\nFrom-SVN: r22502", "tree": {"sha": "86083eff717ea5271a9e531db1d9cac5cb8c356f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86083eff717ea5271a9e531db1d9cac5cb8c356f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/056a3b121c17e7614fadc394c00383b35460f142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/056a3b121c17e7614fadc394c00383b35460f142", "html_url": "https://github.com/Rust-GCC/gccrs/commit/056a3b121c17e7614fadc394c00383b35460f142", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/056a3b121c17e7614fadc394c00383b35460f142/comments", "author": null, "committer": null, "parents": [{"sha": "3add584574c8fa2716b86cec451b47987a900caf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3add584574c8fa2716b86cec451b47987a900caf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3add584574c8fa2716b86cec451b47987a900caf"}], "stats": {"total": 215, "additions": 111, "deletions": 104}, "files": [{"sha": "dcbb93beb9cdae2c44de6eace89e558a37825939", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/056a3b121c17e7614fadc394c00383b35460f142/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/056a3b121c17e7614fadc394c00383b35460f142/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=056a3b121c17e7614fadc394c00383b35460f142", "patch": "@@ -1,3 +1,7 @@\n+1998-09-20  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* class.c (maybe_warn_about_overly_private_class): Reformat.\n+\n 1998-09-17  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* exception.cc (__cplus_type_matcher): realign some code."}, {"sha": "624c05898db621de84e090684c8de230afc13a3c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 107, "deletions": 104, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/056a3b121c17e7614fadc394c00383b35460f142/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/056a3b121c17e7614fadc394c00383b35460f142/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=056a3b121c17e7614fadc394c00383b35460f142", "patch": "@@ -1910,129 +1910,132 @@ static void\n maybe_warn_about_overly_private_class (t)\n      tree t;\n {\n-  if (warn_ctor_dtor_privacy\n+  int has_member_fn = 0;\n+  int has_nonprivate_method = 0;\n+  tree fn;\n+\n+  if (!warn_ctor_dtor_privacy\n       /* If the class has friends, those entities might create and\n \t access instances, so we should not warn.  */\n-      && !(CLASSTYPE_FRIEND_CLASSES (t)\n-\t   || DECL_FRIENDLIST (TYPE_MAIN_DECL (t)))\n+      || (CLASSTYPE_FRIEND_CLASSES (t)\n+\t  || DECL_FRIENDLIST (TYPE_MAIN_DECL (t)))\n       /* We will have warned when the template was declared; there's\n \t no need to warn on every instantiation.  */\n-      && !CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n-    {\n-      /* We only issue one warning, if more than one applies, because\n-\t otherwise, on code like:\n-\n-\t   class A {\n-\t     // Oops - forgot `public:'\n-\t     A();\n-\t     A(const A&);\n-\t     ~A();\n-\t   };\n-\n-\t we warn several times about essentially the same problem.  */\n-\n-      int has_member_fn = 0;\n-      int has_nonprivate_method = 0;\n-      tree fn;\n-\n-      /* Check to see if all (non-constructor, non-destructor) member\n-\t functions are private.  (Since there are no friends or\n-\t non-private statics, we can't ever call any of the private\n-\t member functions.)  */\n-      for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n-\t/* We're not interested in compiler-generated methods; they\n-\t   don't provide any way to call private members.  */\n-\tif (!DECL_ARTIFICIAL (fn)) \n+      || CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n+    /* There's no reason to even consider warning about this \n+       class.  */\n+    return;\n+    \n+  /* We only issue one warning, if more than one applies, because\n+     otherwise, on code like:\n+\n+     class A {\n+       // Oops - forgot `public:'\n+       A();\n+       A(const A&);\n+       ~A();\n+     };\n+\n+     we warn several times about essentially the same problem.  */\n+\n+  /* Check to see if all (non-constructor, non-destructor) member\n+     functions are private.  (Since there are no friends or\n+     non-private statics, we can't ever call any of the private member\n+     functions.)  */\n+  for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n+    /* We're not interested in compiler-generated methods; they don't\n+       provide any way to call private members.  */\n+    if (!DECL_ARTIFICIAL (fn)) \n+      {\n+\tif (!TREE_PRIVATE (fn))\n \t  {\n-\t    if (!TREE_PRIVATE (fn))\n-\t      {\n-\t\tif (DECL_STATIC_FUNCTION_P (fn)) \n-\t\t  /* A non-private static member function is just like a\n-\t\t     friend; it can create and invoke private member\n-\t\t     functions, and be accessed without a class\n-\t\t     instance.  */\n-\t\t  return;\n+\t    if (DECL_STATIC_FUNCTION_P (fn)) \n+\t      /* A non-private static member function is just like a\n+\t\t friend; it can create and invoke private member\n+\t\t functions, and be accessed without a class\n+\t\t instance.  */\n+\t      return;\n \t\t\n-\t\thas_nonprivate_method = 1;\n-\t\tbreak;\n-\t      }\n-\t    else\n-\t      has_member_fn = 1;\n-\t  } \n+\t    has_nonprivate_method = 1;\n+\t    break;\n+\t  }\n+\telse\n+\t  has_member_fn = 1;\n+      } \n \n-      if (!has_nonprivate_method && has_member_fn) \n+  if (!has_nonprivate_method && has_member_fn) \n+    {\n+      int i;\n+      tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n+      for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); i++)\n+\tif (TREE_VIA_PUBLIC (TREE_VEC_ELT (binfos, i))\n+\t    || TREE_VIA_PROTECTED (TREE_VEC_ELT (binfos, i)))\n+\t  {\n+\t    has_nonprivate_method = 1;\n+\t    break;\n+\t  }\n+      if (!has_nonprivate_method) \n \t{\n-\t  int i;\n-\t  tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n-\t  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); i++)\n-\t    if (TREE_VIA_PUBLIC (TREE_VEC_ELT (binfos, i))\n-\t\t|| TREE_VIA_PROTECTED (TREE_VEC_ELT (binfos, i)))\n-\t      {\n-\t\thas_nonprivate_method = 1;\n-\t\tbreak;\n-\t      }\n-\t  if (!has_nonprivate_method) \n-\t    {\n-\t      cp_warning (\"all member functions in class `%T' are private\", t);\n-\t      return;\n-\t    }\n+\t  cp_warning (\"all member functions in class `%T' are private\", t);\n+\t  return;\n \t}\n+    }\n \n-      /* Even if some of the member functions are non-private, the\n-\t class won't be useful for much if all the constructors or\n-\t destructors are private: such an object can never be created\n-\t or destroyed.  */\n-      if (TYPE_HAS_DESTRUCTOR (t))\n-\t{\n-\t  tree dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1);\n+  /* Even if some of the member functions are non-private, the class\n+     won't be useful for much if all the constructors or destructors\n+     are private: such an object can never be created or destroyed.  */\n+  if (TYPE_HAS_DESTRUCTOR (t))\n+    {\n+      tree dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1);\n \n-\t  if (TREE_PRIVATE (dtor))\n-\t    {\n-\t      cp_warning (\"`%#T' only defines a private destructor and has no friends\",\n-\t\t\t  t);\n-\t      return;\n-\t    }\n+      if (TREE_PRIVATE (dtor))\n+\t{\n+\t  cp_warning (\"`%#T' only defines a private destructor and has no friends\",\n+\t\t      t);\n+\t  return;\n \t}\n+    }\n \n-      if (TYPE_HAS_CONSTRUCTOR (t))\n-\t{\n-\t  int nonprivate_ctor = 0;\n+  if (TYPE_HAS_CONSTRUCTOR (t))\n+    {\n+      int nonprivate_ctor = 0;\n \t  \n-\t  /* If a non-template class does not define a copy\n-\t     constructor, one is defined for it, enabling it to avoid\n-\t     this warning.  For a template class, this does not\n-\t     happen, and so we would normally get a warning on:\n+      /* If a non-template class does not define a copy\n+\t constructor, one is defined for it, enabling it to avoid\n+\t this warning.  For a template class, this does not\n+\t happen, and so we would normally get a warning on:\n \n-\t       template <class T> class C { private: C(); };  \n+\t   template <class T> class C { private: C(); };  \n \t  \n-\t     To avoid this asymmetry, we check TYPE_HAS_INIT_REF.  */ \n-\t  if (!TYPE_HAS_INIT_REF (t))\n-\t    nonprivate_ctor = 1;\n-\t  else \n-\t    for (fn = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n-\t\t fn;\n-\t\t fn = OVL_NEXT (fn)) \n+\t To avoid this asymmetry, we check TYPE_HAS_INIT_REF.  All\n+\t complete non-template or fully instantiated classes have this\n+\t flag set.  */\n+      if (!TYPE_HAS_INIT_REF (t))\n+\tnonprivate_ctor = 1;\n+      else \n+\tfor (fn = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n+\t     fn;\n+\t     fn = OVL_NEXT (fn)) \n+\t  {\n+\t    tree ctor = OVL_CURRENT (fn);\n+\t    /* Ideally, we wouldn't count copy constructors (or, in\n+\t       fact, any constructor that takes an argument of the\n+\t       class type as a parameter) because such things cannot\n+\t       be used to construct an instance of the class unless\n+\t       you already have one.  But, for now at least, we're\n+\t       more generous.  */\n+\t    if (! TREE_PRIVATE (ctor))\n \t      {\n-\t\ttree ctor = OVL_CURRENT (fn);\n-\t\t/* Ideally, we wouldn't count copy constructors (or, in\n-\t\t   fact, any constructor that takes an argument of the\n-\t\t   class type as a parameter) because such things cannot\n-\t\t   be used to construct an instance of the class unless\n-\t\t   you already have one.  But, for now at least, we're\n-\t\t   more generous.  */\n-\t\tif (! TREE_PRIVATE (ctor))\n-\t\t  {\n-\t\t    nonprivate_ctor = 1;\n-\t\t    break;\n-\t\t  }\n+\t\tnonprivate_ctor = 1;\n+\t\tbreak;\n \t      }\n+\t  }\n \n-\t  if (nonprivate_ctor == 0)\n-\t    {\n-\t      cp_warning (\"`%#T' only defines private constructors and has no friends\",\n-\t\t\t  t);\n-\t      return;\n-\t    }\n+      if (nonprivate_ctor == 0)\n+\t{\n+\t  cp_warning (\"`%#T' only defines private constructors and has no friends\",\n+\t\t      t);\n+\t  return;\n \t}\n     }\n }"}]}