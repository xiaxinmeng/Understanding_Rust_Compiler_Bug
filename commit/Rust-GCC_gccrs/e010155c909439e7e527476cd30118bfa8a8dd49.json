{"sha": "e010155c909439e7e527476cd30118bfa8a8dd49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAxMDE1NWM5MDk0MzllN2U1Mjc0NzZjZDMwMTE4YmZhOGE4ZGQ0OQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-22T01:23:03Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-22T01:23:03Z"}, "message": "(emit_library_call_value): Really pass mem value address\nto the library function.\n\nFrom-SVN: r3511", "tree": {"sha": "a9ad78658cfc2ba3fa9e2f27a6964790a2ed47d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9ad78658cfc2ba3fa9e2f27a6964790a2ed47d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e010155c909439e7e527476cd30118bfa8a8dd49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e010155c909439e7e527476cd30118bfa8a8dd49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e010155c909439e7e527476cd30118bfa8a8dd49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e010155c909439e7e527476cd30118bfa8a8dd49/comments", "author": null, "committer": null, "parents": [{"sha": "e53bfc4bb645c747242a8d5d51960acc7b509946", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e53bfc4bb645c747242a8d5d51960acc7b509946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e53bfc4bb645c747242a8d5d51960acc7b509946"}], "stats": {"total": 71, "additions": 63, "deletions": 8}, "files": [{"sha": "6342e5bcb0a39b30820cd35ba57bf8f08b1422aa", "filename": "gcc/expr.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e010155c909439e7e527476cd30118bfa8a8dd49/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e010155c909439e7e527476cd30118bfa8a8dd49/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e010155c909439e7e527476cd30118bfa8a8dd49", "patch": "@@ -2337,7 +2337,8 @@ emit_library_call (va_alist)\n }\n \f\n /* Like emit_library_call except that an extra argument, VALUE,\n-   comes second and says where to store the result.  */\n+   comes second and says where to store the result.\n+   (If VALUE is zero, the result comes in the function value register.)  */\n \n void\n emit_library_call_value (va_alist)\n@@ -2392,14 +2393,58 @@ emit_library_call_value (va_alist)\n      of the full argument passing conventions to limit complexity here since\n      library functions shouldn't have many args.  */\n \n-  argvec = (struct arg *) alloca (nargs * sizeof (struct arg));\n+  argvec = (struct arg *) alloca ((nargs + 1) * sizeof (struct arg));\n \n   INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun);\n \n   args_size.constant = 0;\n   args_size.var = 0;\n \n-  for (count = 0; count < nargs; count++)\n+  count = 0;\n+\n+  /* If there's a structure value address to be passed,\n+     either pass it in the special place, or pass it as an extra argument.  */\n+  if (mem_value)\n+    {\n+      rtx addr = XEXP (mem_value, 0);\n+\n+      if (! struct_value_rtx)\n+\t{\n+\t  nargs++;\n+\n+\t  /* Make sure it is a reasonable operand for a move or push insn.  */\n+\t  if (GET_CODE (addr) != REG && GET_CODE (addr) != MEM\n+\t      && ! (CONSTANT_P (addr) && LEGITIMATE_CONSTANT_P (addr)))\n+\t    addr = force_operand (addr, NULL_RTX);\n+\n+\t  argvec[count].value = addr;\n+\t  argvec[count].mode = outmode;\n+\t  argvec[count].partial = 0;\n+\n+\t  argvec[count].reg = FUNCTION_ARG (args_so_far, outmode, NULL_TREE, 1);\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+\t  if (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, outmode, NULL_TREE, 1))\n+\t    abort ();\n+#endif\n+\n+\t  locate_and_pad_parm (outmode, NULL_TREE,\n+\t\t\t       argvec[count].reg && argvec[count].partial == 0,\n+\t\t\t       NULL_TREE, &args_size, &argvec[count].offset,\n+\t\t\t       &argvec[count].size);\n+\n+\n+\t  if (argvec[count].reg == 0 || argvec[count].partial != 0\n+#ifdef REG_PARM_STACK_SPACE\n+\t      || 1\n+#endif\n+\t      )\n+\t    args_size.constant += argvec[count].size.constant;\n+\n+\t  FUNCTION_ARG_ADVANCE (args_so_far, outmode, (tree)0, 1);\n+\t}\n+    }\n+\n+  for (; count < nargs; count++)\n     {\n       rtx val = va_arg (p, rtx);\n       enum machine_mode mode = va_arg (p, enum machine_mode);\n@@ -2559,6 +2604,9 @@ emit_library_call_value (va_alist)\n \n   /* Now load any reg parms into their regs.  */\n \n+  if (mem_value != 0 && struct_value_rtx != 0)\n+    emit_move_insn (struct_value_rtx, addr);\n+\n   for (count = 0; count < nargs; count++, argnum += inc)\n     {\n       register enum machine_mode mode = argvec[argnum].mode;\n@@ -2571,9 +2619,11 @@ emit_library_call_value (va_alist)\n       NO_DEFER_POP;\n     }\n \n+#if 0\n   /* For version 1.37, try deleting this entirely.  */\n   if (! no_queue)\n     emit_queue ();\n+#endif\n \n   /* Any regs containing parms remain in use through the call.  */\n   start_sequence ();\n@@ -2602,13 +2652,18 @@ emit_library_call_value (va_alist)\n   OK_DEFER_POP;\n \n   /* Copy the value to the right place.  */\n-  if (mem_value)\n+  if (outmode != VOIDmode)\n     {\n-      if (value != mem_value)\n-\temit_move_insn (value, mem_value);\n+      if (mem_value)\n+\t{\n+\t  if (value == 0)\n+\t    value = hard_libcall_value (outmode);\n+\t  if (value != mem_value)\n+\t    emit_move_insn (value, mem_value);\n+\t}\n+      else if (value != 0)\n+\temit_move_insn (value, hard_libcall_value (outmode));\n     }\n-  else\n-    emit_move_insn (value, hard_libcall_value (outmode));\n }\n \f\n /* Expand an assignment that stores the value of FROM into TO."}]}