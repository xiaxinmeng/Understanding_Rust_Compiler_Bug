{"sha": "9e64426dae129cca5b62355ef6c5a3bd6137e830", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU2NDQyNmRhZTEyOWNjYTViNjIzNTVlZjZjNWEzYmQ2MTM3ZTgzMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-06-14T21:37:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-06-16T15:41:08Z"}, "message": "libcpp: location comparison within macro [PR100796]\n\nThe patch for 96391 changed linemap_compare_locations to give up on\ncomparing locations from macro expansions if we don't have column\ninformation.  But in this testcase, the BOILERPLATE macro is multiple lines\nlong, so we do want to compare locations within the macro.  So this patch\nmoves the LINE_MAP_MAX_LOCATION_WITH_COLS check inside the block, to use it\nfor failing gracefully.\n\n\tPR c++/100796\n\tPR preprocessor/96391\n\nlibcpp/ChangeLog:\n\n\t* line-map.c (linemap_compare_locations): Only use comparison with\n\tLINE_MAP_MAX_LOCATION_WITH_COLS to avoid abort.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/plugin/location-overflow-test-pr100796.c: New test.\n\t* g++.dg/plugin/plugin.exp: Run it.", "tree": {"sha": "743aef1e7b4ba903473889568e8f79aedd136b35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/743aef1e7b4ba903473889568e8f79aedd136b35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e64426dae129cca5b62355ef6c5a3bd6137e830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e64426dae129cca5b62355ef6c5a3bd6137e830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e64426dae129cca5b62355ef6c5a3bd6137e830", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e64426dae129cca5b62355ef6c5a3bd6137e830/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd835ec24be9b1a89c6b0c78673de88c81a23966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd835ec24be9b1a89c6b0c78673de88c81a23966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd835ec24be9b1a89c6b0c78673de88c81a23966"}], "stats": {"total": 48, "additions": 38, "deletions": 10}, "files": [{"sha": "7fa964c07e5fd0dbf37c7b133f0ba85eb468b5dd", "filename": "gcc/testsuite/g++.dg/plugin/location-overflow-test-pr100796.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e64426dae129cca5b62355ef6c5a3bd6137e830/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Flocation-overflow-test-pr100796.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e64426dae129cca5b62355ef6c5a3bd6137e830/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Flocation-overflow-test-pr100796.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Flocation-overflow-test-pr100796.c?ref=9e64426dae129cca5b62355ef6c5a3bd6137e830", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/100796\n+// { dg-additional-options \"-Wsuggest-override -fplugin-arg-location_overflow_plugin-value=0x60000001\" }\n+// Passing LINE_MAP_MAX_LOCATION_WITH_COLS meant we stopped distinguishing between lines in a macro.\n+\n+#define DO_PRAGMA(text)           _Pragma(#text)\n+#define WARNING_PUSH              DO_PRAGMA(GCC diagnostic push)\n+#define WARNING_POP               DO_PRAGMA(GCC diagnostic pop)\n+#define WARNING_DISABLE(text)     DO_PRAGMA(GCC diagnostic ignored text)\n+#define NO_OVERRIDE_WARNING       WARNING_DISABLE(\"-Wsuggest-override\")\n+\n+#define BOILERPLATE\t\t\t\t\\\n+  WARNING_PUSH\t\t\t\t\t\\\n+  NO_OVERRIDE_WARNING\t\t\t\t\\\n+  void f();\t\t\t\t\t\\\n+  WARNING_POP\n+\n+struct B\n+{\n+  virtual void f();\n+};\n+\n+struct D: B\n+{\n+  BOILERPLATE\n+};"}, {"sha": "74e12df207c2afd8dfc2d8b06853df800c38f7aa", "filename": "gcc/testsuite/g++.dg/plugin/plugin.exp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e64426dae129cca5b62355ef6c5a3bd6137e830/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e64426dae129cca5b62355ef6c5a3bd6137e830/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp?ref=9e64426dae129cca5b62355ef6c5a3bd6137e830", "patch": "@@ -73,7 +73,8 @@ set plugin_test_list [list \\\n \t  ../../gcc.dg/plugin/diagnostic-test-string-literals-3.c \\\n \t  ../../gcc.dg/plugin/diagnostic-test-string-literals-4.c } \\\n     { ../../gcc.dg/plugin/location_overflow_plugin.c \\\n-\t  location-overflow-test-pr96391.c } \\\n+\t  location-overflow-test-pr96391.c \\\n+          location-overflow-test-pr100796.c } \\\n     { show_template_tree_color_plugin.c \\\n     \t  show-template-tree-color.C \\\n     \t  show-template-tree-color-labels.C \\"}, {"sha": "1a6902acdb7ce75f40c37409c22c9c4125bb1e27", "filename": "libcpp/line-map.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e64426dae129cca5b62355ef6c5a3bd6137e830/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e64426dae129cca5b62355ef6c5a3bd6137e830/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=9e64426dae129cca5b62355ef6c5a3bd6137e830", "patch": "@@ -1421,23 +1421,25 @@ linemap_compare_locations (line_maps *set,\n \n   if (l0 == l1\n       && pre_virtual_p\n-      && post_virtual_p\n-      && l0 <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      && post_virtual_p)\n     {\n       /* So pre and post represent two tokens that are present in a\n \t same macro expansion.  Let's see if the token for pre was\n \t before the token for post in that expansion.  */\n-      unsigned i0, i1;\n       const struct line_map *map =\n \tfirst_map_in_common (set, pre, post, &l0, &l1);\n \n       if (map == NULL)\n-\t/* This should not be possible.  */\n-\tabort ();\n-\n-      i0 = l0 - MAP_START_LOCATION (map);\n-      i1 = l1 - MAP_START_LOCATION (map);\n-      return i1 - i0;\n+\t/* This should not be possible while we have column information, but if\n+\t   we don't, the tokens could be from separate macro expansions on the\n+\t   same line.  */\n+\tgcc_assert (l0 > LINE_MAP_MAX_LOCATION_WITH_COLS);\n+      else\n+\t{\n+\t  unsigned i0 = l0 - MAP_START_LOCATION (map);\n+\t  unsigned i1 = l1 - MAP_START_LOCATION (map);\n+\t  return i1 - i0;\n+\t}\n     }\n \n   if (IS_ADHOC_LOC (l0))"}]}