{"sha": "845bb366adcf702331de3d8022fd0e1c1c918607", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ1YmIzNjZhZGNmNzAyMzMxZGUzZDgwMjJmZDBlMWMxYzkxODYwNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-01-28T19:34:56Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-01-28T19:38:09Z"}, "message": "ipa: fix handling of multiple speculations (PR93318)\n\nThis patch started as work to resole Richard's comment on quadratic lookups\nin resolve_speculation. While doing it I however noticed multiple problems\nin the new speuclative call code which made the patch quite big. In\nparticular:\n 1) Before applying speculation we consider only targets with at lest\n    probability 1/2.\n    If profile is sane at most two targets can have probability greater or\n    equal to 1/2. So the new multi-target speculation code got enabled only\n    in very special scenario when there ae precisely two target with precise\n    probability 1/2 (which is tested by the single testcase).\n\n    As a conseuqence the multiple target logic got minimal test coverage and\n    this made us to miss several ICEs.\n 2) Profile updating in profile merging, tree-inline and indirect call\n    expansion was wrong which led to inconsistent profiles (as already seen\n    on the testcase).\n 3) Code responsible to turn speculative call to direct call was broken for\n    anything with more than one target.\n 4) There were multiple cases where call_site_hash went out of sync which\n    eventually leads to an ICE..\n 5) Some code expects that all speculative call targets forms a sequence in\n    the callee linked list but there is no code to maintain that invariant\n    nor a verifier.\nFixing this it became obvious that the current API of speculative_call_info is\nnot useful because it really builds on fact tht there are precisely three\ncomponents (direct call, ref and indirect call) in every speculative call\nsequence.  I ended up replacing it with iterator API for direct call\n(first_speculative_call_target, next_speculative_call_target) and accessors for\nthe other coponents updating comment in cgraph.h.\n\nFinally I made the work with call site hash more effetive by updating edge\nmanipulation to keep them in sequence. So first one can be looked up from the\nhash and then they can be iterated by callee.\n\nThere are other things that can be improved (for example the speculation should\nstart with most common target first), but I will try to keep that for next\nstage1. This patch is mostly about getting rid of ICE and profile corruption\nwhich is a regression from GCC 9.\n\ngcc/ChangeLog:\n\n\tPR lto/93318\n\t* cgraph.c (cgraph_add_edge_to_call_site_hash): Update call site\n\thash only when edge is first within the sequence.\n\t(cgraph_edge::set_call_stmt): Update handling of speculative calls.\n\t(symbol_table::create_edge): Do not set target_prob.\n\t(cgraph_edge::remove_caller): Watch for speculative calls when updating\n\tthe call site hash.\n\t(cgraph_edge::make_speculative): Drop target_prob parameter.\n\t(cgraph_edge::speculative_call_info): Remove.\n\t(cgraph_edge::first_speculative_call_target): New member function.\n\t(update_call_stmt_hash_for_removing_direct_edge): New function.\n\t(cgraph_edge::resolve_speculation): Rewrite to new API.\n\t(cgraph_edge::speculative_call_for_target): New member function.\n\t(cgraph_edge::make_direct): Rewrite to new API; fix handling of\n\tmultiple speculation targets.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise; fix updating\n\tof profile.\n\t(verify_speculative_call): Verify that targets form an interval.\n\t* cgraph.h (cgraph_edge::speculative_call_info): Remove.\n\t(cgraph_edge::first_speculative_call_target): New member function.\n\t(cgraph_edge::next_speculative_call_target): New member function.\n\t(cgraph_edge::speculative_call_target_ref): New member function.\n\t(cgraph_edge;:speculative_call_indirect_edge): New member funtion.\n\t(cgraph_edge): Remove target_prob.\n\t* cgraphclones.c (cgraph_node::set_call_stmt_including_clones):\n\tFix handling of speculative calls.\n\t* ipa-devirt.c (ipa_devirt): Fix handling of speculative cals.\n\t* ipa-fnsummary.c (analyze_function_body): Likewise.\n\t* ipa-inline.c (speculation_useful_p): Use new speculative call API.\n\t* ipa-profile.c (dump_histogram): Fix formating.\n\t(ipa_profile_generate_summary): Watch for overflows.\n\t(ipa_profile): Do not require probablity to be 1/2; update to new API.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Update to new API.\n\t(update_indirect_edges_after_inlining): Update to new API.\n\t* ipa-utils.c (ipa_merge_profiles): Rewrite merging of speculative call\n\tprofiles.\n\t* profile-count.h: (profile_probability::adjusted): New.\n\t* tree-inline.c (copy_bb): Update to new speculative call API; fix\n\tupdating of profile.\n\t* value-prof.c (gimple_ic_transform): Rename to ...\n\t(dump_ic_profile): ... this one; update dumping.\n\t(stream_in_histogram_value): Fix formating.\n\t(gimple_value_profile_transformations): Update.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/tree-prof/indir-call-prof.C: Update template.\n\t* gcc.dg/tree-prof/crossmodule-indircall-1.c: Add more targets.\n\t* gcc.dg/tree-prof/crossmodule-indircall-1a.c: Add more targets.\n\t* gcc.dg/tree-prof/indir-call-prof.c: Update template.", "tree": {"sha": "2427cc2e79749becee776fd797aaa227519a2361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2427cc2e79749becee776fd797aaa227519a2361"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/845bb366adcf702331de3d8022fd0e1c1c918607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/845bb366adcf702331de3d8022fd0e1c1c918607", "html_url": "https://github.com/Rust-GCC/gccrs/commit/845bb366adcf702331de3d8022fd0e1c1c918607", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/845bb366adcf702331de3d8022fd0e1c1c918607/comments", "author": null, "committer": null, "parents": [{"sha": "dd9b529f08c3c6064c37234922d298336d78caf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd9b529f08c3c6064c37234922d298336d78caf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd9b529f08c3c6064c37234922d298336d78caf7"}], "stats": {"total": 1021, "additions": 491, "deletions": 530}, "files": [{"sha": "3e50b0bc38087582167f5b7c3a36fbd4236b0029", "filename": "gcc/cgraph.c", "status": "modified", "additions": 173, "deletions": 174, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -713,7 +713,9 @@ cgraph_add_edge_to_call_site_hash (cgraph_edge *e)\n   if (*slot)\n     {\n       gcc_assert (((cgraph_edge *)*slot)->speculative);\n-      if (e->callee)\n+      if (e->callee && (!e->prev_callee\n+\t\t\t|| !e->prev_callee->speculative\n+\t\t\t|| e->prev_callee->call_stmt != e->call_stmt))\n \t*slot = e;\n       return;\n     }\n@@ -782,21 +784,40 @@ cgraph_edge::set_call_stmt (cgraph_edge *e, gcall *new_stmt,\n      when asked to.  */\n   if (update_speculative && e->speculative)\n     {\n-      cgraph_edge *direct, *indirect;\n+      cgraph_edge *direct, *indirect, *next;\n       ipa_ref *ref;\n       bool e_indirect = e->indirect_unknown_callee;\n+      int n = 0;\n+\n+      direct = e->first_speculative_call_target ();\n+      indirect = e->speculative_call_indirect_edge ();\n+\n+      gcall *old_stmt = direct->call_stmt;\n+      for (cgraph_edge *d = direct; d; d = next)\n+\t{\n+\t  next = d->next_speculative_call_target ();\n+\t  cgraph_edge *d2 = set_call_stmt (d, new_stmt, false);\n+\t  gcc_assert (d2 == d);\n+\t  n++;\n+\t}\n+      gcc_checking_assert (indirect->num_speculative_call_targets_p () == n);\n+      for (unsigned int i = 0; e->caller->iterate_reference (i, ref); i++)\n+\tif (ref->speculative && ref->stmt == old_stmt)\n+\t  {\n+\t    ref->stmt = new_stmt;\n+\t    n--;\n+\t  }\n \n-      e->speculative_call_info (direct, indirect, ref);\n-      ref->stmt = new_stmt;\n-      cgraph_edge *d2 = set_call_stmt (direct, new_stmt, false);\n-      gcc_assert (direct == d2);\n       indirect = set_call_stmt (indirect, new_stmt, false);\n       return e_indirect ? indirect : direct;\n     }\n \n   /* Only direct speculative edges go to call_site_hash.  */\n   if (e->caller->call_site_hash\n-      && (!e->speculative || !e->indirect_unknown_callee))\n+      && (!e->speculative || !e->indirect_unknown_callee)\n+      /* It is possible that edge was previously speculative.  In this case\n+\t we have different value in call stmt hash which needs preserving.  */\n+      && e->caller->get_edge (e->call_stmt) == e)\n     e->caller->call_site_hash->remove_elt_with_hash\n       (e->call_stmt, cgraph_edge_hasher::hash (e->call_stmt));\n \n@@ -814,7 +835,14 @@ cgraph_edge::set_call_stmt (cgraph_edge *e, gcall *new_stmt,\n \n   function *fun = DECL_STRUCT_FUNCTION (e->caller->decl);\n   e->can_throw_external = stmt_can_throw_external (fun, new_stmt);\n-  if (e->caller->call_site_hash)\n+  /* Update call stite hash.  For speculative calls we only record the first\n+     direct edge.  */\n+  if (e->caller->call_site_hash\n+      && (!e->speculative\n+\t  || (e->callee\n+\t      && (!e->prev_callee || !e->prev_callee->speculative\n+\t\t  || e->prev_callee->call_stmt != e->call_stmt))\n+\t  || (e->speculative && !e->callee)))\n     cgraph_add_edge_to_call_site_hash (e);\n   return e;\n }\n@@ -858,7 +886,6 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   edge->prev_callee = NULL;\n   edge->next_callee = NULL;\n   edge->lto_stmt_uid = 0;\n-  edge->target_prob = 0;\n   edge->speculative_id = 0;\n \n   edge->count = count;\n@@ -992,7 +1019,8 @@ cgraph_edge::remove_caller (void)\n       else\n \tcaller->callees = next_callee;\n     }\n-  if (caller->call_site_hash)\n+  if (caller->call_site_hash\n+      && this == caller->get_edge (call_stmt))\n     caller->call_site_hash->remove_elt_with_hash\n \t(call_stmt, cgraph_edge_hasher::hash (call_stmt));\n }\n@@ -1049,13 +1077,11 @@ cgraph_edge::remove (cgraph_edge *edge)\n    speculative_id is used to link direct calls with their corresponding\n    IPA_REF_ADDR references when representing speculative calls.\n \n-   target_prob is the probability of the speculative call.\n-\n    Return direct edge created.  */\n \n cgraph_edge *\n cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n-\t\t\t       unsigned int speculative_id, int target_prob)\n+\t\t\t       unsigned int speculative_id)\n {\n   cgraph_node *n = caller;\n   ipa_ref *ref = NULL;\n@@ -1074,7 +1100,6 @@ cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n     e2->can_throw_external = can_throw_external;\n   e2->lto_stmt_uid = lto_stmt_uid;\n   e2->speculative_id = speculative_id;\n-  e2->target_prob = target_prob;\n   e2->in_polymorphic_cdtor = in_polymorphic_cdtor;\n   indirect_info->num_speculative_call_targets++;\n   count -= e2->count;\n@@ -1087,91 +1112,59 @@ cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n   return e2;\n }\n \n-/* Speculative calls represent a transformation of indirect calls\n-   which may be later inserted into gimple in the following form:\n-\n-   if (call_dest == target1)\n-   target1 ();\n-   else if (call_dest == target2)\n-   target2 ();\n-   else\n-   call_dest ();\n+/* Speculative call consists of an indirect edge and one or more\n+   direct edge+ref pairs.\n \n-   This is a win in the case when target1 and target2 are common values for\n-   call_dest as determined by ipa-devirt or indirect call profiling.\n-   In particular this may enable inlining and other optimizations.\n+   Given an edge which is part of speculative call, return the first\n+   direct call edge in the speculative call sequence.  */\n \n-   Speculative call consists of the following main components:\n-\n-   1) One or more \"speculative\" direct call (num_speculative_call_targets is\n-   speculative direct call count belongs to the speculative indirect call)\n-   2) One or more IPA_REF_ADDR references (representing the fact that code above\n-   takes address of target1 and target2)\n-   3) The fallback \"speculative\" indirect call\n-\n-   Direct calls and corresponding references are linked by\n-   speculative_id.\n-\n-   speculative_call_info returns triple\n-   (direct_call, indirect call, IPA_REF_ADDR reference)\n-   when called on one edge participating in the speculative call:\n-\n-   1) If called on direct call, its corresponding IPA_REF_ADDR and related\n-   indirect call are returned.\n-\n-   2) If called on indirect call, it will return one of direct edges and its\n-   matching IPA_REF_ADDR.\n- */\n-\n-void\n-cgraph_edge::speculative_call_info (cgraph_edge *&direct,\n-\t\t\t\t    cgraph_edge *&indirect,\n-\t\t\t\t    ipa_ref *&reference)\n+cgraph_edge *\n+cgraph_edge::first_speculative_call_target ()\n {\n-  ipa_ref *ref;\n-  int i;\n-  cgraph_edge *e2;\n   cgraph_edge *e = this;\n \n-  if (!e->indirect_unknown_callee)\n-    for (e2 = e->caller->indirect_calls;\n-\t e2->call_stmt != e->call_stmt || e2->lto_stmt_uid != e->lto_stmt_uid;\n-\t e2 = e2->next_callee)\n-      ;\n-  else\n+  gcc_checking_assert (e->speculative);\n+  if (e->callee)\n+    {\n+      while (e->prev_callee && e->prev_callee->speculative\n+\t     && e->prev_callee->call_stmt == e->call_stmt\n+\t     && e->prev_callee->lto_stmt_uid == e->lto_stmt_uid)\n+\te = e->prev_callee;\n+      return e;\n+    }\n+  /* Call stmt site hash always points to the first target of the\n+     speculative call sequence.  */\n+  if (e->call_stmt)\n+    return e->caller->get_edge (e->call_stmt);\n+  for (cgraph_edge *e2 = e->caller->callees; true; e2 = e2->next_callee)\n+    if (e2->speculative\n+\t&& e->call_stmt == e2->call_stmt\n+\t&& e->lto_stmt_uid == e2->lto_stmt_uid)\n+      return e2;\n+}\n+\n+/* We always maintain first direct edge in the call site hash, if one\n+   exists.  E is going to be removed.  See if it is first one and update\n+   hash accordingly.  INDIRECT is the indirect edge of speculative call.\n+   We assume that INDIRECT->num_speculative_call_targets_p () is already\n+   updated for removal of E.  */\n+static void\n+update_call_stmt_hash_for_removing_direct_edge (cgraph_edge *e,\n+\t\t\t\t\t\tcgraph_edge *indirect)\n+{\n+  if (e->caller->call_site_hash)\n     {\n-      e2 = e;\n-      /* We can take advantage of the call stmt hash.  */\n-      if (e2->call_stmt)\n+      if (e->caller->get_edge (e->call_stmt) != e)\n+\t;\n+      else if (!indirect->num_speculative_call_targets_p ())\n+\tcgraph_update_edge_in_call_site_hash (indirect);\n+      else\n \t{\n-\t  e = e->caller->get_edge (e2->call_stmt);\n-\t  gcc_assert (e->speculative && !e->indirect_unknown_callee);\n+\t  gcc_checking_assert (e->next_callee && e->next_callee->speculative\n+\t\t\t       && e->next_callee->call_stmt == e->call_stmt);\n+\t  cgraph_update_edge_in_call_site_hash (e->next_callee);\n \t}\n-      else\n-\tfor (e = e->caller->callees; \n-\t     e2->call_stmt != e->call_stmt\n-\t     || e2->lto_stmt_uid != e->lto_stmt_uid;\n-\t     e = e->next_callee)\n-\t  ;\n     }\n-  gcc_assert (e->speculative && e2->speculative);\n-  direct = e;\n-  indirect = e2;\n-\n-  reference = NULL;\n-  for (i = 0; e->caller->iterate_reference (i, ref); i++)\n-    if (ref->speculative && ref->speculative_id == e->speculative_id\n-\t&& ((ref->stmt && ref->stmt == e->call_stmt)\n-\t    || (!ref->stmt && ref->lto_stmt_uid == e->lto_stmt_uid)))\n-      {\n-\treference = ref;\n-\tbreak;\n-      }\n-\n-  /* Speculative edge always consist of all three components - direct edge,\n-     indirect and reference.  */\n-  \n-  gcc_assert (e && e2 && ref);\n }\n \n /* Speculative call EDGE turned out to be direct call to CALLEE_DECL.  Remove\n@@ -1195,8 +1188,10 @@ cgraph_edge::resolve_speculation (cgraph_edge *edge, tree callee_decl)\n   cgraph_edge *e2;\n   ipa_ref *ref;\n \n-  gcc_assert (edge->speculative);\n-  edge->speculative_call_info (e2, edge, ref);\n+  gcc_assert (edge->speculative && (!callee_decl || edge->callee));\n+  e2 = edge->first_speculative_call_target ();\n+  ref = e2->speculative_call_target_ref ();\n+  edge = edge->speculative_call_indirect_edge ();\n   if (!callee_decl\n       || !ref->referred->semantically_equivalent_p\n \t   (symtab_node::get (callee_decl)))\n@@ -1242,31 +1237,30 @@ cgraph_edge::resolve_speculation (cgraph_edge *edge, tree callee_decl)\n   else\n     edge->speculative = false;\n   e2->speculative = false;\n+  update_call_stmt_hash_for_removing_direct_edge (e2, edge);\n   ref->remove_reference ();\n   if (e2->indirect_unknown_callee || e2->inline_failed)\n     remove (e2);\n   else\n     e2->callee->remove_symbol_and_inline_clones ();\n-  if (edge->caller->call_site_hash)\n-    {\n-      /* We always maintain direct edge in the call site hash, if one\n-\t exists.  */\n-      if (!edge->num_speculative_call_targets_p ())\n-\tcgraph_update_edge_in_call_site_hash (edge);\n-      else\n-\t{\n-\t  cgraph_edge *e;\n-\t  for (e = edge->caller->callees;\n-\t       e->call_stmt != edge->call_stmt\n-\t       || e->lto_stmt_uid != edge->lto_stmt_uid;\n-\t       e = e->next_callee)\n-\t    ;\n-\t  cgraph_update_edge_in_call_site_hash (e);\n-\t}\n-    }\n   return edge;\n }\n \n+/* Return edge corresponding to speculative call to a given target.\n+   NULL if speculative call does not have one.  */\n+\n+cgraph_edge *\n+cgraph_edge::speculative_call_for_target (cgraph_node *target)\n+{\n+  for (cgraph_edge *direct = first_speculative_call_target ();\n+       direct;\n+       direct = direct->next_speculative_call_target ())\n+    if (direct->speculative_call_target_ref ()\n+\t->referred->semantically_equivalent_p (target))\n+      return direct;\n+  return NULL;\n+}\n+\n /* Make an indirect edge with an unknown callee an ordinary edge leading to\n    CALLEE.  Speculations can be resolved in the process and EDGE can be removed\n    and deallocated.  Return the edge that now represents the call.  */\n@@ -1281,47 +1275,37 @@ cgraph_edge::make_direct (cgraph_edge *edge, cgraph_node *callee)\n     {\n       cgraph_edge *found = NULL;\n       cgraph_edge *direct, *next;\n-      ipa_ref *ref;\n \n-      edge->speculative_call_info (direct, edge, ref);\n+      edge = edge->speculative_call_indirect_edge ();\n \n       /* Look all speculative targets and remove all but one corresponding\n-\t to callee (if it exists).\n-\t If there is only one target we can save one extra call to\n-\t speculative_call_info.  */\n-      if (edge->num_speculative_call_targets_p () != 1)\n-\tfor (direct = edge->caller->callees; direct; direct = next)\n-\t  {\n-\t    next = direct->next_callee;\n-\t    if (direct->call_stmt == edge->call_stmt\n-\t\t&& direct->lto_stmt_uid == edge->lto_stmt_uid)\n-\t      {\n-\t\tdirect->speculative_call_info (direct, edge, ref);\n-\n-\t\t/* Compare ref not direct->callee.  Direct edge is possibly\n-\t\t   inlined or redirected.  */\n-\t\tif (!ref->referred->semantically_equivalent_p (callee))\n-\t\t  edge = direct->resolve_speculation (direct, NULL);\n-\t\telse\n-\t\t  {\n-\t\t    gcc_checking_assert (!found);\n-\t\t    found = direct;\n-\t\t  }\n-\t      }\n-\t  }\n-\telse if (!ref->referred->semantically_equivalent_p (callee))\n-\t  edge = direct->resolve_speculation (direct, NULL);\n-\telse\n-\t  found = direct;\n+\t to callee (if it exists).  */\n+      for (direct = edge->first_speculative_call_target ();\n+\t   direct;\n+\t   direct = next)\n+\t{\n+\t  next = direct->next_speculative_call_target ();\n+\n+\t  /* Compare ref not direct->callee.  Direct edge is possibly\n+\t     inlined or redirected.  */\n+\t  if (!direct->speculative_call_target_ref ()\n+\t       ->referred->semantically_equivalent_p (callee))\n+\t    edge = direct->resolve_speculation (direct, NULL);\n+\t  else\n+\t    {\n+\t      gcc_checking_assert (!found);\n+\t      found = direct;\n+\t    }\n+\t}\n \n       /* On successful speculation just remove the indirect edge and\n \t return the pre existing direct edge.\n \t It is important to not remove it and redirect because the direct\n \t edge may be inlined or redirected.  */\n       if (found)\n \t{\n-\t  resolve_speculation (edge, callee->decl);\n-\t  gcc_checking_assert (!found->speculative);\n+\t  cgraph_edge *e2 = resolve_speculation (found, callee->decl);\n+\t  gcc_checking_assert (!found->speculative && e2 == found);\n \t  return found;\n \t}\n       gcc_checking_assert (!edge->speculative);\n@@ -1377,17 +1361,19 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n \n   if (e->speculative)\n     {\n-      cgraph_edge *e2;\n-      gcall *new_stmt;\n-      ipa_ref *ref;\n-\n-      e->speculative_call_info (e, e2, ref);\n       /* If there already is an direct call (i.e. as a result of inliner's\n \t substitution), forget about speculating.  */\n       if (decl)\n \te = make_direct (e, cgraph_node::get (decl));\n       else\n \t{\n+\t  /* Be sure we redirect all speculative targets before poking\n+\t     abou tindirect edge.  */\n+\t  gcc_checking_assert (e->callee);\n+\t  cgraph_edge *indirect = e->speculative_call_indirect_edge ();\n+\t  gcall *new_stmt;\n+\t  ipa_ref *ref;\n+\n \t  /* Expand speculation into GIMPLE code.  */\n \t  if (dump_file)\n \t    {\n@@ -1398,51 +1384,45 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n \t      e->count.dump (dump_file);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n-\t  gcc_assert (e2->speculative);\n \t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n \n-\t  profile_probability prob = e->count.probability_in (e->count\n-\t\t\t\t\t\t\t      + e2->count);\n+\t  profile_count all = indirect->count;\n+\t  for (cgraph_edge *e2 = e->first_speculative_call_target ();\n+\t       e2;\n+\t       e2 = e2->next_speculative_call_target ())\n+\t    all = all + e2->count;\n+\t  profile_probability prob = e->count.probability_in (all);\n \t  if (!prob.initialized_p ())\n \t    prob = profile_probability::even ();\n+\t  ref = e->speculative_call_target_ref ();\n \t  new_stmt = gimple_ic (e->call_stmt,\n \t\t\t\tdyn_cast<cgraph_node *> (ref->referred),\n \t\t\t\tprob);\n \t  e->speculative = false;\n-\t  e->caller->set_call_stmt_including_clones (e->call_stmt, new_stmt,\n-\t\t\t\t\t\t     false);\n-\t  e->count = gimple_bb (e->call_stmt)->count;\n-\t  if (e2->num_speculative_call_targets_p ())\n+\t  if (indirect->num_speculative_call_targets_p ())\n \t    {\n \t      /* The indirect edge has multiple speculative targets, don't\n \t\t remove speculative until all related direct edges are\n \t\t redirected.  */\n-\t      e2->indirect_info->num_speculative_call_targets--;\n-\t      if (!e2->indirect_info->num_speculative_call_targets)\n-\t\te2->speculative = false;\n+\t      indirect->indirect_info->num_speculative_call_targets--;\n+\t      if (!indirect->indirect_info->num_speculative_call_targets)\n+\t\tindirect->speculative = false;\n \t    }\n \t  else\n-\t    e2->speculative = false;\n-\t  e2->count = gimple_bb (e2->call_stmt)->count;\n-\t  ref->speculative = false;\n-\t  ref->stmt = NULL;\n+\t    indirect->speculative = false;\n \t  /* Indirect edges are not both in the call site hash.\n \t     get it updated.  */\n-\t  if (e->caller->call_site_hash)\n-\t    {\n-\t      if (!e2->num_speculative_call_targets_p ())\n-\t\tcgraph_update_edge_in_call_site_hash (e2);\n-\t      else\n-\t\t{\n-\t\t  cgraph_edge *e;\n-\t\t  for (e = e2->caller->callees;\n-\t\t       e->call_stmt != e2->call_stmt\n-\t\t       || e->lto_stmt_uid != e2->lto_stmt_uid;\n-\t\t       e = e->next_callee)\n-\t\t    ;\n-\t\t  cgraph_update_edge_in_call_site_hash (e);\n-\t\t}\n-\t    }\n+\t  update_call_stmt_hash_for_removing_direct_edge (e, indirect);\n+\t  cgraph_edge::set_call_stmt (e, new_stmt, false);\n+\t  e->count = gimple_bb (e->call_stmt)->count;\n+\n+\t  /* Once we are done with expanding the sequence, update also indirect\n+\t     call probability.  Until then the basic block accounts for the\n+\t     sum of indirect edge and all non-expanded speculations.  */\n+\t  if (!indirect->speculative)\n+\t    indirect->count = gimple_bb (indirect->call_stmt)->count;\n+\t  ref->speculative = false;\n+\t  ref->stmt = NULL;\n \t  pop_cfun ();\n \t  /* Continue redirecting E to proper target.  */\n \t}\n@@ -3222,10 +3202,21 @@ verify_speculative_call (struct cgraph_node *node, gimple *stmt,\n       refs[i] = NULL;\n     }\n \n+  cgraph_edge *first_call = NULL;\n+  cgraph_edge *prev_call = NULL;\n+\n   for (cgraph_edge *direct = node->callees; direct;\n        direct = direct->next_callee)\n     if (direct->call_stmt == stmt && direct->lto_stmt_uid == lto_stmt_uid)\n       {\n+\tif (!first_call)\n+\t  first_call = direct;\n+\tif (prev_call && direct != prev_call->next_callee)\n+\t  {\n+\t    error (\"speculative edges are not adjacent\");\n+\t    return true;\n+\t  }\n+\tprev_call = direct;\n \tif (!direct->speculative)\n \t  {\n \t    error (\"direct call to %s in speculative call sequence has no \"\n@@ -3249,6 +3240,14 @@ verify_speculative_call (struct cgraph_node *node, gimple *stmt,\n \tdirect_calls[direct->speculative_id] = direct;\n       }\n \n+  if (first_call->call_stmt\n+      && first_call != node->get_edge (first_call->call_stmt))\n+    {\n+      error (\"call stmt hash does not point to first direct edge of \"\n+\t     \"speculative call sequence \");\n+      return true;\n+    }\n+\n   ipa_ref *ref;\n   for (int i = 0; node->iterate_reference (i, ref); i++)\n     if (ref->speculative"}, {"sha": "aa4cdc955066973a1f593d330a36bac21b4b64b9", "filename": "gcc/cgraph.h", "status": "modified", "additions": 79, "deletions": 8, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -1765,14 +1765,87 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n      the profile so the direct call is taken COUNT times\n      with FREQUENCY.  speculative_id is used to link direct calls with their\n      corresponding IPA_REF_ADDR references when representing speculative calls.\n-     target_prob is the probability of the speculative call.  */\n+   */\n   cgraph_edge *make_speculative (cgraph_node *n2, profile_count direct_count,\n-\t\t\t\t unsigned int speculative_id = 0,\n-\t\t\t\t int target_prob = 0);\n+\t\t\t\t unsigned int speculative_id = 0);\n \n-  /* Given speculative call edge, return all three components.  */\n-  void speculative_call_info (cgraph_edge *&direct, cgraph_edge *&indirect,\n-\t\t\t      ipa_ref *&reference);\n+  /* Speculative call consists of an indirect edge and one or more\n+     direct edge+ref pairs.  Speculative will expand to the following sequence:\n+\n+     if (call_dest == target1)\t\t// reference to target1\n+\ttarget1 ();\t\t\t// direct call to target1\n+     else if (call_dest == target2)\t// reference to targt2\n+\ttarget2 ();\t\t\t// direct call to target2\n+     else\n+\tcall_dest ();\t\t\t// indirect call\n+\n+     Before the expansion we will have indirect call and the direct call+ref\n+     pairs all linked to single statement.\n+\n+     Note that ref may point to different symbol than the corresponding call\n+     becuase the speculated edge may have been optimized (redirected to\n+     a clone) or inlined.\n+\n+     Given an edge which is part of speculative call, return the first\n+     direct call edge in the speculative call sequence.\n+\n+     In the example above called on any cgraph edge in the sequence it will\n+     return direct call to target1.  */\n+  cgraph_edge *first_speculative_call_target ();\n+\n+  /* Return next speculative call target or NULL if there is none.\n+     All targets are required to form an interval in the callee list.\n+\n+     In example above, if called on call to target1 it will return call to\n+     target2.  */\n+  cgraph_edge *next_speculative_call_target ()\n+  {\n+    cgraph_edge *e = this;\n+    gcc_checking_assert (speculative && callee);\n+\n+    if (e->next_callee && e->next_callee->speculative\n+\t&& e->next_callee->call_stmt == e->call_stmt\n+\t&& e->next_callee->lto_stmt_uid == e->lto_stmt_uid)\n+      return e->next_callee;\n+    return NULL;\n+  }\n+\n+  /* When called on any edge in the speculative call return the (unique)\n+     indirect call edge in the speculative call sequence.  */\n+  cgraph_edge *speculative_call_indirect_edge ()\n+  {\n+    gcc_checking_assert (speculative);\n+    if (!callee)\n+      return this;\n+    for (cgraph_edge *e2 = caller->indirect_calls;\n+\t true; e2 = e2->next_callee)\n+      if (e2->speculative\n+\t  && call_stmt == e2->call_stmt\n+\t  && lto_stmt_uid == e2->lto_stmt_uid)\n+\treturn e2;\n+  }\n+\n+  /* When called on any edge in speculative call and when given any target\n+     of ref which is speculated to it returns the corresponding direct call.\n+\n+     In example above if called on function target2 it will return call to\n+     target2.  */\n+  cgraph_edge *speculative_call_for_target (cgraph_node *);\n+\n+  /* Return REF corresponding to direct call in the specualtive call\n+     sequence.  */\n+  ipa_ref *speculative_call_target_ref ()\n+  {\n+    ipa_ref *ref;\n+\n+    gcc_checking_assert (speculative);\n+    for (unsigned int i = 0; caller->iterate_reference (i, ref); i++)\n+      if (ref->speculative && ref->speculative_id == speculative_id\n+\t  && ref->stmt == (gimple *)call_stmt\n+\t  && ref->lto_stmt_uid == lto_stmt_uid)\n+\treturn ref;\n+    gcc_unreachable ();\n+  }\n \n   /* Speculative call edge turned out to be direct call to CALLEE_DECL.  Remove\n      the speculative call sequence and return edge representing the call, the\n@@ -1874,8 +1947,6 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* The stmt_uid of call_stmt.  This is used by LTO to recover the call_stmt\n      when the function is serialized in.  */\n   unsigned int lto_stmt_uid;\n-  /*  target_prob is the probability of the speculative call.  */\n-  unsigned int target_prob;\n   /* speculative id is used to link direct calls with their corresponding\n      IPA_REF_ADDR references when representing speculative calls.  */\n   unsigned int speculative_id : 16;"}, {"sha": "c73b8f810f0f0c896de1ebfdd13494a6d352f45b", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -765,14 +765,18 @@ cgraph_node::set_call_stmt_including_clones (gimple *old_stmt,\n \t       callgraph edges.  */\n \t    if (edge->speculative && !update_speculative)\n \t      {\n-\t\tcgraph_edge *direct, *indirect;\n-\t\tipa_ref *ref;\n-\n-\t\tgcc_assert (!edge->indirect_unknown_callee);\n-\t\tedge->speculative_call_info (direct, indirect, ref);\n-\t\tdirect->speculative = false;\n+\t\tcgraph_edge *indirect = edge->speculative_call_indirect_edge ();\n+\n+\t\tfor (cgraph_edge *next, *direct\n+\t\t\t= edge->first_speculative_call_target ();\n+\t\t     direct;\n+\t\t     direct = next)\n+\t\t  {\n+\t\t    next = direct->next_speculative_call_target ();\n+\t\t    direct->speculative_call_target_ref ()->speculative = false;\n+\t\t    direct->speculative = false;\n+\t\t  }\n \t\tindirect->speculative = false;\n-\t\tref->speculative = false;\n \t      }\n \t  }\n \tif (node->clones)"}, {"sha": "b04cae704f9bc06b1ff79b5831db8dab797da7f1", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -3757,11 +3757,8 @@ ipa_devirt (void)\n  \t       with the speculation.  */\n \t    if (e->speculative)\n \t      {\n-\t\tstruct cgraph_edge *e2;\n-\t\tstruct ipa_ref *ref;\n-\t\te->speculative_call_info (e2, e, ref);\n-\t\tif (e2->callee->ultimate_alias_target ()\n-\t\t    == likely_target->ultimate_alias_target ())\n+\t\tbool found = e->speculative_call_for_target (likely_target);\n+\t\tif (found)\n \t\t  {\n \t\t    fprintf (dump_file, \"We agree with speculation\\n\\n\");\n \t\t    nok++;"}, {"sha": "059ea74278f3f96dede42b8a1d3cea2aba2a26bf", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -2604,34 +2604,26 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t      edge_set_predicate (edge, &bb_predicate);\n \t      if (edge->speculative)\n \t\t{\n-\t\t  cgraph_edge *direct, *indirect, *next_direct;\n-\t\t  ipa_ref *ref;\n-\t\t  edge->speculative_call_info (direct, indirect, ref);\n-\t\t  gcc_assert (direct == edge);\n+\t\t  cgraph_edge *indirect\n+\t\t\t= edge->speculative_call_indirect_edge ();\n \t          ipa_call_summary *es2\n \t\t\t = ipa_call_summaries->get_create (indirect);\n \t\t  ipa_call_summaries->duplicate (edge, indirect,\n \t\t\t\t\t\t es, es2);\n \n-\t\t  /* Create and duplicate call summaries for multiple\n+\t\t  /* Edge is the first direct call.\n+\t\t     create and duplicate call summaries for multiple\n \t\t     speculative call targets.  */\n-\t\t  int num_specs = indirect->num_speculative_call_targets_p ();\n-\t\t  if (num_specs > 1)\n-\t\t    for (next_direct = edge->next_callee;\n-\t\t\t next_direct && --num_specs;\n-\t\t\t next_direct = next_direct->next_callee)\n-\t\t      {\n-\t\t\tnext_direct->speculative_call_info (direct, indirect,\n-\t\t\t\t\t\t\t    ref);\n-\t\t\tif (direct == next_direct && next_direct->speculative\n-\t\t\t    && edge->call_stmt == stmt)\n-\t\t\t  {\n-\t\t\t    ipa_call_summary *es3\n-\t\t\t      = ipa_call_summaries->get_create (next_direct);\n-\t\t\t    ipa_call_summaries->duplicate (edge, next_direct,\n-\t\t\t\t\t\t\t   es, es3);\n-\t\t\t  }\n-\t\t      }\n+\t\t  for (cgraph_edge *direct\n+\t\t\t = edge->next_speculative_call_target ();\n+\t\t       direct;\n+\t\t       direct = direct->next_speculative_call_target ())\n+\t\t    {\n+\t\t      ipa_call_summary *es3\n+\t\t\t= ipa_call_summaries->get_create (direct);\n+\t\t      ipa_call_summaries->duplicate (edge, direct,\n+\t\t\t\t\t\t     es, es3);\n+\t\t    }\n \t\t}\n \t    }\n "}, {"sha": "6b6ba9aa4b65b166e2903ec8a7e63130b39792dd", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -1778,8 +1778,6 @@ speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n   enum availability avail;\n   struct cgraph_node *target = e->callee->ultimate_alias_target (&avail,\n \t\t\t\t\t\t\t\t e->caller);\n-  struct cgraph_edge *direct, *indirect;\n-  struct ipa_ref *ref;\n \n   gcc_assert (e->speculative && !e->indirect_unknown_callee);\n \n@@ -1794,14 +1792,14 @@ speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n       int ecf_flags = flags_from_decl_or_type (target->decl);\n       if (ecf_flags & ECF_CONST)\n         {\n-\t  e->speculative_call_info (direct, indirect, ref);\n-\t  if (!(indirect->indirect_info->ecf_flags & ECF_CONST))\n+\t  if (!(e->speculative_call_indirect_edge ()->indirect_info\n+\t\t->ecf_flags & ECF_CONST))\n \t    return true;\n         }\n       else if (ecf_flags & ECF_PURE)\n         {\n-\t  e->speculative_call_info (direct, indirect, ref);\n-\t  if (!(indirect->indirect_info->ecf_flags & ECF_PURE))\n+\t  if (!(e->speculative_call_indirect_edge ()->indirect_info\n+\t\t->ecf_flags & ECF_PURE))\n \t    return true;\n         }\n     }"}, {"sha": "9fbfa90e5383478b25cbaaf9ff603adb67af0638", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -134,7 +134,8 @@ static void\n dump_histogram (FILE *file, vec<histogram_entry *> histogram)\n {\n   unsigned int i;\n-  gcov_type overall_time = 0, cumulated_time = 0, cumulated_size = 0, overall_size = 0;\n+  gcov_type overall_time = 0, cumulated_time = 0, cumulated_size = 0,\n+\t    overall_size = 0;\n   \n   fprintf (dump_file, \"Histogram:\\n\");\n   for (i = 0; i < histogram.length (); i++)\n@@ -266,7 +267,8 @@ ipa_profile_generate_summary (void)\n   call_sums = new ipa_profile_call_summaries (symtab);\n \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n-    if (ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (node->decl))->count.ipa_p ())\n+    if (ENTRY_BLOCK_PTR_FOR_FN\n+\t  (DECL_STRUCT_FUNCTION (node->decl))->count.ipa_p ())\n       FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n \t{\n \t  int time = 0;\n@@ -300,30 +302,31 @@ ipa_profile_generate_summary (void)\n \t\t\t\t\t\t\t  j))\n \t\t\t    continue;\n \n-\t\t\t  if (val == 0)\n+\t\t\t  if (val == 0 || count == 0)\n \t\t\t    continue;\n \n-\t\t\t  speculative_call_target item (\n-\t\t\t    val, GCOV_COMPUTE_SCALE (count, all));\n-\t\t\t  if (item.target_probability > REG_BR_PROB_BASE)\n+\t\t\t  if (count > all)\n \t\t\t    {\n \t\t\t      if (dump_file)\n \t\t\t\tfprintf (dump_file,\n \t\t\t\t\t \"Probability capped to 1\\n\");\n-\t\t\t      item.target_probability = REG_BR_PROB_BASE;\n+\t\t\t      count = all;\n \t\t\t    }\n+\t\t\t  speculative_call_target item (\n+\t\t\t    val, GCOV_COMPUTE_SCALE (count, all));\n \t\t\t  csum->speculative_call_targets.safe_push (item);\n \t\t\t}\n \n-\t\t      gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->decl),\n-\t\t\t\t\t\t      stmt, h);\n+\t\t      gimple_remove_histogram_value\n+\t\t\t (DECL_STRUCT_FUNCTION (node->decl), stmt, h);\n \t\t    }\n \t\t}\n \t      time += estimate_num_insns (stmt, &eni_time_weights);\n \t      size += estimate_num_insns (stmt, &eni_size_weights);\n \t    }\n \t  if (bb->count.ipa_p () && bb->count.initialized_p ())\n-\t    account_time_size (&hashtable, histogram, bb->count.ipa ().to_gcov_type (),\n+\t    account_time_size (&hashtable, histogram,\n+\t\t\t       bb->count.ipa ().to_gcov_type (),\n \t\t\t       time, size);\n \t}\n   histogram.qsort (cmp_counts);\n@@ -864,6 +867,7 @@ ipa_profile (void)\n \t\t}\n \n \t      unsigned speculative_id = 0;\n+\t      profile_count orig = e->count;\n \t      for (unsigned i = 0; i < spec_count; i++)\n \t\t{\n \t\t  speculative_call_target item\n@@ -881,7 +885,8 @@ ipa_profile (void)\n \t\t\t\t   item.target_probability\n \t\t\t\t     / (float) REG_BR_PROB_BASE);\n \t\t\t}\n-\t\t      if (item.target_probability < REG_BR_PROB_BASE / 2)\n+\t\t      if (item.target_probability\n+\t\t \t  < REG_BR_PROB_BASE / GCOV_TOPN_VALUES / 2)\n \t\t\t{\n \t\t\t  nuseless++;\n \t\t\t  if (dump_file)\n@@ -939,11 +944,12 @@ ipa_profile (void)\n \t\t\t\tn2 = alias;\n \t\t\t    }\n \t\t\t  nconverted++;\n+\t\t\t  profile_probability prob\n+\t\t\t\t = profile_probability::from_reg_br_prob_base\n+\t\t\t\t\t(item.target_probability).adjusted ();\n \t\t\t  e->make_speculative (n2,\n-\t\t\t\t\t       e->count.apply_probability (\n-\t\t\t\t\t\t item.target_probability),\n-\t\t\t\t\t       speculative_id,\n-\t\t\t\t\t       item.target_probability);\n+\t\t\t\t\t       orig.apply_probability (prob),\n+\t\t\t\t\t       speculative_id);\n \t\t\t  update = true;\n \t\t\t  speculative_id++;\n \t\t\t}"}, {"sha": "7b97154f5016c848bbde4b52d1f52d8c6d44fced", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -3237,7 +3237,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a known target \"\n-\t\t     \"(%s -> %s) but cannot refer to it. Giving up.\\n\",\n+\t\t     \"(%s -> %s) but cannot refer to it.  Giving up.\\n\",\n \t\t     ie->caller->dump_name (),\n \t\t     ie->callee->dump_name ());\n \t  return NULL;\n@@ -3248,25 +3248,26 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n   /* If the edge is already speculated.  */\n   if (speculative && ie->speculative)\n     {\n-      struct cgraph_edge *e2;\n-      struct ipa_ref *ref;\n-      ie->speculative_call_info (e2, ie, ref);\n-      if (e2->callee->ultimate_alias_target ()\n-\t  != callee->ultimate_alias_target ())\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative \"\n-\t\t     \"target (%s -> %s) but the call is already \"\n-\t\t     \"speculated to %s. Giving up.\\n\",\n-\t\t     ie->caller->dump_name (), callee->dump_name (),\n-\t\t     e2->callee->dump_name ());\n-\t}\n-      else\n+      if (dump_file)\n \t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative target \"\n-\t\t     \"(%s -> %s) this agree with previous speculation.\\n\",\n-\t\t     ie->caller->dump_name (), callee->dump_name ());\n+\t  cgraph_edge *e2 = ie->speculative_call_for_target (callee);\n+\t  if (!e2)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"ipa-prop: Discovered call to a \"\n+\t\t\t \"speculative target (%s -> %s) but the call is \"\n+\t\t\t \"already speculated to different target.  \"\n+\t\t\t \"Giving up.\\n\",\n+\t\t\t ie->caller->dump_name (), callee->dump_name ());\n+\t    }\n+\t  else\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"ipa-prop: Discovered call to a speculative target \"\n+\t\t\t \"(%s -> %s) this agree with previous speculation.\\n\",\n+\t\t\t ie->caller->dump_name (), callee->dump_name ());\n+\t    }\n \t}\n       return NULL;\n     }\n@@ -3771,7 +3772,6 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n       class cgraph_indirect_call_info *ici = ie->indirect_info;\n       struct ipa_jump_func *jfunc;\n       int param_index;\n-      cgraph_node *spec_target = NULL;\n \n       next_ie = ie->next_callee;\n \n@@ -3787,14 +3787,11 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \n       param_index = ici->param_index;\n       jfunc = ipa_get_ith_jump_func (top, param_index);\n+      cgraph_node *spec_target;\n \n+      /* FIXME: This may need updating for multiple calls.  */\n       if (ie->speculative)\n-\t{\n-\t  struct cgraph_edge *de;\n-          struct ipa_ref *ref;\n-\t  ie->speculative_call_info (de, ie, ref);\n-\t  spec_target = de->callee;\n-\t}\n+\tspec_target = ie->first_speculative_call_target ()->callee;\n \n       if (!opt_for_fn (node->decl, flag_indirect_inlining))\n \tnew_direct_edge = NULL;"}, {"sha": "23e7f714306082864dfb36a301c95cf786379ebc", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 58, "deletions": 183, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -674,201 +674,75 @@ ipa_merge_profiles (struct cgraph_node *dst,\n       for (e = dst->indirect_calls, e2 = src->indirect_calls; e;\n \t   e2 = (e2 ? e2->next_callee : NULL), e = e->next_callee)\n \t{\n-\t  profile_count count = gimple_bb (e->call_stmt)->count;\n-\t  /* Below code are introduced by r279373 of \"Fix merging of common\n-\t     traget info.\".\n-\n-\t     ipa-icf runs after ipa-profile, common_target_id with\n-\t     common_target_probablity are useless in ipa-icf since they are\n-\t     moved from cgraph.h to ipa-profile.c and processed already.\n-\t     Need double circulation to find out each mapped direct speculative\n-\t     edge and do prob merge.  Not easy to construct a case to cover all\n-\t     circumstances here.  For src and dst both have multiple speculative\n-\t     targets, only N:N maps are implemented, 2:0, 2:1, 0:2, 1:2 are not\n-\t     implemented yet as too complicated and no test cases to cover.  */\n-\t  if (copy_counts)\n+\t  if (!e->speculative && !e2->speculative)\n \t    {\n-\t      /* copy if both e and e2 have same num_speculative_call_targets.\n-\t       */\n-\t      if (e->num_speculative_call_targets_p ()\n-\t\t  == e2->num_speculative_call_targets_p ())\n-\t\t{\n-\t\t  int num_specs = e->num_speculative_call_targets_p ();\n-\t\t  cgraph_edge *direct, *indirect, *next_direct;\n-\t\t  cgraph_edge *direct2, *indirect2, *next_direct2;\n-\t\t  ipa_ref *ref;\n-\t\t  for (next_direct = e; next_direct && num_specs--;\n-\t\t       next_direct = direct->next_callee)\n-\t\t    {\n-\t\t      next_direct->speculative_call_info (direct, indirect,\n-\t\t\t\t\t\t\t  ref);\n-\n-\t\t      int num_specs2 = e2->num_speculative_call_targets_p ();\n-\t\t      for (next_direct2 = e2; next_direct2 && num_specs2--;\n-\t\t\t   next_direct2 = direct2->next_callee)\n-\t\t\t{\n-\t\t\t  if (e2 && e2->speculative)\n-\t\t\t    next_direct2->speculative_call_info (direct2,\n-\t\t\t\t\t\t\t\t indirect2,\n-\t\t\t\t\t\t\t\t ref);\n-\t\t\t  if (direct->speculative_id == direct2->speculative_id\n-\t\t\t      && direct->lto_stmt_uid == direct2->lto_stmt_uid)\n-\t\t\t    {\n-\t\t\t      direct->target_prob = direct2->target_prob;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tgcc_assert (e->num_speculative_call_targets_p ()\n-\t\t\t    && e->num_speculative_call_targets_p ());\n+\t      /* FIXME: we need to also merge ipa-profile histograms\n+\t\t because with LTO merging happens from lto-symtab before\n+\t\t these are converted to indirect edges.  */\n+\t      e->count = gimple_bb (e->call_stmt)->count;\n+\t      continue;\n \t    }\n-\t  else if (e->num_speculative_call_targets_p ()\n-\t\t   || e2->num_speculative_call_targets_p ())\n+\n+\t  /* When copying just remove all speuclations on dst and then copy\n+\t     one from src.  */\n+\t  if (copy_counts)\n \t    {\n-\t      if (e->num_speculative_call_targets_p ()\n-\t\t  == e2->num_speculative_call_targets_p ())\n+\t      while (e->speculative)\n+\t\tcgraph_edge::resolve_speculation (e, NULL);\n+\t      e->count = gimple_bb (e->call_stmt)->count;\n+\t      if (e2->speculative)\n \t\t{\n-\t\t  int num_specs = e->num_speculative_call_targets_p ();\n-\t\t  cgraph_edge *direct, *indirect, *next_direct;\n-\t\t  cgraph_edge *direct2, *indirect2, *next_direct2;\n-\t\t  ipa_ref *ref;\n-\t\t  for (next_direct = e; next_direct && num_specs--;\n-\t\t       next_direct = direct->next_callee)\n+\t\t  for (cgraph_edge *e3 = e2->first_speculative_call_target ();\n+\t\t       e3;\n+\t\t       e3 = e3->next_speculative_call_target ())\n \t\t    {\n-\t\t      next_direct->speculative_call_info (direct, indirect,\n-\t\t\t\t\t\t\t  ref);\n-\n-\t\t      int num_specs2 = e2->num_speculative_call_targets_p ();\n-\t\t      for (next_direct2 = e2; next_direct2 && num_specs2--;\n-\t\t\t   next_direct2 = direct2->next_callee)\n-\t\t\t{\n-\t\t\t  if (e2 && e2->speculative)\n-\t\t\t    next_direct2->speculative_call_info (direct2,\n-\t\t\t\t\t\t\t\t indirect2,\n-\t\t\t\t\t\t\t\t ref);\n-\t\t\t  if (direct->speculative_id == direct2->speculative_id\n-\t\t\t      && direct->lto_stmt_uid == direct2->lto_stmt_uid)\n-\t\t\t    {\n-\t\t\t      sreal scale1\n-\t\t\t\t= e->count.ipa ().to_sreal_scale (count);\n-\t\t\t      sreal scale2\n-\t\t\t\t= e2->count.ipa ().to_sreal_scale (count);\n-\n-\t\t\t      if (scale1 == 0 && scale2 == 0)\n-\t\t\t\tscale1 = scale2 = 1;\n-\t\t\t      sreal sum = scale1 + scale2;\n-\t\t\t      int scaled_prob1\n-\t\t\t\t= (((sreal)direct->target_prob)\n-\t\t\t\t   * scale1 / sum).to_int ();\n-\t\t\t      int scaled_prob2\n-\t\t\t\t= (((sreal)direct2->target_prob)\n-\t\t\t\t   * scale2 / sum).to_int ();\n-\t\t\t      if (symtab->dump_file)\n-\t\t\t\t{\n-\t\t\t\t  fprintf (\n-\t\t\t\t    symtab->dump_file,\n-\t\t\t\t    \"Merging speculative id %i prob %i\"\n-\t\t\t\t    \" and %i prob %i with scales %f %f\\n\",\n-\t\t\t\t    direct->speculative_id, direct->target_prob,\n-\t\t\t\t    direct2->speculative_id,\n-\t\t\t\t    direct2->target_prob, scale1.to_double (),\n-\t\t\t\t    scale2.to_double ());\n-\t\t\t\t  fprintf (symtab->dump_file,\n-\t\t\t\t\t   \"Combined BB count \");\n-\t\t\t\t  count.dump (symtab->dump_file);\n-\t\t\t\t  fprintf (symtab->dump_file,\n-\t\t\t\t\t   \" dst edge count \");\n-\t\t\t\t  e->count.dump (symtab->dump_file);\n-\t\t\t\t  fprintf (symtab->dump_file,\n-\t\t\t\t\t   \" src edge count \");\n-\t\t\t\t  e2->count.dump (symtab->dump_file);\n-\t\t\t\t  fprintf (symtab->dump_file, \"\\n\");\n-\t\t\t\t}\n-\t\t\t      direct->target_prob = scaled_prob1 + scaled_prob2;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n+\t\t      cgraph_edge *ns;\n+\t\t      ns = e->make_speculative\n+\t\t\t (dyn_cast <cgraph_node *>\n+\t\t\t    (e3->speculative_call_target_ref ()->referred),\n+\t\t\t     e3->count, e3->speculative_id);\n+\t\t      /* Target may differ from ref (for example it may be\n+\t\t\t redirected to local alias.  */\n+\t\t      ns->redirect_callee (e3->callee);\n \t\t    }\n \t\t}\n-\t      else if (e->num_speculative_call_targets_p ())\n-\t\t{\n-\t\t  /* Process if only dst is speculative.  */\n-\t\t  gcc_assert (!e->num_speculative_call_targets_p ());\n-\t\t}\n-\t      else if (e2->num_speculative_call_targets_p ())\n-\t\t{\n-\t\t  /* Process if only src is speculative.  */\n-\t\t  gcc_assert (!e2->num_speculative_call_targets_p ());\n-\t\t}\n+\t      continue;\n \t    }\n \n-\t  /* When call is speculative, we need to re-distribute probabilities\n-\t     the same way as they was.  This is not really correct because\n-\t     in the other copy the speculation may differ; but probably it\n-\t     is not really worth the effort.  */\n-\t  if (e->speculative)\n+\t  /* Iterate all speculations in SRC, see if corresponding ones exist\n+\t     int DST and if so, sum the counts.  Otherwise create new\n+\t     speculation.  */\n+\t  int max_spec = 0;\n+\t  for (cgraph_edge *e3 = e->first_speculative_call_target ();\n+\t       e3;\n+\t       e3 = e3->next_speculative_call_target ())\n+\t    if (e3->speculative_id > max_spec)\n+\t      max_spec = e3->speculative_id;\n+\t  for (cgraph_edge *e3 = e2->first_speculative_call_target ();\n+\t       e3;\n+\t       e3 = e3->next_speculative_call_target ())\n \t    {\n-\t      cgraph_edge *direct, *indirect;\n-\t      cgraph_edge *direct2 = NULL, *indirect2 = NULL;\n-\t      ipa_ref *ref;\n-\n-\t      e->speculative_call_info (direct, indirect, ref);\n-\t      gcc_assert (e == indirect);\n-\t      if (e2 && e2->speculative)\n-\t        e2->speculative_call_info (direct2, indirect2, ref);\n-\t      if (indirect->count > profile_count::zero ()\n-\t\t  || direct->count > profile_count::zero ())\n+\t      cgraph_edge *te\n+\t\t = e->speculative_call_for_target\n+\t\t\t (dyn_cast <cgraph_node *>\n+\t\t\t    (e3->speculative_call_target_ref ()->referred));\n+\t      if (te)\n+\t\tte->count = te->count + e3->count;\n+\t      else\n \t\t{\n-\t\t  /* We should mismatch earlier if there is no matching\n-\t\t     indirect edge.  */\n-\t\t  if (!e2)\n-\t\t    {\n-\t\t      if (symtab->dump_file)\n-\t\t        fprintf (symtab->dump_file,\n-\t\t\t\t \"Mismatch in merging indirect edges\\n\");\n-\t\t    }\n-\t\t  else if (!e2->speculative)\n-\t\t    indirect->count += e2->count;\n-\t\t  else if (e2->speculative)\n-\t\t    {\n-\t\t      if (DECL_ASSEMBLER_NAME (direct2->callee->decl)\n-\t\t\t  != DECL_ASSEMBLER_NAME (direct->callee->decl))\n-\t\t\t{\n-\t\t\t  if (direct2->count >= direct->count)\n-\t\t\t    {\n-\t\t\t      direct->redirect_callee (direct2->callee);\n-\t\t\t      indirect->count += indirect2->count\n-\t\t\t\t\t\t + direct->count;\n-\t\t\t      direct->count = direct2->count;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    indirect->count += indirect2->count + direct2->count;\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t   direct->count += direct2->count;\n-\t\t\t   indirect->count += indirect2->count;\n-\t\t\t}\n-\t\t    }\n+\t\t  e->count = e->count + e3->count;\n+\t\t  cgraph_edge *ns;\n+\t\t  ns = e->make_speculative\n+\t\t\t (dyn_cast <cgraph_node *>\n+\t\t\t    (e3->speculative_call_target_ref ()\n+\t\t\t     ->referred),\n+\t\t\t  e3->count,\n+\t\t\t  e3->speculative_id + max_spec + 1);\n+\t\t  /* Target may differ from ref (for example it may be\n+\t\t     redirected to local alias.  */\n+\t\t  ns->redirect_callee (e3->callee);\n \t\t}\n-\t      else\n-\t\t/* At the moment we should have only profile feedback based\n-\t\t   speculations when merging.  */\n-\t\tgcc_unreachable ();\n \t    }\n-\t  else if (e2 && e2->speculative)\n-\t    {\n-\t      cgraph_edge *direct, *indirect;\n-\t      ipa_ref *ref;\n-\n-\t      e2->speculative_call_info (direct, indirect, ref);\n-\t      e->count = count;\n-\t      e->make_speculative (direct->callee, direct->count);\n-\t    }\n-\t  else\n-\t    e->count = count;\n \t}\n       if (!preserve_body)\n         src->release_body ();\n@@ -882,7 +756,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   src->decl = oldsrcdecl;\n }\n \n-/* Return true if call to DEST is known to be self-recusive call withing FUNC.   */\n+/* Return true if call to DEST is known to be self-recusive\n+   call withing FUNC.  */\n \n bool\n recursive_call_p (tree func, tree dest)"}, {"sha": "014f597986d09bf07edf0152709e081ceb7b9da6", "filename": "gcc/profile-count.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -262,6 +262,16 @@ class GTY((user)) profile_probability\n       return ret;\n     }\n \n+  /* Return THIS with quality set to ADJUSTED.  */\n+  profile_probability adjusted () const\n+    {\n+      profile_probability ret = *this;\n+      if (!initialized_p ())\n+\treturn *this;\n+      ret.m_quality = ADJUSTED;\n+      return ret;\n+    }\n+\n   int to_reg_br_prob_base () const\n     {\n       gcc_checking_assert (initialized_p ());"}, {"sha": "3374744613ea8feef72f80d45cd9fbaae7a107e4", "filename": "gcc/testsuite/g++.dg/tree-prof/indir-call-prof.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -38,6 +38,6 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final-use-not-autofdo { scan-ipa-dump \"Indirect call -> direct call.* AA transformation on insn\" \"profile\" } } */\n-/* { dg-final-use-autofdo { scan-ipa-dump \"Indirect call -> direct call.* AA transformation on insn\" \"afdo\" } } */\n+/* { dg-final-use-not-autofdo { scan-ipa-dump \"Indirect call -> direct call.* AA .will resolve by ipa-profile\" \"profile\" } } */\n+/* { dg-final-use-autofdo { scan-ipa-dump \"Indirect call -> direct call.* AA .will resolve by ipa-profile\" \"afdo\" } } */\n /* { dg-final-use-not-autofdo { scan-tree-dump-not \"Invalid sum\" \"optimized\" } } */"}, {"sha": "4f65dc61eba628fbe7f0480d64cbf7d8ade6f77e", "filename": "gcc/testsuite/gcc.dg/tree-prof/crossmodule-indircall-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -3,7 +3,7 @@\n /* { dg-options \"-O3 -flto -DDOJOB=1\" } */\n \n int a;\n-extern void (*p[2])(int n);\n+extern void (*p[5])(int n);\n void abort (void);\n int\n main()\n@@ -14,8 +14,8 @@ main()\n     p[0](1);\n   /* This call shall not be converted.  */\n   for (i = 0;i<1000;i++)\n-    p[i%2](2);\n-  if (a != 1000)\n+    p[i%5](2);\n+  if (a != -1000)\n     abort ();\n \n   return 0;"}, {"sha": "92237852ef17b6d17cfd1b484f38aa1fd7254193", "filename": "gcc/testsuite/gcc.dg/tree-prof/crossmodule-indircall-1a.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1a.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -30,8 +30,23 @@ sub(int i)\n {\n   a -= i;\n }\n+void\n+add2(int i)\n+{\n+  a -= 2*i;\n+}\n+void\n+sub2(int i)\n+{\n+  a -= 2*i;\n+}\n+void\n+nothing(int i)\n+{\n+  a -= i;\n+}\n __attribute__ ((externally_visible))\n-void (*p[2])(int)={add, sub};\n+void (*p[5])(int)={add, sub, add2, sub2, nothing};\n #else\n int\n main()"}, {"sha": "138b85a08d2a48f5c9b9363036528556fc0ebe55", "filename": "gcc/testsuite/gcc.dg/tree-prof/indir-call-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -37,6 +37,6 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final-use-not-autofdo { scan-ipa-dump \"Indirect call -> direct call.* a1 transformation on insn\" \"profile\"} } */\n-/* { dg-final-use-autofdo { scan-ipa-dump \"Indirect call -> direct call.* a1 transformation on insn\" \"afdo\"} } */\n+/* { dg-final-use-not-autofdo { scan-ipa-dump \"Indirect call -> direct call.* a1 .will resolve by ipa-profile\" \"profile\"} } */\n+/* { dg-final-use-autofdo { scan-ipa-dump \"Indirect call -> direct call.* a1 .will resolve by ipa-profile\" \"afdo\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */"}, {"sha": "5b0050a53d2f78cb027cbe25e13254cfa583a540", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -2181,47 +2181,51 @@ copy_bb (copy_body_data *id, basic_block bb,\n \t\t  if (edge)\n \t\t    {\n \t\t      struct cgraph_edge *old_edge = edge;\n-\t\t      profile_count old_cnt = edge->count;\n-\t\t      edge = edge->clone (id->dst_node, call_stmt,\n-\t\t\t\t\t  gimple_uid (stmt),\n-\t\t\t\t\t  num, den,\n-\t\t\t\t\t  true);\n-\n-\t\t      /* A speculative call is consist of edges - indirect edge\n-\t\t\t and direct edges (one indirect edeg may has multiple\n-\t\t\t direct edges).  Duplicate the whole thing and\n-\t\t\t distribute frequencies accordingly.  */\n+\n+\t\t      /* A speculative call is consist of multiple\n+\t\t\t edges - indirect edge and one or more direct edges\n+\t\t\t Duplicate the whole thing and distribute frequencies\n+\t\t\t accordingly.  */\n \t\t      if (edge->speculative)\n \t\t\t{\n-\t\t\t  struct cgraph_edge *direct, *indirect;\n-\t\t\t  struct ipa_ref *ref;\n-\n-\t\t\t  gcc_assert (!edge->indirect_unknown_callee);\n-\t\t\t  old_edge->speculative_call_info (direct, indirect, ref);\n-\t\t\t  while (old_edge->next_callee\n-\t\t\t\t && old_edge->next_callee->speculative\n-\t\t\t\t && indirect->num_speculative_call_targets_p ()\n-\t\t\t\t      > 1)\n+\t\t\t  int n = 0;\n+\t\t\t  profile_count direct_cnt\n+\t\t\t\t = profile_count::zero ();\n+\n+\t\t\t  /* First figure out the distribution of counts\n+\t\t\t     so we can re-scale BB profile accordingly.  */\n+\t\t\t  for (cgraph_edge *e = old_edge; e;\n+\t\t\t       e = e->next_speculative_call_target ())\n+\t\t\t    direct_cnt = direct_cnt + e->count;\n+\n+\t\t\t  cgraph_edge *indirect\n+\t\t\t\t = old_edge->speculative_call_indirect_edge ();\n+\t\t\t  profile_count indir_cnt = indirect->count;\n+\n+\t\t\t  /* Next iterate all direct edges, clone it and its\n+\t\t\t     corresponding reference and update profile.  */\n+\t\t\t  for (cgraph_edge *e = old_edge;\n+\t\t\t       e;\n+\t\t\t       e = e->next_speculative_call_target ())\n \t\t\t    {\n-\t\t\t      id->dst_node->clone_reference (ref, stmt);\n-\n-\t\t\t      edge = old_edge->next_callee;\n-\t\t\t      edge = edge->clone (id->dst_node, call_stmt,\n-\t\t\t\t\t\t  gimple_uid (stmt), num, den,\n-\t\t\t\t\t\t  true);\n-\t\t\t      old_edge = old_edge->next_callee;\n-\t\t\t      gcc_assert (!edge->indirect_unknown_callee);\n-\n-\t\t\t      /* If the indirect edge has multiple speculative\n-\t\t\t\t calls, iterate through all direct calls\n-\t\t\t\t associated to the speculative call and clone\n-\t\t\t\t all related direct edges before cloning the\n-\t\t\t\t related indirect edge.  */\n-\t\t\t      old_edge->speculative_call_info (direct, indirect,\n-\t\t\t\t\t\t\t       ref);\n+\t\t\t      profile_count cnt = e->count;\n+\n+\t\t\t      id->dst_node->clone_reference\n+\t\t\t\t (e->speculative_call_target_ref (), stmt);\n+\t\t\t      edge = e->clone (id->dst_node, call_stmt,\n+\t\t\t\t\t       gimple_uid (stmt), num, den,\n+\t\t\t\t\t       true);\n+\t\t\t      profile_probability prob\n+\t\t\t\t = cnt.probability_in (direct_cnt\n+\t\t\t\t\t\t       + indir_cnt);\n+\t\t\t      edge->count\n+\t\t\t\t = copy_basic_block->count.apply_probability\n+\t\t\t\t\t (prob);\n+\t\t\t      n++;\n \t\t\t    }\n-\n-\t\t\t  profile_count indir_cnt = indirect->count;\n+\t\t\t  gcc_checking_assert\n+\t\t\t\t (indirect->num_speculative_call_targets_p ()\n+\t\t\t\t  == n);\n \n \t\t\t  /* Duplicate the indirect edge after all direct edges\n \t\t\t     cloned.  */\n@@ -2231,14 +2235,19 @@ copy_bb (copy_body_data *id, basic_block bb,\n \t\t\t\t\t\t      true);\n \n \t\t\t  profile_probability prob\n-\t\t\t     = indir_cnt.probability_in (old_cnt + indir_cnt);\n+\t\t\t     = indir_cnt.probability_in (direct_cnt\n+\t\t\t\t\t\t\t + indir_cnt);\n \t\t\t  indirect->count\n \t\t\t     = copy_basic_block->count.apply_probability (prob);\n-\t\t\t  edge->count = copy_basic_block->count - indirect->count;\n-\t\t\t  id->dst_node->clone_reference (ref, stmt);\n \t\t\t}\n \t\t      else\n-\t\t\tedge->count = copy_basic_block->count;\n+\t\t\t{\n+\t\t\t  edge = edge->clone (id->dst_node, call_stmt,\n+\t\t\t\t\t      gimple_uid (stmt),\n+\t\t\t\t\t      num, den,\n+\t\t\t\t\t      true);\n+\t\t\t  edge->count = copy_basic_block->count;\n+\t\t\t}\n \t\t    }\n \t\t  break;\n "}, {"sha": "f0456c8e93d1013d4667cb5639d0d6acaea39e23", "filename": "gcc/value-prof.c", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/845bb366adcf702331de3d8022fd0e1c1c918607/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=845bb366adcf702331de3d8022fd0e1c1c918607", "patch": "@@ -106,7 +106,7 @@ static bool gimple_divmod_fixed_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_pow2_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_subtract_transform (gimple_stmt_iterator *);\n static bool gimple_stringops_transform (gimple_stmt_iterator *);\n-static void gimple_ic_transform (gimple_stmt_iterator *);\n+static void dump_ic_profile (gimple_stmt_iterator *gsi);\n \n /* Allocate histogram value.  */\n \n@@ -386,7 +386,9 @@ stream_in_histogram_value (class lto_input_block *ib, gimple *stmt)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      new_val->hvalue.counters = XNEWVAR (gcov_type, sizeof (*new_val->hvalue.counters) * ncounters);\n+      new_val->hvalue.counters = XNEWVAR (gcov_type,\n+\t\t\t\t\t  sizeof (*new_val->hvalue.counters)\n+\t\t\t\t\t  * ncounters);\n       new_val->n_counters = ncounters;\n       for (i = 0; i < ncounters; i++)\n \tnew_val->hvalue.counters[i] = streamer_read_gcov_count (ib);\n@@ -629,7 +631,8 @@ gimple_value_profile_transformations (void)\n \t    }\n \n \t  /* The function never thansforms a GIMPLE statement.  */\n-\t  gimple_ic_transform (&gsi);\n+\t  if (dump_enabled_p ())\n+\t    dump_ic_profile (&gsi);\n         }\n     }\n \n@@ -1388,13 +1391,10 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n   return dcall_stmt;\n }\n \n-/* There maybe multiple indirect targets in histogram.  Check every\n-   indirect/virtual call if callee function exists, if not exist, leave it to\n-   LTO stage for later process.  Modify code of this indirect call to an if-else\n-   structure in ipa-profile finally.  */\n+/* Dump info about indirect call profile.  */\n \n static void\n-gimple_ic_transform (gimple_stmt_iterator *gsi)\n+dump_ic_profile (gimple_stmt_iterator *gsi)\n {\n   gcall *stmt;\n   histogram_value histogram;\n@@ -1423,37 +1423,25 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n       if (!get_nth_most_common_value (NULL, \"indirect call\", histogram, &val,\n \t\t\t\t      &count, &all, j))\n \treturn;\n-\n-      /* Minimum probability.  should be higher than 25%.  */\n-      if (4 * count <= all)\n-\treturn;\n+      if (!count)\n+\tcontinue;\n \n       direct_call = find_func_by_profile_id ((int) val);\n \n       if (direct_call == NULL)\n-\t{\n-\t  if (val)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (\n-\t\t  MSG_MISSED_OPTIMIZATION, stmt,\n-\t\t  \"Indirect call -> direct call from other \"\n-\t\t  \"module %T=> %i (will resolve only with LTO)\\n\",\n-\t\t  gimple_call_fn (stmt), (int) val);\n-\t    }\n-\t  return;\n-\t}\n-\n-      if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,\n-\t\t\t   \"Indirect call -> direct call \"\n-\t\t\t   \"%T => %T transformation on insn postponed\\n\",\n-\t\t\t   gimple_call_fn (stmt), direct_call->decl);\n-\t  dump_printf_loc (MSG_NOTE, stmt,\n-\t\t\t   \"hist->count %\" PRId64 \" hist->all %\" PRId64 \"\\n\",\n-\t\t\t   count, all);\n-\t}\n+\tdump_printf_loc (\n+\t  MSG_MISSED_OPTIMIZATION, stmt,\n+\t  \"Indirect call -> direct call from other \"\n+\t  \"module %T=> %i (will resolve by ipa-profile only with LTO)\\n\",\n+\t  gimple_call_fn (stmt), (int) val);\n+      else\n+\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,\n+\t\t\t \"Indirect call -> direct call \"\n+\t\t\t \"%T => %T (will resolve by ipa-profile)\\n\",\n+\t\t\t gimple_call_fn (stmt), direct_call->decl);\n+      dump_printf_loc (MSG_NOTE, stmt,\n+\t\t       \"hist->count %\" PRId64 \" hist->all %\" PRId64 \"\\n\",\n+\t\t       count, all);\n     }\n }\n "}]}