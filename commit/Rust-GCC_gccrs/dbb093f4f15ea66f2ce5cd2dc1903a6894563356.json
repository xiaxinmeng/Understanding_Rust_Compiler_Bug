{"sha": "dbb093f4f15ea66f2ce5cd2dc1903a6894563356", "node_id": "C_kwDOANBUbNoAKGRiYjA5M2Y0ZjE1ZWE2NmYyY2U1Y2QyZGMxOTAzYTY4OTQ1NjMzNTY", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-07-18T19:04:23Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-07-19T22:05:49Z"}, "message": "Resolve complicated join nodes in range_from_dom.\n\nJoin nodes which carry outgoing ranges on incoming edges are uncommon,\nbut can still be resolved by setting the dominator range, and then\ncalculating incoming edges.  Avoid doing so if one of the incoing edges\nis not dominated by the same dominator.\n\n\t* gimple-range-cache.cc (ranger_cache::range_from_dom): Check\n\t  for incoming ranges on join nodes and add to worklist.", "tree": {"sha": "58d2ee0260b022833fbad476b36be28041c75971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58d2ee0260b022833fbad476b36be28041c75971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbb093f4f15ea66f2ce5cd2dc1903a6894563356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb093f4f15ea66f2ce5cd2dc1903a6894563356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbb093f4f15ea66f2ce5cd2dc1903a6894563356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb093f4f15ea66f2ce5cd2dc1903a6894563356/comments", "author": null, "committer": null, "parents": [{"sha": "b0cc57cd76f511f29cab233654249817312ec2a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cc57cd76f511f29cab233654249817312ec2a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0cc57cd76f511f29cab233654249817312ec2a6"}], "stats": {"total": 26, "additions": 26, "deletions": 0}, "files": [{"sha": "f3292fccaee68c6849af520d8730c3cee4afa067", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbb093f4f15ea66f2ce5cd2dc1903a6894563356/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbb093f4f15ea66f2ce5cd2dc1903a6894563356/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=dbb093f4f15ea66f2ce5cd2dc1903a6894563356", "patch": "@@ -1384,6 +1384,32 @@ ranger_cache::range_from_dom (vrange &r, tree name, basic_block start_bb,\n       // This block has an outgoing range.\n       if (m_gori.has_edge_range_p (name, bb))\n \tm_workback.quick_push (prev_bb);\n+      else\n+\t{\n+\t  // Normally join blocks don't carry any new range information on\n+\t  // incoming edges.  If the first incoming edge to this block does\n+\t  // generate a range, calculate the ranges if all incoming edges\n+\t  // are also dominated by the dominator.  (Avoids backedges which\n+\t  // will break the rule of moving only upward in the domniator tree).\n+\t  // If the first pred does not generate a range, then we will be\n+\t  // using the dominator range anyway, so thats all the check needed.\n+\t  if (EDGE_COUNT (prev_bb->preds) > 1\n+\t      && m_gori.has_edge_range_p (name, EDGE_PRED (prev_bb, 0)->src))\n+\t    {\n+\t      edge e;\n+\t      edge_iterator ei;\n+\t      bool all_dom = true;\n+\t      FOR_EACH_EDGE (e, ei, prev_bb->preds)\n+\t\tif (e->src != bb\n+\t\t    && !dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+\t\t  {\n+\t\t    all_dom = false;\n+\t\t    break;\n+\t\t  }\n+\t      if (all_dom)\n+\t\tm_workback.quick_push (prev_bb);\n+\t    }\n+\t}\n \n       if (def_bb == bb)\n \tbreak;"}]}