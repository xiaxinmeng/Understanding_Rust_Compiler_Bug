{"sha": "d2158690aee47faf2cbe7199305abd626c4df488", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIxNTg2OTBhZWU0N2ZhZjJjYmU3MTk5MzA1YWJkNjI2YzRkZjQ4OA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-30T01:34:00Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-30T01:34:00Z"}, "message": "cpphash.h (enum node_type): Take out T_MCONST.\n\n\t* cpphash.h (enum node_type: Take out T_MCONST.\n\t(union hashval): Move into struct hashnode.\n\t(struct hashnode): Pack tighter.  Remove file, line, col\n\tmembers.\n\t* cpphash.c: Constify most of the macro-definition structures.\n\t(struct definition): Replace by struct object_defn\n\tand struct funct_defn.  Put file, line, column information\n\there.  All users updated to match.\n\t(_cpp_create_definition, _cpp_macroexpand): Remove special\n\tcase for #define WORD OTHERWORD.\n\t* cpplib.c (do_undef): Remove T_MCONST case.\n\nFrom-SVN: r33538", "tree": {"sha": "9695b447d0767996981375b00e5448cb208e44e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9695b447d0767996981375b00e5448cb208e44e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2158690aee47faf2cbe7199305abd626c4df488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2158690aee47faf2cbe7199305abd626c4df488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2158690aee47faf2cbe7199305abd626c4df488", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2158690aee47faf2cbe7199305abd626c4df488/comments", "author": null, "committer": null, "parents": [{"sha": "10d1117cbc74ea64d22bbe75fb5f305a5d8948c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d1117cbc74ea64d22bbe75fb5f305a5d8948c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d1117cbc74ea64d22bbe75fb5f305a5d8948c1"}], "stats": {"total": 340, "additions": 195, "deletions": 145}, "files": [{"sha": "33ac5975484ad93f0f7a58ae94252facdd04e0b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2158690aee47faf2cbe7199305abd626c4df488/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2158690aee47faf2cbe7199305abd626c4df488/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2158690aee47faf2cbe7199305abd626c4df488", "patch": "@@ -1,5 +1,17 @@\n 2000-04-29  Zack Weinberg  <zack@wolery.cumb.org>\n \n+\t* cpphash.h (enum node_type: Take out T_MCONST.\n+\t(union hashval): Move into struct hashnode.\n+\t(struct hashnode): Pack tighter.  Remove file, line, col\n+\tmembers.\n+\t* cpphash.c: Constify most of the macro-definition structures.\n+\t(struct definition): Replace by struct object_defn\n+\tand struct funct_defn.  Put file, line, column information\n+\there.  All users updated to match.\n+\t(_cpp_create_definition, _cpp_macroexpand): Remove special\n+\tcase for #define WORD OTHERWORD.\n+\t* cpplib.c (do_undef): Remove T_MCONST case.\n+\n \t* cpphash.h: Move struct reflist, struct definition, and the\n \tDEFINITION typedef to cpphash.c.  Use 'struct definition *' in\n \tunion hashval.  _cpp_free_definition takes a HASHNODE pointer."}, {"sha": "4c45161ee74c9a8f82543852dc4a2a62dbab7372", "filename": "gcc/cpphash.c", "status": "modified", "additions": 168, "deletions": 122, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2158690aee47faf2cbe7199305abd626c4df488/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2158690aee47faf2cbe7199305abd626c4df488/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=d2158690aee47faf2cbe7199305abd626c4df488", "patch": "@@ -33,11 +33,14 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n /* Structure allocated for every #define.  For a simple replacement\n    such as\n-   \t#define foo bar ,\n-   nargs = -1, the `pattern' list is null, and the expansion is just\n-   the replacement text.  Nargs = 0 means a functionlike macro with no args,\n-   e.g.,\n-       #define getchar() getc (stdin) .\n+   \t#define foo bar\n+\n+   we allocate an object_defn structure; the expansion field points\n+   to the replacement text.  For a function-like macro we allocate a\n+   funct_defn structure; nargs is the number of arguments - it can be zero,\n+   e.g.\n+       #define getchar() getc (stdin)\n+\n    When there are args, the expansion is the replacement text with the\n    args squashed out, and the reflist is a list describing how to\n    build the output from the input: e.g., \"3 chars, then the 1st arg,\n@@ -50,11 +53,25 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    #define f(x) x+x+x+x+x+x+x would have replacement text \"++++++\" and\n    pattern list\n      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }\n-   where (x, y) means (nchars, argno). */\n+   where (x, y) means (nchars, argno).\n+\n+   Note that EMPTY and IDENTITY macros have object_defn structures too,\n+   but they're just used to hold the file, line, and column.  The\n+   expansion field will be NULL.  */\n+\n+struct object_defn\n+{\n+  const U_CHAR *expansion;\n+  unsigned int length;\n+\n+  const char *file;\t\t/* File, line, column of definition */\n+  int line;\n+  int col;\n+};  \n \n struct reflist\n {\n-  struct reflist *next;\n+  const struct reflist *next;\n   char stringify;\t\t/* nonzero if this arg was preceded by a\n \t\t\t\t   # operator. */\n   char raw_before;\t\t/* Nonzero if a ## operator before arg. */\n@@ -65,25 +82,29 @@ struct reflist\n   int argno;\t\t\t/* Number of arg to substitute (origin-0) */\n };\n \n-typedef struct definition DEFINITION;\n-struct definition\n+struct funct_defn\n {\n   int nargs;\n   int length;\t\t\t/* length of expansion string */\n-  U_CHAR *expansion;\n+  const U_CHAR *expansion;\n   char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n-  struct reflist *pattern;\n+  const struct reflist *pattern;\n \n   /* Names of macro args, concatenated in order with \\0 between\n      them.  The only use of this is that we warn on redefinition if\n      this differs between the old and new definitions.  */\n   U_CHAR *argnames;\n+\n+  const char *file;\t\t/* File, line, column of definition */\n+  int line;\n+  int col;\n };\n \n static unsigned int hash_HASHNODE PARAMS ((const void *));\n static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n static void del_HASHNODE\t  PARAMS ((void *));\n-static void dump_DEFINITION\t  PARAMS ((cpp_reader *, DEFINITION *));\n+static void dump_funlike_macro\t  PARAMS ((cpp_reader *,\n+\t\t\t\t\t   const struct funct_defn *));\n static int dump_hash_helper\t  PARAMS ((void **, void *));\n \n static void push_macro_expansion PARAMS ((cpp_reader *, const U_CHAR *,\n@@ -92,22 +113,23 @@ static int unsafe_chars\t\t PARAMS ((cpp_reader *, int, int));\n static int macro_cleanup\t PARAMS ((cpp_buffer *, cpp_reader *));\n static enum cpp_ttype macarg\t PARAMS ((cpp_reader *, int));\n static void special_symbol\t PARAMS ((cpp_reader *, HASHNODE *));\n-static int compare_defs\t\t PARAMS ((cpp_reader *, DEFINITION *,\n-\t\t\t\t\t  DEFINITION *));\n+static int compare_defs\t\t PARAMS ((cpp_reader *,\n+\t\t\t\t\t  const struct funct_defn *,\n+\t\t\t\t\t  const struct funct_defn *));\n \n /* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n #define HASHSIZE 500\n \n-/* The arglist structure is built by create_definition to tell\n-   collect_expansion where the argument names begin.  That\n-   is, for a define like \"#define f(x,y,z) foo+x-bar*y\", the arglist\n-   would contain pointers to the strings x, y, and z.\n-   collect_expansion would then build a DEFINITION node,\n-   with reflist nodes pointing to the places x, y, and z had\n-   appeared.  So the arglist is just convenience data passed\n-   between these two routines.  It is not kept around after\n-   the current #define has been processed and entered into the\n-   hash table.  */\n+/* The arglist structure is built by collect_params to tell\n+   collect_funlike_expansion where the argument names begin.  That is,\n+   for a define like \"#define f(x,y,z) foo+x-bar*y\", the arglist would\n+   contain pointers to the strings x, y, and z.\n+   collect_funlike_expansion would then build a funct_defn node, with\n+   reflist nodes pointing to the places x, y, and z had appeared.\n+\n+   The arglist is just convenience data passed between these two\n+   routines.  It is not kept around after the current #define has been\n+   processed and entered into the hash table.  */\n \n struct arg\n {\n@@ -124,9 +146,9 @@ struct arglist\n };\n \n \n-static DEFINITION *\n+static struct object_defn *\n collect_objlike_expansion PARAMS ((cpp_reader *, cpp_toklist *));\n-static DEFINITION *\n+static struct funct_defn *\n collect_funlike_expansion PARAMS ((cpp_reader *, cpp_toklist *,\n \t\t\t\t   struct arglist *, unsigned int));\n static unsigned int collect_params PARAMS ((cpp_reader *, cpp_toklist *,\n@@ -160,8 +182,9 @@ struct argdata\n   int stringified_length;\n };\n \n-static void scan_arguments\tPARAMS ((cpp_reader *, DEFINITION *,\n-\t\t\t\t\t  struct argdata *, const U_CHAR *));\n+static void scan_arguments\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t const struct funct_defn *,\n+\t\t\t\t\t struct argdata *, const U_CHAR *));\n static void stringify\t\tPARAMS ((cpp_reader *, struct argdata *));\n static void funlike_macroexpand\tPARAMS ((cpp_reader *, HASHNODE *,\n \t\t\t\t\t struct argdata *));\n@@ -318,22 +341,29 @@ void\n _cpp_free_definition (h)\n      HASHNODE *h;\n {\n-  if (h->type == T_MCONST || h->type == T_XCONST)\n-    free ((void *) h->value.cpval);\n-  else if (h->type == T_MACRO || h->type == T_FMACRO)\n+  if (h->type == T_XCONST)\n+    free ((PTR) h->value.cpval);\n+  else if (h->type == T_MACRO)\n+    {\n+      if (h->value.odefn->expansion)\n+\tfree ((PTR) h->value.odefn->expansion);\n+      free ((PTR) h->value.odefn);\n+    }\n+  else if (h->type == T_FMACRO)\n     {\n-      DEFINITION *d = h->value.defn;\n-      struct reflist *ap, *nextap;\n+      const struct funct_defn *d = h->value.fdefn;\n+      const struct reflist *ap, *nextap;\n     \n       for (ap = d->pattern; ap != NULL; ap = nextap)\n \t{\n \t  nextap = ap->next;\n-\t  free (ap);\n+\t  free ((PTR) ap);\n \t}\n       if (d->argnames)\n-\tfree (d->argnames);\n-      free (d);\n+\tfree ((PTR) d->argnames);\n+      free ((PTR) d);\n     }\n+  h->value.cpval = NULL;\n }\n \n static int\n@@ -344,10 +374,10 @@ macro_cleanup (pbuf, pfile)\n   HASHNODE *m = pbuf->macro;\n   \n   m->disabled = 0;\n-  if (m->type == T_FMACRO && pbuf->buf != m->value.defn->expansion)\n-    free ((PTR) pbuf->buf);\n-  else if (m->type != T_MACRO && m->type != T_FMACRO && m->type != T_CONST\n-\t   && m->type != T_MCONST && m->type != T_XCONST)\n+  if ((m->type == T_FMACRO && pbuf->buf != m->value.fdefn->expansion)\n+      || m->type == T_SPECLINE || m->type == T_FILE\n+      || m->type == T_BASE_FILE || m->type == T_INCLUDE_LEVEL\n+      || m->type == T_STDC)\n     free ((PTR) pbuf->buf);\n   return 0;\n }\n@@ -466,14 +496,14 @@ trad_stringify (pfile, base, len, argc, argv, pat, endpat, last)\n }\n \n /* Read a replacement list for an object-like macro, and build the\n-   DEFINITION structure.  LIST contains the replacement list,\n+   object_defn structure.  LIST contains the replacement list,\n    beginning at 1.  */\n-static DEFINITION *\n+static struct object_defn *\n collect_objlike_expansion (pfile, list)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n {\n-  DEFINITION *defn;\n+  struct object_defn *defn;\n   unsigned int i;\n   unsigned int start;\n   int last_was_paste = 0;\n@@ -535,30 +565,26 @@ collect_objlike_expansion (pfile, list)\n   memcpy (exp, pfile->token_buffer + start, len);\n   exp[len] = '\\0';\n \n-  defn = (DEFINITION *) xmalloc (sizeof (DEFINITION));\n+  defn = (struct object_defn *) xmalloc (sizeof (struct object_defn));\n   defn->length = len;\n   defn->expansion = exp;\n-  defn->pattern = 0;\n-  defn->rest_args = 0;\n-  defn->argnames = 0;\n-  defn->nargs = -1;\n \n   return defn;\n }\n \n /* Read a replacement list for a function-like macro, and build the\n-   DEFINITION structure.  LIST contains the replacement list,\n+   funct_defn structure.  LIST contains the replacement list,\n    beginning at REPLACEMENT.  ARGLIST specifies the formal parameters\n    to look for in the text of the definition.  */\n \n-static DEFINITION *\n+static struct funct_defn *\n collect_funlike_expansion (pfile, list, arglist, replacement)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n      struct arglist *arglist;\n      unsigned int replacement;\n {\n-  DEFINITION *defn;\n+  struct funct_defn *defn;\n   struct reflist *pat = 0, *endpat = 0;\n   enum cpp_ttype token;\n   unsigned int start, last;\n@@ -694,7 +720,7 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n   memcpy (exp, pfile->token_buffer + start, len);\n   exp[len] = '\\0';\n \n-  defn = (DEFINITION *) xmalloc (sizeof (DEFINITION));\n+  defn = (struct funct_defn *) xmalloc (sizeof (struct funct_defn));\n   defn->length = len;\n   defn->expansion = exp;\n   defn->pattern = pat;\n@@ -868,51 +894,39 @@ collect_params (pfile, list, arglist)\n   return i + 1;\n }\n \n-/* Create a DEFINITION node for a macro.  The replacement text\n-   (including formal parameters if present) is in LIST.  If FUNLIKE is\n-   true, this is a function-like macro.  */\n+/* Create a definition for a macro.  The replacement text (including\n+   formal parameters if present) is in LIST.  If FUNLIKE is true, this\n+   is a function-like macro.  */\n \n int\n _cpp_create_definition (pfile, list, hp)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n      HASHNODE *hp;\n {\n-  DEFINITION *defn = 0;\n-  U_CHAR *cpval = 0;\n+  struct funct_defn *fdefn = 0;\n+  struct object_defn *odefn = 0;\n   enum node_type ntype;\n   int ok;\n \n   /* Special-case a few simple and common idioms:\n      #define TOKEN   // nothing\n      #define TOKEN TOKEN\n-     #define TOKEN OTHERTOKEN\n \n      Might also be good to special-case these:\n \n      #define FUNC()  // nothing\n      #define FUNC(a, b, ...) // nothing\n-     #define FUNC(a, b, c) FUNC(a, b, c)\n-     #define FUNC(a, b, c) foobar(a, b, c)  */\n+     #define FUNC(a, b, c) FUNC(a, b, c)  */\n \n   if (list->tokens_used == 2)\n     ntype = T_EMPTY;    /* Empty definition of object-like macro.  */\n-  else if (list->tokens_used == 3 && list->tokens[1].type == CPP_NAME)\n-    {\n-      if (list->tokens[0].val.name.len == list->tokens[1].val.name.len\n-\t  && !strncmp (list->tokens[0].val.name.offset + list->namebuf,\n-\t\t       list->tokens[1].val.name.offset + list->namebuf,\n-\t\t       list->tokens[0].val.name.len))\n-\tntype = T_IDENTITY;\n-      else\n-\t{\n-\t  ntype = T_MCONST;\n-\t  cpval = xmalloc (list->tokens[1].val.name.len + 1);\n-\t  memcpy (cpval, list->tokens[1].val.name.offset + list->namebuf,\n-\t\t  list->tokens[1].val.name.len);\n-\t  cpval[list->tokens[1].val.name.len] = '\\0';\n-\t}\n-    }\n+  else if (list->tokens_used == 3 && list->tokens[1].type == CPP_NAME\n+\t   && list->tokens[0].val.name.len == list->tokens[1].val.name.len\n+\t   && !strncmp (list->tokens[0].val.name.offset + list->namebuf,\n+\t\t\tlist->tokens[1].val.name.offset + list->namebuf,\n+\t\t\tlist->tokens[0].val.name.len))\n+    ntype = T_IDENTITY;  /* Object like macro defined to itself.  */\n \n   /* The macro is function-like only if the next character,\n      with no intervening whitespace, is '('.  */\n@@ -925,8 +939,8 @@ _cpp_create_definition (pfile, list, hp)\n       replacement = collect_params (pfile, list, &args);\n       if (replacement == 0)\n \treturn 0;\n-      defn = collect_funlike_expansion (pfile, list, &args, replacement);\n-      if (defn == 0)\n+      fdefn = collect_funlike_expansion (pfile, list, &args, replacement);\n+      if (fdefn == 0)\n \treturn 0;\n \n       ntype = T_FMACRO;\n@@ -941,13 +955,20 @@ _cpp_create_definition (pfile, list, hp)\n \t\t     \"The C standard requires whitespace after #define %s\",\n \t\t     hp->name);\n \n-      defn = collect_objlike_expansion (pfile, list);\n-      if (defn == 0)\n+      odefn = collect_objlike_expansion (pfile, list);\n+      if (odefn == 0)\n \treturn 0;\n \n       ntype = T_MACRO;\n     }\n \n+  if (ntype == T_EMPTY || ntype == T_IDENTITY)\n+    {\n+      odefn = xmalloc (sizeof (struct object_defn));\n+      odefn->length = 0;\n+      odefn->expansion = 0;\n+    }\n+\n   /* Check for a redefinition, and its legality.  Redefining a macro\n      of whatever stripe is ok if the definitions are the same.\n      Redefining a built-in _constant_ (T_CONST or T_XCONST) is ok only\n@@ -958,16 +979,20 @@ _cpp_create_definition (pfile, list, hp)\n     case T_VOID:  ok = 1; break;\n     default:\t  ok = 0; break;\n \n-    case T_MACRO: case T_FMACRO:\n-      ok = (ntype == hp->type && !compare_defs (pfile, defn, hp->value.defn));\n+    case T_MACRO:\n+      ok = (ntype == hp->type\n+\t    && odefn->length == hp->value.odefn->length\n+\t    && !strncmp (odefn->expansion, hp->value.odefn->expansion,\n+\t\t\t odefn->length));\n+      break;\n+    case T_FMACRO:\n+      ok = (ntype == hp->type\n+\t    && !compare_defs (pfile, fdefn, hp->value.fdefn));\n       break;\n     case T_IDENTITY:\n     case T_EMPTY:\n       ok = (ntype == hp->type);\n       break;\n-    case T_MCONST:\n-      ok = (ntype == hp->type && !strcmp (cpval, hp->value.cpval));\n-      break;\n     case T_CONST:\n     case T_XCONST:\n       ok = ! pfile->done_initializing;\n@@ -979,23 +1004,45 @@ _cpp_create_definition (pfile, list, hp)\n     {\n       cpp_pedwarn (pfile, \"\\\"%s\\\" redefined\", hp->name);\n       if (pfile->done_initializing)\n-\tcpp_pedwarn_with_file_and_line (pfile, hp->file, hp->line, hp->col,\n+\t{\n+\t  const char *file;\n+\t  unsigned int line, col;\n+\t  if (hp->type == T_FMACRO)\n+\t    {\n+\t      file = hp->value.fdefn->file;\n+\t      line = hp->value.fdefn->line;\n+\t      col  = hp->value.fdefn->col;\n+\t    }\n+\t  else\n+\t    {\n+\t      file = hp->value.odefn->file;\n+\t      line = hp->value.odefn->line;\n+\t      col  = hp->value.odefn->col;\n+\t    }\n+\tcpp_pedwarn_with_file_and_line (pfile, file, line, col,\n \t\t\t\"this is the location of the previous definition\");\n+\t}\n     }\n \n   /* And replace the old definition (if any).  */\n \n   _cpp_free_definition (hp);\n \n-  if (ntype == T_MACRO || ntype == T_FMACRO)\n-    hp->value.defn = defn;\n-  else\n-    hp->value.cpval = cpval;\n-\n   hp->type = ntype;\n-  hp->file = CPP_BUFFER (pfile)->nominal_fname;\n-  hp->line = list->line;\n-  hp->col  = list->tokens[0].col;\n+  if (ntype == T_FMACRO)\n+    {\n+      fdefn->file = CPP_BUFFER (pfile)->nominal_fname;\n+      fdefn->line = list->line;\n+      fdefn->col  = list->tokens[0].col;\n+      hp->value.fdefn = fdefn;\n+    }\n+  else\n+    {\n+      odefn->file = CPP_BUFFER (pfile)->nominal_fname;\n+      odefn->line = list->line;\n+      odefn->col  = list->tokens[0].col;\n+      hp->value.odefn = odefn;\n+    }\n   return 1;\n }\n \n@@ -1227,21 +1274,21 @@ _cpp_macroexpand (pfile, hp)\n      cpp_reader *pfile;\n      HASHNODE *hp;\n {\n-  DEFINITION *defn;\n+  const struct funct_defn *defn;\n   struct argdata *args;\n   unsigned int old_written;\n   int i;\n \n   /* Object like macro - most common case.  */\n   if (hp->type == T_MACRO)\n     {\n-      push_macro_expansion (pfile, hp->value.defn->expansion,\n-\t\t\t    hp->value.defn->length, hp);\n+      push_macro_expansion (pfile, hp->value.odefn->expansion,\n+\t\t\t    hp->value.odefn->length, hp);\n       return;\n     }\n \n   /* Or might it be a constant string?  */\n-  if (hp->type == T_MCONST || hp->type == T_CONST || hp->type == T_XCONST)\n+  if (hp->type == T_CONST || hp->type == T_XCONST)\n     {\n       const U_CHAR *cpval = hp->value.cpval;\n       if (cpval && *cpval != '\\0')\n@@ -1253,8 +1300,9 @@ _cpp_macroexpand (pfile, hp)\n   if (hp->type != T_FMACRO)\n     {\n       U_CHAR *xbuf;\n-      unsigned int len, old_written = CPP_WRITTEN (pfile);\n-      \n+      unsigned int len;\n+\n+      old_written = CPP_WRITTEN (pfile);\n       special_symbol (pfile, hp);\n       len = CPP_WRITTEN (pfile) - old_written;\n       CPP_SET_WRITTEN (pfile, old_written);\n@@ -1270,7 +1318,7 @@ _cpp_macroexpand (pfile, hp)\n \n   /* Okay, it's a full-on function-like macro...  */\n   old_written = CPP_WRITTEN (pfile);\n-  defn = hp->value.defn;\n+  defn = hp->value.fdefn;\n \n   args = alloca (MAX (defn->nargs, 1) * sizeof (struct argdata));\n   for (i = 0; i < MAX (defn->nargs, 1); i++)\n@@ -1301,7 +1349,7 @@ _cpp_macroexpand (pfile, hp)\n static void\n scan_arguments (pfile, defn, args, name)\n      cpp_reader *pfile;\n-     DEFINITION *defn;\n+     const struct funct_defn *defn;\n      struct argdata *args;\n      const U_CHAR *name;\n {\n@@ -1479,13 +1527,13 @@ funlike_macroexpand (pfile, hp, args)\n      HASHNODE *hp;\n      struct argdata *args;\n {\n-  DEFINITION *defn = hp->value.defn;\n+  const struct funct_defn *defn = hp->value.fdefn;\n   register U_CHAR *xbuf;\n   int xbuf_len;\n-  U_CHAR *exp = defn->expansion;\n+  const U_CHAR *exp = defn->expansion;\n   int offset;\t/* offset in expansion, copied a piece at a time */\n   int totlen;\t/* total amount of exp buffer filled so far */\n-  struct reflist *ap, *last_ap;\n+  const struct reflist *ap, *last_ap;\n   int i;\n \n   /* Compute length in characters of the macro's expansion.\n@@ -1776,20 +1824,20 @@ push_macro_expansion (pfile, xbuf, len, hp)\n      foo(foo(baz(0, 0)) in K+R.  This looks pathological to me.\n      If someone has a real-world example I would love to see it.  */\n   if (hp->type != T_FMACRO\n-      || hp->value.defn->nargs == 0\n-      || hp->value.defn->pattern == 0\n+      || hp->value.fdefn->nargs == 0\n+      || hp->value.fdefn->pattern == 0\n       || !CPP_TRADITIONAL (pfile))\n     hp->disabled = 1;\n }\n \n-/* Return zero if two DEFINITIONs are isomorphic.  */\n+/* Return zero if two funct_defns are isomorphic.  */\n \n static int\n compare_defs (pfile, d1, d2)\n      cpp_reader *pfile;\n-     DEFINITION *d1, *d2;\n+     const struct funct_defn *d1, *d2;\n {\n-  struct reflist *a1, *a2;\n+  const struct reflist *a1, *a2;\n \n   if (d1->nargs != d2->nargs)\n     return 1;\n@@ -1842,23 +1890,21 @@ _cpp_dump_definition (pfile, hp)\n   if (hp->type == T_EMPTY)\n     /* do nothing */;\n   else if (hp->type == T_FMACRO)\n-    dump_DEFINITION (pfile, hp->value.defn);\n+    dump_funlike_macro (pfile, hp->value.fdefn);\n   else\n     {\n       CPP_PUTC_Q (pfile, ' ');\n \n       if (hp->type == T_IDENTITY)\n \tCPP_PUTS (pfile, hp->name, hp->length);\n-      else if (hp->type == T_MCONST)\n-\tCPP_PUTS (pfile, hp->value.cpval, strlen (hp->value.cpval));\n       else if (hp->type == T_MACRO)\n \t{\n \t  /* The first and last two characters of a macro expansion are\n \t     always \"\\r \"; this needs to be trimmed out.\n \t     So we need length-4 chars of space, plus one for the NUL.  */\n-\t  CPP_RESERVE (pfile, hp->value.defn->length - 4 + 1);\n-\t  CPP_PUTS_Q (pfile, hp->value.defn->expansion + 2,\n-\t\t      hp->value.defn->length - 4);\n+\t  CPP_RESERVE (pfile, hp->value.odefn->length - 4 + 1);\n+\t  CPP_PUTS_Q (pfile, hp->value.odefn->expansion + 2,\n+\t\t      hp->value.odefn->length - 4);\n \t}\n       else\n \tcpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n@@ -1868,15 +1914,15 @@ _cpp_dump_definition (pfile, hp)\n }\n \n static void\n-dump_DEFINITION (pfile, defn)\n+dump_funlike_macro (pfile, defn)\n      cpp_reader *pfile;\n-     DEFINITION *defn;\n+     const struct funct_defn *defn;\n {\n-  struct reflist *r;\n-  unsigned char **argv = (unsigned char **) alloca (defn->nargs *\n-\t\t\t\t\t\t    sizeof(char *));\n+  const struct reflist *r;\n+  const U_CHAR **argv = (const U_CHAR **) alloca (defn->nargs *\n+\t\t\t\t\t\t  sizeof(const U_CHAR *));\n   int *argl = (int *) alloca (defn->nargs * sizeof(int));\n-  unsigned char *x;\n+  const U_CHAR *x;\n   int i;\n \n   /* First extract the argument list. */"}, {"sha": "edb61f74e5357e489a9398191f58d3955b48adf7", "filename": "gcc/cpphash.h", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2158690aee47faf2cbe7199305abd626c4df488/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2158690aee47faf2cbe7199305abd626c4df488/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d2158690aee47faf2cbe7199305abd626c4df488", "patch": "@@ -45,35 +45,28 @@ enum node_type\n   T_CONST,\t   /* Constant string, used by `__SIZE_TYPE__' etc */\n   T_XCONST,\t   /* Ditto, but the string is malloced memory */\n   T_POISON,\t   /* poisoned identifier */\n-  T_MCONST,\t   /* object-like macro defined to a single identifier */\n-  T_MACRO,\t   /* general object-like macro */\n-  T_FMACRO,\t   /* general function-like macro */\n+  T_MACRO,\t   /* object-like macro */\n+  T_FMACRO,\t   /* function-like macro */\n   T_IDENTITY,\t   /* macro defined to itself */\n   T_EMPTY\t   /* macro defined to nothing */\n };\n \n-/* different kinds of things that can appear in the value field\n-   of a hash node. */\n-union hashval\n-{\n-  const char *cpval;\t\t/* some predefined macros */\n-  struct definition *defn;\t/* #define */\n-  struct hashnode *aschain;\t/* #assert */\n-};\n-\n typedef struct hashnode HASHNODE;\n struct hashnode\n {\n-  const U_CHAR *name;\t\t/* the actual name */\n-  size_t length;\t\t/* length of token, for quick comparison */\n-  unsigned long hash;\t\t/* cached hash value */\n-  union hashval value;\t\t/* pointer to expansion, or whatever */\n-  enum node_type type;\t\t/* type of special token */\n-  int disabled;\t\t\t/* macro turned off for rescan?  */\n-\n-  const char *file;\t\t/* File, line, column of definition; */\n-  int line;\n-  int col;\n+  unsigned int hash;\t\t\t/* cached hash value */\n+  unsigned short length;\t\t/* length of name */\n+  ENUM_BITFIELD(node_type) type : 8;\t/* node type */\n+  char disabled;\t\t\t/* macro turned off for rescan? */\n+\n+  union {\n+    const char *cpval;\t\t\t/* some predefined macros */\n+    const struct object_defn *odefn;\t/* #define foo bar */\n+    const struct funct_defn *fdefn;\t/* #define foo(x) bar(x) */\n+    struct hashnode *aschain;\t\t/* #assert */\n+  } value;\n+\n+  const U_CHAR *name;\n };\n \n /* List of directories to look for include files in. */"}, {"sha": "06e828640a91fac640cbbde1a3d3879787f08b33", "filename": "gcc/cpplib.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2158690aee47faf2cbe7199305abd626c4df488/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2158690aee47faf2cbe7199305abd626c4df488/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d2158690aee47faf2cbe7199305abd626c4df488", "patch": "@@ -727,7 +727,6 @@ do_undef (pfile)\n \t    pass_thru_directive (hp->name, len, pfile, T_UNDEF);\n \n \t  if (hp->type != T_MACRO && hp->type != T_FMACRO\n-\t      && hp->type != T_MCONST\n \t      && hp->type != T_EMPTY && hp->type != T_IDENTITY)\n \t    cpp_warning (pfile, \"undefining `%s'\", hp->name);\n "}]}