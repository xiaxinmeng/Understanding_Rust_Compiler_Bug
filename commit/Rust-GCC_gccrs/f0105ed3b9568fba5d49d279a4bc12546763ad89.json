{"sha": "f0105ed3b9568fba5d49d279a4bc12546763ad89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxMDVlZDNiOTU2OGZiYTVkNDlkMjc5YTRiYzEyNTQ2NzYzYWQ4OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-10T08:30:08Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-10T08:30:08Z"}, "message": "cp-tree.h (CPTI_ATEXIT): New macro.\n\n\t* cp-tree.h (CPTI_ATEXIT): New macro.\n\t(atexit_node): Likewise.\n\t* decl.c (destroy_local_static): New function, broken out from ...\n\t(expand_static_init): Here.\n\nFrom-SVN: r29260", "tree": {"sha": "31521403b2dab439f0ba27951b75c9250da93780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31521403b2dab439f0ba27951b75c9250da93780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0105ed3b9568fba5d49d279a4bc12546763ad89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0105ed3b9568fba5d49d279a4bc12546763ad89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0105ed3b9568fba5d49d279a4bc12546763ad89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0105ed3b9568fba5d49d279a4bc12546763ad89/comments", "author": null, "committer": null, "parents": [{"sha": "0bb9c57d22015000b3f312091a981139fc35ba59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb9c57d22015000b3f312091a981139fc35ba59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bb9c57d22015000b3f312091a981139fc35ba59"}], "stats": {"total": 151, "additions": 85, "deletions": 66}, "files": [{"sha": "a8f032292f21429a8bf6432e0aea955828e067a9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0105ed3b9568fba5d49d279a4bc12546763ad89/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0105ed3b9568fba5d49d279a4bc12546763ad89/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f0105ed3b9568fba5d49d279a4bc12546763ad89", "patch": "@@ -1,5 +1,10 @@\n 1999-09-10  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (CPTI_ATEXIT): New macro.\n+\t(atexit_node): Likewise.\n+\t* decl.c (destroy_local_static): New function, broken out from ...\n+\t(expand_static_init): Here.\n+\n \t* rtti.c (get_tinfo_var): These should always be global\n \t(expand_si_desc): Use tree, not RTL, functions to generate code.\n \t(expand_class_desc): Likewise."}, {"sha": "a35da1fa85ef3096dad4c754f1dd67ede79b30b7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0105ed3b9568fba5d49d279a4bc12546763ad89/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0105ed3b9568fba5d49d279a4bc12546763ad89/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f0105ed3b9568fba5d49d279a4bc12546763ad89", "patch": "@@ -429,6 +429,7 @@ enum cp_tree_index\n     CPTI_JCLASS,\n     CPTI_MINUS_ONE,\n     CPTI_TERMINATE,\n+    CPTI_ATEXIT,\n \n     CPTI_MAX\n };\n@@ -520,6 +521,9 @@ extern tree cp_global_trees[CPTI_MAX];\n /* The declaration for `std::terminate'.  */\n #define terminate_node                  cp_global_trees[CPTI_TERMINATE]\n \n+/* The declaration for `std::atexit'.  */\n+#define atexit_node                     cp_global_trees[CPTI_ATEXIT]\n+\n /* Global state.  */\n \n struct saved_scope {"}, {"sha": "21d88ae1cb3b7867d7cd1ace1de7bff93989de66", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0105ed3b9568fba5d49d279a4bc12546763ad89/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0105ed3b9568fba5d49d279a4bc12546763ad89/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f0105ed3b9568fba5d49d279a4bc12546763ad89", "patch": "@@ -206,6 +206,7 @@ static void mark_binding_level PROTO((void *));\n static void mark_cp_function_context PROTO((struct function *));\n static void mark_saved_scope PROTO((void *));\n static void check_function_type PROTO((tree));\n+static void destroy_local_static PROTO((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -8043,6 +8044,77 @@ finish_decl (decl, init, asmspec_tree)\n   cp_finish_decl (decl, init, asmspec_tree, 1, 0);\n }\n \n+/* Generate code to handle the destruction of the function-scoped\n+   static variable DECL.  */\n+\n+static void\n+destroy_local_static (decl)\n+     tree decl;\n+{\n+  tree cleanup, fcall;\n+  tree compound_stmt;\n+  int saved_flag_access_control;\n+\n+  if (atexit_node == 0)\n+    {\n+      tree atexit_fndecl, PFV, pfvlist;\n+      /* Remember this information until end of file.  */\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      PFV = build_pointer_type (build_function_type\n+\t\t\t\t(void_type_node, void_list_node));\n+\n+      pfvlist = tree_cons (NULL_TREE, PFV, void_list_node);\n+\n+      push_lang_context (lang_name_c);\n+      /* Note that we do not call pushdecl for this function;\n+\t there's no reason that this declaration should be\n+\t accessible to anyone.  */\n+      atexit_fndecl\n+\t= define_function (\"atexit\",\n+\t\t\t   build_function_type (void_type_node,\n+\t\t\t\t\t\tpfvlist),\n+\t\t\t   NOT_BUILT_IN, \n+\t\t\t   /*pfn=*/0,\n+\t\t\t   NULL_PTR);\n+      mark_used (atexit_fndecl);\n+      atexit_node = default_conversion (atexit_fndecl);\n+      pop_lang_context ();\n+      pop_obstacks ();\n+    }\n+\t      \n+  /* Call build_cleanup before we enter the anonymous function so that\n+     any access checks will be done relative to the current scope,\n+     rather than the scope of the anonymous function.  */\n+  build_cleanup (decl);\n+\n+  /* Now start the function.  */\n+  cleanup = start_anon_func ();\n+\n+  /* Now, recompute the cleanup.  It may contain SAVE_EXPRs that refer\n+     to the original function, rather than the anonymous one.  That\n+     will make the back-end think that nested functions are in use,\n+     which causes confusion.  */\n+  saved_flag_access_control = flag_access_control;\n+  flag_access_control = 0;\n+  fcall = build_cleanup (decl);\n+  flag_access_control = saved_flag_access_control;\n+\n+  /* Create the body of the anonymous function.  */\n+  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n+  finish_expr_stmt (fcall);\n+  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n+  end_anon_func ();\n+\n+  /* Call atexit with the cleanup function.  */\n+  mark_addressable (cleanup);\n+  cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n+  fcall = build_function_call (atexit_node,\n+\t\t\t       tree_cons (NULL_TREE, \n+\t\t\t\t\t  cleanup, \n+\t\t\t\t\t  NULL_TREE));\n+  finish_expr_stmt (fcall);\n+}\n+\n void\n expand_static_init (decl, init)\n      tree decl;\n@@ -8060,6 +8132,7 @@ expand_static_init (decl, init)\n       /* Emit code to perform this initialization but once.  */\n       tree temp;\n       tree if_stmt;\n+      tree then_clause;\n       tree assignment;\n       tree temp_init;\n \n@@ -8098,6 +8171,7 @@ expand_static_init (decl, init)\n       finish_if_stmt_cond (build_binary_op (EQ_EXPR, temp,\n \t\t\t\t\t    integer_zero_node), \n \t\t\t   if_stmt);\n+      then_clause = begin_compound_stmt (/*has_no_scope=*/0);\n \n       /* Do the initialization itself.  */\n       if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n@@ -8133,73 +8207,9 @@ expand_static_init (decl, init)\n       /* Use atexit to register a function for destroying this static\n \t variable.  */\n       if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n-\t{\n-\t  tree cleanup, fcall;\n-\t  static tree Atexit = 0;\n-\t  int saved_flag_access_control;\n-\n-\t  if (Atexit == 0)\n-\t    {\n-\t      tree atexit_fndecl, PFV, pfvlist;\n-\n-\t      ggc_add_tree_root (&Atexit, 1);\n-\n-\t      /* Remember this information until end of file.  */\n-\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n-\t      PFV = build_pointer_type (build_function_type\n-\t\t\t\t\t(void_type_node, void_list_node));\n-\n-\t      pfvlist = tree_cons (NULL_TREE, PFV, void_list_node);\n-\n-\t      push_lang_context (lang_name_c);\n-\t      /* Note that we do not call pushdecl for this function;\n-\t\t there's no reason that this declaration should be\n-\t\t accessible to anyone.  */\n-\t      atexit_fndecl\n-\t\t= define_function (\"atexit\",\n-\t\t\t\t   build_function_type (void_type_node,\n-\t\t\t\t\t\t\tpfvlist),\n-\t\t\t\t   NOT_BUILT_IN, \n-\t\t\t\t   /*pfn=*/0,\n-\t\t\t\t   NULL_PTR);\n-\t      mark_used (atexit_fndecl);\n-\t      Atexit = default_conversion (atexit_fndecl);\n-\t      pop_lang_context ();\n-\t      pop_obstacks ();\n-\t    }\n-\t      \n-\t  /* Call build_cleanup before we enter the anonymous function\n-\t     so that any access checks will be done relative to the\n-\t     current scope, rather than the scope of the anonymous\n-\t     function.  */\n-\t  build_cleanup (decl);\n-\n-\t  /* Now start the function.  */\n-\t  cleanup = start_anon_func ();\n-\n-\t  /* Now, recompute the cleanup.  It may contain SAVE_EXPRs\n-\t     that refer to the original function, rather than the\n-\t     anonymous one.  That will make the back-end think that\n-\t     nested functions are in use, which causes confusion.  */\n-\t  saved_flag_access_control = flag_access_control;\n-\t  flag_access_control = 0;\n-\t  fcall = build_cleanup (decl);\n-\t  flag_access_control = saved_flag_access_control;\n-\n-\t  /* Finish off the function.  */\n-\t  expand_expr_stmt (fcall);\n-\t  end_anon_func ();\n-\n-\t  /* Call atexit with the cleanup function.  */\n-\t  mark_addressable (cleanup);\n-\t  cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n-\t  fcall = build_function_call (Atexit, \n-\t\t\t\t       tree_cons (NULL_TREE, \n-\t\t\t\t\t\t  cleanup, \n-\t\t\t\t\t\t  NULL_TREE));\n-\t  finish_expr_stmt (fcall);\n-\t}\n+\tdestroy_local_static (decl);\n \n+      finish_compound_stmt (/*has_no_scope=*/0, then_clause);\n       finish_then_clause (if_stmt);\n       finish_if_stmt ();\n "}]}