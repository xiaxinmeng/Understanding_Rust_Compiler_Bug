{"sha": "05b8fcb4d2087c1544ebe3ad128711f12bcff022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDViOGZjYjRkMjA4N2MxNTQ0ZWJlM2FkMTI4NzExZjEyYmNmZjAyMg==", "commit": {"author": {"name": "Fritz O. Reese", "email": "fritzoreese@gmail.com", "date": "2016-11-10T21:54:48Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2016-11-10T21:54:48Z"}, "message": "Fix some whitespace.\n\n\tgcc/fortran/\n\t* decl.c (get_struct_decl, gfc_match_map, gfc_match_union): Fix\n\twhitespace.\n\t* interface.c (gfc_compare_union_types): Likewise.\n\nFrom-SVN: r242057", "tree": {"sha": "1b848f307ec6f5df1c86adced8e648c82b497701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b848f307ec6f5df1c86adced8e648c82b497701"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05b8fcb4d2087c1544ebe3ad128711f12bcff022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b8fcb4d2087c1544ebe3ad128711f12bcff022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05b8fcb4d2087c1544ebe3ad128711f12bcff022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b8fcb4d2087c1544ebe3ad128711f12bcff022/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f065303fcf9aa29bf376cf9db985b81d338d7709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f065303fcf9aa29bf376cf9db985b81d338d7709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f065303fcf9aa29bf376cf9db985b81d338d7709"}], "stats": {"total": 252, "additions": 129, "deletions": 123}, "files": [{"sha": "0872b4943275cee76cd2c12b4b998a60977a5fbf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05b8fcb4d2087c1544ebe3ad128711f12bcff022/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05b8fcb4d2087c1544ebe3ad128711f12bcff022/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=05b8fcb4d2087c1544ebe3ad128711f12bcff022", "patch": "@@ -1,3 +1,9 @@\n+2016-11-10  Fritz O. Reese <fritzoreese@gmail.com>\n+\n+\t* decl.c (get_struct_decl, gfc_match_map, gfc_match_union): Fix\n+\twhitespace.\n+\t* interface.c (gfc_compare_union_types): Likewise.\n+\n 2016-11-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cpp.c (cpp_define_builtins): Define _OPENMP to 201511 instead"}, {"sha": "1272f1fe52957121f1c0e2e73cf5e0893f6c0eec", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 91, "deletions": 91, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05b8fcb4d2087c1544ebe3ad128711f12bcff022/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05b8fcb4d2087c1544ebe3ad128711f12bcff022/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=05b8fcb4d2087c1544ebe3ad128711f12bcff022", "patch": "@@ -8597,31 +8597,31 @@ get_struct_decl (const char *name, sym_flavor fl, locus *decl,\n match\n gfc_match_map (void)\n {\n-    /* Counter used to give unique internal names to map structures. */\n-    static unsigned int gfc_map_id = 0;\n-    char name[GFC_MAX_SYMBOL_LEN + 1];\n-    gfc_symbol *sym;\n-    locus old_loc;\n+  /* Counter used to give unique internal names to map structures. */\n+  static unsigned int gfc_map_id = 0;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symbol *sym;\n+  locus old_loc;\n \n-    old_loc = gfc_current_locus;\n+  old_loc = gfc_current_locus;\n \n-    if (gfc_match_eos () != MATCH_YES)\n-      {\n-          gfc_error (\"Junk after MAP statement at %C\");\n-          gfc_current_locus = old_loc;\n-          return MATCH_ERROR;\n-      }\n+  if (gfc_match_eos () != MATCH_YES)\n+    {\n+\tgfc_error (\"Junk after MAP statement at %C\");\n+\tgfc_current_locus = old_loc;\n+\treturn MATCH_ERROR;\n+    }\n \n-    /* Map blocks are anonymous so we make up unique names for the symbol table\n-       which are invalid Fortran identifiers.  */\n-    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"MM$%u\", gfc_map_id++);\n+  /* Map blocks are anonymous so we make up unique names for the symbol table\n+     which are invalid Fortran identifiers.  */\n+  snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"MM$%u\", gfc_map_id++);\n \n-    if (!get_struct_decl (name, FL_STRUCT, &old_loc, &sym))\n-      return MATCH_ERROR;\n+  if (!get_struct_decl (name, FL_STRUCT, &old_loc, &sym))\n+    return MATCH_ERROR;\n \n-    gfc_new_block = sym;\n+  gfc_new_block = sym;\n \n-    return MATCH_YES;\n+  return MATCH_YES;\n }\n \n \n@@ -8630,31 +8630,31 @@ gfc_match_map (void)\n match\n gfc_match_union (void)\n {\n-    /* Counter used to give unique internal names to union types. */\n-    static unsigned int gfc_union_id = 0;\n-    char name[GFC_MAX_SYMBOL_LEN + 1];\n-    gfc_symbol *sym;\n-    locus old_loc;\n+  /* Counter used to give unique internal names to union types. */\n+  static unsigned int gfc_union_id = 0;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symbol *sym;\n+  locus old_loc;\n \n-    old_loc = gfc_current_locus;\n+  old_loc = gfc_current_locus;\n \n-    if (gfc_match_eos () != MATCH_YES)\n-      {\n-          gfc_error (\"Junk after UNION statement at %C\");\n-          gfc_current_locus = old_loc;\n-          return MATCH_ERROR;\n-      }\n+  if (gfc_match_eos () != MATCH_YES)\n+    {\n+\tgfc_error (\"Junk after UNION statement at %C\");\n+\tgfc_current_locus = old_loc;\n+\treturn MATCH_ERROR;\n+    }\n \n-    /* Unions are anonymous so we make up unique names for the symbol table\n-       which are invalid Fortran identifiers.  */\n-    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"UU$%u\", gfc_union_id++);\n+  /* Unions are anonymous so we make up unique names for the symbol table\n+     which are invalid Fortran identifiers.  */\n+  snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"UU$%u\", gfc_union_id++);\n \n-    if (!get_struct_decl (name, FL_UNION, &old_loc, &sym))\n-      return MATCH_ERROR;\n+  if (!get_struct_decl (name, FL_UNION, &old_loc, &sym))\n+    return MATCH_ERROR;\n \n-    gfc_new_block = sym;\n+  gfc_new_block = sym;\n \n-    return MATCH_YES;\n+  return MATCH_YES;\n }\n \n \n@@ -8666,67 +8666,67 @@ gfc_match_union (void)\n match\n gfc_match_structure_decl (void)\n {\n-    /* Counter used to give unique internal names to anonymous structures.  */\n-    static unsigned int gfc_structure_id = 0;\n-    char name[GFC_MAX_SYMBOL_LEN + 1];\n-    gfc_symbol *sym;\n-    match m;\n-    locus where;\n+  /* Counter used to give unique internal names to anonymous structures.  */\n+  static unsigned int gfc_structure_id = 0;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symbol *sym;\n+  match m;\n+  locus where;\n \n-    if(!flag_dec_structure)\n-      {\n-          gfc_error (\"STRUCTURE at %C is a DEC extension, enable with \"\n-                     \"-fdec-structure\");\n-          return MATCH_ERROR;\n-      }\n+  if (!flag_dec_structure)\n+    {\n+      gfc_error (\"STRUCTURE at %C is a DEC extension, enable with \"\n+\t\t \"-fdec-structure\");\n+      return MATCH_ERROR;\n+    }\n \n-    name[0] = '\\0';\n+  name[0] = '\\0';\n \n-    m = gfc_match (\" /%n/\", name);\n-    if (m != MATCH_YES)\n-      {\n-          /* Non-nested structure declarations require a structure name.  */\n-          if (!gfc_comp_struct (gfc_current_state ()))\n-            {\n-                gfc_error (\"Structure name expected in non-nested structure \"\n-                           \"declaration at %C\");\n-                return MATCH_ERROR;\n-            }\n-          /* This is an anonymous structure; make up a unique name for it\n-             (upper-case letters never make it to symbol names from the source).\n-             The important thing is initializing the type variable\n-             and setting gfc_new_symbol, which is immediately used by\n-             parse_structure () and variable_decl () to add components of\n-             this type.  */\n-          snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"SS$%u\", gfc_structure_id++);\n-      }\n+  m = gfc_match (\" /%n/\", name);\n+  if (m != MATCH_YES)\n+    {\n+      /* Non-nested structure declarations require a structure name.  */\n+      if (!gfc_comp_struct (gfc_current_state ()))\n+\t{\n+\t    gfc_error (\"Structure name expected in non-nested structure \"\n+\t\t       \"declaration at %C\");\n+\t    return MATCH_ERROR;\n+\t}\n+      /* This is an anonymous structure; make up a unique name for it\n+\t (upper-case letters never make it to symbol names from the source).\n+\t The important thing is initializing the type variable\n+\t and setting gfc_new_symbol, which is immediately used by\n+\t parse_structure () and variable_decl () to add components of\n+\t this type.  */\n+      snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"SS$%u\", gfc_structure_id++);\n+    }\n \n-    where = gfc_current_locus;\n-    /* No field list allowed after non-nested structure declaration.  */\n-    if (!gfc_comp_struct (gfc_current_state ())\n-        && gfc_match_eos () != MATCH_YES)\n-      {\n-          gfc_error (\"Junk after non-nested STRUCTURE statement at %C\");\n-          return MATCH_ERROR;\n-      }\n+  where = gfc_current_locus;\n+  /* No field list allowed after non-nested structure declaration.  */\n+  if (!gfc_comp_struct (gfc_current_state ())\n+      && gfc_match_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Junk after non-nested STRUCTURE statement at %C\");\n+      return MATCH_ERROR;\n+    }\n \n-    /* Make sure the name is not the name of an intrinsic type.  */\n-    if (gfc_is_intrinsic_typename (name))\n-      {\n-        gfc_error (\"Structure name '%s' at %C cannot be the same as an\"\n-                   \" intrinsic type\", name);\n-        return MATCH_ERROR;\n-      }\n+  /* Make sure the name is not the name of an intrinsic type.  */\n+  if (gfc_is_intrinsic_typename (name))\n+    {\n+      gfc_error (\"Structure name '%s' at %C cannot be the same as an\"\n+\t\t \" intrinsic type\", name);\n+      return MATCH_ERROR;\n+    }\n \n-    /* Store the actual type symbol for the structure with an upper-case first\n-       letter (an invalid Fortran identifier).  */\n+  /* Store the actual type symbol for the structure with an upper-case first\n+     letter (an invalid Fortran identifier).  */\n \n-    sprintf (name, gfc_dt_upper_string (name));\n-    if (!get_struct_decl (name, FL_STRUCT, &where, &sym))\n-      return MATCH_ERROR;\n+  sprintf (name, gfc_dt_upper_string (name));\n+  if (!get_struct_decl (name, FL_STRUCT, &where, &sym))\n+    return MATCH_ERROR;\n \n-    gfc_new_block = sym;\n-    return MATCH_YES;\n+  gfc_new_block = sym;\n+  return MATCH_YES;\n }\n \n "}, {"sha": "a0cb0bb9ce300b9fb8e5433bf21da08b2b65895e", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05b8fcb4d2087c1544ebe3ad128711f12bcff022/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05b8fcb4d2087c1544ebe3ad128711f12bcff022/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=05b8fcb4d2087c1544ebe3ad128711f12bcff022", "patch": "@@ -558,46 +558,46 @@ gfc_compare_union_types (gfc_symbol *un1, gfc_symbol *un2)\n      we will say they are not equal for the purposes of this test; therefore\n      we compare the maps sequentially. */\n   for (;;)\n-  {\n-    map1_t = map1->ts.u.derived;\n-    map2_t = map2->ts.u.derived;\n+    {\n+      map1_t = map1->ts.u.derived;\n+      map2_t = map2->ts.u.derived;\n \n-    cmp1 = map1_t->components;\n-    cmp2 = map2_t->components;\n+      cmp1 = map1_t->components;\n+      cmp2 = map2_t->components;\n \n-    /* Protect against null components.  */\n-    if (map1_t->attr.zero_comp != map2_t->attr.zero_comp)\n-      return 0;\n+      /* Protect against null components.  */\n+      if (map1_t->attr.zero_comp != map2_t->attr.zero_comp)\n+\treturn 0;\n \n-    if (map1_t->attr.zero_comp)\n-      return 1;\n+      if (map1_t->attr.zero_comp)\n+\treturn 1;\n \n-    for (;;)\n-    {\n-      /* No two fields will ever point to the same map type unless they are\n-         the same component, because one map field is created with its type\n-         declaration. Therefore don't worry about recursion here. */\n-      /* TODO: worry about recursion into parent types of the unions? */\n-      if (compare_components (cmp1, cmp2, map1_t, map2_t) == 0)\n-        return 0;\n+      for (;;)\n+\t{\n+\t  /* No two fields will ever point to the same map type unless they are\n+\t     the same component, because one map field is created with its type\n+\t     declaration. Therefore don't worry about recursion here. */\n+\t  /* TODO: worry about recursion into parent types of the unions? */\n+\t  if (compare_components (cmp1, cmp2, map1_t, map2_t) == 0)\n+\t    return 0;\n \n-      cmp1 = cmp1->next;\n-      cmp2 = cmp2->next;\n+\t  cmp1 = cmp1->next;\n+\t  cmp2 = cmp2->next;\n \n-      if (cmp1 == NULL && cmp2 == NULL)\n-        break;\n-      if (cmp1 == NULL || cmp2 == NULL)\n-        return 0;\n-    }\n+\t  if (cmp1 == NULL && cmp2 == NULL)\n+\t    break;\n+\t  if (cmp1 == NULL || cmp2 == NULL)\n+\t    return 0;\n+\t}\n \n-    map1 = map1->next;\n-    map2 = map2->next;\n+      map1 = map1->next;\n+      map2 = map2->next;\n \n-    if (map1 == NULL && map2 == NULL)\n-      break;\n-    if (map1 == NULL || map2 == NULL)\n-      return 0;\n-  }\n+      if (map1 == NULL && map2 == NULL)\n+\tbreak;\n+      if (map1 == NULL || map2 == NULL)\n+\treturn 0;\n+    }\n \n   return 1;\n }"}]}