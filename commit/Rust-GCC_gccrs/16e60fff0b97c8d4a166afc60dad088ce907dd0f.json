{"sha": "16e60fff0b97c8d4a166afc60dad088ce907dd0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZlNjBmZmYwYjk3YzhkNGExNjZhZmM2MGRhZDA4OGNlOTA3ZGQwZg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2014-05-12T19:23:11Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2014-05-12T19:23:11Z"}, "message": "Fix stack overflow crash in getcwd intrinsic.\n\n2014-05-12  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libfortran/61035\n\t* intrinsics/getcwd.c (getcwd_i4_sub): Avoid potentially large\n\tstack allocation, avoid extra copying in the common case.\n\nFrom-SVN: r210335", "tree": {"sha": "abee16e7f24de843f1d23fe13d306718e67bbd5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abee16e7f24de843f1d23fe13d306718e67bbd5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16e60fff0b97c8d4a166afc60dad088ce907dd0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e60fff0b97c8d4a166afc60dad088ce907dd0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e60fff0b97c8d4a166afc60dad088ce907dd0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e60fff0b97c8d4a166afc60dad088ce907dd0f/comments", "author": null, "committer": null, "parents": [{"sha": "f7b6856fa4cb73c3b4b4f41a1fbced4c5cf7ebd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b6856fa4cb73c3b4b4f41a1fbced4c5cf7ebd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7b6856fa4cb73c3b4b4f41a1fbced4c5cf7ebd1"}], "stats": {"total": 43, "additions": 32, "deletions": 11}, "files": [{"sha": "ed26a4d70772649a0e60b76f9e1186cd1b61470b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e60fff0b97c8d4a166afc60dad088ce907dd0f/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e60fff0b97c8d4a166afc60dad088ce907dd0f/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=16e60fff0b97c8d4a166afc60dad088ce907dd0f", "patch": "@@ -1,3 +1,9 @@\n+2014-05-12  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/61035\n+\t* intrinsics/getcwd.c (getcwd_i4_sub): Avoid potentially large\n+\tstack allocation, avoid extra copying in the common case.\n+\n 2014-05-12  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* configure.ac (AM_CFLAGS): Use -std=gnu11."}, {"sha": "2bc1fbc8266444a46ecb27a7d39875f78dbc3fcc", "filename": "libgfortran/intrinsics/getcwd.c", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e60fff0b97c8d4a166afc60dad088ce907dd0f/libgfortran%2Fintrinsics%2Fgetcwd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e60fff0b97c8d4a166afc60dad088ce907dd0f/libgfortran%2Fintrinsics%2Fgetcwd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fgetcwd.c?ref=16e60fff0b97c8d4a166afc60dad088ce907dd0f", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 2004-2014 Free Software Foundation, Inc.\n    Contributed by Steven G. Kargl <kargls@comcast.net>.\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -40,20 +40,35 @@ iexport_proto(getcwd_i4_sub);\n void\n getcwd_i4_sub (char *cwd, GFC_INTEGER_4 *status, gfc_charlen_type cwd_len)\n {\n-  char str[cwd_len + 1];\n-  GFC_INTEGER_4 stat;\n+  int err;\n \n-  memset(cwd, ' ', (size_t) cwd_len);\n-\n-  if (!getcwd (str, (size_t) cwd_len + 1))\n-    stat = errno;\n-  else\n+  if (getcwd (cwd, cwd_len))\n     {\n-      stat = 0;\n-      memcpy (cwd, str, strlen (str));\n+      size_t len = strlen (cwd);\n+      memset (cwd + len, ' ', cwd_len - len);\n+      err = 0;\n     }\n+  else if (errno == ERANGE)\n+    {\n+      /* There is a possibility that the previous attempt failed due\n+\t to not enough space for the terminating null byte. Try again\n+\t with a buffer one char longer.  */\n+      char *buf = xmalloc (cwd_len + 1);\n+      if (getcwd (buf, cwd_len + 1))\n+\t{\n+\t  memcpy (cwd, buf, cwd_len);\n+\t  err = 0;\n+\t}\n+      else\n+\terr = errno;\n+      free (buf);\n+    }\n+  else\n+    err = errno;\n+  if (err)\n+    memset (cwd, ' ', cwd_len);\n   if (status != NULL)\n-    *status = stat;\n+    *status = err;\n }\n iexport(getcwd_i4_sub);\n "}]}