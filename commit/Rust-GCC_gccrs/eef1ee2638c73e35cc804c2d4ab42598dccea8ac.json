{"sha": "eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "node_id": "C_kwDOANBUbNoAKGVlZjFlZTI2MzhjNzNlMzVjYzgwNGMyZDRhYjQyNTk4ZGNjZWE4YWM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-23T09:28:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-23T09:28:09Z"}, "message": "Merge #1049\n\n1049: Add better restrictions around semicolons in statements r=CohenArthur a=CohenArthur\n\nWhen parsing macro invocations, rustc does not actually consume the\r\nstatement's trailing semicolon.\r\n\r\nLet's take the following example:\r\n```rust\r\nmacro_rules! one_stmt {\r\n    ($s:stmt) => {};\r\n}\r\n\r\nmacro_rules! one_or_more_stmt {\r\n    ($($s:stmt)*) => {};\r\n}\r\n\r\none_stmt!(let a = 1);\r\none_stmt!(let b = 2;); // error\r\n\r\none_or_more_stmt!(;); // valid\r\none_or_more_stmt!(let a = 15;); // valid, two statements!\r\none_or_more_stmt!(let a = 15 let b = 13); // valid, two statements again\r\n```\r\n\r\nA semicolon can count as a valid empty statement, but cannot be part of\r\na statement (in macro invocations). This commit adds more restrictions\r\nthat allow the parser to not always expect a semicolon token after the\r\nstatement. Furthermore, this fixes a test that was previously accepted\r\nby the compiler but not by rustc.\r\n\r\nFixes #1046 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "49e8cb28376b9059702bad0b2ead1fa054ad583b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49e8cb28376b9059702bad0b2ead1fa054ad583b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiOugpCRBK7hj4Ov3rIwAAWV0IABFTPHPk/RJwDYQZbrh0nr+o\nYBSealfOEQ7CTQaX9468M63yzpOARspnNE/K9kM7fHAdfD/olIUmY9TboU35xJ5/\nLhrK4yPxmVeuIk7U7SlU3pykUfunLzux0iMOPVxGSda/Ft6DDeFHSCGLZ9fSd/QW\n735DXAHg430PB8/rRe/p0kSc+6ZCUTSW4jGBofK4g7s0CO3Qbj3m/SD4UDPR2Bvc\nzKmFRZJV6YRd7HqLddXGfikS7GQfmAIyallA6O33Ek5xwgadBDvOVLHC8irt4yBY\nOZQCivcTOhZKxhOUOUfeaNxiu7s0BUYNdgiQ+gyGMJ+YZoIiXWpqX3KgrXojIvs=\n=iyY/\n-----END PGP SIGNATURE-----\n", "payload": "tree 49e8cb28376b9059702bad0b2ead1fa054ad583b\nparent b9720caa100efa6758a5f0d54d3764072d83be41\nparent ef5638186202daac03feed7a20eb975991965403\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648027689 +0000\ncommitter GitHub <noreply@github.com> 1648027689 +0000\n\nMerge #1049\n\n1049: Add better restrictions around semicolons in statements r=CohenArthur a=CohenArthur\n\nWhen parsing macro invocations, rustc does not actually consume the\r\nstatement's trailing semicolon.\r\n\r\nLet's take the following example:\r\n```rust\r\nmacro_rules! one_stmt {\r\n    ($s:stmt) => {};\r\n}\r\n\r\nmacro_rules! one_or_more_stmt {\r\n    ($($s:stmt)*) => {};\r\n}\r\n\r\none_stmt!(let a = 1);\r\none_stmt!(let b = 2;); // error\r\n\r\none_or_more_stmt!(;); // valid\r\none_or_more_stmt!(let a = 15;); // valid, two statements!\r\none_or_more_stmt!(let a = 15 let b = 13); // valid, two statements again\r\n```\r\n\r\nA semicolon can count as a valid empty statement, but cannot be part of\r\na statement (in macro invocations). This commit adds more restrictions\r\nthat allow the parser to not always expect a semicolon token after the\r\nstatement. Furthermore, this fixes a test that was previously accepted\r\nby the compiler but not by rustc.\r\n\r\nFixes #1046 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9720caa100efa6758a5f0d54d3764072d83be41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9720caa100efa6758a5f0d54d3764072d83be41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9720caa100efa6758a5f0d54d3764072d83be41"}, {"sha": "ef5638186202daac03feed7a20eb975991965403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef5638186202daac03feed7a20eb975991965403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef5638186202daac03feed7a20eb975991965403"}], "stats": {"total": 87, "additions": 53, "deletions": 34}, "files": [{"sha": "e0dfc502609e60b23a751b00f6eb7e2ccc4660aa", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "patch": "@@ -477,9 +477,12 @@ MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n       parser.parse_visibility ();\n       break;\n \n-    case AST::MacroFragSpec::STMT:\n-      parser.parse_stmt (/* allow_no_semi */ true);\n-      break;\n+      case AST::MacroFragSpec::STMT: {\n+\tauto restrictions = ParseRestrictions ();\n+\trestrictions.consume_semi = false;\n+\tparser.parse_stmt (restrictions);\n+\tbreak;\n+      }\n \n     case AST::MacroFragSpec::LIFETIME:\n       parser.parse_lifetime_params ();\n@@ -887,11 +890,14 @@ transcribe_many_trait_impl_items (Parser<MacroInvocLexer> &parser,\n static std::vector<AST::SingleASTNode>\n transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n+  auto restrictions = ParseRestrictions ();\n+  restrictions.consume_semi = false;\n+\n   // FIXME: This is invalid! It needs to also handle cases where the macro\n   // transcriber is an expression, but since the macro call is followed by\n   // a semicolon, it's a valid ExprStmt\n-  return parse_many (parser, delimiter, [&parser] () {\n-    auto stmt = parser.parse_stmt (/* allow_no_semi */ true);\n+  return parse_many (parser, delimiter, [&parser, restrictions] () {\n+    auto stmt = parser.parse_stmt (restrictions);\n     return AST::SingleASTNode (std::move (stmt));\n   });\n }"}, {"sha": "5dfe29f4e9028e55be7951cd8d8a5863bacb039a", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "patch": "@@ -6100,7 +6100,7 @@ Parser<ManagedTokenSource>::parse_named_function_param (\n // Parses a statement (will further disambiguate any statement).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Stmt>\n-Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n+Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n {\n   // quick exit for empty statement\n   // FIXME: Can we have empty statements without semicolons? Just nothing?\n@@ -6125,7 +6125,7 @@ Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n     {\n     case LET:\n       // let statement\n-      return parse_let_stmt (std::move (outer_attrs), allow_no_semi);\n+      return parse_let_stmt (std::move (outer_attrs), restrictions);\n     case PUB:\n     case MOD:\n     case EXTERN_TOK:\n@@ -6180,7 +6180,7 @@ Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n       // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n     default:\n       // fallback: expression statement\n-      return parse_expr_stmt (std::move (outer_attrs), allow_no_semi);\n+      return parse_expr_stmt (std::move (outer_attrs), restrictions);\n       break;\n     }\n }\n@@ -6189,7 +6189,7 @@ Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::LetStmt>\n Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs,\n-\t\t\t\t\t    bool allow_no_semi)\n+\t\t\t\t\t    ParseRestrictions restrictions)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (LET);\n@@ -6244,13 +6244,9 @@ Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs,\n \t}\n     }\n \n-  if (!maybe_skip_token (SEMICOLON) && !allow_no_semi)\n-    {\n-      // skip after somewhere\n+  if (restrictions.consume_semi)\n+    if (!skip_token (SEMICOLON))\n       return nullptr;\n-      /* TODO: how wise is it to ditch a mostly-valid let statement just\n-       * because a semicolon is missing? */\n-    }\n \n   return std::unique_ptr<AST::LetStmt> (\n     new AST::LetStmt (std::move (pattern), std::move (expr), std::move (type),\n@@ -7085,7 +7081,7 @@ Parser<ManagedTokenSource>::parse_method ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmt>\n Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n-\t\t\t\t\t     bool allow_no_semi)\n+\t\t\t\t\t     ParseRestrictions restrictions)\n {\n   /* potential thoughts - define new virtual method \"has_block()\" on expr. parse\n    * expr and then determine whether semicolon is needed as a result of this\n@@ -7125,7 +7121,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n \telse\n \t  {\n \t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n-\t\t\t\t\t\t  allow_no_semi);\n+\t\t\t\t\t\t  restrictions);\n \t  }\n       }\n       case UNSAFE: {\n@@ -7139,7 +7135,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n \telse\n \t  {\n \t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n-\t\t\t\t\t\t  allow_no_semi);\n+\t\t\t\t\t\t  restrictions);\n \t  }\n       }\n     default:\n@@ -7148,7 +7144,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n        * initial tokens in order to prevent more syntactical errors at parse\n        * time. */\n       return parse_expr_stmt_without_block (std::move (outer_attrs),\n-\t\t\t\t\t    allow_no_semi);\n+\t\t\t\t\t    restrictions);\n     }\n }\n \n@@ -7264,7 +7260,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmtWithoutBlock>\n Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n-  AST::AttrVec outer_attrs, bool allow_no_semi)\n+  AST::AttrVec outer_attrs, ParseRestrictions restrictions)\n {\n   /* TODO: maybe move more logic for expr without block in here for better error\n    * handling */\n@@ -7273,7 +7269,6 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n   std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n   Location locus = lexer.peek_token ()->get_locus ();\n \n-  auto restrictions = ParseRestrictions ();\n   restrictions.expr_can_be_stmt = true;\n \n   expr = parse_expr_without_block (std::move (outer_attrs), restrictions);\n@@ -7288,12 +7283,9 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n       return nullptr;\n     }\n \n-  // skip semicolon at end that is required\n-  if (!maybe_skip_token (SEMICOLON) && !allow_no_semi)\n-    {\n-      // skip somewhere?\n+  if (restrictions.consume_semi)\n+    if (!skip_token (SEMICOLON))\n       return nullptr;\n-    }\n \n   return std::unique_ptr<AST::ExprStmtWithoutBlock> (\n     new AST::ExprStmtWithoutBlock (std::move (expr), locus));"}, {"sha": "cb77033fe5597d81a5ad3c0942ad1c6ad75ecea3", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "patch": "@@ -81,6 +81,7 @@ struct ParseRestrictions\n   bool entered_from_unary = false;\n   bool expr_can_be_null = false;\n   bool expr_can_be_stmt = false;\n+  bool consume_semi = true;\n };\n \n // Parser implementation for gccrs.\n@@ -129,11 +130,9 @@ template <typename ManagedTokenSource> class Parser\n    *    | LetStatement\n    *    | ExpressionStatement\n    *    | MacroInvocationSemi\n-   *\n-   * @param allow_no_semi Allow the parser to not parse a semicolon after\n-   * \t\tthe statement without erroring out\n    */\n-  std::unique_ptr<AST::Stmt> parse_stmt (bool allow_no_semi = false);\n+  std::unique_ptr<AST::Stmt> parse_stmt (ParseRestrictions restrictions\n+\t\t\t\t\t = ParseRestrictions ());\n   std::unique_ptr<AST::Type> parse_type ();\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n   std::unique_ptr<AST::TraitItem> parse_trait_item ();\n@@ -616,14 +615,17 @@ template <typename ManagedTokenSource> class Parser\n    * \t\tsemicolon to follow it\n    */\n   std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs,\n-\t\t\t\t\t\tbool allow_no_semi = false);\n+\t\t\t\t\t\tParseRestrictions restrictions\n+\t\t\t\t\t\t= ParseRestrictions ());\n   std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs,\n-\t\t\t\t\t\t  bool allow_no_semi = false);\n+\t\t\t\t\t\t  ParseRestrictions restrictions\n+\t\t\t\t\t\t  = ParseRestrictions ());\n   std::unique_ptr<AST::ExprStmtWithBlock>\n   parse_expr_stmt_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmtWithoutBlock>\n   parse_expr_stmt_without_block (AST::AttrVec outer_attrs,\n-\t\t\t\t bool allow_no_semi = false);\n+\t\t\t\t ParseRestrictions restrictions\n+\t\t\t\t = ParseRestrictions ());\n   ExprOrStmt parse_stmt_or_expr_without_block ();\n   ExprOrStmt parse_stmt_or_expr_with_block (AST::AttrVec outer_attrs);\n   ExprOrStmt parse_macro_invocation_maybe_semi (AST::AttrVec outer_attrs);"}, {"sha": "5418725b619cd0e708fc2f24d935e8c7ad83e4f4", "filename": "gcc/testsuite/rust/compile/macro18.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs?ref=eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "patch": "@@ -7,7 +7,7 @@ macro_rules! take_stmt {\n }\n \n fn main() -> i32 {\n-    take_stmt!(let complete = 15;);\n+    take_stmt!(let complete = 15;); // { dg-error \"Failed to match any rule within macro\" }\n     take_stmt!(let lacking = 14);\n \n     0"}, {"sha": "d1d6305e6bdd005a0a696037926389ae9767c85b", "filename": "gcc/testsuite/rust/compile/macro32.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef1ee2638c73e35cc804c2d4ab42598dccea8ac/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro32.rs?ref=eef1ee2638c73e35cc804c2d4ab42598dccea8ac", "patch": "@@ -0,0 +1,19 @@\n+macro_rules! s {\n+    ($s:stmt) => {{}};\n+}\n+\n+macro_rules! multi_s {\n+    ($($s:stmt)+) => {{}};\n+}\n+\n+fn main() -> i32 {\n+    s!(let a = 15);\n+    s!(;); // Empty statement\n+    s!(let a = 15;); // { dg-error \"Failed to match any rule within macro\" }\n+    multi_s!(let a = 15;);\n+    // ^ this actually gets parsed as two statements - one LetStmt and one\n+    // empty statement. This is the same behavior as rustc, which you can\n+    // see using a count!() macro\n+\n+    32\n+}"}]}