{"sha": "ea1ebe12668f086e41253260075616b277c920da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWExZWJlMTI2NjhmMDg2ZTQxMjUzMjYwMDc1NjE2YjI3N2M5MjBkYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2005-02-02T22:09:16Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2005-02-02T22:09:16Z"}, "message": "Revert bad import\n\nFrom-SVN: r94621", "tree": {"sha": "2aa957d46f9795762ffcdd5ed13a4e0280d65738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2aa957d46f9795762ffcdd5ed13a4e0280d65738"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea1ebe12668f086e41253260075616b277c920da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1ebe12668f086e41253260075616b277c920da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea1ebe12668f086e41253260075616b277c920da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1ebe12668f086e41253260075616b277c920da/comments", "author": null, "committer": null, "parents": [{"sha": "6c02751b14035a957cd17450909605fa973b3b27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c02751b14035a957cd17450909605fa973b3b27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c02751b14035a957cd17450909605fa973b3b27"}], "stats": {"total": 132562, "additions": 0, "deletions": 132562}, "files": [{"sha": "968e271ff44ad6bb0d11a31c7afd7a5405ce4cf6", "filename": "gcc/config/dsp16xx/dsp16xx-modes.def", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,23 +0,0 @@\n-/* DSP16xx extra modes.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* HFmode is the DSP16xx's equivalent of SFmode.\n-   FIXME: What format is this anyway? */ \n-FLOAT_MODE (HF, 2, 0);"}, {"sha": "802c69b62ec8e50d5a0349eeff040a719608c302", "filename": "gcc/config/dsp16xx/dsp16xx-protos.h", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,86 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  AT&T DSP1600.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Michael Collison (collison@world.std.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-extern struct rtx_def *gen_compare_reg (enum rtx_code, rtx, rtx);\n-extern int call_address_operand (rtx, enum machine_mode);\n-extern int arith_reg_operand (rtx, enum machine_mode);\n-extern int symbolic_address_operand (rtx, enum machine_mode);\n-extern int Y_address_operand (rtx, enum machine_mode);\n-extern int sp_operand (rtx, enum machine_mode);\n-extern int sp_operand2 (rtx, enum machine_mode);\n-extern int nonmemory_arith_operand (rtx, enum machine_mode);\n-extern int dsp16xx_comparison_operator (rtx, enum machine_mode);\n-extern int unx_comparison_operator (rtx, enum machine_mode);\n-extern int signed_comparison_operator (rtx, enum machine_mode);\n-\n-extern void notice_update_cc (rtx);\n-extern void double_reg_from_memory (rtx[]);\n-extern void double_reg_to_memory (rtx[]);\n-extern enum rtx_code next_cc_user_code (rtx);\n-extern int next_cc_user_unsigned (rtx);\n-extern struct rtx_def *gen_tst_reg (rtx);\n-extern const char *output_block_move (rtx[]);\n-extern enum reg_class preferred_reload_class (rtx, enum reg_class);\n-extern enum reg_class secondary_reload_class (enum reg_class,\n-\t\t\t\t\t      enum machine_mode, rtx);\n-extern int emit_move_sequence (rtx *, enum machine_mode);\n-extern void print_operand (FILE *, rtx, int);\n-extern void print_operand_address (FILE *, rtx);\n-extern void output_dsp16xx_float_const (rtx *);\n-extern void emit_1600_core_shift (enum rtx_code, rtx *, int);\n-extern int symbolic_address_p (rtx);\n-extern int uns_comparison_operator (rtx, enum machine_mode);\n-#endif /* RTX_CODE */\n-\n-\n-#ifdef TREE_CODE\n-extern struct rtx_def *dsp16xx_function_arg (CUMULATIVE_ARGS,\n-\t\t\t\t\t     enum machine_mode,\n-\t\t\t\t\t     tree, int);\n-extern void dsp16xx_function_arg_advance (CUMULATIVE_ARGS *,\n-\t\t\t\t\t  enum machine_mode,\n-\t\t\t\t\t  tree, int);\n-#endif /* TREE_CODE */\n-\n-extern void dsp16xx_invalid_register_for_compare (void);\n-extern int class_max_nregs (enum reg_class, enum machine_mode);\n-extern enum reg_class limit_reload_class (enum reg_class, enum machine_mode);\n-extern int dsp16xx_register_move_cost (enum reg_class, enum reg_class);\n-extern int dsp16xx_makes_calls (void);\n-extern long compute_frame_size (int);\n-extern int dsp16xx_call_saved_register (int);\n-extern int dsp16xx_call_saved_register (int);\n-extern void init_emulation_routines (void);\n-extern int ybase_regs_ever_used (void);\n-extern void override_options (void);\n-extern int dsp16xx_starting_frame_offset (void);\n-extern int initial_frame_pointer_offset (void);\n-extern void asm_output_common (FILE *, const char *, int, int);\n-extern void asm_output_local (FILE *, const char *, int, int);\n-extern void asm_output_float (FILE *, double);\n-extern bool dsp16xx_compare_gen;\n-extern int hard_regno_mode_ok (int, enum machine_mode);\n-extern enum reg_class dsp16xx_reg_class_from_letter (int);\n-extern int regno_reg_class (int);\n-extern void function_prologue (FILE *, int);\n-extern void function_epilogue (FILE *, int);\n-extern int num_1600_core_shifts (int);"}, {"sha": "14d9c5e088e21515d56ee000fcf17e1d2407c8ee", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "removed", "additions": 0, "deletions": 2632, "changes": 2632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,2632 +0,0 @@\n-/* Subroutines for assembler code output on the DSP1610.\n-   Copyright (C) 1994, 1995, 1997, 1998, 2001 Free Software Foundation, Inc.\n-   Contributed by Michael Collison (collison@isisinc.net).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Some output-actions in dsp1600.md need these.  */\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"function.h\"\n-#include \"flags.h\"\n-#include \"ggc.h\"\n-#include \"toplev.h\"\n-#include \"recog.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-const char *text_seg_name;\n-const char *rsect_text;\n-const char *data_seg_name;\n-const char *rsect_data;\n-const char *bss_seg_name;\n-const char *rsect_bss;\n-const char *const_seg_name;\n-const char *rsect_const;\n-\n-const char *chip_name;\n-const char *save_chip_name;\n-\n-/* Save the operands of a compare. The 16xx has not lt or gt, so\n-   in these cases we swap the operands and reverse the condition.  */\n-\n-rtx dsp16xx_compare_op0;\n-rtx dsp16xx_compare_op1;\n-bool dsp16xx_compare_gen;\n-\n-static const char *fp;\n-static const char *sp;\n-static const char *rr;\n-static const char *a1h;\n-\n-struct dsp16xx_frame_info current_frame_info;\n-struct dsp16xx_frame_info zero_frame_info;\n-\n-rtx dsp16xx_addhf3_libcall = (rtx) 0;\n-rtx dsp16xx_subhf3_libcall = (rtx) 0;\n-rtx dsp16xx_mulhf3_libcall = (rtx) 0;\n-rtx dsp16xx_divhf3_libcall = (rtx) 0;\n-rtx dsp16xx_cmphf3_libcall = (rtx) 0;\n-rtx dsp16xx_fixhfhi2_libcall = (rtx) 0;\n-rtx dsp16xx_floathihf2_libcall = (rtx) 0;\n-rtx dsp16xx_neghf2_libcall = (rtx) 0;\n-\n-rtx dsp16xx_mulhi3_libcall = (rtx) 0;\n-rtx dsp16xx_udivqi3_libcall = (rtx) 0;\n-rtx dsp16xx_udivhi3_libcall = (rtx) 0;\n-rtx dsp16xx_divqi3_libcall = (rtx) 0;\n-rtx dsp16xx_divhi3_libcall = (rtx) 0;\n-rtx dsp16xx_modqi3_libcall = (rtx) 0;\n-rtx dsp16xx_modhi3_libcall = (rtx) 0;\n-rtx dsp16xx_umodqi3_libcall = (rtx) 0;\n-rtx dsp16xx_umodhi3_libcall = (rtx) 0;\n-rtx dsp16xx_ashrhi3_libcall = (rtx) 0;\n-rtx dsp16xx_ashlhi3_libcall = (rtx) 0;\n-rtx dsp16xx_ucmphi2_libcall = (rtx) 0;\n-rtx dsp16xx_lshrhi3_libcall = (rtx) 0;\n-\n-static const char *const himode_reg_name[] = HIMODE_REGISTER_NAMES;\n-\n-#define SHIFT_INDEX_1   0\n-#define SHIFT_INDEX_4   1\n-#define SHIFT_INDEX_8   2\n-#define SHIFT_INDEX_16  3\n-\n-static const char *const ashift_right_asm[] = \n-{\n-  \"%0=%0>>1\",\n-  \"%0=%0>>4\",\n-  \"%0=%0>>8\",\n-  \"%0=%0>>16\"\n-};\n-\n-static const char *const ashift_right_asm_first[] = \n-{\n-  \"%0=%1>>1\",\n-  \"%0=%1>>4\",\n-  \"%0=%1>>8\",\n-  \"%0=%1>>16\"\n-};\n-\n-static const char *const ashift_left_asm[] = \n-{\n-  \"%0=%0<<1\",\n-  \"%0=%0<<4\",\n-  \"%0=%0<<8\",\n-  \"%0=%0<<16\"\n-};\n-\n-static const char *const ashift_left_asm_first[] = \n-{\n-  \"%0=%1<<1\",\n-  \"%0=%1<<4\",\n-  \"%0=%1<<8\",\n-  \"%0=%1<<16\"\n-};\n-\n-static const char *const lshift_right_asm[] = \n-{\n-  \"%0=%0>>1\\n\\t%0=%b0&0x7fff\",\n-  \"%0=%0>>4\\n\\t%0=%b0&0x0fff\",\n-  \"%0=%0>>8\\n\\t%0=%b0&0x00ff\",\n-  \"%0=%0>>16\\n\\t%0=%b0&0x0000\"\n-};\n-\n-static const char *const lshift_right_asm_first[] = \n-{\n-  \"%0=%1>>1\\n\\t%0=%b0&0x7fff\",\n-  \"%0=%1>>4\\n\\t%0=%b0&0x0fff\",\n-  \"%0=%1>>8\\n\\t%0=%b0&0x00ff\",\n-  \"%0=%1>>16\\n\\t%0=%b0&0x0000\"\n-};\n-\n-static int reg_save_size (void);\n-static void dsp16xx_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void dsp16xx_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void dsp16xx_file_start (void);\n-static bool dsp16xx_rtx_costs (rtx, int, int, int *);\n-static int dsp16xx_address_cost (rtx);\n-\f\n-/* Initialize the GCC target structure.  */\n-\n-#undef TARGET_ASM_BYTE_OP\n-#define TARGET_ASM_BYTE_OP \"\\tint\\t\"\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP NULL\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP NULL\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE dsp16xx_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE dsp16xx_output_function_epilogue\n-\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START dsp16xx_file_start\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS dsp16xx_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST dsp16xx_address_cost\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\n-int \n-hard_regno_mode_ok (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n-{\n-  switch ((int) mode)\n-    {\n-    case VOIDmode:\n-      return 1;\n-      \n-      /* We can't use the c0-c2 for QImode, since they are only\n-\t 8 bits in length.  */\n-\n-    case QImode:\n-      if (regno != REG_C0 && regno != REG_C1 && regno != REG_C2)\n-\treturn 1;\n-      else\n-\treturn 0;\n-      \n-      /* We only allow a0, a1, y, and p to be allocated for 32-bit modes.\n-         Additionally we allow the virtual ybase registers to be used for 32-bit\n-\t modes.  */\n-      \n-    case HFmode:\n-    case HImode:\n-#if 0 /* ??? These modes do not appear in the machine description nor\n-         are there library routines for them.  */\n-    case SFmode:\n-    case DFmode:\n-    case XFmode:\n-    case SImode:\n-    case DImode:\n-#endif\n-      if (regno == REG_A0 || regno == REG_A1 || regno == REG_Y || regno == REG_PROD\n-\t  || (IS_YBASE_REGISTER_WINDOW(regno) && ((regno & 1) == 0)))\n-\treturn 1;\n-      else\n-\treturn 0;\n-      \n-    default:\n-      return 0;\n-    }\n-}\n-\n-enum reg_class\n-dsp16xx_reg_class_from_letter (c)\n-     int c;\n-{\n-  switch (c)\n-    {\n-    case 'A':\n-      return ACCUM_REGS;\n-\n-    case 'l':\n-      return A0_REG;\n-\n-    case 'C':\n-      return A1_REG;\n-      \n-    case 'h':\n-      return ACCUM_HIGH_REGS;\n-      \n-    case 'j':\n-      return A0H_REG;\n-      \n-    case 'k':\n-      return A0L_REG;\n-      \n-    case 'q':\n-      return A1H_REG;\n-      \n-    case 'u':\n-      return A1L_REG;\n-      \n-    case 'x':\n-      return X_REG;\n-\n-    case 'y':\n-      return YH_REG;\n-\n-    case 'z':\n-      return YL_REG;\n-\n-    case 't':\n-      return P_REG;\n-\n-    case 'Z':\n-      return Y_OR_P_REGS;\n-\n-    case 'd':\n-      return ACCUM_Y_OR_P_REGS;\n-\n-    case 'a':\n-      return Y_ADDR_REGS;\n-\n-    case 'B':\n-      return (TARGET_BMU ? BMU_REGS : NO_REGS);\n-\n-    case 'Y':\n-      return YBASE_VIRT_REGS;\n-\n-    case 'v':\n-      return PH_REG;\n-\n-    case 'w':\n-      return PL_REG;\n-\n-    case 'W':\n-      return J_REG;\n-\n-    case 'e':\n-      return YBASE_ELIGIBLE_REGS;\n-\n-    case 'b':\n-      return ACCUM_LOW_REGS;\n-\n-    case 'c':\n-      return NON_YBASE_REGS;\n-\n-    case 'f':\n-      return Y_REG;\n-\n-    case 'D':\n-      return SLOW_MEM_LOAD_REGS;\n-\n-    default:\n-      return NO_REGS;\n-    }\n-}\n-\n-/* Return the class number of the smallest class containing\n-   reg number REGNO.  */\n-\n-int \n-regno_reg_class(regno)\n-     int regno;\n-{\n-  switch (regno)\n-    {\n-    case REG_A0L:\n-      return (int) A0L_REG;\n-    case REG_A1L:\n-      return (int) A1L_REG;\n-      \n-    case REG_A0:\n-      return (int) A0H_REG;\n-    case REG_A1:\n-      return (int) A1H_REG;\n-      \n-    case REG_X:\n-      return (int) X_REG;\n-      \n-    case REG_Y:\n-      return (int) YH_REG;\n-    case REG_YL:\n-      return (int) YL_REG;\n-      \n-    case REG_PROD:\n-      return (int) PH_REG;\n-    case REG_PRODL:\n-      return (int) PL_REG;\n-      \n-    case REG_R0: case REG_R1: case REG_R2: case REG_R3:\n-      return (int) Y_ADDR_REGS;\n-      \n-    case REG_J:\n-      return (int) J_REG;\n-    case REG_K:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_YBASE:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_PT:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_AR0: case REG_AR1: case REG_AR2: case REG_AR3:\n-      return (int) BMU_REGS;\n-      \n-    case REG_C0: case REG_C1: case REG_C2:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_PR:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_RB:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_YBASE0: case REG_YBASE1: case REG_YBASE2: case REG_YBASE3:\n-    case REG_YBASE4: case REG_YBASE5: case REG_YBASE6: case REG_YBASE7:\n-    case REG_YBASE8: case REG_YBASE9: case REG_YBASE10: case REG_YBASE11:\n-    case REG_YBASE12: case REG_YBASE13: case REG_YBASE14: case REG_YBASE15:\n-    case REG_YBASE16: case REG_YBASE17: case REG_YBASE18: case REG_YBASE19:\n-    case REG_YBASE20: case REG_YBASE21: case REG_YBASE22: case REG_YBASE23:\n-    case REG_YBASE24: case REG_YBASE25: case REG_YBASE26: case REG_YBASE27:\n-    case REG_YBASE28: case REG_YBASE29: case REG_YBASE30: case REG_YBASE31:\n-      return (int) YBASE_VIRT_REGS;\n-      \n-    default:\n-      return (int) NO_REGS;\n-    }\n-}\n-\n-/* A C expression for the maximum number of consecutive registers of class CLASS\n-   needed to hold a value of mode MODE.  */\n-\n-int\n-class_max_nregs(class, mode)\n-     enum reg_class class ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n-{\n-    return (GET_MODE_SIZE(mode));\n-}\n-\n-enum reg_class\n-limit_reload_class (mode, class)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     enum reg_class class;\n-{\n-  return class;\n-}\n-\n-int\n-dsp16xx_register_move_cost (from, to)\n-     enum reg_class from, to;\n-{\n-  if (from == A0H_REG || from == A0L_REG || from == A0_REG ||\n-      from == A1H_REG || from == ACCUM_HIGH_REGS || from == A1L_REG ||\n-      from == ACCUM_LOW_REGS || from == A1_REG || from == ACCUM_REGS)\n-    {\n-      if (to == Y_REG || to == P_REG)\n-\treturn 4;\n-      else\n-\treturn 2;\n-    }\n-\n-  if (to == A0H_REG || to == A0L_REG || to == A0_REG ||\n-      to == A1H_REG || to == ACCUM_HIGH_REGS || to == A1L_REG ||\n-      to == ACCUM_LOW_REGS || to == A1_REG || to == ACCUM_REGS)\n-    {\n-      return 2;\n-    }\n-\n-  if (from == YBASE_VIRT_REGS)\n-    {\n-      if (to == YBASE_VIRT_REGS)\n-\treturn 16;\n-\n-      if (to == X_REG || to == YH_REG || to == YL_REG ||\n-\t  to == Y_REG || to == PL_REG || to == PH_REG ||\n-\t  to == P_REG || to == Y_ADDR_REGS || to == YBASE_ELIGIBLE_REGS ||\n-\t  to == Y_OR_P_REGS)\n-\t{\n-\t  return 8;\n-\t}\n-      else\n-\treturn 10;\n-    }\n-\n-  if (to == YBASE_VIRT_REGS)\n-    {\n-      if (from == X_REG || from == YH_REG || from == YL_REG ||\n-\t  from == Y_REG || from == PL_REG || from == PH_REG ||\n-\t  from == P_REG || from == Y_ADDR_REGS || from == YBASE_ELIGIBLE_REGS ||\n-\t  from == Y_OR_P_REGS)\n-\t{\n-\t  return 8;\n-\t}\n-      else\n-\treturn 10;\n-    }\n-\n-  return 8;\n-}\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-   Also, we must ensure that a PLUS is reloaded either\n-   into an accumulator or an address register.  */\n-\n-enum reg_class\n-preferred_reload_class (x, class)\n-     rtx x;\n-     enum reg_class class;\n-{\n-  /* The ybase registers cannot have constants copied directly\n-     to them.  */\n-\n-  if (CONSTANT_P (x))\n-    {\n-      switch ((int) class)\n-\t{\n-\tcase YBASE_VIRT_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_YBASE_REGS:\n-\t  return ACCUM_LOW_REGS;\n-\n-\tcase ACCUM_OR_YBASE_REGS:\n-\t  return ACCUM_REGS;\n-\n-\tcase X_OR_YBASE_REGS:\n-\t  return X_REG;\n-\n-\tcase Y_OR_YBASE_REGS:\n-\t  return Y_REG;\n-\n-\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-\t  return YL_OR_PL_OR_ACCUM_LOW_REGS;\n-\n-\tcase P_OR_YBASE_REGS:\n-\t  return P_REG;\n-\n-\tcase ACCUM_Y_P_OR_YBASE_REGS:\n-\t  return ACCUM_Y_OR_P_REGS;\n-\n-\tcase Y_ADDR_OR_YBASE_REGS:\n-\t  return Y_ADDR_REGS;\n-\n-\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;;\n-\t  \n-\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n-\t  return YBASE_ELIGIBLE_REGS;\n-\n-\tcase NO_HIGH_ALL_REGS:\n-\t  return NOHIGH_NON_YBASE_REGS;\n-\n-\tcase ALL_REGS:\n-\t  return NON_YBASE_REGS;\n-\n-\tdefault:\n-\t  return class;\n-\t}\n-    }\n-\n-  /* If x is not an accumulator or a ybase register, restrict the class of registers\n-     we can copy the register into.  */\n-\n-  if (REG_P (x) && !IS_ACCUM_REG (REGNO (x)) && !IS_YBASE_REGISTER_WINDOW (REGNO (x)))\n-    {\n-      switch ((int) class)\n-\t{\n-\tcase NO_REGS:\n-\tcase A0H_REG: case A0L_REG: case A0_REG: case A1H_REG:\n-\tcase ACCUM_HIGH_REGS: case A1L_REG: case ACCUM_LOW_REGS: \n-\tcase A1_REG: case ACCUM_REGS:\n-\t  return class;\n-\n-\tcase X_REG: \n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase X_OR_ACCUM_LOW_REGS: \n-\t  return ACCUM_LOW_REGS;\n-\n-\tcase X_OR_ACCUM_REGS:\n-\t  return ACCUM_REGS;\n-\n-\tcase YH_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YH_OR_ACCUM_HIGH_REGS:\n-\t  return ACCUM_HIGH_REGS;\n-\n-\tcase X_OR_YH_REGS: \n-\tcase YL_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YL_OR_ACCUM_LOW_REGS: \n-\t  return ACCUM_LOW_REGS;\n-\n-\tcase X_OR_YL_REGS:\n-\tcase X_OR_Y_REGS: case Y_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_OR_Y_REGS: \n-\t  return ACCUM_REGS;\n-\n-\tcase PH_REG:\n-\tcase X_OR_PH_REGS: case PL_REG: \n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase PL_OR_ACCUM_LOW_REGS:\n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase X_OR_PL_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YL_OR_PL_OR_ACCUM_LOW_REGS: \n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase P_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_OR_P_REGS: \n-\t  return ACCUM_REGS;\n-\n-\tcase YL_OR_P_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_YL_OR_P_REGS: \n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase Y_OR_P_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_Y_OR_P_REGS: \n-\t  return ACCUM_REGS;\n-\n-\tcase NO_FRAME_Y_ADDR_REGS:\n-\tcase Y_ADDR_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_Y_ADDR_REGS:\n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase ACCUM_OR_Y_ADDR_REGS: \n-\t  return ACCUM_REGS;\n-\n-\tcase X_OR_Y_ADDR_REGS:\n-\tcase Y_OR_Y_ADDR_REGS: \n-\tcase P_OR_Y_ADDR_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase NON_HIGH_YBASE_ELIGIBLE_REGS: \n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase YBASE_ELIGIBLE_REGS:\n-\t  return ACCUM_REGS;\n-\n-\tcase J_REG:\n-\tcase J_OR_DAU_16_BIT_REGS:\n-\tcase BMU_REGS: \n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YBASE_VIRT_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return class;\n-\t  else\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return class;\n-\t  else\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase ACCUM_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return class;\n-\t  else\n-\t    return ACCUM_REGS;\n-\n-\tcase X_OR_YBASE_REGS:\n-\tcase Y_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return YBASE_VIRT_REGS;\n-\t  else\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_LOW_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase P_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return YBASE_VIRT_REGS;\n-\t  else\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_Y_P_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_REGS;\n-\n-\tcase Y_ADDR_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return YBASE_VIRT_REGS;\n-\t  else\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_LOW_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_REGS;\n-\n-\tcase NO_HIGH_ALL_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_LOW_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase ALL_REGS: \n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_REGS;\n-\n-\tcase NOHIGH_NON_ADDR_REGS:\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase NON_ADDR_REGS:\n-\tcase SLOW_MEM_LOAD_REGS:\n-\t    return ACCUM_REGS;\n-\n-\tcase NOHIGH_NON_YBASE_REGS:\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase NO_ACCUM_NON_YBASE_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase NON_YBASE_REGS:\n-\t    return ACCUM_REGS;\n-\n-\tdefault:\n-\t  return class;\n-\t}\n-    }\n-\n-  /* If x (the input) is a ybase register, restrict the class of registers\n-     we can copy the register into.  */\n-\n-  if (REG_P (x) && !TARGET_RESERVE_YBASE\n-      && IS_YBASE_REGISTER_WINDOW (REGNO(x)))\n-    {\n-      switch ((int) class)\n-\t{\n-\tcase NO_REGS:\n-\tcase A0H_REG: case A0L_REG: case A0_REG: case A1H_REG:\n-\tcase ACCUM_HIGH_REGS: case A1L_REG: case ACCUM_LOW_REGS: \n-\tcase A1_REG: case ACCUM_REGS: case X_REG: \n-\tcase X_OR_ACCUM_LOW_REGS: case X_OR_ACCUM_REGS:\n-\tcase YH_REG: case YH_OR_ACCUM_HIGH_REGS:\n-\tcase X_OR_YH_REGS: case YL_REG:\n-\tcase YL_OR_ACCUM_LOW_REGS: case X_OR_YL_REGS:\n-\tcase X_OR_Y_REGS: case Y_REG:\n-\tcase ACCUM_OR_Y_REGS: case PH_REG:\n-\tcase X_OR_PH_REGS: case PL_REG: \n-\tcase PL_OR_ACCUM_LOW_REGS: case X_OR_PL_REGS:\n-\tcase YL_OR_PL_OR_ACCUM_LOW_REGS: case P_REG:\n-\tcase ACCUM_OR_P_REGS: case YL_OR_P_REGS:\n-\tcase ACCUM_LOW_OR_YL_OR_P_REGS: case Y_OR_P_REGS:\n-\tcase ACCUM_Y_OR_P_REGS: case NO_FRAME_Y_ADDR_REGS:\n-\tcase Y_ADDR_REGS: case ACCUM_LOW_OR_Y_ADDR_REGS:\n-\tcase ACCUM_OR_Y_ADDR_REGS: case X_OR_Y_ADDR_REGS:\n-\tcase Y_OR_Y_ADDR_REGS: case P_OR_Y_ADDR_REGS:\n-\tcase NON_HIGH_YBASE_ELIGIBLE_REGS: case YBASE_ELIGIBLE_REGS:\n-\tdefault:\n-\t  return class;\n-\n-\tcase J_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase J_OR_DAU_16_BIT_REGS:\n-\t  return ACCUM_HIGH_REGS;\n-\n-\tcase BMU_REGS: \n-\tcase YBASE_VIRT_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_YBASE_REGS:\n-\t  return ACCUM_LOW_REGS;\n-\n-\tcase ACCUM_OR_YBASE_REGS:\n-\t  return ACCUM_REGS;\n-\n-\tcase X_OR_YBASE_REGS:\n-\t  return X_REG;\n-\n-\tcase Y_OR_YBASE_REGS:\n-\t  return Y_REG;\n-\n-\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-\t  return YL_OR_PL_OR_ACCUM_LOW_REGS; \n-\n-\tcase P_OR_YBASE_REGS:\n-\t  return P_REG;\n-\n-\tcase ACCUM_Y_P_OR_YBASE_REGS:\n-\t  return ACCUM_Y_OR_P_REGS;\n-\n-\tcase Y_ADDR_OR_YBASE_REGS:\n-\t  return Y_ADDR_REGS;\n-\n-\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\n-\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n-\t  return YBASE_ELIGIBLE_REGS;\n-\n-\tcase NO_HIGH_ALL_REGS:\n-\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\n-\tcase ALL_REGS: \n-\t  return YBASE_ELIGIBLE_REGS;\n-\n-\tcase NOHIGH_NON_ADDR_REGS:\n-\t  return ACCUM_LOW_OR_YL_OR_P_REGS;\n-\n-\tcase NON_ADDR_REGS:\n-\t  return ACCUM_Y_OR_P_REGS;\n-\n-\tcase SLOW_MEM_LOAD_REGS:\n-\t  return ACCUM_OR_Y_ADDR_REGS;\n-\n-\tcase NOHIGH_NON_YBASE_REGS:\n-    \t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\n-    \tcase NO_ACCUM_NON_YBASE_REGS:\n-\t  return Y_ADDR_REGS;\n-\n-    \tcase NON_YBASE_REGS:\n-\t  return YBASE_ELIGIBLE_REGS;\n-\t}\n-    }\n-\n-  if (GET_CODE (x) == PLUS)\n-    {\n-      if (GET_MODE (x) == QImode\n-\t  && REG_P (XEXP (x,0))\n-\t  && (XEXP (x,0) == frame_pointer_rtx\n-\t      || XEXP (x,0) == stack_pointer_rtx)\n-\t  && (GET_CODE (XEXP (x,1)) == CONST_INT))\n-\t{\n-\t  if (class == ACCUM_HIGH_REGS)\n-\t    return class;\n-\n-\t  /* If the accumulators are not part of the class\n-\t     being reloaded into, return NO_REGS.  */\n-#if 0\n-\t  if (!reg_class_subset_p (ACCUM_REGS, class))\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-#endif\n-\t  if (reg_class_subset_p (ACCUM_HIGH_REGS, class))\n-\t    return ACCUM_HIGH_REGS;\n-\n-\t  /* We will use accumulator 'a1l' for reloading a\n-\t     PLUS.  We can only use one accumulator because\n-\t     'reload_inqi' only allows one alternative to be\n-\t     used.  */\n-\n-\t  else if (class == ACCUM_LOW_REGS)\n-\t    return A1L_REG;\n-\t  else if (class == A0L_REG)\n-\t    return NO_REGS;\n-\t  else\n-\t    return class;\n-\t}\n-\n-      if (class == NON_YBASE_REGS || class == YBASE_ELIGIBLE_REGS)\n-\treturn Y_ADDR_REGS;\n-      else\n-\treturn class;\n-    }\n-  else if (GET_CODE (x) == MEM)\n-    {\n-      /* We can't copy from a memory location into a\n-\t ybase register.  */\n-      if (reg_class_subset_p(YBASE_VIRT_REGS, class))\n-\t{\n-\t  switch ((int) class)\n-\t    {\n-\t    case YBASE_VIRT_REGS:\n-\t      return (!reload_in_progress ? NO_REGS : class);\n-\n-\t    case ACCUM_LOW_OR_YBASE_REGS:\n-\t      return ACCUM_LOW_REGS;\n-\n-\t    case ACCUM_OR_YBASE_REGS:\n-\t      return ACCUM_REGS;\n-\n-\t    case X_OR_YBASE_REGS:\n-\t      return X_REG;\n-\n-\t    case Y_OR_YBASE_REGS:\n-\t      return Y_REG;\n-\n-\t    case ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-\t      return YL_OR_PL_OR_ACCUM_LOW_REGS;\n-\n-\t    case P_OR_YBASE_REGS:\n-\t      return P_REG;\n-\n-\t    case ACCUM_Y_P_OR_YBASE_REGS:\n-\t      return ACCUM_Y_OR_P_REGS;\n-\n-\t    case Y_ADDR_OR_YBASE_REGS:\n-\t      return Y_ADDR_REGS;\n-\n-\t    case YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-\t      return NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\t  \n-\t    case YBASE_OR_YBASE_ELIGIBLE_REGS:\n-\t      return YBASE_ELIGIBLE_REGS;\n-\n-\t    case NO_HIGH_ALL_REGS:\n-\t      return NOHIGH_NON_YBASE_REGS;\n-\n-\t    case ALL_REGS:\n-\t      return NON_YBASE_REGS;\n-\n-\t    default:\n-\t      return class;\n-\t    }\n-\t}\n-      else\n-\treturn class;\n-    }\n-  else\n-    return class;\n-}\n-\t\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx in;\n-{\n-  int regno = -1;\n-\n-  if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n-    regno = true_regnum (in);\n-\n-  /* If we are reloading a plus into a high accumulator register,\n-     we need a scratch low accumulator, because the low half gets\n-     clobbered.  */\n-\n-  if (class == ACCUM_HIGH_REGS \n-      || class == A1H_REG\n-      || class == A0H_REG)\n-    {\n-      if (GET_CODE (in) == PLUS && mode == QImode)\n-\treturn ACCUM_LOW_REGS;\n-    }\n-\n-  if (class == ACCUM_HIGH_REGS \n-      || class == ACCUM_LOW_REGS\n-      || class == A1L_REG\n-      || class == A0L_REG\n-      || class == A1H_REG\n-      || class == A0H_REG)\n-    {\n-      if (GET_CODE (in) == PLUS && mode == QImode)\n-\t{\n-\t  rtx addr0 = XEXP (in, 0);\n-\t  rtx addr1 = XEXP (in, 1);\n-\t  \n-\t  /* If we are reloading a plus (reg:QI) (reg:QI)\n-\t     we need an additional register.  */ \n-\t  if (REG_P (addr0) && REG_P (addr1))\n-\t    return NO_REGS;\n-\t}\n-    }\n-\n-  /* We can place anything into ACCUM_REGS and can put ACCUM_REGS\n-     into anything.  */\n-\n-  if ((class == ACCUM_REGS || class == ACCUM_HIGH_REGS ||\n-       class == ACCUM_LOW_REGS || class == A0H_REG || class == A0L_REG ||\n-       class == A1H_REG || class == A1_REG) || \n-      (regno >= REG_A0 && regno < REG_A1L + 1))\n-    return NO_REGS;\n-\n-  if (class == ACCUM_OR_YBASE_REGS && REG_P(in)\n-      && IS_YBASE_ELIGIBLE_REG(regno))\n-    {\n-      return NO_REGS;\n-    }\n-\n-  /* We can copy the ybase registers into:\n-     r0-r3, a0-a1, y, p, & x or the union of\n-     any of these.  */\n-\n-  if (!TARGET_RESERVE_YBASE && IS_YBASE_REGISTER_WINDOW(regno))\n-    {\n-      switch ((int) class)\n-\t{\n-\tcase (int) X_REG:\n-\tcase (int) X_OR_ACCUM_LOW_REGS:\n-\tcase (int) X_OR_ACCUM_REGS:\n-\tcase (int) YH_REG:\n-\tcase (int) YH_OR_ACCUM_HIGH_REGS:\n-\tcase (int) X_OR_YH_REGS:\n-\tcase (int) YL_REG:\n-\tcase (int) YL_OR_ACCUM_LOW_REGS:\n-\tcase (int) X_OR_Y_REGS:\n-\tcase (int) X_OR_YL_REGS:\n-\tcase (int) Y_REG:\n-\tcase (int) ACCUM_OR_Y_REGS:\n-\tcase (int) PH_REG:\n-\tcase (int) X_OR_PH_REGS:\n-\tcase (int) PL_REG:\n-\tcase (int) PL_OR_ACCUM_LOW_REGS:\n-\tcase (int) X_OR_PL_REGS:\n-\tcase (int) YL_OR_PL_OR_ACCUM_LOW_REGS:\n-\tcase (int) P_REG:\n-\tcase (int) ACCUM_OR_P_REGS:\n-\tcase (int) YL_OR_P_REGS:\n-\tcase (int) ACCUM_LOW_OR_YL_OR_P_REGS:\n-\tcase (int) Y_OR_P_REGS:\n-\tcase (int) ACCUM_Y_OR_P_REGS:\n-\tcase (int) Y_ADDR_REGS:\n-\tcase (int) ACCUM_LOW_OR_Y_ADDR_REGS:\n-\tcase (int) ACCUM_OR_Y_ADDR_REGS:\n-\tcase (int) X_OR_Y_ADDR_REGS:\n-\tcase (int) Y_OR_Y_ADDR_REGS:\n-\tcase (int) P_OR_Y_ADDR_REGS:\n-\tcase (int) YBASE_ELIGIBLE_REGS:\n-\t  return NO_REGS;\n-\n-\tdefault:\n-\t  return ACCUM_HIGH_REGS;\n-\t}\n-    }\n-\n-  /* We can copy r0-r3, a0-a1, y, & p\n-     directly to the ybase registers. In addition\n-     we can use any of the ybase virtual registers\n-     as the secondary reload registers when copying\n-     between any of these registers.  */\n-\n-  if (!TARGET_RESERVE_YBASE && regno != -1)\n-    {\n-      switch (regno)\n-\t{\n-\tcase REG_A0:\n-\tcase REG_A0L:\n-\tcase REG_A1:\n-\tcase REG_A1L:\n-\tcase REG_X:\n-\tcase REG_Y:\n-\tcase REG_YL:\n-\tcase REG_PROD:\n-\tcase REG_PRODL:\n-\tcase REG_R0:\n-\tcase REG_R1:\n-\tcase REG_R2:\n-\tcase REG_R3:\n-\t  if (class == YBASE_VIRT_REGS)\n-\t    return NO_REGS;\n-\t  else\n-\t    {\n-\t      switch ((int) class)\n-\t\t{\n-\t\tcase (int) X_REG:\n-\t\tcase (int) X_OR_ACCUM_LOW_REGS:\n-\t\tcase (int) X_OR_ACCUM_REGS:\n-\t\tcase (int) YH_REG:\n-\t\tcase (int) YH_OR_ACCUM_HIGH_REGS:\n-\t\tcase (int) X_OR_YH_REGS:\n-\t\tcase (int) YL_REG:\n-\t\tcase (int) YL_OR_ACCUM_LOW_REGS:\n-\t\tcase (int) X_OR_Y_REGS:\n-\t\tcase (int) X_OR_YL_REGS:\n-\t\tcase (int) Y_REG:\n-\t\tcase (int) ACCUM_OR_Y_REGS:\n-\t\tcase (int) PH_REG:\n-\t\tcase (int) X_OR_PH_REGS:\n-\t\tcase (int) PL_REG:\n-\t\tcase (int) PL_OR_ACCUM_LOW_REGS:\n-\t\tcase (int) X_OR_PL_REGS:\n-\t\tcase (int) YL_OR_PL_OR_ACCUM_LOW_REGS:\n-\t\tcase (int) P_REG:\n-\t\tcase (int) ACCUM_OR_P_REGS:\n-\t\tcase (int) YL_OR_P_REGS:\n-\t\tcase (int) ACCUM_LOW_OR_YL_OR_P_REGS:\n-\t\tcase (int) Y_OR_P_REGS:\n-\t\tcase (int) ACCUM_Y_OR_P_REGS:\n-\t\tcase (int) Y_ADDR_REGS:\n-\t\tcase (int) ACCUM_LOW_OR_Y_ADDR_REGS:\n-\t\tcase (int) ACCUM_OR_Y_ADDR_REGS:\n-\t\tcase (int) X_OR_Y_ADDR_REGS:\n-\t\tcase (int) Y_OR_Y_ADDR_REGS:\n-\t\tcase (int) P_OR_Y_ADDR_REGS:\n-\t\tcase (int) YBASE_ELIGIBLE_REGS:\n-\t\t  return YBASE_VIRT_REGS;\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Memory or constants can be moved from or to any register\n-     except the ybase virtual registers.  */\n-  if (regno == -1 && GET_CODE(in) != PLUS)\n-    {\n-      if (class == YBASE_VIRT_REGS)\n-\treturn NON_YBASE_REGS;\n-      else\n-        return NO_REGS;\n-    }\n-\n-  if (GET_CODE (in) == PLUS && mode == QImode)\n-    {\n-      rtx addr0 = XEXP (in, 0);\n-      rtx addr1 = XEXP (in, 1);\n-\n-      /* If we are reloading a plus (reg:QI) (reg:QI)\n-\t we need a low accumulator, not a high one.  */\n-      if (REG_P (addr0) && REG_P (addr1))\n-\treturn ACCUM_LOW_REGS;\n-    }\n-\n-#if 0\n-  if (REG_P(in))\n-    return ACCUM_REGS;\n-#endif\n-\n-  /* Otherwise, we need a high accumulator(s).  */\n-  return ACCUM_HIGH_REGS;\n-}\n-\n-int\n-symbolic_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (symbolic_address_p (op));\n-}\n-\n-int\n-symbolic_address_p (op)\n-     rtx op;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n-              && INTVAL (XEXP (op,1)) < 0x20);\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* For a Y address space operand we allow only *rn, *rn++, *rn--.\n-   This routine only recognizes *rn, the '<>' constraints recognize\n-   (*rn++), and (*rn--).  */\n-\n-int\n-Y_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (memory_address_p (mode, op) && !symbolic_address_p (op));\n-}\t     \n-\n-int\n-sp_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-    return (GET_CODE (op) == PLUS\n-\t    && (XEXP (op, 0) == stack_pointer_rtx\n-\t\t|| XEXP (op, 0) == frame_pointer_rtx)\n-\t    && GET_CODE (XEXP (op,1)) == CONST_INT);\n-}\n-\n-int\n-sp_operand2 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if ((GET_CODE (op) == PLUS \n-       && (XEXP (op, 0) == stack_pointer_rtx\n-\t   || XEXP (op, 0) == frame_pointer_rtx)\n-       && (REG_P (XEXP (op,1))\n-\t   && IS_ADDRESS_REGISTER (REGNO (XEXP(op, 1))))))\n-    return 1;\n-  else if ((GET_CODE (op) == PLUS\n-       && (XEXP (op, 1) == stack_pointer_rtx\n-\t   || XEXP (op, 1) == frame_pointer_rtx)\n-       && (REG_P (XEXP (op,0))\n-\t   && IS_ADDRESS_REGISTER (REGNO (XEXP(op, 1))))))\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-int\n-nonmemory_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (immediate_operand (op, mode) || arith_reg_operand (op, mode));\n-}\n-\n-int\n-arith_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode)\n-\t  && (GET_CODE (op) != REG\n-\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || (!(IS_YBASE_REGISTER_WINDOW (REGNO (op)))\n-\t\t  && REGNO (op) != FRAME_POINTER_REGNUM)));\n-}\n-\n-int\n-call_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-    if (symbolic_address_p (op) || REG_P(op))\n-    {\n-\treturn 1;\n-    }\n-\n-    return 0;\n-}\n-\n-int\n-dsp16xx_comparison_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && GET_RTX_CLASS (GET_CODE (op)) == '<'\n-\t  && (GET_CODE(op) != GE && GET_CODE (op) != LT &&\n-\t      GET_CODE (op) != GEU && GET_CODE (op) != LTU));\n-}\n-\n-void\n-notice_update_cc(exp)\n-     rtx exp;\n-{\n-    if (GET_CODE (exp) == SET)\n-    {\n-\t/* Jumps do not alter the cc's.  */\n-\n-\tif (SET_DEST (exp) == pc_rtx)\n-\t    return;\n-\n-\t/* Moving register or memory into a register:\n-\t   it doesn't alter the cc's, but it might invalidate\n-\t   the RTX's which we remember the cc's came from.\n-\t   (Note that moving a constant 0 or 1 MAY set the cc's).  */\n-\tif (REG_P (SET_DEST (exp))\n-\t    && (REG_P (SET_SRC (exp)) || GET_CODE (SET_SRC (exp)) == MEM))\n-\t{\n-\t    if (cc_status.value1\n-\t\t&& reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1))\n-\t\tcc_status.value1 = 0;\n-\t    if (cc_status.value2\n-\t\t&& reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2))\n-\t\tcc_status.value2 = 0;\n-\t    return;\n-\t}\n-\t/* Moving register into memory doesn't alter the cc's.\n-\t   It may invalidate the RTX's which we remember the cc's came from.  */\n-\tif (GET_CODE (SET_DEST (exp)) == MEM && REG_P (SET_SRC (exp)))\n-\t{\n-\t    if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM)\n-\t\tcc_status.value1 = 0;\n-\t    if (cc_status.value2 && GET_CODE (cc_status.value2) == MEM)\n-\t\tcc_status.value2 = 0;\n-\t    return;\n-\t}\n-\t/* Function calls clobber the cc's.  */\n-\telse if (GET_CODE (SET_SRC (exp)) == CALL)\n-\t{\n-\t    CC_STATUS_INIT;\n-\t    return;\n-\t}\n-\t/* Tests and compares set the cc's in predictable ways.  */\n-\telse if (SET_DEST (exp) == cc0_rtx)\n-\t{\n-\t    CC_STATUS_INIT;\n-\t    cc_status.value1 = SET_SRC (exp);\n-\t    return;\n-\t}\n-\t/* Certain instructions effect the condition codes.  */\n-\telse if (GET_MODE_CLASS (GET_MODE (SET_SRC (exp))) == MODE_INT)\n-\t    switch (GET_CODE (SET_SRC (exp)))\n-\t    {\n-\t    case PLUS: \n-\t    case MINUS:\n-\t      if (REG_P (SET_DEST (exp)))\n-\t\t{\n-\t\t  /* Address registers don't set the condition codes.  */\n-\t\t  if (IS_ADDRESS_REGISTER (REGNO (SET_DEST (exp))))\n-\t\t    {\n-\t\t      CC_STATUS_INIT;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    case ASHIFTRT: \n-\t    case LSHIFTRT:\n-\t    case ASHIFT: \n-\t    case AND: \n-\t    case IOR: \n-\t    case XOR:\n-\t    case MULT:\n-\t    case NEG:\n-\t    case NOT:\n-\t      cc_status.value1 = SET_SRC (exp);\n-\t      cc_status.value2 = SET_DEST (exp);\n-\t      break;\n-\t      \n-\t    default:\n-\t      CC_STATUS_INIT;\n-\t    }\n-\telse\n-\t{\n-\t    CC_STATUS_INIT;\n-\t}\n-    }\n-    else if (GET_CODE (exp) == PARALLEL\n-\t     && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n-    {\n-\tif (SET_DEST (XVECEXP (exp, 0, 0)) == pc_rtx)\n-\t    return;\n-\n-\tif (SET_DEST (XVECEXP (exp, 0, 0)) == cc0_rtx)\n-\t{\n-\t    CC_STATUS_INIT;\n-\t    cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n-\t    return;\n-\t}\n-\n-\tCC_STATUS_INIT;\n-    }\n-    else\n-    {\n-\tCC_STATUS_INIT;\n-    }\n-}\n-\n-int\n-dsp16xx_makes_calls ()\n-{\n-  rtx insn;\n-\n-  for (insn = get_insns (); insn; insn = next_insn (insn))\n-    if (GET_CODE (insn) == CALL_INSN)\n-      return (1);\n-\n-  return 0;\n-}\n-\n-long\n-compute_frame_size (size)\n-     int size;\n-{\n-  long total_size;\n-  long var_size;\n-  long args_size;\n-  long extra_size;\n-  long reg_size;\n-\n-  /* This value is needed to compute reg_size.  */\n-  current_frame_info.function_makes_calls = !leaf_function_p ();\n-\n-  reg_size = 0;\n-  extra_size = 0;\n-  var_size = size;\n-  args_size = current_function_outgoing_args_size;\n-  reg_size = reg_save_size ();  \n-\n-  total_size = var_size + args_size + extra_size + reg_size;\n-\n-\n-  /* Save other computed information.  */\n-  current_frame_info.total_size  = total_size;\n-  current_frame_info.var_size    = var_size;\n-  current_frame_info.args_size   = args_size;\n-  current_frame_info.extra_size  = extra_size;\n-  current_frame_info.reg_size    = reg_size;\n-  current_frame_info.initialized = reload_completed;\n-  current_frame_info.reg_size\t = reg_size / UNITS_PER_WORD;\n-\n-  if (reg_size)\n-    {\n-      unsigned long offset = args_size + var_size + reg_size;\n-      current_frame_info.sp_save_offset = offset;\n-      current_frame_info.fp_save_offset = offset - total_size;\n-    }\n-\n-  return total_size;\n-}\n-\n-int\n-dsp16xx_call_saved_register (regno)\n-     int regno;\n-{\n-#if 0\n-  if (regno == REG_PR && current_frame_info.function_makes_calls)\n-    return 1;\n-#endif\n-  return (regs_ever_live[regno] && !call_used_regs[regno] &&\n-\t  !IS_YBASE_REGISTER_WINDOW(regno));\n-}\n-\n-int\n-ybase_regs_ever_used ()\n-{\n-  int regno;\n-  int live = 0;\n-\n-  for (regno = REG_YBASE0; regno <= REG_YBASE31; regno++)\n-    if (regs_ever_live[regno])\n-      {\n-\tlive = 1;\n-\tbreak;\n-      }\n-\n-  return live;\n-}\n-\n-static void \n-dsp16xx_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  int regno;\n-  long total_size;\n-  fp = reg_names[FRAME_POINTER_REGNUM];\n-  sp = reg_names[STACK_POINTER_REGNUM];\n-  rr = reg_names[RETURN_ADDRESS_REGNUM];   /* return address register */\n-  a1h = reg_names[REG_A1];\n-  \n-  total_size = compute_frame_size (size);\n-  \n-  fprintf (file, \"\\t/* FUNCTION PROLOGUE: */\\n\");\n-  fprintf (file, \"\\t/* total=%ld, vars= %ld, regs= %d, args=%d, extra= %ld */\\n\",\n-\t   current_frame_info.total_size,\n-\t   current_frame_info.var_size,\n-\t   current_frame_info.reg_size,\n-\t   current_function_outgoing_args_size,\n-\t   current_frame_info.extra_size);\n-  \n-  fprintf (file, \"\\t/* fp save offset= %ld, sp save_offset= %ld */\\n\\n\",\n-\t   current_frame_info.fp_save_offset,\n-\t   current_frame_info.sp_save_offset);\n-  /* Set up the 'ybase' register window.  */\n-  \n-  if (ybase_regs_ever_used())\n-    {\n-      fprintf (file, \"\\t%s=%s\\n\", a1h, reg_names[REG_YBASE]);\n-      if (TARGET_YBASE_HIGH)\n-\tfprintf (file, \"\\t%s=%sh-32\\n\", reg_names[REG_A1], a1h);\n-      else\n-\tfprintf (file, \"\\t%s=%sh+32\\n\", reg_names[REG_A1], a1h);\n-      fprintf (file, \"\\t%s=%s\\n\", reg_names[REG_YBASE], a1h);\n-    }\n-  \n-  if (current_frame_info.var_size)\n-    {\n-      if (current_frame_info.var_size == 1)\n-\tfprintf (file, \"\\t*%s++\\n\", sp);\n-      else\n-        {\n-\t  if (SMALL_INTVAL(current_frame_info.var_size) && ((current_frame_info.var_size & 0x8000) == 0))\n-\t    fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", reg_names[REG_J], current_frame_info.var_size, sp, reg_names[REG_J]);\n-\t  else\n-\t    fatal_error (\"stack size > 32k\");\n-\t}\n-    }\n-  \n-  /* Save any registers this function uses, unless they are\n-     used in a call, in which case we don't need to.  */\n-  \n-  for(regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno)\n-    if (dsp16xx_call_saved_register (regno)) \n-      {\n-\tfprintf (file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno]);\n-      }\n-\n-  /* For debugging purposes, we want the return address to be at a predictable\n-     location.  */\n-  if (current_frame_info.function_makes_calls)\n-    fprintf (file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[RETURN_ADDRESS_REGNUM]);\n-\n-  if (current_frame_info.args_size)\n-    {\n-      if (current_frame_info.args_size == 1)\n-\tfprintf (file, \"\\t*%s++\\n\", sp);\n-      else\n-\terror (\"stack size > 32k\");\n-    }\n-   \n-  if (frame_pointer_needed)\n-    {\n-      fprintf (file, \"\\t%s=%s\\n\", a1h, sp);\n-      fprintf (file, \"\\t%s=%s\\n\", fp, a1h);  /* Establish new base frame */\n-      fprintf (file, \"\\t%s=%ld\\n\", reg_names[REG_J], -total_size);\n-      fprintf (file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n-    }\n-  \n-  fprintf (file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\");\n-}\n-\n-void\n-init_emulation_routines ()\n-{\n- dsp16xx_addhf3_libcall = (rtx) 0;\n- dsp16xx_subhf3_libcall = (rtx) 0;\n- dsp16xx_mulhf3_libcall = (rtx) 0;\n- dsp16xx_divhf3_libcall = (rtx) 0;\n- dsp16xx_cmphf3_libcall = (rtx) 0;\n- dsp16xx_fixhfhi2_libcall = (rtx) 0;\n- dsp16xx_floathihf2_libcall = (rtx) 0;\n- dsp16xx_neghf2_libcall = (rtx) 0;\n-\n- dsp16xx_mulhi3_libcall = (rtx) 0;\n- dsp16xx_udivqi3_libcall = (rtx) 0;\n- dsp16xx_udivhi3_libcall = (rtx) 0;\n- dsp16xx_divqi3_libcall = (rtx) 0;\n- dsp16xx_divhi3_libcall = (rtx) 0;\n- dsp16xx_modqi3_libcall = (rtx) 0;\n- dsp16xx_modhi3_libcall = (rtx) 0;\n- dsp16xx_umodqi3_libcall = (rtx) 0;\n- dsp16xx_umodhi3_libcall = (rtx) 0;\n- dsp16xx_ashrhi3_libcall = (rtx) 0;\n- dsp16xx_ashlhi3_libcall = (rtx) 0;\n- dsp16xx_ucmphi2_libcall = (rtx) 0;\n- dsp16xx_lshrhi3_libcall = (rtx) 0;\n-\n-}\n-static void\n-dsp16xx_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-{\n-  int regno;\n-  \n-  fp = reg_names[FRAME_POINTER_REGNUM];\n-  sp = reg_names[STACK_POINTER_REGNUM];\n-  rr = reg_names[RETURN_ADDRESS_REGNUM];   /* return address register */\n-  a1h = reg_names[REG_A1];\n-  \n-  fprintf (file, \"\\n\\t/* FUNCTION EPILOGUE: */\\n\");\n-  \n-  if (current_frame_info.args_size)\n-    {\n-      if (current_frame_info.args_size == 1)\n-\tfprintf (file, \"\\t*%s--\\n\", sp);\n-      else\n-\t{\n-\t  fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", \n-\t\t   reg_names[REG_J], -current_frame_info.args_size, sp, reg_names[REG_J]);\n-\t}\n-    }\n-  \n-  if (ybase_regs_ever_used())\n-    {\n-      fprintf (file, \"\\t%s=%s\\n\", a1h, reg_names[REG_YBASE]);\n-      if (TARGET_YBASE_HIGH)\n-\tfprintf (file, \"\\t%s=%sh+32\\n\", reg_names[REG_A1], a1h);\n-      else\n-\tfprintf (file, \"\\t%s=%sh-32\\n\", reg_names[REG_A1], a1h);\n-      fprintf (file, \"\\t%s=%s\\n\", reg_names[REG_YBASE], a1h);\n-    }\n-\n-  if (current_frame_info.function_makes_calls)\n-    fprintf (file, \"\\t%s=pop(*%s)\\n\", reg_names[RETURN_ADDRESS_REGNUM], sp);\n-  \n-  for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; --regno)\n-    if (dsp16xx_call_saved_register(regno))\n-      {\n-\tfprintf (file, \"\\t%s=pop(*%s)\\n\", reg_names[regno], sp);\n-      }\n-  \n-  if (current_frame_info.var_size)\n-    {\n-      if (current_frame_info.var_size == 1)\n-\tfprintf (file, \"\\t*%s--\\n\", sp);\n-      else\n-\t{\n-\t  fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", \n-\t\t   reg_names[REG_J], -current_frame_info.var_size, sp, reg_names[REG_J]);\n-\t}\n-    }\n-  \n-  fprintf (file, \"\\treturn\\n\");\n-  /* Reset the frame info for the next function.  */\n-  current_frame_info = zero_frame_info;\n-  init_emulation_routines ();\n-}\n-\n-/* Emit insns to move operands[1] into operands[0].\n-\n-   Return 1 if we have written out everything that needs to be done to\n-   do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally.  */\n-\n-int\n-emit_move_sequence (operands, mode)\n-     rtx *operands;\n-     enum machine_mode mode;\n-{\n-  register rtx operand0 = operands[0];\n-  register rtx operand1 = operands[1];\n-\n-  /* We can only store registers to memory.  */\n-\n-  if (GET_CODE (operand0) == MEM && GET_CODE (operand1) != REG)\n-    operands[1] = force_reg (mode, operand1);\n-\n-  return 0;\n-}\n-\n-void\n-double_reg_from_memory (operands)\n-     rtx operands[];\n-{\n-    rtx xoperands[4];\n-\n-    if (GET_CODE(XEXP(operands[1],0)) == POST_INC)\n-    {\n-\toutput_asm_insn (\"%u0=%1\", operands);\n-\toutput_asm_insn (\"%w0=%1\", operands);\n-    }\n-    else if (GET_CODE(XEXP(operands[1],0)) == POST_DEC)\n-    {\n-\txoperands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\txoperands[0] = operands[0];\n-\t\n-\t/* We can't use j anymore since the compiler can allocate it.  */\n-/*\toutput_asm_insn (\"j=-3\\n\\t%u0=*%1++\\n\\t%w0=*%1++j\", xoperands); */\n-\toutput_asm_insn (\"%u0=*%1++\\n\\t%w0=*%1--\\n\\t*%1--\\n\\t*%1--\", xoperands);\n-    }\n-    else if (GET_CODE(XEXP(operands[1],0)) == PLUS)\n-    {\n-      rtx addr;\n-      int offset = 0;\n-\n-      output_asm_insn (\"%u0=%1\", operands);\n-\n-\n-      /* In order to print out the least significant word we must\n-\t use 'offset + 1'.  */\n-      addr = XEXP (operands[1], 0);\n-      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,0)) + 1;\n-      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,1)) + 1;\n-\n-      fprintf (asm_out_file, \"\\t%s=*(%d)\\n\", reg_names[REGNO(operands[0]) + 1], offset + 31);\n-    }\n-    else\n-    {\n-\txoperands[1] = XEXP(operands[1],0);\n-\txoperands[0] = operands[0];\n-\n-\toutput_asm_insn (\"%u0=*%1++\\n\\t%w0=*%1--\", xoperands);\n-    }\n-}\n-\n-\n-void\n-double_reg_to_memory (operands)\n-     rtx operands[];\n-{\n-    rtx xoperands[4];\n-\n-    if (GET_CODE(XEXP(operands[0],0)) == POST_INC)\n-    {\n-\toutput_asm_insn (\"%0=%u1\", operands);\n-\toutput_asm_insn (\"%0=%w1\", operands);\n-    }\n-    else if (GET_CODE(XEXP(operands[0],0)) == POST_DEC)\n-    {\n-\txoperands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\txoperands[1] = operands[1];\n-\t\n-\t/* We can't use j anymore since the compiler can allocate it.  */\n-\n-/*\toutput_asm_insn (\"j=-3\\n\\t*%0++=%u1\\n\\t*%0++j=%w1\", xoperands); */\n-\toutput_asm_insn (\"*%0++=%u1\\n\\t*%0--=%w1\\n\\t*%0--\\n\\t*%0--\", xoperands);\n-\n-    }\n-    else if (GET_CODE(XEXP(operands[0],0)) == PLUS)\n-    {\n-      rtx addr;\n-      int offset = 0;\n-\n-      output_asm_insn (\"%0=%u1\", operands);\n-\n-      /* In order to print out the least significant word we must\n-\t use 'offset + 1'.  */\n-      addr = XEXP (operands[0], 0);\n-      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,0)) + 1;\n-      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,1)) + 1;\n-      else\n-\tfatal_error (\"invalid addressing mode\");\n-\n-      fprintf (asm_out_file, \"\\t*(%d)=%s\\n\", offset + 31, reg_names[REGNO(operands[1]) + 1]);\n-    }\n-    else\n-    {\n-\txoperands[0] = XEXP(operands[0],0);\n-\txoperands[1] = operands[1];\n-\n-\toutput_asm_insn (\"*%0++=%u1\\n\\t*%0--=%w1\", xoperands);\n-    }\n-}\n-\n-void\n-override_options ()\n-{\n-  if (chip_name == (char *) 0)\n-    chip_name = DEFAULT_CHIP_NAME;\n-\n-  if (text_seg_name == (char *) 0)\n-    text_seg_name = DEFAULT_TEXT_SEG_NAME;\n-  \n-  if (data_seg_name == (char *) 0)\n-    data_seg_name = DEFAULT_DATA_SEG_NAME;\n-  \n-  if (bss_seg_name == (char *) 0)\n-    bss_seg_name = DEFAULT_BSS_SEG_NAME;\n-  \n-  if (const_seg_name == (char *) 0)\n-    const_seg_name = DEFAULT_CONST_SEG_NAME;\n-  \n-  save_chip_name = xstrdup (chip_name);\n-\n-  rsect_text = concat (\".rsect \\\"\", text_seg_name, \"\\\"\", NULL);\n-  rsect_data = concat (\".rsect \\\"\", data_seg_name, \"\\\"\", NULL);\n-  rsect_bss = concat (\".rsect \\\"\", bss_seg_name, \"\\\"\", NULL);\n-  rsect_const = concat (\".rsect \\\"\", const_seg_name, \"\\\"\", NULL);\n-}\n-\n-int\n-next_cc_user_unsigned (insn)\n-     rtx insn;\n-{\n-  switch (next_cc_user_code (insn))\n-    {\n-    case GTU:\n-    case GEU:\n-    case LTU:\n-    case LEU:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-enum rtx_code\n-next_cc_user_code (insn)\n-     rtx insn;\n-{\n-  /* If no insn could be found we assume that the jump has been\n-     deleted and the compare will be deleted later.  */\n-\n-  if (!(insn = next_cc0_user (insn)))\n-    return (enum rtx_code) 0;\n-  else if (GET_CODE (insn) == JUMP_INSN\n-\t   && GET_CODE (PATTERN (insn)) == SET\n-\t   && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n-    return GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 0));\n-  else if (GET_CODE (insn) == INSN\n-\t   && GET_CODE (PATTERN (insn)) == SET\n-\t   && comparison_operator (SET_SRC (PATTERN (insn)), VOIDmode))\n-    return GET_CODE (SET_SRC (PATTERN (insn)));\n-  else\n-    abort ();\n-}\n-\n-void\n-print_operand(file, op, letter)\n-     FILE *file;\n-     rtx op;\n-     int letter;\n-{\n-    enum rtx_code code;\n-\n-    code = GET_CODE(op);\n-\n-    switch (letter)\n-    {\n-       case 'I':\n-\t  code = reverse_condition (code);\n-\t  /* Fallthrough */\n-\n-       case 'C':\n-          if (code == EQ) \n-          { \n-\t      fputs (\"eq\", file); \n-\t      return; \n-\t  }\n-          else if (code == NE)  \n-\t  { \n-\t      fputs (\"ne\", file); \n-\t      return; \n-\t  }\n-          else if (code == GT || code == GTU)  \n-\t  { \n-\t      fputs (\"gt\", file); \n-\t      return; \n-\t  }\n-          else if (code == LT || code == LTU)  \n-\t  { \n-\t      fputs (\"mi\", file); \n-\t      return; \n-\t  }\n-          else if (code == GE || code == GEU)  \n-\t  {\n-\t      fputs (\"pl\", file); \n-\t      return; \n-\t  }\n-          else if (code == LE || code == LEU)  \n-\t  { \n-\t      fputs (\"le\", file); \n-\t      return; \n-\t  }\n-          else \n-\t      abort ();\n-\t  break;\n-\n-       default:\n-          break;  \n-    }\n-\n-    if (code == REG)\n-    {\n-\t/* Print the low half of a 32-bit register pair.  */\n-        if (letter == 'w')\n-           fprintf (file, \"%s\", reg_names[REGNO (op) + 1]);\n-        else if (letter == 'u' || !letter)\n-           fprintf (file, \"%s\", reg_names[REGNO (op)]);\n-\telse if (letter == 'b')\n-\t    fprintf (file, \"%sh\", reg_names[REGNO (op)]);\n-\telse if (letter == 'm')\n-\t  fprintf (file, \"%s\", himode_reg_name[REGNO (op)]);\n-        else\n-\t  output_operand_lossage (\"bad register extension code\");\n-    }\n-    else if (code == MEM)\n-      output_address (XEXP(op,0));\n-    else if (code == CONST_INT)\n-      { \n-\tHOST_WIDE_INT val = INTVAL (op);\n-\n-        if (letter == 'H')\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, val & 0xffff);\n-\telse if (letter == 'h')\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n-        else if (letter == 'U')\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n-        else\n-           output_addr_const(file, op);\n-      }\n-    else if (code == CONST_DOUBLE && GET_MODE(op) != DImode)\n-      {\n-\tlong l;\n-\tREAL_VALUE_TYPE r;\n-\tREAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-\tREAL_VALUE_TO_TARGET_SINGLE (r, l);\n-\tfprintf (file, \"0x%lx\", l);\n-      }\n-    else if (code == CONST)\n-      {\n-\trtx addr = XEXP (op, 0);\n-\t\n-\tif (GET_CODE (addr) != PLUS)\n-\t  {\n-\t    output_addr_const(file, op);\n-\t    return;\n-\t  }\n-\t\n-\tif ((GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n-\t     || GET_CODE (XEXP (addr, 0)) == LABEL_REF)\n-\t    && (GET_CODE (XEXP (addr, 1)) == CONST_INT))\n-\t  {\n-\t    int n = INTVAL (XEXP(addr, 1));\n-\t    output_addr_const (file, XEXP (addr, 0));\n-\t    \n-\t    if (n >= 0)\n-\t      fprintf (file, \"+\");\n-\t    \n-\t    n = (int) (short) n;\n-\t    fprintf (file, \"%d\", n);\n-\t  }\n-\telse if ((GET_CODE (XEXP (addr, 1)) == SYMBOL_REF\n-\t\t  || GET_CODE (XEXP (addr, 1)) == LABEL_REF)\n-\t\t && (GET_CODE (XEXP (addr, 0)) == CONST_INT))\n-\t  {\n-\t    int n = INTVAL (XEXP(addr, 0));\n-\t    output_addr_const (file, XEXP (addr, 1));\n-\t    \n-\t    if (n >= 0)\n-\t      fprintf (file, \"+\");\n-\t    \n-\t    n = (int) (short) n;\n-\t    fprintf (file, \"%d\", n);\n-\t  }\n-\telse\n-\t  output_addr_const(file, op);\n-      }\n-    else\n-      output_addr_const (file, op);\n-}\n-\n-\n-void\n-print_operand_address(file, addr)\n-     FILE *file;\n-     rtx addr;\n-{\n-  rtx base;\n-  int offset = 0;;\n-  \n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      fprintf (file, \"*%s\", reg_names[REGNO (addr)]);\n-      break;\n-    case POST_DEC:\n-      fprintf (file, \"*%s--\", reg_names[REGNO (XEXP (addr, 0))]);\n-      break;\n-    case POST_INC:\n-      fprintf (file, \"*%s++\", reg_names[REGNO (XEXP (addr, 0))]);\n-      break;\n-    case PLUS:\n-      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,0)), base = XEXP(addr,1);\n-      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,1)), base = XEXP(addr,0);\n-      else\n-\tabort();\n-      if (GET_CODE (base) == REG && REGNO(base) == STACK_POINTER_REGNUM)\n-\t{\n-\t  if (offset >= -31 && offset <= 0)\n-\t    offset = 31 + offset;\n-\t  else\n-\t    fatal_error (\"invalid offset in ybase addressing\");\n-\t}\n-      else\n-\tfatal_error (\"invalid register in ybase addressing\");\n-      \n-      fprintf (file, \"*(%d)\", offset);\n-      break;\n-      \n-    default:\n-      if (FITS_5_BITS (addr))\n-\tfprintf (file, \"*(0x%x)\", (int)(INTVAL (addr) & 0x20));\n-      else\n-\toutput_addr_const (file, addr);\n-    }\n-}\n-\n-void\n-output_dsp16xx_float_const (operands)\n-     rtx *operands;\n-{\n-  rtx src = operands[1];\n-  \n-  REAL_VALUE_TYPE d;\n-  long value;\n-  \n-  REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n-  REAL_VALUE_TO_TARGET_SINGLE (d, value);\n-  \n-  operands[1] = GEN_INT (value);\n-  output_asm_insn (\"%u0=%U1\\n\\t%w0=%H1\", operands);\n-}\n-\n-static int\n-reg_save_size ()\n-{\n-  int reg_save_size = 0;\n-  int regno;\n-\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (dsp16xx_call_saved_register (regno))\n-      {\n-\treg_save_size += UNITS_PER_WORD;\n-      }\n-\n-  /* If the function makes calls we will save need to save the 'pr' register.  */\n-  if (current_frame_info.function_makes_calls)\n-    reg_save_size += 1;\n-\n-  return (reg_save_size);\n-}\n-\n-#if 0\n-int\n-dsp16xx_starting_frame_offset()\n-{\n-  int reg_save_size = 0;\n- int regno;\n- \n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (dsp16xx_call_saved_register (regno))\n-      {\n-\treg_save_size += UNITS_PER_WORD;\n-      }\n-\n-  return (reg_save_size);\n-}\n-#endif\n-\n-int\n-initial_frame_pointer_offset()\n-{\n-  int offset = 0;\n-  \n-  offset = compute_frame_size (get_frame_size());\n-\n-#ifdef STACK_GROWS_DOWNWARD\n-  return (offset);\n-#else\n-  return (-offset);\n-#endif\n-}\n-\n-/* Generate the minimum number of 1600 core shift instructions\n-   to shift by 'shift_amount'.  */\n-\n-#if 0\n-void\n-emit_1600_core_shift (shift_op, operands, shift_amount, mode)\n-     enum rtx_code shift_op;\n-     rtx *operands;\n-     int shift_amount;\n-     enum machine_mode mode;\n-{\n-  int quotient;\n-  int i;\n-  int first_shift_emitted = 0;\n-  \n-  while (shift_amount != 0)\n-    {\n-      if (shift_amount/16)\n-\t{\n-\t  quotient = shift_amount/16;\n-\t  shift_amount = shift_amount - (quotient * 16);\n-\t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t    gen_rtx (shift_op, mode, \n-\t\t\t\t\t     first_shift_emitted\n-\t\t\t\t\t     ? operands[0] : operands[1],\n-\t\t\t\t\t     GEN_INT (16))));\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/8)\n-\t{\n-\t  quotient = shift_amount/8;\n-\t  shift_amount = shift_amount - (quotient * 8);\n-\t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t    gen_rtx (shift_op, mode, \n-\t\t\t\t\t     first_shift_emitted\n-\t\t\t\t\t     ? operands[0] : operands[1],\n-\t\t\t\t\t     GEN_INT (8))));\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/4)\n-\t{\n-\t  quotient = shift_amount/4;\n-\t  shift_amount = shift_amount - (quotient * 4);\n-\t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t    gen_rtx (shift_op, mode, \n-\t\t\t\t\t     first_shift_emitted\n-\t\t\t\t\t     ? operands[0] : operands[1],\n-\t\t\t\t\t     GEN_INT (4))));\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/1)\n-\t{\n-\t  quotient = shift_amount/1;\n-\t  shift_amount = shift_amount - (quotient * 1);\n-\t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t    gen_rtx (shift_op, mode, \n-\t\t\t\t\t     first_shift_emitted\n-\t\t\t\t\t     ? operands[0] : operands[1],\n-\t\t\t\t\t     GEN_INT (1))));\n-\t  first_shift_emitted = 1;\n-\t}\n-    }\n-}\n-#else\n-void\n-emit_1600_core_shift (shift_op, operands, shift_amount)\n-     enum rtx_code shift_op;\n-     rtx *operands;\n-     int shift_amount;\n-{\n-  int quotient;\n-  int i;\n-  int first_shift_emitted = 0;\n-  const char * const *shift_asm_ptr;\n-  const char * const *shift_asm_ptr_first;\n-\n-  if (shift_op == ASHIFT)\n-    {\n-      shift_asm_ptr = ashift_left_asm;\n-      shift_asm_ptr_first = ashift_left_asm_first;\n-    }\n-  else if (shift_op == ASHIFTRT)\n-    {\n-      shift_asm_ptr = ashift_right_asm;\n-      shift_asm_ptr_first = ashift_right_asm_first;\n-    }\n-  else if (shift_op == LSHIFTRT)\n-    {\n-      shift_asm_ptr = lshift_right_asm;\n-      shift_asm_ptr_first = lshift_right_asm_first;\n-    }\n-  else\n-    fatal_error (\"invalid shift operator in emit_1600_core_shift\");\n-\n-  while (shift_amount != 0)\n-    {\n-      if (shift_amount/16)\n-\t{\n-\t  quotient = shift_amount/16;\n-\t  shift_amount = shift_amount - (quotient * 16);\n-\t  for (i = 0; i < quotient; i++)\n-\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_16]\n-\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_16]), operands);\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/8)\n-\t{\n-\t  quotient = shift_amount/8;\n-\t  shift_amount = shift_amount - (quotient * 8);\n-\t  for (i = 0; i < quotient; i++)\n-\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_8]\n-\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_8]), operands);\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/4)\n-\t{\n-\t  quotient = shift_amount/4;\n-\t  shift_amount = shift_amount - (quotient * 4);\n-\t  for (i = 0; i < quotient; i++)\n-\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_4]\n-\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_4]), operands);\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/1)\n-\t{\n-\t  quotient = shift_amount/1;\n-\t  shift_amount = shift_amount - (quotient * 1);\n-\t  for (i = 0; i < quotient; i++)\n-\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_1]\n-\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_1]), operands);\n-\t  first_shift_emitted = 1;\n-\t}\n-    }\n-}\n-#endif\n-\n-int\n-num_1600_core_shifts (shift_amount)\n-int shift_amount;\n-{\n-  int quotient;\n-  int i;\n-  int first_shift_emitted = 0;\n-  int num_shifts = 0;\n-\n-  while (shift_amount != 0)\n-    {\n-      if (shift_amount/16)\n-\t{\n-\t  quotient = shift_amount/16;\n-\t  shift_amount = shift_amount - (quotient * 16);\n-\t  for (i = 0; i < quotient; i++)\n-\t    num_shifts++;\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/8)\n-\t{\n-\t  quotient = shift_amount/8;\n-\t  shift_amount = shift_amount - (quotient * 8);\n-\t  for (i = 0; i < quotient; i++)\n-\t    num_shifts++;\n-\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/4)\n-\t{\n-\t  quotient = shift_amount/4;\n-\t  shift_amount = shift_amount - (quotient * 4);\n-\t  for (i = 0; i < quotient; i++)\n-\t    num_shifts++;\n-\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/1)\n-\t{\n-\t  quotient = shift_amount/1;\n-\t  shift_amount = shift_amount - (quotient * 1);\n-\t  for (i = 0; i < quotient; i++)\n-\t    num_shifts++;\n-\n-\t  first_shift_emitted = 1;\n-\t}\n-    }\n-  return num_shifts;\n-}\n-\n-void\n-asm_output_common(file, name, size, rounded)\n-     FILE *file;\n-     const char *name;\n-     int size ATTRIBUTE_UNUSED;\n-     int rounded;\n-{\n-    bss_section ();\n-    (*targetm.asm_out.globalize_label) (file, name);\n-    assemble_name (file, name);\n-    fputs (\":\", file);\n-    if (rounded > 1)\n-\tfprintf (file, \"%d * int\\n\", rounded);\n-    else\n-\tfprintf (file, \"int\\n\");\n-}\n-\n-void\n-asm_output_local(file, name, size, rounded)\n-     FILE *file;\n-     const char *name;\n-     int size ATTRIBUTE_UNUSED;\n-     int rounded;\n-{\n-    bss_section ();\n-    assemble_name (file, name);\n-    fputs (\":\", file);\n-    if (rounded > 1)\n-\tfprintf (file, \"%d * int\\n\", rounded);\n-    else\n-\tfprintf (file, \"int\\n\");\n-}\n-\n-static int\n-dsp16xx_address_cost (addr)\n-     rtx addr;\n-{\n-    switch (GET_CODE (addr))\n-    {\n-\t  default:\n-\t     break;\n-\n-\t  case REG:\n-\t     return 1;\n-\n-\t  case CONST:\n-\t     {\n-\t        rtx offset = const0_rtx;\n-\t        addr = eliminate_constant_term (addr, &offset);\n-\n-\t        if (GET_CODE (addr) == LABEL_REF)\n-\t            return 2;\n-\n-\t        if (GET_CODE (addr) != SYMBOL_REF)\n-\t            return 4;\n-\n-\t        if (INTVAL (offset) == 0)\n-\t            return 2;\n-             }\n-\t     /* fall through */\n-\n-\t  case POST_INC: case POST_DEC:\n-\t     return (GET_MODE (addr) == QImode ? 1 : 2);\n-\n-\t  case SYMBOL_REF: case LABEL_REF:\n-\t     return 2;\n-\n-\t  case PLUS:\n-\t  {\n-\t     register rtx plus0 = XEXP (addr, 0);\n-\t     register rtx plus1 = XEXP (addr, 1);\n-\t     \n-\t     if (GET_CODE (plus0) != REG && GET_CODE (plus1) == REG)\n-\t     {\n-\t\t plus0 = XEXP (addr, 1);\n-\t\t plus1 = XEXP (addr, 0);\n-\t     }\n-\t     \n-\t     if (GET_CODE (plus0) != REG)\n-\t\t break;\n-\t     \n-\t     switch (GET_CODE (plus1))\n-\t     {\n-\t\t   default:\n-\t\t      break;\n-\t\t \n-\t\t   case CONST_INT:\n-\t\t      return 4;\n-\n-\t\t   case CONST:\n-\t\t   case SYMBOL_REF:\n-\t\t   case LABEL_REF:\n-\t\t      return dsp16xx_address_cost (plus1) + 1;\n-\t     }\n-\t  }\n-     }\n-\t     \n-     return 4;\n-}\n-\n-\f\n-/* Determine whether a function argument is passed in a register, and\n-   which register.\n-\n-   The arguments are CUM, which summarizes all the previous\n-   arguments; MODE, the machine mode of the argument; TYPE,\n-   the data type of the argument as a tree node or 0 if that is not known\n-   (which happens for C support library functions); and NAMED,\n-   which is 1 for an ordinary argument and 0 for nameless arguments that\n-   correspond to `...' in the called function's prototype.\n-\n-   The value of the expression should either be a `reg' RTX for the\n-   hard register in which to pass the argument, or zero to pass the\n-   argument on the stack.\n-\n-   On the dsp1610 the first four words of args are normally in registers\n-   and the rest are pushed. If we a long or on float mode, the argument\n-   must begin on an even register boundary\n-\n-   Note that FUNCTION_ARG and FUNCTION_INCOMING_ARG were different.\n-   For structures that are passed in memory, but could have been\n-   passed in registers, we first load the structure into the\n-   register, and then when the last argument is passed, we store\n-   the registers into the stack locations.  This fixes some bugs\n-   where GCC did not expect to have register arguments, followed.  */\n-\n-struct rtx_def *\n-dsp16xx_function_arg (args_so_far, mode, type, named)\n-     CUMULATIVE_ARGS args_so_far;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n-{\n-  if (TARGET_REGPARM)\n-    {\n-      if ((args_so_far & 1) != 0\n-\t  && (mode == HImode || GET_MODE_CLASS(mode) == MODE_FLOAT))\n-\targs_so_far++;\n-\n-      if (type == void_type_node)\n-\treturn (struct rtx_def *) 0;\n-\n-      if (named && args_so_far < 4 && !MUST_PASS_IN_STACK (mode,type))\n-\treturn gen_rtx_REG (mode, args_so_far + FIRST_REG_FOR_FUNCTION_ARG);\n-      else\n-\treturn (struct rtx_def *) 0;\n-    }\n-  else\n-    return (struct rtx_def *) 0;\n-}\n-\n-/* Advance the argument to the next argument position.  */\n-\n-void\n-dsp16xx_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named ATTRIBUTE_UNUSED;/* whether or not the argument was named */\n-{\n-  if (TARGET_REGPARM)\n-    {\n-      if ((*cum & 1) != 0\n-\t  && (mode == HImode || GET_MODE_CLASS(mode) == MODE_FLOAT))\n-\t*cum += 1;\n-\n-      if (mode != BLKmode)\n-\t*cum += GET_MODE_SIZE (mode);\n-      else\n-\t*cum += int_size_in_bytes (type);\n-    }\n-}\n-\n-static void\n-dsp16xx_file_start ()\n-{\n-  fprintf (asm_out_file, \"#include <%s.h>\\n\", save_chip_name);\n-}\n-\n-rtx\n-gen_tst_reg (x)\n-     rtx x;\n-{\n-  enum machine_mode mode;\n-\n-  mode = GET_MODE (x);\n-\n-  if (mode == QImode)\n-    emit_insn (gen_rtx_PARALLEL\n-\t       (VOIDmode,\n-\t\tgen_rtvec (2, gen_rtx_SET (VOIDmode, cc0_rtx, x),\n-\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t    gen_rtx_SCRATCH (QImode)))));\n-  else if (mode == HImode)\n-    emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, x));\n-  else\n-    fatal_error (\"invalid mode for gen_tst_reg\");\n-\n-  return cc0_rtx;\n-}\n-\n-rtx\n-gen_compare_reg (code, x, y)\n-     enum rtx_code code;\n-     rtx x, y;\n-{\n-  enum machine_mode mode;\n-\n-  mode = GET_MODE (x);\n-  /* For floating point compare insns, a call is generated so don't\n-     do anything here.  */\n-\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    return cc0_rtx;\n-\n-  if (mode == QImode)\n-    {\n-      if (code == GTU || code == GEU\n-\t  || code == LTU || code == LEU)\n-\t{\n-\t  emit_insn (gen_rtx_PARALLEL\n-\t\t     (VOIDmode,\n-\t\t      gen_rtvec (3,\n-\t\t\t\t gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t\t\t      gen_rtx_COMPARE (mode, x, y)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n-\t}\n-      else\n-\t{\n-\t  emit_insn (gen_rtx_PARALLEL\n-\t\t     (VOIDmode,\n-\t\t      gen_rtvec (3, gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t\t\t\t gen_rtx_COMPARE (mode, x, y)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n-\t}\n-    }\n-  else if (mode == HImode)\n-    {\n-      if (code == GTU || code == GEU\n-\t  || code == LTU || code == LEU)\n-\t{\n-\t  emit_insn (gen_rtx_PARALLEL \n-\t\t     (VOIDmode, \n-\t\t      gen_rtvec (5,\n-\t\t\t\t gen_rtx_SET (VOIDmode, cc0_rtx, \n-\t\t\t\t\t      gen_rtx_COMPARE (VOIDmode, x, y)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n-\t}\n-      else\n-\temit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t\tgen_rtx_COMPARE (VOIDmode,\n-\t\t\t\t\t\t force_reg (HImode, x), \n-\t\t\t\t\t\t force_reg (HImode,y))));\n-    }\n-  else\n-    fatal_error (\"invalid mode for integer comparison in gen_compare_reg\");\n-\n-  return cc0_rtx;\n-}\n-\n-const char *\n-output_block_move (operands)\n-     rtx operands[];\n-{\n-  int loop_count = INTVAL(operands[2]);\n-  rtx xoperands[4];\n-\n-  fprintf (asm_out_file, \"\\tdo %d {\\n\", loop_count);\n-  xoperands[0] = operands[4];\n-  xoperands[1] = operands[1];\n-  output_asm_insn (\"%0=*%1++\", xoperands);\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = operands[4];\n-  output_asm_insn (\"*%0++=%1\", xoperands);\n-\n-  fprintf (asm_out_file, \"\\t}\\n\");\n-  return \"\";\n-}\n-\n-int\n-uns_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (mode == VOIDmode || GET_MODE (op) == mode)\n-    {\n-      enum rtx_code code;\n-      \n-      code = GET_CODE(op);\n-\n-      if (code == LEU || code == LTU || code == GEU\n-\t  || code == GTU)\n-\t{\n-\t  return 1;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-\n-  return 0;\n-}\n-\n-int\n-signed_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (mode == VOIDmode || GET_MODE (op) == mode)\n-    {\n-      enum rtx_code code;\n-      \n-      code = GET_CODE(op);\n-\n-      if (!(code == LEU || code == LTU || code == GEU\n-\t  || code == GTU))\n-\t{\n-\t  return 1;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-\n-  return 0;\n-}\n-\f\n-static bool\n-dsp16xx_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code;\n-     int outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n-{\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      *total = (unsigned HOST_WIDE_INT) INTVAL (x) < 65536 ? 0 : 2;\n-      return true;\n-\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      *total = COSTS_N_INSNS (2);\n-      return true;\n-\n-    case MEM:\n-      *total = COSTS_N_INSNS (GET_MODE (x) == QImode ? 2 : 4);\n-      return true;\n-\n-    case DIV:\n-    case MOD:\n-      *total = COSTS_N_INSNS (38);\n-      return true;\n-\n-    case MULT:\n-      if (GET_MODE (x) == QImode)\n-        *total = COSTS_N_INSNS (2);\n-      else\n-\t*total = COSTS_N_INSNS (38);\n-      return true;\n-\n-    case PLUS:\n-    case MINUS:\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t{\n-\t  *total = 1;\n-\t  return false;\n-\t}\n-      else\n-\t{\n-          *total = COSTS_N_INSNS (38);\n-\t  return true;\n-\t}\n-\n-    case NEG:\n-    case NOT:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  HOST_WIDE_INT number = INTVAL (XEXP (x, 1));\n-\t  if (number == 1 || number == 4 || number == 8\n-\t      || number == 16)\n-\t    *total = COSTS_N_INSNS (1);\n-\t  else if (TARGET_BMU)\n-            *total = COSTS_N_INSNS (2);\n-          else\n-            *total = COSTS_N_INSNS (num_1600_core_shifts (number));\n-\t  return true;\n-\t}\n-      break;\n-    }\n-\n-  if (TARGET_BMU)\n-    *total = COSTS_N_INSNS (1);\n-  else\n-    *total = COSTS_N_INSNS (15);\n-  return true;\n-}"}, {"sha": "472ba1f0d9bf5df64d66f789c8ad51773b9e20a8", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "removed", "additions": 0, "deletions": 1768, "changes": 1768, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,1768 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  AT&T DSP1600.\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Michael Collison (collison@isisinc.net).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-extern const char *low_reg_names[];\n-extern const char *text_seg_name;\n-extern const char *rsect_text;\n-extern const char *data_seg_name;\n-extern const char *rsect_data;\n-extern const char *bss_seg_name;\n-extern const char *rsect_bss;\n-extern const char *const_seg_name;\n-extern const char *rsect_const;\n-extern const char *chip_name;\n-extern const char *save_chip_name;\n-extern GTY(()) rtx dsp16xx_compare_op0;\n-extern GTY(()) rtx dsp16xx_compare_op1;\n-extern GTY(()) rtx dsp16xx_addhf3_libcall;\n-extern GTY(()) rtx dsp16xx_subhf3_libcall;\n-extern GTY(()) rtx dsp16xx_mulhf3_libcall;\n-extern GTY(()) rtx dsp16xx_divhf3_libcall;\n-extern GTY(()) rtx dsp16xx_cmphf3_libcall;\n-extern GTY(()) rtx dsp16xx_fixhfhi2_libcall;\n-extern GTY(()) rtx dsp16xx_floathihf2_libcall;\n-extern GTY(()) rtx dsp16xx_neghf2_libcall;\n-extern GTY(()) rtx dsp16xx_mulhi3_libcall;\n-extern GTY(()) rtx dsp16xx_udivqi3_libcall;\n-extern GTY(()) rtx dsp16xx_udivhi3_libcall;\n-extern GTY(()) rtx dsp16xx_divqi3_libcall;\n-extern GTY(()) rtx dsp16xx_divhi3_libcall;\n-extern GTY(()) rtx dsp16xx_modqi3_libcall;\n-extern GTY(()) rtx dsp16xx_modhi3_libcall;\n-extern GTY(()) rtx dsp16xx_umodqi3_libcall;\n-extern GTY(()) rtx dsp16xx_umodhi3_libcall;\n-\n-extern GTY(()) rtx dsp16xx_ashrhi3_libcall;\n-extern GTY(()) rtx dsp16xx_ashlhi3_libcall;\n-extern GTY(()) rtx dsp16xx_lshrhi3_libcall;\n-\n-/* RUN-TIME TARGET SPECIFICATION */\n-#define DSP16XX   1\n-\n-/* Name of the AT&T assembler */\n-\n-#define ASM_PROG \"as1600\"\n-\n-/* Name of the AT&T linker */\n-\n-#define LD_PROG \"ld1600\"\n-\n-/* Define which switches take word arguments */\n-#define WORD_SWITCH_TAKES_ARG(STR)              \\\n-  (!strcmp (STR, \"ifile\") ? 1 :                 \\\n-   0)\n-\n-#undef  CC1_SPEC\n-#define CC1_SPEC       \"%{!O*:-O}\"\n-\n-/* Define this as a spec to call the AT&T assembler */\n-\n-#define CROSS_ASM_SPEC   \"%{!S:as1600 %a %i\\n }\"\n-\n-/* Define this as a spec to call the AT&T linker */\n-\n-#define CROSS_LINK_SPEC  \"%{!c:%{!M:%{!MM:%{!E:%{!S:ld1600 %l %X %{o*} %{m} \\\n-\t\t\t%{r} %{s} %{t} %{u*} %{x}\\\n-\t\t\t%{!A:%{!nostdlib:%{!nostartfiles:%S}}} %{static:}\\\n-\t\t\t%{L*} %D %o %{!nostdlib:-le1600 %L -le1600}\\\n-\t\t\t%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\\n }}}}}\"\n-\n-/* Nothing complicated here, just link with libc.a under normal\n-   circumstances */\n-#define LIB_SPEC \"-lc\"\n-\n-/* Specify the startup file to link with.  */\n-#define STARTFILE_SPEC \"%{mmap1:m1_crt0.o%s}  \\\n-%{mmap2:m2_crt0.o%s}                          \\\n-%{mmap3:m3_crt0.o%s}                          \\\n-%{mmap4:m4_crt0.o%s}                          \\\n-%{!mmap*: %{!ifile*: m4_crt0.o%s} %{ifile*:     \\\n-%ea -ifile option requires a -map option}}\"\n-\n-/* Specify the end file to link with */\n-\n-#define ENDFILE_SPEC \"%{mmap1:m1_crtn.o%s}  \\\n-%{mmap2:m2_crtn.o%s}                          \\\n-%{mmap3:m3_crtn.o%s}                          \\\n-%{mmap4:m4_crtn.o%s}                          \\\n-%{!mmap*: %{!ifile*: m4_crtn.o%s} %{ifile*:     \\\n-%ea -ifile option requires a -map option}}\"\n-\n-\n-/* Tell gcc where to look for the startfile */\n-/*#define STANDARD_STARTFILE_PREFIX   \"/d1600/lib\"*/\n-\n-/* Tell gcc where to look for it's executables */\n-/*#define STANDARD_EXEC_PREFIX  \"/d1600/bin\"*/\n-\n-/* Command line options to the AT&T assembler */\n-#define ASM_SPEC  \"%{V} %{v:%{!V:-V}} %{g*:-g}\"\n-\n-/* Command line options for the AT&T linker */\n-\n-#define LINK_SPEC \"%{V} %{v:%{!V:-V}} %{minit:-i}  \\\n-%{!ifile*:%{mmap1:m1_deflt.if%s}         \\\n-          %{mmap2:m2_deflt.if%s}         \\\n-          %{mmap3:m3_deflt.if%s}         \\\n-          %{mmap4:m4_deflt.if%s}         \\\n-          %{!mmap*:m4_deflt.if%s}}       \\\n-%{ifile*:%*} %{r}\"\n-\n-/* Include path is determined from the environment variable */\n-#define INCLUDE_DEFAULTS     \\\n-{                            \\\n-  { 0, 0, 0, 0, 0 }          \\\n-}\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"dsp1600\");\t\t\\\n-      builtin_define_std (\"DSP1600\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#ifdef __MSDOS__\n-# define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"MSDOS\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-#else\n-# define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"dsp1610\");\t\t\\\n-      builtin_define_std (\"DSP1610\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-#endif\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern int target_flags;\n-\n-/* Macros used in the machine description to test the flags.  */\n-\n-#define MASK_REGPARM         0x00000001    /* Pass parameters in registers */\n-#define MASK_NEAR_CALL       0x00000002    /* The call is on the same 4k page */\n-#define MASK_NEAR_JUMP       0x00000004    /* The jump is on the same 4k page */\n-#define MASK_BMU             0x00000008    /* Use the 'bmu' shift instructions */\n-#define MASK_MAP1            0x00000040    /* Link with map1 */\n-#define MASK_MAP2            0x00000080    /* Link with map2 */\n-#define MASK_MAP3            0x00000100    /* Link with map3 */\n-#define MASK_MAP4            0x00000200    /* Link with map4 */\n-#define MASK_YBASE_HIGH      0x00000400    /* The ybase register window starts high */\n-#define MASK_INIT\t     0x00000800    /* Have the linker generate tables to\n-\t\t\t\t\t      initialize data at startup */\n-#define MASK_RESERVE_YBASE   0x00002000    /* Reserved the ybase registers */\n-#define MASK_DEBUG           0x00004000\t   /* Debugging turned on*/\n-#define MASK_SAVE_TEMPS      0x00008000    /* Save temps. option seen */\n-\n-/* Compile passing first two args in regs 0 and 1.\n-   This exists only to test compiler features that will\n-   be needed for RISC chips.  It is not usable\n-   and is not intended to be usable on this cpu.  */\n-#define TARGET_REGPARM   (target_flags & MASK_REGPARM)\n-\n-/* The call is on the same 4k page, so instead of loading\n-   the 'pt' register and branching, we can branch directly */\n-\n-#define TARGET_NEAR_CALL (target_flags & MASK_NEAR_CALL)\n-\n-/* The jump is on the same 4k page, so instead of loading\n-   the 'pt' register and branching, we can branch directly */\n-\n-#define TARGET_NEAR_JUMP (target_flags & MASK_NEAR_JUMP)\n-\n-/* Generate shift instructions to use the 1610 Bit Manipulation\n-   Unit.  */\n-#define TARGET_BMU (target_flags & MASK_BMU)\n-\n-#define TARGET_YBASE_HIGH (target_flags & MASK_YBASE_HIGH)\n-\n-/* Direct the linker to output extra info for initialized data */\n-#define TARGET_MASK_INIT (target_flags & MASK_INIT)\n-\n-#define TARGET_INLINE_MULT (target_flags & MASK_INLINE_MULT)\n-\n-/* Reserve the ybase registers *(0) - *(31) */\n-#define TARGET_RESERVE_YBASE (target_flags & MASK_RESERVE_YBASE)\n-\n-/* We turn this option on internally after seeing \"-g\" */\n-#define TARGET_DEBUG            (target_flags & MASK_DEBUG)\n-\n-/* We turn this option on internally after seeing \"-save-temps */\n-#define TARGET_SAVE_TEMPS       (target_flags & MASK_SAVE_TEMPS)\n-\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-\n-#define TARGET_SWITCHES                                           \\\n-  {\t\t\t\t                                  \\\n-    { \"regparm\",       MASK_REGPARM,                              \\\n-      N_(\"Pass parameters in registers (default)\") },             \\\n-    { \"no-regparm\",   -MASK_REGPARM,\t                          \\\n-      N_(\"Don't pass parameters in registers\") },                 \\\n-    { \"near-call\",     MASK_NEAR_JUMP,                            \\\n-      N_(\"Generate code for near calls\") },                       \\\n-    { \"no-near-call\", -MASK_NEAR_CALL,                            \\\n-      N_(\"Don't generate code for near calls\") },                 \\\n-    { \"near-jump\",     MASK_NEAR_JUMP,                            \\\n-      N_(\"Generate code for near jumps\") },                       \\\n-    { \"no-near-jump\", -MASK_NEAR_JUMP,                            \\\n-      N_(\"Don't generate code for near jumps\") },                 \\\n-    { \"bmu\",           MASK_BMU,                                  \\\n-      N_(\"Generate code for a bit-manipulation unit\") },          \\\n-    { \"no-bmu\",       -MASK_BMU,                                  \\\n-      N_(\"Don't generate code for a bit-manipulation unit\") },    \\\n-    { \"map1\",          MASK_MAP1,                                 \\\n-      N_(\"Generate code for memory map1\") },                      \\\n-    { \"map2\",          MASK_MAP2,                                 \\\n-      N_(\"Generate code for memory map2\") },                      \\\n-    { \"map3\",          MASK_MAP3,                                 \\\n-      N_(\"Generate code for memory map3\") },                      \\\n-    { \"map4\",          MASK_MAP4,                                 \\\n-      N_(\"Generate code for memory map4\") },                      \\\n-    { \"init\",          MASK_INIT,                                 \\\n-      N_(\"Ouput extra code for initialized data\") },              \\\n-    { \"reserve-ybase\", MASK_RESERVE_YBASE,                        \\\n-      N_(\"Don't let reg. allocator use ybase registers\") },       \\\n-    { \"debug\",         MASK_DEBUG,                                \\\n-      N_(\"Output extra debug info in Luxworks environment\") },    \\\n-    { \"save-temporaries\",    MASK_SAVE_TEMPS,                     \\\n-      N_(\"Save temp. files in Luxworks environment\") },           \\\n-    { \"\",              TARGET_DEFAULT, \"\"}                        \\\n-  }\n-\n-/* Default target_flags if no switches are specified */\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT  MASK_REGPARM|MASK_YBASE_HIGH\n-#endif\n-\n-#define TARGET_OPTIONS\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  { \"text=\",\t&text_seg_name,\t\t\t\t        \\\n-    N_(\"Specify alternate name for text section\"), 0},          \\\n-  { \"data=\",\t&data_seg_name,\t\t\t\t        \\\n-    N_(\"Specify alternate name for data section\"), 0},          \\\n-  { \"bss=\",\t&bss_seg_name,\t\t\t\t        \\\n-    N_(\"Specify alternate name for bss section\"), 0},           \\\n-  { \"const=\",   &const_seg_name,                                \\\n-    N_(\"Specify alternate name for constant section\"), 0},      \\\n-  { \"chip=\",    &chip_name,                                     \\\n-    N_(\"Specify alternate name for dsp16xx chip\"), 0},          \\\n-}\n-\n-/* Sometimes certain combinations of command options do not make sense\n-   on a particular target machine.  You can define a macro\n-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n-   defined, is executed once just after all the command options have\n-   been parsed.\n-  \n-   Don't use this macro to turn on various extra optimizations for\n-   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n-\n-#define OVERRIDE_OPTIONS override_options ()\n-\n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)              \\\n-{                                                     \\\n-    if (LEVEL >= 2)                                   \\\n-    {                                                 \\\n-        /* The dsp16xx family has so few registers    \\\n-         * that running the first instruction         \\\n-         * scheduling is bad for reg. allocation      \\\n-         * since it increases lifetimes of pseudos.   \\\n-         * So turn of first scheduling pass.          \\\n-         */                                           \\\n-        flag_schedule_insns          = FALSE;         \\\n-    }                                                 \\\n-}\n-\f\n-/* STORAGE LAYOUT */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n- */\n-#define BITS_BIG_ENDIAN  0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.\n-   We define big-endian, but since the 1600 series cannot address bytes\n-   it does not matter.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is numbered.\n-   For the 1600 we can decide arbitrarily since there are no machine instructions for them.  */\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* number of bits in an addressable storage unit */\n-#define BITS_PER_UNIT 16\n-\n-/* Maximum number of bits in a word.  */\n-#define MAX_BITS_PER_WORD 16\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 1\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY 16\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 16\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 16\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 16\n-\n-/* Biggest alignment that any data type can require on this machine, in bits.  */\n-#define BIGGEST_ALIGNMENT 16\n-\n-/* Biggest alignment that any structure field can require on this machine, in bits */\n-#define BIGGEST_FIELD_ALIGNMENT 16\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 16\n-\n-/* Number of bits which any structure or union's size must be a multiple of. Each structure\n-   or union's size is rounded up to a multiple of this */\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* Define this if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT  1\n-\n-/* An integer expression for the size in bits of the largest integer machine mode that\n-   should actually be used. All integer machine modes of this size or smaller can be\n-   used for structures and unions with the appropriate sizes.  */\n-#define MAX_FIXED_MODE_SIZE 32\n-\f\n-/* LAYOUT OF SOURCE LANGUAGE DATA TYPES */\n-\n-#define SHORT_TYPE_SIZE        16\n-#define INT_TYPE_SIZE          16\n-#define LONG_TYPE_SIZE         32\n-#define LONG_LONG_TYPE_SIZE    32\n-#define FLOAT_TYPE_SIZE        32\n-#define DOUBLE_TYPE_SIZE       32\n-#define LONG_DOUBLE_TYPE_SIZE  32\n-\n-/* An expression whose value is 1 or 0, according to whether the type char should be\n-   signed or unsigned by default.  */\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* A C expression to determine whether to give an enum type only as many bytes\n-   as it takes to represent the range of possible values of that type. A nonzero\n-   value means to do that; a zero value means all enum types should be allocated\n-   like int.  */\n-\n-#define DEFAULT_SHORT_ENUMS 0\n-\n-/* A C expression for a string describing the name of the data type to use for\n-   size values.  */\n-\n-#define SIZE_TYPE    \"unsigned int\"\n-\n-/* A C expression for a string describing the name of the data type to use for the\n-   result of subtracting two pointers */\n-\n-#define PTRDIFF_TYPE \"int\"\n-\n-\f\n-/* REGISTER USAGE.  */\n-\n-#define ALL_16_BIT_REGISTERS  1\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to FIRST_PSEUDO_REGISTER-1 */\n-\n-#define FIRST_PSEUDO_REGISTER (REG_YBASE31 + 1)\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-\n-   The registers are laid out as follows:\n-\n-   {a0,a0l,a1,a1l,x,y,yl,p,pl} - Data Arithmetic Unit\n-   {r0,r1,r2,r3,j,k,ybase} - Y Space Address Arithmetic Unit\n-   {pt} - X Space Address Arithmetic Unit\n-   {ar0,ar1,ar2,ar3} - Bit Manipulation UNit\n-   {pr} - Return Address Register\n-\n-   We reserve r2 for the Stack Pointer.\n-   We specify r3 for the Frame Pointer but allow the compiler\n-   to omit it when possible since we have so few pointer registers.  */\n-\n-#define REG_A0     0\n-#define REG_A0L    1\n-#define REG_A1     2\n-#define REG_A1L    3 \n-#define REG_X      4\n-#define REG_Y      5\n-#define REG_YL     6\n-#define REG_PROD   7\n-#define REG_PRODL  8\n-#define REG_R0     9\n-#define REG_R1     10\n-#define REG_R2     11\n-#define REG_R3     12\n-#define REG_J      13\n-#define REG_K      14\n-#define REG_YBASE  15\n-#define REG_PT     16\n-#define REG_AR0    17\n-#define REG_AR1    18\n-#define REG_AR2    19\n-#define REG_AR3    20\n-#define REG_C0     21\n-#define REG_C1     22\n-#define REG_C2     23\n-#define REG_PR     24\n-#define REG_RB     25\n-#define REG_YBASE0 26\n-#define REG_YBASE1 27\n-#define REG_YBASE2 28\n-#define REG_YBASE3 29\n-#define REG_YBASE4 30\n-#define REG_YBASE5 31\n-#define REG_YBASE6 32\n-#define REG_YBASE7 33\n-#define REG_YBASE8 34\n-#define REG_YBASE9 35\n-#define REG_YBASE10 36\n-#define REG_YBASE11 37\n-#define REG_YBASE12 38\n-#define REG_YBASE13 39\n-#define REG_YBASE14 40\n-#define REG_YBASE15 41\n-#define REG_YBASE16 42\n-#define REG_YBASE17 43\n-#define REG_YBASE18 44\n-#define REG_YBASE19 45\n-#define REG_YBASE20 46\n-#define REG_YBASE21 47\n-#define REG_YBASE22 48\n-#define REG_YBASE23 49\n-#define REG_YBASE24 50\n-#define REG_YBASE25 51\n-#define REG_YBASE26 52\n-#define REG_YBASE27 53\n-#define REG_YBASE28 54\n-#define REG_YBASE29 55\n-#define REG_YBASE30 56\n-#define REG_YBASE31 57\n-\n-/* Do we have an accumulator register? */\n-#define IS_ACCUM_REG(REGNO) IN_RANGE ((REGNO), REG_A0, REG_A1L)\n-#define IS_ACCUM_LOW_REG(REGNO) ((REGNO) == REG_A0L || (REGNO) == REG_A1L)\n-\n-/* Do we have a virtual ybase register */\n-#define IS_YBASE_REGISTER_WINDOW(REGNO) ((REGNO) >= REG_YBASE0 && (REGNO) <= REG_YBASE31)\n-\n-#define IS_YBASE_ELIGIBLE_REG(REGNO) (IS_ACCUM_REG (REGNO) || IS_ADDRESS_REGISTER(REGNO) \\\n-                                      || REGNO == REG_X || REGNO == REG_Y || REGNO == REG_YL \\\n-                                      || REGNO == REG_PROD || REGNO == REG_PRODL)\n-\n-#define IS_ADDRESS_REGISTER(REGNO) ((REGNO) >= REG_R0 && (REGNO) <= REG_R3)\n-\n-#define FIXED_REGISTERS     \\\n-{0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n- 0, 0, 0, 1, 0, 0, 1,       \\\n- 1,                         \\\n- 0, 0, 0, 0,                \\\n- 1, 1, 1,                   \\\n- 1, 0,                      \\\n- 0, 0, 0, 0, 0, 0, 0, 0,    \\\n- 0, 0, 0, 0, 0, 0, 0, 0,    \\\n- 0, 0, 0, 0, 0, 0, 0, 0,    \\\n- 0, 0, 0, 0, 0, 0, 0, 0}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   On the 1610 'a0' holds return values from functions. 'r0' holds\n-   structure-value addresses.\n-\n-   In addition we don't save either j, k, ybase or any of the\n-   bit manipulation registers.  */\n-\n-\n-#define CALL_USED_REGISTERS\t\t\t\\\n-{1, 1, 1, 1, 0, 1, 1, 1, 1,\t/* 0-8 */\t\\\n- 1, 0, 0, 1, 1, 1, 1,\t\t/* 9-15 */\t\\\n- 1,                             /* 16 */\t\\\n- 0, 0, 1, 1,\t\t\t/* 17-20 */\t\\\n- 1, 1, 1,\t\t\t/* 21-23 */\t\\\n- 1, 1,\t\t\t\t/* 24-25 */\t\\\n- 0, 0, 0, 0, 0, 0, 0, 0,\t/* 26-33 */\t\\\n- 0, 0, 0, 0, 0, 0, 0, 0,\t/* 34-41 */\t\\\n- 0, 0, 0, 0, 0, 0, 0, 0,\t/* 42-49 */\t\\\n- 0, 0, 0, 0, 0, 0, 0, 0}\t/* 50-57 */\n-\n-/* List the order in which to allocate registers.  Each register must be\n-   listed once, even those in FIXED_REGISTERS.\n-\n-   We allocate in the following order:\n- */\n-\n-#if 0\n-#define REG_ALLOC_ORDER\t\t\t\t\t\\\n-{ REG_R0, REG_R1, REG_R2, REG_PROD, REG_Y, REG_X,       \\\n-  REG_PRODL, REG_YL, REG_AR0, REG_AR1,                  \\\n-  REG_RB, REG_A0, REG_A1, REG_A0L,                      \\\n-  REG_A1L, REG_AR2, REG_AR3,                            \\\n-  REG_YBASE, REG_J, REG_K, REG_PR, REG_PT, REG_C0,      \\\n-  REG_C1, REG_C2, REG_R3,\t\t\t\t\\\n-  REG_YBASE0, REG_YBASE1, REG_YBASE2, REG_YBASE3,       \\\n-  REG_YBASE4, REG_YBASE5, REG_YBASE6, REG_YBASE7,       \\\n-  REG_YBASE8, REG_YBASE9, REG_YBASE10, REG_YBASE11,     \\\n-  REG_YBASE12, REG_YBASE13, REG_YBASE14, REG_YBASE15,   \\\n-  REG_YBASE16, REG_YBASE17, REG_YBASE18, REG_YBASE19,   \\\n-  REG_YBASE20, REG_YBASE21, REG_YBASE22, REG_YBASE23,   \\\n-  REG_YBASE24, REG_YBASE25, REG_YBASE26, REG_YBASE27,   \\\n-  REG_YBASE28, REG_YBASE29, REG_YBASE30, REG_YBASE31 }\n-#else\n-#define REG_ALLOC_ORDER                                 \\\n-{                                                       \\\n-  REG_A0, REG_A0L, REG_A1, REG_A1L, REG_Y, REG_YL,      \\\n-  REG_PROD,                                             \\\n-  REG_PRODL, REG_R0, REG_J, REG_K, REG_AR2, REG_AR3,    \\\n-  REG_X, REG_R1, REG_R2, REG_RB, REG_AR0, REG_AR1,      \\\n-  REG_YBASE0, REG_YBASE1, REG_YBASE2, REG_YBASE3,       \\\n-  REG_YBASE4, REG_YBASE5, REG_YBASE6, REG_YBASE7,       \\\n-  REG_YBASE8, REG_YBASE9, REG_YBASE10, REG_YBASE11,     \\\n-  REG_YBASE12, REG_YBASE13, REG_YBASE14, REG_YBASE15,   \\\n-  REG_YBASE16, REG_YBASE17, REG_YBASE18, REG_YBASE19,   \\\n-  REG_YBASE20, REG_YBASE21, REG_YBASE22, REG_YBASE23,   \\\n-  REG_YBASE24, REG_YBASE25, REG_YBASE26, REG_YBASE27,   \\\n-  REG_YBASE28, REG_YBASE29, REG_YBASE30, REG_YBASE31,   \\\n-  REG_R3, REG_YBASE, REG_PT, REG_C0, REG_C1, REG_C2,    \\\n-  REG_PR }\n-#endif\n-/* Zero or more C statements that may conditionally modify two\n-   variables `fixed_regs' and `call_used_regs' (both of type `char\n-   []') after they have been initialized from the two preceding\n-   macros.\n-\n-   This is necessary in case the fixed or call-clobbered registers\n-   depend on target flags.\n-\n-   You need not define this macro if it has no work to do.\n-\n-   If the usage of an entire class of registers depends on the target\n-   flags, you may indicate this to GCC by using this macro to modify\n-   `fixed_regs' and `call_used_regs' to 1 for each of the registers in\n-   the classes which should not be used by GCC.  Also define the macro\n-   `REG_CLASS_FROM_LETTER' to return `NO_REGS' if it is called with a\n-   letter for a class that shouldn't be used.\n-\n-   (However, if this class is not included in `GENERAL_REGS' and all\n-   of the insn patterns whose constraints permit this class are\n-   controlled by target switches, then GCC will automatically avoid\n-   using these registers when the target switches are opposed to\n-   them.)  If the user tells us there is no BMU, we can't use\n-   ar0-ar3 for register allocation */\n-\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (!TARGET_BMU)\t\t\t\t\t\t        \\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (regno = REG_AR0; regno <= REG_AR3; regno++)\t        \\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_RESERVE_YBASE)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (regno = REG_YBASE0; regno <= REG_YBASE31; regno++)\t        \\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* Determine which register classes are very likely used by spill registers.\n-   local-alloc.c won't allocate pseudos that have these classes as their\n-   preferred class unless they are \"preferred or nothing\".  */\n-\n-#define CLASS_LIKELY_SPILLED_P(CLASS) \\\n- ((CLASS) != ALL_REGS && (CLASS) != YBASE_VIRT_REGS)\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)                                 \\\n-  (GET_MODE_SIZE(MODE))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok(REGNO, MODE)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t     \\\n-  (((MODE1) == (MODE2)) ||                           \\\n-   (GET_MODE_CLASS((MODE1)) == MODE_FLOAT)           \\\n-    == (GET_MODE_CLASS((MODE2)) == MODE_FLOAT))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* DSP1600 pc isn't overloaded on a register.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  \n-   This is r3 in our case */\n-#define STACK_POINTER_REGNUM  REG_R3\n-\n-/* Base register for access to local variables of the function.\n-   This is r2 in our case   */\n-#define FRAME_POINTER_REGNUM  REG_R2\n-\n-/* We can debug without the frame pointer */\n-#define CAN_DEBUG_WITHOUT_FP 1\n-\n-/* The 1610 saves the return address in this register */\n-#define RETURN_ADDRESS_REGNUM REG_PR\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n-\n-/* Register in which static-chain is passed to a function.  */\n-\n-#define STATIC_CHAIN_REGNUM 4\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  This is 'r0' in our case */\n-#define STRUCT_VALUE_REGNUM   REG_R0\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-\n-enum reg_class \n-{ \n-    NO_REGS, \n-    A0H_REG,\n-    A0L_REG,\n-    A0_REG,\n-    A1H_REG,\n-    ACCUM_HIGH_REGS,\n-    A1L_REG,\n-    ACCUM_LOW_REGS, \n-    A1_REG,\n-    ACCUM_REGS, \n-    X_REG, \n-    X_OR_ACCUM_LOW_REGS,\n-    X_OR_ACCUM_REGS,\n-    YH_REG,\n-    YH_OR_ACCUM_HIGH_REGS,\n-    X_OR_YH_REGS,\n-    YL_REG,\n-    YL_OR_ACCUM_LOW_REGS,\n-    X_OR_YL_REGS,\n-    X_OR_Y_REGS,\n-    Y_REG,\n-    ACCUM_OR_Y_REGS,\n-    PH_REG,\n-    X_OR_PH_REGS, \n-    PL_REG, \n-    PL_OR_ACCUM_LOW_REGS,\n-    X_OR_PL_REGS,\n-    YL_OR_PL_OR_ACCUM_LOW_REGS,\n-    P_REG,\n-    ACCUM_OR_P_REGS,\n-    YL_OR_P_REGS,\n-    ACCUM_LOW_OR_YL_OR_P_REGS,\n-    Y_OR_P_REGS,\n-    ACCUM_Y_OR_P_REGS, \n-    NO_FRAME_Y_ADDR_REGS,\n-    Y_ADDR_REGS, \n-    ACCUM_LOW_OR_Y_ADDR_REGS,\n-    ACCUM_OR_Y_ADDR_REGS,\n-    X_OR_Y_ADDR_REGS,\n-    Y_OR_Y_ADDR_REGS,\n-    P_OR_Y_ADDR_REGS,\n-    NON_HIGH_YBASE_ELIGIBLE_REGS,\n-    YBASE_ELIGIBLE_REGS,\n-    J_REG,\n-    J_OR_DAU_16_BIT_REGS,\n-    BMU_REGS, \n-    NOHIGH_NON_ADDR_REGS,\n-    NON_ADDR_REGS,\n-    SLOW_MEM_LOAD_REGS,\n-    NOHIGH_NON_YBASE_REGS,\n-    NO_ACCUM_NON_YBASE_REGS,\n-    NON_YBASE_REGS,\n-    YBASE_VIRT_REGS,\n-    ACCUM_LOW_OR_YBASE_REGS,\n-    ACCUM_OR_YBASE_REGS,\n-    X_OR_YBASE_REGS,\n-    Y_OR_YBASE_REGS,\n-    ACCUM_LOW_YL_PL_OR_YBASE_REGS,\n-    P_OR_YBASE_REGS,\n-    ACCUM_Y_P_OR_YBASE_REGS,\n-    Y_ADDR_OR_YBASE_REGS,\n-    YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS,\n-    YBASE_OR_YBASE_ELIGIBLE_REGS,\n-    NO_HIGH_ALL_REGS,\n-    ALL_REGS, \n-    LIM_REG_CLASSES \n-};\n-\n-/* GENERAL_REGS must be the name of a register class */\n-#define GENERAL_REGS ALL_REGS\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES        \\\n-{                              \\\n-    \"NO_REGS\",                 \\\n-    \"A0H_REG\",                 \\\n-    \"A0L_REG\",                 \\\n-    \"A0_REG\",                  \\\n-    \"A1H_REG\",                 \\\n-    \"ACCUM_HIGH_REGS\",         \\\n-    \"A1L_REG\",                 \\\n-    \"ACCUM_LOW_REGS\",          \\\n-    \"A1_REG\",                  \\\n-    \"ACCUM_REGS\",              \\\n-    \"X_REG\",                   \\\n-    \"X_OR_ACCUM_LOW_REGS\",     \\\n-    \"X_OR_ACCUM_REGS\",         \\\n-    \"YH_REG\",                  \\\n-    \"YH_OR_ACCUM_HIGH_REGS\",   \\\n-    \"X_OR_YH_REGS\",            \\\n-    \"YL_REG\",                  \\\n-    \"YL_OR_ACCUM_LOW_REGS\",    \\\n-    \"X_OR_YL_REGS\",            \\\n-    \"X_OR_Y_REGS\",             \\\n-    \"Y_REG\",                   \\\n-    \"ACCUM_OR_Y_REGS\",         \\\n-    \"PH_REG\",                  \\\n-    \"X_OR_PH_REGS\",            \\\n-    \"PL_REG\",                  \\\n-    \"PL_OR_ACCUM_LOW_REGS\",    \\\n-    \"X_OR_PL_REGS\",            \\\n-    \"PL_OR_YL_OR_ACCUM_LOW_REGS\", \\\n-    \"P_REG\",                   \\\n-    \"ACCUM_OR_P_REGS\",         \\\n-    \"YL_OR_P_REGS\",            \\\n-    \"ACCUM_LOW_OR_YL_OR_P_REGS\", \\\n-    \"Y_OR_P_REGS\",             \\\n-    \"ACCUM_Y_OR_P_REGS\",       \\\n-    \"NO_FRAME_Y_ADDR_REGS\",      \\\n-    \"Y_ADDR_REGS\",               \\\n-    \"ACCUM_LOW_OR_Y_ADDR_REGS\",  \\\n-    \"ACCUM_OR_Y_ADDR_REGS\",    \\\n-    \"X_OR_Y_ADDR_REGS\",        \\\n-    \"Y_OR_Y_ADDR_REGS\",        \\\n-    \"P_OR_Y_ADDR_REGS\",        \\\n-    \"NON_HIGH_YBASE_ELIGIBLE_REGS\", \\\n-    \"YBASE_ELIGIBLE_REGS\",     \\\n-    \"J_REG\",                   \\\n-    \"J_OR_DAU_16_BIT_REGS\",    \\\n-    \"BMU_REGS\",                \\\n-    \"NOHIGH_NON_ADDR_REGS\",    \\\n-    \"NON_ADDR_REGS\",           \\\n-    \"SLOW_MEM_LOAD_REGS\",      \\\n-    \"NOHIGH_NON_YBASE_REGS\",   \\\n-    \"NO_ACCUM_NON_YBASE_REGS\", \\\n-    \"NON_YBASE_REGS\",          \\\n-    \"YBASE_VIRT_REGS\",         \\\n-    \"ACCUM_LOW_OR_YBASE_REGS\", \\\n-    \"ACCUM_OR_YBASE_REGS\",     \\\n-    \"X_OR_YBASE_REGS\",         \\\n-    \"Y_OR_YBASE_REGS\",         \\\n-    \"ACCUM_LOW_YL_PL_OR_YBASE_REGS\", \\\n-    \"P_OR_YBASE_REGS\",         \\\n-    \"ACCUM_Y_P_OR_YBASE_REGS\", \\\n-    \"Y_ADDR_OR_YBASE_REGS\",    \\\n-    \"YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS\", \\\n-    \"YBASE_OR_YBASE_ELIGIBLE_REGS\", \\\n-    \"NO_HIGH_ALL_REGS\",        \\\n-    \"ALL_REGS\"                 \\\n-}\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS   \\\n-{                            \\\n-    {0x00000000,  0x00000000},      /* no reg */                             \\\n-    {0x00000001,  0x00000000},      /* a0h */                                \\\n-    {0x00000002,  0x00000000},      /* a0l */                                \\\n-    {0x00000003,  0x00000000},      /* a0h:a0l */                            \\\n-    {0x00000004,  0x00000000},      /* a1h */                                \\\n-    {0x00000005,  0x00000000},      /* accum high */                         \\\n-    {0x00000008,  0x00000000},      /* a1l */                                \\\n-    {0x0000000A,  0x00000000},      /* accum low */                          \\\n-    {0x0000000c,  0x00000000},      /* a1h:a1l */                            \\\n-    {0x0000000f,  0x00000000},      /* accum regs */                         \\\n-    {0x00000010,  0x00000000},      /* x reg */                              \\\n-    {0x0000001A,  0x00000000},      /* x & accum_low_regs */                 \\\n-    {0x0000001f,  0x00000000},      /* x & accum regs */                     \\\n-    {0x00000020,  0x00000000},      /* y high */                             \\\n-    {0x00000025,  0x00000000},      /* yh, accum high */                     \\\n-    {0x00000030,  0x00000000},      /* x & yh */                             \\\n-    {0x00000040,  0x00000000},      /* y low */                              \\\n-    {0x0000004A,  0x00000000},      /* y low, accum_low */                   \\\n-    {0x00000050,  0x00000000},      /* x & yl */                             \\\n-    {0x00000060,  0x00000000},      /* yl:yh */                              \\\n-    {0x00000070,  0x00000000},      /* x, yh,a nd yl */                      \\\n-    {0x0000006F,  0x00000000},      /* accum, y */                           \\\n-    {0x00000080,  0x00000000},      /* p high */                             \\\n-    {0x00000090,  0x00000000},      /* x & ph */                             \\\n-    {0x00000100,  0x00000000},      /* p low */                              \\\n-    {0x0000010A,  0x00000000},      /* p_low and accum_low */                \\\n-    {0x00000110,  0x00000000},      /* x & pl */                             \\\n-    {0x0000014A,  0x00000000},      /* pl,yl,a1l,a0l */                      \\\n-    {0x00000180,  0x00000000},      /* pl:ph */                              \\\n-    {0x0000018F,  0x00000000},      /* accum, p */                           \\\n-    {0x000001C0,  0x00000000},      /* pl:ph and yl */                       \\\n-    {0x000001CA,  0x00000000},      /* pl:ph, yl, a0l, a1l */                \\\n-    {0x000001E0,  0x00000000},      /* y or p */                             \\\n-    {0x000001EF,  0x00000000},      /* accum, y or p */                      \\\n-    {0x00000E00,  0x00000000},      /* r0-r2 */                              \\\n-    {0x00001E00,  0x00000000},      /* r0-r3 */                              \\\n-    {0x00001E0A,  0x00000000},      /* r0-r3, accum_low */                   \\\n-    {0x00001E0F,  0x00000000},      /* accum,r0-r3 */                        \\\n-    {0x00001E10,  0x00000000},      /* x,r0-r3 */                            \\\n-    {0x00001E60,  0x00000000},      /* y,r0-r3 */                            \\\n-    {0x00001F80,  0x00000000},      /* p,r0-r3 */                            \\\n-    {0x00001FDA,  0x00000000},      /* ph:pl, r0-r3, x,a0l,a1l */            \\\n-    {0x00001fff,  0x00000000},      /* accum,x,y,p,r0-r3 */                  \\\n-    {0x00002000,  0x00000000},      /* j */                                  \\\n-    {0x00002025,  0x00000000},      /* j, yh, a1h, a0h */                    \\\n-    {0x001E0000,  0x00000000},      /* ar0-ar3 */                            \\\n-    {0x03FFE1DA,  0x00000000},      /* non_addr except yh,a0h,a1h */         \\\n-    {0x03FFE1FF,  0x00000000},      /* non_addr regs */                      \\\n-    {0x03FFFF8F,  0x00000000},      /* non ybase except yh, yl, and x */     \\\n-    {0x03FFFFDA,  0x00000000},      /* non ybase regs except yh,a0h,a1h */   \\\n-    {0x03FFFFF0,  0x00000000},      /* non ybase except a0,a0l,a1,a1l */     \\\n-    {0x03FFFFFF,  0x00000000},      /* non ybase regs */                     \\\n-    {0xFC000000,  0x03FFFFFF},      /* virt ybase regs */                    \\\n-    {0xFC00000A,  0x03FFFFFF},      /* accum_low, virt ybase regs */         \\\n-    {0xFC00000F,  0x03FFFFFF},      /* accum, virt ybase regs */             \\\n-    {0xFC000010,  0x03FFFFFF},      /* x,virt ybase regs */                  \\\n-    {0xFC000060,  0x03FFFFFF},      /* y,virt ybase regs */                  \\\n-    {0xFC00014A,  0x03FFFFFF},      /* accum_low, yl, pl, ybase */           \\\n-    {0xFC000180,  0x03FFFFFF},      /* p,virt ybase regs */                  \\\n-    {0xFC0001EF,  0x03FFFFFF},      /* accum,y,p,ybase regs */               \\\n-    {0xFC001E00,  0x03FFFFFF},      /* r0-r3, ybase regs */                  \\\n-    {0xFC001FDA,  0x03FFFFFF},      /* r0-r3, pl:ph,yl,x,a1l,a0l */          \\\n-    {0xFC001FFF,  0x03FFFFFF},      /* virt ybase, ybase eligible regs */    \\\n-    {0xFCFFFFDA,  0x03FFFFFF},      /* all regs except yh,a0h,a1h */         \\\n-    {0xFFFFFFFF,  0x03FFFFFF}       /* all regs */                           \\\n-}\n-\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) regno_reg_class(REGNO)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS NO_REGS\n-#define BASE_REG_CLASS  Y_ADDR_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  dsp16xx_reg_class_from_letter(C)\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)  \\\n-   secondary_reload_class(CLASS, MODE, X)\n-\n-/* When defined, the compiler allows registers explicitly used in the\n-   rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers.  */\n-\n-#define SMALL_REGISTER_CLASSES 1\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-/* A C expression which is nonzero if register REGNO is suitable for use\n-   as a base register in operand addresses. It may be either a suitable\n-   hard register or a pseudo register that has been allocated such a\n-   hard register. \n-\n-  On the 1610 the Y address pointers can be used as a base registers */\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-(((REGNO) >= REG_R0 && (REGNO) < REG_R3 + 1) || ((unsigned) reg_renumber[REGNO] >= REG_R0  \\\n-                                   && (unsigned) reg_renumber[REGNO] < REG_R3 + 1))\n-\n-#define REGNO_OK_FOR_YBASE_P(REGNO) \\\n-  (((REGNO) == REG_YBASE) || ((unsigned) reg_renumber[REGNO] == REG_YBASE))\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO)  0\n-\n-#ifdef ALL_16_BIT_REGISTERS\n-#define IS_32_BIT_REG(REGNO)  0\n-#else\n-#define IS_32_BIT_REG(REGNO)     \\\n-  ((REGNO) == REG_A0 || (REGNO) == REG_A1 || (REGNO) == REG_Y || (REGNO) == REG_PROD)\n-#endif\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-   Also, we must ensure that a PLUS is reloaded either\n-   into an accumulator or an address register.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t preferred_reload_class (X, CLASS)\n-\n-/*   A C expression that places additional restrictions on the register\n-     class to use when it is necessary to be able to hold a value of\n-     mode MODE in a reload register for which class CLASS would\n-     ordinarily be used.\n-\n-     Unlike `PREFERRED_RELOAD_CLASS', this macro should be used when\n-     there are certain modes that simply can't go in certain reload\n-     classes.\n-\n-     The value is a register class; perhaps CLASS, or perhaps another,\n-     smaller class.\n-\n-     Don't define this macro unless the target machine has limitations\n-     which require the macro to do something nontrivial.  */\n-\n-#if 0\n-#define LIMIT_RELOAD_CLASS(MODE, CLASS) dsp16xx_limit_reload_class (MODE, CLASS)\n-#endif\n-\n-/* A C expression for the maximum number of consecutive registers of class CLASS\n-   needed to hold a value of mode MODE */\n-#define CLASS_MAX_NREGS(CLASS, MODE)                                \\\n-    class_max_nregs(CLASS, MODE)\n-\n-/* The letters 'I' through 'P' in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For the 16xx, the following constraints are used:\n-   'I' requires a non-negative 16-bit value.\n-   'J' requires a non-negative 9-bit value\n-   'K' requires a constant 0 operand.\n-   'L' constant for use in add or sub from low 16-bits\n-   'M' 32-bit value -- low 16-bits zero\n-   'N' constant for use incrementing or decrementing an address register\n-   'O' constant for use with and'ing only high 16-bit\n-   'P' constant for use with and'ing only low 16-bit\n- */\n-\n-#define SMALL_INT(X) (SMALL_INTVAL (INTVAL (X)))\n-#define SMALL_INTVAL(I) ((unsigned) (I) < 0x10000)\n-#define SHORT_IMMEDIATE(X)  (SHORT_INTVAL (INTVAL(X)))\n-#define SHORT_INTVAL(I)     ((unsigned) (I) < 0x100)\n-#define ADD_LOW_16(I)       ((I) >= 0 && (I) <= 32767)\n-#define ADD_HIGH_16(I)      (((I) & 0x0000ffff) == 0)\n-#define AND_LOW_16(I)       ((I) >= 0 && (I) <= 32767)\n-#define AND_HIGH_16(I)      (((I) & 0x0000ffff) == 0)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)                           \\\n-   ((C) == 'I' ? (SMALL_INTVAL(VALUE))                            \\\n-    : (C) == 'J' ? (SHORT_INTVAL(VALUE))                          \\\n-    : (C) == 'K' ? ((VALUE) == 0)                                 \\\n-    : (C) == 'L' ? ((VALUE) >= 0 && (VALUE) <= 32767)             \\\n-    : (C) == 'M' ? (((VALUE) & 0x0000ffff) == 0)                  \\\n-    : (C) == 'N' ? ((VALUE) == -1 || (VALUE) == 1                 \\\n-                    || (VALUE) == -2 || (VALUE) == 2)             \\\n-    : (C) == 'O' ? (((VALUE) & 0xffff0000) == 0xffff0000)         \\\n-    : (C) == 'P' ? (((VALUE) & 0x0000ffff) == 0xffff)             \\\n-    : 0)\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)   1\n-\n-/* Optional extra constraints for this machine */\n-#define EXTRA_CONSTRAINT(OP,C)                                    \\\n-  ((C) == 'R' ? symbolic_address_p (OP)                           \\\n-   : 0)\n-\f\n-/* DESCRIBING STACK LAYOUT AND CALLING CONVENTIONS */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-/* #define STACK_GROWS_DOWNWARD */\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-#define ARGS_GROW_DOWNWARD\n-\n-/* We use post decrement on the 1600 because there isn't\n-   a pre-decrement addressing mode. This means that we\n-   assume the stack pointer always points at the next\n-   FREE location on the stack.  */\n-#define STACK_PUSH_CODE POST_INC\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET  0\n-\n-/* Offset from the stack pointer register to the first\n-   location at which outgoing arguments are placed.  */\n-#define STACK_POINTER_OFFSET (0)\n-\n-struct dsp16xx_frame_info\n-{\n-  unsigned long total_size;\t/* # bytes that the entire frame takes up */\n-  unsigned long var_size;\t/* # bytes that variables take up */\n-  unsigned long args_size;\t/* # bytes that outgoing arguments take up */\n-  unsigned long extra_size;\t/* # bytes of extra gunk */\n-  unsigned int  reg_size;\t/* # bytes needed to store regs */\n-  long\t\tfp_save_offset;\t/* offset from vfp to store registers */\n-  unsigned long sp_save_offset;\t/* offset from new sp to store registers */\n-  int\t\tpr_save_offset;\t/* offset to saved PR */\n-  int\t\tinitialized;\t/* != 0 if frame size already calculated */\n-  int\t\tnum_regs;\t/* number of registers saved */\n-  int           function_makes_calls;  /* Does the function make calls */\n-};\n-\n-extern struct dsp16xx_frame_info current_frame_info;\n-\n-#define RETURN_ADDR_OFF current_frame_info.pr_save_offset\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.  */\n-/* #define PUSH_ROUNDING(BYTES) ((BYTES)) */\n-\n-/* If defined, the maximum amount of space required for outgoing\n-   arguments will be computed and placed into the variable\n-   'current_function_outgoing_args_size'. No space will be pushed\n-   onto the stack for each call; instead, the function prologue should\n-   increase the stack frame size by this amount.\n-\n-   It is not proper to define both 'PUSH_ROUNDING' and\n-   'ACCUMULATE_OUTGOING_ARGS'.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Offset of first parameter from the argument pointer\n-   register value.  */\n-\n-#define FIRST_PARM_OFFSET(FNDECL)   (0)\n-\n-/* Value is 1 if returning from a function call automatically\n-   pops the arguments described by the number-of-args field in the call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0. On the 1610 all function return their values\n-   in a0 (i.e. the upper 16 bits). If the return value is 32-bits the\n-   entire register is significant.  */\n-\n-#define VALUE_REGNO(MODE)  (REG_Y)\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), VALUE_REGNO(TYPE_MODE(VALTYPE)))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, VALUE_REGNO(MODE))\n-\n-/* 1 if N is a possible register number for a function value.  */\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_Y)\n-\f\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-/* On the 1610 all args are pushed, except if -mregparm is specified\n-   then the first two words of arguments are passed in a0, a1.  */\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  dsp16xx_function_arg (CUM, MODE, TYPE, NAMED)\n-\n-/* Define the first register to be used for argument passing */\n-#define FIRST_REG_FOR_FUNCTION_ARG REG_Y\n-\n-/* Define the profitability of saving registers around calls.\n-   NOTE: For now we turn this off because of a bug in the\n-   caller-saves code and also because i'm not sure it is helpful\n-   on the 1610.  */\n-\n-#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n-\n-/* This indicates that an argument is to be passed with an invisible reference\n-   (i.e., a pointer to the object is passed).\n-\n-   On the dsp16xx, we do this if it must be passed on the stack.  */\n-\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n-  (MUST_PASS_IN_STACK (MODE, TYPE))\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  (0)\n-\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.  */\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-  ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  dsp16xx_function_arg_advance (&CUM, MODE,TYPE, NAMED)\n-\n-/* 1 if N is a possible register number for function argument passing.  */\n-#define FUNCTION_ARG_REGNO_P(N)   \\\n-  ((N) == REG_Y || (N) == REG_YL || (N) == REG_PROD || (N) == REG_PRODL)\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)        \\\n-  internal_error (\"profiling not implemented yet\")\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK  (0)\n-\n-#define TRAMPOLINE_TEMPLATE(FILE) \\\n-  internal_error (\"trampolines not yet implemented\");\n-\n-/* Length in units of the trampoline for entering a nested function.\n-   This is a dummy value  */\n-\n-#define TRAMPOLINE_SIZE 20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-  internal_error (\"trampolines not yet implemented\");\n-\n-/* A C expression which is nonzero if a function must have and use a\n-   frame pointer. If its value is nonzero the functions will have a\n-   frame pointer.  */\n-#define FRAME_POINTER_REQUIRED  (current_function_calls_alloca)\n-\n-/* A C statement to store in the variable 'DEPTH' the difference\n-   between the frame pointer and the stack pointer values immediately\n-   after the function prologue.  */\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)                     \\\n-{  (DEPTH) = initial_frame_pointer_offset();\t                \\\n-}\n-\f\n-/* IMPLICIT CALLS TO LIBRARY ROUTINES */\n-\n-#define ADDHF3_LIBCALL      \"__Emulate_addhf3\"\n-#define SUBHF3_LIBCALL      \"__Emulate_subhf3\"\n-#define MULHF3_LIBCALL      \"__Emulate_mulhf3\"\n-#define DIVHF3_LIBCALL      \"__Emulate_divhf3\"\n-#define CMPHF3_LIBCALL      \"__Emulate_cmphf3\"\n-#define FIXHFHI2_LIBCALL    \"__Emulate_fixhfhi2\"\n-#define FLOATHIHF2_LIBCALL  \"__Emulate_floathihf2\"\n-#define NEGHF2_LIBCALL      \"__Emulate_neghf2\"\n-\n-#define UMULHI3_LIBCALL     \"__Emulate_umulhi3\"\n-#define MULHI3_LIBCALL      \"__Emulate_mulhi3\"\n-#define UDIVQI3_LIBCALL     \"__Emulate_udivqi3\"\n-#define UDIVHI3_LIBCALL     \"__Emulate_udivhi3\"\n-#define DIVQI3_LIBCALL      \"__Emulate_divqi3\"\n-#define DIVHI3_LIBCALL      \"__Emulate_divhi3\"\n-#define MODQI3_LIBCALL      \"__Emulate_modqi3\"\n-#define MODHI3_LIBCALL      \"__Emulate_modhi3\"\n-#define UMODQI3_LIBCALL     \"__Emulate_umodqi3\"\n-#define UMODHI3_LIBCALL     \"__Emulate_umodhi3\"\n-#define ASHRHI3_LIBCALL     \"__Emulate_ashrhi3\"\n-#define LSHRHI3_LIBCALL     \"__Emulate_lshrhi3\"\n-#define ASHLHI3_LIBCALL     \"__Emulate_ashlhi3\"\n-#define LSHLHI3_LIBCALL     \"__Emulate_lshlhi3\"   /* NOT USED */\n-\n-/* Define this macro if calls to the ANSI C library functions memcpy and\n-   memset should be generated instead of the BSD function bcopy & bzero.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n-\f\n-/* ADDRESSING MODES */\n-\n-/* The 1610 has post-increment and decrement, but no pre-modify */\n-#define HAVE_POST_INCREMENT 1\n-#define HAVE_POST_DECREMENT 1\n-\n-/* Recognize any constant value that is a valid address.  */\n-#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X)  0\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)    \\\n-    ((REGNO (X) >= REG_R0 && REGNO (X) < REG_R3 + 1 )          \\\n-       || (REGNO (X) >= FIRST_PSEUDO_REGISTER))\n-\n-/* Nonzero if X is the 'ybase' register */\n-#define REG_OK_FOR_YBASE_P(X)   \\\n-  (REGNO(X) == REG_YBASE || (REGNO (X) >= FIRST_PSEUDO_REGISTER))\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-/* Nonzero if X is the 'ybase' register */\n-#define REG_OK_FOR_YBASE_P(X) REGNO_OK_FOR_YBASE_P (REGNO(X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On the 1610, the actual legitimate addresses must be N (N must fit in\n-   5 bits), *rn (register indirect), *rn++, or *rn-- */\n-\n-#define INT_FITS_5_BITS(I)    ((unsigned long) (I) < 0x20)\n-#define INT_FITS_16_BITS(I)   ((unsigned long) (I) < 0x10000)\n-#define YBASE_CONST_OFFSET(I)       ((I) >= -31 && (I) <= 0)\n-#define YBASE_OFFSET(X)       (GET_CODE (X) == CONST_INT && YBASE_CONST_OFFSET (INTVAL(X)))\n-\n-#define FITS_16_BITS(X)       (GET_CODE (X) == CONST_INT && INT_FITS_16_BITS(INTVAL(X)))\n-#define FITS_5_BITS(X)        (GET_CODE (X) == CONST_INT && INT_FITS_5_BITS(INTVAL(X)))\n-#define ILLEGAL_HIMODE_ADDR(MODE, CONST)  ((MODE) == HImode && CONST == -31)\n-\n-#define INDIRECTABLE_ADDRESS_P(X)                            \\\n-    ((GET_CODE(X) == REG && REG_OK_FOR_BASE_P(X))            \\\n-  || ((GET_CODE(X) == POST_DEC || GET_CODE(X) == POST_INC)   \\\n-       && REG_P(XEXP(X,0)) && REG_OK_FOR_BASE_P(XEXP(X,0)))  \\\n-  || (GET_CODE(X) == CONST_INT && (unsigned long) (X) < 0x20))\n-\n-\n-#define INDEXABLE_ADDRESS_P(X,MODE)                                 \\\n-   ((GET_CODE(X) == PLUS && GET_CODE (XEXP (X,0)) == REG &&         \\\n-     XEXP(X,0) == stack_pointer_rtx && YBASE_OFFSET(XEXP(X,1)) &&   \\\n-     !ILLEGAL_HIMODE_ADDR(MODE, INTVAL(XEXP(X,1)))) ||              \\\n-    (GET_CODE(X) == PLUS && GET_CODE (XEXP (X,1)) == REG &&         \\\n-     XEXP(X,1) == stack_pointer_rtx && YBASE_OFFSET(XEXP(X,0)) &&  \\\n-     !ILLEGAL_HIMODE_ADDR(MODE, INTVAL(XEXP(X,0)))))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                     \\\n-{\t\t\t\t\t\t\t            \\\n-    if (INDIRECTABLE_ADDRESS_P(X))                                  \\\n-        goto ADDR;                                                  \\\n-}\n-\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For the 1610, we need not do anything.  However, if we don't,\n-   `memory_address' will try lots of things to get a valid address, most of\n-   which will result in dead code and extra pseudos.  So we make the address\n-   valid here.\n-\n-   This is easy:  The only valid addresses are an offset from a register\n-   and we know the address isn't valid.  So just call either `force_operand'\n-   or `force_reg' unless this is a (plus (reg ...) (const_int 0)).  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{ if (GET_CODE (X) == PLUS && XEXP (X, 1) == const0_rtx)\t\\\n-    X = XEXP (x, 0);\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == MULT || GET_CODE (X) == PLUS)\t\t\\\n-    X = force_operand (X, 0);\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    X = force_reg (Pmode, X);\t\t\t\t\t\\\n-  goto WIN;\t\t\t\t\t\t\t\\\n-}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the 1610, only postdecrement and postincrement address depend thus\n-   (the amount of decrement or increment being the length of the operand).  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n- if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == POST_DEC) goto LABEL\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-#define LEGITIMATE_CONSTANT_P(X) (1)\n-\n-\f\n-/* CONDITION CODE INFORMATION */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-   notice_update_cc( (EXP) )\n-\f\n-/* DESCRIBING RELATIVE COSTS OF OPERATIONS */\n-\n-/* A c expression for the cost of moving data from a register in\n-   class FROM to one in class TO. The classes are expressed using\n-   the enumeration values such as GENERAL_REGS. A value of 2 is\n-   the default.  */\n-#define REGISTER_MOVE_COST(MODE,FROM,TO)  dsp16xx_register_move_cost (FROM, TO)\n-\n-/* A C expression for the cost of moving data of mode MODE between\n-   a register and memory. A value of 2 is the default.  */\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN)                          \\\n-  (GET_MODE_CLASS(MODE) == MODE_INT && MODE == QImode ? 12       \\\n-   : 16)\n-\n-/* A C expression for the cost of a branch instruction. A value of\n-   1 is the default; */\n-#define BRANCH_COST 1\n-\f\n-\n-/* Define this because otherwise gcc will try to put the function address\n-   in any old pseudo register. We can only use pt.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Define this macro as a C expression which is nonzero if accessing less\n-   than a word of memory (i.e a char or short) is no faster than accessing\n-   a word of memory, i.e if such access require more than one instruction\n-   or if there is no difference in cost between byte and (aligned) word\n-   loads.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define this macro if unaligned accesses have a cost many times greater than\n-   aligned accesses, for example if they are emulated in a trap handler */\n-/* define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) */\n-\n-\f\n-/* DIVIDING THE OUTPUT IN SECTIONS */\n-/* Output before read-only data.  */\n-\n-#define DEFAULT_TEXT_SEG_NAME \".text\"\n-#define TEXT_SECTION_ASM_OP  rsect_text\n-\n-/* Output before constants and strings */\n-#define DEFAULT_CONST_SEG_NAME  \".const\"\n-#define READONLY_DATA_SECTION_ASM_OP rsect_const\n-\n-/* Output before writable data.  */\n-#define DEFAULT_DATA_SEG_NAME \".data\"\n-#define DATA_SECTION_ASM_OP  rsect_data\n-\n-#define DEFAULT_BSS_SEG_NAME \".bss\"\n-#define BSS_SECTION_ASM_OP rsect_bss\n-\n-/* We will default to using 1610 if the user doesn't\n-   specify it.  */\n-#define DEFAULT_CHIP_NAME \"1610\"\n-\f\n-/* THE OVERALL FRAMEWORK OF AN ASSEMBLER FILE */\n-\n-/* A C string constant describing how to begin a comment in the target\n-   assembler language.  */\n-#define ASM_COMMENT_START \"\"\n-#define ASM_COMMENT_END \"\"\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-#define ASM_APP_OFF \"\"\n-\f\n-/* OUTPUT OF DATA */\n-\n-/* This is how we output a 'c' character string. For the 16xx\n-   assembler we have to do it one letter at a time */\n-\n-#define ASCII_LENGTH 10\n-\n-#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    FILE *_hide_asm_out_file = (MYFILE);\t\t\t\t      \\\n-    const unsigned char *_hide_p = (const unsigned char *) (MYSTRING);\t      \\\n-    int _hide_thissize = (MYLENGTH);\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      FILE *asm_out_file = _hide_asm_out_file;\t\t\t\t      \\\n-      const unsigned char *p = _hide_p;\t\t\t\t\t      \\\n-      int thissize = _hide_thissize;\t\t\t\t\t      \\\n-      int i;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-      for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n-\t{\t\t\t\t\t\t\t\t      \\\n-\t  register int c = p[i];\t\t\t\t\t      \\\n-\t  \t\t\t\t\t\t\t\t      \\\n-\t  if (i % ASCII_LENGTH == 0) \\\n-\t    fprintf (asm_out_file, \"\\tint \");\t\t\t\t      \\\n-\t    \t\t\t\t\t\t\t\t\\\n-\t  if (c >= ' ' && c < 0177 && c != '\\'')\t\t\t      \\\n-\t  {\t\t\t\t\t\t\t\t      \\\n-\t    putc ('\\'', asm_out_file);\t\t\t\t\t      \\\n-\t    putc (c, asm_out_file);\t\t\t\t\t      \\\n-\t    putc ('\\'', asm_out_file);\t\t\t\t\t      \\\n-\t  }\t\t\t\t\t\t\t\t      \\\n-\t  else\t\t\t\t\t\t\t\t      \\\n-\t    {\t\t\t\t\t\t\t\t      \\\n-\t      fprintf (asm_out_file, \"%d\", c);\t\t\t              \\\n-\t      /* After an octal-escape, if a digit follows,\t\t      \\\n-\t\t terminate one string constant and start another.\t      \\\n-\t\t The VAX assembler fails to stop reading the escape\t      \\\n-\t\t after three digits, so this is the only way we\t\t      \\\n-\t\t can get it to parse the data properly.  \t\t      \\\n-\t      if (i < thissize - 1 && ISDIGIT (p[i + 1]))\t\t      \\\n-\t\tfprintf (asm_out_file, \"\\'\\n\\tint \\'\");\t\t              \\\n-\t\t*/ \\\n-\t  }\t\t\t\t\t\t\t\t      \\\n-\t  /* if: \\\n-\t     we are not at the last char (i != thissize -1) \\\n-\t     and (we are not at a line break multiple  \\\n-\t     but i == 0) (it will be the very first time) \\\n-\t     then put out a comma to extend. \\\n-\t   */ \\\n-\t  if ((i != thissize - 1) && ((i + 1) % ASCII_LENGTH))\t      \\\n-\t    fprintf(asm_out_file, \",\");\t \t                      \\\n-\t  if (!((i + 1) % ASCII_LENGTH)) \\\n-\t    fprintf (asm_out_file, \"\\n\");\t\t\t      \\\n-\t}\t\t\t\t\t\t\t\t      \\\n-      fprintf (asm_out_file, \"\\n\");\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-  }\t\t\t\t\t\t\t\t\t      \\\n-  while (0)\n-\n-#define ASM_PN_FORMAT \"*L%s_%lu\"\n-\f\n-/* OUTPUT OF UNINITIALIZED VARIABLES */\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-  asm_output_common (FILE, NAME, SIZE, ROUNDED);\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-  asm_output_local (FILE, NAME, SIZE, ROUNDED);\n-\f\n-/* OUTPUT AND GENERATION OF LABELS */\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \".global \"\n-\n-/* A C statement to output to the stdio stream any text necessary\n-   for declaring the name of an external symbol named name which\n-   is referenced in this compilation but not defined.  */\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)   \\\n-{\t\t\t\t\t\\\n-\tfprintf (FILE, \".extern \");\t\\\n-\tassemble_name (FILE, NAME);\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\\\n-}\n-/* A C statement to output on stream an assembler pseudo-op to\n-   declare a library function named external.  */\n-\n-#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)    \\\n-{\t\t\t\t\t\t\\\n-\tfprintf (FILE, \".extern \");\t\t\\\n-\tassemble_name (FILE, XSTR (FUN, 0));\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\\\n-}\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%lu\", PREFIX, (unsigned long)(NUM))\n-\n-\f\n-/* OUTPUT OF ASSEMBLER INSTRUCTIONS */\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"a0\", \"a0l\", \"a1\", \"a1l\", \"x\", \"y\", \"yl\", \"p\", \"pl\",  \\\n- \"r0\", \"r1\", \"r2\",  \"r3\", \"j\", \"k\", \"ybase\", \"pt\",     \\\n- \"ar0\", \"ar1\", \"ar2\", \"ar3\",                           \\\n- \"c0\", \"c1\", \"c2\", \"pr\", \"rb\",                         \\\n- \"*(0)\", \"*(1)\", \"*(2)\", \"*(3)\", \"*(4)\", \"*(5)\",       \\\n- \"*(6)\", \"*(7)\", \"*(8)\", \"*(9)\", \"*(10)\", \"*(11)\",     \\\n- \"*(12)\", \"*(13)\", \"*(14)\", \"*(15)\", \"*(16)\", \"*(17)\", \\\n- \"*(18)\", \"*(19)\", \"*(20)\", \"*(21)\", \"*(22)\", \"*(23)\", \\\n- \"*(24)\", \"*(25)\", \"*(26)\", \"*(27)\", \"*(28)\", \"*(29)\", \\\n- \"*(30)\", \"*(31)\" }\n-\n-#define HIMODE_REGISTER_NAMES \\\n-{\"a0\", \"a0\", \"a1\", \"a1\", \"x\", \"y\", \"y\", \"p\", \"p\",  \\\n- \"r0\", \"r1\", \"r2\",  \"r3\", \"j\", \"k\", \"ybase\", \"pt\",     \\\n- \"ar0\", \"ar1\", \"ar2\", \"ar3\",                           \\\n- \"c0\", \"c1\", \"c2\", \"pr\", \"rb\",                         \\\n- \"*(0)\", \"*(1)\", \"*(2)\", \"*(3)\", \"*(4)\", \"*(5)\",       \\\n- \"*(6)\", \"*(7)\", \"*(8)\", \"*(9)\", \"*(10)\", \"*(11)\",     \\\n- \"*(12)\", \"*(13)\", \"*(14)\", \"*(15)\", \"*(16)\", \"*(17)\", \\\n- \"*(18)\", \"*(19)\", \"*(20)\", \"*(21)\", \"*(22)\", \"*(23)\", \\\n- \"*(24)\", \"*(25)\", \"*(26)\", \"*(27)\", \"*(28)\", \"*(29)\", \\\n- \"*(30)\", \"*(31)\" }\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)  0\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-   \n-   DSP1610 extensions for operand codes:\n-\n-   %H - print lower 16 bits of constant\n-   %U - print upper 16 bits of constant\n-   %w - print low half of register (e.g 'a0l')\n-   %u - print upper half of register (e.g 'a0')\n-   %b - print high half of accumulator for F3 ALU instructions\n-   %h - print constant in decimal   */\n-\n-#define PRINT_OPERAND(FILE, X, CODE) print_operand(FILE, X, CODE)\n-\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address (FILE, ADDR)\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code since it is used only for profiling  */\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)    \\\n-  internal_error (\"profiling not implemented yet\");\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code since it is used only for profiling  */\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)     \\\n-  internal_error (\"profiling not implemented yet\"); \n-\f\n-/* OUTPUT OF DISPATCH TABLES */\n-\n-/* This macro should be provided on machines where the addresses in a dispatch\n-   table are relative to the table's own address.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\tint L%d-L%d\\n\", VALUE, REL)\n-\n-/* This macro should be provided on machines where the addresses in a dispatch\n-   table are absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\tint L%d\\n\", VALUE)\n-\n-/* ASSEMBLER COMMANDS FOR ALIGNMENT */\n-\n-/* This is how to output an assembler line that says to advance \n-   the location counter to a multiple of 2**LOG bytes. We should\n-   not have to do any alignment since the 1610 is a word machine.  */\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\n-\n-/* Define this macro if ASM_OUTPUT_SKIP should not be used in the text section\n-   because it fails to put zero1 in the bytes that are skipped.  */\n-#define ASM_NO_SKIP_IN_TEXT 1\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t%d * int 0\\n\", (int)(SIZE))\n-\n-/* CONTROLLING DEBUGGING INFORMATION FORMAT */\n-\n-#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n-\n-#define ASM_OUTPUT_DEF(asm_out_file, LABEL1, LABEL2) \\\n-         do {\t\t\t\t\t\t\\\n-\t fprintf (asm_out_file, \".alias \" ); \\\n-         ASM_OUTPUT_LABELREF(asm_out_file, LABEL1);  \\\n-\t fprintf (asm_out_file, \"=\" ); \\\n-         ASM_OUTPUT_LABELREF(asm_out_file, LABEL2); \\\n-\t fprintf (asm_out_file, \"\\n\" );\t\t\t\\\n-\t } while (0)\n-\n-\f\n-/* MISCELLANEOUS PARAMETERS */\n-\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE QImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 1\n-\n-/* Defining this macro causes the compiler to omit a sign-extend, zero-extend,\n-   or bitwise 'and' instruction that truncates the count of a shift operation\n-   to a width equal to the number of bits needed to represent the size of the\n-   object being shifted. Do not define this macro unless the truncation applies\n-   to both shift operations and bit-field operations (if any).  */\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* An alias for the machine mode used for pointers */\n-#define Pmode  QImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE  QImode\n-\n-#if !defined(__DATE__)\n-#define TARGET_VERSION fprintf (stderr, \" (%s)\", VERSION_INFO1)\n-#else\n-#define TARGET_VERSION fprintf (stderr, \" (%s, %s)\", VERSION_INFO1, __DATE__)\n-#endif\n-\n-#define VERSION_INFO1 \"Lucent DSP16xx C Cross Compiler, version 1.3.0b\"\n-\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* Define this so gcc does not output a call to __main, since we\n-   are not currently supporting c++.  */\n-#define INIT_SECTION_ASM_OP  1\n-"}, {"sha": "fffd2a9d9e0b9e6333ca2b945fafe4385094afd8", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "removed", "additions": 0, "deletions": 3049, "changes": 3049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "56c6342dc64675d91fed1431520d6b17f2ffbac4", "filename": "gcc/config/i370/README", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2FREADME?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,125 +0,0 @@\n-\n-This directory contains code for building a compiler for the\n-32-bit ESA/390 architecture.  It supports three different styles \n-of assembly:\n-\n--- MVS for use with the HLASM assembler\n--- Open Edition (USS Unix System Services) \n--- ELF/Linux for use with the binutils/gas GNU assembler.\n-\n-\n-Cross-compiling Hints\n----------------------\n-When building a cross-compiler on AIX, set the environment variable CC\n-and be sure to set the -ma and -qcpluscmt flags; i.e.\n-\n-   export CC=\"cc -ma -qcpluscmt\"\n-\n-do this *before* running configure, e.g.\n-\n-   configure --target=i370-ibm-linux --prefix=/where/to/install/usr\n-\n-The Objective-C and FORTRAN front ends don't build.  To avoid looking at\n-errors, do only \n-\n-   make LANGUAGES=c\n-\n-\n-OpenEdition Hints\n------------------\n-The shell script \"install\" is handy for users of OpenEdition.\n-\n-\n-The ELF ABI\n------------\n-This compiler, in conjunction with the gas/binutils assembler, defines\n-a defacto ELF-based ABI for the ESA/390 architecture.  Be warned: this \n-ABI has several major faults.  It should be fixed.  As it is fixed,\n-it is subject to change without warning.  You should not commit to major\n-software systems without further exploring and fixing these problems.\n-Here are some of the problems:\n-\n--- No support for shared libraries or dynamically loadable objects.\n-   This is because the compiler currently places address literals in \n-   the text section.  Although the GAS assembler supports a syntax for \n-   USING that will place address literals in the data section, this forces\n-   the use of two base registers, one for branches and one for the literal \n-   pool. Work is needed to redesign the function prologue, epilogue and the \n-   base register reloads to minimize the currently excessive use of reserved \n-   registers. \n-\n-   I beleive the best solution would be to add a toc or plt, and extending\n-   the meaning of the USING directive to encompass this.  This would \n-   allow the continued use of the human-readable and familiar practice\n-   of using =A() and =F'' to denote address literals, as opposed to more \n-   difficult jump-table notation.\n-\n--- the stackframe is almost twice as big as it needs to be.\n-\n--- currently, r15 is used to return 32-bit values.  Because this is the\n-   last register, it prevents 64-bit ints and small structures from being \n-   returned in registers, forcing return in memory.  It would be more\n-   efficient to use r14 to return 32-bit values, and r14+r15 to return\n-   64-bit values.\n-\n--- all arguments are currently passed in memory.  It would be more efficient \n-   to pass arguments in registers.\n-\n-\n-\n-\n-ChangeLog\n----------\n-Oct98-Dec98 -- add ELF back end; work on getting ABI more or less functional.\n-98.12.05 -- fix numerous MVC bugs\n-99.02.06 -- multiply insn sometimes not generated when needed.\n-         -- extendsidi bugs, bad literal values printed\n-         -- remove broken adddi subdi patterns\n-99.02.15 -- add clrstrsi pattern\n-         -- fix -O2 divide bug\n-99.03.04 -- base & index reg usage bugs\n-99.03.15 -- fixes for returning long longs and structs (struct value return)\n-99.03.29 -- fix handling & alignment of shorts\n-99.03.31 -- clobbered register 14 is not always clobbered\n-99.04.02 -- operand constraints for cmphi\n-99.04.07 -- function pointer fixes for call, call_value patterns,\n-            function pointers derefed once too often.\n-99.04.14 -- add pattern to print double-wide int\n-         -- check intval<4096 for misc operands\n-         -- add clrstrsi pattern\n-         -- movstrsi fixes\n-99.04.16 -- use r2 to pass args into r11 in subroutine call.\n-         -- fixes to movsi; some operand combinations impossible;\n-            rework constraints\n-         -- start work on forward jump optimization\n-         -- char alignment bug\n-99.04.25 -- add untyped_call pattern so that builtin_apply works\n-99.04.27 -- fixes to compare logical under mask\n-99.04.28 -- reg 2 is clobbered by calls\n-99.04.30 -- fix rare mulsi bug\n-99.04.30 -- add constraints so that all RS, SI, SS forms insns have valid\n-            addressing modes\n-99.04.30 -- major condition code fixes. The old code was just way off \n-            w.r.t. which insns set condition code, and the codes that\n-            were set.  The extent of this damage was unbeleivable.\n-99.05.01 -- restructuring of operand constraints on many patterns,\n-            many lead to invalid instructions being genned.\n-99.05.02 -- float pt fixes\n-         -- fix movdi issue bugs\n-99.05.03 -- fix divide insn; was dividing incorrectly\n-99.05.05 -- fix sign extension problems on andhi\n-         -- deprecate some constraints\n-99.05.06 -- add set_attr insn lengths; fix misc litpool sizes\n-         -- add notes about how unsigned jumps work (i.e. \n-            arithmetic vs. logical vs. signed vs unsigned).\n-99.05.11 -- use insn length to predict forward branch target;\n-            use relative branchining where possible,\n-            remove un-needed base register reload.\n-99.05.15 -- fix movstrsi, clrstrsi, cmpstrsi patterns as per conversation \n-            w/ Richard Henderson\n-\n-\n-\n-\n-\n-"}, {"sha": "fe39191cfa294103639ca3a1632bc3fa8a674ca0", "filename": "gcc/config/i370/i370-c.c", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370-c.c?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,64 +0,0 @@\n-/* Subroutines for the C front end for System/370.\n-   Copyright (C) 1989, 1993, 1995, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org) \n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"toplev.h\"\n-#include \"cpplib.h\"\n-#include \"c-pragma.h\"\n-#include \"tm_p.h\"\n-\n-#ifdef TARGET_HLASM\n-\n-/* #pragma map (name, alias) -\n-   In this implementation both name and alias are required to be\n-   identifiers.  The older code seemed to be more permissive.  Can\n-   anyone clarify?  */\n-\n-void\n-i370_pr_map (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree name, alias, x;\n-\n-  if (c_lex (&x)        == CPP_OPEN_PAREN\n-      && c_lex (&name)  == CPP_NAME\n-      && c_lex (&x)     == CPP_COMMA\n-      && c_lex (&alias) == CPP_NAME\n-      && c_lex (&x)     == CPP_CLOSE_PAREN)\n-    {\n-      if (c_lex (&x) != CPP_EOF)\n-\twarning (\"junk at end of #pragma map\");\n-\n-      mvs_add_alias (IDENTIFIER_POINTER (name), IDENTIFIER_POINTER (alias), 1);\n-      return;\n-    }\n-\n-  warning (\"malformed #pragma map, ignored\");\n-}\n-\n-#endif"}, {"sha": "666db0b7aa601bcf78890bfc079009cf9f14e4de", "filename": "gcc/config/i370/i370-protos.h", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370-protos.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,55 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_I370_PROTOS_H\n-#define GCC_I370_PROTOS_H\n-\n-extern void override_options (void);\n-\n-#ifdef RTX_CODE\n-extern int i370_branch_dest (rtx);\n-extern int i370_branch_length (rtx);\n-extern int i370_short_branch (rtx);\n-extern int s_operand (rtx, enum machine_mode);\n-extern int r_or_s_operand (rtx, enum machine_mode);\n-extern int unsigned_jump_follows_p (rtx);\n-#endif /* RTX_CODE */\n-\n-#ifdef TREE_CODE\n-extern int handle_pragma (int (*)(void), void (*)(int), const char *);\n-#endif /* TREE_CODE */\n-\n-extern void mvs_add_label (int);\n-extern int mvs_check_label (int);\n-extern int mvs_check_page (FILE *, int, int);\n-extern int mvs_function_check (const char *);\n-extern void mvs_add_alias (const char *, const char *, int);\n-extern int mvs_need_alias (const char *);\n-extern int mvs_get_alias (const char *, char *);\n-extern int mvs_check_alias (const char *, char *);\n-extern void check_label_emit (void);\n-extern void mvs_free_label_list (void);\n-\n-extern void i370_pr_map (struct cpp_reader *);\n-\n-#endif /* ! GCC_I370_PROTOS_H */"}, {"sha": "2cfe4fe3269013f889dad8d0c4c01b2c5f545723", "filename": "gcc/config/i370/i370.c", "status": "removed", "additions": 0, "deletions": 1514, "changes": 1514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,1514 +0,0 @@\n-/* Subroutines for insn-output.c for System/370.\n-   Copyright (C) 1989, 1993, 1995, 1997, 1998, 1999, 2000, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org) \n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"flags.h\"\n-#include \"recog.h\"\n-#include \"toplev.h\"\n-#include \"cpplib.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-extern FILE *asm_out_file;\n-\n-/* Label node.  This structure is used to keep track of labels \n-      on the various pages in the current routine.\n-   The label_id is the numeric ID of the label,\n-   The label_page is the page on which it actually appears,\n-   The first_ref_page is the page on which the true first ref appears.\n-   The label_addr is an estimate of its location in the current routine,\n-   The label_first & last_ref are estimates of where the earliest and\n-      latest references to this label occur.  */\n-\n-typedef struct label_node\n-  {\n-    struct label_node *label_next;\n-    int label_id;\n-    int label_page;\n-    int first_ref_page;\n-\n-    int label_addr;\n-    int label_first_ref;\n-    int label_last_ref;\n-  }\n-label_node_t;\n-\n-/* Is 1 when a label has been generated and the base register must be reloaded.  */\n-int mvs_need_base_reload = 0;\n-\n-/* Current function starting base page.  */\n-int function_base_page;\n-\n-/* Length of the current page code.  */\n-int mvs_page_code;\n-\n-/* Length of the current page literals.  */\n-int mvs_page_lit;\n-\n-/* Current function name.  */\n-char *mvs_function_name = 0;\n-\n-/* Current function name length.  */\n-size_t mvs_function_name_length = 0;\n-\n-/* Page number for multi-page functions.  */\n-int mvs_page_num = 0;\n-\n-/* Label node list anchor.  */\n-static label_node_t *label_anchor = 0;\n-\n-/* Label node free list anchor.  */\n-static label_node_t *free_anchor = 0;\n-\n-/* Assembler source file descriptor.  */\n-static FILE *assembler_source = 0;\n-\n-static label_node_t * mvs_get_label (int);\n-static void i370_label_scan (void);\n-#ifdef TARGET_HLASM\n-static bool i370_hlasm_assemble_integer (rtx, unsigned int, int);\n-static void i370_globalize_label (FILE *, const char *);\n-#endif\n-static void i370_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void i370_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void i370_file_start (void);\n-static void i370_file_end (void);\n-\n-#ifdef LONGEXTERNAL\n-static int mvs_hash_alias (const char *);\n-#endif\n-static void i370_internal_label (FILE *, const char *, unsigned long);\n-static bool i370_rtx_costs (rtx, int, int, int *);\n-\n-/* ===================================================== */\n-/* defines and functions specific to the HLASM assembler */\n-#ifdef TARGET_HLASM\n-\n-#define MVS_HASH_PRIME 999983\n-#if HOST_CHARSET == HOST_CHARSET_EBCDIC\n-#define MVS_SET_SIZE 256\n-#else\n-#define MVS_SET_SIZE 128\n-#endif\n-\n-#ifndef MAX_MVS_LABEL_SIZE\n-#define MAX_MVS_LABEL_SIZE 8\n-#endif\n-\n-#define MAX_LONG_LABEL_SIZE 255\n-\n-/* Alias node, this structure is used to keep track of aliases to external\n-   variables. The IBM assembler allows an alias to an external name \n-   that is longer that 8 characters; but only once per assembly.\n-   Also, this structure stores the #pragma map info.  */\n-typedef struct alias_node\n-  {\n-    struct alias_node *alias_next;\n-    int  alias_emitted;\n-    char alias_name [MAX_MVS_LABEL_SIZE + 1];\n-    char real_name [MAX_LONG_LABEL_SIZE + 1];\n-  }\n-alias_node_t;\n-\n-/* Alias node list anchor.  */\n-static alias_node_t *alias_anchor = 0;\n-\n-/* Define the length of the internal MVS function table.  */\n-#define MVS_FUNCTION_TABLE_LENGTH 32\n-\n-/* C/370 internal function table.  These functions use non-standard linkage\n-   and must handled in a special manner.  */\n-static const char *const mvs_function_table[MVS_FUNCTION_TABLE_LENGTH] =\n-{\n-#if HOST_CHARSET == HOST_CHARSET_EBCDIC /* Changed for EBCDIC collating sequence */\n-   \"ceil\",     \"edc_acos\", \"edc_asin\", \"edc_atan\", \"edc_ata2\", \"edc_cos\",\n-   \"edc_cosh\", \"edc_erf\",  \"edc_erfc\", \"edc_exp\",  \"edc_gamm\", \"edc_lg10\",\n-   \"edc_log\",  \"edc_sin\",  \"edc_sinh\", \"edc_sqrt\", \"edc_tan\",  \"edc_tanh\",\n-   \"fabs\",     \"floor\",    \"fmod\",     \"frexp\",    \"hypot\",    \"jn\",\n-   \"j0\",       \"j1\",       \"ldexp\",    \"modf\",     \"pow\",      \"yn\",\n-   \"y0\",       \"y1\"\n-#else\n-   \"ceil\",     \"edc_acos\", \"edc_asin\", \"edc_ata2\", \"edc_atan\", \"edc_cos\",\n-   \"edc_cosh\", \"edc_erf\",  \"edc_erfc\", \"edc_exp\",  \"edc_gamm\", \"edc_lg10\",\n-   \"edc_log\",  \"edc_sin\",  \"edc_sinh\", \"edc_sqrt\", \"edc_tan\",  \"edc_tanh\",\n-   \"fabs\",     \"floor\",    \"fmod\",     \"frexp\",    \"hypot\",    \"j0\",\n-   \"j1\",       \"jn\",       \"ldexp\",    \"modf\",     \"pow\",      \"y0\",\n-   \"y1\",       \"yn\"\n-#endif\n-};\n-\n-#endif /* TARGET_HLASM */\n-/* ===================================================== */\n-\n-\f\n-/* Initialize the GCC target structure.  */\n-#ifdef TARGET_HLASM\n-#undef TARGET_ASM_BYTE_OP\n-#define TARGET_ASM_BYTE_OP NULL\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP NULL\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP NULL\n-#undef TARGET_ASM_INTEGER\n-#define TARGET_ASM_INTEGER i370_hlasm_assemble_integer\n-#undef TARGET_ASM_GLOBALIZE_LABEL\n-#define TARGET_ASM_GLOBALIZE_LABEL i370_globalize_label\n-#endif\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE i370_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE i370_output_function_epilogue\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START i370_file_start\n-#undef TARGET_ASM_FILE_END\n-#define TARGET_ASM_FILE_END i370_file_end\n-#undef TARGET_ASM_INTERNAL_LABEL\n-#define  TARGET_ASM_INTERNAL_LABEL i370_internal_label\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS i370_rtx_costs\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Set global variables as needed for the options enabled.  */\n-\n-void\n-override_options ()\n-{\n-  /* We're 370 floating point, not IEEE floating point.  */\n-  memset (real_format_for_mode, 0, sizeof real_format_for_mode);\n-  REAL_MODE_FORMAT (SFmode) = &i370_single_format;\n-  REAL_MODE_FORMAT (DFmode) = &i370_double_format;\n-}\n-\n-/* ===================================================== */\n-/* The following three routines are used to determine whther \n-   forward branch is on this page, or is a far jump.  We use\n-   the \"length\" attr on an insn [(set_atter \"length\" \"4\")]\n-   to store the largest possible code length that insn\n-   could have.  This gives us a hint of the address of a\n-   branch destination, and from that, we can work out \n-   the length of the jump, and whether its on page or not. \n- */\n-\n-/* Return the destination address of a branch.  */\n-\n-int\n-i370_branch_dest (branch)\n-     rtx branch;\n-{\n-  rtx dest = SET_SRC (PATTERN (branch));\n-  int dest_uid;\n-  int dest_addr;\n-\n-  /* first, compute the estimated address of the branch target */\n-  if (GET_CODE (dest) == IF_THEN_ELSE)\n-    dest = XEXP (dest, 1);\n-  dest = XEXP (dest, 0);\n-  dest_uid = INSN_UID (dest);\n-  dest_addr = INSN_ADDRESSES (dest_uid);\n-\n-  /* next, record the address of this insn as the true addr of first ref */\n-  {\n-     label_node_t *lp;\n-     rtx label = JUMP_LABEL (branch);\n-     int labelno = CODE_LABEL_NUMBER (label);\n-\n-     if (!label || CODE_LABEL != GET_CODE (label)) abort ();\n-\n-     lp = mvs_get_label (labelno);\n-     if (-1 == lp -> first_ref_page) lp->first_ref_page = mvs_page_num;\n-  }\n-  return dest_addr;\n-}\n-\n-int\n-i370_branch_length (insn)\n-     rtx insn;\n-{\n-  int here, there;\n-  here = INSN_ADDRESSES (INSN_UID (insn));\n-  there = i370_branch_dest (insn);\n-  return (there - here);\n-}\n-\n-\n-int\n-i370_short_branch (insn)\n-     rtx insn;\n-{\n-  int base_offset;\n-\n-  base_offset = i370_branch_length(insn);\n-  if (0 > base_offset) \n-    {\n-      base_offset += mvs_page_code;\n-    } \n-  else \n-    {\n-      /* avoid bumping into lit pool; use 2x to estimate max possible lits */\n-      base_offset *= 2;\n-      base_offset += mvs_page_code + mvs_page_lit;\n-    }\n-  \n-  /* make a conservative estimate of room left on page */\n-  if ((4060 >base_offset) && ( 0 < base_offset)) return 1;\n-  return 0;\n-}\n-\n-/* The i370_label_scan() routine is supposed to loop over\n-   all labels and label references in a compilation unit,\n-   and determine whether all label refs appear on the same \n-   code page as the label. If they do, then we can avoid \n-   a reload of the base register for that label.\n-  \n-   Note that the instruction addresses used here are only \n-   approximate, and make the sizes of the jumps appear\n-   farther apart then they will actually be.  This makes \n-   this code far more conservative than it needs to be.\n- */\n-\n-#define I370_RECORD_LABEL_REF(label,addr) {\t\t\t\t\\\n-\tlabel_node_t *lp;\t\t\t\t\t\t\\\n-\tint labelno = CODE_LABEL_NUMBER (label);\t\t\t\\\n-\tlp = mvs_get_label (labelno);\t\t\t\t\t\\\n-\tif (addr < lp -> label_first_ref) lp->label_first_ref = addr;\t\\\n-\tif (addr > lp -> label_last_ref) lp->label_last_ref = addr;\t\\\n-}\n-\n-static void \n-i370_label_scan () \n-{\n-   rtx insn;\n-   label_node_t *lp;\n-   int tablejump_offset = 0;\n-\n-   for (insn = get_insns(); insn; insn = NEXT_INSN(insn))\n-     {\n-       int here = INSN_ADDRESSES (INSN_UID (insn));\n-       enum rtx_code code = GET_CODE(insn);\n-\n-       /* ??? adjust for tables embedded in the .text section that\n-        * the compiler didn't take into account */\n-       here += tablejump_offset;\n-       INSN_ADDRESSES (INSN_UID (insn)) = here;\n-\n-       /* check to see if this insn is a label ...  */\n-       if (CODE_LABEL == code)\n-         {\n-           int labelno = CODE_LABEL_NUMBER (insn);\n-\n-           lp = mvs_get_label (labelno);\n-           lp -> label_addr = here;\n-#if 0\n-           /* Supposedly, labels are supposed to have circular\n-              lists of label-refs that reference them, \n-              setup in flow.c, but this does not appear to be the case.  */\n-           rtx labelref = LABEL_REFS (insn);\n-           rtx ref = labelref;\n-           do \n-             {\n-               rtx linsn = CONTAINING_INSN(ref);\n-               ref =  LABEL_NEXTREF(ref);\n-             } while (ref && (ref != labelref));\n-#endif\n-         }\n-       else\n-       if (JUMP_INSN == code)\n-         {\n-           rtx label = JUMP_LABEL (insn);\n-\n-           /* If there is no label for this jump, then this\n-              had better be a ADDR_VEC or an ADDR_DIFF_VEC\n-              and there had better be a vector of labels.  */\n-           if (!label) \n-             {\n-               int j;\n-               rtx body = PATTERN (insn);\n-               if (ADDR_VEC == GET_CODE(body)) \n-                 {\n-                    for (j=0; j < XVECLEN (body, 0); j++)\n-                      {\n-                         rtx lref = XVECEXP (body, 0, j);\n-                         if (LABEL_REF != GET_CODE (lref)) abort ();\n-                         label = XEXP (lref,0);\n-                         if (CODE_LABEL != GET_CODE (label)) abort ();\n-                         tablejump_offset += 4;\n-                         here += 4;\n-                         I370_RECORD_LABEL_REF(label,here);\n-                      }\n-                    /* finished with the vector go do next insn */\n-                    continue;\n-                 }\n-               else\n-               if (ADDR_DIFF_VEC == GET_CODE(body))\n-                 {\n-/* XXX hack alert.\n-   Right now, we leave this as a no-op, but strictly speaking,\n-   this is incorrect.  It is possible that a table-jump\n-   driven off of a relative address could take us off-page,\n-   to a place where we need to reload the base reg.  So really,\n-   we need to examing both labels, and compare thier values\n-   to the current basereg value.\n-  \n-   More generally, this brings up a troubling issue overall:\n-   what happens if a tablejump is split across two pages? I do \n-   not beleive that this case is handled correctly at all, and\n-   can only lead to horrible results if this were to occur.\n-  \n-   However, the current situation is not any worse than it was \n-   last week, and so we punt for now.  */\n-\n-                    debug_rtx (insn);\n-                    for (j=0; j < XVECLEN (body, 0); j++)\n-                      {\n-                      }\n-                    /* finished with the vector go do next insn */\n-                    continue;\n-                 }\n-               else \n-                 {\n-/* XXX hack alert.\n-   Compiling the exception handling (L_eh) in libgcc2.a will trip\n-   up right here, with something that looks like\n-   (set (pc) (mem:SI (plus:SI (reg/v:SI 1 r1) (const_int 4))))\n-      {indirect_jump} \n-   I'm not sure of what leads up to this, but it looks like\n-   the makings of a long jump which will surely get us into trouble\n-   because the base & page registers don't get reloaded.  For now\n-   I'm not sure of what to do ... again we punt ... we are not worse\n-   off than yesterday.  */\n-\n-                    /* print_rtl_single (stdout, insn); */\n-                    debug_rtx (insn);\n-                    /* abort(); */\n-                    continue;\n-                 }\n-            }\n-          else\n-            {\n-              /* At this point, this jump_insn had better be a plain-old\n-                 ordinary one, grap the label id and go */\n-              if (CODE_LABEL != GET_CODE (label)) abort ();\n-              I370_RECORD_LABEL_REF(label,here);\n-            }\n-        }\n-\n-      /* Sometimes, we take addresses of labels and use them\n-         as instruction operands ... these show up as REG_NOTES */\n-      else\n-      if (INSN == code)\n-       {\n-         if ('i' == GET_RTX_CLASS (code)) \n-           {\n-              rtx note;\n-              for (note = REG_NOTES (insn); note;  note = XEXP(note,1))\n-                {\n-                   if (REG_LABEL == REG_NOTE_KIND(note))\n-                     {\n-                        rtx label = XEXP (note,0);\n-                        if (!label || CODE_LABEL != GET_CODE (label)) abort ();\n-\n-                        I370_RECORD_LABEL_REF(label,here);\n-                     }\n-                }\n-           }\n-       }\n-   }\n-}\n-\n-/* ===================================================== */\n-\n-/* Emit reload of base register if indicated.  This is to eliminate multiple\n-   reloads when several labels are generated pointing to the same place\n-   in the code.  \n-\n-   The page table is written at the end of the function. \n-   The entries in the page table look like\n-     .LPGT0:          // PGT0 EQU *\n-     .long .LPG0      // DC A(PG0)\n-     .long .LPG1      // DC A(PG1)\n-  while the prologue generates\n-      L       r4,=A(.LPGT0)\n-\n-  Note that this paging scheme breaks down if a single subroutine \n-  has more than about 10MB of code in it ... as long as humans write\n-  code, this shouldn't be a problem ...\n- */\n-\n-void\n-check_label_emit ()\n-{\n-  if (mvs_need_base_reload)\n-    {\n-      mvs_need_base_reload = 0;\n-\n-      mvs_page_code += 4;\n-      fprintf (assembler_source, \"\\tL\\t%d,%d(,%d)\\n\",\n-\t  BASE_REGISTER, (mvs_page_num - function_base_page) * 4,\n-\t  PAGE_REGISTER);\n-    }\n-}\n-\n-/* Add the label to the current page label list.  If a free element is available\n-   it will be used for the new label.  Otherwise, a label element will be\n-   allocated from memory.\n-   ID is the label number of the label being added to the list.  */\n-\n-static label_node_t *\n-mvs_get_label (id)\n-     int id;\n-{\n-  label_node_t *lp;\n-\n-  /* first, lets see if we already go one, if so, use that.  */\n-  for (lp = label_anchor; lp; lp = lp->label_next)\n-    {\n-      if (lp->label_id == id) return lp;\n-    }\n-\n-  /* not found, get a new one */\n-  if (free_anchor)\n-    {\n-      lp = free_anchor;\n-      free_anchor = lp->label_next;\n-    }\n-  else\n-    {\n-      lp = (label_node_t *) xmalloc (sizeof (label_node_t));\n-    }\n-\n-  /* initialize for new label */\n-  lp->label_id = id;\n-  lp->label_page = -1;\n-  lp->label_next = label_anchor;\n-  lp->label_first_ref = 2000123123;\n-  lp->label_last_ref = -1;\n-  lp->label_addr = -1;\n-  lp->first_ref_page = -1;\n-  label_anchor = lp;\n-\n-  return lp;\n-}\n-\n-void\n-mvs_add_label (id)\n-     int id;\n-{\n-  label_node_t *lp;\n-  int fwd_distance;\n-\n-  lp = mvs_get_label (id);\n-  lp->label_page = mvs_page_num;\n-\n-  /* OK, we just saw the label.  Determine if this label\n-   * needs a reload of the base register */\n-  if ((-1 != lp->first_ref_page) && \n-      (lp->first_ref_page != mvs_page_num)) \n-    {\n-      /* Yep; the first label_ref was on a different page.  */\n-      mvs_need_base_reload ++;\n-      return;\n-    }\n-\n-  /* Hmm.  Try to see if the estimated address of the last\n-     label_ref is on the current page.  If it is, then we\n-     don't need a base reg reload.  Note that this estimate\n-     is very conservatively handled; we'll tend to have \n-     a good bit more reloads than actually needed.  Someday,\n-     we should tighten the estimates (which are driven by\n-     the (set_att \"length\") insn attibute.\n-    \n-     Currently, we estimate that number of page literals \n-     same as number of insns, which is a vast overestimate,\n-     esp that the estimate of each insn size is its max size.  */\n-\n-  /* if latest ref comes before label, we are clear */\n-  if (lp->label_last_ref < lp->label_addr) return;\n-\n-  fwd_distance = lp->label_last_ref - lp->label_addr;\n-\n-  if (mvs_page_code + 2 * fwd_distance + mvs_page_lit < 4060) return;\n-\n-  mvs_need_base_reload ++;\n-}\n-\n-/* Check to see if the label is in the list and in the current\n-   page.  If not found, we have to make worst case assumption \n-   that label will be on a different page, and thus will have to\n-   generate a load and branch on register.  This is rather\n-   ugly for forward-jumps, but what can we do? For backward\n-   jumps on the same page we can branch directly to address.\n-   ID is the label number of the label being checked.  */\n-\n-int\n-mvs_check_label (id)\n-     int id;\n-{\n-  label_node_t *lp;\n-\n-  for (lp = label_anchor; lp; lp = lp->label_next)\n-    {\n-      if (lp->label_id == id) \n-        {\n-          if (lp->label_page == mvs_page_num) \n-            {\n-               return 1;\n-            } \n-          else \n-            {\n-\t       return 0;\n-            } \n-        }\n-    }\n-  return 0;\n-}\n-\n-/* Get the page on which the label sits.  This will be used to \n-   determine is a register reload is really needed.  */\n-\n-#if 0\n-int\n-mvs_get_label_page(int id)\n-{\n-  label_node_t *lp;\n-\n-  for (lp = label_anchor; lp; lp = lp->label_next)\n-    {\n-      if (lp->label_id == id)\n-\treturn lp->label_page;\n-    }\n-  return -1;\n-}\n-#endif\n-\n-/* The label list for the current page freed by linking the list onto the free\n-   label element chain.  */\n-\n-void\n-mvs_free_label_list ()\n-{\n-\n-  if (label_anchor)\n-    {\n-      label_node_t *last_lp = label_anchor;\n-      while (last_lp->label_next) last_lp = last_lp->label_next;\n-      last_lp->label_next = free_anchor;\n-      free_anchor = label_anchor;\n-    }\n-  label_anchor = 0;\n-}\n-\n-/* ====================================================================== */\n-/* If the page size limit is reached a new code page is started, and the base\n-   register is set to it.  This page break point is counted conservatively,\n-   most literals that have the same value are collapsed by the assembler.\n-   True is returned when a new page is started.\n-   FILE is the assembler output file descriptor.\n-   CODE is the length, in bytes, of the instruction to be emitted.\n-   LIT is the length of the literal to be emitted.  */\n-\n-#ifdef TARGET_HLASM\n-int\n-mvs_check_page (file, code, lit)\n-     FILE *file;\n-     int code, lit;\n-{\n-  if (file)\n-    assembler_source = file;\n-\n-  if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)\n-    {\n-      fprintf (assembler_source, \"\\tB\\tPGE%d\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\tDS\\t0F\\n\");\n-      fprintf (assembler_source, \"\\tLTORG\\n\");\n-      fprintf (assembler_source, \"\\tDS\\t0F\\n\");\n-      fprintf (assembler_source, \"PGE%d\\tEQU\\t*\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\tDROP\\t%d\\n\", BASE_REGISTER);\n-      mvs_page_num++;\n-      /* Safe to use BASR not BALR, since we are\n-       * not switching addressing mode here ...  */\n-      fprintf (assembler_source, \"\\tBASR\\t%d,0\\n\", BASE_REGISTER);\n-      fprintf (assembler_source, \"PG%d\\tEQU\\t*\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n-      mvs_page_code = code;\n-      mvs_page_lit = lit;\n-      return 1;\n-    }\n-  mvs_page_code += code;\n-  mvs_page_lit += lit;\n-  return 0;\n-}\n-#endif /* TARGET_HLASM */\n-\n-\n-#ifdef TARGET_ELF_ABI\n-int\n-mvs_check_page (file, code, lit)\n-     FILE *file;\n-     int code, lit;\n-{\n-  if (file)\n-    assembler_source = file;\n-\n-  if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)\n-    {\n-      /* hop past the literal pool */\n-      fprintf (assembler_source, \"\\tB\\t.LPGE%d\\n\", mvs_page_num);\n-\n-      /* dump the literal pool. The .baligns are optional, since \n-       * ltorg will align to the size of the largest literal \n-       * (which is possibly 8 bytes) */\n-      fprintf (assembler_source, \"\\t.balign\\t4\\n\");\n-      fprintf (assembler_source, \"\\t.LTORG\\n\");\n-      fprintf (assembler_source, \"\\t.balign\\t4\\n\");\n-\n-      /* we continue execution here ...  */\n-      fprintf (assembler_source, \".LPGE%d:\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\t.DROP\\t%d\\n\", BASE_REGISTER);\n-      mvs_page_num++;\n-\n-      /* BASR puts the contents of the PSW into r3\n-       * that is, r3 will be loaded with the address of \".\" */\n-      fprintf (assembler_source, \"\\tBASR\\tr%d,0\\n\", BASE_REGISTER);\n-      fprintf (assembler_source, \".LPG%d:\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\t.USING\\t.,r%d\\n\", BASE_REGISTER);\n-      mvs_page_code = code;\n-      mvs_page_lit = lit;\n-      return 1;\n-    }\n-  mvs_page_code += code;\n-  mvs_page_lit += lit;\n-  return 0;\n-}\n-#endif /* TARGET_ELF_ABI */\n-\n-/* ===================================================== */\n-/* defines and functions specific to the HLASM assembler */\n-#ifdef TARGET_HLASM\n-\n-/* Check for C/370 runtime function, they don't use standard calling\n-   conventions.  True is returned if the function is in the table.\n-   NAME is the name of the current function.  */\n-\n-int\n-mvs_function_check (name)\n-     const char *name;\n-{\n-  int lower, middle, upper;\n-  int i;\n-\n-  lower = 0;\n-  upper = MVS_FUNCTION_TABLE_LENGTH - 1;\n-  while (lower <= upper)\n-    {\n-      middle = (lower + upper) / 2;\n-      i = strcmp (name, mvs_function_table[middle]);\n-      if (i == 0)\n-\treturn 1;\n-      if (i < 0)\n-\tupper = middle - 1;\n-      else\n-\tlower = middle + 1;\n-    }\n-  return 0;\n-}\n-\n-/* Generate a hash for a given key.  */\n-\n-#ifdef LONGEXTERNAL\n-static int\n-mvs_hash_alias (key)\n-     const char *key;\n-{\n-  int h;\n-  int i;\n-  int l = strlen (key);\n-\n-  h = key[0];\n-  for (i = 1; i < l; i++)\n-    h = ((h * MVS_SET_SIZE) + key[i]) % MVS_HASH_PRIME;\n-  return (h);\n-}\n-#endif\n-\n-/* Add the alias to the current alias list.  */\n-\n-void\n-mvs_add_alias (realname, aliasname, emitted)\n-     const char *realname;\n-     const char *aliasname;\n-     int   emitted;\n-{\n-  alias_node_t *ap;\n-\n-  ap = (alias_node_t *) xmalloc (sizeof (alias_node_t));\n-  if (strlen (realname) > MAX_LONG_LABEL_SIZE)\n-    {\n-      warning (\"real name is too long - alias ignored\");\n-      return;\n-    }\n-  if (strlen (aliasname) > MAX_MVS_LABEL_SIZE)\n-    {\n-      warning (\"alias name is too long - alias ignored\");\n-      return;\n-    }\n-      \n-  strcpy (ap->real_name, realname);\n-  strcpy (ap->alias_name, aliasname);\n-  ap->alias_emitted = emitted;\n-  ap->alias_next = alias_anchor;\n-  alias_anchor = ap;\n-}\n-\n-/* Check to see if the name needs aliasing. ie. the name is either:\n-     1. Longer than 8 characters\n-     2. Contains an underscore\n-     3. Is mixed case */\n-\n-int\n-mvs_need_alias (realname)\n-      const char *realname;\n-{\n-   int i, j = strlen (realname);\n-\n-   if (mvs_function_check (realname))\n-     return 0;\n-#if 0\n-   if (!strcmp (realname, \"gccmain\"))\n-     return 0;\n-   if (!strcmp (realname, \"main\"))\n-     return 0;\n-#endif\n-   if (j > MAX_MVS_LABEL_SIZE)\n-     return 1;\n-   if (strchr (realname, '_') != 0)\n-     return 1;\n-   if (ISUPPER (realname[0]))\n-     {\n-       for (i = 1; i < j; i++)\n-\t {\n-\t   if (ISLOWER (realname[i]))\n-\t     return 1;\n-\t }\n-     }\n-   else\n-     {\n-       for (i = 1; i < j; i++)\n-         {\n-\t   if (ISUPPER (realname[i]))\n-\t     return 1;\n-\t }\n-     }\n-\n-   return 0;\n-}\n-\n-/* Get the alias from the list. \n-   If 1 is returned then it's in the alias list, 0 if it was not */\n-\n-int\n-mvs_get_alias (realname, aliasname)\n-     const char *realname;\n-     char *aliasname;\n-{\n-#ifdef LONGEXTERNAL\n-  alias_node_t *ap;\n-\n-  for (ap = alias_anchor; ap; ap = ap->alias_next)\n-    {\n-      if (!strcmp (ap->real_name, realname))\n-\t{\n-\t  strcpy (aliasname, ap->alias_name);\n-\t  return 1;\n-\t}\n-    }\n-  if (mvs_need_alias (realname))\n-    {\n-      char c1, c2;\n-\n-      c1 = realname[0];\n-      c2 = realname[1];\n-      if (ISLOWER (c1)) c1 = TOUPPER (c1);\n-      else if (c1 == '_') c1 = 'A';\n-      if (ISLOWER (c2)) c2 = TOUPPER (c2);\n-      else if (c2 == '_' || c2 == '\\0') c2 = '#';\n-\n-      sprintf (aliasname, \"%c%c%06d\", c1, c2, mvs_hash_alias (realname));\n-      mvs_add_alias (realname, aliasname, 0);\n-      return 1;\n-    }\n-#else\n-  if (strlen (realname) > MAX_MVS_LABEL_SIZE)\n-    {\n-      strncpy (aliasname, realname, MAX_MVS_LABEL_SIZE);\n-      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n-      return 1;\n-    }\n-#endif\n-  return 0;\n-}\n-\n-/* Check to see if the alias is in the list. \n-   If 1 is returned then it's in the alias list, 2 it was emitted  */\n-\n-int\n-mvs_check_alias (realname, aliasname)\n-     const char *realname;\n-     char *aliasname;\n-{\n-#ifdef LONGEXTERNAL\n-  alias_node_t *ap;\n-\n-  for (ap = alias_anchor; ap; ap = ap->alias_next)\n-    {\n-      if (!strcmp (ap->real_name, realname))\n-\t{\n-\t  int rc = (ap->alias_emitted == 1) ? 1 : 2; \n-\t  strcpy (aliasname, ap->alias_name);\n-\t  ap->alias_emitted = 1; \n-\t  return rc;\n-\t}\n-    }\n-  if (mvs_need_alias (realname))\n-    {\n-      char c1, c2;\n-\n-      c1 = realname[0];\n-      c2 = realname[1];\n-      if (ISLOWER (c1)) c1 = TOUPPER (c1);\n-      else if (c1 == '_') c1 = 'A';\n-      if (ISLOWER (c2)) c2 = TOUPPER (c2);\n-      else if (c2 == '_' || c2 == '\\0') c2 = '#';\n-\n-      sprintf (aliasname, \"%c%c%06d\", c1, c2, mvs_hash_alias (realname));\n-      mvs_add_alias (realname, aliasname, 0);\n-      alias_anchor->alias_emitted = 1;\n-      return 2;\n-    }\n-#else\n-  if (strlen (realname) > MAX_MVS_LABEL_SIZE)\n-    {\n-      strncpy (aliasname, realname, MAX_MVS_LABEL_SIZE);\n-      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n-      return 1;\n-    }\n-#endif\n-  return 0;\n-}\n-\n-/* defines and functions specific to the HLASM assembler */\n-#endif /* TARGET_HLASM */\n-/* ===================================================== */\n-/* ===================================================== */\n-/* defines and functions specific to the gas assembler */\n-#ifdef TARGET_ELF_ABI\n-\n-/* Check for C/370 runtime function, they don't use standard calling\n-   conventions.  True is returned if the function is in the table.\n-   NAME is the name of the current function.  */\n-/* no special calling conventions (yet ??) */\n-\n-int\n-mvs_function_check (name)\n-     const char *name ATTRIBUTE_UNUSED;\n-{\n-   return 0;\n-}\n-\n-#endif /* TARGET_ELF_ABI */\n-/* ===================================================== */\n-\n-\n-/* Return 1 if OP is a valid S operand for an RS, SI or SS type instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-s_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  extern int volatile_ok;\n-  register enum rtx_code code = GET_CODE (op);\n-\n-  if (CONSTANT_ADDRESS_P (op))\n-    return 1;\n-  if (mode == VOIDmode || GET_MODE (op) != mode)\n-    return 0;\n-  if (code == MEM)\n-    {\n-      register rtx x = XEXP (op, 0);\n-\n-      if (!volatile_ok && op->volatil)\n-\treturn 0;\n-      if (REG_P (x) && REG_OK_FOR_BASE_P (x))\n-\treturn 1;\n-      if (GET_CODE (x) == PLUS\n-\t  && REG_P (XEXP (x, 0)) && REG_OK_FOR_BASE_P (XEXP (x, 0))\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && (unsigned) INTVAL (XEXP (x, 1)) < 4096)\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-\n-/* Return 1 if OP is a valid R or S operand for an RS, SI or SS type\n-   instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-r_or_s_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  extern int volatile_ok;\n-  register enum rtx_code code = GET_CODE (op);\n-\n-  if (CONSTANT_ADDRESS_P (op))\n-    return 1;\n-  if (mode == VOIDmode || GET_MODE (op) != mode)\n-    return 0;\n-  if (code == REG)\n-    return 1;\n-  else if (code == MEM)\n-    {\n-      register rtx x = XEXP (op, 0);\n-\n-      if (!volatile_ok && op->volatil)\n-\treturn 0;\n-      if (REG_P (x) && REG_OK_FOR_BASE_P (x))\n-\treturn 1;\n-      if (GET_CODE (x) == PLUS\n-\t  && REG_P (XEXP (x, 0)) && REG_OK_FOR_BASE_P (XEXP (x, 0))\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && (unsigned) INTVAL (XEXP (x, 1)) < 4096)\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-\n-/* Some remarks about unsigned_jump_follows_p():\n-   gcc is built around the assumption that branches are signed\n-   or unsigned, whereas the 370 doesn't care; its the compares that\n-   are signed or unsigned.  Thus, we need to somehow know if we\n-   need to do a signed or an unsigned compare, and we do this by \n-   looking ahead in the instruction sequence until we find a jump.\n-   We then note whether this jump is signed or unsigned, and do the \n-   compare appropriately.  Note that we have to scan ahead indefinitley,\n-   as the gcc optimizer may insert any number of instructions between \n-   the compare and the jump.\n-  \n-   Note that using conditional branch expanders seems to be be a more \n-   elegant/correct way of doing this.   See, for instance, the Alpha \n-   cmpdi and bgt patterns.  Note also that for the i370, various\n-   arithmetic insn's set the condition code as well.\n-\n-   The unsigned_jump_follows_p() routine  returns a 1 if the next jump \n-   is unsigned.  INSN is the current instruction.  */\n-\n-int\n-unsigned_jump_follows_p (insn)\n-     register rtx insn;\n-{\n-  rtx orig_insn = insn;\n-  while (1) \n-    {\n-      register rtx tmp_insn;\n-      enum rtx_code coda;\n-  \n-      insn = NEXT_INSN (insn);\n-      if (!insn) fatal_insn (\"internal error--no jump follows compare:\", orig_insn);\n-  \n-      if (GET_CODE (insn) != JUMP_INSN) continue;\n-    \n-      tmp_insn = XEXP (insn, 3);\n-      if (GET_CODE (tmp_insn) != SET) continue;\n-    \n-      if (GET_CODE (XEXP (tmp_insn, 0)) != PC) continue;\n-    \n-      tmp_insn = XEXP (tmp_insn, 1);\n-      if (GET_CODE (tmp_insn) != IF_THEN_ELSE) continue;\n-    \n-      /* if we got to here, this instruction is a jump.  Is it signed? */\n-      tmp_insn = XEXP (tmp_insn, 0);\n-      coda = GET_CODE (tmp_insn);\n-  \n-      return coda != GE && coda != GT && coda != LE && coda != LT;\n-    }\n-}\n-\n-#ifdef TARGET_HLASM\n-\n-/* Target hook for assembling integer objects.  This version handles all\n-   objects when TARGET_HLASM is defined.  */\n-\n-static bool\n-i370_hlasm_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n-{\n-  const char *int_format = NULL;\n-\n-  if (aligned_p)\n-    switch (size)\n-      {\n-      case 1:\n-\tint_format = \"\\tDC\\tX'%02X'\\n\";\n-\tbreak;\n-\n-      case 2:\n-\tint_format = \"\\tDC\\tX'%04X'\\n\";\n-\tbreak;\n-\n-      case 4:\n-\tif (GET_CODE (x) == CONST_INT)\n-\t  {\n-\t    fputs (\"\\tDC\\tF'\", asm_out_file);\n-\t    output_addr_const (asm_out_file, x);\n-\t    fputs (\"'\\n\", asm_out_file);\n-\t  }\n-\telse\n-\t  {\n-\t    fputs (\"\\tDC\\tA(\", asm_out_file);\n-\t    output_addr_const (asm_out_file, x);\n-\t    fputs (\")\\n\", asm_out_file);\n-\t  }\n-\treturn true;\n-      }\n-\n-  if (int_format && GET_CODE (x) == CONST_INT)\n-    {\n-      fprintf (asm_out_file, int_format, INTVAL (x));\n-      return true;\n-    }\n-  return default_assemble_integer (x, size, aligned_p);\n-}\n-\n-/* Generate the assembly code for function entry.  FILE is a stdio\n-   stream to output the code to.  SIZE is an int: how many units of\n-   temporary storage to allocate.\n-\n-   Refer to the array `regs_ever_live' to determine which registers to\n-   save; `regs_ever_live[I]' is nonzero if register number I is ever\n-   used in the function.  This function is responsible for knowing\n-   which registers should not be saved even if used.  */\n-\n-static void\n-i370_output_function_prologue (f, l)\n-     FILE *f;\n-     HOST_WIDE_INT l;\n-{\n-#if MACROPROLOGUE == 1\n-  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n-  fprintf (f, \"\\tEDCPRLG USRDSAL=%d,BASEREG=%d\\n\",\n-\t   STACK_POINTER_OFFSET + l - 120 +\n-\t   current_function_outgoing_args_size, BASE_REGISTER);\n-#else /* MACROPROLOGUE != 1 */\n-  static int function_label_index = 1;\n-  static int function_first = 0;\n-  static int function_year, function_month, function_day;\n-  static int function_hour, function_minute, function_second;\n-#if defined(LE370)\n-  if (!function_first)\n-    {\n-      struct tm *function_time;\n-      time_t lcltime;\n-      time (&lcltime);\n-      function_time = localtime (&lcltime);\n-      function_year = function_time->tm_year + 1900;\n-      function_month = function_time->tm_mon + 1;\n-      function_day = function_time->tm_mday;\n-      function_hour = function_time->tm_hour;\n-      function_minute = function_time->tm_min;\n-      function_second = function_time->tm_sec;\n-    }\n-  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n-  fprintf (f, \"FDSE%03d\\tDSECT\\n\", function_label_index);\n-  fprintf (f, \"\\tDS\\tD\\n\");\n-  fprintf (f, \"\\tDS\\tCL(\" HOST_WIDE_INT_PRINT_DEC \")\\n\",\n-\t   STACK_POINTER_OFFSET + l\n-\t   + current_function_outgoing_args_size);\n-  fprintf (f, \"\\tORG\\tFDSE%03d\\n\", function_label_index);\n-  fprintf (f, \"\\tDS\\tCL(120+8)\\n\");\n-  fprintf (f, \"\\tORG\\n\");\n-  fprintf (f, \"\\tDS\\t0D\\n\");\n-  fprintf (f, \"FDSL%03d\\tEQU\\t*-FDSE%03d-8\\n\", function_label_index,\n-\t   function_label_index);\n-  fprintf (f, \"\\tDS\\t0H\\n\");\n-  assemble_name (f, mvs_function_name);\n-  fprintf (f, \"\\tCSECT\\n\");\n-  fprintf (f, \"\\tUSING\\t*,15\\n\");\n-  fprintf (f, \"\\tB\\tFENT%03d\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tAL1(FNAM%03d+4-*)\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tX'CE',X'A0',AL1(16)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(FPPA%03d)\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(FDSL%03d)\\n\", function_label_index);\n-  fprintf (f, \"FNAM%03d\\tEQU\\t*\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tAL2(%d),C'%s'\\n\", strlen (mvs_function_name),\n-\tmvs_function_name);\n-  fprintf (f, \"FPPA%03d\\tDS\\t0F\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tX'03',X'00',X'33',X'00'\\n\");\n-  fprintf (f, \"\\tDC\\tV(CEESTART)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(FTIM%03d)\\n\", function_label_index);\n-  fprintf (f, \"FTIM%03d\\tDS\\t0F\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\n-  \t\t function_year, function_month, function_day,\n-    \t\t function_hour, function_minute);\n-  fprintf (f, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\n-  fprintf (f, \"FENT%03d\\tDS\\t0H\\n\", function_label_index);\n-  fprintf (f, \"\\tSTM\\t14,12,12(13)\\n\");\n-  fprintf (f, \"\\tL\\t2,76(,13)\\n\");\n-  fprintf (f, \"\\tL\\t0,16(,15)\\n\");\n-  fprintf (f, \"\\tALR\\t0,2\\n\");\n-  fprintf (f, \"\\tCL\\t0,12(,12)\\n\");\n-  fprintf (f, \"\\tBNH\\t*+10\\n\");\n-  fprintf (f, \"\\tL\\t15,116(,12)\\n\");\n-  fprintf (f, \"\\tBALR\\t14,15\\n\");\n-  fprintf (f, \"\\tL\\t15,72(,13)\\n\");\n-  fprintf (f, \"\\tSTM\\t15,0,72(2)\\n\");\n-  fprintf (f, \"\\tMVI\\t0(2),X'10'\\n\");\n-  fprintf (f, \"\\tST\\t2,8(,13)\\n \");\n-  fprintf (f, \"\\tST\\t13,4(,2)\\n \");\n-  fprintf (f, \"\\tLR\\t13,2\\n\");\n-  fprintf (f, \"\\tDROP\\t15\\n\");\n-  fprintf (f, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\n-  fprintf (f, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n-  function_first = 1;\n-  function_label_index ++;\n-#else /* !LE370 */\n-  if (!function_first)\n-    {\n-      struct tm *function_time;\n-      time_t lcltime;\n-      time (&lcltime);\n-      function_time = localtime (&lcltime);\n-      function_year = function_time->tm_year + 1900;\n-      function_month = function_time->tm_mon + 1;\n-      function_day = function_time->tm_mday;\n-      function_hour = function_time->tm_hour;\n-      function_minute = function_time->tm_min;\n-      function_second = function_time->tm_sec;\n-      fprintf (f, \"PPA2\\tDS\\t0F\\n\");\n-      fprintf (f, \"\\tDC\\tX'03',X'00',X'33',X'00'\\n\");\n-      fprintf (f, \"\\tDC\\tV(CEESTART),A(0)\\n\");\n-      fprintf (f, \"\\tDC\\tA(CEETIMES)\\n\");\n-      fprintf (f, \"CEETIMES\\tDS\\t0F\\n\");\n-      fprintf (f, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\n-    \t\t function_year, function_month, function_day,\n-    \t\t function_hour, function_minute, function_second);\n-      fprintf (f, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\n-    }\n-  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n-  fprintf (f, \"FDSD%03d\\tDSECT\\n\", function_label_index);\n-  fprintf (f, \"\\tDS\\tD\\n\");\n-  fprintf (f, \"\\tDS\\tCL(%d)\\n\", STACK_POINTER_OFFSET + l\n-\t\t\t+ current_function_outgoing_args_size);\n-  fprintf (f, \"\\tORG\\tFDSD%03d\\n\", function_label_index);\n-  fprintf (f, \"\\tDS\\tCL(120+8)\\n\");\n-  fprintf (f, \"\\tORG\\n\");\n-  fprintf (f, \"\\tDS\\t0D\\n\");\n-  fprintf (f, \"FDSL%03d\\tEQU\\t*-FDSD%03d-8\\n\", function_label_index,\n-\t   function_label_index);\n-  fprintf (f, \"\\tDS\\t0H\\n\");\n-  assemble_name (f, mvs_function_name);\n-  fprintf (f, \"\\tCSECT\\n\");\n-  fprintf (f, \"\\tUSING\\t*,15\\n\");\n-  fprintf (f, \"\\tB\\tFPL%03d\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tAL1(FPL%03d+4-*)\\n\", function_label_index + 1);\n-  fprintf (f, \"\\tDC\\tX'CE',X'A0',AL1(16)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(PPA2)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(FDSL%03d)\\n\", function_label_index);\n-  fprintf (f, \"FPL%03d\\tEQU\\t*\\n\", function_label_index + 1);\n-  fprintf (f, \"\\tDC\\tAL2(%d),C'%s'\\n\", strlen (mvs_function_name),\n-\tmvs_function_name);\n-  fprintf (f, \"FPL%03d\\tDS\\t0H\\n\", function_label_index);\n-  fprintf (f, \"\\tSTM\\t14,12,12(13)\\n\");\n-  fprintf (f, \"\\tL\\t2,76(,13)\\n\");\n-  fprintf (f, \"\\tL\\t0,16(,15)\\n\");\n-  fprintf (f, \"\\tALR\\t0,2\\n\");\n-  fprintf (f, \"\\tCL\\t0,12(,12)\\n\");\n-  fprintf (f, \"\\tBNH\\t*+10\\n\");\n-  fprintf (f, \"\\tL\\t15,116(,12)\\n\");\n-  fprintf (f, \"\\tBALR\\t14,15\\n\");\n-  fprintf (f, \"\\tL\\t15,72(,13)\\n\");\n-  fprintf (f, \"\\tSTM\\t15,0,72(2)\\n\");\n-  fprintf (f, \"\\tMVI\\t0(2),X'10'\\n\");\n-  fprintf (f, \"\\tST\\t2,8(,13)\\n \");\n-  fprintf (f, \"\\tST\\t13,4(,2)\\n \");\n-  fprintf (f, \"\\tLR\\t13,2\\n\");\n-  fprintf (f, \"\\tDROP\\t15\\n\");\n-  fprintf (f, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\n-  fprintf (f, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n-  function_first = 1;\n-  function_label_index += 2;\n-#endif /* !LE370 */\n-#endif /* MACROPROLOGUE */\n-  fprintf (f, \"PG%d\\tEQU\\t*\\n\", mvs_page_num );\n-  fprintf (f, \"\\tLR\\t11,1\\n\"); \n-  fprintf (f, \"\\tL\\t%d,=A(PGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\n-  fprintf (f, \"* Function %s code\\n\", mvs_function_name);\n-\n-  mvs_free_label_list ();\n-  mvs_page_code = 6;\n-  mvs_page_lit = 4;\n-  mvs_check_page (f, 0, 0);\n-  function_base_page = mvs_page_num;\n-\n-  /* find all labels in this routine */\n-  i370_label_scan ();\n-}\n-\n-static void\n-i370_globalize_label (stream, name)\n-     FILE *stream;\n-     const char *name;\n-{\n-  char temp[MAX_MVS_LABEL_SIZE + 1];\n-  if (mvs_check_alias (name, temp) == 2)\n-    fprintf (stream, \"%s\\tALIAS\\tC'%s'\\n\", temp, name);\n-  fputs (\"\\tENTRY\\t\", stream);\n-  assemble_name (stream, name);\n-  putc ('\\n', stream);\n-}\n-#endif /* TARGET_HLASM */\n-\n-\n-#ifdef TARGET_ELF_ABI\n-/*\n-   The 370_function_prolog() routine generates the current ELF ABI ES/390 prolog.\n-   It implements a stack that grows downward. \n-   It performs the following steps:\n-   -- saves the callers non-volatile registers on the callers stack.\n-   -- subtracts stackframe size from the stack pointer.\n-   -- stores backpointer to old caller stack.\n-  \n-   XXX hack alert -- if the global var int leaf_function is nonzero, \n-   then this is a leaf, and it might be possible to optimize the prologue\n-   into doing even less, e.g. not grabbing a new stackframe or maybe just a\n-   partial stack frame.\n-  \n-   XXX hack alert -- the current stack frame is bloated into twice the \n-   needed size by unused entries. These entries make it marginally \n-   compatible with MVS/OE/USS C environment, but really they're not used\n-   and could probably chopped out. Modifications to i370.md would be needed\n-   also, to quite using addresses 136, 140, etc.\n- */\n-\n-static void\n-i370_output_function_prologue (f, frame_size)\n-     FILE *f;\n-     HOST_WIDE_INT frame_size;\n-{\n-  static int function_label_index = 1;\n-  static int function_first = 0;\n-  int stackframe_size, aligned_size;\n-\n-  fprintf (f, \"# Function prologue\\n\");\n-  /* define the stack, put it into its own data segment\n-     FDSE == Function Stack Entry\n-     FDSL == Function Stack Length */\n-  stackframe_size = \n-     STACK_POINTER_OFFSET + current_function_outgoing_args_size + frame_size;\n-  aligned_size = (stackframe_size + 7) >> 3;\n-  aligned_size <<= 3;\n-  \n-  fprintf (f, \"# arg_size=0x%x frame_size=\" HOST_WIDE_INT_PRINT_HEX\n-\t   \" aligned size=0x%x\\n\", \n-     current_function_outgoing_args_size, frame_size, aligned_size);\n-\n-  fprintf (f, \"\\t.using\\t.,r15\\n\");\n-\n-  /* Branch to exectuable part of prologue.  */\n-  fprintf (f, \"\\tB\\t.LFENT%03d\\n\", function_label_index);\n-\n-  /* write the length of the stackframe */\n-  fprintf (f, \"\\t.long\\t%d\\n\", aligned_size);\n-\n-  /* FENT == function prologue entry */\n-  fprintf (f, \"\\t.balign 2\\n.LFENT%03d:\\n\",\n-              function_label_index);\n-\n-  /* store multiple registers 14,15,0,...12 at 12 bytes from sp */\n-  fprintf (f, \"\\tSTM\\tr14,r12,12(sp)\\n\");\n-\n-  /* r3 == saved callee stack pointer */\n-  fprintf (f, \"\\tLR\\tr3,sp\\n\");\n-\n-  /* 4(r15) == stackframe size */\n-  fprintf (f, \"\\tSL\\tsp,4(,r15)\\n\");\n-\n-  /* r11 points to arg list in callers stackframe; was passed in r2 */\n-  fprintf (f, \"\\tLR\\tr11,r2\\n\");\n-\n-  /* store callee stack pointer at 8(sp) */\n-  /* fprintf (f, \"\\tST\\tsp,8(,r3)\\n \");  wasted cycles, no one uses this ...  */\n-\n-  /* backchain -- store caller sp at 4(callee_sp)  */\n-  fprintf (f, \"\\tST\\tr3,4(,sp)\\n \");\n-\n-  fprintf (f, \"\\t.drop\\tr15\\n\");\n-  /* Place contents of the PSW into r3\n-     that is, place the address of \".\" into r3 */\n-  fprintf (f, \"\\tBASR\\tr%d,0\\n\", BASE_REGISTER);\n-  fprintf (f, \"\\t.using\\t.,r%d\\n\", BASE_REGISTER);\n-  function_first = 1;\n-  function_label_index ++;\n-\n-  fprintf (f, \".LPG%d:\\n\", mvs_page_num  );\n-  fprintf (f, \"\\tL\\tr%d,=A(.LPGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\n-  fprintf (f, \"# Function code\\n\");\n-\n-  mvs_free_label_list ();\n-  mvs_page_code = 6;\n-  mvs_page_lit = 4;\n-  mvs_check_page (f, 0, 0);\n-  function_base_page = mvs_page_num;\n-\n-  /* find all labels in this routine */\n-  i370_label_scan ();\n-}\n-#endif /* TARGET_ELF_ABI */\n-\n-/* This function generates the assembly code for function exit.\n-   Args are as for output_function_prologue ().\n-\n-   The function epilogue should not depend on the current stack\n-   pointer!  It should use the frame pointer only.  This is mandatory\n-   because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning.  */\n-\n-static void\n-i370_output_function_epilogue (file, l)\n-     FILE *file;\n-     HOST_WIDE_INT l ATTRIBUTE_UNUSED;\n-{\n-  int i;\n-\n-  check_label_emit ();\n-  mvs_check_page (file, 14, 0);\n-  fprintf (file, \"* Function %s epilogue\\n\", mvs_function_name);\n-  mvs_page_num++;\n-\n-#if MACROEPILOGUE == 1\n-  fprintf (file, \"\\tEDCEPIL\\n\");\n-#else /* MACROEPILOGUE != 1 */\n-  fprintf (file, \"\\tL\\t13,4(,13)\\n\");\n-  fprintf (file, \"\\tL\\t14,12(,13)\\n\");\n-  fprintf (file, \"\\tLM\\t2,12,28(13)\\n\");\n-  fprintf (file, \"\\tBALR\\t1,14\\n\");\n-  fprintf (file, \"\\tDC\\tA(\");\n-  assemble_name (file, mvs_function_name);\n-  fprintf (file, \")\\n\" );\n-#endif /* MACROEPILOGUE */\n-\n-  fprintf (file, \"* Function %s literal pool\\n\", mvs_function_name);\n-  fprintf (file, \"\\tDS\\t0F\\n\" );\n-  fprintf (file, \"\\tLTORG\\n\");\n-  fprintf (file, \"* Function %s page table\\n\", mvs_function_name);\n-  fprintf (file, \"\\tDS\\t0F\\n\");\n-  fprintf (file, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\n-\n-  mvs_free_label_list();\n-  for (i = function_base_page; i < mvs_page_num; i++)\n-    fprintf (file, \"\\tDC\\tA(PG%d)\\n\", i);\n-}\n-\n-static void\n-i370_file_start ()\n-{\n-  fputs (\"\\tRMODE\\tANY\\n\\tCSECT\\n\", asm_out_file);\n-}\n-\n-static void\n-i370_file_end ()\n-{\n-  fputs (\"\\tEND\\n\", asm_out_file);\n-}\n-\n-static void\n-i370_internal_label (stream, prefix, labelno)\n-     FILE *stream;\n-     const char *prefix;\n-     unsigned long labelno;\n-{\n-  if (!strcmp (prefix, \"L\"))\n-    mvs_add_label(labelno);\n-\n-  default_internal_label (stream, prefix, labelno);\n-}\n-\n-static bool\n-i370_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code;\n-     int outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n-{\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      if ((unsigned HOST_WIDE_INT) INTVAL (x) < 0xfff)\n-\t{\n-\t  *total = 1;\n-\t  return true;\n-\t}\n-      /* FALLTHRU */\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = 2;\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      *total = 4;\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}"}, {"sha": "5d7037f4902157d8b6526d9860097c446043f8ac", "filename": "gcc/config/i370/i370.h", "status": "removed", "additions": 0, "deletions": 1863, "changes": 1863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,1863 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003 Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_I370_H\n-#define GCC_I370_H\n-\n-/* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"GCC\");\t\t\\\n-      builtin_define_std (\"gcc\");\t\t\\\n-      builtin_assert (\"machine=i370\");\t\t\\\n-      builtin_assert (\"cpu=i370\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern int target_flags;\n-\n-/* The sizes of the code and literals on the current page.  */\n-\n-extern int mvs_page_code, mvs_page_lit;\n-\n-/* The current page number and the base page number for the function.  */\n-\n-extern int mvs_page_num, function_base_page;\n-\n-/* The name of the current function.  */\n-\n-extern char *mvs_function_name;\n-\n-/* The length of the function name malloc'd area.  */\n-\n-extern size_t mvs_function_name_length;\n-\n-/* Compile using char instructions (mvc, nc, oc, xc).  On 4341 use this since\n-   these are more than twice as fast as load-op-store.\n-   On 3090 don't use this since load-op-store is much faster.  */\n-\n-#define TARGET_CHAR_INSTRUCTIONS (target_flags & 1)\n-\n-/* Default target switches */\n-\n-#define TARGET_DEFAULT 1\n-\n-/* Macro to define tables used to set the flags.  This is a list in braces\n-   of pairs in braces, each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-{ { \"char-instructions\", 1, N_(\"Generate char instructions\")},            \\\n-  { \"no-char-instructions\", -1, N_(\"Do not generate char instructions\")}, \\\n-  { \"\", TARGET_DEFAULT, 0} }\n-\n-#define OVERRIDE_OPTIONS  override_options ()\n-\n-/* To use IBM supplied macro function prologue and epilogue, define the\n-   following to 1.  Should only be needed if IBM changes the definition\n-   of their prologue and epilogue.  */\n-\n-#define MACROPROLOGUE 0\n-#define MACROEPILOGUE 0\n-\n-/* Target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered in instructions\n-   that operate on numbered bit-fields.  */\n-\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if MS word of a multiword is the lowest numbered.  */\n-\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* Width of a word, in units (bytes).  */\n-\n-#define UNITS_PER_WORD 4\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-\n-#define POINTER_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-\n-#define STACK_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-\n-#define FUNCTION_BOUNDARY 32\n-\n-/* There is no point aligning anything to a rounder boundary than this.  */\n-\n-#define BIGGEST_ALIGNMENT 64\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Define this if move instructions will actually fail to work when given\n-   unaligned data.  */\n-\n-#define STRICT_ALIGNMENT 0\n-\n-/* Define target floating point format.  */\n-\n-#define TARGET_FLOAT_FORMAT IBM_FLOAT_FORMAT\n-\n-#ifdef TARGET_HLASM\n-/* HLASM requires #pragma map.  */\n-#define REGISTER_TARGET_PRAGMAS() c_register_pragma (0, \"map\", i370_pr_map)\n-#endif /* TARGET_HLASM */\n-\n-/* Define maximum length of page minus page escape overhead.  */\n-\n-#define MAX_MVS_PAGE_LENGTH 4080\n-\n-/* Define special register allocation order desired.  \n-   Don't fiddle with this.  I did, and I got all sorts of register \n-   spill errors when compiling even relatively simple programs...\n-   I have no clue why ...\n-   E.g. this one is bad:\n-   { 0, 1, 2, 9, 8, 7, 6, 5, 10, 15, 14, 12, 3, 4, 16, 17, 18, 19, 11, 13 }\n- */\n-\n-#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n-{ 0, 1, 2, 3, 14, 15, 12, 10, 9, 8, 7, 6, 5, 4, 16, 17, 18, 19, 11, 13 }\n-\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.  The hardware registers are\n-   assigned numbers for the compiler from 0 to just below\n-   FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-   For the 370, we give the data registers numbers 0-15,\n-   and the floating point registers numbers 16-19.  */\n-\n-#define FIRST_PSEUDO_REGISTER 20\n-\n-/* Define base and page registers.  */\n-\n-#define BASE_REGISTER 3\n-#define PAGE_REGISTER 4\n-\n-#ifdef TARGET_HLASM\n-/* 1 for registers that have pervasive standard uses and are not available\n-   for the register allocator.  These are registers that must have fixed,\n-   valid values stored in them for the entire length of the subroutine call,\n-   and must not in any way be moved around, jiggered with, etc. That is,\n-   they must never be clobbered, and, if clobbered, the register allocator \n-   will never restore them back.\n-   \n-   We use five registers in this special way:\n-   -- R3 which is used as the base register\n-   -- R4 the page origin table pointer used to load R3,\n-   -- R11 the arg pointer.  \n-   -- R12 the TCA pointer\n-   -- R13 the stack (DSA) pointer\n-\n-   A fifth register is also exceptional: R14 is used in many branch\n-   instructions to hold the target of the branch.  Technically, this\n-   does not qualify R14 as a register with a long-term meaning; it should\n-   be enough, theoretically, to note that these instructions clobber\n-   R14, and let the compiler deal with that.  In practice, however,\n-   the \"clobber\" directive acts as a barrier to optimization, and the\n-   optimizer appears to be unable to perform optimizations around branches.\n-   Thus, a much better strategy appears to give R14 a pervasive use;\n-   this eliminates it from the register pool witout hurting optimization.\n-\n-   There are other registers which have special meanings, but its OK\n-   for them to get clobbered, since other allocator config below will\n-   make sure that they always have the right value.  These are for \n-   example:\n-   -- R1 the returned structure pointer.\n-   -- R10 the static chain reg.\n-   -- R15 holds the value a subroutine returns.\n-\n-   Notice that it is *almost* safe to mark R11 as available to the allocator.\n-   By marking it as a call_used_register, in most cases, the compiler\n-   can handle it being clobbered.  However, there are a few rare\n-   circumstances where the register allocator will allocate r11 and \n-   also try to use it as the arg pointer ... thus it must be marked fixed.\n-   I think this is a bug, but I can't track it down...\n- */\n-\n-#define FIXED_REGISTERS \t\t\t\t\t\t\\\n-{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n-/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n-\n-/* 1 for registers not available across function calls.  These must include\n-   the FIXED_REGISTERS and also any registers that can be used without being\n-   saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   NOTE: all floating registers are undefined across calls.  \n-*/\n-\n-#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n-{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n-/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  \n-   Note that DCmode (complex double) needs two regs.\n-*/\n-#endif /* TARGET_HLASM */\n-\n-/* ================= */\n-#ifdef TARGET_ELF_ABI \n-/* The Linux/ELF ABI uses the same register layout as the \n- * the MVS/OE version, with the following exceptions:\n- * -- r12 (rtca) is not used.\n- */\n-\n-#define FIXED_REGISTERS \t\t\t\t\t\t\\\n-{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0 }\n-/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n-\n-#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n-{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 }\n-/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n-\n-#endif /* TARGET_ELF_ABI */\n-/* ================= */\n-\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\t\\\n-  ((REGNO) > 15 ? \t\t\t\t\t\t\t\\\n-   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n-   (GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the 370, the cpu registers can hold QI, HI, SI, SF and DF.  The\n-   even registers can hold DI.  The floating point registers can hold\n-   either SF, DF, SC or DC.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  ((REGNO) < 16 ? (((REGNO) & 1) == 0 || \t\t\t\t\\\n-\t\t  (((MODE) != DImode) && ((MODE) != DFmode)))\t\t\\\n-\t\t: ((MODE) == SFmode || (MODE) == DFmode) ||\t\t\\\n-                   (MODE) == SCmode || (MODE) == DCmode)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n-   mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n-  (((MODE1) == SFmode || (MODE1) == DFmode)\t\t\t\t\\\n-   == ((MODE2) == SFmode || (MODE2) == DFmode))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* 370 PC isn't overloaded on a register.  */\n-\n-/* #define PC_REGNUM */\n-\n-/* Register to use for pushing function arguments.  */\n-\n-#define STACK_POINTER_REGNUM 13\n-\n-/* Base register for access to local variables of the function.  */\n-\n-#define FRAME_POINTER_REGNUM 13\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms may be\n-   accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-\n-#define FRAME_POINTER_REQUIRED 1\n-\n-/* Base register for access to arguments of the function.  */\n-\n-#define ARG_POINTER_REGNUM 11\n-\n-/* R10 is register in which static-chain is passed to a function.  \n-   Static-chaining is done when a nested function references as a global\n-   a stack variable of its parent: e.g.\n-        int parent_func (int arg) { \n-             int x;                            // x is in parents stack\n-             void child_func (void) { x++: }   // child references x as global var\n-             ... \n-        }\n- */\n-\n-#define STATIC_CHAIN_REGNUM 10\n-\n-/* R1 is register in which address to store a structure value is passed to\n-   a function.  This is used only when returning 64-bit long-long in a 32-bit arch\n-   and when calling functions that return structs by value. e.g.\n-        typedef struct A_s { int a,b,c; } A_t;\n-        A_t fun_returns_value (void) { \n-            A_t a; a.a=1; a.b=2 a.c=3;\n-            return a;\n-        } \n-   In the above, the storage for the return value is in the callers stack, and \n-   the R1 points at that mem location.\n- */\n-\n-#define STRUCT_VALUE_REGNUM 1\n-\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-enum reg_class\n-  {\n-    NO_REGS, ADDR_REGS, DATA_REGS,\n-    FP_REGS, ALL_REGS, LIM_REG_CLASSES\n-  };\n-\n-#define GENERAL_REGS DATA_REGS\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES \t\t\t\t\t\t\\\n-{ \"NO_REGS\", \"ADDR_REGS\", \"DATA_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.  This is an initializer for\n-   a vector of HARD_REG_SET of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS {{0}, {0x0fffe}, {0x0ffff}, {0xf0000}, {0xfffff}}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) \t\t\t\t\t\t\\\n-  ((REGNO) >= 16 ? FP_REGS : (REGNO) != 0 ? ADDR_REGS : DATA_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS ADDR_REGS\n-#define BASE_REG_CLASS ADDR_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C)\t\t\t\t\t\\\n-  ((C) == 'a' ? ADDR_REGS :\t\t\t\t\t\t\\\n-  ((C) == 'd' ? DATA_REGS :\t\t\t\t\t\t\\\n-  ((C) == 'f' ? FP_REGS   : NO_REGS)))\n-\n-/* The letters I, J, K, L and M in a register constraint string can be used\n-   to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-  ((C) == 'I' ? (unsigned) (VALUE) < 256 :\t\t\t\t\\\n-   (C) == 'J' ? (unsigned) (VALUE) < 4096 :\t\t\t\t\\\n-   (C) == 'K' ? (VALUE) >= -32768 && (VALUE) < 32768 : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n-\n-/* see recog.c for details */\n-#define EXTRA_CONSTRAINT(OP,C)\t\t\t\t\t\t\\\n-   ((C) == 'R' ? r_or_s_operand (OP, GET_MODE(OP)) :\t\t\t\\\n-    (C) == 'S' ? s_operand (OP, GET_MODE(OP)) :\t0)\t\t\t\\\n-\n-/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n-   return the class of reg to actually use.  In general this is just CLASS;\n-   but on some machines in some cases it is preferable to use a more\n-   restrictive class.  \n-\n-   XXX We reload CONST_INT's into ADDR not DATA regs because on certain \n-   rare occasions when lots of egisters are spilled, reload() will try\n-   to put a const int into r0 and then use r0 as an index register.\n-*/\n-\n-#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n-    (GET_CODE(X) == CONST_DOUBLE ? FP_REGS :\t\t\t\t\\\n-     GET_CODE(X) == CONST_INT ? (reload_in_progress ? ADDR_REGS : DATA_REGS) :\t\\\n-     GET_CODE(X) == LABEL_REF ||\t\t\t\t\t\\\n-     GET_CODE(X) == SYMBOL_REF ||\t\t\t\t\t\\\n-     GET_CODE(X) == CONST ? ADDR_REGS : (CLASS))\n-\n-/* Return the maximum number of consecutive registers needed to represent\n-   mode MODE in a register of class CLASS.  \n-   Note that DCmode (complex double) needs two regs.\n-*/\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n-   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n-   (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack makes the stack pointer a\n-   smaller address.  */\n-/* ------------------------------------------------------------------- */\n-\n-/* ================= */\n-#ifdef TARGET_HLASM\n-/* #define STACK_GROWS_DOWNWARD */\n-\n-/* Define this if the nominal address of the stack frame is at the\n-   high-address end of the local variables; that is, each additional local\n-   variable allocated goes at a more negative offset in the frame.  */\n-\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-\n-#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n-     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n-\n-/* If we generate an insn to push BYTES bytes, this says how many the stack\n-   pointer really advances by.  On the 370, we have no push instruction.  */\n-\n-#endif /* TARGET_HLASM */\n-\n-/* ================= */\n-#ifdef TARGET_ELF_ABI \n-\n-/* With ELF/Linux, stack is placed at large virtual addrs and grows down.\n-   But we want the compiler to generate posistive displacements from the \n-   stack pointer, and so we make the frame lie above the stack.  */\n-\n-#define STACK_GROWS_DOWNWARD \n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   This is the offset to the BEGINNING of the first local allocated.  */\n-\n-#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n-     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n-\n-#endif /* TARGET_ELF_ABI */\n-/* ================= */\n-\n-/* #define PUSH_ROUNDING(BYTES) */\n-\n-/* Accumulate the outgoing argument count so we can request the right\n-   DSA size and determine stack offset.  */\n-\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Define offset from stack pointer, to location where a parm can be\n-   pushed.  */\n-\n-#define STACK_POINTER_OFFSET 148\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On the 370, no registers are used in this way.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) 0\n-\n-/* Define a data type for recording info about an argument list during\n-   the scan of that argument list.  This data type should hold all\n-   necessary information about the function itself and about the args\n-   processed so far, enough to enable macros such as FUNCTION_ARG to\n-   determine where the next arg should go.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to\n-   a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-  ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument of mode MODE and\n-   data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.) */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n- ((CUM) += ((MODE) == DFmode || (MODE) == SFmode\t\t\t\\\n-\t    ? 256\t\t\t\t\t\t\t\\\n-\t    : (MODE) != BLKmode                 \t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) / 4 \t\t\t\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) / 4))\n-\n-/* Define where to put the arguments to a function.  Value is zero to push\n-   the argument on the stack, or a hard register in which to store the\n-   argument.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n-\n-/* For an arg passed partly in registers and partly in memory, this is the\n-   number of registers used.  For args passed entirely in registers or\n-   entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n-/* Define if returning from a function call automatically pops the\n-   arguments described by the number-of-args field in the call.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* The FUNCTION_VALUE macro defines how to find the value returned by a \n-   function.  VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is NULL.  \n-\n-   On the 370 the return value is in R15 or R16.  However,\n-   DImode (64-bit ints) scalars need to get returned on the stack, \n-   with r15 pointing to the location.  To accomplish this, we define\n-   the RETURN_IN_MEMORY macro to be true for both blockmode (structures)\n-   and the DImode scalars.\n- */\n-\n-#define RET_REG(MODE)\t\\\n-    (((MODE) == DCmode || (MODE) == SCmode \\\n-      || (MODE) == DFmode || (MODE) == SFmode) ? 16 : 15)\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \t\t\t\t\t\\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), RET_REG (TYPE_MODE (VALTYPE)))\n-\n-#define RETURN_IN_MEMORY(VALTYPE)  \\\n-  ((DImode == TYPE_MODE (VALTYPE)) || (BLKmode == TYPE_MODE (VALTYPE)))\n-\n-/* Define how to find the value returned by a library function assuming\n-   the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, RET_REG (MODE))\n-\n-/* 1 if N is a possible register number for a function value.\n-   On the 370 under C/370, R15 and R16 are thus used.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 15 || (N) == 16)\n-\n-/* This macro definition sets up a default value for `main' to return.  */\n-\n-#define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n-\n-\n-/* Output assembler code for a block containing the constant parts of a\n-   trampoline, leaving space for the variable parts.\n-\n-   On the 370, the trampoline contains these instructions:\n-\n-        BALR  14,0\n-        USING *,14\n-        L     STATIC_CHAIN_REGISTER,X\n-        L     15,Y\n-        BR    15\n-   X    DS    0F\n-   Y    DS    0F  */\n-/*\n-   I am confused as to why this emitting raw binary, instead of instructions ...\n-   see for example, rs6000/rs000.c for an example of a different way to\n-   do this ... especially since BASR should probably be substituted for BALR.\n- */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0x05E0));\t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0x5800 | STATIC_CHAIN_REGNUM << 4)); \\\n-  assemble_aligned_integer (2, GEN_INT (0xE00A));\t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0x58F0)); \t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0xE00E));\t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0x07FF));\t\t\t\\\n-  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n-  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n-  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n-  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n-}\n-\n-/* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n-   pointer does not matter (provided there is a frame pointer).  */\n-\n-#define EXIT_IGNORE_STACK\t1\n-\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.  They give\n-   nonzero only if REGNO is a hard reg of the suitable class or a pseudo\n-   reg currently allocated to a suitable hard reg.\n-   These definitions are NOT overridden anywhere.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \t\t\t\t\t\\\n-  (((REGNO) > 0 && (REGNO) < 16)\t\t\t\t\t\\\n-    || (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 16))\n-\n-#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P(REGNO)\n-\n-#define REGNO_OK_FOR_DATA_P(REGNO) \t\t\t\t\t\\\n-  ((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n-\n-#define REGNO_OK_FOR_FP_P(REGNO) \t\t\t\t\t\\\n-  ((unsigned) ((REGNO) - 16) < 4 || (unsigned) (reg_renumber[REGNO] - 16) < 4)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.  */\n-\n-/* 1 if X is a data register.  */\n-\n-#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n-\n-/* 1 if X is an address register.  */\n-\n-#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-  || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n-  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF)\t\t\\\n-  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n-\t  && !SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (X, 0), 0))))\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check\n-   its validity for a certain class.  We have two alternate definitions\n-   for each of them.  The usual definition accepts all pseudo regs; the\n-   other rejects them all.  The symbol REG_OK_STRICT causes the latter\n-   definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that they will\n-   get allocated to the class that the insn wants them to be in.\n-   Some source files that are used after register allocation\n-   need to be strict.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index or if it is\n-  a pseudo reg.  */\n-\n-#define REG_OK_FOR_INDEX_P(X)\t\t\t\t\t\t\\\n-  ((REGNO(X) > 0 && REGNO(X) < 16) || REGNO(X) >= 20)\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg or if it is\n-   a pseudo reg.  */\n-\n-#define REG_OK_FOR_BASE_P(X)\tREG_OK_FOR_INDEX_P(X)\n-\n-#else /* REG_OK_STRICT */\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P(REGNO(X))\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P(REGNO(X))\n-\n-#endif /* REG_OK_STRICT */\n-\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n-   valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  \n-*/\n-\n-#define COUNT_REGS(X, REGS, FAIL)\t\t\t\t\t\\\n- if (REG_P (X)) {\t\t\t\t\t\t\t\\\n-   if (REG_OK_FOR_BASE_P (X)) REGS += 1;\t\t\t\t\\\n-   else goto FAIL;\t\t\t\t\t\t\t\\\n- }\t\t\t\t\t\t\t\t\t\\\n- else if (GET_CODE (X) != CONST_INT || (unsigned) INTVAL (X) >= 4096)\t\\\n-   goto FAIL;\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int regs = 0;\t\t\t\t\t\t\t\\\n-      rtx x0 = XEXP (X, 0);\t\t\t\t\t\t\\\n-      rtx x1 = XEXP (X, 1);\t\t\t\t\t\t\\\n-      if (GET_CODE (x0) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  COUNT_REGS (XEXP (x0, 0), regs, FAIL);\t\t\t\\\n-\t  COUNT_REGS (XEXP (x0, 1), regs, FAIL);\t\t\t\\\n-\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n-\t  if (regs == 2)\t\t\t\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (x1) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n-\t  COUNT_REGS (XEXP (x1, 0), regs, FAIL);\t\t\t\\\n-\t  COUNT_REGS (XEXP (x1, 1), regs, FAIL);\t\t\t\\\n-\t  if (regs == 2)\t\t\t\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n-\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n-\t  if (regs != 0)\t\t\t\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  FAIL: ;\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* The 370 has no mode dependent addresses.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n-\n-/* Macro: LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n-   Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c. \n-  \n-   Several comments:\n-   (1) It's not obvious that this macro results in better code\n-       than its omission does. For historical reasons we leave it in.\n-  \n-   (2) This macro may be (???) implicated in the accidental promotion\n-       or RS operand to RX operands, which bombs out any RS, SI, SS \n-       instruction that was expecting a simple address.  Note that \n-       this occurs fairly rarely ...\n-  \n-   (3) There is a bug somewhere that causes either r4 to be spilled,\n-       or causes r0 to be used as a base register.  Changeing the macro \n-       below will make the bug move around, but will not make it go away \n-       ... Note that this is a rare bug ...\n-   \n- */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 0), 0));\t\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), 0));\t\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Specify the machine mode that this machine uses for the index in the\n-   tablejump instruction.  */\n-\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define this if the tablejump instruction expects the table to contain\n-   offsets from the address of the table.\n-   Do not define this if the table should contain absolute addresses.  */\n-\n-/* #define CASE_VECTOR_PC_RELATIVE */\n-\n-/* Define this if fixuns_trunc is the same as fix_trunc.  */\n-\n-#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-\n-/* We use \"unsigned char\" as default.  */\n-\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-/* Max number of bytes we can move from memory to memory in one reasonably\n-   fast instruction.  */\n-\n-#define MOVE_MAX 256\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define if shifts truncate the shift count which implies one can omit\n-   a sign-extension or zero-extension of a shift count.  */\n-\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)\t(OUTPREC != 16)\n-\n-/* ??? Investigate defining STORE_FLAG_VALUE to (-1).  */\n-\n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* Don't perform CSE on function addresses.  */\n-\n-#define NO_FUNCTION_CSE\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-\n-#define Pmode SImode\n-\n-/* A function address in a call instruction is a byte address (for\n-   indexing purposes) so give the MEM rtx a byte's mode.  */\n-\n-#define FUNCTION_MODE QImode\n-\n-/*   A C statement (sans semicolon) to update the integer variable COST\n-     based on the relationship between INSN that is dependent on\n-     DEP_INSN through the dependence LINK.  The default is to make no\n-     adjustment to COST.  This can be used for example to specify to\n-     the scheduler that an output- or anti-dependence does not incur\n-     the same cost as a data-dependence. \n-\n-     We will want to use this to indicate that there is a cost associated \n-     with the loading, followed by use of base registers ... \n-#define ADJUST_COST (INSN, LINK, DEP_INSN, COST)\n- */\n-\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* Store in cc_status the expressions that the condition codes will\n-   describe after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.\n-\n-   On the 370, load insns do not alter the cc's.  However, in some\n-   cases these instructions can make it possibly invalid to use the\n-   saved cc's.  In those cases we clear out some or all of the saved\n-   cc's so they won't be used.  \n-\n-   Note that only some arith instructions set the CC.  These include\n-   add, subtract, complement, various shifts.  Note that multiply\n-   and divide do *not* set set the CC.  Therefore, in the code below,\n-   don't set the status for MUL, DIV, etc.\n-\n-   Note that the bitwise ops set the condition code, but not in a \n-   way that we can make use of it. So we treat these as clobbering, \n-   rather than setting the CC.  These are clobbered in the individual\n-   instruction patterns that use them.  Use CC_STATUS_INIT to clobber.\n-*/\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx exp = (EXP);\t\t\t\t\t\t\t\\\n-  if (GET_CODE (exp) == PARALLEL) /* Check this */\t\t\t\\\n-    exp = XVECEXP (exp, 0, 0);\t\t\t\t\t\t\\\n-  if (GET_CODE (exp) != SET)\t\t\t\t\t\t\\\n-    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (XEXP (exp, 0) == cc0_rtx)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  cc_status.value1 = XEXP (exp, 0);\t\t\t\t\\\n-\t  cc_status.value2 = XEXP (exp, 1);\t\t\t\t\\\n-\t  cc_status.flags = 0;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (cc_status.value1\t\t\t\t\t\t\\\n-\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value1))\t\\\n-\t    cc_status.value1 = 0;\t\t\t\t\t\\\n-\t  if (cc_status.value2\t\t\t\t\t\t\\\n-\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value2))\t\\\n-\t    cc_status.value2 = 0;\t\t\t\t\t\\\n-\t  switch (GET_CODE (XEXP (exp, 1)))\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      case PLUS:     case MINUS: case NEG:    \t\t\t\\\n-\t      case NOT:\t case ABS:\t\t\t\t\t\\\n-\t\tCC_STATUS_SET (XEXP (exp, 0), XEXP (exp, 1));\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-              /* mult and div don't set any cc codes !! */\t\t\\\n-\t      case MULT:  /* case UMULT: */ case DIV:      case UDIV: \t\\\n-              /* and, or and xor set the cc's the wrong way !! */\t\\\n-\t      case AND:   case IOR:    case XOR:  \t\t\t\\\n-              /* some shifts set the CC some don't.  */\t\t\t\\\n-              case ASHIFT: \t case ASHIFTRT:  \t\t\t\\\n-                 do {} while (0);\t\t\t\t\t\\\n-              default:\t\t\t\t\t\t\t\\\n-                break;\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-\n-#define CC_STATUS_SET(V1, V2)\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  cc_status.flags = 0;\t\t\t\t\t\t\t\\\n-  cc_status.value1 = (V1);\t\t\t\t\t\t\\\n-  cc_status.value2 = (V2);\t\t\t\t\t\t\\\n-  if (cc_status.value1\t\t\t\t\t\t\t\\\n-      && reg_mentioned_p (cc_status.value1, cc_status.value2))\t\t\\\n-    cc_status.value2 = 0;\t\t\t\t\t\t\\\n-}\n-\n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV) \t\t\t\t\\\n-{ if (cc_status.flags & CC_NO_OVERFLOW)\treturn NO_OV; return NORMAL; }\n-\n-/* ------------------------------------------ */\n-/* Control the assembler format that we output.  */\n-\n-/* Define standard character escape sequences for non-ASCII targets\n-   only.  */\n-\n-#ifdef TARGET_EBCDIC\n-#define TARGET_ESC\t39\n-#define TARGET_BELL\t47\n-#define TARGET_BS\t22\n-#define TARGET_TAB\t5\n-#define TARGET_NEWLINE\t21\n-#define TARGET_VT\t11\n-#define TARGET_FF\t12\n-#define TARGET_CR\t13\n-#endif\n-\n-/* ======================================================== */\n-\n-#ifdef TARGET_HLASM\n-#define TEXT_SECTION_ASM_OP \"* Program text area\"\n-#define DATA_SECTION_ASM_OP \"* Program data area\"\n-#define INIT_SECTION_ASM_OP \"* Program initialization area\"\n-#define SHARED_SECTION_ASM_OP \"* Program shared data\"\n-#define CTOR_LIST_BEGIN\t\t/* NO OP */\n-#define CTOR_LIST_END\t\t/* NO OP */\n-#define MAX_MVS_LABEL_SIZE 8\n-\n-/* How to refer to registers in assembler output.  This sequence is\n-   indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{ \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\t\t\t\\\n-  \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\t\t\t\\\n-  \"0\",  \"2\",  \"4\",  \"6\"\t\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_COMMENT_START \"*\"\n-#define ASM_APP_OFF \"\"\n-#define ASM_APP_ON \"\"\n-\n-#define ASM_OUTPUT_LABEL(FILE, NAME) \t\t\t\t\t\\\n-{ assemble_name (FILE, NAME); fputs (\"\\tEQU\\t*\\n\", FILE); }\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  char temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\t\\\n-  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* MVS externals are limited to 8 characters, upper case only.\n-   The '_' is mapped to '@', except for MVS functions, then '#'.  */\n-\n-\n-#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  char *bp, ch, temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\\\n-  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n-    strcpy (temp, NAME);\t\t\t\t\t\t\\\n-  if (!strcmp (temp,\"main\"))\t\t\t\t\t\t\\\n-    strcpy (temp,\"gccmain\");\t\t\t\t\t\t\\\n-  if (mvs_function_check (temp))\t\t\t\t\t\\\n-    ch = '#';\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    ch = '@';\t\t\t\t\t\t\t\t\\\n-  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n-    *bp = (*bp == '_' ? ch : TOUPPER (*bp));\t\t\t\t\\\n-  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n-  sprintf (LABEL, \"*%s%lu\", PREFIX, (unsigned long)(NUM))\n-\n-/* Generate case label.  For HLASM we can change to the data CSECT\n-   and put the vectors out of the code body. The assembler just\n-   concatenates CSECTs with the same name.  */\n-\n-#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n-  fprintf (FILE,\"\\tCSECT\\n\");                                           \\\n-  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n-\n-/* Put the CSECT back to the code body */\n-\n-#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n-  assemble_name (FILE, mvs_function_name);                              \\\n-  fputs (\"\\tCSECT\\n\", FILE);\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tA(L%d)\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n-  fprintf (FILE, \"\\tDC\\tA(L%d-L%d)\\n\", VALUE, REL)\n-\n-/* This is how to output an insn to push a register on the stack.\n-    It need not be very fast code.  \n-   Right now, PUSH & POP are used only when profiling is enabled, \n-   and then, only to push the static chain reg and the function struct \n-   value reg, and only if those are used.  Since profiling is not\n-   supported anyway, punt on this.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n-  mvs_check_page (FILE, 8, 4);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tS\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n-     reg_names[REGNO], STACK_POINTER_OFFSET)\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\t\t\t\t\\\n-  mvs_check_page (FILE, 8, 0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLA\\t13,4(13)\\n\",\t\t\t\\\n-     reg_names[REGNO], STACK_POINTER_OFFSET)\n-\n-/* This outputs a text string.  The string are chopped up to fit into\n-   an 80 byte record.  Also, control and special characters, interpreted\n-   by the IBM assembler, are output numerically.  */\n-\n-#define MVS_ASCII_TEXT_LENGTH 48\n-\n-#define ASM_OUTPUT_ASCII(FILE, PTR, LEN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  size_t i, limit = (LEN);\t\t\t\t\t\t\\\n-  int j;\t\t\t\t\t\t\t\t\\\n-  for (j = 0, i = 0; i < limit; j++, i++)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int c = (PTR)[i];\t\t\t\t\t\t\t\\\n-      if (ISCNTRL (c) || c == '&')\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (j % MVS_ASCII_TEXT_LENGTH != 0 )\t\t\t\t\\\n-\t    fprintf (FILE, \"'\\n\");\t\t\t\t\t\\\n-\t  j = -1;\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tDC\\tX'%X'\\n\", c );\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (j % MVS_ASCII_TEXT_LENGTH == 0)\t\t\t\t\\\n-            fprintf (FILE, \"\\tDC\\tC'\");\t\t\t\t\t\\\n-          if ( c == '\\'' )                                       \t\\\n-\t    fprintf (FILE, \"%c%c\", c, c);                        \t\\\n-\t  else                                                   \t\\\n-\t    fprintf (FILE, \"%c\", c);                             \t\\\n-\t  if (j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)\t\\\n-\t    fprintf (FILE, \"'\\n\" );\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (j % MVS_ASCII_TEXT_LENGTH != 0)\t\t\t\t\t\\\n-    fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n-}\n-\n-/* This is how to output an assembler line that says to advance the\n-   location counter to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\t\t\t\t\\\n-  if (LOG)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if ((LOG) == 1)\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tDS\\t0H\\n\" );\t\t\t\t\t\\\n-      else \t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\n-/* The maximum length of memory that the IBM assembler will allow in one\n-   DS operation.  */\n-\n-#define MAX_CHUNK 32767\n-\n-/* A C statement to output to the stdio stream FILE an assembler\n-   instruction to advance the location counter by SIZE bytes. Those\n-   bytes should be zero when loaded.  */\n-\n-#define ASM_OUTPUT_SKIP(FILE, SIZE)  \t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  unsigned HOST_WIDE_INT s;\t\t\t\t\t\t\\\n-  int  k;\t\t\t\t\t\t\t\t\\\n-  for (s = (SIZE); s > 0; s -= MAX_CHUNK)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (s > MAX_CHUNK)\t\t\t\t\t\t\\\n-\tk = MAX_CHUNK;\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tk = s;\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tDS\\tXL%d\\n\", k);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   FILE the assembler definition of a common-label named NAME whose\n-   size is SIZE bytes.  The variable ROUNDED is the size rounded up\n-   to whatever alignment the caller wants.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  char temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\t\\\n-  if (mvs_check_alias(NAME, temp) == 2)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\t\\\n-  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-  fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n-}\n-\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   FILE the assembler definition of a local-common-label named NAME\n-   whose size is SIZE bytes.  The variable ROUNDED is the size\n-   rounded up to whatever alignment the caller wants.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_PN_FORMAT \"%s%lu\"\n-\n-/* Print operand XV (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n-\n-#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      static char curreg[4];\t\t\t\t\t\t\\\n-      case REG:\t\t\t\t\t\t\t\t\\\n-\tif (CODE == 'N')\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (XV) + 1]);\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (XV)]);\t\t\t\\\n-\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case MEM:\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n-\t  if (CODE == 'O')\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-\t\tfprintf (FILE, HOST_WIDE_INT_PRINT_DEC, INTVAL (XEXP (addr, 1))); \\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-\t\tfprintf (FILE, \"%s\", reg_names[REGNO (XEXP (addr, 0))]);\\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"%s\", reg_names[REGNO (addr)]);\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-      case LABEL_REF:\t\t\t\t\t\t\t\\\n-\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-\tif (SYMBOL_REF_EXTERNAL_P (XV)) fprintf (FILE, \"=V(\");\t\t\\\n-\telse                      fprintf (FILE, \"=A(\");\t\t\\\n-\toutput_addr_const (FILE, XV);\t\t\t\t\t\\\n-\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST_INT:\t\t\t\t\t        \t\\\n-\tif (CODE == 'B')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%d\", (int) (INTVAL (XV) & 0xff));\t\t\\\n-\telse if (CODE == 'X')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%02X\", (int) (INTVAL (XV) & 0xff));\t\t\\\n-\telse if (CODE == 'h')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC, (INTVAL (XV) << 16) >> 16); \\\n-\telse if (CODE == 'H')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=H'\" HOST_WIDE_INT_PRINT_DEC \"'\", (INTVAL (XV) << 16) >> 16); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (CODE == 'K')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", (INTVAL (XV) << 16) >> 16); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (CODE == 'W')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n-\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n-\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n-\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n-            } else {\t\t\t\t\t\t\t\\\n-\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n-            }\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", INTVAL (XV)); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST_DOUBLE:\t\t\t\t\t\t\\\n-\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (CODE == 'M')\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (CODE == 'L')\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL8'%08X%08X'\", CONST_DOUBLE_LOW (XV),\t\\\n-\t\t\tCONST_DOUBLE_HIGH (XV));\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  { \t\t\t\t\t\t\t\t\\\n-            char buf[50];\t\t\t\t\t\t\\\n-\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n-\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n-\t\tfprintf (FILE, \"=E'%s'\", buf);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n-\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n-\t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else /* VOIDmode */\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n-\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST:\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    if (SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (XV, 0), 0)))\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n-\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n-\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n-\t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", \\\n-\t\t\t curreg, INTVAL (XEXP (XEXP (XV, 0), 1)));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n-\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n-\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\");\t\t\t\t\t\\\n-\t    output_addr_const (FILE, XV);\t\t\t\t\\\n-\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tabort();\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n-  \t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      case REG:\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"0(%s)\", reg_names[REGNO (ADDR)]);\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case PLUS:\t\t\t\t\t\t\t\\\n-\tbreg = 0;\t\t\t\t\t\t\t\\\n-\txreg = 0;\t\t\t\t\t\t\t\\\n-\toffset = 0;\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n-\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n-\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (breg)\t\t\t\t\t\t\\\n-\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n-\t\telse\t\t\t\t\t\t\t\\\n-\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (breg)\t\t\t\t\t\t\\\n-\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n-\t\telse\t\t\t\t\t\t\t\\\n-\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (breg)\t\t\t\t\t\t\t\\\n-\t      xreg = plus;\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      breg = plus;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    offset = plus;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (offset)\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n-\t      fprintf (FILE, \"L%d\",\t\t\t\t\t\\\n-\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      output_addr_const (FILE, offset);\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n-\tif (xreg)\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n-\t\t    reg_names[REGNO (xreg)], reg_names[REGNO (breg)]); \t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s)\", reg_names[REGNO (breg)]);\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-\tif (SYMBOL_REF_EXTERNAL_P (ADDR)) fprintf (FILE, \"=V(\");\t\\\n-\telse                        fprintf (FILE, \"=A(\");\t\t\\\n-\toutput_addr_const (FILE, ADDR);\t\t\t\t\t\\\n-\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (strlen (NAME) + 1 > mvs_function_name_length)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (mvs_function_name)\t\t\t\t\t\t\\\n-\tfree (mvs_function_name);\t\t\t\t\t\\\n-      mvs_function_name = 0;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (!mvs_function_name)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n-      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n-    strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n-  fputs (\"\\tRMODE\\tANY\\n\", FILE);\t\t\t\t\t\\\n-  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n-  fputs (\"\\tCSECT\\n\", FILE);\t\t\t\t\t\t\\\n-}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\t\\\n-  fprintf (FILE, \"Error: No profiling available.\\n\")\n-\n-#endif /* TARGET_HLASM */\n-\n-/* ======================================================== */\n-\n-#ifdef TARGET_ELF_ABI \n-\n-/* How to refer to registers in assembler output.  This sequence is\n-   indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{ \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n-  \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n-  \"f0\",  \"f2\",  \"f4\",  \"f6\"\t\t\t\t\t\t\\\n-}\n-\n-/* Print operand XV (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n-\n-#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      static char curreg[4];\t\t\t\t\t\t\\\n-      case REG:\t\t\t\t\t\t\t\t\\\n-\tif (CODE == 'N')\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (XV) + 1]);\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (XV)]);\t\t\t\\\n-\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case MEM:\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n-\t  if (CODE == 'O')\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-\t\tfprintf (FILE, HOST_WIDE_INT_PRINT_DEC, INTVAL (XEXP (addr, 1))); \\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-\t\tfprintf (FILE, \"%s\", reg_names[REGNO (XEXP (addr, 0))]);\\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"%s\", reg_names[REGNO (addr)]);\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-      case LABEL_REF:\t\t\t\t\t\t\t\\\n-\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-        if (SYMBOL_REF_EXTERNAL_P (XV)) fprintf (FILE, \"=V(\");\t\t\\\n-        else                      fprintf (FILE, \"=A(\");                \\\n-        output_addr_const (FILE, XV);                                   \\\n-        fprintf (FILE, \")\");                                            \\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST_INT:\t\t\t\t\t        \t\\\n-\tif (CODE == 'B')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%d\", (int) (INTVAL (XV) & 0xff));\t\t\\\n-\telse if (CODE == 'X')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%02X\", (int) (INTVAL (XV) & 0xff));\t\t\\\n-\telse if (CODE == 'h')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC, (INTVAL (XV) << 16) >> 16); \\\n-\telse if (CODE == 'H')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=H'\" HOST_WIDE_INT_PRINT_DEC \"'\",\t\t\\\n-\t\t     (INTVAL (XV) << 16) >> 16);\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (CODE == 'K')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\",\t\t\\\n-\t\t     (INTVAL (XV) << 16) >> 16);\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (CODE == 'W')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n-\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n-\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n-\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n-            } else {\t\t\t\t\t\t\t\\\n-\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n-            }\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", INTVAL (XV)); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST_DOUBLE:\t\t\t\t\t\t\\\n-\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (CODE == 'M')\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (CODE == 'L')\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=yyyyXL8'%08X%08X'\", \t\t\t\\\n-\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  { \t\t\t\t\t\t\t\t\\\n-            char buf[50];\t\t\t\t\t\t\\\n-\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n-\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n-\t\tfprintf (FILE, \"=E'%s'\", buf);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n-\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n-\t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else /* VOIDmode */\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n-\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST:\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    if (SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (XV, 0), 0)))\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n-\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n-\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n-\t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", \\\n-\t\t\t curreg, INTVAL (XEXP (XEXP (XV, 0), 1)));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n-\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n-\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=bogus_bad_F'\");\t\t\t\t\\\n-\t    output_addr_const (FILE, XV);\t\t\t\t\\\n-\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n-/* XXX hack alert this gets gen'd in -fPIC code in relation to a tablejump */  \\\n-/* but its somehow fundamentally broken, I can't make any sense out of it */  \\\n-debug_rtx (XV); \\\n-abort(); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tabort();\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n-  \t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      case REG:\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"0(%s)\", reg_names[REGNO (ADDR)]);\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case PLUS:\t\t\t\t\t\t\t\\\n-\tbreg = 0;\t\t\t\t\t\t\t\\\n-\txreg = 0;\t\t\t\t\t\t\t\\\n-\toffset = 0;\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n-\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n-\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (breg)\t\t\t\t\t\t\\\n-\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n-\t\telse\t\t\t\t\t\t\t\\\n-\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (breg)\t\t\t\t\t\t\\\n-\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n-\t\telse\t\t\t\t\t\t\t\\\n-\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (breg)\t\t\t\t\t\t\t\\\n-\t      xreg = plus;\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      breg = plus;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    offset = plus;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (offset)\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n-\t      fprintf (FILE, \"L%d\",\t\t\t\t\t\\\n-\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      output_addr_const (FILE, offset);\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n-\tif (xreg)\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n-\t\t    reg_names[REGNO (xreg)], reg_names[REGNO (breg)]); \t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s)\", reg_names[REGNO (breg)]);\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-\tif (SYMBOL_REF_EXTERNAL_P (ADDR)) fprintf (FILE, \"=V(\");\t\\\n-\telse                        fprintf (FILE, \"=A(\");\t\t\\\n-\toutput_addr_const (FILE, ADDR);\t\t\t\t\t\\\n-\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-/* Make it a no-op for now, so we can at least compile glibc */\n-#define FUNCTION_PROFILER(FILE, LABELNO)  {\t\t\t\t\\\n-  mvs_check_page (FILE, 24, 4);\t\t\t\t\t\t\\\n-     fprintf (FILE, \"\\tSTM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n-     fprintf (FILE, \"\\tLA\\tr1,1(0,0)\\n\"); \t\t\t\t\\\n-     fprintf (FILE, \"\\tL\\tr2,=A(.LP%d)\\n\", LABELNO);\t\t\t\\\n-     fprintf (FILE, \"\\tA\\tr1,0(r2)\\n\");\t\t\t \t\t\\\n-     fprintf (FILE, \"\\tST\\tr1,0(r2)\\n\");\t\t \t\t\\\n-     fprintf (FILE, \"\\tLM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n-}\n-\n-/* Don't bother to output .extern pseudo-ops.  They are not needed by\n-   ELF assemblers.  */\n-\n-#undef ASM_OUTPUT_EXTERNAL\n-\n-#define ASM_DOUBLE \"\\t.double\"     \n-\n-/* #define ASM_OUTPUT_LABELREF(FILE, NAME) */\t/* use gas -- defaults.h */\n-\n-/* let config/svr4.h define this ...\n- *  #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\n- *    fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n- */\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n-  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.long\\t.L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n-  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.long\\t.L%d-.L%d\\n\", VALUE, REL)\n-\n-/* Right now, PUSH & POP are used only when profiling is enabled, \n-   and then, only to push the static chain reg and the function struct \n-   value reg, and only if those are used by the function being profiled.\n-   We don't need this for profiling, so punt.  */\n-#define ASM_OUTPUT_REG_PUSH(FILE, REGNO) \n-#define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\n-\n-\n-/* Indicate that jump tables go in the text section.  This is\n-   necessary when compiling PIC code.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\n-/* Define macro used to output shift-double opcodes when the shift\n-   count is in %cl.  Some assemblers require %cl as an argument;\n-   some don't.\n-\n-   GAS requires the %cl argument, so override i386/unix.h.  */\n-\n-#undef SHIFT_DOUBLE_OMITS_COUNT\n-#define SHIFT_DOUBLE_OMITS_COUNT 0\n-\n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-#define TARGET_MEM_FUNCTIONS\n- \n-/* Output before read-only data.  */\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable (initialized) data.  */\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* Output before writable (uninitialized) data.  */\n-#define BSS_SECTION_ASM_OP \"\\t.bss\"\n-\n-/* In the past there was confusion as to what the argument to .align was\n-   in GAS.  For the last several years the rule has been this: for a.out\n-   file formats that argument is LOG, and for all other file formats the\n-   argument is 1<<LOG.\n-\n-   However, GAS now has .p2align and .balign pseudo-ops so to remove any\n-   doubt or guess work, and since this file is used for both a.out and other\n-   file formats, we use one of them.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n-  if ((LOG)!=0) fprintf ((FILE), \"\\t.balign %d\\n\", 1<<(LOG))\n- \n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \".globl \"\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),                     \\\n-  assemble_name ((FILE), (NAME)),               \\\n-  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),                    \\\n-  assemble_name ((FILE), (NAME)),               \\\n-  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (ROUNDED)))\n-\n-#endif /* TARGET_ELF_ABI */\n-#endif /* ! GCC_I370_H */"}, {"sha": "342b6e8727e38d4f60821d8dcbe51ce5e65a965c", "filename": "gcc/config/i370/i370.md", "status": "removed", "additions": 0, "deletions": 4739, "changes": 4739, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "f402fbde9f3d50ddbfac43c651fb29340aa656c8", "filename": "gcc/config/i370/linux.h", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Flinux.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,113 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for Linux/390 by Linas Vepstas (linas@linas.org)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#define TARGET_VERSION fprintf (stderr, \" (i370 GNU/Linux with ELF)\");\n-\n-/* Specify that we're generating code for a Linux port to 370 */\n-\n-#define TARGET_ELF_ABI\n-\n-/* Target OS preprocessor built-ins.  */\n-#define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()\n-\n-/* Options for this target machine.  */\n-\n-#define LIBGCC_SPEC \"libgcc.a%s\"\n-\n-#ifdef SOME_FUTURE_DAY\n- \n-#define CPP_SPEC \"%{posix: -D_POSIX_SOURCE} %(cpp_sysv) %(cpp_endian_big) \\\n-%{mcall-linux: %(cpp_os_linux) } \\\n-%{!mcall-linux: %(cpp_os_default) }\"\n-\n-#define LIB_SPEC \"\\\n-%{mcall-linux: %(lib_linux) } \\\n-%{!mcall-linux:%(lib_default) }\"\n-\n-#define STARTFILE_SPEC \"\\\n-%{mcall-linux: %(startfile_linux) } \\\n-%{!mcall-linux: %(startfile_default) }\"\n-\n-#define ENDFILE_SPEC \"\\\n-%{mcall-linux: %(endfile_linux) } \\\n-%{!mcall-linux: %(endfile_default) }\"\n-\n-/* GNU/Linux support.  */\n-#ifndef LIB_LINUX_SPEC\n-#define LIB_LINUX_SPEC \"%{mnewlib: --start-group -llinux -lc --end-group } %{!mnewlib: -lc }\"\n-#endif\n-\n-#ifndef STARTFILE_LINUX_SPEC\n-#define STARTFILE_LINUX_SPEC \"\\\n-%{!shared: %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}} \\\n-%{mnewlib: ecrti.o%s} \\\n-%{!mnewlib: crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}}\"\n-#endif\n-\n-#ifndef ENDFILE_LINUX_SPEC\n-#define ENDFILE_LINUX_SPEC \"\\\n-%{mnewlib: ecrtn.o%s} \\\n-%{!mnewlib: %{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s}\"\n-#endif\n-\n-#ifndef LINK_START_LINUX_SPEC\n-#define LINK_START_LINUX_SPEC \"-Ttext 0x10000\"\n-#endif\n-\n-#ifndef LINK_OS_LINUX_SPEC\n-#define LINK_OS_LINUX_SPEC \"\"\n-#endif\n-\n-#ifndef CPP_OS_LINUX_SPEC\n-#define CPP_OS_LINUX_SPEC \"-D__unix__ -D__gnu_linux__ -D__linux__ \\\n-%{!ansi: -Dunix -Dlinux } \\\n--Asystem=unix -Asystem=linux\"\n-#endif\n-\n-#ifndef CPP_OS_LINUX_SPEC\n-#define CPP_OS_LINUX_SPEC \"\"\n-#endif\n-\n-\n-/* Define any extra SPECS that the compiler needs to generate.  */\n-#undef  SUBTARGET_EXTRA_SPECS\n-#define SUBTARGET_EXTRA_SPECS                                           \\\n-  { \"lib_linux\",                LIB_LINUX_SPEC },                       \\\n-  { \"lib_default\",              LIB_DEFAULT_SPEC },                     \\\n-  { \"startfile_linux\",          STARTFILE_LINUX_SPEC },                 \\\n-  { \"startfile_default\",        STARTFILE_DEFAULT_SPEC },               \\\n-  { \"endfile_linux\",            ENDFILE_LINUX_SPEC },                   \\\n-  { \"endfile_default\",          ENDFILE_DEFAULT_SPEC },                 \\\n-  { \"link_shlib\",               LINK_SHLIB_SPEC },                      \\\n-  { \"link_target\",              LINK_TARGET_SPEC },                     \\\n-  { \"link_start\",               LINK_START_SPEC },                      \\\n-  { \"link_start_linux\",         LINK_START_LINUX_SPEC },                \\\n-  { \"link_os\",                  LINK_OS_SPEC },                         \\\n-  { \"link_os_linux\",            LINK_OS_LINUX_SPEC },                   \\\n-  { \"link_os_default\",          LINK_OS_DEFAULT_SPEC },                 \\\n-  { \"cpp_endian_big\",           CPP_ENDIAN_BIG_SPEC },                  \\\n-  { \"cpp_os_linux\",             CPP_OS_LINUX_SPEC },                    \\\n-  { \"cpp_os_default\",           CPP_OS_DEFAULT_SPEC },\n-\n-#endif /* SOME_FUTURE_DAY */"}, {"sha": "dfb4cba188ae9a5fa1a550bf003237ca698079e5", "filename": "gcc/config/i370/mvs.h", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fmvs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Fmvs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fmvs.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,49 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define TARGET_VERSION printf (\" (370/MVS)\");\n-\n-/* Specify that we're generating code for the Language Environment */\n-\n-#define LE370 1\n-#define TARGET_EBCDIC 1\n-#define TARGET_HLASM 1\n-\n-/* Options for the preprocessor for this target machine.  */\n-\n-#define CPP_SPEC \"-trigraphs\"\n-\n-/* Target OS preprocessor built-ins.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tbuiltin_define_std (\"MVS\");\t\t\\\n-\tbuiltin_define_std (\"mvs\");\t\t\\\n-\tMAYBE_LE370_MACROS();\t\t\t\\\n-\tbuiltin_assert (\"system=mvs\");\t\t\\\n-    } while (0)\n-\n-#if defined(LE370)\n-# define MAYBE_LE370_MACROS() do {builtin_define_std (\"LE370\");} while (0)\n-#else\n-# define MAYBE_LE370_MACROS()\n-#endif"}, {"sha": "088c043530eeacbb0dd38e2f9315a23f71a1fbb0", "filename": "gcc/config/i370/oe.h", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Foe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Foe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Foe.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,53 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define TARGET_VERSION printf (\" (370/OpenEdition)\");\n-\n-/* Specify that we're generating code for the Language Environment */\n-\n-#define LE370 1\n-#define LONGEXTERNAL 1\n-#define TARGET_EBCDIC 1\n-#define TARGET_HLASM 1\n-\n-/* Options for the preprocessor for this target machine.  */\n-\n-#define CPP_SPEC \"-trigraphs\"\n-\n-/* Options for this target machine.  */\n-\n-#define LIB_SPEC \"\"\n-#define LIBGCC_SPEC \"\"\n-#define STARTFILE_SPEC \"/usr/local/lib/gccmain.o\"\n-\n-/* Target OS preprocessor built-ins.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\\\n-\tbuiltin_define_std (\"UNIX\");\t\t\\\n-\tbuiltin_define_std (\"openedition\");\t\\\n-\tbuiltin_define (\"__i370__\");\t\t\\\n-\tbuiltin_assert (\"system=openedition\");\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\\\n-    } while (0)\n-"}, {"sha": "fccd1632fde40e63f20385f2e5eb2ab18aec7a02", "filename": "gcc/config/i370/t-i370", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Ft-i370", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi370%2Ft-i370", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Ft-i370?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,3 +0,0 @@\n-i370-c.o: $(srcdir)/config/i370/i370-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(TM_H) $(TREE_H) toplev.h $(CPPLIB_H) c-pragma.h $(TM_P_H)\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/i370/i370-c.c"}, {"sha": "6c1199e352e4085d06be5082a3dd4b3ab49f61d2", "filename": "gcc/config/i960/i960-c.c", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-c.c?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,117 +0,0 @@\n-/* Intel 80960 specific, C compiler specific functions.\n-   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"cpplib.h\"\n-#include \"tree.h\"\n-#include \"c-pragma.h\"\n-#include \"toplev.h\"\n-#include \"ggc.h\"\n-#include \"tm_p.h\"\n-\n-/* Handle pragmas for compatibility with Intel's compilers.  */\n-\n-/* NOTE: ic960 R3.0 pragma align definition:\n-\n-   #pragma align [(size)] | (identifier=size[,...])\n-   #pragma noalign [(identifier)[,...]]\n-     \n-   (all parens are optional)\n-     \n-   - size is [1,2,4,8,16]\n-   - noalign means size==1\n-   - applies only to component elements of a struct (and union?)\n-   - identifier applies to structure tag (only)\n-   - missing identifier means next struct\n-     \n-   - alignment rules for bitfields need more investigation.\n-\n-   This implementation only handles the case of no identifiers.  */\n-\n-void\n-i960_pr_align (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree number;\n-  enum cpp_ttype type;\n-  int align;\n-\n-  type = c_lex (&number);\n-  if (type == CPP_OPEN_PAREN)\n-    type = c_lex (&number);\n-  if (type == CPP_NAME)\n-    {\n-      warning (\"sorry, not implemented: #pragma align NAME=SIZE\");\n-      return;\n-    }\n-  if (type != CPP_NUMBER)\n-    {\n-      warning (\"malformed #pragma align - ignored\");\n-      return;\n-    }\n-\n-  align = TREE_INT_CST_LOW (number);\n-  switch (align)\n-    {\n-    case 0:\n-      /* Return to last alignment.  */\n-      align = i960_last_maxbitalignment / 8;\n-      /* Fall through.  */\n-    case 16:\n-    case 8:\n-    case 4:\n-    case 2:\n-    case 1:\n-      i960_last_maxbitalignment = i960_maxbitalignment;\n-      i960_maxbitalignment = align * 8;\n-      break;\n-      \n-    default:\n-      /* Silently ignore bad values.  */\n-      break;\n-    }\n-}\n-\n-void\n-i960_pr_noalign (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  enum cpp_ttype type;\n-  tree number;\n-\n-  type = c_lex (&number);\n-  if (type == CPP_OPEN_PAREN)\n-    type = c_lex (&number);\n-  if (type == CPP_NAME)\n-    {\n-      warning (\"sorry, not implemented: #pragma noalign NAME\");\n-      return;\n-    }\n-\n-  i960_last_maxbitalignment = i960_maxbitalignment;\n-  i960_maxbitalignment = 8;\n-}"}, {"sha": "465ea33cc3e76a2aad2e0e693f93baca5f0444e4", "filename": "gcc/config/i960/i960-coff.h", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960-coff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960-coff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-coff.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,43 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for \"naked\" Intel\n-   80960 using coff object format and coff debugging symbols.\n-   Copyright (C) 1988, 1989, 1991, 1996, 2000 Free Software Foundation.\n-   Contributed by Steven McGeady (mcg@omepd.intel.com)\n-   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Support -gstabs using stabs in COFF sections.  */\n-\n-/* Generate SDB_DEBUGGING_INFO by default.  */\n-#undef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n-\n-/* This is intended to be used with Cygnus's newlib library, so we want to\n-   use the standard definition of LIB_SPEC.  */\n-#undef LIB_SPEC\n-\n-/* Emit a .file directive.  */\n-#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n-\n-/* Support the ctors and dtors sections for g++.  */\n-\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"x\\\"\"\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"x\\\"\"\n-\n-/* end of i960-coff.h */"}, {"sha": "e99939049c62734e62d3f7aba6e239841f2ecb37", "filename": "gcc/config/i960/i960-modes.def", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-modes.def?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,33 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for Intel 80960\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* long double */\n-FLOAT_MODE (TF, 16, ieee_extended_intel_128_format);\n-\n-/* Add any extra modes needed to represent the condition code.\n-\n-   Also, signed and unsigned comparisons are distinguished, as\n-   are operations which are compatible with chkbit insns.  */\n-\n-CC_MODE (CC_UNS);\n-CC_MODE (CC_CHK);"}, {"sha": "269a40be19cbbd99622c0cd221a1e2788cbd1c2a", "filename": "gcc/config/i960/i960-protos.h", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-protos.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,102 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for Intel 80960\n-   Copyright (C) 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_I960_PROTOS_H\n-#define GCC_I960_PROTOS_H\n-\n-#ifdef RTX_CODE\n-extern struct rtx_def *legitimize_address (rtx, rtx, enum machine_mode);\n-/* Define the function that build the compare insn for scc and bcc.  */\n-\n-extern struct rtx_def *gen_compare_reg (enum rtx_code, rtx, rtx);\n-\n-/* Define functions in i960.c and used in insn-output.c.  */\n-\n-extern const char *i960_output_ldconst (rtx, rtx);\n-extern const char *i960_output_call_insn (rtx, rtx, rtx, rtx);\n-extern const char *i960_output_ret_insn (rtx);\n-extern const char *i960_output_move_double (rtx, rtx);\n-extern const char *i960_output_move_double_zero (rtx);\n-extern const char *i960_output_move_quad (rtx, rtx);\n-extern const char *i960_output_move_quad_zero (rtx);\n-\n-extern int literal (rtx, enum machine_mode);\n-extern int hard_regno_mode_ok (int, enum machine_mode);\n-extern int fp_literal (rtx, enum machine_mode);\n-extern int signed_literal (rtx, enum machine_mode);\n-extern int legitimate_address_p (enum machine_mode, rtx, int);\n-extern void i960_print_operand (FILE *, rtx, int);\n-extern int fpmove_src_operand (rtx, enum machine_mode);\n-extern int arith_operand (rtx, enum machine_mode);\n-extern int logic_operand (rtx, enum machine_mode);\n-extern int fp_arith_operand (rtx, enum machine_mode);\n-extern int signed_arith_operand (rtx, enum machine_mode);\n-extern int fp_literal_one (rtx, enum machine_mode);\n-extern int fp_literal_zero (rtx, enum machine_mode);\n-extern int symbolic_memory_operand (rtx, enum machine_mode);\n-extern int eq_or_neq (rtx, enum machine_mode);\n-extern int arith32_operand (rtx, enum machine_mode);\n-extern int power2_operand (rtx, enum machine_mode);\n-extern int cmplpower2_operand (rtx, enum machine_mode);\n-extern enum machine_mode select_cc_mode (RTX_CODE, rtx);\n-extern int emit_move_sequence (rtx *, enum machine_mode);\n-extern int i960_bypass (rtx, rtx, rtx, int);\n-extern void i960_print_operand_addr (FILE *, rtx);\n-extern int i960_expr_alignment (rtx, int);\n-extern int i960_improve_align (rtx, rtx, int);\n-extern int i960_si_ti (rtx, rtx);\n-extern int i960_si_di (rtx, rtx);\n-#ifdef TREE_CODE\n-extern struct rtx_def *i960_function_arg (CUMULATIVE_ARGS *,\n-\t\t\t\t\t  enum machine_mode,\n-\t\t\t\t\t  tree, int);\n-extern rtx i960_va_arg (tree, tree);\n-extern void i960_va_start (tree, rtx);\n-#endif /* TREE_CODE */\n-extern enum reg_class secondary_reload_class (enum reg_class, enum machine_mode, rtx);\n-#endif /* RTX_CODE */\n-\n-#ifdef TREE_CODE\n-extern void i960_function_name_declare (FILE *, const char *, tree);\n-extern void i960_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n-extern int i960_round_align (int, tree);\n-extern void i960_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n-extern int i960_final_reg_parm_stack_space (int, tree);\n-extern int i960_reg_parm_stack_space (tree);\n-#endif /* TREE_CODE */\n-\n-extern int process_pragma (int(*)(void), void(*)(int), const char *);\n-extern int i960_object_bytes_bitalign (int);\n-extern void i960_initialize (void);\n-extern int bitpos (unsigned int);\n-extern int is_mask (unsigned int);\n-extern int bitstr (unsigned int, int *, int *);\n-extern int compute_frame_size (int);\n-extern void output_function_profiler (FILE *, int);\n-extern void i960_scan_opcode (const char *);\n-\n-extern void i960_pr_align (struct cpp_reader *);\n-extern void i960_pr_noalign (struct cpp_reader *);\n-\n-#endif /* ! GCC_I960_PROTOS_H  */"}, {"sha": "3d976b65fd4e32d732cb6693235f71cd18d87bcb", "filename": "gcc/config/i960/i960.c", "status": "removed", "additions": 0, "deletions": 2917, "changes": 2917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,2917 +0,0 @@\n-/* Subroutines used for code generation on intel 80960.\n-   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include <math.h>\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"flags.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"except.h\"\n-#include \"function.h\"\n-#include \"recog.h\"\n-#include \"toplev.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-static void i960_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void i960_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void i960_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t  HOST_WIDE_INT, tree);\n-static bool i960_rtx_costs (rtx, int, int, int *);\n-static int i960_address_cost (rtx);\n-static tree i960_build_builtin_va_list (void);\n-\n-/* Save the operands last given to a compare for use when we\n-   generate a scc or bcc insn.  */\n-\n-rtx i960_compare_op0, i960_compare_op1;\n-\n-/* Used to implement #pragma align/noalign.  Initialized by OVERRIDE_OPTIONS\n-   macro in i960.h.  */\n-\n-int i960_maxbitalignment;\n-int i960_last_maxbitalignment;\n-\n-/* Used to implement switching between MEM and ALU insn types, for better\n-   C series performance.  */\n-\n-enum insn_types i960_last_insn_type;\n-\n-/* The leaf-procedure return register.  Set only if this is a leaf routine.  */\n-\n-static int i960_leaf_ret_reg;\n-\n-/* True if replacing tail calls with jumps is OK.  */\n-\n-static int tail_call_ok;\n-\n-/* A string containing a list of insns to emit in the epilogue so as to\n-   restore all registers saved by the prologue.  Created by the prologue\n-   code as it saves registers away.  */\n-\n-char epilogue_string[1000];\n-\n-/* A unique number (per function) for return labels.  */\n-\n-static int ret_label = 0;\n-\n-/* This is true if FNDECL is either a varargs or a stdarg function.\n-   This is used to help identify functions that use an argument block.  */\n-\n-#define VARARGS_STDARG_FUNCTION(FNDECL)\t\\\n-(TYPE_ARG_TYPES (TREE_TYPE (FNDECL)) != 0\t\t\t\t\\\n-  && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (FNDECL)))))\t\\\n-      != void_type_node)\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE i960_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE i960_output_function_epilogue\n-\n-#undef TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK i960_output_mi_thunk\n-#undef TARGET_CAN_ASM_OUTPUT_MI_THUNK\n-#define TARGET_CAN_ASM_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS i960_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST i960_address_cost\n-\n-#undef TARGET_BUILD_BUILTIN_VA_LIST\n-#define TARGET_BUILD_BUILTIN_VA_LIST i960_build_builtin_va_list\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Override conflicting target switch options.\n-   Doesn't actually detect if more than one -mARCH option is given, but\n-   does handle the case of two blatantly conflicting -mARCH options.\n-\n-   Also initialize variables before compiling any files.  */\n-\n-void\n-i960_initialize ()\n-{\n-  if (TARGET_K_SERIES && TARGET_C_SERIES)\n-    {\n-      warning (\"conflicting architectures defined - using C series\");\n-      target_flags &= ~TARGET_FLAG_K_SERIES;\n-    }\n-  if (TARGET_K_SERIES && TARGET_MC)\n-    {\n-      warning (\"conflicting architectures defined - using K series\");\n-      target_flags &= ~TARGET_FLAG_MC;\n-    }\n-  if (TARGET_C_SERIES && TARGET_MC)\n-    {\n-      warning (\"conflicting architectures defined - using C series\");\n-      target_flags &= ~TARGET_FLAG_MC;\n-    }\n-  if (TARGET_IC_COMPAT3_0)\n-    {\n-      flag_short_enums = 1;\n-      flag_signed_char = 1;\n-      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\n-      if (TARGET_IC_COMPAT2_0)\n-\t{\n-\t  warning (\"iC2.0 and iC3.0 are incompatible - using iC3.0\");\n-\t  target_flags &= ~TARGET_FLAG_IC_COMPAT2_0;\n-\t}\n-    }\n-  if (TARGET_IC_COMPAT2_0)\n-    {\n-      flag_signed_char = 1;\n-      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\n-    }\n-\n-  if (TARGET_IC_COMPAT2_0)\n-    {\n-      i960_maxbitalignment = 8;\n-      i960_last_maxbitalignment = 128;\n-    }\n-  else\n-    {\n-      i960_maxbitalignment = 128;\n-      i960_last_maxbitalignment = 8;\n-    }\n-}\n-\f\n-/* Return true if OP can be used as the source of an fp move insn.  */\n-\n-int\n-fpmove_src_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (GET_CODE (op) == CONST_DOUBLE || general_operand (op, mode));\n-}\n-\n-#if 0\n-/* Return true if OP is a register or zero.  */\n-\n-int\n-reg_or_zero_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return register_operand (op, mode) || op == const0_rtx;\n-}\n-#endif\n-\n-/* Return truth value of whether OP can be used as an operands in a three\n-   address arithmetic insn (such as add %o1,7,%l2) of mode MODE.  */\n-\n-int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) || literal (op, mode));\n-}\n-\n-/* Return truth value of whether OP can be used as an operands in a three\n-   address logic insn, possibly complementing OP, of mode MODE.  */\n-\n-int\n-logic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && INTVAL(op) >= -32 && INTVAL(op) < 32));\n-}\n-\n-/* Return true if OP is a register or a valid floating point literal.  */\n-\n-int\n-fp_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) || fp_literal (op, mode));\n-}\n-\n-/* Return true if OP is a register or a valid signed integer literal.  */\n-\n-int\n-signed_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) || signed_literal (op, mode));\n-}\n-\n-/* Return truth value of whether OP is an integer which fits the\n-   range constraining immediate operands in three-address insns.  */\n-\n-int\n-literal (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return ((GET_CODE (op) == CONST_INT) && INTVAL(op) >= 0 && INTVAL(op) < 32);\n-}\n-\n-/* Return true if OP is a float constant of 1.  */\n-\n-int\n-fp_literal_one (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (TARGET_NUMERICS && mode == GET_MODE (op) && op == CONST1_RTX (mode));\n-}\n-\n-/* Return true if OP is a float constant of 0.  */\n-\n-int\n-fp_literal_zero (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (TARGET_NUMERICS && mode == GET_MODE (op) && op == CONST0_RTX (mode));\n-}\n-\n-/* Return true if OP is a valid floating point literal.  */\n-\n-int\n-fp_literal(op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return fp_literal_zero (op, mode) || fp_literal_one (op, mode);\n-}\n-\n-/* Return true if OP is a valid signed immediate constant.  */\n-\n-int\n-signed_literal(op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return ((GET_CODE (op) == CONST_INT) && INTVAL(op) > -32 && INTVAL(op) < 32);\n-}\n-\n-/* Return truth value of statement that OP is a symbolic memory\n-   operand of mode MODE.  */\n-\n-int\n-symbolic_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n-\t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n-}\n-\n-/* Return truth value of whether OP is EQ or NE.  */\n-\n-int\n-eq_or_neq (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n-}\n-\n-/* OP is an integer register or a constant.  */\n-\n-int\n-arith32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-  return (CONSTANT_P (op));\n-}\n-\n-/* Return true if OP is an integer constant which is a power of 2.  */\n-\n-int\n-power2_operand (op,mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  return exact_log2 (INTVAL (op)) >= 0;\n-}\n-\n-/* Return true if OP is an integer constant which is the complement of a\n-   power of 2.  */\n-\n-int\n-cmplpower2_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  return exact_log2 (~ INTVAL (op)) >= 0;\n-}\n-\n-/* If VAL has only one bit set, return the index of that bit.  Otherwise\n-   return -1.  */\n-\n-int\n-bitpos (val)\n-     unsigned int val;\n-{\n-  register int i;\n-\n-  for (i = 0; val != 0; i++, val >>= 1)\n-    {\n-      if (val & 1)\n-\t{\n-\t  if (val != 1)\n-\t    return -1;\n-\t  return i;\n-\t}\n-    }\n-  return -1;\n-}\n-\n-/* Return nonzero if OP is a mask, i.e. all one bits are consecutive.\n-   The return value indicates how many consecutive nonzero bits exist\n-   if this is a mask.  This is the same as the next function, except that\n-   it does not indicate what the start and stop bit positions are.  */\n-\n-int\n-is_mask (val)\n-     unsigned int val;\n-{\n-  register int start, end = 0, i;\n-\n-  start = -1;\n-  for (i = 0; val != 0; val >>= 1, i++)\n-    {\n-      if (val & 1)\n-\t{\n-\t  if (start < 0)\n-\t    start = i;\n-\n-\t  end = i;\n-\t  continue;\n-\t}\n-      /* Still looking for the first bit.  */\n-      if (start < 0)\n-\tcontinue;\n-\n-      /* We've seen the start of a bit sequence, and now a zero.  There\n-\t must be more one bits, otherwise we would have exited the loop.\n-\t Therefore, it is not a mask.  */\n-      if (val)\n-\treturn 0;\n-    }\n-\n-  /* The bit string has ones from START to END bit positions only.  */\n-  return end - start + 1;\n-}\n-\n-/* If VAL is a mask, then return nonzero, with S set to the starting bit\n-   position and E set to the ending bit position of the mask.  The return\n-   value indicates how many consecutive bits exist in the mask.  This is\n-   the same as the previous function, except that it also indicates the\n-   start and end bit positions of the mask.  */\n-\n-int\n-bitstr (val, s, e)\n-     unsigned int val;\n-     int *s, *e;\n-{\n-  register int start, end, i;\n-\n-  start = -1;\n-  end = -1;\n-  for (i = 0; val != 0; val >>= 1, i++)\n-    {\n-      if (val & 1)\n-\t{\n-\t  if (start < 0)\n-\t    start = i;\n-\n-\t  end = i;\n-\t  continue;\n-\t}\n-\n-      /* Still looking for the first bit.  */\n-      if (start < 0)\n-\tcontinue;\n-\n-      /* We've seen the start of a bit sequence, and now a zero.  There\n-\t must be more one bits, otherwise we would have exited the loop.\n-\t Therefor, it is not a mask.  */\n-      if (val)\n-\t{\n-\t  start = -1;\n-\t  end = -1;\n-\t  break;\n-\t}\n-    }\n-\n-  /* The bit string has ones from START to END bit positions only.  */\n-  *s = start;\n-  *e = end;\n-  return ((start < 0) ? 0 : end - start + 1);\n-}\n-\f\n-/* Return the machine mode to use for a comparison.  */\n-\n-enum machine_mode\n-select_cc_mode (op, x)\n-     RTX_CODE op;\n-     rtx x ATTRIBUTE_UNUSED;\n-{\n-  if (op == GTU || op == LTU || op == GEU || op == LEU)\n-    return CC_UNSmode;\n-  return CCmode;\n-}\n-\n-/* X and Y are two things to compare using CODE.  Emit the compare insn and\n-   return the rtx for register 36 in the proper mode.  */\n-\n-rtx\n-gen_compare_reg (code, x, y)\n-     enum rtx_code code;\n-     rtx x, y;\n-{\n-  rtx cc_reg;\n-  enum machine_mode ccmode = SELECT_CC_MODE (code, x, y);\n-  enum machine_mode mode\n-    = GET_MODE (x) == VOIDmode ? GET_MODE (y) : GET_MODE (x);\n-\n-  if (mode == SImode)\n-    {\n-      if (! arith_operand (x, mode))\n-\tx = force_reg (SImode, x);\n-      if (! arith_operand (y, mode))\n-\ty = force_reg (SImode, y);\n-    }\n-\n-  cc_reg = gen_rtx_REG (ccmode, 36);\n-  emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n-\t\t\t  gen_rtx_COMPARE (ccmode, x, y)));\n-\n-  return cc_reg;\n-}\n-\n-/* For the i960, REG is cost 1, REG+immed CONST is cost 2, REG+REG is cost 2,\n-   REG+nonimmed CONST is cost 4.  REG+SYMBOL_REF, SYMBOL_REF, and similar\n-   are 4.  Indexed addresses are cost 6.  */\n-\n-/* ??? Try using just RTX_COST, i.e. not defining ADDRESS_COST.  */\n-\n-static int\n-i960_address_cost (x)\n-     rtx x;\n-{\n-  if (GET_CODE (x) == REG)\n-    return 1;\n-\n-  /* This is a MEMA operand -- it's free.  */\n-  if (GET_CODE (x) == CONST_INT\n-      && INTVAL (x) >= 0\n-      && INTVAL (x) < 4096)\n-    return 0;\n-\n-  if (GET_CODE (x) == PLUS)\n-    {\n-      rtx base = XEXP (x, 0);\n-      rtx offset = XEXP (x, 1);\n-\n-      if (GET_CODE (base) == SUBREG)\n-\tbase = SUBREG_REG (base);\n-      if (GET_CODE (offset) == SUBREG)\n-\toffset = SUBREG_REG (offset);\n-\n-      if (GET_CODE (base) == REG)\n-\t{\n-\t  if (GET_CODE (offset) == REG)\n-\t    return 2;\n-\t  if (GET_CODE (offset) == CONST_INT)\n-\t    {\n-\t      if ((unsigned)INTVAL (offset) < 2047)\n-\t\treturn 2;\n-\t      return 4;\n-\t    }\n-\t  if (CONSTANT_P (offset))\n-\t    return 4;\n-\t}\n-      if (GET_CODE (base) == PLUS || GET_CODE (base) == MULT)\n-\treturn 6;\n-\n-      /* This is an invalid address.  The return value doesn't matter, but\n-\t for convenience we make this more expensive than anything else.  */\n-      return 12;\n-    }\n-  if (GET_CODE (x) == MULT)\n-    return 6;\n-\n-  /* Symbol_refs and other unrecognized addresses are cost 4.  */\n-  return 4;\n-}\n-\f\n-/* Emit insns to move operands[1] into operands[0].\n-\n-   Return 1 if we have written out everything that needs to be done to\n-   do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally.  */\n-\n-int\n-emit_move_sequence (operands, mode)\n-     rtx *operands;\n-     enum machine_mode mode;\n-{\n-  /* We can only store registers to memory.  */\n-  \n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) != REG\n-      && (operands[1] != const0_rtx || current_function_args_size\n-\t  || current_function_stdarg\n-\t  || rtx_equal_function_value_matters))\n-    /* Here we use the same test as movsi+1 pattern -- see i960.md.  */\n-    operands[1] = force_reg (mode, operands[1]);\n-\n-  /* Storing multi-word values in unaligned hard registers to memory may\n-     require a scratch since we have to store them a register at a time and\n-     adding 4 to the memory address may not yield a valid insn.  */\n-  /* ??? We don't always need the scratch, but that would complicate things.\n-     Maybe later.  */\n-  /* ??? We must also handle stores to pseudos here, because the pseudo may be\n-     replaced with a MEM later.  This would be cleaner if we didn't have\n-     a separate pattern for unaligned DImode/TImode stores.  */\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && (GET_CODE (operands[0]) == MEM\n-\t  || (GET_CODE (operands[0]) == REG\n-\t      && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n-      && GET_CODE (operands[1]) == REG\n-      && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-      && ! HARD_REGNO_MODE_OK (REGNO (operands[1]), mode))\n-    {\n-      emit_insn (gen_rtx_PARALLEL\n-\t\t (VOIDmode,\n-\t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx_SET (VOIDmode, operands[0], operands[1]),\n-\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t      gen_rtx_SCRATCH (Pmode)))));\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Output assembler to move a double word value.  */\n-\n-const char *\n-i960_output_move_double (dst, src)\n-     rtx dst, src;\n-{\n-  rtx operands[5];\n-\n-  if (GET_CODE (dst) == REG\n-      && GET_CODE (src) == REG)\n-    {\n-      if ((REGNO (src) & 1)\n-\t  || (REGNO (dst) & 1))\n-\t{\n-\t  /* We normally copy the low-numbered register first.  However, if\n-\t     the second source register is the same as the first destination\n-\t     register, we must copy in the opposite order.  */\n-\t  if (REGNO (src) + 1 == REGNO (dst))\n-\t    return \"mov\t%D1,%D0\\n\\tmov\t%1,%0\";\n-\t  else\n-\t    return \"mov\t%1,%0\\n\\tmov\t%D1,%D0\";\n-\t}\n-      else\n-\treturn \"movl\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == REG\n-\t   && GET_CODE (src) == CONST_INT\n-\t   && CONST_OK_FOR_LETTER_P (INTVAL (src), 'I'))\n-    {\n-      if (REGNO (dst) & 1)\n-\treturn \"mov\t%1,%0\\n\\tmov\t0,%D0\";\n-      else\n-\treturn \"movl\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == REG\n-\t   && GET_CODE (src) == MEM)\n-    {\n-      if (REGNO (dst) & 1)\n-\t{\n-\t  /* One can optimize a few cases here, but you have to be\n-\t     careful of clobbering registers used in the address and\n-\t     edge conditions.  */\n-\t  operands[0] = dst;\n-\t  operands[1] = src;\n-\t  operands[2] = gen_rtx_REG (Pmode, REGNO (dst) + 1);\n-\t  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n-\t  operands[4] = adjust_address (operands[3], word_mode,\n-\t\t\t\t\tUNITS_PER_WORD);\n-\t  output_asm_insn\n-\t    (\"lda\t%1,%2\\n\\tld\t%3,%0\\n\\tld\t%4,%D0\", operands);\n-\t  return \"\";\n-\t}\n-      else\n-\treturn \"ldl\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == MEM\n-\t   && GET_CODE (src) == REG)\n-    {\n-      if (REGNO (src) & 1)\n-\t{\n-\t  operands[0] = dst;\n-\t  operands[1] = adjust_address (dst, word_mode, UNITS_PER_WORD);\n-\t  if (! memory_address_p (word_mode, XEXP (operands[1], 0)))\n-\t    abort ();\n-\t  operands[2] = src;\n-\t  output_asm_insn (\"st\t%2,%0\\n\\tst\t%D2,%1\", operands);\n-\t  return \"\";\n-\t}\n-      return \"stl\t%1,%0\";\n-    }\n-  else\n-    abort ();\n-}\n-\n-/* Output assembler to move a double word zero.  */\n-\n-const char *\n-i960_output_move_double_zero (dst)\n-     rtx dst;\n-{\n-  rtx operands[2];\n-\n-  operands[0] = dst;\n-    {\n-      operands[1] = adjust_address (dst, word_mode, 4);\n-      output_asm_insn (\"st\tg14,%0\\n\\tst\tg14,%1\", operands);\n-    }\n-  return \"\";\n-}\n-\n-/* Output assembler to move a quad word value.  */\n-\n-const char *\n-i960_output_move_quad (dst, src)\n-     rtx dst, src;\n-{\n-  rtx operands[7];\n-\n-  if (GET_CODE (dst) == REG\n-      && GET_CODE (src) == REG)\n-    {\n-      if ((REGNO (src) & 3)\n-\t  || (REGNO (dst) & 3))\n-\t{\n-\t  /* We normally copy starting with the low numbered register.\n-\t     However, if there is an overlap such that the first dest reg\n-\t     is <= the last source reg but not < the first source reg, we\n-\t     must copy in the opposite order.  */\n-\t  if (REGNO (dst) <= REGNO (src) + 3\n-\t      && REGNO (dst) >= REGNO (src))\n-\t    return \"mov\t%F1,%F0\\n\\tmov\t%E1,%E0\\n\\tmov\t%D1,%D0\\n\\tmov\t%1,%0\";\n-\t  else\n-\t    return \"mov\t%1,%0\\n\\tmov\t%D1,%D0\\n\\tmov\t%E1,%E0\\n\\tmov\t%F1,%F0\";\n-\t}\n-      else\n-\treturn \"movq\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == REG\n-\t   && GET_CODE (src) == CONST_INT\n-\t   && CONST_OK_FOR_LETTER_P (INTVAL (src), 'I'))\n-    {\n-      if (REGNO (dst) & 3)\n-\treturn \"mov\t%1,%0\\n\\tmov\t0,%D0\\n\\tmov\t0,%E0\\n\\tmov\t0,%F0\";\n-      else\n-\treturn \"movq\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == REG\n-\t   && GET_CODE (src) == MEM)\n-    {\n-      if (REGNO (dst) & 3)\n-\t{\n-\t  /* One can optimize a few cases here, but you have to be\n-\t     careful of clobbering registers used in the address and\n-\t     edge conditions.  */\n-\t  operands[0] = dst;\n-\t  operands[1] = src;\n-\t  operands[2] = gen_rtx_REG (Pmode, REGNO (dst) + 3);\n-\t  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n-\t  operands[4]\n-\t    = adjust_address (operands[3], word_mode, UNITS_PER_WORD);\n-\t  operands[5]\n-\t    = adjust_address (operands[4], word_mode, UNITS_PER_WORD);\n-\t  operands[6]\n-\t    = adjust_address (operands[5], word_mode, UNITS_PER_WORD);\n-\t  output_asm_insn (\"lda\t%1,%2\\n\\tld\t%3,%0\\n\\tld\t%4,%D0\\n\\tld\t%5,%E0\\n\\tld\t%6,%F0\", operands);\n-\t  return \"\";\n-\t}\n-      else\n-\treturn \"ldq\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == MEM\n-\t   && GET_CODE (src) == REG)\n-    {\n-      if (REGNO (src) & 3)\n-\t{\n-\t  operands[0] = dst;\n-\t  operands[1] = adjust_address (dst, word_mode, UNITS_PER_WORD);\n-\t  operands[2] = adjust_address (dst, word_mode, 2 * UNITS_PER_WORD);\n-\t  operands[3] = adjust_address (dst, word_mode, 3 * UNITS_PER_WORD);\n-\t  if (! memory_address_p (word_mode, XEXP (operands[3], 0)))\n-\t    abort ();\n-\t  operands[4] = src;\n-\t  output_asm_insn (\"st\t%4,%0\\n\\tst\t%D4,%1\\n\\tst\t%E4,%2\\n\\tst\t%F4,%3\", operands);\n-\t  return \"\";\n-\t}\n-      return \"stq\t%1,%0\";\n-    }\n-  else\n-    abort ();\n-}\n-\n-/* Output assembler to move a quad word zero.  */\n-\n-const char *\n-i960_output_move_quad_zero (dst)\n-     rtx dst;\n-{\n-  rtx operands[4];\n-\n-  operands[0] = dst;\n-    {\n-      operands[1] = adjust_address (dst, word_mode, 4);\n-      operands[2] = adjust_address (dst, word_mode, 8);\n-      operands[3] = adjust_address (dst, word_mode, 12);\n-      output_asm_insn (\"st\tg14,%0\\n\\tst\tg14,%1\\n\\tst\tg14,%2\\n\\tst\tg14,%3\", operands);\n-    }\n-  return \"\";\n-}\n-\n-\f\n-/* Emit insns to load a constant to non-floating point registers.\n-   Uses several strategies to try to use as few insns as possible.  */\n-\n-const char *\n-i960_output_ldconst (dst, src)\n-     register rtx dst, src;\n-{\n-  register int rsrc1;\n-  register unsigned rsrc2;\n-  enum machine_mode mode = GET_MODE (dst);\n-  rtx operands[4];\n-\n-  operands[0] = operands[2] = dst;\n-  operands[1] = operands[3] = src;\n-\n-  /* Anything that isn't a compile time constant, such as a SYMBOL_REF,\n-     must be a ldconst insn.  */\n-\n-  if (GET_CODE (src) != CONST_INT && GET_CODE (src) != CONST_DOUBLE)\n-    {\n-      output_asm_insn (\"ldconst\t%1,%0\", operands);\n-      return \"\";\n-    }\n-  else if (mode == TFmode)\n-    {\n-      REAL_VALUE_TYPE d;\n-      long value_long[3];\n-      int i;\n-\n-      if (fp_literal_zero (src, TFmode))\n-\treturn \"movt\t0,%0\";\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n-      REAL_VALUE_TO_TARGET_LONG_DOUBLE (d, value_long);\n-\n-      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n-\n-      for (i = 0; i < 3; i++)\n-\t{\n-\t  operands[0] = gen_rtx_REG (SImode, REGNO (dst) + i);\n-\t  operands[1] = GEN_INT (value_long[i]);\n-\t  output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t\t   operands);\n-\t}\n-\n-      return \"\"; \n-   }\n-  else if (mode == DFmode)\n-    {\n-      rtx first, second;\n-\n-      if (fp_literal_zero (src, DFmode))\n-\treturn \"movl\t0,%0\";\n-\n-      split_double (src, &first, &second);\n-\n-      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n-\n-      operands[0] = gen_rtx_REG (SImode, REGNO (dst));\n-      operands[1] = first;\n-      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t      operands);\n-      operands[0] = gen_rtx_REG (SImode, REGNO (dst) + 1);\n-      operands[1] = second;\n-      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t      operands);\n-      return \"\";\n-    }\n-  else if (mode == SFmode)\n-    {\n-      REAL_VALUE_TYPE d;\n-      long value;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n-      REAL_VALUE_TO_TARGET_SINGLE (d, value);\n-\n-      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n-      operands[0] = gen_rtx_REG (SImode, REGNO (dst));\n-      operands[1] = GEN_INT (value);\n-      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t      operands);\n-      return \"\";\n-    }\n-  else if (mode == TImode)\n-    {\n-      /* ??? This is currently not handled at all.  */\n-      abort ();\n-\n-      /* Note: lowest order word goes in lowest numbered reg.  */\n-      rsrc1 = INTVAL (src);\n-      if (rsrc1 >= 0 && rsrc1 < 32)\n-\treturn \"movq\t%1,%0\";\n-      else\n-\toutput_asm_insn (\"movq\\t0,%0\\t# ldconstq %1,%0\",operands);\n-      /* Go pick up the low-order word.  */\n-    }\n-  else if (mode == DImode)\n-    {\n-      rtx upperhalf, lowerhalf, xoperands[2];\n-\n-      if (GET_CODE (src) == CONST_DOUBLE || GET_CODE (src) == CONST_INT)\n- \tsplit_double (src, &lowerhalf, &upperhalf);\n-\n-      else\n-\tabort ();\n-\n-      /* Note: lowest order word goes in lowest numbered reg.  */\n-      /* Numbers from 0 to 31 can be handled with a single insn.  */\n-      rsrc1 = INTVAL (lowerhalf);\n-      if (upperhalf == const0_rtx && rsrc1 >= 0 && rsrc1 < 32)\n-\treturn \"movl\t%1,%0\";\n-\n-      /* Output the upper half with a recursive call.  */\n-      xoperands[0] = gen_rtx_REG (SImode, REGNO (dst) + 1);\n-      xoperands[1] = upperhalf;\n-      output_asm_insn (i960_output_ldconst (xoperands[0], xoperands[1]),\n-\t\t       xoperands);\n-      /* The lower word is emitted as normally.  */\n-    }\n-  else\n-    {\n-      rsrc1 = INTVAL (src);\n-      if (mode == QImode)\n-\t{\n-\t  if (rsrc1 > 0xff)\n-\t    rsrc1 &= 0xff;\n-\t}\n-      else if (mode == HImode)\n-\t{\n-\t  if (rsrc1 > 0xffff)\n-\t    rsrc1 &= 0xffff;\n-\t}\n-    }\n-\n-  if (rsrc1 >= 0)\n-    {\n-      /* ldconst\t0..31,X\t\t-> \tmov\t0..31,X  */\n-      if (rsrc1 < 32)\n-\t{\n-\t  if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t    return \"lda\t%1,%0\";\n-\t  return \"mov\t%1,%0\";\n-\t}\n-\n-      /* ldconst\t32..63,X\t->\tadd\t31,nn,X  */\n-      if (rsrc1 < 63)\n-\t{\n-\t  if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t    return \"lda\t%1,%0\";\n-\t  operands[1] = GEN_INT (rsrc1 - 31);\n-\t  output_asm_insn (\"addo\\t31,%1,%0\\t# ldconst %3,%0\", operands);\n-\t  return \"\";\n-\t}\n-    }\n-  else if (rsrc1 < 0)\n-    {\n-      /* ldconst\t-1..-31\t\t->\tsub\t0,0..31,X  */\n-      if (rsrc1 >= -31)\n-\t{\n-\t  /* return 'sub -(%1),0,%0' */\n-\t  operands[1] = GEN_INT (- rsrc1);\n-\t  output_asm_insn (\"subo\\t%1,0,%0\\t# ldconst %3,%0\", operands);\n-\t  return \"\";\n-\t}\n-      \n-      /* ldconst\t-32\t\t->\tnot\t31,X  */\n-      if (rsrc1 == -32)\n-\t{\n-\t  operands[1] = GEN_INT (~rsrc1);\n-\t  output_asm_insn (\"not\\t%1,%0\t# ldconst %3,%0\", operands);\n-\t  return \"\";\n-\t}\n-    }\n-\n-  /* If const is a single bit.  */\n-  if (bitpos (rsrc1) >= 0)\n-    {\n-      operands[1] = GEN_INT (bitpos (rsrc1));\n-      output_asm_insn (\"setbit\\t%1,0,%0\\t# ldconst %3,%0\", operands);\n-      return \"\";\n-    }\n-\n-  /* If const is a bit string of less than 6 bits (1..31 shifted).  */\n-  if (is_mask (rsrc1))\n-    {\n-      int s, e;\n-\n-      if (bitstr (rsrc1, &s, &e) < 6)\n-\t{\n-\t  rsrc2 = ((unsigned int) rsrc1) >> s;\n-\t  operands[1] = GEN_INT (rsrc2);\n-\t  operands[2] = GEN_INT (s);\n-\t  output_asm_insn (\"shlo\\t%2,%1,%0\\t# ldconst %3,%0\", operands);\n-\t  return \"\";\n-\t}\n-    }\n-\n-  /* Unimplemented cases:\n-     const is in range 0..31 but rotated around end of word:\n-     ror\t31,3,g0\t-> ldconst 0xe0000003,g0\n-   \n-     and any 2 instruction cases that might be worthwhile  */\n-  \n-  output_asm_insn (\"ldconst\t%1,%0\", operands);\n-  return \"\";\n-}\n-\n-/* Determine if there is an opportunity for a bypass optimization.\n-   Bypass succeeds on the 960K* if the destination of the previous\n-   instruction is the second operand of the current instruction.\n-   Bypass always succeeds on the C*.\n- \n-   Return 1 if the pattern should interchange the operands.\n-\n-   CMPBR_FLAG is true if this is for a compare-and-branch insn.\n-   OP1 and OP2 are the two source operands of a 3 operand insn.  */\n-\n-int\n-i960_bypass (insn, op1, op2, cmpbr_flag)\n-     register rtx insn, op1, op2;\n-     int cmpbr_flag;\n-{\n-  register rtx prev_insn, prev_dest;\n-\n-  if (TARGET_C_SERIES)\n-    return 0;\n-\n-  /* Can't do this if op1 isn't a register.  */\n-  if (! REG_P (op1))\n-    return 0;\n-\n-  /* Can't do this for a compare-and-branch if both ops aren't regs.  */\n-  if (cmpbr_flag && ! REG_P (op2))\n-    return 0;\n-\n-  prev_insn = prev_real_insn (insn);\n-\n-  if (prev_insn && GET_CODE (prev_insn) == INSN\n-      && GET_CODE (PATTERN (prev_insn)) == SET)\n-    {\n-      prev_dest = SET_DEST (PATTERN (prev_insn));\n-      if ((GET_CODE (prev_dest) == REG && REGNO (prev_dest) == REGNO (op1))\n-\t  || (GET_CODE (prev_dest) == SUBREG\n-\t      && GET_CODE (SUBREG_REG (prev_dest)) == REG\n-\t      && REGNO (SUBREG_REG (prev_dest)) == REGNO (op1)))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\f\n-/* Output the code which declares the function name.  This also handles\n-   leaf routines, which have special requirements, and initializes some\n-   global variables.  */\n-\n-void\n-i960_function_name_declare (file, name, fndecl)\n-     FILE *file;\n-     const char *name;\n-     tree fndecl;\n-{\n-  register int i, j;\n-  int leaf_proc_ok;\n-  rtx insn;\n-\n-  /* Increment global return label.  */\n-\n-  ret_label++;\n-\n-  /* Compute whether tail calls and leaf routine optimizations can be performed\n-     for this function.  */\n-\n-  if (TARGET_TAILCALL)\n-    tail_call_ok = 1;\n-  else\n-    tail_call_ok = 0;\n-\n-  if (TARGET_LEAFPROC)\n-    leaf_proc_ok = 1;\n-  else\n-    leaf_proc_ok = 0;\n-\n-  /* Even if nobody uses extra parms, can't have leafproc or tail calls if\n-     argblock, because argblock uses g14 implicitly.  */\n-\n-  if (current_function_args_size != 0 || VARARGS_STDARG_FUNCTION (fndecl))\n-    {\n-      tail_call_ok = 0;\n-      leaf_proc_ok = 0;\n-    }\n-      \n-  /* See if caller passes in an address to return value.  */\n-\n-  if (aggregate_value_p (DECL_RESULT (fndecl), fndecl))\n-    {\n-      tail_call_ok = 0;\n-      leaf_proc_ok = 0;\n-    }\n-\n-  /* Can not use tail calls or make this a leaf routine if there is a non\n-     zero frame size.  */\n-\n-  if (get_frame_size () != 0)\n-    leaf_proc_ok = 0;\n-\n-  /* I don't understand this condition, and do not think that it is correct.\n-     Apparently this is just checking whether the frame pointer is used, and\n-     we can't trust regs_ever_live[fp] since it is (almost?) always set.  */\n-\n-  if (tail_call_ok)\n-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == INSN\n-\t  && reg_mentioned_p (frame_pointer_rtx, insn))\n-\t{\n-\t  tail_call_ok = 0;\n-\t  break;\n-\t}\n-\n-  /* Check for CALL insns.  Can not be a leaf routine if there are any.  */\n-\n-  if (leaf_proc_ok)\n-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  leaf_proc_ok = 0;\n-\t  break;\n-\t}\n-\n-  /* Can not be a leaf routine if any non-call clobbered registers are\n-     used in this function.  */\n-\n-  if (leaf_proc_ok)\n-    for (i = 0, j = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      if (regs_ever_live[i]\n-\t  && ((! call_used_regs[i]) || (i > 7 && i < 12)))\n-\t{\n-\t  /* Global registers.  */\n-\t  if (i < 16 && i > 7 && i != 13)\n-\t    leaf_proc_ok = 0;\n-\t  /* Local registers.  */\n-\t  else if (i < 32)\n-\t    leaf_proc_ok = 0;\n-\t}\n-\n-  /* Now choose a leaf return register, if we can find one, and if it is\n-     OK for this to be a leaf routine.  */\n-\n-  i960_leaf_ret_reg = -1;\n-\n-  if (optimize && leaf_proc_ok)\n-    {\n-      for (i960_leaf_ret_reg = -1, i = 0; i < 8; i++)\n-\tif (regs_ever_live[i] == 0)\n-\t  {\n-\t    i960_leaf_ret_reg = i;\n-\t    regs_ever_live[i] = 1;\n-\t    break;\n-\t  }\n-    }\n-\n-  /* Do this after choosing the leaf return register, so it will be listed\n-     if one was chosen.  */\n-\n-  fprintf (file, \"\\t#  Function '%s'\\n\", (name[0] == '*' ? &name[1] : name));\n-  fprintf (file, \"\\t#  Registers used: \");\n-\n-  for (i = 0, j = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (regs_ever_live[i])\n-\t{\n-\t  fprintf (file, \"%s%s \", reg_names[i], call_used_regs[i] ? \"\" : \"*\");\n-\n-\t  if (i > 15 && j == 0)\n-\t    {\n-\t      fprintf (file,\"\\n\\t#\\t\\t   \");\n-\t      j++;\n-            }\n-        }\n-    }\n-\n-  fprintf (file, \"\\n\");\n-\n-  if (i960_leaf_ret_reg >= 0)\n-    {\n-      /* Make it a leaf procedure.  */\n-\n-      if (TREE_PUBLIC (fndecl))\n-\tfprintf (file,\"\\t.globl\\t%s.lf\\n\", (name[0] == '*' ? &name[1] : name));\n-\n-      fprintf (file, \"\\t.leafproc\\t\");\n-      assemble_name (file, name);\n-      fprintf (file, \",%s.lf\\n\", (name[0] == '*' ? &name[1] : name));\n-      ASM_OUTPUT_LABEL (file, name);\n-      fprintf (file, \"\\tlda    Li960R%d,g14\\n\", ret_label);\n-      fprintf (file, \"%s.lf:\\n\", (name[0] == '*' ? &name[1] : name));\n-      fprintf (file, \"\\tmov    g14,g%d\\n\", i960_leaf_ret_reg);\n-\n-      if (TARGET_C_SERIES)\n-\t{\n-\t  fprintf (file, \"\\tlda    0,g14\\n\");\n-\t  i960_last_insn_type = I_TYPE_MEM;\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, \"\\tmov    0,g14\\n\");\n-\t  i960_last_insn_type = I_TYPE_REG;\n-\t}\n-    }\n-  else\n-    {\n-      ASM_OUTPUT_LABEL (file, name);\n-      i960_last_insn_type = I_TYPE_CTRL; \n-    }\n-}\n-\f\n-/* Compute and return the frame size.  */\n-\n-int\n-compute_frame_size (size)\n-     int size;\n-{\n-  int actual_fsize;\n-  int outgoing_args_size = current_function_outgoing_args_size;\n-\n-  /* The STARTING_FRAME_OFFSET is totally hidden to us as far\n-     as size is concerned.  */\n-  actual_fsize = (size + 15) & -16;\n-  actual_fsize += (outgoing_args_size + 15) & -16;\n-\n-  return actual_fsize;\n-}\n-\n-/* Here register group is range of registers which can be moved by\n-   one i960 instruction.  */\n-\n-struct reg_group\n-{\n-  char start_reg;\n-  char length;\n-};\n-\n-static int i960_form_reg_groups (int, int, int *, int, struct reg_group *);\n-static int i960_reg_group_compare (const void *, const void *);\n-static int i960_split_reg_group (struct reg_group *, int, int);\n-static void i960_arg_size_and_align (enum machine_mode, tree, int *, int *);\n-\n-/* The following functions forms the biggest as possible register\n-   groups with registers in STATE.  REGS contain states of the\n-   registers in range [start, finish_reg).  The function returns the\n-   number of groups formed.  */\n-static int\n-i960_form_reg_groups (start_reg, finish_reg, regs, state, reg_groups)\n-     int start_reg;\n-     int finish_reg;\n-     int *regs;\n-     int state;\n-     struct reg_group *reg_groups;\n-{\n-  int i;\n-  int nw = 0;\n-\n-  for (i = start_reg; i < finish_reg; )\n-    {\n-      if (regs [i] != state)\n-\t{\n-\t  i++;\n-\t  continue;\n-\t}\n-      else if (i % 2 != 0 || regs [i + 1] != state)\n-\treg_groups [nw].length = 1;\n-      else if (i % 4 != 0 || regs [i + 2] != state)\n-\treg_groups [nw].length = 2;\n-      else if (regs [i + 3] != state)\n-\treg_groups [nw].length = 3;\n-      else\n-\treg_groups [nw].length = 4;\n-      reg_groups [nw].start_reg = i;\n-      i += reg_groups [nw].length;\n-      nw++;\n-    }\n-  return nw;\n-}\n-\n-/* We sort register winodws in descending order by length.  */\n-static int\n-i960_reg_group_compare (group1, group2)\n-     const void *group1;\n-     const void *group2;\n-{\n-  const struct reg_group *w1 = group1;\n-  const struct reg_group *w2 = group2;\n-\n-  if (w1->length > w2->length)\n-    return -1;\n-  else if (w1->length < w2->length)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Split the first register group in REG_GROUPS on subgroups one of\n-   which will contain SUBGROUP_LENGTH registers.  The function\n-   returns new number of winodws.  */\n-static int\n-i960_split_reg_group (reg_groups, nw, subgroup_length)\n-     struct reg_group *reg_groups;\n-     int nw;\n-     int subgroup_length;\n-{\n-  if (subgroup_length < reg_groups->length - subgroup_length)\n-    /* This guarantees correct alignments of the two subgroups for\n-       i960 (see spliting for the group length 2, 3, 4).  More\n-       generalized algorithm would require splitting the group more\n-       two subgroups.  */\n-    subgroup_length = reg_groups->length - subgroup_length;\n-  /* More generalized algorithm would require to try merging\n-     subgroups here.  But in case i960 it always results in failure\n-     because of register group alignment.  */\n-  reg_groups[nw].length = reg_groups->length - subgroup_length;\n-  reg_groups[nw].start_reg = reg_groups->start_reg + subgroup_length;\n-  nw++;\n-  reg_groups->length = subgroup_length;\n-  qsort (reg_groups, nw, sizeof (struct reg_group), i960_reg_group_compare);\n-  return nw;\n-}\n-\n-/* Output code for the function prologue.  */\n-\n-static void\n-i960_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  register int i, j, nr;\n-  int n_saved_regs = 0;\n-  int n_remaining_saved_regs;\n-  HOST_WIDE_INT lvar_size;\n-  HOST_WIDE_INT actual_fsize, offset;\n-  int gnw, lnw;\n-  struct reg_group *g, *l;\n-  char tmpstr[1000];\n-  /* -1 if reg must be saved on proc entry, 0 if available, 1 if saved\n-     somewhere.  */\n-  int regs[FIRST_PSEUDO_REGISTER];\n-  /* All global registers (which must be saved) divided by groups.  */\n-  struct reg_group global_reg_groups [16];\n-  /* All local registers (which are available) divided by groups.  */\n-  struct reg_group local_reg_groups [16];\n-\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (regs_ever_live[i]\n-\t&& ((! call_used_regs[i]) || (i > 7 && i < 12))\n-\t/* No need to save the static chain pointer.  */\n-\t&& ! (i == STATIC_CHAIN_REGNUM && current_function_needs_context))\n-      {\n-\tregs[i] = -1;\n-        /* Count global registers that need saving.  */\n-\tif (i < 16)\n-\t  n_saved_regs++;\n-      }\n-    else\n-      regs[i] = 0;\n-\n-  n_remaining_saved_regs = n_saved_regs;\n-\n-  epilogue_string[0] = '\\0';\n-\n-  if (current_function_profile)\n-    {\n-      /* When profiling, we may use registers 20 to 27 to save arguments, so\n-\t they can't be used here for saving globals.  J is the number of\n-\t argument registers the mcount call will save.  */\n-      for (j = 7; j >= 0 && ! regs_ever_live[j]; j--)\n-\t;\n-\n-      for (i = 20; i <= j + 20; i++)\n-\tregs[i] = -1;\n-    }\n-\n-  gnw = i960_form_reg_groups (0, 16, regs, -1, global_reg_groups);\n-  lnw = i960_form_reg_groups (19, 32, regs, 0, local_reg_groups);\n-  qsort (global_reg_groups, gnw, sizeof (struct reg_group),\n-\t i960_reg_group_compare);\n-  qsort (local_reg_groups, lnw, sizeof (struct reg_group),\n-\t i960_reg_group_compare);\n-  for (g = global_reg_groups, l = local_reg_groups; lnw != 0 && gnw != 0;)\n-    {\n-      if (g->length == l->length)\n-\t{\n-\t  fprintf (file, \"\\tmov%s\t%s,%s\\n\",\n-\t\t   ((g->length == 4) ? \"q\" :\n-\t\t    (g->length == 3) ? \"t\" :\n-\t\t    (g->length == 2) ? \"l\" : \"\"),\n-\t\t   reg_names[(unsigned char) g->start_reg],\n-\t\t   reg_names[(unsigned char) l->start_reg]);\n-\t  sprintf (tmpstr, \"\\tmov%s\t%s,%s\\n\",\n-\t\t   ((g->length == 4) ? \"q\" :\n-\t\t    (g->length == 3) ? \"t\" :\n-\t\t    (g->length == 2) ? \"l\" : \"\"),\n-\t\t   reg_names[(unsigned char) l->start_reg],\n-\t\t   reg_names[(unsigned char) g->start_reg]);\n-\t  strcat (epilogue_string, tmpstr);\n-\t  n_remaining_saved_regs -= g->length;\n-\t  for (i = 0; i < g->length; i++)\n-\t    {\n-\t      regs [i + g->start_reg] = 1;\n-\t      regs [i + l->start_reg] = -1;\n-\t      regs_ever_live [i + l->start_reg] = 1;\n-\t    }\n-\t  g++;\n-\t  l++;\n-\t  gnw--;\n-\t  lnw--;\n-\t}\n-      else if (g->length > l->length)\n-\tgnw = i960_split_reg_group (g, gnw, l->length);\n-      else\n-\tlnw = i960_split_reg_group (l, lnw, g->length);\n-    }\n-\n-  actual_fsize = compute_frame_size (size) + 4 * n_remaining_saved_regs;\n-#if 0\n-  /* ??? The 1.2.1 compiler does this also.  This is meant to round the frame\n-     size up to the nearest multiple of 16.  I don't know whether this is\n-     necessary, or even desirable.\n-\n-     The frame pointer must be aligned, but the call instruction takes care of\n-     that.  If we leave the stack pointer unaligned, we may save a little on\n-     dynamic stack allocation.  And we don't lose, at least according to the\n-     i960CA manual.  */\n-  actual_fsize = (actual_fsize + 15) & ~0xF;\n-#endif\n-\n-  /* Check stack limit if necessary.  */\n-  if (current_function_limit_stack)\n-    {\n-      rtx min_stack = stack_limit_rtx;\n-      if (actual_fsize != 0)\n-\tmin_stack = plus_constant (stack_limit_rtx, -actual_fsize);\n-\n-      /* Now, emulate a little bit of reload.  We want to turn 'min_stack'\n-\t into an arith_operand.  Use register 20 as the temporary.  */\n-      if (legitimate_address_p (Pmode, min_stack, 1) \n-\t  && !arith_operand (min_stack, Pmode))\n-\t{\n-\t  rtx tmp = gen_rtx_MEM (Pmode, min_stack);\n-\t  fputs (\"\\tlda\\t\", file);\n-\t  i960_print_operand (file, tmp, 0);\n-\t  fputs (\",r4\\n\", file);\n-\t  min_stack = gen_rtx_REG (Pmode, 20);\n-\t}\n-      if (arith_operand (min_stack, Pmode))\n-\t{\n-\t  fputs (\"\\tcmpo\\tsp,\", file);\n-\t  i960_print_operand (file, min_stack, 0);\n-\t  fputs (\"\\n\\tfaultge.f\\n\", file);\n-\t}\n-      else\n-\twarning (\"stack limit expression is not supported\");\n-    }\n-\n-  /* Allocate space for register save and locals.  */\n-  if (actual_fsize > 0)\n-    {\n-      if (actual_fsize < 32)\n-\tfprintf (file, \"\\taddo\t\" HOST_WIDE_INT_PRINT_DEC \",sp,sp\\n\",\n-\t\t actual_fsize);\n-      else\n-\tfprintf (file, \"\\tlda\\t\" HOST_WIDE_INT_PRINT_DEC \"(sp),sp\\n\",\n-\t\t actual_fsize);\n-    }\n-\n-  /* Take hardware register save area created by the call instruction\n-     into account, but store them before the argument block area.  */\n-  lvar_size = actual_fsize - compute_frame_size (0) - n_remaining_saved_regs * 4;\n-  offset = STARTING_FRAME_OFFSET + lvar_size;\n-  /* Save registers on stack if needed.  */\n-  /* ??? Is it worth to use the same algorithm as one for saving\n-     global registers in local registers? */\n-  for (i = 0, j = n_remaining_saved_regs; j > 0 && i < 16; i++)\n-    {\n-      if (regs[i] != -1)\n-\tcontinue;\n-\n-      nr = 1;\n-\n-      if (i <= 14 && i % 2 == 0 && regs[i+1] == -1 && offset % 2 == 0)\n-\tnr = 2;\n-\n-      if (nr == 2 && i <= 12 && i % 4 == 0 && regs[i+2] == -1\n-\t  && offset % 4 == 0)\n-\tnr = 3;\n-\n-      if (nr == 3 && regs[i+3] == -1)\n-\tnr = 4;\n-\n-      fprintf (file,\"\\tst%s\t%s,\" HOST_WIDE_INT_PRINT_DEC \"(fp)\\n\",\n-\t       ((nr == 4) ? \"q\" :\n-\t\t(nr == 3) ? \"t\" :\n-\t\t(nr == 2) ? \"l\" : \"\"),\n-\t       reg_names[i], offset);\n-      sprintf (tmpstr,\"\\tld%s\t\" HOST_WIDE_INT_PRINT_DEC \"(fp),%s\\n\",\n-\t       ((nr == 4) ? \"q\" :\n-\t\t(nr == 3) ? \"t\" :\n-\t\t(nr == 2) ? \"l\" : \"\"),\n-\t       offset, reg_names[i]);\n-      strcat (epilogue_string, tmpstr);\n-      i += nr-1;\n-      j -= nr;\n-      offset += nr * 4;\n-    }\n-\n-  if (actual_fsize == 0)\n-    return;\n-\n-  fprintf (file, \"\\t#Prologue stats:\\n\");\n-  fprintf (file, \"\\t#  Total Frame Size: \" HOST_WIDE_INT_PRINT_DEC \" bytes\\n\",\n-\t   actual_fsize);\n-\n-  if (lvar_size)\n-    fprintf (file, \"\\t#  Local Variable Size: \" HOST_WIDE_INT_PRINT_DEC\n-\t     \" bytes\\n\", lvar_size);\n-  if (n_saved_regs)\n-    fprintf (file, \"\\t#  Register Save Size: %d regs, %d bytes\\n\",\n-\t     n_saved_regs, n_saved_regs * 4);\n-  fprintf (file, \"\\t#End Prologue#\\n\");\n-}\n-\n-/* Output code for the function profiler.  */\n-\n-void\n-output_function_profiler (file, labelno)\n-     FILE *file;\n-     int labelno;\n-{\n-  /* The last used parameter register.  */\n-  int last_parm_reg;\n-  int i, j, increment;\n-  int varargs_stdarg_function\n-    = VARARGS_STDARG_FUNCTION (current_function_decl);\n-\n-  /* Figure out the last used parameter register.  The proper thing to do\n-     is to walk incoming args of the function.  A function might have live\n-     parameter registers even if it has no incoming args.  Note that we\n-     don't have to save parameter registers g8 to g11 because they are\n-     call preserved.  */\n-\n-  /* See also output_function_prologue, which tries to use local registers\n-     for preserved call-saved global registers.  */\n-\n-  for (last_parm_reg = 7;\n-       last_parm_reg >= 0 && ! regs_ever_live[last_parm_reg];\n-       last_parm_reg--)\n-    ;\n-\n-  /* Save parameter registers in regs r4 (20) to r11 (27).  */\n-\n-  for (i = 0, j = 4; i <= last_parm_reg; i += increment, j += increment)\n-    {\n-      if (i % 4 == 0 && (last_parm_reg - i) >= 3)\n-\tincrement = 4;\n-      else if (i % 4 == 0 && (last_parm_reg - i) >= 2)\n-\tincrement = 3;\n-      else if (i % 2 == 0 && (last_parm_reg - i) >= 1)\n-\tincrement = 2;\n-      else\n-\tincrement = 1;\n-\n-      fprintf (file, \"\\tmov%s\tg%d,r%d\\n\",\n-\t       (increment == 4 ? \"q\" : increment == 3 ? \"t\"\n-\t\t: increment == 2 ? \"l\": \"\"), i, j);\n-      }\n-\n-  /* If this function uses the arg pointer, then save it in r3 and then\n-     set it to zero.  */\n-\n-  if (current_function_args_size != 0 || varargs_stdarg_function)\n-    fprintf (file, \"\\tmov\tg14,r3\\n\\tmov\t0,g14\\n\");\n-\n-  /* Load location address into g0 and call mcount.  */\n-\n-  fprintf (file, \"\\tlda\\tLP%d,g0\\n\\tcallx\\tmcount\\n\", labelno);\n-\n-  /* If this function uses the arg pointer, restore it.  */\n-\n-  if (current_function_args_size != 0 || varargs_stdarg_function)\n-    fprintf (file, \"\\tmov\tr3,g14\\n\");\n-\n-  /* Restore parameter registers.  */\n-\n-  for (i = 0, j = 4; i <= last_parm_reg; i += increment, j += increment)\n-    {\n-      if (i % 4 == 0 && (last_parm_reg - i) >= 3)\n-\tincrement = 4;\n-      else if (i % 4 == 0 && (last_parm_reg - i) >= 2)\n-\tincrement = 3;\n-      else if (i % 2 == 0 && (last_parm_reg - i) >= 1)\n-\tincrement = 2;\n-      else\n-\tincrement = 1;\n-\n-      fprintf (file, \"\\tmov%s\tr%d,g%d\\n\",\n-\t       (increment == 4 ? \"q\" : increment == 3 ? \"t\"\n-\t\t: increment == 2 ? \"l\": \"\"), j, i);\n-    }\n-}\n-\n-/* Output code for the function epilogue.  */\n-\n-static void\n-i960_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-{\n-  if (i960_leaf_ret_reg >= 0)\n-    {\n-      fprintf (file, \"Li960R%d:\tret\\n\", ret_label);\n-      return;\n-    }\n-\n-  if (*epilogue_string == 0)\n-    {\n-      register rtx tmp;\n-\t\n-      /* Emit a return insn, but only if control can fall through to here.  */\n-\n-      tmp = get_last_insn ();\n-      while (tmp)\n-\t{\n-\t  if (GET_CODE (tmp) == BARRIER)\n-\t    return;\n-\t  if (GET_CODE (tmp) == CODE_LABEL)\n-\t    break;\n-\t  if (GET_CODE (tmp) == JUMP_INSN)\n-\t    {\n-\t      if (GET_CODE (PATTERN (tmp)) == RETURN)\n-\t\treturn;\n-\t      break;\n-\t    }\n-\t  if (GET_CODE (tmp) == NOTE)\n-\t    {\n-\t      tmp = PREV_INSN (tmp);\n-\t      continue;\n-\t    }\n-\t  break;\n-\t}\n-      fprintf (file, \"Li960R%d:\tret\\n\", ret_label);\n-      return;\n-    }\n-\n-  fprintf (file, \"Li960R%d:\\n\", ret_label);\n-\n-  fprintf (file, \"\\t#EPILOGUE#\\n\");\n-\n-  /* Output the string created by the prologue which will restore all\n-     registers saved by the prologue.  */\n-\n-  if (epilogue_string[0] != '\\0')\n-    fprintf (file, \"%s\", epilogue_string);\n-\n-  /* Must clear g14 on return if this function set it.\n-     Only varargs/stdarg functions modify g14.  */\n-\n-  if (VARARGS_STDARG_FUNCTION (current_function_decl))\n-    fprintf (file, \"\\tmov\t0,g14\\n\");\n-\n-  fprintf (file, \"\\tret\\n\");\n-  fprintf (file, \"\\t#End Epilogue#\\n\");\n-}\n-\n-/* Output code for a call insn.  */\n-\n-const char *\n-i960_output_call_insn (target, argsize_rtx, arg_pointer, insn)\n-     register rtx target, argsize_rtx, arg_pointer, insn;\n-{\n-  int argsize = INTVAL (argsize_rtx);\n-  rtx nexti = next_real_insn (insn);\n-  rtx operands[2];\n-  int varargs_stdarg_function\n-    = VARARGS_STDARG_FUNCTION (current_function_decl);\n-\n-  operands[0] = target;\n-  operands[1] = arg_pointer;\n-\n-  if (current_function_args_size != 0 || varargs_stdarg_function)\n-    output_asm_insn (\"mov\tg14,r3\", operands);\n-\n-  if (argsize > 48)\n-    output_asm_insn (\"lda\t%a1,g14\", operands);\n-  else if (current_function_args_size != 0 || varargs_stdarg_function)\n-    output_asm_insn (\"mov\t0,g14\", operands);\n-\n-  /* The code used to assume that calls to SYMBOL_REFs could not be more\n-     than 24 bits away (b vs bx, callj vs callx).  This is not true.  This\n-     feature is now implemented by relaxing in the GNU linker.  It can convert\n-     bx to b if in range, and callx to calls/call/balx/bal as appropriate.  */\n-\n-  /* Nexti could be zero if the called routine is volatile.  */\n-  if (optimize && (*epilogue_string == 0) && argsize == 0 && tail_call_ok \n-      && (nexti == 0 || GET_CODE (PATTERN (nexti)) == RETURN))\n-    {\n-      /* Delete following return insn.  */\n-      if (nexti && no_labels_between_p (insn, nexti))\n-\tdelete_insn (nexti);\n-      output_asm_insn (\"bx\t%0\", operands);\n-      return \"# notreached\";\n-    }\n-\n-  output_asm_insn (\"callx\t%0\", operands);\n-\n-  /* If the caller sets g14 to the address of the argblock, then the caller\n-     must clear it after the return.  */\n-\n-  if (current_function_args_size != 0 || varargs_stdarg_function)\n-    output_asm_insn (\"mov\tr3,g14\", operands);\n-  else if (argsize > 48)\n-    output_asm_insn (\"mov\t0,g14\", operands);\n-\n-  return \"\";\n-}\n-\n-/* Output code for a return insn.  */\n-\n-const char *\n-i960_output_ret_insn (insn)\n-     register rtx insn;\n-{\n-  static char lbuf[20];\n-  \n-  if (*epilogue_string != 0)\n-    {\n-      if (! TARGET_CODE_ALIGN && next_real_insn (insn) == 0)\n-\treturn \"\";\n-\n-      sprintf (lbuf, \"b\tLi960R%d\", ret_label);\n-      return lbuf;\n-    }\n-\n-  /* Must clear g14 on return if this function set it.\n-     Only varargs/stdarg functions modify g14.  */\n-\n-  if (VARARGS_STDARG_FUNCTION (current_function_decl))\n-    output_asm_insn (\"mov\t0,g14\", 0);\n-\n-  if (i960_leaf_ret_reg >= 0)\n-    {\n-      sprintf (lbuf, \"bx\t(%s)\", reg_names[i960_leaf_ret_reg]);\n-      return lbuf;\n-    }\n-  return \"ret\";\n-}\n-\f\n-/* Print the operand represented by rtx X formatted by code CODE.  */\n-\n-void\n-i960_print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n-{\n-  enum rtx_code rtxcode = x ? GET_CODE (x) : NIL;\n-\n-  if (rtxcode == REG)\n-    {\n-      switch (code)\n-\t{\n-\tcase 'D':\n-\t  /* Second reg of a double or quad.  */\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)+1]);\n-\t  break;\n-\n-\tcase 'E':\n-\t  /* Third reg of a quad.  */\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)+2]);\n-\t  break;\n-\n-\tcase 'F':\n-\t  /* Fourth reg of a quad.  */\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)+3]);\n-\t  break;\n-\n-\tcase 0:\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-      return;\n-    }\n-  else if (rtxcode == MEM)\n-    {\n-      output_address (XEXP (x, 0));\n-      return;\n-    }\n-  else if (rtxcode == CONST_INT)\n-    {\n-      HOST_WIDE_INT val = INTVAL (x);\n-      if (code == 'C')\n-\tval = ~val;\n-      if (val > 9999 || val < -999)\n-\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, val);\n-      else\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n-      return;\n-    }\n-  else if (rtxcode == CONST_DOUBLE)\n-    {\n-      char dstr[30];\n-\n-      if (x == CONST0_RTX (GET_MODE (x)))\n-\t{\n-\t  fprintf (file, \"0f0.0\");\n-\t  return;\n-\t}\n-      else if (x == CONST1_RTX (GET_MODE (x)))\n-\t{\n-\t  fprintf (file, \"0f1.0\");\n-\t  return;\n-\t}\n-\n-      real_to_decimal (dstr, CONST_DOUBLE_REAL_VALUE (x), sizeof (dstr), 0, 1);\n-      fprintf (file, \"0f%s\", dstr);\n-      return;\n-    }\n-\n-  switch(code)\n-    {\n-    case 'B':\n-      /* Branch or jump, depending on assembler.  */\n-      if (TARGET_ASM_COMPAT)\n-\tfputs (\"j\", file);\n-      else\n-\tfputs (\"b\", file);\n-      break;\n-\n-    case 'S':\n-      /* Sign of condition.  */\n-      if ((rtxcode == EQ) || (rtxcode == NE) || (rtxcode == GTU)\n-\t  || (rtxcode == LTU) || (rtxcode == GEU) || (rtxcode == LEU))\n-\tfputs (\"o\", file);\n-      else if ((rtxcode == GT) || (rtxcode == LT)\n-\t  || (rtxcode == GE) || (rtxcode == LE))\n-\tfputs (\"i\", file);\n-      else\n-\tabort();\n-      break;\n-\n-    case 'I':\n-      /* Inverted condition.  */\n-      rtxcode = reverse_condition (rtxcode);\n-      goto normal;\n-\n-    case 'X':\n-      /* Inverted condition w/ reversed operands.  */\n-      rtxcode = reverse_condition (rtxcode);\n-      /* Fallthrough.  */\n-\n-    case 'R':\n-      /* Reversed operand condition.  */\n-      rtxcode = swap_condition (rtxcode);\n-      /* Fallthrough.  */\n-\n-    case 'C':\n-      /* Normal condition.  */\n-    normal:\n-      if (rtxcode == EQ)  { fputs (\"e\", file); return; }\n-      else if (rtxcode == NE)  { fputs (\"ne\", file); return; }\n-      else if (rtxcode == GT)  { fputs (\"g\", file); return; }\n-      else if (rtxcode == GTU) { fputs (\"g\", file); return; }\n-      else if (rtxcode == LT)  { fputs (\"l\", file); return; }\n-      else if (rtxcode == LTU) { fputs (\"l\", file); return; }\n-      else if (rtxcode == GE)  { fputs (\"ge\", file); return; }\n-      else if (rtxcode == GEU) { fputs (\"ge\", file); return; }\n-      else if (rtxcode == LE)  { fputs (\"le\", file); return; }\n-      else if (rtxcode == LEU) { fputs (\"le\", file); return; }\n-      else abort ();\n-      break;\n-\n-    case '+':\n-      /* For conditional branches, substitute \".t\" or \".f\".  */\n-      if (TARGET_BRANCH_PREDICT)\n-\t{\n-\t  x = find_reg_note (current_output_insn, REG_BR_PROB, 0);\n-\t  if (x)\n-\t    {\n-\t      int pred_val = INTVAL (XEXP (x, 0));\n-\t      fputs ((pred_val < REG_BR_PROB_BASE / 2 ? \".f\" : \".t\"), file);\n-\t    }\n-\t}\n-      break;\n-\n-    case 0:\n-      output_addr_const (file, x);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  return;\n-}\n-\f\n-/* Print a memory address as an operand to reference that memory location.\n-\n-   This is exactly the same as legitimate_address_p, except that it the prints\n-   addresses instead of recognizing them.  */\n-\n-void\n-i960_print_operand_addr (file, addr)\n-     FILE *file;\n-     register rtx addr;\n-{\n-  rtx breg, ireg;\n-  rtx scale, offset;\n-\n-  ireg = 0;\n-  breg = 0;\n-  offset = 0;\n-  scale = const1_rtx;\n-\n-  if (GET_CODE (addr) == REG)\n-    breg = addr;\n-  else if (CONSTANT_P (addr))\n-    offset = addr;\n-  else if (GET_CODE (addr) == PLUS)\n-    {\n-      rtx op0, op1;\n-\n-      op0 = XEXP (addr, 0);\n-      op1 = XEXP (addr, 1);\n-\n-      if (GET_CODE (op0) == REG)\n-\t{\n-\t  breg = op0;\n-\t  if (GET_CODE (op1) == REG)\n-\t    ireg = op1;\n-\t  else if (CONSTANT_P (op1))\n-\t    offset = op1;\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (GET_CODE (op0) == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (op0, 0)) == MULT)\n-\t    {\n-\t      ireg = XEXP (XEXP (op0, 0), 0);\n-\t      scale = XEXP (XEXP (op0, 0), 1);\n-\t      if (GET_CODE (XEXP (op0, 1)) == REG)\n-\t\t{\n-\t\t  breg = XEXP (op0, 1);\n-\t\t  offset = op1;\n-\t\t}\n-\t      else\n-\t\tabort ();\n-\t    }\n-\t  else if (GET_CODE (XEXP (op0, 0)) == REG)\n-\t    {\n-\t      breg = XEXP (op0, 0);\n-\t      if (GET_CODE (XEXP (op0, 1)) == REG)\n-\t\t{\n-\t\t  ireg = XEXP (op0, 1);\n-\t\t  offset = op1;\n-\t\t}\n-\t      else\n-\t\tabort ();\n-\t    }\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (GET_CODE (op0) == MULT)\n-\t{\n-\t  ireg = XEXP (op0, 0);\n-\t  scale = XEXP (op0, 1);\n-\t  if (GET_CODE (op1) == REG)\n-\t    breg = op1;\n-\t  else if (CONSTANT_P (op1))\n-\t    offset = op1;\n-\t  else\n-\t    abort ();\n-\t}\n-      else\n-\tabort ();\n-    }\n-  else if (GET_CODE (addr) == MULT)\n-    {\n-      ireg = XEXP (addr, 0);\n-      scale = XEXP (addr, 1);\n-    }\n-  else\n-    abort ();\n-\n-  if (offset)\n-    output_addr_const (file, offset);\n-  if (breg)\n-    fprintf (file, \"(%s)\", reg_names[REGNO (breg)]);\n-  if (ireg)\n-    fprintf (file, \"[%s*\" HOST_WIDE_INT_PRINT_DEC \"]\",\n-\t     reg_names[REGNO (ireg)], INTVAL (scale));\n-}\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-\tOn 80960, legitimate addresses are:\n-\t\tbase\t\t\t\tld\t(g0),r0\n-\t\tdisp\t(12 or 32 bit)\t\tld\tfoo,r0\n-\t\tbase + index\t\t\tld\t(g0)[g1*1],r0\n-\t\tbase + displ\t\t\tld\t0xf00(g0),r0\n-\t\tbase + index*scale + displ\tld\t0xf00(g0)[g1*4],r0\n-\t\tindex*scale + base\t\tld\t(g0)[g1*4],r0\n-\t\tindex*scale + displ\t\tld\t0xf00[g1*4],r0\n-\t\tindex*scale\t\t\tld\t[g1*4],r0\n-\t\tindex + base + displ\t\tld\t0xf00(g0)[g1*1],r0\n-\n-\tIn each case, scale can be 1, 2, 4, 8, or 16.  */\n-\n-/* This is exactly the same as i960_print_operand_addr, except that\n-   it recognizes addresses instead of printing them.\n-\n-   It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should\n-   convert common non-canonical forms to canonical form so that they will\n-   be recognized.  */\n-\n-/* These two macros allow us to accept either a REG or a SUBREG anyplace\n-   where a register is valid.  */\n-\n-#define RTX_OK_FOR_BASE_P(X, STRICT)\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n-    && (STRICT ? REG_OK_FOR_BASE_P_STRICT (X) : REG_OK_FOR_BASE_P (X)))\t\\\n-   || (GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-       && (STRICT ? REG_OK_FOR_BASE_P_STRICT (SUBREG_REG (X))\t\t\\\n-\t   : REG_OK_FOR_BASE_P (SUBREG_REG (X)))))\n-\n-#define RTX_OK_FOR_INDEX_P(X, STRICT)\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n-    && (STRICT ? REG_OK_FOR_INDEX_P_STRICT (X) : REG_OK_FOR_INDEX_P (X)))\\\n-   || (GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-       && (STRICT ? REG_OK_FOR_INDEX_P_STRICT (SUBREG_REG (X))\t\t\\\n-\t   : REG_OK_FOR_INDEX_P (SUBREG_REG (X)))))\n-\n-int\n-legitimate_address_p (mode, addr, strict)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     register rtx addr;\n-     int strict;\n-{\n-  if (RTX_OK_FOR_BASE_P (addr, strict))\n-    return 1;\n-  else if (CONSTANT_P (addr))\n-    return 1;\n-  else if (GET_CODE (addr) == PLUS)\n-    {\n-      rtx op0, op1;\n-\n-      if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n-\treturn 0;\n-\n-      op0 = XEXP (addr, 0);\n-      op1 = XEXP (addr, 1);\n-\n-      if (RTX_OK_FOR_BASE_P (op0, strict))\n-\t{\n-\t  if (RTX_OK_FOR_INDEX_P (op1, strict))\n-\t    return 1;\n-\t  else if (CONSTANT_P (op1))\n-\t    return 1;\n-\t  else\n-\t    return 0;\n-\t}\n-      else if (GET_CODE (op0) == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (op0, 0)) == MULT)\n-\t    {\n-\t      if (! (RTX_OK_FOR_INDEX_P (XEXP (XEXP (op0, 0), 0), strict)\n-\t\t     && SCALE_TERM_P (XEXP (XEXP (op0, 0), 1))))\n-\t\treturn 0;\n-\n-\t      if (RTX_OK_FOR_BASE_P (XEXP (op0, 1), strict)\n-\t\t  && CONSTANT_P (op1))\n-\t\treturn 1;\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t  else if (RTX_OK_FOR_BASE_P (XEXP (op0, 0), strict))\n-\t    {\n-\t      if (RTX_OK_FOR_INDEX_P (XEXP (op0, 1), strict)\n-\t\t  && CONSTANT_P (op1))\n-\t\treturn 1;\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t  else\n-\t    return 0;\n-\t}\n-      else if (GET_CODE (op0) == MULT)\n-\t{\n-\t  if (! (RTX_OK_FOR_INDEX_P (XEXP (op0, 0), strict)\n-\t\t && SCALE_TERM_P (XEXP (op0, 1))))\n-\t    return 0;\n-\n-\t  if (RTX_OK_FOR_BASE_P (op1, strict))\n-\t    return 1;\n-\t  else if (CONSTANT_P (op1))\n-\t    return 1;\n-\t  else\n-\t    return 0;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-  else if (GET_CODE (addr) == MULT)\n-    {\n-      if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n-\treturn 0;\n-\n-      return (RTX_OK_FOR_INDEX_P (XEXP (addr, 0), strict)\n-\t      && SCALE_TERM_P (XEXP (addr, 1)));\n-    }\n-  else\n-    return 0;\n-}\n-\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   This converts some non-canonical addresses to canonical form so they\n-   can be recognized.  */\n-\n-rtx\n-legitimize_address (x, oldx, mode)\n-     register rtx x;\n-     register rtx oldx ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{ \n-  if (GET_CODE (x) == SYMBOL_REF)\n-    {\n-      abort ();\n-      x = copy_to_reg (x);\n-    }\n-\n-  if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n-    return x;\n-\n-  /* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const)))\n-     into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be\n-     created by virtual register instantiation, register elimination, and\n-     similar optimizations.  */\n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n-      && GET_CODE (XEXP (x, 1)) == PLUS)\n-    x = gen_rtx_PLUS (Pmode,\n-\t\t      gen_rtx_PLUS (Pmode, XEXP (x, 0), XEXP (XEXP (x, 1), 0)),\n-\t\t      XEXP (XEXP (x, 1), 1));\n-\n-  /* Canonicalize (plus (plus (mult (reg) (const)) (plus (reg) (const))) const)\n-     into (plus (plus (mult (reg) (const)) (reg)) (const)).  */\n-  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n-\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == PLUS\n-\t   && CONSTANT_P (XEXP (x, 1)))\n-    {\n-      rtx constant, other;\n-\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  constant = XEXP (x, 1);\n-\t  other = XEXP (XEXP (XEXP (x, 0), 1), 1);\n-\t}\n-      else if (GET_CODE (XEXP (XEXP (XEXP (x, 0), 1), 1)) == CONST_INT)\n-\t{\n-\t  constant = XEXP (XEXP (XEXP (x, 0), 1), 1);\n-\t  other = XEXP (x, 1);\n-\t}\n-      else\n-\tconstant = 0, other = 0;\n-\n-      if (constant)\n-\tx = gen_rtx_PLUS (Pmode,\n-\t\t\t  gen_rtx_PLUS (Pmode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\tXEXP (XEXP (XEXP (x, 0), 1), 0)),\n-\t\t\t  plus_constant (other, INTVAL (constant)));\n-    }\n-\n-  return x;\n-}\n-\f\n-#if 0\n-/* Return the most stringent alignment that we are willing to consider\n-   objects of size SIZE and known alignment ALIGN as having.  */\n-   \n-int\n-i960_alignment (size, align)\n-     int size;\n-     int align;\n-{\n-  int i;\n-\n-  if (! TARGET_STRICT_ALIGN)\n-    if (TARGET_IC_COMPAT2_0 || align >= 4)\n-      {\n-\ti = i960_object_bytes_bitalign (size) / BITS_PER_UNIT;\n-\tif (i > align)\n-\t  align = i;\n-      }\n-\n-  return align;\n-}\n-#endif\n-\f\n-\n-int\n-hard_regno_mode_ok (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n-{\n-  if (regno < 32)\n-    {\n-      switch (mode)\n-\t{\n-\tcase CCmode: case CC_UNSmode: case CC_CHKmode:\n-\t  return 0;\n-\n-\tcase DImode: case DFmode:\n-\t  return (regno & 1) == 0;\n-\n-\tcase TImode: case TFmode:\n-\t  return (regno & 3) == 0;\n-\n-\tdefault:\n-\t  return 1;\n-\t}\n-    }\n-  else if (regno >= 32 && regno < 36)\n-    {\n-      switch (mode)\n-\t{\n-\tcase SFmode: case DFmode: case TFmode:\n-\tcase SCmode: case DCmode:\n-\t  return 1;\n-\n-\tdefault:\n-\t  return 0;\n-\t}\n-    }\n-  else if (regno == 36)\n-    {\n-      switch (mode)\n-\t{\n-\tcase CCmode: case CC_UNSmode: case CC_CHKmode:\n-\t  return 1;\n-\n-\tdefault:\n-\t  return 0;\n-\t}\n-    }\n-  else if (regno == 37)\n-    return 0;\n-\n-  abort ();\n-}\n-\n-\f\n-/* Return the minimum alignment of an expression rtx X in bytes.  This takes\n-   advantage of machine specific facts, such as knowing that the frame pointer\n-   is always 16 byte aligned.  */\n-\n-int\n-i960_expr_alignment (x, size)\n-     rtx x;\n-     int size;\n-{\n-  int align = 1;\n-\n-  if (x == 0)\n-    return 1;\n-\n-  switch (GET_CODE(x))\n-    {\n-    case CONST_INT:\n-      align = INTVAL(x);\n-\n-      if ((align & 0xf) == 0)\n-\talign = 16;\n-      else if ((align & 0x7) == 0)\n-\talign = 8;\n-      else if ((align & 0x3) == 0)\n-\talign = 4;\n-      else if ((align & 0x1) == 0)\n-\talign = 2;\n-      else\n-\talign = 1;\n-      break;\n-\n-    case PLUS:\n-      align = MIN (i960_expr_alignment (XEXP (x, 0), size),\n-\t\t   i960_expr_alignment (XEXP (x, 1), size));\n-      break;\n-\n-    case SYMBOL_REF:\n-      /* If this is a valid program, objects are guaranteed to be\n-\t correctly aligned for whatever size the reference actually is.  */\n-      align = i960_object_bytes_bitalign (size) / BITS_PER_UNIT;\n-      break;\n-\n-    case REG:\n-      if (REGNO (x) == FRAME_POINTER_REGNUM)\n-\talign = 16;\n-      break;\n-\n-    case ASHIFT:\n-      align = i960_expr_alignment (XEXP (x, 0), size);\n-\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  align = align << INTVAL (XEXP (x, 1));\n-\t  align = MIN (align, 16);\n-\t}\n-      break;\n-\n-    case MULT:\n-      align = (i960_expr_alignment (XEXP (x, 0), size) *\n-\t       i960_expr_alignment (XEXP (x, 1), size));\n-\n-      align = MIN (align, 16);\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  return align;\n-}\n-\n-/* Return true if it is possible to reference both BASE and OFFSET, which\n-   have alignment at least as great as 4 byte, as if they had alignment valid\n-   for an object of size SIZE.  */\n-\n-int\n-i960_improve_align (base, offset, size)\n-     rtx base;\n-     rtx offset;\n-     int size;\n-{\n-  int i, j;\n-\n-  /* We have at least a word reference to the object, so we know it has to\n-     be aligned at least to 4 bytes.  */\n-\n-  i = MIN (i960_expr_alignment (base, 4),\n-\t   i960_expr_alignment (offset, 4));\n-\n-  i = MAX (i, 4);\n-\n-  /* We know the size of the request.  If strict align is not enabled, we\n-     can guess that the alignment is OK for the requested size.  */\n-\n-  if (! TARGET_STRICT_ALIGN)\n-    if ((j = (i960_object_bytes_bitalign (size) / BITS_PER_UNIT)) > i)\n-      i = j;\n-\n-  return (i >= size);\n-}\n-\n-/* Return true if it is possible to access BASE and OFFSET, which have 4 byte\n-   (SImode) alignment as if they had 16 byte (TImode) alignment.  */\n-\n-int\n-i960_si_ti (base, offset)\n-     rtx base;\n-     rtx offset;\n-{\n-  return i960_improve_align (base, offset, 16);\n-}\n-\n-/* Return true if it is possible to access BASE and OFFSET, which have 4 byte\n-   (SImode) alignment as if they had 8 byte (DImode) alignment.  */\n-\n-int\n-i960_si_di (base, offset)\n-     rtx base;\n-     rtx offset;\n-{\n-  return i960_improve_align (base, offset, 8);\n-}\n-\f\n-/* Return raw values of size and alignment (in words) for the data\n-   type being accessed.  These values will be rounded by the caller.  */\n-\n-static void \n-i960_arg_size_and_align (mode, type, size_out, align_out)\n-     enum machine_mode mode;\n-     tree type;\n-     int *size_out;\n-     int *align_out;\n-{\n-  int size, align;\n-\n-  /* Use formal alignment requirements of type being passed, except make\n-     it at least a word.  If we don't have a type, this is a library call,\n-     and the parm has to be of scalar type.  In this case, consider its\n-     formal alignment requirement to be its size in words.  */\n-\n-  if (mode == BLKmode)\n-    size = (int_size_in_bytes (type) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  else if (mode == VOIDmode)\n-    {\n-      /* End of parm list.  */\n-      if (type == 0 || TYPE_MODE (type) != VOIDmode)\n-\tabort ();\n-      size = 1;\n-    }\n-  else\n-    size = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n-  if (type == 0)\n-    align = size;\n-  else if (TYPE_ALIGN (type) >= BITS_PER_WORD)\n-    align = TYPE_ALIGN (type) / BITS_PER_WORD;\n-  else\n-    align = 1;\n-\n-  *size_out  = size;\n-  *align_out = align;\n-}\n-\n-/* On the 80960 the first 12 args are in registers and the rest are pushed.\n-   Any arg that is bigger than 4 words is placed on the stack and all\n-   subsequent arguments are placed on the stack.\n-\n-   Additionally, parameters with an alignment requirement stronger than\n-   a word must be aligned appropriately.  Note that this means that a\n-   64 bit object with a 32 bit alignment is not 64 bit aligned and may be\n-   passed in an odd/even register pair.  */\n-\n-/* Update CUM to advance past an argument described by MODE and TYPE.  */\n-\n-void\n-i960_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n-{\n-  int size, align;\n-\n-  i960_arg_size_and_align (mode, type, &size, &align);\n-\n-  if (size > 4 || cum->ca_nstackparms != 0\n-      || (size + ROUND_PARM (cum->ca_nregparms, align)) > NPARM_REGS\n-      || MUST_PASS_IN_STACK (mode, type))\n-    {\n-      /* Indicate that all the registers are in use, even if all are not,\n-\t so va_start will compute the right value.  */\n-      cum->ca_nregparms = NPARM_REGS;\n-      cum->ca_nstackparms = ROUND_PARM (cum->ca_nstackparms, align) + size;\n-    }\n-  else\n-    cum->ca_nregparms = ROUND_PARM (cum->ca_nregparms, align) + size;\n-}\n-\n-/* Return the register that the argument described by MODE and TYPE is\n-   passed in, or else return 0 if it is passed on the stack.  */\n-\n-rtx\n-i960_function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n-{\n-  rtx ret;\n-  int size, align;\n-\n-  if (mode == VOIDmode)\n-    return 0;\n-\n-  i960_arg_size_and_align (mode, type, &size, &align);\n-\n-  if (size > 4 || cum->ca_nstackparms != 0\n-      || (size + ROUND_PARM (cum->ca_nregparms, align)) > NPARM_REGS\n-      || MUST_PASS_IN_STACK (mode, type))\n-    {\n-      cum->ca_nstackparms = ROUND_PARM (cum->ca_nstackparms, align);\n-      ret = 0;\n-    }\n-  else\n-    {\n-      cum->ca_nregparms = ROUND_PARM (cum->ca_nregparms, align);\n-      ret = gen_rtx_REG (mode, cum->ca_nregparms);\n-    }\n-\n-  return ret;\n-}\n-\f\n-/* Return the number of bits that an object of size N bytes is aligned to.  */\n-\n-int\n-i960_object_bytes_bitalign (n)\n-     int n;\n-{\n-  if (n > 8)      n = 128;\n-  else if (n > 4) n = 64;\n-  else if (n > 2) n = 32;\n-  else if (n > 1) n = 16;\n-  else            n = 8;\n-\n-  return n;\n-}\n-\n-/* Compute the alignment for an aggregate type TSIZE.\n-   Alignment is MAX (greatest member alignment,\n-                     MIN (pragma align, structure size alignment)).  */\n-\n-int\n-i960_round_align (align, type)\n-     int align;\n-     tree type;\n-{\n-  int new_align;\n-  tree tsize;\n-\n-  if (TARGET_OLD_ALIGN || TYPE_PACKED (type))\n-    return align;\n-  if (TREE_CODE (type) != RECORD_TYPE)\n-    return align;\n-  tsize = TYPE_SIZE (type);\n-\n-  if (! tsize || TREE_CODE (tsize) != INTEGER_CST)\n-    return align;\n-\n-  new_align = i960_object_bytes_bitalign (TREE_INT_CST_LOW (tsize)\n-\t\t\t\t\t  / BITS_PER_UNIT);\n-  /* Handle #pragma align.  */\n-  if (new_align > i960_maxbitalignment)\n-    new_align = i960_maxbitalignment;\n-\n-  if (align < new_align)\n-    align = new_align;\n-\n-  return align;\n-}\n-\f\n-/* Do any needed setup for a varargs function.  For the i960, we must\n-   create a register parameter block if one doesn't exist, and then copy\n-   all register parameters to memory.  */\n-\n-void\n-i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n-     int *pretend_size ATTRIBUTE_UNUSED;\n-     int no_rtl;\n-{\n-  /* Note: for a varargs fn with only a va_alist argument, this is 0.  */\n-  int first_reg = cum->ca_nregparms;\n-\n-  /* Copy only unnamed register arguments to memory.  If there are\n-     any stack parms, there are no unnamed arguments in registers, and\n-     an argument block was already allocated by the caller.\n-     Remember that any arg bigger than 4 words is passed on the stack as\n-     are all subsequent args.\n-\n-     If there are no stack arguments but there are exactly NPARM_REGS\n-     registers, either there were no extra arguments or the caller\n-     allocated an argument block.  */\n-\n-  if (cum->ca_nstackparms == 0 && first_reg < NPARM_REGS && !no_rtl)\n-    {\n-      rtx label = gen_label_rtx ();\n-      rtx regblock, fake_arg_pointer_rtx;\n-\n-      /* Use a different rtx than arg_pointer_rtx so that cse and friends\n-\t can go on believing that the argument pointer can never be zero.  */\n-      fake_arg_pointer_rtx = gen_raw_REG (Pmode, ARG_POINTER_REGNUM);\n-\n-      /* If the argument pointer is 0, no arguments were passed on the stack\n-\t and we need to allocate a chunk to save the registers (if any\n-\t arguments were passed on the stack the caller would allocate the\n-\t 48 bytes as well).  We must allocate all 48 bytes (12*4) because\n-\t va_start assumes it.  */\n-      emit_insn (gen_cmpsi (fake_arg_pointer_rtx, const0_rtx));\n-      emit_jump_insn (gen_bne (label));\n-      emit_insn (gen_rtx_SET (VOIDmode, fake_arg_pointer_rtx,\n-\t\t\t      stack_pointer_rtx));\n-      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t      memory_address (SImode,\n-\t\t\t\t\t      plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\t     48))));\n-      emit_label (label);\n-\n-      /* ??? Note that we unnecessarily store one extra register for stdarg\n-\t fns.  We could optimize this, but it's kept as for now.  */\n-      regblock = gen_rtx_MEM (BLKmode,\n-\t\t\t      plus_constant (arg_pointer_rtx, first_reg * 4));\n-      set_mem_alias_set (regblock, get_varargs_alias_set ());\n-      set_mem_align (regblock, BITS_PER_WORD);\n-      move_block_from_reg (first_reg, regblock,\n-\t\t\t   NPARM_REGS - first_reg);\n-    }\n-}\n-\n-/* Define the `__builtin_va_list' type for the ABI.  */\n-\n-static tree\n-i960_build_builtin_va_list ()\n-{\n-  return build_array_type (unsigned_type_node,\n-\t\t\t   build_index_type (size_one_node));\n-}\n-\n-/* Implement `va_start' for varargs and stdarg.  */\n-\n-void\n-i960_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n-{\n-  tree s, t, base, num;\n-  rtx fake_arg_pointer_rtx;\n-\n-  /* The array type always decays to a pointer before we get here, so we\n-     can't use ARRAY_REF.  */\n-  base = build1 (INDIRECT_REF, unsigned_type_node, valist);\n-  num = build1 (INDIRECT_REF, unsigned_type_node,\n-\t\tbuild (PLUS_EXPR, unsigned_type_node, valist,\n-\t\t       TYPE_SIZE_UNIT (TREE_TYPE (valist))));\n-\n-  /* Use a different rtx than arg_pointer_rtx so that cse and friends\n-     can go on believing that the argument pointer can never be zero.  */\n-  fake_arg_pointer_rtx = gen_raw_REG (Pmode, ARG_POINTER_REGNUM);\n-  s = make_tree (unsigned_type_node, fake_arg_pointer_rtx);\n-  t = build (MODIFY_EXPR, unsigned_type_node, base, s);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  s = build_int_2 ((current_function_args_info.ca_nregparms\n-\t\t    + current_function_args_info.ca_nstackparms) * 4, 0);\n-  t = build (MODIFY_EXPR, unsigned_type_node, num, s);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-}\n-\n-/* Implement `va_arg'.  */\n-\n-rtx\n-i960_va_arg (valist, type)\n-     tree valist, type;\n-{\n-  HOST_WIDE_INT siz, ali;\n-  tree base, num, pad, next, this, t1, t2, int48;\n-  rtx addr_rtx;\n-\n-  /* The array type always decays to a pointer before we get here, so we\n-     can't use ARRAY_REF.  */\n-  base = build1 (INDIRECT_REF, unsigned_type_node, valist);\n-  num = build1 (INDIRECT_REF, unsigned_type_node,\n-\t\tbuild (PLUS_EXPR, unsigned_type_node, valist,\n-\t\t       TYPE_SIZE_UNIT (TREE_TYPE (valist))));\n-\n-  /* Round up sizeof(type) to a word.  */\n-  siz = (int_size_in_bytes (type) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n-\n-  /* Round up alignment to a word.  */\n-  ali = TYPE_ALIGN (type);\n-  if (ali < BITS_PER_WORD)\n-    ali = BITS_PER_WORD;\n-  ali /= BITS_PER_UNIT;\n-\n-  /* Align NUM appropriate for the argument.  */\n-  pad = fold (build (PLUS_EXPR, unsigned_type_node, num, \n-\t\t      build_int_2 (ali - 1, 0)));\n-  pad = fold (build (BIT_AND_EXPR, unsigned_type_node, pad,\n-\t\t      build_int_2 (-ali, -1)));\n-  pad = save_expr (pad);\n-\n-  /* Increment VPAD past this argument.  */\n-  next = fold (build (PLUS_EXPR, unsigned_type_node, pad,\n-\t\t      build_int_2 (siz, 0)));\n-  next = save_expr (next);\n-\n-  /* Find the offset for the current argument.  Mind peculiar overflow\n-     from registers to stack.  */\n-  int48 = build_int_2 (48, 0);\n-  if (siz > 16)\n-    t2 = integer_one_node;\n-  else\n-    t2 = fold (build (GT_EXPR, integer_type_node, next, int48));\n-  t1 = fold (build (LE_EXPR, integer_type_node, num, int48));\n-  t1 = fold (build (TRUTH_AND_EXPR, integer_type_node, t1, t2));\n-  this = fold (build (COND_EXPR, unsigned_type_node, t1, int48, pad));\n-\n-  /* Find the address for the current argument.  */\n-  t1 = fold (build (PLUS_EXPR, unsigned_type_node, base, this));\n-  t1 = build1 (NOP_EXPR, ptr_type_node, t1);\n-  addr_rtx = expand_expr (t1, NULL_RTX, Pmode, EXPAND_NORMAL);\n-\n-  /* Increment NUM.  */\n-  t1 = build (MODIFY_EXPR, unsigned_type_node, num, next);\n-  TREE_SIDE_EFFECTS (t1) = 1;\n-  expand_expr (t1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-  \n-  return addr_rtx;\n-}\n-\n-/* Calculate the final size of the reg parm stack space for the current\n-   function, based on how many bytes would be allocated on the stack.  */\n-\n-int\n-i960_final_reg_parm_stack_space (const_size, var_size)\n-     int const_size;\n-     tree var_size;\n-{\n-  if (var_size || const_size > 48)\n-    return 48;\n-  else\n-    return 0;\n-}\n-\n-/* Calculate the size of the reg parm stack space.  This is a bit complicated\n-   on the i960.  */\n-\n-int\n-i960_reg_parm_stack_space (fndecl)\n-     tree fndecl;\n-{\n-  /* In this case, we are called from emit_library_call, and we don't need\n-     to pretend we have more space for parameters than what's apparent.  */\n-  if (fndecl == 0)\n-    return 0;\n-\n-  /* In this case, we are called from locate_and_pad_parms when we're\n-     not IN_REGS, so we have an arg block.  */\n-  if (fndecl != current_function_decl)\n-    return 48;\n-\n-  /* Otherwise, we have an arg block if the current function has more than\n-     48 bytes of parameters.  */\n-  if (current_function_args_size != 0 || VARARGS_STDARG_FUNCTION (fndecl))\n-    return 48;\n-  else\n-    return 0;\n-}\n-\f\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx in;\n-{\n-  int regno = -1;\n-\n-  if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n-    regno = true_regnum (in);\n-\n-  /* We can place anything into LOCAL_OR_GLOBAL_REGS and can put\n-     LOCAL_OR_GLOBAL_REGS into anything.  */\n-  if (class == LOCAL_OR_GLOBAL_REGS || class == LOCAL_REGS\n-      || class == GLOBAL_REGS || (regno >= 0 && regno < 32))\n-    return NO_REGS;\n-\n-  /* We can place any hard register, 0.0, and 1.0 into FP_REGS.  */\n-  if (class == FP_REGS\n-      && ((regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n-\t  || in == CONST0_RTX (mode) || in == CONST1_RTX (mode)))\n-    return NO_REGS;\n-\n-  return LOCAL_OR_GLOBAL_REGS;\n-}\n-\f\n-/* Look at the opcode P, and set i96_last_insn_type to indicate which\n-   function unit it executed on.  */\n-\n-/* ??? This would make more sense as an attribute.  */\n-\n-void\n-i960_scan_opcode (p)\n-     const char *p;\n-{\n-  switch (*p)\n-    {\n-    case 'a':\n-    case 'd':\n-    case 'e':\n-    case 'm':\n-    case 'n':\n-    case 'o':\n-    case 'r':\n-      /* Ret is not actually of type REG, but it won't matter, because no\n-\t insn will ever follow it.  */\n-    case 'u':\n-    case 'x':\n-      i960_last_insn_type = I_TYPE_REG;\n-      break;\n-\n-    case 'b':\n-      if (p[1] == 'x' || p[3] == 'x')\n-        i960_last_insn_type = I_TYPE_MEM;\n-      i960_last_insn_type = I_TYPE_CTRL;\n-      break;\n-\n-    case 'f':\n-    case 't':\n-      i960_last_insn_type = I_TYPE_CTRL;\n-      break;\n-\n-    case 'c':\n-      if (p[1] == 'a')\n-\t{\n-\t  if (p[4] == 'x')\n-\t    i960_last_insn_type = I_TYPE_MEM;\n-\t  else\n-\t    i960_last_insn_type = I_TYPE_CTRL;\n-\t}\n-      else if (p[1] == 'm')\n-\t{\n-\t  if (p[3] == 'd')\n-\t    i960_last_insn_type = I_TYPE_REG;\n-\t  else if (p[4] == 'b' || p[4] == 'j')\n-\t    i960_last_insn_type = I_TYPE_CTRL;\n-\t  else\n-\t    i960_last_insn_type = I_TYPE_REG;\n-\t}\n-      else\n-        i960_last_insn_type = I_TYPE_REG;\n-      break;\n-\n-    case 'l':\n-      i960_last_insn_type = I_TYPE_MEM;\n-      break;\n-\n-    case 's':\n-      if (p[1] == 't')\n-        i960_last_insn_type = I_TYPE_MEM;\n-      else\n-        i960_last_insn_type = I_TYPE_REG;\n-      break;\n-    }\n-}\n-\n-static void\n-i960_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n-     tree function;\n-{\n-  int d = delta;\n-  if (d < 0 && d > -32)\t\t\t\t\t\t\t\n-    fprintf (file, \"\\tsubo %d,g0,g0\\n\", -d);\t\t\t\t\n-  else if (d > 0 && d < 32)\t\t\t\t\t\t\n-    fprintf (file, \"\\taddo %d,g0,g0\\n\", d);\t\t\t\t\n-  else\t\t\t\t\t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\t\n-      fprintf (file, \"\\tldconst %d,r5\\n\", d);\t\t\t\t\n-      fprintf (file, \"\\taddo r5,g0,g0\\n\");\t\t\t\t\n-    }\t\t\t\t\t\t\t\t\t\n-  fprintf (file, \"\\tbx \");\t\t\t\t\t\t\n-  assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\t\n-  fprintf (file, \"\\n\");\t\t\t\t\t\t\t\n-}\n-\n-static bool\n-i960_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n-{\n-  switch (code)\n-    {\n-      /* Constants that can be (non-ldconst) insn operands are cost 0.\n-\t Constants that can be non-ldconst operands in rare cases are cost 1.\n-         Other constants have higher costs.\n-\n-         Must check for OUTER_CODE of SET for power2_operand, because\n-         reload_cse_move2add calls us with OUTER_CODE of PLUS to decide\n-\t when to replace set with add.  */\n-\n-    case CONST_INT:\n-      if ((INTVAL (x) >= 0 && INTVAL (x) < 32)\n-\t  || (outer_code == SET && power2_operand (x, VOIDmode)))\n-\t{\n-\t  *total = 0;\n-\t  return true;\n-\t}\n-      else if (INTVAL (x) >= -31 && INTVAL (x) < 0)\n-\t{\n-\t  *total = 1;\n-\t  return true;\n-\t}\n-      /* FALLTHRU */\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = (TARGET_C_SERIES ? 6 : 8);\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      if (x == CONST0_RTX (DFmode) || x == CONST0_RTX (SFmode)\n-\t  || x == CONST1_RTX (DFmode) || x == CONST1_RTX (SFmode))\n-\t*total = 1;\n-      else\n-\t*total = 12;\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}"}, {"sha": "67c34e250319c059a261103c39b01b22ad6f6e4b", "filename": "gcc/config/i960/i960.h", "status": "removed", "additions": 0, "deletions": 1404, "changes": 1404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,1404 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for Intel 80960\n-   Copyright (C) 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Note that some other tm.h files may include this one and then override\n-   many of the definitions that relate to assembler syntax.  */\n-\n-/* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define_std (\"i960\");\t\t\\\n-\tbuiltin_define_std (\"I960\");\t\t\\\n-\tbuiltin_define_std (\"i80960\");\t\t\\\n-\tbuiltin_define_std (\"I80960\");\t\t\\\n-\tbuiltin_assert (\"cpu=i960\");\t\t\\\n-\tbuiltin_assert (\"machine=i960\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define MULTILIB_DEFAULTS { \"mnumerics\" }\n-\n-/* Name to predefine in the preprocessor for processor variations.\n-   -mic* options make characters signed by default.  */\n-#define\tCPP_SPEC \"%{mic*:-D__i960 -fsigned-char\\\n-\t\t\t%{mka:-D__i960KA}%{mkb:-D__i960KB}\\\n-\t\t\t%{mja:-D__i960JA}%{mjd:-D__i960JD}%{mjf:-D__i960JF}\\\n-\t\t\t%{mrp:-D__i960RP}\\\n-\t\t\t%{msa:-D__i960SA}%{msb:-D__i960SB}\\\n-\t\t\t%{mmc:-D__i960MC}\\\n-\t\t\t%{mca:-D__i960CA}%{mcc:-D__i960CC}\\\n-\t\t\t%{mcf:-D__i960CF}}\\\n-\t%{msoft-float:-D_SOFT_FLOAT}\\\n-\t%{mka:-D__i960KA__ -D__i960_KA__}\\\n-\t%{mkb:-D__i960KB__ -D__i960_KB__}\\\n-\t%{msa:-D__i960SA__ -D__i960_SA__}\\\n-\t%{msb:-D__i960SB__ -D__i960_SB__}\\\n-\t%{mmc:-D__i960MC__ -D__i960_MC__}\\\n-\t%{mca:-D__i960CA__ -D__i960_CA__}\\\n-\t%{mcc:-D__i960CC__ -D__i960_CC__}\\\n-\t%{mcf:-D__i960CF__ -D__i960_CF__}\\\n-\t%{!mka:%{!mkb:%{!msa:%{!msb:%{!mmc:%{!mca:\\\n-\t\t%{!mcc:%{!mcf:-D__i960_KB -D__i960KB__ %{mic*:-D__i960KB}}}}}}}}}\\\n-\t%{mlong-double-64:-D__LONG_DOUBLE_64__}\"\n-\n-/* Specs for the compiler, to handle processor variations. \n-   If the user gives an explicit -gstabs or -gcoff option, then do not\n-   try to add an implicit one, as this will fail. \n-   -mic* options make characters signed by default.  */\n-#define CC1_SPEC \\\n-\t\"%{mic*:-fsigned-char}\\\n-%{!mka:%{!mkb:%{!msa:%{!msb:%{!mmc:%{!mca:%{!mcc:%{!mcf:%{!mja:%{!mjd:%{!mjf:%{!mrp:-mka}}}}}}}}}}}}\\\n-\t %{!gs*:%{!gc*:%{mbout:%{g*:-gstabs}}\\\n-\t\t       %{mcoff:%{g*:-gcoff}}\\\n-\t\t       %{!mbout:%{!mcoff:%{g*:-gstabs}}}}}\"\n-\n-/* Specs for the assembler, to handle processor variations.\n-   For compatibility with Intel's gnu960 tool chain, pass -A options to\n-   the assembler.  */\n-#define ASM_SPEC \\\n-\t\"%{mka:-AKA}%{mkb:-AKB}%{msa:-ASA}%{msb:-ASB}\\\n-\t%{mmc:-AMC}%{mca:-ACA}%{mcc:-ACC}%{mcf:-ACF}\\\n-        %{mja:-AJX}%{mjd:-AJX}%{mjf:-AJX}%{mrp:-AJX}\\\n-\t%{!mka:%{!mkb:%{!msa:%{!msb:%{!mmc:%{!mca:%{!mcc:%{!mcf:%{!mja:%{!mjd:%{!mjf:%{!mrp:-AKB}}}}}}}}}}}}\\\n-\t%{mlink-relax:-linkrelax}\"\n-\n-/* Specs for the linker, to handle processor variations.\n-   For compatibility with Intel's gnu960 tool chain, pass -F and -A options\n-   to the linker.  */\n-#define LINK_SPEC \\\n-\t\"%{mka:-AKA}%{mkb:-AKB}%{msa:-ASA}%{msb:-ASB}\\\n-\t%{mmc:-AMC}%{mca:-ACA}%{mcc:-ACC}%{mcf:-ACF}\\\n-        %{mja:-AJX}%{mjd:-AJX}%{mjf:-AJX}%{mrp:-AJX}\\\n-\t%{mbout:-Fbout}%{mcoff:-Fcoff}\\\n-\t%{mlink-relax:-relax}\"\n-\n-/* Specs for the libraries to link with, to handle processor variations.\n-   Compatible with Intel's gnu960 tool chain.  */\n-#define LIB_SPEC \"%{!nostdlib:-lcg %{p:-lprof}%{pg:-lgprof}\\\n-\t  %{mka:-lfpg}%{msa:-lfpg}%{mca:-lfpg}%{mcf:-lfpg} -lgnu}\"\n-\n-/* Defining the macro shows we can debug even without a frame pointer.\n-   Actually, we can debug without FP.  But defining the macro results in\n-   that -O means FP elimination.  Addressing through sp requires\n-   negative offset and more one word addressing in the most cases\n-   (offsets except for 0-4095 require one more word).  Therefore we've\n-   not defined the macro.  */\n-/*#define CAN_DEBUG_WITHOUT_FP*/\n-\n-/* Do leaf procedure and tail call optimizations for -O2 and higher.  */\n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\\\n-{\t\t\t\t\t\t\\\n-  if ((LEVEL) >= 2)\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      target_flags |= TARGET_FLAG_LEAFPROC;\t\\\n-      target_flags |= TARGET_FLAG_TAILCALL;\t\\\n-    }\t\t\t\t\t\t\\\n-}\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION fprintf (stderr,\" (intel 80960)\");\n-\n-/* Generate DBX debugging information.  */\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Generate SDB style debugging information.  */\n-#define SDB_DEBUGGING_INFO 1\n-#define EXTENDED_SDB_BASIC_TYPES\n-\n-/* Generate DBX_DEBUGGING_INFO by default.  */\n-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-\n-/* Redefine this to print in hex.  No value adjustment is necessary\n-   anymore.  */\n-#define PUT_SDB_TYPE(A) \\\n-  fprintf (asm_out_file, \"\\t.type\\t0x%x;\", A)\n-\n-/* Handle pragmas for compatibility with Intel's compilers.  */\n-\n-extern int i960_maxbitalignment;\n-extern int i960_last_maxbitalignment;\n-\n-#define REGISTER_TARGET_PRAGMAS() do {\t\t\t\\\n-  c_register_pragma (0, \"align\", i960_pr_align);\t\\\n-  c_register_pragma (0, \"noalign\", i960_pr_noalign);\t\\\n-} while (0)\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-/* 960 architecture with floating-point.  */\n-#define TARGET_FLAG_NUMERICS\t0x01\n-#define TARGET_NUMERICS\t\t(target_flags & TARGET_FLAG_NUMERICS)\n-\n-/* 960 architecture with memory management.  */\n-/* ??? Not used currently.  */\n-#define\tTARGET_FLAG_PROTECTED\t0x02\n-#define\tTARGET_PROTECTED\t(target_flags & TARGET_FLAG_PROTECTED)\n-\n-/* The following three are mainly used to provide a little sanity checking\n-   against the -mARCH flags given. The Jx series, for the purposes of\n-   gcc, is a Kx with a data cache.  */\n-\n-/* Nonzero if we should generate code for the KA and similar processors.\n-   No FPU, no microcode instructions.  */\n-#define TARGET_FLAG_K_SERIES\t0x04\n-#define TARGET_K_SERIES\t\t(target_flags & TARGET_FLAG_K_SERIES)\n-\n-/* Nonzero if we should generate code for the MC processor.\n-   Not really different from KB for our purposes.  */\n-#define\tTARGET_FLAG_MC\t\t0x08\n-#define TARGET_MC \t\t(target_flags & TARGET_FLAG_MC)\n-\n-/* Nonzero if we should generate code for the CA processor.\n-   Enables different optimization strategies.  */\n-#define\tTARGET_FLAG_C_SERIES\t0x10\n-#define\tTARGET_C_SERIES \t(target_flags & TARGET_FLAG_C_SERIES)\n-\n-/* Nonzero if we should generate leaf-procedures when we find them.\n-   You may not want to do this because leaf-proc entries are\n-   slower when not entered via BAL - this would be true when\n-   a linker not supporting the optimization is used.  */\n-#define\tTARGET_FLAG_LEAFPROC\t0x20\n-#define\tTARGET_LEAFPROC\t\t(target_flags & TARGET_FLAG_LEAFPROC)\n-\n-/* Nonzero if we should perform tail-call optimizations when we find them.\n-   You may not want to do this because the detection of cases where\n-   this is not valid is not totally complete.  */\n-#define\tTARGET_FLAG_TAILCALL\t0x40\n-#define\tTARGET_TAILCALL\t\t(target_flags & TARGET_FLAG_TAILCALL)\n-\n-/* Nonzero if use of a complex addressing mode is a win on this implementation.\n-   Complex addressing modes are probably not worthwhile on the K-series,\n-   but they definitely are on the C-series.  */\n-#define\tTARGET_FLAG_COMPLEX_ADDR 0x80\n-#define\tTARGET_COMPLEX_ADDR\t(target_flags & TARGET_FLAG_COMPLEX_ADDR)\n-\n-/* Align code to 8 byte boundaries for faster fetching.  */\n-#define\tTARGET_FLAG_CODE_ALIGN\t0x100\n-#define\tTARGET_CODE_ALIGN\t(target_flags  & TARGET_FLAG_CODE_ALIGN)\n-\n-/* Append branch prediction suffixes to branch opcodes.  */\n-/* ??? Not used currently.  */\n-#define\tTARGET_FLAG_BRANCH_PREDICT 0x200\n-#define\tTARGET_BRANCH_PREDICT\t(target_flags  & TARGET_FLAG_BRANCH_PREDICT)\n-\n-/* Forces prototype and return promotions.  */\n-/* ??? This does not work.  */\n-#define\tTARGET_FLAG_CLEAN_LINKAGE 0x400\n-#define\tTARGET_CLEAN_LINKAGE\t(target_flags & TARGET_FLAG_CLEAN_LINKAGE)\n-\n-/* For compatibility with iC960 v3.0.  */\n-#define\tTARGET_FLAG_IC_COMPAT3_0 0x800 \n-#define\tTARGET_IC_COMPAT3_0\t(target_flags & TARGET_FLAG_IC_COMPAT3_0)\n-\n-/* For compatibility with iC960 v2.0.  */\n-#define\tTARGET_FLAG_IC_COMPAT2_0 0x1000\n-#define\tTARGET_IC_COMPAT2_0\t(target_flags & TARGET_FLAG_IC_COMPAT2_0)\n-\n-/* If no unaligned accesses are to be permitted.  */\n-#define\tTARGET_FLAG_STRICT_ALIGN 0x2000\n-#define\tTARGET_STRICT_ALIGN\t(target_flags & TARGET_FLAG_STRICT_ALIGN)\n-\n-/* For compatibility with iC960 assembler.  */\n-#define\tTARGET_FLAG_ASM_COMPAT\t0x4000\n-#define\tTARGET_ASM_COMPAT\t(target_flags & TARGET_FLAG_ASM_COMPAT)\n-\n-/* For compatibility with the gcc960 v1.2 compiler.  Use the old structure\n-   alignment rules.  Also, turns on STRICT_ALIGNMENT.  */\n-#define TARGET_FLAG_OLD_ALIGN\t0x8000\n-#define TARGET_OLD_ALIGN\t(target_flags & TARGET_FLAG_OLD_ALIGN)\n-\n-/* Nonzero if long doubles are to be 64 bits.  Useful for soft-float targets\n-   if 80 bit long double support is missing.  */\n-#define TARGET_FLAG_LONG_DOUBLE_64\t0x10000\n-#define TARGET_LONG_DOUBLE_64\t(target_flags & TARGET_FLAG_LONG_DOUBLE_64)\n-\n-extern int target_flags;\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-/* ??? Not all ten of these architecture variations actually exist, but I\n-   am not sure which are real and which aren't.  */\n-\n-#define TARGET_SWITCHES  \\\n-  { {\"sa\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"Generate SA code\")},\t\t\t\t\t\t\\\n-    {\"sb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_K_SERIES|\t\t\t\\\n-\t\t\tTARGET_FLAG_COMPLEX_ADDR),\t\t\t\\\n-       N_(\"Generate SB code\")},\t\t\t\t\t\t\\\n-/*  {\"sc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\t\t\t\\\n-\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR),\t\\\n-       N_(\"Generate SC code\")}, */\t\t\t\t\t\\\n-    {\"ka\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"Generate KA code\")},\t\t\t\t\t\t\\\n-    {\"kb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_K_SERIES|\t\t\t\\\n-\t\t\tTARGET_FLAG_COMPLEX_ADDR),\t\t\t\\\n-       N_(\"Generate KB code\")},\t\t\t\t\t\t\\\n-/*  {\"kc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\t\t\t\\\n-\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR),\t\\\n-       N_(\"Generate KC code\")}, */\t\t\t\t\t\\\n-    {\"ja\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"Generate JA code\")},\t\t\t\t\t\t\\\n-    {\"jd\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"Generate JD code\")},\t\t\t\t\t\t\\\n-    {\"jf\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_K_SERIES|\t\t\t\\\n-\t\t\tTARGET_FLAG_COMPLEX_ADDR),\t\t\t\\\n-       N_(\"Generate JF code\")},\t\t\t\t\t\t\\\n-    {\"rp\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"generate RP code\")},\t\t\t\t\t\t\\\n-    {\"mc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\t\t\t\\\n-\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR),\t\\\n-       N_(\"Generate MC code\")},\t\t\t\t\t\t\\\n-    {\"ca\", (TARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\t\t\\\n-\t\t\tTARGET_FLAG_CODE_ALIGN|TARGET_FLAG_COMPLEX_ADDR),\\\n-       N_(\"Generate CA code\")},\t\t\t\t\t\t\\\n-/*  {\"cb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_C_SERIES|\t\t\t\\\n-\t\t\tTARGET_FLAG_BRANCH_PREDICT|TARGET_FLAG_CODE_ALIGN),\\\n-       N_(\"Generate CB code\")},\t\t\t\t\t\t\\\n-    {\"cc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\t\t\t\\\n-\t\t\tTARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\\\n-\t\t\tTARGET_FLAG_CODE_ALIGN),\t\t\t\\\n-       N_(\"Generate CC code\")}, */\t\t\t\t\t\\\n-    {\"cf\", (TARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\t\t\\\n-\t\t\tTARGET_FLAG_CODE_ALIGN|TARGET_FLAG_COMPLEX_ADDR),\\\n-       N_(\"Generate CF code\")},\t\t\t\t\t\t\\\n-    {\"numerics\", (TARGET_FLAG_NUMERICS),\t\t\t\t\\\n-       N_(\"Use hardware floating point instructions\")},\t\t\t\\\n-    {\"soft-float\", -(TARGET_FLAG_NUMERICS),\t\t\t\t\\\n-       N_(\"Use software floating point\")},\t\t\t\t\\\n-    {\"leaf-procedures\", TARGET_FLAG_LEAFPROC,\t\t\t\t\\\n-       N_(\"Use alternate leaf function entries\")},\t\t\t\\\n-    {\"no-leaf-procedures\", -(TARGET_FLAG_LEAFPROC),\t\t\t\\\n-       N_(\"Do not use alternate leaf function entries\")},\t\t\\\n-    {\"tail-call\", TARGET_FLAG_TAILCALL,\t\t\t\t\t\\\n-       N_(\"Perform tail call optimization\")},\t\t\t\t\\\n-    {\"no-tail-call\", -(TARGET_FLAG_TAILCALL),\t\t\t\t\\\n-       N_(\"Do not perform tail call optimization\")},\t\t\t\\\n-    {\"complex-addr\", TARGET_FLAG_COMPLEX_ADDR, \t\t\t\t\\\n-       N_(\"Use complex addressing modes\")},\t\t\t\t\\\n-    {\"no-complex-addr\", -(TARGET_FLAG_COMPLEX_ADDR),\t\t\t\\\n-       N_(\"Do not use complex addressing modes\")},\t\t\t\\\n-    {\"code-align\", TARGET_FLAG_CODE_ALIGN,\t\t\t\t\\\n-       N_(\"Align code to 8 byte boundary\")},\t\t\t\t\\\n-    {\"no-code-align\", -(TARGET_FLAG_CODE_ALIGN),\t\t\t\\\n-       N_(\"Do not align code to 8 byte boundary\")},\t\t\t\\\n-/*  {\"clean-linkage\", (TARGET_FLAG_CLEAN_LINKAGE),\t\t\t\\\n-       N_(\"Force use of prototypes\")},\t\t\t\t\t\\\n-    {\"no-clean-linkage\", -(TARGET_FLAG_CLEAN_LINKAGE),\t\t\t\\\n-       N_(\"Do not force use of prototypes\")}, */\t\t\t\\\n-    {\"ic-compat\", TARGET_FLAG_IC_COMPAT2_0,\t\t\t\t\\\n-       N_(\"Enable compatibility with iC960 v2.0\")},\t\t\t\\\n-    {\"ic2.0-compat\", TARGET_FLAG_IC_COMPAT2_0,\t\t\t\t\\\n-       N_(\"Enable compatibility with iC960 v2.0\")},\t\t\t\\\n-    {\"ic3.0-compat\", TARGET_FLAG_IC_COMPAT3_0,\t\t\t\t\\\n-       N_(\"Enable compatibility with iC960 v3.0\")},\t\t\t\\\n-    {\"asm-compat\", TARGET_FLAG_ASM_COMPAT,\t\t\t\t\\\n-       N_(\"Enable compatibility with ic960 assembler\")},\t\t\\\n-    {\"intel-asm\", TARGET_FLAG_ASM_COMPAT,\t\t\t\t\\\n-       N_(\"Enable compatibility with ic960 assembler\")},\t\t\\\n-    {\"strict-align\", TARGET_FLAG_STRICT_ALIGN,\t\t\t\t\\\n-       N_(\"Do not permit unaligned accesses\")},\t\t\t\t\\\n-    {\"no-strict-align\", -(TARGET_FLAG_STRICT_ALIGN),\t\t\t\\\n-       N_(\"Permit unaligned accesses\")},\t\t\t\t\\\n-    {\"old-align\", (TARGET_FLAG_OLD_ALIGN|TARGET_FLAG_STRICT_ALIGN),\t\\\n-       N_(\"Layout types like Intel's v1.3 gcc\")},\t\t\t\\\n-    {\"no-old-align\", -(TARGET_FLAG_OLD_ALIGN|TARGET_FLAG_STRICT_ALIGN),\t\\\n-       N_(\"Do not layout types like Intel's v1.3 gcc\")},\t\t\\\n-    {\"long-double-64\", TARGET_FLAG_LONG_DOUBLE_64,\t\t\t\\\n-       N_(\"Use 64 bit long doubles\")},\t\t\t\t\t\\\n-    {\"link-relax\", 0,\t\t\t\t\t\t\t\\\n-       N_(\"Enable linker relaxation\")},\t\t\t\t\t\\\n-    {\"no-link-relax\", 0,\t\t\t\t\t\t\\\n-       N_(\"Do not enable linker relaxation\")},\t\t\t\t\\\n-    SUBTARGET_SWITCHES                                                  \\\n-    { \"\", TARGET_DEFAULT,\t\t\t\t\t\t\\\n-\tNULL}}\n-\n-/* This are meant to be redefined in the host dependent files */\n-#define SUBTARGET_SWITCHES\n-\n-/* Override conflicting target switch options.\n-   Doesn't actually detect if more than one -mARCH option is given, but\n-   does handle the case of two blatantly conflicting -mARCH options.  */\n-#define OVERRIDE_OPTIONS  i960_initialize ()\n-\n-/* Don't enable anything by default.  The user is expected to supply a -mARCH\n-   option.  If none is given, then -mka is added by CC1_SPEC.  */\n-#define TARGET_DEFAULT 0\n-\f\n-/* Target machine storage layout.  */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.\n-   The i960 case be either big endian or little endian.  We only support\n-   little endian, which is the most common.  */\n-#define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword number is lowest\n-   numbered.  */\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* Bitfields cannot cross word boundaries.  */\n-#define BITFIELD_NBYTES_LIMITED 1\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Width in bits of a long double.  */\n-#define\tLONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_64 ? 64 : 128)\n-#define MAX_LONG_DOUBLE_TYPE_SIZE 128\n-\n-/* Define this to set long double type size to use in libgcc2.c, which can\n-   not depend on target_flags.  */\n-#if defined(__LONG_DOUBLE_64__)\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64\n-#else\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128\n-#endif\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 128\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 128\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* This makes zero-length anonymous fields lay the next field\n-   at a word boundary.  It also makes the whole struct have\n-   at least word alignment if there are any bitfields at all.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* No data type wants to be aligned rounder than this.\n-   Extended precision floats gets 4-word alignment.  */\n-#define BIGGEST_ALIGNMENT 128\n-\n-/* Define this if move instructions will actually fail to work\n-   when given unaligned data.\n-   80960 will work even with unaligned data, but it is slow.  */\n-#define STRICT_ALIGNMENT TARGET_STRICT_ALIGN\n-\n-/* Specify alignment for string literals (which might be higher than the\n-   base type's minimal alignment requirement.  This allows strings to be\n-   aligned on word boundaries, and optimizes calls to the str* and mem*\n-   library functions.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN) \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && i960_object_bytes_bitalign (int_size_in_bytes (TREE_TYPE (EXP))) > (int)(ALIGN) \\\n-   ? i960_object_bytes_bitalign (int_size_in_bytes (TREE_TYPE (EXP)))\t    \\\n-   : (int)(ALIGN))\n-\n-/* Macros to determine size of aggregates (structures and unions\n-   in C).  Normally, these may be defined to simply return the maximum\n-   alignment and simple rounded-up size, but on some machines (like\n-   the i960), the total size of a structure is based on a non-trivial\n-   rounding method.  */\n-\n-#define ROUND_TYPE_ALIGN(TYPE, COMPUTED, SPECIFIED) \\\n-  i960_round_align (MAX ((COMPUTED), (SPECIFIED)), TYPE)\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   Registers 0-15 are the global registers (g0-g15).\n-   Registers 16-31 are the local registers (r0-r15).\n-   Register 32-35 are the fp registers (fp0-fp3).\n-   Register 36 is the condition code register.\n-   Register 37 is unused.  */\n-\n-#define FIRST_PSEUDO_REGISTER 38\n-\n-/* 1 for registers that have pervasive standard uses and are not available\n-   for the register allocator.  On 80960, this includes the frame pointer\n-   (g15), the previous FP (r0), the stack pointer (r1), the return\n-   instruction pointer (r2), and the argument pointer (g14).  */\n-#define FIXED_REGISTERS  \\\n- {0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n-  1, 1, 1, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 1, 1}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-\n-/* On the 80960, note that:\n-\tg0..g3 are used for return values,\n-\tg0..g7 may always be used for parameters,\n-\tg8..g11 may be used for parameters, but are preserved if they aren't,\n-\tg12 is the static chain if needed, otherwise is preserved\n-\tg13 is the struct return ptr if used, or temp, but may be trashed,\n-\tg14 is the leaf return ptr or the arg block ptr otherwise zero,\n-\t\tmust be reset to zero before returning if it was used,\n-\tg15 is the frame pointer,\n-\tr0 is the previous FP,\n-\tr1 is the stack pointer,\n-\tr2 is the return instruction pointer,\n-\tr3-r15 are always available,\n-\tr3 is clobbered by calls in functions that use the arg pointer\n-\tr4-r11 may be clobbered by the mcount call when profiling\n-\tr4-r15 if otherwise unused may be used for preserving global registers\n-\tfp0..fp3 are never available.  */\n-#define CALL_USED_REGISTERS  \\\n- {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  0, 0, 0, 0, 0, 1, 1, 1,\t\\\n-  1, 1, 1, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1, 1, 1, 1, 1, 1}\n-\n-/* If no fp unit, make all of the fp registers fixed so that they can't\n-   be used.  */\n-#define\tCONDITIONAL_REGISTER_USAGE\t\\\n-  if (! TARGET_NUMERICS) {\t\t\t\t\t\t\\\n-     fixed_regs[32] = fixed_regs[33] = fixed_regs[34] = fixed_regs[35] = 1;\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On 80960, ordinary registers hold 32 bits worth, but can be ganged\n-   together to hold double or extended precision floating point numbers,\n-   and the floating point registers hold any size floating point number */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) < 32\t\t\t\t\t\t\t\\\n-   ? (((MODE) == VOIDmode)\t\t\t\t\t\\\n-      ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)) \\\n-   : ((REGNO) < FIRST_PSEUDO_REGISTER) ? 1 : 0)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On 80960, the cpu registers can hold any mode but the float registers\n-   can only hold SFmode, DFmode, or TFmode.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok ((REGNO), (MODE))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* 80960 pc isn't overloaded on a register that the compiler knows about.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 17\n-\n-/* Actual top-of-stack address is same as\n-   the contents of the stack pointer register.  */\n-#define STACK_POINTER_OFFSET (-current_function_outgoing_args_size)\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 15\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-/* ??? It isn't clear to me why this is here.  Perhaps because of a bug (since\n-   fixed) in the definition of INITIAL_FRAME_POINTER_OFFSET which would have\n-   caused this to fail.  */\n-/* ??? Must check current_function_has_nonlocal_goto, otherwise frame pointer\n-  elimination messes up nonlocal goto sequences.  I think this works for other\n-  targets because they use indirect jumps for the return which disables fp\n-  elimination.  */\n-#define FRAME_POINTER_REQUIRED \\\n-  (! leaf_function_p () || current_function_has_nonlocal_goto)\n-\n-/* Definitions for register eliminations.\n-\n-   This is an array of structures.  Each structure initializes one pair\n-   of eliminable registers.  The \"from\" register number is given first,\n-   followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference..  */\n-\n-#define ELIMINABLE_REGS\t {{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n-\n-/* Given FROM and TO register numbers, say whether this elimination is allowed.\n-   Frame pointer elimination is automatically handled.  */\n-#define CAN_ELIMINATE(FROM, TO) 1\n-\n-/* Define the offset between two registers, one to be eliminated, and\n-   the other its replacement, at the start of a routine.\n-\n-   Since the stack grows upward on the i960, this must be a negative number.\n-   This includes the 64 byte hardware register save area and the size of\n-   the frame.  */\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-  do { (OFFSET) = - (64 + compute_frame_size (get_frame_size ())); } while (0)\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 14\n-\n-/* Register in which static-chain is passed to a function.\n-   On i960, we use g12.  We can't use any local register, because we need\n-   a register that can be set before a call or before a jump.  */\n-#define STATIC_CHAIN_REGNUM 12\n- \n-/* Functions which return large structures get the address\n-   to place the wanted value at in g13.  */\n-\n-#define STRUCT_VALUE_REGNUM 13 \n-\n-/* The order in which to allocate registers.  */\n-\n-#define\tREG_ALLOC_ORDER\t\\\n-{  4, 5, 6, 7, 0, 1, 2, 3, 13,\t /* g4, g5, g6, g7, g0, g1, g2, g3, g13  */ \\\n-  20, 21, 22, 23, 24, 25, 26, 27,/* r4, r5, r6, r7, r8, r9, r10, r11  */    \\\n-  28, 29, 30, 31, 19, 8, 9, 10,\t /* r12, r13, r14, r15, r3, g8, g9, g10  */ \\\n-  11, 12,\t\t\t /* g11, g12  */\t\t\t    \\\n-  32, 33, 34, 35,\t\t /* fp0, fp1, fp2, fp3  */\t\t    \\\n-  /* We can't actually allocate these.  */\t\t\t\t    \\\n-  16, 17, 18, 14, 15, 36, 37}\t /* r0, r1, r2, g14, g15, cc  */\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-/* The 80960 has four kinds of registers, global, local, floating point,\n-   and condition code.  The cc register is never allocated, so no class\n-   needs to be defined for it.  */\n-\n-enum reg_class { NO_REGS, GLOBAL_REGS, LOCAL_REGS, LOCAL_OR_GLOBAL_REGS,\n-  FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-/* 'r' includes floating point registers if TARGET_NUMERICS.  'd' never\n-   does.  */\n-#define\tGENERAL_REGS\t((TARGET_NUMERICS) ? ALL_REGS : LOCAL_OR_GLOBAL_REGS)\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n-{ \"NO_REGS\", \"GLOBAL_REGS\", \"LOCAL_REGS\", \"LOCAL_OR_GLOBAL_REGS\",\t\\\n-  \"FP_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS\t\\\n-{ {0, 0}, {0x0ffff, 0}, {0xffff0000, 0}, {-1,0}, {0, -1}, {-1,-1}}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO)\t\\\n-  ((REGNO) < 16 ? GLOBAL_REGS\t\\\n-   : (REGNO) < 32 ? LOCAL_REGS\t\\\n-   : (REGNO) < 36 ? FP_REGS\t\\\n-   : NO_REGS)\n-\n-/* The class value for index registers, and the one for base regs.\n-   There is currently no difference between base and index registers on the\n-   i960, but this distinction may one day be useful.  */\n-#define INDEX_REG_CLASS LOCAL_OR_GLOBAL_REGS\n-#define BASE_REG_CLASS LOCAL_OR_GLOBAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.\n-   'f' is a floating point register (fp0..fp3)\n-   'l' is a local register (r0-r15)\n-   'b' is a global register (g0-g15)\n-   'd' is any local or global register\n-   'r' or 'g' are pre-defined to the class GENERAL_REGS.  */\n-/* 'l' and 'b' are probably never used.  Note that 'd' and 'r' are *not*\n-   the same thing, since 'r' may include the fp registers.  */\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  (((C) == 'f') && (TARGET_NUMERICS) ? FP_REGS : ((C) == 'l' ? LOCAL_REGS : \\\n-    (C) == 'b' ? GLOBAL_REGS : ((C) == 'd' ? LOCAL_OR_GLOBAL_REGS : NO_REGS)))\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For 80960:\n-\t'I' is used for literal values 0..31\n-   \t'J' means literal 0\n-\t'K' means 0..-31.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t\t\t\\\n-  ((C) == 'I' ? (((unsigned) (VALUE)) <= 31)\t\t\t\t\\\n-   : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n-   : (C) == 'K' ? ((VALUE) >= -31 && (VALUE) <= 0)\t\t\t\\\n-   : (C) == 'M' ? ((VALUE) >= -32 && (VALUE) <= 0)\t\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.\n-   For the 80960, G is 0.0 and H is 1.0.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((TARGET_NUMERICS) &&\t\t\t\t\t\t\t\\\n-   (((C) == 'G' && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n-    || ((C) == 'H' && ((VALUE) == CONST1_RTX (GET_MODE (VALUE))))))\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-/* On 960, can't load constant into floating-point reg except\n-   0.0 or 1.0.\n-\n-   Any hard reg is ok as a src operand of a reload insn.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n-  (GET_CODE (X) == REG && REGNO (X) < FIRST_PSEUDO_REGISTER\t\\\n-   ? (CLASS)\t\t\t\t\t\t\t\\\n-   : ((CLASS) == FP_REGS && CONSTANT_P (X)\t\t\t\\\n-      && (X) != CONST0_RTX (DFmode) && (X) != CONST1_RTX (DFmode)\\\n-      && (X) != CONST0_RTX (SFmode) && (X) != CONST1_RTX (SFmode)\\\n-      ? NO_REGS\t\t\t\t\t\t\t\\\n-      : (CLASS) == ALL_REGS ? LOCAL_OR_GLOBAL_REGS : (CLASS)))\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  secondary_reload_class (CLASS, MODE, IN)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On 80960, this is the size of MODE in words,\n-   except in the FP regs, where a single reg is always enough.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((CLASS) == FP_REGS ? 1 : HARD_REGNO_NREGS (0, (MODE)))\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-/* #define STACK_GROWS_DOWNWARD */\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.\n-\n-   The i960 has a 64 byte register save area, plus possibly some extra\n-   bytes allocated for varargs functions.  */\n-#define STARTING_FRAME_OFFSET 64\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On 80960, don't define this because there are no push insns.  */\n-/* #define PUSH_ROUNDING(BYTES) BYTES */\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* When a parameter is passed in a register, no stack space is\n-   allocated for it.  However, when args are passed in the\n-   stack, space is allocated for every register parameter.  */\n-#define MAYBE_REG_PARM_STACK_SPACE 48\n-#define FINAL_REG_PARM_STACK_SPACE(CONST_SIZE, VAR_SIZE)\t\\\n-  i960_final_reg_parm_stack_space (CONST_SIZE, VAR_SIZE);\n-#define REG_PARM_STACK_SPACE(DECL) i960_reg_parm_stack_space (DECL)\n-#define OUTGOING_REG_PARM_STACK_SPACE\n-\n-/* Keep the stack pointer constant throughout the function.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Value is 1 if returning from a function call automatically\n-   pops the arguments described by the number-of-args field in the call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE) gen_rtx_REG ((MODE), 0)\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.\n-   On 80960, returns are in g0..g3 */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On 80960, parameters are passed in g0..g11 */\n-\n-#define FUNCTION_ARG_REGNO_P(N) ((N) < 12)\n-\n-/* Perform any needed actions needed for a function that is receiving a\n-   variable number of arguments. \n-\n-   CUM is as above.\n-\n-   MODE and TYPE are the mode and type of the current parameter.\n-\n-   PRETEND_SIZE is a variable that should be set to the amount of stack\n-   that must be pushed by the prolog to pretend that our caller pushed\n-   it.\n-\n-   Normally, this macro will push all remaining incoming registers on the\n-   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n-\n-#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n-  i960_setup_incoming_varargs(&CUM,MODE,TYPE,&PRETEND_SIZE,NO_RTL)\n-\n-/* Implement `va_start' for varargs and stdarg.  */\n-#define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n-  i960_va_start (valist, nextarg)\n-\n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  i960_va_arg (valist, type)\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On 80960, this is two integers, which count the number of register\n-   parameters and the number of stack parameters seen so far.  */\n-\n-struct cum_args { int ca_nregparms; int ca_nstackparms; };\n-\n-#define CUMULATIVE_ARGS struct cum_args\n-\n-/* Define the number of registers that can hold parameters.\n-   This macro is used only in macro definitions below and/or i960.c.  */\n-#define NPARM_REGS 12\n-\n-/* Define how to round to the next parameter boundary.\n-   This macro is used only in macro definitions below and/or i960.c.  */\n-#define ROUND_PARM(X, MULTIPLE_OF)\t\\\n-  ((((X) + (MULTIPLE_OF) - 1) / (MULTIPLE_OF)) * MULTIPLE_OF)\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On 80960, the offset always starts at 0; the first parm reg is g0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-  ((CUM).ca_nregparms = 0, (CUM).ca_nstackparms = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   CUM should be advanced to align with the data type accessed and\n-   also the size of that data type in # of regs.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  i960_function_arg_advance(&CUM, MODE, TYPE, NAMED)\n-\n-/* Indicate the alignment boundary for an argument of the specified mode and\n-   type.  */\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n-  (((TYPE) != 0)\t\t\t\t\t\t\t\\\n-   ? ((TYPE_ALIGN (TYPE) <= PARM_BOUNDARY)\t\t\t\t\\\n-      ? PARM_BOUNDARY\t\t\t\t\t\t\t\\\n-      : TYPE_ALIGN (TYPE))\t\t\t\t\t\t\\\n-   : ((GET_MODE_ALIGNMENT (MODE) <= PARM_BOUNDARY)\t\t\t\\\n-      ? PARM_BOUNDARY\t\t\t\t\t\t\t\\\n-      : GET_MODE_ALIGNMENT (MODE)))\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n-  i960_function_arg(&CUM, MODE, TYPE, NAMED)\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-#define FUNCTION_VALUE(TYPE, FUNC) \\\n-  gen_rtx_REG (TYPE_MODE (TYPE), 0)\n-\n-/* Force aggregates and objects larger than 16 bytes to be returned in memory,\n-   since we only have 4 registers available for return values.  */\n-\n-#define RETURN_IN_MEMORY(TYPE) \\\n-  (TYPE_MODE (TYPE) == BLKmode || int_size_in_bytes (TYPE) > 16)\n-\n-/* Don't default to pcc-struct-return, because we have already specified\n-   exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   This never happens on 80960.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\f\n-/* Output the label for a function definition.\n-  This handles leaf functions and a few other things for the i960.  */\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n-  i960_function_name_declare (FILE, NAME, DECL)\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n-  output_function_profiler ((FILE), (LABELNO));\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define\tEXIT_IGNORE_STACK 1\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-  ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-  ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_FP_P(REGNO) \\\n-  ((REGNO) < 36 || (unsigned) reg_renumber[REGNO] < 36)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.\n-\n-   These macros are specific to the 960, and may be used only\n-   in code for printing assembler insns and in conditions for\n-   define_optimization.  */\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REGNO (X) >= 32 && REGNO (X) < 36)\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-#define\tMAX_REGS_PER_ADDRESS 2\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* LEGITIMATE_CONSTANT_P is nonzero if the constant value X\n-   is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P.\n-\n-   Anything but a CONST_DOUBLE can be made to work, excepting 0.0 and 1.0.\n-\n-   ??? This probably should be defined to 1.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  ((GET_CODE (X) != CONST_DOUBLE) || fp_literal ((X), GET_MODE (X)))\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-  (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-#define REG_OK_FOR_INDEX_P_STRICT(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-#define REG_OK_FOR_BASE_P_STRICT(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-\tOn 80960, legitimate addresses are:\n-\t\tbase\t\t\t\tld\t(g0),r0\n-\t\tdisp\t(12 or 32 bit)\t\tld\tfoo,r0\n-\t\tbase + index\t\t\tld\t(g0)[g1*1],r0\n-\t\tbase + displ\t\t\tld\t0xf00(g0),r0\n-\t\tbase + index*scale + displ\tld\t0xf00(g0)[g1*4],r0\n-\t\tindex*scale + base\t\tld\t(g0)[g1*4],r0\n-\t\tindex*scale + displ\t\tld\t0xf00[g1*4],r0\n-\t\tindex*scale\t\t\tld\t[g1*4],r0\n-\t\tindex + base + displ\t\tld\t0xf00(g0)[g1*1],r0\n-\n-\tIn each case, scale can be 1, 2, 4, 8, or 16.  */\n-\n-/* Returns 1 if the scale factor of an index term is valid.  */\n-#define SCALE_TERM_P(X)\t\t\t\t\t\t\t\\\n-  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n-   && (INTVAL (X) == 1 || INTVAL (X) == 2 || INTVAL (X) == 4 \t\t\\\n-       || INTVAL(X) == 8 || INTVAL (X) == 16))\n-\n-\n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-  { if (legitimate_address_p (MODE, X, 1)) goto ADDR; }\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-  { if (legitimate_address_p (MODE, X, 0)) goto ADDR; }\n-#endif\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-/* On 80960, convert non-canonical addresses to canonical form.  */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n-{ rtx orig_x = (X);\t\t\t\t\\\n-  (X) = legitimize_address (X, OLDX, MODE);\t\\\n-  if ((X) != orig_x && memory_address_p (MODE, X)) \\\n-    goto WIN; }\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the 960 this is never true.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 16\n-\n-/* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n-   will either zero-extend or sign-extend.  The value of this macro should\n-   be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n-#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n-\n-/* Nonzero if access to memory by bytes is no faster than for words.\n-   Value changed to 1 after reports of poor bit-field code with g++.\n-   Indications are that code is usually as good, sometimes better.  */   \n-\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits.  */\n-#define SHIFT_COUNT_TRUNCATED 0\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* Specify the widest mode that BLKmode objects can be promoted to */\n-#define\tMAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (TImode)\n-\f\n-/* These global variables are used to pass information between\n-   cc setter and cc user at insn emit time.  */\n-\n-extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n-\n-/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  For floating-point, CCFPmode\n-   should be used.  CC_NOOVmode should be used when the first operand is a\n-   PLUS, MINUS, or NEG.  CCmode should be used when no special processing is\n-   needed.  */\n-#define SELECT_CC_MODE(OP,X,Y) select_cc_mode (OP, X)\n-\n-/* A function address in a call instruction is a byte address\n-   (for indexing purposes) so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE SImode\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   Desirable on machines where ordinary constants are expensive\n-   but a CALL with constant address is cheap.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Use memcpy, etc. instead of bcopy.  */\n-\n-#ifndef WIND_RIVER\n-#define\tTARGET_MEM_FUNCTIONS\t1\n-#endif\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"\"\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES {\t\t\t\t\t\t\\\n-\t\"g0\", \"g1\", \"g2\",  \"g3\",  \"g4\",  \"g5\",  \"g6\",  \"g7\",\t\t\\\n-\t\"g8\", \"g9\", \"g10\", \"g11\", \"g12\", \"g13\", \"g14\", \"fp\",\t\t\\\n-\t\"pfp\",\"sp\", \"rip\", \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n-\t\"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n-\t\"fp0\",\"fp1\",\"fp2\", \"fp3\", \"cc\", \"fake\" }\n-\n-/* How to renumber registers for dbx and gdb.\n-   In the 960 encoding, g0..g15 are registers 16..31.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\t\\\n-  (((REGNO) < 16) ? (REGNO) + 16\t\t\t\t\t\\\n-   : (((REGNO) > 31) ? (REGNO) : (REGNO) - 16))\n-\n-/* Don't emit dbx records longer than this.  This is an arbitrary value.  */\n-#define DBX_CONTIN_LENGTH 1500\n-\n-/* This is how to output a note to DBX telling it the line number\n-   to which the following sequence of instructions corresponds.  */\n-\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)\t\t\\\n-{ if (write_symbols == SDB_DEBUG) {\t\t\t\t\\\n-    fprintf ((FILE), \"\\t.ln\t%d\\n\",\t\t\t\t\\\n-\t     (sdb_begin_function_line\t\t\t\t\\\n-\t      ? (LINE) - sdb_begin_function_line : 1));\t\t\\\n-  } else if (write_symbols == DBX_DEBUG) {\t\t\t\\\n-\tfprintf((FILE),\"\\t.stabd\t68,0,%d\\n\",(LINE));\t\\\n-  } }\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.globl \"\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%lu\", PREFIX, (unsigned long)(NUM))\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tst\\t%s,(sp)\\n\\taddo\\t4,sp,sp\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tsubo\\t4,sp,sp\\n\\tld\\t(sp),%s\\n\", reg_names[REGNO])\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line that says to advance the\n-   location counter to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %d\\n\", (int)(SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-/* For common objects, output unpadded size... gld960 & lnk960 both\n-   have code to align each common object at link time.  Also, if size\n-   is 0, treat this as a declaration, not a definition - i.e.,\n-   do nothing at all.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n-{ if ((SIZE) != 0)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fputs (\".globl \", (FILE)),\t\t\t\\\n-      assemble_name ((FILE), (NAME)),\t\t\t\\\n-      fputs (\"\\n.comm \", (FILE)),\t\t\t\\\n-      assemble_name ((FILE), (NAME)),\t\t\t\\\n-      fprintf ((FILE), \",%d\\n\", (int)(SIZE));\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\n-\n-/* This says how to output an assembler line to define a local common symbol.\n-   Output unpadded size, with request to linker to align as requested.\n-   0 size should not be possible here.  */\n-\n-#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)  \\\n-( fputs (\".bss\\t\", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%d,%d\\n\", (int)(SIZE),\t\\\n-\t   (floor_log2 ((ALIGN) / BITS_PER_UNIT))))\n-\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   FILE the assembler definition of uninitialized global DECL named\n-   NAME whose size is SIZE bytes and alignment is ALIGN bytes.\n-   Try to use asm_output_aligned_bss to implement this macro.  */\n-\n-#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);\t\t\\\n-  } while (0)\n-\n-/* Output text for an #ident directive.  */\n-#define\tASM_OUTPUT_IDENT(FILE, STR)  fprintf(FILE, \"\\t# %s\\n\", STR);\n-\n-/* Align code to 8 byte boundary if TARGET_CODE_ALIGN is true.  */\n-\n-#define\tLABEL_ALIGN_AFTER_BARRIER(LABEL) (TARGET_CODE_ALIGN ? 3 : 0)\n-\n-\f\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-  i960_print_operand (FILE, X, CODE);\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\\\n-  i960_print_operand_addr (FILE, ADDR)\n-\n-/* Determine which codes are valid without a following integer.  These must\n-   not be alphabetic (the characters are chosen so that\n-   PRINT_OPERAND_PUNCT_VALID_P translates into a simple range change when\n-   using ASCII).  */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)   ((CODE) == '+')\n-\f\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.  */\n-\n-/* On the i960, the trampoline contains three instructions:\n-     ldconst _function, r4\n-     ldconst static addr, g12\n-     jump (r4)  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x8C203000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x00000000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x8CE03000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x00000000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x84212000));\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 4)), FNADDR); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT); \\\n-}\n-\n-/* Generate RTL to flush the register windows so as to make arbitrary frames\n-   available.  */\n-#define SETUP_FRAME_ADDRESSES()\t\t\\\n-  emit_insn (gen_flush_register_windows ())\n-\n-#define BUILTIN_SETJMP_FRAME_VALUE hard_frame_pointer_rtx\n-\n-#if 0\n-/* Promote char and short arguments to ints, when want compatibility with\n-   the iC960 compilers.  */\n-\n-/* ??? In order for this to work, all users would need to be changed\n-   to test the value of the macro at run time.  */\n-#define PROMOTE_PROTOTYPES\tTARGET_CLEAN_LINKAGE\n-/* ??? This does not exist.  */\n-#define PROMOTE_RETURN\t\tTARGET_CLEAN_LINKAGE\n-#endif\n-\n-/* Instruction type definitions.  Used to alternate instructions types for\n-   better performance on the C series chips.  */\n-\n-enum insn_types { I_TYPE_REG, I_TYPE_MEM, I_TYPE_CTRL };\n-\n-/* Holds the insn type of the last insn output to the assembly file.  */\n-\n-extern enum insn_types i960_last_insn_type;\n-\n-/* Parse opcodes, and set the insn last insn type based on them.  */\n-\n-#define ASM_OUTPUT_OPCODE(FILE, INSN)\ti960_scan_opcode (INSN)\n-\n-/* Table listing what rtl codes each predicate in i960.c will accept.  */\n-\n-#define PREDICATE_CODES \\\n-  {\"fpmove_src_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t  LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n-  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"logic_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"fp_arith_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n-  {\"signed_arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"literal\", {CONST_INT}},\t\t\t\t\t\t\\\n-  {\"fp_literal_one\", {CONST_DOUBLE}},\t\t\t\t\t\\\n-  {\"fp_literal_double\", {CONST_DOUBLE}},\t\t\t\t\\\n-  {\"fp_literal\", {CONST_DOUBLE}},\t\t\t\t\t\\\n-  {\"signed_literal\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n-  {\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\\\n-  {\"arith32_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n-\t\t       CONST_DOUBLE, CONST}},\t\t\t\t\\\n-  {\"power2_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"cmplpower2_operand\", {CONST_INT}},\n-\n-/* Defined in reload.c, and used in insn-recog.c.  */\n-\n-extern int rtx_equal_function_value_matters;"}, {"sha": "ad1678a7077a5237285404f13f8dc4a2bb7a3bde", "filename": "gcc/config/i960/i960.md", "status": "removed", "additions": 0, "deletions": 2818, "changes": 2818, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,2818 +0,0 @@\n-;;- Machine description for Intel 80960 chip for GNU C compiler\n-;;   Copyright (C) 1992, 1995, 1998, 2001 Free Software Foundation, Inc.\n-;;   Contributed by Steven McGeady, Intel Corp.\n-;;   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-;;   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\f\n-;; There are very few (4) 'f' registers, they can't be loaded/stored from/to\n-;; memory, and some instructions explicitly require them, so we get better\n-;; code by discouraging pseudo-registers from being allocated to them.\n-;; However, we do want to allow all patterns which can store to them to\n-;; include them in their constraints, so we always use '*f' in a destination\n-;; constraint except when 'f' is the only alternative.\n-\f\n-;; Insn attributes which describe the i960.\n-\n-;; Modscan is not used, since the compiler never emits any of these insns.\n-(define_attr \"type\"\n-  \"move,arith,alu2,mult,div,modscan,load,store,branch,call,address,compare,fpload,fpstore,fpmove,fpcvt,fpcc,fpadd,fpmul,fpdiv,multi,misc\"\n-  (const_string \"arith\"))\n-\n-;; Length (in # of insns).\n-(define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"load,fpload\")\n-\t      (if_then_else (match_operand 1 \"symbolic_memory_operand\" \"\")\n-\t\t\t    (const_int 2)\n-\t\t\t    (const_int 1))\n-\t (eq_attr \"type\" \"store,fpstore\")\n-\t      (if_then_else (match_operand 0 \"symbolic_memory_operand\" \"\")\n-\t\t\t    (const_int 2)\n-\t\t\t    (const_int 1))\n-\t (eq_attr \"type\" \"address\")\n-\t      (const_int 2)]\n-\t(const_int 1)))\n-\n-(define_asm_attributes\n-  [(set_attr \"length\" \"1\")\n-   (set_attr \"type\" \"multi\")])\n-\n-;; (define_function_unit {name} {num-units} {n-users} {test}\n-;;                       {ready-delay} {issue-delay} [{conflict-list}])\n-\n-;; The integer ALU\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"arith,compare,move,address\") 1 0)\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"alu2\") 2 0)\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"mult\") 5 0)\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"div\") 35 0)\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"modscan\") 3 0)\n-\n-;; Memory with load-delay of 1 (i.e., 2 cycle load).\n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,fpload\") 2 0)\n-\n-;; Floating point operations.\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpmove\") 5 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpcvt\") 35 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpcc\") 10 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpadd\") 10 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpmul\") 20 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpdiv\") 35 0)\n-\f\n-;; Compare instructions.\n-;; This controls RTL generation and register allocation.\n-\n-;; We generate RTL for comparisons and branches by having the cmpxx \n-;; patterns store away the operands.  Then, the scc and bcc patterns\n-;; emit RTL for both the compare and the branch.\n-;;\n-;; We start with the DEFINE_EXPANDs, then DEFINE_INSNs to match\n-;; the patterns.  Finally, we have the DEFINE_SPLITs for some of the scc\n-;; insns that actually require more than one machine instruction.\n-\n-;; Put cmpsi first because it is expected to be the most common.\n-\n-(define_expand \"cmpsi\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  i960_compare_op0 = operands[0];\n-  i960_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdf\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:DF 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:DF 1 \"nonmemory_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  i960_compare_op0 = operands[0];\n-  i960_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpsf\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:SF 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:SF 1 \"nonmemory_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  i960_compare_op0 = operands[0];\n-  i960_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-;; Now the DEFINE_INSNs for the compare and scc cases.  First the compares.\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t    (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"cmpi\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC_UNS 36)\n-\t(compare:CC_UNS (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t(match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"cmpo\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:DF 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:DF 1 \"nonmemory_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cmprl %0,%1\"\n-  [(set_attr \"type\" \"fpcc\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:SF 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:SF 1 \"nonmemory_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cmpr %0,%1\"\n-  [(set_attr \"type\" \"fpcc\")])\n-\n-;; Instruction definitions for branch-on-bit-set and clear insns.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (ne (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"arith_operand\" \"dI\"))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"bbs%+\t%1,%0,%l2\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (eq (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"arith_operand\" \"dI\"))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"bbc%+\t%1,%0,%l2\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"arith_operand\" \"dI\"))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"bbs%+\t%1,%0,%l2\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"arith_operand\" \"dI\"))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"bbc%+\t%1,%0,%l2\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-;; ??? These will never match.  The LOG_LINKs necessary to make these match\n-;; are not created by flow.  These remain as a reminder to make this work\n-;; some day.\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"+d\")))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n-  \"0\"\n-  \"cmpinci\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC_UNS 36)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"+d\")))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n-  \"0\"\n-  \"cmpinco\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"+d\")))\n-   (set (match_dup 1) (minus:SI (match_dup 1) (const_int 1)))]\n-  \"0\"\n-  \"cmpdeci\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC_UNS 36)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"+d\")))\n-   (set (match_dup 1) (minus:SI (match_dup 1) (const_int 1)))]\n-  \"0\"\n-  \"cmpdeco\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\f\n-;; Templates to store result of condition.\n-;; '1' is stored if condition is true.\n-;; '0' is stored if condition is false.\n-;; These should use predicate \"general_operand\", since\n-;; gcc seems to be creating mem references which use these\n-;; templates.\n-\n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (NE, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(gt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GT, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(gtu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GTU, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(lt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LT, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ltu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LTU, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ge:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GE, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(geu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GEU, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(le:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LE, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(leu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LEU, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(eq:SI (match_operand:SI 1 \"register_operand\" \"d\") (const_int 0)))]\n-  \"\"\n-  \"shro\t%1,1,%0\"\n-  [(set_attr \"type\" \"alu2\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(match_operator:SI 1 \"comparison_operator\" [(reg:CC 36) (const_int 0)]))]\n-  \"\"\n-  \"test%C1\t%0\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(match_operator:SI 1 \"comparison_operator\" [(reg:CC_UNS 36) (const_int 0)]))]\n-  \"\"\n-  \"test%C1\t%0\"\n-  [(set_attr \"type\" \"compare\")])\n-\f\n-;; These control RTL generation for conditional jump insns\n-;; and match them for register allocation.\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (NE, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (GT, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (match_dup 1)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (GTU, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (LT, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (match_dup 1)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (LTU, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (GE, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (match_dup 1)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (GEU, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (LE, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_dup 1)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (LEU, i960_compare_op0, i960_compare_op1); }\")\n-\f\n-;; Now the normal branch insns (forward and reverse).\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 36) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"b%C0%+ %l1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 36) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"b%I0%+ %l1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC_UNS 36) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"b%C0%+ %l1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC_UNS 36) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"b%I0%+ %l1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n-\t\t\t [(match_operand:SI 1 \"arith_operand\" \"d\")\n-\t\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")])\n-\t (label_ref (match_operand 3 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"cmp%S0%B0%R0%+\t%2,%1,%l3\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n-\t\t\t [(match_operand:SI 1 \"arith_operand\" \"d\")\n-\t\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")])\n-\t (pc)\n-\t (label_ref (match_operand 3 \"\" \"\"))))]\n-  \"\"\n-  \"cmp%S0%B0%X0%+\t%2,%1,%l3\"\n-  [(set_attr \"type\" \"branch\")])\n-\f\n-;; Now the trap instructions.  The i960 appears to only have conditional\n-;; traps...\n-\n-(define_insn (\"trap\")\n-  [(trap_if (const_int 1) (const_int 0))]\n-  \"\"\n-  \"cmpo g0,g0 ; faulte.t\")\n-\n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t     [(match_dup 2) (const_int 0)]) \n-\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = gen_compare_reg (GET_CODE (operands[0]), \n-\t\t\t\t i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_insn \"\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t     [(reg:CC 36) (const_int 0)]) \n-\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n-  \"\"\n-  \"fault%C0.f\")\n-\n-(define_insn \"\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t     [(reg:CC_UNS 36) (const_int 0)]) \n-\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n-  \"\"\n-  \"fault%C0.f\")\n-\f\n-;; Normal move instructions.\n-;; This code is based on the sparc machine description.\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, SImode))\n-    DONE;\n-}\")\n-\n-;; The store case can not be separate, because reload may convert a register\n-;; to register move insn to a store (or load) insn without rerecognizing\n-;; the insn.\n-\n-;; The i960 does not have any store constant to memory instruction.  However,\n-;; the calling convention is defined so that the arg pointer when it is not\n-;; overwise being used is zero.  Thus, we can handle store zero to memory\n-;; by storing an unused arg pointer.  The arg pointer will be unused if\n-;; current_function_args_size is zero and this is not a stdarg\n-;; function.  This value of the former variable is not valid until after\n-;; all rtl generation is complete, including function inlining (because a\n-;; function that doesn't need an arg pointer may be inlined into a function\n-;; that does need an arg pointer), so we must also check that\n-;; rtx_equal_function_value_matters is zero.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:SI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], SImode)\n-       || register_operand (operands[1], SImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ld\t%1,%0\\\";\n-    case 3:\n-      if (operands[1] == const0_rtx)\n-\treturn \\\"st\tg14,%0\\\";\n-      return \\\"st\t%1,%0\\\";      \n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,address,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:SI 1 \"general_operand\" \"dI,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], SImode)\n-       || register_operand (operands[1], SImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ld\t%1,%0\\\";\n-    case 3:\n-      return \\\"st\t%1,%0\\\";      \n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,address,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, HImode))\n-    DONE;\n-}\")\n-\n-;; Special pattern for zero stores to memory for functions which don't use\n-;; the arg pointer.\n-\n-;; The store case can not be separate.  See above.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldos\t%1,%0\\\";\n-    case 3:\n-      if (operands[1] == const0_rtx)\n-\treturn \\\"stos\tg14,%0\\\";\n-      return \\\"stos\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,misc,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-;; The store case can not be separate.  See above.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"dI,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldos\t%1,%0\\\";\n-    case 3:\n-      return \\\"stos\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,misc,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, QImode))\n-    DONE;\n-}\")\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldob\t%1,%0\\\";\n-    case 3:\n-      if (operands[1] == const0_rtx)\n-\treturn \\\"stob\tg14,%0\\\";\n-      return \\\"stob\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,misc,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"dI,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldob\t%1,%0\\\";\n-    case 3:\n-      return \\\"stob\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,misc,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, DImode))\n-    DONE;\n-}\")\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,d,m,o\")\n-\t(match_operand:DI 1 \"general_operand\" \"d,I,i,m,d,J\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], DImode)\n-       || register_operand (operands[1], DImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 3:\n-    case 4:\n-      return i960_output_move_double (operands[0], operands[1]);\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 5:\n-       return i960_output_move_double_zero (operands[0]);\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,load,store,store\")])\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,d,m\")\n-\t(match_operand:DI 1 \"general_operand\" \"d,I,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], DImode)\n-       || register_operand (operands[1], DImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 3:\n-    case 4:\n-      return i960_output_move_double (operands[0], operands[1]);\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,load,store\")])\n-\n-(define_insn \"*store_unaligned_di_reg\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,m\")\n-\t(match_operand:DI 1 \"register_operand\" \"d,d\"))\n-   (clobber (match_scratch:SI 2 \"=X,&d\"))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return i960_output_move_double (operands[0], operands[1]);\n-    \n-  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n-  operands[4] = adjust_address (operands[3], word_mode, UNITS_PER_WORD);\n-  return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\\";\n-}\"\n-  [(set_attr \"type\" \"move,store\")])\n-\n-(define_expand \"movti\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"\")\n-\t(match_operand:TI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, TImode))\n-    DONE;\n-}\")\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,d,m,o\")\n-\t(match_operand:TI 1 \"general_operand\" \"d,I,i,m,d,J\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], TImode)\n-       || register_operand (operands[1], TImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 3:\n-    case 4:\n-      return i960_output_move_quad (operands[0], operands[1]);\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 5:\n-      return i960_output_move_quad_zero (operands[0]);\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,load,store,store\")])\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,d,m\")\n-\t(match_operand:TI 1 \"general_operand\" \"d,I,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], TImode)\n-       || register_operand (operands[1], TImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 3:\n-    case 4:\n-      return i960_output_move_quad (operands[0], operands[1]);\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,load,store\")])\n-\n-(define_insn \"*store_unaligned_ti_reg\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"=d,m\")\n-\t(match_operand:TI 1 \"register_operand\" \"d,d\"))\n-   (clobber (match_scratch:SI 2 \"=X,&d\"))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return i960_output_move_quad (operands[0], operands[1]);\n-\n-  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n-  operands[4] = adjust_address (operands[3], word_mode, UNITS_PER_WORD);\n-  operands[5] = adjust_address (operands[4], word_mode, UNITS_PER_WORD);\n-  operands[6] = adjust_address (operands[5], word_mode, UNITS_PER_WORD);\n-  return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\;st\t%E1,%5\\;st\t%F1,%6\\\";\n-}\"\n-  [(set_attr \"type\" \"move,store\")])\n-\n-(define_expand \"store_multiple\"\n-  [(set (match_operand:SI 0 \"\" \"\")\t;;- dest\n-\t(match_operand:SI 1 \"\" \"\"))\t;;- src\n-   (use (match_operand:SI 2 \"\" \"\"))]\t;;- nregs\n-  \"\"\n-  \"\n-{\n-  int regno;\n-  int count;\n-  int offset = 0;\n-\n-  if (GET_CODE (operands[0]) != MEM\n-      || GET_CODE (operands[1]) != REG\n-      || GET_CODE (operands[2]) != CONST_INT)\n-    FAIL;\n-\n-  count = INTVAL (operands[2]);\n-  if (count > 12)\n-    FAIL;\n-\n-  regno = REGNO (operands[1]);\n-  while (count >= 4 && ((regno & 3) == 0))\n-    {\n-      emit_move_insn (adjust_address (operands[0], TImode, offset),\n-\t\t      gen_rtx_REG (TImode, regno));\n-      count -= 4;\n-      regno += 4;\n-      offset += 16;\n-    }\n-  while (count >= 2 && ((regno & 1) == 0))\n-    {\n-      emit_move_insn (adjust_address (operands[0], DImode, offset),\n-\t\t      gen_rtx_REG (DImode, regno));\n-      count -= 2;\n-      regno += 2;\n-      offset += 8;\n-    }\n-  while (count > 0)\n-    {\n-      emit_move_insn (adjust_address (operands[0], SImode, offset),\n-\t\t      gen_rtx_REG (SImode, regno));\n-      count -= 1;\n-      regno += 1;\n-      offset += 4;\n-    }\n-  DONE;\n-}\")\n-\f\n-;; Floating point move insns\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"fpmove_src_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, DFmode))\n-    DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r,*f,d,d,m,o\")\n-\t(match_operand:DF 1 \"fpmove_src_operand\" \"r,GH,F,m,d,G\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || operands[1] == CONST0_RTX (DFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movrl\t%1,%0\\\";\n-      else\n-\treturn \\\"movl\t%1,%0\\\";\n-    case 1:\n-      return \\\"movrl\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ldl\t%1,%0\\\";\n-    case 4:\n-      return \\\"stl\t%1,%0\\\";\n-    case 5:\n-      operands[1] = adjust_address (operands[0], VOIDmode, 4);\n-      return \\\"st\tg14,%0\\;st\tg14,%1\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore,fpstore\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r,*f,d,d,m\")\n-\t(match_operand:DF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movrl\t%1,%0\\\";\n-      else\n-\treturn \\\"movl\t%1,%0\\\";\n-    case 1:\n-      return \\\"movrl\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ldl\t%1,%0\\\";\n-    case 4:\n-      return \\\"stl\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"fpmove_src_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, SFmode))\n-    DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=r,*f,d,d,m\")\n-\t(match_operand:SF 1 \"fpmove_src_operand\" \"r,GH,F,m,dG\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode)\n-       || operands[1] == CONST0_RTX (SFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movr\t%1,%0\\\";\n-      else\n-\treturn \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return \\\"movr\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ld\t%1,%0\\\";\n-    case 4:\n-      if (operands[1] == CONST0_RTX (SFmode))\n-\treturn \\\"st\tg14,%0\\\";\n-      return \\\"st\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=r,*f,d,d,m\")\n-\t(match_operand:SF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movr\t%1,%0\\\";\n-      else\n-\treturn \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return \\\"movr\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ld\t%1,%0\\\";\n-    case 4:\n-      return \\\"st\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n-\f\n-;; Mixed-mode moves with sign and zero-extension.\n-\n-;; Note that the one starting from HImode comes before those for QImode\n-;; so that a constant operand will match HImode, not QImode.\n-\n-(define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(sign_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n- \"\"\n- \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_16 = GEN_INT (16);\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));\n-      emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldis\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_24 = GEN_INT (24);\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n-      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldib\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_expand \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(sign_extend:HI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_24 = GEN_INT (24);\n-      int op0_subreg_byte = 0;\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      if (GET_CODE (operand0) == SUBREG)\n-\t{\n-\t  op0_subreg_byte = SUBREG_BYTE (operand0);\n-\t  op0_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op0_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand0 = SUBREG_REG (operand0);\n-\t}\n-      if (GET_MODE (operand0) != SImode)\n-\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n-      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldib\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n- \"\"\n- \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_16 = GEN_INT (16);\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));\n-      emit_insn (gen_lshrsi3 (operand0, temp, shift_16));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldos\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-;; Using shifts here generates much better code than doing an `and 255'.\n-;; This is mainly because the `and' requires loading the constant separately,\n-;; the constant is likely to get optimized, and then the compiler can't\n-;; optimize the `and' because it doesn't know that one operand is a constant.\n-\n-(define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_24 = GEN_INT (24);\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-          op1_subreg_byte = SUBREG_BYTE (operand1);\n-          op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-          op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-          operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n-      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldob\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_expand \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(zero_extend:HI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_24 = GEN_INT (24);\n-      int op0_subreg_byte = 0;\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      if (GET_CODE (operand0) == SUBREG)\n-\t{\n-\t  op0_subreg_byte = SUBREG_BYTE (operand0);\n-\t  operand0 = SUBREG_REG (operand0);\n-\t}\n-      if (GET_MODE (operand0) != SImode)\n-\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n-      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldob\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\f\n-;; Conversions between float and double.\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=*f,d\")\n-\t(float_extend:DF (match_operand:SF 1 \"fp_arith_operand\" \"dGH,fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"@\n-  movr\t%1,%0\n-  movrl\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(float_truncate:SF\n-\t (match_operand:DF 1 \"fp_arith_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"movr\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-;; Conversion between fixed point and floating point.\n-\n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(float:DF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtir\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtir\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-;; Convert a float to an actual integer.\n-;; Truncation is performed as part of the conversion.\n-;; The i960 requires conversion from DFmode to DImode to make\n-;; unsigned conversions work properly.\n-\n-(define_insn \"fixuns_truncdfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(unsigned_fix:DI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"fGH\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzril\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"fixuns_truncsfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(unsigned_fix:DI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"fGH\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzril\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"fGH\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzri\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_expand \"fixuns_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  rtx temp = gen_reg_rtx (DImode);\n-  emit_insn (gen_rtx_SET (VOIDmode, temp,\n-\t\t\t  gen_rtx_UNSIGNED_FIX (DImode,\n-\t\t\t\t\t\tgen_rtx_FIX (DFmode,\n-\t\t\t\t\t\t\t     operands[1]))));\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_SUBREG (SImode, temp, 0)));\n-  DONE;\n-}\")\n-\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"dfGH\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzri\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_expand \"fixuns_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(unsigned_fix:SI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  rtx temp = gen_reg_rtx (DImode);\n-  emit_insn (gen_rtx_SET (VOIDmode, temp,\n-\t\t\t  gen_rtx_UNSIGNED_FIX (DImode,\n-\t\t\t\t\t\tgen_rtx_FIX (SFmode,\n-\t\t\t\t\t\t\t     operands[1]))));\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_SUBREG (SImode, temp, 0)));\n-  DONE;\n-}\")\n-\f\n-;; Arithmetic instructions.\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(minus:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"subo\t%2,%1,%0\")\n-\n-;; Try to generate an lda instruction when it would be faster than an\n-;; add instruction.\n-;; Some assemblers apparently won't accept two addresses added together.\n-\n-;; ??? The condition should be improved to reject the case of two\n-;; symbolic constants.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-\t(plus:SI (match_operand:SI 1 \"arith32_operand\" \"%dn,i,dn\")\n-\t\t (match_operand:SI 2 \"arith32_operand\" \"dn,dn,i\")))]\n-  \"(TARGET_C_SERIES) && (CONSTANT_P (operands[1]) || CONSTANT_P (operands[2]))\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      rtx tmp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = tmp;\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && GET_CODE (operands[1]) == REG\n-      && i960_last_insn_type != I_TYPE_REG)\n-    {\n-      if (INTVAL (operands[2]) < 0 && INTVAL (operands[2]) > -32)\n-\treturn \\\"subo\t%n2,%1,%0\\\";\n-      else if (INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 32)\n-\treturn \\\"addo\t%1,%2,%0\\\";\n-    }\n-  /* Non-canonical results (op1 == const, op2 != const) have been seen\n-     in reload output when both operands were symbols before reload, so\n-     we deal with it here.  This may be a fault of the constraints above.  */\n-  if (CONSTANT_P (operands[1]))\n-    {\n-      if (CONSTANT_P (operands[2]))\n-\treturn \\\"lda\t%1+%2,%0\\\";\n-      else\n-\treturn \\\"lda\t%1(%2),%0\\\";\n-    }\n-  return \\\"lda\t%2(%1),%0\\\";\n-}\")\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(plus:SI (match_operand:SI 1 \"signed_arith_operand\" \"%dI\")\n-\t\t (match_operand:SI 2 \"signed_arith_operand\" \"dIK\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"subo\t%n2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"addo\t%2,%1,%0\\\";\n-  return \\\"addo\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mult:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"mulo\t%2,%1,%0\\\";\n-  return \\\"mulo\t%1,%2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"mult\")])\n-\n-(define_insn \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"emul\t%2,%1,%0\\\";\n-  return \\\"emul\t%1,%2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"mult\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%d\"))\n-\t\t (match_operand:SI 2 \"literal\" \"I\")))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"emul\t%2,%1,%0\\\";\n-  return \\\"emul\t%1,%2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"mult\")])\n-\n-;; This goes after the move/add/sub/mul instructions  \n-;; because those instructions are better when they apply.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"lda\t%a1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-;; This will never be selected because of an \"optimization\" that GCC does.\n-;; It always converts divides by a power of 2 into a sequence of instructions\n-;; that does a right shift, and then corrects the result if it was negative.\n-\n-;; (define_insn \"\"\n-;;   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-;;         (div:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-;;                 (match_operand:SI 2 \"power2_operand\" \"nI\")))]\n-;;   \"\"\n-;;   \"*{\n-;; \toperands[2] = GEN_INT (bitpos (INTVAL (operands[2])));\n-;; \treturn \\\"shrdi\t%2,%1,%0\\\";\n-;;   }\"\n-\n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (div:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-                (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"divi\t%2,%1,%0\"\n-  [(set_attr \"type\" \"div\")])\n-\n-(define_insn \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (udiv:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"divo\t%2,%1,%0\"\n-  [(set_attr \"type\" \"div\")])\n-\n-;; We must use `remi' not `modi' here, to ensure that `%' has the effects\n-;; specified by the ANSI C standard.\n-\n-(define_insn \"modsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (mod:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-                (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"remi\t%2,%1,%0\"\n-  [(set_attr \"type\" \"div\")])\n-\n-(define_insn \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (umod:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"remo\t%2,%1,%0\"\n-  [(set_attr \"type\" \"div\")])\n-\n-;; And instructions (with complement also).\n-\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%d\")\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"andnot\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"and\t%2,%1,%0\\\";\n-  return \\\"and\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t(match_operand:SI 2 \"cmplpower2_operand\" \"n\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[2] = GEN_INT (bitpos (~INTVAL (operands[2])));\n-  return \\\"clrbit\t%2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"nor\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"notand\t%2,%1,%0\\\";\n-  return \\\"andnot\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"%d\"))\n-\t\t(not:SI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"nand\t%2,%1,%0\\\";\n-  return \\\"nand\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%d\")\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"ornot\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"or\t%2,%1,%0\\\";\n-  return \\\"or\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"power2_operand\" \"n\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[2] = GEN_INT (bitpos (INTVAL (operands[2])));\n-  return \\\"setbit\t%2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"nand\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"notor\t%2,%1,%0\\\";\n-  return \\\"ornot\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"%d\"))\n-\t\t(not:SI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"nor\t%2,%1,%0\\\";\n-  return \\\"nor\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%d\")\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"xnor\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"xor\t%2,%1,%0\\\";\n-  return \\\"xor\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t(match_operand:SI 2 \"power2_operand\" \"n\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[2] = GEN_INT (bitpos (INTVAL (operands[2])));\n-  return \\\"notbit\t%2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(not:SI (xor:SI (match_operand:SI 1 \"register_operand\" \"%d\")\n-\t\t\t(match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"xnor\t%2,%1,%0\\\";\n-  return \\\"xnor\t%2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"setbit\t%1,%2,%0\")\n-\n-;; (not (ashift 1 reg)) canonicalizes to (rotate -2 reg)\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (rotate:SI (const_int -2)\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"clrbit\t%1,%2,%0\")\n-\n-;; The above pattern canonicalizes to this when both the input and output\n-;; are the same pseudo-register.\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t(const_int 0))]\n-  \"\"\n-  \"clrbit\t%1,%0,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(xor:SI (ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"notbit\t%1,%2,%0\")\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"subo\t%1,0,%0\"\n-  [(set_attr \"length\" \"1\")])\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(not:SI (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"not\t%1,%0\"\n-  [(set_attr \"length\" \"1\")])\n-\f\n-;; Floating point arithmetic instructions.\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(plus:DF (match_operand:DF 1 \"fp_arith_operand\" \"%rGH\")\n-\t\t (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"addrl\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(plus:SF (match_operand:SF 1 \"fp_arith_operand\" \"%rGH\")\n-\t\t (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"addr\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(minus:DF (match_operand:DF 1 \"fp_arith_operand\" \"rGH\")\n-\t\t  (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"subrl\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(minus:SF (match_operand:SF 1 \"fp_arith_operand\" \"rGH\")\n-\t\t  (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"subr\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(mult:DF (match_operand:DF 1 \"fp_arith_operand\" \"%rGH\")\n-\t\t (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"mulrl\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(mult:SF (match_operand:SF 1 \"fp_arith_operand\" \"%rGH\")\n-\t\t (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"mulr\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n-\n-\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(div:DF (match_operand:DF 1 \"fp_arith_operand\" \"rGH\")\n-\t\t(match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"divrl\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpdiv\")])\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(div:SF (match_operand:SF 1 \"fp_arith_operand\" \"rGH\")\n-\t\t(match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"divr\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpdiv\")])\n-\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d,d*f\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"d,r\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    {\n-      if (REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \\\"notbit\t31,%D1,%D0\\\";\n-      return \\\"mov\t%1,%0\\;notbit\t31,%D1,%D0\\\";\n-    }\n-  return \\\"subrl\t%1,0f0.0,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d,d*f\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"d,r\")))]\n-  \"\"\n-  \"@\n-  notbit\t31,%1,%0\n-  subr\t%1,0f0.0,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-;;; The abs patterns also work even if the target machine doesn't have\n-;;; floating point, because in that case dstreg and srcreg will always be\n-;;; less than 32.\n-\n-(define_insn \"absdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"df\")))]\n-  \"\"\n-  \"*\n-{\n-  int dstreg = REGNO (operands[0]);\n-  int srcreg = REGNO (operands[1]);\n-\n-  if (dstreg < 32)\n-    {\n-      if (srcreg < 32)\n-\t{\n-\t  if (dstreg != srcreg)\n-\t    output_asm_insn (\\\"mov\t%1,%0\\\", operands);\n-\t  return \\\"clrbit\t31,%D1,%D0\\\";\n-\t}\n-      /* Src is an fp reg.  */\n-      return \\\"movrl\t%1,%0\\;clrbit\t31,%D1,%D0\\\";\n-    }\n-  if (srcreg >= 32)\n-    return \\\"cpysre\t%1,0f0.0,%0\\\";\n-  return \\\"movrl\t%1,%0\\;cpysre\t%0,0f0.0,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"df\")))]\n-  \"\"\n-  \"*\n-{\n-  int dstreg = REGNO (operands[0]);\n-  int srcreg = REGNO (operands[1]);\n-\n-  if (dstreg < 32 && srcreg < 32)\n-    return \\\"clrbit\t31,%1,%0\\\";\n-\n-  if (dstreg >= 32 && srcreg >= 32)\n-    return \\\"cpysre\t%1,0f0.0,%0\\\";\n-\n-  if (dstreg < 32)\n-    return \\\"movr\t%1,%0\\;clrbit\t31,%0,%0\\\";\n-\n-  return \\\"movr\t%1,%0\\;cpysre\t%0,0f0.0,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n-\f\n-;; Tetra (16 byte) float support.\n-\n-(define_expand \"cmptf\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:TF 0 \"register_operand\" \"\")\n-\t\t    (match_operand:TF 1 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  i960_compare_op0 = operands[0];\n-  i960_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:TF 0 \"register_operand\" \"f\")\n-\t\t    (match_operand:TF 1 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cmpr %0,%1\"\n-  [(set_attr \"type\" \"fpcc\")])\n-\n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"\")\n-\t(match_operand:TF 1 \"fpmove_src_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, TFmode))\n-    DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"=r,f,d,d,m\")\n-\t(match_operand:TF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n-  \"register_operand (operands[0], TFmode)\n-   || register_operand (operands[1], TFmode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movre\t%1,%0\\\";\n-      else\n-\treturn \\\"movq\t%1,%0\\\";\n-    case 1:\n-      return \\\"movre\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ldt\t%1,%0\\\";\n-    case 4:\n-      return \\\"stt\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n-\n-(define_insn \"extendsftf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f,d\")\n-\t(float_extend:TF\n-\t (match_operand:SF 1 \"register_operand\" \"d,f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"@\n-  movr\t%1,%0\n-  movre\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"extenddftf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f,d\")\n-\t(float_extend:TF\n-\t (match_operand:DF 1 \"register_operand\" \"d,f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"@\n-  movrl\t%1,%0\n-  movre\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"trunctfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(float_truncate:DF\n-\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"movrl\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"trunctfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(float_truncate:SF\n-\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"movr\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"floatsitf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(float:TF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtir\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"fix_trunctfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzri\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"fixuns_trunctfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(unsigned_fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzri\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"addtf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(plus:TF (match_operand:TF 1 \"nonmemory_operand\" \"%fGH\")\n-\t\t (match_operand:TF 2 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"addr\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"subtf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(minus:TF (match_operand:TF 1 \"nonmemory_operand\" \"fGH\")\n-\t\t  (match_operand:TF 2 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"subr\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"multf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(mult:TF (match_operand:TF 1 \"nonmemory_operand\" \"%fGH\")\n-\t\t (match_operand:TF 2 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"mulr\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n-\n-(define_insn \"divtf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(div:TF (match_operand:TF 1 \"nonmemory_operand\" \"fGH\")\n-\t\t(match_operand:TF 2 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"divr\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpdiv\")])\n-\n-(define_insn \"negtf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(neg:TF (match_operand:TF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"subr\t%1,0f0.0,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"abstf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(abs:TF (match_operand:TF 1 \"register_operand\" \"f\")))]\n-  \"(TARGET_NUMERICS)\"\n-  \"cpysre\t%1,0f0.0,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\f\n-;; Arithmetic shift instructions.\n-\n-;; The shli instruction generates an overflow fault if the sign changes.\n-;; In the case of overflow, it does not give the natural result, it instead\n-;; gives the last shift value before the overflow.  We can not use this\n-;; instruction because gcc thinks that arithmetic left shift and logical\n-;; left shift are identical, and sometimes canonicalizes the logical left\n-;; shift to an arithmetic left shift.  Therefore we must always use the\n-;; logical left shift instruction.\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ashift:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"shlo\t%2,%1,%0\"\n-  [(set_attr \"type\" \"alu2\")])\n-\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"shri\t%2,%1,%0\"\n-  [(set_attr \"type\" \"alu2\")])\n-\n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"shro\t%2,%1,%0\"\n-  [(set_attr \"type\" \"alu2\")])\n-\f\n-;; Unconditional and other jump instructions.\n-\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"b\t%l0\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"bx\t%a0\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"d\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"*\n-{\n-  if (flag_pic)\n-    return \\\"bx\t%l1(%0)\\\";\n-  else\n-    return \\\"bx\t(%0)\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-;;- jump to subroutine\n-\n-(define_expand \"call\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t (match_operand:SI 1 \"immediate_operand\" \"i\"))]\n-  \"\"\n-  \"\n-{\n-  emit_call_insn (gen_call_internal (operands[0], operands[1],\n-\t\t\t\t     virtual_outgoing_args_rtx));\n-  DONE;\n-}\")\n-\n-;; We need a call saved register allocated for the match_scratch, so we use\n-;; 'l' because all local registers are call saved.\n-\n-;; ??? I would prefer to use a match_scratch here, but match_scratch allocated\n-;; registers can't be used for spills.  In a function with lots of calls,\n-;; local-alloc may allocate all local registers to a match_scratch, leaving\n-;; no local registers available for spills.\n-\n-(define_insn \"call_internal\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t (match_operand:SI 1 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 2 \"address_operand\" \"p\"))\n-   (clobber (reg:SI 19))]\n-  \"\"\n-  \"* return i960_output_call_insn (operands[0], operands[1], operands[2],\n-\t\t\t\t   insn);\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_expand \"call_value\"\n-  [(set (match_operand 0 \"register_operand\" \"=d\")\n-\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"\"\n-  \"\n-{\n-  emit_call_insn (gen_call_value_internal (operands[0], operands[1],\n-\t\t\t\t\t   operands[2],\n-\t\t\t\t           virtual_outgoing_args_rtx));\n-  DONE;\n-}\")\n-\n-;; We need a call saved register allocated for the match_scratch, so we use\n-;; 'l' because all local registers are call saved.\n-\n-(define_insn \"call_value_internal\"\n-  [(set (match_operand 0 \"register_operand\" \"=d\")\n-\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:SI 2 \"immediate_operand\" \"i\")))\n-   (use (match_operand:SI 3 \"address_operand\" \"p\"))\n-   (clobber (reg:SI 19))]\n-  \"\"\n-  \"* return i960_output_call_insn (operands[1], operands[2], operands[3],\n-\t\t\t\t   insn);\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_insn \"return\"\n-  [(return)]\n-  \"\"\n-  \"* return i960_output_ret_insn (insn);\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-;; A return instruction.  Used only by nonlocal_goto to change the\n-;; stack pointer, frame pointer, previous frame pointer and the return\n-;; instruction pointer.\n-(define_insn \"ret\"\n-  [(set (pc) (unspec_volatile [(reg:SI 16)] 3))]\n-  \"\"\n-  \"ret\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_expand \"nonlocal_goto\"\n-  [(match_operand:SI 0 \"\" \"\")\n-   (match_operand:SI 1 \"general_operand\" \"\")\n-   (match_operand:SI 2 \"general_operand\" \"\")\n-   (match_operand:SI 3 \"general_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx chain = operands[0];\n-  rtx handler = operands[1];\n-  rtx stack = operands[2];\n-\n-  /* We must restore the stack pointer, frame pointer, previous frame\n-     pointer and the return instruction pointer.  Since the ret\n-     instruction does all this for us with one instruction, we arrange\n-     everything so that ret will do everything we need done.  */\n-\n-  /* First, we must flush the register windows, so that we can modify\n-     the saved local registers on the stack directly and because we\n-     are going to change the previous frame pointer.  */\n-\n-  emit_insn (gen_flush_register_windows ());\n-\n-  /* Load the static chain value for the containing fn into fp.  This is needed\n-     because STACK refers to fp.  */\n-  emit_move_insn (hard_frame_pointer_rtx, chain);\n-\n-  /* Now move the adjusted value into the pfp register for the following return\n-     instruction.  */\n-  emit_move_insn (gen_rtx (REG, SImode, 16),\n-\t\t  plus_constant (hard_frame_pointer_rtx, -64));\n-\n-  /* Next, we put the address that we want to transfer to, into the\n-     saved $rip value in the frame.  Once we ret below, that value\n-     will be loaded into the pc (IP).  */\n-\n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   plus_constant (hard_frame_pointer_rtx, -56)),\n-\t\t  handler);\n-\n-  /* Next, we put stack into the saved $sp value in the frame.  */\n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   plus_constant (hard_frame_pointer_rtx, -60)),\n-\t\t  stack);\n-\n-  /* And finally, we can now just ret to get all the values saved\n-     above into all the right registers, and also, all the local\n-     register that were in use in the function, are restored from\n-     their saved values (from the call instruction) on the stack\n-     because we are very careful to ret from the exact save area in\n-     use during the original call.  */\n-\n-  emit_jump_insn (gen_ret ());\n-  emit_barrier ();\n-  DONE;\n-}\")\n-\n-;; Special insn to flush register windows.\n-(define_insn \"flush_register_windows\"\n-  [(unspec_volatile [(const_int 0)] 1)]\n-  \"\"\n-  \"flushreg\"\n-  [(set_attr \"type\" \"misc\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"\")\n-\f\n-;; Various peephole optimizations for multiple-word moves, loads, and stores.\n-;; Multiple register moves.\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n-\t(match_operand:SI 5 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 6 \"register_operand\" \"=r\")\n-\t(match_operand:SI 7 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n-   && (REGNO (operands[0]) + 3 == REGNO (operands[6]))\n-   && (REGNO (operands[1]) + 3 == REGNO (operands[7]))\"\n-  \"movq\t%1,%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n-\t(match_operand:DI 3 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\"\n-  \"movq\t%1,%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n-\t(match_operand:SI 5 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 3 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) + 3 == REGNO (operands[5]))\"\n-  \"movq\t%1,%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:DI 4 \"register_operand\" \"=r\")\n-\t(match_operand:DI 5 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\"\n-  \"movq\t%1,%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\"\n-  \"movt\t%1,%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n-\t(match_operand:SI 5 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\"\n-  \"movt\t%1,%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 1) == 0)\n-   && ((REGNO (operands[1]) & 1) == 0)\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\"\n-  \"movl\t%1,%0\")\n-\f\n-; Multiple register loads.\n-\n-;; Matched 6/15/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 3 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 5 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 7 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 8 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) != REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[5]))\n-   && (REGNO (operands[1]) != REGNO (operands[5]))\n-   && (REGNO (operands[0]) + 3 == REGNO (operands[7]))\n-   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4]))\n-   && (INTVAL (operands[2]) + 8 == INTVAL (operands[6]))\n-   && (INTVAL (operands[2]) + 12 == INTVAL (operands[8])))\"\n-  \"ldq\t%2(%1),%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:DF 3 \"register_operand\" \"=d\")\n-\t(mem:DF (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) != REGNO (operands[3]))\n-   && (INTVAL (operands[2]) + 8 == INTVAL (operands[4])))\"\n-  \"ldq\t%2(%1),%0\")\n-\n-;; Matched 1/24/92\n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(mem:DI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:DI 3 \"register_operand\" \"=d\")\n-\t(mem:DI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) != REGNO (operands[3]))\n-   && (INTVAL (operands[2]) + 8 == INTVAL (operands[4])))\"\n-  \"ldq\t%2(%1),%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 4 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 6 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 7 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], 0) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) != REGNO (operands[2]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) != REGNO (operands[4]))\n-   && (REGNO (operands[0]) + 3 == REGNO (operands[6]))\n-   && (INTVAL (operands[3]) == 4)\n-   && (INTVAL (operands[5]) == 8)\n-   && (INTVAL (operands[7]) == 12))\"\n-  \"ldq\t(%1),%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 5 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) != REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[5]))\n-   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4]))\n-   && (INTVAL (operands[2]) + 8 == INTVAL (operands[6])))\"\n-  \"ldt\t%2(%1),%0\")\n-\n-;; Matched 6/15/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 4 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], 0) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) != REGNO (operands[2]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (INTVAL (operands[3]) == 4)\n-   && (INTVAL (operands[5]) == 8))\"\n-  \"ldt\t(%1),%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_di (operands[1], operands[2]) && ((REGNO (operands[0]) & 1) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n-   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4])))\"\n-  \"ldl\t%2(%1),%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_di (operands[1], 0) && ((REGNO (operands[0]) & 1) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (INTVAL (operands[3]) == 4))\"\n-  \"ldl\t(%1),%0\")\n-\f\n-; Multiple register stores.\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 2 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 4 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 6 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 7 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 8 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n-   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n-   && (REGNO (operands[2]) + 2 == REGNO (operands[6]))\n-   && (REGNO (operands[2]) + 3 == REGNO (operands[8]))\n-   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3]))\n-   && (INTVAL (operands[1]) + 8 == INTVAL (operands[5]))\n-   && (INTVAL (operands[1]) + 12 == INTVAL (operands[7])))\"\n-  \"stq\t%2,%1(%0)\")\n-\n-;; Matched 6/16/91\n-(define_peephole\n-  [(set (mem:DF (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:DF 2 \"register_operand\" \"d\"))\n-   (set (mem:DF (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:DF 4 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n-   && (REGNO (operands[2]) + 2 == REGNO (operands[4]))\n-   && (INTVAL (operands[1]) + 8 == INTVAL (operands[3])))\"\n-  \"stq\t%2,%1(%0)\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (mem:DI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:DI 2 \"register_operand\" \"d\"))\n-   (set (mem:DI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:DI 4 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n-   && (REGNO (operands[2]) + 2 == REGNO (operands[4]))\n-   && (INTVAL (operands[1]) + 8 == INTVAL (operands[3])))\"\n-  \"stq\t%2,%1(%0)\")\n-\n-;; Matched 1/23/92\n-(define_peephole\n-  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n-\t(match_operand:SI 1 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 3 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 5 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 7 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], 0) && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n-   && (REGNO (operands[1]) + 3 == REGNO (operands[7]))\n-   && (INTVAL (operands[2]) == 4)\n-   && (INTVAL (operands[4]) == 8)\n-   && (INTVAL (operands[6]) == 12))\"\n-  \"stq\t%1,(%0)\")\n-\n-;; Matched 5/29/91\n-(define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 2 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 4 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 6 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n-   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n-   && (REGNO (operands[2]) + 2 == REGNO (operands[6]))\n-   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3]))\n-   && (INTVAL (operands[1]) + 8 == INTVAL (operands[5])))\"\n-  \"stt\t%2,%1(%0)\")\n-\n-;; Matched 5/29/91\n-(define_peephole\n-  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n-\t(match_operand:SI 1 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 3 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 5 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], 0) && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n-   && (INTVAL (operands[2]) == 4)\n-   && (INTVAL (operands[4]) == 8))\"\n-  \"stt\t%1,(%0)\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 2 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 4 \"register_operand\" \"d\"))]\n-  \"(i960_si_di (operands[0], operands[1]) && ((REGNO (operands[2]) & 1) == 0)\n-   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n-   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3])))\"\n-  \"stl\t%2,%1(%0)\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n-\t(match_operand:SI 1 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 3 \"register_operand\" \"d\"))]\n-  \"(i960_si_di (operands[0], 0) && ((REGNO (operands[1]) & 1) == 0)\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (INTVAL (operands[2]) == 4))\"\n-  \"stl\t%1,(%0)\")"}, {"sha": "092b7920abf360579d1e10e4e6d86aaf9355294c", "filename": "gcc/config/i960/rtems.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Frtems.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,29 +0,0 @@\n-/* Definitions for rtems targeting an Intel i960.\n-   Copyright (C) 1996, 1997, 2000, 2002 Free Software Foundation, Inc.\n-   Contributed by Joel Sherrill (joel@OARcorp.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Target OS builtins.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__rtems__\");\t\t\\\n-\tbuiltin_assert (\"system=rtems\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)"}, {"sha": "9cbaa9f9065a435f7440abc1451e332bb0342838", "filename": "gcc/config/i960/t-960bare", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Ft-960bare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Fconfig%2Fi960%2Ft-960bare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Ft-960bare?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,30 +0,0 @@\n-LIB2FUNCS_EXTRA = xp-bit.c\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' > dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-xp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define EXTENDED_FLOAT_STUBS' > xp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> xp-bit.c\n-\n-i960-c.o: $(srcdir)/config/i960/i960-c.c $(CONFIG_H) $(SYSTEM_H) \\\n-  coretypes.h $(TM_H) $(CPPLIB_H) $(TREE_H) c-pragma.h toplev.h $(GGC_H) $(TM_P_H)\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/i960/i960-c.c\n-\n-MULTILIB_OPTIONS=mnumerics/msoft-float mlong-double-64\n-MULTILIB_DIRNAMES=float soft-float ld64\n-MULTILIB_MATCHES=mnumerics=msb mnumerics=msc mnumerics=mkb mnumerics=mkc mnumerics=mmc mnumerics=mcb mnumerics=mcc mnumerics=mjf msoft-float=msa msoft-float=mka msoft-float=mca msoft-float=mcf\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib"}, {"sha": "c93c5fe7ea067fc2f23c906e636a259e1ea6fe61", "filename": "gcc/f/ChangeLog", "status": "removed", "additions": 0, "deletions": 7315, "changes": 7315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "3d6675e5d3743f761aef12df1f425be9bce86337", "filename": "gcc/f/ChangeLog.0", "status": "removed", "additions": 0, "deletions": 4806, "changes": 4806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2FChangeLog.0", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2FChangeLog.0", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog.0?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "47585b0e2421b8c32193ce3f2a260792120a3072", "filename": "gcc/f/Make-lang.in", "status": "removed", "additions": 0, "deletions": 516, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FMake-lang.in?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,516 +0,0 @@\n-# Top level -*- makefile -*- fragment for GNU Fortran.\n-#   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n-\n-#This file is part of GNU Fortran.\n-\n-#GNU Fortran is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 2, or (at your option)\n-#any later version.\n-\n-#GNU Fortran is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GNU Fortran; see the file COPYING.  If not, write to\n-#the Free Software Foundation, 59 Temple Place - Suite 330,\n-#Boston, MA 02111-1307, USA.\n-\n-# This file provides the language dependent support in the main Makefile.\n-# Each language makefile fragment must provide the following targets:\n-#\n-# foo.all.build, foo.all.cross, foo.start.encap, foo.rest.encap,\n-# foo.install-normal, foo.install-common, foo.install-man,\n-# foo.uninstall,\n-# foo.mostlyclean, foo.clean, foo.distclean,\n-# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4\n-#\n-# where `foo' is the name of the language.\n-#\n-# It should also provide rules for:\n-#\n-# - making any compiler driver (eg: g++)\n-# - the compiler proper (eg: cc1plus)\n-# - define the names for selecting the language in LANGUAGES.\n-#\n-# $(srcdir) must be set to the gcc/ source directory (not gcc/f/).\n-#\f\n-# Actual name to use when installing a native compiler.\n-G77_INSTALL_NAME := $(shell echo g77|sed '$(program_transform_name)')\n-\n-# Some versions of `touch' (such as the version on Solaris 2.8) \n-# do not correctly set the timestamp due to buggy versions of `utime'\n-# in the kernel.  So, we use `echo' instead. \n-STAMP = echo timestamp >\n-\n-#\f\n-# Define the names for selecting f77 in LANGUAGES.\n-# Note that it would be nice to move the dependency on g77\n-# into the F77 rule, but that needs a little bit of work\n-# to do the right thing within all.cross.\n-F77 f77: f771$(exeext)\n-\n-# Tell GNU make to ignore these if they exist.\n-.PHONY: F77 f77 f77.all.build f77.all.cross \\\n-  f77.start.encap f77.rest.encap f77.dvi \\\n-  f77.install-normal \\\n-  f77.install-common f77.install-man \\\n-  f77.uninstall f77.mostlyclean f77.clean f77.distclean \\\n-  f77.maintainer-clean \\\n-  f77.stage1 f77.stage2 f77.stage3 f77.stage4 \\\n-  f77.stageprofile f77.stagefeedback\n-\n-g77spec.o: $(srcdir)/f/g77spec.c $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H) \\\n-\t$(CONFIG_H) intl.h\n-\t(SHLIB_LINK='$(SHLIB_LINK)' \\\n-\tSHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \\\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(DRIVER_DEFINES) \\\n-\t\t$(INCLUDES) $(srcdir)/f/g77spec.c)\n-\n-# Create the compiler driver for g77.\n-g77$(exeext): gcc.o g77spec.o version.o prefix.o intl.o \\\n-  $(LIBDEPS) $(EXTRA_GCC_OBJS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o g77spec.o \\\n-\t   version.o prefix.o intl.o $(EXTRA_GCC_OBJS) $(LIBS)\n-\n-# Create a version of the g77 driver which calls the cross-compiler.\n-g77-cross$(exeext): g77$(exeext)\n-\trm -f g77-cross$(exeext); \\\n-\tcp g77$(exeext) g77-cross$(exeext)\n-\n-# The compiler itself.\n-\n-F77_OBJS = f/bad.o f/bit.o f/bld.o f/com.o f/data.o f/equiv.o f/expr.o \\\n- f/global.o f/implic.o f/info.o f/intrin.o f/lab.o f/lex.o f/malloc.o \\\n- f/name.o f/parse.o f/src.o f/st.o f/sta.o f/stb.o f/stc.o \\\n- f/std.o f/ste.o f/storag.o f/stp.o f/str.o f/sts.o f/stt.o f/stu.o \\\n- f/stv.o f/stw.o f/symbol.o f/target.o f/top.o f/type.o f/where.o\n-\n-# Use loose warnings for this front end.\n-f-warn = $(WERROR)\n-\n-f771$(exeext): $(F77_OBJS) $(BACKEND) $(LIBDEPS)\n-\trm -f f771$(exeext)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(F77_OBJS) $(BACKEND) $(LIBS)\n-\n-# Keyword tables.\n-f/stamp-str: f/str-1t.h f/str-1t.j f/str-2t.h f/str-2t.j \\\n- f/str-fo.h f/str-fo.j f/str-io.h f/str-io.j f/str-nq.h  f/str-nq.j \\\n- f/str-op.h f/str-op.j f/str-ot.h f/str-ot.j\n-\t$(STAMP) f/stamp-str\n-\n-f/str-1t.h f/str-1t.j: f/fini$(build_exeext) f/str-1t.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-1t.fin f/str-1t.j f/str-1t.h\n-\n-f/str-2t.h f/str-2t.j: f/fini$(build_exeext) f/str-2t.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-2t.fin f/str-2t.j f/str-2t.h\n-\n-f/str-fo.h f/str-fo.j: f/fini$(build_exeext) f/str-fo.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-fo.fin f/str-fo.j f/str-fo.h\n-\n-f/str-io.h f/str-io.j: f/fini$(build_exeext) f/str-io.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-io.fin f/str-io.j f/str-io.h\n-\n-f/str-nq.h f/str-nq.j: f/fini$(build_exeext) f/str-nq.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-nq.fin f/str-nq.j f/str-nq.h\n-\n-f/str-op.h f/str-op.j: f/fini$(build_exeext) f/str-op.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-op.fin f/str-op.j f/str-op.h\n-\n-f/str-ot.h f/str-ot.j: f/fini$(build_exeext) f/str-ot.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-ot.fin f/str-ot.j f/str-ot.h\n-\n-f/fini$(build_exeext): f/fini.o $(BUILD_LIBDEPS)\n-\t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o f/fini$(build_exeext) \\\n-\t\tf/fini.o $(BUILD_LIBS)\n-\n-f/fini.o:\n-\t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \\\n-\t      -c $(srcdir)/f/fini.c $(OUTPUT_OPTION)\n-\n-gt-f-lex.h gt-f-where.h gt-f-com.h gt-f-ste.h gtype-f.h : s-gtype; @true\n-\n-#\f\n-# Build hooks:\n-\n-f77.all.build: g77$(exeext)\n-f77.all.cross: g77-cross$(exeext)\n-f77.start.encap: g77$(exeext)\n-f77.rest.encap:\n-\n-f77.srcinfo: doc/g77.info\n-\t-cp -p $^ $(srcdir)/doc\n-f77.srcman: doc/g77.1\n-\t-cp -p $^ $(srcdir)/doc\n-f77.srcextra: f/BUGS f/NEWS \n-\t-cp -p $^ $(srcdir)/f\n-\n-f77.tags: force\n-\tcd $(srcdir)/f; etags -o TAGS.sub *.c *.h; \\\n-\tetags --include TAGS.sub --include ../TAGS.sub\n-\n-f77.info: doc/g77.info\n-dvi:: doc/g77.dvi\n-f77.man: doc/g77.1\n-\n-check-f77 : check-g77\n-lang_checks += check-g77\n-\n-# g77 documentation.\n-TEXI_G77_FILES = f/g77.texi f/bugs.texi f/ffe.texi f/invoke.texi \\\n-\t\t f/news.texi f/root.texi $(docdir)/include/fdl.texi \\\n-\t\t $(docdir)/include/gpl.texi $(docdir)/include/funding.texi \\\n-\t\t $(docdir)/include/gcc-common.texi $(srcdir)/f/intdoc.texi\n-\n-doc/g77.info: $(TEXI_G77_FILES)\n-\tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n-\t  rm -f $(@)*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -I$(docdir)/include -I$(srcdir)/f \\\n-            -o$@ $<; \\\n-\telse true; fi\n-\n-doc/g77.dvi: $(TEXI_G77_FILES)\n-\t$(TEXI2DVI) -I $(srcdir)/f -I $(abs_docdir)/include -I $(objdir)/f -o $@ $<\n-\n-.INTERMEDIATE: g77.pod\n-g77.pod: f/invoke.texi\n-\t-$(TEXI2POD) < $< > $@\n-\n-# This dance is all about producing accurate documentation for g77's\n-# intrinsics with minimum fuss.  f/ansify appends \"\\n\\\" to C strings\n-# so ANSI C compilers can compile f/intdoc.h -- gcc can compile f/intdoc.in\n-# directly, if f/intdoc.c #include'd that, but we don't want to force\n-# people to install gcc just to build the documentation.  We use the\n-# C format for f/intdoc.in in the first place to allow a fairly \"free\",\n-# but widely known format for documentation -- basically anyone who knows\n-# how to write texinfo source and enclose it in C constants can handle\n-# it, and f/ansify allows them to not even end lines with \"\\n\\\".  So,\n-# essentially, the C preprocessor and compiler are used to enter the\n-# document snippets into a data base via name lookup, rather than duplicating\n-# that kind of code here.  And we use f/intdoc.c instead of straight\n-# texinfo in the first place so that as much information as possible\n-# contained in f/intrin.def can be inserted directly and reliably into\n-# the documentation.  That's better than replicating it, because it\n-# reduces the likelihood of discrepancies between the docs and the compiler\n-# itself, which uses f/intrin.def; in fact, many bugs in f/intrin.def have\n-# been found only upon reading the documentation that was automatically\n-# produced from it.\n-\n-# If the documentation files depended on executables in the build\n-# tree, there'd be no way to ship a source tree with the documentation\n-# already generated such that `make' wouldn't attempt to rebuild it.\n-# So, we punt and arrange for the documentation files to depend on the\n-# dependencies of the executables, not on the executables themselves.\n-# But then, we have to build the executables explicitly in their build\n-# rules.\n-\n-INTDOC_DEPS = f/intdoc.c f/intrin.h f/intrin.def\n-\n-$(srcdir)/f/intdoc.texi: $(INTDOC_DEPS) f/intdoc.in\n-\t$(MAKE) f/intdoc$(build_exeext)\n-\tf/intdoc$(build_exeext) > $(srcdir)/f/intdoc.texi\n-\n-f/intdoc$(build_exeext): $(INTDOC_DEPS) f/intdoc.h0 bconfig.h \\\n-  $(SYSTEM_H) coretypes.h $(TM_H) $(BUILD_LIBDEPS)\n-\t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) $(INCLUDES) $< \\\n-\t  $(BUILD_LIBS) -o $@\n-\n-f/intdoc.h0: f/intdoc.in f/ansify$(build_exeext)\n-\tf/ansify$(build_exeext) $< < $< > $@\n-\n-f/ansify$(build_exeext): f/ansify.c bconfig.h $(SYSTEM_H) coretypes.h $(TM_H)\n-\t  $(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) $(INCLUDES) $< \\\n-\t  -o $@\n-\n-f/BUGS: f/bugs0.texi f/bugs.texi f/root.texi\n-\tif [ x$(BUILD_INFO) = xinfo ]; then \\\n-\t  rm -f $(@)*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -D BUGSONLY --no-header --no-split \\\n-           --no-validate -I$(docdir)/include -I$(srcdir)/f -o $@ bugs0.texi; \\\n-\telse true; fi\n-\n-f/NEWS: f/news0.texi f/news.texi f/root.texi\n-\tif [ x$(BUILD_INFO) = xinfo ]; then \\\n-\t  rm -f $(@)*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -D NEWSONLY --no-header --no-split \\\n-           --no-validate -I$(docdir)/include -I$(srcdir)/f -o $@ news0.texi; \\\n-\telse true; fi\n-\n-#\f\n-# Install hooks:\n-# f771 is installed elsewhere as part of $(COMPILERS).\n-\n-f77.install-normal:\n-\n-# Install the driver program as $(target)-g77\n-# and also as either g77 (if native) or $(tooldir)/bin/g77.\n-f77.install-common: installdirs\n-\t-if [ -f f771$(exeext) ] ; then \\\n-\t  rm -f $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \\\n-\t  $(INSTALL_PROGRAM) g77$(exeext) $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \\\n-\t  chmod a+x $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \\\n-\telse true; fi\n-\t@if [ -f f77-install-ok -o -f $(srcdir)/f77-install-ok ]; then \\\n-\t  echo ''; \\\n-\t  echo 'Warning: gcc no longer installs an f77 command.'; \\\n-\t  echo '         You must do so yourself.  For more information,'; \\\n-\t  echo '         read \"Distributing Binaries\" in the g77 docs.'; \\\n-\t  echo '         (To turn off this warning, delete the file'; \\\n-\t  echo '         f77-install-ok in the source or build directory.)'; \\\n-\t  echo ''; \\\n-\telse true; fi\n-\n-install-info:: $(DESTDIR)$(infodir)/g77.info\n-\n-f77.install-man: installdirs $(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(man1ext)\n-\n-$(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(man1ext): doc/g77.1\n-\t-rm -f $@\n-\t-$(INSTALL_DATA) $< $@\n-\t-chmod a-x $@\n-\n-f77.uninstall: installdirs\n-\tif $(SHELL) -c 'install-info --version | sed 1q | fgrep -s -v -i debian' >/dev/null 2>&1; then \\\n-\t  echo \" install-info --delete --info-dir=$(DESTDIR)$(infodir) $(DESTDIR)$(infodir)/g77.info\"; \\\n-\t  install-info --delete --info-dir=$(DESTDIR)$(infodir) $(DESTDIR)$(infodir)/g77.info || : ; \\\n-\telse : ; fi\n-\trm -rf $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \\\n-\trm -rf $(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(man1ext); \\\n-\trm -rf $(DESTDIR)$(infodir)/g77.info*\n-#\f\n-# Clean hooks:\n-# A lot of the ancillary files are deleted by the main makefile.\n-# We just have to delete files specific to us.\n-\n-f77.mostlyclean:\n-\t-rm -f f/*$(objext)\n-\t-rm -f f/*$(coverageexts)\n-\t-rm -f f/fini$(build_exeext) f/stamp-str f/str-*.h f/str-*.j\n-\t-rm -f f/BUGS f/NEWS\n-\t-rm -f g77.aux g77.cps g77.ky g77.toc g77.vr g77.fn g77.kys \\\n-\t       g77.pg g77.tp g77.vrs g77.cp g77.fns g77.log g77.pgs g77.tps \n-f77.clean:\n-\t-rm -f g77spec.o\n-f77.distclean:\n-\t-rm -f f/Makefile\n-f77.maintainer-clean:\n-\t-rm -f $(srcdir)/f/BUGS $(srcdir)/f/TAGS $(srcdir)/f/TAGS.SUB\n-\t-rm -f $(srcdir)/f/NEWS $(srcdir)/f/intdoc.texi\n-#\f\n-# Stage hooks:\n-# The main makefile has already created stage?/f.\n-\n-G77STAGESTUFF = f/*$(objext) f/fini$(build_exeext) f/stamp-str \\\n-  f/str-*.h f/str-*.j g77spec.o\n-\n-f77.stage1: stage1-start\n-\t-mv -f $(G77STAGESTUFF) stage1/f\n-\n-f77.stage2: stage2-start\n-\t-mv -f $(G77STAGESTUFF) stage2/f\n-\n-f77.stage3: stage3-start\n-\t-mv -f $(G77STAGESTUFF) stage3/f\n-\n-f77.stage4: stage4-start\n-\t-mv -f $(G77STAGESTUFF) stage4/f\n-\n-f77.stageprofile: stageprofile-start\n-\t-mv -f $(G77STAGESTUFF) stageprofile/f\n-\n-f77.stagefeedback: stageprofile-start\n-\t-mv -f $(G77STAGESTUFF) stagefeedback/f\n-#\f\n-# .o: .h dependencies.\n-\n-f/bad.o: f/bad.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/malloc.h flags.h f/com.h f/com-rt.def $(TREE_H) f/bld.h \\\n- f/bld-op.def f/bit.h f/info.h f/info-b.def f/info-k.def f/info-w.def \\\n- f/target.h f/lex.h f/type.h f/intrin.h f/intrin.def f/lab.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/storag.h f/global.h f/name.h toplev.h intl.h \\\n- diagnostic.h coretypes.h $(TM_H)\n-f/bit.o: f/bit.c f/proj.h $(CONFIG_H) $(SYSTEM_H) glimits.h f/bit.h \\\n- f/malloc.h coretypes.h $(TM_H)\n-f/bld.o: f/bld.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bld.h f/bld-op.def f/bit.h \\\n- f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def \\\n- f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h f/top.h f/lex.h \\\n- f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def f/equiv.h f/global.h \\\n- f/name.h f/intrin.h f/intrin.def real.h coretypes.h $(TM_H)\n-f/com.o: f/com.c f/proj.h $(CONFIG_H) $(SYSTEM_H) flags.h $(RTL_H) $(TREE_H) \\\n- output.h convert.h f/com.h f/com-rt.def f/bld.h f/bld-op.def f/bit.h \\\n- f/malloc.h f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/intrin.h \\\n- f/intrin.def f/lab.h f/symbol.h f/symbol.def f/equiv.h f/storag.h f/global.h \\\n- f/name.h f/expr.h f/implic.h f/src.h f/st.h $(GGC_H) toplev.h diagnostic.h \\\n- $(LANGHOOKS_DEF) langhooks.h intl.h real.h debug.h gt-f-com.h gtype-f.h \\\n- coretypes.h $(TM_H)\n-f/data.o: f/data.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/data.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n- f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def f/equiv.h \\\n- f/global.h f/name.h f/intrin.h f/intrin.def f/expr.h f/st.h coretypes.h $(TM_H)\n-f/equiv.o: f/equiv.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/equiv.h f/bld.h \\\n- f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def \\\n- f/global.h f/name.h f/intrin.h f/intrin.def f/data.h coretypes.h $(TM_H)\n-f/expr.o: f/expr.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/expr.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n- f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def f/equiv.h \\\n- f/global.h f/name.h f/intrin.h f/intrin.def f/implic.h f/src.h f/st.h \\\n- f/stamp-str real.h coretypes.h $(TM_H)\n-f/fini.o: f/fini.c f/proj.h bconfig.h $(SYSTEM_H) f/malloc.h coretypes.h $(TM_H)\n-f/global.o: f/global.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/global.h f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h $(TREE_H) f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/lex.h f/type.h f/name.h f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h coretypes.h $(TM_H)\n-f/implic.o: f/implic.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/implic.h f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h $(TREE_H) f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/lex.h f/type.h f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h f/global.h f/name.h f/src.h \\\n- coretypes.h $(TM_H)\n-f/info.o: f/info.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h $(TREE_H) f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/malloc.h f/lex.h f/type.h coretypes.h $(TM_H)\n-f/intrin.o: f/intrin.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/intrin.h \\\n- f/intrin.def f/bld.h f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def \\\n- $(TREE_H) f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/expr.h f/src.h \\\n- coretypes.h $(TM_H)\n-f/lab.o: f/lab.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/lab.h f/com.h f/com-rt.def \\\n- $(TREE_H) f/bld.h f/bld-op.def f/bit.h f/malloc.h f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n- f/top.h f/lex.h f/type.h f/intrin.h f/intrin.def f/symbol.h f/symbol.def \\\n- f/equiv.h f/storag.h f/global.h f/name.h coretypes.h $(TM_H)\n-f/lex.o: f/lex.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/top.h f/malloc.h f/where.h \\\n- glimits.h f/bad.h f/bad.def f/com.h f/com-rt.def $(TREE_H) f/bld.h \\\n- f/bld-op.def f/bit.h f/info.h f/info-b.def f/info-k.def f/info-w.def \\\n- f/target.h f/lex.h f/type.h f/intrin.h f/intrin.def f/lab.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/storag.h f/global.h f/name.h f/src.h flags.h \\\n- debug.h input.h toplev.h output.h $(GGC_H) gt-f-lex.h coretypes.h $(TM_H)\n-f/malloc.o: f/malloc.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/malloc.h \\\n- coretypes.h $(TM_H)\n-f/name.o: f/name.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/malloc.h f/name.h f/global.h f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h $(TREE_H) f/lex.h f/type.h f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h f/src.h coretypes.h $(TM_H)\n-f/parse.o: f/parse.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/top.h f/malloc.h \\\n- f/where.h glimits.h f/com.h f/com-rt.def $(TREE_H) f/bld.h f/bld-op.def \\\n- f/bit.h f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/lex.h f/type.h f/intrin.h f/intrin.def f/lab.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/storag.h f/global.h f/name.h version.h flags.h \\\n- coretypes.h $(TM_H)\n-f/src.o: f/src.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/src.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h coretypes.h $(TM_H)\n-f/st.o: f/st.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/st.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/lex.h f/symbol.h f/symbol.def \\\n- f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def $(TREE_H) f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/type.h f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h f/global.h f/name.h f/sta.h \\\n- f/stamp-str f/stb.h f/expr.h f/stp.h f/stt.h f/stc.h f/std.h \\\n- f/stv.h f/stw.h f/ste.h f/sts.h f/stu.h coretypes.h $(TM_H)\n-f/sta.o: f/sta.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/sta.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/lex.h f/stamp-str f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def $(TREE_H) \\\n- f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/type.h f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h f/global.h f/name.h f/implic.h \\\n- f/stb.h f/expr.h f/stp.h f/stt.h f/stc.h f/std.h f/stv.h f/stw.h coretypes.h \\\n- $(TM_H)\n-f/stb.o: f/stb.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stb.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/expr.h f/bld.h f/bld-op.def f/bit.h \\\n- f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def \\\n- f/info-w.def f/target.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def f/stp.h \\\n- f/stt.h f/stamp-str f/src.h f/sta.h f/stc.h coretypes.h $(TM_H)\n-f/stc.o: f/stc.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stc.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/bld.h f/bld-op.def f/bit.h f/com.h \\\n- f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def f/info-w.def \\\n- f/target.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def \\\n- f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def f/expr.h f/stp.h \\\n- f/stt.h f/stamp-str f/data.h f/implic.h f/src.h f/sta.h f/std.h f/stv.h \\\n- f/stw.h coretypes.h $(TM_H)\n-f/std.o: f/std.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/std.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n- f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def f/equiv.h \\\n- f/global.h f/name.h f/intrin.h f/intrin.def f/stp.h f/stt.h f/stamp-str \\\n- f/stv.h f/stw.h f/sta.h f/ste.h f/sts.h coretypes.h $(TM_H)\n-f/ste.o: f/ste.c f/proj.h $(CONFIG_H) $(SYSTEM_H) $(RTL_H) toplev.h f/ste.h \\\n- f/bld.h f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H)\t\\\n- f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def f/stp.h \\\n- f/stt.h f/stamp-str f/sts.h f/stv.h f/stw.h f/expr.h f/sta.h $(GGC_H) \\\n- gt-f-ste.h coretypes.h $(TM_H)\n-f/storag.o: f/storag.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/storag.h f/bld.h  \\\n- f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) \\\n- f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h \\\n- f/intrin.def f/data.h coretypes.h $(TM_H)\n-f/stp.o: f/stp.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stp.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h \\\n- f/intrin.def f/stt.h coretypes.h $(TM_H)\n-f/str.o: f/str.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/src.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/stamp-str f/lex.h coretypes.h $(TM_H)\n-f/sts.o: f/sts.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/sts.h f/malloc.h f/com.h \\\n- f/com-rt.def $(TREE_H) f/bld.h f/bld-op.def f/bit.h f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/lex.h f/type.h f/intrin.h f/intrin.def \\\n- f/lab.h f/symbol.h f/symbol.def f/equiv.h f/storag.h f/global.h \\\n- f/name.h coretypes.h $(TM_H)\n-f/stt.o: f/stt.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stt.h f/top.h f/malloc.h \\\n- f/where.h glimits.h f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def \\\n- $(TREE_H) f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h \\\n- f/bad.h f/bad.def f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def \\\n- f/stp.h f/expr.h f/sta.h f/stamp-str coretypes.h $(TM_H)\n-f/stu.o: f/stu.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bld.h f/bld-op.def f/bit.h \\\n- f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def \\\n- f/implic.h f/stu.h f/sta.h f/stamp-str coretypes.h $(TM_H)\n-f/stv.o: f/stv.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stv.h f/lab.h f/com.h \\\n- f/com-rt.def $(TREE_H) f/bld.h f/bld-op.def f/bit.h f/malloc.h \\\n- f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/intrin.h \\\n- f/intrin.def f/symbol.h f/symbol.def f/equiv.h f/storag.h f/global.h \\\n- f/name.h coretypes.h $(TM_H)\n-f/stw.o: f/stw.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stw.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h \\\n- f/intrin.def f/stv.h f/sta.h f/stamp-str coretypes.h $(TM_H)\n-f/symbol.o: f/symbol.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/malloc.h f/com.h \\\n- f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def \\\n- f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h f/top.h \\\n- f/lex.h f/type.h f/lab.h f/storag.h f/intrin.h f/intrin.def f/equiv.h \\\n- f/global.h f/name.h f/src.h f/st.h coretypes.h $(TM_H)\n-f/target.o: f/target.c f/proj.h $(CONFIG_H) $(SYSTEM_H) glimits.h f/target.h \\\n- $(TREE_H) f/bad.h f/bad.def f/where.h f/top.h f/malloc.h f/info.h real.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/type.h f/lex.h diagnostic.h \\\n- coretypes.h $(TM_H) toplev.h\n-f/top.o: f/top.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/top.h f/malloc.h f/where.h \\\n- glimits.h f/bad.h f/bad.def f/bit.h f/bld.h f/bld-op.def f/com.h \\\n- f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def \\\n- f/info-w.def f/target.h f/lex.h f/type.h f/lab.h f/storag.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h \\\n- f/intrin.def f/data.h f/expr.h f/implic.h f/src.h f/st.h flags.h \\\n- toplev.h coretypes.h $(TM_H) opts.h options.h\n-f/type.o: f/type.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/type.h f/malloc.h \\\n- coretypes.h $(TM_H)\n-f/where.o: f/where.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/where.h glimits.h \\\n- f/top.h f/malloc.h f/lex.h $(GGC_H) gt-f-where.h coretypes.h $(TM_H)"}, {"sha": "71eebf614c4ff1cc6bc7945dc9ec2e1a6bed374f", "filename": "gcc/f/RELEASE-PREP", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2FRELEASE-PREP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2FRELEASE-PREP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FRELEASE-PREP?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,5 +0,0 @@\n-1999-03-13  RELEASE-PREP\n-\n-Things to do to prepare a g77 release.\n-\n--  Update root.texi: clear DEVELOPMENT flag, set version info."}, {"sha": "b03206d79e35cdfd2f42b6438635d69295656221", "filename": "gcc/f/ansify.c", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fansify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fansify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fansify.c?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,190 +0,0 @@\n-/* ansify.c\n-   Copyright (C) 1997, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-#include \"bconfig.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-#define die_unless(c) \\\n-  do if (!(c)) \\\n-    { \\\n-      fprintf (stderr, \"%s:%lu: %s\\n\", argv[1], lineno, #c); \\\n-      die (); \\\n-    } \\\n-  while(0)\n-\n-static void ATTRIBUTE_NORETURN\n-die (void)\n-{\n-  exit (1);\n-}\n-\n-int\n-main(int argc, char **argv)\n-{\n-  int c;\n-  static unsigned long lineno = 1;\n-\n-  die_unless (argc == 2);\n-\n-  printf (\"\\\n-/* This file is automatically generated from `%s',\\n\\\n-   which you should modify instead.  */\\n\\\n-#line 1 \\\"%s\\\"\\n\\\n-\",\n-\t  argv[1], argv[1]);\n-\n-  while ((c = getchar ()) != EOF)\n-    {\n-      switch (c)\n-\t{\n-\tdefault:\n-\t  putchar (c);\n-\t  break;\n-\n-\tcase '\\n':\n-\t  ++lineno;\n-\t  putchar (c);\n-\t  break;\n-\n-\tcase '\"':\n-\t  putchar (c);\n-\t  for (;;)\n-\t    {\n-\t      c = getchar ();\n-\t      die_unless (c != EOF);\n-\t      switch (c)\n-\t\t{\n-\t\tcase '\"':\n-\t\t  putchar (c);\n-\t\t  goto next_char;\n-\n-\t\tcase '\\n':\n-\t\t  putchar ('\\\\');\n-\t\t  putchar ('n');\n-\t\t  putchar ('\\\\');\n-\t\t  putchar ('\\n');\n-\t\t  ++lineno;\n-\t\t  break;\n-\n-\t\tcase '\\\\':\n-\t\t  putchar (c);\n-\t\t  c = getchar ();\n-\t\t  die_unless (c != EOF);\n-\t\t  putchar (c);\n-\t\t  if (c == '\\n')\n-\t\t    ++lineno;\n-\t\t  break;\n-\t\t  \n-\t\tdefault:\n-\t\t  putchar (c);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tcase '\\'':\n-\t  putchar (c);\n-\t  for (;;)\n-\t    {\n-\t      c = getchar ();\n-\t      die_unless (c != EOF);\n-\t      switch (c)\n-\t\t{\n-\t\tcase '\\'':\n-\t\t  putchar (c);\n-\t\t  goto next_char;\n-\t\t  \n-\t\tcase '\\n':\n-\t\t  putchar ('\\\\');\n-\t\t  putchar ('n');\n-\t\t  putchar ('\\\\');\n-\t\t  putchar ('\\n');\n-\t\t  ++lineno;\n-\t\t  break;\n-\t\t  \n-\t\tcase '\\\\':\n-\t\t  putchar (c);\n-\t\t  c = getchar ();\n-\t\t  die_unless (c != EOF);\n-\t\t  putchar (c);\n-\t\t  if (c == '\\n')\n-\t\t    ++lineno;\n-\t\t  break;\n-\t\t  \n-\t\tdefault:\n-\t\t  putchar (c);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tcase '/':\n-\t  putchar (c);\n-\t  c = getchar ();\n-\t  putchar (c);\n-\t  if (c != '*')\n-\t    break;\n-\t  for (;;)\n-\t    {\n-\t      c = getchar ();\n-\t      die_unless (c != EOF);\n-\n-\t      switch (c)\n-\t\t{\n-\t\tcase '\\n':\n-\t\t  ++lineno;\n-\t\t  putchar (c);\n-\t\t  break;\n-\t\t  \n-\t\tcase '*':\n-\t\t  c = getchar ();\n-\t\t  die_unless (c != EOF);\n-\t\t  if (c == '/')\n-\t\t    {\n-\t\t      putchar ('*');\n-\t\t      putchar ('/');\n-\t\t      goto next_char;\n-\t\t    }\n-\t\t  if (c == '\\n')\n-\t\t    {\n-\t\t      ++lineno;\n-\t\t      putchar (c);\n-\t\t    }\n-\t\t  break;\n-\t\t  \n-\t\tdefault:\n-\t\t  /* Don't bother outputting content of comments.  */\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  break;\n-\t}\n-      \n-    next_char:\n-      ;\n-    }\n-\n-  die_unless (c == EOF);\n-\n-  return 0;\n-}"}, {"sha": "bed9734ecc78a24e2429d611ca2af72832d08ce8", "filename": "gcc/f/bad.c", "status": "removed", "additions": 0, "deletions": 537, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.c?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,537 +0,0 @@\n-/* bad.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-      None\n-\n-   Description:\n-      Handles the displaying of diagnostic messages regarding the user's source\n-      files.\n-\n-   Modifications:\n-*/\n-\n-/* If there's a %E or %4 in the messages, set this to at least 5,\n-   for example.  */\n-\n-#define FFEBAD_MAX_ 6\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"bad.h\"\n-#include \"flags.h\"\n-#include \"com.h\"\n-#include \"toplev.h\"\n-#include \"where.h\"\n-#include \"intl.h\"\n-#include \"diagnostic.h\"\n-\n-/* Externals defined here. */\n-\n-bool ffebad_is_inhibited_ = FALSE;\n-\n-/* Simple definitions and enumerations. */\n-\n-#define FFEBAD_LONG_MSGS_ 1\t/* 0 to use short (or same) messages. */\n-\n-/* Internal typedefs. */\n-\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-struct _ffebad_message_\n-  {\n-    const ffebadSeverity severity;\n-    const char *const message;\n-  };\n-\n-/* Static objects accessed by functions in this module.\t */\n-\n-static const struct _ffebad_message_ ffebad_messages_[]\n-=\n-{\n-#define FFEBAD_MSG(kwd,sev,msgid) { sev, msgid },\n-#if FFEBAD_LONG_MSGS_ == 0\n-#define LONG(m)\n-#define SHORT(m) m\n-#else\n-#define LONG(m) m\n-#define SHORT(m)\n-#endif\n-#include \"bad.def\"\n-#undef FFEBAD_MSG\n-#undef LONG\n-#undef SHORT\n-};\n-\n-static struct\n-  {\n-    ffewhereLine line;\n-    ffewhereColumn col;\n-    ffebadIndex tag;\n-  }\n-\n-ffebad_here_[FFEBAD_MAX_];\n-static const char *ffebad_string_[FFEBAD_MAX_];\n-static ffebadIndex ffebad_order_[FFEBAD_MAX_];\n-static ffebad ffebad_errnum_;\n-static ffebadSeverity ffebad_severity_;\n-static const char *ffebad_message_;\n-static unsigned char ffebad_index_;\n-static ffebadIndex ffebad_places_;\n-static bool ffebad_is_temp_inhibited_;\t/* Effective setting of\n-\t\t\t\t\t   _is_inhibited_ for this\n-\t\t\t\t\t   _start/_finish invocation. */\n-\n-/* Static functions (internal). */\n-\n-static int ffebad_bufputs_ (char buf[], int bufi, const char *s);\n-\n-/* Internal macros. */\n-\n-#define ffebad_bufflush_(buf, bufi) \\\n-  (((buf)[bufi] = '\\0'), fputs ((buf), stderr), 0)\n-#define ffebad_bufputc_(buf, bufi, c) \\\n-  (((bufi) == ARRAY_SIZE (buf)) \\\n-   ? (ffebad_bufflush_ ((buf), (bufi)), ((buf)[0] = (c)), 1) \\\n-   : (((buf)[bufi] = (c)), (bufi) + 1))\n-\f\n-\n-static int\n-ffebad_bufputs_ (char buf[], int bufi, const char *s)\n-{\n-  for (; *s != '\\0'; ++s)\n-    bufi = ffebad_bufputc_ (buf, bufi, *s);\n-  return bufi;\n-}\n-\n-/* ffebad_init_0 -- Initialize\n-\n-   ffebad_init_0();  */\n-\n-void\n-ffebad_init_0 (void)\n-{\n-  assert (FFEBAD == ARRAY_SIZE (ffebad_messages_));\n-}\n-\n-ffebadSeverity\n-ffebad_severity (ffebad errnum)\n-{\n-  return ffebad_messages_[errnum].severity;\n-}\n-\n-/* ffebad_start_ -- Start displaying an error message\n-\n-   ffebad_start(FFEBAD_SOME_ERROR_CODE);\n-\n-   Call ffebad_start to establish the message, ffebad_here and ffebad_string\n-   to send run-time data to it as necessary, then ffebad_finish when through\n-   to actually get it to print (to stderr).\n-\n-   Note: ffebad_start(errnum) turns into ffebad_start_(FALSE,errnum).  No\n-   outside caller should call ffebad_start_ directly (as indicated by the\n-   trailing underscore).\n-\n-   Call ffebad_start to start a normal message, one that might be inhibited\n-   by the current state of statement guessing.\tCall ffebad_start_lex\n-   instead to start a message that is global to all statement guesses and\n-   happens only once for all guesses (i.e. the lexer).\n-\n-   sev and message are overrides for the severity and messages when errnum\n-   is FFEBAD, meaning the caller didn't want to have to put a message in\n-   bad.def to produce a diagnostic.  */\n-\n-bool\n-ffebad_start_ (bool lex_override, ffebad errnum, ffebadSeverity sev,\n-\t       const char *msgid)\n-{\n-  unsigned char i;\n-\n-  if (ffebad_is_inhibited_ && !lex_override)\n-    {\n-      ffebad_is_temp_inhibited_ = TRUE;\n-      return FALSE;\n-    }\n-\n-  if (errnum != FFEBAD)\n-    {\n-      ffebad_severity_ = ffebad_messages_[errnum].severity;\n-      ffebad_message_ = gettext (ffebad_messages_[errnum].message);\n-    }\n-  else\n-    {\n-      ffebad_severity_ = sev;\n-      ffebad_message_ = gettext (msgid);\n-    }\n-\n-  switch (ffebad_severity_)\n-    {\t\t\t\t/* Tell toplev.c about this message. */\n-    case FFEBAD_severityINFORMATIONAL:\n-    case FFEBAD_severityTRIVIAL:\n-      if (inhibit_warnings)\n-\t{\t\t\t/* User wants no warnings. */\n-\t  ffebad_is_temp_inhibited_ = TRUE;\n-\t  return FALSE;\n-\t}\n-      /* Fall through.  */\n-    case FFEBAD_severityWARNING:\n-    case FFEBAD_severityPECULIAR:\n-    case FFEBAD_severityPEDANTIC:\n-      if ((ffebad_severity_ != FFEBAD_severityPEDANTIC)\n-\t  || !flag_pedantic_errors)\n-\t{\n-\t  if (!diagnostic_report_warnings_p ())\n-\t    {\t\t\t/* User wants no warnings. */\n-\t      ffebad_is_temp_inhibited_ = TRUE;\n-\t      return FALSE;\n-\t    }\n-\t  diagnostic_kind_count (global_dc, DK_WARNING)++;\n-\t  break;\n-\t}\n-      /* Fall through (PEDANTIC && flag_pedantic_errors).  */\n-    case FFEBAD_severityFATAL:\n-    case FFEBAD_severityWEIRD:\n-    case FFEBAD_severitySEVERE:\n-    case FFEBAD_severityDISASTER:\n-      diagnostic_kind_count (global_dc, DK_ERROR)++;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  ffebad_is_temp_inhibited_ = FALSE;\n-  ffebad_errnum_ = errnum;\n-  ffebad_index_ = 0;\n-  ffebad_places_ = 0;\n-  for (i = 0; i < FFEBAD_MAX_; ++i)\n-    {\n-      ffebad_string_[i] = NULL;\n-      ffebad_here_[i].line = ffewhere_line_unknown ();\n-      ffebad_here_[i].col = ffewhere_column_unknown ();\n-    }\n-\n-  return TRUE;\n-}\n-\n-/* ffebad_here -- Establish source location of some diagnostic concern\n-\n-   ffebad_here(ffebadIndex i,ffewhereLine line,ffewhereColumn col);\n-\n-   Call ffebad_start to establish the message, ffebad_here and ffebad_string\n-   to send run-time data to it as necessary, then ffebad_finish when through\n-   to actually get it to print (to stderr).  */\n-\n-void\n-ffebad_here (ffebadIndex index, ffewhereLine line, ffewhereColumn col)\n-{\n-  ffewhereLineNumber line_num;\n-  ffewhereLineNumber ln;\n-  ffewhereColumnNumber col_num;\n-  ffewhereColumnNumber cn;\n-  ffebadIndex i;\n-  ffebadIndex j;\n-\n-  if (ffebad_is_temp_inhibited_)\n-    return;\n-\n-  assert (index < FFEBAD_MAX_);\n-  ffebad_here_[index].line = ffewhere_line_use (line);\n-  ffebad_here_[index].col = ffewhere_column_use (col);\n-  if (ffewhere_line_is_unknown (line)\n-      || ffewhere_column_is_unknown (col))\n-    {\n-      ffebad_here_[index].tag = FFEBAD_MAX_;\n-      return;\n-    }\n-  ffebad_here_[index].tag = 0;\t/* For now, though it shouldn't matter. */\n-\n-  /* Sort the source line/col points into the order they occur in the source\n-     file.  Deal with duplicates appropriately. */\n-\n-  line_num = ffewhere_line_number (line);\n-  col_num = ffewhere_column_number (col);\n-\n-  /* Determine where in the ffebad_order_ array this new place should go. */\n-\n-  for (i = 0; i < ffebad_places_; ++i)\n-    {\n-      ln = ffewhere_line_number (ffebad_here_[ffebad_order_[i]].line);\n-      cn = ffewhere_column_number (ffebad_here_[ffebad_order_[i]].col);\n-      if (line_num < ln)\n-\tbreak;\n-      if (line_num == ln)\n-\t{\n-\t  if (col_num == cn)\n-\t    {\n-\t      ffebad_here_[index].tag = i;\n-\t      return;\t\t/* Shouldn't go in, has equivalent. */\n-\t    }\n-\t  else if (col_num < cn)\n-\t    break;\n-\t}\n-    }\n-\n-  /* Before putting new place in ffebad_order_[i], first increment all tags\n-     that are i or greater. */\n-\n-  if (i != ffebad_places_)\n-    {\n-      for (j = 0; j < FFEBAD_MAX_; ++j)\n-\t{\n-\t  if (ffebad_here_[j].tag >= i)\n-\t    ++ffebad_here_[j].tag;\n-\t}\n-    }\n-\n-  /* Then slide all ffebad_order_[] entries at and above i up one entry. */\n-\n-  for (j = ffebad_places_; j > i; --j)\n-    ffebad_order_[j] = ffebad_order_[j - 1];\n-\n-  /* Finally can put new info in ffebad_order_[i]. */\n-\n-  ffebad_order_[i] = index;\n-  ffebad_here_[index].tag = i;\n-  ++ffebad_places_;\n-}\n-\n-/* Establish string for next index (always in order) of message\n-\n-   ffebad_string(const char *string);\n-\n-   Call ffebad_start to establish the message, ffebad_here and ffebad_string\n-   to send run-time data to it as necessary, then ffebad_finish when through\n-   to actually get it to print (to stderr).  Note: don't trash the string\n-   until after calling ffebad_finish, since we just maintain a pointer to\n-   the argument passed in until then.  */\n-\n-void\n-ffebad_string (const char *string)\n-{\n-  if (ffebad_is_temp_inhibited_)\n-    return;\n-\n-  assert (ffebad_index_ != FFEBAD_MAX_);\n-  ffebad_string_[ffebad_index_++] = string;\n-}\n-\n-/* ffebad_finish -- Display error message with where & run-time info\n-\n-   ffebad_finish();\n-\n-   Call ffebad_start to establish the message, ffebad_here and ffebad_string\n-   to send run-time data to it as necessary, then ffebad_finish when through\n-   to actually get it to print (to stderr).  */\n-\n-void\n-ffebad_finish (void)\n-{\n-#define MAX_SPACES 132\n-  static const char *const spaces\n-  = \"...>\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\";\t\t\t/* MAX_SPACES - 1 spaces. */\n-  ffewhereLineNumber last_line_num;\n-  ffewhereLineNumber ln;\n-  ffewhereLineNumber rn;\n-  ffewhereColumnNumber last_col_num;\n-  ffewhereColumnNumber cn;\n-  ffewhereColumnNumber cnt;\n-  ffewhereLine l;\n-  ffebadIndex bi;\n-  unsigned short i;\n-  char pointer;\n-  unsigned char c;\n-  unsigned const char *s;\n-  const char *fn;\n-  static char buf[1024];\n-  int bufi;\n-  int index;\n-\n-  if (ffebad_is_temp_inhibited_)\n-    return;\n-\n-  switch (ffebad_severity_)\n-    {\n-    case FFEBAD_severityINFORMATIONAL:\n-      s = _(\"note:\");\n-      break;\n-\n-    case FFEBAD_severityWARNING:\n-      s = _(\"warning:\");\n-      break;\n-\n-    case FFEBAD_severitySEVERE:\n-      s = _(\"fatal:\");\n-      break;\n-\n-    default:\n-      s = \"\";\n-      break;\n-    }\n-\n-  /* Display the annoying source references. */\n-\n-  last_line_num = 0;\n-  last_col_num = 0;\n-\n-  for (bi = 0; bi < ffebad_places_; ++bi)\n-    {\n-      if (ffebad_places_ == 1)\n-\tpointer = '^';\n-      else\n-\tpointer = '1' + bi;\n-\n-      l = ffebad_here_[ffebad_order_[bi]].line;\n-      ln = ffewhere_line_number (l);\n-      rn = ffewhere_line_filelinenum (l);\n-      cn = ffewhere_column_number (ffebad_here_[ffebad_order_[bi]].col);\n-      fn = ffewhere_line_filename (l);\n-      if (ln != last_line_num)\n-\t{\n-\t  if (bi != 0)\n-\t    fputc ('\\n', stderr);\n-\t  diagnostic_report_current_function (global_dc);\n-\t  fprintf (stderr,\n-\t\t   /* the trailing space on the <file>:<line>: line\n-\t\t      fools emacs19 compilation mode into finding the\n-\t\t      report */\n-\t\t   \"%s:%\" ffewhereLineNumber_f \"u: %s\\n   %s\\n   %s%c\",\n-\t\t   fn, rn,\n-\t\t   s,\n-\t\t   ffewhere_line_content (l),\n-\t\t   &spaces[cn > MAX_SPACES ? 0 : MAX_SPACES - cn + 4],\n-\t\t   pointer);\n-\t  last_line_num = ln;\n-\t  last_col_num = cn;\n-\t  s = _(\"(continued):\");\n-\t}\n-      else\n-\t{\n-\t  cnt = cn - last_col_num;\n-\t  fprintf (stderr,\n-\t\t   \"%s%c\", &spaces[cnt > MAX_SPACES\n-\t\t\t\t   ? 0 : MAX_SPACES - cnt + 4],\n-\t\t   pointer);\n-\t  last_col_num = cn;\n-\t}\n-    }\n-  if (ffebad_places_ == 0)\n-    {\n-      /* Didn't output \"warning:\" string, capitalize it for message.  */\n-      if (s[0] != '\\0')\n-\t{\n-\t  char c;\n-\n-\t  c = TOUPPER (s[0]);\n-\t  fprintf (stderr, \"%c%s \", c, &s[1]);\n-\t}\n-      else if (s[0] != '\\0')\n-\tfprintf (stderr, \"%s \", s);\n-    }\n-  else\n-    fputc ('\\n', stderr);\n-\n-  /* Release the ffewhere info. */\n-\n-  for (bi = 0; bi < FFEBAD_MAX_; ++bi)\n-    {\n-      ffewhere_line_kill (ffebad_here_[bi].line);\n-      ffewhere_column_kill (ffebad_here_[bi].col);\n-    }\n-\n-  /* Now display the message. */\n-\n-  bufi = 0;\n-  for (i = 0; (c = ffebad_message_[i]) != '\\0'; ++i)\n-    {\n-      if (c == '%')\n-\t{\n-\t  c = ffebad_message_[++i];\n-\t  if (ISUPPER (c))\n-\t    {\n-\t      index = c - 'A';\n-\n-\t      if ((index < 0) || (index >= FFEBAD_MAX_))\n-\t\t{\n-\t\t  bufi = ffebad_bufputs_ (buf, bufi, _(\"[REPORT BUG!!] %\"));\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, c);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  s = ffebad_string_[index];\n-\t\t  if (s == NULL)\n-\t\t    bufi = ffebad_bufputs_ (buf, bufi, _(\"[REPORT BUG!!]\"));\n-\t\t  else\n-\t\t    bufi = ffebad_bufputs_ (buf, bufi, s);\n-\t\t}\n-\t    }\n-\t  else if (ISDIGIT (c))\n-\t    {\n-\t      index = c - '0';\n-\n-\t      if ((index < 0) || (index >= FFEBAD_MAX_))\n-\t\t{\n-\t\t  bufi = ffebad_bufputs_ (buf, bufi, _(\"[REPORT BUG!!] %\"));\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, c);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  pointer = ffebad_here_[index].tag + '1';\n-\t\t  if (pointer == FFEBAD_MAX_ + '1')\n-\t\t    pointer = '?';\n-\t\t  else if (ffebad_places_ == 1)\n-\t\t    pointer = '^';\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, '(');\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, pointer);\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, ')');\n-\t\t}\n-\t    }\n-\t  else if (c == '\\0')\n-\t    break;\n-\t  else if (c == '%')\n-\t    bufi = ffebad_bufputc_ (buf, bufi, '%');\n-\t  else\n-\t    {\n-\t      bufi = ffebad_bufputs_ (buf, bufi, _(\"[REPORT BUG!!]\"));\n-\t      bufi = ffebad_bufputc_ (buf, bufi, '%');\n-\t      bufi = ffebad_bufputc_ (buf, bufi, c);\n-\t    }\n-\t}\n-      else\n-\tbufi = ffebad_bufputc_ (buf, bufi, c);\n-    }\n-  bufi = ffebad_bufputc_ (buf, bufi, '\\n');\n-  bufi = ffebad_bufflush_ (buf, bufi);\n-}"}, {"sha": "92d7e23303030cbc24128e18dadb72a1d3f1de1e", "filename": "gcc/f/bad.def", "status": "removed", "additions": 0, "deletions": 1103, "changes": 1103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbad.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbad.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.def?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,1103 +0,0 @@\n-/* bad.def -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 1996, 1997, 2002 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bad.c\n-\n-   Modifications:\n-*/\n-\n-#define INFORM FFEBAD_severityINFORMATIONAL\n-#define TRIVIAL FFEBAD_severityTRIVIAL\n-#define WARN FFEBAD_severityWARNING\n-#define PECULIAR FFEBAD_severityPECULIAR\n-#define FATAL FFEBAD_severityFATAL\n-#define WEIRD FFEBAD_severityWEIRD\n-#define SEVERE FFEBAD_severitySEVERE\n-#define DISASTER FFEBAD_severityDISASTER\n-\n-FFEBAD_MSG (FFEBAD_MISSING_FIRST_BINARY_OPERAND, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing first operand for binary operator at %0\")\n-FFEBAD_MSG (FFEBAD_NULL_CHAR_CONST, WARN,\n-/* xgettext:no-c-format */\n-\"Zero-length character constant at %0\")\n-FFEBAD_MSG (FFEBAD_INVALID_TOKEN_IN_EXPRESSION, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid token at %0 in expression or subexpression at %1\")\n-FFEBAD_MSG (FFEBAD_MISSING_OPERAND_FOR_OPERATOR, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing operand for operator at %1 at end of expression at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_ALREADY_DEFINED, FATAL,\n-/* xgettext:no-c-format */\n-\"Label %A already defined at %1 when redefined at %0\")\n-FFEBAD_MSG (FFEBAD_UNRECOGNIZED_CHARACTER, FATAL,\n-/* xgettext:no-c-format */\n-\"Unrecognized character at %0 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LABEL_WITHOUT_STMT, WARN,\n-/* xgettext:no-c-format */\n-\"Label definition %A at %0 on empty statement (as of %1)\")\n-FFEBAD_MSG (FFEBAD_EXTRA_LABEL_DEF, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Extra label definition %A at %0 -- perhaps previous label definition %B at %1 should have CONTINUE statement?\")\n-/* xgettext:no-c-format */\n-SHORT(\"Extra label definition %A at %0 following label definition %B at %1\"))\n-FFEBAD_MSG (FFEBAD_FIRST_CHAR_INVALID, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid first character at %0 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LINE_TOO_LONG, FATAL,\n-/* xgettext:no-c-format */\n-\"Line too long as of %0 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LABEL_FIELD_NOT_NUMERIC, FATAL,\n-/* xgettext:no-c-format */\n-\"Non-numeric character at %0 in label field [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LABEL_NUMBER_INVALID, FATAL,\n-/* xgettext:no-c-format */\n-\"Label number at %0 not in range 1-99999\")\n-FFEBAD_MSG (FFEBAD_NON_ANSI_COMMENT, WARN,\n-/* xgettext:no-c-format */\n-\"At %0, '!' and '/*' are not valid comment delimiters\")\n-FFEBAD_MSG (FFEBAD_NON_ANSI_CONTINUATION_COLUMN, WARN,\n-/* xgettext:no-c-format */\n-\"Continuation indicator at %0 must appear in column 6 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LABEL_ON_CONTINUATION, FATAL,\n-/* xgettext:no-c-format */\n-\"Label at %0 invalid with continuation line indicator at %1 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_INVALID_CONTINUATION, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Continuation indicator at %0 invalid on first non-comment line of file or following END or INCLUDE [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Continuation indicator at %0 invalid here [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_NO_CLOSING_APOSTROPHE, FATAL,\n-/* xgettext:no-c-format */\n-\"Character constant at %0 has no closing apostrophe at %1\")\n-FFEBAD_MSG (FFEBAD_NOT_ENOUGH_HOLLERITH_CHARS, FATAL,\n-/* xgettext:no-c-format */\n-\"Hollerith constant at %0 specified %A more characters than are present as of %1\")\n-FFEBAD_MSG (FFEBAD_MISSING_CLOSE_PAREN, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing close parenthese at %0 needed to match open parenthese at %1\")\n-FFEBAD_MSG (FFEBAD_INTEGER_TOO_LARGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Integer at %0 too large\")\n-FFEBAD_MSG (FFEBAD_BAD_MAGICAL, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Integer at %0 too large except as negative number (preceded by unary minus sign)\")\n-/* xgettext:no-c-format */\n-SHORT(\"Non-negative integer at %0 too large\"))\n-FFEBAD_MSG (FFEBAD_BAD_MAGICAL_PRECEDENCE, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Integer at %0 too large; even though preceded by unary minus sign at %1, subsequent operator at %2 has precedence over unary minus -- enclose unary minus sign and integer in parentheses to force precedence\")\n-/* xgettext:no-c-format */\n-SHORT(\"Integer at %0 too large (%2 has precedence over %1)\"))\n-FFEBAD_MSG (FFEBAD_BAD_MAGICAL_BINARY, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Integer at %0 too large; even though preceded by minus sign at %1, because minus sign is a binary, not unary, operator -- insert plus sign before minus sign to change it to a unary minus sign\")\n-/* xgettext:no-c-format */\n-SHORT(\"Integer at %0 too large (needs unary, not binary, minus at %1)\"))\n-FFEBAD_MSG (FFEBAD_BAD_MAGICAL_PRECEDENCE_BINARY, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Integer at %0 too large; even though preceded by minus sign at %1, subsequent operator at %2 has precedence over minus, and that minus sign should be a unary minus rather than a binary minus -- insert plus sign before minus sign to change it to a unary minus sign, and enclose unary minus sign and integer in parentheses to force precedence\")\n-/* xgettext:no-c-format */\n-SHORT(\"Integer at %0 too large (%2 has precedence over %1, which needs to be unary, not binary, minus)\"))\n-FFEBAD_MSG (FFEBAD_IGNORING_PERIOD, FATAL,\n-/* xgettext:no-c-format */\n-\"Period at %0 not followed by digits for floating-point number or by `NOT.', `TRUE.', or `FALSE.'\")\n-FFEBAD_MSG (FFEBAD_INSERTING_PERIOD, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing close-period between `.%A' at %0 and %1\")\n-FFEBAD_MSG (FFEBAD_INVALID_EXPONENT, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid exponent at %0 for real constant at %1; nondigit `%A' in exponent field\")\n-FFEBAD_MSG (FFEBAD_MISSING_EXPONENT_VALUE, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing value at %1 for real-number exponent at %0\")\n-FFEBAD_MSG (FFEBAD_MISSING_BINARY_OPERATOR, FATAL,\n-/* xgettext:no-c-format */\n-\"Expected binary operator between expressions at %0 and at %1\")\n-FFEBAD_MSG (FFEBAD_INVALID_DOTDOT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Period at %0 not followed by valid keyword forming a valid binary operator; `.%A.' is not a valid binary operator\")\n-/* xgettext:no-c-format */\n-SHORT(\"`.%A.' at %0 not a binary operator\"))\n-FFEBAD_MSG (FFEBAD_QUOTE_MISSES_DIGITS, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Double-quote at %0 not followed by a string of valid octal digits at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid octal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_BINARY_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid binary digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid binary constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_HEX_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid hexadecimal digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid hexadecimal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_OCTAL_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid octal digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid octal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_RADIX_SPECIFIER, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid radix specifier `%A' at %0 for typeless constant at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid typeless constant at %1\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPELESS_BINARY_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid binary digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid binary constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPELESS_OCTAL_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid octal digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid octal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPELESS_HEX_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid hexadecimal digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid hexadecimal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_COMPLEX_PART, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"%A part of complex constant at %0 must be a real or integer constant -- otherwise use CMPLX() or COMPLEX() in place of ()\")\n-/* xgettext:no-c-format */\n-SHORT(\"%A part of complex constant at %0 not a real or integer constant\"))\n-FFEBAD_MSG (FFEBAD_INVALID_PERCENT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid keyword `%%%A' at %0 in this context\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid keyword `%%%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_NULL_EXPRESSION, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Null expression between %0 and %1 invalid in this context\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid null expression between %0 and %1\"))\n-FFEBAD_MSG (FFEBAD_CONCAT_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Concatenation operator at %0 must operate on two subexpressions of character type, but neither subexpression at %1 or %2 is of character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for concatenation operator at %0\"))\n-FFEBAD_MSG (FFEBAD_CONCAT_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Concatenation operator at %0 must operate on two subexpressions of character type, but the subexpression at %1 is not of character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for concatenation operator at %0\"))\n-FFEBAD_MSG (FFEBAD_CONCAT_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Concatenation operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning character scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for concatenation operator at %0\"))\n-FFEBAD_MSG (FFEBAD_MATH_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Arithmetic operator at %0 must operate on two subexpressions of arithmetic type, but neither subexpression at %1 or %2 is of arithmetic type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for arithmetic operator at %0\"))\n-FFEBAD_MSG (FFEBAD_MATH_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Arithmetic operator at %0 must operate on two subexpressions of arithmetic type, but the subexpression at %1 is not of arithmetic type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for arithmetic operator at %0\"))\n-FFEBAD_MSG (FFEBAD_MATH_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Arithmetic operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning arithmetic scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for arithmetic operator at %0\"))\n-FFEBAD_MSG (FFEBAD_NO_CLOSING_QUOTE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Character constant at %0 has no closing quote at %1 [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unterminated character constant at %0 [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_BAD_CHAR_CONTINUE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Continuation line at %0 must have initial `&' since it continues a character context [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Missing initial `&' on continuation line at %0 [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_BAD_LEXTOK_CONTINUE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Continuation line at %0 must have initial `&' since it continues a split lexical token [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Missing initial `&' on continuation line at %0 [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_BAD_FREE_CONTINUE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Continuation line at %0 invalid because it consists only of a single `&' as the only nonblank character\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid continuation line at %0\"))\n-FFEBAD_MSG (FFEBAD_STMT_BEGINS_BAD, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Statement at %0 begins with invalid token [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid statement at %0 [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_SEMICOLON, FATAL,\n-/* xgettext:no-c-format */\n-\"Semicolon at %0 is an invalid token\")\n-FFEBAD_MSG (FFEBAD_UNREC_STMT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unrecognized statement name at %0 and invalid form for assignment or statement-function definition at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid statement at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_STMT_FORM, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid form for %A statement at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid %A statement at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_HOLL_IN_STMT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid use of hollerith constant in statement at %0 -- enclose the constant in parentheses (for example, change BACKSPACE 2HAB to BACKSPACE (2HAB))\")\n-/* xgettext:no-c-format */\n-SHORT(\"Enclose hollerith constant in statement at %0 in parentheses\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_EXTRA_COMMA, FATAL,\n-/* xgettext:no-c-format */\n-\"Extraneous comma in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_MISSING_COMMA, WARN,\n-/* xgettext:no-c-format */\n-\"Missing comma in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_SPURIOUS_SIGN, FATAL,\n-/* xgettext:no-c-format */\n-\"Spurious sign in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_SPURIOUS_NUMBER, FATAL,\n-/* xgettext:no-c-format */\n-\"Spurious number in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_TEXT_IN_NUMBER, FATAL,\n-/* xgettext:no-c-format */\n-\"Spurious text trailing number in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_P_NOCOMMA, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"nP control edit descriptor not followed by comma but followed by edit descriptor at %0 other than D, E, EN, F, or G\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid edit descriptor at %0 following nP control edit descriptor\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-\"Unrecognized FORMAT specifier at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_I_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid I specifier in FORMAT statement at %0 -- correct form: [r]Iw.[m]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid I specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_B_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid B specifier in FORMAT statement at %0 -- correct form: [r]Bw.[m]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid B specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_O_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid O specifier in FORMAT statement at %0 -- correct form: [r]Ow.[m]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid O specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_Z_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid Z specifier in FORMAT statement at %0 -- correct form: [r]Zw.[m]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid Z specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_F_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid F specifier in FORMAT statement at %0 -- correct form: [r]Fw.d\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid F specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_E_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid E specifier in FORMAT statement at %0 -- correct form: [r]Ew.d[Ee]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid E specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_EN_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid EN specifier in FORMAT statement at %0 -- correct form: [r]ENw.d[Ee]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid EN specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_G_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid G specifier in FORMAT statement at %0 -- correct form: [r]Gw.d[Ee]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid G specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_L_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid L specifier in FORMAT statement at %0 -- correct form: [r]Lw\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid L specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_A_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid A specifier in FORMAT statement at %0 -- correct form: [r]A[w]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid A specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_D_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid D specifier in FORMAT statement at %0 -- correct form: [r]Dw.d\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid D specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_Q_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid Q specifier in FORMAT statement at %0 -- correct form: Q\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid Q specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_DOLLAR_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid $ specifier in FORMAT statement at %0 -- correct form: $\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid $ specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_P_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid P specifier in FORMAT statement at %0 -- correct form: kP\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid P specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_T_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid T specifier in FORMAT statement at %0 -- correct form: Tn\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid T specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_TL_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid TL specifier in FORMAT statement at %0 -- correct form: TLn\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid TL specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_TR_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid TR specifier in FORMAT statement at %0 -- correct form: TRn\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid TR specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_X_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid X specifier in FORMAT statement at %0 -- correct form: nX\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid X specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_S_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid S specifier in FORMAT statement at %0 -- correct form: S\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid S specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_SP_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid SP specifier in FORMAT statement at %0 -- correct form: SP\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid SP specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_SS_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid SS specifier in FORMAT statement at %0 -- correct form: SS\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid SS specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_BN_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid BN specifier in FORMAT statement at %0 -- correct form: BN\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid BN specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_BZ_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid BZ specifier in FORMAT statement at %0 -- correct form: BZ\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid BZ specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_COLON_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid : specifier in FORMAT statement at %0 -- correct form: :\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid : specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_H_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid H specifier in FORMAT statement at %0 -- correct form: nHcharacters  !where n is an unsigned decimal constant, and characters               !contains exactly n characters (including spaces)\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid H specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_MISSING_PAREN, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing close-parenthese(s) in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_MISSING_DOT, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing number following period in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_MISSING_EXP, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing number following `E' in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_EXPR_TOKEN, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid token with FORMAT run-time expression at %0 -- use the traditional operators .LT., .LE., .GT., .GE., .EQ., and .NE. in place of the newer tokens <, <=, >, >=, ==, and !=, because > ends an expression within a FORMAT statement\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid token with FORMAT run-time expression at %0\"))\n-FFEBAD_MSG (FFEBAD_TRAILING_COMMA, WARN,\n-/* xgettext:no-c-format */\n-\"Spurious trailing comma preceding terminator at %0\")\n-FFEBAD_MSG (FFEBAD_INTERFACE_ASSIGNMENT, WARN,\n-/* xgettext:no-c-format */\n-\"At %0, specify OPERATOR instead of ASSIGNMENT for INTERFACE statement not specifying the assignment operator (=)\")\n-FFEBAD_MSG (FFEBAD_INTERFACE_OPERATOR, WARN,\n-/* xgettext:no-c-format */\n-\"At %0, specify ASSIGNMENT instead of OPERATOR for INTERFACE statement specifying the assignment operator (=)\")\n-FFEBAD_MSG (FFEBAD_INTERFACE_NONLETTER, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Defined operator at %0 contains a nonletter -- must contain only letters A-Z (or a-z)\")\n-/* xgettext:no-c-format */\n-SHORT(\"Nonletter in defined operator at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPEDECL_ATTR, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid type-declaration attribute at %0 -- must be one of: DIMENSION(array-spec), EXTERNAL, INTRINSIC, PARAMETER, or SAVE\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid type-declaration attribute at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPEDECL_INIT, FATAL,\n-/* xgettext:no-c-format */\n-\"Cannot specify =initialization-expr at %0 unless `::' appears before list of objects\")\n-FFEBAD_MSG (FFEBAD_LABEL_USE_DEF, FATAL,\n-/* xgettext:no-c-format */\n-\"Reference to label at %1 inconsistent with its definition at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_USE_USE, FATAL,\n-/* xgettext:no-c-format */\n-\"Reference to label at %1 inconsistent with earlier reference at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_DEF_DO, FATAL,\n-/* xgettext:no-c-format */\n-\"DO-statement reference to label at %1 follows its definition at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_BLOCK, WARN,\n-/* xgettext:no-c-format */\n-\"Reference to label at %1 is outside block containing definition at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_DO_BLOCK_DO, FATAL,\n-/* xgettext:no-c-format */\n-\"DO-statement references to label at %0 and %2 separated by unterminated block starting at %1\")\n-FFEBAD_MSG (FFEBAD_LABEL_DO_BLOCK_END, FATAL,\n-/* xgettext:no-c-format */\n-\"DO-statement reference to label at %0 and label definition at %2 separated by unterminated block starting at %1\")\n-FFEBAD_MSG (FFEBAD_INVALID_LABEL_DEF, FATAL,\n-/* xgettext:no-c-format */\n-\"Label definition at %0 invalid on this kind of statement\")\n-FFEBAD_MSG (FFEBAD_ORDER_1, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 invalid in this context\")\n-FFEBAD_MSG (FFEBAD_ORDER_2, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 invalid in context established by statement at %1\")\n-FFEBAD_MSG (FFEBAD_CONSTRUCT_NAMED, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 must specify construct name specified at %1\")\n-FFEBAD_MSG (FFEBAD_CONSTRUCT_NOT_NAMED, FATAL,\n-/* xgettext:no-c-format */\n-\"Construct name at %0 superfluous, no construct name specified at %1\")\n-FFEBAD_MSG (FFEBAD_CONSTRUCT_WRONG_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Construct name at %0 not the same as construct name at %1\")\n-FFEBAD_MSG (FFEBAD_CONSTRUCT_NO_DO_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Construct name at %0 does not match construct name for any containing DO constructs\")\n-FFEBAD_MSG (FFEBAD_DO_HAD_LABEL, FATAL,\n-/* xgettext:no-c-format */\n-\"Label definition missing at %0 for DO construct specifying label at %1\")\n-FFEBAD_MSG (FFEBAD_AFTER_ELSE, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 follows ELSE block for IF construct at %1\")\n-FFEBAD_MSG (FFEBAD_FORMAT_NO_LABEL_DEF, FATAL,\n-/* xgettext:no-c-format */\n-\"No label definition for FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_SECOND_ELSE_WHERE, FATAL,\n-/* xgettext:no-c-format */\n-\"Second occurrence of ELSE WHERE at %0 within WHERE at %1\")\n-FFEBAD_MSG (FFEBAD_END_WO, WARN,\n-/* xgettext:no-c-format */\n-\"END statement at %0 missing `%A' keyword required for internal or module procedure(s) bounded by %1\")\n-FFEBAD_MSG (FFEBAD_INVALID_MODULE_PROCEDURE, FATAL,\n-/* xgettext:no-c-format */\n-\"MODULE PROCEDURE statement at %0 disallowed because INTERFACE at %1 specifies no generic name, operator, or assignment\")\n-FFEBAD_MSG (FFEBAD_BLOCKDATA_NOT_NAMED, FATAL,\n-/* xgettext:no-c-format */\n-\"BLOCK DATA name at %0 superfluous, no name specified at %1\")\n-FFEBAD_MSG (FFEBAD_PROGRAM_NOT_NAMED, FATAL,\n-/* xgettext:no-c-format */\n-\"Program name at %0 superfluous, no PROGRAM statement specified at %1\")\n-FFEBAD_MSG (FFEBAD_UNIT_WRONG_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Program unit name at %0 not the same as name at %1\")\n-FFEBAD_MSG (FFEBAD_TYPE_WRONG_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Type name at %0 not the same as name at %1\")\n-FFEBAD_MSG (FFEBAD_EOF_BEFORE_BLOCK_END, FATAL,\n-/* xgettext:no-c-format */\n-\"End of source file before end of block started at %0\")\n-FFEBAD_MSG (FFEBAD_UNDEF_LABEL, FATAL,\n-/* xgettext:no-c-format */\n-\"Undefined label, first referenced at %0\")\n-FFEBAD_MSG (FFEBAD_CONFLICTING_SAVES, WARN,\n-/* xgettext:no-c-format */\n-\"SAVE statement or attribute at %1 cannot be specified along with SAVE statement or attribute at %0\")\n-FFEBAD_MSG (FFEBAD_CONFLICTING_ACCESSES, FATAL,\n-/* xgettext:no-c-format */\n-\"PUBLIC or PRIVATE statement at %1 cannot be specified along with PUBLIC or PRIVATE statement at %0\")\n-FFEBAD_MSG (FFEBAD_RETURN_IN_MAIN, WARN,\n-/* xgettext:no-c-format */\n-\"RETURN statement at %0 invalid within a main program unit\")\n-FFEBAD_MSG (FFEBAD_ALTRETURN_IN_PROGRAM, FATAL,\n-/* xgettext:no-c-format */\n-\"Alternate return specifier at %0 invalid within a main program unit\")\n-FFEBAD_MSG (FFEBAD_ALTRETURN_IN_FUNCTION, FATAL,\n-/* xgettext:no-c-format */\n-\"Alternate return specifier at %0 invalid within a function\")\n-FFEBAD_MSG (FFEBAD_DERIVTYP_ACCESS, FATAL,\n-/* xgettext:no-c-format */\n-\"Access specifier or PRIVATE statement at %0 invalid for derived-type definition within other than the specification part of a module\")\n-FFEBAD_MSG (FFEBAD_DERIVTYP_ACCESS_FIRST, FATAL,\n-/* xgettext:no-c-format */\n-\"Access specifier at %0 must immediately follow derived-type statement at %1 with no intervening statements\")\n-FFEBAD_MSG (FFEBAD_DERIVTYP_NO_COMPONENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"No components specified as of %0 for derived-type definition beginning at %1\")\n-FFEBAD_MSG (FFEBAD_STRUCT_NO_COMPONENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"No components specified as of %0 for structure definition beginning at %1\")\n-FFEBAD_MSG (FFEBAD_STRUCT_MISSING_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing structure name for outer structure definition at %0\")\n-FFEBAD_MSG (FFEBAD_STRUCT_IGNORING_FIELD, FATAL,\n-/* xgettext:no-c-format */\n-\"Field names at %0 for outer structure definition -- specify them in a subsequent RECORD statement instead\")\n-FFEBAD_MSG (FFEBAD_STRUCT_MISSING_FIELD, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing field name(s) for structure definition at %0 within structure definition at %1\")\n-FFEBAD_MSG (FFEBAD_MAP_NO_COMPONENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"No components specified as of %0 for map beginning at %1\")\n-FFEBAD_MSG (FFEBAD_UNION_NO_TWO_MAPS, FATAL,\n-/* xgettext:no-c-format */\n-\"Zero or one maps specified as of %0 for union beginning at %1 -- at least two are required\")\n-FFEBAD_MSG (FFEBAD_MISSING_SPECIFIER, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing %A specifier in statement at %0\")\n-FFEBAD_MSG (FFEBAD_NAMELIST_ITEMS, FATAL,\n-/* xgettext:no-c-format */\n-\"Items in I/O list starting at %0 invalid for namelist-directed I/O\")\n-FFEBAD_MSG (FFEBAD_CONFLICTING_SPECS, FATAL,\n-/* xgettext:no-c-format */\n-\"Conflicting I/O control specifications at %0 and %1\")\n-FFEBAD_MSG (FFEBAD_NO_UNIT_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-\"No UNIT= specifier in I/O control list at %0\")\n-FFEBAD_MSG (FFEBAD_MISSING_ADVANCE_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-\"Specification at %0 requires ADVANCE=`NO' specification in same I/O control list\")\n-FFEBAD_MSG (FFEBAD_MISSING_FORMAT_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-\"Specification at %0 requires explicit FMT= specification in same I/O control list\")\n-FFEBAD_MSG (FFEBAD_SPEC_VALUE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unrecognized value for character constant at %0 -- expecting %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unrecognized value for character constant at %0\"))\n-FFEBAD_MSG (FFEBAD_CASE_SECOND_DEFAULT, FATAL,\n-/* xgettext:no-c-format */\n-\"Second occurrence of CASE DEFAULT at %0 within SELECT CASE at %1\")\n-FFEBAD_MSG (FFEBAD_CASE_DUPLICATE, FATAL,\n-/* xgettext:no-c-format */\n-\"Duplicate or overlapping case values/ranges at %0 and %1\")\n-FFEBAD_MSG (FFEBAD_CASE_TYPE_DISAGREE, FATAL,\n-/* xgettext:no-c-format */\n-\"Type and/or kind-type parameter disagreement between CASE value or value within range at %0 and SELECT CASE at %1\")\n-FFEBAD_MSG (FFEBAD_CASE_LOGICAL_RANGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Range specification at %0 invalid for CASE statement within logical-type SELECT CASE statement\")\n-FFEBAD_MSG (FFEBAD_CASE_BAD_RANGE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Range specification at %0 invalid -- at least one expression must be specified, or use CASE DEFAULT\")\n-/* xgettext:no-c-format */\n-SHORT(\"Range specification at %0 invalid\"))\n-FFEBAD_MSG (FFEBAD_CASE_RANGE_USELESS, INFORM,\n-/* xgettext:no-c-format */\n-LONG(\"Range specification at %0 useless; first expression greater than second expression in range, so range can never be matched by any selection expression\")\n-/* xgettext:no-c-format */\n-SHORT(\"Useless range at %0\"))\n-FFEBAD_MSG (FFEBAD_F90, FATAL,\n-/* xgettext:no-c-format */\n-\"Fortran 90 feature at %0 unsupported\")\n-FFEBAD_MSG (FFEBAD_KINDTYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid kind at %0 for type at %1 -- unsupported or not permitted\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid kind at %0 for type at %1\"))\n-FFEBAD_MSG (FFEBAD_BAD_IMPLICIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Cannot establish implicit type for initial letter `%A' at %0 -- already explicitly established or used to set implicit type of some name, or backwards order of letters in letter range\")\n-/* xgettext:no-c-format */\n-SHORT(\"Cannot establish implicit type for initial letter `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_SYMERR, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid declaration of or reference to symbol `%A' at %0 [initially seen at %1]\")\n-FFEBAD_MSG (FFEBAD_LABEL_WRONG_PLACE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Label definition %A (at %0) invalid -- must be in columns 1-5\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid label definition %A (at %0)\"))\n-FFEBAD_MSG (FFEBAD_NULL_ELEMENT, FATAL,\n-/* xgettext:no-c-format */\n-\"Null element at %0 for array reference at %1\")\n-FFEBAD_MSG (FFEBAD_TOO_FEW_ELEMENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"Too few elements (%A missing) as of %0 for array reference at %1\")\n-FFEBAD_MSG (FFEBAD_TOO_MANY_ELEMENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"Too many elements as of %0 for array reference at %1\")\n-FFEBAD_MSG (FFEBAD_MISSING_COLON_IN_SUBSTR, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing colon as of %0 in substring reference for %1\")\n-FFEBAD_MSG (FFEBAD_BAD_SUBSTR, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid use at %0 of substring operator on %1\")\n-FFEBAD_MSG (FFEBAD_RANGE_SUBSTR, WARN,\n-/* xgettext:no-c-format */\n-\"Substring begin/end point at %0 out of defined range\")\n-FFEBAD_MSG (FFEBAD_RANGE_ARRAY, WARN,\n-/* xgettext:no-c-format */\n-\"Array element value at %0 out of defined range\")\n-FFEBAD_MSG (FFEBAD_EXPR_WRONG, FATAL,\n-/* xgettext:no-c-format */\n-\"Expression at %0 has incorrect data type or rank for its context\")\n-FFEBAD_MSG (FFEBAD_DIV_BY_ZERO, WARN,\n-/* xgettext:no-c-format */\n-\"Division by 0 (zero) at %0 (IEEE not yet supported)\")\n-FFEBAD_MSG (FFEBAD_DO_STEP_ZERO, FATAL,\n-/* xgettext:no-c-format */\n-\"%A step count known to be 0 (zero) at %0\")\n-FFEBAD_MSG (FFEBAD_DO_END_OVERFLOW, WARN,\n-/* xgettext:no-c-format */\n-\"%A end value plus step count known to overflow at %0\")\n-FFEBAD_MSG (FFEBAD_DO_IMP_OVERFLOW, WARN,\n-/* xgettext:no-c-format */\n-\"%A begin, end, and step-count values known to result in implementation-dependent behavior due to overflow(s) in intermediate calculations at %0\")\n-FFEBAD_MSG (FFEBAD_DO_NULL, WARN,\n-/* xgettext:no-c-format */\n-\"%A begin, end, and step-count values known to result in no iterations at %0\")\n-FFEBAD_MSG (FFEBAD_BAD_TYPES, FATAL,\n-/* xgettext:no-c-format */\n-\"Type disagreement between expressions at %0 and %1\")\n-FFEBAD_MSG (FFEBAD_FORMAT_EXPR_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Run-time expression at %0 in FORMAT statement that does not follow the first executable statement in the program unit -- move the statement\")\n-/* xgettext:no-c-format */\n-SHORT(\"FORMAT at %0 with run-time expression must follow first executable statement\"))\n-FFEBAD_MSG (FFEBAD_BAD_IMPDO, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unexpected token at %0 in implied-DO construct at %1 -- form of implied-DO is `(item-list,do-var=start,end[,incr])'\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unexpected token at %0 in implied-DO construct at %1\"))\n-FFEBAD_MSG (FFEBAD_BAD_IMPDCL, FATAL,\n-/* xgettext:no-c-format */\n-\"No specification for implied-DO iterator `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_IMPDO_PAREN, WARN,\n-/* xgettext:no-c-format */\n-\"Gratuitous parentheses surround implied-DO construct at %0\")\n-FFEBAD_MSG (FFEBAD_ZERO_SIZE, FATAL,\n-/* xgettext:no-c-format */\n-\"Zero-size specification invalid at %0\")\n-FFEBAD_MSG (FFEBAD_ZERO_ARRAY, FATAL,\n-/* xgettext:no-c-format */\n-\"Zero-size array at %0\")\n-FFEBAD_MSG (FFEBAD_BAD_COMPLEX, FATAL,\n-/* xgettext:no-c-format */\n-\"Target machine does not support complex entity of kind specified at %0\")\n-FFEBAD_MSG (FFEBAD_BAD_DBLCMPLX, FATAL,\n-/* xgettext:no-c-format */\n-\"Target machine does not support DOUBLE COMPLEX, specified at %0\")\n-FFEBAD_MSG (FFEBAD_BAD_POWER, WARN,\n-/* xgettext:no-c-format */\n-\"Attempt to raise constant zero to a power at %0\")\n-FFEBAD_MSG (FFEBAD_BOOL_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Boolean/logical operator at %0 must operate on two subexpressions of logical type, but neither subexpression at %1 or %2 is of logical type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for boolean operator at %0\"))\n-FFEBAD_MSG (FFEBAD_BOOL_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Boolean/logical operator at %0 must operate on two subexpressions of logical type, but the subexpression at %1 is not of logical type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for boolean operator at %0\"))\n-FFEBAD_MSG (FFEBAD_BOOL_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Boolean/logical operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning logical scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for boolean operator at %0\"))\n-FFEBAD_MSG (FFEBAD_NOT_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\".NOT. operator at %0 must operate on subexpression of logical type, but the subexpression at %1 is not of logical type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for .NOT. operator at %0\"))\n-FFEBAD_MSG (FFEBAD_NOT_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\".NOT. operator at %0 must operate on scalar subexpressions -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for .NOT. operator at %0\"))\n-FFEBAD_MSG (FFEBAD_EQOP_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Equality operator at %0 must operate on two subexpressions of arithmetic or character type, but neither subexpression at %1 or %2 is of arithmetic or character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for equality operator at %0\"))\n-FFEBAD_MSG (FFEBAD_EQOP_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Equality operator at %0 must operate on two subexpressions of arithmetic or character type, but the subexpression at %1 is not of arithmetic or character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for equality operator at %0\"))\n-FFEBAD_MSG (FFEBAD_EQOP_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Equality operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning arithmetic or character scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for equality operator at %0\"))\n-FFEBAD_MSG (FFEBAD_RELOP_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Relational operator at %0 must operate on two subexpressions of integer, real, or character type, but neither subexpression at %1 or %2 is of integer, real, or character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for relational operator at %0\"))\n-FFEBAD_MSG (FFEBAD_RELOP_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Relational operator at %0 must operate on two subexpressions of integer, real, or character type, but the subexpression at %1 is not of integer, real, or character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for relational operator at %0\"))\n-FFEBAD_MSG (FFEBAD_RELOP_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Relational operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning integer, real, or character scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for relational operator at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_REF, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to intrinsic `%A' at %0 invalid -- one or more arguments have incorrect type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid reference to intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_TOOFEW, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Too few arguments passed to intrinsic `%A' at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Too few arguments for intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_TOOMANY, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Too many arguments passed to intrinsic `%A' at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Too many arguments for intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_DISABLED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to disabled intrinsic `%A' at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Disabled intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_IS_SUBR, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to intrinsic subroutine `%A' as if it were a function at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Function reference to intrinsic subroutine `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_IS_FUNC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to intrinsic function `%A' as if it were a subroutine at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Subroutine reference to intrinsic function `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_UNIMPL, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to unimplemented intrinsic `%A' at %0 -- use EXTERNAL to reference user-written procedure with this name\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unimplemented intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_UNIMPLW, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to unimplemented intrinsic `%A' at %0 (assumed EXTERNAL)\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unimplemented intrinsic `%A' at %0 (assumed EXTERNAL)\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_AMBIG, FATAL,\n-/* xgettext:no-c-format */\n-\"Reference to generic intrinsic `%A' at %0 could be to form %B or %C\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_CMPAMBIG, FATAL,\n-/* xgettext:no-c-format */\n-\"Ambiguous use of intrinsic `%A' at %0 [info -f g77 M CMPAMBIG]\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_EXPIMP, WARN,\n-/* xgettext:no-c-format */\n-\"Intrinsic `%A' referenced %Bly at %0, %Cly at %1 [info -f g77 M EXPIMP]\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_GLOBAL, WARN,\n-/* xgettext:no-c-format */\n-\"Same name `%A' used for %B at %0 and %C at %1 [info -f g77 M INTGLOB]\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_TYPE, WARN,\n-/* xgettext:no-c-format */\n-\"Explicit type declaration for intrinsic `%A' disagrees with invocation at %0\")\n-FFEBAD_MSG (FFEBAD_OPEN_INCLUDE, FATAL,\n-/* xgettext:no-c-format */\n-\"Unable to open INCLUDE file `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_DOITER, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Attempt to modify variable `%A' at %0 while it serves as DO-loop iterator at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Modification of DO-loop iterator `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_DOITER_IMPDO, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Attempt to modify variable `%A' via item #%B in list at %0 while it serves as implied-DO iterator at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Modification of DO-loop iterator `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_TOO_MANY_DIMS, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Array has too many dimensions, as of dimension specifier at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Too many dimensions at %0\"))\n-FFEBAD_MSG (FFEBAD_NULL_ARGUMENT, FATAL,\n-/* xgettext:no-c-format */\n-\"Null argument at %0 for statement function reference at %1\")\n-FFEBAD_MSG (FFEBAD_NULL_ARGUMENT_W, WARN,\n-/* xgettext:no-c-format */\n-\"Null argument at %0 for procedure invocation at %1\")\n-FFEBAD_MSG (FFEBAD_TOO_FEW_ARGUMENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"%A too few arguments (starting with dummy argument `%B') as of %0 for statement function reference at %1\")\n-FFEBAD_MSG (FFEBAD_TOO_MANY_ARGUMENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"%A too many arguments as of %0 for statement function reference at %1\")\n-FFEBAD_MSG (FFEBAD_ARRAY_AS_SFARG, FATAL,\n-/* xgettext:no-c-format */\n-\"Array supplied at %1 for dummy argument `%A' in statement function reference at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-\"Unsupported FORMAT specifier at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_VARIABLE, FATAL,\n-/* xgettext:no-c-format */\n-\"Variable-expression FORMAT specifier at %0 -- unsupported\")\n-FFEBAD_MSG (FFEBAD_OPEN_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unsupported OPEN control item at %0 -- ACTION=, ASSOCIATEVARIABLE=, BLOCKSIZE=, BUFFERCOUNT=, CARRIAGECONTROL=, DEFAULTFILE=, DELIM=, DISPOSE=, EXTENDSIZE=, INITIALSIZE=, KEY=, MAXREC=, NOSPANBLOCKS, ORGANIZATION=, PAD=, POSITION=, READONLY=, RECORDTYPE=, SHARED=, and USEROPEN= are not supported\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unsupported OPEN control item at %0\"))\n-FFEBAD_MSG (FFEBAD_INQUIRE_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unsupported INQUIRE control item at %0 -- ACTION=, CARRIAGECONTROL=, DEFAULTFILE=, DELIM=, KEYED=, ORGANIZATION=, PAD=, POSITION=, READ=, READWRITE=, RECORDTYPE=, and WRITE= are not supported\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unsupported INQUIRE control item at %0\"))\n-FFEBAD_MSG (FFEBAD_READ_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unsupported READ control item at %0 -- ADVANCE=, EOR=, KEYEQ=, KEYGE=, KEYGT=, KEYID=, NULLS=, and SIZE= are not supported\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unsupported READ control item at %0\"))\n-FFEBAD_MSG (FFEBAD_WRITE_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unsupported WRITE control item at %0 -- ADVANCE= and EOR= are not supported\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unsupported WRITE control item at %0\"))\n-FFEBAD_MSG (FFEBAD_VXT_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-\"Unsupported VXT statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_REINIT, FATAL,\n-/* xgettext:no-c-format */\n-\"Attempt to specify second initial value for `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_TOOFEW, FATAL,\n-/* xgettext:no-c-format */\n-\"Too few initial values in list of initializers for `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_TOOMANY, FATAL,\n-/* xgettext:no-c-format */\n-\"Too many initial values in list of initializers starting at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_RANGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Array or substring specification for `%A' out of range in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_SUBSCRIPT, FATAL,\n-/* xgettext:no-c-format */\n-\"Array subscript #%B out of range for initialization of `%A' in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_ZERO, FATAL,\n-/* xgettext:no-c-format */\n-\"Implied do-loop step count of 0 (zero) for iteration variable `%A' in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_EMPTY, FATAL,\n-/* xgettext:no-c-format */\n-\"Implied do-loop iteration count of 0 (zero) for iteration variable `%A' in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_EVAL, FATAL,\n-/* xgettext:no-c-format */\n-\"Not an integer constant expression in implied do-loop in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_MULTIPLE, FATAL,\n-/* xgettext:no-c-format */\n-\"Attempt to specify second initial value for element of `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_EQUIV_COMMON, FATAL,\n-/* xgettext:no-c-format */\n-\"Attempt to EQUIVALENCE common areas `%A' and `%B' at %0\")\n-FFEBAD_MSG (FFEBAD_EQUIV_ALIGN, FATAL,\n-/* xgettext:no-c-format */\n-\"Can't place `%A' as directed by EQUIVALENCE due to alignment restrictions\")\n-FFEBAD_MSG (FFEBAD_EQUIV_MISMATCH, FATAL,\n-/* xgettext:no-c-format */\n-\"Mismatched EQUIVALENCE requirements for placement of `%A' at both %C and %D bytes offset from `%B'\")\n-FFEBAD_MSG (FFEBAD_EQUIV_RANGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Array or substring specification for `%A' out of range in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_EQUIV_SUBSTR, FATAL,\n-/* xgettext:no-c-format */\n-\"Substring of non-CHARACTER entity `%A' in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_EQUIV_ARRAY, FATAL,\n-/* xgettext:no-c-format */\n-\"Array reference to scalar variable `%A' in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_EQUIV_SUBSCRIPT, WARN,\n-/* xgettext:no-c-format */\n-\"Array subscript #%B out of range for EQUIVALENCE of `%A'\")\n-FFEBAD_MSG (FFEBAD_COMMON_PAD, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Padding of %A %D required before `%B' in common block `%C' at %0 -- consider reordering members, largest-type-size first\")\n-/* xgettext:no-c-format */\n-SHORT(\"Padding of %A %D required before `%B' in common block `%C' at %0\"))\n-FFEBAD_MSG (FFEBAD_COMMON_NEG, FATAL,\n-/* xgettext:no-c-format */\n-\"Attempt to extend COMMON area beyond its starting point via EQUIVALENCE of `%A'\")\n-FFEBAD_MSG (FFEBAD_EQUIV_FEW, FATAL,\n-/* xgettext:no-c-format */\n-\"Too few elements in reference to array `%A' in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_EQUIV_MANY, FATAL,\n-/* xgettext:no-c-format */\n-\"Too many elements in reference to array `%A' in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_MIXED_TYPES, WARN,\n-/* xgettext:no-c-format */\n-\"Mixed CHARACTER and non-CHARACTER types via COMMON/EQUIVALENCE -- for example, `%A' and `%B'\")\n-FFEBAD_MSG (FFEBAD_IMPLICIT_ADJLEN, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid length specification at %0 for IMPLICIT statement -- must be integer constant expression\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid length specification at %0\"))\n-FFEBAD_MSG (FFEBAD_ENTRY_CONFLICTS, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Type of ENTRY point at %0 to function conflicts with type(s) of previous entrypoint(s) -- must all be identical-length CHARACTER or none be CHARACTER type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Type of ENTRY point at %0 to function conflicts with type(s) of previous entrypoint(s)\"))\n-FFEBAD_MSG (FFEBAD_RETURN_VALUE_UNSET, WARN,\n-/* xgettext:no-c-format */\n-\"Return value `%A' for FUNCTION at %0 not referenced in subprogram\")\n-FFEBAD_MSG (FFEBAD_COMMON_ALREADY_INIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Common block `%A' initialized at %0 already initialized at %1 -- only one program unit may specify initial values for a particular common block\")\n-/* xgettext:no-c-format */\n-SHORT(\"Common block `%A' initialized at %0 already initialized at %1\"))\n-FFEBAD_MSG (FFEBAD_COMMON_INIT_PAD, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Initial padding for common block `%A' is %B %C at %0 -- consider reordering members, largest-type-size first\")\n-/* xgettext:no-c-format */\n-SHORT(\"Initial padding for common block `%A' is %B %C at %0\"))\n-FFEBAD_MSG (FFEBAD_COMMON_DIFF_PAD, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Initial padding for common block `%A' is %B %D at %0 but %C %E at %1 -- consider reordering members, largest-type-size first\")\n-/* xgettext:no-c-format */\n-SHORT(\"Initial padding for common block `%A' is %B %D at %0 but %C %E at %1\"))\n-FFEBAD_MSG (FFEBAD_COMMON_DIFF_SAVE, WARN,\n-/* xgettext:no-c-format */\n-\"Common block `%A' is SAVEd, explicitly or implicitly, at %0 but not SAVEd at %1\")\n-FFEBAD_MSG (FFEBAD_COMMON_DIFF_SIZE, WARN,\n-/* xgettext:no-c-format */\n-\"Common block `%A' is %B %D in length at %0 but %C %E at %1\")\n-FFEBAD_MSG (FFEBAD_COMMON_ENLARGED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Common block `%A' is initialized to %B %D long at %0 but enlarged to %C %E at %1 -- use consistent definitions or reorder program units in source file\")\n-/* xgettext:no-c-format */\n-SHORT(\"Common block `%A' is initialized to %B %D long at %0 but enlarged to %C %E at %1\"))\n-FFEBAD_MSG (FFEBAD_COMMON_BLANK_INIT, WARN,\n-/* xgettext:no-c-format */\n-\"Blank common initialized at %0\")\n-FFEBAD_MSG (FFEBAD_NEED_INTRINSIC, WARN,\n-/* xgettext:no-c-format */\n-\"Intrinsic `%A' is passed as actual argument at %0 but not explicitly declared INTRINSIC\")\n-FFEBAD_MSG (FFEBAD_NEED_EXTERNAL, WARN,\n-/* xgettext:no-c-format */\n-\"External procedure `%A' is passed as actual argument at %0 but not explicitly declared EXTERNAL\")\n-FFEBAD_MSG (FFEBAD_SYMBOL_UPPER_CASE, WARN,\n-/* xgettext:no-c-format */\n-\"Character `%A' (for example) is upper-case in symbol name at %0\")\n-FFEBAD_MSG (FFEBAD_SYMBOL_LOWER_CASE, WARN,\n-/* xgettext:no-c-format */\n-\"Character `%A' (for example) is lower-case in symbol name at %0\")\n-FFEBAD_MSG (FFEBAD_SYMBOL_NOLOWER_INITCAP, WARN,\n-/* xgettext:no-c-format */\n-\"Character `%A' not followed at some point by lower-case character in symbol name at %0\")\n-FFEBAD_MSG (FFEBAD_SYMBOL_LOWER_INITCAP, WARN,\n-/* xgettext:no-c-format */\n-\"Initial character `%A' is lower-case in symbol name at %0\")\n-FFEBAD_MSG (FFEBAD_DO_REAL, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"DO-variable `%A' is type REAL or DOUBLE PRECISION at %0 -- unexpected behavior likely\")\n-/* xgettext:no-c-format */\n-SHORT(\"DO-variable `%A' is type REAL or DOUBLE PRECISION at %0\"))\n-FFEBAD_MSG (FFEBAD_NAMELIST_CASE, WARN,\n-/* xgettext:no-c-format */\n-\"NAMELIST not adequately supported by run-time library for source files with case preserved\")\n-FFEBAD_MSG (FFEBAD_NESTED_PERCENT, WARN,\n-/* xgettext:no-c-format */\n-\"Nested %% construct (%%VAL, %%REF, or %%DESCR) at %0\")\n-FFEBAD_MSG (FFEBAD_ACTUALARG, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid actual argument at %0 -- replace hollerith constants with %%REF('string') and typeless constants with INTEGER constant equivalents, or use -fugly-args or -fugly\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid actual argument at %0\"))\n-FFEBAD_MSG (FFEBAD_QUAD_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Quadruple-precision floating-point unsupported -- treating constant at %0 as double-precision\")\n-/* xgettext:no-c-format */\n-SHORT(\"Quadruple-precision floating-point unsupported\"))\n-FFEBAD_MSG (FFEBAD_TOO_BIG_INIT, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Initialization of large (%B-unit) aggregate area `%A' at %0 slow and takes lots of memory during g77 compile\")\n-/* xgettext:no-c-format */\n-SHORT(\"This could take a while (initializing `%A' at %0)...\"))\n-FFEBAD_MSG (FFEBAD_BLOCKDATA_STMT, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 invalid in BLOCK DATA program unit at %1\")\n-FFEBAD_MSG (FFEBAD_TRUNCATING_CHARACTER, FATAL,\n-/* xgettext:no-c-format */\n-\"Truncating characters on right side of character constant at %0\")\n-FFEBAD_MSG (FFEBAD_TRUNCATING_HOLLERITH, FATAL,\n-/* xgettext:no-c-format */\n-\"Truncating characters on right side of hollerith constant at %0\")\n-FFEBAD_MSG (FFEBAD_TRUNCATING_NUMERIC, FATAL,\n-/* xgettext:no-c-format */\n-\"Truncating non-zero data on left side of numeric constant at %0\")\n-FFEBAD_MSG (FFEBAD_TRUNCATING_TYPELESS, FATAL,\n-/* xgettext:no-c-format */\n-\"Truncating non-zero data on left side of typeless constant at %0\")\n-FFEBAD_MSG (FFEBAD_TYPELESS_OVERFLOW, FATAL,\n-/* xgettext:no-c-format */\n-\"Typeless constant at %0 too large\")\n-FFEBAD_MSG (FFEBAD_AMPERSAND, WARN,\n-/* xgettext:no-c-format */\n-\"First-column ampersand continuation at %0\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_ALREADY_SEEN, FATAL,\n-/* xgettext:no-c-format */\n-\"Global name `%A' defined at %0 already defined at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_ALREADY_SEEN_W, WARN,\n-/* xgettext:no-c-format */\n-\"Global name `%A' defined at %0 already defined at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_DISAGREEMENT, FATAL,\n-/* xgettext:no-c-format */\n-\"Global name `%A' is %B at %0 but is %C at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_DISAGREEMENT_W, WARN,\n-/* xgettext:no-c-format */\n-\"Global name `%A' is %B at %0 but is %C at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_TYPE_MISMATCH, FATAL,\n-/* xgettext:no-c-format */\n-\"Global name `%A' at %0 has different type at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_TYPE_MISMATCH_W, WARN,\n-/* xgettext:no-c-format */\n-\"Global name `%A' at %0 has different type at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_NARGS, FATAL,\n-/* xgettext:no-c-format */\n-\"Too %B arguments passed to `%A' at %0 versus definition at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_NARGS_W, WARN,\n-/* xgettext:no-c-format */\n-\"Too %B arguments for `%A' at %0 versus invocation at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_ARG, FATAL,\n-/* xgettext:no-c-format */\n-\"Argument #%B of `%A' is %C at %0 but is %D at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_ARG_W, WARN,\n-/* xgettext:no-c-format */\n-\"Argument #%B of `%A' is %C at %0 but is %D at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_ARRAY_LARGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Array `%A' at %0 is too large to handle\")\n-FFEBAD_MSG (FFEBAD_SFUNC_UNUSED, WARN,\n-/* xgettext:no-c-format */\n-\"Statement function `%A' defined at %0 is not used\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_Y2KBAD, WARN,\n-/* xgettext:no-c-format */\n-\"Intrinsic `%A', invoked at %0, known to be non-Y2K-compliant [info -f g77 M Y2KBAD]\")\n-FFEBAD_MSG (FFEBAD_NOCANDO, DISASTER,\n-/* xgettext:no-c-format */\n-\"Internal compiler error -- cannot perform operation\")\n-\n-#undef INFORM\n-#undef TRIVIAL\n-#undef WARN\n-#undef PECULIAR\n-#undef FATAL\n-#undef WEIRD\n-#undef SEVERE\n-#undef DISASTER"}, {"sha": "bd7581e50d95587e74e4c3bdf475c62c41ca78ff", "filename": "gcc/f/bad.h", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,106 +0,0 @@\n-/* bad.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 2002 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bad.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_BAD_H\n-#define GCC_F_BAD_H\n-\n-/* Simple definitions and enumerations. */\n-\n-typedef enum\n-  {\n-#define FFEBAD_MSG(KWD,SEV,MSG) KWD,\n-#include \"bad.def\"\n-#undef FFEBAD_MSG\n-    FFEBAD\n-  } ffebad;\n-\n-typedef enum\n-  {\n-\n-    /* Order important; must be increasing severity. */\n-\n-    FFEBAD_severityINFORMATIONAL,\t/* User notice. */\n-    FFEBAD_severityTRIVIAL,\t/* Internal notice. */\n-    FFEBAD_severityWARNING,\t/* User warning. */\n-    FFEBAD_severityPECULIAR,\t/* Internal warning. */\n-    FFEBAD_severityPEDANTIC,\t/* Pedantic, could be warning or error. */\n-    FFEBAD_severityFATAL,\t/* User error. */\n-    FFEBAD_severityWEIRD,\t/* Internal error. */\n-    FFEBAD_severitySEVERE,\t/* User error, cannot continue. */\n-    FFEBAD_severityDISASTER,\t/* Internal error, cannot continue. */\n-    FFEBAD_severity\n-  } ffebadSeverity;\n-\n-/* Typedefs. */\n-\n-typedef unsigned char ffebadIndex;\n-\n-/* Include files needed by this one. */\n-\n-#include \"where.h\"\n-\n-/* Structure definitions. */\n-\n-\n-/* Global objects accessed by users of this module. */\n-\n-extern bool ffebad_is_inhibited_;\n-\n-/* Declare functions with prototypes. */\n-\n-void ffebad_finish (void);\n-void ffebad_here (ffebadIndex i, ffewhereLine wl, ffewhereColumn wc);\n-void ffebad_init_0 (void);\n-bool ffebad_is_fatal (ffebad errnum);\n-ffebadSeverity ffebad_severity (ffebad errnum);\n-bool ffebad_start_ (bool lex_override, ffebad errnum, ffebadSeverity sev,\n-\t\t    const char *msgid);\n-void ffebad_string (const char *string);\n-\n-/* Define macros. */\n-\n-#define ffebad_inhibit() (ffebad_is_inhibited_)\n-#define ffebad_init_1()\n-#define ffebad_init_2()\n-#define ffebad_init_3()\n-#define ffebad_init_4()\n-#define ffebad_set_inhibit(f) (ffebad_is_inhibited_ = (f))\n-#define ffebad_start(e) ffebad_start_ (FALSE, (e), FFEBAD_severity, NULL)\n-#define ffebad_start_lex(e) ffebad_start_ (TRUE, (e), FFEBAD_severity, NULL)\n-#define ffebad_start_msg(msgid,s) ffebad_start_ (FALSE, FFEBAD, (s), (msgid))\n-#define ffebad_start_msg_lex(msgid,s) ffebad_start_ (TRUE, FFEBAD, (s), (msgid))\n-#define ffebad_terminate_0()\n-#define ffebad_terminate_1()\n-#define ffebad_terminate_2()\n-#define ffebad_terminate_3()\n-#define ffebad_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_BAD_H */"}, {"sha": "00f064b1da22a6c545abd35781f7441cfbf4a3aa", "filename": "gcc/f/bit.c", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbit.c?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,200 +0,0 @@\n-/* bit.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-      None\n-\n-   Description:\n-      Tracks arrays of booleans in useful ways.\n-\n-   Modifications:\n-*/\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"bit.h\"\n-#include \"malloc.h\"\n-\n-/* Externals defined here. */\n-\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Internal typedefs. */\n-\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-\n-/* Static objects accessed by functions in this module. */\n-\n-\n-/* Static functions (internal). */\n-\n-\n-/* Internal macros. */\n-\f\n-\n-/* ffebit_count -- Count # of bits set a particular way\n-\n-   ffebit b;  // the ffebit object\n-   ffebitCount offset;\t// 0..size-1\n-   bool value;\t// FALSE (0), TRUE (1)\n-   ffebitCount range;  // # bits to test\n-   ffebitCount number;\t// # bits equal to value\n-   ffebit_count(b,offset,value,range,&number);\n-\n-   Sets <number> to # bits at <offset> through <offset + range - 1> set to\n-   <value>.  If <range> is 0, <number> is set to 0.  */\n-\n-void\n-ffebit_count (ffebit b, ffebitCount offset, bool value, ffebitCount range,\n-\t      ffebitCount *number)\n-{\n-  ffebitCount element;\n-  ffebitCount bitno;\n-\n-  assert (offset + range <= b->size);\n-\n-  for (*number = 0; range != 0; --range, ++offset)\n-    {\n-      element = offset / CHAR_BIT;\n-      bitno = offset % CHAR_BIT;\n-      if (value\n-\t  == ((b->bits[element] & ((unsigned char) 1 << bitno)) == 0 ? FALSE : TRUE))\n-\t++ * number;\n-    }\n-}\n-\n-/* ffebit_new -- Create a new ffebit object\n-\n-   ffebit b;\n-   ffebit_kill(b);\n-\n-   Destroys an ffebit object obtained via ffebit_new.  */\n-\n-void\n-ffebit_kill (ffebit b)\n-{\n-  malloc_kill_ks (b->pool, b,\n-\t\t  offsetof (struct _ffebit_, bits)\n-\t\t  + (b->size + CHAR_BIT - 1) / CHAR_BIT);\n-}\n-\n-/* ffebit_new -- Create a new ffebit object\n-\n-   ffebit b;\n-   mallocPool pool;\n-   ffebitCount size;\n-   b = ffebit_new(pool,size);\n-\n-   Allocates an ffebit object that holds the values of <size> bits in pool\n-   <pool>.  */\n-\n-ffebit\n-ffebit_new (mallocPool pool, ffebitCount size)\n-{\n-  ffebit b;\n-\n-  b = malloc_new_zks (pool, \"ffebit\",\n-\t\t      offsetof (struct _ffebit_, bits)\n-\t\t      + (size + CHAR_BIT - 1) / CHAR_BIT,\n-\t\t      0);\n-  b->pool = pool;\n-  b->size = size;\n-\n-  return b;\n-}\n-\n-/* ffebit_set -- Set value of # of bits\n-\n-   ffebit b;  // the ffebit object\n-   ffebitCount offset;\t// 0..size-1\n-   bool value;\t// FALSE (0), TRUE (1)\n-   ffebitCount length;\t// # bits to set starting at offset (usually 1)\n-   ffebit_set(b,offset,value,length);\n-\n-   Sets bit #s <offset> through <offset + length - 1> to <value>.  */\n-\n-void\n-ffebit_set (ffebit b, ffebitCount offset, bool value, ffebitCount length)\n-{\n-  ffebitCount i;\n-  ffebitCount element;\n-  ffebitCount bitno;\n-\n-  assert (offset + length <= b->size);\n-\n-  for (i = 0; i < length; ++i, ++offset)\n-    {\n-      element = offset / CHAR_BIT;\n-      bitno = offset % CHAR_BIT;\n-      b->bits[element] = (((unsigned char) (value ? 1 : 0)) << bitno)\n-\t| (b->bits[element] & ~((unsigned char) 1 << bitno));\n-    }\n-}\n-\n-/* ffebit_test -- Test value of # of bits\n-\n-   ffebit b;  // the ffebit object\n-   ffebitCount offset;\t// 0..size-1\n-   bool value;\t// FALSE (0), TRUE (1)\n-   ffebitCount length;\t// # bits with same value\n-   ffebit_test(b,offset,&value,&length);\n-\n-   Returns value of bits at <offset> through <offset + length - 1> in\n-   <value>.  If <offset> is already at the end of the bit array (if\n-   offset == ffebit_size(b)), <length> is set to 0 and <value> is\n-   undefined.  */\n-\n-void\n-ffebit_test (ffebit b, ffebitCount offset, bool *value, ffebitCount *length)\n-{\n-  ffebitCount i;\n-  ffebitCount element;\n-  ffebitCount bitno;\n-\n-  if (offset >= b->size)\n-    {\n-      assert (offset == b->size);\n-      *length = 0;\n-      return;\n-    }\n-\n-  element = offset / CHAR_BIT;\n-  bitno = offset % CHAR_BIT;\n-  *value = (b->bits[element] & ((unsigned char) 1 << bitno)) == 0 ? FALSE : TRUE;\n-  *length = 1;\n-\n-  for (i = b->size - offset - 1, ++offset; i != 0; --i, ++offset, ++*length)\n-    {\n-      element = offset / CHAR_BIT;\n-      bitno = offset % CHAR_BIT;\n-      if (*value\n-\t  != ((b->bits[element] & ((unsigned char) 1 << bitno)) == 0 ? FALSE : TRUE))\n-\tbreak;\n-    }\n-}"}, {"sha": "6b559efe668ea614ef35be324448cfa4968be4b1", "filename": "gcc/f/bit.h", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbit.h?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,84 +0,0 @@\n-/* bit.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bit.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_BIT_H\n-#define GCC_F_BIT_H\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Typedefs. */\n-\n-typedef struct _ffebit_ *ffebit;\n-typedef unsigned long ffebitCount;\n-#define ffebitCount_f \"l\"\n-\n-/* Include files needed by this one. */\n-\n-#include \"malloc.h\"\n-\n-/* Structure definitions. */\n-\n-struct _ffebit_\n-  {\n-    mallocPool pool;\n-    ffebitCount size;\n-    unsigned char bits[1];\n-  };\n-\n-/* Global objects accessed by users of this module. */\n-\n-\n-/* Declare functions with prototypes. */\n-\n-void ffebit_count (ffebit b, ffebitCount offset, bool value, ffebitCount range,\n-\t\t   ffebitCount *number);\n-void ffebit_kill (ffebit b);\n-ffebit ffebit_new (mallocPool pool, ffebitCount size);\n-void ffebit_set (ffebit b, ffebitCount offset, bool value, ffebitCount length);\n-void ffebit_test (ffebit b, ffebitCount offset, bool *value, ffebitCount *length);\n-\n-/* Define macros. */\n-\n-#define ffebit_init_0()\n-#define ffebit_init_1()\n-#define ffebit_init_2()\n-#define ffebit_init_3()\n-#define ffebit_init_4()\n-#define ffebit_pool(b) ((b)->pool)\n-#define ffebit_size(b) ((b)->size)\n-#define ffebit_terminate_0()\n-#define ffebit_terminate_1()\n-#define ffebit_terminate_2()\n-#define ffebit_terminate_3()\n-#define ffebit_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_BIT_H */"}, {"sha": "737dcc7e2f69541969c6ef54fe688c9aa633dc4f", "filename": "gcc/f/bld-op.def", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbld-op.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbld-op.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbld-op.def?ref=6c02751b14035a957cd17450909605fa973b3b27", "patch": "@@ -1,69 +0,0 @@\n-/* bld-op.def -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bad.c\n-\n-   Modifications:\n-*/\n-\n-FFEBLD_OP (FFEBLD_opANY, \"ANY\", 0)\n-FFEBLD_OP (FFEBLD_opSTAR, \"STAR\", 0)\t/* For adjustable arrays, alternate return dummies, etc. */\n-FFEBLD_OP (FFEBLD_opCONTER, \"CONTER\", 0)\n-FFEBLD_OP (FFEBLD_opARRTER, \"ARRTER\", 0)\t/* Array of constants (DATA...). */\n-FFEBLD_OP (FFEBLD_opACCTER, \"ACCTER\", 0)\t/* Accreting ARRTER. */\n-FFEBLD_OP (FFEBLD_opSYMTER, \"SYMTER\", 0)\n-FFEBLD_OP (FFEBLD_opITEM, \"ITEM\", 0)\n-FFEBLD_OP (FFEBLD_opUPLUS, \"UPLUS\", 1)\n-FFEBLD_OP (FFEBLD_opUMINUS, \"UMINUS\", 1)\n-FFEBLD_OP (FFEBLD_opADD, \"ADD\", 2)\n-FFEBLD_OP (FFEBLD_opSUBTRACT, \"SUBTRACT\", 2)\n-FFEBLD_OP (FFEBLD_opMULTIPLY, \"MULTIPLY\", 2)\n-FFEBLD_OP (FFEBLD_opDIVIDE, \"DIVIDE\", 2)\n-FFEBLD_OP (FFEBLD_opPOWER, \"POWER\", 2)\n-FFEBLD_OP (FFEBLD_opCONCATENATE, \"CONCATENATE\", 2)\n-FFEBLD_OP (FFEBLD_opNOT, \"NOT\", 1)\n-FFEBLD_OP (FFEBLD_opLT, \"LT\", 2)\n-FFEBLD_OP (FFEBLD_opLE, \"LE\", 2)\n-FFEBLD_OP (FFEBLD_opEQ, \"EQ\", 2)\n-FFEBLD_OP (FFEBLD_opNE, \"NE\", 2)\n-FFEBLD_OP (FFEBLD_opGT, \"GT\", 2)\n-FFEBLD_OP (FFEBLD_opGE, \"GE\", 2)\n-FFEBLD_OP (FFEBLD_opAND, \"AND\", 2)\n-FFEBLD_OP (FFEBLD_opOR, \"OR\", 2)\n-FFEBLD_OP (FFEBLD_opXOR, \"XOR\", 2)\n-FFEBLD_OP (FFEBLD_opEQV, \"EQV\", 2)\n-FFEBLD_OP (FFEBLD_opNEQV, \"NEQV\", 2)\n-FFEBLD_OP (FFEBLD_opPAREN, \"PAREN\", 1)\n-FFEBLD_OP (FFEBLD_opPERCENT_LOC, \"%LOC\", 1)\n-FFEBLD_OP (FFEBLD_opPERCENT_VAL, \"%VAL\", 1)\n-FFEBLD_OP (FFEBLD_opPERCENT_REF, \"%REF\", 1)\n-FFEBLD_OP (FFEBLD_opPERCENT_DESCR, \"%DESCR\", 1)\n-FFEBLD_OP (FFEBLD_opCONVERT, \"CONVERT\", 1)\n-FFEBLD_OP (FFEBLD_opREPEAT, \"REPEAT\", 2)\n-FFEBLD_OP (FFEBLD_opBOUNDS, \"BOUNDS\", 2)\t/* For low:high in dimension lists. */\n-FFEBLD_OP (FFEBLD_opFUNCREF, \"FUNCREF\", 2)\n-FFEBLD_OP (FFEBLD_opSUBRREF, \"SUBRREF\", 2)\n-FFEBLD_OP (FFEBLD_opARRAYREF, \"ARRAYREF\", 2)\n-FFEBLD_OP (FFEBLD_opSUBSTR, \"SUBSTR\", 2)\n-FFEBLD_OP (FFEBLD_opLABTER, \"LABTER\", 0)\n-FFEBLD_OP (FFEBLD_opLABTOK, \"LABTOK\", 0)\t/* Like LABTER but contains ffelexToken instead. */\n-FFEBLD_OP (FFEBLD_opIMPDO, \"IMPDO\", 2)"}, {"sha": "ec7c5cd683e3958f6c86210a39dae0c4762ff234", "filename": "gcc/f/bld.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbld.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "900b5dea01990331c6632abb40945b949a36b3d8", "filename": "gcc/f/bld.h", "status": "removed", "additions": 0, "deletions": 748, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbld.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "fdc4f159deba11e940ed0902ac168bc6216b65d8", "filename": "gcc/f/bugs.texi", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbugs.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbugs.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbugs.texi?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "9636f4da3d4d0ce9111b7d689f1d5a8d98e618d7", "filename": "gcc/f/bugs0.texi", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbugs0.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fbugs0.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbugs0.texi?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "185aef52d0582dea9c3159a1582f6cbb0d08c957", "filename": "gcc/f/com-rt.def", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fcom-rt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fcom-rt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom-rt.def?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "a64ef86b17240a57b9e498957a6f9dde7518c3b8", "filename": "gcc/f/com.c", "status": "removed", "additions": 0, "deletions": 16525, "changes": 16525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "d23db6687a2f36c9037c81e180290655d8eb7a1b", "filename": "gcc/f/com.h", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fcom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fcom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "92ba5cca73e84e106b6b6c5cb8908ae34e48e4ce", "filename": "gcc/f/config-lang.in", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fconfig-lang.in?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "2040f0ab6dc21304d6b6b92aa9e65a3335b61d2c", "filename": "gcc/f/data.c", "status": "removed", "additions": 0, "deletions": 1877, "changes": 1877, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fdata.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "a99369d0b0407b0076d9a5178a32018dfaa17294", "filename": "gcc/f/data.h", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fdata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fdata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fdata.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "bd7ac6d4d24fdb64a8a14bcd351fabf8bacbbddb", "filename": "gcc/f/equiv.c", "status": "removed", "additions": 0, "deletions": 1484, "changes": 1484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fequiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fequiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fequiv.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "59abfc875ca248c19a31fa8c315858ad35c2148c", "filename": "gcc/f/equiv.h", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fequiv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fequiv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fequiv.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "ef7661dc3ec3e95e60099e5b716b406fa3b17e3d", "filename": "gcc/f/expr.c", "status": "removed", "additions": 0, "deletions": 18571, "changes": 18571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fexpr.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "b82173bbf0e7453e2c3659853e1952df02164894", "filename": "gcc/f/expr.h", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fexpr.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "fd5d3bf349ae7d7d0e6ff4b512ace5bb64b2f1c9", "filename": "gcc/f/ffe.texi", "status": "removed", "additions": 0, "deletions": 2063, "changes": 2063, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fffe.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fffe.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fffe.texi?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "167837b461f30b12ee788dcee97d31dfb475dd76", "filename": "gcc/f/fini.c", "status": "removed", "additions": 0, "deletions": 772, "changes": 772, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Ffini.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Ffini.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ffini.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "3d5f83d3da6aa48e35933fc2f47fa48e8a38aff7", "filename": "gcc/f/g77.texi", "status": "removed", "additions": 0, "deletions": 11848, "changes": 11848, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fg77.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fg77.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77.texi?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "3dca7bc44838d114b2d1543f362196425b87565f", "filename": "gcc/f/g77spec.c", "status": "removed", "additions": 0, "deletions": 541, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fg77spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fg77spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77spec.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "8793f62c4a73ccc8ad02b4304e85a74e5dcba137", "filename": "gcc/f/global.c", "status": "removed", "additions": 0, "deletions": 1586, "changes": 1586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fglobal.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "dc499df9eb7d47abcd6ae834b8fcc99535c1100d", "filename": "gcc/f/global.h", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fglobal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fglobal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fglobal.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "c7a28cbc42acc6e23bf459a1ce7bbf1a4dbe02a3", "filename": "gcc/f/implic.c", "status": "removed", "additions": 0, "deletions": 383, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fimplic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fimplic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fimplic.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "44fbfac4e4fa1d0bb6aea3bbe2150be4967a97dc", "filename": "gcc/f/implic.h", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fimplic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fimplic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fimplic.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "088d108f05539a9d1b416d3aaff07fb0d8d4cbf8", "filename": "gcc/f/info-b.def", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo-b.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo-b.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo-b.def?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "9e6052d61502655bc8f9a324ed2917816386da99", "filename": "gcc/f/info-k.def", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo-k.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo-k.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo-k.def?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "57e3f8c6d628146513ff98047fa54e1bb0850a51", "filename": "gcc/f/info-w.def", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo-w.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo-w.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo-w.def?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "3c0030f27f8f172514fb5a3719d1c473f9227452", "filename": "gcc/f/info.c", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "69defd27ab633f0e61e692dc913d3ea2e4392362", "filename": "gcc/f/info.h", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "b24c79a481141ffc1da82bc90dd853dcb7c843a4", "filename": "gcc/f/intdoc.c", "status": "removed", "additions": 0, "deletions": 1325, "changes": 1325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintdoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintdoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "6f2423f6cac6f8f3a8288b853034413c5e9a6034", "filename": "gcc/f/intdoc.in", "status": "removed", "additions": 0, "deletions": 2705, "changes": 2705, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintdoc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintdoc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.in?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "e657510a0608136453ecbbdc0eda530f770db796", "filename": "gcc/f/intdoc.texi", "status": "removed", "additions": 0, "deletions": 10931, "changes": 10931, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintdoc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintdoc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.texi?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "a379684ae4c2c229c2053b0426906f1847cd46a3", "filename": "gcc/f/intrin.c", "status": "removed", "additions": 0, "deletions": 2119, "changes": 2119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintrin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintrin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "5d712ba21c0286abc85fccbf6d6d07b1ff2f05af", "filename": "gcc/f/intrin.def", "status": "removed", "additions": 0, "deletions": 3358, "changes": 3358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintrin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintrin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.def?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "e741e69b4ecefa6e6861143a4aaa253a83dd330a", "filename": "gcc/f/intrin.h", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Fintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "fd1b80412a64c8503976b3fe45f36a79ed3caad6", "filename": "gcc/f/invoke.texi", "status": "removed", "additions": 0, "deletions": 2233, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finvoke.texi?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "1d278748b21d02bf3e80ee10c8d8f3be48a26ee6", "filename": "gcc/f/lab.c", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Flab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Flab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flab.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "f3f89868a546b9f612236ae621832f7bdbaf6773", "filename": "gcc/f/lab.h", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Flab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Flab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flab.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "9ed51ef5a60c015d874fdda83f4afcbf66068565", "filename": "gcc/f/lang-specs.h", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flang-specs.h?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "d6a53b7dcd13be1502ef66833507792c97d55e24", "filename": "gcc/f/lang.opt", "status": "removed", "additions": 0, "deletions": 402, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ff%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flang.opt?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "c5242446a4987f46b1d188540b3639880a437c0e", "filename": "gcc/testsuite/g77.f-torture/execute/io1.f", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fio1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fio1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fio1.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "6a69a3aadabe8c961e589e941a0119293b909f14", "filename": "gcc/testsuite/g77.f-torture/execute/io1.x", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fio1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fio1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fio1.x?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "032fa41f8998b3e2c04812aae7ff57a70a42131b", "filename": "gcc/testsuite/g77.f-torture/execute/labug1.f", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Flabug1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Flabug1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Flabug1.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "0af5b1b0b3f016e0ef7e65390f4e84eb7f5abc37", "filename": "gcc/testsuite/g77.f-torture/execute/large_vec.f", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Flarge_vec.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Flarge_vec.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Flarge_vec.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "74e42750d55f3f72075236ca28d8ba5563ba4e73", "filename": "gcc/testsuite/g77.f-torture/execute/le.f", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fle.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fle.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fle.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "f1024330a71278aebca915378ab526c240c2f4dc", "filename": "gcc/testsuite/g77.f-torture/execute/select.f", "status": "removed", "additions": 0, "deletions": 173, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fselect.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fselect.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fselect.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "89ae273891cd7d9ddbc6630603dae438329d0356", "filename": "gcc/testsuite/g77.f-torture/execute/short.f", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fshort.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fshort.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fshort.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "f502bc7283395da4b5b98074c21120c355cd6805", "filename": "gcc/testsuite/g77.f-torture/execute/u77-test.f", "status": "removed", "additions": 0, "deletions": 421, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "e4b89008c25e35e88732b25ec06f07e0469bc82a", "filename": "gcc/testsuite/g77.f-torture/execute/u77-test.x", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fu77-test.x?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "0cc9087d6cb413227b3ffdcf0da03744eb0d24af", "filename": "gcc/testsuite/g77.f-torture/noncompile/19981216-0.f", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19981216-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19981216-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19981216-0.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "25b7c5b2b52c335a3ab99877fafba181dda5d0fd", "filename": "gcc/testsuite/g77.f-torture/noncompile/19990218-1.f", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990218-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990218-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990218-1.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "86d2a939064bd69e9f4789dca137284a2157b9f7", "filename": "gcc/testsuite/g77.f-torture/noncompile/19990826-4.f", "status": "removed", "additions": 0, "deletions": 648, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990826-4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990826-4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990826-4.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "026d05e4b3ce819aeef9a46c795205ebd4fba542", "filename": "gcc/testsuite/g77.f-torture/noncompile/19990905-1.f", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990905-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990905-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990905-1.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "e68b3e0a65fffad771b183d1f129c8b3d2031c6d", "filename": "gcc/testsuite/g77.f-torture/noncompile/9263.f", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F9263.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F9263.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F9263.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "c1e2348646f7b2668413b0506c4df98646b23a19", "filename": "gcc/testsuite/g77.f-torture/noncompile/970626-2.f", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F970626-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F970626-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F970626-2.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "316969f6aa818902512482913b6e158d4e416e91", "filename": "gcc/testsuite/g77.f-torture/noncompile/980615-0.f", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F980615-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F980615-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F980615-0.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "bd5e74022a3f307e25881a5421cbd172472bbbbe", "filename": "gcc/testsuite/g77.f-torture/noncompile/980616-0.f", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F980616-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F980616-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F980616-0.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "fc3c6ca730e2b531e2dfa26f511123d40a25ea4d", "filename": "gcc/testsuite/g77.f-torture/noncompile/check0.f", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fcheck0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fcheck0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fcheck0.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "fadd1fbbe5af4f83c93195c87c567485dbe67ee5", "filename": "gcc/testsuite/g77.f-torture/noncompile/noncompile.exp", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fnoncompile.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fnoncompile.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fnoncompile.exp?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "f7dad339a8158bd92917785b44af49a9df56d04e", "filename": "gcc/testsuite/g77.f-torture/noncompile/select_no_compile.f", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fselect_no_compile.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fselect_no_compile.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2Fselect_no_compile.f?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "495e3e9c5a5f4d813e26569ace9d41e7093a9507", "filename": "libjava/doc/cni.sgml", "status": "removed", "additions": 0, "deletions": 996, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fdoc%2Fcni.sgml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fdoc%2Fcni.sgml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fcni.sgml?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "c98549b4059f0e9b6474b0189b5c78cbfc6ad16b", "filename": "libjava/gnu/javax/rmi/CORBA/DelegateFactory.java", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FDelegateFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FDelegateFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FDelegateFactory.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "27b84f122395d140c3137e2583215c3c0197d050", "filename": "libjava/gnu/javax/rmi/CORBA/GetDelegateInstanceException.java", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FGetDelegateInstanceException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FGetDelegateInstanceException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FGetDelegateInstanceException.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "973c4c4f89fdf294807384f1c3b0db8f8ce43a9d", "filename": "libjava/gnu/javax/rmi/CORBA/PortableRemoteObjectDelegateImpl.java", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FPortableRemoteObjectDelegateImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FPortableRemoteObjectDelegateImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FPortableRemoteObjectDelegateImpl.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "894e50236fd0c010964abacf450043b25c919719", "filename": "libjava/gnu/javax/rmi/CORBA/StubDelegateImpl.java", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FStubDelegateImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FStubDelegateImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FStubDelegateImpl.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "70b2e60c673e5761e80b099e4f93780973183d9d", "filename": "libjava/gnu/javax/rmi/CORBA/UtilDelegateImpl.java", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FUtilDelegateImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FUtilDelegateImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FUtilDelegateImpl.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "6935aa68c4c92da85e05b39987aff3c662da70ea", "filename": "libjava/gnu/javax/rmi/CORBA/ValueHandlerImpl.java", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FValueHandlerImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FValueHandlerImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjavax%2Frmi%2FCORBA%2FValueHandlerImpl.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "b5022cab7b391df8625cd97e4583ac580ba47c38", "filename": "libjava/gnu/javax/rmi/PortableServer.java", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FPortableServer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fgnu%2Fjavax%2Frmi%2FPortableServer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjavax%2Frmi%2FPortableServer.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "36081a47c57bc37f373d7328a67339710812880f", "filename": "libjava/javax/rmi/BAD_OPERATION.java", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FBAD_OPERATION.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FBAD_OPERATION.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FBAD_OPERATION.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "052046df9262b79184767cdba631167cbb2c6e75", "filename": "libjava/javax/rmi/CORBA/ClassDesc.java", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FClassDesc.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FClassDesc.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FClassDesc.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "d76d673cedef94e5953106aae2449c921378090e", "filename": "libjava/javax/rmi/CORBA/ObjectImpl.java", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FObjectImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FObjectImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FObjectImpl.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "a073cf4705cbb24359744878ea3055f6d1227c60", "filename": "libjava/javax/rmi/CORBA/PortableRemoteObjectDelegate.java", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FPortableRemoteObjectDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FPortableRemoteObjectDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FPortableRemoteObjectDelegate.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "c79b85cb46e5a1e274f22dd179c4193d03b172ad", "filename": "libjava/javax/rmi/CORBA/Stub.java", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FStub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FStub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FStub.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "6c7f69fe7dcd94bf90ef6a5d3a9884513b83022d", "filename": "libjava/javax/rmi/CORBA/StubDelegate.java", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FStubDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FStubDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FStubDelegate.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "f8afdc35e35e68e77e90a87c69ee761782018db4", "filename": "libjava/javax/rmi/CORBA/SystemException.java", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FSystemException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FSystemException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FSystemException.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "ca14e3d42360387af26056122704c7df6acfbdc2", "filename": "libjava/javax/rmi/CORBA/Tie.java", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FTie.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FTie.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FTie.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "45a189d97c5d5899bccf3e22d8de5a463a174429", "filename": "libjava/javax/rmi/CORBA/Util.java", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FUtil.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FUtil.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FUtil.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "4d611bc8bfb6e2f396992b0085c2ffe7b66fe1b4", "filename": "libjava/javax/rmi/CORBA/UtilDelegate.java", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FUtilDelegate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FUtilDelegate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FUtilDelegate.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "3a008f18cca2d93112ec85aeee7c9e91e1411fb3", "filename": "libjava/javax/rmi/CORBA/ValueHandler.java", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FValueHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FCORBA%2FValueHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FCORBA%2FValueHandler.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "be7a894e65af353c53162e7b3878bb225607b3be", "filename": "libjava/javax/rmi/ORB.java", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FORB.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FORB.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FORB.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "ee40d9c9e74e51ba252292f8b9e419536e442e4e", "filename": "libjava/javax/rmi/PortableRemoteObject.java", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FPortableRemoteObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libjava%2Fjavax%2Frmi%2FPortableRemoteObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Frmi%2FPortableRemoteObject.java?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "d34c8daf9c95f08aeb385e06fadb8dd256718efa", "filename": "libstdc++-v3/testsuite/20_util/allocator/1.cc", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F1.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "2ac77eaaf16e0febd3b371d68350426b571fca8f", "filename": "libstdc++-v3/testsuite/20_util/allocator/10378.cc", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F10378.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F10378.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F10378.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "cb8a2f5c4bf81c630a8dbcc583388341cc2f7a90", "filename": "libstdc++-v3/testsuite/20_util/allocator/14176.cc", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F14176.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F14176.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F14176.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "95b6cbee55fb8b2b09ade1a49d89686546576f35", "filename": "libstdc++-v3/testsuite/20_util/allocator/8230.cc", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F8230.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F8230.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F8230.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "8e150b0187ce002595817e3fc1d685d72a99eb6e", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/1.cc", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F1.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "6ce31d1fe88c3fa1d2070b8f11791bf91cd1fc09", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/2.cc", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F2.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "8090d277783437912643912b6c5742e8628a4d1c", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/3.cc", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F3.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "191ba6f9306607d99ae610263729794f9e633626", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/3946.cc", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F3946.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F3946.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F3946.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "18148005573259d33af72901657e5860bf8669ce", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/4.cc", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F4.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "77969816496cfc14cf985fb3d9517a1a684b1d92", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/5.cc", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F5.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "e4e13d9d6b0d7b630ba69d02c4d439066f992de6", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/6.cc", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F6.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "a77ba51cb584b3d4b8e966b2aee520d11985807c", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/7.cc", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2F7.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "55291676f3d91f0d1da018b51880bf75a8736c62", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/assign_neg.cc", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2Fassign_neg.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "7ccee6dd569b89d637429159d8826a1c8e6d0e53", "filename": "libstdc++-v3/testsuite/20_util/pair/1.cc", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F1.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "82d928c2d01a7e1ed87c2280159764e9d9c0dfe3", "filename": "libstdc++-v3/testsuite/20_util/pair/2.cc", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F2.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "bac0e7eb9744e3771042885102c648644f85e63f", "filename": "libstdc++-v3/testsuite/20_util/pair/3.cc", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F3.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "f6a1b5697d78d24db8275109b2472ce54f52e100", "filename": "libstdc++-v3/testsuite/20_util/pair/4.cc", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F4.cc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "28d527f47f885e4cd957e1c2559f0ef74697b5cd", "filename": "zlib/contrib/asm386/gvmat32.asm", "status": "removed", "additions": 0, "deletions": 559, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "d853bb7ce8ab0b2b4a5aa37fc6ee567e6650bc78", "filename": "zlib/contrib/asm386/gvmat32c.c", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "6c5ffd7a024f70e7166474beabfc6710cbe38199", "filename": "zlib/contrib/asm386/mkgvmt32.bat", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "7e9d60d55d90d410e2d4b519f8bcfeb36027081c", "filename": "zlib/contrib/asm386/zlibvc.def", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "a70d4d4a6b0ec6ad54f2966c42b445e9b8ded02b", "filename": "zlib/contrib/asm386/zlibvc.dsp", "status": "removed", "additions": 0, "deletions": 651, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "493cd870365a5cfb7e0725656d66c3b1d0b3dd21", "filename": "zlib/contrib/asm386/zlibvc.dsw", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "78bb254088a5b57eb578afd0fbcd9cbd3963a5b5", "filename": "zlib/contrib/delphi2/d_zlib.bpr", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "f5dea59b762332ad7f8f875637023b601af6647b", "filename": "zlib/contrib/delphi2/d_zlib.cpp", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "cbd31620d87b42a2b58f4cdb81741c10cdbb39bd", "filename": "zlib/contrib/delphi2/readme.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "b6c9acdf8c90fd799ea414d64fc42324fe55e1f4", "filename": "zlib/contrib/delphi2/zlib.bpg", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "cf3945b2523339928e570a643b1d866ecf15f6ba", "filename": "zlib/contrib/delphi2/zlib.bpr", "status": "removed", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "bf6953ba1985710b5b96db20abdf46d3c12c14d1", "filename": "zlib/contrib/delphi2/zlib.cpp", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "10ae4cae2568638dfb9c250392da6f3700a5219e", "filename": "zlib/contrib/delphi2/zlib.pas", "status": "removed", "additions": 0, "deletions": 534, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "cabcec449474e2df0e805fc22375021126d355df", "filename": "zlib/contrib/delphi2/zlib32.bpr", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "7372f6b985f8d57538fca6bc0520f759c1f868f6", "filename": "zlib/contrib/delphi2/zlib32.cpp", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "2d475b1847e11f1ee53b44603a3c1000d55415f2", "filename": "zlib/nt/Makefile.emx", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fnt%2FMakefile.emx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fnt%2FMakefile.emx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.emx?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "cdd652f236028439ef45ebea059d36ccf526caec", "filename": "zlib/nt/Makefile.gcc", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fnt%2FMakefile.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fnt%2FMakefile.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.gcc?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "b250f2ac7d2aab67fa45ea00fff2ca4f8bf59ba8", "filename": "zlib/nt/Makefile.nt", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fnt%2FMakefile.nt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fnt%2FMakefile.nt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.nt?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "7f9475cfb0ee39b4653f03cc5d8a2ceb48ca1eec", "filename": "zlib/nt/zlib.dnt", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fnt%2Fzlib.dnt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fnt%2Fzlib.dnt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2Fzlib.dnt?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "4f569471ecab93be6d411066c7dc3ed647ec04cc", "filename": "zlib/os2/Makefile.os2", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fos2%2FMakefile.os2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fos2%2FMakefile.os2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fos2%2FMakefile.os2?ref=6c02751b14035a957cd17450909605fa973b3b27"}, {"sha": "4c753f1a3b993842030429bbdeccdb48f8a86ebe", "filename": "zlib/os2/zlib.def", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fos2%2Fzlib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c02751b14035a957cd17450909605fa973b3b27/zlib%2Fos2%2Fzlib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fos2%2Fzlib.def?ref=6c02751b14035a957cd17450909605fa973b3b27"}]}