{"sha": "00a8faa302f7eba507852e21fc85a5d5a9650494", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBhOGZhYTMwMmY3ZWJhNTA3ODUyZTIxZmM4NWE1ZDVhOTY1MDQ5NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-28T21:17:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-28T21:17:11Z"}, "message": "entered into RCS\n\nFrom-SVN: r852", "tree": {"sha": "0ea8832f82943bf8c960fc1dc2bbed507c992d48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ea8832f82943bf8c960fc1dc2bbed507c992d48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00a8faa302f7eba507852e21fc85a5d5a9650494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00a8faa302f7eba507852e21fc85a5d5a9650494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00a8faa302f7eba507852e21fc85a5d5a9650494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00a8faa302f7eba507852e21fc85a5d5a9650494/comments", "author": null, "committer": null, "parents": [{"sha": "4c561ce2f490bb4b55f9d9ab090fc1a88c2fe783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c561ce2f490bb4b55f9d9ab090fc1a88c2fe783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c561ce2f490bb4b55f9d9ab090fc1a88c2fe783"}], "stats": {"total": 200, "additions": 147, "deletions": 53}, "files": [{"sha": "5c3e03a3d6dce6ef183a42caf6e166ae847df244", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 147, "deletions": 53, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00a8faa302f7eba507852e21fc85a5d5a9650494/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00a8faa302f7eba507852e21fc85a5d5a9650494/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=00a8faa302f7eba507852e21fc85a5d5a9650494", "patch": "@@ -83,17 +83,21 @@\n \n (define_insn \"cmpdf\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"gF\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"gF\")))]\n+\t(compare (match_operand:DF 0 \"general_operand\" \"gF,gF\")\n+\t\t (match_operand:DF 1 \"general_operand\" \"G,gF\")))]\n   \"\"\n-  \"cmp%# %0,%1\")\n+  \"@\n+   tst%# %0\n+   cmp%# %0,%1\")\n \n (define_insn \"cmpsf\"\n   [(set (cc0)\n-\t(compare (match_operand:SF 0 \"general_operand\" \"gF\")\n-\t\t (match_operand:SF 1 \"general_operand\" \"gF\")))]\n+\t(compare (match_operand:SF 0 \"general_operand\" \"gF,gF\")\n+\t\t (match_operand:SF 1 \"general_operand\" \"G,gF\")))]\n   \"\"\n-  \"cmpf %0,%1\")\n+  \"@\n+   tstf %0\n+   cmpf %0,%1\")\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -173,6 +177,23 @@\n    clrq %0\n    movq %1,%0\")\n \n+;; The VAX move instructions have space-time tradeoffs.  On a microVAX\n+;; register-register mov instructions take 3 bytes and 2 CPU cycles.  clrl\n+;; takes 2 bytes and 3 cycles.  mov from constant to register takes 2 cycles\n+;; if the constant is smaller than 4 bytes, 3 cycles for a longword\n+;; constant.  movz, mneg, and mcom are as fast as mov, so movzwl is faster\n+;; than movl for positive constants that fit in 16 bits but not 6 bits.  cvt\n+;; instructions take 4 cycles.  inc takes 3 cycles.  The machine description\n+;; is willing to trade 1 byte for 1 cycle (clrl instead of movl $0; cvtwl\n+;; instead of movl).\n+\n+;; Cycle counts for other models may vary (on a VAX 750 they are similar,\n+;; but on a VAX 9000 most move and add instructions with one constant\n+;; operand take 1 cycle).\n+\n+;;  Loads of constants between 64 and 128 used to be done with\n+;; \"addl3 $63,#,dst\" but this is slower than movzbl and takes as much space.\n+\n (define_insn \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(match_operand:SI 1 \"general_operand\" \"g\"))]\n@@ -187,33 +208,21 @@\n       && GET_CODE (XEXP (link, 0)) != NOTE\n       /* Make sure cross jumping didn't happen here.  */\n       && no_labels_between_p (XEXP (link, 0), insn))\n-    /* Fastest way to change a 0 to a 1.  */\n     return \\\"incl %0\\\";\n   if (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n     {\n       if (push_operand (operands[0], SImode))\n \treturn \\\"pushab %a1\\\";\n       return \\\"movab %a1,%0\\\";\n     }\n-  /* this is slower than a movl, except when pushing an operand */\n   if (operands[1] == const0_rtx)\n     return \\\"clrl %0\\\";\n   if (GET_CODE (operands[1]) == CONST_INT\n       && (unsigned) INTVAL (operands[1]) >= 64)\n     {\n       int i = INTVAL (operands[1]);\n       if ((unsigned)(~i) < 64)\n-\t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, ~i);\n-\t  return \\\"mcoml %1,%0\\\";\n-\t}\n-      if ((unsigned)i < 127)\n-\t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, 63);\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, i-63);\n-\t  return \\\"addl3 %2,%1,%0\\\";\n-\t}\n-      /* trading speed for space */\n+\treturn \\\"mcoml %N1,%0\\\";\n       if ((unsigned)i < 0x100)\n \treturn \\\"movzbl %1,%0\\\";\n       if (i >= -0x80 && i < 0)\n@@ -242,30 +251,40 @@\n       && GET_CODE (XEXP (link, 0)) != NOTE\n       /* Make sure cross jumping didn't happen here.  */\n       && no_labels_between_p (XEXP (link, 0), insn))\n-    /* Fastest way to change a 0 to a 1.  */\n     return \\\"incw %0\\\";\n-  if (operands[1] == const0_rtx)\n-    return \\\"clrw %0\\\";\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && (unsigned) INTVAL (operands[1]) >= 64)\n+\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[1]);\n+      if (i == 0)\n+\treturn \\\"clrw %0\\\";\n+      else if ((unsigned int)i < 64)\n+\treturn \\\"movw %1,%0\\\";\n+      else if ((unsigned int)~i < 64)\n+\treturn \\\"mcomw %H1,%0\\\";\n+      else if ((unsigned int)i < 256)\n+\treturn \\\"movzbw %1,%0\\\";\n+    }\n+  return \\\"movw %1,%0\\\";\n+}\")\n+\n+(define_insn \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"=g\"))\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n     {\n       int i = INTVAL (operands[1]);\n-      if ((unsigned)((~i) & 0xffff) < 64)\n-\t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, (~i) & 0xffff);\n-\t  return \\\"mcomw %1,%0\\\";\n-\t}\n-      if ((unsigned)(i & 0xffff) < 127)\n-\t{\n-\t   operands[1] = gen_rtx (CONST_INT, VOIDmode, 63);\n-\t   operands[2] = gen_rtx (CONST_INT, VOIDmode, (i-63) & 0xffff);\n-\t   return \\\"addw3 %2,%1,%0\\\";\n-\t}\n-      /* this is a lot slower, and only saves 1 measly byte! */\n-      /* if ((unsigned)i < 0x100)\n-\t   return \\\"movzbw %1,%0\\\"; */\n-      /* if (i >= -0x80 && i < 0)\n-\t   return \\\"cvtbw %1,%0\\\"; */\n+      if (i == 0)\n+\treturn \\\"clrw %0\\\";\n+      else if ((unsigned int)i < 64)\n+\treturn \\\"movw %1,%0\\\";\n+      else if ((unsigned int)~i < 64)\n+\treturn \\\"mcomw %H1,%0\\\";\n+      else if ((unsigned int)i < 256)\n+\treturn \\\"movzbw %1,%0\\\";\n     }\n   return \\\"movw %1,%0\\\";\n }\")\n@@ -276,17 +295,40 @@\n   \"\"\n   \"*\n {\n-  if (operands[1] == const0_rtx)\n-    return \\\"clrb %0\\\";\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && (unsigned) INTVAL (operands[1]) >= 64)\n+  rtx link;\n+  if (operands[1] == const1_rtx\n+      && (link = find_reg_note (insn, REG_WAS_0, 0))\n+      /* Make sure the insn that stored the 0 is still present.  */\n+      && ! INSN_DELETED_P (XEXP (link, 0))\n+      && GET_CODE (XEXP (link, 0)) != NOTE\n+      /* Make sure cross jumping didn't happen here.  */\n+      && no_labels_between_p (XEXP (link, 0), insn))\n+    return \\\"incb %0\\\";\n+\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[1]);\n+      if (i == 0)\n+\treturn \\\"clrb %0\\\";\n+      else if ((unsigned int)~i < 64)\n+\treturn \\\"mcomb %B1,%0\\\";\n+    }\n+  return \\\"movb %1,%0\\\";\n+}\")\n+\n+(define_insn \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"=g\"))\n+\t(match_operand:QI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n     {\n       int i = INTVAL (operands[1]);\n-      if ((unsigned)((~i) & 0xff) < 64)\n-\t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, (~i) & 0xff);\n-\t  return \\\"mcomb %1,%0\\\";\n-\t}\n+      if (i == 0)\n+\treturn \\\"clrb %0\\\";\n+      else if ((unsigned int)~i < 64)\n+\treturn \\\"mcomb %B1,%0\\\";\n     }\n   return \\\"movb %1,%0\\\";\n }\")\n@@ -1285,21 +1327,48 @@\n   \"\"\n   \"cmpzv %2,%1,%0,%3\")\n \n+;; When the field position and size are constant and the destination\n+;; is a register, extv and extzv are much slower than a rotate followed\n+;; by a bicl or sign extension.\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(sign_extract:SI (match_operand:SI 1 \"nonmemory_operand\" \"r\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n \t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n   \"\"\n-  \"extv %3,%2,%1,%0\")\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) != CONST_INT || GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[0]) != REG\n+      || (INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16))\n+    return \\\"extv %3,%2,%1,%0\\\";\n+  if (INTVAL (operands[2]) == 8)\n+    return \\\"rotl %R3,%1,%0\\;cvtbl %0,%0\\\";\n+  return \\\"rotl %R3,%1,%0\\;cvtwl %0,%0\\\";\n+}\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(zero_extract:SI (match_operand:SI 1 \"nonmemory_operand\" \"r\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n \t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n   \"\"\n-  \"extzv %3,%2,%1,%0\")\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) != CONST_INT || GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[0]) != REG)\n+    return \\\"extzv %3,%2,%1,%0\\\";\n+  if (INTVAL (operands[2]) == 8)\n+    return \\\"rotl %R3,%1,%0\\;movzbl %0,%0\\\";\n+  if (INTVAL (operands[2]) == 16)\n+    return \\\"rotl %R3,%1,%0\\;movzwl %0,%0\\\";\n+  if (INTVAL (operands[3]) & 31)\n+    return \\\"rotl %R3,%1,%0\\;bicl2 %M2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"bicl2 %M2,%0\\\";\n+  return \\\"bicl3 %M2,%1,%0\\\";\n+}\")\n \n ;; Non-register cases.\n ;; nonimmediate_operand is used to make sure that mode-ambiguous cases\n@@ -1331,15 +1400,40 @@\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n \t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n   \"\"\n-  \"extv %3,%2,%1,%0\")\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[3]) != CONST_INT\n+      || (INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16)\n+      || side_effects_p (operands[1])\n+      || (GET_CODE (operands[1]) == MEM\n+\t  && mode_dependent_address_p (XEXP (operands[1], 0))))\n+    return \\\"extv %3,%2,%1,%0\\\";\n+  if (INTVAL (operands[2]) == 8)\n+    return \\\"rotl %R3,%1,%0\\;cvtbl %0,%0\\\";\n+  return \\\"rotl %R3,%1,%0\\;cvtwl %0,%0\\\";\n+}\")\n \n (define_insn \"extzv\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(zero_extract:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n \t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n   \"\"\n-  \"extzv %3,%2,%1,%0\")\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[3]) != CONST_INT\n+      || side_effects_p (operands[1])\n+      || (GET_CODE (operands[1]) == MEM\n+\t  && mode_dependent_address_p (XEXP (operands[1], 0))))\n+    return \\\"extzv %3,%2,%1,%0\\\";\n+  if (INTVAL (operands[2]) == 8)\n+    return \\\"rotl %R3,%1,%0\\;movzbl %0,%0\\\";\n+  if (INTVAL (operands[2]) == 16)\n+    return \\\"rotl %R3,%1,%0\\;movzwl %0,%0\\\";\n+  return \\\"rotl %R3,%1,%0\\;bicl2 %M2,%0\\\";\n+}\")\n \n (define_insn \"insv\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"+g\")"}]}