{"sha": "45d765871b6744d2fe519a61a1d15ff4d613388f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkNzY1ODcxYjY3NDRkMmZlNTE5YTYxYTFkMTVmZjRkNjEzMzg4Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-08-03T20:32:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-08-03T20:32:08Z"}, "message": "DR 1286\n\n\tDR 1286\n\t* pt.c (get_underlying_template): New.\n\t(convert_template_argument, lookup_template_class_1): Use it.\n\nFrom-SVN: r201470", "tree": {"sha": "9218647d81212608b0e192ef6ad5cce3a8330fe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9218647d81212608b0e192ef6ad5cce3a8330fe0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d765871b6744d2fe519a61a1d15ff4d613388f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d765871b6744d2fe519a61a1d15ff4d613388f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d765871b6744d2fe519a61a1d15ff4d613388f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d765871b6744d2fe519a61a1d15ff4d613388f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e356571d442ca5241117b05428fb5055b55d0aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e356571d442ca5241117b05428fb5055b55d0aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e356571d442ca5241117b05428fb5055b55d0aa"}], "stats": {"total": 139, "additions": 134, "deletions": 5}, "files": [{"sha": "5587ac1eb968d4c0cafe49a442353c4495d4ee57", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=45d765871b6744d2fe519a61a1d15ff4d613388f", "patch": "@@ -1,5 +1,9 @@\n 2013-08-03  Jason Merrill  <jason@redhat.com>\n \n+\tDR 1286\n+\t* pt.c (get_underlying_template): New.\n+\t(convert_template_argument, lookup_template_class_1): Use it.\n+\n \tDR 1430\n \tPR c++/51239\n \t* pt.c (pack_expansion_args_count): Rename from"}, {"sha": "d03c1cf9e910365f8e35c557f50ae48de43e9a0e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=45d765871b6744d2fe519a61a1d15ff4d613388f", "patch": "@@ -5111,6 +5111,34 @@ alias_template_specialization_p (const_tree t)\n \t  && DECL_ALIAS_TEMPLATE_P (TYPE_TI_TEMPLATE (t)));\n }\n \n+/* Return either TMPL or another template that it is equivalent to under DR\n+   1286: An alias that just changes the name of a template is equivalent to\n+   the other template.  */\n+\n+static tree\n+get_underlying_template (tree tmpl)\n+{\n+  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n+  while (DECL_ALIAS_TEMPLATE_P (tmpl))\n+    {\n+      tree result = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n+      if (TYPE_TEMPLATE_INFO (result))\n+\t{\n+\t  tree sub = TYPE_TI_TEMPLATE (result);\n+\t  if (PRIMARY_TEMPLATE_P (sub)\n+\t      && same_type_p (result, TREE_TYPE (sub)))\n+\t    {\n+\t      /* The alias type is equivalent to the pattern of the\n+\t\t underlying template, so strip the alias.  */\n+\t      tmpl = sub;\n+\t      continue;\n+\t    }\n+\t}\n+      break;\n+    }\n+  return tmpl;\n+}\n+\n /* Subroutine of convert_nontype_argument. Converts EXPR to TYPE, which\n    must be a function or a pointer-to-function type, as specified\n    in [temp.arg.nontype]: disambiguate EXPR if it is an overload set,\n@@ -6319,6 +6347,9 @@ convert_template_argument (tree parm,\n \t      tree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n \t      tree argparm;\n \n+\t      /* Strip alias templates that are equivalent to another\n+\t\t template.  */\n+\t      arg = get_underlying_template (arg);\n               argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n \n \t      if (coerce_template_template_parms (parmparm, argparm,\n@@ -7177,6 +7208,13 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \n   complain &= ~tf_user;\n \n+  /* An alias that just changes the name of a template is equivalent to the\n+     other template, so if any of the arguments are pack expansions, strip\n+     the alias to avoid problems with a pack expansion passed to a non-pack\n+     alias template parameter (DR 1430).  */\n+  if (pack_expansion_args_count (INNERMOST_TEMPLATE_ARGS (arglist)))\n+    templ = get_underlying_template (templ);\n+\n   if (DECL_TEMPLATE_TEMPLATE_PARM_P (templ))\n     {\n       /* Create a new TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM node to store"}, {"sha": "f38f9932b44e1e9ab85fd4a61190eedab8c8ab1d", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-0.C", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-0.C?ref=45d765871b6744d2fe519a61a1d15ff4d613388f", "patch": "@@ -10,14 +10,13 @@ void g(X<Z>);\n void\n foo()\n {\n-    // Below x and y don't have the same type, because Y and Z don't\n-    // designate the same template ...\n+    // Below x and y have the same type (DR 1286)\n     X<Y> y; \n     X<Z> z;\n \n-    // ... So these must fail to compile.\n-    f(z);   // { dg-error \"\" }\n-    g(y);   // { dg-error \"\" }\n+    // ... So these must compile.\n+    f(z);   // { dg-bogus \"\" }\n+    g(y);   // { dg-bogus \"\" }\n }\n \n template<class> struct A0 {};"}, {"sha": "a1c442eabeba80b01559a2bc558db87ac5080ade", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-33a.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-33a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-33a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-33a.C?ref=45d765871b6744d2fe519a61a1d15ff4d613388f", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/51239\n+// { dg-require-effective-target c++11 }\n+// This variant should work because tail is equivalent to list.\n+\n+template<class y, class... x>\n+class list{};\n+template<class a, class... b>\n+using tail=list<a, b...>;\n+template <class...T>\n+void f(tail<T...>);\n+\n+int main()\n+{\n+  f<int,int>({});\n+}"}, {"sha": "0c545c735f062c4dbd0575bbd48dfb1fe09b87d5", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-dr1286.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1286.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1286.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1286.C?ref=45d765871b6744d2fe519a61a1d15ff4d613388f", "patch": "@@ -0,0 +1,13 @@\n+// DR 1286: An alias template can be equivalent to an underlying template.\n+// { dg-do compile { target c++11 } }\n+\n+template <class T, class U> struct same;\n+template <class T> struct same<T,T> {};\n+\n+template <class T> struct A {};\n+template <class T> using B = A<T>;\n+\n+template <template <class> class T> class C {};\n+\n+void f(C<B>) { }\t    // { dg-final { scan-assembler \"_Z1f1CI1AE\" } }\n+same<C<A>, C<B> > s;"}, {"sha": "1780c9a47b79e254439b17511ba75b068510df34", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-dr1286a.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1286a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d765871b6744d2fe519a61a1d15ff4d613388f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1286a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-dr1286a.C?ref=45d765871b6744d2fe519a61a1d15ff4d613388f", "patch": "@@ -0,0 +1,60 @@\n+// DR 1286\n+// { dg-do compile { target c++11 } }\n+\n+template <class,class> struct same;\n+template <class T> struct same<T,T> {};\n+\n+template <class,class> struct different {};\n+template <class T> struct different<T,T>;\n+\n+template<typename T, typename U = T> struct A;\n+template<template <class...> class> struct X;\n+\n+// equivalent to A\n+template<typename V, typename W>\n+using B = A<V, W>;\n+\n+same<X<A>,X<B>> s1;\n+\n+// not equivalent to A: not all parameters used\n+template<typename V, typename W>\n+using C = A<V>;\n+\n+different<X<A>,X<C>> d1;\n+\n+// not equivalent to A: different number of parameters\n+template<typename V>\n+using D = A<V>;\n+\n+different<X<A>,X<D>> d2;\n+\n+// not equivalent to A: template-arguments in wrong order\n+template<typename V, typename W>\n+using E = A<W, V>;\n+\n+different<X<A>,X<E>> d3;\n+\n+// equivalent to A: default arguments not considered\n+template<typename V, typename W = int>\n+using F = A<V, W>;\n+\n+same<X<A>,X<F>> s2;\n+\n+// equivalent to A and B\n+template<typename V, typename W>\n+using G = A<V, W>;\n+\n+same<X<A>,X<G>> s3;\n+same<X<B>,X<G>> s3b;\n+\n+// equivalent to E\n+template<typename V, typename W>\n+using H = E<V, W>;\n+\n+same<X<E>,X<H>> s4;\n+\n+// not equivalent to A: argument not identifier\n+template<typename V, typename W>\n+using I = A<V, typename W::type>;\n+\n+different<X<A>,X<I>> d4;"}]}