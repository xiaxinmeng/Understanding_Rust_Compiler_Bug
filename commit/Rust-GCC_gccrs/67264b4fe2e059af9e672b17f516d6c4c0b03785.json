{"sha": "67264b4fe2e059af9e672b17f516d6c4c0b03785", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyNjRiNGZlMmUwNTlhZjllNjcyYjE3ZjUxNmQ2YzRjMGIwMzc4NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-10-22T18:00:06Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-10-22T18:00:06Z"}, "message": "ChangeLog: Fix typos.\n\n\t* ChangeLog: Fix typos.\n\t* expr.c: Fix comment typos.\n\t* jcf-write.c: Likewise.\n\t* lang.c: Likewise.\n\t* lex.c: Likewise.\n\t* mangle.c: Likewise.\n\t* parse-scan.y: Likewise.\n\t* parse.y: Likewise.\n\nFrom-SVN: r72809", "tree": {"sha": "1b747e339c225cdfbed517d164b762c63bd110c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b747e339c225cdfbed517d164b762c63bd110c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67264b4fe2e059af9e672b17f516d6c4c0b03785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67264b4fe2e059af9e672b17f516d6c4c0b03785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67264b4fe2e059af9e672b17f516d6c4c0b03785", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67264b4fe2e059af9e672b17f516d6c4c0b03785/comments", "author": null, "committer": null, "parents": [{"sha": "1322946805597f3b80f585da69c3447a79a37de0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1322946805597f3b80f585da69c3447a79a37de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1322946805597f3b80f585da69c3447a79a37de0"}], "stats": {"total": 119, "additions": 65, "deletions": 54}, "files": [{"sha": "6dad9d102575edb45567d05627b2a91b08302921", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=67264b4fe2e059af9e672b17f516d6c4c0b03785", "patch": "@@ -1,3 +1,14 @@\n+2003-10-22  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* ChangeLog: Fix typos.\n+\t* expr.c: Fix comment typos.\n+\t* jcf-write.c: Likewise.\n+\t* lang.c: Likewise.\n+\t* lex.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* parse-scan.y: Likewise.\n+\t* parse.y: Likewise.\n+\n 2003-10-22  Tom Tromey  <tromey@redhat.com>\n \n \t* expr.c (expand_byte_code): Only warn about dead bytecode when\n@@ -3458,7 +3469,7 @@\n \n 2001-08-31  Per Bothner  <per@bothner.com>\n \n-\t* class.c (set_constant_value):  When not emiting class files, then a\n+\t* class.c (set_constant_value):  When not emitting class files, then a\n \tString ConstantValue is a utf8const_ptr_type.\n \n 2001-08-30  Per Bothner  <per@bothner.com>\n@@ -3726,7 +3737,7 @@\n \t`finish_class' when compiling to native.\n \t(resolve_expression_name): Use `orig' after building outer class\n \tfield access.\n-\t(patch_invoke): Remember static method invokations.\n+\t(patch_invoke): Remember static method invocations.\n \n 2001-08-06  Richard Henderson  <rth@redhat.com>\n \n@@ -4186,15 +4197,15 @@\n \t(add_instance_initializer): Use it.\n \t(java_fix_constructors): Set `current_class' before fix pass.\n \t(fix_constructors): Just return if already fixed. Move `super()'\n-\tinvokation ahead. Use `build_instance_initializer.'\n+\tinvocation ahead. Use `build_instance_initializer.'\n \tFixes PR java/1315.\n \n 2001-04-04  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* parse.y (resolve_qualified_expression_name): Pass field's\n \tDECL_CONTEXT to `not_accessible_p.'\n \t(not_accessible_p): Changed parameters order in `inherits_from_p'\n-\tinvokation.\n+\tinvocation.\n \n 2001-03-27  Andrew Haley  <aph@cambridge.redhat.com>\n \n@@ -7033,7 +7044,7 @@\n \n 2000-04-05  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n-\t* jcf-write.c (generate_bytecode_insns): At invokation time,\n+\t* jcf-write.c (generate_bytecode_insns): At invocation time,\n \talways relate an interface method to the type of its selector.\n \n 2000-04-05  Tom Tromey  <tromey@cygnus.com>\n@@ -7604,7 +7615,7 @@\n 2000-02-12  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (outer_field_access_fix): First parameter now a tree\n-\tnode. Check for assignement to final. First argument to\n+\tnode. Check for assignment to final. First argument to\n \tbuild_outer_field_access_fix modified to accommodate prototype.\n \t(build_outer_field_access): Don't check for assignment to final\n \there.\n@@ -8522,7 +8533,7 @@\n \n 1999-12-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n-\t* parse.y (java_complete_lhs): Force convertion of array\n+\t* parse.y (java_complete_lhs): Force conversion of array\n \tdimensions to int_type_node, that's what runtime's ABI expects.\n \n 1999-12-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n@@ -9543,7 +9554,7 @@\n 1999-05-24  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* lex.c (java_lex): Accepts `+' or `-' after the beginning of a\n-\tfloating point litteral only when the exponent indicator has been\n+\tfloating point literal only when the exponent indicator has been\n \tparsed.\n \n 1999-05-22  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n@@ -10265,7 +10276,7 @@\n \tnon accessible fields.\n \t(java_stabilize_reference): New function.\n \t(java_complete_lhs): Fixed indentation. Use\n-\tjava_stabilize_reference in compound assignement. Insert the\n+\tjava_stabilize_reference in compound assignment. Insert the\n \tcast. If not processing `+' fix string constants before processing\n \tbinop.\n \n@@ -10893,7 +10904,7 @@\n \twith assembler temp labels.\n \n \t* parse.y (patch_synchronized_statement): Set TREE_SIDE_EFFECTS on\n-\tMODIFY_EXPR.  Without this, code for the assignement may not be\n+\tMODIFY_EXPR.  Without this, code for the assignment may not be\n \tgenerated at all and the synchronized statement will read an\n \tuninitialized variable.\n \n@@ -14616,7 +14627,7 @@\n \t(block:): Likewise.\n \t(labeled_statement_nsi:): Generate debug info when reducing\n \texpression_statement:.\n-\t(check_pkg_class_access): get_access_flags_from_decl invokation\n+\t(check_pkg_class_access): get_access_flags_from_decl invocation\n \tfixed for new CLASS_* flags location.\n \t(source_end_java_method): Save/restore parser context when\n \tentering/leaving this routine. Restore lineno to its right value"}, {"sha": "e5654e79b6f43491c8cf7453ba937397a8a61708", "filename": "gcc/java/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=67264b4fe2e059af9e672b17f516d6c4c0b03785", "patch": "@@ -107,7 +107,7 @@ int always_initialize_class_p;\n \n    If a variable is on the quick stack, it means the value of variable\n    when the quick stack was last flushed.  Conceptually, flush_quick_stack\n-   saves all the the quick_stack elements in parellel.  However, that is\n+   saves all the the quick_stack elements in parallel.  However, that is\n    complicated, so it actually saves them (i.e. copies each stack value\n    to is home virtual register) from low indexes.  This allows a quick_stack\n    element at index i (counting from the bottom of stack the) to references\n@@ -456,7 +456,7 @@ pop_value (tree type)\n }\n \n \n-/* Pop and discrad the top COUNT stack slots. */\n+/* Pop and discard the top COUNT stack slots. */\n \n static void\n java_stack_pop (int count)"}, {"sha": "8a6519bab7dc2f849cac98b175dbad116b782b83", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=67264b4fe2e059af9e672b17f516d6c4c0b03785", "patch": "@@ -276,7 +276,7 @@ struct jcf_partial\n   /* Information about the current switch statement. */\n   struct jcf_switch_state *sw_state;\n \n-  /* The count of jsr instructions that have been emmitted.  */\n+  /* The count of jsr instructions that have been emitted.  */\n   long num_jsrs;\n };\n \n@@ -2868,7 +2868,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n   append_chunk (NULL, 0, state);\n   cpool_chunk = state->chunk;\n \n-  /* Next allocate the chunk containing acces_flags through fields_count. */\n+  /* Next allocate the chunk containing access_flags through fields_count. */\n   if (clas == object_type_node)\n     i = 10;\n   else\n@@ -2877,7 +2877,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n   i = get_access_flags (TYPE_NAME (clas));\n   if (! (i & ACC_INTERFACE))\n     i |= ACC_SUPER;\n-  PUT2 (i); /* acces_flags */\n+  PUT2 (i); /* access_flags */\n   i = find_class_constant (&state->cpool, clas);  PUT2 (i);  /* this_class */\n   if (clas == object_type_node)\n     {"}, {"sha": "ee476b2fc9e524f6c2ba72c39e1b4ba7c5944b8c", "filename": "gcc/java/lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=67264b4fe2e059af9e672b17f516d6c4c0b03785", "patch": "@@ -1104,14 +1104,14 @@ java_estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n       return NULL;\n     }\n   /* Assume that constants and references counts nothing.  These should\n-     be majorized by amount of operations amoung them we count later\n+     be majorized by amount of operations among them we count later\n      and are common target of CSE and similar optimizations.  */\n   if (TREE_CODE_CLASS (TREE_CODE (x)) == 'c'\n       || TREE_CODE_CLASS (TREE_CODE (x)) == 'r')\n     return NULL;\n   switch (TREE_CODE (x))\n     { \n-    /* Reconginze assignments of large structures and constructors of\n+    /* Recognize assignments of large structures and constructors of\n        big arrays.  */\n     case MODIFY_EXPR:\n     case CONSTRUCTOR:"}, {"sha": "18c0a8adb9a1da631dd37a4868995bb4a82ed507", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=67264b4fe2e059af9e672b17f516d6c4c0b03785", "patch": "@@ -1360,7 +1360,7 @@ do_java_lex (YYSTYPE *java_lval)\n       string = obstack_finish (&temporary_obstack);\n #ifndef JC1_LITE\n       if (!no_error || (c != '\"'))\n-\tjava_lval->node = error_mark_node; /* FIXME: Requires futher\n+\tjava_lval->node = error_mark_node; /* FIXME: Requires further\n                                               testing.  */\n       else\n \tjava_lval->node = build_string (strlen (string), string);"}, {"sha": "e0b53a13c2b38292fa186e5747dbf0dec2159e40", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=67264b4fe2e059af9e672b17f516d6c4c0b03785", "patch": "@@ -471,7 +471,7 @@ mangle_array_type (tree p_type)\n }\n \n /* Write a substitution string for entry I. Substitution string starts a\n-   -1 (encoded S_.) The base is 36, and the code shamlessly taken from\n+   -1 (encoded S_.) The base is 36, and the code shamelessly taken from\n    cp/mangle.c.  */\n \n static void"}, {"sha": "8c622a42019ab213f577664e4eab683b364e858a", "filename": "gcc/java/parse-scan.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=67264b4fe2e059af9e672b17f516d6c4c0b03785", "patch": "@@ -565,7 +565,7 @@ constructor_declaration:\n /* extra SC_TK, FIXME */\n |\tmodifiers constructor_declarator throws constructor_body SC_TK\n \t\t{ modifier_value = 0; }\n-/* I'm not happy with the SC_TK addition. It isn't in the grammer and should\n+/* I'm not happy with the SC_TK addition. It isn't in the grammar and should\n    probably be matched by and empty statement. But it doesn't work. FIXME */\n ;\n "}, {"sha": "e1ad1a9e0150c9c1be180ee683dde26627e40984", "filename": "gcc/java/parse.y", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67264b4fe2e059af9e672b17f516d6c4c0b03785/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=67264b4fe2e059af9e672b17f516d6c4c0b03785", "patch": "@@ -367,7 +367,7 @@ static const enum tree_code binop_lookup[19] =\n   binop_lookup [((VALUE) - PLUS_TK) % ARRAY_SIZE (binop_lookup)]\n \n /* This is the end index for binary operators that can also be used\n-   in compound assignements. */\n+   in compound assignments. */\n #define BINOP_COMPOUND_CANDIDATES 11\n \n /* The \"$L\" identifier we use to create labels.  */\n@@ -2021,7 +2021,7 @@ class_instance_creation_expression:\n \n /* Created after JDK1.1 rules originally added to\n    class_instance_creation_expression, but modified to use\n-   'class_type' instead of 'TypeName' (type_name) which is mentionned\n+   'class_type' instead of 'TypeName' (type_name) which is mentioned\n    in the documentation but doesn't exist. */\n \n anonymous_class_creation:\n@@ -2808,7 +2808,7 @@ java_parser_context_resume (void)\n   current_class = saver->class_type;\n   current_function_decl = saver->function_decl;\n \n-  /* Retrive the restored context */\n+  /* Retrieve the restored context */\n   ctxp = restored;\n \n   /* Re-installed the data for the parsing to carry on */\n@@ -3730,7 +3730,7 @@ maybe_create_class_interface_decl (tree decl, tree raw_name,\n \n   /* Take care of the file and line business */\n   DECL_SOURCE_FILE (decl) = EXPR_WFL_FILENAME (cl);\n-  /* If we're emiting xrefs, store the line/col number information */\n+  /* If we're emitting xrefs, store the line/col number information */\n   if (flag_emit_xref)\n     DECL_SOURCE_LINE (decl) = EXPR_WFL_LINECOL (cl);\n   else\n@@ -3898,7 +3898,7 @@ create_anonymous_class (int location, tree type_name)\n   if ((type_decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (type_name))))\n     {\n       /* Create a class which either implements on extends the designated\n-\t class. The class bears an innacessible name. */\n+\t class. The class bears an inaccessible name. */\n       if (CLASS_INTERFACE (type_decl))\n \t{\n \t  /* It's OK to modify it here. It's been already used and\n@@ -4099,7 +4099,7 @@ add_inner_class_fields (tree class_decl, tree fct_decl)\n \t     methods first, then finit$ to get a picture of what's\n \t     used.  It works with the exception that we would have to\n \t     go back on all constructor invoked in regular methods to\n-\t     have their invokation reworked (to include the right amount\n+\t     have their invocation reworked (to include the right amount\n \t     of alias initializer parameters.)\n \n \t     The only real way around, I think, is a first pass to\n@@ -4109,10 +4109,10 @@ add_inner_class_fields (tree class_decl, tree fct_decl)\n \n \t     On the other hand, it only affect local inner classes,\n \t     whose constructors (and finit$ call) will be featuring\n-\t     unecessary arguments. It's easy for a developper to keep\n+\t     unnecessary arguments. It's easy for a developer to keep\n \t     this number of parameter down by using the `final'\n \t     keyword only when necessary. For the time being, we can\n-\t     issue a warning on unecessary finals. FIXME */\n+\t     issue a warning on unnecessary finals. FIXME */\n \t  init = build_assignment (ASSIGN_TK, EXPR_WFL_LINECOL (wfl),\n \t\t\t\t   wfl, init);\n \n@@ -4130,7 +4130,7 @@ add_inner_class_fields (tree class_decl, tree fct_decl)\n     return;\n \n   /* If we ever registered an alias field, insert and marker to\n-     remeber where the list ends. The second part of the list (the one\n+     remember where the list ends. The second part of the list (the one\n      featuring initialized fields) so it can be later reversed to\n      enforce 8.5. The marker will be removed during that operation. */\n   marker = build_tree_list (NULL_TREE, NULL_TREE);\n@@ -4469,7 +4469,7 @@ build_instinit_invocation (tree class_type)\n   return to_return;\n }\n \n-/* Shared accros method_declarator and method_header to remember the\n+/* Shared across method_declarator and method_header to remember the\n    patch stage that was reached during the declaration of the method.\n    A method DECL is built differently is there is no patch\n    (JDEP_NO_PATCH) or a patch (JDEP_METHOD or JDEP_METHOD_RETURN)\n@@ -4969,7 +4969,7 @@ method_declarator (tree id, tree list)\n \n       /* The argument node: a name and a (possibly) incomplete type.  */\n       arg_node = build_tree_list (name, real_type);\n-      /* Remeber arguments declared final. */\n+      /* Remember arguments declared final. */\n       ARG_FINAL_P (arg_node) = ARG_FINAL_P (current);\n \n       if (jdep)\n@@ -5057,7 +5057,7 @@ parser_check_super_interface (tree super_decl, tree this_decl, tree this_wfl)\n }\n \n /* Makes sure that SUPER_DECL is suitable to extend THIS_DECL. Returns\n-   0 if everthing is OK.  */\n+   0 if everything is OK.  */\n \n static int\n parser_check_super (tree super_decl, tree this_decl, tree wfl)\n@@ -5331,7 +5331,7 @@ build_alias_initializer_parameter_list (int mode, tree class_type, tree parm,\n \t    break;\n \n \t  case AIPL_FUNCTION_CTOR_INVOCATION:\n-\t    /* There are two case: the constructor invokation happends\n+\t    /* There are two case: the constructor invocation happens\n \t       outside the local inner, in which case, locales from the outer\n \t       context are directly used.\n \n@@ -7631,7 +7631,7 @@ java_layout_classes (void)\n   java_parse_abort_on_error ();\n }\n \n-/* Expand methods in the current set of classes rememebered for\n+/* Expand methods in the current set of classes remembered for\n    generation.  */\n \n static void\n@@ -8260,7 +8260,7 @@ outer_field_access_p (tree type, tree decl)\n     return 0;\n \n   /* If the inner class extends the declaration context of the field\n-     we're try to acces, then this isn't an outer field access */\n+     we're trying to access, then this isn't an outer field access */\n   if (inherits_from_p (type, DECL_CONTEXT (decl)))\n     return 0;\n \n@@ -8684,7 +8684,7 @@ build_current_thisn (tree type)\n   return saved_thisn;\n }\n \n-/* Return the assignement to the hidden enclosing context `this$<n>'\n+/* Return the assignment to the hidden enclosing context `this$<n>'\n    by the second incoming parameter to the innerclass constructor. The\n    form used is `this.this$<n> = this$<n>;'.  */\n \n@@ -8901,7 +8901,7 @@ fix_constructors (tree mdecl)\n       if (!found)\n \tcompound = add_stmt_to_compound (compound, NULL_TREE,\n                                          build_super_invocation (mdecl));\n-      /* Explicit super() invokation should take place before the\n+      /* Explicit super() invocation should take place before the\n          instance initializer blocks. */\n       else\n \t{\n@@ -9007,7 +9007,7 @@ java_expand_classes (void)\n \n \n   /* Find anonymous classes and expand their constructor. This extra pass is\n-     neccessary because the constructor itself is only generated when the\n+     necessary because the constructor itself is only generated when the\n      method in which it is defined is expanded. */\n   for (cur_ctxp = ctxp_for_generation; cur_ctxp; cur_ctxp = cur_ctxp->next)\n     {\n@@ -9878,7 +9878,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t\t}\n \t    }\n \n-\t  /* Report and error if we're using a numerical litteral as a\n+\t  /* Report and error if we're using a numerical literal as a\n              qualifier. It can only be an INTEGER_CST. */\n \t  else if (TREE_CODE (qual_wfl) == INTEGER_CST)\n \t    {\n@@ -10451,7 +10451,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t  this_arg = primary ? primary : current_this;\n \n \t  /* If we're using an access method, things are different.\n-\t     There are two familly of cases:\n+\t     There are two family of cases:\n \n \t     1) We're not generating bytecodes:\n \n@@ -10467,7 +10467,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \t     - LIST is static. It's invocation is transformed from\n \t       x(a1,....,an) into TYPE_OF(this$<n>).x(a1,....an).\n \n-\t     Of course, this$<n> can be abitrary complex, ranging from\n+\t     Of course, this$<n> can be arbitrarily complex, ranging from\n \t     this$0 (the immediate outer context) to\n \t     access$0(access$0(...(this$0))).\n \n@@ -10709,8 +10709,8 @@ maybe_use_access_method (int is_super_init, tree *mdecl, tree *this_arg)\n   *mdecl = md;\n   *this_arg = ta;\n \n-  /* Returnin a nonzero value indicates we were doing a non static\n-     method invokation that is now a static invocation. It will have\n+  /* Returning a nonzero value indicates we were doing a non static\n+     method invocation that is now a static invocation. It will have\n      callee displace `this' to insert it in the regular argument\n      list. */\n   return (non_static_context && to_return);\n@@ -10739,7 +10739,7 @@ patch_invoke (tree patch, tree method, tree args)\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n \n-  /* Resolve unresolved returned type isses */\n+  /* Resolve unresolved returned type issues */\n   t = TREE_TYPE (TREE_TYPE (method));\n   if (TREE_CODE (t) == POINTER_TYPE && !CLASS_LOADED_P (TREE_TYPE (t)))\n     resolve_and_layout (TREE_TYPE (t), NULL);\n@@ -11420,7 +11420,7 @@ qualify_ambiguous_name (tree id)\n \t    return;\n \t  }\n \tqual = TREE_CHAIN (qual);\n-\t/* Do one more interation to set things up */\n+\t/* Do one more iteration to set things up */\n \tsuper_found = again = 1;\n       }\n   } while (again);\n@@ -11482,7 +11482,7 @@ qualify_ambiguous_name (tree id)\n   else\n     RESOLVE_PACKAGE_NAME_P (qual_wfl) = 1;\n \n-  /* Propagate the qualification accross other components of the\n+  /* Propagate the qualification across other components of the\n      qualified name */\n   for (qual = TREE_CHAIN (qual); qual;\n        qual_wfl = QUAL_WFL (qual), qual = TREE_CHAIN (qual))\n@@ -12533,7 +12533,7 @@ build_wfl_wrap (tree node, int location)\n {\n   tree wfl, node_to_insert = node;\n \n-  /* We want to process THIS . xxx symbolicaly, to keep it consistent\n+  /* We want to process THIS . xxx symbolically, to keep it consistent\n      with the way we're processing SUPER. A THIS from a primary as a\n      different form than a SUPER. Turn THIS into something symbolic */\n   if (TREE_CODE (node) == THIS_EXPR)\n@@ -13014,7 +13014,7 @@ try_builtin_assignconv (tree wfl_op1, tree lhs_type, tree rhs)\n /* Return 1 if RHS_TYPE can be converted to LHS_TYPE by identity\n    conversion (5.1.1) or widening primitive conversion (5.1.2).  Return\n    0 is the conversion test fails.  This implements parts the method\n-   invocation convertion (5.3).  */\n+   invocation conversion (5.3).  */\n \n static int\n valid_builtin_assignconv_identity_widening_p (tree lhs_type, tree rhs_type)\n@@ -13104,7 +13104,7 @@ valid_ref_assignconv_cast_p (tree source, tree dest, int cast)\n \t  /* Otherwise, SOURCE must implement DEST */\n \t  return interface_of_p (dest, source);\n \t}\n-      /* DEST is an array, cast permited if SOURCE is of Object type */\n+      /* DEST is an array, cast permitted if SOURCE is of Object type */\n       return (cast && source == object_type_node ? 1 : 0);\n     }\n   if (TYPE_INTERFACE_P (source))\n@@ -13448,7 +13448,7 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n       if (code == RDIV_EXPR && TREE_CODE (prom_type) == INTEGER_TYPE)\n \tTREE_SET_CODE (node, TRUNC_DIV_EXPR);\n \n-      /* Before divisions as is disapear, try to simplify and bail if\n+      /* Before divisions as is disappear, try to simplify and bail if\n          applicable, otherwise we won't perform even simple\n          simplifications like (1-1)/3. We can't do that with floating\n          point number, folds can't handle them at this stage. */\n@@ -14378,7 +14378,7 @@ patch_cast (tree node, tree wfl_op)\n \tif (cast_type != long_type_node)\n \t  op = convert (integer_type_node, op);\n \n-      /* Try widening/narrowing convertion.  Potentially, things need\n+      /* Try widening/narrowing conversion.  Potentially, things need\n \t to be worked out in gcc so we implement the extreme cases\n \t correctly.  fold_convert() needs to be fixed.  */\n       return convert (cast_type, op);\n@@ -14925,7 +14925,7 @@ patch_if_else_statement (tree node)\n \n /* 14.6 Labeled Statements */\n \n-/* Action taken when a lableled statement is parsed. a new\n+/* Action taken when a labeled statement is parsed. a new\n    LABELED_BLOCK_EXPR is created. No statement is attached to the\n    label, yet.  LABEL can be NULL_TREE for artificially-generated blocks. */\n \n@@ -15167,7 +15167,7 @@ build_bc_statement (int location, int is_break, tree name)\n \t    (merge_qualified_name (label_id, EXPR_WFL_NODE (name)))))\n \t/* Null means that we don't have a target for this named\n \t   break/continue. In this case, we make the target to be the\n-\t   label name, so that the error can be reported accuratly in\n+\t   label name, so that the error can be reported accurately in\n \t   patch_bc_statement. */\n \tlabel_block_expr = EXPR_WFL_NODE (name);\n     }"}]}