{"sha": "61f8d16512a62120c29e1cc82cddbc4d3816a1c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmOGQxNjUxMmE2MjEyMGMyOWUxY2M4MmNkZGJjNGQzODE2YTFjNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-10-27T15:59:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-10-27T15:59:54Z"}, "message": "call.c (build_integral_nontype_arg_conv): New.\n\n\t* call.c (build_integral_nontype_arg_conv): New.\n\t* cp-tree.h: Declare it.\n\t* pt.c (convert_nontype_argument): Use it.\n\nFrom-SVN: r166011", "tree": {"sha": "c7e91a2823c3f547d1962dd84e91b0b537670714", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7e91a2823c3f547d1962dd84e91b0b537670714"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61f8d16512a62120c29e1cc82cddbc4d3816a1c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f8d16512a62120c29e1cc82cddbc4d3816a1c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f8d16512a62120c29e1cc82cddbc4d3816a1c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2842beb62d01d883db7c770291e15f4de8202174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2842beb62d01d883db7c770291e15f4de8202174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2842beb62d01d883db7c770291e15f4de8202174"}], "stats": {"total": 96, "additions": 84, "deletions": 12}, "files": [{"sha": "c752736380bc54a77d2a37f56e19c3773d548208", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=61f8d16512a62120c29e1cc82cddbc4d3816a1c4", "patch": "@@ -1,5 +1,9 @@\n 2010-10-27  Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (build_integral_nontype_arg_conv): New.\n+\t* cp-tree.h: Declare it.\n+\t* pt.c (convert_nontype_argument): Use it.\n+\n \t* error.c (dump_simple_decl): Print constexpr.\n \n \t* cvt.c (build_up_reference): Use target_type for the temporary var."}, {"sha": "204fda5eec45e0e58881ebf44e890c6a10a0464c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=61f8d16512a62120c29e1cc82cddbc4d3816a1c4", "patch": "@@ -3165,6 +3165,76 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n   return NULL_TREE;\n }\n \n+/* Subroutine of convert_nontype_argument.\n+\n+   EXPR is an argument for a template non-type parameter of integral or\n+   enumeration type.  Do any necessary conversions (that are permitted for\n+   non-type arguments) to convert it to the parameter type.\n+\n+   If conversion is successful, returns the converted expression;\n+   otherwise, returns error_mark_node.  */\n+\n+tree\n+build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n+{\n+  conversion *conv;\n+  void *p;\n+  tree t;\n+\n+  if (error_operand_p (expr))\n+    return error_mark_node;\n+\n+  gcc_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n+  conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n+\t\t\t      /*c_cast_p=*/false,\n+\t\t\t      LOOKUP_IMPLICIT);\n+\n+  /* for a non-type template-parameter of integral or\n+     enumeration type, integral promotions (4.5) and integral\n+     conversions (4.7) are applied.  */\n+  /* It should be sufficient to check the outermost conversion step, since\n+     there are no qualification conversions to integer type.  */\n+  if (conv)\n+    switch (conv->kind)\n+      {\n+\t/* A conversion function is OK.  If it isn't constexpr, we'll\n+\t   complain later that the argument isn't constant.  */\n+      case ck_user:\n+\t/* The lvalue-to-rvalue conversion is OK.  */\n+      case ck_rvalue:\n+      case ck_identity:\n+\tbreak;\n+\n+      case ck_std:\n+\tt = conv->u.next->type;\n+\tif (INTEGRAL_OR_ENUMERATION_TYPE_P (t))\n+\t  break;\n+\n+\tif (complain & tf_error)\n+\t  error (\"conversion from %qT to %qT not considered for \"\n+\t\t \"non-type template argument\", t, type);\n+\t/* and fall through.  */\n+\n+      default:\n+\tconv = NULL;\n+\tbreak;\n+      }\n+\n+  if (conv)\n+    expr = convert_like (conv, expr, complain);\n+  else\n+    expr = error_mark_node;\n+\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  return expr;\n+}\n+\n /* Do any initial processing on the arguments to a function call.  */\n \n static VEC(tree,gc) *"}, {"sha": "ec026a416e9d93d80ea8d2ff7b470c12f10ee0d9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=61f8d16512a62120c29e1cc82cddbc4d3816a1c4", "patch": "@@ -4651,6 +4651,7 @@ extern tree strip_top_quals\t\t\t(tree);\n extern bool reference_related_p\t\t\t(tree, tree);\n extern tree perform_implicit_conversion\t\t(tree, tree, tsubst_flags_t);\n extern tree perform_implicit_conversion_flags\t(tree, tree, tsubst_flags_t, int);\n+extern tree build_integral_nontype_arg_conv\t(tree, tree, tsubst_flags_t);\n extern tree perform_direct_initialization_if_possible (tree, tree, bool,\n                                                        tsubst_flags_t);\n extern tree in_charge_arg_for_name\t\t(tree);"}, {"sha": "8a6d451a69e0ed0e85942b8b9d20f6d0cab85921", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f8d16512a62120c29e1cc82cddbc4d3816a1c4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=61f8d16512a62120c29e1cc82cddbc4d3816a1c4", "patch": "@@ -5069,10 +5069,17 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n      (_conv.integral_) are applied.  */\n   if (INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     {\n-      if (!INTEGRAL_OR_ENUMERATION_TYPE_P (expr_type))\n+      tree t = build_integral_nontype_arg_conv (type, expr, complain);\n+      t = fold_decl_constant_value (t);\n+      if (t != error_mark_node)\n+\texpr = t;\n+\n+      if (!same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (expr)))\n \treturn error_mark_node;\n \n-      expr = fold_decl_constant_value (expr);\n+      /* Conversion was allowed: fold it to a bare integer constant.  */\n+      expr = fold (expr);\n+\n       /* Notice that there are constant expressions like '4 % 0' which\n \t do not fold into integer constants.  */\n       if (TREE_CODE (expr) != INTEGER_CST)\n@@ -5082,16 +5089,6 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t\t   \"because it is a non-constant expression\", expr, type);\n \t  return NULL_TREE;\n \t}\n-\n-      /* At this point, an implicit conversion does what we want,\n-\t because we already know that the expression is of integral\n-\t type.  */\n-      expr = perform_implicit_conversion (type, expr, complain);\n-      if (expr == error_mark_node)\n-\treturn error_mark_node;\n-\n-      /* Conversion was allowed: fold it to a bare integer constant.  */\n-      expr = fold (expr);\n     }\n   /* [temp.arg.nontype]/5, bullet 2\n "}]}