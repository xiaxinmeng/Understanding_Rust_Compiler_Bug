{"sha": "77bbf69d2981dafc2ef3e59bfbefb645d88bab9d", "node_id": "C_kwDOANBUbNoAKDc3YmJmNjlkMjk4MWRhZmMyZWYzZTU5YmZiZWZiNjQ1ZDg4YmFiOWQ", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-01T10:35:07Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-25T12:44:54Z"}, "message": "fortran: Support clobbering of derived types [PR41453]\n\nThis adds support for clobbering of non-polymorphic derived type\nvariables, when they are passed as actual argument whose associated\ndummy has the INTENT(OUT) attribute.\n\nWe avoid to play with non-constant type sizes or class descriptors by\nrequiring that the types are derived (not class) and strictly matching,\nand by excluding parameterized derived types.\n\nTypes that are used in the callee are also excluded: they are types with\nallocatable components (the components will be deallocated), and\nfinalizable types or types with finalizable components (they will be\npassed to finalization routines).\n\n\tPR fortran/41453\n\ngcc/fortran/ChangeLog:\n\n\t* trans-expr.cc (gfc_conv_procedure_call): Allow strictly\n\tmatching derived types.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/intent_optimize_10.f90: New test.", "tree": {"sha": "96df5717abb95282a0c9738559ff0ec04b929d6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96df5717abb95282a0c9738559ff0ec04b929d6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77bbf69d2981dafc2ef3e59bfbefb645d88bab9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77bbf69d2981dafc2ef3e59bfbefb645d88bab9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77bbf69d2981dafc2ef3e59bfbefb645d88bab9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77bbf69d2981dafc2ef3e59bfbefb645d88bab9d/comments", "author": null, "committer": null, "parents": [{"sha": "95375ffb3dd59f51e79408dd3b2b620dc1af71b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95375ffb3dd59f51e79408dd3b2b620dc1af71b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95375ffb3dd59f51e79408dd3b2b620dc1af71b1"}], "stats": {"total": 84, "additions": 83, "deletions": 1}, "files": [{"sha": "4f3ae82d39c82d479bc5b58b6e29387c85fca70b", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77bbf69d2981dafc2ef3e59bfbefb645d88bab9d/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77bbf69d2981dafc2ef3e59bfbefb645d88bab9d/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=77bbf69d2981dafc2ef3e59bfbefb645d88bab9d", "patch": "@@ -6526,8 +6526,24 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  && e->symtree->n.sym\n \t\t\t  && !e->symtree->n.sym->attr.dimension\n \t\t\t  && e->ts.type != BT_CHARACTER\n-\t\t\t  && e->ts.type != BT_DERIVED\n \t\t\t  && e->ts.type != BT_CLASS\n+\t\t\t  && (e->ts.type != BT_DERIVED\n+\t\t\t      || (dsym->ts.type == BT_DERIVED\n+\t\t\t\t  && e->ts.u.derived == dsym->ts.u.derived\n+\t\t\t\t  /* Types with allocatable components are\n+\t\t\t\t     excluded from clobbering because we need\n+\t\t\t\t     the unclobbered pointers to free the\n+\t\t\t\t     allocatable components in the callee.\n+\t\t\t\t     Same goes for finalizable types or types\n+\t\t\t\t     with finalizable components, we need to\n+\t\t\t\t     pass the unclobbered values to the\n+\t\t\t\t     finalization routines.\n+\t\t\t\t     For parameterized types, it's less clear\n+\t\t\t\t     but they may not have a constant size\n+\t\t\t\t     so better exclude them in any case.  */\n+\t\t\t\t  && !e->ts.u.derived->attr.alloc_comp\n+\t\t\t\t  && !e->ts.u.derived->attr.pdt_type\n+\t\t\t\t  && !gfc_is_finalizable (e->ts.u.derived, NULL)))\n \t\t\t  && !sym->attr.elemental)\n \t\t\t{\n \t\t\t  tree var;"}, {"sha": "d8bc1bb3b7ba543c4d6c6142f6f58fb06281ff17", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_10.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77bbf69d2981dafc2ef3e59bfbefb645d88bab9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77bbf69d2981dafc2ef3e59bfbefb645d88bab9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_10.f90?ref=77bbf69d2981dafc2ef3e59bfbefb645d88bab9d", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes in the case of non-polymorphic derived type arguments:\n+!  - one clobber to be emitted in the caller before calls to FOO in the *.original dump,\n+!  - no clobber to be emitted in the caller before calls to BAR in the *.original dump,\n+!  - the initialization constants to be optimized away in the *.optimized dump.\n+\n+module x\n+  implicit none\n+  type :: t\n+    integer :: c\n+  end type t\n+  type, extends(t) :: u\n+    integer :: d\n+  end type u\n+contains\n+  subroutine foo(a)\n+    type(t), intent(out) :: a\n+    a = t(42)\n+  end subroutine foo\n+  subroutine bar(b)\n+    class(t), intent(out) :: b\n+    b%c = 24\n+  end subroutine bar\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  type(t) :: tc\n+  type(u) :: uc, ud\n+  class(t), allocatable :: te, tf\n+\n+  tc = t(123456789)\n+  call foo(tc)\n+  if (tc%c /= 42) stop 1\n+\n+  uc = u(987654321, 0)\n+  call foo(uc%t)\n+  if (uc%c /= 42) stop 2\n+  if (uc%d /= 0) stop 3\n+\n+  ud = u(11223344, 0)\n+  call bar(ud)\n+  if (ud%c /= 24) stop 4\n+\n+  te = t(55667788)\n+  call foo(te)\n+  if (te%c /= 42) stop 5\n+\n+  tf = t(99887766)\n+  call bar(tf)\n+  if (tf%c /= 24) stop 6\n+\n+end program main\n+\n+! We don't support class descriptors, neither derived type components, so there is a clobber for tc only;\n+! no clobber for uc, ud, te, tf.\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump \"tc = {CLOBBER};\" \"original\" } }\n+\n+! There is a clobber for tc, so we should manage to optimize away the associated initialization constant (but not other\n+! initialization constants).\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }"}]}