{"sha": "3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RiMWI0MzQ4NjMyZDg3ZTZhMzcyZmZjMTlhMWI1MzNiNWE3OGEzYQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-12-04T20:10:29Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-12-04T20:10:29Z"}, "message": "re PR rtl-optimization/13260 (Incorrect optimisation of loop termination condition)\n\n\tPR optimization/13260\n\t* sh-protos.h (sh_expand_t_scc): Declare.\n\t* sh.h (PREDICATE_CODES): Add cmpsi_operand.\n\t* sh.c (cmpsi_operand, sh_expand_t_scc): New functions.\n\t* sh.md (cmpsi): Use cmpsi_operand.  If T_REG is compared to\n\tsomething that is not a CONST_INT, copy it into a pseudo register.\n\t(subc): Fix description of new T value.\n\t(slt, sgt, sge, sgtu): Don't clobber T after rtl generation is over.\n\t(sltu, sleu, sgeu): Likewise.\n\t(seq, sne): Likewise. Use sh_expand_t_scc.\n\nFrom-SVN: r74294", "tree": {"sha": "35d881277dbd8c7c9a0b309b60cc803e360617e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35d881277dbd8c7c9a0b309b60cc803e360617e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/comments", "author": null, "committer": null, "parents": [{"sha": "a0a8f530d945e53d9f8e0f21b1480c344ffa9e6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a8f530d945e53d9f8e0f21b1480c344ffa9e6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a8f530d945e53d9f8e0f21b1480c344ffa9e6b"}], "stats": {"total": 88, "additions": 84, "deletions": 4}, "files": [{"sha": "8cd28e7e682df700e1fe471fbd460d418282cb5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "patch": "@@ -1,3 +1,16 @@\n+2003-12-04  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\tPR optimization/13260\n+\t* sh-protos.h (sh_expand_t_scc): Declare.\n+\t* sh.h (PREDICATE_CODES): Add cmpsi_operand.\n+\t* sh.c (cmpsi_operand, sh_expand_t_scc): New functions.\n+\t* sh.md (cmpsi): Use cmpsi_operand.  If T_REG is compared to\n+\tsomething that is not a CONST_INT, copy it into a pseudo register.\n+\t(subc): Fix description of new T value.\n+\t(slt, sgt, sge, sgtu): Don't clobber T after rtl generation is over.\n+\t(sltu, sleu, sgeu): Likewise.\n+\t(seq, sne): Likewise. Use sh_expand_t_scc.\n+\n 2003-12-04  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* configure.in: Generalize the CONFIG_HEADERS pattern under which"}, {"sha": "ec723bda12791772e5dca7a3fedf85b882f94ae0", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "patch": "@@ -97,6 +97,7 @@ extern int sh_insn_length_adjustment (rtx);\n extern int sh_can_redirect_branch (rtx, rtx);\n extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);\n extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n+extern int sh_expand_t_scc (enum rtx_code code, rtx target);\n #ifdef TREE_CODE\n extern void sh_va_start (tree, rtx);\n extern rtx sh_va_arg (tree, tree);"}, {"sha": "186372ff73f2f791684942a174b28f5ec6baa0a5", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "patch": "@@ -8898,6 +8898,15 @@ sh_register_operand (rtx op, enum machine_mode mode)\n   return register_operand (op, mode);\n }\n \n+int\n+cmpsi_operand (rtx op, enum machine_mode mode)\n+{\n+  if (GET_CODE (op) == REG && REGNO (op) == T_REG\n+      && GET_MODE (op) == SImode)\n+    return 1;\n+  return arith_operand (op, mode);\n+}\n+\n static rtx emit_load_ptr (rtx, rtx);\n \n static rtx\n@@ -9129,4 +9138,33 @@ sh_get_pr_initial_val (void)\n   return val;\n }\n \n+int\n+sh_expand_t_scc (enum rtx_code code, rtx target)\n+{\n+  rtx result = target;\n+  HOST_WIDE_INT val;\n+\n+  if (GET_CODE (sh_compare_op0) != REG || REGNO (sh_compare_op0) != T_REG\n+      || GET_CODE (sh_compare_op1) != CONST_INT)\n+    return 0;\n+  if (GET_CODE (result) != REG)\n+    result = gen_reg_rtx (SImode);\n+  val = INTVAL (sh_compare_op1);\n+  if ((code == EQ && val == 1) || (code == NE && val == 0))\n+    emit_insn (gen_movt (result));\n+  else if ((code == EQ && val == 0) || (code == NE && val == 1))\n+    {\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode, result));\n+      emit_insn (gen_subc (result, result, result));\n+      emit_insn (gen_addsi3 (result, result, GEN_INT (1)));\n+    }\n+  else if (code == EQ || code == NE)\n+    emit_insn (gen_move_insn (result, GEN_INT (code == NE)));\n+  else\n+    return 0;\n+  if (result != target)\n+    emit_move_insn (target, result);\n+  return 1;\n+}\n+\n #include \"gt-sh.h\""}, {"sha": "e79f6c1a277afa6f2e2f96c154cd918c3bfd68b8", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "patch": "@@ -3145,6 +3145,7 @@ extern int rtx_equal_function_value_matters;\n   {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_VECTOR}},\t\\\n   {\"binary_float_operator\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\\n   {\"binary_logical_operator\", {AND, IOR, XOR}},\t\t\t\t\\\n+  {\"cmpsi_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n   {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n   {\"equality_comparison_operator\", {EQ,NE}},\t\t\t\t\\\n   {\"extend_reg_operand\", {SUBREG, REG, TRUNCATE}},\t\t\t\\"}, {"sha": "aa63209dbf608d5206d259d2ca65e5ef1cd73492", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db1b4348632d87e6a372ffc19a1b533b5a78a3a/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=3db1b4348632d87e6a372ffc19a1b533b5a78a3a", "patch": "@@ -705,11 +705,14 @@\n \n (define_expand \"cmpsi\"\n   [(set (reg:SI T_REG)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"\")\n+\t(compare (match_operand:SI 0 \"cmpsi_operand\" \"\")\n \t\t (match_operand:SI 1 \"arith_operand\" \"\")))]\n   \"TARGET_SH1\"\n   \"\n {\n+  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == T_REG\n+      && GET_CODE (operands[1]) != CONST_INT)\n+    operands[0] = copy_to_mode_reg (SImode, operands[0]);\n   sh_compare_op0 = operands[0];\n   sh_compare_op1 = operands[1];\n   DONE;\n@@ -1167,7 +1170,9 @@\n \t\t\t    (match_operand:SI 2 \"arith_reg_operand\" \"r\"))\n \t\t  (reg:SI T_REG)))\n    (set (reg:SI T_REG)\n-\t(gtu:SI (minus:SI (match_dup 1) (match_dup 2)) (match_dup 1)))]\n+\t(gtu:SI (minus:SI (minus:SI (match_dup 1) (match_dup 2))\n+\t\t\t  (reg:SI T_REG))\n+\t\t(match_dup 1)))]\n   \"TARGET_SH1\"\n   \"subc\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n@@ -7446,6 +7451,10 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t}\n       DONE;\n     }\n+  if (sh_expand_t_scc (EQ, operands[0]))\n+    DONE;\n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n   operands[1] = prepare_scc_operands (EQ);\n }\")\n \n@@ -7492,6 +7501,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t}\n       DONE;\n     }\n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n   operands[1] = prepare_scc_operands (LT);\n }\")\n \n@@ -7594,6 +7605,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t}\n       DONE;\n     }\n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n   operands[1] = prepare_scc_operands (GT);\n }\")\n \n@@ -7646,6 +7659,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n       DONE;\n     }\n \n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n   if (GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n     {\n       if (TARGET_IEEE)\n@@ -7685,6 +7700,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t\t\t\t     sh_compare_op0, sh_compare_op1));\n       DONE;\n     }\n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n   operands[1] = prepare_scc_operands (GTU);\n }\")\n \n@@ -7709,6 +7726,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t\t\t\t     sh_compare_op1, sh_compare_op0));\n       DONE;\n     }\n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n   operands[1] = prepare_scc_operands (LTU);\n }\")\n \n@@ -7738,6 +7757,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       DONE;\n     }\n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n   operands[1] = prepare_scc_operands (LEU);\n }\")\n \n@@ -7768,6 +7789,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n       DONE;\n     }\n \n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n   operands[1] = prepare_scc_operands (GEU);\n }\")\n \n@@ -7815,8 +7838,12 @@ mov.l\\\\t1f,r0\\\\n\\\\\n       DONE;\n     }\n \n-   operands[1] = prepare_scc_operands (EQ);\n-   operands[2] = gen_reg_rtx (SImode);\n+  if (sh_expand_t_scc (NE, operands[0]))\n+    DONE;\n+  if (! rtx_equal_function_value_matters)\n+    FAIL;\n+  operands[1] = prepare_scc_operands (EQ);\n+  operands[2] = gen_reg_rtx (SImode);\n }\")\n \n (define_expand \"sunordered\""}]}