{"sha": "415dddc81c99f37554902cbe0d838060b62a2548", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE1ZGRkYzgxYzk5ZjM3NTU0OTAyY2JlMGQ4MzgwNjBiNjJhMjU0OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:57:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:57:59Z"}, "message": "New Language: Ada\n\nFrom-SVN: r45960", "tree": {"sha": "4ef27cb0e7d117a7b5941427f004d4d06fc8675b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ef27cb0e7d117a7b5941427f004d4d06fc8675b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/415dddc81c99f37554902cbe0d838060b62a2548", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415dddc81c99f37554902cbe0d838060b62a2548", "html_url": "https://github.com/Rust-GCC/gccrs/commit/415dddc81c99f37554902cbe0d838060b62a2548", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415dddc81c99f37554902cbe0d838060b62a2548/comments", "author": null, "committer": null, "parents": [{"sha": "996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996ae0b0aeb9e07a4d7d7ff2926625fd0a58349e"}], "stats": {"total": 31793, "additions": 31793, "deletions": 0}, "files": [{"sha": "95da3a7e3550a177d3b5dd8ae7ba0622635d0e5a", "filename": "gcc/ada/table.adb", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,345 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                T A B L E                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.44 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;   use Debug;\n+with Opt;\n+with Output;  use Output;\n+with System;  use System;\n+with Tree_IO; use Tree_IO;\n+\n+package body Table is\n+   package body Table is\n+\n+      Min : constant Int := Int (Table_Low_Bound);\n+      --  Subscript of the minimum entry in the currently allocated table\n+\n+      Length : Int := 0;\n+      --  Number of entries in currently allocated table. The value of zero\n+      --  ensures that we initially allocate the table.\n+\n+      procedure free (T : Table_Ptr);\n+      pragma Import (C, free);\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      procedure Reallocate;\n+      --  Reallocate the existing table according to the current value stored\n+      --  in Max. Works correctly to do an initial allocation if the table\n+      --  is currently null.\n+\n+      function Tree_Get_Table_Address return Address;\n+      --  Return Null_Address if the table length is zero,\n+      --  Table (First)'Address if not.\n+\n+      ------------\n+      -- Append --\n+      ------------\n+\n+      procedure Append (New_Val : Table_Component_Type) is\n+      begin\n+         Increment_Last;\n+         Table (Table_Index_Type (Last_Val)) := New_Val;\n+      end Append;\n+\n+      --------------------\n+      -- Decrement_Last --\n+      --------------------\n+\n+      procedure Decrement_Last is\n+      begin\n+         Last_Val := Last_Val - 1;\n+      end Decrement_Last;\n+\n+      ----------\n+      -- Free --\n+      ----------\n+\n+      procedure Free is\n+      begin\n+         free (Table);\n+         Table := null;\n+         Length := 0;\n+      end Free;\n+\n+      --------------------\n+      -- Increment_Last --\n+      --------------------\n+\n+      procedure Increment_Last is\n+      begin\n+         Last_Val := Last_Val + 1;\n+\n+         if Last_Val > Max then\n+            Reallocate;\n+         end if;\n+      end Increment_Last;\n+\n+      ----------\n+      -- Init --\n+      ----------\n+\n+      procedure Init is\n+         Old_Length : Int := Length;\n+\n+      begin\n+         Last_Val := Min - 1;\n+         Max      := Min + (Table_Initial * Opt.Table_Factor) - 1;\n+         Length   := Max - Min + 1;\n+\n+         --  If table is same size as before (happens when table is never\n+         --  expanded which is a common case), then simply reuse it. Note\n+         --  that this also means that an explicit Init call right after\n+         --  the implicit one in the package body is harmless.\n+\n+         if Old_Length = Length then\n+            return;\n+\n+         --  Otherwise we can use Reallocate to get a table of the right size.\n+         --  Note that Reallocate works fine to allocate a table of the right\n+         --  initial size when it is first allocated.\n+\n+         else\n+            Reallocate;\n+         end if;\n+      end Init;\n+\n+      ----------\n+      -- Last --\n+      ----------\n+\n+      function Last return Table_Index_Type is\n+      begin\n+         return Table_Index_Type (Last_Val);\n+      end Last;\n+\n+      ----------------\n+      -- Reallocate --\n+      ----------------\n+\n+      procedure Reallocate is\n+\n+         function realloc\n+           (memblock : Table_Ptr;\n+            size     : size_t)\n+            return     Table_Ptr;\n+         pragma Import (C, realloc);\n+\n+         function malloc\n+           (size     : size_t)\n+            return     Table_Ptr;\n+         pragma Import (C, malloc);\n+\n+         New_Size : size_t;\n+\n+      begin\n+         if Max < Last_Val then\n+            pragma Assert (not Locked);\n+\n+            --  Make sure that we have at least the initial allocation. This\n+            --  is needed in cases where a zero length table is written out.\n+\n+            Length := Int'Max (Length, Table_Initial);\n+\n+            --  Now increment table length until it is sufficiently large\n+\n+            while Max < Last_Val loop\n+               Length := Length * (100 + Table_Increment) / 100;\n+               Max := Min + Length - 1;\n+            end loop;\n+\n+            if Debug_Flag_D then\n+               Write_Str (\"--> Allocating new \");\n+               Write_Str (Table_Name);\n+               Write_Str (\" table, size = \");\n+               Write_Int (Max - Min + 1);\n+               Write_Eol;\n+            end if;\n+         end if;\n+\n+         New_Size :=\n+           size_t ((Max - Min + 1) *\n+                   (Table_Type'Component_Size / Storage_Unit));\n+\n+         if Table = null then\n+            Table := malloc (New_Size);\n+\n+         elsif New_Size > 0 then\n+            Table :=\n+              realloc\n+                (memblock => Table,\n+                 size     => New_Size);\n+         end if;\n+\n+         if Length /= 0 and then Table = null then\n+            Set_Standard_Error;\n+            Write_Str (\"available memory exhausted\");\n+            Write_Eol;\n+            Set_Standard_Output;\n+            raise Unrecoverable_Error;\n+         end if;\n+\n+      end Reallocate;\n+\n+      -------------\n+      -- Release --\n+      -------------\n+\n+      procedure Release is\n+      begin\n+         Length := Last_Val - Int (Table_Low_Bound) + 1;\n+         Max    := Last_Val;\n+         Reallocate;\n+      end Release;\n+\n+      -------------\n+      -- Restore --\n+      -------------\n+\n+      procedure Restore (T : Saved_Table) is\n+      begin\n+         free (Table);\n+         Last_Val := T.Last_Val;\n+         Max      := T.Max;\n+         Table    := T.Table;\n+         Length   := Max - Min + 1;\n+      end Restore;\n+\n+      ----------\n+      -- Save --\n+      ----------\n+\n+      function Save return Saved_Table is\n+         Res : Saved_Table;\n+\n+      begin\n+         Res.Last_Val := Last_Val;\n+         Res.Max      := Max;\n+         Res.Table    := Table;\n+\n+         Table  := null;\n+         Length := 0;\n+         Init;\n+         return Res;\n+      end Save;\n+\n+      --------------\n+      -- Set_Item --\n+      --------------\n+\n+      procedure Set_Item\n+         (Index : Table_Index_Type;\n+          Item  : Table_Component_Type)\n+      is\n+      begin\n+         if Int (Index) > Max then\n+            Set_Last (Index);\n+         end if;\n+\n+         Table (Index) := Item;\n+      end Set_Item;\n+\n+      --------------\n+      -- Set_Last --\n+      --------------\n+\n+      procedure Set_Last (New_Val : Table_Index_Type) is\n+      begin\n+         if Int (New_Val) < Last_Val then\n+            Last_Val := Int (New_Val);\n+         else\n+            Last_Val := Int (New_Val);\n+\n+            if Last_Val > Max then\n+               Reallocate;\n+            end if;\n+         end if;\n+      end Set_Last;\n+\n+      ----------------------------\n+      -- Tree_Get_Table_Address --\n+      ----------------------------\n+\n+      function Tree_Get_Table_Address return Address is\n+      begin\n+         if Length = 0 then\n+            return Null_Address;\n+         else\n+            return Table (First)'Address;\n+         end if;\n+      end Tree_Get_Table_Address;\n+\n+      ---------------\n+      -- Tree_Read --\n+      ---------------\n+\n+      --  Note: we allocate only the space required to accomodate the data\n+      --  actually written, which means that a Tree_Write/Tree_Read sequence\n+      --  does an implicit Release.\n+\n+      procedure Tree_Read is\n+      begin\n+         Tree_Read_Int (Max);\n+         Last_Val := Max;\n+         Length := Max - Min + 1;\n+         Reallocate;\n+\n+         Tree_Read_Data\n+           (Tree_Get_Table_Address,\n+             (Last_Val - Int (First) + 1) *\n+               Table_Type'Component_Size / Storage_Unit);\n+      end Tree_Read;\n+\n+      ----------------\n+      -- Tree_Write --\n+      ----------------\n+\n+      --  Note: we write out only the currently valid data, not the entire\n+      --  contents of the allocated array. See note above on Tree_Read.\n+\n+      procedure Tree_Write is\n+      begin\n+         Tree_Write_Int (Int (Last));\n+         Tree_Write_Data\n+           (Tree_Get_Table_Address,\n+            (Last_Val - Int (First) + 1) *\n+              Table_Type'Component_Size / Storage_Unit);\n+      end Tree_Write;\n+\n+   begin\n+      Init;\n+   end Table;\n+end Table;"}, {"sha": "4588e4d0e8953ff5cc06bf0c917c2182af3b99d8", "filename": "gcc/ada/table.ads", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,225 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                T A B L E                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.38 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an implementation of dynamically resizable one\n+--  dimensional arrays. The idea is to mimic the normal Ada semantics for\n+--  arrays as closely as possible with the one additional capability of\n+--  dynamically modifying the value of the Last attribute.\n+\n+--  Note that this interface should remain synchronized with those in\n+--  GNAT.Table and GNAT.Dynamic_Tables to keep coherency between these\n+--  three related units.\n+\n+with Types; use Types;\n+\n+package Table is\n+pragma Elaborate_Body (Table);\n+\n+   generic\n+      type Table_Component_Type is private;\n+      type Table_Index_Type     is range <>;\n+\n+      Table_Low_Bound  : Table_Index_Type;\n+      Table_Initial    : Pos;\n+      Table_Increment  : Nat;\n+      Table_Name       : String;\n+\n+   package Table is\n+\n+      --  Table_Component_Type and Table_Index_Type specify the type of the\n+      --  array, Table_Low_Bound is the lower bound. Index_type must be an\n+      --  integer type. The effect is roughly to declare:\n+\n+      --    Table : array (Table_Index_Type range Table_Low_Bound .. <>)\n+      --                       of Table_Component_Type;\n+\n+      --    Note: since the upper bound can be one less than the lower\n+      --    bound for an empty array, the table index type must be able\n+      --    to cover this range, e.g. if the lower bound is 1, then the\n+      --    Table_Index_Type should be Natural rather than Positive.\n+\n+      --  Table_Component_Type may be any Ada type, except that controlled\n+      --  types are not supported. Note however that default initialization\n+      --  will NOT occur for array components.\n+\n+      --  The Table_Initial values controls the allocation of the table when\n+      --  it is first allocated, either by default, or by an explicit Init\n+      --  call. The value used is Opt.Table_Factor * Table_Initial.\n+\n+      --  The Table_Increment value controls the amount of increase, if the\n+      --  table has to be increased in size. The value given is a percentage\n+      --  value (e.g. 100 = increase table size by 100%, i.e. double it).\n+\n+      --  The Table_Name parameter is simply use in debug output messages it\n+      --  has no other usage, and is not referenced in non-debugging mode.\n+\n+      --  The Last and Set_Last subprograms provide control over the current\n+      --  logical allocation. They are quite efficient, so they can be used\n+      --  freely (expensive reallocation occurs only at major granularity\n+      --  chunks controlled by the allocation parameters).\n+\n+      --  Note: we do not make the table components aliased, since this would\n+      --  restict the use of table for discriminated types. If it is necessary\n+      --  to take the access of a table element, use Unrestricted_Access.\n+\n+      type Table_Type is\n+        array (Table_Index_Type range <>) of Table_Component_Type;\n+\n+      subtype Big_Table_Type is\n+        Table_Type (Table_Low_Bound .. Table_Index_Type'Last);\n+      --  We work with pointers to a bogus array type that is constrained\n+      --  with the maximum possible range bound. This means that the pointer\n+      --  is a thin pointer, which is more efficient. Since subscript checks\n+      --  in any case must be on the logical, rather than physical bounds,\n+      --  safety is not compromised by this approach.\n+\n+      type Table_Ptr is access all Big_Table_Type;\n+      --  The table is actually represented as a pointer to allow reallocation\n+\n+      Table : aliased Table_Ptr := null;\n+      --  The table itself. The lower bound is the value of Low_Bound.\n+      --  Logically the upper bound is the current value of Last (although\n+      --  the actual size of the allocated table may be larger than this).\n+      --  The program may only access and modify Table entries in the range\n+      --  First .. Last.\n+\n+      Locked : Boolean := False;\n+      --  Table expansion is permitted only if this switch is set to False. A\n+      --  client may set Locked to True, in which case any attempt to expand\n+      --  the table will cause an assertion failure. Note that while a table\n+      --  is locked, its address in memory remains fixed and unchanging. This\n+      --  feature is used to control table expansion during Gigi processing.\n+      --  Gigi assumes that tables other than the Uint and Ureal tables do\n+      --  not move during processing, which means that they cannot be expanded.\n+      --  The Locked flag is used to enforce this restriction.\n+\n+      procedure Init;\n+      --  This procedure allocates a new table of size Initial (freeing any\n+      --  previously allocated larger table). It is not necessary to call\n+      --  Init when a table is first instantiated (since the instantiation does\n+      --  the same initialization steps). However, it is harmless to do so, and\n+      --  Init is convenient in reestablishing a table for new use.\n+\n+      function Last return Table_Index_Type;\n+      pragma Inline (Last);\n+      --  Returns the current value of the last used entry in the table, which\n+      --  can then be used as a subscript for Table. Note that the only way to\n+      --  modify Last is to call the Set_Last procedure. Last must always be\n+      --  used to determine the logically last entry.\n+\n+      procedure Release;\n+      --  Storage is allocated in chunks according to the values given in the\n+      --  Initial and Increment parameters. A call to Release releases all\n+      --  storage that is allocated, but is not logically part of the current\n+      --  array value. Current array values are not affected by this call.\n+\n+      procedure Free;\n+      --  Free all allocated memory for the table. A call to init is required\n+      --  before any use of this table after calling Free.\n+\n+      First : constant Table_Index_Type := Table_Low_Bound;\n+      --  Export First as synonym for Low_Bound (parallel with use of Last)\n+\n+      procedure Set_Last (New_Val : Table_Index_Type);\n+      pragma Inline (Set_Last);\n+      --  This procedure sets Last to the indicated value. If necessary the\n+      --  table is reallocated to accomodate the new value (i.e. on return\n+      --  the allocated table has an upper bound of at least Last). If Set_Last\n+      --  reduces the size of the table, then logically entries are removed\n+      --  from the table. If Set_Last increases the size of the table, then\n+      --  new entries are logically added to the table.\n+\n+      procedure Increment_Last;\n+      pragma Inline (Increment_Last);\n+      --  Adds 1 to Last (same as Set_Last (Last + 1).\n+\n+      procedure Decrement_Last;\n+      pragma Inline (Decrement_Last);\n+      --  Subtracts 1 from Last (same as Set_Last (Last - 1).\n+\n+      procedure Append (New_Val : Table_Component_Type);\n+      pragma Inline (Append);\n+      --  Equivalent to:\n+      --    x.Increment_Last;\n+      --    x.Table (x.Last) := New_Val;\n+      --  i.e. the table size is increased by one, and the given new item\n+      --  stored in the newly created table element.\n+\n+      procedure Set_Item\n+        (Index : Table_Index_Type;\n+         Item  : Table_Component_Type);\n+      pragma Inline (Set_Item);\n+      --  Put Item in the table at position Index. The table is expanded if\n+      --  current table length is less than Index and in that case Last is set\n+      --  to Index. Item will replace any value already present in the table\n+      --  at this position.\n+\n+      type Saved_Table is private;\n+      --  Type used for Save/Restore subprograms\n+\n+      function Save return Saved_Table;\n+      --  Resets table to empty, but saves old contents of table in returned\n+      --  value, for possible later restoration by a call to Restore.\n+\n+      procedure Restore (T : Saved_Table);\n+      --  Given a Saved_Table value returned by a prior call to Save, restores\n+      --  the table to the state it was in at the time of the Save call.\n+\n+      procedure Tree_Write;\n+      --  Writes out contents of table using Tree_IO\n+\n+      procedure Tree_Read;\n+      --  Initializes table by reading contents previously written\n+      --  with the Tree_Write call (also using Tree_IO)\n+\n+   private\n+\n+      Last_Val : Int;\n+      --  Current value of Last. Note that we declare this in the private part\n+      --  because we don't want the client to modify Last except through one of\n+      --  the official interfaces (since a modification to Last may require a\n+      --  reallocation of the table).\n+\n+      Max : Int;\n+      --  Subscript of the maximum entry in the currently allocated table\n+\n+      type Saved_Table is record\n+         Last_Val : Int;\n+         Max      : Int;\n+         Table    : Table_Ptr;\n+      end record;\n+\n+   end Table;\n+end Table;"}, {"sha": "9e823d89971180c6dd06c680b91e8efa65e0d774", "filename": "gcc/ada/targparm.adb", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,228 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                             T A R G P A R M                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.15 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Namet;    use Namet;\n+with Output;   use Output;\n+with Sinput;   use Sinput;\n+with Sinput.L; use Sinput.L;\n+with Fname.UF; use Fname.UF;\n+with Types;    use Types;\n+\n+package body Targparm is\n+\n+   type Targparm_Tags is\n+     (AAM, CLA, DEN, DSP, FEL, HIM, LSI, MOV,\n+      MRN, SCD, SCP, SNZ, UAM, VMS, ZCD, ZCG, ZCF);\n+\n+   Targparm_Flags : array (Targparm_Tags) of Boolean := (others => False);\n+   --  Flag is set True if corresponding parameter is scanned\n+\n+   AAM_Str : aliased constant Source_Buffer := \"AAMP\";\n+   CLA_Str : aliased constant Source_Buffer := \"Command_Line_Args\";\n+   DEN_Str : aliased constant Source_Buffer := \"Denorm\";\n+   DSP_Str : aliased constant Source_Buffer := \"Functions_Return_By_DSP\";\n+   FEL_Str : aliased constant Source_Buffer := \"Frontend_Layout\";\n+   HIM_Str : aliased constant Source_Buffer := \"High_Integrity_Mode\";\n+   LSI_Str : aliased constant Source_Buffer := \"Long_Shifts_Inlined\";\n+   MOV_Str : aliased constant Source_Buffer := \"Machine_Overflows\";\n+   MRN_Str : aliased constant Source_Buffer := \"Machine_Rounds\";\n+   SCD_Str : aliased constant Source_Buffer := \"Stack_Check_Default\";\n+   SCP_Str : aliased constant Source_Buffer := \"Stack_Check_Probes\";\n+   SNZ_Str : aliased constant Source_Buffer := \"Signed_Zeros\";\n+   UAM_Str : aliased constant Source_Buffer := \"Use_Ada_Main_Program_Name\";\n+   VMS_Str : aliased constant Source_Buffer := \"OpenVMS\";\n+   ZCD_Str : aliased constant Source_Buffer := \"ZCX_By_Default\";\n+   ZCG_Str : aliased constant Source_Buffer := \"GCC_ZCX_Support\";\n+   ZCF_Str : aliased constant Source_Buffer := \"Front_End_ZCX_Support\";\n+\n+   type Buffer_Ptr is access constant Source_Buffer;\n+   Targparm_Str : array (Targparm_Tags) of Buffer_Ptr :=\n+     (AAM_Str'Access,\n+      CLA_Str'Access,\n+      DEN_Str'Access,\n+      DSP_Str'Access,\n+      FEL_Str'Access,\n+      HIM_Str'Access,\n+      LSI_Str'Access,\n+      MOV_Str'Access,\n+      MRN_Str'Access,\n+      SCD_Str'Access,\n+      SCP_Str'Access,\n+      SNZ_Str'Access,\n+      UAM_Str'Access,\n+      VMS_Str'Access,\n+      ZCD_Str'Access,\n+      ZCG_Str'Access,\n+      ZCF_Str'Access);\n+\n+   ---------------------------\n+   -- Get_Target_Parameters --\n+   ---------------------------\n+\n+   procedure Get_Target_Parameters is\n+      use ASCII;\n+\n+      S : Source_File_Index;\n+      N : Name_Id;\n+      T : Source_Buffer_Ptr;\n+      P : Source_Ptr;\n+      Z : Source_Ptr;\n+\n+      Fatal : Boolean := False;\n+      --  Set True if a fatal error is detected\n+\n+      Result : Boolean;\n+      --  Records boolean from system line\n+\n+   begin\n+      Name_Buffer (1 .. 6) := \"system\";\n+      Name_Len := 6;\n+      N := File_Name_Of_Spec (Name_Find);\n+      S := Load_Source_File (N);\n+\n+      if S = No_Source_File then\n+         Write_Line (\"fatal error, run-time library not installed correctly\");\n+         Write_Str (\"cannot locate file \");\n+         Write_Line (Name_Buffer (1 .. Name_Len));\n+         raise Unrecoverable_Error;\n+\n+      --  This must always be the first source file read, and we have defined\n+      --  a constant Types.System_Source_File_Index as 1 to reflect this.\n+\n+      else\n+         pragma Assert (S = System_Source_File_Index);\n+         null;\n+      end if;\n+\n+      P := Source_First (S);\n+      Z := Source_Last  (S);\n+      T := Source_Text  (S);\n+\n+      while T (P .. P + 10) /= \"end System;\" loop\n+\n+         for K in Targparm_Tags loop\n+            if T (P + 3 .. P + 2 + Targparm_Str (K)'Length) =\n+                                                   Targparm_Str (K).all\n+            then\n+               P := P + 3 + Targparm_Str (K)'Length;\n+\n+               if Targparm_Flags (K) then\n+                  Set_Standard_Error;\n+                  Write_Line\n+                    (\"fatal error: system.ads is incorrectly formatted\");\n+                  Write_Str (\"duplicate line for parameter: \");\n+\n+                  for J in Targparm_Str (K)'Range loop\n+                     Write_Char (Targparm_Str (K).all (J));\n+                  end loop;\n+\n+                  Write_Eol;\n+                  Set_Standard_Output;\n+                  Fatal := True;\n+\n+               else\n+                  Targparm_Flags (K) := True;\n+               end if;\n+\n+               while T (P) /= ':' or else T (P + 1) /= '=' loop\n+                  P := P + 1;\n+               end loop;\n+\n+               P := P + 2;\n+\n+               while T (P) = ' ' loop\n+                  P := P + 1;\n+               end loop;\n+\n+               Result := (T (P) = 'T');\n+\n+               case K is\n+                  when AAM => AAMP_On_Target                      := Result;\n+                  when CLA => Command_Line_Args_On_Target         := Result;\n+                  when DEN => Denorm_On_Target                    := Result;\n+                  when DSP => Functions_Return_By_DSP_On_Target   := Result;\n+                  when FEL => Frontend_Layout_On_Target           := Result;\n+                  when HIM => High_Integrity_Mode_On_Target       := Result;\n+                  when LSI => Long_Shifts_Inlined_On_Target       := Result;\n+                  when MOV => Machine_Overflows_On_Target         := Result;\n+                  when MRN => Machine_Rounds_On_Target            := Result;\n+                  when SCD => Stack_Check_Default_On_Target       := Result;\n+                  when SCP => Stack_Check_Probes_On_Target        := Result;\n+                  when SNZ => Signed_Zeros_On_Target              := Result;\n+                  when UAM => Use_Ada_Main_Program_Name_On_Target := Result;\n+                  when VMS => OpenVMS_On_Target                   := Result;\n+                  when ZCD => ZCX_By_Default_On_Target            := Result;\n+                  when ZCG => GCC_ZCX_Support_On_Target           := Result;\n+                  when ZCF => Front_End_ZCX_Support_On_Target     := Result;\n+               end case;\n+\n+               exit;\n+            end if;\n+         end loop;\n+\n+         while T (P) /= CR and then T (P) /= LF loop\n+            P := P + 1;\n+            exit when P >= Z;\n+         end loop;\n+\n+         while T (P) = CR or else T (P) = LF loop\n+            P := P + 1;\n+            exit when P >= Z;\n+         end loop;\n+\n+         if P >= Z then\n+            Set_Standard_Error;\n+            Write_Line (\"fatal error, system.ads not formatted correctly\");\n+            Set_Standard_Output;\n+            raise Unrecoverable_Error;\n+         end if;\n+      end loop;\n+\n+      for K in Targparm_Tags loop\n+         if not Targparm_Flags (K) then\n+            Set_Standard_Error;\n+            Write_Line\n+              (\"fatal error: system.ads is incorrectly formatted\");\n+            Write_Str (\"missing line for parameter: \");\n+\n+            for J in Targparm_Str (K)'Range loop\n+               Write_Char (Targparm_Str (K).all (J));\n+            end loop;\n+\n+            Write_Eol;\n+            Set_Standard_Output;\n+            Fatal := True;\n+         end if;\n+      end loop;\n+\n+      if Fatal then\n+         raise Unrecoverable_Error;\n+      end if;\n+   end Get_Target_Parameters;\n+\n+end Targparm;"}, {"sha": "2346fd209e73aa3727969fe2bf2471c500dd0111", "filename": "gcc/ada/targparm.ads", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftargparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftargparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,288 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                             T A R G P A R M                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package obtains parameters from the target runtime version of\n+--  System, to indicate parameters relevant to the target environment.\n+\n+--  Conceptually, these parameters could be obtained using rtsfind, but\n+--  we do not do this for three reasons:\n+\n+--    1. Compiling System for every compilation wastes time\n+--    2. This compilation impedes debugging by adding extra compile steps\n+--    3. There are recursion problems coming from compiling System itself\n+--        or any of its children.\n+\n+--  For all these reasons, we read in the source of System, and then scan\n+--  it at the text level to extract the parameter values.\n+\n+--  Note however, that later on, when the ali file is written, we make sure\n+--  that the System file is at least parsed, so that the checksum is properly\n+--  computed and set in the ali file. This partially negates points 1 and 2\n+--  above although just parsing is quick and does not impact debugging much.\n+\n+package Targparm is\n+\n+   --  The following parameters correspond to the variables defined in the\n+   --  private part of System (without the terminating _On_Target). Note\n+   --  that it is required that all parameters be specified in system.ads.\n+\n+   -----------------------------------\n+   -- Control of Exception Handling --\n+   -----------------------------------\n+\n+   --  GNAT provides two methods of implementing exceptions:\n+\n+   --    Longjmp/Setjmp (-gnatL)\n+\n+   --      This approach uses longjmp/setjmp to handle exceptions. It\n+   --      uses less storage, and can often propagate exceptions faster,\n+   --      at the expense of (sometimes considerable) overhead in setting\n+   --      up an exception handler. This approach is available on all\n+   --      targets, and is the default where it is the only approach.\n+\n+   --    Zero Cost (-gnatZ)\n+\n+   --      This approach uses separate exception tables. These use extra\n+   --      storage, and exception propagation can be quite slow, but there\n+   --      is no overhead in setting up an exception handler (it is to this\n+   --      latter operation that the phrase zero-cost refers). This approach\n+   --      is only available on some targets, and is the default where it is\n+   --      available.\n+\n+   ZCX_By_Default_On_Target : Boolean;\n+   --  Indicates if zero cost exceptions are active by default. Can be modified\n+   --  by the use of -gnatZ and -gnatL switches.\n+\n+   GCC_ZCX_Support_On_Target  : Boolean;\n+   --  Indicates that when ZCX is active the mechanism to be used is the\n+   --  standard GCC ZCX mechanism  (introduced in GCC 3.1)\n+\n+   Front_End_ZCX_Support_On_Target : Boolean;\n+   --  Indicates that when ZCX is active (and GCC_ZCX_Support is not set)\n+   --  the mechanism to be used is the GNAT front end specific ZCX mechanism\n+\n+   ---------------------------------------\n+   -- High_Integrity (No Run Time) Mode --\n+   ---------------------------------------\n+\n+   --  In High_Integrity mode, there is no system run-time, and the flag\n+   --  Opt.No_Run_Time is set so that the language is appropriately\n+   --  restricted to forbid construct that would generate run-time calls.\n+\n+   High_Integrity_Mode_On_Target : Boolean;\n+   --  Indicates that this build is for a high integrity mode version of\n+   --  GNAT, so that no run time is permitted.\n+\n+   -------------------------------\n+   -- Control of Stack Checking --\n+   -------------------------------\n+\n+   --  GNAT provides two methods of implementing exceptions:\n+\n+   --    GCC Probing Mechanism\n+\n+   --      This approach uses the standard GCC mechanism for\n+   --      stack checking. The method assumes that accessing\n+   --      storage immediately beyond the end of the stack\n+   --      will result in a trap that is converted to a storage\n+   --      error by the runtime system. This mechanism has\n+   --      minimal overhead, but requires complex hardware,\n+   --      operating system and run-time support. Probing is\n+   --      the default method where it is available. The stack\n+   --      size for the environment task depends on the operating\n+   --      system and cannot be set in a system-independent way.\n+\n+   --   GNAT Stack-limit Checking\n+\n+   --      This method relies on comparing the stack pointer\n+   --      with per-task stack limits. If the check fails, an\n+   --      exception is explicitly raised. The advantage is\n+   --      that the method requires no extra system dependent\n+   --      runtime support and can be used on systems without\n+   --      memory protection as well, but at the cost of more\n+   --      overhead for doing the check. This method is the\n+   --      default on systems that lack complete support for\n+   --      probing.\n+\n+   Stack_Check_Probes_On_Target : Boolean;\n+   --  Indicates if stack check probes are used, as opposed to the standard\n+   --  target independent comparison method.\n+\n+   Stack_Check_Default_On_Target : Boolean;\n+   --  Indicates if stack checking is on by default\n+\n+   ----------------------------\n+   -- Command Line Arguments --\n+   ----------------------------\n+\n+   --  For most ports of GNAT, command line arguments are supported. The\n+   --  following flag is set to False for targets that do not support\n+   --  command line arguments (notably VxWorks).\n+\n+   Command_Line_Args_On_Target : Boolean;\n+   --  Set False if no command line arguments on target\n+\n+   --  Note: this is prepared for future use, but not yet used, since we\n+   --  do not yet have a way of propagating Targparm params to the binder\n+\n+   -----------------------\n+   -- Main Program Name --\n+   -----------------------\n+\n+   --  When the binder generates the main program to be used to create the\n+   --  executable, the main program name is main by default (to match the\n+   --  usual Unix practice). If this parameter is set to True, then the\n+   --  name is instead by default taken from the actual Ada main program\n+   --  name (just the name of the child if the main program is a child unit).\n+   --  In either case, this value can be overridden using -M name.\n+\n+   Use_Ada_Main_Program_Name_On_Target : Boolean;\n+   --  Set True to use the Ada main program name as the main name\n+\n+   --  Note: this is prepared for future use, but not yet used, since we\n+   --  do not yet have a way of propagating Targparm params to the binder\n+\n+   ----------------------------\n+   -- Support of Long Shifts --\n+   ----------------------------\n+\n+   --  In GNORT mode, we cannot call library routines, and in particular\n+   --  we cannot call routines for long (64-bit) shifts if such routines\n+   --  are required on the target. This comes up in the context of support\n+   --  of packed arrays. We can only represent packed arrays whose length\n+   --  is in the range 33- to 64-bits as modular types if long shifts are\n+   --  done with inline code.\n+\n+   --  For the default version, for now we set long shifts inlined as True\n+   --  This may not be quite accurate, but until we get proper separate\n+   --  System's for each target, it is a safer choice.\n+\n+   Long_Shifts_Inlined_On_Target : Boolean;\n+   --  Indicates if long (double word) shifts are generated using inlined\n+   --  code (and thus are permissible in No_Run_Time mode).\n+\n+   ----------------------------------------------\n+   -- Boolean-Valued Floating-Point Attributes --\n+   ----------------------------------------------\n+\n+   --  The constants below give the values for representation oriented\n+   --  floating-point attributes that are the same for all float types\n+   --  on the target. These are all boolean values.\n+\n+   --  A value is only True if the target reliably supports the corresponding\n+   --  feature. Reliably here means that support is guaranteed for all\n+   --  possible settings of the relevant compiler switches (like -mieee),\n+   --  since we cannot control the user setting of those switches.\n+\n+   --  The attributes cannot dependent on the current setting of compiler\n+   --  switches, since the values must be static and consistent throughout\n+   --  the partition. We probably should add such consistency checks in future,\n+   --  but for now we don't do this.\n+\n+   AAMP_On_Target : Boolean;\n+   --  Set to True if target is AAMP.\n+\n+   Denorm_On_Target : Boolean;\n+   --  Set to False on targets that do not reliably support denormals.\n+   --  Reliably here means for all settings of the relevant -m flag, so\n+   --  for example, this is False on the Alpha where denormals are not\n+   --  supported unless -mieee is used.\n+\n+   Machine_Rounds_On_Target : Boolean;\n+   --  Set to False for targets where S'Machine_Rounds is False\n+\n+   Machine_Overflows_On_Target : Boolean;\n+   --  Set to True for targets where S'Machine_Overflows is True\n+\n+   Signed_Zeros_On_Target : Boolean;\n+   --  Set to False on targets that do not reliably support signed zeros.\n+\n+   OpenVMS_On_Target : Boolean;\n+   --  Set to True if target is OpenVMS.\n+\n+   --------------------------------------------------------------\n+   -- Handling of Unconstrained Values Returned from Functions --\n+   --------------------------------------------------------------\n+\n+   --  Functions that return variable length objects, notably unconstrained\n+   --  arrays are a special case, because there is no simple obvious way of\n+   --  implementing this feature. Furthermore, this capability is not present\n+   --  in C++ or C, so typically the system ABI does not handle this case.\n+\n+   --  GNAT uses two different approaches\n+\n+   --    The Secondary Stack\n+\n+   --      The secondary stack is a special storage pool that is used for\n+   --      this purpose. The called function places the result on the\n+   --      secondary stack, and the caller uses or copies the value from\n+   --      the secondary stack, and pops the secondary stack after the\n+   --      value is consumed. The secondary stack is outside the system\n+   --      ABI, and the important point is that although generally it is\n+   --      handled in a stack like manner corresponding to the subprogram\n+   --      call structure, a return from a function does NOT pop the stack.\n+\n+   --    DSP (Depressed Stack Pointer)\n+\n+   --      Some targets permit the implementation of a function call/return\n+   --      protocol in which the function does not pop the main stack pointer\n+   --      on return, but rather returns with the stack pointer depressed.\n+   --      This is not generally permitted by any ABI, but for at least some\n+   --      targets, the implementation of alloca provides a model for this\n+   --      approach. If return-with-DSP is implemented, then functions that\n+   --      return variable length objects do it by returning with the stack\n+   --      pointer depressed, and the returned object is a pointer to the\n+   --      area within the stack frame of the called procedure that contains\n+   --      the returned value. The caller must then pop the main stack when\n+   --      this value is consumed.\n+\n+   Functions_Return_By_DSP_On_Target : Boolean;\n+   --  Set to True if target permits functions to return with using the\n+   --  DSP (depressed stack pointer) approach.\n+\n+   -----------------\n+   -- Data Layout --\n+   -----------------\n+\n+   --  Normally when using the GCC backend, Gigi and GCC perform much of the\n+   --  data layout using the standard layout capabilities of GCC. If the\n+   --  parameter Backend_Layout is set to False, then the front end must\n+   --  perform all data layout. For further details see the package Layout.\n+\n+   Frontend_Layout_On_Target : Boolean;\n+   --  Set True if front end does layout\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Get_Target_Parameters;\n+   --  Called at the start of execution to read the source of System and\n+   --  obtain and set the values of the above parameters.\n+\n+end Targparm;"}, {"sha": "900762b2e1e002622ccaf0e613b26d84b1bd984f", "filename": "gcc/ada/targtyps.c", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargtyps.c?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,226 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                            T A R G T Y P S                               *\n+ *                                                                          *\n+ *                                  Body                                    *\n+ *                                                                          *\n+ *                             $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Functions for retrieving target types. See Ada package Get_Targ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"real.h\"\n+#include \"rtl.h\"\n+#include \"ada.h\"\n+#include \"types.h\"\n+#include \"atree.h\"\n+#include \"elists.h\"\n+#include \"namet.h\"\n+#include \"nlists.h\"\n+#include \"snames.h\"\n+#include \"stringt.h\"\n+#include \"uintp.h\"\n+#include \"urealp.h\"\n+#include \"fe.h\"\n+#include \"sinfo.h\"\n+#include \"einfo.h\"\n+#include \"ada-tree.h\"\n+#include \"gigi.h\"\n+\n+#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))\n+\n+/* Standard data type sizes.  Most of these are not used.  */\n+\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+\n+#ifndef SHORT_TYPE_SIZE\n+#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n+#endif\n+\n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifdef OPEN_VMS /* A target macro defined in vms.h */\n+#define LONG_TYPE_SIZE 64\n+#else\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+#endif\n+\n+#ifndef LONG_LONG_TYPE_SIZE\n+#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef FLOAT_TYPE_SIZE\n+#define FLOAT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef DOUBLE_TYPE_SIZE\n+#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef WIDEST_HARDWARE_FP_SIZE\n+#define WIDEST_HARDWARE_FP_SIZE LONG_DOUBLE_TYPE_SIZE\n+#endif\n+\n+/* The following provide a functional interface for the front end Ada code\n+   to determine the sizes that are used for various C types. */\n+\n+Pos\n+get_target_bits_per_unit ()\n+{\n+  return BITS_PER_UNIT;\n+}\n+\n+Pos\n+get_target_bits_per_word ()\n+{\n+  return BITS_PER_WORD;\n+}\n+\n+Pos\n+get_target_char_size ()\n+{\n+  return CHAR_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_wchar_t_size ()\n+{\n+  /* We never want wide chacters less than \"short\" in Ada.  */\n+  return MAX (SHORT_TYPE_SIZE, WCHAR_TYPE_SIZE);\n+}\n+\n+Pos\n+get_target_short_size ()\n+{\n+  return SHORT_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_int_size ()\n+{\n+  return INT_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_long_size ()\n+{\n+  return LONG_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_long_long_size ()\n+{\n+  return LONG_LONG_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_float_size ()\n+{\n+  return FLOAT_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_double_size ()\n+{\n+  return DOUBLE_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_long_double_size ()\n+{\n+  return WIDEST_HARDWARE_FP_SIZE;\n+}\n+\n+Pos\n+get_target_pointer_size ()\n+{\n+  return POINTER_SIZE;\n+}\n+\n+Pos\n+get_target_maximum_alignment ()\n+{\n+  return BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+}\n+\n+Boolean\n+get_target_no_dollar_in_label ()\n+{\n+#ifdef NO_DOLLAR_IN_LABEL\n+  return 1;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+#ifndef FLOAT_WORDS_BIG_ENDIAN\n+#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n+#endif\n+\n+Nat\n+get_float_words_be ()\n+{\n+  return FLOAT_WORDS_BIG_ENDIAN;\n+}\n+\n+Nat\n+get_words_be ()\n+{\n+  return WORDS_BIG_ENDIAN;\n+}\n+\n+Nat\n+get_bytes_be ()\n+{\n+  return BYTES_BIG_ENDIAN;\n+}\n+\n+Nat\n+get_bits_be ()\n+{\n+  return BITS_BIG_ENDIAN;\n+}\n+\n+Nat\n+get_strict_alignment ()\n+{\n+  return STRICT_ALIGNMENT;\n+}"}, {"sha": "3ccd7a7472e067eb262f34e82f75044fbe7bc379", "filename": "gcc/ada/tbuild.adb", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,522 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               T B U I L D                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.98 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Restrict; use Restrict;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Uintp;    use Uintp;\n+\n+package body Tbuild is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Add_Unique_Serial_Number;\n+   --  Add a unique serialization to the string in the Name_Buffer. This\n+   --  consists of a unit specific serial number, and b/s for body/spec.\n+\n+   ------------------------------\n+   -- Add_Unique_Serial_Number --\n+   ------------------------------\n+\n+   procedure Add_Unique_Serial_Number is\n+      Unit_Node : constant Node_Id := Unit (Cunit (Current_Sem_Unit));\n+\n+   begin\n+      Add_Nat_To_Name_Buffer (Increment_Serial_Number);\n+\n+      --  Add either b or s, depending on whether current unit is a spec\n+      --  or a body. This is needed because we may generate the same name\n+      --  in a spec and a body otherwise.\n+\n+      Name_Len := Name_Len + 1;\n+\n+      if Nkind (Unit_Node) = N_Package_Declaration\n+        or else Nkind (Unit_Node) = N_Subprogram_Declaration\n+        or else Nkind (Unit_Node) in N_Generic_Declaration\n+      then\n+         Name_Buffer (Name_Len) := 's';\n+      else\n+         Name_Buffer (Name_Len) := 'b';\n+      end if;\n+   end Add_Unique_Serial_Number;\n+\n+   ----------------\n+   -- Checks_Off --\n+   ----------------\n+\n+   function Checks_Off (N : Node_Id) return Node_Id is\n+   begin\n+      return\n+        Make_Unchecked_Expression (Sloc (N),\n+          Expression => N);\n+   end Checks_Off;\n+\n+   ----------------\n+   -- Convert_To --\n+   ----------------\n+\n+   function Convert_To (Typ : Entity_Id; Expr : Node_Id) return Node_Id is\n+      Result : Node_Id;\n+\n+   begin\n+      if Present (Etype (Expr))\n+        and then (Etype (Expr)) = Typ\n+      then\n+         return Relocate_Node (Expr);\n+      else\n+         Result :=\n+           Make_Type_Conversion (Sloc (Expr),\n+             Subtype_Mark => New_Occurrence_Of (Typ, Sloc (Expr)),\n+             Expression => Relocate_Node (Expr));\n+\n+         Set_Etype (Result, Typ);\n+         return Result;\n+      end if;\n+   end Convert_To;\n+\n+   --------------------\n+   -- Make_DT_Access --\n+   --------------------\n+\n+   function Make_DT_Access\n+     (Loc  : Source_Ptr;\n+      Rec  : Node_Id;\n+      Typ  : Entity_Id)\n+      return Node_Id\n+   is\n+      Full_Type : Entity_Id := Typ;\n+\n+   begin\n+      if Is_Private_Type (Typ) then\n+         Full_Type := Underlying_Type (Typ);\n+      end if;\n+\n+      return\n+        Unchecked_Convert_To (\n+          New_Occurrence_Of (Etype (Access_Disp_Table (Full_Type)), Loc),\n+          Make_Selected_Component (Loc,\n+            Prefix => New_Copy (Rec),\n+            Selector_Name =>\n+              New_Reference_To (Tag_Component (Full_Type), Loc)));\n+   end Make_DT_Access;\n+\n+   -----------------------\n+   -- Make_DT_Component --\n+   -----------------------\n+\n+   function Make_DT_Component\n+     (Loc  : Source_Ptr;\n+      Typ  : Entity_Id;\n+      I    : Positive)\n+      return Node_Id\n+   is\n+      X : Node_Id;\n+      Full_Type : Entity_Id := Typ;\n+\n+   begin\n+      if Is_Private_Type (Typ) then\n+         Full_Type := Underlying_Type (Typ);\n+      end if;\n+\n+      X := First_Component (\n+             Designated_Type (Etype (Access_Disp_Table (Full_Type))));\n+\n+      for J in 2 .. I loop\n+         X := Next_Component (X);\n+      end loop;\n+\n+      return New_Reference_To (X, Loc);\n+   end Make_DT_Component;\n+\n+   --------------------------------\n+   -- Make_Implicit_If_Statement --\n+   --------------------------------\n+\n+   function Make_Implicit_If_Statement\n+     (Node            : Node_Id;\n+      Condition       : Node_Id;\n+      Then_Statements : List_Id;\n+      Elsif_Parts     : List_Id := No_List;\n+      Else_Statements : List_Id := No_List)\n+      return            Node_Id\n+   is\n+   begin\n+      Check_Restriction (No_Implicit_Conditionals, Node);\n+      return Make_If_Statement (Sloc (Node),\n+        Condition,\n+        Then_Statements,\n+        Elsif_Parts,\n+        Else_Statements);\n+   end Make_Implicit_If_Statement;\n+\n+   -------------------------------------\n+   -- Make_Implicit_Label_Declaration --\n+   -------------------------------------\n+\n+   function Make_Implicit_Label_Declaration\n+     (Loc                 : Source_Ptr;\n+      Defining_Identifier : Node_Id;\n+      Label_Construct     : Node_Id)\n+      return                Node_Id\n+   is\n+      N : constant Node_Id :=\n+            Make_Implicit_Label_Declaration (Loc, Defining_Identifier);\n+\n+   begin\n+      Set_Label_Construct (N, Label_Construct);\n+      return N;\n+   end Make_Implicit_Label_Declaration;\n+\n+   ----------------------------------\n+   -- Make_Implicit_Loop_Statement --\n+   ----------------------------------\n+\n+   function Make_Implicit_Loop_Statement\n+     (Node                   : Node_Id;\n+      Statements             : List_Id;\n+      Identifier             : Node_Id := Empty;\n+      Iteration_Scheme       : Node_Id := Empty;\n+      Has_Created_Identifier : Boolean := False;\n+      End_Label              : Node_Id := Empty)\n+      return                   Node_Id\n+   is\n+   begin\n+      Check_Restriction (No_Implicit_Loops, Node);\n+\n+      if Present (Iteration_Scheme)\n+        and then Present (Condition (Iteration_Scheme))\n+      then\n+         Check_Restriction (No_Implicit_Conditionals, Node);\n+      end if;\n+\n+      return Make_Loop_Statement (Sloc (Node),\n+        Identifier             => Identifier,\n+        Iteration_Scheme       => Iteration_Scheme,\n+        Statements             => Statements,\n+        Has_Created_Identifier => Has_Created_Identifier,\n+        End_Label              => End_Label);\n+   end Make_Implicit_Loop_Statement;\n+\n+   --------------------------\n+   -- Make_Integer_Literal --\n+   ---------------------------\n+\n+   function Make_Integer_Literal\n+     (Loc    : Source_Ptr;\n+      Intval : Int)\n+      return   Node_Id\n+   is\n+   begin\n+      return Make_Integer_Literal (Loc, UI_From_Int (Intval));\n+   end Make_Integer_Literal;\n+\n+   ---------------------------\n+   -- Make_Unsuppress_Block --\n+   ---------------------------\n+\n+   --  Generates the following expansion:\n+\n+   --    declare\n+   --       pragma Suppress (<check>);\n+   --    begin\n+   --       <stmts>\n+   --    end;\n+\n+   function Make_Unsuppress_Block\n+     (Loc   : Source_Ptr;\n+      Check : Name_Id;\n+      Stmts : List_Id)\n+      return  Node_Id\n+   is\n+   begin\n+      return\n+        Make_Block_Statement (Loc,\n+          Declarations => New_List (\n+            Make_Pragma (Loc,\n+              Chars => Name_Suppress,\n+              Pragma_Argument_Associations => New_List (\n+                Make_Pragma_Argument_Association (Loc,\n+                  Expression => Make_Identifier (Loc, Check))))),\n+\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => Stmts));\n+   end Make_Unsuppress_Block;\n+\n+   --------------------------\n+   -- New_Constraint_Error --\n+   --------------------------\n+\n+   function New_Constraint_Error (Loc : Source_Ptr) return Node_Id is\n+      Ident_Node : Node_Id;\n+      Raise_Node : Node_Id;\n+\n+   begin\n+      Ident_Node := New_Node (N_Identifier, Loc);\n+      Set_Chars (Ident_Node, Chars (Standard_Entity (S_Constraint_Error)));\n+      Set_Entity (Ident_Node, Standard_Entity (S_Constraint_Error));\n+      Raise_Node := New_Node (N_Raise_Statement, Loc);\n+      Set_Name (Raise_Node, Ident_Node);\n+      return Raise_Node;\n+   end New_Constraint_Error;\n+\n+   -----------------------\n+   -- New_External_Name --\n+   -----------------------\n+\n+   function New_External_Name\n+     (Related_Id   : Name_Id;\n+      Suffix       : Character := ' ';\n+      Suffix_Index : Int       := 0;\n+      Prefix       : Character := ' ')\n+      return         Name_Id\n+   is\n+   begin\n+      Get_Name_String (Related_Id);\n+\n+      if Prefix /= ' ' then\n+         pragma Assert (Is_OK_Internal_Letter (Prefix));\n+\n+         for J in reverse 1 .. Name_Len loop\n+            Name_Buffer (J + 1) := Name_Buffer (J);\n+         end loop;\n+\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (1) := Prefix;\n+      end if;\n+\n+      if Suffix /= ' ' then\n+         pragma Assert (Is_OK_Internal_Letter (Suffix));\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (Name_Len) := Suffix;\n+      end if;\n+\n+      if Suffix_Index /= 0 then\n+         if Suffix_Index < 0 then\n+            Add_Unique_Serial_Number;\n+         else\n+            Add_Nat_To_Name_Buffer (Suffix_Index);\n+         end if;\n+      end if;\n+\n+      return Name_Find;\n+   end New_External_Name;\n+\n+   function New_External_Name\n+     (Related_Id   : Name_Id;\n+      Suffix       : String;\n+      Suffix_Index : Int       := 0;\n+      Prefix       : Character := ' ')\n+      return         Name_Id\n+   is\n+   begin\n+      Get_Name_String (Related_Id);\n+\n+      if Prefix /= ' ' then\n+         pragma Assert (Is_OK_Internal_Letter (Prefix));\n+\n+         for J in reverse 1 .. Name_Len loop\n+            Name_Buffer (J + 1) := Name_Buffer (J);\n+         end loop;\n+\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (1) := Prefix;\n+      end if;\n+\n+      if Suffix /= \"\" then\n+         Name_Buffer (Name_Len + 1 .. Name_Len + Suffix'Length) := Suffix;\n+         Name_Len := Name_Len + Suffix'Length;\n+      end if;\n+\n+      if Suffix_Index /= 0 then\n+         if Suffix_Index < 0 then\n+            Add_Unique_Serial_Number;\n+         else\n+            Add_Nat_To_Name_Buffer (Suffix_Index);\n+         end if;\n+      end if;\n+\n+      return Name_Find;\n+   end New_External_Name;\n+\n+   function New_External_Name\n+     (Suffix       : Character;\n+      Suffix_Index : Nat)\n+      return         Name_Id\n+   is\n+   begin\n+      Name_Buffer (1) := Suffix;\n+      Name_Len := 1;\n+      Add_Nat_To_Name_Buffer (Suffix_Index);\n+      return Name_Find;\n+   end New_External_Name;\n+\n+   -----------------------\n+   -- New_Internal_Name --\n+   -----------------------\n+\n+   function New_Internal_Name (Id_Char : Character) return Name_Id is\n+   begin\n+      pragma Assert (Is_OK_Internal_Letter (Id_Char));\n+      Name_Buffer (1) := Id_Char;\n+      Name_Len := 1;\n+      Add_Unique_Serial_Number;\n+      return Name_Enter;\n+   end New_Internal_Name;\n+\n+   -----------------------\n+   -- New_Occurrence_Of --\n+   -----------------------\n+\n+   function New_Occurrence_Of\n+     (Def_Id : Entity_Id;\n+      Loc    : Source_Ptr)\n+      return   Node_Id\n+   is\n+      Occurrence : Node_Id;\n+\n+   begin\n+      Occurrence := New_Node (N_Identifier, Loc);\n+      Set_Chars (Occurrence, Chars (Def_Id));\n+      Set_Entity (Occurrence, Def_Id);\n+\n+      if Is_Type (Def_Id) then\n+         Set_Etype (Occurrence, Def_Id);\n+      else\n+         Set_Etype (Occurrence, Etype (Def_Id));\n+      end if;\n+\n+      return Occurrence;\n+   end New_Occurrence_Of;\n+\n+   ----------------------\n+   -- New_Reference_To --\n+   ----------------------\n+\n+   function New_Reference_To\n+     (Def_Id : Entity_Id;\n+      Loc    : Source_Ptr)\n+      return   Node_Id\n+   is\n+      Occurrence : Node_Id;\n+\n+   begin\n+      Occurrence := New_Node (N_Identifier, Loc);\n+      Set_Chars (Occurrence, Chars (Def_Id));\n+      Set_Entity (Occurrence, Def_Id);\n+      return Occurrence;\n+   end New_Reference_To;\n+\n+   -----------------------\n+   -- New_Suffixed_Name --\n+   -----------------------\n+\n+   function New_Suffixed_Name\n+     (Related_Id : Name_Id;\n+      Suffix     : String)\n+      return       Name_Id\n+   is\n+   begin\n+      Get_Name_String (Related_Id);\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := '_';\n+      Name_Buffer (Name_Len + 1 .. Name_Len + Suffix'Length) := Suffix;\n+      Name_Len := Name_Len + Suffix'Length;\n+      return Name_Find;\n+   end New_Suffixed_Name;\n+\n+   -------------------\n+   -- OK_Convert_To --\n+   -------------------\n+\n+   function OK_Convert_To (Typ : Entity_Id; Expr : Node_Id) return Node_Id is\n+      Result : Node_Id;\n+\n+   begin\n+      Result :=\n+        Make_Type_Conversion (Sloc (Expr),\n+          Subtype_Mark => New_Occurrence_Of (Typ, Sloc (Expr)),\n+          Expression   => Relocate_Node (Expr));\n+      Set_Conversion_OK (Result, True);\n+      Set_Etype (Result, Typ);\n+      return Result;\n+   end OK_Convert_To;\n+\n+   --------------------------\n+   -- Unchecked_Convert_To --\n+   --------------------------\n+\n+   function Unchecked_Convert_To\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id)\n+      return Node_Id\n+   is\n+      Loc    : constant Source_Ptr := Sloc (Expr);\n+      Result : Node_Id;\n+\n+   begin\n+      --  If the expression is already of the correct type, then nothing\n+      --  to do, except for relocating the node in case this is required.\n+\n+      if Present (Etype (Expr))\n+        and then (Base_Type (Etype (Expr)) = Typ\n+                   or else Etype (Expr) = Typ)\n+      then\n+         return Relocate_Node (Expr);\n+\n+      --  Cases where the inner expression is itself an unchecked conversion\n+      --  to the same type, and we can thus eliminate the outer conversion.\n+\n+      elsif Nkind (Expr) = N_Unchecked_Type_Conversion\n+        and then Entity (Subtype_Mark (Expr)) = Typ\n+      then\n+         Result := Relocate_Node (Expr);\n+\n+      --  All other cases\n+\n+      else\n+         Result :=\n+           Make_Unchecked_Type_Conversion (Loc,\n+             Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n+             Expression   => Relocate_Node (Expr));\n+      end if;\n+\n+      Set_Etype (Result, Typ);\n+      return Result;\n+   end Unchecked_Convert_To;\n+\n+end Tbuild;"}, {"sha": "51d539b523bdb25bf369a5a515f986828482f4f7", "filename": "gcc/ada/tbuild.ads", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,241 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               T B U I L D                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.69 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains various utility procedures to assist in\n+--  building specific types of tree nodes.\n+\n+with Types; use Types;\n+\n+package Tbuild is\n+\n+   function Make_DT_Component\n+     (Loc  : Source_Ptr;\n+      Typ  : Entity_Id;\n+      I    : Positive)\n+      return Node_Id;\n+   --  Gives a reference to the Ith component of the Dispatch Table of\n+   --  a given Tagged Type.\n+   --\n+   --  I = 1    --> Inheritance_Depth\n+   --  I = 2    --> Tags (array of ancestors)\n+   --  I = 3, 4 --> predefined primitive\n+   --            function _Size (X : Typ) return Long_Long_Integer;\n+   --            function _Equality (X : Typ; Y : Typ'Class) return Boolean;\n+   --  I >= 5   --> User-Defined Primitive Operations\n+\n+   function Make_DT_Access\n+     (Loc : Source_Ptr; Rec : Node_Id; Typ : Entity_Id) return Node_Id;\n+   --  Create an access to the Dispatch Table by using the Tag field\n+   --  of a tagged record : Acc_Dt (Rec.tag).all\n+\n+   function Make_Implicit_If_Statement\n+     (Node            : Node_Id;\n+      Condition       : Node_Id;\n+      Then_Statements : List_Id;\n+      Elsif_Parts     : List_Id := No_List;\n+      Else_Statements : List_Id := No_List)\n+      return            Node_Id;\n+   pragma Inline (Make_Implicit_If_Statement);\n+   --  This function makes an N_If_Statement node whose fields are filled\n+   --  in with the indicated values (see Sinfo), and whose Sloc field is\n+   --  is set to Sloc (Node). The effect is identical to calling function\n+   --  Nmake.Make_If_Statement except that there is a check for restriction\n+   --  No_Implicit_Conditionals, and if this restriction is being violated,\n+   --  an error message is posted on Node.\n+\n+   function Make_Implicit_Label_Declaration\n+     (Loc                 : Source_Ptr;\n+      Defining_Identifier : Node_Id;\n+      Label_Construct     : Node_Id)\n+      return                Node_Id;\n+   --  Used to contruct an implicit label declaration node, including setting\n+   --  the proper Label_Construct field (since Label_Construct is a semantic\n+   --  field, the normal call to Make_Implicit_Label_Declaration does not\n+   --  set this field).\n+\n+   function Make_Implicit_Loop_Statement\n+     (Node                   : Node_Id;\n+      Statements             : List_Id;\n+      Identifier             : Node_Id := Empty;\n+      Iteration_Scheme       : Node_Id := Empty;\n+      Has_Created_Identifier : Boolean := False;\n+      End_Label              : Node_Id := Empty)\n+      return                   Node_Id;\n+   --  This function makes an N_Loop_Statement node whose fields are filled\n+   --  in with the indicated values (see Sinfo), and whose Sloc field is\n+   --  is set to Sloc (Node). The effect is identical to calling function\n+   --  Nmake.Make_Loop_Statement except that there is a check for restrictions\n+   --  No_Implicit_Loops and No_Implicit_Conditionals (the first applying in\n+   --  all cases, and the second only for while loops), and if one of these\n+   --  restrictions is being violated, an error message is posted on Node.\n+\n+   function Make_Integer_Literal\n+     (Loc    : Source_Ptr;\n+      Intval : Int)\n+      return   Node_Id;\n+   pragma Inline (Make_Integer_Literal);\n+   --  A convenient form of Make_Integer_Literal taking Int instead of Uint\n+\n+   function Make_Unsuppress_Block\n+     (Loc   : Source_Ptr;\n+      Check : Name_Id;\n+      Stmts : List_Id)\n+      return  Node_Id;\n+   --  Build a block with a pragma Suppress on 'Check'. Stmts is the\n+   --  statements list that needs protection against the check\n+\n+   function New_Constraint_Error (Loc : Source_Ptr) return Node_Id;\n+   --  This function builds a tree corresponding to the Ada statement\n+   --  \"raise Constraint_Error\" and returns the root of this tree,\n+   --  the N_Raise_Statement node.\n+\n+   function New_External_Name\n+     (Related_Id   : Name_Id;\n+      Suffix       : Character := ' ';\n+      Suffix_Index : Int       := 0;\n+      Prefix       : Character := ' ')\n+      return         Name_Id;\n+   function New_External_Name\n+     (Related_Id   : Name_Id;\n+      Suffix       : String;\n+      Suffix_Index : Int       := 0;\n+      Prefix       : Character := ' ')\n+      return         Name_Id;\n+   --  Builds a new entry in the names table of the form:\n+   --\n+   --    [Prefix  &] Related_Id [& Suffix] [& Suffix_Index]\n+   --\n+   --  Prefix is prepended only if Prefix is non-blank (in which case it\n+   --  must be an upper case letter other than O,Q,U,W (which are used for\n+   --  identifier encoding, see Namet), and T is reserved for use by implicit\n+   --  types. and X is reserved for use by debug type encoding (see package\n+   --  Exp_Dbug). Note: the reason that Prefix is last is that it is almost\n+   --  always omitted. The notable case of Prefix being non-null is when\n+   --  it is 'T' for an implicit type.\n+\n+   --  Suffix_Index'Image is appended only if the value of Suffix_Index is\n+   --  positive, or if Suffix_Index is negative 1, then a unique serialized\n+   --  suffix is added. If Suffix_Index is zero, then no index is appended.\n+\n+   --  Suffix is also a single upper case letter other than O,Q,U,W,X and is a\n+   --  required parameter (T is permitted). The constructed name is stored\n+   --  using Find_Name so that it can be located using a subsequent Find_Name\n+   --  operation (i.e. it is properly hashed into the names table). The upper\n+   --  case letter given as the Suffix argument ensures that the name does\n+   --  not clash with any Ada identifier name. These generated names are\n+   --  permitted, but not required, to be made public by setting the flag\n+   --  Is_Public in the associated entity.\n+\n+   function New_External_Name\n+     (Suffix       : Character;\n+      Suffix_Index : Nat)\n+      return         Name_Id;\n+   --  Builds a new entry in the names table of the form\n+   --    Suffix & Suffix_Index'Image\n+   --  where Suffix is a single upper case letter other than O,Q,U,W,X and is\n+   --  a required parameter (T is permitted). The constructed name is stored\n+   --  using Find_Name so that it can be located using a subsequent Find_Name\n+   --  operation (i.e. it is properly hashed into the names table). The upper\n+   --  case letter given as the Suffix argument ensures that the name does\n+   --  not clash with any Ada identifier name. These generated names are\n+   --  permitted, but not required, to be made public by setting the flag\n+   --  Is_Public in the associated entity.\n+\n+   function New_Internal_Name (Id_Char : Character) return Name_Id;\n+   --  Id_Char is an upper case letter other than O,Q,U,W (which are reserved\n+   --  for identifier encoding (see Namet package for details) and X which is\n+   --  used for debug encoding (see Exp_Dbug). The letter T is permitted, but\n+   --  is reserved by convention for the case of internally generated types.\n+   --  The result of the call is a new generated unique name of the form XyyyU\n+   --  where X is Id_Char, yyy is a unique serial number, and U is either a\n+   --  lower case s or b indicating if the current unit is a spec or a body.\n+   --\n+   --  The name is entered into the names table using Name_Enter rather than\n+   --  Name_Find, because there can never be a need to locate the entry using\n+   --  the Name_Find procedure later on. Names created by New_Internal_Name\n+   --  are guaranteed to be consistent from one compilation to another (i.e.\n+   --  if the identical unit is compiled with a semantically consistent set\n+   --  of sources, the numbers will be consistent. This means that it is fine\n+   --  to use these as public symbols.\n+\n+   function New_Suffixed_Name\n+     (Related_Id : Name_Id;\n+      Suffix     : String)\n+      return       Name_Id;\n+   --  This function is used to create special suffixed names used by the\n+   --  debugger. Suffix is a string of upper case letters, used to construct\n+   --  the required name. For instance, the special type used to record the\n+   --  fixed-point small is called typ_SMALL where typ is the name of the\n+   --  fixed-point type (as passed in Related_Id), and Suffix is \"SMALL\".\n+\n+   function New_Occurrence_Of\n+     (Def_Id : Entity_Id;\n+      Loc    : Source_Ptr)\n+      return   Node_Id;\n+   --  New_Occurrence_Of creates an N_Identifier node which is an\n+   --  occurrence of the defining identifier which is passed as its\n+   --  argument. The Entity and Etype of the result are set from\n+   --  the given defining identifier as follows: Entity is simply\n+   --  a copy of Def_Id. Etype is a copy of Def_Id for types, and\n+   --  a copy of the Etype of Def_Id for other entities.\n+\n+   function New_Reference_To\n+     (Def_Id : Entity_Id;\n+      Loc    : Source_Ptr)\n+      return   Node_Id;\n+   --  This is like New_Occurrence_Of, but it does not set the Etype field.\n+   --  It is used from the expander, where Etype fields are generally not set,\n+   --  since they are set when the expanded tree is reanalyzed.\n+\n+   function Checks_Off (N : Node_Id) return Node_Id;\n+   pragma Inline (Checks_Off);\n+   --  Returns an N_Unchecked_Expression node whose expression is the given\n+   --  argument. The results is a subexpression identical to the argument,\n+   --  except that it will be analyzed and resolved with checks off.\n+\n+   function Convert_To (Typ : Entity_Id; Expr : Node_Id) return Node_Id;\n+   --  Returns an expression that represents the result of a checked convert\n+   --  of expression Exp to type T. If the base type of Exp is T, then no\n+   --  conversion is required, and Exp is returned unchanged. Otherwise an\n+   --  N_Type_Conversion node is constructed to convert the expression.\n+   --  If an N_Type_Conversion node is required, Relocate_Node is used on\n+   --  Exp. This means that it is safe to replace a node by a Convert_To\n+   --  of itself to some other type.\n+\n+   function OK_Convert_To (Typ : Entity_Id; Expr : Node_Id) return Node_Id;\n+   --  Like Convert_To, except that a conversion node is always generated,\n+   --  and the Conversion_OK flag is set on this conversion node.\n+\n+   function Unchecked_Convert_To\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id)\n+      return Node_Id;\n+   --  Like Convert_To, but if a conversion is actually needed, constructs\n+   --  an N_Unchecked_Type_Conversion node to do the required conversion.\n+\n+end Tbuild;"}, {"sha": "7715464f8260973ff77b564e0bfe966bdbc9fe42", "filename": "gcc/ada/text_io.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftext_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftext_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftext_io.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                              T E X T _ I O                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_95;\n+with Ada.Text_IO;\n+\n+package Text_IO renames Ada.Text_IO;"}, {"sha": "1ea4b8025ea51f42e0eb93f3489158b5de9a9475", "filename": "gcc/ada/tracebak.c", "status": "added", "additions": 1177, "deletions": 0, "changes": 1177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,1177 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                            T R A C E B A C K                             *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                            $Revision: 1.1 $\n+ *                                                                          *\n+ *           Copyright (C) 2000-2001 Ada Core Technologies, Inc.            *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file contains low level support for stack unwinding using GCC intrinsic\n+   functions.\n+   It has been tested on the following configurations:\n+   HPPA/HP-UX\n+   PowerPC/AiX\n+   PowerPC/VxWorks\n+   Sparc/Solaris\n+   i386/Linux\n+   i386/Solaris\n+   i386/NT\n+   i386/OS2\n+   i386/LynxOS\n+   Alpha/VxWorks\n+*/\n+\n+#ifdef __alpha_vxworks\n+#include \"vxWorks.h\"\n+#endif\n+\n+#ifdef IN_RTS\n+#define POSIX\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+#define Lock_Task system__soft_links__lock_task\n+extern void (*Lock_Task) (void);\n+\n+#define Unlock_Task system__soft_links__unlock_task\n+extern void (*Unlock_Task) (void);\n+\n+#ifndef CURRENT_STACK_FRAME\n+# define CURRENT_STACK_FRAME  ({ char __csf; &__csf; })\n+#endif\n+\n+extern int __gnat_backtrace\tPARAMS ((void **, int, void *, void *));\n+\n+#if defined (__hppa)\n+struct layout\n+{\n+  void *return_address;\n+  void *pad[4];\n+  struct layout *next;\n+};\n+\n+#define FRAME_LEVEL 1\n+#define FRAME_OFFSET -20\n+#define SKIP_FRAME 1\n+#define PC_ADJUST -4\n+\n+/* If CURRENT is unaligned, it means that CURRENT is not a valid frame\n+   pointer and we should stop popping frames. */\n+\n+#define STOP_FRAME(CURRENT, TOP_STACK) \\\n+  (((int) (CURRENT) & 0x3) != 0 && (CURRENT)->return_address == 0)\n+\n+/* Current implementation need to be protected against invalid memory\n+   accesses */\n+#define PROTECT_SEGV\n+\n+#elif defined (_AIX)\n+struct layout\n+{\n+  struct layout *next;\n+  void *pad;\n+  void *return_address;\n+};\n+\n+#define FRAME_LEVEL 1\n+#define FRAME_OFFSET 0\n+#define SKIP_FRAME 2\n+#define PC_ADJUST -4\n+#define STOP_FRAME(CURRENT, TOP_STACK) ((void *) (CURRENT) < (TOP_STACK))\n+\n+#elif defined (_ARCH_PPC) && defined (__vxworks)\n+struct layout\n+{\n+  struct layout *next;\n+  void *return_address;\n+};\n+\n+#define FRAME_LEVEL 1\n+#define FRAME_OFFSET 0\n+#define SKIP_FRAME 2\n+#define PC_ADJUST 0\n+#define STOP_FRAME(CURRENT, TOP_STACK) ((CURRENT)->return_address == 0)\n+\n+#elif defined (sun) && defined (sparc)\n+struct layout\n+{\n+  struct layout *next;\n+  void *return_address;\n+};\n+\n+#define FRAME_LEVEL 1\n+#define FRAME_OFFSET (14*4)\n+#define SKIP_FRAME 1\n+#define PC_ADJUST 0\n+#define STOP_FRAME(CURRENT, TOP_STACK) \\\n+  ((CURRENT)->return_address == 0|| (CURRENT)->next == 0 \\\n+   || (void *) (CURRENT) < (TOP_STACK))\n+\n+#elif defined (i386)\n+struct layout\n+{\n+  struct layout *next;\n+  void *return_address;\n+};\n+\n+#define FRAME_LEVEL 0\n+#define FRAME_OFFSET 0\n+#define SKIP_FRAME 1\n+#define PC_ADJUST -2\n+#define STOP_FRAME(CURRENT, TOP_STACK) \\\n+  ((CURRENT)->return_address == 0|| (CURRENT)->next == 0  \\\n+   || (void *) (CURRENT) < (TOP_STACK))\n+\n+#elif defined (__alpha_vxworks)\n+\n+#define SKIP_FRAME 1\n+#define PC_ADJUST -4\n+\n+extern void kerTaskEntry();\n+\n+#define STOP_FRAME \\\n+   (current == NULL \\\n+    || ((CORE_ADDR) &kerTaskEntry >= PROC_LOW_ADDR (current->proc_desc) \\\n+        && current->pc >= (CORE_ADDR) &kerTaskEntry))\n+#endif\n+\n+#if !defined (PC_ADJUST)\n+int\n+__gnat_backtrace (array, size, exclude_min, exclude_max)\n+     void **array ATTRIBUTE_UNUSED;\n+     int size ATTRIBUTE_UNUSED;\n+     void *exclude_min ATTRIBUTE_UNUSED;\n+     void *exclude_max ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+#elif !defined (__alpha_vxworks)\n+\n+#ifdef PROTECT_SEGV\n+#include <setjmp.h>\n+#include <signal.h>\n+\n+static jmp_buf sigsegv_excp;\n+\n+static void\n+segv_handler (ignored)\n+     int ignored;\n+{\n+  longjmp (sigsegv_excp, 1);\n+}\n+#endif\n+\n+int\n+__gnat_backtrace (array, size, exclude_min, exclude_max)\n+     void **array;\n+     int size;\n+     void *exclude_min;\n+     void *exclude_max;\n+{\n+  struct layout *current;\n+  void *top_frame;\n+  void *top_stack;\n+  void *ret;\n+  int cnt = 0;\n+\n+#ifdef PROTECT_SEGV\n+  struct sigaction this_act, old_act;\n+\n+  /* This function is not thread safe if PROTECT_SEGV is defined, so\n+     protect it */\n+  (*Lock_Task) ();\n+#endif\n+\n+  top_frame = __builtin_frame_address (FRAME_LEVEL);\n+  top_stack = CURRENT_STACK_FRAME;\n+  current = (struct layout *) ((size_t) top_frame + FRAME_OFFSET);\n+\n+#ifdef PROTECT_SEGV\n+  this_act.sa_handler = segv_handler;\n+  sigemptyset (&this_act.sa_mask);\n+  this_act.sa_flags = 0;\n+  sigaction (SIGSEGV, &this_act, &old_act);\n+\n+  if (setjmp (sigsegv_excp))\n+    goto Done;\n+#endif\n+\n+  /* We skip the call to this function, it makes no sense to record it.  */\n+  while (cnt < SKIP_FRAME)\n+    {\n+      current = (struct layout *) ((size_t) current->next + FRAME_OFFSET);\n+      cnt++;\n+    }\n+\n+  cnt = 0;\n+  while (cnt < size)\n+    {\n+      if (STOP_FRAME (current, top_stack))\n+        break;\n+\n+      if (current->return_address < exclude_min\n+\t  || current->return_address > exclude_max)\n+        array[cnt++] = current->return_address + PC_ADJUST;\n+\n+      current = (struct layout *) ((size_t) current->next + FRAME_OFFSET);\n+    }\n+\n+#ifdef PROTECT_SEGV\n+ Done:\n+  sigaction (SIGSEGV, &old_act, NULL);\n+  (*Unlock_Task) ();\n+#endif\n+  return cnt;\n+}\n+\n+#else\n+/* Alpha vxWorks requires a special, complex treatment that is extracted\n+   from GDB */\n+\n+#include <string.h>\n+\n+/* Register numbers of various important registers.\n+   Note that most of these values are \"real\" register numbers,\n+   and correspond to the general registers of the machine,\n+   and FP_REGNUM is a \"phony\" register number which is too large\n+   to be an actual register number as far as the user is concerned\n+   but serves to get the desired value when passed to read_register.  */\n+\n+#define T7_REGNUM 8\t\t/* Return address register for OSF/1 __add* */\n+#define GCC_FP_REGNUM 15\t/* Used by gcc as frame register */\n+#define T9_REGNUM 23\t\t/* Return address register for OSF/1 __div* */\n+#define SP_REGNUM 30\t\t/* Contains address of top of stack */\n+#define RA_REGNUM 26\t\t/* Contains return address value */\n+#define FP0_REGNUM 32\t\t/* Floating point register 0 */\n+#define PC_REGNUM 64\t\t/* Contains program counter */\n+#define NUM_REGS 66\n+\n+#define VM_MIN_ADDRESS (CORE_ADDR)0x120000000\n+\n+#define SIZEOF_FRAME_SAVED_REGS (sizeof (CORE_ADDR) * (NUM_REGS))\n+#define INIT_EXTRA_FRAME_INFO(fromleaf, fci) init_extra_frame_info(fci)\n+\n+#define FRAME_CHAIN(thisframe) (CORE_ADDR) alpha_frame_chain (thisframe)\n+\n+#define FRAME_CHAIN_VALID(CHAIN, THISFRAME)\t\\\n+  ((CHAIN) != 0\t\t\t\t\t\\\n+   && !inside_entry_file (FRAME_SAVED_PC (THISFRAME)))\n+\n+#define FRAME_SAVED_PC(FRAME)\t(alpha_frame_saved_pc (FRAME))\n+\n+#define\tFRAME_CHAIN_COMBINE(CHAIN, THISFRAME) (CHAIN)\n+\n+#define\tINIT_FRAME_PC(FROMLEAF, PREV)\n+\n+#define INIT_FRAME_PC_FIRST(FROMLEAF, PREV) \\\n+  (PREV)->pc = ((FROMLEAF) ? SAVED_PC_AFTER_CALL ((PREV)->next) \\\n+\t\t: (PREV)->next ? FRAME_SAVED_PC ((prev)->NEXT) : read_pc ());\n+\n+#define SAVED_PC_AFTER_CALL(FRAME)\talpha_saved_pc_after_call (FRAME)\n+\n+typedef unsigned long long int bfd_vma;\n+\n+typedef bfd_vma CORE_ADDR;\n+\n+typedef struct pdr\n+{\n+  bfd_vma adr;\t\t/* memory address of start of procedure */\n+  long\tisym;\t\t/* start of local symbol entries */\n+  long\tiline;\t\t/* start of line number entries*/\n+  long\tregmask;\t/* save register mask */\n+  long\tregoffset;\t/* save register offset */\n+  long\tiopt;\t\t/* start of optimization symbol entries*/\n+  long\tfregmask;\t/* save floating point register mask */\n+  long\tfregoffset;\t/* save floating point register offset */\n+  long\tframeoffset;\t/* frame size */\n+  short\tframereg;\t/* frame pointer register */\n+  short\tpcreg;\t\t/* offset or reg of return pc */\n+  long\tlnLow;\t\t/* lowest line in the procedure */\n+  long\tlnHigh;\t\t/* highest line in the procedure */\n+  bfd_vma cbLineOffset;\t/* byte offset for this procedure from the fd base */\n+  /* These fields are new for 64 bit ECOFF.  */\n+  unsigned gp_prologue : 8; /* byte size of GP prologue */\n+  unsigned gp_used : 1;\t/* true if the procedure uses GP */\n+  unsigned reg_frame : 1; /* true if register frame procedure */\n+  unsigned prof : 1;\t/* true if compiled with -pg */\n+  unsigned reserved : 13; /* reserved: must be zero */\n+  unsigned localoff : 8; /* offset of local variables from vfp */\n+} PDR;\n+\n+typedef struct alpha_extra_func_info\n+{\n+  long numargs;\t\t/* number of args to procedure (was iopt) */\n+  PDR pdr;\t\t\t/* Procedure descriptor record */\n+}\n+*alpha_extra_func_info_t;\n+\n+struct frame_info\n+{\n+  /* Nominal address of the frame described.  See comments at FRAME_FP\n+     about what this means outside the *FRAME* macros; in the *FRAME*\n+     macros, it can mean whatever makes most sense for this machine.  */\n+  CORE_ADDR frame;\n+\n+  /* Address at which execution is occurring in this frame.  For the\n+     innermost frame, it's the current pc.  For other frames, it is a\n+     pc saved in the next frame.  */\n+  CORE_ADDR pc;\n+\n+  /* For each register, address of where it was saved on entry to the\n+     frame, or zero if it was not saved on entry to this frame.  This\n+     includes special registers such as pc and fp saved in special\n+     ways in the stack frame.  The SP_REGNUM is even more special, the\n+     address here is the sp for the next frame, not the address where\n+     the sp was saved.  Allocated by frame_saved_regs_zalloc () which\n+     is called and initialized by FRAME_INIT_SAVED_REGS. */\n+  CORE_ADDR *saved_regs;\t/*NUM_REGS */\n+\n+  int localoff;\n+  int pc_reg;\n+  alpha_extra_func_info_t proc_desc;\n+\n+  /* Pointers to the next and previous frame_info's in the frame cache.  */\n+  struct frame_info *next, *prev;\n+};\n+\n+struct frame_saved_regs\n+{\n+  /* For each register R (except the SP), regs[R] is the address at\n+     which it was saved on entry to the frame, or zero if it was not\n+     saved on entry to this frame.  This includes special registers\n+     such as pc and fp saved in special ways in the stack frame.\n+\n+     regs[SP_REGNUM] is different.  It holds the actual SP, not the\n+     address at which it was saved.  */\n+\n+  CORE_ADDR regs[NUM_REGS];\n+};\n+\n+static CORE_ADDR theRegisters[32];\n+\n+/* Prototypes for local functions. */\n+\n+static CORE_ADDR read_next_frame_reg PARAMS ((struct frame_info *, int));\n+static CORE_ADDR heuristic_proc_start PARAMS ((CORE_ADDR));\n+static int alpha_about_to_return PARAMS ((CORE_ADDR pc));\n+static void init_extra_frame_info PARAMS ((struct frame_info *));\n+static CORE_ADDR alpha_frame_chain PARAMS ((struct frame_info *));\n+static CORE_ADDR alpha_frame_saved_pc PARAMS ((struct frame_info *frame))\n+static void *trace_alloc PARAMS ((unsigned int));\n+static struct frame_info *create_new_frame PARAMS ((CORE_ADDR, CORE_ADDR));\n+\n+static alpha_extra_func_info_t\n+heuristic_proc_desc PARAMS ((CORE_ADDR, CORE_ADDR, struct frame_info *,\n+\t\t\t     struct frame_saved_regs *));\n+\n+static alpha_extra_func_info_t\n+find_proc_desc PARAMS ((CORE_ADDR, struct frame_info *,\n+\t\t\tstruct frame_saved_regs *));\n+\n+/* Heuristic_proc_start may hunt through the text section for a long\n+   time across a 2400 baud serial line.  Allows the user to limit this\n+   search.  */\n+static unsigned int heuristic_fence_post = 1<<16;\n+\n+/* Layout of a stack frame on the alpha:\n+\n+                |\t\t\t\t|\n+ pdr members:\t|  7th ... nth arg,\t\t|\n+                |  `pushed' by caller.\t\t|\n+                |\t\t\t\t|\n+----------------|-------------------------------|<--  old_sp == vfp\n+   ^  ^  ^  ^\t|\t\t\t\t|\n+   |  |  |  |\t|\t\t\t\t|\n+   |  |localoff\t|  Copies of 1st .. 6th\t\t|\n+   |  |  |  |\t|  argument if necessary.\t|\n+   |  |  |  v\t|\t\t\t\t|\n+   |  |  |  ---\t|-------------------------------|<-- FRAME_LOCALS_ADDRESS\n+   |  |  |      |\t\t\t\t|\n+   |  |  |      |  Locals and temporaries.\t|\n+   |  |  |      |\t\t\t\t|\n+   |  |  |      |-------------------------------|\n+   |  |  |      |\t\t\t\t|\n+   |-fregoffset\t|  Saved float registers.\t|\n+   |  |  |      |  F9\t\t\t\t|\n+   |  |  |      |   .\t\t\t\t|\n+   |  |  |      |   .\t\t\t\t|\n+   |  |  |      |  F2\t\t\t\t|\n+   |  |  v      |\t\t\t\t|\n+   |  |  -------|-------------------------------|\n+   |  |         |\t\t\t\t|\n+   |  |         |  Saved registers.\t\t|\n+   |  |         |  S6\t\t\t\t|\n+   |-regoffset\t|   .\t\t\t\t|\n+   |  |         |   .\t\t\t\t|\n+   |  |         |  S0\t\t\t\t|\n+   |  |         |  pdr.pcreg\t\t\t|\n+   |  v         |\t\t\t\t|\n+   |  ----------|-------------------------------|\n+   |            |\t\t\t\t|\n+ frameoffset    |  Argument build area, gets\t|\n+   |            |  7th ... nth arg for any\t|\n+   |            |  called procedure.\t\t|\n+   v            |  \t\t\t\t|\n+   -------------|-------------------------------|<-- sp\n+                |\t\t\t\t|            */\n+\n+#define PROC_LOW_ADDR(PROC) ((PROC)->pdr.adr)\t\t    /* least address */\n+#define PROC_HIGH_ADDR(PROC) ((PROC)->pdr.iline)      /* upper address bound */\n+#define PROC_DUMMY_FRAME(PROC) ((PROC)->pdr.cbLineOffset) /*CALL_DUMMY frame */\n+#define PROC_FRAME_OFFSET(PROC) ((PROC)->pdr.frameoffset)\n+#define PROC_FRAME_REG(PROC) ((PROC)->pdr.framereg)\n+#define PROC_REG_MASK(PROC) ((PROC)->pdr.regmask)\n+#define PROC_FREG_MASK(PROC) ((PROC)->pdr.fregmask)\n+#define PROC_REG_OFFSET(PROC) ((PROC)->pdr.regoffset)\n+#define PROC_FREG_OFFSET(PROC) ((PROC)->pdr.fregoffset)\n+#define PROC_PC_REG(PROC) ((PROC)->pdr.pcreg)\n+#define PROC_LOCALOFF(PROC) ((PROC)->pdr.localoff)\n+\n+/* Local storage allocation/deallocation functions.  trace_alloc does\n+   a malloc, but also chains allocated blocks on trace_alloc_chain, so\n+   they may all be freed on exit from __gnat_backtrace. */\n+\n+struct alloc_chain\n+{\n+  struct alloc_chain *next;\n+  double x[0];\n+};\n+struct alloc_chain *trace_alloc_chain;\n+\n+static void * \n+trace_alloc (n)\n+     unsigned int n;\n+{\n+  struct alloc_chain * result = malloc (n + sizeof(struct alloc_chain));\n+\n+  result->next = trace_alloc_chain;\n+  trace_alloc_chain = result;\n+  return (void*) result->x;\n+}\n+\n+static void\n+free_trace_alloc ()\n+{\n+  while (trace_alloc_chain != 0)\n+    {\n+      struct alloc_chain *old = trace_alloc_chain;\n+\n+      trace_alloc_chain = trace_alloc_chain->next;\n+      free (old);\n+    }\n+}\n+\n+/* Read value at ADDR into *DEST, returning 0 if this is valid, != 0\n+   otherwise. */\n+\n+static int\n+read_memory_safe4 (addr, dest)\n+     CORE_ADDR addr;\n+     unsigned int *dest;\n+{\n+  *dest = *((unsigned int*) addr);\n+  return 0;\n+}\n+\n+/* Read value at ADDR into *DEST, returning 0 if this is valid, != 0\n+   otherwise. */\n+\n+static int\n+read_memory_safe8 (addr, dest)\n+     CORE_ADDR addr;\n+     CORE_ADDR *dest;\n+{\n+  *dest = *((CORE_ADDR*) addr);\n+  return 0;\n+}\n+\n+static CORE_ADDR\n+read_register (regno)\n+     int regno;\n+{\n+  if (regno >= 0 && regno < 31)\n+    return theRegisters[regno];\n+\n+  return (CORE_ADDR) 0;\n+}\n+\n+static void\n+frame_saved_regs_zalloc (fi)\n+     struct frame_info *fi;\n+{\n+  fi->saved_regs = (CORE_ADDR *) trace_alloc (SIZEOF_FRAME_SAVED_REGS);\n+  memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);\n+}\n+\n+static void *\n+frame_obstack_alloc (size)\n+     unsigned long size;\n+{\n+  return (void *) trace_alloc (size);\n+}\n+\n+static int\n+inside_entry_file (addr)\n+     CORE_ADDR addr;\n+{\n+  if (addr == 0)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+static CORE_ADDR\n+alpha_saved_pc_after_call (frame)\n+     struct frame_info *frame;\n+{\n+  CORE_ADDR pc = frame->pc;\n+  alpha_extra_func_info_t proc_desc;\n+  int pcreg;\n+\n+  proc_desc = find_proc_desc (pc, frame->next, NULL);\n+  pcreg = proc_desc ? PROC_PC_REG (proc_desc) : RA_REGNUM;\n+\n+  return read_register (pcreg);\n+}\n+\n+/* Guaranteed to set frame->saved_regs to some values (it never leaves it\n+   NULL).  */\n+\n+static void\n+alpha_find_saved_regs (frame)\n+     struct frame_info *frame;\n+{\n+  int ireg;\n+  CORE_ADDR reg_position;\n+  unsigned long mask;\n+  alpha_extra_func_info_t proc_desc;\n+  int returnreg;\n+\n+  frame_saved_regs_zalloc (frame);\n+\n+  /* If it is the frame for __sigtramp, the saved registers are located in a\n+     sigcontext structure somewhere on the stack. __sigtramp passes a pointer\n+     to the sigcontext structure on the stack.  If the stack layout for\n+     __sigtramp changes, or if sigcontext offsets change, we might have to\n+     update this code.  */\n+\n+#ifndef SIGFRAME_PC_OFF\n+#define SIGFRAME_PC_OFF\t\t(2 * 8)\n+#define SIGFRAME_REGSAVE_OFF\t(4 * 8)\n+#define SIGFRAME_FPREGSAVE_OFF\t(SIGFRAME_REGSAVE_OFF + 32 * 8 + 8)\n+#endif\n+\n+  proc_desc = frame->proc_desc;\n+  if (proc_desc == NULL)\n+    /* I'm not sure how/whether this can happen.  Normally when we can't\n+       find a proc_desc, we \"synthesize\" one using heuristic_proc_desc\n+       and set the saved_regs right away.  */\n+    return;\n+\n+  /* Fill in the offsets for the registers which gen_mask says\n+     were saved.  */\n+\n+  reg_position = frame->frame + PROC_REG_OFFSET (proc_desc);\n+  mask = PROC_REG_MASK (proc_desc);\n+\n+  returnreg = PROC_PC_REG (proc_desc);\n+\n+  /* Note that RA is always saved first, regardless of its actual\n+     register number.  */\n+  if (mask & (1 << returnreg))\n+    {\n+      frame->saved_regs[returnreg] = reg_position;\n+      reg_position += 8;\n+      mask &= ~(1 << returnreg);\t/* Clear bit for RA so we\n+\t\t\t\t\t   don't save again later. */\n+    }\n+\n+  for (ireg = 0; ireg <= 31; ireg++)\n+    if (mask & (1 << ireg))\n+      {\n+\tframe->saved_regs[ireg] = reg_position;\n+\treg_position += 8;\n+      }\n+\n+  /* Fill in the offsets for the registers which float_mask says\n+     were saved.  */\n+\n+  reg_position = frame->frame + PROC_FREG_OFFSET (proc_desc);\n+  mask = PROC_FREG_MASK (proc_desc);\n+\n+  for (ireg = 0; ireg <= 31; ireg++)\n+    if (mask & (1 << ireg))\n+      {\n+\tframe->saved_regs[FP0_REGNUM + ireg] = reg_position;\n+\treg_position += 8;\n+      }\n+\n+  frame->saved_regs[PC_REGNUM] = frame->saved_regs[returnreg];\n+}\n+\n+static CORE_ADDR\n+read_next_frame_reg (fi, regno)\n+     struct frame_info *fi;\n+     int regno;\n+{\n+  CORE_ADDR result;\n+  for (; fi; fi = fi->next)\n+    {\n+      /* We have to get the saved sp from the sigcontext\n+         if it is a signal handler frame.  */\n+      if (regno == SP_REGNUM)\n+\treturn fi->frame;\n+      else\n+\t{\n+\t  if (fi->saved_regs == 0)\n+\t    alpha_find_saved_regs (fi);\n+\n+\t  if (fi->saved_regs[regno])\n+\t    {\n+\t      if (read_memory_safe8 (fi->saved_regs[regno], &result) == 0)\n+\t\treturn result;\n+\t      else\n+\t\treturn 0;\n+\t    }\n+\t}\n+    }\n+\n+  return read_register (regno);\n+}\n+\n+static CORE_ADDR\n+alpha_frame_saved_pc (frame)\n+     struct frame_info *frame;\n+{\n+  return read_next_frame_reg (frame, frame->pc_reg);\n+}\n+\n+static struct alpha_extra_func_info temp_proc_desc;\n+\n+/* Nonzero if instruction at PC is a return instruction.  \"ret\n+   $zero,($ra),1\" on alpha. */\n+\n+static int\n+alpha_about_to_return (pc)\n+     CORE_ADDR pc;\n+{\n+  int inst;\n+\n+  read_memory_safe4 (pc, &inst);\n+  return inst == 0x6bfa8001;\n+}\n+\n+/* A heuristically computed start address for the subprogram\n+   containing address PC.   Returns 0 if none detected. */\n+\n+static CORE_ADDR\n+heuristic_proc_start (pc)\n+     CORE_ADDR pc;\n+{\n+  CORE_ADDR start_pc = pc;\n+  CORE_ADDR fence = start_pc - heuristic_fence_post;\n+\n+  if (start_pc == 0)\n+    return 0;\n+\n+  if (heuristic_fence_post == UINT_MAX\n+      || fence < VM_MIN_ADDRESS)\n+    fence = VM_MIN_ADDRESS;\n+\n+  /* search back for previous return */\n+  for (start_pc -= 4; ; start_pc -= 4)\n+    {\n+      if (start_pc < fence)\n+\treturn 0;\n+      else if (alpha_about_to_return (start_pc))\n+\tbreak;\n+    }\n+\n+  start_pc += 4;\t\t/* skip return */\n+  return start_pc;\n+}\n+\n+static alpha_extra_func_info_t\n+heuristic_proc_desc (start_pc, limit_pc, next_frame, saved_regs_p)\n+     CORE_ADDR start_pc;\n+     CORE_ADDR limit_pc;\n+     struct frame_info *next_frame;\n+     struct frame_saved_regs *saved_regs_p;\n+{\n+  CORE_ADDR sp = read_next_frame_reg (next_frame, SP_REGNUM);\n+  CORE_ADDR cur_pc;\n+  int frame_size;\n+  int has_frame_reg = 0;\n+  unsigned long reg_mask = 0;\n+  int pcreg = -1;\n+\n+  if (start_pc == 0)\n+    return 0;\n+\n+  memset (&temp_proc_desc, '\\0', sizeof (temp_proc_desc));\n+  if (saved_regs_p != 0)\n+    memset (saved_regs_p, '\\0', sizeof (struct frame_saved_regs));\n+\n+  PROC_LOW_ADDR (&temp_proc_desc) = start_pc;\n+\n+  if (start_pc + 200 < limit_pc)\n+    limit_pc = start_pc + 200;\n+\n+  frame_size = 0;\n+  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += 4)\n+    {\n+      unsigned int word;\n+      int status;\n+\n+      status = read_memory_safe4 (cur_pc, &word);\n+      if (status)\n+\treturn 0;\n+\n+      if ((word & 0xffff0000) == 0x23de0000)\t/* lda $sp,n($sp) */\n+\t{\n+\t  if (word & 0x8000)\n+\t    frame_size += (-word) & 0xffff;\n+\t  else\n+\t    /* Exit loop if a positive stack adjustment is found, which\n+\t       usually means that the stack cleanup code in the function\n+\t       epilogue is reached.  */\n+\t    break;\n+\t}\n+      else if ((word & 0xfc1f0000) == 0xb41e0000\t/* stq reg,n($sp) */\n+\t       && (word & 0xffff0000) != 0xb7fe0000)\t/* reg != $zero */\n+\t{\n+\t  int reg = (word & 0x03e00000) >> 21;\n+\n+\t  reg_mask |= 1 << reg;\n+\t  if (saved_regs_p != 0)\n+\t    saved_regs_p->regs[reg] = sp + (short) word;\n+\n+\t  /* Starting with OSF/1-3.2C, the system libraries are shipped\n+\t     without local symbols, but they still contain procedure\n+\t     descriptors without a symbol reference. GDB is currently\n+\t     unable to find these procedure descriptors and uses\n+\t     heuristic_proc_desc instead.\n+\t     As some low level compiler support routines (__div*, __add*)\n+\t     use a non-standard return address register, we have to\n+\t     add some heuristics to determine the return address register,\n+\t     or stepping over these routines will fail.\n+\t     Usually the return address register is the first register\n+\t     saved on the stack, but assembler optimization might\n+\t     rearrange the register saves.\n+\t     So we recognize only a few registers (t7, t9, ra) within\n+\t     the procedure prologue as valid return address registers.\n+\t     If we encounter a return instruction, we extract the\n+\t     the return address register from it.\n+\n+\t     FIXME: Rewriting GDB to access the procedure descriptors,\n+\t     e.g. via the minimal symbol table, might obviate this hack.  */\n+\t  if (pcreg == -1\n+\t      && cur_pc < (start_pc + 80)\n+\t      && (reg == T7_REGNUM || reg == T9_REGNUM || reg == RA_REGNUM))\n+\t    pcreg = reg;\n+\t}\n+      else if ((word & 0xffe0ffff) == 0x6be08001)\t/* ret zero,reg,1 */\n+\tpcreg = (word >> 16) & 0x1f;\n+      else if (word == 0x47de040f)\t/* bis sp,sp fp */\n+\thas_frame_reg = 1;\n+    }\n+\n+  if (pcreg == -1)\n+    {\n+      /* If we haven't found a valid return address register yet,\n+         keep searching in the procedure prologue.  */\n+      while (cur_pc < (limit_pc + 80) && cur_pc < (start_pc + 80))\n+\t{\n+\t  unsigned int word;\n+\n+\t  if (read_memory_safe4 (cur_pc, &word))\n+\t    break;\n+\t  cur_pc += 4;\n+\n+\t  if ((word & 0xfc1f0000) == 0xb41e0000\t\t/* stq reg,n($sp) */\n+\t      && (word & 0xffff0000) != 0xb7fe0000)\t/* reg != $zero */\n+\t    {\n+\t      int reg = (word & 0x03e00000) >> 21;\n+\n+\t      if (reg == T7_REGNUM || reg == T9_REGNUM || reg == RA_REGNUM)\n+\t\t{\n+\t\t  pcreg = reg;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else if ((word & 0xffe0ffff) == 0x6be08001)\t/* ret zero,reg,1 */\n+\t    {\n+\t      pcreg = (word >> 16) & 0x1f;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (has_frame_reg)\n+    PROC_FRAME_REG (&temp_proc_desc) = GCC_FP_REGNUM;\n+  else\n+    PROC_FRAME_REG (&temp_proc_desc) = SP_REGNUM;\n+\n+  PROC_FRAME_OFFSET (&temp_proc_desc) = frame_size;\n+  PROC_REG_MASK (&temp_proc_desc) = reg_mask;\n+  PROC_PC_REG (&temp_proc_desc) = (pcreg == -1) ? RA_REGNUM : pcreg;\n+  PROC_LOCALOFF (&temp_proc_desc) = 0;\t/* XXX - bogus */\n+\n+  return &temp_proc_desc;\n+}\n+\n+static alpha_extra_func_info_t\n+find_proc_desc (pc, next_frame, saved_regs)\n+     CORE_ADDR pc;\n+     struct frame_info *next_frame;\n+     struct frame_saved_regs *saved_regs;\n+{\n+  CORE_ADDR startaddr;\n+\n+  /* If heuristic_fence_post is non-zero, determine the procedure\n+     start address by examining the instructions.\n+     This allows us to find the start address of static functions which\n+     have no symbolic information, as startaddr would have been set to\n+     the preceding global function start address by the\n+     find_pc_partial_function call above.  */\n+  startaddr = heuristic_proc_start (pc);\n+\n+  return heuristic_proc_desc (startaddr, pc, next_frame, saved_regs);\n+}\n+\n+static CORE_ADDR\n+alpha_frame_chain (frame)\n+     struct frame_info *frame;\n+{\n+  alpha_extra_func_info_t proc_desc;\n+  CORE_ADDR saved_pc = FRAME_SAVED_PC (frame);\n+\n+  if (saved_pc == 0 || inside_entry_file (saved_pc))\n+    return 0;\n+\n+  proc_desc = find_proc_desc (saved_pc, frame, NULL);\n+  if (!proc_desc)\n+    return 0;\n+\n+  /* If no frame pointer and frame size is zero, we must be at end\n+     of stack (or otherwise hosed).  If we don't check frame size,\n+     we loop forever if we see a zero size frame.  */\n+  if (PROC_FRAME_REG (proc_desc) == SP_REGNUM\n+      && PROC_FRAME_OFFSET (proc_desc) == 0)\n+    return 0;\n+  else\n+    return read_next_frame_reg (frame, PROC_FRAME_REG (proc_desc))\n+      + PROC_FRAME_OFFSET (proc_desc);\n+}\n+\n+static void\n+init_extra_frame_info (frame)\n+     struct frame_info *frame;\n+{\n+  struct frame_saved_regs temp_saved_regs;\n+  alpha_extra_func_info_t proc_desc = \n+    find_proc_desc (frame->pc, frame->next, &temp_saved_regs);\n+\n+  frame->saved_regs = NULL;\n+  frame->localoff = 0;\n+  frame->pc_reg = RA_REGNUM;\n+  frame->proc_desc = proc_desc;\n+\n+  if (proc_desc)\n+    {\n+      /* Get the locals offset and the saved pc register from the\n+         procedure descriptor, they are valid even if we are in the\n+         middle of the prologue.  */\n+      frame->localoff = PROC_LOCALOFF (proc_desc);\n+      frame->pc_reg = PROC_PC_REG (proc_desc);\n+\n+      /* Fixup frame-pointer - only needed for top frame */\n+\n+      /* This may not be quite right, if proc has a real frame register.\n+         Get the value of the frame relative sp, procedure might have been\n+         interrupted by a signal at it's very start.  */\n+      if (frame->pc == PROC_LOW_ADDR (proc_desc))\n+\tframe->frame = read_next_frame_reg (frame->next, SP_REGNUM);\n+      else\n+\tframe->frame\n+\t  = (read_next_frame_reg (frame->next, PROC_FRAME_REG (proc_desc))\n+\t     + PROC_FRAME_OFFSET (proc_desc));\n+\n+      frame->saved_regs\n+\t= (CORE_ADDR *) frame_obstack_alloc (SIZEOF_FRAME_SAVED_REGS);\n+      memcpy\n+        (frame->saved_regs, temp_saved_regs.regs, SIZEOF_FRAME_SAVED_REGS);\n+      frame->saved_regs[PC_REGNUM] = frame->saved_regs[RA_REGNUM];\n+    }\n+}\n+\n+/* Create an arbitrary (i.e. address specified by user) or innermost frame.\n+   Always returns a non-NULL value.  */\n+\n+static struct frame_info *\n+create_new_frame (addr, pc)\n+     CORE_ADDR addr;\n+     CORE_ADDR pc;\n+{\n+  struct frame_info *fi;\n+\n+  fi = (struct frame_info *)\n+    trace_alloc (sizeof (struct frame_info));\n+\n+  /* Arbitrary frame */\n+  fi->next = NULL;\n+  fi->prev = NULL;\n+  fi->frame = addr;\n+  fi->pc = pc;\n+\n+#ifdef INIT_EXTRA_FRAME_INFO\n+  INIT_EXTRA_FRAME_INFO (0, fi);\n+#endif\n+\n+  return fi;\n+}\n+\n+static CORE_ADDR current_pc;\n+\n+static void\n+set_current_pc ()\n+{\n+  current_pc = (CORE_ADDR) __builtin_return_address (0);\n+}\n+\n+static CORE_ADDR\n+read_pc ()\n+{\n+  return current_pc;\n+}\n+\n+static struct frame_info *\n+get_current_frame ()\n+{\n+  return create_new_frame (0, read_pc ());\n+}\n+\n+/* Return the frame that called FI.\n+   If FI is the original frame (it has no caller), return 0.  */\n+\n+static struct frame_info *\n+get_prev_frame (next_frame)\n+     struct frame_info *next_frame;\n+{\n+  CORE_ADDR address = 0;\n+  struct frame_info *prev;\n+  int fromleaf = 0;\n+\n+  /* If we have the prev one, return it */\n+  if (next_frame->prev)\n+    return next_frame->prev;\n+\n+  /* On some machines it is possible to call a function without\n+     setting up a stack frame for it.  On these machines, we\n+     define this macro to take two args; a frameinfo pointer\n+     identifying a frame and a variable to set or clear if it is\n+     or isn't leafless.  */\n+\n+  /* Two macros defined in tm.h specify the machine-dependent\n+     actions to be performed here.\n+\n+     First, get the frame's chain-pointer.  If that is zero, the frame\n+     is the outermost frame or a leaf called by the outermost frame.\n+     This means that if start calls main without a frame, we'll return\n+     0 (which is fine anyway).\n+\n+     Nope; there's a problem.  This also returns when the current\n+     routine is a leaf of main.  This is unacceptable.  We move\n+     this to after the ffi test; I'd rather have backtraces from\n+     start go curfluy than have an abort called from main not show\n+     main.  */\n+\n+  address = FRAME_CHAIN (next_frame);\n+  if (!FRAME_CHAIN_VALID (address, next_frame))\n+    return 0;\n+  address = FRAME_CHAIN_COMBINE (address, next_frame);\n+\n+  if (address == 0)\n+    return 0;\n+\n+  prev = (struct frame_info *) trace_alloc (sizeof (struct frame_info));\n+\n+  prev->saved_regs = NULL;\n+  if (next_frame)\n+    next_frame->prev = prev;\n+\n+  prev->next = next_frame;\n+  prev->prev = (struct frame_info *) 0;\n+  prev->frame = address;\n+\n+  /* This change should not be needed, FIXME!  We should\n+     determine whether any targets *need* INIT_FRAME_PC to happen\n+     after INIT_EXTRA_FRAME_INFO and come up with a simple way to\n+     express what goes on here.\n+\n+     INIT_EXTRA_FRAME_INFO is called from two places: create_new_frame\n+     (where the PC is already set up) and here (where it isn't).\n+     INIT_FRAME_PC is only called from here, always after\n+     INIT_EXTRA_FRAME_INFO.\n+\n+     The catch is the MIPS, where INIT_EXTRA_FRAME_INFO requires the PC\n+     value (which hasn't been set yet).  Some other machines appear to\n+     require INIT_EXTRA_FRAME_INFO before they can do INIT_FRAME_PC.  Phoo.\n+\n+     We shouldn't need INIT_FRAME_PC_FIRST to add more complication to\n+     an already overcomplicated part of GDB.   gnu@cygnus.com, 15Sep92.\n+\n+     Assuming that some machines need INIT_FRAME_PC after\n+     INIT_EXTRA_FRAME_INFO, one possible scheme:\n+\n+     SETUP_INNERMOST_FRAME()\n+     Default version is just create_new_frame (read_fp ()),\n+     read_pc ()).  Machines with extra frame info would do that (or the\n+     local equivalent) and then set the extra fields.\n+     INIT_PREV_FRAME(fromleaf, prev)\n+     Replace INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC.  This should\n+     also return a flag saying whether to keep the new frame, or\n+     whether to discard it, because on some machines (e.g.  mips) it\n+     is really awkward to have FRAME_CHAIN_VALID called *before*\n+     INIT_EXTRA_FRAME_INFO (there is no good way to get information\n+     deduced in FRAME_CHAIN_VALID into the extra fields of the new frame).\n+     std_frame_pc(fromleaf, prev)\n+     This is the default setting for INIT_PREV_FRAME.  It just does what\n+     the default INIT_FRAME_PC does.  Some machines will call it from\n+     INIT_PREV_FRAME (either at the beginning, the end, or in the middle).\n+     Some machines won't use it.\n+     kingdon@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */\n+\n+#ifdef INIT_FRAME_PC_FIRST\n+  INIT_FRAME_PC_FIRST (fromleaf, prev);\n+#endif\n+\n+#ifdef INIT_EXTRA_FRAME_INFO\n+  INIT_EXTRA_FRAME_INFO (fromleaf, prev);\n+#endif\n+\n+  /* This entry is in the frame queue now, which is good since\n+     FRAME_SAVED_PC may use that queue to figure out its value\n+     (see tm-sparc.h).  We want the pc saved in the inferior frame. */\n+  INIT_FRAME_PC (fromleaf, prev);\n+\n+  /* If ->frame and ->pc are unchanged, we are in the process of getting\n+     ourselves into an infinite backtrace.  Some architectures check this\n+     in FRAME_CHAIN or thereabouts, but it seems like there is no reason\n+     this can't be an architecture-independent check.  */\n+  if (next_frame != NULL)\n+    {\n+      if (prev->frame == next_frame->frame\n+\t  && prev->pc == next_frame->pc)\n+\t{\n+\t  next_frame->prev = NULL;\n+\t  free (prev);\n+\t  return NULL;\n+\t}\n+    }\n+\n+  return prev;\n+}\n+\n+#define SAVE(regno,disp) \\\n+    \"stq $\" #regno \", \" #disp \"(%0)\\n\" \n+\n+int\n+__gnat_backtrace (array, size, exclude_min, exclude_max)\n+     void **array;\n+     int size;\n+     void *exclude_min;\n+     void *exclude_max;\n+{\n+  struct frame_info* top;\n+  struct frame_info* current;\n+  int cnt;\n+\n+  /* This function is not thread safe, protect it */\n+  (*Lock_Task) ();\n+  asm volatile (\n+      SAVE (9,72)\n+      SAVE (10,80)\n+      SAVE (11,88)\n+      SAVE (12,96)\n+      SAVE (13,104)\n+      SAVE (14,112)\n+      SAVE (15,120)\n+      SAVE (16,128)\n+      SAVE (17,136)\n+      SAVE (18,144)\n+      SAVE (19,152)\n+      SAVE (20,160)\n+      SAVE (21,168)\n+      SAVE (22,176)\n+      SAVE (23,184)\n+      SAVE (24,192)\n+      SAVE (25,200)\n+      SAVE (26,208)\n+      SAVE (27,216)\n+      SAVE (28,224)\n+      SAVE (29,232)\n+      SAVE (30,240)\n+      : : \"r\" (&theRegisters));\n+\n+  trace_alloc_chain = NULL;\n+  set_current_pc ();\n+\n+  top = current = get_current_frame ();\n+  cnt = 0;\n+\n+  /* We skip the call to this function, it makes no sense to record it.  */\n+  for (cnt = 0; cnt < SKIP_FRAME; cnt += 1) {\n+    current = get_prev_frame (current);\n+  }\n+\n+  cnt = 0;\n+  while (cnt < size)\n+    {\n+      if (STOP_FRAME)\n+        break;\n+\n+      if (current->pc < (CORE_ADDR) exclude_min\n+\t  || current->pc > (CORE_ADDR) exclude_max)\n+        array[cnt++] = (void*) (current->pc + PC_ADJUST);\n+\n+      current = get_prev_frame (current);\n+    }\n+\n+  free_trace_alloc ();\n+  (*Unlock_Task) ();\n+\n+  return cnt;\n+}\n+#endif"}, {"sha": "572dff2645c9d2cf783f83306409e6b7624f106e", "filename": "gcc/ada/trans.c", "status": "added", "additions": 5428, "deletions": 0, "changes": 5428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=415dddc81c99f37554902cbe0d838060b62a2548"}, {"sha": "fc54b0e45c235a5787abb1c89321106de6516605", "filename": "gcc/ada/tree_gen.adb", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_gen.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             T R E E _ G E N                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;\n+with Elists;\n+with Fname;\n+with Lib;\n+with Namet;\n+with Nlists;\n+with Opt;\n+with Osint;\n+with Repinfo;\n+with Sinput;\n+with Stand;\n+with Stringt;\n+with Uintp;\n+with Urealp;\n+\n+procedure Tree_Gen is\n+begin\n+   if Opt.Tree_Output then\n+      Osint.Tree_Create;\n+      Opt.Tree_Write;\n+      Atree.Tree_Write;\n+      Elists.Tree_Write;\n+      Fname.Tree_Write;\n+      Lib.Tree_Write;\n+      Namet.Tree_Write;\n+      Nlists.Tree_Write;\n+      Sinput.Tree_Write;\n+      Stand.Tree_Write;\n+      Stringt.Tree_Write;\n+      Uintp.Tree_Write;\n+      Urealp.Tree_Write;\n+      Repinfo.Tree_Write;\n+      Osint.Tree_Close;\n+   end if;\n+end Tree_Gen;"}, {"sha": "0d3afe08380cec25e30338ceb7d108b2c9754b25", "filename": "gcc/ada/tree_gen.ads", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_gen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_gen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_gen.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,31 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             T R E E _ G E N                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+--     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This procedure is used to write out the tree if the option is set\n+\n+procedure Tree_Gen;"}, {"sha": "368cf5a2f487c09908cc9b56eda2d9b4c08bac68", "filename": "gcc/ada/tree_in.adb", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_in.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_in.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_in.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              T R E E _ I N                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;\n+with Csets;\n+with Elists;\n+with Fname;\n+with Lib;\n+with Namet;\n+with Nlists;\n+with Opt;\n+with Repinfo;\n+with Sinput;\n+with Stand;\n+with Stringt;\n+with Tree_IO;\n+with Uintp;\n+with Urealp;\n+\n+procedure Tree_In (Desc : File_Descriptor) is\n+begin\n+   Tree_IO.Tree_Read_Initialize (Desc);\n+   Opt.Tree_Read;\n+   Atree.Tree_Read;\n+   Elists.Tree_Read;\n+   Fname.Tree_Read;\n+   Lib.Tree_Read;\n+   Namet.Tree_Read;\n+   Nlists.Tree_Read;\n+   Sinput.Tree_Read;\n+   Stand.Tree_Read;\n+   Stringt.Tree_Read;\n+   Uintp.Tree_Read;\n+   Urealp.Tree_Read;\n+   Repinfo.Tree_Read;\n+   Csets.Initialize;\n+end Tree_In;"}, {"sha": "932794ce42f3fae0bd30b2fd488c7d50582c771a", "filename": "gcc/ada/tree_in.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_in.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_in.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_in.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,46 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              T R E E _ I N                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This procedure is used to read in a tree if the option is set. Note that\n+--  it is not part of the compiler proper, but rather the interface from\n+--  tools that need to read the tree to the tree reading routines, and is\n+--  thus bound as part of such tools.\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n+procedure Tree_In (Desc : File_Descriptor);\n+--  Desc is the file descriptor for the file containing the tree, as written\n+--  by the compiler in a previous compilation using Tree_Gen. On return the\n+--  global data structures are appropriately initialized."}, {"sha": "5f4c30fae770247d08a1ba61d59c70de964897be", "filename": "gcc/ada/tree_io.adb", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_io.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_io.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_io.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,661 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              T R E E _ I O                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;  use Debug;\n+with Output; use Output;\n+with Unchecked_Conversion;\n+\n+package body Tree_IO is\n+   Debug_Flag_Tree : Boolean := False;\n+   --  Debug flag for debug output from tree read/write\n+\n+   -------------------------------------------\n+   -- Compression Scheme Used for Tree File --\n+   -------------------------------------------\n+\n+   --  We don't just write the data directly, but instead do a mild form\n+   --  of compression, since we expect lots of compressible zeroes and\n+   --  blanks. The compression scheme is as follows:\n+\n+   --    00nnnnnn followed by nnnnnn bytes (non compressed data)\n+   --    01nnnnnn indicates nnnnnn binary zero bytes\n+   --    10nnnnnn indicates nnnnnn ASCII space bytes\n+   --    11nnnnnn bbbbbbbb indicates nnnnnnnn occurrences of byte bbbbbbbb\n+\n+   --  Since we expect many zeroes in trees, and many spaces in sources,\n+   --  this compression should be reasonably efficient. We can put in\n+   --  something better later on.\n+\n+   --  Note that this compression applies to the Write_Tree_Data and\n+   --  Read_Tree_Data calls, not to the calls to read and write single\n+   --  scalar values, which are written in memory format without any\n+   --  compression.\n+\n+   C_Noncomp : constant := 2#00_000000#;\n+   C_Zeros   : constant := 2#01_000000#;\n+   C_Spaces  : constant := 2#10_000000#;\n+   C_Repeat  : constant := 2#11_000000#;\n+   --  Codes for compression sequences\n+\n+   Max_Count : constant := 63;\n+   --  Maximum data length for one compression sequence\n+\n+   Max_Comp : constant := Max_Count + 1;\n+   --  Maximum length of one compression sequence\n+\n+   --  The above compression scheme applies only to data written with the\n+   --  Tree_Write routine and read with Tree_Read. Data written using the\n+   --  Tree_Write_Char or Tree_Write_Int routines and read using the\n+   --  corresponding input routines is not compressed.\n+\n+   type Int_Bytes is array (1 .. 4) of Byte;\n+   for Int_Bytes'Size use 32;\n+\n+   function To_Int_Bytes is new Unchecked_Conversion (Int, Int_Bytes);\n+   function To_Int       is new Unchecked_Conversion (Int_Bytes, Int);\n+\n+   ----------------------\n+   -- Global Variables --\n+   ----------------------\n+\n+   Tree_FD : File_Descriptor;\n+   --  File descriptor for tree\n+\n+   Buflen : constant Int := 8_192;\n+   --  Length of buffer for read and write file data\n+\n+   Buf : array (Pos range 1 .. Buflen) of Byte;\n+   --  Read/write file data buffer\n+\n+   Bufn : Nat;\n+   --  Number of bytes read/written from/to buffer\n+\n+   Buft : Nat;\n+   --  Total number of bytes in input buffer containing valid data. Used only\n+   --  for input operations. There is data left to be processed in the buffer\n+   --  if Buft > Bufn. A value of zero for Buft means that the buffer is empty.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Read_Buffer;\n+   --  Reads data into buffer, setting Bufe appropriately\n+\n+   function Read_Byte return Byte;\n+   pragma Inline (Read_Byte);\n+   --  Returns next byte from input file, raises Tree_Format_Error if none left\n+\n+   procedure Write_Buffer;\n+   --  Writes out current buffer contents\n+\n+   procedure Write_Byte (B : Byte);\n+   pragma Inline (Write_Byte);\n+   --  Write one byte to output buffer, checking for buffer-full condition\n+\n+   -----------------\n+   -- Read_Buffer --\n+   -----------------\n+\n+   procedure Read_Buffer is\n+   begin\n+      Buft := Int (Read (Tree_FD, Buf (1)'Address, Integer (Buflen)));\n+\n+      if Buft = 0 then\n+         raise Tree_Format_Error;\n+      else\n+         Bufn := 0;\n+      end if;\n+   end Read_Buffer;\n+\n+   ---------------\n+   -- Read_Byte --\n+   ---------------\n+\n+   function Read_Byte return Byte is\n+   begin\n+      if Bufn = Buft then\n+         Read_Buffer;\n+      end if;\n+\n+      Bufn := Bufn + 1;\n+      return Buf (Bufn);\n+   end Read_Byte;\n+\n+   --------------------\n+   -- Tree_Read_Bool --\n+   --------------------\n+\n+   procedure Tree_Read_Bool (B : out Boolean) is\n+   begin\n+      B := Boolean'Val (Read_Byte);\n+\n+      if Debug_Flag_Tree then\n+         if B then\n+            Write_Str (\"True\");\n+         else\n+            Write_Str (\"False\");\n+         end if;\n+\n+         Write_Eol;\n+      end if;\n+   end Tree_Read_Bool;\n+\n+   --------------------\n+   -- Tree_Read_Char --\n+   --------------------\n+\n+   procedure Tree_Read_Char (C : out Character) is\n+   begin\n+      C := Character'Val (Read_Byte);\n+\n+      if Debug_Flag_Tree then\n+         Write_Str (\"==> transmitting Character = \");\n+         Write_Char (C);\n+         Write_Eol;\n+      end if;\n+   end Tree_Read_Char;\n+\n+   --------------------\n+   -- Tree_Read_Data --\n+   --------------------\n+\n+   procedure Tree_Read_Data (Addr : Address; Length : Int) is\n+\n+      type S is array (Pos) of Byte;\n+      --  This is a big array, for which we have to suppress the warning\n+\n+      type SP is access all S;\n+\n+      function To_SP is new Unchecked_Conversion (Address, SP);\n+\n+      Data : constant SP := To_SP (Addr);\n+      --  Data buffer to be read as an indexable array of bytes\n+\n+      OP : Pos := 1;\n+      --  Pointer to next byte of data buffer to be read into\n+\n+      B : Byte;\n+      C : Byte;\n+      L : Int;\n+\n+   begin\n+      if Debug_Flag_Tree then\n+         Write_Str (\"==> transmitting \");\n+         Write_Int (Length);\n+         Write_Str (\" data bytes\");\n+         Write_Eol;\n+      end if;\n+\n+      --  Verify data length\n+\n+      Tree_Read_Int (L);\n+\n+      if L /= Length then\n+         Write_Str (\"==> transmitting, expected \");\n+         Write_Int (Length);\n+         Write_Str (\" bytes, found length = \");\n+         Write_Int (L);\n+         Write_Eol;\n+         raise Tree_Format_Error;\n+      end if;\n+\n+      --  Loop to read data\n+\n+      while OP <= Length loop\n+\n+         --  Get compression control character\n+\n+         B := Read_Byte;\n+         C := B and 2#00_111111#;\n+         B := B and 2#11_000000#;\n+\n+         --  Non-repeat case\n+\n+         if B = C_Noncomp then\n+            if Debug_Flag_Tree then\n+               Write_Str (\"==>    uncompressed:  \");\n+               Write_Int (Int (C));\n+               Write_Str (\", starting at \");\n+               Write_Int (OP);\n+               Write_Eol;\n+            end if;\n+\n+            for J in 1 .. C loop\n+               Data (OP) := Read_Byte;\n+               OP := OP + 1;\n+            end loop;\n+\n+         --  Repeated zeroes\n+\n+         elsif B = C_Zeros then\n+            if Debug_Flag_Tree then\n+               Write_Str (\"==>    zeroes:        \");\n+               Write_Int (Int (C));\n+               Write_Str (\", starting at \");\n+               Write_Int (OP);\n+               Write_Eol;\n+            end if;\n+\n+            for J in 1 .. C loop\n+               Data (OP) := 0;\n+               OP := OP + 1;\n+            end loop;\n+\n+         --  Repeated spaces\n+\n+         elsif B = C_Spaces then\n+            if Debug_Flag_Tree then\n+               Write_Str (\"==>    spaces:        \");\n+               Write_Int (Int (C));\n+               Write_Str (\", starting at \");\n+               Write_Int (OP);\n+               Write_Eol;\n+            end if;\n+\n+            for J in 1 .. C loop\n+               Data (OP) := Character'Pos (' ');\n+               OP := OP + 1;\n+            end loop;\n+\n+         --  Specified repeated character\n+\n+         else -- B = C_Repeat\n+            B := Read_Byte;\n+\n+            if Debug_Flag_Tree then\n+               Write_Str (\"==>    other char:    \");\n+               Write_Int (Int (C));\n+               Write_Str (\" (\");\n+               Write_Int (Int (B));\n+               Write_Char (')');\n+               Write_Str (\", starting at \");\n+               Write_Int (OP);\n+               Write_Eol;\n+            end if;\n+\n+            for J in 1 .. C loop\n+               Data (OP) := B;\n+               OP := OP + 1;\n+            end loop;\n+         end if;\n+      end loop;\n+\n+      --  At end of loop, data item must be exactly filled\n+\n+      if OP /= Length + 1 then\n+         raise Tree_Format_Error;\n+      end if;\n+\n+   end Tree_Read_Data;\n+\n+   --------------------------\n+   -- Tree_Read_Initialize --\n+   --------------------------\n+\n+   procedure Tree_Read_Initialize (Desc : File_Descriptor) is\n+   begin\n+      Buft := 0;\n+      Bufn := 0;\n+      Tree_FD := Desc;\n+      Debug_Flag_Tree := Debug_Flag_5;\n+   end Tree_Read_Initialize;\n+\n+   -------------------\n+   -- Tree_Read_Int --\n+   -------------------\n+\n+   procedure Tree_Read_Int (N : out Int) is\n+      N_Bytes : Int_Bytes;\n+\n+   begin\n+      for J in 1 .. 4 loop\n+         N_Bytes (J) := Read_Byte;\n+      end loop;\n+\n+      N := To_Int (N_Bytes);\n+\n+      if Debug_Flag_Tree then\n+         Write_Str (\"==> transmitting Int = \");\n+         Write_Int (N);\n+         Write_Eol;\n+      end if;\n+   end Tree_Read_Int;\n+\n+   -------------------\n+   -- Tree_Read_Str --\n+   -------------------\n+\n+   procedure Tree_Read_Str (S : out String_Ptr) is\n+      N : Nat;\n+\n+   begin\n+      Tree_Read_Int (N);\n+      S := new String (1 .. Natural (N));\n+      Tree_Read_Data (S.all (1)'Address, N);\n+   end Tree_Read_Str;\n+\n+   -------------------------\n+   -- Tree_Read_Terminate --\n+   -------------------------\n+\n+   procedure Tree_Read_Terminate is\n+   begin\n+      --  Must be at end of input buffer, so we should get Tree_Format_Error\n+      --  if we try to read one more byte, if not, we have a format error.\n+\n+      declare\n+         B : Byte;\n+      begin\n+         B := Read_Byte;\n+      exception\n+         when Tree_Format_Error => return;\n+      end;\n+\n+      raise Tree_Format_Error;\n+   end Tree_Read_Terminate;\n+\n+   ---------------------\n+   -- Tree_Write_Bool --\n+   ---------------------\n+\n+   procedure Tree_Write_Bool (B : Boolean) is\n+   begin\n+      if Debug_Flag_Tree then\n+         Write_Str (\"==> transmitting Boolean = \");\n+\n+         if B then\n+            Write_Str (\"True\");\n+         else\n+            Write_Str (\"False\");\n+         end if;\n+\n+         Write_Eol;\n+      end if;\n+\n+      Write_Byte (Boolean'Pos (B));\n+   end Tree_Write_Bool;\n+\n+   ---------------------\n+   -- Tree_Write_Char --\n+   ---------------------\n+\n+   procedure Tree_Write_Char (C : Character) is\n+   begin\n+      if Debug_Flag_Tree then\n+         Write_Str (\"==> transmitting Character = \");\n+         Write_Char (C);\n+         Write_Eol;\n+      end if;\n+\n+      Write_Byte (Character'Pos (C));\n+   end Tree_Write_Char;\n+\n+   ---------------------\n+   -- Tree_Write_Data --\n+   ---------------------\n+\n+   procedure Tree_Write_Data (Addr : Address; Length : Int) is\n+\n+      type S is array (Pos) of Byte;\n+      --  This is a big array, for which we have to suppress the warning\n+\n+      type SP is access all S;\n+\n+      function To_SP is new Unchecked_Conversion (Address, SP);\n+\n+      Data : constant SP := To_SP (Addr);\n+      --  Pointer to data to be written, converted to array type\n+\n+      IP : Pos := 1;\n+      --  Input buffer pointer, next byte to be processed\n+\n+      NC : Nat range 0 .. Max_Count := 0;\n+      --  Number of bytes of non-compressible sequence\n+\n+      C  : Byte;\n+\n+      procedure Write_Non_Compressed_Sequence;\n+      --  Output currently collected sequence of non-compressible data\n+\n+      procedure Write_Non_Compressed_Sequence is\n+      begin\n+         if NC > 0 then\n+            Write_Byte (C_Noncomp + Byte (NC));\n+\n+            if Debug_Flag_Tree then\n+               Write_Str (\"==>    uncompressed:  \");\n+               Write_Int (NC);\n+               Write_Str (\", starting at \");\n+               Write_Int (IP - NC);\n+               Write_Eol;\n+            end if;\n+\n+            for J in reverse 1 .. NC loop\n+               Write_Byte (Data (IP - J));\n+            end loop;\n+\n+            NC := 0;\n+         end if;\n+      end Write_Non_Compressed_Sequence;\n+\n+   --  Start of processing for Tree_Write_Data\n+\n+   begin\n+      if Debug_Flag_Tree then\n+         Write_Str (\"==> transmitting \");\n+         Write_Int (Length);\n+         Write_Str (\" data bytes\");\n+         Write_Eol;\n+      end if;\n+\n+      --  We write the count at the start, so that we can check it on\n+      --  the corresponding read to make sure that reads and writes match\n+\n+      Tree_Write_Int (Length);\n+\n+      --  Conversion loop\n+      --    IP is index of next input character\n+      --    NC is number of non-compressible bytes saved up\n+\n+      loop\n+         --  If input is completely processed, then we are all done\n+\n+         if IP > Length then\n+            Write_Non_Compressed_Sequence;\n+            return;\n+         end if;\n+\n+         --  Test for compressible sequence, must be at least three identical\n+         --  bytes in a row to be worthwhile compressing.\n+\n+         if IP + 2 <= Length\n+           and then Data (IP) = Data (IP + 1)\n+           and then Data (IP) = Data (IP + 2)\n+         then\n+            Write_Non_Compressed_Sequence;\n+\n+            --  Count length of new compression sequence\n+\n+            C := 3;\n+            IP := IP + 3;\n+\n+            while IP < Length\n+              and then Data (IP) = Data (IP - 1)\n+              and then C < Max_Count\n+            loop\n+               C := C + 1;\n+               IP := IP + 1;\n+            end loop;\n+\n+            --  Output compression sequence\n+\n+            if Data (IP - 1) = 0 then\n+               if Debug_Flag_Tree then\n+                  Write_Str (\"==>    zeroes:        \");\n+                  Write_Int (Int (C));\n+                  Write_Str (\", starting at \");\n+                  Write_Int (IP - Int (C));\n+                  Write_Eol;\n+               end if;\n+\n+               Write_Byte (C_Zeros + C);\n+\n+            elsif Data (IP - 1) = Character'Pos (' ') then\n+               if Debug_Flag_Tree then\n+                  Write_Str (\"==>    spaces:        \");\n+                  Write_Int (Int (C));\n+                  Write_Str (\", starting at \");\n+                  Write_Int (IP - Int (C));\n+                  Write_Eol;\n+               end if;\n+\n+               Write_Byte (C_Spaces + C);\n+\n+            else\n+               if Debug_Flag_Tree then\n+                  Write_Str (\"==>    other char:    \");\n+                  Write_Int (Int (C));\n+                  Write_Str (\" (\");\n+                  Write_Int (Int (Data (IP - 1)));\n+                  Write_Char (')');\n+                  Write_Str (\", starting at \");\n+                  Write_Int (IP - Int (C));\n+                  Write_Eol;\n+               end if;\n+\n+               Write_Byte (C_Repeat + C);\n+               Write_Byte (Data (IP - 1));\n+            end if;\n+\n+         --  No compression possible here\n+\n+         else\n+            --  Output non-compressed sequence if at maximum length\n+\n+            if NC = Max_Count then\n+               Write_Non_Compressed_Sequence;\n+            end if;\n+\n+            NC := NC + 1;\n+            IP := IP + 1;\n+         end if;\n+      end loop;\n+\n+   end Tree_Write_Data;\n+\n+   ---------------------------\n+   -- Tree_Write_Initialize --\n+   ---------------------------\n+\n+   procedure Tree_Write_Initialize (Desc : File_Descriptor) is\n+   begin\n+      Bufn := 0;\n+      Tree_FD := Desc;\n+      Set_Standard_Error;\n+      Debug_Flag_Tree := Debug_Flag_5;\n+   end Tree_Write_Initialize;\n+\n+   --------------------\n+   -- Tree_Write_Int --\n+   --------------------\n+\n+   procedure Tree_Write_Int (N : Int) is\n+      N_Bytes : constant Int_Bytes := To_Int_Bytes (N);\n+\n+   begin\n+      if Debug_Flag_Tree then\n+         Write_Str (\"==> transmitting Int = \");\n+         Write_Int (N);\n+         Write_Eol;\n+      end if;\n+\n+      for J in 1 .. 4 loop\n+         Write_Byte (N_Bytes (J));\n+      end loop;\n+   end Tree_Write_Int;\n+\n+   --------------------\n+   -- Tree_Write_Str --\n+   --------------------\n+\n+   procedure Tree_Write_Str (S : String_Ptr) is\n+   begin\n+      Tree_Write_Int (S'Length);\n+      Tree_Write_Data (S (1)'Address, S'Length);\n+   end Tree_Write_Str;\n+\n+   --------------------------\n+   -- Tree_Write_Terminate --\n+   --------------------------\n+\n+   procedure Tree_Write_Terminate is\n+   begin\n+      if Bufn > 0 then\n+         Write_Buffer;\n+      end if;\n+   end Tree_Write_Terminate;\n+\n+   ------------------\n+   -- Write_Buffer --\n+   ------------------\n+\n+   procedure Write_Buffer is\n+   begin\n+      if Integer (Bufn) = Write (Tree_FD, Buf'Address, Integer (Bufn)) then\n+         Bufn := 0;\n+\n+      else\n+         Set_Standard_Error;\n+         Write_Str (\"fatal error: disk full\");\n+         OS_Exit (2);\n+      end if;\n+   end Write_Buffer;\n+\n+   ----------------\n+   -- Write_Byte --\n+   ----------------\n+\n+   procedure Write_Byte (B : Byte) is\n+   begin\n+      Bufn := Bufn + 1;\n+      Buf (Bufn) := B;\n+\n+      if Bufn = Buflen then\n+         Write_Buffer;\n+      end if;\n+   end Write_Byte;\n+\n+end Tree_IO;"}, {"sha": "28fd07aefeffafc440130e5ba82b68ca4d682e2f", "filename": "gcc/ada/tree_io.ads", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftree_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_io.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,107 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              T R E E _ I O                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines used to read and write the tree files\n+--  used by ASIS. Only the actual read and write routines are here. The open,\n+--  create and close routines are elsewhere (in Osint in the compiler, and in\n+--  the tree read driver for the tree read interface).\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with System;      use System;\n+with Types;       use Types;\n+\n+package Tree_IO is\n+\n+   Tree_Format_Error : exception;\n+   --  Raised if a format error is detected in the input file\n+\n+   procedure Tree_Read_Initialize (Desc : File_Descriptor);\n+   --  Called to initialize reading of a tree file. This call must be made\n+   --  before calls to Tree_Read_xx. No calls to Tree_Write_xx are permitted\n+   --  after this call.\n+\n+   procedure Tree_Read_Data (Addr : Address; Length : Int);\n+   --  Checks that the Length provided is the same as what has been provided\n+   --  to the corresponding Tree_Write_Data from the current tree file,\n+   --  Tree_Format_Error is raised if it is not the case. If Length is\n+   --  correct and non zero, reads Length bytes of information into memory\n+   --  starting at Addr from the current tree file.\n+\n+   procedure Tree_Read_Bool (B : out Boolean);\n+   --  Reads a single boolean value. The boolean value must have been written\n+   --  with a call to the Tree_Write_Bool procedure.\n+\n+   procedure Tree_Read_Char (C : out Character);\n+   --  Reads a single character. The character must have been written with a\n+   --  call to the Tree_Write_Char procedure.\n+\n+   procedure Tree_Read_Int (N : out Int);\n+   --  Reads a single integer value. The integer must have been written with\n+   --  a call to the Tree_Write_Int procedure.\n+\n+   procedure Tree_Read_Str (S : out String_Ptr);\n+   --  Read string, allocate on heap, and return pointer to allocated string\n+   --  which always has a lower bound of 1.\n+\n+   procedure Tree_Read_Terminate;\n+   --  Called after reading all data, checks that the buffer pointers is at\n+   --  the end of file, raising Tree_Format_Error if not.\n+\n+   procedure Tree_Write_Initialize (Desc : File_Descriptor);\n+   --  Called to initialize writing of a tree file. This call must be made\n+   --  before calls to Tree_Write_xx. No calls to Tree_Read_xx are permitted\n+   --  after this call.\n+\n+   procedure Tree_Write_Data (Addr : Address; Length : Int);\n+   --  Writes Length then, if Length is not null, Length bytes of data\n+   --  starting at Addr to current tree file\n+\n+   procedure Tree_Write_Bool (B : Boolean);\n+   --  Writes a single boolean value to the current tree file\n+\n+   procedure Tree_Write_Char (C : Character);\n+   --  Writes a single character to the current tree file\n+\n+   procedure Tree_Write_Int (N : Int);\n+   --  Writes a single integer value to the current tree file\n+\n+   procedure Tree_Write_Str (S : String_Ptr);\n+   --  Write out string value referenced by S. Low bound must be 1.\n+\n+   procedure Tree_Write_Terminate;\n+   --  Terminates writing of the file (flushing the buffer), but does not\n+   --  close the file (the caller is responsible for closing the file).\n+\n+end Tree_IO;"}, {"sha": "80954c9e660c54dcd69b5c96a7aeea225154dc8d", "filename": "gcc/ada/treepr.adb", "status": "added", "additions": 1873, "deletions": 0, "changes": 1873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,1873 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               T R E E P R                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.128 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Csets;    use Csets;\n+with Debug;    use Debug;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Output;   use Output;\n+with Sem_Mech; use Sem_Mech;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Sinput;   use Sinput;\n+with Stand;    use Stand;\n+with Stringt;  use Stringt;\n+with Treeprs;  use Treeprs;\n+with Uintp;    use Uintp;\n+with Urealp;   use Urealp;\n+with Uname;    use Uname;\n+with Unchecked_Deallocation;\n+\n+package body Treepr is\n+\n+   use Atree.Unchecked_Access;\n+   --  This module uses the unchecked access functions in package Atree\n+   --  since it does an untyped traversal of the tree (we do not want to\n+   --  count on the structure of the tree being correct in this routine!)\n+\n+   ----------------------------------\n+   -- Approach Used for Tree Print --\n+   ----------------------------------\n+\n+   --  When a complete subtree is being printed, a trace phase first marks\n+   --  the nodes and lists to be printed. This trace phase allocates logical\n+   --  numbers corresponding to the order in which the nodes and lists will\n+   --  be printed. The Node_Id, List_Id and Elist_Id values are mapped to\n+   --  logical node numbers using a hash table. Output is done using a set\n+   --  of Print_xxx routines, which are similar to the Write_xxx routines\n+   --  with the same name, except that they do not generate any output in\n+   --  the marking phase. This allows identical logic to be used in the\n+   --  two phases.\n+\n+   --  Note that the hash table not only holds the serial numbers, but also\n+   --  acts as a record of which nodes have already been visited. In the\n+   --  marking phase, a node has been visited if it is already in the hash\n+   --  table, and in the printing phase, we can tell whether a node has\n+   --  already been printed by looking at the value of the serial number.\n+\n+   ----------------------\n+   -- Global Variables --\n+   ----------------------\n+\n+   type Hash_Record is record\n+      Serial : Nat;\n+      --  Serial number for hash table entry. A value of zero means that\n+      --  the entry is currently unused.\n+\n+      Id : Int;\n+      --  If serial number field is non-zero, contains corresponding Id value\n+   end record;\n+\n+   type Hash_Table_Type is array (Nat range <>) of Hash_Record;\n+   type Access_Hash_Table_Type is access Hash_Table_Type;\n+   Hash_Table : Access_Hash_Table_Type;\n+   --  The hash table itself, see Serial_Number function for details of use\n+\n+   Hash_Table_Len : Nat;\n+   --  Range of Hash_Table is from 0 .. Hash_Table_Len - 1 so that dividing\n+   --  by Hash_Table_Len gives a remainder that is in Hash_Table'Range.\n+\n+   Next_Serial_Number : Nat;\n+   --  Number of last visited node or list. Used during the marking phase to\n+   --  set proper node numbers in the hash table, and during the printing\n+   --  phase to make sure that a given node is not printed more than once.\n+   --  (nodes are printed in order during the printing phase, that's the\n+   --  point of numbering them in the first place!)\n+\n+   Printing_Descendants : Boolean;\n+   --  True if descendants are being printed, False if not. In the false case,\n+   --  only node Id's are printed. In the true case, node numbers as well as\n+   --  node Id's are printed, as described above.\n+\n+   type Phase_Type is (Marking, Printing);\n+   --  Type for Phase variable\n+\n+   Phase : Phase_Type;\n+   --  When an entire tree is being printed, the traversal operates in two\n+   --  phases. The first phase marks the nodes in use by installing node\n+   --  numbers in the node number table. The second phase prints the nodes.\n+   --  This variable indicates the current phase.\n+\n+   ----------------------\n+   -- Local Procedures --\n+   ----------------------\n+\n+   procedure Print_End_Span (N : Node_Id);\n+   --  Special routine to print contents of End_Span field of node N.\n+   --  The format includes the implicit source location as well as the\n+   --  value of the field.\n+\n+   procedure Print_Init;\n+   --  Initialize for printing of tree with descendents\n+\n+   procedure Print_Term;\n+   --  Clean up after printing of tree with descendents\n+\n+   procedure Print_Char (C : Character);\n+   --  Print character C if currently in print phase, noop if in marking phase\n+\n+   procedure Print_Name (N : Name_Id);\n+   --  Print name from names table if currently in print phase, noop if in\n+   --  marking phase. Note that the name is output in mixed case mode.\n+\n+   procedure Print_Node_Kind (N : Node_Id);\n+   --  Print node kind name in mixed case if in print phase, noop if in\n+   --  marking phase.\n+\n+   procedure Print_Str (S : String);\n+   --  Print string S if currently in print phase, noop if in marking phase\n+\n+   procedure Print_Str_Mixed_Case (S : String);\n+   --  Like Print_Str, except that the string is printed in mixed case mode\n+\n+   procedure Print_Int (I : Int);\n+   --  Print integer I if currently in print phase, noop if in marking phase\n+\n+   procedure Print_Eol;\n+   --  Print end of line if currently in print phase, noop if in marking phase\n+\n+   procedure Print_Node_Ref (N : Node_Id);\n+   --  Print \"<empty>\", \"<error>\" or \"Node #nnn\" with additional information\n+   --  in the latter case, including the Id and the Nkind of the node.\n+\n+   procedure Print_List_Ref (L : List_Id);\n+   --  Print \"<no list>\", or \"<empty node list>\" or \"Node list #nnn\"\n+\n+   procedure Print_Elist_Ref (E : Elist_Id);\n+   --  Print \"<no elist>\", or \"<empty element list>\" or \"Element list #nnn\"\n+\n+   procedure Print_Entity_Info (Ent : Entity_Id; Prefix : String);\n+   --  Called if the node being printed is an entity. Prints fields from the\n+   --  extension, using routines in Einfo to get the field names and flags.\n+\n+   procedure Print_Field (Val : Union_Id; Format : UI_Format := Auto);\n+   --  Print representation of Field value (name, tree, string, uint, charcode)\n+   --  The format parameter controls the format of printing in the case of an\n+   --  integer value (see UI_Write for details).\n+\n+   procedure Print_Flag (F : Boolean);\n+   --  Print True or False\n+\n+   procedure Print_Node\n+     (N           : Node_Id;\n+      Prefix_Str  : String;\n+      Prefix_Char : Character);\n+   --  This is the internal routine used to print a single node. Each line of\n+   --  output is preceded by Prefix_Str (which is used to set the indentation\n+   --  level and the bars used to link list elements). In addition, for lines\n+   --  other than the first, an additional character Prefix_Char is output.\n+\n+   function Serial_Number (Id : Int) return Nat;\n+   --  Given a Node_Id, List_Id or Elist_Id, returns the previously assigned\n+   --  serial number, or zero if no serial number has yet been assigned.\n+\n+   procedure Set_Serial_Number;\n+   --  Can be called only immediately following a call to Serial_Number that\n+   --  returned a value of zero. Causes the value of Next_Serial_Number to be\n+   --  placed in the hash table (corresponding to the Id argument used in the\n+   --  Serial_Number call), and increments Next_Serial_Number.\n+\n+   procedure Visit_Node\n+     (N           : Node_Id;\n+      Prefix_Str  : String;\n+      Prefix_Char : Character);\n+   --  Called to process a single node in the case where descendents are to\n+   --  be printed before every line, and Prefix_Char added to all lines\n+   --  except the header line for the node.\n+\n+   procedure Visit_List (L : List_Id; Prefix_Str : String);\n+   --  Visit_List is called to process a list in the case where descendents\n+   --  are to be printed. Prefix_Str is to be added to all printed lines.\n+\n+   procedure Visit_Elist (E : Elist_Id; Prefix_Str : String);\n+   --  Visit_Elist is called to process an element list in the case where\n+   --  descendents are to be printed. Prefix_Str is to be added to all\n+   --  printed lines.\n+\n+   --------\n+   -- PE --\n+   --------\n+\n+   procedure PE (E : Elist_Id) is\n+   begin\n+      Print_Tree_Elist (E);\n+   end PE;\n+\n+   --------\n+   -- PL --\n+   --------\n+\n+   procedure PL (L : List_Id) is\n+   begin\n+      Print_Tree_List (L);\n+   end PL;\n+\n+   --------\n+   -- PN --\n+   --------\n+\n+   procedure PN (N : Node_Id) is\n+   begin\n+      Print_Tree_Node (N);\n+   end PN;\n+\n+   ----------------\n+   -- Print_Char --\n+   ----------------\n+\n+   procedure Print_Char (C : Character) is\n+   begin\n+      if Phase = Printing then\n+         Write_Char (C);\n+      end if;\n+   end Print_Char;\n+\n+   ---------------------\n+   -- Print_Elist_Ref --\n+   ---------------------\n+\n+   procedure Print_Elist_Ref (E : Elist_Id) is\n+   begin\n+      if Phase /= Printing then\n+         return;\n+      end if;\n+\n+      if E = No_Elist then\n+         Write_Str (\"<no elist>\");\n+\n+      elsif Is_Empty_Elmt_List (E) then\n+         Write_Str (\"Empty elist, (Elist_Id=\");\n+         Write_Int (Int (E));\n+         Write_Char (')');\n+\n+      else\n+         Write_Str (\"(Elist_Id=\");\n+         Write_Int (Int (E));\n+         Write_Char (')');\n+\n+         if Printing_Descendants then\n+            Write_Str (\" #\");\n+            Write_Int (Serial_Number (Int (E)));\n+         end if;\n+      end if;\n+   end Print_Elist_Ref;\n+\n+   -------------------------\n+   -- Print_Elist_Subtree --\n+   -------------------------\n+\n+   procedure Print_Elist_Subtree (E : Elist_Id) is\n+   begin\n+      Print_Init;\n+\n+      Next_Serial_Number := 1;\n+      Phase := Marking;\n+      Visit_Elist (E, \"\");\n+\n+      Next_Serial_Number := 1;\n+      Phase := Printing;\n+      Visit_Elist (E, \"\");\n+\n+      Print_Term;\n+   end Print_Elist_Subtree;\n+\n+   --------------------\n+   -- Print_End_Span --\n+   --------------------\n+\n+   procedure Print_End_Span (N : Node_Id) is\n+      Val : constant Uint := End_Span (N);\n+\n+   begin\n+      UI_Write (Val);\n+      Write_Str (\" (Uint = \");\n+      Write_Int (Int (Field5 (N)));\n+      Write_Str (\")  \");\n+\n+      if Val /= No_Uint then\n+         Write_Location (End_Location (N));\n+      end if;\n+   end Print_End_Span;\n+\n+   -----------------------\n+   -- Print_Entity_Info --\n+   -----------------------\n+\n+   procedure Print_Entity_Info (Ent : Entity_Id; Prefix : String) is\n+      function Field_Present (U : Union_Id) return Boolean;\n+      --  Returns False unless the value U represents a missing value\n+      --  (Empty, No_Uint, No_Ureal or No_String)\n+\n+      function Field_Present (U : Union_Id) return Boolean is\n+      begin\n+         return\n+            U /= Union_Id (Empty)    and then\n+            U /= To_Union (No_Uint)  and then\n+            U /= To_Union (No_Ureal) and then\n+            U /= Union_Id (No_String);\n+      end Field_Present;\n+\n+   --  Start of processing for Print_Entity_Info\n+\n+   begin\n+      Print_Str (Prefix);\n+      Print_Str (\"Ekind = \");\n+      Print_Str_Mixed_Case (Entity_Kind'Image (Ekind (Ent)));\n+      Print_Eol;\n+\n+      Print_Str (Prefix);\n+      Print_Str (\"Etype = \");\n+      Print_Node_Ref (Etype (Ent));\n+      Print_Eol;\n+\n+      if Convention (Ent) /= Convention_Ada then\n+         Print_Str (Prefix);\n+         Print_Str (\"Convention = \");\n+\n+         --  Print convention name skipping the Convention_ at the start\n+\n+         declare\n+            S : constant String := Convention_Id'Image (Convention (Ent));\n+\n+         begin\n+            Print_Str_Mixed_Case (S (12 .. S'Last));\n+            Print_Eol;\n+         end;\n+      end if;\n+\n+      if Field_Present (Field6 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field6_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field6 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field7 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field7_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field7 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field8 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field8_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field8 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field9 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field9_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field9 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field10 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field10_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field10 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field11 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field11_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field11 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field12 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field12_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field12 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field13 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field13_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field13 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field14 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field14_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field14 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field15 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field15_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field15 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field16 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field16_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field16 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field17 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field17_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field17 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field18 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field18_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field18 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field19 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field19_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field19 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field20 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field20_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field20 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field21 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field21_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field21 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field22 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field22_Name (Ent);\n+         Write_Str (\" = \");\n+\n+         --  Mechanism case has to be handled specially\n+\n+         if Ekind (Ent) = E_Function or else Is_Formal (Ent) then\n+            declare\n+               M : constant Mechanism_Type := Mechanism (Ent);\n+\n+            begin\n+               case M is\n+                  when Default_Mechanism  => Write_Str (\"Default\");\n+                  when By_Copy            => Write_Str (\"By_Copy\");\n+                  when By_Reference       => Write_Str (\"By_Reference\");\n+                  when By_Descriptor      => Write_Str (\"By_Descriptor\");\n+                  when By_Descriptor_UBS  => Write_Str (\"By_Descriptor_UBS\");\n+                  when By_Descriptor_UBSB => Write_Str (\"By_Descriptor_UBSB\");\n+                  when By_Descriptor_UBA  => Write_Str (\"By_Descriptor_UBA\");\n+                  when By_Descriptor_S    => Write_Str (\"By_Descriptor_S\");\n+                  when By_Descriptor_SB   => Write_Str (\"By_Descriptor_SB\");\n+                  when By_Descriptor_A    => Write_Str (\"By_Descriptor_A\");\n+                  when By_Descriptor_NCA  => Write_Str (\"By_Descriptor_NCA\");\n+\n+                  when 1 .. Mechanism_Type'Last =>\n+                     Write_Str (\"By_Copy if size <= \");\n+                     Write_Int (Int (M));\n+\n+               end case;\n+            end;\n+\n+         --  Normal case (not Mechanism)\n+\n+         else\n+            Print_Field (Field22 (Ent));\n+         end if;\n+\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field23 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field23_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field23 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      Write_Entity_Flags (Ent, Prefix);\n+\n+   end Print_Entity_Info;\n+\n+   ---------------\n+   -- Print_Eol --\n+   ---------------\n+\n+   procedure Print_Eol is\n+   begin\n+      if Phase = Printing then\n+         Write_Eol;\n+      end if;\n+   end Print_Eol;\n+\n+   -----------------\n+   -- Print_Field --\n+   -----------------\n+\n+   procedure Print_Field (Val : Union_Id; Format : UI_Format := Auto) is\n+   begin\n+      if Phase /= Printing then\n+         return;\n+      end if;\n+\n+      if Val in Node_Range then\n+         Print_Node_Ref (Node_Id (Val));\n+\n+      elsif Val in List_Range then\n+         Print_List_Ref (List_Id (Val));\n+\n+      elsif Val in Elist_Range then\n+         Print_Elist_Ref (Elist_Id (Val));\n+\n+      elsif Val in Names_Range then\n+         Print_Name (Name_Id (Val));\n+         Write_Str (\" (Name_Id=\");\n+         Write_Int (Int (Val));\n+         Write_Char (')');\n+\n+      elsif Val in Strings_Range then\n+         Write_String_Table_Entry (String_Id (Val));\n+         Write_Str (\" (String_Id=\");\n+         Write_Int (Int (Val));\n+         Write_Char (')');\n+\n+      elsif Val in Uint_Range then\n+         UI_Write (From_Union (Val), Format);\n+         Write_Str (\" (Uint = \");\n+         Write_Int (Int (Val));\n+         Write_Char (')');\n+\n+      elsif Val in Ureal_Range then\n+         UR_Write (From_Union (Val));\n+         Write_Str (\" (Ureal = \");\n+         Write_Int (Int (Val));\n+         Write_Char (')');\n+\n+      elsif Val in Char_Code_Range then\n+         Write_Str (\"Character code = \");\n+\n+         declare\n+            C : Char_Code := Char_Code (Val - Char_Code_Bias);\n+\n+         begin\n+            Write_Int (Int (C));\n+            Write_Str (\" ('\");\n+            Write_Char_Code (C);\n+            Write_Str (\"')\");\n+         end;\n+\n+      else\n+         Print_Str (\"****** Incorrect value = \");\n+         Print_Int (Int (Val));\n+      end if;\n+   end Print_Field;\n+\n+   ----------------\n+   -- Print_Flag --\n+   ----------------\n+\n+   procedure Print_Flag (F : Boolean) is\n+   begin\n+      if F then\n+         Print_Str (\"True\");\n+      else\n+         Print_Str (\"False\");\n+      end if;\n+   end Print_Flag;\n+\n+   ----------------\n+   -- Print_Init --\n+   ----------------\n+\n+   procedure Print_Init is\n+   begin\n+      Printing_Descendants := True;\n+      Write_Eol;\n+\n+      --  Allocate and clear serial number hash table. The size is 150% of\n+      --  the maximum possible number of entries, so that the hash table\n+      --  cannot get significantly overloaded.\n+\n+      Hash_Table_Len := (150 * (Num_Nodes + Num_Lists + Num_Elists)) / 100;\n+      Hash_Table := new Hash_Table_Type  (0 .. Hash_Table_Len - 1);\n+\n+      for J in Hash_Table'Range loop\n+         Hash_Table (J).Serial := 0;\n+      end loop;\n+\n+   end Print_Init;\n+\n+   ---------------\n+   -- Print_Int --\n+   ---------------\n+\n+   procedure Print_Int (I : Int) is\n+   begin\n+      if Phase = Printing then\n+         Write_Int (I);\n+      end if;\n+   end Print_Int;\n+\n+   --------------------\n+   -- Print_List_Ref --\n+   --------------------\n+\n+   procedure Print_List_Ref (L : List_Id) is\n+   begin\n+      if Phase /= Printing then\n+         return;\n+      end if;\n+\n+      if No (L) then\n+         Write_Str (\"<no list>\");\n+\n+      elsif Is_Empty_List (L) then\n+         Write_Str (\"<empty list> (List_Id=\");\n+         Write_Int (Int (L));\n+         Write_Char (')');\n+\n+      else\n+         Write_Str (\"List\");\n+\n+         if Printing_Descendants then\n+            Write_Str (\" #\");\n+            Write_Int (Serial_Number (Int (L)));\n+         end if;\n+\n+         Write_Str (\" (List_Id=\");\n+         Write_Int (Int (L));\n+         Write_Char (')');\n+      end if;\n+   end Print_List_Ref;\n+\n+   ------------------------\n+   -- Print_List_Subtree --\n+   ------------------------\n+\n+   procedure Print_List_Subtree (L : List_Id) is\n+   begin\n+      Print_Init;\n+\n+      Next_Serial_Number := 1;\n+      Phase := Marking;\n+      Visit_List (L, \"\");\n+\n+      Next_Serial_Number := 1;\n+      Phase := Printing;\n+      Visit_List (L, \"\");\n+\n+      Print_Term;\n+   end Print_List_Subtree;\n+\n+   ----------------\n+   -- Print_Name --\n+   ----------------\n+\n+   procedure Print_Name (N : Name_Id) is\n+   begin\n+      if Phase = Printing then\n+         if N = No_Name then\n+            Print_Str (\"<No_Name>\");\n+\n+         elsif N = Error_Name then\n+            Print_Str (\"<Error_Name>\");\n+\n+         else\n+            Get_Name_String (N);\n+            Print_Char ('\"');\n+            Write_Name (N);\n+            Print_Char ('\"');\n+         end if;\n+      end if;\n+   end Print_Name;\n+\n+   ----------------\n+   -- Print_Node --\n+   ----------------\n+\n+   procedure Print_Node\n+     (N           : Node_Id;\n+      Prefix_Str  : String;\n+      Prefix_Char : Character)\n+   is\n+      F : Fchar;\n+      P : Natural := Pchar_Pos (Nkind (N));\n+\n+      Field_To_Be_Printed : Boolean;\n+      Prefix_Str_Char     : String (Prefix_Str'First .. Prefix_Str'Last + 1);\n+\n+      Sfile : Source_File_Index;\n+      Notes : Boolean;\n+      Fmt   : UI_Format;\n+\n+   begin\n+      if Phase /= Printing then\n+         return;\n+      end if;\n+\n+      if Nkind (N) = N_Integer_Literal and then Print_In_Hex (N) then\n+         Fmt := Hex;\n+      else\n+         Fmt := Auto;\n+      end if;\n+\n+      Prefix_Str_Char (Prefix_Str'Range)    := Prefix_Str;\n+      Prefix_Str_Char (Prefix_Str'Last + 1) := Prefix_Char;\n+\n+      --  Print header line\n+\n+      Print_Str (Prefix_Str);\n+      Print_Node_Ref (N);\n+\n+      Notes := False;\n+\n+      if Comes_From_Source (N) then\n+         Notes := True;\n+         Print_Str (\" (source\");\n+      end if;\n+\n+      if Analyzed (N) then\n+         if not Notes then\n+            Notes := True;\n+            Print_Str (\" (\");\n+         else\n+            Print_Str (\",\");\n+         end if;\n+\n+         Print_Str (\"analyzed\");\n+      end if;\n+\n+      if Error_Posted (N) then\n+         if not Notes then\n+            Notes := True;\n+            Print_Str (\" (\");\n+         else\n+            Print_Str (\",\");\n+         end if;\n+\n+         Print_Str (\"posted\");\n+      end if;\n+\n+      if Notes then\n+         Print_Char (')');\n+      end if;\n+\n+      Print_Eol;\n+\n+      if Is_Rewrite_Substitution (N) then\n+         Print_Str (Prefix_Str);\n+         Print_Str (\" Rewritten: original node = \");\n+         Print_Node_Ref (Original_Node (N));\n+         Print_Eol;\n+      end if;\n+\n+      if N = Empty then\n+         return;\n+      end if;\n+\n+      if not Is_List_Member (N) then\n+         Print_Str (Prefix_Str);\n+         Print_Str (\" Parent = \");\n+         Print_Node_Ref (Parent (N));\n+         Print_Eol;\n+      end if;\n+\n+      --  Print Sloc field if it is set\n+\n+      if Sloc (N) /= No_Location then\n+         Print_Str (Prefix_Str_Char);\n+         Print_Str (\"Sloc = \");\n+\n+         if Sloc (N) = Standard_Location then\n+            Print_Str (\"Standard_Location\");\n+\n+         elsif Sloc (N) = Standard_ASCII_Location then\n+            Print_Str (\"Standard_ASCII_Location\");\n+\n+         else\n+            Sfile := Get_Source_File_Index (Sloc (N));\n+            Print_Int (Int (Sloc (N)) - Int (Source_Text (Sfile)'First));\n+            Write_Str (\"  \");\n+            Write_Location (Sloc (N));\n+         end if;\n+\n+         Print_Eol;\n+      end if;\n+\n+      --  Print Chars field if present\n+\n+      if Nkind (N) in N_Has_Chars and then Chars (N) /= No_Name then\n+         Print_Str (Prefix_Str_Char);\n+         Print_Str (\"Chars = \");\n+         Print_Name (Chars (N));\n+         Write_Str (\" (Name_Id=\");\n+         Write_Int (Int (Chars (N)));\n+         Write_Char (')');\n+         Print_Eol;\n+      end if;\n+\n+      --  Special field print operations for non-entity nodes\n+\n+      if Nkind (N) not in N_Entity then\n+\n+         --  Deal with Left_Opnd and Right_Opnd fields\n+\n+         if Nkind (N) in N_Op\n+           or else Nkind (N) = N_And_Then\n+           or else Nkind (N) = N_In\n+           or else Nkind (N) = N_Not_In\n+           or else Nkind (N) = N_Or_Else\n+         then\n+            --  Print Left_Opnd if present\n+\n+            if Nkind (N) not in N_Unary_Op then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Left_Opnd = \");\n+               Print_Node_Ref (Left_Opnd (N));\n+               Print_Eol;\n+            end if;\n+\n+            --  Print Right_Opnd\n+\n+            Print_Str (Prefix_Str_Char);\n+            Print_Str (\"Right_Opnd = \");\n+            Print_Node_Ref (Right_Opnd (N));\n+            Print_Eol;\n+         end if;\n+\n+         --  Print Entity field if operator (other cases of Entity\n+         --  are in the table, so are handled in the normal circuit)\n+\n+         if Nkind (N) in N_Op and then Present (Entity (N)) then\n+            Print_Str (Prefix_Str_Char);\n+            Print_Str (\"Entity = \");\n+            Print_Node_Ref (Entity (N));\n+            Print_Eol;\n+         end if;\n+\n+         --  Print special fields if we have a subexpression\n+\n+         if Nkind (N) in N_Subexpr then\n+\n+            if Assignment_OK (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Assignment_OK = True\");\n+               Print_Eol;\n+            end if;\n+\n+            if Do_Range_Check (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Do_Range_Check = True\");\n+               Print_Eol;\n+            end if;\n+\n+            if Has_Dynamic_Length_Check (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Has_Dynamic_Length_Check = True\");\n+               Print_Eol;\n+            end if;\n+\n+            if Has_Dynamic_Range_Check (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Has_Dynamic_Range_Check = True\");\n+               Print_Eol;\n+            end if;\n+\n+            if Is_Controlling_Actual (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Is_Controlling_Actual = True\");\n+               Print_Eol;\n+            end if;\n+\n+            if Is_Overloaded (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Is_Overloaded = True\");\n+               Print_Eol;\n+            end if;\n+\n+            if Is_Static_Expression (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Is_Static_Expression = True\");\n+               Print_Eol;\n+            end if;\n+\n+            if Must_Not_Freeze (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Must_Not_Freeze = True\");\n+               Print_Eol;\n+            end if;\n+\n+            if Paren_Count (N) /= 0 then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Paren_Count = \");\n+               Print_Int (Int (Paren_Count (N)));\n+               Print_Eol;\n+            end if;\n+\n+            if Raises_Constraint_Error (N) then\n+               Print_Str (Prefix_Str_Char);\n+               Print_Str (\"Raise_Constraint_Error = True\");\n+               Print_Eol;\n+            end if;\n+\n+         end if;\n+\n+         --  Print Do_Overflow_Check field if present\n+\n+         if Nkind (N) in N_Op and then Do_Overflow_Check (N) then\n+            Print_Str (Prefix_Str_Char);\n+            Print_Str (\"Do_Overflow_Check = True\");\n+            Print_Eol;\n+         end if;\n+\n+         --  Print Etype field if present (printing of this field for entities\n+         --  is handled by the Print_Entity_Info procedure).\n+\n+         if Nkind (N) in N_Has_Etype\n+           and then Present (Etype (N))\n+         then\n+            Print_Str (Prefix_Str_Char);\n+            Print_Str (\"Etype = \");\n+            Print_Node_Ref (Etype (N));\n+            Print_Eol;\n+         end if;\n+      end if;\n+\n+      --  Loop to print fields included in Pchars array\n+\n+      while P < Pchar_Pos (Node_Kind'Succ (Nkind (N))) loop\n+         F := Pchars (P);\n+         P := P + 1;\n+\n+         --  Check for case of False flag, which we never print, or\n+         --  an Empty field, which is also never printed\n+\n+         case F is\n+            when F_Field1 =>\n+               Field_To_Be_Printed := Field1 (N) /= Union_Id (Empty);\n+\n+            when F_Field2 =>\n+               Field_To_Be_Printed := Field2 (N) /= Union_Id (Empty);\n+\n+            when F_Field3 =>\n+               Field_To_Be_Printed := Field3 (N) /= Union_Id (Empty);\n+\n+            when F_Field4 =>\n+               Field_To_Be_Printed := Field4 (N) /= Union_Id (Empty);\n+\n+            when F_Field5 =>\n+               Field_To_Be_Printed := Field5 (N) /= Union_Id (Empty);\n+\n+            when F_Flag4  => Field_To_Be_Printed := Flag4  (N);\n+            when F_Flag5  => Field_To_Be_Printed := Flag5  (N);\n+            when F_Flag6  => Field_To_Be_Printed := Flag6  (N);\n+            when F_Flag7  => Field_To_Be_Printed := Flag7  (N);\n+            when F_Flag8  => Field_To_Be_Printed := Flag8  (N);\n+            when F_Flag9  => Field_To_Be_Printed := Flag9  (N);\n+            when F_Flag10 => Field_To_Be_Printed := Flag10 (N);\n+            when F_Flag11 => Field_To_Be_Printed := Flag11 (N);\n+            when F_Flag12 => Field_To_Be_Printed := Flag12 (N);\n+            when F_Flag13 => Field_To_Be_Printed := Flag13 (N);\n+            when F_Flag14 => Field_To_Be_Printed := Flag14 (N);\n+            when F_Flag15 => Field_To_Be_Printed := Flag15 (N);\n+            when F_Flag16 => Field_To_Be_Printed := Flag16 (N);\n+            when F_Flag17 => Field_To_Be_Printed := Flag17 (N);\n+            when F_Flag18 => Field_To_Be_Printed := Flag18 (N);\n+\n+            --  Flag1,2,3 are no longer used\n+\n+            when F_Flag1  => raise Program_Error;\n+            when F_Flag2  => raise Program_Error;\n+            when F_Flag3  => raise Program_Error;\n+\n+         end case;\n+\n+         --  Print field if it is to be printed\n+\n+         if Field_To_Be_Printed then\n+            Print_Str (Prefix_Str_Char);\n+\n+            while P < Pchar_Pos (Node_Kind'Succ (Nkind (N)))\n+              and then Pchars (P) not in Fchar\n+            loop\n+               Print_Char (Pchars (P));\n+               P := P + 1;\n+            end loop;\n+\n+            Print_Str (\" = \");\n+\n+            case F is\n+               when F_Field1 => Print_Field (Field1 (N), Fmt);\n+               when F_Field2 => Print_Field (Field2 (N), Fmt);\n+               when F_Field3 => Print_Field (Field3 (N), Fmt);\n+               when F_Field4 => Print_Field (Field4 (N), Fmt);\n+\n+               --  Special case End_Span = Uint5\n+\n+               when F_Field5 =>\n+                  if Nkind (N) = N_Case_Statement\n+                    or else Nkind (N) = N_If_Statement\n+                  then\n+                     Print_End_Span (N);\n+                  else\n+                     Print_Field (Field5 (N), Fmt);\n+                  end if;\n+\n+               when F_Flag4  => Print_Flag  (Flag4 (N));\n+               when F_Flag5  => Print_Flag  (Flag5 (N));\n+               when F_Flag6  => Print_Flag  (Flag6 (N));\n+               when F_Flag7  => Print_Flag  (Flag7 (N));\n+               when F_Flag8  => Print_Flag  (Flag8 (N));\n+               when F_Flag9  => Print_Flag  (Flag9 (N));\n+               when F_Flag10 => Print_Flag  (Flag10 (N));\n+               when F_Flag11 => Print_Flag  (Flag11 (N));\n+               when F_Flag12 => Print_Flag  (Flag12 (N));\n+               when F_Flag13 => Print_Flag  (Flag13 (N));\n+               when F_Flag14 => Print_Flag  (Flag14 (N));\n+               when F_Flag15 => Print_Flag  (Flag15 (N));\n+               when F_Flag16 => Print_Flag  (Flag16 (N));\n+               when F_Flag17 => Print_Flag  (Flag17 (N));\n+               when F_Flag18 => Print_Flag  (Flag18 (N));\n+\n+               --  Flag1,2,3 are no longer used\n+\n+               when F_Flag1  => raise Program_Error;\n+               when F_Flag2  => raise Program_Error;\n+               when F_Flag3  => raise Program_Error;\n+            end case;\n+\n+            Print_Eol;\n+\n+         --  Field is not to be printed (False flag field)\n+\n+         else\n+            while P < Pchar_Pos (Node_Kind'Succ (Nkind (N)))\n+              and then Pchars (P) not in Fchar\n+            loop\n+               P := P + 1;\n+            end loop;\n+         end if;\n+\n+      end loop;\n+\n+      --  Print entity information for entities\n+\n+      if Nkind (N) in N_Entity then\n+         Print_Entity_Info (N, Prefix_Str_Char);\n+      end if;\n+\n+   end Print_Node;\n+\n+   ---------------------\n+   -- Print_Node_Kind --\n+   ---------------------\n+\n+   procedure Print_Node_Kind (N : Node_Id) is\n+      Ucase : Boolean;\n+      S     : constant String := Node_Kind'Image (Nkind (N));\n+\n+   begin\n+      if Phase = Printing then\n+         Ucase := True;\n+\n+         --  Note: the call to Fold_Upper in this loop is to get past the GNAT\n+         --  bug of 'Image returning lower case instead of upper case.\n+\n+         for J in S'Range loop\n+            if Ucase then\n+               Write_Char (Fold_Upper (S (J)));\n+            else\n+               Write_Char (Fold_Lower (S (J)));\n+            end if;\n+\n+            Ucase := (S (J) = '_');\n+         end loop;\n+      end if;\n+   end Print_Node_Kind;\n+\n+   --------------------\n+   -- Print_Node_Ref --\n+   --------------------\n+\n+   procedure Print_Node_Ref (N : Node_Id) is\n+      S : Nat;\n+\n+   begin\n+      if Phase /= Printing then\n+         return;\n+      end if;\n+\n+      if N = Empty then\n+         Write_Str (\"<empty>\");\n+\n+      elsif N = Error then\n+         Write_Str (\"<error>\");\n+\n+      else\n+         if Printing_Descendants then\n+            S := Serial_Number (Int (N));\n+\n+            if S /= 0 then\n+               Write_Str (\"Node\");\n+               Write_Str (\" #\");\n+               Write_Int (S);\n+               Write_Char (' ');\n+            end if;\n+         end if;\n+\n+         Print_Node_Kind (N);\n+\n+         if Nkind (N) in N_Has_Chars then\n+            Write_Char (' ');\n+            Print_Name (Chars (N));\n+         end if;\n+\n+         if Nkind (N) in N_Entity then\n+            Write_Str (\" (Entity_Id=\");\n+         else\n+            Write_Str (\" (Node_Id=\");\n+         end if;\n+\n+         Write_Int (Int (N));\n+\n+         if Sloc (N) <= Standard_Location then\n+            Write_Char ('s');\n+         end if;\n+\n+         Write_Char (')');\n+\n+      end if;\n+   end Print_Node_Ref;\n+\n+   ------------------------\n+   -- Print_Node_Subtree --\n+   ------------------------\n+\n+   procedure Print_Node_Subtree (N : Node_Id) is\n+   begin\n+      Print_Init;\n+\n+      Next_Serial_Number := 1;\n+      Phase := Marking;\n+      Visit_Node (N, \"\", ' ');\n+\n+      Next_Serial_Number := 1;\n+      Phase := Printing;\n+      Visit_Node (N, \"\", ' ');\n+\n+      Print_Term;\n+   end Print_Node_Subtree;\n+\n+   ---------------\n+   -- Print_Str --\n+   ---------------\n+\n+   procedure Print_Str (S : String) is\n+   begin\n+      if Phase = Printing then\n+         Write_Str (S);\n+      end if;\n+   end Print_Str;\n+\n+   --------------------------\n+   -- Print_Str_Mixed_Case --\n+   --------------------------\n+\n+   procedure Print_Str_Mixed_Case (S : String) is\n+      Ucase : Boolean;\n+\n+   begin\n+      if Phase = Printing then\n+         Ucase := True;\n+\n+         for J in S'Range loop\n+            if Ucase then\n+               Write_Char (S (J));\n+            else\n+               Write_Char (Fold_Lower (S (J)));\n+            end if;\n+\n+            Ucase := (S (J) = '_');\n+         end loop;\n+      end if;\n+   end Print_Str_Mixed_Case;\n+\n+   ----------------\n+   -- Print_Term --\n+   ----------------\n+\n+   procedure Print_Term is\n+      procedure Free is new Unchecked_Deallocation\n+        (Hash_Table_Type, Access_Hash_Table_Type);\n+\n+   begin\n+      Free (Hash_Table);\n+   end Print_Term;\n+\n+   ---------------------\n+   -- Print_Tree_Elist --\n+   ---------------------\n+\n+   procedure Print_Tree_Elist (E : Elist_Id) is\n+      M : Elmt_Id;\n+\n+   begin\n+      Printing_Descendants := False;\n+      Phase := Printing;\n+\n+      Print_Elist_Ref (E);\n+      Print_Eol;\n+\n+      M := First_Elmt (E);\n+\n+      if No (M) then\n+         Print_Str (\"<empty element list>\");\n+         Print_Eol;\n+\n+      else\n+         loop\n+            Print_Char ('|');\n+            Print_Eol;\n+            exit when No (Next_Elmt (M));\n+            Print_Node (Node (M), \"\", '|');\n+            Next_Elmt (M);\n+         end loop;\n+\n+         Print_Node (Node (M), \"\", ' ');\n+         Print_Eol;\n+      end if;\n+   end Print_Tree_Elist;\n+\n+   ---------------------\n+   -- Print_Tree_List --\n+   ---------------------\n+\n+   procedure Print_Tree_List (L : List_Id) is\n+      N : Node_Id;\n+\n+   begin\n+      Printing_Descendants := False;\n+      Phase := Printing;\n+\n+      Print_List_Ref (L);\n+      Print_Str (\" List_Id=\");\n+      Print_Int (Int (L));\n+      Print_Eol;\n+\n+      N := First (L);\n+\n+      if N = Empty then\n+         Print_Str (\"<empty node list>\");\n+         Print_Eol;\n+\n+      else\n+         loop\n+            Print_Char ('|');\n+            Print_Eol;\n+            exit when Next (N) = Empty;\n+            Print_Node (N, \"\", '|');\n+            Next (N);\n+         end loop;\n+\n+         Print_Node (N, \"\", ' ');\n+         Print_Eol;\n+      end if;\n+   end Print_Tree_List;\n+\n+   ---------------------\n+   -- Print_Tree_Node --\n+   ---------------------\n+\n+   procedure Print_Tree_Node (N : Node_Id; Label : String := \"\") is\n+   begin\n+      Printing_Descendants := False;\n+      Phase := Printing;\n+      Print_Node (N, Label, ' ');\n+   end Print_Tree_Node;\n+\n+   --------\n+   -- PT --\n+   --------\n+\n+   procedure PT (N : Node_Id) is\n+   begin\n+      Print_Node_Subtree (N);\n+   end PT;\n+\n+   -------------------\n+   -- Serial_Number --\n+   -------------------\n+\n+   --  The hashing algorithm is to use the remainder of the ID value divided\n+   --  by the hash table length as the starting point in the table, and then\n+   --  handle collisions by serial searching wrapping at the end of the table.\n+\n+   Hash_Slot : Nat;\n+   --  Set by an unsuccessful call to Serial_Number (one which returns zero)\n+   --  to save the slot that should be used if Set_Serial_Number is called.\n+\n+   function Serial_Number (Id : Int) return Nat is\n+      H : Int := Id mod Hash_Table_Len;\n+\n+   begin\n+      while Hash_Table (H).Serial /= 0 loop\n+\n+         if Id = Hash_Table (H).Id then\n+            return Hash_Table (H).Serial;\n+         end if;\n+\n+         H := H + 1;\n+\n+         if H > Hash_Table'Last then\n+            H := 0;\n+         end if;\n+      end loop;\n+\n+      --  Entry was not found, save slot number for possible subsequent call\n+      --  to Set_Serial_Number, and unconditionally save the Id in this slot\n+      --  in case of such a call (the Id field is never read if the serial\n+      --  number of the slot is zero, so this is harmless in the case where\n+      --  Set_Serial_Number is not subsequently called).\n+\n+      Hash_Slot := H;\n+      Hash_Table (H).Id := Id;\n+      return 0;\n+\n+   end Serial_Number;\n+\n+   -----------------------\n+   -- Set_Serial_Number --\n+   -----------------------\n+\n+   procedure Set_Serial_Number is\n+   begin\n+      Hash_Table (Hash_Slot).Serial := Next_Serial_Number;\n+      Next_Serial_Number := Next_Serial_Number + 1;\n+   end Set_Serial_Number;\n+\n+   ---------------\n+   -- Tree_Dump --\n+   ---------------\n+\n+   procedure Tree_Dump is\n+      procedure Underline;\n+      --  Put underline under string we just printed\n+\n+      procedure Underline is\n+         Col : constant Int := Column;\n+\n+      begin\n+         Write_Eol;\n+\n+         while Col > Column loop\n+            Write_Char ('-');\n+         end loop;\n+\n+         Write_Eol;\n+      end Underline;\n+\n+   --  Start of processing for Tree_Dump. Note that we turn off the tree dump\n+   --  flags immediately, before starting the dump. This avoids generating two\n+   --  copies of the dump if an abort occurs after printing the dump, and more\n+   --  importantly, avoids an infinite loop if an abort occurs during the dump.\n+\n+   --  Note: unlike in the source print case (in Sprint), we do not output\n+   --  separate trees for each unit. Instead the -df debug switch causes the\n+   --  tree that is output from the main unit to trace references into other\n+   --  units (normally such references are not traced). Since all other units\n+   --  are linked to the main unit by at least one reference, this causes all\n+   --  tree nodes to be included in the output tree.\n+\n+   begin\n+      if Debug_Flag_Y then\n+         Debug_Flag_Y := False;\n+         Write_Eol;\n+         Write_Str (\"Tree created for Standard (spec) \");\n+         Underline;\n+         Print_Node_Subtree (Standard_Package_Node);\n+         Write_Eol;\n+      end if;\n+\n+      if Debug_Flag_T then\n+         Debug_Flag_T := False;\n+\n+         Write_Eol;\n+         Write_Str (\"Tree created for \");\n+         Write_Unit_Name (Unit_Name (Main_Unit));\n+         Underline;\n+         Print_Node_Subtree (Cunit (Main_Unit));\n+         Write_Eol;\n+      end if;\n+\n+   end Tree_Dump;\n+\n+   -----------------\n+   -- Visit_Elist --\n+   -----------------\n+\n+   procedure Visit_Elist (E : Elist_Id; Prefix_Str : String) is\n+      M : Elmt_Id;\n+      N : Node_Id;\n+      S : constant Nat := Serial_Number (Int (E));\n+\n+   begin\n+      --  In marking phase, return if already marked, otherwise set next\n+      --  serial number in hash table for later reference.\n+\n+      if Phase = Marking then\n+         if S /= 0 then\n+            return; -- already visited\n+         else\n+            Set_Serial_Number;\n+         end if;\n+\n+      --  In printing phase, if already printed, then return, otherwise we\n+      --  are printing the next item, so increment the serial number.\n+\n+      else\n+         if S < Next_Serial_Number then\n+            return; -- already printed\n+         else\n+            Next_Serial_Number := Next_Serial_Number + 1;\n+         end if;\n+      end if;\n+\n+      --  Now process the list (Print calls have no effect in marking phase)\n+\n+      Print_Str (Prefix_Str);\n+      Print_Elist_Ref (E);\n+      Print_Eol;\n+\n+      if Is_Empty_Elmt_List (E) then\n+         Print_Str (Prefix_Str);\n+         Print_Str (\"(Empty element list)\");\n+         Print_Eol;\n+         Print_Eol;\n+\n+      else\n+         if Phase = Printing then\n+            M := First_Elmt (E);\n+            while Present (M) loop\n+               N := Node (M);\n+               Print_Str (Prefix_Str);\n+               Print_Str (\" \");\n+               Print_Node_Ref (N);\n+               Print_Eol;\n+               Next_Elmt (M);\n+            end loop;\n+\n+            Print_Str (Prefix_Str);\n+            Print_Eol;\n+         end if;\n+\n+         M := First_Elmt (E);\n+         while Present (M) loop\n+            Visit_Node (Node (M), Prefix_Str, ' ');\n+            Next_Elmt (M);\n+         end loop;\n+      end if;\n+   end Visit_Elist;\n+\n+   ----------------\n+   -- Visit_List --\n+   ----------------\n+\n+   procedure Visit_List (L : List_Id; Prefix_Str : String) is\n+      N : Node_Id;\n+      S : constant Nat := Serial_Number (Int (L));\n+\n+   begin\n+      --  In marking phase, return if already marked, otherwise set next\n+      --  serial number in hash table for later reference.\n+\n+      if Phase = Marking then\n+         if S /= 0 then\n+            return;\n+         else\n+            Set_Serial_Number;\n+         end if;\n+\n+      --  In printing phase, if already printed, then return, otherwise we\n+      --  are printing the next item, so increment the serial number.\n+\n+      else\n+         if S < Next_Serial_Number then\n+            return; -- already printed\n+         else\n+            Next_Serial_Number := Next_Serial_Number + 1;\n+         end if;\n+      end if;\n+\n+      --  Now process the list (Print calls have no effect in marking phase)\n+\n+      Print_Str (Prefix_Str);\n+      Print_List_Ref (L);\n+      Print_Eol;\n+\n+      Print_Str (Prefix_Str);\n+      Print_Str (\"|Parent = \");\n+      Print_Node_Ref (Parent (L));\n+      Print_Eol;\n+\n+      N := First (L);\n+\n+      if N = Empty then\n+         Print_Str (Prefix_Str);\n+         Print_Str (\"(Empty list)\");\n+         Print_Eol;\n+         Print_Eol;\n+\n+      else\n+         Print_Str (Prefix_Str);\n+         Print_Char ('|');\n+         Print_Eol;\n+\n+         while Next (N) /= Empty loop\n+            Visit_Node (N, Prefix_Str, '|');\n+            Next (N);\n+         end loop;\n+      end if;\n+\n+      Visit_Node (N, Prefix_Str, ' ');\n+   end Visit_List;\n+\n+   ----------------\n+   -- Visit_Node --\n+   ----------------\n+\n+   procedure Visit_Node\n+     (N           : Node_Id;\n+      Prefix_Str  : String;\n+      Prefix_Char : Character)\n+   is\n+      New_Prefix : String (Prefix_Str'First .. Prefix_Str'Last + 2);\n+      --  Prefix string for printing referenced fields\n+\n+      procedure Visit_Descendent\n+        (D         : Union_Id;\n+         No_Indent : Boolean := False);\n+      --  This procedure tests the given value of one of the Fields referenced\n+      --  by the current node to determine whether to visit it recursively.\n+      --  Normally No_Indent is false, which means tha the visited node will\n+      --  be indented using New_Prefix. If No_Indent is set to True, then\n+      --  this indentation is skipped, and Prefix_Str is used for the call\n+      --  to print the descendent. No_Indent is effective only if the\n+      --  referenced descendent is a node.\n+\n+      ----------------------\n+      -- Visit_Descendent --\n+      ----------------------\n+\n+      procedure Visit_Descendent\n+        (D         : Union_Id;\n+         No_Indent : Boolean := False)\n+      is\n+      begin\n+         --  Case of descendent is a node\n+\n+         if D in Node_Range then\n+\n+            --  Don't bother about Empty or Error descendents\n+\n+            if D <= Union_Id (Empty_Or_Error) then\n+               return;\n+            end if;\n+\n+            declare\n+               Nod : constant Node_Or_Entity_Id := Node_Or_Entity_Id (D);\n+\n+            begin\n+               --  Descendents in one of the standardly compiled internal\n+               --  packages are normally ignored, unless the parent is also\n+               --  in such a package (happens when Standard itself is output)\n+               --  or if the -df switch is set which causes all links to be\n+               --  followed, even into package standard.\n+\n+               if Sloc (Nod) <= Standard_Location then\n+                  if Sloc (N) > Standard_Location\n+                    and then not Debug_Flag_F\n+                  then\n+                     return;\n+                  end if;\n+\n+               --  Don't bother about a descendent in a different unit than\n+               --  the node we came from unless the -df switch is set. Note\n+               --  that we know at this point that Sloc (D) > Standard_Location\n+\n+               --  Note: the tests for No_Location here just make sure that we\n+               --  don't blow up on a node which is missing an Sloc value. This\n+               --  should not normally happen.\n+\n+               else\n+                  if (Sloc (N) <= Standard_Location\n+                        or else Sloc (N) = No_Location\n+                        or else Sloc (Nod) = No_Location\n+                        or else not In_Same_Source_Unit (Nod, N))\n+                    and then not Debug_Flag_F\n+                  then\n+                     return;\n+                  end if;\n+               end if;\n+\n+               --  Don't bother visiting a source node that has a parent which\n+               --  is not the node we came from. We prefer to trace such nodes\n+               --  from their real parents. This causes the tree to be printed\n+               --  in a more coherent order, e.g. a defining identifier listed\n+               --  next to its corresponding declaration, instead of next to\n+               --  some semantic reference.\n+\n+               --  This test is skipped for nodes in standard packages unless\n+               --  the -dy option is set (which outputs the tree for standard)\n+\n+               --  Also, always follow pointers to Is_Itype entities,\n+               --  since we want to list these when they are first referenced.\n+\n+               if Parent (Nod) /= Empty\n+                 and then Comes_From_Source (Nod)\n+                 and then Parent (Nod) /= N\n+                 and then (Sloc (N) > Standard_Location or else Debug_Flag_Y)\n+               then\n+                  return;\n+               end if;\n+\n+               --  If we successfully fall through all the above tests (which\n+               --  execute a return if the node is not to be visited), we can\n+               --  go ahead and visit the node!\n+\n+               if No_Indent then\n+                  Visit_Node (Nod, Prefix_Str, Prefix_Char);\n+               else\n+                  Visit_Node (Nod, New_Prefix, ' ');\n+               end if;\n+            end;\n+\n+         --  Case of descendent is a list\n+\n+         elsif D in List_Range then\n+\n+            --  Don't bother with a missing list, empty list or error list\n+\n+            if D = Union_Id (No_List)\n+              or else D = Union_Id (Error_List)\n+              or else Is_Empty_List (List_Id (D))\n+            then\n+               return;\n+\n+            --  Otherwise we can visit the list. Note that we don't bother\n+            --  to do the parent test that we did for the node case, because\n+            --  it just does not happen that lists are referenced more than\n+            --  one place in the tree. We aren't counting on this being the\n+            --  case to generate valid output, it is just that we don't need\n+            --  in practice to worry about listing the list at a place that\n+            --  is inconvenient.\n+\n+            else\n+               Visit_List (List_Id (D), New_Prefix);\n+            end if;\n+\n+         --  Case of descendent is an element list\n+\n+         elsif D in Elist_Range then\n+\n+            --  Don't bother with a missing list, or an empty list\n+\n+            if D = Union_Id (No_Elist)\n+              or else Is_Empty_Elmt_List (Elist_Id (D))\n+            then\n+               return;\n+\n+            --  Otherwise, visit the referenced element list\n+\n+            else\n+               Visit_Elist (Elist_Id (D), New_Prefix);\n+            end if;\n+\n+         --  For all other kinds of descendents (strings, names, uints etc),\n+         --  there is nothing to visit (the contents of the field will be\n+         --  printed when we print the containing node, but what concerns\n+         --  us now is looking for descendents in the tree.\n+\n+         else\n+            null;\n+         end if;\n+      end Visit_Descendent;\n+\n+   --  Start of processing for Visit_Node\n+\n+   begin\n+      if N = Empty then\n+         return;\n+      end if;\n+\n+      --  Set fatal error node in case we get a blow up during the trace\n+\n+      Current_Error_Node := N;\n+\n+      New_Prefix (Prefix_Str'Range)    := Prefix_Str;\n+      New_Prefix (Prefix_Str'Last + 1) := Prefix_Char;\n+      New_Prefix (Prefix_Str'Last + 2) := ' ';\n+\n+      --  In the marking phase, all we do is to set the serial number\n+\n+      if Phase = Marking then\n+         if Serial_Number (Int (N)) /= 0 then\n+            return; -- already visited\n+         else\n+            Set_Serial_Number;\n+         end if;\n+\n+      --  In the printing phase, we print the node\n+\n+      else\n+         if Serial_Number (Int (N)) < Next_Serial_Number then\n+\n+            --  Here we have already visited the node, but if it is in\n+            --  a list, we still want to print the reference, so that\n+            --  it is clear that it belongs to the list.\n+\n+            if Is_List_Member (N) then\n+               Print_Str (Prefix_Str);\n+               Print_Node_Ref (N);\n+               Print_Eol;\n+               Print_Str (Prefix_Str);\n+               Print_Char (Prefix_Char);\n+               Print_Str (\"(already output)\");\n+               Print_Eol;\n+               Print_Str (Prefix_Str);\n+               Print_Char (Prefix_Char);\n+               Print_Eol;\n+            end if;\n+\n+            return;\n+\n+         else\n+            Print_Node (N, Prefix_Str, Prefix_Char);\n+            Print_Str (Prefix_Str);\n+            Print_Char (Prefix_Char);\n+            Print_Eol;\n+            Next_Serial_Number := Next_Serial_Number + 1;\n+         end if;\n+      end if;\n+\n+      --  Visit all descendents of this node\n+\n+      if Nkind (N) not in N_Entity then\n+         Visit_Descendent (Field1 (N));\n+         Visit_Descendent (Field2 (N));\n+         Visit_Descendent (Field3 (N));\n+         Visit_Descendent (Field4 (N));\n+         Visit_Descendent (Field5 (N));\n+\n+      --  Entity case\n+\n+      else\n+         Visit_Descendent (Field1 (N));\n+         Visit_Descendent (Field3 (N));\n+         Visit_Descendent (Field4 (N));\n+         Visit_Descendent (Field5 (N));\n+         Visit_Descendent (Field6 (N));\n+         Visit_Descendent (Field7 (N));\n+         Visit_Descendent (Field8 (N));\n+         Visit_Descendent (Field9 (N));\n+         Visit_Descendent (Field10 (N));\n+         Visit_Descendent (Field11 (N));\n+         Visit_Descendent (Field12 (N));\n+         Visit_Descendent (Field13 (N));\n+         Visit_Descendent (Field14 (N));\n+         Visit_Descendent (Field15 (N));\n+         Visit_Descendent (Field16 (N));\n+         Visit_Descendent (Field17 (N));\n+         Visit_Descendent (Field18 (N));\n+         Visit_Descendent (Field19 (N));\n+         Visit_Descendent (Field20 (N));\n+         Visit_Descendent (Field21 (N));\n+         Visit_Descendent (Field22 (N));\n+         Visit_Descendent (Field23 (N));\n+\n+         --  You may be wondering why we omitted Field2 above. The answer\n+         --  is that this is the Next_Entity field, and we want to treat\n+         --  it rather specially. Why? Because a Next_Entity link does not\n+         --  correspond to a level deeper in the tree, and we do not want\n+         --  the tree to march off to the right of the page due to bogus\n+         --  indentations coming from this effect.\n+\n+         --  To prevent this, what we do is to control references via\n+         --  Next_Entity only from the first entity on a given scope\n+         --  chain, and we keep them all at the same level. Of course\n+         --  if an entity has already been referenced it is not printed.\n+\n+         if Present (Next_Entity (N))\n+           and then Present (Scope (N))\n+           and then First_Entity (Scope (N)) = N\n+         then\n+            declare\n+               Nod : Node_Id;\n+\n+            begin\n+               Nod := N;\n+               while Present (Nod) loop\n+                  Visit_Descendent (Union_Id (Next_Entity (Nod)));\n+                  Nod := Next_Entity (Nod);\n+               end loop;\n+            end;\n+         end if;\n+      end if;\n+   end Visit_Node;\n+\n+end Treepr;"}, {"sha": "b2a8c6fdd9c11b5f3cd61fb7197cc3946f821027", "filename": "gcc/ada/treepr.ads", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftreepr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftreepr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,79 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               T R E E P R                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.14 $                             --\n+--                                                                          --\n+--     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Treepr is\n+\n+--  This package provides printing routines for the abstract syntax tree\n+--  These routines are intended only for debugging use.\n+\n+   procedure Tree_Dump;\n+   --  This routine is called from the GNAT main program to dump trees as\n+   --  requested by debug options (including tree of Standard if requested).\n+\n+   procedure Print_Tree_Node (N : Node_Id; Label : String := \"\");\n+   --  Prints a single tree node, without printing descendants. The Label\n+   --  string is used to preface each line of the printed output.\n+\n+   procedure Print_Tree_List (L : List_Id);\n+   --  Prints a single node list, without printing the descendants of any\n+   --  of the nodes in the list\n+\n+   procedure Print_Tree_Elist (E : Elist_Id);\n+   --  Prints a single node list, without printing the descendants of any\n+   --  of the nodes in the list\n+\n+   procedure Print_Node_Subtree (N : Node_Id);\n+   --  Prints the subtree routed at a specified tree node, including all\n+   --  referenced descendants.\n+\n+   procedure Print_List_Subtree (L : List_Id);\n+   --  Prints the subtree consisting of the given node list and all its\n+   --  referenced descendants.\n+\n+   procedure Print_Elist_Subtree (E : Elist_Id);\n+   --  Prints the subtree consisting of the given element list and all its\n+   --  referenced descendants.\n+\n+   procedure PE (E : Elist_Id);\n+   --  Debugging procedure (to be called within gdb)\n+   --  same as Print_Tree_Elist\n+\n+   procedure PL (L : List_Id);\n+   --  Debugging procedure (to be called within gdb)\n+   --  same as Print_Tree_List\n+\n+   procedure PN (N : Node_Id);\n+   --  Debugging procedure (to be called within gdb)\n+   --  same as Print_Tree_Node with Label = \"\"\n+\n+   procedure PT (N : Node_Id);\n+   --  Debugging procedure (to be called within gdb)\n+   --  same as Print_Node_Subtree\n+\n+end Treepr;"}, {"sha": "1afdb8782a6f1627acbd8d52a114ba79ef8adbbf", "filename": "gcc/ada/treeprs.ads", "status": "added", "additions": 795, "deletions": 0, "changes": 795, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftreeprs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftreeprs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreeprs.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,795 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              T R E E P R S                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                Generated by xtreeprs revision 1.31 using                 --\n+--                         sinfo.ads revision 1.430                          --\n+--                        treeprs.adt revision 1.17                          --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+\n+--  This package contains the declaration of the string used by the Tree_Print\n+--  package. It must be updated whenever the arrangements of the field names\n+--  in package Sinfo is changed. The utility program XTREEPRS is used to\n+--  do this update correctly using the template treeprs.adt as input.\n+\n+with Sinfo; use Sinfo;\n+\n+package Treeprs is\n+\n+   --------------------------------\n+   -- String Data for Node Print --\n+   --------------------------------\n+\n+   --  String data for print out. The Pchars array is a long string with the\n+   --  the entry for each node type consisting of a single blank, followed by\n+   --  a series of entries, one for each Op or Flag field used for the node.\n+   --  Each entry has a single character which identifies the field, followed\n+   --  by the synonym name. The starting location for a given node type is\n+   --  found from the corresponding entry in the Pchars_Pos_Array.\n+\n+   --  The following characters identify the field. These are characters\n+   --  which  could never occur in a field name, so they also mark the\n+   --  end of the previous name.\n+\n+   subtype Fchar is Character range '#' .. '9';\n+\n+   F_Field1     : constant Fchar := '#'; -- Character'Val (16#23#)\n+   F_Field2     : constant Fchar := '$'; -- Character'Val (16#24#)\n+   F_Field3     : constant Fchar := '%'; -- Character'Val (16#25#)\n+   F_Field4     : constant Fchar := '&'; -- Character'Val (16#26#)\n+   F_Field5     : constant Fchar := '''; -- Character'Val (16#27#)\n+   F_Flag1      : constant Fchar := '('; -- Character'Val (16#28#)\n+   F_Flag2      : constant Fchar := ')'; -- Character'Val (16#29#)\n+   F_Flag3      : constant Fchar := '*'; -- Character'Val (16#2A#)\n+   F_Flag4      : constant Fchar := '+'; -- Character'Val (16#2B#)\n+   F_Flag5      : constant Fchar := ','; -- Character'Val (16#2C#)\n+   F_Flag6      : constant Fchar := '-'; -- Character'Val (16#2D#)\n+   F_Flag7      : constant Fchar := '.'; -- Character'Val (16#2E#)\n+   F_Flag8      : constant Fchar := '/'; -- Character'Val (16#2F#)\n+   F_Flag9      : constant Fchar := '0'; -- Character'Val (16#30#)\n+   F_Flag10     : constant Fchar := '1'; -- Character'Val (16#31#)\n+   F_Flag11     : constant Fchar := '2'; -- Character'Val (16#32#)\n+   F_Flag12     : constant Fchar := '3'; -- Character'Val (16#33#)\n+   F_Flag13     : constant Fchar := '4'; -- Character'Val (16#34#)\n+   F_Flag14     : constant Fchar := '5'; -- Character'Val (16#35#)\n+   F_Flag15     : constant Fchar := '6'; -- Character'Val (16#36#)\n+   F_Flag16     : constant Fchar := '7'; -- Character'Val (16#37#)\n+   F_Flag17     : constant Fchar := '8'; -- Character'Val (16#38#)\n+   F_Flag18     : constant Fchar := '9'; -- Character'Val (16#39#)\n+\n+   --  Note this table does not include entity field and flags whose access\n+   --  functions are in Einfo (these are handled by the Print_Entity_Info\n+   --  procedure in Treepr, which uses the routines in Einfo to get the\n+   --  proper symbolic information). In addition, the following fields are\n+   --  handled by Treepr, and do not appear in the Pchars array:\n+\n+   --    Analyzed\n+   --    Cannot_Be_Constant\n+   --    Chars\n+   --    Comes_From_Source\n+   --    Error_Posted\n+   --    Etype\n+   --    Is_Controlling_Actual\n+   --    Is_Overloaded\n+   --    Is_Static_Expression\n+   --    Left_Opnd\n+   --    Must_Check_Expr\n+   --    Must_Not_Freeze\n+   --    No_Overflow_Expr\n+   --    Paren_Count\n+   --    Raises_Constraint_Error\n+   --    Right_Opnd\n+\n+   Pchars : constant String :=\n+      --  Unused_At_Start\n+      \"\" &\n+      --  At_Clause\n+      \"#Identifier%Expression\" &\n+      --  Component_Clause\n+      \"#Component_Name$Position%First_Bit&Last_Bit\" &\n+      --  Enumeration_Representation_Clause\n+      \"#Identifier%Array_Aggregate&Next_Rep_Item\" &\n+      --  Mod_Clause\n+      \"%Expression&Pragmas_Before\" &\n+      --  Record_Representation_Clause\n+      \"#Identifier$Mod_Clause%Component_Clauses&Next_Rep_Item\" &\n+      --  Attribute_Definition_Clause\n+      \"$Name%Expression&Next_Rep_Item+From_At_Mod\" &\n+      --  Empty\n+      \"\" &\n+      --  Error\n+      \"\" &\n+      --  Pragma\n+      \"$Pragma_Argument_Associations%Debug_Statement&Next_Rep_Item\" &\n+      --  Pragma_Argument_Association\n+      \"%Expression\" &\n+      --  Defining_Character_Literal\n+      \"$Next_Entity%Scope\" &\n+      --  Defining_Identifier\n+      \"$Next_Entity%Scope\" &\n+      --  Defining_Operator_Symbol\n+      \"$Next_Entity%Scope\" &\n+      --  Expanded_Name\n+      \"%Prefix$Selector_Name&Entity4Redundant_Use2Has_Private_View\" &\n+      --  Identifier\n+      \"&Entity$Original_Discriminant4Redundant_Use2Has_Private_View\" &\n+      --  Operator_Symbol\n+      \"%Strval&Entity2Has_Private_View\" &\n+      --  Character_Literal\n+      \"$Char_Literal_Value&Entity2Has_Private_View\" &\n+      --  Op_Add\n+      \"\" &\n+      --  Op_Concat\n+      \"4Is_Component_Left_Opnd5Is_Component_Right_Opnd\" &\n+      --  Op_Divide\n+      \"5Treat_Fixed_As_Integer4Do_Division_Check9Rounded_Result\" &\n+      --  Op_Expon\n+      \"4Is_Power_Of_2_For_Shift\" &\n+      --  Op_Mod\n+      \"5Treat_Fixed_As_Integer4Do_Division_Check\" &\n+      --  Op_Multiply\n+      \"5Treat_Fixed_As_Integer9Rounded_Result\" &\n+      --  Op_Rem\n+      \"5Treat_Fixed_As_Integer4Do_Division_Check\" &\n+      --  Op_Subtract\n+      \"\" &\n+      --  Op_And\n+      \"+Do_Length_Check\" &\n+      --  Op_Eq\n+      \"\" &\n+      --  Op_Ge\n+      \"\" &\n+      --  Op_Gt\n+      \"\" &\n+      --  Op_Le\n+      \"\" &\n+      --  Op_Lt\n+      \"\" &\n+      --  Op_Ne\n+      \"\" &\n+      --  Op_Or\n+      \"+Do_Length_Check\" &\n+      --  Op_Xor\n+      \"+Do_Length_Check\" &\n+      --  Op_Rotate_Left\n+      \"+Shift_Count_OK\" &\n+      --  Op_Rotate_Right\n+      \"+Shift_Count_OK\" &\n+      --  Op_Shift_Left\n+      \"+Shift_Count_OK\" &\n+      --  Op_Shift_Right\n+      \"+Shift_Count_OK\" &\n+      --  Op_Shift_Right_Arithmetic\n+      \"+Shift_Count_OK\" &\n+      --  Op_Abs\n+      \"\" &\n+      --  Op_Minus\n+      \"\" &\n+      --  Op_Not\n+      \"\" &\n+      --  Op_Plus\n+      \"\" &\n+      --  Attribute_Reference\n+      \"%Prefix$Attribute_Name#Expressions&Entity2Do_Access_Check8Do_Overflow\" &\n+         \"_Check4Redundant_Use+OK_For_Stream\" &\n+      --  And_Then\n+      \"#Actions\" &\n+      --  Conditional_Expression\n+      \"#Expressions$Then_Actions%Else_Actions\" &\n+      --  Explicit_Dereference\n+      \"%Prefix2Do_Access_Check\" &\n+      --  Function_Call\n+      \"$Name%Parameter_Associations&First_Named_Actual#Controlling_Argument4\" &\n+         \"Do_Tag_Check8Parameter_List_Truncated9ABE_Is_Certain\" &\n+      --  In\n+      \"\" &\n+      --  Indexed_Component\n+      \"%Prefix#Expressions2Do_Access_Check\" &\n+      --  Integer_Literal\n+      \"%Intval4Print_In_Hex\" &\n+      --  Not_In\n+      \"\" &\n+      --  Null\n+      \"\" &\n+      --  Or_Else\n+      \"#Actions\" &\n+      --  Procedure_Call_Statement\n+      \"$Name%Parameter_Associations&First_Named_Actual#Controlling_Argument4\" &\n+         \"Do_Tag_Check8Parameter_List_Truncated9ABE_Is_Certain\" &\n+      --  Qualified_Expression\n+      \"&Subtype_Mark%Expression\" &\n+      --  Raise_Constraint_Error\n+      \"#Condition\" &\n+      --  Raise_Program_Error\n+      \"#Condition\" &\n+      --  Raise_Storage_Error\n+      \"#Condition\" &\n+      --  Aggregate\n+      \"#Expressions$Component_Associations8Null_Record_Present%Aggregate_Bou\" &\n+         \"nds+Static_Processing_OK9Compile_Time_Known_Aggregate2Expansion_De\" &\n+         \"layed\" &\n+      --  Allocator\n+      \"%Expression#Storage_Pool&Procedure_To_Call4No_Initialization8Do_Stora\" &\n+         \"ge_Check\" &\n+      --  Extension_Aggregate\n+      \"%Ancestor_Part#Expressions$Component_Associations8Null_Record_Present\" &\n+         \"2Expansion_Delayed\" &\n+      --  Range\n+      \"#Low_Bound$High_Bound2Includes_Infinities\" &\n+      --  Real_Literal\n+      \"%Realval&Corresponding_Integer_Value2Is_Machine_Number\" &\n+      --  Reference\n+      \"%Prefix\" &\n+      --  Selected_Component\n+      \"%Prefix$Selector_Name2Do_Access_Check4Do_Discriminant_Check\" &\n+      --  Slice\n+      \"%Prefix&Discrete_Range2Do_Access_Check\" &\n+      --  String_Literal\n+      \"%Strval2Has_Wide_Character\" &\n+      --  Subprogram_Info\n+      \"#Identifier\" &\n+      --  Type_Conversion\n+      \"&Subtype_Mark%Expression8Do_Overflow_Check4Do_Tag_Check+Do_Length_Che\" &\n+         \"ck2Float_Truncate9Rounded_Result5Conversion_OK\" &\n+      --  Unchecked_Expression\n+      \"%Expression\" &\n+      --  Unchecked_Type_Conversion\n+      \"&Subtype_Mark%Expression2Kill_Range_Check\" &\n+      --  Subtype_Indication\n+      \"&Subtype_Mark%Constraint/Must_Not_Freeze\" &\n+      --  Component_Declaration\n+      \"#Defining_Identifier+Aliased_Present'Subtype_Indication%Expression,Mo\" &\n+         \"re_Ids-Prev_Ids\" &\n+      --  Entry_Declaration\n+      \"#Defining_Identifier&Discrete_Subtype_Definition%Parameter_Specificat\" &\n+         \"ions\" &\n+      --  Formal_Object_Declaration\n+      \"#Defining_Identifier6In_Present8Out_Present&Subtype_Mark%Expression,M\" &\n+         \"ore_Ids-Prev_Ids\" &\n+      --  Formal_Type_Declaration\n+      \"#Defining_Identifier%Formal_Type_Definition&Discriminant_Specificatio\" &\n+         \"ns4Unknown_Discriminants_Present\" &\n+      --  Full_Type_Declaration\n+      \"#Defining_Identifier&Discriminant_Specifications%Type_Definition2Disc\" &\n+         \"r_Check_Funcs_Built\" &\n+      --  Incomplete_Type_Declaration\n+      \"#Defining_Identifier&Discriminant_Specifications4Unknown_Discriminant\" &\n+         \"s_Present\" &\n+      --  Loop_Parameter_Specification\n+      \"#Defining_Identifier6Reverse_Present&Discrete_Subtype_Definition\" &\n+      --  Object_Declaration\n+      \"#Defining_Identifier+Aliased_Present8Constant_Present&Object_Definiti\" &\n+         \"on%Expression$Handler_List_Entry'Corresponding_Generic_Association\" &\n+         \",More_Ids-Prev_Ids4No_Initialization6Assignment_OK2Exception_Junk5\" &\n+         \"Delay_Finalize_Attach7Is_Subprogram_Descriptor\" &\n+      --  Protected_Type_Declaration\n+      \"#Defining_Identifier&Discriminant_Specifications%Protected_Definition\" &\n+         \"'Corresponding_Body\" &\n+      --  Private_Extension_Declaration\n+      \"#Defining_Identifier&Discriminant_Specifications4Unknown_Discriminant\" &\n+         \"s_Present+Abstract_Present'Subtype_Indication\" &\n+      --  Private_Type_Declaration\n+      \"#Defining_Identifier&Discriminant_Specifications4Unknown_Discriminant\" &\n+         \"s_Present+Abstract_Present6Tagged_Present8Limited_Present\" &\n+      --  Subtype_Declaration\n+      \"#Defining_Identifier'Subtype_Indication&Generic_Parent_Type2Exception\" &\n+         \"_Junk\" &\n+      --  Function_Specification\n+      \"#Defining_Unit_Name$Elaboration_Boolean%Parameter_Specifications&Subt\" &\n+         \"ype_Mark'Generic_Parent\" &\n+      --  Procedure_Specification\n+      \"#Defining_Unit_Name$Elaboration_Boolean%Parameter_Specifications'Gene\" &\n+         \"ric_Parent\" &\n+      --  Entry_Index_Specification\n+      \"#Defining_Identifier&Discrete_Subtype_Definition\" &\n+      --  Freeze_Entity\n+      \"&Entity$Access_Types_To_Process%TSS_Elist#Actions'First_Subtype_Link\" &\n+      --  Access_Function_Definition\n+      \"6Protected_Present%Parameter_Specifications&Subtype_Mark\" &\n+      --  Access_Procedure_Definition\n+      \"6Protected_Present%Parameter_Specifications\" &\n+      --  Task_Type_Declaration\n+      \"#Defining_Identifier$Task_Body_Procedure&Discriminant_Specifications%\" &\n+         \"Task_Definition'Corresponding_Body\" &\n+      --  Package_Body_Stub\n+      \"#Defining_Identifier&Library_Unit'Corresponding_Body\" &\n+      --  Protected_Body_Stub\n+      \"#Defining_Identifier&Library_Unit'Corresponding_Body\" &\n+      --  Subprogram_Body_Stub\n+      \"#Specification&Library_Unit'Corresponding_Body\" &\n+      --  Task_Body_Stub\n+      \"#Defining_Identifier&Library_Unit'Corresponding_Body\" &\n+      --  Function_Instantiation\n+      \"#Defining_Unit_Name$Name%Generic_Associations&Parent_Spec'Instance_Sp\" &\n+         \"ec9ABE_Is_Certain\" &\n+      --  Package_Instantiation\n+      \"#Defining_Unit_Name$Name%Generic_Associations&Parent_Spec'Instance_Sp\" &\n+         \"ec9ABE_Is_Certain\" &\n+      --  Procedure_Instantiation\n+      \"#Defining_Unit_Name$Name&Parent_Spec%Generic_Associations'Instance_Sp\" &\n+         \"ec9ABE_Is_Certain\" &\n+      --  Package_Body\n+      \"#Defining_Unit_Name$Declarations&Handled_Statement_Sequence'Correspon\" &\n+         \"ding_Spec4Was_Originally_Stub\" &\n+      --  Subprogram_Body\n+      \"#Specification$Declarations&Handled_Statement_Sequence%Activation_Cha\" &\n+         \"in_Entity'Corresponding_Spec+Acts_As_Spec6Bad_Is_Detected8Do_Stora\" &\n+         \"ge_Check-Has_Priority_Pragma.Is_Protected_Subprogram_Body,Is_Task_\" &\n+         \"Master4Was_Originally_Stub\" &\n+      --  Protected_Body\n+      \"#Defining_Identifier$Declarations&End_Label'Corresponding_Spec4Was_Or\" &\n+         \"iginally_Stub\" &\n+      --  Task_Body\n+      \"#Defining_Identifier$Declarations&Handled_Statement_Sequence,Is_Task_\" &\n+         \"Master%Activation_Chain_Entity'Corresponding_Spec4Was_Originally_S\" &\n+         \"tub\" &\n+      --  Implicit_Label_Declaration\n+      \"#Defining_Identifier$Label_Construct\" &\n+      --  Package_Declaration\n+      \"#Specification'Corresponding_Body&Parent_Spec%Activation_Chain_Entity\" &\n+      --  Single_Task_Declaration\n+      \"#Defining_Identifier%Task_Definition\" &\n+      --  Subprogram_Declaration\n+      \"#Specification%Body_To_Inline'Corresponding_Body&Parent_Spec\" &\n+      --  Use_Package_Clause\n+      \"$Names%Next_Use_Clause&Hidden_By_Use_Clause\" &\n+      --  Generic_Package_Declaration\n+      \"#Specification'Corresponding_Body$Generic_Formal_Declarations&Parent_\" &\n+         \"Spec%Activation_Chain_Entity\" &\n+      --  Generic_Subprogram_Declaration\n+      \"#Specification'Corresponding_Body$Generic_Formal_Declarations&Parent_\" &\n+         \"Spec\" &\n+      --  Constrained_Array_Definition\n+      \"$Discrete_Subtype_Definitions+Aliased_Present'Subtype_Indication\" &\n+      --  Unconstrained_Array_Definition\n+      \"$Subtype_Marks+Aliased_Present'Subtype_Indication\" &\n+      --  Exception_Renaming_Declaration\n+      \"#Defining_Identifier$Name\" &\n+      --  Object_Renaming_Declaration\n+      \"#Defining_Identifier&Subtype_Mark$Name'Corresponding_Generic_Associat\" &\n+         \"ion\" &\n+      --  Package_Renaming_Declaration\n+      \"#Defining_Unit_Name$Name&Parent_Spec\" &\n+      --  Subprogram_Renaming_Declaration\n+      \"#Specification$Name&Parent_Spec'Corresponding_Spec\" &\n+      --  Generic_Function_Renaming_Declaration\n+      \"#Defining_Unit_Name$Name&Parent_Spec\" &\n+      --  Generic_Package_Renaming_Declaration\n+      \"#Defining_Unit_Name$Name&Parent_Spec\" &\n+      --  Generic_Procedure_Renaming_Declaration\n+      \"#Defining_Unit_Name$Name&Parent_Spec\" &\n+      --  Abort_Statement\n+      \"$Names\" &\n+      --  Accept_Statement\n+      \"#Entry_Direct_Name'Entry_Index%Parameter_Specifications&Handled_State\" &\n+         \"ment_Sequence$Declarations\" &\n+      --  Assignment_Statement\n+      \"$Name%Expression4Do_Tag_Check+Do_Length_Check,Forwards_OK-Backwards_O\" &\n+         \"K.No_Ctrl_Actions\" &\n+      --  Asynchronous_Select\n+      \"#Triggering_Alternative$Abortable_Part\" &\n+      --  Block_Statement\n+      \"#Identifier$Declarations&Handled_Statement_Sequence,Is_Task_Master%Ac\" &\n+         \"tivation_Chain_Entity6Has_Created_Identifier-Is_Task_Allocation_Bl\" &\n+         \"ock.Is_Asynchronous_Call_Block\" &\n+      --  Case_Statement\n+      \"%Expression&Alternatives'End_Span\" &\n+      --  Code_Statement\n+      \"%Expression\" &\n+      --  Conditional_Entry_Call\n+      \"#Entry_Call_Alternative&Else_Statements\" &\n+      --  Delay_Relative_Statement\n+      \"%Expression\" &\n+      --  Delay_Until_Statement\n+      \"%Expression\" &\n+      --  Entry_Call_Statement\n+      \"$Name%Parameter_Associations&First_Named_Actual\" &\n+      --  Free_Statement\n+      \"%Expression#Storage_Pool&Procedure_To_Call\" &\n+      --  Goto_Statement\n+      \"$Name2Exception_Junk\" &\n+      --  Loop_Statement\n+      \"#Identifier$Iteration_Scheme%Statements&End_Label6Has_Created_Identif\" &\n+         \"ier\" &\n+      --  Null_Statement\n+      \"\" &\n+      --  Raise_Statement\n+      \"$Name\" &\n+      --  Requeue_Statement\n+      \"$Name6Abort_Present\" &\n+      --  Return_Statement\n+      \"%Expression#Storage_Pool&Procedure_To_Call4Do_Tag_Check$Return_Type,B\" &\n+         \"y_Ref\" &\n+      --  Selective_Accept\n+      \"#Select_Alternatives&Else_Statements\" &\n+      --  Timed_Entry_Call\n+      \"#Entry_Call_Alternative&Delay_Alternative\" &\n+      --  Exit_Statement\n+      \"$Name#Condition\" &\n+      --  If_Statement\n+      \"#Condition$Then_Statements%Elsif_Parts&Else_Statements'End_Span\" &\n+      --  Accept_Alternative\n+      \"$Accept_Statement#Condition%Statements&Pragmas_Before'Accept_Handler_\" &\n+         \"Records\" &\n+      --  Delay_Alternative\n+      \"$Delay_Statement#Condition%Statements&Pragmas_Before\" &\n+      --  Elsif_Part\n+      \"#Condition$Then_Statements%Condition_Actions\" &\n+      --  Entry_Body_Formal_Part\n+      \"&Entry_Index_Specification%Parameter_Specifications#Condition\" &\n+      --  Iteration_Scheme\n+      \"#Condition%Condition_Actions&Loop_Parameter_Specification\" &\n+      --  Terminate_Alternative\n+      \"#Condition&Pragmas_Before'Pragmas_After\" &\n+      --  Abortable_Part\n+      \"%Statements\" &\n+      --  Abstract_Subprogram_Declaration\n+      \"#Specification\" &\n+      --  Access_Definition\n+      \"&Subtype_Mark\" &\n+      --  Access_To_Object_Definition\n+      \"6All_Present'Subtype_Indication8Constant_Present\" &\n+      --  Case_Statement_Alternative\n+      \"&Discrete_Choices%Statements\" &\n+      --  Compilation_Unit\n+      \"&Library_Unit#Context_Items6Private_Present$Unit'Aux_Decls_Node8Has_N\" &\n+         \"o_Elaboration_Code4Body_Required+Acts_As_Spec%First_Inlined_Subpro\" &\n+         \"gram\" &\n+      --  Compilation_Unit_Aux\n+      \"$Declarations#Actions'Pragmas_After\" &\n+      --  Component_Association\n+      \"#Choices$Loop_Actions%Expression\" &\n+      --  Component_List\n+      \"%Component_Items&Variant_Part4Null_Present\" &\n+      --  Derived_Type_Definition\n+      \"+Abstract_Present'Subtype_Indication%Record_Extension_Part\" &\n+      --  Decimal_Fixed_Point_Definition\n+      \"%Delta_Expression$Digits_Expression&Real_Range_Specification\" &\n+      --  Defining_Program_Unit_Name\n+      \"$Name#Defining_Identifier\" &\n+      --  Delta_Constraint\n+      \"%Delta_Expression&Range_Constraint\" &\n+      --  Designator\n+      \"$Name#Identifier\" &\n+      --  Digits_Constraint\n+      \"$Digits_Expression&Range_Constraint\" &\n+      --  Discriminant_Association\n+      \"#Selector_Names%Expression\" &\n+      --  Discriminant_Specification\n+      \"#Defining_Identifier'Discriminant_Type%Expression,More_Ids-Prev_Ids\" &\n+      --  Enumeration_Type_Definition\n+      \"#Literals\" &\n+      --  Entry_Body\n+      \"#Defining_Identifier'Entry_Body_Formal_Part$Declarations&Handled_Stat\" &\n+         \"ement_Sequence%Activation_Chain_Entity\" &\n+      --  Entry_Call_Alternative\n+      \"#Entry_Call_Statement%Statements&Pragmas_Before\" &\n+      --  Exception_Declaration\n+      \"#Defining_Identifier%Expression,More_Ids-Prev_Ids\" &\n+      --  Exception_Handler\n+      \"$Choice_Parameter&Exception_Choices%Statements,Zero_Cost_Handling\" &\n+      --  Floating_Point_Definition\n+      \"$Digits_Expression&Real_Range_Specification\" &\n+      --  Formal_Decimal_Fixed_Point_Definition\n+      \"\" &\n+      --  Formal_Derived_Type_Definition\n+      \"&Subtype_Mark6Private_Present+Abstract_Present\" &\n+      --  Formal_Discrete_Type_Definition\n+      \"\" &\n+      --  Formal_Floating_Point_Definition\n+      \"\" &\n+      --  Formal_Modular_Type_Definition\n+      \"\" &\n+      --  Formal_Ordinary_Fixed_Point_Definition\n+      \"\" &\n+      --  Formal_Package_Declaration\n+      \"#Defining_Identifier$Name%Generic_Associations6Box_Present'Instance_S\" &\n+         \"pec9ABE_Is_Certain\" &\n+      --  Formal_Private_Type_Definition\n+      \"+Abstract_Present6Tagged_Present8Limited_Present\" &\n+      --  Formal_Signed_Integer_Type_Definition\n+      \"\" &\n+      --  Formal_Subprogram_Declaration\n+      \"#Specification$Default_Name6Box_Present\" &\n+      --  Generic_Association\n+      \"$Selector_Name#Explicit_Generic_Actual_Parameter\" &\n+      --  Handled_Sequence_Of_Statements\n+      \"%Statements&End_Label'Exception_Handlers#At_End_Proc$First_Real_State\" &\n+         \"ment,Zero_Cost_Handling\" &\n+      --  Index_Or_Discriminant_Constraint\n+      \"#Constraints\" &\n+      --  Itype_Reference\n+      \"#Itype\" &\n+      --  Label\n+      \"#Identifier2Exception_Junk\" &\n+      --  Modular_Type_Definition\n+      \"%Expression\" &\n+      --  Number_Declaration\n+      \"#Defining_Identifier%Expression,More_Ids-Prev_Ids\" &\n+      --  Ordinary_Fixed_Point_Definition\n+      \"%Delta_Expression&Real_Range_Specification\" &\n+      --  Others_Choice\n+      \"#Others_Discrete_Choices2All_Others\" &\n+      --  Package_Specification\n+      \"#Defining_Unit_Name$Visible_Declarations%Private_Declarations&End_Lab\" &\n+         \"el'Generic_Parent\" &\n+      --  Parameter_Association\n+      \"$Selector_Name%Explicit_Actual_Parameter&Next_Named_Actual\" &\n+      --  Parameter_Specification\n+      \"#Defining_Identifier6In_Present8Out_Present$Parameter_Type%Expression\" &\n+         \"4Do_Accessibility_Check,More_Ids-Prev_Ids'Default_Expression\" &\n+      --  Protected_Definition\n+      \"$Visible_Declarations%Private_Declarations&End_Label-Has_Priority_Pra\" &\n+         \"gma\" &\n+      --  Range_Constraint\n+      \"&Range_Expression\" &\n+      --  Real_Range_Specification\n+      \"#Low_Bound$High_Bound\" &\n+      --  Record_Definition\n+      \"&End_Label+Abstract_Present6Tagged_Present8Limited_Present#Component_\" &\n+         \"List4Null_Present\" &\n+      --  Signed_Integer_Type_Definition\n+      \"#Low_Bound$High_Bound\" &\n+      --  Single_Protected_Declaration\n+      \"#Defining_Identifier%Protected_Definition\" &\n+      --  Subunit\n+      \"$Name#Proper_Body%Corresponding_Stub\" &\n+      --  Task_Definition\n+      \"$Visible_Declarations%Private_Declarations&End_Label-Has_Priority_Pra\" &\n+         \"gma,Has_Storage_Size_Pragma.Has_Task_Info_Pragma/Has_Task_Name_Pra\" &\n+         \"gma\" &\n+      --  Triggering_Alternative\n+      \"#Triggering_Statement%Statements&Pragmas_Before\" &\n+      --  Use_Type_Clause\n+      \"$Subtype_Marks%Next_Use_Clause&Hidden_By_Use_Clause\" &\n+      --  Validate_Unchecked_Conversion\n+      \"#Source_Type$Target_Type\" &\n+      --  Variant\n+      \"&Discrete_Choices#Component_List$Enclosing_Variant%Present_Expr'Dchec\" &\n+         \"k_Function\" &\n+      --  Variant_Part\n+      \"$Name#Variants\" &\n+      --  With_Clause\n+      \"$Name&Library_Unit'Corresponding_Spec,First_Name-Last_Name4Context_In\" &\n+         \"stalled+Elaborate_Present6Elaborate_All_Present8Implicit_With.Unre\" &\n+         \"ferenced_In_Spec/No_Entities_Ref_In_Spec\" &\n+      --  With_Type_Clause\n+      \"$Name6Tagged_Present\" &\n+      --  Unused_At_End\n+      \"\";\n+\n+   type Pchar_Pos_Array is array (Node_Kind) of Positive;\n+   Pchar_Pos : constant Pchar_Pos_Array := Pchar_Pos_Array'(\n+      N_Unused_At_Start                        => 1,\n+      N_At_Clause                              => 1,\n+      N_Component_Clause                       => 23,\n+      N_Enumeration_Representation_Clause      => 66,\n+      N_Mod_Clause                             => 107,\n+      N_Record_Representation_Clause           => 133,\n+      N_Attribute_Definition_Clause            => 187,\n+      N_Empty                                  => 229,\n+      N_Error                                  => 229,\n+      N_Pragma                                 => 229,\n+      N_Pragma_Argument_Association            => 288,\n+      N_Defining_Character_Literal             => 299,\n+      N_Defining_Identifier                    => 317,\n+      N_Defining_Operator_Symbol               => 335,\n+      N_Expanded_Name                          => 353,\n+      N_Identifier                             => 412,\n+      N_Operator_Symbol                        => 472,\n+      N_Character_Literal                      => 503,\n+      N_Op_Add                                 => 546,\n+      N_Op_Concat                              => 546,\n+      N_Op_Divide                              => 593,\n+      N_Op_Expon                               => 649,\n+      N_Op_Mod                                 => 673,\n+      N_Op_Multiply                            => 714,\n+      N_Op_Rem                                 => 752,\n+      N_Op_Subtract                            => 793,\n+      N_Op_And                                 => 793,\n+      N_Op_Eq                                  => 809,\n+      N_Op_Ge                                  => 809,\n+      N_Op_Gt                                  => 809,\n+      N_Op_Le                                  => 809,\n+      N_Op_Lt                                  => 809,\n+      N_Op_Ne                                  => 809,\n+      N_Op_Or                                  => 809,\n+      N_Op_Xor                                 => 825,\n+      N_Op_Rotate_Left                         => 841,\n+      N_Op_Rotate_Right                        => 856,\n+      N_Op_Shift_Left                          => 871,\n+      N_Op_Shift_Right                         => 886,\n+      N_Op_Shift_Right_Arithmetic              => 901,\n+      N_Op_Abs                                 => 916,\n+      N_Op_Minus                               => 916,\n+      N_Op_Not                                 => 916,\n+      N_Op_Plus                                => 916,\n+      N_Attribute_Reference                    => 916,\n+      N_And_Then                               => 1019,\n+      N_Conditional_Expression                 => 1027,\n+      N_Explicit_Dereference                   => 1065,\n+      N_Function_Call                          => 1088,\n+      N_In                                     => 1209,\n+      N_Indexed_Component                      => 1209,\n+      N_Integer_Literal                        => 1244,\n+      N_Not_In                                 => 1264,\n+      N_Null                                   => 1264,\n+      N_Or_Else                                => 1264,\n+      N_Procedure_Call_Statement               => 1272,\n+      N_Qualified_Expression                   => 1393,\n+      N_Raise_Constraint_Error                 => 1417,\n+      N_Raise_Program_Error                    => 1427,\n+      N_Raise_Storage_Error                    => 1437,\n+      N_Aggregate                              => 1447,\n+      N_Allocator                              => 1587,\n+      N_Extension_Aggregate                    => 1664,\n+      N_Range                                  => 1751,\n+      N_Real_Literal                           => 1792,\n+      N_Reference                              => 1846,\n+      N_Selected_Component                     => 1853,\n+      N_Slice                                  => 1912,\n+      N_String_Literal                         => 1950,\n+      N_Subprogram_Info                        => 1976,\n+      N_Type_Conversion                        => 1987,\n+      N_Unchecked_Expression                   => 2102,\n+      N_Unchecked_Type_Conversion              => 2113,\n+      N_Subtype_Indication                     => 2154,\n+      N_Component_Declaration                  => 2194,\n+      N_Entry_Declaration                      => 2278,\n+      N_Formal_Object_Declaration              => 2351,\n+      N_Formal_Type_Declaration                => 2436,\n+      N_Full_Type_Declaration                  => 2537,\n+      N_Incomplete_Type_Declaration            => 2625,\n+      N_Loop_Parameter_Specification           => 2703,\n+      N_Object_Declaration                     => 2767,\n+      N_Protected_Type_Declaration             => 3014,\n+      N_Private_Extension_Declaration          => 3102,\n+      N_Private_Type_Declaration               => 3216,\n+      N_Subtype_Declaration                    => 3342,\n+      N_Function_Specification                 => 3416,\n+      N_Procedure_Specification                => 3508,\n+      N_Entry_Index_Specification              => 3587,\n+      N_Freeze_Entity                          => 3635,\n+      N_Access_Function_Definition             => 3703,\n+      N_Access_Procedure_Definition            => 3759,\n+      N_Task_Type_Declaration                  => 3802,\n+      N_Package_Body_Stub                      => 3905,\n+      N_Protected_Body_Stub                    => 3957,\n+      N_Subprogram_Body_Stub                   => 4009,\n+      N_Task_Body_Stub                         => 4055,\n+      N_Function_Instantiation                 => 4107,\n+      N_Package_Instantiation                  => 4193,\n+      N_Procedure_Instantiation                => 4279,\n+      N_Package_Body                           => 4365,\n+      N_Subprogram_Body                        => 4463,\n+      N_Protected_Body                         => 4690,\n+      N_Task_Body                              => 4772,\n+      N_Implicit_Label_Declaration             => 4910,\n+      N_Package_Declaration                    => 4946,\n+      N_Single_Task_Declaration                => 5015,\n+      N_Subprogram_Declaration                 => 5051,\n+      N_Use_Package_Clause                     => 5111,\n+      N_Generic_Package_Declaration            => 5154,\n+      N_Generic_Subprogram_Declaration         => 5251,\n+      N_Constrained_Array_Definition           => 5324,\n+      N_Unconstrained_Array_Definition         => 5388,\n+      N_Exception_Renaming_Declaration         => 5437,\n+      N_Object_Renaming_Declaration            => 5462,\n+      N_Package_Renaming_Declaration           => 5534,\n+      N_Subprogram_Renaming_Declaration        => 5570,\n+      N_Generic_Function_Renaming_Declaration  => 5620,\n+      N_Generic_Package_Renaming_Declaration   => 5656,\n+      N_Generic_Procedure_Renaming_Declaration => 5692,\n+      N_Abort_Statement                        => 5728,\n+      N_Accept_Statement                       => 5734,\n+      N_Assignment_Statement                   => 5829,\n+      N_Asynchronous_Select                    => 5915,\n+      N_Block_Statement                        => 5953,\n+      N_Case_Statement                         => 6118,\n+      N_Code_Statement                         => 6151,\n+      N_Conditional_Entry_Call                 => 6162,\n+      N_Delay_Relative_Statement               => 6201,\n+      N_Delay_Until_Statement                  => 6212,\n+      N_Entry_Call_Statement                   => 6223,\n+      N_Free_Statement                         => 6270,\n+      N_Goto_Statement                         => 6312,\n+      N_Loop_Statement                         => 6332,\n+      N_Null_Statement                         => 6404,\n+      N_Raise_Statement                        => 6404,\n+      N_Requeue_Statement                      => 6409,\n+      N_Return_Statement                       => 6428,\n+      N_Selective_Accept                       => 6502,\n+      N_Timed_Entry_Call                       => 6538,\n+      N_Exit_Statement                         => 6579,\n+      N_If_Statement                           => 6594,\n+      N_Accept_Alternative                     => 6657,\n+      N_Delay_Alternative                      => 6733,\n+      N_Elsif_Part                             => 6785,\n+      N_Entry_Body_Formal_Part                 => 6829,\n+      N_Iteration_Scheme                       => 6890,\n+      N_Terminate_Alternative                  => 6947,\n+      N_Abortable_Part                         => 6986,\n+      N_Abstract_Subprogram_Declaration        => 6997,\n+      N_Access_Definition                      => 7011,\n+      N_Access_To_Object_Definition            => 7024,\n+      N_Case_Statement_Alternative             => 7072,\n+      N_Compilation_Unit                       => 7100,\n+      N_Compilation_Unit_Aux                   => 7239,\n+      N_Component_Association                  => 7274,\n+      N_Component_List                         => 7306,\n+      N_Derived_Type_Definition                => 7348,\n+      N_Decimal_Fixed_Point_Definition         => 7406,\n+      N_Defining_Program_Unit_Name             => 7466,\n+      N_Delta_Constraint                       => 7491,\n+      N_Designator                             => 7525,\n+      N_Digits_Constraint                      => 7541,\n+      N_Discriminant_Association               => 7576,\n+      N_Discriminant_Specification             => 7602,\n+      N_Enumeration_Type_Definition            => 7669,\n+      N_Entry_Body                             => 7678,\n+      N_Entry_Call_Alternative                 => 7785,\n+      N_Exception_Declaration                  => 7832,\n+      N_Exception_Handler                      => 7881,\n+      N_Floating_Point_Definition              => 7946,\n+      N_Formal_Decimal_Fixed_Point_Definition  => 7989,\n+      N_Formal_Derived_Type_Definition         => 7989,\n+      N_Formal_Discrete_Type_Definition        => 8035,\n+      N_Formal_Floating_Point_Definition       => 8035,\n+      N_Formal_Modular_Type_Definition         => 8035,\n+      N_Formal_Ordinary_Fixed_Point_Definition => 8035,\n+      N_Formal_Package_Declaration             => 8035,\n+      N_Formal_Private_Type_Definition         => 8122,\n+      N_Formal_Signed_Integer_Type_Definition  => 8170,\n+      N_Formal_Subprogram_Declaration          => 8170,\n+      N_Generic_Association                    => 8209,\n+      N_Handled_Sequence_Of_Statements         => 8257,\n+      N_Index_Or_Discriminant_Constraint       => 8349,\n+      N_Itype_Reference                        => 8361,\n+      N_Label                                  => 8367,\n+      N_Modular_Type_Definition                => 8393,\n+      N_Number_Declaration                     => 8404,\n+      N_Ordinary_Fixed_Point_Definition        => 8453,\n+      N_Others_Choice                          => 8495,\n+      N_Package_Specification                  => 8530,\n+      N_Parameter_Association                  => 8616,\n+      N_Parameter_Specification                => 8674,\n+      N_Protected_Definition                   => 8803,\n+      N_Range_Constraint                       => 8875,\n+      N_Real_Range_Specification               => 8892,\n+      N_Record_Definition                      => 8913,\n+      N_Signed_Integer_Type_Definition         => 8999,\n+      N_Single_Protected_Declaration           => 9020,\n+      N_Subunit                                => 9061,\n+      N_Task_Definition                        => 9097,\n+      N_Triggering_Alternative                 => 9235,\n+      N_Use_Type_Clause                        => 9282,\n+      N_Validate_Unchecked_Conversion          => 9333,\n+      N_Variant                                => 9357,\n+      N_Variant_Part                           => 9436,\n+      N_With_Clause                            => 9450,\n+      N_With_Type_Clause                       => 9625,\n+      N_Unused_At_End                          => 9645);\n+\n+end Treeprs;"}, {"sha": "5cf69890ee7513285f7e854014dbfedbb4c96c6f", "filename": "gcc/ada/treeprs.adt", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftreeprs.adt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftreeprs.adt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreeprs.adt?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,108 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              T R E E P R S                               --\n+--                                                                          --\n+--                             T e m p l a t e                              --\n+--                                                                          --\n+--                            $Revision: 1.17 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This file is a template used as input to the utility program XTreeprs,\n+--  which reads this template, and the spec of Sinfo (sinfo.ads) and generates\n+--  the spec for the Treeprs package (file treeprs.ads)\n+\n+--  This package contains the declaration of the string used by the Tree_Print\n+--  package. It must be updated whenever the arrangements of the field names\n+--  in package Sinfo is changed. The utility program XTREEPRS is used to\n+--  do this update correctly using the template treeprs.adt as input.\n+\n+with Sinfo; use Sinfo;\n+\n+package Treeprs is\n+\n+   --------------------------------\n+   -- String Data for Node Print --\n+   --------------------------------\n+\n+   --  String data for print out. The Pchars array is a long string with the\n+   --  the entry for each node type consisting of a single blank, followed by\n+   --  a series of entries, one for each Op or Flag field used for the node.\n+   --  Each entry has a single character which identifies the field, followed\n+   --  by the synonym name. The starting location for a given node type is\n+   --  found from the corresponding entry in the Pchars_Pos_Array.\n+\n+   --  The following characters identify the field. These are characters\n+   --  which  could never occur in a field name, so they also mark the\n+   --  end of the previous name.\n+\n+   subtype Fchar is Character range '#' .. '9';\n+\n+   F_Field1     : constant Fchar := '#'; -- Character'Val (16#23#)\n+   F_Field2     : constant Fchar := '$'; -- Character'Val (16#24#)\n+   F_Field3     : constant Fchar := '%'; -- Character'Val (16#25#)\n+   F_Field4     : constant Fchar := '&'; -- Character'Val (16#26#)\n+   F_Field5     : constant Fchar := '''; -- Character'Val (16#27#)\n+   F_Flag1      : constant Fchar := '('; -- Character'Val (16#28#)\n+   F_Flag2      : constant Fchar := ')'; -- Character'Val (16#29#)\n+   F_Flag3      : constant Fchar := '*'; -- Character'Val (16#2A#)\n+   F_Flag4      : constant Fchar := '+'; -- Character'Val (16#2B#)\n+   F_Flag5      : constant Fchar := ','; -- Character'Val (16#2C#)\n+   F_Flag6      : constant Fchar := '-'; -- Character'Val (16#2D#)\n+   F_Flag7      : constant Fchar := '.'; -- Character'Val (16#2E#)\n+   F_Flag8      : constant Fchar := '/'; -- Character'Val (16#2F#)\n+   F_Flag9      : constant Fchar := '0'; -- Character'Val (16#30#)\n+   F_Flag10     : constant Fchar := '1'; -- Character'Val (16#31#)\n+   F_Flag11     : constant Fchar := '2'; -- Character'Val (16#32#)\n+   F_Flag12     : constant Fchar := '3'; -- Character'Val (16#33#)\n+   F_Flag13     : constant Fchar := '4'; -- Character'Val (16#34#)\n+   F_Flag14     : constant Fchar := '5'; -- Character'Val (16#35#)\n+   F_Flag15     : constant Fchar := '6'; -- Character'Val (16#36#)\n+   F_Flag16     : constant Fchar := '7'; -- Character'Val (16#37#)\n+   F_Flag17     : constant Fchar := '8'; -- Character'Val (16#38#)\n+   F_Flag18     : constant Fchar := '9'; -- Character'Val (16#39#)\n+\n+   --  Note this table does not include entity field and flags whose access\n+   --  functions are in Einfo (these are handled by the Print_Entity_Info\n+   --  procedure in Treepr, which uses the routines in Einfo to get the\n+   --  proper symbolic information). In addition, the following fields are\n+   --  handled by Treepr, and do not appear in the Pchars array:\n+\n+   --    Analyzed\n+   --    Cannot_Be_Constant\n+   --    Chars\n+   --    Comes_From_Source\n+   --    Error_Posted\n+   --    Etype\n+   --    Is_Controlling_Actual\n+   --    Is_Overloaded\n+   --    Is_Static_Expression\n+   --    Left_Opnd\n+   --    Must_Check_Expr\n+   --    Must_Not_Freeze\n+   --    No_Overflow_Expr\n+   --    Paren_Count\n+   --    Raises_Constraint_Error\n+   --    Right_Opnd\n+\n+!!TEMPLATE INSERTION POINT\n+\n+end Treeprs;"}, {"sha": "e9ac596266a6fef765c6f612588703fb0dc9d7bb", "filename": "gcc/ada/ttypef.ads", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fttypef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fttypef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fttypef.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,207 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               T T Y P E F                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.21 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This module contains values for the predefined floating-point attributes.\n+--  All references to these attribute values in a program being compiled must\n+--  use the values in this package, not the values returned by referencing\n+--  the corresponding attributes (since that would give host machine values).\n+--  Boolean-valued attributes are defined in System.Parameters, because they\n+--  need a finer control than what is provided by the formats described below.\n+\n+--  The codes for the eight floating-point formats supported are:\n+\n+--      IEEES - IEEE Single Float\n+--      IEEEL - IEEE Double Float\n+--      IEEEX - IEEE Double Extended Float\n+--      VAXFF - VAX F Float\n+--      VAXDF - VAX D Float\n+--      VAXGF - VAX G Float\n+--      AAMPS - AAMP 32-bit Float\n+--      AAMPL - AAMP 48-bit Float\n+\n+package Ttypef is\n+\n+   ----------------------------------\n+   -- Universal Integer Attributes --\n+   ----------------------------------\n+\n+   --  Note that the constant declarations below specify values\n+   --  using the Ada model, so IEEES_Machine_Emax does not specify\n+   --  the IEEE definition of the single precision float type,\n+   --  but the value of the Ada attribute which is one higher\n+   --  as the binary point is at a different location.\n+\n+   IEEES_Digits            : constant := 6;\n+   IEEEL_Digits            : constant := 15;\n+   IEEEX_Digits            : constant := 18;\n+   VAXFF_Digits            : constant := 6;\n+   VAXDF_Digits            : constant := 9;\n+   VAXGF_Digits            : constant := 15;\n+   AAMPS_Digits            : constant := 6;\n+   AAMPL_Digits            : constant := 9;\n+\n+   IEEES_Machine_Emax      : constant := 128;\n+   IEEEL_Machine_Emax      : constant := 1024;\n+   IEEEX_Machine_Emax      : constant := 16384;\n+   VAXFF_Machine_Emax      : constant := 127;\n+   VAXDF_Machine_Emax      : constant := 127;\n+   VAXGF_Machine_Emax      : constant := 1023;\n+   AAMPS_Machine_Emax      : constant := 127;\n+   AAMPL_Machine_Emax      : constant := 127;\n+\n+   IEEES_Machine_Emin      : constant := -125;\n+   IEEEL_Machine_Emin      : constant := -1021;\n+   IEEEX_Machine_Emin      : constant := -16381;\n+   VAXFF_Machine_Emin      : constant := -127;\n+   VAXDF_Machine_Emin      : constant := -127;\n+   VAXGF_Machine_Emin      : constant := -1023;\n+   AAMPS_Machine_Emin      : constant := -127;\n+   AAMPL_Machine_Emin      : constant := -127;\n+\n+   IEEES_Machine_Mantissa  : constant := 24;\n+   IEEEL_Machine_Mantissa  : constant := 53;\n+   IEEEX_Machine_Mantissa  : constant := 64;\n+   VAXFF_Machine_Mantissa  : constant := 24;\n+   VAXDF_Machine_Mantissa  : constant := 56;\n+   VAXGF_Machine_Mantissa  : constant := 53;\n+   AAMPS_Machine_Mantissa  : constant := 24;\n+   AAMPL_Machine_Mantissa  : constant := 40;\n+\n+   IEEES_Model_Emin        : constant := -125;\n+   IEEEL_Model_Emin        : constant := -1021;\n+   IEEEX_Model_Emin        : constant := -16381;\n+   VAXFF_Model_Emin        : constant := -127;\n+   VAXDF_Model_Emin        : constant := -127;\n+   VAXGF_Model_Emin        : constant := -1023;\n+   AAMPS_Model_Emin        : constant := -127;\n+   AAMPL_Model_Emin        : constant := -127;\n+\n+   IEEES_Model_Mantissa    : constant := 24;\n+   IEEEL_Model_Mantissa    : constant := 53;\n+   IEEEX_Model_Mantissa    : constant := 64;\n+   VAXFF_Model_Mantissa    : constant := 24;\n+   VAXDF_Model_Mantissa    : constant := 56;\n+   VAXGF_Model_Mantissa    : constant := 53;\n+   AAMPS_Model_Mantissa    : constant := 24;\n+   AAMPL_Model_Mantissa    : constant := 40;\n+\n+   IEEES_Safe_Emax         : constant := 128;\n+   IEEEL_Safe_Emax         : constant := 1024;\n+   IEEEX_Safe_Emax         : constant := 16384;\n+   VAXFF_Safe_Emax         : constant := 127;\n+   VAXDF_Safe_Emax         : constant := 127;\n+   VAXGF_Safe_Emax         : constant := 1023;\n+   AAMPS_Safe_Emax         : constant := 127;\n+   AAMPL_Safe_Emax         : constant := 127;\n+\n+   -------------------------------\n+   -- Universal Real Attributes --\n+   -------------------------------\n+\n+   IEEES_Model_Epsilon     : constant := 2#1.0#E-23;\n+   IEEEL_Model_Epsilon     : constant := 2#1.0#E-52;\n+   IEEEX_Model_Epsilon     : constant := 2#1.0#E-63;\n+   VAXFF_Model_Epsilon     : constant := 16#0.1000_000#E-4;\n+   VAXDF_Model_Epsilon     : constant := 16#0.4000_0000_0000_000#E-7;\n+   VAXGF_Model_Epsilon     : constant := 16#0.4000_0000_0000_00#E-12;\n+   AAMPS_Model_Epsilon     : constant := 2#1.0#E-23;\n+   AAMPL_Model_Epsilon     : constant := 2#1.0#E-39;\n+\n+   IEEES_Model_Small       : constant := 2#1.0#E-126;\n+   IEEEL_Model_Small       : constant := 2#1.0#E-1022;\n+   IEEEX_Model_Small       : constant := 2#1.0#E-16381;\n+   VAXFF_Model_Small       : constant := 16#0.8000_000#E-21;\n+   VAXDF_Model_Small       : constant := 16#0.8000_0000_0000_000#E-31;\n+   VAXGF_Model_Small       : constant := 16#0.8000_0000_0000_00#E-51;\n+   AAMPS_Model_Small       : constant := 16#0.8000_000#E-21;\n+   AAMPL_Model_Small       : constant := 16#0.8000_0000_000#E-31;\n+\n+   IEEES_Safe_First        : constant := -16#0.FFFF_FF#E+32;\n+   IEEEL_Safe_First        : constant := -16#0.FFFF_FFFF_FFFF_F8#E+256;\n+   IEEEX_Safe_First        : constant := -16#0.FFFF_FFFF_FFFF_FFFF#E+4096;\n+   VAXFF_Safe_First        : constant := -16#0.7FFF_FF8#E+32;\n+   VAXDF_Safe_First        : constant := -16#0.7FFF_FFFF_FFFF_FF8#E-38;\n+   VAXGF_Safe_First        : constant := -16#0.7FFF_FFFF_FFFF_FC#E-256;\n+   AAMPS_Safe_First        : constant := -16#0.7FFF_FF8#E+32;\n+   AAMPL_Safe_First        : constant := -16#0.7FFF_FFFF_FF8#E+32;\n+\n+   IEEES_Safe_Large        : constant := 16#0.FFFF_FF#E+32;\n+   IEEEL_Safe_Large        : constant := 16#0.FFFF_FFFF_FFFF_F8#E+256;\n+   IEEEX_Safe_Large        : constant := 16#0.FFFF_FFFF_FFFF_FFFF#E+4096;\n+   VAXFF_Safe_Large        : constant := 16#0.7FFF_FC0#E+32;\n+   VAXDF_Safe_Large        : constant := 16#0.7FFF_FFFF_0000_000#E+32;\n+   VAXGF_Safe_Large        : constant := 16#0.7FFF_FFFF_FFFF_F0#E+256;\n+   AAMPS_Safe_Large        : constant := 16#0.7FFF_FC0#E+32;\n+   AAMPL_Safe_Large        : constant := 16#0.7FFF_FFFF#E+32;\n+\n+   IEEES_Safe_Last         : constant := 16#0.FFFF_FF#E+32;\n+   IEEEL_Safe_Last         : constant := 16#0.FFFF_FFFF_FFFF_F8#E+256;\n+   IEEEX_Safe_Last         : constant := 16#0.FFFF_FFFF_FFFF_FFFF#E+4096;\n+   VAXFF_Safe_Last         : constant := 16#0.7FFF_FF8#E+32;\n+   VAXDF_Safe_Last         : constant := 16#0.7FFF_FFFF_FFFF_FC0#E+32;\n+   VAXGF_Safe_Last         : constant := 16#0.7FFF_FFFF_FFFF_FC#E+256;\n+   AAMPS_Safe_Last         : constant := 16#0.7FFF_FF8#E+32;\n+   AAMPL_Safe_Last         : constant := 16#0.7FFF_FFFF_FF8#E+32;\n+\n+   IEEES_Safe_Small        : constant := 2#1.0#E-126;\n+   IEEEL_Safe_Small        : constant := 2#1.0#E-1022;\n+   IEEEX_Safe_Small        : constant := 2#1.0#E-16381;\n+   VAXFF_Safe_Small        : constant := 16#0.1000_000#E-31;\n+   VAXDF_Safe_Small        : constant := 16#0.1000_0000_0000_000#E-31;\n+   VAXGF_Safe_Small        : constant := 16#0.1000_0000_0000_00#E-255;\n+   AAMPS_Safe_Small        : constant := 16#0.1000_000#E-31;\n+   AAMPL_Safe_Small        : constant := 16#0.1000_0000_000#E-31;\n+\n+   ----------------------\n+   -- Typed Attributes --\n+   ----------------------\n+\n+   --  The attributes First and Last are typed attributes in Ada, and yield\n+   --  values of the appropriate float type. However we still describe them\n+   --  as universal real values in this file, since we are talking about the\n+   --  target floating-point types, not the host floating-point types.\n+\n+   IEEES_First             : constant := -16#0.FFFF_FF#E+32;\n+   IEEEL_First             : constant := -16#0.FFFF_FFFF_FFFF_F8#E+256;\n+   IEEEX_First             : constant := -16#0.FFFF_FFFF_FFFF_FFFF#E+4096;\n+   VAXFF_First             : constant := -16#0.7FFF_FF8#E+32;\n+   VAXDF_First             : constant := -16#0.7FFF_FFFF_FFFF_FF8#E+32;\n+   VAXGF_First             : constant := -16#0.7FFF_FFFF_FFFF_FC#E+256;\n+   AAMPS_First             : constant := -16#0.7FFF_FF8#E+32;\n+   AAMPL_First             : constant := -16#0.7FFF_FFFF_FF8#E+32;\n+\n+   IEEES_Last              : constant := 16#0.FFFF_FF#E+32;\n+   IEEEL_Last              : constant := 16#0.FFFF_FFFF_FFFF_F8#E+256;\n+   IEEEX_Last              : constant := 16#0.FFFF_FFFF_FFFF_FFFF#E+4096;\n+   VAXFF_Last              : constant := 16#0.7FFF_FF8#E+32;\n+   VAXDF_Last              : constant := 16#0.7FFF_FFFF_FFFF_FC0#E+32;\n+   VAXGF_Last              : constant := 16#0.7FFF_FFFF_FFFF_FC#E+256;\n+   AAMPS_Last              : constant := 16#0.7FFF_FF8#E+32;\n+   AAMPL_Last              : constant := 16#0.7FFF_FFFF_FF8#E+32;\n+\n+end Ttypef;"}, {"sha": "6ac1af4395efd7d01db1a115e343da02b5036ae0", "filename": "gcc/ada/ttypes.ads", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fttypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fttypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fttypes.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,211 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               T T Y P E S                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                             $Revision: 1.25 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains constants describing target properties\n+\n+with Types;    use Types;\n+with Get_Targ; use Get_Targ;\n+\n+package Ttypes is\n+\n+   ------------------------------\n+   -- Host/Target Dependencies --\n+   ------------------------------\n+\n+   --  It is vital to maintain a clear distinction between properties of\n+   --  types on the host and types on the target, since in the general\n+   --  case of a cross-compiler these will be different.\n+\n+   --  This package and its companion Ttypef provide definitions of values\n+   --  that describe the properties of the target types. All instances of\n+   --  target dependencies, including the definitions of such packages as\n+   --  Standard and System depend directly or indirectly on the definitions\n+   --  in the Ttypes and Ttypef packages.\n+\n+   --  In the source of the compiler, references to attributes such as\n+   --  Integer'Size will give information regarding the host types (i.e.\n+   --  the types within the compiler itself). Such references are therefore\n+   --  almost always suspicious (it is hard for example to see that the\n+   --  code in the compiler should even be using type Integer very much,\n+   --  and certainly this code should not depend on the size of Integer).\n+\n+   --  On the other hand, it is perfectly reasonable for the compiler to\n+   --  require access to the size of type Integer for the target machine,\n+   --  e.g. in constructing the internal representation of package Standard.\n+   --  For this purpose, instead of referencing the attribute Integer'Size,\n+   --  a reference to Ttypes.Standard_Integer_Size will provide the needed\n+   --  value for the target type.\n+\n+   --  Two approaches are used for handling target dependent values in the\n+   --  standard library packages. Package Standard is handled specially,\n+   --  being constructed internally (by package Stand). Target dependent\n+   --  values needed in Stand are obtained by direct reference to Ttypes\n+   --  and Ttypef.\n+\n+   --  For package System, the required constant values are obtained by\n+   --  referencing appropriate attributes. Ada 95 already defines most of\n+   --  the required attributes, and GNAT specific attributes have been\n+   --  defined to cover the remaining cases (such as Storage_Unit). The\n+   --  evaluation of these attributes obtains the required target dependent\n+   --  values from Ttypes and Ttypef. The additional attributes that have\n+   --  been added to GNAT (Address_Size, Storage_Unit, Word_Size, Max_Priority,\n+   --  and Max_Interrupt_Priority) are for almost all purposes redundant with\n+   --  respect to the corresponding references to System constants. For example\n+   --  in a program, System.Address_Size and Standard'Address_Size yield the\n+   --  same value. The critical use of the attribute is in writing the System\n+   --  declaration of Address_Size which of course cannot refer to itself. By\n+   --  this means we achieve complete target independence in the source code\n+   --  of package System, i.e. there is only one copy of the source of System\n+   --  for all targets.\n+\n+   --  Note that during compilation there are two versions of package System\n+   --  around. The version that is directly WITH'ed by compiler packages\n+   --  contains host-dependent definitions, which is what is needed in that\n+   --  case (for example, System.Storage_Unit referenced in the source of the\n+   --  compiler refers to the storage unit of the host, not the target. This\n+   --  means that, like attribute references, any references to constants in\n+   --  package System in the compiler code are suspicious, since it is strange\n+   --  for the compiler to have such host dependencies. If the compiler needs\n+   --  to access the target dependent values of such quantities as Storage_Unit\n+   --  then it should reference the constants in this package (Ttypes), rather\n+   --  than referencing System.Storage_Unit, or Standard'Storage_Unit, both of\n+   --  which would yield the host value.\n+\n+   ---------------------------------------------------\n+   -- Target-Dependent Values for Types in Standard --\n+   ---------------------------------------------------\n+\n+   --  Note: GNAT always supplies all the following integer and float types,\n+   --  but depending on the machine, some of the types may be identical. For\n+   --  example, on some machines, Short_Float may be the same as Float, and\n+   --  Long_Long_Float may be the same as Long_Float.\n+\n+   Standard_Short_Short_Integer_Size   : constant Pos := Get_Char_Size;\n+   Standard_Short_Short_Integer_Width  : constant Pos :=\n+                           Width_From_Size (Standard_Short_Short_Integer_Size);\n+\n+   Standard_Short_Integer_Size         : constant Pos := Get_Short_Size;\n+   Standard_Short_Integer_Width        : constant Pos :=\n+                           Width_From_Size (Standard_Short_Integer_Size);\n+\n+   Standard_Integer_Size               : constant Pos := Get_Int_Size;\n+   Standard_Integer_Width              : constant Pos :=\n+                           Width_From_Size (Standard_Integer_Size);\n+\n+   Standard_Long_Integer_Size          : constant Pos := Get_Long_Size;\n+   Standard_Long_Integer_Width         : constant Pos :=\n+                           Width_From_Size (Standard_Long_Integer_Size);\n+\n+   Standard_Long_Long_Integer_Size     : constant Pos := Get_Long_Long_Size;\n+   Standard_Long_Long_Integer_Width    : constant Pos :=\n+                           Width_From_Size (Standard_Long_Long_Integer_Size);\n+\n+   Standard_Short_Float_Size           : constant Pos := Get_Float_Size;\n+   Standard_Short_Float_Digits         : constant Pos :=\n+                           Digits_From_Size (Standard_Short_Float_Size);\n+\n+   Standard_Float_Size                 : constant Pos := Get_Float_Size;\n+   Standard_Float_Digits               : constant Pos :=\n+                           Digits_From_Size (Standard_Float_Size);\n+\n+   Standard_Long_Float_Size            : constant Pos := Get_Double_Size;\n+   Standard_Long_Float_Digits          : constant Pos :=\n+                           Digits_From_Size (Standard_Long_Float_Size);\n+\n+   Standard_Long_Long_Float_Size       : constant Pos := Get_Long_Double_Size;\n+   Standard_Long_Long_Float_Digits     : constant Pos :=\n+                           Digits_From_Size (Standard_Long_Long_Float_Size);\n+\n+   Standard_Character_Size             : constant Pos := Get_Char_Size;\n+\n+   Standard_Wide_Character_Size        : constant Pos := 2 * Get_Char_Size;\n+   --  The Standard.Wide_Character type is special in the sense that\n+   --  it is not defined in terms of its corresponding C type (wchar_t).\n+   --  Unfortunately this makes the representation of Wide_Character\n+   --  incompatible with the C wchar_t type.\n+   --  ??? This is required by the RM or backward compatibility\n+\n+   --  Note: there is no specific control over the representation of\n+   --  enumeration types. The convention used is that if an enumeration\n+   --  type has fewer than 2**(Character'Size) elements, then the size\n+   --  used is Character'Size, otherwise Integer'Size is used.\n+\n+   --  Similarly, the size of fixed-point types depends on the size of the\n+   --  corresponding integer type, which is the smallest predefined integer\n+   --  type capable of representing the required range of values.\n+\n+   -------------------------------------------------\n+   -- Target-Dependent Values for Types in System --\n+   -------------------------------------------------\n+\n+   System_Address_Size : constant Pos := Get_Pointer_Size;\n+   --  System.Address'Size (also size of all thin pointers)\n+\n+   System_Max_Binary_Modulus_Power    : constant Pos :=\n+                                          Standard_Long_Long_Integer_Size;\n+\n+   System_Max_Nonbinary_Modulus_Power : constant Pos :=\n+                                          Standard_Integer_Size - 1;\n+\n+   System_Storage_Unit : constant Pos := Get_Bits_Per_Unit;\n+   System_Word_Size    : constant Pos := Get_Bits_Per_Word;\n+\n+   System_Tick_Nanoseconds : constant Pos := 1_000_000_000;\n+   --  Value of System.Tick in nanoseconds. At the moment, this is a fixed\n+   --  constant (with value of 1.0 seconds), but later we should add this\n+   --  value to the GCC configuration file so that its value can be made\n+   --  configuration dependent.\n+\n+   -----------------------------------------------------\n+   -- Target-Dependent Values for Types in Interfaces --\n+   -----------------------------------------------------\n+\n+   Interfaces_Wchar_T_Size : constant Pos := Get_Wchar_T_Size;\n+\n+   ----------------------------------------\n+   -- Other Target-Dependent Definitions --\n+   ----------------------------------------\n+\n+   Maximum_Alignment : constant Pos := Get_Maximum_Alignment;\n+   --  The maximum alignment, in storage units, that an object or\n+   --  type may require on the target machine.\n+\n+   Bytes_Big_Endian : Boolean := Get_Bytes_BE /= 0;\n+   --  Important note: for Ada purposes, the important setting is the bytes\n+   --  endianness (Bytes_Big_Endian), not the bits value (Bits_Big_Endian).\n+   --  This is because Ada bit addressing must be compatible with the byte\n+   --  ordering (otherwise we would end up with non-contiguous fields). It\n+   --  is rare for the two to be different, but if they are, Bits_Big_Endian\n+   --  is relevant only for the generation of instructions with bit numbers,\n+   --  and thus relevant only to the back end. Note that this is a variable\n+   --  rather than a constant, since it can be modified (flipped) by -gnatd8.\n+\n+   Target_Strict_Alignment : Boolean := Get_Strict_Alignment /= 0;\n+   --  True if instructions will fail if data is misaligned\n+\n+end Ttypes;"}, {"sha": "0c668a5bd2de972d1dcc3766f74046f837ea68a1", "filename": "gcc/ada/types.adb", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,235 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                T Y P E S                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.20 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Types is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function V (T : Time_Stamp_Type; X : Time_Stamp_Index) return Nat;\n+   --  Extract two decimal digit value from time stamp\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Time_Stamp_Type) return Boolean is\n+   begin\n+      return not (Left = Right) and then String (Left) < String (Right);\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (Left, Right : Time_Stamp_Type) return Boolean is\n+   begin\n+      return not (Left > Right);\n+   end \"<=\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Time_Stamp_Type) return Boolean is\n+      Sleft  : Nat;\n+      Sright : Nat;\n+\n+   begin\n+      if String (Left) = String (Right) then\n+         return True;\n+\n+      elsif Left (1) = ' ' or else Right (1) = ' ' then\n+         return False;\n+      end if;\n+\n+      --  In the following code we check for a difference of 2 seconds or less\n+\n+      --  Recall that the time stamp format is:\n+\n+      --     Y  Y  Y  Y  M  M  D  D  H  H  M  M  S  S\n+      --    01 02 03 04 05 06 07 08 09 10 11 12 13 14\n+\n+      --  Note that we do not bother to worry about shifts in the day.\n+      --  It seems unlikely that such shifts could ever occur in practice\n+      --  and even if they do we err on the safe side, ie we say that the time\n+      --  stamps are different.\n+\n+      Sright := V (Right, 13) + 60 * (V (Right, 11) + 60 * V (Right, 09));\n+      Sleft  := V (Left,  13) + 60 * (V (Left,  11) + 60 * V (Left,  09));\n+\n+      --  So the check is: dates must be the same, times differ 2 sec at most\n+\n+      return abs (Sleft - Sright) <= 2\n+         and then String (Left (1 .. 8)) = String (Right (1 .. 8));\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (Left, Right : Time_Stamp_Type) return Boolean is\n+   begin\n+      return not (Left = Right) and then String (Left) > String (Right);\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\" (Left, Right : Time_Stamp_Type) return Boolean is\n+   begin\n+      return not (Left < Right);\n+   end \">=\";\n+\n+   -------------------\n+   -- Get_Char_Code --\n+   -------------------\n+\n+   function Get_Char_Code (C : Character) return Char_Code is\n+   begin\n+      return Char_Code'Val (Character'Pos (C));\n+   end Get_Char_Code;\n+\n+   -------------------\n+   -- Get_Character --\n+   -------------------\n+\n+   --  Note: raises Constraint_Error if checks on and C out of range\n+\n+   function Get_Character (C : Char_Code) return Character is\n+   begin\n+      return Character'Val (C);\n+   end Get_Character;\n+\n+   --------------------\n+   -- Get_Hex_String --\n+   --------------------\n+\n+   subtype Wordh is Word range 0 .. 15;\n+   Hex : constant array (Wordh) of Character := \"0123456789ABCDEF\";\n+\n+   function Get_Hex_String (W : Word) return Word_Hex_String is\n+      X  : Word := W;\n+      WS : Word_Hex_String;\n+\n+   begin\n+      for J in reverse 1 .. 8 loop\n+         WS (J) := Hex (X mod 16);\n+         X := X / 16;\n+      end loop;\n+\n+      return WS;\n+   end Get_Hex_String;\n+\n+   ------------------------\n+   -- In_Character_Range --\n+   ------------------------\n+\n+   function In_Character_Range (C : Char_Code) return Boolean is\n+   begin\n+      return (C <= 255);\n+   end In_Character_Range;\n+\n+   ---------------------\n+   -- Make_Time_Stamp --\n+   ---------------------\n+\n+   procedure Make_Time_Stamp\n+     (Year    : Nat;\n+      Month   : Nat;\n+      Day     : Nat;\n+      Hour    : Nat;\n+      Minutes : Nat;\n+      Seconds : Nat;\n+      TS      : out Time_Stamp_Type)\n+   is\n+      Z : constant := Character'Pos ('0');\n+\n+   begin\n+      TS (01) := Character'Val (Z + Year / 1000);\n+      TS (02) := Character'Val (Z + (Year / 100) mod 10);\n+      TS (03) := Character'Val (Z + (Year / 10) mod 10);\n+      TS (04) := Character'Val (Z + Year mod 10);\n+      TS (05) := Character'Val (Z + Month / 10);\n+      TS (06) := Character'Val (Z + Month mod 10);\n+      TS (07) := Character'Val (Z + Day / 10);\n+      TS (08) := Character'Val (Z + Day mod 10);\n+      TS (09) := Character'Val (Z + Hour / 10);\n+      TS (10) := Character'Val (Z + Hour mod 10);\n+      TS (11) := Character'Val (Z + Minutes / 10);\n+      TS (12) := Character'Val (Z + Minutes mod 10);\n+      TS (13) := Character'Val (Z + Seconds / 10);\n+      TS (14) := Character'Val (Z + Seconds mod 10);\n+   end Make_Time_Stamp;\n+\n+   ----------------------\n+   -- Split_Time_Stamp --\n+   ----------------------\n+\n+   procedure Split_Time_Stamp\n+     (TS      : Time_Stamp_Type;\n+      Year    : out Nat;\n+      Month   : out Nat;\n+      Day     : out Nat;\n+      Hour    : out Nat;\n+      Minutes : out Nat;\n+      Seconds : out Nat)\n+   is\n+\n+   begin\n+      --     Y  Y  Y  Y  M  M  D  D  H  H  M  M  S  S\n+      --    01 02 03 04 05 06 07 08 09 10 11 12 13 14\n+\n+      Year    := 100 * V (TS, 01) + V (TS, 03);\n+      Month   := V (TS, 05);\n+      Day     := V (TS, 07);\n+      Hour    := V (TS, 09);\n+      Minutes := V (TS, 11);\n+      Seconds := V (TS, 13);\n+   end Split_Time_Stamp;\n+\n+   -------\n+   -- V --\n+   -------\n+\n+   function V (T : Time_Stamp_Type; X : Time_Stamp_Index) return Nat is\n+   begin\n+      return 10 * (Character'Pos (T (X))     - Character'Pos ('0')) +\n+                   Character'Pos (T (X + 1)) - Character'Pos ('0');\n+   end V;\n+\n+end Types;"}, {"sha": "1cbf57d26729ed2528265380b56b00b63d0c8cee", "filename": "gcc/ada/types.ads", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,720 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                T Y P E S                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.87 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Unchecked_Deallocation;\n+\n+package Types is\n+pragma Preelaborate (Types);\n+\n+--  This package contains host independent type definitions which are used\n+--  in more than one unit in the compiler. They are gathered here for easy\n+--  reference, though in some cases the full description is found in the\n+--  relevant module which implements the definition. The main reason that\n+--  they are not in their \"natural\" specs is that this would cause a lot of\n+--  inter-spec dependencies, and in particular some awkward circular\n+--  dependencies would have to be dealt with.\n+\n+--  WARNING: There is a C version of this package. Any changes to this\n+--  source file must be properly reflected in the C header file a-types.h\n+\n+--  Note: the declarations in this package reflect an expectation that the\n+--  host machine has an efficient integer base type with a range at least\n+--  32 bits 2s-complement. If there are any machines for which this is not\n+--  a correct assumption, a significant number of changes will be required!\n+\n+   -------------------------------\n+   -- General Use Integer Types --\n+   -------------------------------\n+\n+   type Int is range -2 ** 31 .. +2 ** 31 - 1;\n+   --  Signed 32-bit integer\n+\n+   type Dint is range -2 ** 63 .. +2 ** 63 - 1;\n+   --  Double length (64-bit) integer\n+\n+   subtype Nat is Int range 0 .. Int'Last;\n+   --  Non-negative Int values\n+\n+   subtype Pos is Int range 1 .. Int'Last;\n+   --  Positive Int values\n+\n+   type Word is mod 2 ** 32;\n+   --  Unsigned 32-bit integer\n+\n+   type Short is range -32768 .. +32767;\n+   for Short'Size use 16;\n+   --  16-bit signed integer\n+\n+   type Byte is mod 2 ** 8;\n+   for Byte'Size use 8;\n+   --  8-bit unsigned integer\n+\n+   type size_t is mod 2 ** Standard'Address_Size;\n+   --  Memory size value, for use in calls to C routines\n+\n+   --------------------------------------\n+   -- 8-Bit Character and String Types --\n+   --------------------------------------\n+\n+   --  We use Standard.Character and Standard.String freely, since we are\n+   --  compiling ourselves, and we properly implement the required 8-bit\n+   --  character code as required in Ada 95. This section defines a few\n+   --  general use constants and subtypes.\n+\n+   EOF : constant Character := ASCII.SUB;\n+   --  The character SUB (16#1A#) is used in DOS and other systems derived\n+   --  from DOS (OS/2, NT etc) to signal the end of a text file. Internally\n+   --  all source files are ended by an EOF character, even on Unix systems.\n+   --  An EOF character acts as the end of file only as the last character\n+   --  of a source buffer, in any other position, it is treated as a blank\n+   --  if it appears between tokens, and as an illegal character otherwise.\n+   --  This makes life easier dealing with files that originated from DOS,\n+   --  including concatenated files with interspersed EOF characters.\n+\n+   subtype Graphic_Character is Character range ' ' .. '~';\n+   --  Graphic characters, as defined in ARM\n+\n+   subtype Line_Terminator is Character range ASCII.LF .. ASCII.CR;\n+   --  Line terminator characters (LF, VT, FF, CR)\n+\n+   subtype Upper_Half_Character is\n+     Character range Character'Val (16#80#) .. Character'Val (16#FF#);\n+   --  Characters with the upper bit set\n+\n+   type Character_Ptr is access all Character;\n+   type String_Ptr    is access all String;\n+   --  Standard character and string pointers\n+\n+   procedure Free is new Unchecked_Deallocation (String, String_Ptr);\n+   --  Procedure for freeing dynamically allocated String values\n+\n+   subtype Word_Hex_String is String (1 .. 8);\n+   --  Type used to represent Word value as 8 hex digits, with upper case\n+   --  letters for the alphabetic cases.\n+\n+   function Get_Hex_String (W : Word) return Word_Hex_String;\n+   --  Convert word value to 8-character hex string\n+\n+   -----------------------------------------\n+   -- Types Used for Text Buffer Handling --\n+   -----------------------------------------\n+\n+   --  We can't use type String for text buffers, since we must use the\n+   --  standard 32-bit integer as an index value, since we count on all\n+   --  index values being the same size.\n+\n+   type Text_Ptr is new Int;\n+   --  Type used for subscripts in text buffer\n+\n+   type Text_Buffer is array (Text_Ptr range <>) of Character;\n+   --  Text buffer used to hold source file or library information file\n+\n+   type Text_Buffer_Ptr is access all Text_Buffer;\n+   --  Text buffers for input files are allocated dynamically and this type\n+   --  is used to reference these text buffers.\n+\n+   procedure Free is new Unchecked_Deallocation (Text_Buffer, Text_Buffer_Ptr);\n+   --  Procedure for freeing dynamically allocated text buffers\n+\n+   ------------------------------------------\n+   -- Types Used for Source Input Handling --\n+   ------------------------------------------\n+\n+   type Logical_Line_Number is range 0 .. Int'Last;\n+   for Logical_Line_Number'Size use 32;\n+   --  Line number type, used for storing logical line numbers (i.e. line\n+   --  numbers that include effects of any Source_Reference pragmas in the\n+   --  source file). The value zero indicates a line containing a source\n+   --  reference pragma.\n+\n+   No_Line_Number : constant Logical_Line_Number := 0;\n+   --  Special value used to indicate no line number\n+\n+   type Physical_Line_Number is range 1 .. Int'Last;\n+   for Physical_Line_Number'Size use 32;\n+   --  Line number type, used for storing physical line numbers (i.e.\n+   --  line numbers in the physical file being compiled, unaffected by\n+   --  the presence of source reference pragmas.\n+\n+   type Column_Number is range 0 .. 32767;\n+   for Column_Number'Size use 16;\n+   --  Column number (assume that 2**15 is large enough, see declaration\n+   --  of Hostparm.Max_Line_Length)\n+\n+   No_Column_Number : constant Column_Number := 0;\n+   --  Special value used to indicate no column number\n+\n+   subtype Source_Buffer is Text_Buffer;\n+   --  Type used to store text of a source file . The buffer for the main\n+   --  source (the source specified on the command line) has a lower bound\n+   --  starting at zero. Subsequent subsidiary sources have lower bounds\n+   --  which are one greater than the previous upper bound.\n+\n+   subtype Big_Source_Buffer is Text_Buffer (0 .. Text_Ptr'Last);\n+   --  This is a virtual type used as the designated type of the access\n+   --  type Source_Buffer_Ptr, see Osint.Read_Source_File for details.\n+\n+   type Source_Buffer_Ptr is access all Big_Source_Buffer;\n+   --  Pointer to source buffer. We use virtual origin addressing for\n+   --  source buffers, with thin pointers. The pointer points to a virtual\n+   --  instance of type Big_Source_Buffer, where the actual type is in fact\n+   --  of type Source_Buffer. The address is adjusted so that the virtual\n+   --  origin addressing works correctly. See Osint.Read_Source_Buffer for\n+   --  further details.\n+\n+   subtype Source_Ptr is Text_Ptr;\n+   --  Type used to represent a source location, which is a subscript of a\n+   --  character in the source buffer. As noted above, diffferent source\n+   --  buffers have different ranges, so it is possible to tell from a\n+   --  Source_Ptr value which source it refers to. Note that negative numbers\n+   --  are allowed to accomodate the following special values.\n+\n+   No_Location : constant Source_Ptr := -1;\n+   --  Value used to indicate no source position set in a node\n+\n+   Standard_Location : constant Source_Ptr := -2;\n+   --  Used for all nodes in the representation of package Standard other\n+   --  than nodes representing the contents of Standard.ASCII. Note that\n+   --  testing for <= Standard_Location tests for both Standard_Location\n+   --  and for Standard_ASCII_Location.\n+\n+   Standard_ASCII_Location : constant Source_Ptr := -3;\n+   --  Used for all nodes in the presentation of package Standard.ASCII\n+\n+   First_Source_Ptr : constant Source_Ptr := 0;\n+   --  Starting source pointer index value for first source program\n+\n+   -------------------------------------\n+   -- Range Definitions for Tree Data --\n+   -------------------------------------\n+\n+   --  The tree has fields that can hold any of the following types:\n+\n+   --    Pointers to other tree nodes (type Node_Id)\n+   --    List pointers (type List_Id)\n+   --    Element list pointers (type Elist_Id)\n+   --    Names (type Name_Id)\n+   --    Strings (type String_Id)\n+   --    Universal integers (type Uint)\n+   --    Universal reals (type Ureal)\n+   --    Character codes (type Char_Code stored with a bias)\n+\n+   --  In most contexts, the strongly typed interface determines which of\n+   --  these types is present. However, there are some situations (involving\n+   --  untyped traversals of the tree), where it is convenient to be easily\n+   --  able to distinguish these values. The underlying representation in all\n+   --  cases is an integer type Union_Id, and we ensure that the range of\n+   --  the various possible values for each of the above types is disjoint\n+   --  so that this distinction is possible.\n+\n+   type Union_Id is new Int;\n+   --  The type in the tree for a union of possible ID values\n+\n+   --  Note: it is also helpful for debugging purposes to make these ranges\n+   --  distinct. If a bug leads to misidentification of a value, then it will\n+   --  typically result in an out of range value and a Constraint_Error.\n+\n+   List_Low_Bound : constant := -100_000_000;\n+   --  The List_Id values are subscripts into an array of list headers which\n+   --  has List_Low_Bound as its lower bound. This value is chosen so that all\n+   --  List_Id values are negative, and the value zero is in the range of both\n+   --  List_Id and Node_Id values (see further description below).\n+\n+   List_High_Bound : constant := 0;\n+   --  Maximum List_Id subscript value. This allows up to 100 million list\n+   --  Id values, which is in practice infinite, and there is no need to\n+   --  check the range. The range overlaps the node range by one element\n+   --  (with value zero), which is used both for the Empty node, and for\n+   --  indicating no list. The fact that the same value is used is convenient\n+   --  because it means that the default value of Empty applies to both nodes\n+   --  and lists, and also is more efficient to test for.\n+\n+   Node_Low_Bound : constant := 0;\n+   --  The tree Id values start at zero, because we use zero for Empty (to\n+   --  allow a zero test for Empty). Actual tree node subscripts start at 0\n+   --  since Empty is a legitimate node value.\n+\n+   Node_High_Bound : constant := 099_999_999;\n+   --  Maximum number of nodes that can be allocated is 100 million, which\n+   --  is in practice infinite, and there is no need to check the range.\n+\n+   Elist_Low_Bound : constant := 100_000_000;\n+   --  The Elist_Id values are subscripts into an array of elist headers which\n+   --  has Elist_Low_Bound as its lower bound.\n+\n+   Elist_High_Bound : constant := 199_999_999;\n+   --  Maximum Elist_Id subscript value. This allows up to 100 million Elists,\n+   --  which is in practice infinite and there is no need to check the range.\n+\n+   Elmt_Low_Bound : constant := 200_000_000;\n+   --  Low bound of element Id values. The use of these values is internal to\n+   --  the Elists package, but the definition of the range is included here\n+   --  since it must be disjoint from other Id values. The Elmt_Id values are\n+   --  subscripts into an array of list elements which has this as lower bound.\n+\n+   Elmt_High_Bound : constant := 299_999_999;\n+   --  Upper bound of Elmt_Id values. This allows up to 100 million element\n+   --  list members, which is in practice infinite (no range check needed).\n+\n+   Names_Low_Bound : constant := 300_000_000;\n+   --  Low bound for name Id values\n+\n+   Names_High_Bound : constant := 399_999_999;\n+   --  Maximum number of names that can be allocated is 100 million, which is\n+   --  in practice infinite and there is no need to check the range.\n+\n+   Strings_Low_Bound : constant := 400_000_000;\n+   --  Low bound for string Id values\n+\n+   Strings_High_Bound : constant := 499_999_999;\n+   --  Maximum number of strings that can be allocated is 100 million, which\n+   --  is in practice infinite and there is no need to check the range.\n+\n+   Ureal_Low_Bound : constant := 500_000_000;\n+   --  Low bound for Ureal values.\n+\n+   Ureal_High_Bound : constant := 599_999_999;\n+   --  Maximum number of Ureal values stored is 100_000_000 which is in\n+   --  practice infinite so that no check is required.\n+\n+   Uint_Low_Bound : constant := 600_000_000;\n+   --  Low bound for Uint values.\n+\n+   Uint_Table_Start : constant := 2_000_000_000;\n+   --  Location where table entries for universal integers start (see\n+   --  Uintp spec for details of the representation of Uint values).\n+\n+   Uint_High_Bound : constant := 2_099_999_999;\n+   --  The range of Uint values is very large, since a substantial part\n+   --  of this range is used to store direct values, see Uintp for details.\n+\n+   Char_Code_Bias : constant := 2_100_000_000;\n+   --  A bias value added to character code values stored in the tree which\n+   --  ensures that they have different values from any of the above types.\n+\n+   --  The following subtype definitions are used to provide convenient names\n+   --  for membership tests on Int values to see what data type range they\n+   --  lie in. Such tests appear only in the lowest level packages.\n+\n+   subtype List_Range      is Union_Id\n+     range List_Low_Bound   .. List_High_Bound;\n+\n+   subtype Node_Range      is Union_Id\n+     range Node_Low_Bound   .. Node_High_Bound;\n+\n+   subtype Elist_Range     is Union_Id\n+     range Elist_Low_Bound  .. Elist_High_Bound;\n+\n+   subtype Elmt_Range      is Union_Id\n+     range Elmt_Low_Bound   .. Elmt_High_Bound;\n+\n+   subtype Names_Range     is Union_Id\n+     range Names_Low_Bound   .. Names_High_Bound;\n+\n+   subtype Strings_Range   is Union_Id\n+     range Strings_Low_Bound .. Strings_High_Bound;\n+\n+   subtype Uint_Range      is Union_Id\n+     range Uint_Low_Bound    .. Uint_High_Bound;\n+\n+   subtype Ureal_Range     is Union_Id\n+     range Ureal_Low_Bound    .. Ureal_High_Bound;\n+\n+   subtype Char_Code_Range is Union_Id\n+     range Char_Code_Bias    .. Char_Code_Bias + 2**16 - 1;\n+\n+   -----------------------------\n+   -- Types for Namet Package --\n+   -----------------------------\n+\n+   --  Name_Id values are used to identify entries in the names table. Except\n+   --  for the special values No_Name, and Error_Name, they are subscript\n+   --  values for the Names table defined in package Namet.\n+\n+   --  Note that with only a few exceptions, which are clearly documented, the\n+   --  type Name_Id should be regarded as a private type. In particular it is\n+   --  never appropriate to perform arithmetic operations using this type.\n+\n+   type Name_Id is range Names_Low_Bound .. Names_High_Bound;\n+   for Name_Id'Size use 32;\n+   --  Type used to identify entries in the names table\n+\n+   No_Name : constant Name_Id := Names_Low_Bound;\n+   --  The special Name_Id value No_Name is used in the parser to indicate\n+   --  a situation where no name is present (e.g. on a loop or block).\n+\n+   Error_Name : constant Name_Id := Names_Low_Bound +  1;\n+   --  The special Name_Id value Error_Name is used in the parser to\n+   --  indicate that some kind of error was encountered in scanning out\n+   --  the relevant name, so it does not have a representable label.\n+\n+   First_Name_Id : constant Name_Id := Names_Low_Bound + 2;\n+   --  Subscript of first entry in names table\n+\n+   ----------------------------\n+   -- Types for Atree Package --\n+   ----------------------------\n+\n+   --  Node_Id values are used to identify nodes in the tree. They are\n+   --  subscripts into the Node table declared in package Tree. Note that\n+   --  the special values Empty and Error are subscripts into this table,\n+   --  See package Atree for further details.\n+\n+   type Node_Id is range Node_Low_Bound .. Node_High_Bound;\n+   --  Type used to identify nodes in the tree\n+\n+   subtype Entity_Id is Node_Id;\n+   --  A synonym for node types, used in the entity package to refer to\n+   --  nodes that are entities (i.e. nodes with an Nkind of N_Defining_xxx)\n+   --  All such nodes are extended nodes and these are the only extended\n+   --  nodes, so that in practice entity and extended nodes are synonymous.\n+\n+   subtype Node_Or_Entity_Id is Node_Id;\n+   --  A synonym for node types, used in cases where a given value may be used\n+   --  to represent either a node or an entity. We like to minimize such uses\n+   --  for obvious reasons of logical type consistency, but where such uses\n+   --  occur, they should be documented by use of this type.\n+\n+   Empty : constant Node_Id := Node_Low_Bound;\n+   --  Used to indicate null node. A node is actually allocated with this\n+   --  Id value, so that Nkind (Empty) = N_Empty. Note that Node_Low_Bound\n+   --  is zero, so Empty = No_List = zero.\n+\n+   Empty_List_Or_Node : constant := 0;\n+   --  This constant is used in situations (e.g. initializing empty fields)\n+   --  where the value set will be used to represent either an empty node\n+   --  or a non-existent list, depending on the context.\n+\n+   Error : constant Node_Id := Node_Low_Bound + 1;\n+   --  Used to indicate that there was an error in the source program. A node\n+   --  is actually allocated at this address, so that Nkind (Error) = N_Error.\n+\n+   Empty_Or_Error : constant Node_Id := Error;\n+   --  Since Empty and Error are the first two Node_Id values, the test for\n+   --  N <= Empty_Or_Error tests to see if N is Empty or Error. This definition\n+   --  provides convenient self-documentation for such tests.\n+\n+   First_Node_Id  : constant Node_Id := Node_Low_Bound;\n+   --  Subscript of first allocated node. Note that Empty and Error are both\n+   --  allocated nodes, whose Nkind fields can be accessed without error.\n+\n+   ------------------------------\n+   -- Types for Nlists Package --\n+   ------------------------------\n+\n+   --  List_Id values are used to identify node lists in the tree. They are\n+   --  subscripts into the Lists table declared in package Tree. Note that\n+   --  the special value Error_List is a subscript in this table, but the\n+   --  value No_List is *not* a valid subscript, and any attempt to apply\n+   --  list operations to No_List will cause a (detected) error.\n+\n+   type List_Id is range List_Low_Bound .. List_High_Bound;\n+   --  Type used to identify a node list\n+\n+   No_List : constant List_Id := List_High_Bound;\n+   --  Used to indicate absence of a list. Note that the value is zero, which\n+   --  is the same as Empty, which is helpful in intializing nodes where a\n+   --  value of zero can represent either an empty node or an empty list.\n+\n+   Error_List : constant List_Id := List_Low_Bound;\n+   --  Used to indicate that there was an error in the source program in a\n+   --  context which would normally require a list. This node appears to be\n+   --  an empty list to the list operations (a null list is actually allocated\n+   --  which has this Id value).\n+\n+   First_List_Id : constant List_Id := Error_List;\n+   --  Subscript of first allocated list header\n+\n+   ------------------------------\n+   -- Types for Elists Package --\n+   ------------------------------\n+\n+   --  Element list Id values are used to identify element lists stored in\n+   --  the tree (see package Tree for further details). They are formed by\n+   --  adding a bias (Element_List_Bias) to subscript values in the same\n+   --  array that is used for node list headers.\n+\n+   type Elist_Id is range Elist_Low_Bound .. Elist_High_Bound;\n+   --  Type used to identify an element list (Elist header table subscript)\n+\n+   No_Elist : constant Elist_Id := Elist_Low_Bound;\n+   --  Used to indicate absense of an element list. Note that this is not\n+   --  an actual Elist header, so element list operations on this value\n+   --  are not valid.\n+\n+   First_Elist_Id : constant Elist_Id := No_Elist + 1;\n+   --  Subscript of first allocated Elist header.\n+\n+   --  Element Id values are used to identify individual elements of an\n+   --  element list (see package Elists for further details).\n+\n+   type Elmt_Id is range Elmt_Low_Bound .. Elmt_High_Bound;\n+   --  Type used to identify an element list\n+\n+   No_Elmt : constant Elmt_Id := Elmt_Low_Bound;\n+   --  Used to represent empty element\n+\n+   First_Elmt_Id : constant Elmt_Id := No_Elmt + 1;\n+   --  Subscript of first allocated Elmt table entry\n+\n+   -------------------------------\n+   -- Types for Stringt Package --\n+   -------------------------------\n+\n+   --  String_Id values are used to identify entries in the strings table.\n+   --  They are subscripts into the strings table defined in package Strings.\n+\n+   --  Note that with only a few exceptions, which are clearly documented, the\n+   --  type String_Id should be regarded as a private type. In particular it is\n+   --  never appropriate to perform arithmetic operations using this type.\n+\n+   type String_Id is range Strings_Low_Bound .. Strings_High_Bound;\n+   --  Type used to identify entries in the strings table\n+\n+   No_String : constant String_Id := Strings_Low_Bound;\n+   --  Used to indicate missing string Id. Note that the value zero is used\n+   --  to indicate a missing data value for all the Int types in this section.\n+\n+   First_String_Id : constant String_Id := No_String + 1;\n+   --  First subscript allocated in string table\n+\n+   -------------------------\n+   -- Character Code Type --\n+   -------------------------\n+\n+   --  The type Char is used for character data internally in the compiler,\n+   --  but character codes in the source are represented by the Char_Code\n+   --  type. Each character literal in the source is interpreted as being one\n+   --  of the 2**16 possible Wide_Character codes, and a unique integer value\n+   --  is assigned, corresponding to the POS value in the Wide_Character type.\n+   --  String literals are similarly interpreted as a sequence of such codes.\n+\n+   --  Note: when character code values are stored in the tree, they are stored\n+   --  by adding a bias value (Char_Code_Bias) that results in values that can\n+   --  be distinguished from other types of values stored in the tree.\n+\n+   type Char_Code is mod 2 ** 16;\n+   for Char_Code'Size use 16;\n+\n+   function Get_Char_Code (C : Character) return Char_Code;\n+   pragma Inline (Get_Char_Code);\n+   --  Function to obtain internal character code from source character. For\n+   --  the moment, the internal character code is simply the Pos value of the\n+   --  input source character, but we provide this interface for possible\n+   --  later support of alternative character sets.\n+\n+   function In_Character_Range (C : Char_Code) return Boolean;\n+   pragma Inline (In_Character_Range);\n+   --  Determines if the given character code is in range of type Character,\n+   --  and if so, returns True. If not, returns False.\n+\n+   function Get_Character (C : Char_Code) return Character;\n+   pragma Inline (Get_Character);\n+   --  For a character C that is in character range (see above function), this\n+   --  function returns the corresponding Character value. It is an error to\n+   --  call Get_Character if C is not in character range\n+\n+   ---------------------------------------\n+   -- Types used for Library Management --\n+   ---------------------------------------\n+\n+   type Unit_Number_Type is new Int;\n+   --  Unit number. The main source is unit 0, and subsidiary sources have\n+   --  non-zero numbers starting with 1. Unit numbers are used to index the\n+   --  file table in Lib.\n+\n+   Main_Unit : constant Unit_Number_Type := 0;\n+   --  Unit number value for main unit\n+\n+   No_Unit : constant Unit_Number_Type := -1;\n+   --  Special value used to signal no unit\n+\n+   type Source_File_Index is new Nat;\n+   --  Type used to index the source file table (see package Sinput)\n+\n+   No_Source_File : constant Source_File_Index := 0;\n+   --  Value used to indicate no source file present\n+\n+   System_Source_File_Index : constant Source_File_Index := 1;\n+   --  Value used for source file table entry for system.ads, which is\n+   --  always the first source file read (see unit Targparm for details).\n+\n+   subtype File_Name_Type is Name_Id;\n+   --  File names are stored in the names table and this synonym is used to\n+   --  indicate that a Name_Id value is being used to hold a simple file\n+   --  name (which does not include any directory information).\n+\n+   No_File : constant File_Name_Type := File_Name_Type (No_Name);\n+   --  Constant used to indicate no file found\n+\n+   subtype Unit_Name_Type is Name_Id;\n+   --  Unit names are stored in the names table and this synonym is used to\n+   --  indicate that a Name_Id value is being used to hold a unit name.\n+\n+   -----------------------------------\n+   -- Representation of Time Stamps --\n+   -----------------------------------\n+\n+   --  All compiled units are marked with a time stamp which is derived from\n+   --  the source file (we assume that the host system has the concept of a\n+   --  file time stamp which is modified when a file is modified). These\n+   --  time stamps are used to ensure consistency of the set of units that\n+   --  constitutes a library. Time stamps are 12 character strings with\n+   --  with the following format:\n+\n+   --     YYYYMMDDHHMMSS\n+\n+   --       YYYY   year\n+   --       MM     month (2 digits 01-12)\n+   --       DD     day (2 digits 01-31)\n+   --       HH     hour (2 digits 00-23)\n+   --       MM     minutes (2 digits 00-59)\n+   --       SS     seconds (2 digits 00-59)\n+\n+   --  In the case of Unix systems (and other systems which keep the time in\n+   --  GMT), the time stamp is the GMT time of the file, not the local time.\n+   --  This solves problems in using libraries across networks with clients\n+   --  spread across multiple time-zones.\n+\n+   Time_Stamp_Length : constant := 14;\n+   --  Length of time stamp value\n+\n+   subtype Time_Stamp_Index is Natural range 1 .. Time_Stamp_Length;\n+   type Time_Stamp_Type is new String (Time_Stamp_Index);\n+   --  Type used to represent time stamp\n+\n+   Empty_Time_Stamp : constant Time_Stamp_Type := (others => ' ');\n+   --  Type used to represent an empty or missing time stamp. Looks less\n+   --  than any real time stamp if two time stamps are compared. Note that\n+   --  although this is not a private type, clients should not rely on the\n+   --  exact way in which this string is represented, and instead should\n+   --  use the subprograms below.\n+\n+   function \"=\"  (Left, Right : Time_Stamp_Type) return Boolean;\n+   function \"<=\" (Left, Right : Time_Stamp_Type) return Boolean;\n+   function \">=\" (Left, Right : Time_Stamp_Type) return Boolean;\n+   function \"<\"  (Left, Right : Time_Stamp_Type) return Boolean;\n+   function \">\"  (Left, Right : Time_Stamp_Type) return Boolean;\n+   --  Comparison functions on time stamps. Note that two time stamps\n+   --  are defined as being equal if they have the same day/month/year\n+   --  and the hour/minutes/seconds values are within 2 seconds of one\n+   --  another. This deals with rounding effects in library file time\n+   --  stamps caused by copying operations during installation. We have\n+   --  particularly noticed that WinNT seems susceptible to such changes.\n+   --  Note: the Empty_Time_Stamp value looks equal to itself, and less\n+   --  than any non-empty time stamp value.\n+\n+   procedure Split_Time_Stamp\n+     (TS      : Time_Stamp_Type;\n+      Year    : out Nat;\n+      Month   : out Nat;\n+      Day     : out Nat;\n+      Hour    : out Nat;\n+      Minutes : out Nat;\n+      Seconds : out Nat);\n+   --  Given a time stamp, decompose it into its components\n+\n+   procedure Make_Time_Stamp\n+     (Year    : Nat;\n+      Month   : Nat;\n+      Day     : Nat;\n+      Hour    : Nat;\n+      Minutes : Nat;\n+      Seconds : Nat;\n+      TS      : out Time_Stamp_Type);\n+   --  Given the components of a time stamp, initialize the value\n+\n+   -----------------------------------------------\n+   -- Types used for Pragma Suppress Management --\n+   -----------------------------------------------\n+\n+   --  The following record contains an entry for each recognized check name\n+   --  for pragma Suppress. It is used to represent current settings of scope\n+   --  based suppress actions from pragma Suppress or command line settings.\n+\n+   type Suppress_Record is record\n+      Access_Checks        : Boolean;\n+      Accessibility_Checks : Boolean;\n+      Discriminant_Checks  : Boolean;\n+      Division_Checks      : Boolean;\n+      Elaboration_Checks   : Boolean;\n+      Index_Checks         : Boolean;\n+      Length_Checks        : Boolean;\n+      Overflow_Checks      : Boolean;\n+      Range_Checks         : Boolean;\n+      Storage_Checks       : Boolean;\n+      Tag_Checks           : Boolean;\n+   end record;\n+\n+   --  To add a new check type to GNAT, the following steps are required:\n+\n+   --    1.  Add an appropriate entry to the above record type\n+   --    2.  Add an entry to Snames spec and body for the new name\n+   --    3.  Add an entry to the definition of Check_Id in the Snames spec\n+   --    4.  Add a new entity flag definition in Einfo for the check\n+   --    5.  Add a new function to Sem.Util to handle the new check test\n+   --    6.  Add appropriate processing for pragma Suppress in Sem.Prag\n+   --    7.  Add a branch to the case statement in Sem.Ch8.Pop_Scope\n+   --    8.  Add a new Do_xxx_Check flag to Sinfo (if required)\n+   --    9.  Add appropriate checks for the new test\n+\n+   -----------------------------------\n+   -- Global Exception Declarations --\n+   -----------------------------------\n+\n+   --  This section contains declarations of exceptions that are used\n+   --  throughout the compiler.\n+\n+   Unrecoverable_Error : exception;\n+   --  This exception is raised to immediately terminate the compilation\n+   --  of the current source program. Used in situations where things are\n+   --  bad enough that it doesn't seem worth continuing (e.g. max errors\n+   --  reached, or a required file is not found). Also raised when the\n+   --  compiler finds itself in trouble after an error (see Comperr).\n+\n+   ---------------------------------\n+   -- Parameter Mechanism Control --\n+   ---------------------------------\n+\n+   --  Function and parameter entities have a field that records the\n+   --  passing mechanism. See specification of Sem_Mech for full details.\n+   --  The following subtype is used to represent values of this type:\n+\n+   subtype Mechanism_Type is Int range -10 .. Int'Last;\n+   --  Type used to represent a mechanism value. This is a subtype rather\n+   --  than a type to avoid some annoying processing problems with certain\n+   --  routines in Einfo (processing them to create the corresponding C).\n+\n+end Types;"}, {"sha": "e993bdbea6aaf0be0f5e65bb2b80bdbd72324b3b", "filename": "gcc/ada/types.h", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,335 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                T Y P E S                                 *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *                             $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This is the C file that corresponds to the Ada package spec Types. It was\n+   created manually from the files types.ads and types.adb.\n+\n+   This package contains host independent type definitions which are used \n+   throughout the compiler modules. The comments in the C version are brief\n+   reminders of the purpose of each declaration.  For complete documentation,\n+   see the Ada version of these definitions.  */\n+\n+/* Boolean Types:  */\n+\n+/* Boolean type (cannot use enum, because of bit field restriction on some\n+   compilers).  */\n+typedef unsigned char Boolean;\n+#define False 0\n+#define True  1\n+\n+/* General Use Integer Types */\n+\n+/* Signed 32/bit integer */\n+typedef int Int;\n+\n+/* Signed 16 bit integer */\n+typedef short Short;\n+\n+/* Non/negative Int values */\n+typedef Int Nat;\n+\n+/* Positive Int values */\n+typedef Int Pos;\n+\n+/* 8/bit unsigned integer */\n+typedef char Byte;\n+\n+/* 8/Bit Character and String Types:  */\n+\n+/* 8/bit character type */\n+typedef char Char;\n+\n+/* Graphic characters, as defined in ARM */\n+typedef Char Graphic_Character;\n+\n+/* Line terminator characters (LF, VT, FF, CR) */\n+typedef Char Line_Terminator;\n+\n+/* Characters with the upper bit set */\n+typedef Char Upper_Half_Character;\n+\n+/* String type built on Char (note that zero is an OK index) */\n+typedef Char *Str;\n+\n+/* Pointer to string of Chars */\n+typedef Char *Str_Ptr;\n+\n+/* Types for the fat pointer used for strings and the template it\n+   points to.  */\n+typedef struct {int Low_Bound, High_Bound; } String_Template;\n+typedef struct {const char *Array; String_Template *Bounds; } \n+\t__attribute ((aligned (sizeof (char *) * 2))) Fat_Pointer;\n+\n+/* Types for Node/Entity Kinds:  */\n+\n+/* The reason that these are defined here in the C version, rather than in the\n+   corresponding packages is that the requirement for putting bodies of\n+   inlined stuff IN the C header changes the dependencies.  Both a-sinfo.h\n+   and a-einfo.h now reference routines defined in tree.h.\n+\n+   Note: these types would more naturally be defined as unsigned  char, but\n+   once again, the annoying restriction on bit fields for some compilers\n+   bites us!  */\n+\n+typedef unsigned int Node_Kind;\n+typedef unsigned int Entity_Kind;\n+\n+/* Types used for Text Buffer Handling:  */\n+\n+/* Type used for subscripts in text buffer.  */\n+typedef Int Text_Ptr;\n+\n+/* Text buffer used to hold source file or library information file.  */\n+typedef Char *Text_Buffer;\n+\n+/* Pointer to text buffer.  */\n+typedef Char *Text_Buffer_Ptr;\n+\n+/* Types used for Source Input Handling:  */\n+\n+/* Line number type, used for storing all line numbers.  */\n+typedef Int Line_Number_Type;\n+\n+/* Column number type, used for storing all column numbers.  */\n+typedef Int Column_Number_Type;\n+\n+/* Type used to store text of a source file.  */\n+typedef Text_Buffer Source_Buffer;\n+\n+/* Pointer to source buffer. */\n+typedef Text_Buffer_Ptr Source_Buffer_Ptr;\n+\n+/* Type used for source location.  */\n+typedef Text_Ptr Source_Ptr;\n+\n+/* Value used to indicate no source position set.  */\n+#define No_Location -1\n+\n+/* Used for Sloc in all nodes in the representation of package Standard.  */\n+#define Standard_Location -2\n+\n+/* Type used for union of all possible ID values covering all ranges */\n+typedef int Union_Id;\n+\n+/* Range definitions for Tree Data:  */\n+\n+#define List_Low_Bound\t\t-100000000\n+#define List_High_Bound\t\t0\n+\n+#define Node_Low_Bound\t\t0\n+#define Node_High_Bound\t\t99999999\n+\n+#define Elist_Low_Bound\t\t100000000\n+#define Elist_High_Bound\t199999999\n+\n+#define Elmt_Low_Bound\t\t200000000\n+#define Elmt_High_Bound\t\t299999999\n+\n+#define Names_Low_Bound\t\t300000000\n+#define Names_High_Bound\t399999999\n+\n+#define Strings_Low_Bound\t400000000\n+#define Strings_High_Bound\t499999999\n+\n+#define Ureal_Low_Bound\t\t500000000\n+#define Ureal_High_Bound        599999999\n+\n+#define Uint_Low_Bound\t\t600000000\n+#define Uint_Table_Start        2000000000\n+#define Uint_High_Bound\t        2099999999\n+\n+#define Char_Code_Bias\t\t2100000000\n+\n+SUBTYPE (List_Range,      Int, List_Low_Bound,    List_High_Bound)\n+SUBTYPE (Node_Range,      Int, Node_Low_Bound,    Node_High_Bound)\n+SUBTYPE (Elist_Range,     Int, Elist_Low_Bound,   Elist_High_Bound)\n+SUBTYPE (Elmt_Range,      Int, Elmt_Low_Bound,    Elmt_High_Bound)\n+SUBTYPE (Names_Range,     Int, Names_Low_Bound,   Names_High_Bound)\n+SUBTYPE (Strings_Range,   Int, Strings_Low_Bound, Strings_High_Bound)\n+SUBTYPE (Uint_Range,      Int, Uint_Low_Bound,    Uint_High_Bound)\n+SUBTYPE (Ureal_Range,     Int, Ureal_Low_Bound,   Ureal_High_Bound)\n+SUBTYPE (Char_Code_Range, Int, Char_Code_Bias,    (Char_Code_Bias + 65535))\n+\n+/* Types for Names_Table Package:  */\n+\n+typedef Int Name_Id;\n+\n+/* Name_Id value for no name present.  */\n+#define No_Name Names_Low_Bound\n+\n+/* Name_Id value for bad name.  */\n+#define Error_Name (Names_Low_Bound + 1)\n+\n+/* First subscript of names table. */\n+#define First_Name_Id (Names_Low_Bound + 2)\n+\n+/* Types for Tree Package:  */\n+\n+/* Subscript of nodes table entry.  */\n+typedef Int Node_Id;\n+\n+/* Used in semantics for Node_Id value referencing an entity.  */\n+typedef Node_Id Entity_Id;\n+\n+/* Null node.  */\n+#define Empty 0\n+\n+/* Error node.  */\n+#define Error 1\n+\n+/* Subscript of first allocated node.  */\n+#define First_Node_Id Empty\n+\n+/* Subscript of entry in lists table.  */\n+typedef Int List_Id;\n+\n+/* Indicates absence of a list.  */\n+#define No_List 0\n+\n+/* Error list. */\n+#define Error_List List_Low_Bound\n+\n+/* Subscript of first allocated list header.  */\n+#define First_List_Id Error_List\n+\n+/* Element list Id, subscript value of entry in lists table.  */\n+typedef Int Elist_Id;\n+\n+/* Used to indicate absence of an element list.  */\n+#define No_Elist Elist_Low_Bound\n+\n+/* Subscript of first allocated elist header */\n+#define First_Elist_Id (No_Elist + 1)\n+\n+/* Element Id, subscript value of entry in elements table.  */\n+typedef Int Elmt_Id;\n+\n+/* Used to indicate absence of a list element.  */\n+#define No_Elmt Elmt_Low_Bound\n+\n+/* Subscript of first allocated element */\n+#define First_Elmt_Id (No_Elmt + 1)\n+\n+/* Types for String_Table Package:  */\n+\n+/* Subscript of strings table entry.  */\n+typedef Int String_Id;\n+\n+/* Used to indicate missing string Id.  */\n+#define No_String Strings_Low_Bound\n+\n+/* Subscript of first entry in strings table.  */\n+#define First_String_Id (No_String + 1)\n+\n+/* Types for Uint_Support Package:  */\n+\n+/* Type used for representation of universal integers.  */\n+typedef Int Uint;\n+\n+/* Used to indicate missing Uint value.  */\n+#define No_Uint Uint_Low_Bound\n+\n+/* Base value used to represent Uint values.  */\n+#define Base 32768\n+\n+/* Minimum and maximum integers directly representable as Uint values */\n+#define Min_Direct (-(Base - 1))\n+#define Max_Direct ((Base - 1) * (Base - 1))\n+\n+#define Uint_Direct_Bias  (Uint_Low_Bound + Base)\n+#define Uint_Direct_First (Uint_Direct_Bias + Min_Direct)\n+#define Uint_Direct_Last  (Uint_Direct_Bias + Max_Direct)\n+\n+/* Define range of direct biased values */\n+SUBTYPE (Uint_Direct, Uint, Uint_Direct_First, Uint_Direct_Last)\n+\n+/* Constants in Uint format.  */\n+#define Uint_0  (Uint_Direct_Bias + 0)\n+#define Uint_1  (Uint_Direct_Bias + 1)\n+#define Uint_2  (Uint_Direct_Bias + 2)\n+#define Uint_10 (Uint_Direct_Bias + 10)\n+#define Uint_16 (Uint_Direct_Bias + 16)\n+\n+/* Types for Ureal_Support Package:  */\n+\n+/* Type used for representation of universal reals.  */\n+typedef Int Ureal;\n+\n+/* Used to indicate missing Uint value.  */\n+#define No_Ureal Ureal_Low_Bound\n+\n+/* Subscript of first entry in Ureal table.  */\n+#define Ureal_First_Entry (No_Ureal + 1)\n+\n+/* Character Code Type:  */\n+\n+/* Character code value, intended to be 16 bits.  */\n+typedef short Char_Code;\n+\n+/* Types Used for Library Management:  */\n+\n+/* Unit number.  */\n+typedef Int Unit_Number_Type;\n+\n+/* Unit number value for main unit.  */\n+#define Main_Unit 0\n+\n+/* Type used for lines table.  */\n+typedef Source_Ptr *Lines_Table_Type;\n+\n+/* Type used for pointer to lines table.  */\n+typedef Source_Ptr *Lines_Table_Ptr;\n+\n+/* Length of time stamp value.  */\n+#define Time_Stamp_Length 22\n+\n+/* Type used to represent time stamp.  */\n+typedef Char *Time_Stamp_Type;\n+\n+/* Name_Id synonym used for file names.  */\n+typedef Name_Id File_Name_Type;\n+\n+/* Constant used to indicate no file found.  */\n+#define No_File No_Name\n+\n+/* Name_Id synonym used for unit names.  */\n+typedef Name_Id Unit_Name_Type;\n+\n+/* Definitions for mechanism type and values */\n+typedef Int Mechanism_Type;\n+#define Default            0\n+#define By_Copy            (-1)\n+#define By_Reference       (-2)\n+#define By_Descriptor      (-3)\n+#define By_Descriptor_UBS  (-4)\n+#define By_Descriptor_UBSB (-5)\n+#define By_Descriptor_UBA  (-6)\n+#define By_Descriptor_S    (-7)\n+#define By_Descriptor_SB   (-8)\n+#define By_Descriptor_A    (-9)\n+#define By_Descriptor_NCA  (-10)"}, {"sha": "d60986b07d0f9b3e6913bfcba185dfb45e3751b1", "filename": "gcc/ada/uintp.adb", "status": "added", "additions": 2472, "deletions": 0, "changes": 2472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,2472 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                U I N T P                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.74 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Output;  use Output;\n+with Tree_IO; use Tree_IO;\n+\n+package body Uintp is\n+\n+   ------------------------\n+   -- Local Declarations --\n+   ------------------------\n+\n+   Uint_Int_First : Uint := Uint_0;\n+   --  Uint value containing Int'First value, set by Initialize. The initial\n+   --  value of Uint_0 is used for an assertion check that ensures that this\n+   --  value is not used before it is initialized. This value is used in the\n+   --  UI_Is_In_Int_Range predicate, and it is right that this is a host\n+   --  value, since the issue is host representation of integer values.\n+\n+   Uint_Int_Last : Uint;\n+   --  Uint value containing Int'Last value set by Initialize.\n+\n+   UI_Power_2 : array (Int range 0 .. 64) of Uint;\n+   --  This table is used to memoize exponentiations by powers of 2. The Nth\n+   --  entry, if set, contains the Uint value 2 ** N. Initially UI_Power_2_Set\n+   --  is zero and only the 0'th entry is set, the invariant being that all\n+   --  entries in the range 0 .. UI_Power_2_Set are initialized.\n+\n+   UI_Power_2_Set : Nat;\n+   --  Number of entries set in UI_Power_2;\n+\n+   UI_Power_10 : array (Int range 0 .. 64) of Uint;\n+   --  This table is used to memoize exponentiations by powers of 10 in the\n+   --  same manner as described above for UI_Power_2.\n+\n+   UI_Power_10_Set : Nat;\n+   --  Number of entries set in UI_Power_10;\n+\n+   Uints_Min   : Uint;\n+   Udigits_Min : Int;\n+   --  These values are used to make sure that the mark/release mechanism\n+   --  does not destroy values saved in the U_Power tables. Whenever an\n+   --  entry is made in the U_Power tables, Uints_Min and Udigits_Min are\n+   --  updated to protect the entry, and Release never cuts back beyond\n+   --  these minimum values.\n+\n+   Int_0 : constant Int := 0;\n+   Int_1 : constant Int := 1;\n+   Int_2 : constant Int := 2;\n+   --  These values are used in some cases where the use of numeric literals\n+   --  would cause ambiguities (integer vs Uint).\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Direct (U : Uint) return Boolean;\n+   pragma Inline (Direct);\n+   --  Returns True if U is represented directly\n+\n+   function Direct_Val (U : Uint) return Int;\n+   --  U is a Uint for is represented directly. The returned result\n+   --  is the value represented.\n+\n+   function GCD (Jin, Kin : Int) return Int;\n+   --  Compute GCD of two integers. Assumes that Jin >= Kin >= 0\n+\n+   procedure Image_Out\n+     (Input     : Uint;\n+      To_Buffer : Boolean;\n+      Format    : UI_Format);\n+   --  Common processing for UI_Image and UI_Write, To_Buffer is set\n+   --  True for UI_Image, and false for UI_Write, and Format is copied\n+   --  from the Format parameter to UI_Image or UI_Write.\n+\n+   procedure Init_Operand (UI : Uint; Vec : out UI_Vector);\n+   pragma Inline (Init_Operand);\n+   --  This procedure puts the value of UI into the vector in canonical\n+   --  multiple precision format. The parameter should be of the correct\n+   --  size as determined by a previous call to N_Digits (UI). The first\n+   --  digit of Vec contains the sign, all other digits are always non-\n+   --  negative. Note that the input may be directly represented, and in\n+   --  this case Vec will contain the corresponding one or two digit value.\n+\n+   function Least_Sig_Digit (Arg : Uint) return Int;\n+   pragma Inline (Least_Sig_Digit);\n+   --  Returns the Least Significant Digit of Arg quickly. When the given\n+   --  Uint is less than 2**15, the value returned is the input value, in\n+   --  this case the result may be negative. It is expected that any use\n+   --  will mask off unnecessary bits. This is used for finding Arg mod B\n+   --  where B is a power of two. Hence the actual base is irrelevent as\n+   --  long as it is a power of two.\n+\n+   procedure Most_Sig_2_Digits\n+     (Left      : Uint;\n+      Right     : Uint;\n+      Left_Hat  : out Int;\n+      Right_Hat : out Int);\n+   --  Returns leading two significant digits from the given pair of Uint's.\n+   --  Mathematically: returns Left / (Base ** K) and Right / (Base ** K)\n+   --  where K is as small as possible S.T. Right_Hat < Base * Base.\n+   --  It is required that Left > Right for the algorithm to work.\n+\n+   function N_Digits (Input : Uint) return Int;\n+   pragma Inline (N_Digits);\n+   --  Returns number of \"digits\" in a Uint\n+\n+   function Sum_Digits (Left : Uint; Sign : Int) return Int;\n+   --  If Sign = 1 return the sum of the \"digits\" of Abs (Left). If the\n+   --  total has more then one digit then return Sum_Digits of total.\n+\n+   function Sum_Double_Digits (Left : Uint; Sign : Int) return Int;\n+   --  Same as above but work in New_Base = Base * Base\n+\n+   function Vector_To_Uint\n+     (In_Vec   : UI_Vector;\n+      Negative : Boolean)\n+      return     Uint;\n+   --  Functions that calculate values in UI_Vectors, call this function\n+   --  to create and return the Uint value. In_Vec contains the multiple\n+   --  precision (Base) representation of a non-negative value. Leading\n+   --  zeroes are permitted. Negative is set if the desired result is\n+   --  the negative of the given value. The result will be either the\n+   --  appropriate directly represented value, or a table entry in the\n+   --  proper canonical format is created and returned.\n+   --\n+   --  Note that Init_Operand puts a signed value in the result vector,\n+   --  but Vector_To_Uint is always presented with a non-negative value.\n+   --  The processing of signs is something that is done by the caller\n+   --  before calling Vector_To_Uint.\n+\n+   ------------\n+   -- Direct --\n+   ------------\n+\n+   function Direct (U : Uint) return Boolean is\n+   begin\n+      return Int (U) <= Int (Uint_Direct_Last);\n+   end Direct;\n+\n+   ----------------\n+   -- Direct_Val --\n+   ----------------\n+\n+   function Direct_Val (U : Uint) return Int is\n+   begin\n+      pragma Assert (Direct (U));\n+      return Int (U) - Int (Uint_Direct_Bias);\n+   end Direct_Val;\n+\n+   ---------\n+   -- GCD --\n+   ---------\n+\n+   function GCD (Jin, Kin : Int) return Int is\n+      J, K, Tmp : Int;\n+\n+   begin\n+      pragma Assert (Jin >= Kin);\n+      pragma Assert (Kin >= Int_0);\n+\n+      J := Jin;\n+      K := Kin;\n+\n+      while K /= Uint_0 loop\n+         Tmp := J mod K;\n+         J := K;\n+         K := Tmp;\n+      end loop;\n+\n+      return J;\n+   end GCD;\n+\n+   ---------------\n+   -- Image_Out --\n+   ---------------\n+\n+   procedure Image_Out\n+     (Input     : Uint;\n+      To_Buffer : Boolean;\n+      Format    : UI_Format)\n+   is\n+      Marks  : constant Uintp.Save_Mark := Uintp.Mark;\n+      Base   : Uint;\n+      Ainput : Uint;\n+\n+      Digs_Output : Natural := 0;\n+      --  Counts digits output. In hex mode, but not in decimal mode, we\n+      --  put an underline after every four hex digits that are output.\n+\n+      Exponent : Natural := 0;\n+      --  If the number is too long to fit in the buffer, we switch to an\n+      --  approximate output format with an exponent. This variable records\n+      --  the exponent value.\n+\n+      function Better_In_Hex return Boolean;\n+      --  Determines if it is better to generate digits in base 16 (result\n+      --  is true) or base 10 (result is false). The choice is purely a\n+      --  matter of convenience and aesthetics, so it does not matter which\n+      --  value is returned from a correctness point of view.\n+\n+      procedure Image_Char (C : Character);\n+      --  Internal procedure to output one character\n+\n+      procedure Image_Exponent (N : Natural);\n+      --  Output non-zero exponent. Note that we only use the exponent\n+      --  form in the buffer case, so we know that To_Buffer is true.\n+\n+      procedure Image_Uint (U : Uint);\n+      --  Internal procedure to output characters of non-negative Uint\n+\n+      -------------------\n+      -- Better_In_Hex --\n+      -------------------\n+\n+      function Better_In_Hex return Boolean is\n+         T16 : constant Uint := Uint_2 ** Int'(16);\n+         A   : Uint;\n+\n+      begin\n+         A := UI_Abs (Input);\n+\n+         --  Small values up to 2**16 can always be in decimal\n+\n+         if A < T16 then\n+            return False;\n+         end if;\n+\n+         --  Otherwise, see if we are a power of 2 or one less than a power\n+         --  of 2. For the moment these are the only cases printed in hex.\n+\n+         if A mod Uint_2 = Uint_1 then\n+            A := A + Uint_1;\n+         end if;\n+\n+         loop\n+            if A mod T16 /= Uint_0 then\n+               return False;\n+\n+            else\n+               A := A / T16;\n+            end if;\n+\n+            exit when A < T16;\n+         end loop;\n+\n+         while A > Uint_2 loop\n+            if A mod Uint_2 /= Uint_0 then\n+               return False;\n+\n+            else\n+               A := A / Uint_2;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Better_In_Hex;\n+\n+      ----------------\n+      -- Image_Char --\n+      ----------------\n+\n+      procedure Image_Char (C : Character) is\n+      begin\n+         if To_Buffer then\n+            if UI_Image_Length + 6 > UI_Image_Max then\n+               Exponent := Exponent + 1;\n+            else\n+               UI_Image_Length := UI_Image_Length + 1;\n+               UI_Image_Buffer (UI_Image_Length) := C;\n+            end if;\n+         else\n+            Write_Char (C);\n+         end if;\n+      end Image_Char;\n+\n+      --------------------\n+      -- Image_Exponent --\n+      --------------------\n+\n+      procedure Image_Exponent (N : Natural) is\n+      begin\n+         if N >= 10 then\n+            Image_Exponent (N / 10);\n+         end if;\n+\n+         UI_Image_Length := UI_Image_Length + 1;\n+         UI_Image_Buffer (UI_Image_Length) :=\n+           Character'Val (Character'Pos ('0') + N mod 10);\n+      end Image_Exponent;\n+\n+      ----------------\n+      -- Image_Uint --\n+      ----------------\n+\n+      procedure Image_Uint (U : Uint) is\n+         H : array (Int range 0 .. 15) of Character := \"0123456789ABCDEF\";\n+\n+      begin\n+         if U >= Base then\n+            Image_Uint (U / Base);\n+         end if;\n+\n+         if Digs_Output = 4 and then Base = Uint_16 then\n+            Image_Char ('_');\n+            Digs_Output := 0;\n+         end if;\n+\n+         Image_Char (H (UI_To_Int (U rem Base)));\n+\n+         Digs_Output := Digs_Output + 1;\n+      end Image_Uint;\n+\n+   --  Start of processing for Image_Out\n+\n+   begin\n+      if Input = No_Uint then\n+         Image_Char ('?');\n+         return;\n+      end if;\n+\n+      UI_Image_Length := 0;\n+\n+      if Input < Uint_0 then\n+         Image_Char ('-');\n+         Ainput := -Input;\n+      else\n+         Ainput := Input;\n+      end if;\n+\n+      if Format = Hex\n+        or else (Format = Auto and then Better_In_Hex)\n+      then\n+         Base := Uint_16;\n+         Image_Char ('1');\n+         Image_Char ('6');\n+         Image_Char ('#');\n+         Image_Uint (Ainput);\n+         Image_Char ('#');\n+\n+      else\n+         Base := Uint_10;\n+         Image_Uint (Ainput);\n+      end if;\n+\n+      if Exponent /= 0 then\n+         UI_Image_Length := UI_Image_Length + 1;\n+         UI_Image_Buffer (UI_Image_Length) := 'E';\n+         Image_Exponent (Exponent);\n+      end if;\n+\n+      Uintp.Release (Marks);\n+   end Image_Out;\n+\n+   -------------------\n+   -- Init_Operand --\n+   -------------------\n+\n+   procedure Init_Operand (UI : Uint; Vec : out UI_Vector) is\n+      Loc : Int;\n+\n+   begin\n+      if Direct (UI) then\n+         Vec (1) := Direct_Val (UI);\n+\n+         if Vec (1) >= Base then\n+            Vec (2) := Vec (1) rem Base;\n+            Vec (1) := Vec (1) / Base;\n+         end if;\n+\n+      else\n+         Loc := Uints.Table (UI).Loc;\n+\n+         for J in 1 .. Uints.Table (UI).Length loop\n+            Vec (J) := Udigits.Table (Loc + J - 1);\n+         end loop;\n+      end if;\n+   end Init_Operand;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Uints.Init;\n+      Udigits.Init;\n+\n+      Uint_Int_First := UI_From_Int (Int'First);\n+      Uint_Int_Last  := UI_From_Int (Int'Last);\n+\n+      UI_Power_2 (0) := Uint_1;\n+      UI_Power_2_Set := 0;\n+\n+      UI_Power_10 (0) := Uint_1;\n+      UI_Power_10_Set := 0;\n+\n+      Uints_Min := Uints.Last;\n+      Udigits_Min := Udigits.Last;\n+\n+   end Initialize;\n+\n+   ---------------------\n+   -- Least_Sig_Digit --\n+   ---------------------\n+\n+   function Least_Sig_Digit (Arg : Uint) return Int is\n+      V : Int;\n+\n+   begin\n+      if Direct (Arg) then\n+         V := Direct_Val (Arg);\n+\n+         if V >= Base then\n+            V := V mod Base;\n+         end if;\n+\n+         --  Note that this result may be negative\n+\n+         return V;\n+\n+      else\n+         return\n+           Udigits.Table\n+            (Uints.Table (Arg).Loc + Uints.Table (Arg).Length - 1);\n+      end if;\n+   end Least_Sig_Digit;\n+\n+   ----------\n+   -- Mark --\n+   ----------\n+\n+   function Mark return Save_Mark is\n+   begin\n+      return (Save_Uint => Uints.Last, Save_Udigit => Udigits.Last);\n+   end Mark;\n+\n+   -----------------------\n+   -- Most_Sig_2_Digits --\n+   -----------------------\n+\n+   procedure Most_Sig_2_Digits\n+     (Left      : Uint;\n+      Right     : Uint;\n+      Left_Hat  : out Int;\n+      Right_Hat : out Int)\n+   is\n+   begin\n+      pragma Assert (Left >= Right);\n+\n+      if Direct (Left) then\n+         Left_Hat  := Direct_Val (Left);\n+         Right_Hat := Direct_Val (Right);\n+         return;\n+\n+      else\n+         declare\n+            L1 : constant Int :=\n+                   Udigits.Table (Uints.Table (Left).Loc);\n+            L2 : constant Int :=\n+                   Udigits.Table (Uints.Table (Left).Loc + 1);\n+\n+         begin\n+            --  It is not so clear what to return when Arg is negative???\n+\n+            Left_Hat := abs (L1) * Base + L2;\n+         end;\n+      end if;\n+\n+      declare\n+         Length_L : constant Int := Uints.Table (Left).Length;\n+         Length_R : Int;\n+         R1 : Int;\n+         R2 : Int;\n+         T  : Int;\n+\n+      begin\n+         if Direct (Right) then\n+            T := Direct_Val (Left);\n+            R1 := abs (T / Base);\n+            R2 := T rem Base;\n+            Length_R := 2;\n+\n+         else\n+            R1 := abs (Udigits.Table (Uints.Table (Right).Loc));\n+            R2 := Udigits.Table (Uints.Table (Right).Loc + 1);\n+            Length_R := Uints.Table (Right).Length;\n+         end if;\n+\n+         if Length_L = Length_R then\n+            Right_Hat := R1 * Base + R2;\n+         elsif Length_L = Length_R + Int_1 then\n+            Right_Hat := R1;\n+         else\n+            Right_Hat := 0;\n+         end if;\n+      end;\n+   end Most_Sig_2_Digits;\n+\n+   ---------------\n+   -- N_Digits --\n+   ---------------\n+\n+   --  Note: N_Digits returns 1 for No_Uint\n+\n+   function N_Digits (Input : Uint) return Int is\n+   begin\n+      if Direct (Input) then\n+         if Direct_Val (Input) >= Base then\n+            return 2;\n+         else\n+            return 1;\n+         end if;\n+\n+      else\n+         return Uints.Table (Input).Length;\n+      end if;\n+   end N_Digits;\n+\n+   --------------\n+   -- Num_Bits --\n+   --------------\n+\n+   function Num_Bits (Input : Uint) return Nat is\n+      Bits : Nat;\n+      Num  : Nat;\n+\n+   begin\n+      if UI_Is_In_Int_Range (Input) then\n+         Num := UI_To_Int (Input);\n+         Bits := 0;\n+\n+      else\n+         Bits := Base_Bits * (Uints.Table (Input).Length - 1);\n+         Num  := abs (Udigits.Table (Uints.Table (Input).Loc));\n+      end if;\n+\n+      while Types.\">\" (Num, 0) loop\n+         Num := Num / 2;\n+         Bits := Bits + 1;\n+      end loop;\n+\n+      return Bits;\n+   end Num_Bits;\n+\n+   ---------\n+   -- pid --\n+   ---------\n+\n+   procedure pid (Input : Uint) is\n+   begin\n+      UI_Write (Input, Decimal);\n+      Write_Eol;\n+   end pid;\n+\n+   ---------\n+   -- pih --\n+   ---------\n+\n+   procedure pih (Input : Uint) is\n+   begin\n+      UI_Write (Input, Hex);\n+      Write_Eol;\n+   end pih;\n+\n+   -------------\n+   -- Release --\n+   -------------\n+\n+   procedure Release (M : Save_Mark) is\n+   begin\n+      Uints.Set_Last   (Uint'Max (M.Save_Uint,   Uints_Min));\n+      Udigits.Set_Last (Int'Max  (M.Save_Udigit, Udigits_Min));\n+   end Release;\n+\n+   ----------------------\n+   -- Release_And_Save --\n+   ----------------------\n+\n+   procedure Release_And_Save (M : Save_Mark; UI : in out Uint) is\n+   begin\n+      if Direct (UI) then\n+         Release (M);\n+\n+      else\n+         declare\n+            UE_Len : Pos := Uints.Table (UI).Length;\n+            UE_Loc : Int := Uints.Table (UI).Loc;\n+\n+            UD : Udigits.Table_Type (1 .. UE_Len) :=\n+                   Udigits.Table (UE_Loc .. UE_Loc + UE_Len - 1);\n+\n+         begin\n+            Release (M);\n+\n+            Uints.Increment_Last;\n+            UI := Uints.Last;\n+\n+            Uints.Table (UI) := (UE_Len, Udigits.Last + 1);\n+\n+            for J in 1 .. UE_Len loop\n+               Udigits.Increment_Last;\n+               Udigits.Table (Udigits.Last) := UD (J);\n+            end loop;\n+         end;\n+      end if;\n+   end Release_And_Save;\n+\n+   procedure Release_And_Save (M : Save_Mark; UI1, UI2 : in out Uint) is\n+   begin\n+      if Direct (UI1) then\n+         Release_And_Save (M, UI2);\n+\n+      elsif Direct (UI2) then\n+         Release_And_Save (M, UI1);\n+\n+      else\n+         declare\n+            UE1_Len : Pos := Uints.Table (UI1).Length;\n+            UE1_Loc : Int := Uints.Table (UI1).Loc;\n+\n+            UD1 : Udigits.Table_Type (1 .. UE1_Len) :=\n+                    Udigits.Table (UE1_Loc .. UE1_Loc + UE1_Len - 1);\n+\n+            UE2_Len : Pos := Uints.Table (UI2).Length;\n+            UE2_Loc : Int := Uints.Table (UI2).Loc;\n+\n+            UD2 : Udigits.Table_Type (1 .. UE2_Len) :=\n+                    Udigits.Table (UE2_Loc .. UE2_Loc + UE2_Len - 1);\n+\n+         begin\n+            Release (M);\n+\n+            Uints.Increment_Last;\n+            UI1 := Uints.Last;\n+\n+            Uints.Table (UI1) := (UE1_Len, Udigits.Last + 1);\n+\n+            for J in 1 .. UE1_Len loop\n+               Udigits.Increment_Last;\n+               Udigits.Table (Udigits.Last) := UD1 (J);\n+            end loop;\n+\n+            Uints.Increment_Last;\n+            UI2 := Uints.Last;\n+\n+            Uints.Table (UI2) := (UE2_Len, Udigits.Last + 1);\n+\n+            for J in 1 .. UE2_Len loop\n+               Udigits.Increment_Last;\n+               Udigits.Table (Udigits.Last) := UD2 (J);\n+            end loop;\n+         end;\n+      end if;\n+   end Release_And_Save;\n+\n+   ----------------\n+   -- Sum_Digits --\n+   ----------------\n+\n+   --  This is done in one pass\n+\n+   --  Mathematically: assume base congruent to 1 and compute an equivelent\n+   --  integer to Left.\n+\n+   --  If Sign = -1 return the alternating sum of the \"digits\".\n+\n+   --     D1 - D2 + D3 - D4 + D5 . . .\n+\n+   --  (where D1 is Least Significant Digit)\n+\n+   --  Mathematically: assume base congruent to -1 and compute an equivelent\n+   --  integer to Left.\n+\n+   --  This is used in Rem and Base is assumed to be 2 ** 15\n+\n+   --  Note: The next two functions are very similar, any style changes made\n+   --  to one should be reflected in both.  These would be simpler if we\n+   --  worked base 2 ** 32.\n+\n+   function Sum_Digits (Left : Uint; Sign : Int) return Int is\n+   begin\n+      pragma Assert (Sign = Int_1 or Sign = Int (-1));\n+\n+      --  First try simple case;\n+\n+      if Direct (Left) then\n+         declare\n+            Tmp_Int : Int := Direct_Val (Left);\n+\n+         begin\n+            if Tmp_Int >= Base then\n+               Tmp_Int := (Tmp_Int / Base) +\n+                  Sign * (Tmp_Int rem Base);\n+\n+                  --  Now Tmp_Int is in [-(Base - 1) .. 2 * (Base - 1)]\n+\n+               if Tmp_Int >= Base then\n+\n+                  --  Sign must be 1.\n+\n+                  Tmp_Int := (Tmp_Int / Base) + 1;\n+\n+               end if;\n+\n+               --  Now Tmp_Int is in [-(Base - 1) .. (Base - 1)]\n+\n+            end if;\n+\n+            return Tmp_Int;\n+         end;\n+\n+      --  Otherwise full circuit is needed\n+\n+      else\n+         declare\n+            L_Length : Int := N_Digits (Left);\n+            L_Vec    : UI_Vector (1 .. L_Length);\n+            Tmp_Int  : Int;\n+            Carry    : Int;\n+            Alt      : Int;\n+\n+         begin\n+            Init_Operand (Left, L_Vec);\n+            L_Vec (1) := abs L_Vec (1);\n+            Tmp_Int := 0;\n+            Carry := 0;\n+            Alt := 1;\n+\n+            for J in reverse 1 .. L_Length loop\n+               Tmp_Int := Tmp_Int + Alt * (L_Vec (J) + Carry);\n+\n+               --  Tmp_Int is now between [-2 * Base + 1 .. 2 * Base - 1],\n+               --  since old Tmp_Int is between [-(Base - 1) .. Base - 1]\n+               --  and L_Vec is in [0 .. Base - 1] and Carry in [-1 .. 1]\n+\n+               if Tmp_Int >= Base then\n+                  Tmp_Int := Tmp_Int - Base;\n+                  Carry := 1;\n+\n+               elsif Tmp_Int <= -Base then\n+                  Tmp_Int := Tmp_Int + Base;\n+                  Carry := -1;\n+\n+               else\n+                  Carry := 0;\n+               end if;\n+\n+               --  Tmp_Int is now between [-Base + 1 .. Base - 1]\n+\n+               Alt := Alt * Sign;\n+            end loop;\n+\n+            Tmp_Int := Tmp_Int + Alt * Carry;\n+\n+            --  Tmp_Int is now between [-Base .. Base]\n+\n+            if Tmp_Int >= Base then\n+               Tmp_Int := Tmp_Int - Base + Alt * Sign * 1;\n+\n+            elsif Tmp_Int <= -Base then\n+               Tmp_Int := Tmp_Int + Base + Alt * Sign * (-1);\n+            end if;\n+\n+            --  Now Tmp_Int is in [-(Base - 1) .. (Base - 1)]\n+\n+            return Tmp_Int;\n+         end;\n+      end if;\n+   end Sum_Digits;\n+\n+   -----------------------\n+   -- Sum_Double_Digits --\n+   -----------------------\n+\n+   --  Note: This is used in Rem, Base is assumed to be 2 ** 15\n+\n+   function Sum_Double_Digits (Left : Uint; Sign : Int) return Int is\n+   begin\n+      --  First try simple case;\n+\n+      pragma Assert (Sign = Int_1 or Sign = Int (-1));\n+\n+      if Direct (Left) then\n+         return Direct_Val (Left);\n+\n+      --  Otherwise full circuit is needed\n+\n+      else\n+         declare\n+            L_Length      : Int := N_Digits (Left);\n+            L_Vec         : UI_Vector (1 .. L_Length);\n+            Most_Sig_Int  : Int;\n+            Least_Sig_Int : Int;\n+            Carry         : Int;\n+            J             : Int;\n+            Alt           : Int;\n+\n+         begin\n+            Init_Operand (Left, L_Vec);\n+            L_Vec (1) := abs L_Vec (1);\n+            Most_Sig_Int := 0;\n+            Least_Sig_Int := 0;\n+            Carry := 0;\n+            Alt := 1;\n+            J := L_Length;\n+\n+            while J > Int_1 loop\n+\n+               Least_Sig_Int := Least_Sig_Int + Alt * (L_Vec (J) + Carry);\n+\n+               --  Least is in [-2 Base + 1 .. 2 * Base - 1]\n+               --  Since L_Vec in [0 .. Base - 1] and Carry in [-1 .. 1]\n+               --  and old Least in [-Base + 1 .. Base - 1]\n+\n+               if Least_Sig_Int >= Base then\n+                  Least_Sig_Int := Least_Sig_Int - Base;\n+                  Carry := 1;\n+\n+               elsif Least_Sig_Int <= -Base then\n+                  Least_Sig_Int := Least_Sig_Int + Base;\n+                  Carry := -1;\n+\n+               else\n+                  Carry := 0;\n+               end if;\n+\n+               --  Least is now in [-Base + 1 .. Base - 1]\n+\n+               Most_Sig_Int := Most_Sig_Int + Alt * (L_Vec (J - 1) + Carry);\n+\n+               --  Most is in [-2 Base + 1 .. 2 * Base - 1]\n+               --  Since L_Vec in [0 ..  Base - 1] and Carry in  [-1 .. 1]\n+               --  and old Most in [-Base + 1 .. Base - 1]\n+\n+               if Most_Sig_Int >= Base then\n+                  Most_Sig_Int := Most_Sig_Int - Base;\n+                  Carry := 1;\n+\n+               elsif Most_Sig_Int <= -Base then\n+                  Most_Sig_Int := Most_Sig_Int + Base;\n+                  Carry := -1;\n+               else\n+                  Carry := 0;\n+               end if;\n+\n+               --  Most is now in [-Base + 1 .. Base - 1]\n+\n+               J := J - 2;\n+               Alt := Alt * Sign;\n+            end loop;\n+\n+            if J = Int_1 then\n+               Least_Sig_Int := Least_Sig_Int + Alt * (L_Vec (J) + Carry);\n+            else\n+               Least_Sig_Int := Least_Sig_Int + Alt * Carry;\n+            end if;\n+\n+            if Least_Sig_Int >= Base then\n+               Least_Sig_Int := Least_Sig_Int - Base;\n+               Most_Sig_Int := Most_Sig_Int + Alt * 1;\n+\n+            elsif Least_Sig_Int <= -Base then\n+               Least_Sig_Int := Least_Sig_Int + Base;\n+               Most_Sig_Int := Most_Sig_Int + Alt * (-1);\n+            end if;\n+\n+            if Most_Sig_Int >= Base then\n+               Most_Sig_Int := Most_Sig_Int - Base;\n+               Alt := Alt * Sign;\n+               Least_Sig_Int :=\n+                 Least_Sig_Int + Alt * 1; -- cannot overflow again\n+\n+            elsif Most_Sig_Int <= -Base then\n+               Most_Sig_Int := Most_Sig_Int + Base;\n+               Alt := Alt * Sign;\n+               Least_Sig_Int :=\n+                 Least_Sig_Int + Alt * (-1); --  cannot overflow again.\n+            end if;\n+\n+            return Most_Sig_Int * Base + Least_Sig_Int;\n+         end;\n+      end if;\n+   end Sum_Double_Digits;\n+\n+   ---------------\n+   -- Tree_Read --\n+   ---------------\n+\n+   procedure Tree_Read is\n+   begin\n+      Uints.Tree_Read;\n+      Udigits.Tree_Read;\n+\n+      Tree_Read_Int (Int (Uint_Int_First));\n+      Tree_Read_Int (Int (Uint_Int_Last));\n+      Tree_Read_Int (UI_Power_2_Set);\n+      Tree_Read_Int (UI_Power_10_Set);\n+      Tree_Read_Int (Int (Uints_Min));\n+      Tree_Read_Int (Udigits_Min);\n+\n+      for J in 0 .. UI_Power_2_Set loop\n+         Tree_Read_Int (Int (UI_Power_2 (J)));\n+      end loop;\n+\n+      for J in 0 .. UI_Power_10_Set loop\n+         Tree_Read_Int (Int (UI_Power_10 (J)));\n+      end loop;\n+\n+   end Tree_Read;\n+\n+   ----------------\n+   -- Tree_Write --\n+   ----------------\n+\n+   procedure Tree_Write is\n+   begin\n+      Uints.Tree_Write;\n+      Udigits.Tree_Write;\n+\n+      Tree_Write_Int (Int (Uint_Int_First));\n+      Tree_Write_Int (Int (Uint_Int_Last));\n+      Tree_Write_Int (UI_Power_2_Set);\n+      Tree_Write_Int (UI_Power_10_Set);\n+      Tree_Write_Int (Int (Uints_Min));\n+      Tree_Write_Int (Udigits_Min);\n+\n+      for J in 0 .. UI_Power_2_Set loop\n+         Tree_Write_Int (Int (UI_Power_2 (J)));\n+      end loop;\n+\n+      for J in 0 .. UI_Power_10_Set loop\n+         Tree_Write_Int (Int (UI_Power_10 (J)));\n+      end loop;\n+\n+   end Tree_Write;\n+\n+   -------------\n+   -- UI_Abs --\n+   -------------\n+\n+   function UI_Abs (Right : Uint) return Uint is\n+   begin\n+      if Right < Uint_0 then\n+         return -Right;\n+      else\n+         return Right;\n+      end if;\n+   end UI_Abs;\n+\n+   -------------\n+   -- UI_Add --\n+   -------------\n+\n+   function UI_Add (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Add (UI_From_Int (Left), Right);\n+   end UI_Add;\n+\n+   function UI_Add (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Add (Left, UI_From_Int (Right));\n+   end UI_Add;\n+\n+   function UI_Add (Left : Uint; Right : Uint) return Uint is\n+   begin\n+      --  Simple cases of direct operands and addition of zero\n+\n+      if Direct (Left) then\n+         if Direct (Right) then\n+            return UI_From_Int (Direct_Val (Left) + Direct_Val (Right));\n+\n+         elsif Int (Left) = Int (Uint_0) then\n+            return Right;\n+         end if;\n+\n+      elsif Direct (Right) and then Int (Right) = Int (Uint_0) then\n+         return Left;\n+      end if;\n+\n+      --  Otherwise full circuit is needed\n+\n+      declare\n+         L_Length   : Int := N_Digits (Left);\n+         R_Length   : Int := N_Digits (Right);\n+         L_Vec      : UI_Vector (1 .. L_Length);\n+         R_Vec      : UI_Vector (1 .. R_Length);\n+         Sum_Length : Int;\n+         Tmp_Int    : Int;\n+         Carry      : Int;\n+         Borrow     : Int;\n+         X_Bigger   : Boolean := False;\n+         Y_Bigger   : Boolean := False;\n+         Result_Neg : Boolean := False;\n+\n+      begin\n+         Init_Operand (Left, L_Vec);\n+         Init_Operand (Right, R_Vec);\n+\n+         --  At least one of the two operands is in multi-digit form.\n+         --  Calculate the number of digits sufficient to hold result.\n+\n+         if L_Length > R_Length then\n+            Sum_Length := L_Length + 1;\n+            X_Bigger := True;\n+         else\n+            Sum_Length := R_Length + 1;\n+            if R_Length > L_Length then Y_Bigger := True; end if;\n+         end if;\n+\n+         --  Make copies of the absolute values of L_Vec and R_Vec into\n+         --  X and Y both with lengths equal to the maximum possibly\n+         --  needed. This makes looping over the digits much simpler.\n+\n+         declare\n+            X      : UI_Vector (1 .. Sum_Length);\n+            Y      : UI_Vector (1 .. Sum_Length);\n+            Tmp_UI : UI_Vector (1 .. Sum_Length);\n+\n+         begin\n+            for J in 1 .. Sum_Length - L_Length loop\n+               X (J) := 0;\n+            end loop;\n+\n+            X (Sum_Length - L_Length + 1) := abs L_Vec (1);\n+\n+            for J in 2 .. L_Length loop\n+               X (J + (Sum_Length - L_Length)) := L_Vec (J);\n+            end loop;\n+\n+            for J in 1 .. Sum_Length - R_Length loop\n+               Y (J) := 0;\n+            end loop;\n+\n+            Y (Sum_Length - R_Length + 1) := abs R_Vec (1);\n+\n+            for J in 2 .. R_Length loop\n+               Y (J + (Sum_Length - R_Length)) := R_Vec (J);\n+            end loop;\n+\n+            if (L_Vec (1) < Int_0) = (R_Vec (1) < Int_0) then\n+\n+               --  Same sign so just add\n+\n+               Carry := 0;\n+               for J in reverse 1 .. Sum_Length loop\n+                  Tmp_Int := X (J) + Y (J) + Carry;\n+\n+                  if Tmp_Int >= Base then\n+                     Tmp_Int := Tmp_Int - Base;\n+                     Carry := 1;\n+                  else\n+                     Carry := 0;\n+                  end if;\n+\n+                  X (J) := Tmp_Int;\n+               end loop;\n+\n+               return Vector_To_Uint (X, L_Vec (1) < Int_0);\n+\n+            else\n+               --  Find which one has bigger magnitude\n+\n+               if not (X_Bigger or Y_Bigger) then\n+                  for J in L_Vec'Range loop\n+                     if abs L_Vec (J) > abs R_Vec (J) then\n+                        X_Bigger := True;\n+                        exit;\n+                     elsif abs R_Vec (J) > abs L_Vec (J) then\n+                        Y_Bigger := True;\n+                        exit;\n+                     end if;\n+                  end loop;\n+               end if;\n+\n+               --  If they have identical magnitude, just return 0, else\n+               --  swap if necessary so that X had the bigger magnitude.\n+               --  Determine if result is negative at this time.\n+\n+               Result_Neg := False;\n+\n+               if not (X_Bigger or Y_Bigger) then\n+                  return Uint_0;\n+\n+               elsif Y_Bigger then\n+                  if R_Vec (1) < Int_0 then\n+                     Result_Neg := True;\n+                  end if;\n+\n+                  Tmp_UI := X;\n+                  X := Y;\n+                  Y := Tmp_UI;\n+\n+               else\n+                  if L_Vec (1) < Int_0 then\n+                     Result_Neg := True;\n+                  end if;\n+               end if;\n+\n+               --  Subtract Y from the bigger X\n+\n+               Borrow := 0;\n+\n+               for J in reverse 1 .. Sum_Length loop\n+                  Tmp_Int := X (J) - Y (J) + Borrow;\n+\n+                  if Tmp_Int < Int_0 then\n+                     Tmp_Int := Tmp_Int + Base;\n+                     Borrow := -1;\n+                  else\n+                     Borrow := 0;\n+                  end if;\n+\n+                  X (J) := Tmp_Int;\n+               end loop;\n+\n+               return Vector_To_Uint (X, Result_Neg);\n+\n+            end if;\n+         end;\n+      end;\n+   end UI_Add;\n+\n+   --------------------------\n+   -- UI_Decimal_Digits_Hi --\n+   --------------------------\n+\n+   function UI_Decimal_Digits_Hi (U : Uint) return Nat is\n+   begin\n+      --  The maximum value of a \"digit\" is 32767, which is 5 decimal\n+      --  digits, so an N_Digit number could take up to 5 times this\n+      --  number of digits. This is certainly too high for large\n+      --  numbers but it is not worth worrying about.\n+\n+      return 5 * N_Digits (U);\n+   end UI_Decimal_Digits_Hi;\n+\n+   --------------------------\n+   -- UI_Decimal_Digits_Lo --\n+   --------------------------\n+\n+   function UI_Decimal_Digits_Lo (U : Uint) return Nat is\n+   begin\n+      --  The maximum value of a \"digit\" is 32767, which is more than four\n+      --  decimal digits, but not a full five digits. The easily computed\n+      --  minimum number of decimal digits is thus 1 + 4 * the number of\n+      --  digits. This is certainly too low for large numbers but it is\n+      --  not worth worrying about.\n+\n+      return 1 + 4 * (N_Digits (U) - 1);\n+   end UI_Decimal_Digits_Lo;\n+\n+   ------------\n+   -- UI_Div --\n+   ------------\n+\n+   function UI_Div (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Div (UI_From_Int (Left), Right);\n+   end UI_Div;\n+\n+   function UI_Div (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Div (Left, UI_From_Int (Right));\n+   end UI_Div;\n+\n+   function UI_Div (Left, Right : Uint) return Uint is\n+   begin\n+      pragma Assert (Right /= Uint_0);\n+\n+      --  Cases where both operands are represented directly\n+\n+      if Direct (Left) and then Direct (Right) then\n+         return UI_From_Int (Direct_Val (Left) / Direct_Val (Right));\n+      end if;\n+\n+      declare\n+         L_Length    : constant Int := N_Digits (Left);\n+         R_Length    : constant Int := N_Digits (Right);\n+         Q_Length    : constant Int := L_Length - R_Length + 1;\n+         L_Vec       : UI_Vector (1 .. L_Length);\n+         R_Vec       : UI_Vector (1 .. R_Length);\n+         D           : Int;\n+         Remainder   : Int;\n+         Tmp_Divisor : Int;\n+         Carry       : Int;\n+         Tmp_Int     : Int;\n+         Tmp_Dig     : Int;\n+\n+      begin\n+         --  Result is zero if left operand is shorter than right\n+\n+         if L_Length < R_Length then\n+            return Uint_0;\n+         end if;\n+\n+         Init_Operand (Left, L_Vec);\n+         Init_Operand (Right, R_Vec);\n+\n+         --  Case of right operand is single digit. Here we can simply divide\n+         --  each digit of the left operand by the divisor, from most to least\n+         --  significant, carrying the remainder to the next digit (just like\n+         --  ordinary long division by hand).\n+\n+         if R_Length = Int_1 then\n+            Remainder := 0;\n+            Tmp_Divisor := abs R_Vec (1);\n+\n+            declare\n+               Quotient : UI_Vector (1 .. L_Length);\n+\n+            begin\n+               for J in L_Vec'Range loop\n+                  Tmp_Int      := Remainder * Base + abs L_Vec (J);\n+                  Quotient (J) := Tmp_Int / Tmp_Divisor;\n+                  Remainder    := Tmp_Int rem Tmp_Divisor;\n+               end loop;\n+\n+               return\n+                 Vector_To_Uint\n+                   (Quotient, (L_Vec (1) < Int_0 xor R_Vec (1) < Int_0));\n+            end;\n+         end if;\n+\n+         --  The possible simple cases have been exhausted. Now turn to the\n+         --  algorithm D from the section of Knuth mentioned at the top of\n+         --  this package.\n+\n+         Algorithm_D : declare\n+            Dividend     : UI_Vector (1 .. L_Length + 1);\n+            Divisor      : UI_Vector (1 .. R_Length);\n+            Quotient     : UI_Vector (1 .. Q_Length);\n+            Divisor_Dig1 : Int;\n+            Divisor_Dig2 : Int;\n+            Q_Guess      : Int;\n+\n+         begin\n+            --  [ NORMALIZE ] (step D1 in the algorithm). First calculate the\n+            --  scale d, and then multiply Left and Right (u and v in the book)\n+            --  by d to get the dividend and divisor to work with.\n+\n+            D := Base / (abs R_Vec (1) + 1);\n+\n+            Dividend (1) := 0;\n+            Dividend (2) := abs L_Vec (1);\n+\n+            for J in 3 .. L_Length + Int_1 loop\n+               Dividend (J) := L_Vec (J - 1);\n+            end loop;\n+\n+            Divisor (1) := abs R_Vec (1);\n+\n+            for J in Int_2 .. R_Length loop\n+               Divisor (J) := R_Vec (J);\n+            end loop;\n+\n+            if D > Int_1 then\n+\n+               --  Multiply Dividend by D\n+\n+               Carry := 0;\n+               for J in reverse Dividend'Range loop\n+                  Tmp_Int      := Dividend (J) * D + Carry;\n+                  Dividend (J) := Tmp_Int rem Base;\n+                  Carry        := Tmp_Int / Base;\n+               end loop;\n+\n+               --  Multiply Divisor by d.\n+\n+               Carry := 0;\n+               for J in reverse Divisor'Range loop\n+                  Tmp_Int      := Divisor (J) * D + Carry;\n+                  Divisor (J)  := Tmp_Int rem Base;\n+                  Carry        := Tmp_Int / Base;\n+               end loop;\n+            end if;\n+\n+            --  Main loop of long division algorithm.\n+\n+            Divisor_Dig1 := Divisor (1);\n+            Divisor_Dig2 := Divisor (2);\n+\n+            for J in Quotient'Range loop\n+\n+               --  [ CALCULATE Q (hat) ] (step D3 in the algorithm).\n+\n+               Tmp_Int := Dividend (J) * Base + Dividend (J + 1);\n+\n+               --  Initial guess\n+\n+               if Dividend (J) = Divisor_Dig1 then\n+                  Q_Guess := Base - 1;\n+               else\n+                  Q_Guess := Tmp_Int / Divisor_Dig1;\n+               end if;\n+\n+               --  Refine the guess\n+\n+               while Divisor_Dig2 * Q_Guess >\n+                     (Tmp_Int - Q_Guess * Divisor_Dig1) * Base +\n+                                                          Dividend (J + 2)\n+               loop\n+                  Q_Guess := Q_Guess - 1;\n+               end loop;\n+\n+               --  [ MULTIPLY & SUBTRACT] (step D4). Q_Guess * Divisor is\n+               --  subtracted from the remaining dividend.\n+\n+               Carry := 0;\n+               for K in reverse Divisor'Range loop\n+                  Tmp_Int := Dividend (J + K) - Q_Guess * Divisor (K) + Carry;\n+                  Tmp_Dig := Tmp_Int rem Base;\n+                  Carry   := Tmp_Int / Base;\n+\n+                  if Tmp_Dig < Int_0 then\n+                     Tmp_Dig := Tmp_Dig + Base;\n+                     Carry   := Carry - 1;\n+                  end if;\n+\n+                  Dividend (J + K) := Tmp_Dig;\n+               end loop;\n+\n+               Dividend (J) := Dividend (J) + Carry;\n+\n+               --  [ TEST REMAINDER ] & [ ADD BACK ] (steps D5 and D6)\n+               --  Here there is a slight difference from the book: the last\n+               --  carry is always added in above and below (cancelling each\n+               --  other). In fact the dividend going negative is used as\n+               --  the test.\n+\n+               --  If the Dividend went negative, then Q_Guess was off by\n+               --  one, so it is decremented, and the divisor is added back\n+               --  into the relevant portion of the dividend.\n+\n+               if Dividend (J) < Int_0 then\n+                  Q_Guess := Q_Guess - 1;\n+\n+                  Carry := 0;\n+                  for K in reverse Divisor'Range loop\n+                     Tmp_Int := Dividend (J + K) + Divisor (K) + Carry;\n+\n+                     if Tmp_Int >= Base then\n+                        Tmp_Int := Tmp_Int - Base;\n+                        Carry := 1;\n+                     else\n+                        Carry := 0;\n+                     end if;\n+\n+                     Dividend (J + K) := Tmp_Int;\n+                  end loop;\n+\n+                  Dividend (J) := Dividend (J) + Carry;\n+               end if;\n+\n+               --  Finally we can get the next quotient digit\n+\n+               Quotient (J) := Q_Guess;\n+            end loop;\n+\n+            return Vector_To_Uint\n+              (Quotient, (L_Vec (1) < Int_0 xor R_Vec (1) < Int_0));\n+\n+         end Algorithm_D;\n+      end;\n+   end UI_Div;\n+\n+   ------------\n+   -- UI_Eq --\n+   ------------\n+\n+   function UI_Eq (Left : Int; Right : Uint) return Boolean is\n+   begin\n+      return not UI_Ne (UI_From_Int (Left), Right);\n+   end UI_Eq;\n+\n+   function UI_Eq (Left : Uint; Right : Int) return Boolean is\n+   begin\n+      return not UI_Ne (Left, UI_From_Int (Right));\n+   end UI_Eq;\n+\n+   function UI_Eq (Left : Uint; Right : Uint) return Boolean is\n+   begin\n+      return not UI_Ne (Left, Right);\n+   end UI_Eq;\n+\n+   --------------\n+   -- UI_Expon --\n+   --------------\n+\n+   function UI_Expon (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Expon (UI_From_Int (Left), Right);\n+   end UI_Expon;\n+\n+   function UI_Expon (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Expon (Left, UI_From_Int (Right));\n+   end UI_Expon;\n+\n+   function UI_Expon (Left : Int; Right : Int) return Uint is\n+   begin\n+      return UI_Expon (UI_From_Int (Left), UI_From_Int (Right));\n+   end UI_Expon;\n+\n+   function UI_Expon (Left : Uint; Right : Uint) return Uint is\n+   begin\n+      pragma Assert (Right >= Uint_0);\n+\n+      --  Any value raised to power of 0 is 1\n+\n+      if Right = Uint_0 then\n+         return Uint_1;\n+\n+      --  0 to any positive power is 0.\n+\n+      elsif Left = Uint_0 then\n+         return Uint_0;\n+\n+      --  1 to any power is 1\n+\n+      elsif Left = Uint_1 then\n+         return Uint_1;\n+\n+      --  Any value raised to power of 1 is that value\n+\n+      elsif Right = Uint_1 then\n+         return Left;\n+\n+      --  Cases which can be done by table lookup\n+\n+      elsif Right <= Uint_64 then\n+\n+         --  2 ** N for N in 2 .. 64\n+\n+         if Left = Uint_2 then\n+            declare\n+               Right_Int : constant Int := Direct_Val (Right);\n+\n+            begin\n+               if Right_Int > UI_Power_2_Set then\n+                  for J in UI_Power_2_Set + Int_1 .. Right_Int loop\n+                     UI_Power_2 (J) := UI_Power_2 (J - Int_1) * Int_2;\n+                     Uints_Min := Uints.Last;\n+                     Udigits_Min := Udigits.Last;\n+                  end loop;\n+\n+                  UI_Power_2_Set := Right_Int;\n+               end if;\n+\n+               return UI_Power_2 (Right_Int);\n+            end;\n+\n+         --  10 ** N for N in 2 .. 64\n+\n+         elsif Left = Uint_10 then\n+            declare\n+               Right_Int : constant Int := Direct_Val (Right);\n+\n+            begin\n+               if Right_Int > UI_Power_10_Set then\n+                  for J in UI_Power_10_Set + Int_1 .. Right_Int loop\n+                     UI_Power_10 (J) := UI_Power_10 (J - Int_1) * Int (10);\n+                     Uints_Min := Uints.Last;\n+                     Udigits_Min := Udigits.Last;\n+                  end loop;\n+\n+                  UI_Power_10_Set := Right_Int;\n+               end if;\n+\n+               return UI_Power_10 (Right_Int);\n+            end;\n+         end if;\n+      end if;\n+\n+      --  If we fall through, then we have the general case (see Knuth 4.6.3)\n+\n+      declare\n+         N       : Uint := Right;\n+         Squares : Uint := Left;\n+         Result  : Uint := Uint_1;\n+         M       : constant Uintp.Save_Mark := Uintp.Mark;\n+\n+      begin\n+         loop\n+            if (Least_Sig_Digit (N) mod Int_2) = Int_1 then\n+               Result := Result * Squares;\n+            end if;\n+\n+            N := N / Uint_2;\n+            exit when N = Uint_0;\n+            Squares := Squares *  Squares;\n+         end loop;\n+\n+         Uintp.Release_And_Save (M, Result);\n+         return Result;\n+      end;\n+   end UI_Expon;\n+\n+   ------------------\n+   -- UI_From_Dint --\n+   ------------------\n+\n+   function UI_From_Dint (Input : Dint) return Uint is\n+   begin\n+\n+      if Dint (Min_Direct) <= Input and then Input <= Dint (Max_Direct) then\n+         return Uint (Dint (Uint_Direct_Bias) + Input);\n+\n+      --  For values of larger magnitude, compute digits into a vector and\n+      --  call Vector_To_Uint.\n+\n+      else\n+         declare\n+            Max_For_Dint : constant := 5;\n+            --  Base is defined so that 5 Uint digits is sufficient\n+            --  to hold the largest possible Dint value.\n+\n+            V : UI_Vector (1 .. Max_For_Dint);\n+\n+            Temp_Integer : Dint;\n+\n+         begin\n+            for J in V'Range loop\n+               V (J) := 0;\n+            end loop;\n+\n+            Temp_Integer := Input;\n+\n+            for J in reverse V'Range loop\n+               V (J) := Int (abs (Temp_Integer rem Dint (Base)));\n+               Temp_Integer := Temp_Integer / Dint (Base);\n+            end loop;\n+\n+            return Vector_To_Uint (V, Input < Dint'(0));\n+         end;\n+      end if;\n+   end UI_From_Dint;\n+\n+   -----------------\n+   -- UI_From_Int --\n+   -----------------\n+\n+   function UI_From_Int (Input : Int) return Uint is\n+   begin\n+\n+      if Min_Direct <= Input and then Input <= Max_Direct then\n+         return Uint (Int (Uint_Direct_Bias) + Input);\n+\n+      --  For values of larger magnitude, compute digits into a vector and\n+      --  call Vector_To_Uint.\n+\n+      else\n+         declare\n+            Max_For_Int : constant := 3;\n+            --  Base is defined so that 3 Uint digits is sufficient\n+            --  to hold the largest possible Int value.\n+\n+            V : UI_Vector (1 .. Max_For_Int);\n+\n+            Temp_Integer : Int;\n+\n+         begin\n+            for J in V'Range loop\n+               V (J) := 0;\n+            end loop;\n+\n+            Temp_Integer := Input;\n+\n+            for J in reverse V'Range loop\n+               V (J) := abs (Temp_Integer rem Base);\n+               Temp_Integer := Temp_Integer / Base;\n+            end loop;\n+\n+            return Vector_To_Uint (V, Input < Int_0);\n+         end;\n+      end if;\n+   end UI_From_Int;\n+\n+   ------------\n+   -- UI_GCD --\n+   ------------\n+\n+   --  Lehmer's algorithm for GCD.\n+\n+   --  The idea is to avoid using multiple precision arithmetic wherever\n+   --  possible, substituting Int arithmetic instead. See Knuth volume II,\n+   --  Algorithm L (page 329).\n+\n+   --  We use the same notation as Knuth (U_Hat standing for the obvious!)\n+\n+   function UI_GCD (Uin, Vin : Uint) return Uint is\n+      U, V : Uint;\n+      --  Copies of Uin and Vin\n+\n+      U_Hat, V_Hat : Int;\n+      --  The most Significant digits of U,V\n+\n+      A, B, C, D, T, Q, Den1, Den2 : Int;\n+\n+      Tmp_UI : Uint;\n+      Marks  : constant Uintp.Save_Mark := Uintp.Mark;\n+      Iterations : Integer := 0;\n+\n+   begin\n+      pragma Assert (Uin >= Vin);\n+      pragma Assert (Vin >= Uint_0);\n+\n+      U := Uin;\n+      V := Vin;\n+\n+      loop\n+         Iterations := Iterations + 1;\n+\n+         if Direct (V) then\n+            if V = Uint_0 then\n+               return U;\n+            else\n+               return\n+                 UI_From_Int (GCD (Direct_Val (V), UI_To_Int (U rem V)));\n+            end if;\n+         end if;\n+\n+         Most_Sig_2_Digits (U, V, U_Hat, V_Hat);\n+         A := 1;\n+         B := 0;\n+         C := 0;\n+         D := 1;\n+\n+         loop\n+            --  We might overflow and get division by zero here. This just\n+            --  means we can not take the single precision step\n+\n+            Den1 := V_Hat + C;\n+            Den2 := V_Hat + D;\n+            exit when (Den1 * Den2) = Int_0;\n+\n+            --  Compute Q, the trial quotient\n+\n+            Q := (U_Hat + A) / Den1;\n+\n+            exit when Q /= ((U_Hat + B) / Den2);\n+\n+            --  A single precision step Euclid step will give same answer as\n+            --  a multiprecision one.\n+\n+            T := A - (Q * C);\n+            A := C;\n+            C := T;\n+\n+            T := B - (Q * D);\n+            B := D;\n+            D := T;\n+\n+            T := U_Hat - (Q * V_Hat);\n+            U_Hat := V_Hat;\n+            V_Hat := T;\n+\n+         end loop;\n+\n+         --  Take a multiprecision Euclid step\n+\n+         if B = Int_0 then\n+\n+            --  No single precision steps take a regular Euclid step.\n+\n+            Tmp_UI := U rem V;\n+            U := V;\n+            V := Tmp_UI;\n+\n+         else\n+            --  Use prior single precision steps to compute this Euclid step.\n+\n+            --  Fixed bug 1415-008 spends 80% of its time working on this\n+            --  step. Perhaps we need a special case Int / Uint dot\n+            --  product to speed things up. ???\n+\n+            --  Alternatively we could increase the single precision\n+            --  iterations to handle Uint's of some small size ( <5\n+            --  digits?). Then we would have more iterations on small Uint.\n+            --  Fixed bug 1415-008 only gets 5 (on average) single\n+            --  precision iterations per large iteration. ???\n+\n+            Tmp_UI := (UI_From_Int (A) * U) + (UI_From_Int (B) * V);\n+            V := (UI_From_Int (C) * U) + (UI_From_Int (D) * V);\n+            U := Tmp_UI;\n+         end if;\n+\n+         --  If the operands are very different in magnitude, the loop\n+         --  will generate large amounts of short-lived data, which it is\n+         --  worth removing periodically.\n+\n+         if Iterations > 100 then\n+            Release_And_Save (Marks, U, V);\n+            Iterations := 0;\n+         end if;\n+      end loop;\n+   end UI_GCD;\n+\n+   ------------\n+   -- UI_Ge --\n+   ------------\n+\n+   function UI_Ge (Left : Int; Right : Uint) return Boolean is\n+   begin\n+      return not UI_Lt (UI_From_Int (Left), Right);\n+   end UI_Ge;\n+\n+   function UI_Ge (Left : Uint; Right : Int) return Boolean is\n+   begin\n+      return not UI_Lt (Left, UI_From_Int (Right));\n+   end UI_Ge;\n+\n+   function UI_Ge (Left : Uint; Right : Uint) return Boolean is\n+   begin\n+      return not UI_Lt (Left, Right);\n+   end UI_Ge;\n+\n+   ------------\n+   -- UI_Gt --\n+   ------------\n+\n+   function UI_Gt (Left : Int; Right : Uint) return Boolean is\n+   begin\n+      return UI_Lt (Right, UI_From_Int (Left));\n+   end UI_Gt;\n+\n+   function UI_Gt (Left : Uint; Right : Int) return Boolean is\n+   begin\n+      return UI_Lt (UI_From_Int (Right), Left);\n+   end UI_Gt;\n+\n+   function UI_Gt (Left : Uint; Right : Uint) return Boolean is\n+   begin\n+      return UI_Lt (Right, Left);\n+   end UI_Gt;\n+\n+   ---------------\n+   -- UI_Image --\n+   ---------------\n+\n+   procedure UI_Image (Input : Uint; Format : UI_Format := Auto) is\n+   begin\n+      Image_Out (Input, True, Format);\n+   end UI_Image;\n+\n+   -------------------------\n+   -- UI_Is_In_Int_Range --\n+   -------------------------\n+\n+   function UI_Is_In_Int_Range (Input : Uint) return Boolean is\n+   begin\n+      --  Make sure we don't get called before Initialize\n+\n+      pragma Assert (Uint_Int_First /= Uint_0);\n+\n+      if Direct (Input) then\n+         return True;\n+      else\n+         return Input >= Uint_Int_First\n+           and then Input <= Uint_Int_Last;\n+      end if;\n+   end UI_Is_In_Int_Range;\n+\n+   ------------\n+   -- UI_Le --\n+   ------------\n+\n+   function UI_Le (Left : Int; Right : Uint) return Boolean is\n+   begin\n+      return not UI_Lt (Right, UI_From_Int (Left));\n+   end UI_Le;\n+\n+   function UI_Le (Left : Uint; Right : Int) return Boolean is\n+   begin\n+      return not UI_Lt (UI_From_Int (Right), Left);\n+   end UI_Le;\n+\n+   function UI_Le (Left : Uint; Right : Uint) return Boolean is\n+   begin\n+      return not UI_Lt (Right, Left);\n+   end UI_Le;\n+\n+   ------------\n+   -- UI_Lt --\n+   ------------\n+\n+   function UI_Lt (Left : Int; Right : Uint) return Boolean is\n+   begin\n+      return UI_Lt (UI_From_Int (Left), Right);\n+   end UI_Lt;\n+\n+   function UI_Lt (Left : Uint; Right : Int) return Boolean is\n+   begin\n+      return UI_Lt (Left, UI_From_Int (Right));\n+   end UI_Lt;\n+\n+   function UI_Lt (Left : Uint; Right : Uint) return Boolean is\n+   begin\n+      --  Quick processing for identical arguments\n+\n+      if Int (Left) = Int (Right) then\n+         return False;\n+\n+      --  Quick processing for both arguments directly represented\n+\n+      elsif Direct (Left) and then Direct (Right) then\n+         return Int (Left) < Int (Right);\n+\n+      --  At least one argument is more than one digit long\n+\n+      else\n+         declare\n+            L_Length : constant Int := N_Digits (Left);\n+            R_Length : constant Int := N_Digits (Right);\n+\n+            L_Vec : UI_Vector (1 .. L_Length);\n+            R_Vec : UI_Vector (1 .. R_Length);\n+\n+         begin\n+            Init_Operand (Left, L_Vec);\n+            Init_Operand (Right, R_Vec);\n+\n+            if L_Vec (1) < Int_0 then\n+\n+               --  First argument negative, second argument non-negative\n+\n+               if R_Vec (1) >= Int_0 then\n+                  return True;\n+\n+               --  Both arguments negative\n+\n+               else\n+                  if L_Length /= R_Length then\n+                     return L_Length > R_Length;\n+\n+                  elsif L_Vec (1) /= R_Vec (1) then\n+                     return L_Vec (1) < R_Vec (1);\n+\n+                  else\n+                     for J in 2 .. L_Vec'Last loop\n+                        if L_Vec (J) /= R_Vec (J) then\n+                           return L_Vec (J) > R_Vec (J);\n+                        end if;\n+                     end loop;\n+\n+                     return False;\n+                  end if;\n+               end if;\n+\n+            else\n+               --  First argument non-negative, second argument negative\n+\n+               if R_Vec (1) < Int_0 then\n+                  return False;\n+\n+               --  Both arguments non-negative\n+\n+               else\n+                  if L_Length /= R_Length then\n+                     return L_Length < R_Length;\n+                  else\n+                     for J in L_Vec'Range loop\n+                        if L_Vec (J) /= R_Vec (J) then\n+                           return L_Vec (J) < R_Vec (J);\n+                        end if;\n+                     end loop;\n+\n+                     return False;\n+                  end if;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+   end UI_Lt;\n+\n+   ------------\n+   -- UI_Max --\n+   ------------\n+\n+   function UI_Max (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Max (UI_From_Int (Left), Right);\n+   end UI_Max;\n+\n+   function UI_Max (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Max (Left, UI_From_Int (Right));\n+   end UI_Max;\n+\n+   function UI_Max (Left : Uint; Right : Uint) return Uint is\n+   begin\n+      if Left >= Right then\n+         return Left;\n+      else\n+         return Right;\n+      end if;\n+   end UI_Max;\n+\n+   ------------\n+   -- UI_Min --\n+   ------------\n+\n+   function UI_Min (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Min (UI_From_Int (Left), Right);\n+   end UI_Min;\n+\n+   function UI_Min (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Min (Left, UI_From_Int (Right));\n+   end UI_Min;\n+\n+   function UI_Min (Left : Uint; Right : Uint) return Uint is\n+   begin\n+      if Left <= Right then\n+         return Left;\n+      else\n+         return Right;\n+      end if;\n+   end UI_Min;\n+\n+   -------------\n+   -- UI_Mod --\n+   -------------\n+\n+   function UI_Mod (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Mod (UI_From_Int (Left), Right);\n+   end UI_Mod;\n+\n+   function UI_Mod (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Mod (Left, UI_From_Int (Right));\n+   end UI_Mod;\n+\n+   function UI_Mod (Left : Uint; Right : Uint) return Uint is\n+      Urem : constant Uint := Left rem Right;\n+\n+   begin\n+      if (Left < Uint_0) = (Right < Uint_0)\n+        or else Urem = Uint_0\n+      then\n+         return Urem;\n+      else\n+         return Right + Urem;\n+      end if;\n+   end UI_Mod;\n+\n+   ------------\n+   -- UI_Mul --\n+   ------------\n+\n+   function UI_Mul (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Mul (UI_From_Int (Left), Right);\n+   end UI_Mul;\n+\n+   function UI_Mul (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Mul (Left, UI_From_Int (Right));\n+   end UI_Mul;\n+\n+   function UI_Mul (Left : Uint; Right : Uint) return Uint is\n+   begin\n+      --  Simple case of single length operands\n+\n+      if Direct (Left) and then Direct (Right) then\n+         return\n+           UI_From_Dint\n+             (Dint (Direct_Val (Left)) * Dint (Direct_Val (Right)));\n+      end if;\n+\n+      --  Otherwise we have the general case (Algorithm M in Knuth)\n+\n+      declare\n+         L_Length : constant Int := N_Digits (Left);\n+         R_Length : constant Int := N_Digits (Right);\n+         L_Vec    : UI_Vector (1 .. L_Length);\n+         R_Vec    : UI_Vector (1 .. R_Length);\n+         Neg      : Boolean;\n+\n+      begin\n+         Init_Operand (Left, L_Vec);\n+         Init_Operand (Right, R_Vec);\n+         Neg := (L_Vec (1) < Int_0) xor (R_Vec (1) < Int_0);\n+         L_Vec (1) := abs (L_Vec (1));\n+         R_Vec (1) := abs (R_Vec (1));\n+\n+         Algorithm_M : declare\n+            Product : UI_Vector (1 .. L_Length + R_Length);\n+            Tmp_Sum : Int;\n+            Carry   : Int;\n+\n+         begin\n+            for J in Product'Range loop\n+               Product (J) := 0;\n+            end loop;\n+\n+            for J in reverse R_Vec'Range loop\n+               Carry := 0;\n+               for K in reverse L_Vec'Range loop\n+                  Tmp_Sum :=\n+                    L_Vec (K) * R_Vec (J) + Product (J + K) + Carry;\n+                  Product (J + K) := Tmp_Sum rem Base;\n+                  Carry := Tmp_Sum / Base;\n+               end loop;\n+\n+               Product (J) := Carry;\n+            end loop;\n+\n+            return Vector_To_Uint (Product, Neg);\n+         end Algorithm_M;\n+      end;\n+   end UI_Mul;\n+\n+   ------------\n+   -- UI_Ne --\n+   ------------\n+\n+   function UI_Ne (Left : Int; Right : Uint) return Boolean is\n+   begin\n+      return UI_Ne (UI_From_Int (Left), Right);\n+   end UI_Ne;\n+\n+   function UI_Ne (Left : Uint; Right : Int) return Boolean is\n+   begin\n+      return UI_Ne (Left, UI_From_Int (Right));\n+   end UI_Ne;\n+\n+   function UI_Ne (Left : Uint; Right : Uint) return Boolean is\n+   begin\n+      --  Quick processing for identical arguments. Note that this takes\n+      --  care of the case of two No_Uint arguments.\n+\n+      if Int (Left) = Int (Right) then\n+         return False;\n+      end if;\n+\n+      --  See if left operand directly represented\n+\n+      if Direct (Left) then\n+\n+         --  If right operand directly represented then compare\n+\n+         if Direct (Right) then\n+            return Int (Left) /= Int (Right);\n+\n+         --  Left operand directly represented, right not, must be unequal\n+\n+         else\n+            return True;\n+         end if;\n+\n+      --  Right operand directly represented, left not, must be unequal\n+\n+      elsif Direct (Right) then\n+         return True;\n+      end if;\n+\n+      --  Otherwise both multi-word, do comparison\n+\n+      declare\n+         Size      : constant Int := N_Digits (Left);\n+         Left_Loc  : Int;\n+         Right_Loc : Int;\n+\n+      begin\n+         if Size /= N_Digits (Right) then\n+            return True;\n+         end if;\n+\n+         Left_Loc  := Uints.Table (Left).Loc;\n+         Right_Loc := Uints.Table (Right).Loc;\n+\n+         for J in Int_0 .. Size - Int_1 loop\n+            if Udigits.Table (Left_Loc + J) /=\n+               Udigits.Table (Right_Loc + J)\n+            then\n+               return True;\n+            end if;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end UI_Ne;\n+\n+   ----------------\n+   -- UI_Negate --\n+   ----------------\n+\n+   function UI_Negate (Right : Uint) return Uint is\n+   begin\n+      --  Case where input is directly represented. Note that since the\n+      --  range of Direct values is non-symmetrical, the result may not\n+      --  be directly represented, this is taken care of in UI_From_Int.\n+\n+      if Direct (Right) then\n+         return UI_From_Int (-Direct_Val (Right));\n+\n+      --  Full processing for multi-digit case. Note that we cannot just\n+      --  copy the value to the end of the table negating the first digit,\n+      --  since the range of Direct values is non-symmetrical, so we can\n+      --  have a negative value that is not Direct whose negation can be\n+      --  represented directly.\n+\n+      else\n+         declare\n+            R_Length : constant Int := N_Digits (Right);\n+            R_Vec    : UI_Vector (1 .. R_Length);\n+            Neg      : Boolean;\n+\n+         begin\n+            Init_Operand (Right, R_Vec);\n+            Neg := R_Vec (1) > Int_0;\n+            R_Vec (1) := abs R_Vec (1);\n+            return Vector_To_Uint (R_Vec, Neg);\n+         end;\n+      end if;\n+   end UI_Negate;\n+\n+   -------------\n+   -- UI_Rem --\n+   -------------\n+\n+   function UI_Rem (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Rem (UI_From_Int (Left), Right);\n+   end UI_Rem;\n+\n+   function UI_Rem (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Rem (Left, UI_From_Int (Right));\n+   end UI_Rem;\n+\n+   function UI_Rem (Left, Right : Uint) return Uint is\n+      Sign : Int;\n+      Tmp  : Int;\n+\n+      subtype Int1_12 is Integer range 1 .. 12;\n+\n+   begin\n+      pragma Assert (Right /= Uint_0);\n+\n+      if Direct (Right) then\n+         if Direct (Left) then\n+            return UI_From_Int (Direct_Val (Left) rem Direct_Val (Right));\n+\n+         else\n+            --  Special cases when Right is less than 13 and Left is larger\n+            --  larger than one digit. All of these algorithms depend on the\n+            --  base being 2 ** 15 We work with Abs (Left) and Abs(Right)\n+            --  then multiply result by Sign (Left)\n+\n+            if (Right <= Uint_12) and then (Right >= Uint_Minus_12) then\n+\n+               if (Left < Uint_0) then\n+                  Sign := -1;\n+               else\n+                  Sign := 1;\n+               end if;\n+\n+               --  All cases are listed, grouped by mathematical method\n+               --  It is not inefficient to do have this case list out\n+               --  of order since GCC sorts the cases we list.\n+\n+               case Int1_12 (abs (Direct_Val (Right))) is\n+\n+                  when 1 =>\n+                     return Uint_0;\n+\n+                  --  Powers of two are simple AND's with LS Left Digit\n+                  --  GCC will recognise these constants as powers of 2\n+                  --  and replace the rem with simpler operations where\n+                  --  possible.\n+\n+                  --  Least_Sig_Digit might return Negative numbers.\n+\n+                  when 2 =>\n+                     return UI_From_Int (\n+                        Sign * (Least_Sig_Digit (Left) mod 2));\n+\n+                  when 4 =>\n+                     return UI_From_Int (\n+                        Sign * (Least_Sig_Digit (Left) mod 4));\n+\n+                  when 8 =>\n+                     return UI_From_Int (\n+                        Sign * (Least_Sig_Digit (Left) mod 8));\n+\n+                  --  Some number theoretical tricks:\n+\n+                  --    If B Rem Right = 1 then\n+                  --    Left Rem Right = Sum_Of_Digits_Base_B (Left) Rem Right\n+\n+                  --  Note: 2^32 mod 3 = 1\n+\n+                  when 3 =>\n+                     return UI_From_Int (\n+                        Sign * (Sum_Double_Digits (Left, 1) rem Int (3)));\n+\n+                  --  Note: 2^15 mod 7 = 1\n+\n+                  when 7 =>\n+                     return UI_From_Int (\n+                        Sign * (Sum_Digits (Left, 1) rem Int (7)));\n+\n+                  --  Note: 2^32 mod 5 = -1\n+                  --  Alternating sums might be negative, but rem is always\n+                  --  positive hence we must use mod here.\n+\n+                  when 5 =>\n+                     Tmp := Sum_Double_Digits (Left, -1) mod Int (5);\n+                     return UI_From_Int (Sign * Tmp);\n+\n+                  --  Note: 2^15 mod 9 = -1\n+                  --  Alternating sums might be negative, but rem is always\n+                  --  positive hence we must use mod here.\n+\n+                  when 9  =>\n+                     Tmp := Sum_Digits (Left, -1) mod Int (9);\n+                     return UI_From_Int (Sign * Tmp);\n+\n+                  --  Note: 2^15 mod 11 = -1\n+                  --  Alternating sums might be negative, but rem is always\n+                  --  positive hence we must use mod here.\n+\n+                  when 11 =>\n+                     Tmp := Sum_Digits (Left, -1) mod Int (11);\n+                     return UI_From_Int (Sign * Tmp);\n+\n+                  --  Now resort to Chinese Remainder theorem\n+                  --  to reduce 6, 10, 12 to previous special cases\n+\n+                  --  There is no reason we could not add more cases\n+                  --  like these if it proves useful.\n+\n+                  --  Perhaps we should go up to 16, however\n+                  --  I have no \"trick\" for 13.\n+\n+                  --  To find u mod m we:\n+                  --  Pick m1, m2 S.T.\n+                  --     GCD(m1, m2) = 1 AND m = (m1 * m2).\n+                  --  Next we pick (Basis) M1, M2 small S.T.\n+                  --     (M1 mod m1) = (M2 mod m2) = 1 AND\n+                  --     (M1 mod m2) = (M2 mod m1) = 0\n+\n+                  --  So u mod m  = (u1 * M1 + u2 * M2) mod m\n+                  --  Where u1 = (u mod m1) AND u2 = (u mod m2);\n+                  --  Under typical circumstances the last mod m\n+                  --  can be done with a (possible) single subtraction.\n+\n+                  --  m1 = 2; m2 = 3; M1 = 3; M2 = 4;\n+\n+                  when 6  =>\n+                     Tmp := 3 * (Least_Sig_Digit (Left) rem 2) +\n+                              4 * (Sum_Double_Digits (Left, 1) rem 3);\n+                     return UI_From_Int (Sign * (Tmp rem 6));\n+\n+                  --  m1 = 2; m2 = 5; M1 = 5; M2 = 6;\n+\n+                  when 10 =>\n+                     Tmp := 5 * (Least_Sig_Digit (Left) rem 2) +\n+                              6 * (Sum_Double_Digits (Left, -1) mod 5);\n+                     return UI_From_Int (Sign * (Tmp rem 10));\n+\n+                  --  m1 = 3; m2 = 4; M1 = 4; M2 = 9;\n+\n+                  when 12 =>\n+                     Tmp := 4 * (Sum_Double_Digits (Left, 1) rem 3) +\n+                              9 * (Least_Sig_Digit (Left) rem 4);\n+                     return UI_From_Int (Sign * (Tmp rem 12));\n+               end case;\n+\n+            end if;\n+\n+            --  Else fall through to general case.\n+\n+            --  ???This needs to be improved. We have the Rem when we do the\n+            --  Div. Div throws it away!\n+\n+            --  The special case Length (Left) = Length(right) = 1 in Div\n+            --  looks slow. It uses UI_To_Int when Int should suffice. ???\n+         end if;\n+      end if;\n+\n+      return Left - (Left / Right) * Right;\n+   end UI_Rem;\n+\n+   ------------\n+   -- UI_Sub --\n+   ------------\n+\n+   function UI_Sub (Left : Int; Right : Uint) return Uint is\n+   begin\n+      return UI_Add (Left, -Right);\n+   end UI_Sub;\n+\n+   function UI_Sub (Left : Uint; Right : Int) return Uint is\n+   begin\n+      return UI_Add (Left, -Right);\n+   end UI_Sub;\n+\n+   function UI_Sub (Left : Uint; Right : Uint) return Uint is\n+   begin\n+      if Direct (Left) and then Direct (Right) then\n+         return UI_From_Int (Direct_Val (Left) - Direct_Val (Right));\n+      else\n+         return UI_Add (Left, -Right);\n+      end if;\n+   end UI_Sub;\n+\n+   ----------------\n+   -- UI_To_Int --\n+   ----------------\n+\n+   function UI_To_Int (Input : Uint) return Int is\n+   begin\n+      if Direct (Input) then\n+         return Direct_Val (Input);\n+\n+      --  Case of input is more than one digit\n+\n+      else\n+         declare\n+            In_Length : constant Int := N_Digits (Input);\n+            In_Vec    : UI_Vector (1 .. In_Length);\n+            Ret_Int   : Int;\n+\n+         begin\n+            --  Uints of more than one digit could be outside the range for\n+            --  Ints. Caller should have checked for this if not certain.\n+            --  Fatal error to attempt to convert from value outside Int'Range.\n+\n+            pragma Assert (UI_Is_In_Int_Range (Input));\n+\n+            --  Otherwise, proceed ahead, we are OK\n+\n+            Init_Operand (Input, In_Vec);\n+            Ret_Int := 0;\n+\n+            --  Calculate -|Input| and then negates if value is positive.\n+            --  This handles our current definition of Int (based on\n+            --  2s complement). Is it secure enough?\n+\n+            for Idx in In_Vec'Range loop\n+               Ret_Int := Ret_Int * Base - abs In_Vec (Idx);\n+            end loop;\n+\n+            if In_Vec (1) < Int_0 then\n+               return Ret_Int;\n+            else\n+               return -Ret_Int;\n+            end if;\n+         end;\n+      end if;\n+   end UI_To_Int;\n+\n+   --------------\n+   -- UI_Write --\n+   --------------\n+\n+   procedure UI_Write (Input : Uint; Format : UI_Format := Auto) is\n+   begin\n+      Image_Out (Input, False, Format);\n+   end UI_Write;\n+\n+   ---------------------\n+   -- Vector_To_Uint --\n+   ---------------------\n+\n+   function Vector_To_Uint\n+     (In_Vec   : UI_Vector;\n+      Negative : Boolean)\n+      return     Uint\n+   is\n+      Size : Int;\n+      Val  : Int;\n+\n+   begin\n+      --  The vector can contain leading zeros. These are not stored in the\n+      --  table, so loop through the vector looking for first non-zero digit\n+\n+      for J in In_Vec'Range loop\n+         if In_Vec (J) /= Int_0 then\n+\n+            --  The length of the value is the length of the rest of the vector\n+\n+            Size := In_Vec'Last - J + 1;\n+\n+            --  One digit value can always be represented directly\n+\n+            if Size = Int_1 then\n+               if Negative then\n+                  return Uint (Int (Uint_Direct_Bias) - In_Vec (J));\n+               else\n+                  return Uint (Int (Uint_Direct_Bias) + In_Vec (J));\n+               end if;\n+\n+            --  Positive two digit values may be in direct representation range\n+\n+            elsif Size = Int_2 and then not Negative then\n+               Val := In_Vec (J) * Base + In_Vec (J + 1);\n+\n+               if Val <= Max_Direct then\n+                  return Uint (Int (Uint_Direct_Bias) + Val);\n+               end if;\n+            end if;\n+\n+            --  The value is outside the direct representation range and\n+            --  must therefore be stored in the table. Expand the table\n+            --  to contain the count and tigis. The index of the new table\n+            --  entry will be returned as the result.\n+\n+            Uints.Increment_Last;\n+            Uints.Table (Uints.Last).Length := Size;\n+            Uints.Table (Uints.Last).Loc    := Udigits.Last + 1;\n+\n+            Udigits.Increment_Last;\n+\n+            if Negative then\n+               Udigits.Table (Udigits.Last) := -In_Vec (J);\n+            else\n+               Udigits.Table (Udigits.Last) := +In_Vec (J);\n+            end if;\n+\n+            for K in 2 .. Size loop\n+               Udigits.Increment_Last;\n+               Udigits.Table (Udigits.Last) := In_Vec (J + K - 1);\n+            end loop;\n+\n+            return Uints.Last;\n+         end if;\n+      end loop;\n+\n+      --  Dropped through loop only if vector contained all zeros\n+\n+      return Uint_0;\n+   end Vector_To_Uint;\n+\n+end Uintp;"}, {"sha": "1cfb79ae17b5ff7d1a2b062e457861bd2e7ea476", "filename": "gcc/ada/uintp.ads", "status": "added", "additions": 505, "deletions": 0, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,505 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                U I N T P                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.58 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Support for universal integer arithmetic\n+\n+--  WARNING: There is a C version of this package. Any changes to this\n+--  source file must be properly reflected in the C header file sinfo.h\n+\n+with Alloc;\n+with Table;\n+with Types; use Types;\n+\n+package Uintp is\n+\n+   -------------------------------------------------\n+   -- Basic Types and Constants for Uintp Package --\n+   -------------------------------------------------\n+\n+   type Uint is private;\n+   --  The basic universal integer type\n+\n+   No_Uint : constant Uint;\n+   --  A constant value indicating a missing or unset Uint value\n+\n+   Uint_0   : constant Uint;\n+   Uint_1   : constant Uint;\n+   Uint_2   : constant Uint;\n+   Uint_3   : constant Uint;\n+   Uint_4   : constant Uint;\n+   Uint_5   : constant Uint;\n+   Uint_6   : constant Uint;\n+   Uint_7   : constant Uint;\n+   Uint_8   : constant Uint;\n+   Uint_9   : constant Uint;\n+   Uint_10  : constant Uint;\n+   Uint_12  : constant Uint;\n+   Uint_15  : constant Uint;\n+   Uint_16  : constant Uint;\n+   Uint_24  : constant Uint;\n+   Uint_32  : constant Uint;\n+   Uint_63  : constant Uint;\n+   Uint_64  : constant Uint;\n+   Uint_128 : constant Uint;\n+\n+   Uint_Minus_1   : constant Uint;\n+   Uint_Minus_2   : constant Uint;\n+   Uint_Minus_3   : constant Uint;\n+   Uint_Minus_4   : constant Uint;\n+   Uint_Minus_5   : constant Uint;\n+   Uint_Minus_6   : constant Uint;\n+   Uint_Minus_7   : constant Uint;\n+   Uint_Minus_8   : constant Uint;\n+   Uint_Minus_9   : constant Uint;\n+   Uint_Minus_12  : constant Uint;\n+   Uint_Minus_128 : constant Uint;\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Initialize;\n+   --  Initialize Uint tables. Note that Initialize must not be called if\n+   --  Tree_Read is used. Note also that there is no lock routine in this\n+   --  unit, these are among the few tables that can be expanded during\n+   --  gigi processing.\n+\n+   procedure Tree_Read;\n+   --  Initializes internal tables from current tree file using Tree_Read.\n+   --  Note that Initialize should not be called if Tree_Read is used.\n+   --  Tree_Read includes all necessary initialization.\n+\n+   procedure Tree_Write;\n+   --  Writes out internal tables to current tree file using Tree_Write.\n+\n+   function UI_Abs (Right : Uint) return Uint;\n+   pragma Inline (UI_Abs);\n+   --  Returns abs function of universal integer.\n+\n+   function UI_Add (Left : Uint; Right : Uint) return Uint;\n+   function UI_Add (Left : Int;  Right : Uint) return Uint;\n+   function UI_Add (Left : Uint; Right : Int)  return Uint;\n+   --  Returns sum of two integer values.\n+\n+   function UI_Decimal_Digits_Hi (U : Uint) return Nat;\n+   --  Returns an estimate of the number of decimal digits required to\n+   --  represent the absolute value of U. This estimate is correct or high,\n+   --  i.e. it never returns a value that is too low. The accuracy of the\n+   --  estimate affects only the effectiveness of comparison optimizations\n+   --  in Urealp.\n+\n+   function UI_Decimal_Digits_Lo (U : Uint) return Nat;\n+   --  Returns an estimate of the number of decimal digits required to\n+   --  represent the absolute value of U. This estimate is correct or low,\n+   --  i.e. it never returns a value that is too high. The accuracy of the\n+   --  estimate affects only the effectiveness of comparison optimizations\n+   --  in Urealp.\n+\n+   function UI_Div (Left : Uint; Right : Uint) return Uint;\n+   function UI_Div (Left : Int;  Right : Uint) return Uint;\n+   function UI_Div (Left : Uint; Right : Int)  return Uint;\n+   --  Returns quotient of two integer values. Fatal error if Right = 0\n+\n+   function UI_Eq (Left : Uint; Right : Uint) return Boolean;\n+   function UI_Eq (Left : Int;  Right : Uint) return Boolean;\n+   function UI_Eq (Left : Uint; Right : Int)  return Boolean;\n+   pragma Inline (UI_Eq);\n+   --  Compares integer values for equality.\n+\n+   function UI_Expon (Left : Uint; Right : Uint) return Uint;\n+   function UI_Expon (Left : Int;  Right : Uint) return Uint;\n+   function UI_Expon (Left : Uint; Right : Int)  return Uint;\n+   function UI_Expon (Left : Int;  Right : Int)  return Uint;\n+   --  Returns result of exponentiating two integer values\n+   --  Fatal error if Right is negative.\n+\n+   function UI_GCD (Uin, Vin : Uint) return Uint;\n+   --  Computes GCD of input values. Assumes Uin >= Vin >= 0.\n+\n+   function UI_Ge (Left : Uint; Right : Uint) return Boolean;\n+   function UI_Ge (Left : Int;  Right : Uint) return Boolean;\n+   function UI_Ge (Left : Uint; Right : Int)  return Boolean;\n+   pragma Inline (UI_Ge);\n+   --  Compares integer values for greater than or equal.\n+\n+   function UI_Gt (Left : Uint; Right : Uint) return Boolean;\n+   function UI_Gt (Left : Int;  Right : Uint) return Boolean;\n+   function UI_Gt (Left : Uint; Right : Int)  return Boolean;\n+   pragma Inline (UI_Gt);\n+   --  Compares integer values for greater than.\n+\n+   function UI_Is_In_Int_Range (Input : Uint) return Boolean;\n+   pragma Inline (UI_Is_In_Int_Range);\n+   --  Determines if universal integer is in Int range.\n+\n+   function UI_Le (Left : Uint; Right : Uint) return Boolean;\n+   function UI_Le (Left : Int;  Right : Uint) return Boolean;\n+   function UI_Le (Left : Uint; Right : Int)  return Boolean;\n+   pragma Inline (UI_Le);\n+   --  Compares integer values for less than or equal.\n+\n+   function UI_Lt (Left : Uint; Right : Uint) return Boolean;\n+   function UI_Lt (Left : Int;  Right : Uint) return Boolean;\n+   function UI_Lt (Left : Uint; Right : Int)  return Boolean;\n+   --  Compares integer values for less than.\n+\n+   function UI_Max (Left : Uint; Right : Uint) return Uint;\n+   function UI_Max (Left : Int;  Right : Uint) return Uint;\n+   function UI_Max (Left : Uint; Right : Int)  return Uint;\n+   --  Returns maximum of two integer values\n+\n+   function UI_Min (Left : Uint; Right : Uint) return Uint;\n+   function UI_Min (Left : Int;  Right : Uint) return Uint;\n+   function UI_Min (Left : Uint; Right : Int)  return Uint;\n+   --  Returns minimum of two integer values.\n+\n+   function UI_Mod (Left : Uint; Right : Uint) return Uint;\n+   function UI_Mod (Left : Int;  Right : Uint) return Uint;\n+   function UI_Mod (Left : Uint; Right : Int)  return Uint;\n+   pragma Inline (UI_Mod);\n+   --  Returns mod function of two integer values.\n+\n+   function UI_Mul (Left : Uint; Right : Uint) return Uint;\n+   function UI_Mul (Left : Int;  Right : Uint) return Uint;\n+   function UI_Mul (Left : Uint; Right : Int)  return Uint;\n+   --  Returns product of two integer values\n+\n+   function UI_Ne (Left : Uint; Right : Uint) return Boolean;\n+   function UI_Ne (Left : Int;  Right : Uint) return Boolean;\n+   function UI_Ne (Left : Uint; Right : Int)  return Boolean;\n+   pragma Inline (UI_Ne);\n+   --  Compares integer values for inequality.\n+\n+   function UI_Negate (Right : Uint) return Uint;\n+   pragma Inline (UI_Negate);\n+   --  Returns negative of universal integer.\n+\n+   function UI_Rem (Left : Uint; Right : Uint) return Uint;\n+   function UI_Rem (Left : Int;  Right : Uint) return Uint;\n+   function UI_Rem (Left : Uint; Right : Int)  return Uint;\n+   --  Returns rem of two integer values.\n+\n+   function UI_Sub (Left : Uint; Right : Uint) return Uint;\n+   function UI_Sub (Left : Int;  Right : Uint) return Uint;\n+   function UI_Sub (Left : Uint; Right : Int)  return Uint;\n+   pragma Inline (UI_Sub);\n+   --  Returns difference of two integer values\n+\n+   function UI_From_Dint (Input : Dint) return Uint;\n+   --  Converts Dint value to universal integer form.\n+\n+   function UI_From_Int (Input : Int) return Uint;\n+   --  Converts Int value to universal integer form.\n+\n+   function UI_To_Int (Input : Uint) return Int;\n+   --  Converts universal integer value to Int. Fatal error\n+   --  if value is not in appropriate range.\n+\n+   function Num_Bits (Input : Uint) return Nat;\n+   --  Approximate number of binary bits in given universal integer.\n+   --  This function is used for capacity checks, and it can be one\n+   --  bit off without affecting its usage.\n+\n+   ---------------------\n+   -- Output Routines --\n+   ---------------------\n+\n+   type UI_Format is (Hex, Decimal, Auto);\n+   --  Used to determine whether UI_Image/UI_Write output is in hexadecimal\n+   --  or decimal format. Auto, the default setting, lets the routine make\n+   --  a decision based on the value.\n+\n+   UI_Image_Max    : constant := 32;\n+   UI_Image_Buffer : String (1 .. UI_Image_Max);\n+   UI_Image_Length : Natural;\n+   --  Buffer used for UI_Image as described below\n+\n+   procedure UI_Image (Input : Uint; Format : UI_Format := Auto);\n+   --  Places a representation of Uint, consisting of a possible minus sign,\n+   --  followed by the value in UI_Image_Buffer. The form of the value is an\n+   --  integer literal in either decimal (no base) or hexadecimal (base 16)\n+   --  format. If Hex is True on entry, then hex mode is forced, otherwise\n+   --  UI_Image makes a guess at which output format is more convenient. The\n+   --  value must fit in UI_Image_Buffer. If necessary, the result is an\n+   --  approximation of the proper value, using an exponential format. The\n+   --  image of No_Uint is output as a single question mark.\n+\n+   procedure UI_Write (Input : Uint; Format : UI_Format := Auto);\n+   --  Writes a representation of Uint, consisting of a possible minus sign,\n+   --  followed by the value to the output file. The form of the value is an\n+   --  integer literal in either decimal (no base) or hexadecimal (base 16)\n+   --  format as appropriate. UI_Format shows which format to use. Auto,\n+   --  the default, asks UI_Write to make a guess at which output format\n+   --  will be more convenient to read.\n+\n+   procedure pid (Input : Uint);\n+   --  Writes representation of Uint in decimal with a terminating line\n+   --  return. This is intended for use from the debugger.\n+\n+   procedure pih (Input : Uint);\n+   --  Writes representation of Uint in hex with a terminating line return.\n+   --  This is intended for use from the debugger.\n+\n+   ------------------------\n+   -- Operator Renamings --\n+   ------------------------\n+\n+   function \"+\" (Left : Uint; Right : Uint) return Uint renames UI_Add;\n+   function \"+\" (Left : Int;  Right : Uint) return Uint renames UI_Add;\n+   function \"+\" (Left : Uint; Right : Int)  return Uint renames UI_Add;\n+\n+   function \"/\" (Left : Uint; Right : Uint) return Uint renames UI_Div;\n+   function \"/\" (Left : Int;  Right : Uint) return Uint renames UI_Div;\n+   function \"/\" (Left : Uint; Right : Int)  return Uint renames UI_Div;\n+\n+   function \"*\" (Left : Uint; Right : Uint) return Uint renames UI_Mul;\n+   function \"*\" (Left : Int;  Right : Uint) return Uint renames UI_Mul;\n+   function \"*\" (Left : Uint; Right : Int)  return Uint renames UI_Mul;\n+\n+   function \"-\" (Left : Uint; Right : Uint) return Uint renames UI_Sub;\n+   function \"-\" (Left : Int;  Right : Uint) return Uint renames UI_Sub;\n+   function \"-\" (Left : Uint; Right : Int)  return Uint renames UI_Sub;\n+\n+   function \"**\"  (Left : Uint; Right : Uint) return Uint renames UI_Expon;\n+   function \"**\"  (Left : Uint; Right : Int)  return Uint renames UI_Expon;\n+   function \"**\"  (Left : Int;  Right : Uint) return Uint renames UI_Expon;\n+   function \"**\"  (Left : Int;  Right : Int)  return Uint renames UI_Expon;\n+\n+   function \"abs\" (Real : Uint) return Uint renames UI_Abs;\n+\n+   function \"mod\" (Left : Uint; Right : Uint) return Uint renames UI_Mod;\n+   function \"mod\" (Left : Int;  Right : Uint) return Uint renames UI_Mod;\n+   function \"mod\" (Left : Uint; Right : Int)  return Uint renames UI_Mod;\n+\n+   function \"rem\" (Left : Uint; Right : Uint) return Uint renames UI_Rem;\n+   function \"rem\" (Left : Int;  Right : Uint) return Uint renames UI_Rem;\n+   function \"rem\" (Left : Uint; Right : Int)  return Uint renames UI_Rem;\n+\n+   function \"-\"   (Real : Uint) return Uint renames UI_Negate;\n+\n+   function \"=\"   (Left : Uint; Right : Uint) return Boolean renames UI_Eq;\n+   function \"=\"   (Left : Int;  Right : Uint) return Boolean renames UI_Eq;\n+   function \"=\"   (Left : Uint; Right : Int)  return Boolean renames UI_Eq;\n+\n+   function \">=\"  (Left : Uint; Right : Uint) return Boolean renames UI_Ge;\n+   function \">=\"  (Left : Int;  Right : Uint) return Boolean renames UI_Ge;\n+   function \">=\"  (Left : Uint; Right : Int)  return Boolean renames UI_Ge;\n+\n+   function \">\"   (Left : Uint; Right : Uint) return Boolean renames UI_Gt;\n+   function \">\"   (Left : Int;  Right : Uint) return Boolean renames UI_Gt;\n+   function \">\"   (Left : Uint; Right : Int)  return Boolean renames UI_Gt;\n+\n+   function \"<=\"  (Left : Uint; Right : Uint) return Boolean renames UI_Le;\n+   function \"<=\"  (Left : Int;  Right : Uint) return Boolean renames UI_Le;\n+   function \"<=\"  (Left : Uint; Right : Int)  return Boolean renames UI_Le;\n+\n+   function \"<\"   (Left : Uint; Right : Uint) return Boolean renames UI_Lt;\n+   function \"<\"   (Left : Int;  Right : Uint) return Boolean renames UI_Lt;\n+   function \"<\"   (Left : Uint; Right : Int)  return Boolean renames UI_Lt;\n+\n+   -----------------------------\n+   -- Mark/Release Processing --\n+   -----------------------------\n+\n+   --  The space used by Uint data is not automatically reclaimed. However,\n+   --  a mark-release regime is implemented which allows storage to be\n+   --  released back to a previously noted mark. This is used for example\n+   --  when doing comparisons, where only intermediate results get stored\n+   --  that do not need to be saved for future use.\n+\n+   type Save_Mark is private;\n+\n+   function Mark return Save_Mark;\n+   --  Note mark point for future release\n+\n+   procedure Release (M : Save_Mark);\n+   --  Release storage allocated since mark was noted\n+\n+   procedure Release_And_Save (M : Save_Mark; UI : in out Uint);\n+   --  Like Release, except that the given Uint value (which is typically\n+   --  among the data being released) is recopied after the release, so\n+   --  that it is the most recent item, and UI is updated to point to\n+   --  its copied location.\n+\n+   procedure Release_And_Save (M : Save_Mark; UI1, UI2 : in out Uint);\n+   --  Like Release, except that the given Uint values (which are typically\n+   --  among the data being released) are recopied after the release, so\n+   --  that they are the most recent items, and UI1 and UI2 are updated if\n+   --  necessary to point to the copied locations. This routine is careful\n+   --  to do things in the right order, so that the values do not clobber\n+   --  one another.\n+\n+   -----------------------------------\n+   -- Representation of Uint Values --\n+   -----------------------------------\n+\n+private\n+\n+   type Uint is new Int range Uint_Low_Bound .. Uint_High_Bound;\n+   for Uint'Size use 32;\n+\n+   No_Uint : constant Uint := Uint (Uint_Low_Bound);\n+\n+   --  Uint values are represented as multiple precision integers stored in\n+   --  a multi-digit format using Base as the base. This value is chosen so\n+   --  that the product Base*Base is within the range of allowed Int values.\n+\n+   --  Base is defined to allow efficient execution of the primitive\n+   --  operations (a0, b0, c0) defined in the section \"The Classical\n+   --  Algorithms\" (sec. 4.3.1) of Donald Knuth's \"The Art of Computer\n+   --  Programming\", Vol. 2. These algorithms are used in this package.\n+\n+   Base_Bits : constant := 15;\n+   --  Number of bits in base value\n+\n+   Base : constant Int := 2 ** Base_Bits;\n+\n+   --  Values in the range -(Base+1) .. maxdirect are encoded directly as\n+   --  Uint values by adding a bias value. The value of maxdirect is chosen\n+   --  so that a directly represented number always fits in two digits when\n+   --  represented in base format.\n+\n+   Min_Direct : constant Int := -(Base - 1);\n+   Max_Direct : constant Int := (Base - 1) * (Base - 1);\n+\n+   --  The following values define the bias used to store Uint values which\n+   --  are in this range, as well as the biased values for the first and\n+   --  last values in this range. We use a new derived type for these\n+   --  constants to avoid accidental use of Uint arithmetic on these\n+   --  values, which is never correct.\n+\n+   type Ctrl is range Int'First .. Int'Last;\n+\n+   Uint_Direct_Bias  : constant Ctrl := Ctrl (Uint_Low_Bound) + Ctrl (Base);\n+   Uint_Direct_First : constant Ctrl := Uint_Direct_Bias + Ctrl (Min_Direct);\n+   Uint_Direct_Last  : constant Ctrl := Uint_Direct_Bias + Ctrl (Max_Direct);\n+\n+   Uint_0   : constant Uint := Uint (Uint_Direct_Bias);\n+   Uint_1   : constant Uint := Uint (Uint_Direct_Bias + 1);\n+   Uint_2   : constant Uint := Uint (Uint_Direct_Bias + 2);\n+   Uint_3   : constant Uint := Uint (Uint_Direct_Bias + 3);\n+   Uint_4   : constant Uint := Uint (Uint_Direct_Bias + 4);\n+   Uint_5   : constant Uint := Uint (Uint_Direct_Bias + 5);\n+   Uint_6   : constant Uint := Uint (Uint_Direct_Bias + 6);\n+   Uint_7   : constant Uint := Uint (Uint_Direct_Bias + 7);\n+   Uint_8   : constant Uint := Uint (Uint_Direct_Bias + 8);\n+   Uint_9   : constant Uint := Uint (Uint_Direct_Bias + 9);\n+   Uint_10  : constant Uint := Uint (Uint_Direct_Bias + 10);\n+   Uint_12  : constant Uint := Uint (Uint_Direct_Bias + 12);\n+   Uint_15  : constant Uint := Uint (Uint_Direct_Bias + 15);\n+   Uint_16  : constant Uint := Uint (Uint_Direct_Bias + 16);\n+   Uint_24  : constant Uint := Uint (Uint_Direct_Bias + 24);\n+   Uint_32  : constant Uint := Uint (Uint_Direct_Bias + 32);\n+   Uint_63  : constant Uint := Uint (Uint_Direct_Bias + 63);\n+   Uint_64  : constant Uint := Uint (Uint_Direct_Bias + 64);\n+   Uint_128 : constant Uint := Uint (Uint_Direct_Bias + 128);\n+\n+   Uint_Minus_1   : constant Uint := Uint (Uint_Direct_Bias - 1);\n+   Uint_Minus_2   : constant Uint := Uint (Uint_Direct_Bias - 2);\n+   Uint_Minus_3   : constant Uint := Uint (Uint_Direct_Bias - 3);\n+   Uint_Minus_4   : constant Uint := Uint (Uint_Direct_Bias - 4);\n+   Uint_Minus_5   : constant Uint := Uint (Uint_Direct_Bias - 5);\n+   Uint_Minus_6   : constant Uint := Uint (Uint_Direct_Bias - 6);\n+   Uint_Minus_7   : constant Uint := Uint (Uint_Direct_Bias - 7);\n+   Uint_Minus_8   : constant Uint := Uint (Uint_Direct_Bias - 8);\n+   Uint_Minus_9   : constant Uint := Uint (Uint_Direct_Bias - 9);\n+   Uint_Minus_12  : constant Uint := Uint (Uint_Direct_Bias - 12);\n+   Uint_Minus_128 : constant Uint := Uint (Uint_Direct_Bias - 128);\n+\n+   type Save_Mark is record\n+      Save_Uint   : Uint;\n+      Save_Udigit : Int;\n+   end record;\n+\n+   --  Values outside the range that is represented directly are stored\n+   --  using two tables. The secondary table Udigits contains sequences of\n+   --  Int values consisting of the digits of the number in a radix Base\n+   --  system. The digits are stored from most significant to least\n+   --  significant with the first digit only carrying the sign.\n+\n+   --  There is one entry in the primary Uints table for each distinct Uint\n+   --  value. This table entry contains the length (number of digits) and\n+   --  a starting offset of the value in the Udigits table.\n+\n+   Uint_First_Entry : constant Uint := Uint (Uint_Table_Start);\n+\n+   --  Some subprograms defined in this package manipulate the Udigits\n+   --  table directly, while for others it is more convenient to work with\n+   --  locally defined arrays of the digits of the Universal Integers.\n+   --  The type UI_Vector is defined for this purpose and some internal\n+   --  subprograms used for converting from one to the other are defined.\n+\n+   type UI_Vector is array (Pos range <>) of Int;\n+   --  Vector containing the integer values of a Uint value\n+\n+   --  Note: An earlier version of this package used pointers of arrays\n+   --  of Ints (dynamically allocated) for the Uint type. The change\n+   --  leads to a few less natural idioms used throughout this code, but\n+   --  eliminates all uses of the heap except for the table package itself.\n+   --  For example, Uint parameters are often converted to UI_Vectors for\n+   --  internal manipulation. This is done by creating the local UI_Vector\n+   --  using the function N_Digits on the Uint to find the size needed for\n+   --  the vector, and then calling Init_Operand to copy the values out\n+   --  of the table into the vector.\n+\n+   type Uint_Entry is record\n+      Length : Pos;\n+      --  Length of entry in Udigits table in digits (i.e. in words)\n+\n+      Loc : Int;\n+      --  Starting location in Udigits table of this Uint value\n+   end record;\n+\n+   package Uints is new Table.Table (\n+     Table_Component_Type => Uint_Entry,\n+     Table_Index_Type     => Uint,\n+     Table_Low_Bound      => Uint_First_Entry,\n+     Table_Initial        => Alloc.Uints_Initial,\n+     Table_Increment      => Alloc.Uints_Increment,\n+     Table_Name           => \"Uints\");\n+\n+   package Udigits is new Table.Table (\n+     Table_Component_Type => Int,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Udigits_Initial,\n+     Table_Increment      => Alloc.Udigits_Increment,\n+     Table_Name           => \"Udigits\");\n+\n+   --  Note: the reason these tables are defined here in the private part of\n+   --  the spec, rather than in the body, is that they are refrerenced\n+   --  directly by gigi.\n+\n+end Uintp;"}, {"sha": "365dba0d60f95204518e087fe98135ee4af9aff4", "filename": "gcc/ada/uintp.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fuintp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fuintp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.h?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,75 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                U I N T P                                 *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *                            $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file corresponds to the Ada package specification Uintp. It was\n+   created manually from the files uintp.ads and uintp.adb  */\n+\n+/* Support for universal integer arithmetic */\n+\n+struct Uint_Entry\n+{\n+  Pos Length;\n+  Int Loc;\n+};\n+\n+/* See if a Uint is within the range of an integer.  */\n+#define UI_Is_In_Int_Range  uintp__ui_is_in_int_range\n+extern Boolean UI_Is_In_Int_Range\tPARAMS((Uint));\n+\n+/* Obtain Int value from Uint input. This will abort if the result is\n+   out of range.  */\n+#define UI_To_Int uintp__ui_to_int\n+extern Int UI_To_Int\t\t\tPARAMS((Uint));\n+\n+/* Convert an Int into a Uint.  */\n+#define UI_From_Int uintp__ui_from_int\n+extern Uint UI_From_Int\t\t\tPARAMS((int));\n+\n+/* Similarly, but return a GCC INTEGER_CST.  Overflow is tested by the\n+   constant-folding used to build the node.  TYPE is the GCC type of the\n+   resulting node.  */\n+extern tree UI_To_gnu\t\t\tPARAMS((Uint, tree));\n+\n+/* Universal integers are represented by the Uint type which is an index into\n+   the Uints_Ptr table containing Uint_Entry values.  A Uint_Entry contains an\n+   index and length for getting the \"digits\" of the universal integer from the\n+   Udigits_Ptr table.\n+\n+   For efficiency, this method is used only for integer values larger than the\n+   constant Uint_Bias.  If a Uint is less than this constant, then it contains\n+   the integer value itself.  The origin of the Uints_Ptr table is adjusted so\n+   that a Uint value of Uint_Bias indexes the first element.  */\n+\n+#define Uints_Ptr (uintp__uints__table - Uint_Table_Start)\n+extern struct Uint_Entry *uintp__uints__table;\n+\n+#define Udigits_Ptr uintp__udigits__table\n+extern int *uintp__udigits__table;\n+\n+#define Uint_0 (Uint_Direct_Bias + 0)\n+#define Uint_1 (Uint_Direct_Bias + 1)"}, {"sha": "b6e0f6bd5e3d79bdbc96d937880d96b2246cd343", "filename": "gcc/ada/uname.adb", "status": "added", "additions": 653, "deletions": 0, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Funame.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Funame.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funame.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,653 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                U N A M E                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.56 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Casing;   use Casing;\n+with Einfo;    use Einfo;\n+with Hostparm;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Output;   use Output;\n+with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n+\n+package body Uname is\n+\n+   -------------------\n+   -- Get_Body_Name --\n+   -------------------\n+\n+   function Get_Body_Name (N : Unit_Name_Type) return Unit_Name_Type is\n+   begin\n+      Get_Name_String (N);\n+\n+      pragma Assert (Name_Len > 2\n+                       and then Name_Buffer (Name_Len - 1) = '%'\n+                       and then Name_Buffer (Name_Len) = 's');\n+\n+      Name_Buffer (Name_Len) := 'b';\n+      return Name_Find;\n+   end Get_Body_Name;\n+\n+   -----------------------------------\n+   -- Get_External_Unit_Name_String --\n+   -----------------------------------\n+\n+   procedure Get_External_Unit_Name_String (N : Unit_Name_Type) is\n+      Pcount : Natural;\n+      Newlen : Natural;\n+\n+   begin\n+      --  Get unit name and eliminate trailing %s or %b\n+\n+      Get_Name_String (N);\n+      Name_Len := Name_Len - 2;\n+\n+      --  Find number of components\n+\n+      Pcount := 0;\n+      for J in 1 .. Name_Len loop\n+         if Name_Buffer (J) = '.' then\n+            Pcount := Pcount + 1;\n+         end if;\n+      end loop;\n+\n+      --  If simple name, nothing to do\n+\n+      if Pcount = 0 then\n+         return;\n+      end if;\n+\n+      --  If name has multiple components, replace dots by double underscore\n+\n+      Newlen := Name_Len + Pcount;\n+\n+      for J in reverse 1 .. Name_Len loop\n+         if Name_Buffer (J) = '.' then\n+            Name_Buffer (Newlen) := '_';\n+            Name_Buffer (Newlen - 1) := '_';\n+            Newlen := Newlen - 2;\n+\n+         else\n+            Name_Buffer (Newlen) := Name_Buffer (J);\n+            Newlen := Newlen - 1;\n+         end if;\n+      end loop;\n+\n+      Name_Len := Name_Len + Pcount;\n+   end Get_External_Unit_Name_String;\n+\n+   --------------------------\n+   -- Get_Parent_Body_Name --\n+   --------------------------\n+\n+   function Get_Parent_Body_Name (N : Unit_Name_Type) return Unit_Name_Type is\n+   begin\n+      Get_Name_String (N);\n+\n+      while Name_Buffer (Name_Len) /= '.' loop\n+         pragma Assert (Name_Len > 1); -- not a child or subunit name\n+         Name_Len := Name_Len - 1;\n+      end loop;\n+\n+      Name_Buffer (Name_Len) := '%';\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := 'b';\n+      return Name_Find;\n+\n+   end Get_Parent_Body_Name;\n+\n+   --------------------------\n+   -- Get_Parent_Spec_Name --\n+   --------------------------\n+\n+   function Get_Parent_Spec_Name (N : Unit_Name_Type) return Unit_Name_Type is\n+   begin\n+      Get_Name_String (N);\n+\n+      while Name_Buffer (Name_Len) /= '.' loop\n+         if Name_Len = 1 then\n+            return No_Name; -- not a child or subunit name\n+         else\n+            Name_Len := Name_Len - 1;\n+         end if;\n+      end loop;\n+\n+      Name_Buffer (Name_Len) := '%';\n+      Name_Len := Name_Len + 1;\n+      Name_Buffer (Name_Len) := 's';\n+      return Name_Find;\n+\n+   end Get_Parent_Spec_Name;\n+\n+   -------------------\n+   -- Get_Spec_Name --\n+   -------------------\n+\n+   function Get_Spec_Name (N : Unit_Name_Type) return Unit_Name_Type is\n+   begin\n+      Get_Name_String (N);\n+\n+      pragma Assert (Name_Len > 2\n+                       and then Name_Buffer (Name_Len - 1) = '%'\n+                       and then Name_Buffer (Name_Len) = 'b');\n+\n+      Name_Buffer (Name_Len) := 's';\n+      return Name_Find;\n+   end Get_Spec_Name;\n+\n+   -------------------\n+   -- Get_Unit_Name --\n+   -------------------\n+\n+   function Get_Unit_Name (N : Node_Id) return Unit_Name_Type is\n+\n+      Unit_Name_Buffer : String (1 .. Hostparm.Max_Name_Length);\n+      --  Buffer used to build name of unit. Note that we cannot use the\n+      --  Name_Buffer in package Name_Table because we use it to read\n+      --  component names.\n+\n+      Unit_Name_Length : Natural := 0;\n+      --  Length of name stored in Unit_Name_Buffer\n+\n+      Node : Node_Id;\n+      --  Program unit node\n+\n+      procedure Add_Char (C : Character);\n+      --  Add a single character to stored unit name\n+\n+      procedure Add_Name (Name : Name_Id);\n+      --  Add the characters of a names table entry to stored unit name\n+\n+      procedure Add_Node_Name (Node : Node_Id);\n+      --  Recursive procedure adds characters associated with Node\n+\n+      function Get_Parent (Node : Node_Id) return Node_Id;\n+      --  Get parent compilation unit of a stub\n+\n+      --------------\n+      -- Add_Char --\n+      --------------\n+\n+      procedure Add_Char (C : Character) is\n+      begin\n+         --  Should really check for max length exceeded here???\n+         Unit_Name_Length := Unit_Name_Length + 1;\n+         Unit_Name_Buffer (Unit_Name_Length) := C;\n+      end Add_Char;\n+\n+      --------------\n+      -- Add_Name --\n+      --------------\n+\n+      procedure Add_Name (Name : Name_Id) is\n+      begin\n+         Get_Name_String (Name);\n+\n+         for J in 1 .. Name_Len loop\n+            Add_Char (Name_Buffer (J));\n+         end loop;\n+      end Add_Name;\n+\n+      -------------------\n+      -- Add_Node_Name --\n+      -------------------\n+\n+      procedure Add_Node_Name (Node : Node_Id) is\n+         Kind : Node_Kind := Nkind (Node);\n+\n+      begin\n+         --  Just ignore an error node (someone else will give a message)\n+\n+         if Node = Error then\n+            return;\n+\n+         --  Otherwise see what kind of node we have\n+\n+         else\n+            case Kind is\n+\n+               when N_Identifier                      |\n+                    N_Defining_Identifier             |\n+                    N_Defining_Operator_Symbol        =>\n+\n+                  --  Note: it is of course an error to have a defining\n+                  --  operator symbol at this point, but this is not where\n+                  --  the error is signalled, so we handle it nicely here!\n+\n+                  Add_Name (Chars (Node));\n+\n+               when N_Defining_Program_Unit_Name      =>\n+                  Add_Node_Name (Name (Node));\n+                  Add_Char ('.');\n+                  Add_Node_Name (Defining_Identifier (Node));\n+\n+               when N_Selected_Component              |\n+                    N_Expanded_Name                   =>\n+                  Add_Node_Name (Prefix (Node));\n+                  Add_Char ('.');\n+                  Add_Node_Name (Selector_Name (Node));\n+\n+               when N_Subprogram_Specification        |\n+                    N_Package_Specification           =>\n+                  Add_Node_Name (Defining_Unit_Name (Node));\n+\n+               when N_Subprogram_Body                 |\n+                    N_Subprogram_Declaration          |\n+                    N_Package_Declaration             |\n+                    N_Generic_Declaration             =>\n+                  Add_Node_Name (Specification (Node));\n+\n+               when N_Generic_Instantiation           =>\n+                  Add_Node_Name (Defining_Unit_Name (Node));\n+\n+               when N_Package_Body                    =>\n+                  Add_Node_Name (Defining_Unit_Name (Node));\n+\n+               when N_Task_Body                       |\n+                    N_Protected_Body                  =>\n+                  Add_Node_Name (Defining_Identifier (Node));\n+\n+               when N_Package_Renaming_Declaration    =>\n+                  Add_Node_Name (Defining_Unit_Name (Node));\n+\n+               when N_Subprogram_Renaming_Declaration =>\n+                  Add_Node_Name (Specification (Node));\n+\n+               when N_Generic_Renaming_Declaration   =>\n+                  Add_Node_Name (Defining_Unit_Name (Node));\n+\n+               when N_Subprogram_Body_Stub            =>\n+                  Add_Node_Name (Get_Parent (Node));\n+                  Add_Char ('.');\n+                  Add_Node_Name (Specification (Node));\n+\n+               when N_Compilation_Unit                =>\n+                  Add_Node_Name (Unit (Node));\n+\n+               when N_Package_Body_Stub               =>\n+                  Add_Node_Name (Get_Parent (Node));\n+                  Add_Char ('.');\n+                  Add_Node_Name (Defining_Identifier (Node));\n+\n+               when N_Task_Body_Stub                  |\n+                    N_Protected_Body_Stub             =>\n+                  Add_Node_Name (Get_Parent (Node));\n+                  Add_Char ('.');\n+                  Add_Node_Name (Defining_Identifier (Node));\n+\n+               when N_Subunit                         =>\n+                  Add_Node_Name (Name (Node));\n+                  Add_Char ('.');\n+                  Add_Node_Name (Proper_Body (Node));\n+\n+               when N_With_Clause                     =>\n+                  Add_Node_Name (Name (Node));\n+\n+               when N_Pragma                          =>\n+                  Add_Node_Name (Expression (First\n+                    (Pragma_Argument_Associations (Node))));\n+\n+               --  Tasks and protected stuff appear only in an error context,\n+               --  but the error has been posted elsewhere, so we deal nicely\n+               --  with these error situations here, and produce a reasonable\n+               --  unit name using the defining identifier.\n+\n+               when N_Task_Type_Declaration           |\n+                    N_Single_Task_Declaration         |\n+                    N_Protected_Type_Declaration      |\n+                    N_Single_Protected_Declaration    =>\n+                  Add_Node_Name (Defining_Identifier (Node));\n+\n+               when others =>\n+                  raise Program_Error;\n+\n+            end case;\n+         end if;\n+      end Add_Node_Name;\n+\n+      ----------------\n+      -- Get_Parent --\n+      ----------------\n+\n+      function Get_Parent (Node : Node_Id) return Node_Id is\n+         N : Node_Id := Node;\n+\n+      begin\n+         while Nkind (N) /= N_Compilation_Unit loop\n+            N := Parent (N);\n+         end loop;\n+\n+         return N;\n+      end Get_Parent;\n+\n+   --------------------------------------------\n+   --  Start of Processing for Get_Unit_Name --\n+   --------------------------------------------\n+\n+   begin\n+      Node := N;\n+\n+      --  If we have Defining_Identifier, find the associated unit node\n+\n+      if Nkind (Node) = N_Defining_Identifier then\n+         Node := Declaration_Node (Node);\n+\n+      --  If an expanded name, it is an already analyzed child unit, find\n+      --  unit node.\n+\n+      elsif Nkind (Node) = N_Expanded_Name then\n+         Node := Declaration_Node (Entity (Node));\n+      end if;\n+\n+      if Nkind (Node) = N_Package_Specification\n+        or else Nkind (Node) in N_Subprogram_Specification\n+      then\n+         Node := Parent (Node);\n+      end if;\n+\n+      --  Node points to the unit, so get its name and add proper suffix\n+\n+      Add_Node_Name (Node);\n+      Add_Char ('%');\n+\n+      case Nkind (Node) is\n+         when N_Generic_Declaration             |\n+              N_Subprogram_Declaration          |\n+              N_Package_Declaration             |\n+              N_With_Clause                     |\n+              N_Pragma                          |\n+              N_Generic_Instantiation           |\n+              N_Package_Renaming_Declaration    |\n+              N_Subprogram_Renaming_Declaration |\n+              N_Generic_Renaming_Declaration    |\n+              N_Single_Task_Declaration         |\n+              N_Single_Protected_Declaration    |\n+              N_Task_Type_Declaration           |\n+              N_Protected_Type_Declaration      =>\n+\n+            Add_Char ('s');\n+\n+         when N_Subprogram_Body                 |\n+              N_Package_Body                    |\n+              N_Subunit                         |\n+              N_Body_Stub                       |\n+              N_Task_Body                       |\n+              N_Protected_Body                  |\n+              N_Identifier                      |\n+              N_Selected_Component              =>\n+\n+            Add_Char ('b');\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+\n+      Name_Buffer (1 .. Unit_Name_Length) :=\n+        Unit_Name_Buffer (1 .. Unit_Name_Length);\n+      Name_Len := Unit_Name_Length;\n+      return Name_Find;\n+\n+   end Get_Unit_Name;\n+\n+   --------------------------\n+   -- Get_Unit_Name_String --\n+   --------------------------\n+\n+   procedure Get_Unit_Name_String (N : Unit_Name_Type) is\n+      Unit_Is_Body : Boolean;\n+\n+   begin\n+      Get_Decoded_Name_String (N);\n+      Unit_Is_Body := Name_Buffer (Name_Len) = 'b';\n+      Set_Casing (Identifier_Casing (Source_Index (Main_Unit)), Mixed_Case);\n+\n+      --  A special fudge, normally we don't have operator symbols present,\n+      --  since it is always an error to do so. However, if we do, at this\n+      --  stage it has the form:\n+\n+      --    \"and\"\n+\n+      --  and the %s or %b has already been eliminated so put 2 chars back\n+\n+      if Name_Buffer (1) = '\"' then\n+         Name_Len := Name_Len + 2;\n+      end if;\n+\n+      --  Now adjust the %s or %b to (spec) or (body)\n+\n+      if Unit_Is_Body then\n+         Name_Buffer (Name_Len - 1 .. Name_Len + 5) := \" (body)\";\n+      else\n+         Name_Buffer (Name_Len - 1 .. Name_Len + 5) := \" (spec)\";\n+      end if;\n+\n+      for J in 1 .. Name_Len loop\n+         if Name_Buffer (J) = '-' then\n+            Name_Buffer (J) := '.';\n+         end if;\n+      end loop;\n+\n+      Name_Len := Name_Len + (7 - 2);\n+   end Get_Unit_Name_String;\n+\n+   ------------------\n+   -- Is_Body_Name --\n+   ------------------\n+\n+   function Is_Body_Name (N : Unit_Name_Type) return Boolean is\n+   begin\n+      Get_Name_String (N);\n+      return Name_Len > 2\n+        and then Name_Buffer (Name_Len - 1) = '%'\n+        and then Name_Buffer (Name_Len) = 'b';\n+   end Is_Body_Name;\n+\n+   -------------------\n+   -- Is_Child_Name --\n+   -------------------\n+\n+   function Is_Child_Name (N : Unit_Name_Type) return Boolean is\n+      J : Natural;\n+\n+   begin\n+      Get_Name_String (N);\n+      J := Name_Len;\n+\n+      while Name_Buffer (J) /= '.' loop\n+         if J = 1 then\n+            return False; -- not a child or subunit name\n+         else\n+            J := J - 1;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Is_Child_Name;\n+\n+   ------------------\n+   -- Is_Spec_Name --\n+   ------------------\n+\n+   function Is_Spec_Name (N : Unit_Name_Type) return Boolean is\n+   begin\n+      Get_Name_String (N);\n+      return Name_Len > 2\n+        and then Name_Buffer (Name_Len - 1) = '%'\n+        and then Name_Buffer (Name_Len) = 's';\n+   end Is_Spec_Name;\n+\n+   -----------------------\n+   -- Name_To_Unit_Name --\n+   -----------------------\n+\n+   function Name_To_Unit_Name (N : Name_Id) return Unit_Name_Type is\n+   begin\n+      Get_Name_String (N);\n+      Name_Buffer (Name_Len + 1) := '%';\n+      Name_Buffer (Name_Len + 2) := 's';\n+      Name_Len := Name_Len + 2;\n+      return Name_Find;\n+   end Name_To_Unit_Name;\n+\n+   ---------------\n+   -- New_Child --\n+   ---------------\n+\n+   function New_Child\n+     (Old  : Unit_Name_Type;\n+      Newp : Unit_Name_Type)\n+      return Unit_Name_Type\n+   is\n+      P : Natural;\n+\n+   begin\n+      Get_Name_String (Old);\n+\n+      declare\n+         Child : String := Name_Buffer (1 .. Name_Len);\n+\n+      begin\n+         Get_Name_String (Newp);\n+         Name_Len := Name_Len - 2;\n+\n+         P := Child'Last;\n+         while Child (P) /= '.' loop\n+            P := P - 1;\n+         end loop;\n+\n+         while P <= Child'Last loop\n+            Name_Len := Name_Len + 1;\n+            Name_Buffer (Name_Len) := Child (P);\n+            P := P + 1;\n+         end loop;\n+\n+         return Name_Find;\n+      end;\n+   end New_Child;\n+\n+   --------------\n+   -- Uname_Ge --\n+   --------------\n+\n+   function Uname_Ge (Left, Right : Unit_Name_Type) return Boolean is\n+   begin\n+      return Left = Right or else Uname_Gt (Left, Right);\n+   end Uname_Ge;\n+\n+   --------------\n+   -- Uname_Gt --\n+   --------------\n+\n+   function Uname_Gt (Left, Right : Unit_Name_Type) return Boolean is\n+   begin\n+      return Left /= Right and then not Uname_Lt (Left, Right);\n+   end Uname_Gt;\n+\n+   --------------\n+   -- Uname_Le --\n+   --------------\n+\n+   function Uname_Le (Left, Right : Unit_Name_Type) return Boolean is\n+   begin\n+      return Left = Right or else Uname_Lt (Left, Right);\n+   end Uname_Le;\n+\n+   --------------\n+   -- Uname_Lt --\n+   --------------\n+\n+   function Uname_Lt (Left, Right : Unit_Name_Type) return Boolean is\n+      Left_Name    : String (1 .. Hostparm.Max_Name_Length);\n+      Left_Length  : Natural;\n+      Right_Name   : String renames Name_Buffer;\n+      Right_Length : Natural renames Name_Len;\n+      J            : Natural;\n+\n+   begin\n+      pragma Warnings (Off, Right_Length);\n+      --  Suppress warnings on Right_Length, used in pragma Assert\n+\n+      if Left = Right then\n+         return False;\n+      end if;\n+\n+      Get_Name_String (Left);\n+      Left_Name  (1 .. Name_Len + 1) := Name_Buffer (1 .. Name_Len + 1);\n+      Left_Length := Name_Len;\n+      Get_Name_String (Right);\n+      J := 1;\n+\n+      loop\n+         exit when Left_Name (J) = '%';\n+\n+         if Right_Name (J) = '%' then\n+            return False; -- left name is longer\n+         end if;\n+\n+         pragma Assert (J <= Left_Length and then J <= Right_Length);\n+\n+         if Left_Name (J) /= Right_Name (J) then\n+            return Left_Name (J) < Right_Name (J); -- parent names different\n+         end if;\n+\n+         J := J + 1;\n+      end loop;\n+\n+      --  Come here pointing to % in left name\n+\n+      if Right_Name (J) /= '%' then\n+         return True; -- right name is longer\n+      end if;\n+\n+      --  Here the parent names are the same and specs sort low. If neither is\n+      --  a spec, then we are comparing the same name and we want a result of\n+      --  False in any case.\n+\n+      return Left_Name (J + 1) = 's';\n+   end Uname_Lt;\n+\n+   ---------------------\n+   -- Write_Unit_Name --\n+   ---------------------\n+\n+   procedure Write_Unit_Name (N : Unit_Name_Type) is\n+   begin\n+      Get_Unit_Name_String (N);\n+      Write_Str (Name_Buffer (1 .. Name_Len));\n+   end Write_Unit_Name;\n+\n+end Uname;"}, {"sha": "c5fc2097396ed6237c90a5e52be417f53b726c68", "filename": "gcc/ada/uname.ads", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Funame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Funame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funame.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,176 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                U N A M E                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.23 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+package Uname is\n+\n+   ---------------------------\n+   -- Unit Name Conventions --\n+   ---------------------------\n+\n+   --  Units are associated with a unique ASCII name as follows. First we\n+   --  have the fully expanded name of the unit, with lower case letters\n+   --  (except for the use of upper case letters for encoding upper half\n+   --  and wide characters, as described in Namet), and periods. Following\n+   --  this is one of the following suffixes:\n+\n+   --    %s  for package/subprogram/generic declarations (specs)\n+   --    %b  for package/subprogram/generic bodies and subunits\n+\n+   --  Unit names are stored in the names table, and referred to by the\n+   --  corresponding Name_Id values. The subtype Unit_Name, which is a\n+   --  synonym for Name_Id, is used to indicate that a Name_Id value that\n+   --  holds a unit name (as defined above) is expected.\n+\n+   --  Note: as far as possible the conventions for unit names are encapsulated\n+   --  in this package. The one exception is that package Fname, which provides\n+   --  conversion routines from unit names to file names must be aware of the\n+   --  precise conventions that are used.\n+\n+   -------------------\n+   -- Display Names --\n+   -------------------\n+\n+   --  For display purposes, unit names are printed out with the suffix\n+   --  \" (body)\" for a body and \" (spec)\" for a spec. These formats are\n+   --  used for the Write_Unit_Name and Get_Unit_Name_String subprograms.\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   function Get_Body_Name (N : Unit_Name_Type) return Unit_Name_Type;\n+   --  Given the name of a spec, this function returns the name of the\n+   --  corresponding body, i.e. characters %s replaced by %b\n+\n+   function Get_Parent_Body_Name (N : Unit_Name_Type) return Unit_Name_Type;\n+   --  Given the name of a subunit, returns the name of the parent body.\n+\n+   function Get_Parent_Spec_Name (N : Unit_Name_Type) return Unit_Name_Type;\n+   --  Given the name of a child unit spec or body, returns the unit name\n+   --  of the parent spec. Returns No_Name if the given name is not the name\n+   --  of a child unit.\n+\n+   procedure Get_External_Unit_Name_String (N : Unit_Name_Type);\n+   --  Given the name of a body or spec unit, this procedure places in\n+   --  Name_Buffer the name of the unit with periods replaced by double\n+   --  underscores. The spec/body indication is eliminated. The length\n+   --  of the stored name is placed in Name_Len. All letters are lower\n+   --  case, corresponding to the string used in external names.\n+\n+   function Get_Spec_Name (N : Unit_Name_Type) return Unit_Name_Type;\n+   --  Given the name of a body, this function returns the name of the\n+   --  corresponding spec, i.e. characters %b replaced by %s\n+\n+   function Get_Unit_Name (N : Node_Id) return Unit_Name_Type;\n+   --  This procedure returns the unit name that corresponds to the given node,\n+   --  which is one of the following:\n+   --\n+   --    N_Subprogram_Declaration         (spec) cases\n+   --    N_Package_Declaration\n+   --    N_Generic_Declaration\n+   --    N_With_Clause\n+   --    N_Function_Instantiation\n+   --    N_Package_Instantiation\n+   --    N_Procedure_Instantiation\n+   --    N_Pragma (Elaborate case)\n+   --\n+   --    N_Package_Body                   (body) cases\n+   --    N_Subprogram_Body\n+   --    N_Identifier\n+   --    N_Selected_Component\n+   --\n+   --    N_Subprogram_Body_Stub           (subunit) cases\n+   --    N_Package_Body_Stub\n+   --    N_Task_Body_Stub\n+   --    N_Protected_Body_Stub\n+   --    N_Subunit\n+\n+   procedure Get_Unit_Name_String (N : Unit_Name_Type);\n+   --  Places the display name of the unit in Name_Buffer and sets Name_Len\n+   --  to the length of the stored name, i.e. it uses the same interface as\n+   --  the Get_Name_String routine in the Namet package. The name contains\n+   --  an indication of spec or body, and is decoded.\n+\n+   function Is_Body_Name (N : Unit_Name_Type) return Boolean;\n+   --  Returns True iff the given name is the unit name of a body (i.e. if\n+   --  it ends with the characters %b).\n+\n+   function Is_Child_Name (N : Unit_Name_Type) return Boolean;\n+   --  Returns True iff the given name is a child unit name (of either a\n+   --  body or a spec).\n+\n+   function Is_Spec_Name (N : Unit_Name_Type) return Boolean;\n+   --  Returns True iff the given name is the unit name of a specification\n+   --  (i.e. if it ends with the characters %s).\n+\n+   function Name_To_Unit_Name (N : Name_Id) return Unit_Name_Type;\n+   --  Given the Id of the Ada name of a unit, this function returns the\n+   --  corresponding unit name of the spec (by appending %s to the name).\n+\n+   function New_Child\n+     (Old  : Unit_Name_Type;\n+      Newp : Unit_Name_Type)\n+      return Unit_Name_Type;\n+   --   Old is a child unit name (for either a body or spec). Newp is the\n+   --   unit name of the actual parent (this may be different from the\n+   --   parent in old). The returned unit name is formed by taking the\n+   --   parent name from Newp and the child unit name from Old, with the\n+   --   result being a body or spec depending on Old. For example:\n+   --\n+   --     Old    = A.B.C (body)\n+   --     Newp   = A.R (spec)\n+   --     result = A.R.C (body)\n+   --\n+   --   See spec of Load_Unit for extensive discussion of why this routine\n+   --   needs to be used (the call in the body of Load_Unit is the only one).\n+\n+   function Uname_Ge (Left, Right : Unit_Name_Type) return Boolean;\n+   function Uname_Gt (Left, Right : Unit_Name_Type) return Boolean;\n+   function Uname_Le (Left, Right : Unit_Name_Type) return Boolean;\n+   function Uname_Lt (Left, Right : Unit_Name_Type) return Boolean;\n+   --  These functions perform lexicographic ordering of unit names. The\n+   --  ordering is suitable for printing, and is not quite a straightforward\n+   --  comparison of the names, since the convention is that specs appear\n+   --  before bodies. Note that the standard = and /= operators work fine\n+   --  because all unit names are hashed into the name table, so if two names\n+   --  are the same, they always have the same Name_Id value.\n+\n+   procedure Write_Unit_Name (N : Unit_Name_Type);\n+   --  Given a unit name, this procedure writes the display name to the\n+   --  standard output file. Name_Buffer and Name_Len are set as described\n+   --  above for the Get_Unit_Name_String call on return.\n+\n+end Uname;"}, {"sha": "f501af5e22a192ea0397594d68e78e13215678ef", "filename": "gcc/ada/unchconv.ads", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Funchconv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Funchconv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funchconv.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,24 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                  U N C H E C K E D _ C O N V E R S I O N                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.15 $                             --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Source (<>) is limited private;\n+   type Target (<>) is limited private;\n+\n+function Unchecked_Conversion (S : Source) return Target;\n+pragma Import (Intrinsic, Unchecked_Conversion);\n+pragma Pure (Unchecked_Conversion);"}, {"sha": "2a24ca05627f87a1fa201d1daba41c429915f7e3", "filename": "gcc/ada/unchdeal.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Funchdeal.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Funchdeal.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funchdeal.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--               U N C H E C K E D _ D E A L L O C A T I O N                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.15 $                             --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Object (<>) is limited private;\n+   type Name is access Object;\n+\n+procedure Unchecked_Deallocation (X : in out Name);\n+pragma Import (Intrinsic, Unchecked_Deallocation);"}, {"sha": "941af1696475dfc79e554db0261f5ec7156365db", "filename": "gcc/ada/urealp.adb", "status": "added", "additions": 1472, "deletions": 0, "changes": 1472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Furealp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Furealp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,1472 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               U R E A L P                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                             $Revision: 1.60 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Alloc;\n+with Output;  use Output;\n+with Table;\n+with Tree_IO; use Tree_IO;\n+\n+package body Urealp is\n+\n+   Ureal_First_Entry : constant Ureal := Ureal'Succ (No_Ureal);\n+   --  First subscript allocated in Ureal table (note that we can't just\n+   --  add 1 to No_Ureal, since \"+\" means something different for Ureals!\n+\n+   type Ureal_Entry is record\n+      Num  : Uint;\n+      --  Numerator (always non-negative)\n+\n+      Den  : Uint;\n+      --  Denominator (always non-zero, always positive if base is zero)\n+\n+      Rbase : Nat;\n+      --  Base value. If Rbase is zero, then the value is simply Num / Den.\n+      --  If Rbase is non-zero, then the value is Num / (Rbase ** Den)\n+\n+      Negative : Boolean;\n+      --  Flag set if value is negative\n+\n+   end record;\n+\n+   package Ureals is new Table.Table (\n+     Table_Component_Type => Ureal_Entry,\n+     Table_Index_Type     => Ureal,\n+     Table_Low_Bound      => Ureal_First_Entry,\n+     Table_Initial        => Alloc.Ureals_Initial,\n+     Table_Increment      => Alloc.Ureals_Increment,\n+     Table_Name           => \"Ureals\");\n+\n+   --  The following universal reals are the values returned by the constant\n+   --  functions. They are initialized by the initialization procedure.\n+\n+   UR_M_0        : Ureal;\n+   UR_0          : Ureal;\n+   UR_Tenth      : Ureal;\n+   UR_Half       : Ureal;\n+   UR_1          : Ureal;\n+   UR_2          : Ureal;\n+   UR_10         : Ureal;\n+   UR_100        : Ureal;\n+   UR_2_128      : Ureal;\n+   UR_2_M_128    : Ureal;\n+\n+   Num_Ureal_Constants : constant := 10;\n+   --  This is used for an assertion check in Tree_Read and Tree_Write to\n+   --  help remember to add values to these routines when we add to the list.\n+\n+   Normalized_Real : Ureal := No_Ureal;\n+   --  Used to memoize Norm_Num and Norm_Den, if either of these functions\n+   --  is called, this value is set and Normalized_Entry contains the result\n+   --  of the normalization. On subsequent calls, this is used to avoid the\n+   --  call to Normalize if it has already been made.\n+\n+   Normalized_Entry : Ureal_Entry;\n+   --  Entry built by most recent call to Normalize\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Decimal_Exponent_Hi (V : Ureal) return Int;\n+   --  Returns an estimate of the exponent of Val represented as a normalized\n+   --  decimal number (non-zero digit before decimal point), The estimate is\n+   --  either correct, or high, but never low. The accuracy of the estimate\n+   --  affects only the efficiency of the comparison routines.\n+\n+   function Decimal_Exponent_Lo (V : Ureal) return Int;\n+   --  Returns an estimate of the exponent of Val represented as a normalized\n+   --  decimal number (non-zero digit before decimal point), The estimate is\n+   --  either correct, or low, but never high. The accuracy of the estimate\n+   --  affects only the efficiency of the comparison routines.\n+\n+   function Equivalent_Decimal_Exponent (U : Ureal_Entry) return Int;\n+   --  U is a Ureal entry for which the base value is non-zero, the value\n+   --  returned is the equivalent decimal exponent value, i.e. the value of\n+   --  Den, adjusted as though the base were base 10. The value is rounded\n+   --  to the nearest integer, and so can be one off.\n+\n+   function Is_Integer (Num, Den : Uint) return Boolean;\n+   --  Return true if the real quotient of Num / Den is an integer value\n+\n+   function Normalize (Val : Ureal_Entry) return Ureal_Entry;\n+   --  Normalizes the Ureal_Entry by reducing it to lowest terms (with a\n+   --  base value of 0).\n+\n+   function Same (U1, U2 : Ureal) return Boolean;\n+   pragma Inline (Same);\n+   --  Determines if U1 and U2 are the same Ureal. Note that we cannot use\n+   --  the equals operator for this test, since that tests for equality,\n+   --  not identity.\n+\n+   function Store_Ureal (Val : Ureal_Entry) return Ureal;\n+   --  This store a new entry in the universal reals table and return\n+   --  its index in the table.\n+\n+   -------------------------\n+   -- Decimal_Exponent_Hi --\n+   -------------------------\n+\n+   function Decimal_Exponent_Hi (V : Ureal) return Int is\n+      Val : constant Ureal_Entry := Ureals.Table (V);\n+\n+   begin\n+      --  Zero always returns zero\n+\n+      if UR_Is_Zero (V) then\n+         return 0;\n+\n+      --  For numbers in rational form, get the maximum number of digits in the\n+      --  numerator and the minimum number of digits in the denominator, and\n+      --  subtract. For example:\n+\n+      --     1000 / 99 = 1.010E+1\n+      --     9999 / 10 = 9.999E+2\n+\n+      --  This estimate may of course be high, but that is acceptable\n+\n+      elsif Val.Rbase = 0 then\n+         return UI_Decimal_Digits_Hi (Val.Num) -\n+                UI_Decimal_Digits_Lo (Val.Den);\n+\n+      --  For based numbers, just subtract the decimal exponent from the\n+      --  high estimate of the number of digits in the numerator and add\n+      --  one to accomodate possible round off errors for non-decimal\n+      --  bases. For example:\n+\n+      --     1_500_000 / 10**4 = 1.50E-2\n+\n+      else -- Val.Rbase /= 0\n+         return UI_Decimal_Digits_Hi (Val.Num) -\n+                Equivalent_Decimal_Exponent (Val) + 1;\n+      end if;\n+\n+   end Decimal_Exponent_Hi;\n+\n+   -------------------------\n+   -- Decimal_Exponent_Lo --\n+   -------------------------\n+\n+   function Decimal_Exponent_Lo (V : Ureal) return Int is\n+      Val : constant Ureal_Entry := Ureals.Table (V);\n+\n+   begin\n+      --  Zero always returns zero\n+\n+      if UR_Is_Zero (V) then\n+         return 0;\n+\n+      --  For numbers in rational form, get min digits in numerator, max digits\n+      --  in denominator, and subtract and subtract one more for possible loss\n+      --  during the division. For example:\n+\n+      --     1000 / 99 = 1.010E+1\n+      --     9999 / 10 = 9.999E+2\n+\n+      --  This estimate may of course be low, but that is acceptable\n+\n+      elsif Val.Rbase = 0 then\n+         return UI_Decimal_Digits_Lo (Val.Num) -\n+                UI_Decimal_Digits_Hi (Val.Den) - 1;\n+\n+      --  For based numbers, just subtract the decimal exponent from the\n+      --  low estimate of the number of digits in the numerator and subtract\n+      --  one to accomodate possible round off errors for non-decimal\n+      --  bases. For example:\n+\n+      --     1_500_000 / 10**4 = 1.50E-2\n+\n+      else -- Val.Rbase /= 0\n+         return UI_Decimal_Digits_Lo (Val.Num) -\n+                Equivalent_Decimal_Exponent (Val) - 1;\n+      end if;\n+\n+   end Decimal_Exponent_Lo;\n+\n+   -----------------\n+   -- Denominator --\n+   -----------------\n+\n+   function Denominator (Real : Ureal) return Uint is\n+   begin\n+      return Ureals.Table (Real).Den;\n+   end Denominator;\n+\n+   ---------------------------------\n+   -- Equivalent_Decimal_Exponent --\n+   ---------------------------------\n+\n+   function Equivalent_Decimal_Exponent (U : Ureal_Entry) return Int is\n+\n+      --  The following table is a table of logs to the base 10\n+\n+      Logs : constant array (Nat range 1 .. 16) of Long_Float := (\n+                1 => 0.000000000000000,\n+                2 => 0.301029995663981,\n+                3 => 0.477121254719662,\n+                4 => 0.602059991327962,\n+                5 => 0.698970004336019,\n+                6 => 0.778151250383644,\n+                7 => 0.845098040014257,\n+                8 => 0.903089986991944,\n+                9 => 0.954242509439325,\n+               10 => 1.000000000000000,\n+               11 => 1.041392685158230,\n+               12 => 1.079181246047620,\n+               13 => 1.113943352306840,\n+               14 => 1.146128035678240,\n+               15 => 1.176091259055680,\n+               16 => 1.204119982655920);\n+\n+   begin\n+      pragma Assert (U.Rbase /= 0);\n+      return Int (Long_Float (UI_To_Int (U.Den)) * Logs (U.Rbase));\n+   end Equivalent_Decimal_Exponent;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Ureals.Init;\n+      UR_0       := UR_From_Components (Uint_0, Uint_1,         0, False);\n+      UR_M_0     := UR_From_Components (Uint_0, Uint_1,         0, True);\n+      UR_Half    := UR_From_Components (Uint_1, Uint_1,         2, False);\n+      UR_Tenth   := UR_From_Components (Uint_1, Uint_1,        10, False);\n+      UR_1       := UR_From_Components (Uint_1, Uint_1,         0, False);\n+      UR_2       := UR_From_Components (Uint_1, Uint_Minus_1,   2, False);\n+      UR_10      := UR_From_Components (Uint_1, Uint_Minus_1,  10, False);\n+      UR_100     := UR_From_Components (Uint_1, Uint_Minus_2,  10, False);\n+      UR_2_128   := UR_From_Components (Uint_1, Uint_Minus_128, 2, False);\n+      UR_2_M_128 := UR_From_Components (Uint_1, Uint_128,       2, False);\n+   end Initialize;\n+\n+   ----------------\n+   -- Is_Integer --\n+   ----------------\n+\n+   function Is_Integer (Num, Den : Uint) return Boolean is\n+   begin\n+      return (Num / Den) * Den = Num;\n+   end Is_Integer;\n+\n+   ----------\n+   -- Mark --\n+   ----------\n+\n+   function Mark return Save_Mark is\n+   begin\n+      return Save_Mark (Ureals.Last);\n+   end Mark;\n+\n+   --------------\n+   -- Norm_Den --\n+   --------------\n+\n+   function Norm_Den (Real : Ureal) return Uint is\n+   begin\n+      if not Same (Real, Normalized_Real) then\n+         Normalized_Real  := Real;\n+         Normalized_Entry := Normalize (Ureals.Table (Real));\n+      end if;\n+\n+      return Normalized_Entry.Den;\n+   end Norm_Den;\n+\n+   --------------\n+   -- Norm_Num --\n+   --------------\n+\n+   function Norm_Num (Real : Ureal) return Uint is\n+   begin\n+      if not Same (Real, Normalized_Real) then\n+         Normalized_Real  := Real;\n+         Normalized_Entry := Normalize (Ureals.Table (Real));\n+      end if;\n+\n+      return Normalized_Entry.Num;\n+   end Norm_Num;\n+\n+   ---------------\n+   -- Normalize --\n+   ---------------\n+\n+   function Normalize (Val : Ureal_Entry) return Ureal_Entry is\n+      J   : Uint;\n+      K   : Uint;\n+      Tmp : Uint;\n+      Num : Uint;\n+      Den : Uint;\n+      M   : constant Uintp.Save_Mark := Uintp.Mark;\n+\n+   begin\n+      --  Start by setting J to the greatest of the absolute values of the\n+      --  numerator and the denominator (taking into account the base value),\n+      --  and K to the lesser of the two absolute values. The gcd of Num and\n+      --  Den is the gcd of J and K.\n+\n+      if Val.Rbase = 0 then\n+         J := Val.Num;\n+         K := Val.Den;\n+\n+      elsif Val.Den < 0 then\n+         J := Val.Num * Val.Rbase ** (-Val.Den);\n+         K := Uint_1;\n+\n+      else\n+         J := Val.Num;\n+         K := Val.Rbase ** Val.Den;\n+      end if;\n+\n+      Num := J;\n+      Den := K;\n+\n+      if K > J then\n+         Tmp := J;\n+         J := K;\n+         K := Tmp;\n+      end if;\n+\n+      J := UI_GCD (J, K);\n+      Num := Num / J;\n+      Den := Den / J;\n+      Uintp.Release_And_Save (M, Num, Den);\n+\n+      --  Divide numerator and denominator by gcd and return result\n+\n+      return (Num      => Num,\n+              Den      => Den,\n+              Rbase    => 0,\n+              Negative => Val.Negative);\n+   end Normalize;\n+\n+   ---------------\n+   -- Numerator --\n+   ---------------\n+\n+   function Numerator (Real : Ureal) return Uint is\n+   begin\n+      return Ureals.Table (Real).Num;\n+   end Numerator;\n+\n+   --------\n+   -- pr --\n+   --------\n+\n+   procedure pr (Real : Ureal) is\n+   begin\n+      UR_Write (Real);\n+      Write_Eol;\n+   end pr;\n+\n+   -----------\n+   -- Rbase --\n+   -----------\n+\n+   function Rbase (Real : Ureal) return Nat is\n+   begin\n+      return Ureals.Table (Real).Rbase;\n+   end Rbase;\n+\n+   -------------\n+   -- Release --\n+   -------------\n+\n+   procedure Release (M : Save_Mark) is\n+   begin\n+      Ureals.Set_Last (Ureal (M));\n+   end Release;\n+\n+   ----------\n+   -- Same --\n+   ----------\n+\n+   function Same (U1, U2 : Ureal) return Boolean is\n+   begin\n+      return Int (U1) = Int (U2);\n+   end Same;\n+\n+   -----------------\n+   -- Store_Ureal --\n+   -----------------\n+\n+   function Store_Ureal (Val : Ureal_Entry) return Ureal is\n+   begin\n+      Ureals.Increment_Last;\n+      Ureals.Table (Ureals.Last) := Val;\n+\n+      --  Normalize representation of signed values\n+\n+      if Val.Num < 0 then\n+         Ureals.Table (Ureals.Last).Negative := True;\n+         Ureals.Table (Ureals.Last).Num := -Val.Num;\n+      end if;\n+\n+      return Ureals.Last;\n+   end Store_Ureal;\n+\n+   ---------------\n+   -- Tree_Read --\n+   ---------------\n+\n+   procedure Tree_Read is\n+   begin\n+      pragma Assert (Num_Ureal_Constants = 10);\n+\n+      Ureals.Tree_Read;\n+      Tree_Read_Int (Int (UR_0));\n+      Tree_Read_Int (Int (UR_M_0));\n+      Tree_Read_Int (Int (UR_Tenth));\n+      Tree_Read_Int (Int (UR_Half));\n+      Tree_Read_Int (Int (UR_1));\n+      Tree_Read_Int (Int (UR_2));\n+      Tree_Read_Int (Int (UR_10));\n+      Tree_Read_Int (Int (UR_100));\n+      Tree_Read_Int (Int (UR_2_128));\n+      Tree_Read_Int (Int (UR_2_M_128));\n+\n+      --  Clear the normalization cache\n+\n+      Normalized_Real := No_Ureal;\n+   end Tree_Read;\n+\n+   ----------------\n+   -- Tree_Write --\n+   ----------------\n+\n+   procedure Tree_Write is\n+   begin\n+      pragma Assert (Num_Ureal_Constants = 10);\n+\n+      Ureals.Tree_Write;\n+      Tree_Write_Int (Int (UR_0));\n+      Tree_Write_Int (Int (UR_M_0));\n+      Tree_Write_Int (Int (UR_Tenth));\n+      Tree_Write_Int (Int (UR_Half));\n+      Tree_Write_Int (Int (UR_1));\n+      Tree_Write_Int (Int (UR_2));\n+      Tree_Write_Int (Int (UR_10));\n+      Tree_Write_Int (Int (UR_100));\n+      Tree_Write_Int (Int (UR_2_128));\n+      Tree_Write_Int (Int (UR_2_M_128));\n+   end Tree_Write;\n+\n+   ------------\n+   -- UR_Abs --\n+   ------------\n+\n+   function UR_Abs (Real : Ureal) return Ureal is\n+      Val : constant Ureal_Entry := Ureals.Table (Real);\n+\n+   begin\n+      return Store_Ureal (\n+               (Num      => Val.Num,\n+                Den      => Val.Den,\n+                Rbase    => Val.Rbase,\n+                Negative => False));\n+   end UR_Abs;\n+\n+   ------------\n+   -- UR_Add --\n+   ------------\n+\n+   function UR_Add (Left : Uint; Right : Ureal) return Ureal is\n+   begin\n+      return UR_From_Uint (Left) + Right;\n+   end UR_Add;\n+\n+   function UR_Add (Left : Ureal; Right : Uint) return Ureal is\n+   begin\n+      return Left + UR_From_Uint (Right);\n+   end UR_Add;\n+\n+   function UR_Add (Left : Ureal; Right : Ureal) return Ureal is\n+      Lval : Ureal_Entry := Ureals.Table (Left);\n+      Rval : Ureal_Entry := Ureals.Table (Right);\n+\n+      Num  : Uint;\n+\n+   begin\n+      --  Note, in the temporary Ureal_Entry values used in this procedure,\n+      --  we store the sign as the sign of the numerator (i.e. xxx.Num may\n+      --  be negative, even though in stored entries this can never be so)\n+\n+      if Lval.Rbase /= 0 and then Lval.Rbase = Rval.Rbase then\n+\n+         declare\n+            Opd_Min, Opd_Max   : Ureal_Entry;\n+            Exp_Min, Exp_Max   : Uint;\n+\n+         begin\n+            if Lval.Negative then\n+               Lval.Num := (-Lval.Num);\n+            end if;\n+\n+            if Rval.Negative then\n+               Rval.Num := (-Rval.Num);\n+            end if;\n+\n+            if Lval.Den < Rval.Den then\n+               Exp_Min := Lval.Den;\n+               Exp_Max := Rval.Den;\n+               Opd_Min := Lval;\n+               Opd_Max := Rval;\n+            else\n+               Exp_Min := Rval.Den;\n+               Exp_Max := Lval.Den;\n+               Opd_Min := Rval;\n+               Opd_Max := Lval;\n+            end if;\n+\n+            Num :=\n+              Opd_Min.Num * Lval.Rbase ** (Exp_Max - Exp_Min) + Opd_Max.Num;\n+\n+            if Num = 0 then\n+               return Store_Ureal (\n+                        (Num      => Uint_0,\n+                         Den      => Uint_1,\n+                         Rbase    => 0,\n+                         Negative => Lval.Negative));\n+\n+            else\n+               return Store_Ureal (\n+                        (Num      => abs Num,\n+                         Den      => Exp_Max,\n+                         Rbase    => Lval.Rbase,\n+                         Negative => (Num < 0)));\n+            end if;\n+         end;\n+\n+      else\n+         declare\n+            Ln : Ureal_Entry := Normalize (Lval);\n+            Rn : Ureal_Entry := Normalize (Rval);\n+\n+         begin\n+            if Ln.Negative then\n+               Ln.Num := (-Ln.Num);\n+            end if;\n+\n+            if Rn.Negative then\n+               Rn.Num := (-Rn.Num);\n+            end if;\n+\n+            Num := (Ln.Num * Rn.Den) + (Rn.Num * Ln.Den);\n+\n+            if Num = 0 then\n+               return Store_Ureal (\n+                        (Num      => Uint_0,\n+                         Den      => Uint_1,\n+                         Rbase    => 0,\n+                         Negative => Lval.Negative));\n+\n+            else\n+               return Store_Ureal (\n+                        Normalize (\n+                          (Num      => abs Num,\n+                           Den      => Ln.Den * Rn.Den,\n+                           Rbase    => 0,\n+                           Negative => (Num < 0))));\n+            end if;\n+         end;\n+      end if;\n+   end UR_Add;\n+\n+   ----------------\n+   -- UR_Ceiling --\n+   ----------------\n+\n+   function UR_Ceiling (Real : Ureal) return Uint is\n+      Val : Ureal_Entry := Normalize (Ureals.Table (Real));\n+\n+   begin\n+      if Val.Negative then\n+         return UI_Negate (Val.Num / Val.Den);\n+      else\n+         return (Val.Num + Val.Den - 1) / Val.Den;\n+      end if;\n+   end UR_Ceiling;\n+\n+   ------------\n+   -- UR_Div --\n+   ------------\n+\n+   function UR_Div (Left : Uint; Right : Ureal) return Ureal is\n+   begin\n+      return UR_From_Uint (Left) / Right;\n+   end UR_Div;\n+\n+   function UR_Div (Left : Ureal; Right : Uint) return Ureal is\n+   begin\n+      return Left / UR_From_Uint (Right);\n+   end UR_Div;\n+\n+   function UR_Div (Left, Right : Ureal) return Ureal is\n+      Lval : constant Ureal_Entry := Ureals.Table (Left);\n+      Rval : constant Ureal_Entry := Ureals.Table (Right);\n+      Rneg : constant Boolean     := Rval.Negative xor Lval.Negative;\n+\n+   begin\n+      pragma Assert (Rval.Num /= Uint_0);\n+\n+      if Lval.Rbase = 0 then\n+\n+         if Rval.Rbase = 0 then\n+            return Store_Ureal (\n+                     Normalize (\n+                       (Num      => Lval.Num * Rval.Den,\n+                        Den      => Lval.Den * Rval.Num,\n+                        Rbase    => 0,\n+                        Negative => Rneg)));\n+\n+         elsif Is_Integer (Lval.Num, Rval.Num * Lval.Den) then\n+            return Store_Ureal (\n+                     (Num      => Lval.Num / (Rval.Num * Lval.Den),\n+                      Den      => (-Rval.Den),\n+                      Rbase    => Rval.Rbase,\n+                      Negative => Rneg));\n+\n+         elsif Rval.Den < 0 then\n+            return Store_Ureal (\n+                     Normalize (\n+                       (Num      => Lval.Num,\n+                        Den      => Rval.Rbase ** (-Rval.Den) *\n+                                    Rval.Num *\n+                                    Lval.Den,\n+                        Rbase    => 0,\n+                        Negative => Rneg)));\n+\n+         else\n+            return Store_Ureal (\n+                     Normalize (\n+                       (Num      => Lval.Num * Rval.Rbase ** Rval.Den,\n+                        Den      => Rval.Num * Lval.Den,\n+                        Rbase    => 0,\n+                        Negative => Rneg)));\n+         end if;\n+\n+      elsif Is_Integer (Lval.Num, Rval.Num) then\n+\n+         if Rval.Rbase = Lval.Rbase then\n+            return Store_Ureal (\n+                     (Num      => Lval.Num / Rval.Num,\n+                      Den      => Lval.Den - Rval.Den,\n+                      Rbase    => Lval.Rbase,\n+                      Negative => Rneg));\n+\n+         elsif Rval.Rbase = 0 then\n+            return Store_Ureal (\n+                     (Num      => (Lval.Num / Rval.Num) * Rval.Den,\n+                      Den      => Lval.Den,\n+                      Rbase    => Lval.Rbase,\n+                      Negative => Rneg));\n+\n+         elsif Rval.Den < 0 then\n+            declare\n+               Num, Den : Uint;\n+\n+            begin\n+               if Lval.Den < 0 then\n+                  Num := (Lval.Num / Rval.Num) * (Lval.Rbase ** (-Lval.Den));\n+                  Den := Rval.Rbase ** (-Rval.Den);\n+               else\n+                  Num := Lval.Num / Rval.Num;\n+                  Den := (Lval.Rbase ** Lval.Den) *\n+                         (Rval.Rbase ** (-Rval.Den));\n+               end if;\n+\n+               return Store_Ureal (\n+                        (Num      => Num,\n+                         Den      => Den,\n+                         Rbase    => 0,\n+                         Negative => Rneg));\n+            end;\n+\n+         else\n+            return Store_Ureal (\n+                     (Num      => (Lval.Num / Rval.Num) *\n+                                  (Rval.Rbase ** Rval.Den),\n+                      Den      => Lval.Den,\n+                      Rbase    => Lval.Rbase,\n+                      Negative => Rneg));\n+         end if;\n+\n+      else\n+         declare\n+            Num, Den : Uint;\n+\n+         begin\n+            if Lval.Den < 0 then\n+               Num := Lval.Num * (Lval.Rbase ** (-Lval.Den));\n+               Den := Rval.Num;\n+\n+            else\n+               Num := Lval.Num;\n+               Den := Rval.Num * (Lval.Rbase ** Lval.Den);\n+            end if;\n+\n+            if Rval.Rbase /= 0 then\n+               if Rval.Den < 0 then\n+                  Den := Den * (Rval.Rbase ** (-Rval.Den));\n+               else\n+                  Num := Num * (Rval.Rbase ** Rval.Den);\n+               end if;\n+\n+            else\n+               Num := Num * Rval.Den;\n+            end if;\n+\n+            return Store_Ureal (\n+                     Normalize (\n+                       (Num      => Num,\n+                        Den      => Den,\n+                        Rbase    => 0,\n+                        Negative => Rneg)));\n+         end;\n+      end if;\n+   end UR_Div;\n+\n+   -----------\n+   -- UR_Eq --\n+   -----------\n+\n+   function UR_Eq (Left, Right : Ureal) return Boolean is\n+   begin\n+      return not UR_Ne (Left, Right);\n+   end UR_Eq;\n+\n+   ---------------------\n+   -- UR_Exponentiate --\n+   ---------------------\n+\n+   function UR_Exponentiate (Real : Ureal; N : Uint) return Ureal is\n+      Bas  : Ureal;\n+      Val  : Ureal_Entry;\n+      X    : Uint := abs N;\n+      Neg  : Boolean;\n+      IBas : Uint;\n+\n+   begin\n+      --  If base is negative, then the resulting sign depends on whether\n+      --  the exponent is even or odd (even => positive, odd = negative)\n+\n+      if UR_Is_Negative (Real) then\n+         Neg := (N mod 2) /= 0;\n+         Bas := UR_Negate (Real);\n+      else\n+         Neg := False;\n+         Bas := Real;\n+      end if;\n+\n+      Val := Ureals.Table (Bas);\n+\n+      --  If the base is a small integer, then we can return the result in\n+      --  exponential form, which can save a lot of time for junk exponents.\n+\n+      IBas := UR_Trunc (Bas);\n+\n+      if IBas <= 16\n+        and then UR_From_Uint (IBas) = Bas\n+      then\n+         return Store_Ureal (\n+                 (Num      => Uint_1,\n+                  Den      => -N,\n+                  Rbase    => UI_To_Int (UR_Trunc (Bas)),\n+                  Negative => Neg));\n+\n+      --  If the exponent is negative then we raise the numerator and the\n+      --  denominator (after normalization) to the absolute value of the\n+      --  exponent and we return the reciprocal. An assert error will happen\n+      --  if the numerator is zero.\n+\n+      elsif N < 0 then\n+         pragma Assert (Val.Num /= 0);\n+         Val := Normalize (Val);\n+\n+         return Store_Ureal (\n+                 (Num      => Val.Den ** X,\n+                  Den      => Val.Num ** X,\n+                  Rbase    => 0,\n+                  Negative => Neg));\n+\n+      --  If positive, we distinguish the case when the base is not zero, in\n+      --  which case the new denominator is just the product of the old one\n+      --  with the exponent,\n+\n+      else\n+         if Val.Rbase /= 0 then\n+\n+            return Store_Ureal (\n+                    (Num      => Val.Num ** X,\n+                     Den      => Val.Den * X,\n+                     Rbase    => Val.Rbase,\n+                     Negative => Neg));\n+\n+         --  And when the base is zero, in which case we exponentiate\n+         --  the old denominator.\n+\n+         else\n+            return Store_Ureal (\n+                    (Num      => Val.Num ** X,\n+                     Den      => Val.Den ** X,\n+                     Rbase    => 0,\n+                     Negative => Neg));\n+         end if;\n+      end if;\n+   end UR_Exponentiate;\n+\n+   --------------\n+   -- UR_Floor --\n+   --------------\n+\n+   function UR_Floor (Real : Ureal) return Uint is\n+      Val : Ureal_Entry := Normalize (Ureals.Table (Real));\n+\n+   begin\n+      if Val.Negative then\n+         return UI_Negate ((Val.Num + Val.Den - 1) / Val.Den);\n+      else\n+         return Val.Num / Val.Den;\n+      end if;\n+   end UR_Floor;\n+\n+   -------------------------\n+   --  UR_From_Components --\n+   -------------------------\n+\n+   function UR_From_Components\n+     (Num      : Uint;\n+      Den      : Uint;\n+      Rbase    : Nat := 0;\n+      Negative : Boolean := False)\n+      return     Ureal\n+   is\n+   begin\n+      return Store_Ureal (\n+               (Num      => Num,\n+                Den      => Den,\n+                Rbase    => Rbase,\n+                Negative => Negative));\n+   end UR_From_Components;\n+\n+   ------------------\n+   -- UR_From_Uint --\n+   ------------------\n+\n+   function UR_From_Uint (UI : Uint) return Ureal is\n+   begin\n+      return UR_From_Components\n+        (abs UI, Uint_1, Negative => (UI < 0));\n+   end UR_From_Uint;\n+\n+   -----------\n+   -- UR_Ge --\n+   -----------\n+\n+   function UR_Ge (Left, Right : Ureal) return Boolean is\n+   begin\n+      return not (Left < Right);\n+   end UR_Ge;\n+\n+   -----------\n+   -- UR_Gt --\n+   -----------\n+\n+   function UR_Gt (Left, Right : Ureal) return Boolean is\n+   begin\n+      return (Right < Left);\n+   end UR_Gt;\n+\n+   --------------------\n+   -- UR_Is_Negative --\n+   --------------------\n+\n+   function UR_Is_Negative (Real : Ureal) return Boolean is\n+   begin\n+      return Ureals.Table (Real).Negative;\n+   end UR_Is_Negative;\n+\n+   --------------------\n+   -- UR_Is_Positive --\n+   --------------------\n+\n+   function UR_Is_Positive (Real : Ureal) return Boolean is\n+   begin\n+      return not Ureals.Table (Real).Negative\n+        and then Ureals.Table (Real).Num /= 0;\n+   end UR_Is_Positive;\n+\n+   ----------------\n+   -- UR_Is_Zero --\n+   ----------------\n+\n+   function UR_Is_Zero (Real : Ureal) return Boolean is\n+   begin\n+      return Ureals.Table (Real).Num = 0;\n+   end UR_Is_Zero;\n+\n+   -----------\n+   -- UR_Le --\n+   -----------\n+\n+   function UR_Le (Left, Right : Ureal) return Boolean is\n+   begin\n+      return not (Right < Left);\n+   end UR_Le;\n+\n+   -----------\n+   -- UR_Lt --\n+   -----------\n+\n+   function UR_Lt (Left, Right : Ureal) return Boolean is\n+   begin\n+      --  An operand is not less than itself\n+\n+      if Same (Left, Right) then\n+         return False;\n+\n+      --  Deal with zero cases\n+\n+      elsif UR_Is_Zero (Left) then\n+         return UR_Is_Positive (Right);\n+\n+      elsif UR_Is_Zero (Right) then\n+         return Ureals.Table (Left).Negative;\n+\n+      --  Different signs are decisive (note we dealt with zero cases)\n+\n+      elsif Ureals.Table (Left).Negative\n+        and then not Ureals.Table (Right).Negative\n+      then\n+         return True;\n+\n+      elsif not Ureals.Table (Left).Negative\n+        and then Ureals.Table (Right).Negative\n+      then\n+         return False;\n+\n+      --  Signs are same, do rapid check based on worst case estimates of\n+      --  decimal exponent, which will often be decisive. Precise test\n+      --  depends on whether operands are positive or negative.\n+\n+      elsif Decimal_Exponent_Hi (Left) < Decimal_Exponent_Lo (Right) then\n+         return UR_Is_Positive (Left);\n+\n+      elsif Decimal_Exponent_Lo (Left) > Decimal_Exponent_Hi (Right) then\n+         return UR_Is_Negative (Left);\n+\n+      --  If we fall through, full gruesome test is required. This happens\n+      --  if the numbers are close together, or in some wierd (/=10) base.\n+\n+      else\n+         declare\n+            Imrk   : constant Uintp.Save_Mark  := Mark;\n+            Rmrk   : constant Urealp.Save_Mark := Mark;\n+            Lval   : Ureal_Entry;\n+            Rval   : Ureal_Entry;\n+            Result : Boolean;\n+\n+         begin\n+            Lval := Ureals.Table (Left);\n+            Rval := Ureals.Table (Right);\n+\n+            --  An optimization. If both numbers are based, then subtract\n+            --  common value of base to avoid unnecessarily giant numbers\n+\n+            if Lval.Rbase = Rval.Rbase and then Lval.Rbase /= 0 then\n+               if Lval.Den < Rval.Den then\n+                  Rval.Den := Rval.Den - Lval.Den;\n+                  Lval.Den := Uint_0;\n+               else\n+                  Lval.Den := Lval.Den - Rval.Den;\n+                  Rval.Den := Uint_0;\n+               end if;\n+            end if;\n+\n+            Lval := Normalize (Lval);\n+            Rval := Normalize (Rval);\n+\n+            if Lval.Negative then\n+               Result := (Lval.Num * Rval.Den) > (Rval.Num * Lval.Den);\n+            else\n+               Result := (Lval.Num * Rval.Den) < (Rval.Num * Lval.Den);\n+            end if;\n+\n+            Release (Imrk);\n+            Release (Rmrk);\n+            return Result;\n+         end;\n+      end if;\n+   end UR_Lt;\n+\n+   ------------\n+   -- UR_Max --\n+   ------------\n+\n+   function UR_Max (Left, Right : Ureal) return Ureal is\n+   begin\n+      if Left >= Right then\n+         return Left;\n+      else\n+         return Right;\n+      end if;\n+   end UR_Max;\n+\n+   ------------\n+   -- UR_Min --\n+   ------------\n+\n+   function UR_Min (Left, Right : Ureal) return Ureal is\n+   begin\n+      if Left <= Right then\n+         return Left;\n+      else\n+         return Right;\n+      end if;\n+   end UR_Min;\n+\n+   ------------\n+   -- UR_Mul --\n+   ------------\n+\n+   function UR_Mul (Left : Uint; Right : Ureal) return Ureal is\n+   begin\n+      return UR_From_Uint (Left) * Right;\n+   end UR_Mul;\n+\n+   function UR_Mul (Left : Ureal; Right : Uint) return Ureal is\n+   begin\n+      return Left * UR_From_Uint (Right);\n+   end UR_Mul;\n+\n+   function UR_Mul (Left, Right : Ureal) return Ureal is\n+      Lval : constant Ureal_Entry := Ureals.Table (Left);\n+      Rval : constant Ureal_Entry := Ureals.Table (Right);\n+      Num  : Uint                 := Lval.Num * Rval.Num;\n+      Den  : Uint;\n+      Rneg : constant Boolean     := Lval.Negative xor Rval.Negative;\n+\n+   begin\n+      if Lval.Rbase = 0 then\n+         if Rval.Rbase = 0 then\n+            return Store_Ureal (\n+                     Normalize (\n+                        (Num      => Num,\n+                         Den      => Lval.Den * Rval.Den,\n+                         Rbase    => 0,\n+                         Negative => Rneg)));\n+\n+         elsif Is_Integer (Num, Lval.Den) then\n+            return Store_Ureal (\n+                     (Num      => Num / Lval.Den,\n+                      Den      => Rval.Den,\n+                      Rbase    => Rval.Rbase,\n+                      Negative => Rneg));\n+\n+         elsif Rval.Den < 0 then\n+            return Store_Ureal (\n+                     Normalize (\n+                       (Num      => Num * (Rval.Rbase ** (-Rval.Den)),\n+                        Den      => Lval.Den,\n+                        Rbase    => 0,\n+                        Negative => Rneg)));\n+\n+         else\n+            return Store_Ureal (\n+                     Normalize (\n+                       (Num      => Num,\n+                        Den      => Lval.Den * (Rval.Rbase ** Rval.Den),\n+                        Rbase    => 0,\n+                        Negative => Rneg)));\n+         end if;\n+\n+      elsif Lval.Rbase = Rval.Rbase then\n+         return Store_Ureal (\n+                  (Num      => Num,\n+                   Den      => Lval.Den + Rval.Den,\n+                   Rbase    => Lval.Rbase,\n+                   Negative => Rneg));\n+\n+      elsif Rval.Rbase = 0 then\n+         if Is_Integer (Num, Rval.Den) then\n+            return Store_Ureal (\n+                     (Num      => Num / Rval.Den,\n+                      Den      => Lval.Den,\n+                      Rbase    => Lval.Rbase,\n+                      Negative => Rneg));\n+\n+         elsif Lval.Den < 0 then\n+            return Store_Ureal (\n+                     Normalize (\n+                       (Num      => Num * (Lval.Rbase ** (-Lval.Den)),\n+                        Den      => Rval.Den,\n+                        Rbase    => 0,\n+                        Negative => Rneg)));\n+\n+         else\n+            return Store_Ureal (\n+                     Normalize (\n+                       (Num      => Num,\n+                        Den      => Rval.Den * (Lval.Rbase ** Lval.Den),\n+                        Rbase    => 0,\n+                        Negative => Rneg)));\n+         end if;\n+\n+      else\n+         Den := Uint_1;\n+\n+         if Lval.Den < 0 then\n+            Num := Num * (Lval.Rbase ** (-Lval.Den));\n+         else\n+            Den := Den * (Lval.Rbase ** Lval.Den);\n+         end if;\n+\n+         if Rval.Den < 0 then\n+            Num := Num * (Rval.Rbase ** (-Rval.Den));\n+         else\n+            Den := Den * (Rval.Rbase ** Rval.Den);\n+         end if;\n+\n+         return Store_Ureal (\n+                  Normalize (\n+                    (Num      => Num,\n+                     Den      => Den,\n+                     Rbase    => 0,\n+                     Negative => Rneg)));\n+      end if;\n+\n+   end UR_Mul;\n+\n+   -----------\n+   -- UR_Ne --\n+   -----------\n+\n+   function UR_Ne (Left, Right : Ureal) return Boolean is\n+   begin\n+      --  Quick processing for case of identical Ureal values (note that\n+      --  this also deals with comparing two No_Ureal values).\n+\n+      if Same (Left, Right) then\n+         return False;\n+\n+      --  Deal with case of one or other operand is No_Ureal, but not both\n+\n+      elsif Same (Left, No_Ureal) or else Same (Right, No_Ureal) then\n+         return True;\n+\n+      --  Do quick check based on number of decimal digits\n+\n+      elsif Decimal_Exponent_Hi (Left) < Decimal_Exponent_Lo (Right) or else\n+            Decimal_Exponent_Lo (Left) > Decimal_Exponent_Hi (Right)\n+      then\n+         return True;\n+\n+      --  Otherwise full comparison is required\n+\n+      else\n+         declare\n+            Imrk   : constant Uintp.Save_Mark  := Mark;\n+            Rmrk   : constant Urealp.Save_Mark := Mark;\n+            Lval   : constant Ureal_Entry := Normalize (Ureals.Table (Left));\n+            Rval   : constant Ureal_Entry := Normalize (Ureals.Table (Right));\n+            Result : Boolean;\n+\n+         begin\n+            if UR_Is_Zero (Left) then\n+               return not UR_Is_Zero (Right);\n+\n+            elsif UR_Is_Zero (Right) then\n+               return not UR_Is_Zero (Left);\n+\n+            --  Both operands are non-zero\n+\n+            else\n+               Result :=\n+                  Rval.Negative /= Lval.Negative\n+                   or else Rval.Num /= Lval.Num\n+                   or else Rval.Den /= Lval.Den;\n+               Release (Imrk);\n+               Release (Rmrk);\n+               return Result;\n+            end if;\n+         end;\n+      end if;\n+   end UR_Ne;\n+\n+   ---------------\n+   -- UR_Negate --\n+   ---------------\n+\n+   function UR_Negate (Real : Ureal) return Ureal is\n+   begin\n+      return Store_Ureal (\n+               (Num      => Ureals.Table (Real).Num,\n+                Den      => Ureals.Table (Real).Den,\n+                Rbase    => Ureals.Table (Real).Rbase,\n+                Negative => not Ureals.Table (Real).Negative));\n+   end UR_Negate;\n+\n+   ------------\n+   -- UR_Sub --\n+   ------------\n+\n+   function UR_Sub (Left : Uint; Right : Ureal) return Ureal is\n+   begin\n+      return UR_From_Uint (Left) + UR_Negate (Right);\n+   end UR_Sub;\n+\n+   function UR_Sub (Left : Ureal; Right : Uint) return Ureal is\n+   begin\n+      return Left + UR_From_Uint (-Right);\n+   end UR_Sub;\n+\n+   function UR_Sub (Left, Right : Ureal) return Ureal is\n+   begin\n+      return Left + UR_Negate (Right);\n+   end UR_Sub;\n+\n+   ----------------\n+   -- UR_To_Uint --\n+   ----------------\n+\n+   function UR_To_Uint (Real : Ureal) return Uint is\n+      Val : Ureal_Entry := Normalize (Ureals.Table (Real));\n+      Res : Uint;\n+\n+   begin\n+      Res := (Val.Num + (Val.Den / 2)) / Val.Den;\n+\n+      if Val.Negative then\n+         return UI_Negate (Res);\n+      else\n+         return Res;\n+      end if;\n+   end UR_To_Uint;\n+\n+   --------------\n+   -- UR_Trunc --\n+   --------------\n+\n+   function UR_Trunc (Real : Ureal) return Uint is\n+      Val : constant Ureal_Entry := Normalize (Ureals.Table (Real));\n+\n+   begin\n+      if Val.Negative then\n+         return -(Val.Num / Val.Den);\n+      else\n+         return Val.Num / Val.Den;\n+      end if;\n+   end UR_Trunc;\n+\n+   --------------\n+   -- UR_Write --\n+   --------------\n+\n+   procedure UR_Write (Real : Ureal) is\n+      Val : constant Ureal_Entry := Ureals.Table (Real);\n+\n+   begin\n+      --  If value is negative, we precede the constant by a minus sign\n+      --  and add an extra layer of parentheses on the outside since the\n+      --  minus sign is part of the value, not a negation operator.\n+\n+      if Val.Negative then\n+         Write_Str (\"(-\");\n+      end if;\n+\n+      --  Constants in base 10 can be written in normal Ada literal style\n+      --  If the literal is negative enclose in parens to emphasize that\n+      --  it is part of the constant, and not a separate negation operator\n+\n+      if Val.Rbase = 10 then\n+\n+         UI_Write (Val.Num / 10);\n+         Write_Char ('.');\n+         UI_Write (Val.Num mod 10);\n+\n+         if Val.Den /= 0 then\n+            Write_Char ('E');\n+            UI_Write (1 - Val.Den);\n+         end if;\n+\n+      --  Constants in a base other than 10 can still be easily written\n+      --  in normal Ada literal style if the numerator is one.\n+\n+      elsif Val.Rbase /= 0 and then Val.Num = 1 then\n+         Write_Int (Val.Rbase);\n+         Write_Str (\"#1.0#E\");\n+         UI_Write (-Val.Den);\n+\n+      --  Other constants with a base other than 10 are written using one\n+      --  of the following forms, depending on the sign of the number\n+      --  and the sign of the exponent (= minus denominator value)\n+\n+      --    (numerator.0*base**exponent)\n+      --    (numerator.0*base**(-exponent))\n+\n+      elsif Val.Rbase /= 0 then\n+         Write_Char ('(');\n+         UI_Write (Val.Num, Decimal);\n+         Write_Str (\".0*\");\n+         Write_Int (Val.Rbase);\n+         Write_Str (\"**\");\n+\n+         if Val.Den <= 0 then\n+            UI_Write (-Val.Den, Decimal);\n+\n+         else\n+            Write_Str (\"(-\");\n+            UI_Write (Val.Den, Decimal);\n+            Write_Char (')');\n+         end if;\n+\n+         Write_Char (')');\n+\n+      --  Rational constants with a denominator of 1 can be written as\n+      --  a real literal for the numerator integer.\n+\n+      elsif Val.Den = 1 then\n+         UI_Write (Val.Num, Decimal);\n+         Write_Str (\".0\");\n+\n+      --  Non-based (rational) constants are written in (num/den) style\n+\n+      else\n+         Write_Char ('(');\n+         UI_Write (Val.Num, Decimal);\n+         Write_Str (\".0/\");\n+         UI_Write (Val.Den, Decimal);\n+         Write_Str (\".0)\");\n+      end if;\n+\n+      --  Add trailing paren for negative values\n+\n+      if Val.Negative then\n+         Write_Char (')');\n+      end if;\n+\n+   end UR_Write;\n+\n+   -------------\n+   -- Ureal_0 --\n+   -------------\n+\n+   function Ureal_0 return Ureal is\n+   begin\n+      return UR_0;\n+   end Ureal_0;\n+\n+   -------------\n+   -- Ureal_1 --\n+   -------------\n+\n+   function Ureal_1 return Ureal is\n+   begin\n+      return UR_1;\n+   end Ureal_1;\n+\n+   -------------\n+   -- Ureal_2 --\n+   -------------\n+\n+   function Ureal_2 return Ureal is\n+   begin\n+      return UR_2;\n+   end Ureal_2;\n+\n+   --------------\n+   -- Ureal_10 --\n+   --------------\n+\n+   function Ureal_10 return Ureal is\n+   begin\n+      return UR_10;\n+   end Ureal_10;\n+\n+   ---------------\n+   -- Ureal_100 --\n+   ---------------\n+\n+   function Ureal_100 return Ureal is\n+   begin\n+      return UR_100;\n+   end Ureal_100;\n+\n+   -----------------\n+   -- Ureal_2_128 --\n+   -----------------\n+\n+   function Ureal_2_128 return Ureal is\n+   begin\n+      return UR_2_128;\n+   end Ureal_2_128;\n+\n+   -------------------\n+   -- Ureal_2_M_128 --\n+   -------------------\n+\n+   function Ureal_2_M_128 return Ureal is\n+   begin\n+      return UR_2_M_128;\n+   end Ureal_2_M_128;\n+\n+   ----------------\n+   -- Ureal_Half --\n+   ----------------\n+\n+   function Ureal_Half return Ureal is\n+   begin\n+      return UR_Half;\n+   end Ureal_Half;\n+\n+   ---------------\n+   -- Ureal_M_0 --\n+   ---------------\n+\n+   function Ureal_M_0 return Ureal is\n+   begin\n+      return UR_M_0;\n+   end Ureal_M_0;\n+\n+   -----------------\n+   -- Ureal_Tenth --\n+   -----------------\n+\n+   function Ureal_Tenth return Ureal is\n+   begin\n+      return UR_Tenth;\n+   end Ureal_Tenth;\n+\n+end Urealp;"}, {"sha": "9896e0d996843e4e6bf729e6b034531569af88a7", "filename": "gcc/ada/urealp.ads", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Furealp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Furealp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,355 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               U R E A L P                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                             $Revision: 1.35 $                            --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Support for universal real arithmetic\n+\n+with Types; use Types;\n+with Uintp; use Uintp;\n+\n+package Urealp is\n+\n+   ---------------------------------------\n+   -- Representation of Universal Reals --\n+   ---------------------------------------\n+\n+   --  A universal real value is represented by a single value (which is\n+   --  an index into an internal table). These values are not hashed, so\n+   --  the equality operator should not be used on Ureal values (instead\n+   --  use the UR_Eq function).\n+\n+   --  A Ureal value represents an arbitrary precision universal real value,\n+   --  stored internally using four components\n+\n+   --    the numerator (Uint, always non-negative)\n+   --    the denominator (Uint, always non-zero, always positive if base = 0)\n+   --    a real base (Nat, either zero, or in the range 2 .. 16)\n+   --    a sign flag (Boolean), set if negative\n+\n+   --  If the base is zero, then the absolute value of the Ureal is simply\n+   --  numerator/denominator. If the base is non-zero, then the absolute\n+   --  value is num / (rbase ** den).\n+\n+   --  Negative numbers are represented by the sign of the numerator being\n+   --  negative. The denominator is always positive.\n+\n+   --  A normalized Ureal value has base = 0, and numerator/denominator\n+   --  reduced to lowest terms, with zero itself being represented as 0/1.\n+   --  This is a canonical format, so that for normalized Ureal values it\n+   --  is the case that two equal values always have the same denominator\n+   --  and numerator values.\n+\n+   --  Note: a value of minus zero is legitimate, and the operations in\n+   --  Urealp preserve the handling of signed zeroes in accordance with\n+   --  the rules of IEEE P754 (\"IEEE floating point\").\n+\n+   ------------------------------\n+   -- Types for Urealp Package --\n+   ------------------------------\n+\n+   type Ureal is private;\n+   --  Type used for representation of universal reals\n+\n+   No_Ureal : constant Ureal;\n+   --  Constant used to indicate missing or unset Ureal value\n+\n+   ---------------------\n+   -- Ureal Constants --\n+   ---------------------\n+\n+   function Ureal_0 return Ureal;\n+   --  Returns value 0.0\n+\n+   function Ureal_M_0 return Ureal;\n+   --  Returns value -0.0\n+\n+   function Ureal_Tenth return Ureal;\n+   --  Returns value 0.1\n+\n+   function Ureal_Half return Ureal;\n+   --  Returns value 0.5\n+\n+   function Ureal_1 return Ureal;\n+   --  Returns value 1.0\n+\n+   function Ureal_2 return Ureal;\n+   --  Returns value 2.0\n+\n+   function Ureal_10 return Ureal;\n+   --  Returns value 10.0\n+\n+   function Ureal_100 return Ureal;\n+   --  Returns value 100.0\n+\n+   function Ureal_2_128 return Ureal;\n+   --  Returns value 2.0 ** 128\n+\n+   function Ureal_2_M_128 return Ureal;\n+   --  Returns value 2.0 ** (-128)\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Initialize;\n+   --  Initialize Ureal tables. Note that Initialize must not be called if\n+   --  Tree_Read is used. Note also that there is no Lock routine in this\n+   --  unit. These tables are among the few tables that can be expanded\n+   --  during Gigi processing.\n+\n+   procedure Tree_Read;\n+   --  Initializes internal tables from current tree file using Tree_Read.\n+   --  Note that Initialize should not be called if Tree_Read is used.\n+   --  Tree_Read includes all necessary initialization.\n+\n+   procedure Tree_Write;\n+   --  Writes out internal tables to current tree file using Tree_Write\n+\n+   function Rbase (Real : Ureal) return Nat;\n+   --  Return the base of the universal real.\n+\n+   function Denominator (Real : Ureal) return Uint;\n+   --  Return the denominator of the universal real.\n+\n+   function Numerator (Real : Ureal) return Uint;\n+   --  Return the numerator of the universal real.\n+\n+   function Norm_Den (Real : Ureal) return Uint;\n+   --  Return the denominator of the universal real after a normalization.\n+\n+   function Norm_Num (Real : Ureal) return Uint;\n+   --  Return the numerator of the universal real after a normalization.\n+\n+   function UR_From_Uint (UI : Uint) return Ureal;\n+   --  Returns real corresponding to universal integer value\n+\n+   function UR_To_Uint (Real : Ureal) return Uint;\n+   --  Return integer value obtained by accurate rounding of real value.\n+   --  The rounding of values half way between two integers is away from\n+   --  zero, as required by normal Ada 95 rounding semantics.\n+\n+   function UR_Trunc (Real : Ureal) return Uint;\n+   --  Return integer value obtained by a truncation of real towards zero\n+\n+   function UR_Ceiling (Real : Ureal) return Uint;\n+   --  Return value of smallest integer not less than the given value\n+\n+   function UR_Floor (Real : Ureal) return Uint;\n+   --  Return value of smallest integer not greater than the given value\n+\n+   --  Conversion table for above four functions\n+\n+   --    Input    To_Uint    Trunc    Ceiling    Floor\n+   --     1.0        1         1         1         1\n+   --     1.2        1         1         2         1\n+   --     1.5        2         1         2         1\n+   --     1.7        2         1         2         1\n+   --     2.0        2         2         2         2\n+   --    -1.0       -1        -1        -1        -1\n+   --    -1.2       -1        -1        -1        -2\n+   --    -1.5       -2        -1        -1        -2\n+   --    -1.7       -2        -1        -1        -2\n+   --    -2.0       -2        -2        -2        -2\n+\n+   function UR_From_Components\n+     (Num      : Uint;\n+      Den      : Uint;\n+      Rbase    : Nat := 0;\n+      Negative : Boolean := False)\n+      return     Ureal;\n+   --  Builds real value from given numerator, denominator and base. The\n+   --  value is negative if Negative is set to true, and otherwise is\n+   --  non-negative.\n+\n+   function UR_Add (Left : Ureal; Right : Ureal) return Ureal;\n+   function UR_Add (Left : Ureal; Right : Uint)  return Ureal;\n+   function UR_Add (Left : Uint;  Right : Ureal) return Ureal;\n+   --  Returns real sum of operands\n+\n+   function UR_Div (Left : Ureal; Right : Ureal) return Ureal;\n+   function UR_Div (Left : Uint;  Right : Ureal) return Ureal;\n+   function UR_Div (Left : Ureal; Right : Uint)  return Ureal;\n+   --  Returns real quotient of operands. Fatal error if Right is zero\n+\n+   function UR_Mul (Left : Ureal; Right : Ureal) return Ureal;\n+   function UR_Mul (Left : Uint;  Right : Ureal) return Ureal;\n+   function UR_Mul (Left : Ureal; Right : Uint)  return Ureal;\n+   --  Returns real product of operands\n+\n+   function UR_Sub (Left : Ureal; Right : Ureal) return Ureal;\n+   function UR_Sub (Left : Uint;  Right : Ureal) return Ureal;\n+   function UR_Sub (Left : Ureal; Right : Uint)  return Ureal;\n+   --  Returns real difference of operands\n+\n+   function UR_Exponentiate (Real  : Ureal; N : Uint) return  Ureal;\n+   --  Returns result of raising Ureal to Uint power.\n+   --  Fatal error if Left is 0 and Right is negative.\n+\n+   function UR_Abs (Real : Ureal) return Ureal;\n+   --  Returns abs function of real\n+\n+   function UR_Negate (Real : Ureal) return Ureal;\n+   --  Returns negative of real\n+\n+   function UR_Eq (Left, Right : Ureal) return Boolean;\n+   --  Compares reals for equality.\n+\n+   function UR_Max (Left, Right : Ureal) return Ureal;\n+   --  Returns the maximum of two reals\n+\n+   function UR_Min (Left, Right : Ureal) return Ureal;\n+   --  Returns the minimum of two reals\n+\n+   function UR_Ne (Left, Right : Ureal) return Boolean;\n+   --  Compares reals for inequality.\n+\n+   function UR_Lt (Left, Right : Ureal) return Boolean;\n+   --  Compares reals for less than.\n+\n+   function UR_Le (Left, Right : Ureal) return Boolean;\n+   --  Compares reals for less than or equal.\n+\n+   function UR_Gt (Left, Right : Ureal) return Boolean;\n+   --  Compares reals for greater than.\n+\n+   function UR_Ge (Left, Right : Ureal) return Boolean;\n+   --  Compares reals for greater than or equal.\n+\n+   function UR_Is_Zero (Real : Ureal) return Boolean;\n+   --  Tests if real value is zero\n+\n+   function UR_Is_Negative (Real : Ureal) return Boolean;\n+   --  Tests if real value is negative, note that negative zero gives true\n+\n+   function UR_Is_Positive (Real : Ureal) return Boolean;\n+   --  Test if real value is greater than zero\n+\n+   procedure UR_Write (Real : Ureal);\n+   --  Writes value of Real to standard output. Used only for debugging and\n+   --  tree/source output. If the result is easily representable as a standard\n+   --  Ada literal, it will be given that way, but as a result of evaluation\n+   --  of static expressions, it is possible to generate constants (e.g. 1/13)\n+   --  which have no such representation. In such cases (and in cases where it\n+   --  is too much work to figure out the Ada literal), the string that is\n+   --  output is of the form [numerator/denominator].\n+\n+   procedure pr (Real : Ureal);\n+   --  Writes value of Real to standard output with a terminating line return,\n+   --  using UR_Write as described above. This is for use from the debugger.\n+\n+   ------------------------\n+   -- Operator Renamings --\n+   ------------------------\n+\n+   function \"+\" (Left : Ureal; Right : Ureal) return Ureal renames UR_Add;\n+   function \"+\" (Left : Uint;  Right : Ureal) return Ureal renames UR_Add;\n+   function \"+\" (Left : Ureal; Right : Uint)  return Ureal renames UR_Add;\n+\n+   function \"/\" (Left : Ureal; Right : Ureal) return Ureal renames UR_Div;\n+   function \"/\" (Left : Uint;  Right : Ureal) return Ureal renames UR_Div;\n+   function \"/\" (Left : Ureal; Right : Uint)  return Ureal renames UR_Div;\n+\n+   function \"*\" (Left : Ureal; Right : Ureal) return Ureal renames UR_Mul;\n+   function \"*\" (Left : Uint;  Right : Ureal) return Ureal renames UR_Mul;\n+   function \"*\" (Left : Ureal; Right : Uint)  return Ureal renames UR_Mul;\n+\n+   function \"-\" (Left : Ureal; Right : Ureal) return Ureal renames UR_Sub;\n+   function \"-\" (Left : Uint;  Right : Ureal) return Ureal renames UR_Sub;\n+   function \"-\" (Left : Ureal; Right : Uint)  return Ureal renames UR_Sub;\n+\n+   function \"**\"  (Real  : Ureal; N : Uint) return Ureal\n+                                                     renames UR_Exponentiate;\n+\n+   function \"abs\" (Real : Ureal) return Ureal renames UR_Abs;\n+\n+   function \"-\"   (Real : Ureal) return Ureal renames UR_Negate;\n+\n+   function \"=\"   (Left, Right : Ureal) return Boolean renames UR_Eq;\n+\n+   function \"<\"   (Left, Right : Ureal) return Boolean renames UR_Lt;\n+\n+   function \"<=\"  (Left, Right : Ureal) return Boolean renames UR_Le;\n+\n+   function \">=\"  (Left, Right : Ureal) return Boolean renames UR_Ge;\n+\n+   function \">\"   (Left, Right : Ureal) return Boolean renames UR_Gt;\n+\n+   -----------------------------\n+   -- Mark/Release Processing --\n+   -----------------------------\n+\n+   --  The space used by Ureal data is not automatically reclaimed. However,\n+   --  a mark-release regime is implemented which allows storage to be\n+   --  released back to a previously noted mark. This is used for example\n+   --  when doing comparisons, where only intermediate results get stored\n+   --  that do not need to be saved for future use.\n+\n+   type Save_Mark is private;\n+\n+   function Mark return Save_Mark;\n+   --  Note mark point for future release\n+\n+   procedure Release (M : Save_Mark);\n+   --  Release storage allocated since mark was noted\n+\n+   ------------------------------------\n+   -- Representation of Ureal Values --\n+   ------------------------------------\n+\n+private\n+\n+   type Ureal is new Int range Ureal_Low_Bound .. Ureal_High_Bound;\n+   for Ureal'Size use 32;\n+\n+   No_Ureal : constant Ureal := Ureal'First;\n+\n+   type Save_Mark is new Int;\n+\n+   pragma Inline (Denominator);\n+   pragma Inline (Mark);\n+   pragma Inline (Norm_Num);\n+   pragma Inline (Norm_Den);\n+   pragma Inline (Numerator);\n+   pragma Inline (Rbase);\n+   pragma Inline (Release);\n+   pragma Inline (Ureal_0);\n+   pragma Inline (Ureal_M_0);\n+   pragma Inline (Ureal_Tenth);\n+   pragma Inline (Ureal_Half);\n+   pragma Inline (Ureal_1);\n+   pragma Inline (Ureal_2);\n+   pragma Inline (Ureal_10);\n+   pragma Inline (UR_From_Components);\n+\n+end Urealp;"}, {"sha": "24afb55b598a5fbbaccf2dfcf5f5c7e0d6a0cdbd", "filename": "gcc/ada/urealp.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Furealp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Furealp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.h?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,50 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                               U R E A L P                                *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *                            $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file corresponds to the Ada package specification Urealp. It was\n+   created manually from the files urealp.ads and urealp.adb  */\n+\n+/* Support for universal real arithmetic.  */\n+\n+#define Numerator urealp__numerator\n+extern Uint Numerator\t\tPARAMS ((Ureal));\n+\n+#define Denominator urealp__denominator\n+extern Uint Denominator\t\tPARAMS ((Ureal));\n+\n+#define Rbase urealp__rbase\n+extern Nat Rbase\t\tPARAMS ((Ureal));\n+\n+#define UR_Is_Negative urealp__ur_is_negative\n+extern Boolean UR_Is_Negative\tPARAMS ((Ureal));\n+\n+#define UR_Is_Zero urealp__ur_is_zero\n+extern Boolean UR_Is_Zero\tPARAMS ((Ureal));\n+\n+#define Machine eval_fat__machine\n+extern Ureal Machine\t\tPARAMS ((Entity_Id, Ureal));"}, {"sha": "f6fffeaedc240f9df36e5fa62fce1e4c1634ad64", "filename": "gcc/ada/usage.adb", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,390 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               U S A G E                                  --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--                           $Revision: 1.116 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Hostparm;\n+with Namet;          use Namet;\n+with Osint;          use Osint;\n+with Output;         use Output;\n+with System.WCh_Con; use System.WCh_Con;\n+\n+procedure Usage is\n+\n+   procedure Write_Switch_Char (Sw : String; Prefix : String := \"gnat\");\n+   --  Output two spaces followed by default switch character followed\n+   --  Prefix, followed by the string given as the argument, and then\n+   --  enough blanks to tab to column 13, i.e. assuming Sw is not longer\n+   --  than 5 characters, the maximum allowed, Write_Switch_Char will\n+   --  always output exactly 12 characters.\n+\n+   procedure Write_Switch_Char (Sw : String; Prefix : String := \"gnat\") is\n+   begin\n+      Write_Str (\"  \");\n+      Write_Char (Switch_Character);\n+      Write_Str (Prefix);\n+      Write_Str (Sw);\n+\n+      for J in 1 .. 12 - 3 - Prefix'Length - Sw'Length loop\n+         Write_Char (' ');\n+      end loop;\n+   end Write_Switch_Char;\n+\n+--  Start of processing for Usage\n+\n+begin\n+   Find_Program_Name;\n+\n+   --  For gnatmake, we are appending this information to the end of\n+   --  the normal gnatmake output, so generate appropriate header\n+\n+   if Name_Len >= 8\n+     and then (Name_Buffer (Name_Len - 7 .. Name_Len) = \"gnatmake\"\n+                 or else\n+               Name_Buffer (Name_Len - 7 .. Name_Len) = \"GNATMAKE\")\n+   then\n+      Write_Eol;\n+      Write_Line (\"Compiler switches (passed to the compiler by gnatmake):\");\n+\n+   else\n+      --  Usage line\n+\n+      Write_Str (\"Usage: \");\n+      Write_Program_Name;\n+      Write_Char (' ');\n+      Write_Str (\"switches sfile\");\n+      Write_Eol;\n+      Write_Eol;\n+\n+      --  Line for sfile\n+\n+      Write_Line (\"  sfile     Source file name\");\n+   end if;\n+\n+   Write_Eol;\n+\n+   --  Common GCC switches not available in JGNAT\n+\n+   if not Hostparm.Java_VM then\n+      Write_Switch_Char (\"fstack-check \", \"\");\n+      Write_Line (\"Generate stack checking code\");\n+\n+      Write_Switch_Char (\"fno-inline   \", \"\");\n+      Write_Line (\"Inhibit all inlining (makes executable smaller)\");\n+   end if;\n+\n+   --  Common switches available to both GCC and JGNAT\n+\n+   Write_Switch_Char (\"g            \", \"\");\n+   Write_Line (\"Generate debugging information\");\n+\n+   Write_Switch_Char (\"Idir         \", \"\");\n+   Write_Line (\"Specify source files search path\");\n+\n+   Write_Switch_Char (\"I-           \", \"\");\n+   Write_Line (\"Do not look for sources in current directory\");\n+\n+   Write_Switch_Char (\"O[0123]      \", \"\");\n+   Write_Line (\"Control the optimization level\");\n+\n+   Write_Eol;\n+\n+   --  Individual lines for switches. Write_Switch_Char outputs fourteen\n+   --  characters, so the remaining message is allowed to be a maximum\n+   --  of 65 characters to be comfortable on an 80 character device.\n+   --  If the Write_Str fits on one line, it is short enough!\n+\n+   --  Line for -gnata switch\n+\n+   Write_Switch_Char (\"a\");\n+   Write_Line (\"Assertions enabled. Pragma Assert/Debug to be activated\");\n+\n+   --  Line for -gnatA switch\n+\n+   Write_Switch_Char (\"A\");\n+   Write_Line (\"Avoid processing gnat.adc, if present file will be ignored\");\n+\n+   --  Line for -gnatb switch\n+\n+   Write_Switch_Char (\"b\");\n+   Write_Line (\"Generate brief messages to stderr even if verbose mode set\");\n+\n+   --  Line for -gnatc switch\n+\n+   Write_Switch_Char (\"c\");\n+   Write_Line (\"Check syntax and semantics only (no code generation)\");\n+\n+   Write_Switch_Char (\"C\");\n+   Write_Line (\"Compress names in external names and debug info tables\");\n+\n+   --  Line for -gnatd switch\n+\n+   Write_Switch_Char (\"d?\");\n+   Write_Line (\"Compiler debug option ? (a-z,A-Z,0-9), see debug.adb\");\n+\n+   --  Line for -gnatD switch\n+\n+   Write_Switch_Char (\"D\");\n+   Write_Line (\"Debug expanded generated code rather than source code\");\n+\n+   --  Line for -gnatec switch\n+\n+   Write_Switch_Char (\"ec?\");\n+   Write_Line (\"Specify configuration pragmas file, e.g. -gnatec/x/f.adc\");\n+\n+   --  Line for -gnatE switch\n+\n+   Write_Switch_Char (\"E\");\n+   Write_Line (\"Dynamic elaboration checking mode enabled\");\n+\n+   --  Line for -gnatf switch\n+\n+   Write_Switch_Char (\"f\");\n+   Write_Line (\"Full errors. Verbose details, all undefined references\");\n+\n+   --  Line for -gnatF switch\n+\n+   Write_Switch_Char (\"F\");\n+   Write_Line (\"Force all import/export external names to all uppercase\");\n+\n+   --  Line for -gnatg switch\n+\n+   Write_Switch_Char (\"g\");\n+   Write_Line (\"GNAT implementation mode (used for compiling GNAT units)\");\n+\n+   --  Line for -gnatG switch\n+\n+   Write_Switch_Char (\"G\");\n+   Write_Line (\"Output generated expanded code in source form\");\n+\n+   --  Line for -gnath switch\n+\n+   Write_Switch_Char (\"h\");\n+   Write_Line (\"Output this usage (help) information\");\n+\n+   --  Line for -gnati switch\n+\n+   Write_Switch_Char (\"i?\");\n+   Write_Line (\"Identifier char set (?=1/2/3/4/8/p/f/n/w)\");\n+\n+   --  Line for -gnatk switch\n+\n+   Write_Switch_Char (\"k\");\n+   Write_Line (\"Limit file names to nnn characters (k = krunch)\");\n+\n+   --  Line for -gnatl switch\n+\n+   Write_Switch_Char (\"l\");\n+   Write_Line (\"Output full source listing with embedded error messages\");\n+\n+   --  Line for -gnatL switch\n+\n+   Write_Switch_Char (\"L\");\n+   Write_Line (\"Use longjmp/setjmp for exception handling\");\n+\n+   --  Line for -gnatm switch\n+\n+   Write_Switch_Char (\"mnnn\");\n+   Write_Line (\"Limit number of detected errors to nnn (1-999)\");\n+\n+   --  Line for -gnatn switch\n+\n+   Write_Switch_Char (\"n\");\n+   Write_Line (\"Inlining of subprograms (apply pragma Inline across units)\");\n+\n+   --  Line for -gnatN switch\n+\n+   Write_Switch_Char (\"N\");\n+   Write_Line (\"Full (frontend) inlining of subprograqms\");\n+\n+   --  Line for -gnato switch\n+\n+   Write_Switch_Char (\"o\");\n+   Write_Line (\"Enable overflow checking (off by default)\");\n+\n+   --  Line for -gnatO switch\n+\n+   Write_Switch_Char (\"O nm \");\n+   Write_Line (\"Set name of output ali file (internal switch)\");\n+\n+   --  Line for -gnatp switch\n+\n+   Write_Switch_Char (\"p\");\n+   Write_Line (\"Suppress all checks\");\n+\n+   --  Line for -gnatP switch\n+\n+   Write_Switch_Char (\"P\");\n+   Write_Line (\"Generate periodic calls to System.Polling.Poll\");\n+\n+   --  Line for -gnatq switch\n+\n+   Write_Switch_Char (\"q\");\n+   Write_Line (\"Don't quit, try semantics, even if parse errors\");\n+\n+   --  Line for -gnatQ switch\n+\n+   Write_Switch_Char (\"Q\");\n+   Write_Line (\"Don't quit, write ali/tree file even if compile errors\");\n+\n+   --  Line for -gnatR switch\n+\n+   Write_Switch_Char (\"R?\");\n+   Write_Line (\"List rep inf (?=0/1/2/3 for none/types/all/variable)\");\n+\n+   --  Lines for -gnats switch\n+\n+   Write_Switch_Char (\"s\");\n+   Write_Line (\"Syntax check only\");\n+\n+   --  Lines for -gnatt switch\n+\n+   Write_Switch_Char (\"t\");\n+   Write_Line (\"Tree output file to be generated\");\n+\n+   --  Line for -gnatT switch\n+\n+   Write_Switch_Char (\"Tnnn\");\n+   Write_Line (\"All compiler tables start at nnn times usual starting size\");\n+\n+   --  Line for -gnatu switch\n+\n+   Write_Switch_Char (\"u\");\n+   Write_Line (\"List units for this compilation\");\n+\n+   --  Line for -gnatU switch\n+\n+   Write_Switch_Char (\"U\");\n+   Write_Line (\"Enable unique tag for error messages\");\n+\n+   --  Line for -gnatv switch\n+\n+   Write_Switch_Char (\"v\");\n+   Write_Line (\"Verbose mode. Full error output with source lines to stdout\");\n+\n+   --  Line for -gnatV switch\n+\n+   Write_Switch_Char (\"V?\");\n+   Write_Line\n+     (\"Validity checking (?=ndcte or 0-4 None/Default/Copy/Test/Exprs)\");\n+\n+   --  Lines for -gnatw switch\n+\n+   Write_Switch_Char (\"wxx\");\n+   Write_Line (\"Enable selected warning modes, xx = list of parameters:\");\n+   Write_Line (\"        a    turn on all optional warnings (except b,h)\");\n+   Write_Line (\"        A    turn off all optional warnings\");\n+   Write_Line (\"        b    turn on biased rounding warnings\");\n+   Write_Line (\"        B    turn off biased rounding warnings\");\n+   Write_Line (\"        c    turn on constant conditional warnings\");\n+   Write_Line (\"        C*   turn off constant conditional warnings\");\n+   Write_Line (\"        e    treat all warnings as errors\");\n+   Write_Line (\"        h    turn on warnings for hiding variables\");\n+   Write_Line (\"        H*   turn off warnings for hiding variables\");\n+   Write_Line (\"        i*   turn on warnings for implementation units\");\n+   Write_Line (\"        I    turn off warnings for implementation units\");\n+   Write_Line (\"        l    turn on elaboration warnings\");\n+   Write_Line (\"        L*   turn off elaboration warnings\");\n+   Write_Line (\"        o*   turn on address clause overlay warnings\");\n+   Write_Line (\"        O    turn off address clause overlay warnings\");\n+   Write_Line (\"        p    turn on warnings for ineffective pragma inline\");\n+   Write_Line (\"        P*   turn off warnings for ineffective pragma inline\");\n+   Write_Line (\"        r    turn on redundant construct warnings\");\n+   Write_Line (\"        R*   turn off redundant construct warnings\");\n+   Write_Line (\"        s    suppress all warnings\");\n+   Write_Line (\"        u    turn on warnings for unused entities\");\n+   Write_Line (\"        U*   turn off warnings for unused entities\");\n+   Write_Line (\"        *    indicates default in above list\");\n+\n+   --  Line for -gnatW switch\n+\n+   Write_Switch_Char (\"W\");\n+   Write_Str (\"Wide character encoding method (\");\n+\n+   for J in WC_Encoding_Method loop\n+      Write_Char (WC_Encoding_Letters (J));\n+\n+      if J = WC_Encoding_Method'Last then\n+         Write_Char (')');\n+      else\n+         Write_Char ('/');\n+      end if;\n+   end loop;\n+\n+   Write_Eol;\n+\n+   --  Line for -gnatx switch\n+\n+   Write_Switch_Char (\"x\");\n+   Write_Line (\"Suppress output of cross-reference information\");\n+\n+   --  Line for -gnatX switch\n+\n+   Write_Switch_Char (\"X\");\n+   Write_Line (\"Language extensions permitted\");\n+\n+   --  Lines for -gnaty switch\n+\n+   Write_Switch_Char (\"y\");\n+   Write_Line (\"Enable all style checks\");\n+\n+   Write_Switch_Char (\"yxx\");\n+   Write_Line (\"Enable selected style checks xx = list of parameters:\");\n+   Write_Line (\"        1-9  check indentation\");\n+   Write_Line (\"        a    check attribute casing\");\n+   Write_Line (\"        b    check no blanks at end of lines\");\n+   Write_Line (\"        c    check comment format\");\n+   Write_Line (\"        e    check end/exit labels present\");\n+   Write_Line (\"        f    check no form feeds/vertical tabs in source\");\n+   Write_Line (\"        h    check no horizontal tabs in source\");\n+   Write_Line (\"        i    check if-then layout\");\n+   Write_Line (\"        k    check casing rules for keywords, identifiers\");\n+   Write_Line (\"        l    check reference manual layout\");\n+   Write_Line (\"        m    check line length <= 79 characters\");\n+   Write_Line (\"        n    check casing of package Standard identifiers\");\n+   Write_Line (\"        Mnnn check line length <= nnn characters\");\n+   Write_Line (\"        o    check subprogram bodies in alphabetical order\");\n+   Write_Line (\"        p    check pragma casing\");\n+   Write_Line (\"        r    check RM column layout\");\n+   Write_Line (\"        s    check separate subprogram specs present\");\n+   Write_Line (\"        t    check token separation rules\");\n+\n+   --  Lines for -gnatz switch\n+\n+   Write_Switch_Char (\"z\");\n+   Write_Line (\"Distribution stub generation (r/s for receiver/sender stubs)\");\n+\n+   --  Line for -gnatZ switch\n+\n+   Write_Switch_Char (\"Z\");\n+   Write_Line (\"Use zero cost exception handling\");\n+\n+   --  Line for -gnat83 switch\n+\n+   Write_Switch_Char (\"83\");\n+   Write_Line (\"Enforce Ada 83 restrictions\");\n+\n+end Usage;"}, {"sha": "af0c35c29bf312499538915caa2cd8e12f67e223", "filename": "gcc/ada/usage.ads", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fusage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fusage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,31 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                U S A G E                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $                              --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Procedure to generate screen of usage information if no file name present\n+\n+procedure Usage;"}, {"sha": "b23bbe9f0c6182b668282a31eb68cbff10d25bd9", "filename": "gcc/ada/utils.c", "status": "added", "additions": 3350, "deletions": 0, "changes": 3350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=415dddc81c99f37554902cbe0d838060b62a2548"}, {"sha": "424673ba103998ab3af3390e6fffdfe651bf6c0a", "filename": "gcc/ada/utils2.c", "status": "added", "additions": 2049, "deletions": 0, "changes": 2049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,2049 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                               U T I L S 2                                *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                            $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"ada.h\"\n+#include \"types.h\"\n+#include \"atree.h\"\n+#include \"stringt.h\"\n+#include \"uintp.h\"\n+#include \"fe.h\"\n+#include \"elists.h\"\n+#include \"nlists.h\"\n+#include \"sinfo.h\"\n+#include \"einfo.h\"\n+#include \"ada-tree.h\"\n+#include \"gigi.h\"\n+\n+static tree find_common_type\t\tPARAMS ((tree, tree));\n+static int contains_save_expr_p\t\tPARAMS ((tree));\n+static tree contains_null_expr\t\tPARAMS ((tree));\n+static tree compare_arrays\t\tPARAMS ((tree, tree, tree));\n+static tree nonbinary_modular_operation\tPARAMS ((enum tree_code, tree,\n+\t\t\t\t\t\ttree, tree));\n+static tree build_simple_component_ref\tPARAMS ((tree, tree, tree));\n+\f\n+/* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n+   operation.\n+\n+   This preparation consists of taking the ordinary representation of\n+   an expression expr and producing a valid tree boolean expression\n+   describing whether expr is nonzero. We could simply always do\n+\n+      build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n+\n+   but we optimize comparisons, &&, ||, and !.\n+\n+   The resulting type should always be the same as the input type.\n+   This function is simpler than the corresponding C version since\n+   the only possible operands will be things of Boolean type.  */\n+\n+tree\n+truthvalue_conversion (expr)\n+     tree expr;\n+{\n+  tree type = TREE_TYPE (expr);\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case EQ_EXPR:  case NE_EXPR: case LE_EXPR: case GE_EXPR:\n+    case LT_EXPR:  case GT_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case ERROR_MARK:\n+      return expr;\n+\n+    case COND_EXPR:\n+      /* Distribute the conversion into the arms of a COND_EXPR.  */\n+      return fold (build (COND_EXPR, type, TREE_OPERAND (expr, 0),\n+\t\t\t  truthvalue_conversion (TREE_OPERAND (expr, 1)),\n+\t\t\t  truthvalue_conversion (TREE_OPERAND (expr, 2))));\n+\n+    case WITH_RECORD_EXPR:\n+      return build (WITH_RECORD_EXPR, type,\n+\t\t    truthvalue_conversion (TREE_OPERAND (expr, 0)),\n+\t\t    TREE_OPERAND (expr, 1));\n+\n+    default:\n+      return build_binary_op (NE_EXPR, type, expr,\n+\t\t\t      convert (type, integer_zero_node));\n+    }\n+}\n+\f\n+/* Return the base type of TYPE.  */\n+\n+tree\n+get_base_type (type)\n+     tree type;\n+{\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      && TYPE_LEFT_JUSTIFIED_MODULAR_P (type))\n+    type = TREE_TYPE (TYPE_FIELDS (type));\n+\n+  while (TREE_TYPE (type) != 0\n+\t && (TREE_CODE (type) == INTEGER_TYPE\n+\t     || TREE_CODE (type) == REAL_TYPE))\n+    type = TREE_TYPE (type);\n+\n+  return type;\n+}\n+\n+/* Likewise, but only return types known to the Ada source.  */\n+tree\n+get_ada_base_type (type)\n+     tree type;\n+{\n+  while (TREE_TYPE (type) != 0\n+\t && (TREE_CODE (type) == INTEGER_TYPE\n+\t     || TREE_CODE (type) == REAL_TYPE)\n+\t && ! TYPE_EXTRA_SUBTYPE_P (type))\n+    type = TREE_TYPE (type);\n+\n+  return type;\n+}\n+\f\n+/* EXP is a GCC tree representing an address.  See if we can find how\n+   strictly the object at that address is aligned.   Return that alignment\n+   in bits.  If we don't know anything about the alignment, return 0.\n+   We do not go merely by type information here since the check on\n+   N_Validate_Unchecked_Alignment does that.  */\n+\n+unsigned int\n+known_alignment (exp)\n+     tree exp;\n+{\n+  unsigned int lhs, rhs;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+    case NON_LVALUE_EXPR:\n+      /* Conversions between pointers and integers don't change the alignment\n+\t of the underlying object.  */\n+      return known_alignment (TREE_OPERAND (exp, 0));\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* If two address are added, the alignment of the result is the\n+\t minimum of the two aligments.  */\n+      lhs = known_alignment (TREE_OPERAND (exp, 0));\n+      rhs = known_alignment (TREE_OPERAND (exp, 1));\n+      return MIN (lhs, rhs);\n+\n+    case INTEGER_CST:\n+      /* The first part of this represents the lowest bit in the constant,\n+\t but is it in bytes, not bits.  */\n+      return MIN (BITS_PER_UNIT\n+\t\t  * (TREE_INT_CST_LOW (exp) & - TREE_INT_CST_LOW (exp)),\n+\t\t  BIGGEST_ALIGNMENT);\n+\n+    case MULT_EXPR:\n+      /* If we know the alignment of just one side, use it.  Otherwise,\n+\t use the product of the alignments.  */\n+      lhs = known_alignment (TREE_OPERAND (exp, 0));\n+      rhs = known_alignment (TREE_OPERAND (exp, 1));\n+      if (lhs == 0 || rhs == 0)\n+\treturn MIN (BIGGEST_ALIGNMENT, MAX (lhs, rhs));\n+\n+      return MIN (BIGGEST_ALIGNMENT, lhs * rhs);\n+\n+    case ADDR_EXPR:\n+      return expr_align (TREE_OPERAND (exp, 0));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* We have a comparison or assignment operation on two types, T1 and T2,\n+   which are both either array types or both record types.\n+   Return the type that both operands should be converted to, if any.\n+   Otherwise return zero.  */\n+\n+static tree\n+find_common_type (t1, t2)\n+     tree t1, t2;\n+{\n+  /* If either type is non-BLKmode, use it.  Note that we know that we will\n+     not have any alignment problems since if we did the non-BLKmode\n+     type could not have been used.  */\n+  if (TYPE_MODE (t1) != BLKmode)\n+    return t1;\n+  else if (TYPE_MODE (t2) != BLKmode)\n+    return t2;\n+\n+  /* Otherwise, return the type that has a constant size.  */\n+  if (TREE_CONSTANT (TYPE_SIZE (t1)))\n+    return t1;\n+  else if (TREE_CONSTANT (TYPE_SIZE (t2)))\n+    return t2;\n+\n+  /* In this case, both types have variable size.  It's probably\n+     best to leave the \"type mismatch\" because changing it could\n+     case a bad self-referential reference.  */\n+  return 0;\n+}\n+\f\n+/* See if EXP contains a SAVE_EXPR in a position where we would\n+   normally put it.\n+\n+   ??? This is a real kludge, but is probably the best approach short\n+   of some very general solution.  */\n+\n+static int\n+contains_save_expr_p (exp)\n+     tree exp;\n+{\n+  switch (TREE_CODE (exp))\n+    {\n+    case SAVE_EXPR:\n+      return 1;\n+\n+    case ADDR_EXPR:  case INDIRECT_REF:\n+    case COMPONENT_REF:\n+    case NOP_EXPR:  case CONVERT_EXPR: case UNCHECKED_CONVERT_EXPR:\n+      return contains_save_expr_p (TREE_OPERAND (exp, 0));\n+\n+    case CONSTRUCTOR:\n+      return (CONSTRUCTOR_ELTS (exp) != 0\n+\t      && contains_save_expr_p (CONSTRUCTOR_ELTS (exp)));\n+\n+    case TREE_LIST:\n+      return (contains_save_expr_p (TREE_VALUE (exp))\n+\t      || (TREE_CHAIN (exp) != 0\n+\t\t  && contains_save_expr_p (TREE_CHAIN (exp))));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* See if EXP contains a NULL_EXPR in an expression we use for sizes. Return\n+   it if so.  This is used to detect types whose sizes involve computations\n+   that are known to raise Constraint_Error.  */\n+\n+static tree\n+contains_null_expr (exp)\n+     tree exp;\n+{\n+  tree tem;\n+\n+  if (TREE_CODE (exp) == NULL_EXPR)\n+    return exp;\n+\n+  switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n+    {\n+    case '1':\n+      return contains_null_expr (TREE_OPERAND (exp, 0));\n+\n+    case '<':  case '2':\n+      tem = contains_null_expr (TREE_OPERAND (exp, 0));\n+      if (tem != 0)\n+\treturn tem;\n+\n+      return contains_null_expr (TREE_OPERAND (exp, 1));\n+\n+    case 'e':\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase SAVE_EXPR:\n+\t  return contains_null_expr (TREE_OPERAND (exp, 0));\n+\n+\tcase COND_EXPR:\n+\t  tem = contains_null_expr (TREE_OPERAND (exp, 0));\n+\t  if (tem != 0)\n+\t    return tem;\n+\n+\t  tem = contains_null_expr (TREE_OPERAND (exp, 1));\n+\t  if (tem != 0)\n+\t    return tem;\n+\n+\t  return contains_null_expr (TREE_OPERAND (exp, 2));\n+\n+\tdefault:\n+\t  return 0;\n+\t}\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* Return an expression tree representing an equality comparison of\n+   A1 and A2, two objects of ARRAY_TYPE.  The returned expression should\n+   be of type RESULT_TYPE\n+\n+   Two arrays are equal in one of two ways: (1) if both have zero length\n+   in some dimension (not necessarily the same dimension) or (2) if the\n+   lengths in each dimension are equal and the data is equal.  We perform the\n+   length tests in as efficient a manner as possible.  */\n+\n+static tree\n+compare_arrays (result_type, a1, a2)\n+     tree a1, a2;\n+     tree result_type;\n+{\n+  tree t1 = TREE_TYPE (a1);\n+  tree t2 = TREE_TYPE (a2);\n+  tree result = convert (result_type, integer_one_node);\n+  tree a1_is_null = convert (result_type, integer_zero_node);\n+  tree a2_is_null = convert (result_type, integer_zero_node);\n+  int length_zero_p = 0;\n+\n+  /* Process each dimension separately and compare the lengths.  If any\n+     dimension has a size known to be zero, set SIZE_ZERO_P to 1 to\n+     suppress the comparison of the data.  */\n+  while (TREE_CODE (t1) == ARRAY_TYPE && TREE_CODE (t2) == ARRAY_TYPE)\n+    {\n+      tree lb1 = TYPE_MIN_VALUE (TYPE_DOMAIN (t1));\n+      tree ub1 = TYPE_MAX_VALUE (TYPE_DOMAIN (t1));\n+      tree lb2 = TYPE_MIN_VALUE (TYPE_DOMAIN (t2));\n+      tree ub2 = TYPE_MAX_VALUE (TYPE_DOMAIN (t2));\n+      tree bt = get_base_type (TREE_TYPE (lb1));\n+      tree length1 = fold (build (MINUS_EXPR, bt, ub1, lb1));\n+      tree length2 = fold (build (MINUS_EXPR, bt, ub2, lb2));\n+      tree nbt;\n+      tree tem;\n+      tree comparison, this_a1_is_null, this_a2_is_null;\n+\n+      /* If the length of the first array is a constant, swap our operands\n+\t unless the length of the second array is the constant zero.  \n+\t Note that we have set the `length' values to the length - 1.  */\n+      if (TREE_CODE (length1) == INTEGER_CST\n+\t  && ! integer_zerop (fold (build (PLUS_EXPR, bt, length2,\n+\t\t\t\t\t   convert (bt, integer_one_node)))))\n+\t{\n+\t  tem = a1, a1 = a2, a2 = tem;\n+\t  tem = t1, t1 = t2, t2 = tem;\n+\t  tem = lb1, lb1 = lb2, lb2 = tem;\n+\t  tem = ub1, ub1 = ub2, ub2 = tem;\n+\t  tem = length1, length1 = length2, length2 = tem;\n+\t  tem = a1_is_null, a1_is_null = a2_is_null, a2_is_null = tem;\n+\t}\n+\n+      /* If the length of this dimension in the second array is the constant\n+\t zero, we can just go inside the original bounds for the first\n+\t array and see if last < first.  */\n+      if (integer_zerop (fold (build (PLUS_EXPR, bt, length2,\n+\t\t\t\t      convert (bt, integer_one_node)))))\n+\t{\n+\t  tree ub = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\n+\t  comparison = build_binary_op (LT_EXPR, result_type, ub, lb);\n+\n+\t  if (contains_placeholder_p (comparison))\n+\t    comparison = build (WITH_RECORD_EXPR, result_type,\n+\t\t\t\tcomparison, a1);\n+\t  if (contains_placeholder_p (length1))\n+\t    length1 = build (WITH_RECORD_EXPR, bt, length1, a1);\n+\n+\t  length_zero_p = 1;\n+\n+\t  this_a1_is_null = comparison;\n+\t  this_a2_is_null = convert (result_type, integer_one_node);\n+\t}\n+\n+      /* If the length is some other constant value, we know that the\n+\t this dimension in the first array cannot be superflat, so we\n+\t can just use its length from the actual stored bounds.  */\n+      else if (TREE_CODE (length2) == INTEGER_CST)\n+\t{\n+\t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  ub2 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n+\t  lb2 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n+\t  nbt = get_base_type (TREE_TYPE (ub1));\n+\n+\t  comparison\n+\t    = build_binary_op (EQ_EXPR, result_type, \n+\t\t\t       build_binary_op (MINUS_EXPR, nbt, ub1, lb1),\n+\t\t\t       build_binary_op (MINUS_EXPR, nbt, ub2, lb2));\n+\n+\t  /* Note that we know that UB2 and LB2 are constant and hence\n+\t     cannot contain a PLACEHOLDER_EXPR.  */\n+\n+\t  if (contains_placeholder_p (comparison))\n+\t    comparison = build (WITH_RECORD_EXPR, result_type, comparison, a1);\n+\t  if (contains_placeholder_p (length1))\n+\t    length1 = build (WITH_RECORD_EXPR, bt, length1, a1);\n+\n+\t  this_a1_is_null = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n+\t  this_a2_is_null = convert (result_type, integer_zero_node);\n+\t}\n+\n+      /* Otherwise compare the computed lengths.  */\n+      else\n+\t{\n+\t  if (contains_placeholder_p (length1))\n+\t    length1 = build (WITH_RECORD_EXPR, bt, length1, a1);\n+\t  if (contains_placeholder_p (length2))\n+\t    length2 = build (WITH_RECORD_EXPR, bt, length2, a2);\n+\n+\t  comparison\n+\t    = build_binary_op (EQ_EXPR, result_type, length1, length2);\n+\n+\t  this_a1_is_null\n+\t    = build_binary_op (LT_EXPR, result_type, length1,\n+\t\t\t       convert (bt, integer_zero_node));\n+\t  this_a2_is_null\n+\t    = build_binary_op (LT_EXPR, result_type, length2,\n+\t\t\t       convert (bt, integer_zero_node));\n+\t}\n+\n+      result = build_binary_op (TRUTH_ANDIF_EXPR, result_type,\n+\t\t\t\tresult, comparison);\n+\n+      a1_is_null = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n+\t\t\t\t    this_a1_is_null, a1_is_null);\n+      a2_is_null = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n+\t\t\t\t    this_a2_is_null, a2_is_null);\n+\n+      t1 = TREE_TYPE (t1);\n+      t2 = TREE_TYPE (t2);\n+    }\n+\n+  /* Unless the size of some bound is known to be zero, compare the\n+     data in the array.  */\n+  if (! length_zero_p)\n+    {\n+      tree type = find_common_type (TREE_TYPE (a1), TREE_TYPE (a2));\n+\n+      if (type != 0)\n+\ta1 = convert (type, a1), a2 = convert (type, a2);\n+\n+\n+      result = build_binary_op (TRUTH_ANDIF_EXPR, result_type, result,\n+\t\t\t\tbuild (EQ_EXPR, result_type, a1, a2));\n+\n+    }\n+\n+  /* The result is also true if both sizes are zero.  */\n+  result = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n+\t\t\t    build_binary_op (TRUTH_ANDIF_EXPR, result_type,\n+\t\t\t\t\t     a1_is_null, a2_is_null),\n+\t\t\t    result);\n+\n+  /* If either operand contains SAVE_EXPRs, they have to be evaluated before\n+     starting the comparison above since the place it would be otherwise\n+     evaluated would be wrong.  */\n+\n+  if (contains_save_expr_p (a1))\n+    result = build (COMPOUND_EXPR, result_type, a1, result);\n+\n+  if (contains_save_expr_p (a2))\n+    result = build (COMPOUND_EXPR, result_type, a2, result);\n+\n+  return result;\n+}\n+\f\n+/* Compute the result of applying OP_CODE to LHS and RHS, where both are of\n+   type TYPE.  We know that TYPE is a modular type with a nonbinary\n+   modulus.  */\n+\n+static tree\n+nonbinary_modular_operation (op_code, type, lhs, rhs)\n+     enum tree_code op_code;\n+     tree type;\n+     tree lhs, rhs;\n+{\n+  tree modulus = TYPE_MODULUS (type);\n+  unsigned int needed_precision = tree_floor_log2 (modulus) + 1;\n+  unsigned int precision;\n+  int unsignedp = 1;\n+  tree op_type = type;\n+  tree result;\n+\n+  /* If this is an addition of a constant, convert it to a subtraction\n+     of a constant since we can do that faster.  */\n+  if (op_code == PLUS_EXPR && TREE_CODE (rhs) == INTEGER_CST)\n+    rhs = fold (build (MINUS_EXPR, type, modulus, rhs)), op_code = MINUS_EXPR;\n+\n+  /* For the logical operations, we only need PRECISION bits.  For\n+     addition and subraction, we need one more and for multiplication we\n+     need twice as many.  But we never want to make a size smaller than\n+     our size. */\n+  if (op_code == PLUS_EXPR || op_code == MINUS_EXPR)\n+    needed_precision += 1;\n+  else if (op_code == MULT_EXPR)\n+    needed_precision *= 2;\n+\n+  precision = MAX (needed_precision, TYPE_PRECISION (op_type));\n+\n+  /* Unsigned will do for everything but subtraction.  */\n+  if (op_code == MINUS_EXPR)\n+    unsignedp = 0;\n+\n+  /* If our type is the wrong signedness or isn't wide enough, make a new\n+     type and convert both our operands to it.  */\n+  if (TYPE_PRECISION (op_type) < precision\n+      || TREE_UNSIGNED (op_type) != unsignedp)\n+    {\n+      /* Copy the node so we ensure it can be modified to make it modular.  */\n+      op_type = copy_node (type_for_size (precision, unsignedp));\n+      modulus = convert (op_type, modulus);\n+      TYPE_MODULUS (op_type) = modulus;\n+      TYPE_MODULAR_P (op_type) = 1;\n+      lhs = convert (op_type, lhs);\n+      rhs = convert (op_type, rhs);\n+    }\n+\n+  /* Do the operation, then we'll fix it up.  */\n+  result = fold (build (op_code, op_type, lhs, rhs));\n+\n+  /* For multiplication, we have no choice but to do a full modulus\n+     operation.  However, we want to do this in the narrowest\n+     possible size.  */\n+  if (op_code == MULT_EXPR)\n+    {\n+      tree div_type = copy_node (type_for_size (needed_precision, 1));\n+      modulus = convert (div_type, modulus);\n+      TYPE_MODULUS (div_type) = modulus;\n+      TYPE_MODULAR_P (div_type) = 1;\n+      result = convert (op_type,\n+\t\t\tfold (build (TRUNC_MOD_EXPR, div_type,\n+\t\t\t\t     convert (div_type, result), modulus)));\n+    }\n+\n+  /* For subtraction, add the modulus back if we are negative.  */\n+  else if (op_code == MINUS_EXPR)\n+    {\n+      result = save_expr (result);\n+      result = fold (build (COND_EXPR, op_type,\n+\t\t\t    build (LT_EXPR, integer_type_node, result,\n+\t\t\t\t   convert (op_type, integer_zero_node)),\n+\t\t\t    fold (build (PLUS_EXPR, op_type,\n+\t\t\t\t\t result, modulus)),\n+\t\t\t    result));\n+    }\n+\n+  /* For the other operations, subtract the modulus if we are >= it.  */\n+  else\n+    {\n+      result = save_expr (result);\n+      result = fold (build (COND_EXPR, op_type,\n+\t\t\t    build (GE_EXPR, integer_type_node,\n+\t\t\t\t   result, modulus),\n+\t\t\t    fold (build (MINUS_EXPR, op_type,\n+\t\t\t\t\t result, modulus)),\n+\t\t\t    result));\n+    }\n+\n+  return convert (type, result);\n+}\n+\f\n+/* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n+   desired for the result.  Usually the operation is to be performed\n+   in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0\n+   in which case the type to be used will be derived from the operands.\n+\n+   This function is very much unlike the ones for C and C++ since we\n+   have already done any type conversion and matching required.  All we\n+   have to do here is validate the work done by SEM and handle subtypes.  */\n+\n+tree\n+build_binary_op (op_code, result_type, left_operand, right_operand)\n+     enum tree_code op_code;\n+     tree result_type;\n+     tree left_operand;\n+     tree right_operand;\n+{\n+  tree left_type  = TREE_TYPE (left_operand);\n+  tree right_type = TREE_TYPE (right_operand);\n+  tree left_base_type = get_base_type (left_type);\n+  tree right_base_type = get_base_type (right_type);\n+  tree operation_type = result_type;\n+  tree best_type = 0;\n+  tree modulus;\n+  tree result;\n+  int has_side_effects = 0;\n+\n+  /* If one (but not both, unless they have the same object) operands are a\n+     WITH_RECORD_EXPR, do the operation and then surround it with the\n+     WITH_RECORD_EXPR.  Don't do this for assignment, for an ARRAY_REF, or\n+     for an ARRAY_RANGE_REF because we need to keep track of the\n+     WITH_RECORD_EXPRs on both operands very carefully.  */\n+  if (op_code != MODIFY_EXPR && op_code != ARRAY_REF\n+      && op_code != ARRAY_RANGE_REF\n+      && TREE_CODE (left_operand) == WITH_RECORD_EXPR\n+      && (TREE_CODE (right_operand) != WITH_RECORD_EXPR\n+\t  || operand_equal_p (TREE_OPERAND (left_operand, 1),\n+\t\t\t      TREE_OPERAND (right_operand, 1), 0)))\n+    {\n+      tree right = right_operand;\n+\n+      if (TREE_CODE (right) == WITH_RECORD_EXPR)\n+\tright = TREE_OPERAND (right, 0);\n+\n+      result = build_binary_op (op_code, result_type,\n+\t\t\t\tTREE_OPERAND (left_operand, 0), right);\n+      return build (WITH_RECORD_EXPR, TREE_TYPE (result), result,\n+\t\t    TREE_OPERAND (left_operand, 1));\n+    }\n+  else if (op_code != MODIFY_EXPR && op_code != ARRAY_REF\n+\t   && op_code != ARRAY_RANGE_REF\n+\t   && TREE_CODE (left_operand) != WITH_RECORD_EXPR\n+\t   && TREE_CODE (right_operand) == WITH_RECORD_EXPR)\n+    {\n+      result = build_binary_op (op_code, result_type, left_operand,\n+\t\t\t\tTREE_OPERAND (right_operand, 0));\n+      return build (WITH_RECORD_EXPR, TREE_TYPE (result), result,\n+\t\t    TREE_OPERAND (right_operand, 1));\n+    }\n+\n+  if (operation_type != 0\n+      && TREE_CODE (operation_type) == RECORD_TYPE\n+      && TYPE_LEFT_JUSTIFIED_MODULAR_P (operation_type))\n+    operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n+\n+  if (operation_type != 0\n+      && ! AGGREGATE_TYPE_P (operation_type)\n+      && TYPE_EXTRA_SUBTYPE_P (operation_type))\n+    operation_type = get_base_type (operation_type);\n+\n+  modulus = (operation_type != 0 && TREE_CODE (operation_type) == INTEGER_TYPE\n+\t     && TYPE_MODULAR_P (operation_type)\n+\t     ? TYPE_MODULUS (operation_type) : 0);\n+\n+  switch (op_code)\n+    {\n+    case MODIFY_EXPR:\n+      /* If there were any integral or pointer conversions on LHS, remove\n+\t them; we'll be putting them back below if needed.  Likewise for\n+\t conversions between array and record types.  But don't do this if\n+\t the right operand is not BLKmode (for packed arrays)\n+\t unless we are not changing the mode.  */\n+      while ((TREE_CODE (left_operand) == CONVERT_EXPR\n+\t      || TREE_CODE (left_operand) == NOP_EXPR\n+\t      || TREE_CODE (left_operand) == UNCHECKED_CONVERT_EXPR)\n+\t     && (((INTEGRAL_TYPE_P (left_type)\n+\t\t   || POINTER_TYPE_P (left_type))\n+\t\t  && (INTEGRAL_TYPE_P (TREE_TYPE\n+\t\t\t\t       (TREE_OPERAND (left_operand, 0)))\n+\t\t      || POINTER_TYPE_P (TREE_TYPE\n+\t\t\t\t\t (TREE_OPERAND (left_operand, 0)))))\n+\t\t || (((TREE_CODE (left_type) == RECORD_TYPE\n+\t\t       /* Don't remove conversions to left-justified modular\n+\t\t\t  types. */\n+\t\t       && ! TYPE_LEFT_JUSTIFIED_MODULAR_P (left_type))\n+\t\t      || TREE_CODE (left_type) == ARRAY_TYPE)\n+\t\t     && ((TREE_CODE (TREE_TYPE\n+\t\t\t\t     (TREE_OPERAND (left_operand, 0)))\n+\t\t\t  == RECORD_TYPE)\n+\t\t\t || (TREE_CODE (TREE_TYPE\n+\t\t\t\t\t(TREE_OPERAND (left_operand, 0)))\n+\t\t\t     == ARRAY_TYPE))\n+\t\t     && (TYPE_MODE (right_type) == BLKmode\n+\t\t\t || (TYPE_MODE (left_type)\n+\t\t\t     == TYPE_MODE (TREE_TYPE\n+\t\t\t\t\t   (TREE_OPERAND\n+\t\t\t\t\t    (left_operand, 0))))))))\n+\t{\n+\t  left_operand = TREE_OPERAND (left_operand, 0);\n+\t  left_type = TREE_TYPE (left_operand);\n+\t}\n+\n+      if (operation_type == 0)\n+\toperation_type = left_type;\n+\n+      /* If the RHS has a conversion between record and array types and\n+\t an inner type is no worse, use it.  Note we cannot do this for\n+\t modular types or types with TYPE_ALIGN_OK_P, since the latter\n+\t might indicate a conversion between a root type and a class-wide\n+\t type, which we must not remove.  */\n+      while (TREE_CODE (right_operand) == UNCHECKED_CONVERT_EXPR\n+\t     && ((TREE_CODE (right_type) == RECORD_TYPE\n+\t\t  && ! TYPE_LEFT_JUSTIFIED_MODULAR_P (right_type)\n+\t\t  && ! TYPE_ALIGN_OK_P (right_type)\n+\t\t  && ! TYPE_IS_FAT_POINTER_P (right_type))\n+\t\t || TREE_CODE (right_type) == ARRAY_TYPE)\n+\t     && (((TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t\t   == RECORD_TYPE)\n+\t\t  && ! (TYPE_LEFT_JUSTIFIED_MODULAR_P\n+\t\t\t(TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\t\t  && ! (TYPE_ALIGN_OK_P\n+\t\t\t(TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\t\t  && ! (TYPE_IS_FAT_POINTER_P\n+\t\t\t(TREE_TYPE (TREE_OPERAND (right_operand, 0)))))\n+\t\t || (TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t\t     == ARRAY_TYPE))\n+\t     && (0 == (best_type\n+\t\t       == find_common_type (right_type,\n+\t\t\t\t\t    TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t\t       (right_operand, 0))))\n+\t\t || right_type != best_type))\n+\t{\n+\t  right_operand = TREE_OPERAND (right_operand, 0);\n+\t  right_type = TREE_TYPE (right_operand);\n+\t}\n+\n+      /* If we are copying one array or record to another, find the best type\n+\t to use.  */\n+      if (((TREE_CODE (left_type) == ARRAY_TYPE\n+\t    && TREE_CODE (right_type) == ARRAY_TYPE)\n+\t   || (TREE_CODE (left_type) == RECORD_TYPE\n+\t       && TREE_CODE (right_type) == RECORD_TYPE))\n+\t  && (best_type = find_common_type (left_type, right_type)) != 0)\n+\toperation_type = best_type;\n+\n+      /* If a class-wide type may be involved, force use of the RHS type.  */\n+      if (TREE_CODE (right_type) == RECORD_TYPE\n+\t  && TYPE_ALIGN_OK_P (right_type))\n+\toperation_type = right_type;\n+\n+      /* After we strip off any COMPONENT_REF, ARRAY_REF, or ARRAY_RANGE_REF\n+\t from the lhs, we must have either an INDIRECT_REF or a decl. Allow\n+\t UNCHECKED_CONVERT_EXPRs, but set TREE_ADDRESSABLE to show they are\n+\t in an LHS.  Finally, allow NOP_EXPR if both types are the same tree\n+\t code and mode because we know these will be nops.  */\n+      for (result = left_operand;\n+\t   TREE_CODE (result) == COMPONENT_REF\n+\t   || TREE_CODE (result) == ARRAY_REF\n+\t   || TREE_CODE (result) == ARRAY_RANGE_REF\n+\t   || TREE_CODE (result) == REALPART_EXPR\n+\t   || TREE_CODE (result) == IMAGPART_EXPR\n+\t   || TREE_CODE (result) == WITH_RECORD_EXPR\n+\t   || TREE_CODE (result) == UNCHECKED_CONVERT_EXPR\n+\t   || ((TREE_CODE (result) == NOP_EXPR\n+\t\t|| TREE_CODE (result) == CONVERT_EXPR)\n+\t       && (TREE_CODE (TREE_TYPE (result))\n+\t\t   == TREE_CODE (TREE_TYPE (TREE_OPERAND (result, 0))))\n+\t       && (TYPE_MODE (TREE_TYPE (TREE_OPERAND (result, 0)))\n+\t\t   == TYPE_MODE (TREE_TYPE (result))));\n+\t   result = TREE_OPERAND (result, 0))\n+\tif (TREE_CODE (result) == UNCHECKED_CONVERT_EXPR)\n+\t  TREE_ADDRESSABLE (result) = 1;\n+\n+      if (TREE_CODE (result) != INDIRECT_REF && TREE_CODE (result) != NULL_EXPR\n+\t  && ! DECL_P (result))\n+\tgigi_abort (516);\n+\n+      /* Convert the right operand to the operation type unless\n+\t it is either already of the correct type or if the type\n+\t involves a placeholder, since the RHS may not have the same\n+\t record type.  */\n+      if (operation_type != right_type\n+\t  && (! (TREE_CODE (TYPE_SIZE (operation_type)) != INTEGER_CST\n+\t\t && contains_placeholder_p (TYPE_SIZE (operation_type)))))\n+\t{\n+\t  /* For a variable-size type, with both BLKmode, convert using\n+\t     CONVERT_EXPR instead of an unchecked conversion since we don't\n+\t     need to make a temporary (and can't anyway).  */\n+\t  if (TREE_CODE (TYPE_SIZE (operation_type)) != INTEGER_CST\n+\t      && TYPE_MODE (TREE_TYPE (right_operand)) == BLKmode\n+\t      && TREE_CODE (right_operand) != UNCONSTRAINED_ARRAY_REF)\n+\t    right_operand = build1 (CONVERT_EXPR, operation_type,\n+\t\t\t\t    right_operand);\n+\t  else\n+\t    right_operand = convert (operation_type, right_operand);\n+\n+\t  right_type = operation_type;\n+\t}\n+\n+      /* If the modes differ, make up a bogus type and convert the RHS to\n+\t it.  This can happen with packed types.  */\n+      if (TYPE_MODE (left_type) != TYPE_MODE (right_type))\n+\t{\n+\t  tree new_type = copy_node (left_type);\n+\n+\t  TYPE_SIZE (new_type) = TYPE_SIZE (right_type);\n+\t  TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (right_type);\n+\t  TYPE_MAIN_VARIANT (new_type) = new_type;\n+\t  right_operand = convert (new_type, right_operand);\n+\t}\n+\n+      has_side_effects = 1;\n+      modulus = 0;\n+      break;\n+\n+    case ARRAY_REF:\n+      if (operation_type == 0)\n+\toperation_type = TREE_TYPE (left_type);\n+\n+      /* ... fall through ... */\n+\n+    case ARRAY_RANGE_REF:\n+\n+      /* First convert the right operand to its base type.  This will\n+\t prevent unneed signedness conversions when sizetype is wider than\n+\t integer.  */\n+      right_operand = convert (right_base_type, right_operand);\n+      right_operand = convert (TYPE_DOMAIN (left_type), right_operand);\n+\n+      if (! TREE_CONSTANT (right_operand)\n+\t  || ! TREE_CONSTANT (TYPE_MIN_VALUE (right_type))\n+\t  || op_code == ARRAY_RANGE_REF)\n+\tmark_addressable (left_operand);\n+\n+      /* If the array is an UNCHECKED_CONVERT_EXPR from and to BLKmode\n+\t types, convert it to a normal conversion since GCC can deal\n+\t with any mis-alignment as part of the handling of compponent\n+\t references.  */\n+\n+      if (TREE_CODE (left_operand) == UNCHECKED_CONVERT_EXPR\n+\t  && TYPE_MODE (TREE_TYPE (left_operand)) == BLKmode\n+\t  && TYPE_MODE (TREE_TYPE (TREE_OPERAND (left_operand, 0))) == BLKmode)\n+\tleft_operand = build1 (CONVERT_EXPR, TREE_TYPE (left_operand),\n+\t\t\t       TREE_OPERAND (left_operand, 0));\n+\n+      modulus = 0;\n+      break;\n+\n+    case GE_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case LT_EXPR:\n+      if (POINTER_TYPE_P (left_type))\n+\tgigi_abort (501);\n+\n+      /* ... fall through ... */\n+\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      /* If either operand is a NULL_EXPR, just return a new one.  */\n+      if (TREE_CODE (left_operand) == NULL_EXPR)\n+\treturn build (op_code, result_type,\n+\t\t      build1 (NULL_EXPR, integer_type_node,\n+\t\t\t      TREE_OPERAND (left_operand, 0)),\n+\t\t      integer_zero_node);\n+\n+      else if (TREE_CODE (right_operand) == NULL_EXPR)\n+\treturn build (op_code, result_type,\n+\t\t      build1 (NULL_EXPR, integer_type_node,\n+\t\t\t      TREE_OPERAND (right_operand, 0)),\n+\t\t      integer_zero_node);\n+\n+      /* If either object is a left-justified modular types, get the\n+\t fields from within.  */\n+      if (TREE_CODE (left_type) == RECORD_TYPE\n+\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (left_type))\n+\t{\n+\t  left_operand = convert (TREE_TYPE (TYPE_FIELDS (left_type)),\n+\t\t\t\t  left_operand);\n+\t  left_type = TREE_TYPE (left_operand);\n+\t  left_base_type = get_base_type (left_type);\n+\t}\n+\n+      if (TREE_CODE (right_type) == RECORD_TYPE\n+\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (right_type))\n+\t{\n+\t  right_operand = convert (TREE_TYPE (TYPE_FIELDS (right_type)),\n+\t\t\t\t  right_operand);\n+\t  right_type = TREE_TYPE (right_operand);\n+\t  right_base_type = get_base_type (right_type);\n+\t}\n+\n+      /* If either object if an UNCHECKED_CONVERT_EXPR between two BLKmode\n+\t objects, change it to a CONVERT_EXPR.  */\n+      if (TREE_CODE (left_operand) == UNCHECKED_CONVERT_EXPR\n+\t  && TYPE_MODE (left_type) == BLKmode\n+\t  && TYPE_MODE (TREE_TYPE (TREE_OPERAND (left_operand, 0))) == BLKmode)\n+\tleft_operand = build1 (CONVERT_EXPR, left_type,\n+\t\t\t       TREE_OPERAND (left_operand, 0));\n+      if (TREE_CODE (right_operand) == UNCHECKED_CONVERT_EXPR\n+\t  && TYPE_MODE (right_type) == BLKmode\n+\t  && (TYPE_MODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t      == BLKmode))\n+\tright_operand = build1 (CONVERT_EXPR, right_type,\n+\t\t\t\tTREE_OPERAND (right_operand, 0));\n+\n+      /* If both objects are arrays, compare them specially.  */\n+      if ((TREE_CODE (left_type) == ARRAY_TYPE\n+\t   || (TREE_CODE (left_type) == INTEGER_TYPE\n+\t       && TYPE_HAS_ACTUAL_BOUNDS_P (left_type)))\n+\t  && (TREE_CODE (right_type) == ARRAY_TYPE\n+\t      || (TREE_CODE (right_type) == INTEGER_TYPE\n+\t\t  && TYPE_HAS_ACTUAL_BOUNDS_P (right_type))))\n+\t{\n+\t  result = compare_arrays (result_type, left_operand, right_operand);\n+\n+\t  if (op_code == EQ_EXPR)\n+\t    ;\n+\t  else if (op_code == NE_EXPR)\n+\t    result = invert_truthvalue (result);\n+\t  else\n+\t    gigi_abort (502);\n+\n+\t  return result;\n+\t}\n+\n+      /* Otherwise, the base types must be the same unless the objects are\n+\t records.  If we have records, use the best type and convert both\n+\t operands to that type.  */\n+      if (left_base_type != right_base_type)\n+\t{\n+\t  if (TREE_CODE (left_base_type) == RECORD_TYPE\n+\t      && TREE_CODE (right_base_type) == RECORD_TYPE)\n+\t    {\n+\t      /* The only way these are permitted to be the same is if both\n+\t\t types have the same name.  In that case, one of them must\n+\t\t not be self-referential.  Use that one as the best type.\n+\t\t Even better is if one is of fixed size.  */\n+\t      best_type = 0;\n+\n+\t      if (TYPE_NAME (left_base_type) == 0\n+\t\t  || TYPE_NAME (left_base_type) != TYPE_NAME (right_base_type))\n+\t\tgigi_abort (503);\n+\n+\t      if (TREE_CONSTANT (TYPE_SIZE (left_base_type)))\n+\t\tbest_type = left_base_type;\n+\t      else if (TREE_CONSTANT (TYPE_SIZE (right_base_type)))\n+\t\tbest_type = right_base_type;\n+\t      else if (! contains_placeholder_p (TYPE_SIZE (left_base_type)))\n+\t\tbest_type = left_base_type;\n+\t      else if (! contains_placeholder_p (TYPE_SIZE (right_base_type)))\n+\t\tbest_type = right_base_type;\n+\t      else\n+\t\tgigi_abort (504);\n+\n+\t      left_operand = convert (best_type, left_operand);\n+\t      right_operand = convert (best_type, right_operand);\n+\t    }\n+\t  else\n+\t    gigi_abort (505);\n+\t}\n+\n+      /* If we are comparing a fat pointer against zero, we need to \n+\t just compare the data pointer.  */\n+      else if (TYPE_FAT_POINTER_P (left_base_type)\n+\t       && TREE_CODE (right_operand) == CONSTRUCTOR\n+\t       && integer_zerop (TREE_VALUE (TREE_OPERAND (right_operand, 1))))\n+\t{\n+\t  right_operand = build_component_ref (left_operand, NULL_TREE,\n+\t\t\t\t\t       TYPE_FIELDS (left_base_type));\n+\t  left_operand = convert (TREE_TYPE (right_operand),\n+\t\t\t\t  integer_zero_node);\n+\t}\n+      else\n+\t{\n+\t  left_operand = convert (left_base_type, left_operand);\n+\t  right_operand = convert (right_base_type, right_operand);\n+\t}\n+\n+      modulus = 0;\n+      break;\n+\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      /* In these, the result type and the left operand type should be the\n+\t same.  Do the operation in the base type of those and convert the\n+\t right operand (which is an integer) to that type.\n+\n+\t Note that these operations are only used in loop control where\n+\t we guarantee that no overflow can occur.  So nothing special need\n+\t be done for modular types.  */\n+\n+      if (left_type != result_type)\n+\tgigi_abort (506);\n+\n+      operation_type = get_base_type (result_type);\n+      left_operand = convert (operation_type, left_operand);\n+      right_operand = convert (operation_type, right_operand);\n+      has_side_effects = 1;\n+      modulus = 0;\n+      break;\n+\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+       /* The RHS of a shift can be any type.  Also, ignore any modulus\n+\t (we used to abort, but this is needed for unchecked conversion\n+\t to modular types).  Otherwise, processing is the same as normal.  */\n+      if (operation_type != left_base_type)\n+\tgigi_abort (514);\n+\n+      modulus = 0;\n+      left_operand = convert (operation_type, left_operand);\n+      break;\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+      left_operand = truthvalue_conversion (left_operand);\n+      right_operand = truthvalue_conversion (right_operand);\n+      goto common;\n+\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      /* For binary modulus, if the inputs are in range, so are the\n+\t outputs.  */\n+      if (modulus != 0 && integer_pow2p (modulus))\n+\tmodulus = 0;\n+\n+      goto common;\n+\n+    case COMPLEX_EXPR:\n+      if (TREE_TYPE (result_type) != left_base_type\n+\t  || TREE_TYPE (result_type) != right_base_type)\n+\tgigi_abort (515);\n+\n+      left_operand = convert (left_base_type, left_operand);\n+      right_operand = convert (right_base_type, right_operand);\n+      break;\n+\n+    case TRUNC_DIV_EXPR:   case TRUNC_MOD_EXPR:\n+    case CEIL_DIV_EXPR:    case CEIL_MOD_EXPR:\n+    case FLOOR_DIV_EXPR:   case FLOOR_MOD_EXPR:\n+    case ROUND_DIV_EXPR:   case ROUND_MOD_EXPR:\n+      /* These always produce results lower than either operand.  */\n+      modulus = 0;\n+      goto common;\n+\n+    default:\n+    common:\n+      /* The result type should be the same as the base types of the\n+\t both operands (and they should be the same).  Convert\n+\t everything to the result type.  */\n+\n+      if (operation_type != left_base_type\n+\t  || left_base_type != right_base_type)\n+\tgigi_abort (507);\n+\n+      left_operand = convert (operation_type, left_operand);\n+      right_operand = convert (operation_type, right_operand);\n+    }\n+\n+  if (modulus != 0 && ! integer_pow2p (modulus))\n+    {\n+      result = nonbinary_modular_operation (op_code, operation_type,\n+\t\t\t\t\t    left_operand, right_operand);\n+      modulus = 0;\n+    }\n+  /* If either operand is a NULL_EXPR, just return a new one.  */\n+  else if (TREE_CODE (left_operand) == NULL_EXPR)\n+    return build1 (NULL_EXPR, operation_type, TREE_OPERAND (left_operand, 0));\n+  else if (TREE_CODE (right_operand) == NULL_EXPR)\n+    return build1 (NULL_EXPR, operation_type, TREE_OPERAND (right_operand, 0));\n+  else\n+    result = fold (build (op_code, operation_type,\n+\t\t\t  left_operand, right_operand));\n+\n+  TREE_SIDE_EFFECTS (result) |= has_side_effects;\n+  TREE_CONSTANT (result)\n+    = (TREE_CONSTANT (left_operand) & TREE_CONSTANT (right_operand)\n+       && op_code != ARRAY_REF && op_code != ARRAY_RANGE_REF);\n+\n+  if ((op_code == ARRAY_REF || op_code == ARRAY_RANGE_REF)\n+      && TYPE_VOLATILE (operation_type))\n+    TREE_THIS_VOLATILE (result) = 1;\n+\n+  /* If we are working with modular types, perform the MOD operation\n+     if something above hasn't eliminated the need for it.  */\n+  if (modulus != 0)\n+    result = fold (build (FLOOR_MOD_EXPR, operation_type, result,\n+\t\t\t  convert (operation_type, modulus)));\n+\n+  if (result_type != 0 && result_type != operation_type)\n+    result = convert (result_type, result);\n+\n+  return result;\n+}\n+\f\n+/* Similar, but for unary operations.  */\n+\n+tree\n+build_unary_op (op_code, result_type, operand)\n+     enum tree_code op_code;\n+     tree result_type;\n+     tree operand;\n+{\n+  tree type = TREE_TYPE (operand);\n+  tree base_type = get_base_type (type);\n+  tree operation_type = result_type;\n+  tree result;\n+  int side_effects = 0;\n+\n+  /* If we have a WITH_RECORD_EXPR as our operand, do the operation first,\n+     then surround it with the WITH_RECORD_EXPR.  This allows GCC to do better\n+     expression folding.  */\n+  if (TREE_CODE (operand) == WITH_RECORD_EXPR)\n+    {\n+      result = build_unary_op (op_code, result_type,\n+\t\t\t       TREE_OPERAND (operand, 0));\n+      return build (WITH_RECORD_EXPR, TREE_TYPE (result), result,\n+\t\t    TREE_OPERAND (operand, 1));\n+    }\n+\n+  if (operation_type != 0\n+      && TREE_CODE (operation_type) == RECORD_TYPE\n+      && TYPE_LEFT_JUSTIFIED_MODULAR_P (operation_type))\n+    operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n+\n+  if (operation_type != 0\n+      && ! AGGREGATE_TYPE_P (operation_type)\n+      && TYPE_EXTRA_SUBTYPE_P (operation_type))\n+    operation_type = get_base_type (operation_type);\n+\n+  switch (op_code)\n+    {\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      if (operation_type == 0)\n+\tresult_type = operation_type = TREE_TYPE (type);\n+      else if (result_type != TREE_TYPE (type))\n+\tgigi_abort (513);\n+\n+      result = fold (build1 (op_code, operation_type, operand));\n+      break;\n+\n+    case TRUTH_NOT_EXPR:\n+      if (result_type != base_type)\n+\tgigi_abort (508);\n+\n+      result = invert_truthvalue (truthvalue_conversion (operand));\n+      break;\n+\n+    case ATTR_ADDR_EXPR:\n+    case ADDR_EXPR:\n+      switch (TREE_CODE (operand))\n+\t{\n+\tcase INDIRECT_REF:\n+\tcase UNCONSTRAINED_ARRAY_REF:\n+\t  result = TREE_OPERAND (operand, 0);\n+\n+\t  /* Make sure the type here is a pointer, not a reference.\n+\t     GCC wants pointer types for function addresses.  */\n+\t  if (result_type == 0)\n+\t    result_type = build_pointer_type (type);\n+\t  break;\n+\n+\tcase NULL_EXPR:\n+\t  result = operand;\n+\t  TREE_TYPE (result) = type = build_pointer_type (type);\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\tcase COMPONENT_REF:\n+\tcase BIT_FIELD_REF:\n+\t    /* If this is for 'Address, find the address of the prefix and\n+\t       add the offset to the field.  Otherwise, do this the normal\n+\t       way.  */\n+\t  if (op_code == ATTR_ADDR_EXPR)\n+\t    {\n+\t      HOST_WIDE_INT bitsize;\n+\t      HOST_WIDE_INT bitpos;\n+\t      tree offset, inner;\n+\t      enum machine_mode mode;\n+\t      int unsignedp, volatilep;\n+\t      unsigned int alignment;\n+\n+\t      inner = get_inner_reference (operand, &bitsize, &bitpos, &offset,\n+\t\t\t\t\t   &mode, &unsignedp, &volatilep,\n+\t\t\t\t\t   &alignment);\n+\n+\t      /* If INNER is a padding type whose field has a self-referential\n+\t\t size, convert to that inner type.  We know the offset is zero\n+\t\t and we need to have that type visible.  */\n+\t      if (TREE_CODE (TREE_TYPE (inner)) == RECORD_TYPE\n+\t\t  && TYPE_IS_PADDING_P (TREE_TYPE (inner))\n+\t\t  && (contains_placeholder_p\n+\t\t      (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n+\t\t\t\t\t     (TREE_TYPE (inner)))))))\n+\t\tinner = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (inner))),\n+\t\t\t\t inner);\n+\n+\t      /* Compute the offset as a byte offset from INNER.  */\n+\t      if (offset == 0)\n+\t\toffset = size_zero_node;\n+\n+\t      offset = size_binop (PLUS_EXPR, offset,\n+\t\t\t\t   size_int (bitpos / BITS_PER_UNIT));\n+\n+\t      /* Take the address of INNER, convert the offset to void *, and\n+\t\t add then.  It will later be converted to the desired result\n+\t\t type, if any.  */\n+\t      inner = build_unary_op (ADDR_EXPR, NULL_TREE, inner);\n+\t      inner = convert (ptr_void_type_node, inner);\n+\t      offset = convert (ptr_void_type_node, offset);\n+\t      result = build_binary_op (PLUS_EXPR, ptr_void_type_node,\n+\t\t\t\t\tinner, offset);\n+\t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n+\t\t\t\tresult);\n+\t      break;\n+\t    }\n+\t  goto common;\n+\n+\tcase CONSTRUCTOR:\n+\t  /* If this is just a constructor for a padded record, we can\n+\t     just take the address of the single field and convert it to\n+\t     a pointer to our type.  */\n+\t  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+\t    {\n+\t      result\n+\t\t= build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t  TREE_VALUE (CONSTRUCTOR_ELTS (operand)));\n+\t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n+\t\t\t\tresult);\n+\t      break;\n+\t    }\n+\n+\t  goto common;\n+\n+\tcase NOP_EXPR:\n+\t  if (AGGREGATE_TYPE_P (type)\n+\t      && AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (operand, 0))))\n+\t    return build_unary_op (ADDR_EXPR, result_type,\n+\t\t\t\t   TREE_OPERAND (operand, 0));\n+\n+\t  /* If this NOP_EXPR doesn't change the mode, get the result type\n+\t     from this type and go down.  We need to do this in case\n+\t     this is a conversion of a CONST_DECL.  */\n+\t  if (TYPE_MODE (type) != BLKmode\n+\t      && (TYPE_MODE (type)\n+\t\t  == TYPE_MODE (TREE_TYPE (TREE_OPERAND (operand, 0)))))\n+\t    return build_unary_op (ADDR_EXPR,\n+\t\t\t\t   (result_type == 0\n+\t\t\t\t    ? build_pointer_type (type)\n+\t\t\t\t    : result_type),\n+\t\t\t\t   TREE_OPERAND (operand, 0));\n+\t  goto common;\n+\n+\tcase CONST_DECL:\n+\t  operand = DECL_CONST_CORRESPONDING_VAR (operand);\n+\n+\t  /* ... fall through ... */\n+\n+\tdefault:\n+\tcommon:\n+\n+\t  if (type != error_mark_node)\n+\t    operation_type = build_pointer_type (type);\n+\n+\t  mark_addressable (operand);\n+\t  result = fold (build1 (ADDR_EXPR, operation_type, operand));\n+\t}\n+\n+      TREE_CONSTANT (result) = staticp (operand) || TREE_CONSTANT (operand);\n+      break;\n+\n+    case INDIRECT_REF:\n+      /* If we want to refer to an entire unconstrained array,\n+\t make up an expression to do so.  This will never survive to\n+\t the backend.  If TYPE is a thin pointer, first convert the\n+\t operand to a fat pointer.  */\n+      if (TYPE_THIN_POINTER_P (type)\n+\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)) != 0)\n+\t{\n+\t  operand\n+\t    = convert (TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))),\n+\t\t       operand);\n+\t  type = TREE_TYPE (operand);\n+\t}\n+\n+      if (TYPE_FAT_POINTER_P (type))\n+\tresult = build1 (UNCONSTRAINED_ARRAY_REF,\n+\t\t\t TYPE_UNCONSTRAINED_ARRAY (type), operand);\n+\n+      else if (TREE_CODE (operand) == ADDR_EXPR)\n+\tresult = TREE_OPERAND (operand, 0);\n+\n+      else\n+\t{\n+\t  result = fold (build1 (op_code, TREE_TYPE (type), operand));\n+\t  TREE_READONLY (result) = TREE_STATIC (result)\n+\t    = TREE_READONLY (TREE_TYPE (type));\n+\t}\n+\n+      side_effects = flag_volatile \n+\t|| (! TYPE_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)));\n+      break;\n+\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+      {\n+\ttree modulus = ((operation_type != 0\n+\t\t\t && TREE_CODE (operation_type) == INTEGER_TYPE\n+\t\t\t && TYPE_MODULAR_P (operation_type))\n+\t\t\t? TYPE_MODULUS (operation_type) : 0);\n+\tint mod_pow2 = modulus != 0 && integer_pow2p (modulus);\n+\n+\t/* If this is a modular type, there are various possibilities\n+\t   depending on the operation and whether the modulus is a\n+\t   power of two or not.  */\n+\n+\tif (modulus != 0)\n+\t  {\n+\t    if (operation_type != base_type)\n+\t      gigi_abort (509);\n+\n+\t    operand = convert (operation_type, operand);\n+\n+\t    /* The fastest in the negate case for binary modulus is\n+\t       the straightforward code; the TRUNC_MOD_EXPR below\n+\t       is an AND operation.  */\n+\t    if (op_code == NEGATE_EXPR && mod_pow2)\n+\t      result = fold (build (TRUNC_MOD_EXPR, operation_type,\n+\t\t\t\t    fold (build1 (NEGATE_EXPR, operation_type,\n+\t\t\t\t\t\t  operand)),\n+\t\t\t\t    modulus));\n+\n+\t    /* For nonbinary negate case, return zero for zero operand,\n+\t       else return the modulus minus the operand.  If the modulus\n+\t       is a power of two minus one, we can do the subtraction\n+\t       as an XOR since it is equivalent and faster on most machines. */\n+\t    else if (op_code == NEGATE_EXPR && ! mod_pow2)\n+\t      {\n+\t\tif (integer_pow2p (fold (build (PLUS_EXPR, operation_type,\n+\t\t\t\t\t\tmodulus,\n+\t\t\t\t\t\tconvert (operation_type,\n+\t\t\t\t\t\t\t integer_one_node)))))\n+\t\t  result = fold (build (BIT_XOR_EXPR, operation_type,\n+\t\t\t\t\toperand, modulus));\n+\t\telse\n+\t\t  result = fold (build (MINUS_EXPR, operation_type,\n+\t\t\t\t\tmodulus, operand));\n+\n+\t\tresult = fold (build (COND_EXPR, operation_type,\n+\t\t\t\t      fold (build (NE_EXPR, integer_type_node,\n+\t\t\t\t\t\t   operand,\n+\t\t\t\t\t\t   convert (operation_type,\n+\t\t\t\t\t\t\t    integer_zero_node))),\n+\t\t\t\t      result, operand));\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* For the NOT cases, we need a constant equal to\n+\t\t   the modulus minus one.  For a binary modulus, we\n+\t\t   XOR against the constant and subtract the operand from\n+\t\t   that constant for nonbinary modulus.  */\n+\n+\t\ttree cnst = fold (build (MINUS_EXPR, operation_type, modulus,\n+\t\t\t\t\t convert (operation_type,\n+\t\t\t\t\t\t  integer_one_node)));\n+\n+\t\tif (mod_pow2)\n+\t\t  result = fold (build (BIT_XOR_EXPR, operation_type,\n+\t\t\t\t\toperand, cnst));\n+\t\telse\n+\t\t  result = fold (build (MINUS_EXPR, operation_type,\n+\t\t\t\t\tcnst, operand));\n+\t      }\n+\n+\t    break;\n+\t  }\n+      }\n+\n+      /* ... fall through ... */\n+\n+    default:\n+      if (operation_type != base_type)\n+\tgigi_abort (509);\n+\n+      result = fold (build1 (op_code, operation_type, convert (operation_type,\n+\t\t\t\t\t\t\t       operand)));\n+    }\n+\n+  if (side_effects)\n+    {\n+      TREE_SIDE_EFFECTS (result) = 1;\n+      if (TREE_CODE (result) == INDIRECT_REF)\n+\tTREE_THIS_VOLATILE (result) = TYPE_VOLATILE (TREE_TYPE (result));\n+    }\n+\n+  if (result_type != 0 && TREE_TYPE (result) != result_type)\n+    result = convert (result_type, result);\n+\n+  return result;\n+}\n+\f\n+/* Similar, but for COND_EXPR.  */\n+\n+tree\n+build_cond_expr (result_type, condition_operand, true_operand, false_operand)\n+     tree result_type;\n+     tree condition_operand;\n+     tree true_operand;\n+     tree false_operand;\n+{\n+  tree result;\n+  int addr_p = 0;\n+\n+  /* Front-end verifies that result, true and false operands have same base\n+     type. Convert everything to the result type.  */\n+\n+  true_operand  = convert (result_type, true_operand);\n+  false_operand = convert (result_type, false_operand);\n+\n+  /* If the result type is unconstrained, take the address of\n+     the operands and then dereference our result.  */\n+\n+  if (TREE_CODE (result_type) == UNCONSTRAINED_ARRAY_TYPE\n+      || (TREE_CODE (TYPE_SIZE (result_type)) != INTEGER_CST\n+\t  && contains_placeholder_p (TYPE_SIZE (result_type))))\n+    {\n+      addr_p = 1;\n+      result_type = build_pointer_type (result_type);\n+      true_operand = build_unary_op (ADDR_EXPR, result_type, true_operand);\n+      false_operand = build_unary_op (ADDR_EXPR, result_type, false_operand);\n+    }\n+\n+  result = fold (build (COND_EXPR, result_type, condition_operand,\n+\t\t\ttrue_operand, false_operand));\n+  if (addr_p)\n+    result = build_unary_op (INDIRECT_REF, NULL_TREE, result);\n+\n+  return result;\n+}\n+\f\n+\n+/* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n+   the CALL_EXPR.  */\n+\n+tree\n+build_call_1_expr (fundecl, arg)\n+     tree fundecl;\n+     tree arg;\n+{\n+  tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t     chainon (NULL_TREE, build_tree_list (NULL_TREE, arg)),\n+\t\t     NULL_TREE);\n+\n+  TREE_SIDE_EFFECTS (call) = 1;\n+\n+  return call;\n+}\n+\n+/* Build a CALL_EXPR to call FUNDECL with two arguments, ARG1 & ARG2.  Return\n+   the CALL_EXPR.  */\n+\n+tree\n+build_call_2_expr (fundecl, arg1, arg2)\n+     tree fundecl;\n+     tree arg1, arg2;\n+{\n+  tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t     chainon (chainon (NULL_TREE,\n+\t\t\t\t       build_tree_list (NULL_TREE, arg1)),\n+\t\t\t      build_tree_list (NULL_TREE, arg2)),\n+\t\t     NULL_TREE);\n+\n+  TREE_SIDE_EFFECTS (call) = 1;\n+\n+  return call;\n+}\n+\n+/* Likewise to call FUNDECL with no arguments.  */\n+\n+tree\n+build_call_0_expr (fundecl)\n+     tree fundecl;\n+{\n+  tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t     NULL_TREE, NULL_TREE);\n+\n+  TREE_SIDE_EFFECTS (call) = 1;\n+\n+  return call;\n+}\n+\f\n+/* Call a function FCN that raises an exception and pass the line\n+   number and file name, if requested.  */\n+\n+tree\n+build_call_raise (fndecl)\n+     tree fndecl;\n+{\n+  const char *str = discard_file_names ? \"\" : ref_filename;\n+  int len = strlen (str) + 1;\n+  tree filename = build_string (len, str);\n+\n+  TREE_TYPE (filename)\n+    = build_array_type (char_type_node,\n+\t\t\tbuild_index_type (build_int_2 (len, 0)));\n+\n+  return\n+    build_call_2_expr (fndecl,\n+\t\t       build1 (ADDR_EXPR, build_pointer_type (char_type_node),\n+\t\t\t       filename),\n+\t\t       build_int_2 (lineno, 0));\n+}\n+\f\n+/* Return a CONSTRUCTOR of TYPE whose list is LIST.  */\n+\n+tree\n+build_constructor (type, list)\n+     tree type;\n+     tree list;\n+{\n+  tree elmt;\n+  int allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n+  int side_effects = 0;\n+  tree result;\n+\n+  for (elmt = list; elmt; elmt = TREE_CHAIN (elmt))\n+    {\n+      if (! TREE_CONSTANT (TREE_VALUE (elmt))\n+\t  || (TREE_CODE (type) == RECORD_TYPE\n+\t      && DECL_BIT_FIELD (TREE_PURPOSE (elmt))\n+\t      && TREE_CODE (TREE_VALUE (elmt)) != INTEGER_CST))\n+\tallconstant = 0;\n+\n+      if (TREE_SIDE_EFFECTS (TREE_VALUE (elmt)))\n+\tside_effects = 1;\n+\n+      /* Propagate an NULL_EXPR from the size of the type.  We won't ever\n+\t be executing the code we generate here in that case, but handle it\n+\t specially to avoid the cmpiler blowing up.  */\n+      if (TREE_CODE (type) == RECORD_TYPE\n+\t  && (0 != (result\n+\t\t    = contains_null_expr (DECL_SIZE (TREE_PURPOSE (elmt))))))\n+\treturn build1 (NULL_EXPR, type, TREE_OPERAND (result, 0));\n+    }\n+\n+  /* If TYPE is a RECORD_TYPE and the fields are not in the\n+     same order as their bit position, don't treat this as constant\n+     since varasm.c can't handle it.  */\n+  if (allconstant && TREE_CODE (type) == RECORD_TYPE)\n+    {\n+      tree last_pos = bitsize_zero_node;\n+      tree field;\n+\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t{\n+\t  tree this_pos = bit_position (field);\n+\n+\t  if (TREE_CODE (this_pos) != INTEGER_CST\n+\t      || tree_int_cst_lt (this_pos, last_pos))\n+\t    {\n+\t      allconstant = 0;\n+\t      break;\n+\t    }\n+\n+\t  last_pos = this_pos;\n+\t}\n+    }\n+\n+  result = build (CONSTRUCTOR, type, NULL_TREE, list);\n+  TREE_CONSTANT (result) = allconstant;\n+  TREE_STATIC (result) = allconstant;\n+  TREE_SIDE_EFFECTS (result) = side_effects;\n+  TREE_READONLY (result) = TREE_READONLY (type);\n+\n+  return result;\n+}\n+\f\n+/* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n+   an IDENTIFIER_NODE giving the name of the field, or FIELD, a FIELD_DECL,\n+   for the field.\n+\n+   We also handle the fact that we might have been passed a pointer to the\n+   actual record and know how to look for fields in variant parts.  */\n+\n+static tree\n+build_simple_component_ref (record_variable, component, field)\n+     tree record_variable;\n+     tree component;\n+     tree field;\n+{\n+  tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n+  tree ref;\n+\n+  if ((TREE_CODE (record_type) != RECORD_TYPE\n+       && TREE_CODE (record_type) != UNION_TYPE\n+       && TREE_CODE (record_type) != QUAL_UNION_TYPE)\n+      || TYPE_SIZE (record_type) == 0)\n+    gigi_abort (510);\n+\n+  /* Either COMPONENT or FIELD must be specified, but not both.  */\n+  if ((component != 0) == (field != 0))\n+    gigi_abort (511);\n+\n+  /* If no field was specified, look for a field with the specified name\n+     in the current record only.  */\n+  if (field == 0)\n+    for (field = TYPE_FIELDS (record_type); field;\n+\t field = TREE_CHAIN (field))\n+      if (DECL_NAME (field) == component)\n+\tbreak;\n+\n+  if (field == 0)\n+    return 0;\n+\n+  /* If this field is not in the specified record, see if we can find\n+     something in the record whose original field is the same as this one. */\n+  if (DECL_CONTEXT (field) != record_type)\n+    /* Check if there is a field with name COMPONENT in the record.  */\n+    {\n+      tree new_field;\n+\n+      /* First loop thru normal components.  */\n+\n+      for (new_field = TYPE_FIELDS (record_type); new_field != 0;\n+\t   new_field = TREE_CHAIN (new_field))\n+\tif (DECL_ORIGINAL_FIELD (new_field) == field\n+\t    || new_field == DECL_ORIGINAL_FIELD (field)\n+\t    || (DECL_ORIGINAL_FIELD (field) != 0\n+\t\t&& (DECL_ORIGINAL_FIELD (field)\n+\t\t    == DECL_ORIGINAL_FIELD (new_field))))\n+\t  break;\n+\n+      /* Next, loop thru DECL_INTERNAL_P components if we haven't found\n+         the component in the first search. Doing this search in 2 steps\n+         is required to avoiding hidden homonymous fields in the\n+         _Parent field.  */\n+\n+      if (new_field == 0)\n+\tfor (new_field = TYPE_FIELDS (record_type); new_field != 0;\n+\t     new_field = TREE_CHAIN (new_field))\n+\t  if (DECL_INTERNAL_P (new_field))\n+\t    {\n+\t      tree field_ref\n+\t\t= build_simple_component_ref (record_variable, \n+\t\t\t\t\t      NULL_TREE, new_field);\n+\t      ref = build_simple_component_ref (field_ref, NULL_TREE, field);\n+\n+\t      if (ref != 0)\n+\t\treturn ref;\n+\t    }\n+\n+      field = new_field;\n+    }\n+\n+  if (field == 0)\n+    return 0;\n+\n+  /* If the record variable is an UNCHECKED_CONVERT_EXPR from and to BLKmode\n+     types, convert it to a normal conversion since GCC can deal with any\n+     mis-alignment as part of the handling of compponent references.  */\n+  if (TREE_CODE (record_variable) == UNCHECKED_CONVERT_EXPR\n+      && TYPE_MODE (TREE_TYPE (record_variable)) == BLKmode\n+      && TYPE_MODE (TREE_TYPE (TREE_OPERAND (record_variable, 0))) == BLKmode)\n+    record_variable = build1 (CONVERT_EXPR, TREE_TYPE (record_variable),\n+\t\t\t      TREE_OPERAND (record_variable, 0));\n+\n+  /* It would be nice to call \"fold\" here, but that can lose a type\n+     we need to tag a PLACEHOLDER_EXPR with, so we can't do it.  */\n+  ref = build (COMPONENT_REF, TREE_TYPE (field), record_variable, field);\n+\n+  if (TREE_READONLY (record_variable) || TREE_READONLY (field))\n+    TREE_READONLY (ref) = 1;\n+  if (TREE_THIS_VOLATILE (record_variable) || TREE_THIS_VOLATILE (field)\n+      || TYPE_VOLATILE (record_type))\n+    TREE_THIS_VOLATILE (ref) = 1;\n+\n+  return ref;\n+}\n+\f\n+/* Like build_simple_component_ref, except that we give an error if the\n+   reference could not be found.  */\n+\n+tree\n+build_component_ref (record_variable, component, field)\n+     tree record_variable;\n+     tree component;\n+     tree field;\n+{\n+  tree ref = build_simple_component_ref (record_variable, component, field);\n+\n+  if (ref != 0)\n+    return ref;\n+\n+  /* If FIELD was specified, assume this is an invalid user field so\n+     raise constraint error.  Otherwise, we can't find the type to return, so\n+     abort.  */\n+\n+  else if (field != 0)\n+    return build1 (NULL_EXPR, TREE_TYPE (field),\n+\t\t   build_call_raise (raise_constraint_error_decl));\n+  else\n+    gigi_abort (512);\n+}\n+\f\n+/* Build a GCC tree to call an allocation or deallocation function.\n+   If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n+   generate an allocator.\n+\n+   GNU_SIZE is the size of the object in bytes and ALIGN is the alignment in\n+   bits.  GNAT_PROC, if present, is a procedure to call and GNAT_POOL is the\n+   storage pool to use.  If not preset, malloc and free will be used except\n+   if GNAT_PROC is the \"fake\" value of -1, in which case we allocate the\n+   object dynamically on the stack frame.  */\n+\n+tree\n+build_call_alloc_dealloc (gnu_obj, gnu_size, align, gnat_proc, gnat_pool)\n+     tree gnu_obj;\n+     tree gnu_size;\n+     int align;\n+     Entity_Id gnat_proc;\n+     Entity_Id gnat_pool;\n+{\n+  tree gnu_align = size_int (align / BITS_PER_UNIT);\n+\n+  if (TREE_CODE (gnu_size) != INTEGER_CST && contains_placeholder_p (gnu_size))\n+    gnu_size = build (WITH_RECORD_EXPR, sizetype, gnu_size,\n+\t\t      build_unary_op (INDIRECT_REF, NULL_TREE, gnu_obj));\n+\n+  if (Present (gnat_proc))\n+    {\n+      /* The storage pools are obviously always tagged types, but the \n+\t secondary stack uses the same mechanism and is not tagged */\n+      if (Is_Tagged_Type (Etype (gnat_pool)))\n+\t{\n+\t  /* The size is the third parameter; the alignment is the\n+             same type.  */\n+\t  Entity_Id gnat_size_type\n+\t    = Etype (Next_Formal (Next_Formal (First_Formal (gnat_proc))));\n+\t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n+\t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n+\t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n+\t  tree gnu_pool = gnat_to_gnu (gnat_pool);\n+\t  tree gnu_pool_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_pool);\n+\t  tree gnu_args = NULL_TREE;\n+\t  tree gnu_call;\n+\n+\t  /* The first arg is always the address of the storage pool; next\n+\t     comes the address of the object, for a deallocator, then the\n+\t     size and alignment.  */\n+\t  gnu_args\n+\t    = chainon (gnu_args, build_tree_list (NULL_TREE, gnu_pool_addr));\n+\n+\t  if (gnu_obj)\n+\t    gnu_args\n+\t      = chainon (gnu_args, build_tree_list (NULL_TREE, gnu_obj));\n+\n+\t  gnu_args\n+\t    = chainon (gnu_args,\n+\t\t       build_tree_list (NULL_TREE,\n+\t\t\t\t\tconvert (gnu_size_type, gnu_size)));\n+\t  gnu_args\n+\t    = chainon (gnu_args,\n+\t\t       build_tree_list (NULL_TREE, \n+\t\t\t\t\tconvert (gnu_size_type, gnu_align)));\n+\n+\t  gnu_call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t    gnu_proc_addr, gnu_args, NULL_TREE);\n+\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n+\t  return gnu_call;\n+\t}\n+\n+      /* Secondary stack case.  */\n+      else\n+\t{\n+\t  /* The size is the second parameter */\n+\t  Entity_Id gnat_size_type \n+\t    = Etype (Next_Formal (First_Formal (gnat_proc)));\n+\t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n+\t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n+\t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n+\t  tree gnu_args = NULL_TREE;\n+\t  tree gnu_call;\n+\n+\t  /* The first arg is the address of the object, for a\n+\t     deallocator, then the size */\n+\t  if (gnu_obj)\n+\t    gnu_args\n+\t      = chainon (gnu_args, build_tree_list (NULL_TREE, gnu_obj));\n+\n+\t  gnu_args\n+\t    = chainon (gnu_args,\n+\t\t       build_tree_list (NULL_TREE,\n+\t\t\t\t\tconvert (gnu_size_type, gnu_size)));\n+\n+\t  gnu_call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t    gnu_proc_addr, gnu_args, NULL_TREE);\n+\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n+\t  return gnu_call;\n+\t}\n+    }\n+\n+  else if (gnu_obj)\n+    return build_call_1_expr (free_decl, gnu_obj);\n+  else if (gnat_pool == -1)\n+    {\n+      /* If the size is a constant, we can put it in the fixed portion of\n+\t the stack frame to avoid the need to adjust the stack pointer.  */\n+      if (TREE_CODE (gnu_size) == INTEGER_CST && ! flag_stack_check)\n+\t{\n+\t  tree gnu_range\n+\t    = build_range_type (NULL_TREE, size_one_node, gnu_size);\n+\t  tree gnu_array_type = build_array_type (char_type_node, gnu_range);\n+\t  tree gnu_decl =\n+\t    create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n+\t\t\t     gnu_array_type, NULL_TREE, 0, 0, 0, 0, 0);\n+\n+\t  return convert (ptr_void_type_node,\n+\t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n+\t}\n+      else\n+\treturn build (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n+    }\n+  else\n+    return build_call_1_expr (malloc_decl, gnu_size);\n+}\n+\f\n+/* Build a GCC tree to correspond to allocating an object of TYPE whose\n+   initial value is INIT, if INIT is nonzero.  Convert the expression to\n+   RESULT_TYPE, which must be some type of pointer.  Return the tree.\n+   GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n+   the storage pool to use.  */\n+\n+tree\n+build_allocator (type, init, result_type, gnat_proc, gnat_pool)\n+     tree type;\n+     tree init;\n+     tree result_type;\n+     Entity_Id gnat_proc;\n+     Entity_Id gnat_pool;\n+{\n+  tree size = TYPE_SIZE_UNIT (type);\n+  tree result;\n+\n+  /* If the initializer, if present, is a NULL_EXPR, just return a new one.  */\n+  if (init != 0 && TREE_CODE (init) == NULL_EXPR)\n+    return build1 (NULL_EXPR, result_type, TREE_OPERAND (init, 0));\n+\n+  /* If RESULT_TYPE is a fat or thin pointer, set SIZE to be the sum of the\n+     sizes of the object and its template.  Allocate the whole thing and\n+     fill in the parts that are known.  */\n+  else if (TYPE_FAT_OR_THIN_POINTER_P (result_type))\n+    {\n+      tree template_type\n+\t= (TYPE_FAT_POINTER_P (result_type)\n+\t   ? TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (result_type))))\n+\t   : TREE_TYPE (TYPE_FIELDS (TREE_TYPE (result_type))));\n+      tree storage_type\n+\t= build_unc_object_type (template_type, type,\n+\t\t\t\t get_identifier (\"ALLOC\"));\n+      tree storage_ptr_type = build_pointer_type (storage_type);\n+      tree storage;\n+      tree template_cons = NULL_TREE;\n+\n+      size = TYPE_SIZE_UNIT (storage_type);\n+\n+      if (TREE_CODE (size) != INTEGER_CST\n+\t  && contains_placeholder_p (size))\n+\tsize = build (WITH_RECORD_EXPR, sizetype, size, init);\n+\n+      storage = build_call_alloc_dealloc (NULL_TREE, size,\n+\t\t\t\t\t  TYPE_ALIGN (storage_type),\n+\t\t\t\t\t  gnat_proc, gnat_pool);\n+      storage = convert (storage_ptr_type, make_save_expr (storage));\n+\n+      if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+\t{\n+\t  type = TREE_TYPE (TYPE_FIELDS (type));\n+\n+\t  if (init != 0)\n+\t    init = convert (type, init);\n+\t}\n+\n+      /* If there is an initializing expression, make a constructor for\n+\t the entire object including the bounds and copy it into the\n+\t object.  If there is no initializing expression, just set the\n+\t bounds.  */\n+      if (init != 0)\n+\t{\n+\t  template_cons = tree_cons (TREE_CHAIN (TYPE_FIELDS (storage_type)),\n+\t\t\t\t     init, NULL_TREE);\n+\t  template_cons = tree_cons (TYPE_FIELDS (storage_type),\n+\t\t\t\t     build_template (template_type, type,\n+\t\t\t\t\t\t     init),\n+\t\t\t\t     template_cons);\n+\n+\t  return convert\n+\t    (result_type,\n+\t     build (COMPOUND_EXPR, storage_ptr_type,\n+\t\t    build_binary_op\n+\t\t    (MODIFY_EXPR, storage_type,\n+\t\t     build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t     convert (storage_ptr_type, storage)),\n+\t\t     build_constructor (storage_type, template_cons)),\n+\t\t    convert (storage_ptr_type, storage)));\n+\t}\n+      else\n+\treturn build\n+\t  (COMPOUND_EXPR, result_type,\n+\t   build_binary_op\n+\t   (MODIFY_EXPR, template_type,\n+\t    build_component_ref\n+\t    (build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t     convert (storage_ptr_type, storage)),\n+\t     NULL_TREE, TYPE_FIELDS (storage_type)),\n+\t    build_template (template_type, type, NULL_TREE)),\n+\t   convert (result_type, convert (storage_ptr_type, storage)));\n+    }\n+\n+  /* If we have an initializing expression, see if its size is simpler\n+     than the size from the type.  */\n+  if (init != 0 && TYPE_SIZE_UNIT (TREE_TYPE (init)) != 0\n+      && (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (init))) == INTEGER_CST\n+\t  || (TREE_CODE (size) != INTEGER_CST\n+\t      && contains_placeholder_p (size))))\n+    size = TYPE_SIZE_UNIT (TREE_TYPE (init));\n+\n+  /* If the size is still self-referential, reference the initializing\n+     expression, if it is present.  If not, this must have been a\n+     call to allocate a library-level object, in which case we use\n+     the maximum size.  */\n+  if (TREE_CODE (size) != INTEGER_CST && contains_placeholder_p (size))\n+    {\n+      if (init == 0)\n+\tsize = max_size (size, 1);\n+      else\n+\tsize = build (WITH_RECORD_EXPR, sizetype, size, init);\n+    }\n+\n+  /* If the size overflows, pass -1 so the allocator will raise\n+     storage error.  */\n+  if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n+    size = ssize_int (-1);\n+\n+  /* If this is a type whose alignment is larger than the\n+     biggest we support in normal alignment and this is in\n+     the default storage pool, make an \"aligning type\", allocate\n+     it, point to the field we need, and return that.  */\n+  if (TYPE_ALIGN (type) > BIGGEST_ALIGNMENT\n+      && No (gnat_proc))\n+    {\n+      tree new_type = make_aligning_type (type, TYPE_ALIGN (type), size);\n+\n+      result = build_call_alloc_dealloc (NULL_TREE, TYPE_SIZE (new_type),\n+\t\t\t\t\t BIGGEST_ALIGNMENT, Empty, Empty);\n+      result = save_expr (result);\n+      result = convert (build_pointer_type (new_type), result);\n+      result = build_unary_op (INDIRECT_REF, NULL_TREE, result);\n+      result = build_component_ref (result, NULL_TREE,\n+\t\t\t\t    TYPE_FIELDS (new_type));\n+      result = convert (result_type,\n+\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n+    }\n+  else\n+    result = convert (result_type,\n+\t\t      build_call_alloc_dealloc (NULL_TREE, size,\n+\t\t\t\t\t\tTYPE_ALIGN (type),\n+\t\t\t\t\t\tgnat_proc, gnat_pool));\n+\n+  /* If we have an initial value, put the new address into a SAVE_EXPR, assign\n+     the value, and return the address.  Do this with a COMPOUND_EXPR.  */\n+\n+  if (init)\n+    {\n+      result = save_expr (result);\n+      result\n+\t= build (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t build_binary_op\n+\t\t (MODIFY_EXPR, TREE_TYPE (TREE_TYPE (result)),\n+\t\t  build_unary_op (INDIRECT_REF, TREE_TYPE (TREE_TYPE (result)),\n+\t\t\t\t  result),\n+\t\t  init),\n+\t\t result);\n+    }\n+\n+  return convert (result_type, result);\n+}\n+\f\n+/* Fill in a VMS descriptor for EXPR and return a constructor for it. \n+   GNAT_FORMAL is how we find the descriptor record.  */\n+\n+tree\n+fill_vms_descriptor (expr, gnat_formal)\n+     tree expr;\n+     Entity_Id gnat_formal;\n+{\n+  tree record_type = TREE_TYPE (TREE_TYPE (get_gnu_tree (gnat_formal)));\n+  tree field;\n+  tree const_list = 0;\n+\n+  expr = maybe_unconstrained_array (expr);\n+  mark_addressable (expr);\n+\n+  for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n+    {\n+      tree init = DECL_INITIAL (field);\n+\n+      if (TREE_CODE (init) != INTEGER_CST\n+\t  && contains_placeholder_p (init))\n+\tinit = build (WITH_RECORD_EXPR, TREE_TYPE (init), init, expr);\n+\n+      const_list = tree_cons (field, convert (TREE_TYPE (field), init),\n+\t\t\t      const_list);\n+    }\n+\n+  return build_constructor (record_type, nreverse (const_list));\n+}\n+\n+/* Indicate that we need to make the address of EXPR_NODE and it therefore\n+   should not be allocated in a register. Return 1 if successful.  */\n+\n+int\n+mark_addressable (expr_node)\n+     tree expr_node;\n+{\n+  while (1)\n+    switch (TREE_CODE (expr_node))\n+      {\n+      case ADDR_EXPR:\n+      case COMPONENT_REF:\n+      case ARRAY_REF:\n+      case ARRAY_RANGE_REF:\n+      case REALPART_EXPR:\n+      case IMAGPART_EXPR:\n+      case NOP_EXPR:\n+\texpr_node = TREE_OPERAND (expr_node, 0);\n+\tbreak;\n+\n+      case CONSTRUCTOR:\n+\tTREE_ADDRESSABLE (expr_node) = 1;\n+\treturn 1;\n+\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case RESULT_DECL:\n+\tput_var_into_stack (expr_node);\n+\tTREE_ADDRESSABLE (expr_node) = 1;\n+\treturn 1;\n+\n+      case FUNCTION_DECL:\n+\tTREE_ADDRESSABLE (expr_node) = 1;\n+\treturn 1;\n+\n+      case CONST_DECL:\n+\treturn (DECL_CONST_CORRESPONDING_VAR (expr_node) != 0\n+\t\t&& (mark_addressable\n+\t\t    (DECL_CONST_CORRESPONDING_VAR (expr_node))));\n+      default:\n+\treturn 1;\n+    }\n+}"}, {"sha": "923c913ea4d89ccb75de576127a2ffc9fc91d301", "filename": "gcc/ada/validsw.adb", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fvalidsw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fvalidsw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvalidsw.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,222 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              V A L I D S W                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Opt; use Opt;\n+\n+package body Validsw is\n+\n+   ----------------------------------\n+   -- Reset_Validity_Check_Options --\n+   ----------------------------------\n+\n+   procedure Reset_Validity_Check_Options is\n+   begin\n+      Validity_Check_Copies         := False;\n+      Validity_Check_Default        := True;\n+      Validity_Check_Floating_Point := False;\n+      Validity_Check_In_Out_Params  := False;\n+      Validity_Check_In_Params      := False;\n+      Validity_Check_Operands       := False;\n+      Validity_Check_Returns        := False;\n+      Validity_Check_Subscripts     := False;\n+      Validity_Check_Tests          := False;\n+   end Reset_Validity_Check_Options;\n+\n+   ---------------------------------\n+   -- Save_Validity_Check_Options --\n+   ---------------------------------\n+\n+   procedure Save_Validity_Check_Options\n+     (Options : out Validity_Check_Options)\n+   is\n+      P : Natural := 0;\n+\n+      procedure Add (C : Character; S : Boolean);\n+      --  Add given character C to string if switch S is true\n+\n+      procedure Add (C : Character; S : Boolean) is\n+      begin\n+         if S then\n+            P := P + 1;\n+            Options (P) := C;\n+         end if;\n+      end Add;\n+\n+   --  Start of processing for Save_Validity_Check_Options\n+\n+   begin\n+      for K in Options'Range loop\n+         Options (K) := ' ';\n+      end loop;\n+\n+      Add ('c', Validity_Check_Copies);\n+      Add ('d', Validity_Check_Default);\n+      Add ('f', Validity_Check_Floating_Point);\n+      Add ('i', Validity_Check_In_Params);\n+      Add ('m', Validity_Check_In_Out_Params);\n+      Add ('o', Validity_Check_Operands);\n+      Add ('r', Validity_Check_Returns);\n+      Add ('s', Validity_Check_Subscripts);\n+      Add ('t', Validity_Check_Tests);\n+   end Save_Validity_Check_Options;\n+\n+   ----------------------------------------\n+   -- Set_Default_Validity_Check_Options --\n+   ----------------------------------------\n+\n+   procedure Set_Default_Validity_Check_Options is\n+   begin\n+      Reset_Validity_Check_Options;\n+      Set_Validity_Check_Options (\"d\");\n+   end Set_Default_Validity_Check_Options;\n+\n+   --------------------------------\n+   -- Set_Validity_Check_Options --\n+   --------------------------------\n+\n+   --  Version used when no error checking is required\n+\n+   procedure Set_Validity_Check_Options (Options : String) is\n+      OK : Boolean;\n+      EC : Natural;\n+\n+   begin\n+      Set_Validity_Check_Options (Options, OK, EC);\n+   end Set_Validity_Check_Options;\n+\n+   --  Normal version with error checking\n+\n+   procedure Set_Validity_Check_Options\n+     (Options  : String;\n+      OK       : out Boolean;\n+      Err_Col  : out Natural)\n+   is\n+      J : Natural;\n+      C : Character;\n+\n+   begin\n+      Reset_Validity_Check_Options;\n+\n+      J := Options'First;\n+      while J <= Options'Last loop\n+         C := Options (J);\n+         J := J + 1;\n+\n+         case C is\n+            when 'c' =>\n+               Validity_Check_Copies         := True;\n+\n+            when 'd' =>\n+               Validity_Check_Default        := True;\n+\n+            when 'f' =>\n+               Validity_Check_Floating_Point := True;\n+\n+            when 'i' =>\n+               Validity_Check_In_Params      := True;\n+\n+            when 'm' =>\n+               Validity_Check_In_Out_Params  := True;\n+\n+            when 'o' =>\n+               Validity_Check_Operands       := True;\n+\n+            when 'r' =>\n+               Validity_Check_Returns        := True;\n+\n+            when 's' =>\n+               Validity_Check_Subscripts     := True;\n+\n+            when 't' =>\n+               Validity_Check_Tests          := True;\n+\n+            when 'C' =>\n+               Validity_Check_Copies         := False;\n+\n+            when 'D' =>\n+               Validity_Check_Default        := False;\n+\n+            when 'I' =>\n+               Validity_Check_In_Params      := False;\n+\n+            when 'F' =>\n+               Validity_Check_Floating_Point := False;\n+\n+            when 'M' =>\n+               Validity_Check_In_Out_Params  := False;\n+\n+            when 'O' =>\n+               Validity_Check_Operands       := False;\n+\n+            when 'R' =>\n+               Validity_Check_Returns        := False;\n+\n+            when 'S' =>\n+               Validity_Check_Subscripts     := False;\n+\n+            when 'T' =>\n+               Validity_Check_Tests          := False;\n+\n+            when 'a' =>\n+               Validity_Check_Copies         := True;\n+               Validity_Check_Default        := True;\n+               Validity_Check_Floating_Point := True;\n+               Validity_Check_In_Out_Params  := True;\n+               Validity_Check_In_Params      := True;\n+               Validity_Check_Operands       := True;\n+               Validity_Check_Returns        := True;\n+               Validity_Check_Subscripts     := True;\n+               Validity_Check_Tests          := True;\n+\n+            when 'n' =>\n+               Validity_Check_Copies         := False;\n+               Validity_Check_Default        := False;\n+               Validity_Check_Floating_Point := False;\n+               Validity_Check_In_Out_Params  := False;\n+               Validity_Check_In_Params      := False;\n+               Validity_Check_Operands       := False;\n+               Validity_Check_Returns        := False;\n+               Validity_Check_Subscripts     := False;\n+               Validity_Check_Tests          := False;\n+\n+            when ' ' =>\n+               null;\n+\n+            when others =>\n+               OK      := False;\n+               Err_Col := J - 1;\n+               return;\n+         end case;\n+      end loop;\n+\n+      Validity_Checks_On := True;\n+      OK := True;\n+      Err_Col := Options'Last + 1;\n+   end Set_Validity_Check_Options;\n+\n+end Validsw;"}, {"sha": "881fca4fd88c17f1ea0108b9b2be3ddbd36edee8", "filename": "gcc/ada/validsw.ads", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fvalidsw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fvalidsw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvalidsw.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,146 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              V A L I D S W                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.1 $\n+--                                                                          --\n+--             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit contains the routines used to handle setting of validity\n+--  checking options.\n+\n+package Validsw is\n+\n+   -----------------------------\n+   -- Validity Check Switches --\n+   -----------------------------\n+\n+   --  The following flags determine the specific set of validity checks\n+   --  to be made if validity checking is active (Validity_Checks_On = True)\n+\n+   --  See GNAT users guide for an exact description of each option. The letter\n+   --  given in the comment is the letter used in the -gnatV compiler switch\n+   --  or in the argument of a Validity_Checks pragma to activate the option.\n+   --  The corresponding upper case letter deactivates the option.\n+\n+   Validity_Check_Copies : Boolean := False;\n+   --  Controls the validity checking of copies. If this switch is set to\n+   --  true using -gnatVc, or a 'c' in the argument of a Validity_Checks\n+   --  pragma, then the right side of assignments and also initializing\n+   --  expressions in object declarations are checked for validity.\n+\n+   Validity_Check_Default : Boolean := True;\n+   --  Controls default (reference manual) validity checking. If this switch\n+   --  is set to True using -gnatVd or a 'd' in the argument of a Validity_\n+   --  Checks pragma then left side subscripts and case statement arguments\n+   --  are checked for validity. This switch is also set by default if no\n+   --  -gnatV switch is used and no Validity_Checks pragma is processed.\n+\n+   Validity_Check_Floating_Point : Boolean := False;\n+   --  Normally validity checking applies only to discrete values (integer\n+   --  and enumeration types). If this switch is set to True using -gnatVf\n+   --  or an 'f' in the argument of a Validity_Checks pragma, then floating-\n+   --  point values are also checked. The context in which such checks\n+   --  occur depends on other flags, e.g. if Validity_Check_Copies is also\n+   --  set then floating-point values on the right side of an assignment\n+   --  will be validity checked.\n+\n+   Validity_Check_In_Out_Params : Boolean := False;\n+   --  Controls the validity checking of IN OUT parameters. If this switch\n+   --  is set to True using -gnatVm or a 'm' in the argument of a pragma\n+   --  Validity_Checks, then the initial value of all IN OUT parameters\n+   --  will be checked at the point of call of a procecure. Note that the\n+   --  character 'm' here stands for modified (parameters).\n+\n+   Validity_Check_In_Params : Boolean := False;\n+   --  Controls the validity checking of IN parameters. If this switch is\n+   --  set to True using -gnatVm or an 'i' in the argument of a pragma\n+   --  Validity_Checks, then the initial value of all IN parameters\n+   --  will be checked at the point of call of a procecure or function.\n+\n+   Validity_Check_Operands : Boolean := False;\n+   --  Controls validity checking of operands. If this switch is set to\n+   --  True using -gnatVo or an 'o' in the argument of a Validity_Checks\n+   --  pragma, then operands of all predefined operators and attributes\n+   --  will be validity checked.\n+\n+   Validity_Check_Returns : Boolean := False;\n+   --  Controls validity checking of returned values. If this switch is set\n+   --  to True using -gnatVr, or an 'r' in the argument of a Validity_Checks\n+   --  pragma, then the expression in a RETURN statement is validity checked.\n+\n+   Validity_Check_Subscripts : Boolean := False;\n+   --  Controls validity checking of subscripts. If this switch is set to\n+   --  True using -gnatVs, or an 's' in the argument of a Validity_Checks\n+   --  pragma, then all subscripts are checked for validity. Note that left\n+   --  side subscript checking is controlled also by Validity_Check_Default.\n+   --  If Validity_Check_Subscripts is True, then all subscripts are checked,\n+   --  otherwise if Validity_Check_Default is True, then left side subscripts\n+   --  are checked, otherwise no subscripts are checked.\n+\n+   Validity_Check_Tests : Boolean := False;\n+   --  Controls validity checking of tests that occur in conditions (i.e. the\n+   --  tests in IF, WHILE, and EXIT statements, and in entry guards). If this\n+   --  switch is set to True using -gnatVt, or a 't' in the argument of a\n+   --  Validity_Checks pragma, then all such conditions are validity checked.\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Set_Default_Validity_Check_Options;\n+   --  This procedure is called to set the default validity checking options\n+   --  that apply if no Validity_Check switches or pragma is given.\n+\n+   procedure Set_Validity_Check_Options\n+     (Options  : String;\n+      OK       : out Boolean;\n+      Err_Col  : out Natural);\n+   --  This procedure is called to set the validity check options that\n+   --  correspond to the characters in the given Options string. If\n+   --  all options are valid, then Set_Default_Validity_Check_Options\n+   --  is first called to set the defaults, and then the options in the\n+   --  given string are set in an additive manner. If any invalid character\n+   --  is found, then OK is False on exit, and Err_Col is the index in\n+   --  in options of the bad character. If all options are valid, then\n+   --  OK is True on return, and Err_Col is set to options'Last + 1.\n+\n+   procedure Set_Validity_Check_Options (Options : String);\n+   --  Like the above procedure, except that the call is simply ignored if\n+   --  there are any error conditions, this is for example appopriate for\n+   --  calls where the string is known to be valid, e.g. because it was\n+   --  obtained by Save_Validity_Check_Options.\n+\n+   procedure Reset_Validity_Check_Options;\n+   --  Sets all validity check options to off\n+\n+   subtype Validity_Check_Options is String (1 .. 16);\n+   --  Long enough string to hold all options from Save call below\n+\n+   procedure Save_Validity_Check_Options\n+     (Options : out Validity_Check_Options);\n+   --  Sets Options to represent current selection of options. This\n+   --  set can be restored by first calling Reset_Validity_Check_Options,\n+   --  and then calling Set_Validity_Check_Options with the Options string.\n+\n+end Validsw;"}, {"sha": "39df6f7ba06bb032095baf742277dbb781151629", "filename": "gcc/ada/widechar.adb", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fwidechar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fwidechar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwidechar.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,163 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             W I D E C H A R                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.15 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Note: this package uses the generic subprograms in System.Wch_Cnv, which\n+--  completely encapsulate the set of wide character encoding methods, so no\n+--  modifications are required when adding new encoding methods.\n+\n+with Opt; use Opt;\n+\n+with System.WCh_Cnv; use System.WCh_Cnv;\n+with System.WCh_Con; use System.WCh_Con;\n+\n+package body Widechar is\n+\n+   ---------------------------\n+   -- Is_Start_Of_Wide_Char --\n+   ---------------------------\n+\n+   function Is_Start_Of_Wide_Char\n+     (S    : Source_Buffer_Ptr;\n+      P    : Source_Ptr)\n+      return Boolean\n+   is\n+   begin\n+      case Wide_Character_Encoding_Method is\n+         when WCEM_Hex =>\n+            return S (P) = ASCII.ESC;\n+\n+         when WCEM_Upper     |\n+              WCEM_Shift_JIS |\n+              WCEM_EUC       |\n+              WCEM_UTF8      =>\n+            return S (P) >= Character'Val (16#80#);\n+\n+         when WCEM_Brackets =>\n+            return P <= S'Last - 2\n+              and then S (P) = '['\n+              and then S (P + 1) = '\"'\n+              and then S (P + 2) /= '\"';\n+      end case;\n+   end Is_Start_Of_Wide_Char;\n+\n+   -----------------\n+   -- Length_Wide --\n+   -----------------\n+\n+   function Length_Wide return Nat is\n+   begin\n+      return WC_Longest_Sequence;\n+   end Length_Wide;\n+\n+   ---------------\n+   -- Scan_Wide --\n+   ---------------\n+\n+   procedure Scan_Wide\n+     (S   : Source_Buffer_Ptr;\n+      P   : in out Source_Ptr;\n+      C   : out Char_Code;\n+      Err : out Boolean)\n+   is\n+      function In_Char return Character;\n+      --  Function to obtain characters of wide character escape sequence\n+\n+      function In_Char return Character is\n+      begin\n+         P := P + 1;\n+         return S (P - 1);\n+      end In_Char;\n+\n+      function WC_In is new Char_Sequence_To_Wide_Char (In_Char);\n+\n+   begin\n+      C := Char_Code (Wide_Character'Pos\n+                       (WC_In (In_Char, Wide_Character_Encoding_Method)));\n+      Err := False;\n+\n+   exception\n+      when Constraint_Error =>\n+         C := Char_Code (0);\n+         P := P - 1;\n+         Err := True;\n+   end Scan_Wide;\n+\n+   --------------\n+   -- Set_Wide --\n+   --------------\n+\n+   procedure Set_Wide\n+     (C : Char_Code;\n+      S : in out String;\n+      P : in out Natural)\n+   is\n+      procedure Out_Char (C : Character);\n+      --  Procedure to store one character of wide character sequence\n+\n+      procedure Out_Char (C : Character) is\n+      begin\n+         P := P + 1;\n+         S (P) := C;\n+      end Out_Char;\n+\n+      procedure WC_Out is new Wide_Char_To_Char_Sequence (Out_Char);\n+\n+   begin\n+      WC_Out (Wide_Character'Val (C), Wide_Character_Encoding_Method);\n+   end Set_Wide;\n+\n+   ---------------\n+   -- Skip_Wide --\n+   ---------------\n+\n+   procedure Skip_Wide (S : String; P : in out Natural) is\n+      function Skip_Char return Character;\n+      --  Function to skip one character of wide character escape sequence\n+\n+      function Skip_Char return Character is\n+      begin\n+         P := P + 1;\n+         return S (P - 1);\n+      end Skip_Char;\n+\n+      function WC_Skip is new Char_Sequence_To_Wide_Char (Skip_Char);\n+\n+      Discard : Wide_Character;\n+\n+   begin\n+      Discard := WC_Skip (Skip_Char, Wide_Character_Encoding_Method);\n+   end Skip_Wide;\n+\n+end Widechar;"}, {"sha": "daf297e9542618d20a9141add836e3f12d793e11", "filename": "gcc/ada/widechar.ads", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fwidechar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fwidechar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwidechar.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,87 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             W I D E C H A R                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Subprograms for manipulation of wide character sequences\n+\n+with Types; use Types;\n+\n+package Widechar is\n+\n+   function Length_Wide return Nat;\n+   --  Returns the maximum length in characters for the escape sequence that\n+   --  is used to encode wide character literals outside the ASCII range. Used\n+   --  only in the implementation of the attribute Width for Wide_Character.\n+\n+   procedure Scan_Wide\n+     (S   : Source_Buffer_Ptr;\n+      P   : in out Source_Ptr;\n+      C   : out Char_Code;\n+      Err : out Boolean);\n+   --  On entry S (P) points to the first character in the source text for\n+   --  a wide character (i.e. to an ESC character, a left bracket, or an\n+   --  upper half character, depending on the representation method). A\n+   --  single wide character is scanned. If no error is found, the value\n+   --  stored in C is the code for this wide character, P is updated past\n+   --  the sequence and Err is set to False. If an error is found, then\n+   --  P points to the improper character, C is undefined, and Err is\n+   --  set to True.\n+\n+   procedure Set_Wide\n+     (C : Char_Code;\n+      S : in out String;\n+      P : in out Natural);\n+   --  The escape sequence (including any leading ESC character) for the\n+   --  given character code is stored starting at S (P + 1), and on return\n+   --  P points to the last stored character (i.e. P is the count of stored\n+   --  characters on entry and exit, and the escape sequence is appended to\n+   --  the end of the stored string). The character code C represents a code\n+   --  originally constructed by Scan_Wide, so it is known to be in a range\n+   --  that is appropriate for the encoding method in use.\n+\n+   procedure Skip_Wide (S : String; P : in out Natural);\n+   --  On entry, S (P) points to an ESC character for a wide character escape\n+   --  sequence or to an upper half character if the encoding method uses the\n+   --  upper bit, or to a left bracket if the brackets encoding method is in\n+   --  use. On exit, P is bumped past the wide character sequence. No error\n+   --  checking is done, since this is only used on escape sequences generated\n+   --  by Set_Wide, which are known to be correct.\n+\n+   function Is_Start_Of_Wide_Char\n+     (S    : Source_Buffer_Ptr;\n+      P    : Source_Ptr)\n+      return Boolean;\n+   --  Determines if S (P) is the start of a wide character sequence\n+\n+end Widechar;"}, {"sha": "38c35ce03c56b659298516f3d13751f19233b926", "filename": "gcc/ada/xeinfo.adb", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxeinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxeinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxeinfo.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,539 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT SYSTEM UTILITIES                           --\n+--                                                                          --\n+--                               X E I N F O                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.29 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Program to construct C header file a-einfo.h (C version of einfo.ads spec)\n+--  for use by Gigi. This header file contaInF all definitions and access\n+--  functions, but does not contain set procedures, since Gigi is not allowed\n+--  to modify the GNAT tree)\n+\n+--    Input files:\n+\n+--       einfo.ads     spec of Einfo package\n+--       einfo.adb     body of Einfo package\n+\n+--    Output files:\n+\n+--       a-einfo.h     Corresponding c header file\n+\n+--  Note: It is assumed that the input files have been compiled without errors\n+\n+--  An optional argument allows the specification of an output file name to\n+--  override the default a-einfo.h file name for the generated output file.\n+\n+--  Most, but not all of the functions in Einfo can be inlined in the C header.\n+--  They are the functions identified by pragma Inline in the spec. Functions\n+--  that cannot be inlined are simply defined in the header.\n+\n+with Ada.Command_Line;              use Ada.Command_Line;\n+with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n+with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n+with Ada.Strings.Maps;              use Ada.Strings.Maps;\n+with Ada.Strings.Maps.Constants;    use Ada.Strings.Maps.Constants;\n+with Ada.Text_IO;                   use Ada.Text_IO;\n+\n+with GNAT.Spitbol;                  use GNAT.Spitbol;\n+with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n+with GNAT.Spitbol.Table_Boolean;    use GNAT.Spitbol.Table_Boolean;\n+\n+procedure XEinfo is\n+\n+   package TB renames GNAT.Spitbol.Table_Boolean;\n+\n+   Err : exception;\n+\n+   A         : VString := Nul;\n+   B         : VString := Nul;\n+   C         : VString := Nul;\n+   Einfobrev : VString := Nul;\n+   Einfosrev : VString := Nul;\n+   Expr      : VString := Nul;\n+   Filler    : VString := Nul;\n+   Fline     : VString := Nul;\n+   Formal    : VString := Nul;\n+   Formaltyp : VString := Nul;\n+   FN        : VString := Nul;\n+   Line      : VString := Nul;\n+   N         : VString := Nul;\n+   N1        : VString := Nul;\n+   N2        : VString := Nul;\n+   N3        : VString := Nul;\n+   Nam       : VString := Nul;\n+   Name      : VString := Nul;\n+   NewS      : VString := Nul;\n+   Nextlin   : VString := Nul;\n+   OldS      : VString := Nul;\n+   Rtn       : VString := Nul;\n+   Term      : VString := Nul;\n+   XEinforev : VString := Nul;\n+\n+   InB : File_Type;\n+   --  Used to read initial header from body\n+\n+   InF   : File_Type;\n+   --  Used to read full text of both spec and body\n+\n+   Ofile : File_Type;\n+   --  Used to write output file\n+\n+   wsp      : Pattern := NSpan (' ' & ASCII.HT);\n+   Get_BRev : Pattern := BreakX ('$') & \"$Rev\" & \"ision: \"\n+                           & Break (' ') * Einfobrev;\n+   Get_SRev : Pattern := BreakX ('$') & \"$Rev\" & \"ision: \"\n+                           & Break (' ') * Einfosrev;\n+   Comment  : Pattern := wsp & \"--\";\n+   For_Rep  : Pattern := wsp & \"for\";\n+   Get_Func : Pattern := wsp * A & \"function\" & wsp & Break (' ') * Name;\n+   Inline   : Pattern := wsp & \"pragma Inline (\" & Break (')') * Name;\n+   Get_Pack : Pattern := wsp & \"package \";\n+   Get_Enam : Pattern := wsp & Break (',') * N & ',';\n+   Find_Fun : Pattern := wsp & \"function\";\n+   F_Subtyp : Pattern := wsp * A & \"subtype \" & Break (' ') * N;\n+   G_Subtyp : Pattern := wsp & \"subtype\" & wsp & Break (' ') * NewS\n+                           & wsp & \"is\" & wsp & Break (\" ;\") * OldS\n+                           & wsp & ';' & wsp & Rtab (0);\n+   F_Typ    : Pattern := wsp * A & \"type \" & Break (' ') * N & \" is (\";\n+   Get_Nam  : Pattern := wsp * A & Break (\",)\") * Nam & Len (1) * Term;\n+   Get_Styp : Pattern := wsp * A & \"subtype \" & Break (' ') * N;\n+   Get_N1   : Pattern := wsp & Break (' ') * N1;\n+   Get_N2   : Pattern := wsp & \"-- \" & Rest * N2;\n+   Get_N3   : Pattern := wsp & Break (';') * N3;\n+   Get_FN   : Pattern := wsp * C & \"function\" & wsp & Break (\" (\") * FN;\n+   Is_Rturn : Pattern := BreakX ('r') & \"return\";\n+   Is_Begin : Pattern := wsp & \"begin\";\n+   Get_Asrt : Pattern := wsp & \"pragma Assert\";\n+   Semicoln : Pattern := BreakX (';');\n+   Get_Cmnt : Pattern := BreakX ('-') * A & \"--\";\n+   Get_Expr : Pattern := wsp & \"return \" & Break (';') * Expr;\n+   Chek_End : Pattern := wsp & \"end\" & BreakX (';') & ';';\n+   Get_B1   : Pattern := BreakX (' ') * A & \" in \" & Rest * B;\n+   Get_B2   : Pattern := BreakX (' ') * A & \" = \" & Rest * B;\n+   Get_B3   : Pattern := BreakX (' ') * A & \" /= \" & Rest * B;\n+   To_Paren : Pattern := wsp * Filler & '(';\n+   Get_Fml  : Pattern := Break (\" :\") * Formal & wsp & ':' & wsp\n+                           & BreakX (\" );\") * Formaltyp;\n+   Nxt_Fml  : Pattern := wsp & \"; \";\n+   Get_Rtn  : Pattern := wsp & \"return\" & wsp & BreakX (\" ;\") * Rtn;\n+   Rem_Prn  : Pattern := wsp & ')';\n+\n+   M : Match_Result;\n+\n+   Lineno : Natural := 0;\n+   --  Line number in spec\n+\n+   V   : Natural;\n+   Ctr : Natural;\n+\n+   Inlined : TB.Table (200);\n+   --  Inlined<N> = True for inlined function, False otherwise\n+\n+   Lastinlined : Boolean;\n+\n+   procedure Badfunc;\n+   --  Signal bad function in body\n+\n+   function Getlin return VString;\n+   --  Get non-comment line (comment lines skipped, also skips FOR rep clauses)\n+   --  Fatal error (raises End_Error exception) if end of file encountered\n+\n+   procedure Must (B : Boolean);\n+   --  Raises Err if the argument (a Match) call, returns False\n+\n+   procedure Sethead (Line : in out VString; Term : String);\n+   --  Process function header into C\n+\n+   -------------\n+   -- Badfunc --\n+   -------------\n+\n+   procedure Badfunc is\n+   begin\n+      Put_Line\n+        (Standard_Error,\n+         \"Body for function \" & FN & \" does not meet requirements\");\n+      raise Err;\n+   end Badfunc;\n+\n+   -------------\n+   -- Getlin --\n+   -------------\n+\n+   function Getlin return VString is\n+      Lin : VString;\n+\n+   begin\n+      loop\n+         Lin := Get_Line (InF);\n+         Lineno := Lineno + 1;\n+\n+         if Lin /= \"\"\n+           and then not Match (Lin, Comment)\n+           and then not Match (Lin, For_Rep)\n+         then\n+            return Lin;\n+         end if;\n+      end loop;\n+   end Getlin;\n+\n+   ----------\n+   -- Must --\n+   ----------\n+\n+   procedure Must (B : Boolean) is\n+   begin\n+      if not B then\n+         raise Err;\n+      end if;\n+   end Must;\n+\n+   -------------\n+   -- Sethead --\n+   -------------\n+\n+   procedure Sethead (Line : in out VString; Term : String) is\n+      Args : VString;\n+\n+   begin\n+      Must (Match (Line, Get_Func, \"\"));\n+      Args := Nul;\n+\n+      if Match (Line, To_Paren, \"\") then\n+         Args := Filler & '(';\n+\n+         loop\n+            Must (Match (Line, Get_Fml, \"\"));\n+            Append (Args, Formaltyp & ' ' & Formal);\n+            exit when not Match (Line, Nxt_Fml);\n+            Append (Args, \",\");\n+         end loop;\n+\n+         Match (Line, Rem_Prn, \"\");\n+         Append (Args, ')');\n+      end if;\n+\n+      Must (Match (Line, Get_Rtn));\n+\n+      if Present (Inlined, Name) then\n+         Put_Line (Ofile, A & \"INLINE \" & Rtn & ' ' & Name & Args & Term);\n+      else\n+         Put_Line (Ofile, A &  Rtn & ' ' & Name & Args & Term);\n+      end if;\n+   end Sethead;\n+\n+--  Start of processing for XEinfo\n+\n+begin\n+   Anchored_Mode := True;\n+\n+   Match (\"$Revision: 1.29 $\", \"$Rev\" & \"ision: \" & Break (' ') * XEinforev);\n+\n+   if Argument_Count > 0 then\n+      Create (Ofile, Out_File, Argument (1));\n+   else\n+      Create (Ofile, Out_File, \"a-einfo.h\");\n+   end if;\n+\n+   Open (InB, In_File, \"einfo.adb\");\n+   Open (InF, In_File, \"einfo.ads\");\n+\n+   Lineno := 0;\n+\n+   --  Get einfo revs and write header to output file\n+\n+   loop\n+      Line := Get_Line (InB);\n+\n+      if Line = \"\" then\n+         raise Err;\n+      end if;\n+\n+      exit when Match (Line, Get_BRev);\n+   end loop;\n+\n+   loop\n+      Line := Get_Line (InF);\n+      Lineno := Lineno + 1;\n+      exit when Line = \"\";\n+\n+      if Match (Line, Get_SRev) then\n+         Put_Line\n+           (Ofile,\n+            \"/*                 Generated by xeinfo revision \" & XEinforev &\n+            \" using                  */\");\n+         Put_Line\n+           (Ofile,\n+            \"/*                         einfo.ads revision \" & Einfosrev &\n+            \"                         */\");\n+         Put_Line\n+           (Ofile,\n+            \"/*                         einfo.adb revision \" & Einfobrev &\n+            \"                         */\");\n+      else\n+         Match (Line,\n+                \"--                                 S p e c       \",\n+                \"--                              C Header File    \");\n+\n+         Match (Line, \"--\", \"/*\");\n+         Match (Line, Rtab (2) * A & \"--\", M);\n+         Replace (M, A & \"*/\");\n+         Put_Line (Ofile, Line);\n+      end if;\n+   end loop;\n+\n+   Put_Line (Ofile, \"\");\n+\n+   --  Find and record pragma Inlines\n+\n+   loop\n+      Line := Get_Line (InF);\n+      exit when Match (Line, \"   --  END XEINFO INLINES\");\n+\n+\n+      if Match (Line, Inline) then\n+         Set (Inlined, Name, True);\n+      end if;\n+   end loop;\n+\n+   --  Skip to package line\n+\n+   Reset (InF, In_File);\n+   Lineno := 0;\n+\n+   loop\n+      Line := Getlin;\n+      exit when Match (Line, Get_Pack);\n+   end loop;\n+\n+   V := 0;\n+   Line := Getlin;\n+   Must (Match (Line, wsp & \"type Entity_Kind\"));\n+\n+   --  Process entity kind code definitions\n+\n+   loop\n+      Line := Getlin;\n+      exit when not Match (Line, Get_Enam);\n+      Put_Line (Ofile, \"   #define \" & Rpad (N, 32) & \" \" & V);\n+      V := V + 1;\n+   end loop;\n+\n+   Must (Match (Line, wsp & Rest * N));\n+   Put_Line (Ofile, \"   #define \" & Rpad (N, 32) & ' ' & V);\n+   Line := Getlin;\n+\n+   Must (Match (Line, wsp & \");\"));\n+   Put_Line (Ofile, \"\");\n+\n+   --  Loop through subtype and type declarations\n+\n+   loop\n+      Line := Getlin;\n+      exit when Match (Line, Find_Fun);\n+\n+      --  Case of a subtype declaration\n+\n+      if Match (Line, F_Subtyp) then\n+\n+         --  Case of a subtype declaration that is an abbreviation of the\n+         --  form subtype x is y, and if so generate the appropriate typedef\n+\n+         if Match (Line, G_Subtyp) then\n+            Put_Line (Ofile, A & \"typedef \" & OldS & ' ' & NewS & ';');\n+\n+         --  Otherwise the subtype must be declaring a subrange of Entity_Id\n+\n+         else\n+            Must (Match (Line, Get_Styp));\n+            Line := Getlin;\n+            Must (Match (Line, Get_N1));\n+\n+            loop\n+               Line := Get_Line (InF);\n+               Lineno := Lineno + 1;\n+               exit when not Match (Line, Get_N2);\n+            end loop;\n+\n+            Must (Match (Line, Get_N3));\n+            Put_Line (Ofile, A & \"SUBTYPE (\" & N & \", Entity_Kind, \");\n+            Put_Line (Ofile, A & \"   \" & N1 & \", \" & N3 & ')');\n+            Put_Line (Ofile, \"\");\n+         end if;\n+\n+\n+      --  Case of type declaration\n+\n+      elsif Match (Line, F_Typ) then\n+         --  Process type declaration (must be enumeration type)\n+\n+         Ctr := 0;\n+         Put_Line (Ofile, A & \"typedef int \" & N & ';');\n+\n+         loop\n+            Line := Getlin;\n+            Must (Match (Line, Get_Nam));\n+            Put_Line (Ofile, A & \"#define \" & Rpad (Nam, 25) & Ctr);\n+            Ctr := Ctr + 1;\n+            exit when Term /= \",\";\n+         end loop;\n+\n+         Put_Line (Ofile, \"\");\n+\n+      --  Neither subtype nor type declaration\n+\n+      else\n+         raise Err;\n+      end if;\n+   end loop;\n+\n+   --  Process function declarations\n+   --  Note: Lastinlined used to control blank lines\n+\n+   Put_Line (Ofile, \"\");\n+   Lastinlined := True;\n+\n+   --  Loop through function declarations\n+\n+   while Match (Line, Get_FN) loop\n+\n+      --  Non-inlined funcion\n+\n+      if not Present (Inlined, FN) then\n+         Put_Line (Ofile, \"\");\n+         Put_Line\n+           (Ofile,\n+            \"   #define \" & FN & \" einfo__\" & Translate (FN, Lower_Case_Map));\n+\n+      --  Inlined function\n+\n+      else\n+         if not Lastinlined then\n+            Put_Line (Ofile, \"\");\n+         end if;\n+      end if;\n+\n+      --  Merge here to output spec\n+\n+      Sethead (Line, \";\");\n+      Lastinlined := Get (Inlined, FN);\n+      Line := Getlin;\n+   end loop;\n+\n+   Put_Line (Ofile, \"\");\n+\n+   --  Read body to find inlined functions\n+\n+   Close (InB);\n+   Close (InF);\n+   Open (InF, In_File, \"einfo.adb\");\n+   Lineno := 0;\n+\n+   --  Loop through input lines to find bodies of inlined functions\n+\n+   while not End_Of_File (InF) loop\n+      Fline := Get_Line (InF);\n+\n+      if Match (Fline, Get_FN)\n+        and then Get (Inlined, FN)\n+      then\n+         --  Here we have an inlined function\n+\n+         if not Match (Fline, Is_Rturn) then\n+            Line := Fline;\n+            Badfunc;\n+         end if;\n+\n+         Line := Getlin;\n+\n+         if not Match (Line, Is_Begin) then\n+            Badfunc;\n+         end if;\n+\n+         --  Skip past pragma Asserts\n+\n+         loop\n+            Line := Getlin;\n+            exit when not Match (Line, Get_Asrt);\n+\n+            --  Pragma asser found, get its continuation lines\n+\n+            loop\n+               exit when Match (Line, Semicoln);\n+               Line := Getlin;\n+            end loop;\n+         end loop;\n+\n+         --  Process return statement\n+\n+         Match (Line, Get_Cmnt, M);\n+         Replace (M, A);\n+\n+         --  Get continuations of return statemnt\n+\n+         while not Match (Line, Semicoln) loop\n+            Nextlin := Getlin;\n+            Match (Nextlin, wsp, \" \");\n+            Append (Line, Nextlin);\n+         end loop;\n+\n+         if not Match (Line, Get_Expr) then\n+            Badfunc;\n+         end if;\n+\n+         Line := Getlin;\n+\n+         if not Match (Line, Chek_End) then\n+            Badfunc;\n+         end if;\n+\n+         Match (Expr, Get_B1, M);\n+         Replace (M, \"IN (\" & A & \", \" & B & ')');\n+         Match (Expr, Get_B2, M);\n+         Replace (M, A & \" == \" & B);\n+         Match (Expr, Get_B3, M);\n+         Replace (M, A & \" != \" & B);\n+         Put_Line (Ofile, \"\");\n+         Sethead (Fline, \"\");\n+         Put_Line (Ofile, C & \"   { return \" & Expr & \"; }\");\n+      end if;\n+   end loop;\n+\n+   Put_Line (Ofile, \"\");\n+   Put_Line\n+     (Ofile,\n+      \"/* End of einfo.h (C version of Einfo package specification) */\");\n+\n+exception\n+   when Err =>\n+      Put_Line (Standard_Error, Lineno & \".  \" & Line);\n+      Put_Line (Standard_Error, \"**** fatal error ****\");\n+      Set_Exit_Status (1);\n+\n+   when End_Error =>\n+      Put_Line (Standard_Error, \"unexpected end of file\");\n+      Put_Line (Standard_Error, \"**** fatal error ****\");\n+\n+end XEinfo;"}, {"sha": "f87b8500b89eb2cd3f6ae89203773baf6f157392", "filename": "gcc/ada/xnmake.adb", "status": "added", "additions": 485, "deletions": 0, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxnmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxnmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxnmake.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548", "patch": "@@ -0,0 +1,485 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT SYSTEM UTILITIES                           --\n+--                                                                          --\n+--                               X N M A K E                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.27 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Program to construct the spec and body of the Nmake package\n+\n+--    Input files:\n+\n+--       sinfo.ads     Spec of Sinfo package\n+--       nmake.adt     Template for Nmake package\n+\n+--    Output files:\n+\n+--       nmake.ads     Spec of Nmake package\n+--       nmake.adb     Body of Nmake package\n+\n+--  Note: this program assumes that sinfo.ads has passed the error checks that\n+--  are carried out by the csinfo utility, so it does not duplicate these\n+--  checks and assumes that sinfo.ads has the correct form.\n+\n+--   In the absence of any switches, both the ads and adb files are output.\n+--   The switch -s or /s indicates that only the ads file is to be output.\n+--   The switch -b or /b indicates that only the adb file is to be output.\n+\n+--   If a file name argument is given, then the output is written to this file\n+--   rather than to nmake.ads or nmake.adb. A file name can only be given if\n+--   exactly one of the -s or -b options is present.\n+\n+with Ada.Command_Line;              use Ada.Command_Line;\n+with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n+with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n+with Ada.Strings.Maps;              use Ada.Strings.Maps;\n+with Ada.Strings.Maps.Constants;    use Ada.Strings.Maps.Constants;\n+with Ada.Text_IO;                   use Ada.Text_IO;\n+\n+with GNAT.Spitbol;                  use GNAT.Spitbol;\n+with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n+\n+procedure XNmake is\n+\n+   Err : exception;\n+   --  Raised to terminate execution\n+\n+   A          : VString := Nul;\n+   Arg        : VString := Nul;\n+   Arg_List   : VString := Nul;\n+   Comment    : VString := Nul;\n+   Default    : VString := Nul;\n+   Field      : VString := Nul;\n+   Line       : VString := Nul;\n+   Node       : VString := Nul;\n+   Op_Name    : VString := Nul;\n+   Prevl      : VString := Nul;\n+   Sinfo_Rev  : VString := Nul;\n+   Synonym    : VString := Nul;\n+   Temp_Rev   : VString := Nul;\n+   X          : VString := Nul;\n+   XNmake_Rev : VString := Nul;\n+\n+   Lineno : Natural;\n+   NWidth : Natural;\n+\n+   FileS : VString := V (\"nmake.ads\");\n+   FileB : VString := V (\"nmake.adb\");\n+   --  Set to null if corresponding file not to be generated\n+\n+   Given_File : VString := Nul;\n+   --  File name given by command line argument\n+\n+   InS,  InT  : File_Type;\n+   OutS, OutB : File_Type;\n+\n+   wsp   : Pattern := Span (' ' & ASCII.HT);\n+\n+   --  Note: in following patterns, we break up the word revision to\n+   --  avoid RCS getting enthusiastic about updating the reference!\n+\n+   Get_SRev : Pattern := BreakX ('$') & \"$Rev\" & \"ision: \" &\n+                           Break (' ') * Sinfo_Rev;\n+\n+   GetT_Rev : Pattern := BreakX ('$') & \"$Rev\" & \"ision: \" &\n+                           Break (' ') * Temp_Rev;\n+\n+\n+   Body_Only : Pattern := BreakX (' ') * X & Span (' ') & \"--  body only\";\n+   Spec_Only : Pattern := BreakX (' ') * X & Span (' ') & \"--  spec only\";\n+\n+   Node_Hdr  : Pattern := wsp & \"--  N_\" & Rest * Node;\n+   Punc      : Pattern := BreakX (\" .,\");\n+\n+   Binop     : Pattern := wsp & \"--  plus fields for binary operator\";\n+   Unop      : Pattern := wsp & \"--  plus fields for unary operator\";\n+   Syn       : Pattern := wsp & \"--  \" & Break (' ') * Synonym\n+                            & \" (\" & Break (')') * Field & Rest * Comment;\n+\n+   Templ     : Pattern := BreakX ('T') * A & \"T e m p l a t e\";\n+   Spec      : Pattern := BreakX ('S') * A & \"S p e c\";\n+\n+   Sem_Field : Pattern := BreakX ('-') & \"-Sem\";\n+   Lib_Field : Pattern := BreakX ('-') & \"-Lib\";\n+\n+   Get_Field : Pattern := BreakX (Decimal_Digit_Set) * Field;\n+\n+   Get_Dflt  : Pattern := BreakX ('(') & \"(set to \"\n+                            & Break (\" \") * Default & \" if\";\n+\n+   Next_Arg  : Pattern := Break (',') * Arg & ',';\n+\n+   Op_Node   : Pattern := \"Op_\" & Rest * Op_Name;\n+\n+   Shft_Rot  : Pattern := \"Shift_\" or \"Rotate_\";\n+\n+   No_Ent    : Pattern := \"Or_Else\" or \"And_Then\" or \"In\" or \"Not_In\";\n+\n+   M : Match_Result;\n+\n+   V_String_Id : constant VString := V (\"String_Id\");\n+   V_Node_Id   : constant VString := V (\"Node_Id\");\n+   V_Name_Id   : constant VString := V (\"Name_Id\");\n+   V_List_Id   : constant VString := V (\"List_Id\");\n+   V_Elist_Id  : constant VString := V (\"Elist_Id\");\n+   V_Boolean   : constant VString := V (\"Boolean\");\n+\n+   procedure WriteS  (S : String);\n+   procedure WriteB  (S : String);\n+   procedure WriteBS (S : String);\n+   procedure WriteS  (S : VString);\n+   procedure WriteB  (S : VString);\n+   procedure WriteBS (S : VString);\n+   --  Write given line to spec or body file or both if active\n+\n+   procedure WriteB (S : String) is\n+   begin\n+      if FileB /= Nul then\n+         Put_Line (OutB, S);\n+      end if;\n+   end WriteB;\n+\n+   procedure WriteB (S : VString) is\n+   begin\n+      if FileB /= Nul then\n+         Put_Line (OutB, S);\n+      end if;\n+   end WriteB;\n+\n+   procedure WriteBS (S : String) is\n+   begin\n+      if FileB /= Nul then\n+         Put_Line (OutB, S);\n+      end if;\n+\n+      if FileS /= Nul then\n+         Put_Line (OutS, S);\n+      end if;\n+   end WriteBS;\n+\n+   procedure WriteBS (S : VString) is\n+   begin\n+      if FileB /= Nul then\n+         Put_Line (OutB, S);\n+      end if;\n+\n+      if FileS /= Nul then\n+         Put_Line (OutS, S);\n+      end if;\n+   end WriteBS;\n+\n+   procedure WriteS (S : String) is\n+   begin\n+      if FileS /= Nul then\n+         Put_Line (OutS, S);\n+      end if;\n+   end WriteS;\n+\n+   procedure WriteS (S : VString) is\n+   begin\n+      if FileS /= Nul then\n+         Put_Line (OutS, S);\n+      end if;\n+   end WriteS;\n+\n+--  Start of processing for XNmake\n+\n+begin\n+   --  Capture our revision (following line updated by RCS)\n+\n+   Match (\"$Revision: 1.27 $\", \"$Rev\" & \"ision: \" & Break (' ') * XNmake_Rev);\n+\n+   Lineno := 0;\n+   NWidth := 28;\n+   Anchored_Mode := True;\n+\n+   for ArgN in 1 .. Argument_Count loop\n+      declare\n+         Arg : constant String := Argument (ArgN);\n+\n+      begin\n+         if Arg (1) = '/' or else Arg (1) = '-' then\n+            if Arg'Length = 2\n+              and then (Arg (2) = 'b' or else Arg (2) = 'B')\n+            then\n+               FileS := Nul;\n+\n+            elsif Arg'Length = 2\n+              and then (Arg (2) = 's' or else Arg (2) = 'S')\n+            then\n+               FileB := Nul;\n+\n+            else\n+               raise Err;\n+            end if;\n+\n+         else\n+            if Given_File /= Nul then\n+               raise Err;\n+            else\n+               Given_File := V (Arg);\n+            end if;\n+         end if;\n+      end;\n+   end loop;\n+\n+   if FileS = Nul and then FileB = Nul then\n+      raise Err;\n+\n+   elsif Given_File /= Nul then\n+      if FileS = Nul then\n+         FileS := Given_File;\n+\n+      elsif FileB = Nul then\n+         FileB := Given_File;\n+\n+      else\n+         raise Err;\n+      end if;\n+   end if;\n+\n+   Open (InS, In_File, \"sinfo.ads\");\n+   Open (InT, In_File, \"nmake.adt\");\n+\n+   if FileS /= Nul then\n+      Create (OutS, Out_File, S (FileS));\n+   end if;\n+\n+   if FileB /= Nul then\n+      Create (OutB, Out_File, S (FileB));\n+   end if;\n+\n+   Anchored_Mode := True;\n+\n+   --  Get Sinfo revision number\n+\n+   loop\n+      Line := Get_Line (InS);\n+      exit when Match (Line, Get_SRev);\n+   end loop;\n+\n+   --  Copy initial part of template to spec and body\n+\n+   loop\n+      Line := Get_Line (InT);\n+\n+      if Match (Line, GetT_Rev) then\n+         WriteBS\n+           (\"--                 Generated by xnmake revision \" &\n+            XNmake_Rev & \" using\" &\n+            \"                  --\");\n+\n+         WriteBS\n+           (\"--                         sinfo.ads revision \" &\n+            Sinfo_Rev &\n+            \"                         --\");\n+\n+         WriteBS\n+           (\"--                         nmake.adt revision \" &\n+            Temp_Rev &\n+            \"                          --\");\n+\n+      else\n+         --  Skip lines describing the template\n+\n+         if Match (Line, \"--  This file is a template\") then\n+            loop\n+               Line := Get_Line (InT);\n+               exit when Line = \"\";\n+            end loop;\n+         end if;\n+\n+         exit when Match (Line, \"package\");\n+\n+         if Match (Line, Body_Only, M) then\n+            Replace (M, X);\n+            WriteB (Line);\n+\n+         elsif Match (Line, Spec_Only, M) then\n+            Replace (M, X);\n+            WriteS (Line);\n+\n+         else\n+            if Match (Line, Templ, M) then\n+               Replace (M, A &  \"    S p e c    \");\n+            end if;\n+\n+            WriteS (Line);\n+\n+            if Match (Line, Spec, M) then\n+               Replace (M, A &  \"B o d y\");\n+            end if;\n+\n+            WriteB (Line);\n+         end if;\n+      end if;\n+   end loop;\n+\n+   --  Package line reached\n+\n+   WriteS (\"package Nmake is\");\n+   WriteB (\"package body Nmake is\");\n+   WriteB (\"\");\n+\n+   --  Copy rest of lines up to template insert point to spec only\n+\n+   loop\n+      Line := Get_Line (InT);\n+      exit when Match (Line, \"!!TEMPLATE INSERTION POINT\");\n+      WriteS (Line);\n+   end loop;\n+\n+   --  Here we are doing the actual insertions, loop through node types\n+\n+   loop\n+      Line := Get_Line (InS);\n+\n+      if Match (Line, Node_Hdr)\n+        and then not Match (Node, Punc)\n+        and then Node /= \"Unused\"\n+      then\n+         exit when Node = \"Empty\";\n+         Prevl := \"   function Make_\" & Node & \" (Sloc : Source_Ptr\";\n+         Arg_List := Nul;\n+\n+         --  Loop through fields of one node\n+\n+         loop\n+            Line := Get_Line (InS);\n+            exit when Line = \"\";\n+\n+            if Match (Line, Binop) then\n+               WriteBS (Prevl & ';');\n+               Append (Arg_List, \"Left_Opnd,Right_Opnd,\");\n+               WriteBS (\n+                 \"      \" & Rpad (\"Left_Opnd\",  NWidth) & \" : Node_Id;\");\n+               Prevl :=\n+                 \"      \" & Rpad (\"Right_Opnd\", NWidth) & \" : Node_Id\";\n+\n+            elsif Match (Line, Unop) then\n+               WriteBS (Prevl & ';');\n+               Append (Arg_List, \"Right_Opnd,\");\n+               Prevl := \"      \" & Rpad (\"Right_Opnd\", NWidth) & \" : Node_Id\";\n+\n+            elsif Match (Line, Syn) then\n+               if         Synonym /= \"Prev_Ids\"\n+                 and then Synonym /= \"More_Ids\"\n+                 and then Synonym /= \"Comes_From_Source\"\n+                 and then Synonym /= \"Paren_Count\"\n+                 and then not Match (Field, Sem_Field)\n+                 and then not Match (Field, Lib_Field)\n+               then\n+                  Match (Field, Get_Field);\n+\n+                  if    Field = \"Str\"   then Field := V_String_Id;\n+                  elsif Field = \"Node\"  then Field := V_Node_Id;\n+                  elsif Field = \"Name\"  then Field := V_Name_Id;\n+                  elsif Field = \"List\"  then Field := V_List_Id;\n+                  elsif Field = \"Elist\" then Field := V_Elist_Id;\n+                  elsif Field = \"Flag\"  then Field := V_Boolean;\n+                  end if;\n+\n+                  if Field = \"Boolean\" then\n+                     Default := V (\"False\");\n+                  else\n+                     Default := Nul;\n+                  end if;\n+\n+                  Match (Comment, Get_Dflt);\n+\n+                  WriteBS (Prevl & ';');\n+                  Append (Arg_List, Synonym & ',');\n+                  Rpad (Synonym, NWidth);\n+\n+                  if Default = \"\" then\n+                     Prevl := \"      \" & Synonym & \" : \" & Field;\n+                  else\n+                     Prevl :=\n+                       \"      \" & Synonym & \" : \" & Field & \" := \" & Default;\n+                  end if;\n+               end if;\n+            end if;\n+         end loop;\n+\n+         WriteBS (Prevl & ')');\n+         WriteS (\"      return Node_Id;\");\n+         WriteS (\"   pragma Inline (Make_\" & Node & \");\");\n+         WriteB (\"      return Node_Id\");\n+         WriteB (\"   is\");\n+         WriteB (\"      N : constant Node_Id :=\");\n+\n+         if Match (Node, \"Defining_Identifier\") or else\n+            Match (Node, \"Defining_Character\")  or else\n+            Match (Node, \"Defining_Operator\")\n+         then\n+            WriteB (\"            New_Entity (N_\" & Node & \", Sloc);\");\n+         else\n+            WriteB (\"            New_Node (N_\" & Node & \", Sloc);\");\n+         end if;\n+\n+         WriteB (\"   begin\");\n+\n+         while Match (Arg_List, Next_Arg, \"\") loop\n+            if Length (Arg) < NWidth then\n+               WriteB (\"      Set_\" & Arg & \" (N, \" & Arg & \");\");\n+            else\n+               WriteB (\"      Set_\" & Arg);\n+               WriteB (\"        (N, \" & Arg & \");\");\n+            end if;\n+         end loop;\n+\n+         if Match (Node, Op_Node) then\n+            if Node = \"Op_Plus\" then\n+               WriteB (\"      Set_Chars (N, Name_Op_Add);\");\n+\n+            elsif Node = \"Op_Minus\" then\n+               WriteB (\"      Set_Chars (N, Name_Op_Subtract);\");\n+\n+            elsif Match (Op_Name, Shft_Rot) then\n+               WriteB (\"      Set_Chars (N, Name_\" & Op_Name & \");\");\n+\n+            else\n+               WriteB (\"      Set_Chars (N, Name_\" & Node & \");\");\n+            end if;\n+\n+            if not Match (Op_Name, No_Ent) then\n+               WriteB (\"      Set_Entity (N, Standard_\" & Node & \");\");\n+            end if;\n+         end if;\n+\n+         WriteB (\"      return N;\");\n+         WriteB (\"   end Make_\" & Node & ';');\n+         WriteBS (\"\");\n+      end if;\n+   end loop;\n+\n+   WriteBS (\"end Nmake;\");\n+\n+exception\n+\n+   when Err =>\n+      Put_Line (Standard_Error, \"usage: xnmake [-b] [-s] [filename]\");\n+      Set_Exit_Status (1);\n+\n+end XNmake;"}, {"sha": "02af07e75ec18fb3239da6f3859caa0af54202b1", "filename": "gcc/ada/xr_tabls.adb", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxr_tabls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxr_tabls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxr_tabls.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548"}, {"sha": "960b35def8e3ac6215bdb6b592399a0ff4899d33", "filename": "gcc/ada/xr_tabls.ads", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxr_tabls.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxr_tabls.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxr_tabls.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548"}, {"sha": "d3dfe37859a0c428618307ab1ae3bafabfc3c6fc", "filename": "gcc/ada/xref_lib.adb", "status": "added", "additions": 1676, "deletions": 0, "changes": 1676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548"}, {"sha": "1282ad142dcb6289156c6ad59032e0bd7cf25aab", "filename": "gcc/ada/xref_lib.ads", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxref_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxref_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.ads?ref=415dddc81c99f37554902cbe0d838060b62a2548"}, {"sha": "57d4b3e1580a193cbb6d2712a84dc98d125e8dcd", "filename": "gcc/ada/xsinfo.adb", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxsinfo.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548"}, {"sha": "995401e498416d863c7d61a667ee8885512c5f53", "filename": "gcc/ada/xtreeprs.adb", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxtreeprs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415dddc81c99f37554902cbe0d838060b62a2548/gcc%2Fada%2Fxtreeprs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxtreeprs.adb?ref=415dddc81c99f37554902cbe0d838060b62a2548"}]}