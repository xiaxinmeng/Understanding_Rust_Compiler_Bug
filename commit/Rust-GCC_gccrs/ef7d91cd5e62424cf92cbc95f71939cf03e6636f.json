{"sha": "ef7d91cd5e62424cf92cbc95f71939cf03e6636f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY3ZDkxY2Q1ZTYyNDI0Y2Y5MmNiYzk1ZjcxOTM5Y2YwM2U2NjM2Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-12-01T00:29:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-12-01T00:29:57Z"}, "message": "elf.h (ASM_OUTPUT_SECTION_NAME): Copy elfos.h defn.\n\n        * config/alpha/elf.h (ASM_OUTPUT_SECTION_NAME): Copy elfos.h defn.\n        (DO_SELECT_SECTION): New.\n        (SELECT_SECTION): Use it.\n        (UNIQUE_SECTION_P): New.\n        (UNIQUE_SECTION): New.\n\nFrom-SVN: r37903", "tree": {"sha": "2fbd320aebe8ed931d2247975611a08caeb6eba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fbd320aebe8ed931d2247975611a08caeb6eba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef7d91cd5e62424cf92cbc95f71939cf03e6636f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef7d91cd5e62424cf92cbc95f71939cf03e6636f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef7d91cd5e62424cf92cbc95f71939cf03e6636f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef7d91cd5e62424cf92cbc95f71939cf03e6636f/comments", "author": null, "committer": null, "parents": [{"sha": "be10afdfe8bbdc4655c211db50ced6843491ca4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be10afdfe8bbdc4655c211db50ced6843491ca4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be10afdfe8bbdc4655c211db50ced6843491ca4f"}], "stats": {"total": 224, "additions": 174, "deletions": 50}, "files": [{"sha": "661ae1235a3edcc708a4c60067b09d66fec09d81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7d91cd5e62424cf92cbc95f71939cf03e6636f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7d91cd5e62424cf92cbc95f71939cf03e6636f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef7d91cd5e62424cf92cbc95f71939cf03e6636f", "patch": "@@ -1,3 +1,11 @@\n+2000-11-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/elf.h (ASM_OUTPUT_SECTION_NAME): Copy elfos.h defn.\n+\t(DO_SELECT_SECTION): New.\n+\t(SELECT_SECTION): Use it.\n+\t(UNIQUE_SECTION_P): New.\n+\t(UNIQUE_SECTION): New.\n+\n 2000-11-30  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* c-common.c (status_warning) [! ANSI_PROTOTYPES]: Load status"}, {"sha": "9224a393d47e9383add62f02e684282008524657", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 166, "deletions": 50, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7d91cd5e62424cf92cbc95f71939cf03e6636f/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7d91cd5e62424cf92cbc95f71939cf03e6636f/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=ef7d91cd5e62424cf92cbc95f71939cf03e6636f", "patch": "@@ -318,16 +318,67 @@ void FN ()\t\t\t\t\t\\\n \n \n /* Switch into a generic section.\n-   This is currently only used to support section attributes.\n \n    We make the section read-only and executable for a function decl,\n-   read-only for a const data decl, and writable for a non-const data decl.  */\n-#undef  ASM_OUTPUT_SECTION_NAME\n-#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC) \\\n-  fprintf (FILE, \".section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, \\\n-\t   (DECL) && TREE_CODE (DECL) == FUNCTION_DECL ? \"ax\" : \\\n-\t   (DECL) && DECL_READONLY_SECTION (DECL, RELOC) ? \"a\" : \"aw\")\n+   read-only for a const data decl, and writable for a non-const data decl.\n \n+   If the section has already been defined, we must not emit the\n+   attributes here. The SVR4 assembler does not recognize section\n+   redefinitions.  If DECL is NULL, no attributes are emitted.  */\n+\n+#undef  ASM_OUTPUT_SECTION_NAME\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static htab_t htab;                                               \\\n+                                                                        \\\n+      struct section_info                                               \\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tenum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n+      };                                                                \\\n+                                                                        \\\n+      struct section_info *s;\t\t\t\t\t\t\\\n+      const char *mode;\t\t\t\t\t\t\t\\\n+      enum sect_enum type;                                              \\\n+      PTR* slot;                                                        \\\n+                                                                        \\\n+      /* The names we put in the hashtable will always be the unique    \\\n+\t versions gived to us by the stringtable, so we can just use    \\\n+\t their addresses as the keys.  */                               \\\n+      if (!htab)                                                        \\\n+\thtab = htab_create (31,                                         \\\n+\t\t\t    htab_hash_pointer,                          \\\n+\t\t\t    htab_eq_pointer,                            \\\n+\t\t\t    NULL);                                      \\\n+                                                                        \\\n+      if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+\ttype = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n+      else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n+\ttype = SECT_RO, mode = \"a\";\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\ttype = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      /* See if we already have an entry for this section.  */          \\\n+      slot = htab_find_slot (htab, NAME, INSERT);                       \\\n+      if (!*slot)                                                       \\\n+\t{                                                               \\\n+\t  s = (struct section_info *) xmalloc (sizeof (* s));\t\t\\\n+\t  s->type = type;\t\t\t\t\t\t\\\n+\t  *slot = s;\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\",\t\t\\\n+\t\t   NAME, mode);\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  s = (struct section_info *) *slot;                            \\\n+\t  if (DECL && s->type != type)\t\t\t\t\t\\\n+\t    error_with_decl (DECL,                                      \\\n+\t\t\t     \"%s causes a section type conflict\");      \\\n+\t  \t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* A C statement (sans semicolon) to output an element in the table of\n    global constructors.  */\n@@ -354,53 +405,118 @@ void FN ()\t\t\t\t\t\\\n /* A C statement or statements to switch to the appropriate\n    section for output of DECL.  DECL is either a `VAR_DECL' node\n    or a constant of some sort.  RELOC indicates whether forming\n-   the initial value of DECL requires link-time relocations.  */\n+   the initial value of DECL requires link-time relocations.\n+\n+   Set SECNUM to:\n+\t0\t.text\n+\t1\t.rodata\n+\t2\t.data\n+\t3\t.sdata\n+\t4\t.bss\n+\t5\t.sbss\n+*/\n+\n+#define DO_SELECT_SECTION(SECNUM, DECL, RELOC)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\\\n+       SECNUM = 1;\t\t\t\t\t\t\\\n+       if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+\t SECNUM = 0;\t\t\t\t\t\t\\\n+       else if (TREE_CODE (DECL) == STRING_CST)\t\t\t\\\n+\t {\t\t\t\t\t\t\t\\\n+\t   if (flag_writable_strings)\t\t\t\t\\\n+\t     SECNUM = 2;\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\\\n+       else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\\\n+\t {\t\t\t\t\t\t\t\\\n+\t   if (DECL_INITIAL (DECL) == NULL\t\t\t\\\n+\t       || DECL_INITIAL (DECL) == error_mark_node)\t\\\n+\t     SECNUM = 4;\t\t\t\t\t\\\n+\t   else if ((flag_pic && RELOC)\t\t\t\t\\\n+\t\t    || ! TREE_READONLY (DECL)\t\t\t\\\n+\t\t    || TREE_SIDE_EFFECTS (DECL)\t\t\t\\\n+\t\t    || ! TREE_CONSTANT (DECL_INITIAL (DECL)))\t\\\n+\t     SECNUM = 2;\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\\\n+       else if (TREE_CODE (DECL) == CONSTRUCTOR)\t\t\\\n+\t {\t\t\t\t\t\t\t\\\n+\t   if ((flag_pic && RELOC)\t\t\t\t\\\n+\t       || ! TREE_READONLY (DECL)\t\t\t\\\n+\t       || TREE_SIDE_EFFECTS (DECL)\t\t\t\\\n+\t       || ! TREE_CONSTANT (DECL))\t\t\t\\\n+\t     SECNUM = 2;\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+       /* Select small data sections based on size.  */\t\t\\\n+       if (SECNUM >= 2)\t\t\t\t\t\t\\\n+\t {\t\t\t\t\t\t\t\\\n+\t   int size = int_size_in_bytes (TREE_TYPE (DECL));\t\\\n+\t   if (size >= 0 && size <= g_switch_value)\t\t\\\n+\t     SECNUM += 1;\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\\\n+   while (0)\n \n #undef  SELECT_SECTION\n-#define SELECT_SECTION(DECL, RELOC)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (! flag_writable_strings)\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tdata_section ();\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if ((flag_pic && RELOC)\t\t\t\t\t\t\\\n-\t  || ! TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n-\t  || ! DECL_INITIAL (DECL)\t\t\t\t\t\\\n-\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n-\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  int size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n-\t  if (size >= 0 && size <= g_switch_value)\t\t\t\\\n-\t    sdata_section ();\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    data_section ();\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (TREE_CODE (DECL) == CONSTRUCTOR)\t\t\t\t\\\n+#define SELECT_SECTION(DECL, RELOC)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      typedef void (*sec_fn) PARAMS ((void));\t\\\n+      static sec_fn const sec_functions[6] =\t\\\n+      {\t\t\t\t\t\t\\\n+\ttext_section,\t\t\t\t\\\n+\tconst_section,\t\t\t\t\\\n+\tdata_section,\t\t\t\t\\\n+\tsdata_section,\t\t\t\t\\\n+\tbss_section,\t\t\t\t\\\n+\tsbss_section\t\t\t\t\\\n+      };\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+      int sec;\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+      DO_SELECT_SECTION (sec, DECL, RELOC);\t\\\n+\t\t\t\t\t\t\\\n+      (*sec_functions[sec]) ();\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define UNIQUE_SECTION_P(DECL)   (DECL_ONE_ONLY (DECL))\n+\n+#undef  UNIQUE_SECTION\n+#define UNIQUE_SECTION(DECL, RELOC)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if ((flag_pic && RELOC)\t\t\t\t\t\t\\\n-\t  || ! TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n-\t  || ! TREE_CONSTANT (DECL))\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  int size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n-\t  if (size >= 0 && size <= g_switch_value)\t\t\t\\\n-\t    sdata_section ();\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    data_section ();\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tconst_section ();\t\t\t\t\t\t\\\n+      static const char * const prefixes[6][2] =\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t{ \".text.\",   \".gnu.linkonce.t.\" },\t\t\t\t\\\n+\t{ \".rodata.\", \".gnu.linkonce.r.\" },\t\t\t\t\\\n+\t{ \".data.\",   \".gnu.linkonce.d.\" },\t\t\t\t\\\n+\t{ \".sdata.\",  \".gnu.linkonce.s.\" },\t\t\t\t\\\n+\t{ \".bss.\",    \".gnu.linkonce.b.\" },\t\t\t\t\\\n+\t{ \".sbss.\",   \".gnu.linkonce.sb.\" }\t\t\t\t\\\n+      };\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      int nlen, plen, sec;\t\t\t\t\t\t\\\n+      const char *name, *prefix;\t\t\t\t\t\\\n+      char *string;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      DO_SELECT_SECTION (sec, DECL, RELOC);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\t\\\n+      STRIP_NAME_ENCODING (name, name);\t\t\t\t\t\\\n+      nlen = strlen (name);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      prefix = prefixes[sec][DECL_ONE_ONLY(DECL)];\t\t\t\\\n+      plen = strlen (prefix);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      string = alloca (nlen + plen + 1);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      memcpy (string, prefix, plen);\t\t\t\t\t\\\n+      memcpy (string + plen, name, nlen + 1);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      DECL_SECTION_NAME (DECL) = build_string (nlen + plen, string);\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    const_section ();\t\t\t\t\t\t\t\\\n-}\n+  while (0)\n \n /* A C statement or statements to switch to the appropriate\n    section for output of RTX in mode MODE.  RTX is some kind"}]}