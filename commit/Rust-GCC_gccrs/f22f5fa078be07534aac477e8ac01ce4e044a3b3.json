{"sha": "f22f5fa078be07534aac477e8ac01ce4e044a3b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIyZjVmYTA3OGJlMDc1MzRhYWM0NzdlOGFjMDFjZTRlMDQ0YTNiMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-30T20:00:30Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-30T20:00:30Z"}, "message": "Initial revision\n\nFrom-SVN: r253", "tree": {"sha": "e686a93664b1a29ea8c01313bcbe6313a5784b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e686a93664b1a29ea8c01313bcbe6313a5784b88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f22f5fa078be07534aac477e8ac01ce4e044a3b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22f5fa078be07534aac477e8ac01ce4e044a3b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f22f5fa078be07534aac477e8ac01ce4e044a3b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22f5fa078be07534aac477e8ac01ce4e044a3b3/comments", "author": null, "committer": null, "parents": [{"sha": "2fa2b671750b833393c32074fbca001dca10a706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa2b671750b833393c32074fbca001dca10a706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fa2b671750b833393c32074fbca001dca10a706"}], "stats": {"total": 1416, "additions": 1416, "deletions": 0}, "files": [{"sha": "5bd9ed57b6378d39b4ac591b5ed90dcf9c2ea657", "filename": "gcc/config/i860/i860.h", "status": "added", "additions": 1416, "deletions": 0, "changes": 1416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f5fa078be07534aac477e8ac01ce4e044a3b3/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f5fa078be07534aac477e8ac01ce4e044a3b3/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=f22f5fa078be07534aac477e8ac01ce4e044a3b3", "patch": "@@ -0,0 +1,1416 @@\n+/* Definitions of target machine for GNU compiler, for Intel 860.\n+   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+\n+   Written by Richard Stallman (rms@ai.mit.edu).\n+\n+   Hacked substantially by Ron Guilmette (rfg@ncd.com) to cater to\n+   the whims of the System V Release 4 assembler.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Note that some other tm.h files include this one and then override\n+   many of the definitions that relate to assembler syntax.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Di860 -Dunix\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (i860)\");\n+\n+/* Run-time compilation parameters selecting different hardware subsets\n+   or supersets.\n+\n+   On the i860, we have one: TARGET_XP.  This option allows gcc to generate\n+   additional instructions available only on the newer i860 XP (but not on\n+   the older i860 XR).\n+*/\n+\n+extern int target_flags;\n+\n+/* Nonzero if we should generate code to use the fpu.  */\n+#define TARGET_XP (target_flags & 1)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"xp\", 1},\t\t\t\\\n+    {\"noxp\", -1},\t\t\\\n+    {\"xr\", -1},\t\t\t\\\n+    { \"\", TARGET_DEFAULT}}\n+\n+#define TARGET_DEFAULT 0\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is a moot question on the i860 due to the lack of bit-field insns.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is not true on i860 in the mode we will use.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+/* For the i860 this goes with BYTES_BIG_ENDIAN.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 128\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 64\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* Minimum size in bits of the largest boundary to which any\n+   and all fundamental data types supported by the hardware\n+   might need to be aligned. No data type wants to be aligned\n+   rounder than this.  The i860 supports 128-bit (long double)\n+   floating point quantities, and the System V Release 4 i860\n+   ABI requires these to be aligned to 16-byte (128-bit)\n+   boundaries.  */\n+#define BIGGEST_ALIGNMENT 128\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT\n+\n+/* If bit field type is int, dont let it cross an int,\n+   and give entire struct the alignment of an int.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   i860 has 32 fullword registers and 32 floating point registers.  */\n+\n+#define FIRST_PSEUDO_REGISTER 64\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the i860, this includes the always-0 registers\n+   and fp, sp, arg pointer, and the return address.\n+   Also r31, used for special purposes for constant addresses.  */\n+#define FIXED_REGISTERS  \\\n+ {1, 1, 1, 1, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 1,\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   On the i860, these are r0-r3, r16-r31, f0, f1, and f16-f31.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1}\n+\n+/* Try to get a non-preserved register before trying to get one we will\n+   have to preserve.  Try to get an FP register only *after* trying to\n+   get a general register, because it is relatively expensive to move\n+   into or out of an FP register.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\\\n+ {31, 30, 29, 28, 27, 26, 25, 24,\t\\\n+  23, 22, 21, 20, 19, 18, 17, 16,\t\\\n+  15, 14, 13, 12, 11, 10,  9,  8,\t\\\n+   7,  6,  5,  4,  3,  2,  1,  0,\t\\\n+  63, 62, 61, 60, 59, 58, 57, 56,\t\\\n+  55, 54, 53, 52, 51, 50, 49, 48,\t\\\n+  47, 46, 45, 44, 43, 42, 41, 40,\t\\\n+  39, 38, 37, 36, 35, 34, 33, 32}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the i860, all registers hold 32 bits worth.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+#define REGNO_MODE_ALIGNED(REGNO, MODE) \\\n+  (((REGNO) % ((GET_MODE_UNIT_SIZE (MODE) + 3) / 4)) == 0)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+\n+   On the i860, we allow anything to go into any registers, but we require\n+   any sort of value going into the FP registers to be properly aligned\n+   (based on its size) within the FP register set.\n+*/\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  (((REGNO) < 32) \t\t\t\t\t\t\t\\\n+   || ((MODE) == VOIDmode)\t\t\t\t\t\t\\\n+   || REGNO_MODE_ALIGNED (REGNO, MODE))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+/* I think that is not always true; alignment restrictions for doubles\n+   should not prevent tying them with singles.  So try allowing that.\n+   On the other hand, don't let fixed and floating be tied;\n+   this restriction is not necessary, but may make better code.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n+    || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\\\n+       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* i860 pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 2\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 3\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 28\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 29\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 16\n+\n+/* Register to use when a source of a floating-point zero is needed.  */\n+#define F0_REGNUM\t32\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The i860 has two kinds of registers, hence four classes.  */\n+\n+enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS\t\\\n+ {{0, 0}, {0xffffffff, 0},\t\\\n+  {0, 0xffffffff}, {0xffffffff, 0xffffffff}}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+ ((REGNO) >= 32 ? FP_REGS : GENERAL_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'f' ? FP_REGS : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For the i860, `I' is used for the range of constants \n+   an add/subtract insn can actually contain.\n+   But not including -0x8000, since we need\n+   to negate the constant sometimes.\n+   `J' is used for the range which is just zero (since that is R0).\n+   `K' is used for the range allowed in bte.\n+   `L' is used for the range allowed in logical insns.  */\n+\n+#define SMALL_INT(X) ((unsigned) (INTVAL (X) + 0x7fff) < 0xffff)\n+\n+#define LOGIC_INT(X) ((unsigned) INTVAL (X) < 0x10000)\n+\n+#define SMALL_INTVAL(X) ((unsigned) ((X) + 0x7fff) < 0xffff)\n+\n+#define LOGIC_INTVAL(X) ((unsigned) (X) < 0x10000)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? ((unsigned) (VALUE) + 0x7fff) < 0xffff\t\\\n+   : (C) == 'J' ? (VALUE) == 0\t\t\t\t\\\n+   : (C) == 'K' ? (unsigned) (VALUE) < 0x20\t\\\n+   : (C) == 'L' ? (unsigned) (VALUE) < 0x10000\t\\\n+   : 0)\n+\n+/* Return non-zero if the given VALUE is acceptable for the\n+   constraint letter C.  For the i860, constraint letter 'G'\n+   permits only a floating-point zero value.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \t\\\n+  ((C) == 'G' && CONST_DOUBLE_LOW ((VALUE)) == 0\t\\\n+   && CONST_DOUBLE_HIGH ((VALUE)) == 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+\n+   If we are trying to put an integer constant into some register, prefer an\n+   integer register to an FP register.  If we are trying to put a \n+   non-zero floating-point constant into some register, use an integer\n+   register if the constant is SFmode and GENERAL_REGS is one of our options.\n+   Otherwise, put the constant intoo memory.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  \\\n+  ((CLASS) == ALL_REGS && GET_CODE (X) == CONST_INT ? GENERAL_REGS\t\\\n+   : (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+      && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n+      && ! CONST_DOUBLE_OK_FOR_LETTER_P (X, 'G'))\t\t\t\\\n+   ? ((CLASS) == ALL_REGS && GET_MODE (X) == SFmode ? GENERAL_REGS\t\\\n+      : (CLASS) == GENERAL_REGS && GET_MODE (X) == SFmode ? (CLASS)\t\\\n+      : NO_REGS)\t\t\t\t\t\t\t\\\n+   : (CLASS))\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   a register in CLASS in MODE.  If it can be done directly, NO_REGS is\n+   returned.  */\n+\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  ((CLASS) == FP_REGS && GET_CODE (IN) == CONST_INT ? GENERAL_REGS : NO_REGS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the i860, this is the size of MODE in words.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On the i860, don't define this because there are no push insns.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the i860, the value register depends on the mode.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE),\t\t\t\t\\\n+\t   (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT\t\\\n+\t    ? 40 : 16))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\\\n+  gen_rtx (REG, MODE,\t\t\t\t\t\\\n+\t   (GET_MODE_CLASS ((MODE)) == MODE_FLOAT\t\\\n+\t    ? 40 : 16))\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 40 || (N) == 16)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the i860, these are r16-r27 and f8-f15.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t\t\\\n+  (((N) < 28 && (N) > 15) || ((N) < 48 && (N) >= 40))\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the i860, we must count separately the number of general registers used\n+   and the number of float registers used.  */\n+\n+struct cumulative_args { int ints, floats; };\n+#define CUMULATIVE_ARGS struct cumulative_args\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the i860, the general-reg offset normally starts at 0,\n+   but starts at 4 bytes\n+   when the function gets a structure-value-address as an\n+   invisible first argument.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM).ints = ((FNTYPE) != 0 && aggregate_value_p ((FNTYPE)) \\\n+\t\t? 4 : 0),\t\t\t\\\n+  (CUM).floats = 0)\n+\n+/* Machine-specific subroutines of the following macros.  */\n+#define CEILING(X,Y)  (((X) + (Y) - 1) / (Y))\n+#define ROUNDUP(X,Y)  (CEILING ((X), (Y)) * (Y))\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)\n+   Floats, and doubleword ints, are returned in f regs;\n+   other ints, in r regs.\n+   Aggregates, even short ones, are passed in memory.  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+ ((TYPE) != 0 && (TREE_CODE ((TYPE)) == RECORD_TYPE\t\t\\\n+\t\t  || TREE_CODE ((TYPE)) == UNION_TYPE)\t\t\\\n+  ? 0\t\t\t\t\t\t\t\t\\\n+  : GET_MODE_CLASS ((MODE)) == MODE_FLOAT || (MODE) == DImode\t\\\n+  ? ((CUM).floats = (ROUNDUP ((CUM).floats, GET_MODE_SIZE ((MODE)))\t\\\n+\t\t     + ROUNDUP (GET_MODE_SIZE (MODE), 4)))\t\\\n+  : GET_MODE_CLASS ((MODE)) == MODE_INT\t\t\t\t\\\n+  ? ((CUM).ints = (ROUNDUP ((CUM).ints, GET_MODE_SIZE ((MODE))) \\\n+\t\t   + ROUNDUP (GET_MODE_SIZE (MODE), 4)))\t\\\n+  : 0)\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the i860, the first 12 words of integer arguments go in r16-r27,\n+   and the first 8 words of floating arguments go in f8-f15.\n+   DImode values are treated as floats.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\\\n+ ((TYPE) != 0 && (TREE_CODE ((TYPE)) == RECORD_TYPE\t\\\n+\t\t  || TREE_CODE ((TYPE)) == UNION_TYPE)\t\\\n+  ? 0\t\t\t\t\t\t\t\\\n+  : GET_MODE_CLASS ((MODE)) == MODE_FLOAT || (MODE) == DImode\t\\\n+  ? (ROUNDUP ((CUM).floats, GET_MODE_SIZE ((MODE))) < 32\t\\\n+     ? gen_rtx (REG, (MODE),\t\t\t\t\\\n+\t\t40+(ROUNDUP ((CUM).floats,\t\t\\\n+\t\t\t     GET_MODE_SIZE ((MODE)))\t\\\n+\t\t    / 4))\t\t\t\t\\\n+     : 0)\t\t\t\t\t\t\\\n+  : GET_MODE_CLASS ((MODE)) == MODE_INT\t\t\t\\\n+  ? (ROUNDUP ((CUM).ints, GET_MODE_SIZE ((MODE))) < 48\t\\\n+     ? gen_rtx (REG, (MODE),\t\t\t\t\\\n+\t\t16+(ROUNDUP ((CUM).ints,\t\t\\\n+\t\t\t     GET_MODE_SIZE ((MODE)))\t\\\n+\t\t    / 4))\t\t\t\t\\\n+     : 0)\t\t\t\t\t\t\\\n+  : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* If defined, a C expression that gives the alignment boundary, in\n+   bits, of an argument with the specified mode and type.  If it is\n+   not defined,  `PARM_BOUNDARY' is used for all arguments.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\\\n+  (((TYPE) != 0)\t\t\t\t\t\t\\\n+   ? ((TYPE_ALIGN(TYPE) <= PARM_BOUNDARY)\t\t\t\\\n+      ? PARM_BOUNDARY\t\t\t\t\t\t\\\n+      : TYPE_ALIGN(TYPE))\t\t\t\t\t\\\n+   : ((GET_MODE_ALIGNMENT(MODE) <= PARM_BOUNDARY)\t\t\\\n+      ? PARM_BOUNDARY\t\t\t\t\t\t\\\n+      : GET_MODE_ALIGNMENT(MODE)))\n+\n+/* This macro generates the assembly code for function entry.\n+\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+*/\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) function_prologue ((FILE), (SIZE))\n+\n+/* Output a no-op just before the beginning of the function,\n+   to ensure that there does not appear to be a delayed branch there.\n+   Such a thing would confuse interrupt recovery.  */\n+#define ASM_OUTPUT_FUNCTION_PREFIX(FILE,NAME) \\\n+  fprintf (FILE, \"\\tnop\\n\")\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   abort ();\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit.\n+\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.\n+*/\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) function_epilogue ((FILE), (SIZE))\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.\n+\n+   On the i860, FRAME_POINTER_REQUIRED is always 1, so the definition of this\n+   macro doesn't matter.  But it must be defined.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) \\\n+  do { (DEPTH) = 0; } while (0)\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the i860, the trampoline contains five instructions:\n+     orh #TOP_OF_FUNCTION,r0,r31\n+     or #BOTTOM_OF_FUNCTION,r31,r31\n+     orh #TOP_OF_STATIC,r0,r29\n+     bri r31\n+     or #BOTTOM_OF_STATIC,r29,r29  */\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xec1f0000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xe7ff0000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xec1d0000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x4000f800));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xe7bd0000));\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 20\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.\n+\n+   Store hi function at +0, low function at +4,\n+   hi static at +8, low static at +16  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx low_cxt = expand_shift (RSHIFT_EXPR, SImode, CXT,\t\t\t\\\n+\t\t\t      size_int (16), 0, 0);\t\t\t\\\n+  rtx low_fn = expand_shift (RSHIFT_EXPR, SImode, FNADDR,\t\t\\\n+\t\t\t     size_int (16), 0, 0);\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 16)),\t\\\n+\t\t  gen_rtx (SUBREG, HImode, CXT));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 4)),\t\\\n+\t\t  gen_rtx (SUBREG, HImode, FNADDR));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 8)),\t\\\n+\t\t  gen_rtx (SUBREG, HImode, low_cxt));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 0)),\t\\\n+\t\t  gen_rtx (SUBREG, HImode, low_fn));\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n+#define REGNO_OK_FOR_FP_P(REGNO) \\\n+(((REGNO) ^ 0x20) < 32 || (unsigned) (reg_renumber[REGNO] ^ 0x20) < 32)\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+\n+   These macros are specific to the i860, and may be used only\n+   in code for printing assembler insns and in conditions for\n+   define_optimization.  */\n+\n+/* 1 if X is an fp register.  */\n+\n+#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+\n+   On the Sparc, this is anything but a CONST_DOUBLE.\n+   Let's try permitting CONST_DOUBLEs and see what happens.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) (((unsigned) REGNO (X)) - 32 >= 14)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) (((unsigned) REGNO (X)) - 32 >= 14)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the i860, the actual addresses must be REG+REG or REG+SMALLINT.\n+   But we can treat a SYMBOL_REF as legitimate if it is part of this\n+   function's constant-pool, because such addresses can actually\n+   be output as REG+SMALLINT.\n+\n+   The displacement in an address must be a multiple of the alignment.\n+\n+   Try making SYMBOL_REF (and other things which are CONSTANT_ADDRESS_P)\n+   a legitimate address, regardless.  Because the only insns which can use\n+   memory are load or store insns, the added hair in the machine description\n+   is not that bad.  It should also speed up the compiler by halving the number\n+   of insns it must manage for each (MEM (SYMBOL_REF ...)) involved.  */\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+{ if (GET_CODE (X) == REG)\t\t\t\t\\\n+    { if (REG_OK_FOR_BASE_P (X)) goto ADDR; }\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n+\t      && INTVAL (XEXP (X, 1)) >= -0x8000\t\\\n+\t      && INTVAL (XEXP (X, 1)) < 0x8000\t\t\\\n+\t      && (INTVAL (XEXP (X, 1)) & (GET_MODE_SIZE (MODE) - 1)) == 0) \\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 1)) == REG\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 0)) == CONST_INT\t\\\n+\t      && INTVAL (XEXP (X, 0)) >= -0x8000\t\\\n+\t      && INTVAL (XEXP (X, 0)) < 0x8000\t\t\\\n+\t      && (INTVAL (XEXP (X, 0)) & (GET_MODE_SIZE (MODE) - 1)) == 0) \\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else if (CONSTANT_ADDRESS_P (X))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+/* On the i860, change COMPLICATED + CONSTANT to REG+CONSTANT.\n+   Also change a symbolic constant to a REG,\n+   though that may not be necessary.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n+{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) != REG\t\\\n+      && GET_CODE (XEXP (X, 0)) != CONST_INT)\t\t\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n+\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) != REG\t\\\n+      && GET_CODE (XEXP (X, 1)) != CONST_INT)\t\t\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n+  if (GET_CODE (x) == SYMBOL_REF)\t\t\t\t\\\n+    (X) = copy_to_reg (X);\t\t\t\t\t\\\n+  if (GET_CODE (x) == CONST)\t\t\t\t\t\\\n+    (X) = copy_to_reg (X);\t\t\t\t\t\\\n+  if (memory_address_p (MODE, X))\t\t\t\t\\\n+    goto WIN; }\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the i860 this is never true.\n+   There are some addresses that are invalid in wide modes\n+   but valid for narrower modes, but they shouldn't affect\n+   the places that use this macro.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Must pass floats to libgcc functions as doubles.  */\n+#define LIBGCC_NEEDS_DOUBLE 1\n+\n+#define DIVSI3_LIBCALL \"*.div\"\n+#define UDIVSI3_LIBCALL \"*.udiv\"\n+#define REMSI3_LIBCALL \"*.rem\"\n+#define UREMSI3_LIBCALL \"*.urem\"\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 16\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Value is 1 if it generates better code to perform an unsigned comparison\n+   on the given literal integer value in the given mode when we are only\n+   looking for an equal/non-equal result.  */\n+/* For the i860, if the immediate value has its high-order 27 bits zero,\n+   then we want to engineer an unsigned comparison for EQ/NE because\n+   such values can fit in the 5-bit immediate field of a bte or btne\n+   instruction (which gets zero extended before comparing).  For all\n+   other immediate values on the i860, we will use signed compares\n+   because that avoids the need for doing explicit xor's to zero_extend\n+   the non-constant operand in cases where it was (mem:QI ...) or a\n+   (mem:HI ...) which always gets automatically sign-extended by the\n+   hardware upon loading.  */\n+\n+#define LITERAL_COMPARE_BETTER_UNSIGNED(intval, mode)                   \\\n+  (((unsigned) (intval) & 0x1f) == (unsigned) (intval))\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE SImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (INTVAL (RTX) == 0)\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\\\n+    if (INTVAL (RTX) < 0x2000 && INTVAL (RTX) >= -0x2000) return 1; \\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 2;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 4;\n+\n+/* Specify the cost of a branch insn; roughly the number of extra insns that\n+   should be added to avoid a branch.\n+\n+   Set this to 3 on the i860 since branches may often take three cycles.  */\n+\n+#define BRANCH_COST 3\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+/* This holds the value sourcing h%r31.  We keep this info\n+   around so that mem/mem ops, such as increment and decrement,\n+   etc, can be performed reasonably.  */\n+#define CC_STATUS_MDEP rtx\n+\n+#define CC_STATUS_MDEP_INIT (cc_status.mdep = 0)\n+\n+#define CC_NEGATED\t01000\n+\n+/* We use this macro in those places in the i860.md file where we would\n+   normally just do a CC_STATUS_INIT (for other machines).  This macro\n+   differs from CC_STATUS_INIT in that it doesn't mess with the special\n+   bits or fields which describe what is currently in the special r31\n+   scratch register, but it does clear out everything that actually\n+   relates to the condition code bit of the i860.  */\n+\n+#define CC_STATUS_PARTIAL_INIT\t\t\t\t\t\t\\\n+ (cc_status.flags &= (CC_KNOW_HI_R31 | CC_HI_R31_ADJ),\t\t\t\\\n+  cc_status.value1 = 0,\t\t\t\t\t\t\t\\\n+  cc_status.value2 = 0)\n+\n+/* Nonzero if we know the value of h%r31.  */\n+#define CC_KNOW_HI_R31 0100000\n+\n+/* Nonzero if h%r31 is actually ha%something, rather than h%something.  */\n+#define CC_HI_R31_ADJ 0200000\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+/* On the i860, only compare insns set a useful condition code.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+{ cc_status.flags &= (CC_KNOW_HI_R31 | CC_HI_R31_ADJ);\t\\\n+  cc_status.value1 = 0; cc_status.value2 = 0; }\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Assembler pseudos to introduce constants of various size.  */\n+\n+#define ASM_BYTE_OP \"\\t.byte\"\n+#define ASM_SHORT \"\\t.short\"\n+#define ASM_LONG \"\\t.long\"\n+#define ASM_DOUBLE \"\\t.double\"\n+\n+/* Output at beginning of assembler file.  */\n+/* The .file command should always begin the output.  */\n+\n+#define ASM_FILE_START(FILE)\n+#if 0\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+  do { output_file_directive ((FILE), main_input_filename);\t\\\n+       if (optimize) ASM_FILE_START_1 (FILE);\t\t\t\\\n+     } while (0)\n+#endif\n+\n+#define ASM_FILE_START_1(FILE)\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"sp\", \"fp\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\t\t\\\n+ \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\",\t\\\n+ \"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",\t\\\n+ \"r30\", \"r31\",\t\t\t\t\t\t\t\t\\\n+ \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\",\t\t\\\n+ \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\", \"f16\", \"f17\", \"f18\", \"f19\",\t\\\n+ \"f20\", \"f21\", \"f22\", \"f23\", \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\",\t\\\n+ \"f30\", \"f31\" }\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\t\t\t\t\\\n+  do { fputs (\".globl \", FILE);\t\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.\n+\n+   This definition is overridden in i860v4.h because under System V\n+   Release 4, user-level symbols are *not* prefixed with underscores in\n+   the generated assembly code.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output an internal numbered label which\n+   labels a jump table.  */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\\\n+  fprintf (FILE, \"\\t.align\\t4\\n.%s%d:\\n\", PREFIX, NUM)\n+\n+/* Output at the end of a jump table.  */\n+\n+#define ASM_OUTPUT_CASE_END(FILE,NUM,INSN)\t\\\n+  fprintf (FILE, \".text\\n\")\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*.%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.double %.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.float %.12e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.short \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output code to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\taddu -16,%ssp,%ssp\\n\\t%sst.l %s%s,0(%ssp)\\n\",\t\\\n+\ti860_reg_prefix, i860_reg_prefix,\t\t\t\t\\\n+\t((REGNO) < 32 ? \"\" : \"f\"),\t\t\t\t\t\\\n+\ti860_reg_prefix, reg_names[REGNO],\t\t\t\t\\\n+\ti860_reg_prefix)\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t%sld.l 0(%ssp),%s%s\\n\\taddu 16,%ssp,%ssp\\n\",\t\\\n+\t((REGNO) < 32 ? \"\" : \"f\"),\t\t\t\t\t\\\n+\ti860_reg_prefix,\t\t\t\t\t\t\\\n+\ti860_reg_prefix, reg_names[REGNO],\t\t\t\t\\\n+\ti860_reg_prefix, i860_reg_prefix)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.long .L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (The i860 does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.blkb %u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+\n+   In the following comments, the term \"constant address\" is used frequently.\n+   For an exact definition of what constitutes a \"constant address\" see the\n+   output_addr_const routine in final.c\n+\n+   On the i860, the following target-specific special codes are recognized:\n+\n+\t`r'\tThe operand can be anything, but if is is an immediate zero\n+\t\tvalue (either integer or floating point) then it will be\n+\t\trepresented as `r0' or as `f0' (respectively).\n+\n+\t`m'\tThe operand is a memory ref (to a constant address) but print\n+\t\tits address as a constant.\n+\n+\t`L'\tThe operand is a numeric constant, a constant address, or\n+\t\ta memory ref to a constant address.  Print the correct\n+\t\tnotation to yield the low part of the given value or\n+\t\taddress or the low part of the address of the referred\n+\t\tto memory object.\n+\n+\t`H'\tThe operand is a numeric constant, a constant address, or\n+\t\ta memory ref to a constant address.  Print the correct\n+\t\tnotation to yield the high part of the given value or\n+\t\taddress or the high part of the address of the refered\n+\t\tto memory object.\n+\n+\t`h'\tThe operand is a numeric constant, a constant address, or\n+\t\ta memory ref to a constant address.  Either print the\n+\t\tcorrect notation to yield the plain high part of the\n+\t\tgiven value or address (or the plain high part of the\n+\t\taddress of the memory object) or else print the correct\n+\t\tnotation to yield the \"adjusted\" high part of the given\n+\t\taddress (or of the address of the referred to memory object).\n+\n+\t\tThe choice of what to print depends upon whether the address\n+\t\tin question is relocatable or not.  If it is relocatable,\n+\t\tprint the notation to get the adjusted high part.  Otherwise\n+\t\tjust print the notation to get the plain high part.  Note\n+\t\tthat \"adjusted\" high parts are generally used *only* when\n+\t\tthe next following instruction uses the low part of the\n+\t\taddress as an offset, as in `offset(reg)'.\n+\n+\t`R'\tThe operand is a floating-pointer register.  Print the\n+\t\tname of the next following (32-bit) floating-point register.\n+\t\t(This is used when moving a value into just the most\n+\t\tsignificant part of a floating-point register pair.)\n+\n+\t`?'\t(takes no operand) Substitute the value of i860_reg_prefix\n+\t\tat this point.  The value of i860_reg_prefix is typically\n+\t\ta null string for most i860 targets, but for System V\n+\t\tRelease 4 the i860 assembler syntax requires that all\n+\t\tnames of registers be prefixed with a percent-sign, so\n+\t\tfor SVR4, the value of i860_reg_prefix is initialized to\n+\t\t\"%\" in i860.c.\n+*/\n+\n+extern char *i860_reg_prefix;\n+extern unsigned long sfmode_constant_to_ulong ();\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '?')\n+\n+/* The following macro definition is overridden in i860v4.h\n+   because the svr4 i860 assembler required a different syntax\n+   for getting parts of constant/relocatable values.  */\n+\n+#define PRINT_OPERAND_PART(FILE, X, PART_CODE)\t\t\t\t\\\n+  do { fprintf (FILE, \"%s%%\", PART_CODE);\t\t\t\t\\\n+\toutput_address (X);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define OPERAND_LOW_PART\t\"l\"\n+#define OPERAND_HIGH_PART\t\"h\"\n+/* NOTE: All documentation available for the i860 sez that you must\n+   use \"ha\" to get the relocated high part of a relocatable, but\n+   reality sez different.  */\n+#define OPERAND_HIGH_ADJ_PART\t\"ha\"\n+\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n+{ if ((CODE) == '?')\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", i860_reg_prefix);\t\t\t\t\\\n+  else if (CODE == 'R')\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s%s\", i860_reg_prefix, reg_names[REGNO (X) + 1]);\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s%s\", i860_reg_prefix, reg_names[REGNO (X)]);\t\\\n+  else if ((CODE) == 'm')\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if ((CODE) == 'L')\t\t\t\t\t\t\\\n+    if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+      PRINT_OPERAND_PART (FILE, XEXP (X, 0), OPERAND_LOW_PART);\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      PRINT_OPERAND_PART (FILE, X, OPERAND_LOW_PART);\t\t\t\\\n+  else if ((CODE) == 'H')\t\t\t\t\t\t\\\n+    if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+      PRINT_OPERAND_PART (FILE, XEXP (X, 0), OPERAND_HIGH_PART);\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      PRINT_OPERAND_PART (FILE, X, OPERAND_HIGH_PART);\t\t\t\\\n+  else if ((CODE) == 'h')\t\t\t\t\t\t\\\n+    if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+      PRINT_OPERAND_PART (FILE, XEXP (X, 0),\t\t\t\t\\\n+\t\tconst_int_operand (XEXP (X, 0))\t\t\t\t\\\n+\t\t\t? OPERAND_HIGH_PART\t\t\t\t\\\n+\t\t\t: OPERAND_HIGH_ADJ_PART);\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      PRINT_OPERAND_PART (FILE, X, \t\t\t\t\t\\\n+\t\tconst_int_operand (X)\t\t\t\t\t\\\n+\t\t\t? OPERAND_HIGH_PART\t\t\t\t\\\n+\t\t\t: OPERAND_HIGH_ADJ_PART);\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if ((CODE) == 'r' && (X) == const0_rtx)\t\t\t\t\\\n+    fprintf (FILE, \"%sr0\", i860_reg_prefix);\t\t\t\t\\\n+  else if ((CODE) == 'r' && (X) == CONST0_RTX (GET_MODE (X)))\t\t\\\n+    fprintf (FILE, \"%sf0\", i860_reg_prefix);\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE)\t\t\t\t\\\n+    fprintf (FILE, \"0x%x\", sfmode_constant_to_ulong (X));\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    output_addr_const (FILE, X); }\n+\f\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx base, index = 0;\t\t\t\t\t\\\n+  int offset = 0;\t\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\\\n+  if (GET_CODE (addr) == REG)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"0(%s%s)\",\t\t\t\t\t\\\n+\ti860_reg_prefix, reg_names[REGNO (addr)]);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (addr) == CONST_DOUBLE\t\t\t\\\n+            && GET_MODE (addr) == SFmode)\t\t\t\\\n+    fprintf (FILE, \"0x%x\", sfmode_constant_to_ulong (addr));\t\\\n+  else if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((GET_CODE (XEXP (addr, 0)) == CONST_INT)\t\t\\\n+\t  && (GET_CODE (XEXP (addr, 1)) == REG))\t\t\\\n+\tfprintf (FILE, \"%d(%s%s)\", INTVAL (XEXP (addr, 0)),\t\\\n+\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 1))]);\\\n+      else if ((GET_CODE (XEXP (addr, 1)) == CONST_INT)\t\t\\\n+\t  && (GET_CODE (XEXP (addr, 0)) == REG))\t\t\\\n+\tfprintf (FILE, \"%d(%s%s)\", INTVAL (XEXP (addr, 1)),\t\\\n+\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 0))]);\\\n+      else if ((GET_CODE (XEXP (addr, 0)) == REG)\t\t\\\n+\t  && (GET_CODE (XEXP (addr, 1)) == REG))\t\t\\\n+\tfprintf (FILE, \"%s%s(%s%s)\",\t\t\t\t\\\n+\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 0))],\t\\\n+\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 1))]);\\\n+      else\t\t\t\t\t\t\t\\\n+\toutput_addr_const (FILE, addr);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      output_addr_const (FILE, addr);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* The following #defines are used when compiling the routines in\n+   libgcc1.c.  Since the i860 calling conventions require single\n+   precision floats to be passed in the floating-point registers\n+   (rather than in the general registers) we have to build the\n+   libgcc1.c routines in such a way that they know the actual types\n+   of their formal arguments and the actual types of their return\n+   values.  Otherwise, gcc will generate calls to the libgcc1.c\n+   routines, passing argumenst in in the floating-point registers,\n+   but the libgcc1.c routines will expect their arguments on the\n+   stack (where the i860 calling conventions require structs &\n+   unions to be passed).  */\n+\n+#define FLOAT_TYPE_VALUE\tfloat\n+#define INTIFY(FLOATVAL)\t(FLOATVAL)\n+#define FLOATIFY(INTVAL)\t(INTVAL)\n+#define FLOAT_ARG_TYPE\t\tfloat\n+\n+\n+/* Optionally define this if you have added predicates to\n+   `MACHINE.c'.  This macro is called within an initializer of an\n+   array of structures.  The first field in the structure is the\n+   name of a predicate and the second field is an arrary of rtl\n+   codes.  For each predicate, list all rtl codes that can be in\n+   expressions matched by the predicate.  The list should have a\n+   trailing comma.  Here is an example of two entries in the list\n+   for a typical RISC machine:\n+\n+   #define PREDICATE_CODES \\\n+     {\"gen_reg_rtx_operand\", {SUBREG, REG}},  \\\n+     {\"reg_or_short_cint_operand\", {SUBREG, REG, CONST_INT}},\n+\n+   Defining this macro does not affect the generated code (however,\n+   incorrect definitions that omit an rtl code that may be matched\n+   by the predicate can cause the compiler to malfunction). \n+   Instead, it allows the table built by `genrecog' to be more\n+   compact and efficient, thus speeding up the compiler.  The most\n+   important predicates to include in the list specified by this\n+   macro are thoses used in the most insn patterns.\n+\n+   Note that for the i860 we have one more predicate, i.e.\n+   `single_insn_src_operand', however this is used only\n+   infrequently, so we don't put in the PREDICATE_CODES list.\n+*/\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+   {\"reg_or_0_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"arith_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"logic_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"shift_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"compare_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"arith_const_operand\",\t{CONST_INT}},\t\t\t\t\\\n+   {\"logic_const_operand\",\t{CONST_INT}},\t\t\t\t\\\n+   {\"bte_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"indexed_operand\",\t\t{MEM}},\t\t\t\t\t\\\n+   {\"load_operand\",\t\t{MEM}},\n+\n+/* Define the information needed to generate branch insns.  This is stored\n+   from the compare operation.  Note that we can't use \"rtx\" here since it\n+   hasn't been defined!  */\n+\n+extern struct rtx_def *i860_compare_op0, *i860_compare_op1;\n+\n+/* Declare things which are defined in i860.c but called from\n+   insn-output.c.  */\n+\n+extern unsigned long sfmode_constant_to_ulong ();\n+extern char *output_load ();\n+extern char *output_store ();\n+extern char *output_move_double ();\n+extern char *output_fp_move_double ();\n+extern char *output_block_move ();\n+extern char *output_delay_insn ();\n+extern char *output_delayed_branch ();\n+extern void output_load_address ();"}]}