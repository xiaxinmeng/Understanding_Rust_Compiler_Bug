{"sha": "44fc7854813cc53c709920c849bc06fd0afc0ff2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRmYzc4NTQ4MTNjYzUzYzcwOTkyMGM4NDliYzA2ZmQwYWZjMGZmMg==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2016-09-21T13:03:59Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2016-09-21T13:03:59Z"}, "message": "re PR tree-optimization/77550 (std::deque with -O3 has infinite std::distance)\n\ngcc:\n2016-09-21  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR tree-optimization/77550\n        * tree-vect-stmts.c (create_array_ref): Change parameters.\n        (get_group_alias_ptr_type): New function.\n        (vectorizable_store, vectorizable_load): Use get_group_alias_ptr_type.\n\ntestsuite:\n2016-09-21  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n        \n        PR tree-optimization/77550\n        * g++.dg/pr77550.C: New test.\n\nFrom-SVN: r240313", "tree": {"sha": "7b392d8ab4b3b2daca0ad7342f20984c89554722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b392d8ab4b3b2daca0ad7342f20984c89554722"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44fc7854813cc53c709920c849bc06fd0afc0ff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fc7854813cc53c709920c849bc06fd0afc0ff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fc7854813cc53c709920c849bc06fd0afc0ff2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fc7854813cc53c709920c849bc06fd0afc0ff2/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e02fd1b7b89245001d3c582c49432c370493d3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e02fd1b7b89245001d3c582c49432c370493d3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e02fd1b7b89245001d3c582c49432c370493d3f"}], "stats": {"total": 403, "additions": 374, "deletions": 29}, "files": [{"sha": "7fb1058a69074e4d777db29a78b2bedc368765fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fc7854813cc53c709920c849bc06fd0afc0ff2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fc7854813cc53c709920c849bc06fd0afc0ff2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44fc7854813cc53c709920c849bc06fd0afc0ff2", "patch": "@@ -1,3 +1,10 @@\n+2016-09-21  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR tree-optimization/77550\n+\t* tree-vect-stmts.c (create_array_ref): Change parameters.\n+\t(get_group_alias_ptr_type): New function.\n+\t(vectorizable_store, vectorizable_load): Use get_group_alias_ptr_type.\n+\n 2016-09-21  Marek Polacek  <polacek@redhat.com>\n \n \t* gimple-ssa-sprintf.c (pass_sprintf_length::compute_format_length):"}, {"sha": "fb04ac3f74739bee4c45d582dd1c93fc7d763a53", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fc7854813cc53c709920c849bc06fd0afc0ff2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fc7854813cc53c709920c849bc06fd0afc0ff2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=44fc7854813cc53c709920c849bc06fd0afc0ff2", "patch": "@@ -1,3 +1,8 @@\n+2016-09-21  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR tree-optimization/77550\n+\t* g++.dg/pr77550.C: New test.\n+\n 2016-09-21  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/77326"}, {"sha": "d13241abb52e08452f81147744103823189e17ba", "filename": "gcc/testsuite/g++.dg/pr77550.C", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fc7854813cc53c709920c849bc06fd0afc0ff2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr77550.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fc7854813cc53c709920c849bc06fd0afc0ff2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr77550.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr77550.C?ref=44fc7854813cc53c709920c849bc06fd0afc0ff2", "patch": "@@ -0,0 +1,295 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++14 -O3\" }\n+\n+namespace std {\n+typedef int size_t;\n+inline namespace __cxx11 {}\n+template <typename...> using _Require = void;\n+template <typename> using __void_t = void;\n+template <typename, typename, template <typename...> class, typename...>\n+struct A {\n+  using type = int;\n+};\n+template <typename _Default, template <typename...> class _Op,\n+          typename... _Args>\n+struct A<_Default, __void_t<_Op<_Args...>>, _Op, _Args...> {\n+  using type = _Op<_Args...>;\n+};\n+template <typename _Default, template <typename...> class _Op,\n+          typename... _Args>\n+using __detected_or = A<_Default, void, _Op, _Args...>;\n+template <typename _Default, template <typename...> class _Op,\n+          typename... _Args>\n+using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;\n+template <template <typename...> class _Default,\n+          template <typename...> class _Op, typename... _Args>\n+using __detected_or_t_ = __detected_or_t<_Default<_Args...>, _Op, _Args...>;\n+template <typename _InputIterator> void __distance(_InputIterator p1) { ++p1; }\n+template <typename _InputIterator>\n+void distance(_InputIterator p1, _InputIterator) {\n+  __distance(p1);\n+}\n+template <typename, typename> using __replace_first_arg_t = int;\n+struct B {\n+  template <typename _Up> using rebind = _Up *;\n+};\n+template <typename, typename> using __ptr_rebind = B;\n+template <typename _Tp> _Tp max(_Tp p1, _Tp) { return p1; }\n+}\n+void *operator new(unsigned long, void *p2) { return p2; }\n+template <typename _Tp> struct C {\n+  typedef _Tp *pointer;\n+  pointer allocate(int p1) {\n+    return static_cast<_Tp *>(operator new(p1 * sizeof(_Tp)));\n+  }\n+  template <typename _Up> void construct(_Up *p1) { new (p1) _Up; }\n+};\n+namespace std {\n+template <typename _Tp> using __allocator_base = C<_Tp>;\n+template <typename _Tp> struct allocator : __allocator_base<_Tp> {\n+  typedef unsigned long size_type;\n+  template <typename _Tp1> struct rebind { typedef allocator<_Tp1> other; };\n+};\n+struct D {\n+  template <typename _Alloc, typename _Up>\n+  using __rebind = typename _Alloc::template rebind<_Up>::other;\n+  template <typename _Tp> using __pointer = typename _Tp::pointer;\n+  template <typename _Tp> using __c_pointer = typename _Tp::const_pointer;\n+  template <typename _Tp> using __size_type = typename _Tp::size_type;\n+};\n+template <typename _Alloc, typename _Up>\n+using __alloc_rebind =\n+    __detected_or_t_<__replace_first_arg_t, D::__rebind, _Alloc, _Up>;\n+template <typename _Alloc> struct K : D {\n+  typedef _Alloc value_type;\n+  using pointer = __detected_or_t<value_type, __pointer, _Alloc>;\n+  using const_pointer =\n+      __detected_or_t<__ptr_rebind<pointer, value_type>, __c_pointer>;\n+  using size_type = __detected_or_t<int, __size_type, _Alloc>;\n+  template <typename _Tp> using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;\n+  template <typename _Tp> static _Require<> _S_construct(_Tp p1) {\n+    _Alloc __a;\n+    __a.construct(p1);\n+  }\n+  static pointer allocate(_Alloc p1, size_type p2) { return p1.allocate(p2); }\n+  template <typename _Tp, typename _Args>\n+  static auto construct(_Alloc, _Tp p2, _Args) {\n+    _S_construct(p2);\n+  }\n+};\n+}\n+template <typename _Alloc> struct O : std::K<_Alloc> {\n+  template <typename _Tp> struct rebind {\n+    typedef typename std::K<_Alloc>::template rebind_alloc<_Tp> other;\n+  };\n+};\n+namespace std {\n+template <typename _ForwardIterator, typename _Tp, typename _Allocator>\n+void __uninitialized_fill_a(_ForwardIterator p1, _ForwardIterator, _Tp,\n+                            _Allocator p4) try {\n+  O<_Allocator>::construct(p4, p1, 0);\n+} catch (...) {\n+}\n+size_t __deque_buf_size(size_t p1) { return 1 ? 512 / p1 : 0; }\n+template <typename _Tp, typename _Ref, typename> struct F {\n+  template <typename _Up> using __ptr_to = B::rebind<_Up>;\n+  template <typename _CvTp> using __iter = F<_Tp, _CvTp &, __ptr_to<_CvTp>>;\n+  typedef __ptr_to<_Tp> _Elt_pointer;\n+  typedef __ptr_to<_Elt_pointer> _Map_pointer;\n+  _Elt_pointer _M_cur;\n+  _Elt_pointer _M_first;\n+  _Elt_pointer _M_last;\n+  _Map_pointer _M_node;\n+  F() {}\n+  F(__iter<_Tp> &p1) : _M_cur(p1._M_cur), _M_node(p1._M_node) {}\n+  _Ref operator*() { return *_M_cur; }\n+  void operator++() {\n+    _M_set_node(_M_node + 1);\n+    _M_cur = _M_first;\n+  }\n+  void _M_set_node(_Map_pointer p1) {\n+    _M_node = p1;\n+    _M_first = *p1;\n+    _M_last = _M_first;\n+  }\n+};\n+template <typename _Tp, typename _Ref, typename _Ptr>\n+int operator==(F<_Tp, _Ref, _Ptr> p1, F<_Tp, _Ref, _Ptr> p2) {\n+  return p1._M_cur == p2._M_cur;\n+}\n+template <typename _Tp, typename _Ref, typename _Ptr>\n+int operator!=(F<_Tp, _Ref, _Ptr> p1, F<_Tp, _Ref, _Ptr> p2) {\n+  return !(p1 == p2);\n+}\n+template <typename _Tp, typename _Alloc> struct _Deque_base {\n+  typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;\n+  typedef O<_Tp_alloc_type> _Alloc_traits;\n+  typedef typename _Alloc_traits::pointer _Ptr;\n+  typedef typename _Alloc_traits::template rebind<_Ptr>::other _Map_alloc_type;\n+  typedef F<_Tp, _Tp &, _Ptr> iterator;\n+  typedef F<_Tp, _Tp &, typename _Alloc_traits::const_pointer> const_iterator;\n+  _Deque_base(_Alloc p1, size_t) : _M_impl(p1) { _M_initialize_map(0); }\n+  ~_Deque_base() noexcept;\n+  typedef typename iterator::_Map_pointer _Map_pointer;\n+  struct L : _Tp_alloc_type {\n+    _Map_pointer _M_map;\n+    size_t _M_map_size;\n+    iterator _M_start;\n+    iterator _M_finish;\n+    L(_Tp_alloc_type) {}\n+  };\n+  _Tp_alloc_type _M_get_Tp_allocator() { return _M_impl; }\n+  _Ptr _M_allocate_node() { return O<_Tp_alloc_type>::allocate(_M_impl, 1); }\n+  _Map_pointer _M_allocate_map(size_t p1) {\n+    _Map_alloc_type __map_alloc;\n+    return O<_Map_alloc_type>::allocate(__map_alloc, p1);\n+  }\n+  void _M_initialize_map(size_t);\n+  void _M_create_nodes(_Map_pointer, _Map_pointer);\n+  enum { _S_initial_map_size = 8 };\n+  L _M_impl;\n+};\n+template <typename _Tp, typename _Alloc>\n+_Deque_base<_Tp, _Alloc>::~_Deque_base() noexcept {}\n+template <typename _Tp, typename _Alloc>\n+void _Deque_base<_Tp, _Alloc>::_M_initialize_map(size_t) {\n+  size_t __num_nodes(__deque_buf_size(sizeof(_Tp)));\n+  _M_impl._M_map_size = max((size_t)_S_initial_map_size, 0);\n+  _M_impl._M_map = _M_allocate_map(_M_impl._M_map_size);\n+  _Map_pointer __nstart(_M_impl._M_map);\n+  _Map_pointer __nfinish = __nstart + __num_nodes;\n+  try {\n+    _M_create_nodes(__nstart, __nfinish);\n+  } catch (...) {\n+  }\n+  _M_impl._M_start._M_set_node(__nstart);\n+  _M_impl._M_finish._M_set_node(__nfinish - 1);\n+  _M_impl._M_start._M_cur = _M_impl._M_start._M_first;\n+  _M_impl._M_finish._M_cur = _M_impl._M_finish._M_first;\n+}\n+template <typename _Tp, typename _Alloc>\n+void _Deque_base<_Tp, _Alloc>::_M_create_nodes(_Map_pointer __nstart,\n+                                               _Map_pointer __nfinish) {\n+  _Map_pointer __cur;\n+  try {\n+    for (__cur = __nstart; __cur < __nfinish; ++__cur)\n+      *__cur = _M_allocate_node();\n+  } catch (...) {\n+  }\n+}\n+template <typename _Tp, typename _Alloc = allocator<_Tp>>\n+struct deque : _Deque_base<_Tp, _Alloc> {\n+  typedef _Deque_base<_Tp, _Alloc> _Base;\n+  typedef typename _Base::_Map_pointer _Map_pointer;\n+  typedef _Tp value_type;\n+  typedef typename _Base::const_iterator const_iterator;\n+  typedef size_t size_type;\n+  typedef _Alloc allocator_type;\n+  using _Base::_M_get_Tp_allocator;\n+  deque(size_type, value_type __value, allocator_type __a = allocator_type())\n+      : _Base(__a, 0) {\n+    _M_fill_initialize(__value);\n+  }\n+  const_iterator begin() { return this->_M_impl._M_start; }\n+  const_iterator end() { return this->_M_impl._M_finish; }\n+  void _M_fill_initialize(const value_type &);\n+};\n+template <typename _Container> auto begin(_Container p1) { return p1.begin(); }\n+template <typename _Container> auto end(_Container p1) { return p1.end(); }\n+template <typename _Container> auto cbegin(_Container p1) { return begin(p1); }\n+template <typename _Container> auto cend(_Container p1) { return end(p1); }\n+template <typename _Tp, typename _Alloc>\n+void deque<_Tp, _Alloc>::_M_fill_initialize(const value_type &) {\n+  _Map_pointer __cur;\n+  try {\n+    for (__cur = this->_M_impl._M_start._M_node;\n+         __cur < this->_M_impl._M_finish._M_node; ++__cur)\n+      __uninitialized_fill_a(*__cur, *__cur, 0, _M_get_Tp_allocator());\n+  } catch (...) {\n+  }\n+}\n+template <class> struct char_traits;\n+namespace __cxx11 {\n+template <typename _CharT, typename = char_traits<_CharT>,\n+          typename = allocator<_CharT>>\n+struct basic_string;\n+typedef basic_string<char> string;\n+}\n+template <> struct char_traits<char> {\n+  typedef char char_type;\n+  static int compare(char_type, char_type *p2, size_t p3) {\n+    return __builtin_memcmp(0, p2, p3);\n+  }\n+};\n+namespace __cxx11 {\n+template <typename, typename, typename> struct basic_string {\n+  typedef O<allocator<char>> _Alloc_traits;\n+  typedef _Alloc_traits::size_type size_type;\n+  typedef _Alloc_traits::pointer pointer;\n+  struct _Alloc_hider {\n+    _Alloc_hider(pointer, allocator<char> && = allocator<char>());\n+  } _M_dataplus;\n+  size_type _M_string_length;\n+  enum { _S_local_capacity = 15 } _M_local_buf[_S_local_capacity];\n+  pointer _M_local_data();\n+  void _M_set_length(size_type);\n+  basic_string() : _M_dataplus(_M_local_data()) { _M_set_length(0); }\n+  basic_string(const basic_string &) : _M_dataplus(0) {}\n+  size_type size() { return _M_string_length; }\n+  char *data() const {}\n+};\n+}\n+template <typename _CharT>\n+int operator==(basic_string<_CharT> &p1, const basic_string<_CharT> &p2) {\n+  return p1.size() && char_traits<_CharT>::compare(0, p2.data(), p1.size());\n+}\n+}\n+struct G {\n+  template <class Facade> static void increment(Facade p1) { p1.increment(); }\n+};\n+template <class Derived> struct H {\n+  Derived derived() { return *static_cast<Derived *>(this); }\n+  void operator++() {\n+    Derived __trans_tmp_1 = derived();\n+    G::increment(__trans_tmp_1);\n+  }\n+};\n+template <class Derived> struct I { typedef H<Derived> type; };\n+template <class Derived, class Base> struct M : I<Derived>::type {\n+  M(Base p1) : m_iterator(p1) {}\n+  Base base() { return m_iterator; }\n+  Base &base_reference() { return m_iterator; }\n+  Base m_iterator;\n+};\n+template <class, class> struct N;\n+template <class Predicate, class Iterator> struct J {\n+  typedef M<N<Predicate, Iterator>, Iterator> type;\n+};\n+template <class Predicate, class Iterator>\n+struct N : J<Predicate, Iterator>::type {\n+  typedef typename J<Predicate, Iterator>::type super_t;\n+  N(Predicate p1, Iterator p2, Iterator p3)\n+      : super_t(p2), m_predicate(p1), m_end(p3) {}\n+  void increment() {\n+    while (this->base() != m_end && !m_predicate(*this->base()))\n+      ++this->base_reference();\n+  }\n+  Predicate m_predicate;\n+  Iterator m_end;\n+};\n+template <class Predicate, class Iterator>\n+N<Predicate, Iterator> make_filter_iterator(Predicate p1, Iterator p2,\n+                                            Iterator p3) {\n+  return N<Predicate, Iterator>(p1, p2, p3);\n+}\n+struct Foo {\n+  std::string bar;\n+};\n+int main() {\n+  std::deque<Foo> foos(0, {});\n+  std::string test;\n+  auto p = [test](auto &foo) { return foo.bar == test; };\n+  auto begin = make_filter_iterator(p, cbegin(foos), cend(foos));\n+  auto end = make_filter_iterator(p, cend(foos), cend(foos));\n+  distance(begin, end);\n+}"}, {"sha": "dbbd731a12dd044340468bcd8d909dfe91b298fb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 67, "deletions": 29, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fc7854813cc53c709920c849bc06fd0afc0ff2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fc7854813cc53c709920c849bc06fd0afc0ff2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=44fc7854813cc53c709920c849bc06fd0afc0ff2", "patch": "@@ -170,11 +170,10 @@ write_vector_array (gimple *stmt, gimple_stmt_iterator *gsi, tree vect,\n    (and its group).  */\n \n static tree\n-create_array_ref (tree type, tree ptr, struct data_reference *first_dr)\n+create_array_ref (tree type, tree ptr, tree alias_ptr_type)\n {\n-  tree mem_ref, alias_ptr_type;\n+  tree mem_ref;\n \n-  alias_ptr_type = reference_alias_ptr_type (DR_REF (first_dr));\n   mem_ref = build2 (MEM_REF, type, ptr, build_int_cst (alias_ptr_type, 0));\n   /* Arrays have the same alignment as their type.  */\n   set_ptr_info_alignment (get_ptr_info (ptr), TYPE_ALIGN_UNIT (type), 0);\n@@ -5432,6 +5431,35 @@ ensure_base_align (stmt_vec_info stmt_info, struct data_reference *dr)\n }\n \n \n+/* Function get_group_alias_ptr_type.\n+\n+   Return the alias type for the group starting at FIRST_STMT.  */\n+\n+static tree\n+get_group_alias_ptr_type (gimple *first_stmt)\n+{\n+  struct data_reference *first_dr, *next_dr;\n+  gimple *next_stmt;\n+\n+  first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (first_stmt));\n+  while (next_stmt)\n+    {\n+      next_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (next_stmt));\n+      if (get_alias_set (DR_REF (first_dr))\n+\t  != get_alias_set (DR_REF (next_dr)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"conflicting alias set types.\\n\");\n+\t  return ptr_type_node;\n+\t}\n+      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+    }\n+  return reference_alias_ptr_type (DR_REF (first_dr));\n+}\n+\n+\n /* Function vectorizable_store.\n \n    Check if STMT defines a non scalar data-ref (array/pointer/structure) that\n@@ -5482,6 +5510,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   gimple *new_stmt;\n   int vf;\n   vec_load_store_type vls_type;\n+  tree ref_type;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -5771,12 +5800,15 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n         /* VEC_NUM is the number of vect stmts to be created for this \n            group.  */\n \tvec_num = group_size;\n+\n+      ref_type = get_group_alias_ptr_type (first_stmt);\n     }\n   else\n     {\n       first_stmt = stmt;\n       first_dr = dr;\n       group_size = vec_num = 1;\n+      ref_type = reference_alias_ptr_type (DR_REF (first_dr));\n     }\n \n   if (dump_enabled_p ())\n@@ -5804,7 +5836,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    (unshare_expr (DR_BASE_ADDRESS (first_dr)),\n \t     size_binop (PLUS_EXPR,\n \t\t\t convert_to_ptrofftype (unshare_expr (DR_OFFSET (first_dr))),\n-\t\t\t convert_to_ptrofftype (DR_INIT(first_dr))));\n+\t\t\t convert_to_ptrofftype (DR_INIT (first_dr))));\n       stride_step = fold_convert (sizetype, unshare_expr (DR_STEP (first_dr)));\n \n       /* For a store with loop-invariant (but other than power-of-2)\n@@ -5865,7 +5897,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n \n       prev_stmt_info = NULL;\n-      alias_off = build_int_cst (reference_alias_ptr_type (DR_REF (first_dr)), 0);\n+      alias_off = build_int_cst (ref_type, 0);\n       next_stmt = first_stmt;\n       for (g = 0; g < group_size; g++)\n \t{\n@@ -6081,11 +6113,10 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      && integer_zerop (DR_OFFSET (first_dr))\n \t      && integer_zerop (DR_INIT (first_dr))\n \t      && alias_sets_conflict_p (get_alias_set (aggr_type),\n-\t\t\t\t\tget_alias_set (DR_REF (first_dr))))\n+\t\t\t\t\tget_alias_set (TREE_TYPE (ref_type))))\n \t    {\n \t      dataref_ptr = unshare_expr (DR_BASE_ADDRESS (first_dr));\n-\t      dataref_offset = build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t      (DR_REF (first_dr)), 0);\n+\t      dataref_offset = build_int_cst (ref_type, 0);\n \t      inv_p = false;\n \t    }\n \t  else\n@@ -6136,7 +6167,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  /* Emit:\n \t       MEM_REF[...all elements...] = STORE_LANES (VEC_ARRAY).  */\n-\t  data_ref = create_array_ref (aggr_type, dataref_ptr, first_dr);\n+\t  data_ref = create_array_ref (aggr_type, dataref_ptr, ref_type);\n \t  new_stmt = gimple_build_call_internal (IFN_STORE_LANES, 1, vec_array);\n \t  gimple_call_set_lhs (new_stmt, data_ref);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -6174,8 +6205,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t      dataref_ptr,\n \t\t\t\t      dataref_offset\n \t\t\t\t      ? dataref_offset\n-\t\t\t\t      : build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t\t       (DR_REF (first_dr)), 0));\n+\t\t\t\t      : build_int_cst (ref_type, 0));\n \t      align = TYPE_ALIGN_UNIT (vectype);\n \t      if (aligned_access_p (first_dr))\n \t\tmisalign = 0;\n@@ -6395,7 +6425,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree dataref_offset = NULL_TREE;\n   gimple *ptr_incr = NULL;\n   int ncopies;\n-  int i, j, group_size = -1, group_gap_adj;\n+  int i, j, group_size, group_gap_adj;\n   tree msq = NULL_TREE, lsq;\n   tree offset = NULL_TREE;\n   tree byte_offset = NULL_TREE;\n@@ -6417,6 +6447,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree aggr_type;\n   gather_scatter_info gs_info;\n   vec_info *vinfo = stmt_info->vinfo;\n+  tree ref_type;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -6773,10 +6804,19 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       gcc_assert (!nested_in_vect_loop);\n \n       if (slp && grouped_load)\n-\tfirst_dr = STMT_VINFO_DATA_REF\n-\t    (vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info)));\n+\t{\n+\t  first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+\t  first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+\t  group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+\t  ref_type = get_group_alias_ptr_type (first_stmt);\n+\t}\n       else\n-\tfirst_dr = dr;\n+\t{\n+\t  first_stmt = stmt;\n+\t  first_dr = dr;\n+\t  group_size = 1;\n+\t  ref_type = reference_alias_ptr_type (DR_REF (first_dr));\n+\t}\n \n       stride_base\n \t= fold_build_pointer_plus\n@@ -6820,7 +6860,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       prev_stmt_info = NULL;\n       running_off = offvar;\n-      alias_off = build_int_cst (reference_alias_ptr_type (DR_REF (first_dr)), 0);\n+      alias_off = build_int_cst (ref_type, 0);\n       int nloads = nunits;\n       int lnel = 1;\n       tree ltype = TREE_TYPE (vectype);\n@@ -6917,6 +6957,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (grouped_load)\n     {\n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       /* For SLP vectorization we directly vectorize a subchain\n          without permutation.  */\n       if (slp && ! SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n@@ -6942,7 +6983,6 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  return true;\n \t}\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       group_gap_adj = 0;\n \n       /* VEC_NUM is the number of vect stmts to be created for this group.  */\n@@ -6960,13 +7000,16 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     \t}\n       else\n \tvec_num = group_size;\n+\n+      ref_type = get_group_alias_ptr_type (first_stmt);\n     }\n   else\n     {\n       first_stmt = stmt;\n       first_dr = dr;\n       group_size = vec_num = 1;\n       group_gap_adj = 0;\n+      ref_type = reference_alias_ptr_type (DR_REF (first_dr));\n     }\n \n   alignment_support_scheme = vect_supportable_dr_alignment (first_dr, false);\n@@ -7127,13 +7170,12 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      && integer_zerop (DR_OFFSET (first_dr))\n \t      && integer_zerop (DR_INIT (first_dr))\n \t      && alias_sets_conflict_p (get_alias_set (aggr_type),\n-\t\t\t\t\tget_alias_set (DR_REF (first_dr)))\n+\t\t\t\t\tget_alias_set (TREE_TYPE (ref_type)))\n \t      && (alignment_support_scheme == dr_aligned\n \t\t  || alignment_support_scheme == dr_unaligned_supported))\n \t    {\n \t      dataref_ptr = unshare_expr (DR_BASE_ADDRESS (first_dr));\n-\t      dataref_offset = build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t      (DR_REF (first_dr)), 0);\n+\t      dataref_offset = build_int_cst (ref_type, 0);\n \t      inv_p = false;\n \t    }\n \t  else if (first_stmt_for_drptr\n@@ -7179,7 +7221,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  /* Emit:\n \t       VEC_ARRAY = LOAD_LANES (MEM_REF[...all elements...]).  */\n-\t  data_ref = create_array_ref (aggr_type, dataref_ptr, first_dr);\n+\t  data_ref = create_array_ref (aggr_type, dataref_ptr, ref_type);\n \t  new_stmt = gimple_build_call_internal (IFN_LOAD_LANES, 1, data_ref);\n \t  gimple_call_set_lhs (new_stmt, vec_array);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -7215,8 +7257,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      = fold_build2 (MEM_REF, vectype, dataref_ptr,\n \t\t\t\t     dataref_offset\n \t\t\t\t     ? dataref_offset\n-\t\t\t\t     : build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t\t      (DR_REF (first_dr)), 0));\n+\t\t\t\t     : build_int_cst (ref_type, 0));\n \t\t    align = TYPE_ALIGN_UNIT (vectype);\n \t\t    if (alignment_support_scheme == dr_aligned)\n \t\t      {\n@@ -7272,8 +7313,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t    data_ref\n \t\t      = build2 (MEM_REF, vectype, ptr,\n-\t\t\t\tbuild_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t\t (DR_REF (first_dr)), 0));\n+\t\t\t\tbuild_int_cst (ref_type, 0));\n \t\t    vec_dest = vect_create_destination_var (scalar_dest,\n \t\t\t\t\t\t\t    vectype);\n \t\t    new_stmt = gimple_build_assign (vec_dest, data_ref);\n@@ -7298,8 +7338,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t    data_ref\n \t\t      = build2 (MEM_REF, vectype, ptr,\n-\t\t\t\tbuild_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t\t (DR_REF (first_dr)), 0));\n+\t\t\t\tbuild_int_cst (ref_type, 0));\n \t\t    break;\n \t\t  }\n \t\tcase dr_explicit_realign_optimized:\n@@ -7315,8 +7354,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  data_ref\n \t\t    = build2 (MEM_REF, vectype, new_temp,\n-\t\t\t      build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t       (DR_REF (first_dr)), 0));\n+\t\t\t      build_int_cst (ref_type, 0));\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();"}]}