{"sha": "e881bb1b1b60bca2b51088b8c6946feb96b0047f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg4MWJiMWIxYjYwYmNhMmI1MTA4OGI4YzY5NDZmZWI5NmIwMDQ3Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-02-25T23:45:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-02-25T23:45:42Z"}, "message": "Flow rewrite to use basic block structures and edge lists.\n\nFrom-SVN: r25450", "tree": {"sha": "5f11cf1c6b61122849435f2ab564e45e67595e64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f11cf1c6b61122849435f2ab564e45e67595e64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e881bb1b1b60bca2b51088b8c6946feb96b0047f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e881bb1b1b60bca2b51088b8c6946feb96b0047f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e881bb1b1b60bca2b51088b8c6946feb96b0047f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e881bb1b1b60bca2b51088b8c6946feb96b0047f/comments", "author": null, "committer": null, "parents": [{"sha": "001e880a269a8b586ee074918b6707edb190ea7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/001e880a269a8b586ee074918b6707edb190ea7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/001e880a269a8b586ee074918b6707edb190ea7c"}], "stats": {"total": 3732, "additions": 2514, "deletions": 1218}, "files": [{"sha": "69d04970bb3e166674066379d856a12d4c721943", "filename": "gcc/ChangeLog", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -1,3 +1,156 @@\n+Thu Feb 25 23:43:59 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\tFlow rewrite to use basic block structures and edge lists:\n+\n+\t* basic-block.h (x_basic_block_head, x_basic_block_end): Kill.\n+\t(basic_block_computed_jump_target, basic_block_live_at_start): Kill.\n+\t(struct edge_def): New.\n+\t(struct basic_block_def): New.\n+\t(basic_block_info): New.\n+\t(BLOCK_HEAD, BLOCK_END): Update.\n+\t(ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR): New.\n+\t(uid_block_number): Kill.\n+\t(basic_block_for_insn, BLOCK_FOR_INSN): New.\n+\t(BLOCK_NUM): Update.\n+\t* flow.c (XNMALLOC): Kill.\n+\t(max_uid_for_flow): Kill.\n+\t(uid_block_number): Kill.\n+\t(uid_volatile): Turn into a bitmap.\n+\t(SET_INSN_VOLATILE): New.\n+\t(basic_block_info): New.\n+\t(entry_exit_blocks): New.\n+\t(x_basic_block_head, x_basic_block_end): Kill.\n+\t(basic_block_computed_jump_target, basic_block_live_at_start): Kill.\n+\t(flow_int_list_blocks, basic_block_succ, basic_block_pred): Kill.\n+\t(basic_block_loop_depth): Kill.\n+\t(basic_block_for_insn): New.\n+\t(find_basic_blocks): Split out initial block counting into \n+\tcount_basic_blocks.  Call functions split out of find_basic_blocks_1.\n+\t(count_basic_blocks): New.\n+\t(find_basic_blocks_1): Split out edge recognition, unreachable\n+\tblock deletion.\n+\t(create_basic_block): New.\n+\t(compute_bb_for_insn): New.\n+\t(clear_edges): New.\n+\t(free_bb_memory): Kill.\n+\t(add_edge, add_edge_to_label): Kill.\n+\t(mark_label_ref): Kill.\n+\t(make_edges): Rewrite to use edge lists.\n+\t(make_edge, make_label_edge): New.\n+\t(mark_critical_edges): New.\n+\t(split_edge, insert_insn_on_edge): New.\n+\t(commit_one_edge_insertion, commit_edge_insertions): New.\n+\t(delete_unreachable_blocks): Rewrite to use edge lists.  \n+\tSplit out EH region manipulation into delete_eh_regions.\n+\tCall tidy_fallthru_edge and merge_blocks.\n+\t(delete_eh_regions): New.\n+\t(delete_note_p): New.\n+\t(delete_insn_chain): New.\n+\t(delete_block): Split out code into delete_insn_chain and\n+\ttidy_fallthru_edge.  Update edge lists.\n+\t(expunge_block): New.\n+\t(flow_delete_insn): New?\n+\t(can_delete_label_p): New?\n+\t(merge_blocks_nomove, merge_blocks): New.\n+\t(tidy_fallthru_edge): New.\n+\t(calculate_loop_depth): New.\n+\t(life_analysis): Allocate and free uid_volatile.\n+\t(free_basic_block_vars): Update for new structures.\n+\t(record_volatile_insns): Use SET_INSN_VOLATILE.\n+\t(mark_regs_live_at_end): Tidy EXIT_IGNORE_STACK usage.\n+\t(mark_used_regs): Likewise.\n+\t(life_analysis_1): Use bb global_live_at_start, global_live_at_end, \n+\tlocal_set regsets.  Use bb->aux to store new_live_at_end.  Begin\n+\tlife propagation from EXIT_BLOCK rather than last block.  Clear\n+\tregs_ever_live after mark_regs_live_at_end.\n+\t(allocate_for_life_analysis): Update for new structures.\n+\t(propagate_block): Split out loop depth calculation to\n+\tcalculate_loop_depth.\n+\t(regno_uninitialized): Use bb->global_live_at_start.\n+\t(regno_clobbered_at_setjmp): Likewise.\n+\t(dump_bb_data): Likewise.\n+\t(find_auto_inc): Use BLOCK_FOR_INSN instead of BLOCK_NUM.\n+\t(dump_flow_info): Update for new structures.\n+\t(dump_edge_info): New.\n+\t(print_rtl_with_bb): Update for new structues.\n+\t(compute_preds_succs): Do no work -- convert edge lists.\n+\t(set_block_for_insn): From corpse of old set_block_num.\n+\t(set_block_num): Call it.\n+\n+\t* rtl.c (note_insn_name): Add NOTE_INSN_BASIC_BLOCK.\n+\t* rtl.h (rtunion_def): Add bb entry.\n+\t(NOTE_BASIC_BLOCK): New.\n+\t(NOTE_INSN_BASIC_BLOCK): New.\n+\n+\t* varray.h (varray_data_tag): Add bb entry.\n+\t(VARRAY_BB_INIT, VARRAY_BB): New.\n+\n+\t* emit-rtl.c (emit_label_before): New.\n+\n+\t* except.c (expand_rethrow): Delete insns following the call to\n+\trethrow.  Put the REG_EH_RETHROW on the call.\n+\n+\t* jump.c (returnjump_p, returnjump_p_1): New.\n+\n+\t* expr.h (nonlocal_goto_handler_labels): New declaration.\n+\t* function.c (nonlocal_goto_handler_labels): Define it.\n+\t(push_function_context_to): Save it.\n+\t(pop_function_context_from): Restore it.\n+\t(init_function_start): Clear it.\n+\t(nonlocal_label_rtx_list): Kill.\n+\t* function.h (struct function): Add storage space for it.\n+\t* stmt.c (expand_nl_handler_label): Return the new label.\n+\t(expand_nl_goto_receivers): Collect a list of them in\n+\tnonlocal_goto_handler_labels.\n+\n+\t* Makefile.in (print-rtl.o): Depend on basic-block.h.\n+\t(flow.o): Depend on tree.h and insn-flags.h.\n+\t(sched.o): Depend on tree.h and expr.h.\n+\n+\t* function.c (thread_prologue_and_epilogue_insns): Do not\n+\thalf-heartedly update bb structures.\n+\n+\t* toplev.c: Add flow2 dump as -dw.\n+\t(rest_of_compilation): Finish .greg before flow2.\n+\n+\t* graph.c (draw_edge): Handle class 3.\n+\t(print_rtl_graph_with_bb): Make abnormal edges red class 2, \n+\tchange non-fall-thru but adjacent to green class 3.  Update \n+\tto use new structures.\n+\n+\t* print-rtl.c (print_rtx): Handle NOTE_INSN_BASIC_BLOCK.\n+\n+\t* reg-stack.c (BLOCK_NUM): Convert to function.  Abort if\n+\tblock_number is -1.\n+\t(reg_to_stack): Initialize block_num to -1.\n+\n+\t* combine.c (set_nonzero_bits_and_sign_copies): Update reference\n+\tto basic_block_live_at_start to bb->global_live_at_start.\n+\t(try_combine): Likewise.\n+\t(reg_dead_at_p): Likewise.\n+\t* global.c (global_conflicts): Likewise.\n+\tHandle stack regs on all abnormal edges, not just computed jumps.\n+\t(mark_elimination): Update reference to basic_block_live_at_start.\n+\t(build_insn_chain): Likewise.\n+\t* haifa-sched.c (haifa_edge): Rename from edge for conflict.\n+\t(is_cfg_nonregular): Look at nonlocal_goto_handler_labels instead\n+\tof nonlocal_label_rtx_list.\n+\t(check_live_1): Update reference to basic_block_live_at_start.\n+\t(update_live_1): Likewise.\n+\t(find_pre_sched_live): Likewise.\n+\t(find_post_sched_live): Likewise.\n+\t* local-alloc.c (update_equiv_regs): Likewise.\n+\t(block_alloc): Likewise.\n+\t* reload1.c (reload, reload_combine): Likewise.\n+\t* regmove.c (mark_flags_life_zones): Likewise.\n+\t* resource.c (mark_target_live_regs): Likewise.\n+\t* sched.c (schedule_block): Likewise.\n+\n+\t* regclass.c (regset_release_memory): Don't free\n+\tbasic_block_live_at_start.\n+\n+\t* unroll.c (copy_loop_body): Don't duplicate NOTE_INSN_BASIC_BLOCK.\n+\n Thu Feb 25 21:32:34 1999  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* fixinc.wrap: Also handle struct queue in sys/stream.h."}, {"sha": "2052b8c42ae725f360e7471679f41371ae8764b7", "filename": "gcc/basic-block.h", "status": "modified", "additions": 76, "deletions": 25, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -21,6 +21,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"bitmap.h\"\n #include \"sbitmap.h\"\n+#include \"varray.h\"\n \n typedef bitmap regset;\t\t/* Head of register set linked list.  */\n \n@@ -95,29 +96,65 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Grow any tables needed when the number of registers is calculated\n    or extended.  For the linked list allocation, nothing needs to\n    be done, other than zero the statistics on the first allocation.  */\n-#define MAX_REGNO_REG_SET(NUM_REGS, NEW_P, RENUMBER_P)\n+#define MAX_REGNO_REG_SET(NUM_REGS, NEW_P, RENUMBER_P) \n \n-/* Number of basic blocks in the current function.  */\n+/* Control flow edge information.  */\n+typedef struct edge_def {\n+  /* Links through the predecessor and successor lists.  */\n+  struct edge_def *pred_next, *succ_next;\n \n-extern int n_basic_blocks;\n+  /* The two blocks at the ends of the edge.  */\n+  struct basic_block_def *src, *dest;\n+\n+  /* Instructions queued on the edge.  */\n+  rtx insns;\n+\n+  /* Auxiliary info specific to a pass.  */\n+  void *aux;\n \n-/* Index by basic block number, get first insn in the block.  */\n+  int flags;\t\t\t/* see EDGE_* below  */\n+  int probability;\t\t/* biased by REG_BR_PROB_BASE */\n+} *edge;\n \n-extern rtx *x_basic_block_head;\n+#define EDGE_FALLTHRU\t\t1\n+#define EDGE_CRITICAL\t\t2\n+#define EDGE_ABNORMAL\t\t4\n+#define EDGE_ABNORMAL_CALL\t8\n+#define EDGE_EH\t\t\t16\n+#define EDGE_FAKE\t\t32\n \n-/* Index by basic block number, get last insn in the block.  */\n \n-extern rtx *x_basic_block_end;\n+/* Basic block information indexed by block number.  */\n+typedef struct basic_block_def {\n+  /* The first and last insns of the block.  */\n+  rtx head, end;\n \n-/* Index by basic block number, determine whether the block can be reached\n-   through a computed jump.  */\n+  /* The edges into and out of the block.  */\n+  edge pred, succ;\n \n-extern char *basic_block_computed_jump_target;\n+  /* Liveness info.  */\n+  regset local_set;\n+  regset global_live_at_start;\n+  regset global_live_at_end;\n \n-/* Index by basic block number, get address of regset\n-   describing the registers live at the start of that block.  */\n+  /* Auxiliary info specific to a pass.  */\n+  void *aux;\n \n-extern regset *basic_block_live_at_start;\n+  /* The index of this block.  */\n+  int index;\n+  /* The loop depth of this block plus one.  */\n+  int loop_depth;\n+} *basic_block;\n+\n+/* Number of basic blocks in the current function.  */\n+\n+extern int n_basic_blocks;\n+\n+/* Index by basic block number, get basic block struct info.  */\n+\n+extern varray_type basic_block_info;\n+\n+#define BASIC_BLOCK(N)  (VARRAY_BB (basic_block_info, (N)))\n \n /* What registers are live at the setjmp call.  */\n \n@@ -177,24 +214,38 @@ extern void free_int_list               PROTO ((int_list_block **));\n \f\n /* Stuff for recording basic block info.  */\n \n-#define BLOCK_HEAD(B)      x_basic_block_head[(B)]\n-#define BLOCK_END(B)       x_basic_block_end[(B)]\n+#define BLOCK_HEAD(B)      (BASIC_BLOCK (B)->head)\n+#define BLOCK_END(B)       (BASIC_BLOCK (B)->end)\n \n /* Special block numbers [markers] for entry and exit.  */\n #define ENTRY_BLOCK (-1)\n #define EXIT_BLOCK (-2)\n \n+/* Similarly, block pointers for the edge list.  */\n+extern struct basic_block_def entry_exit_blocks[2];\n+#define ENTRY_BLOCK_PTR\t(&entry_exit_blocks[0])\n+#define EXIT_BLOCK_PTR\t(&entry_exit_blocks[1])\n+\n /* from flow.c */\n-extern void free_regset_vector PROTO ((regset *, int nelts));\n-extern int *uid_block_number;\n-#define BLOCK_NUM(INSN)    uid_block_number[INSN_UID (INSN)]\n+extern void free_regset_vector\t\tPROTO ((regset *, int nelts));\n \n-extern void dump_bb_data       PROTO ((FILE *, int_list_ptr *, int_list_ptr *,\n-\t\t\t\t       int));\n-extern void free_bb_mem        PROTO ((void));\n+extern varray_type basic_block_for_insn;\n+#define BLOCK_FOR_INSN(INSN)  VARRAY_BB (basic_block_for_insn, INSN_UID (INSN))\n+#define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n+\n+extern void set_block_for_insn\t\tPROTO ((rtx, basic_block));\n+\n+extern void dump_bb_data\t\tPROTO ((FILE *, int_list_ptr *,\n+\t\t\t\t\t\tint_list_ptr *, int));\n+extern void free_bb_mem\t\t\tPROTO ((void));\n extern void free_basic_block_vars\tPROTO ((int));\n \n-extern void compute_preds_succs PROTO ((int_list_ptr *, int_list_ptr *,\n-                                        int *, int *));\n-extern void compute_dominators PROTO ((sbitmap *, sbitmap *,\n-\t\t\t\t       int_list_ptr *, int_list_ptr *));\n+extern basic_block split_edge\t\tPROTO ((edge));\n+extern void insert_insn_on_edge\t\tPROTO ((rtx, edge));\n+extern void commit_edge_insertions\tPROTO ((void));\n+\n+extern void compute_preds_succs\t\tPROTO ((int_list_ptr *, int_list_ptr *,\n+\t\t\t\t\t\tint *, int *));\n+extern void compute_dominators\t\tPROTO ((sbitmap *, sbitmap *,\n+\t\t\t\t\t\tint_list_ptr *,\n+\t\t\t\t\t\tint_list_ptr *));"}, {"sha": "549e0bf4ed213e421b1b3ed0804052179803cd81", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -744,7 +744,7 @@ set_nonzero_bits_and_sign_copies (x, set)\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       /* If this register is undefined at the start of the file, we can't\n \t say what its contents were.  */\n-      && ! REGNO_REG_SET_P (basic_block_live_at_start[0], REGNO (x))\n+      && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, REGNO (x))\n       && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n@@ -2490,7 +2490,8 @@ try_combine (i3, i2, i1)\n \t    regno = REGNO (i2dest);\n \t    REG_N_SETS (regno)--;\n \t    if (REG_N_SETS (regno) == 0\n-\t\t&& ! REGNO_REG_SET_P (basic_block_live_at_start[0], regno))\n+\t\t&& ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,\n+\t\t\t\t      regno))\n \t      REG_N_REFS (regno) = 0;\n \t  }\n       }\n@@ -2512,7 +2513,8 @@ try_combine (i3, i2, i1)\n \t  {\n \t    REG_N_SETS (regno)--;\n \t    if (REG_N_SETS (regno) == 0\n-\t\t&& ! REGNO_REG_SET_P (basic_block_live_at_start[0], regno))\n+\t\t&& ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,\n+\t\t\t\t      regno))\n \t      REG_N_REFS (regno) = 0;\n \t  }\n       }\n@@ -11038,7 +11040,7 @@ reg_dead_at_p (reg, insn)\n     }\n \n   for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n-    if (REGNO_REG_SET_P (basic_block_live_at_start[block], i))\n+    if (REGNO_REG_SET_P (BASIC_BLOCK (block)->global_live_at_start, i))\n       return 0;\n \n   return 1;"}, {"sha": "c7ff5969f2d6800edd637d89a2562a9d239e34a7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -2710,7 +2710,7 @@ emit_call_insn_before (pattern, before)\n }\n \n /* Make an insn of code BARRIER\n-   and output it before the insn AFTER.  */\n+   and output it before the insn BEFORE.  */\n \n rtx\n emit_barrier_before (before)\n@@ -2724,6 +2724,23 @@ emit_barrier_before (before)\n   return insn;\n }\n \n+/* Emit the label LABEL before the insn BEFORE.  */\n+\n+rtx\n+emit_label_before (label, before)\n+     rtx label, before;\n+{\n+  /* This can be called twice for the same label as a result of the\n+     confusion that follows a syntax error!  So make it harmless.  */\n+  if (INSN_UID (label) == 0)\n+    {\n+      INSN_UID (label) = cur_insn_uid++;\n+      add_insn_before (label, before);\n+    }\n+\n+  return label;\n+}\n+\n /* Emit a note of subtype SUBTYPE before the insn BEFORE.  */\n \n rtx"}, {"sha": "6e126fb631ded0b641e2cef4ae77ee6af8659114", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -1967,11 +1967,17 @@ expand_rethrow (label)\n           label = last_rethrow_symbol;\n         emit_library_call (rethrow_libfunc, 0, VOIDmode, 1, label, Pmode);\n         SYMBOL_REF_USED (label) = 1;\n+\n+\t/* Search backwards for the actual call insn.  */\n         insn = get_last_insn ();\n-        val = GEN_INT (eh_region_from_symbol (label));\n+\twhile (GET_CODE (insn) != CALL_INSN)\n+\t  insn = PREV_INSN (insn);\n+\tdelete_insns_since (insn);\n+\t\n         /* Mark the label/symbol on the call. */\n+        val = GEN_INT (eh_region_from_symbol (label));\n         REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EH_RETHROW, val,\n-                                     REG_NOTES (insn));\n+\t\t\t\t\t      REG_NOTES (insn));\n         emit_barrier ();\n       }\n     else"}, {"sha": "5b87b396631323f776fde6f6c9300dd91baa2133", "filename": "gcc/flow.c", "status": "modified", "additions": 1879, "deletions": 984, "changes": 2863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f"}, {"sha": "79ca24deffaf949ba1168bb8e1b0095b6e066128", "filename": "gcc/function.c", "status": "modified", "additions": 148, "deletions": 83, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -262,6 +262,11 @@ tree nonlocal_labels;\n \n rtx nonlocal_goto_handler_slots;\n \n+/* List (chain of EXPR_LIST) of labels heading the current handlers for\n+   nonlocal gotos.  */\n+\n+rtx nonlocal_goto_handler_labels;\n+\n /* RTX for stack slot that holds the stack pointer value to restore\n    for a nonlocal goto.\n    Zero when function does not have nonlocal labels.  */\n@@ -559,6 +564,7 @@ push_function_context_to (context)\n   p->outgoing_args_size = current_function_outgoing_args_size;\n   p->return_rtx = current_function_return_rtx;\n   p->nonlocal_goto_handler_slots = nonlocal_goto_handler_slots;\n+  p->nonlocal_goto_handler_labels = nonlocal_goto_handler_labels;\n   p->nonlocal_goto_stack_level = nonlocal_goto_stack_level;\n   p->nonlocal_labels = nonlocal_labels;\n   p->cleanup_label = cleanup_label;\n@@ -644,6 +650,7 @@ pop_function_context_from (context)\n   current_function_outgoing_args_size = p->outgoing_args_size;\n   current_function_return_rtx = p->return_rtx;\n   nonlocal_goto_handler_slots = p->nonlocal_goto_handler_slots;\n+  nonlocal_goto_handler_labels = p->nonlocal_goto_handler_labels;\n   nonlocal_goto_stack_level = p->nonlocal_goto_stack_level;\n   nonlocal_labels = p->nonlocal_labels;\n   cleanup_label = p->cleanup_label;\n@@ -3852,21 +3859,6 @@ delete_handlers ()\n \t}\n     }\n }\n-\n-/* Return a list (chain of EXPR_LIST nodes) for the nonlocal labels\n-   of the current function.  */\n-\n-rtx\n-nonlocal_label_rtx_list ()\n-{\n-  tree t;\n-  rtx x = 0;\n-\n-  for (t = nonlocal_labels; t; t = TREE_CHAIN (t))\n-    x = gen_rtx_EXPR_LIST (VOIDmode, label_rtx (TREE_VALUE (t)), x);\n-\n-  return x;\n-}\n \f\n /* Output a USE for any register use in RTL.\n    This is used with -noreg to mark the extent of lifespan\n@@ -5644,6 +5636,7 @@ init_function_start (subr, filename, line)\n \n   /* No labels have been declared for nonlocal use.  */\n   nonlocal_labels = 0;\n+  nonlocal_goto_handler_labels = 0;\n \n   /* No function calls so far in this function.  */\n   function_call_count = 0;\n@@ -6438,100 +6431,172 @@ contains (insn, vec)\n \n void\n thread_prologue_and_epilogue_insns (f)\n-     rtx f ATTRIBUTE_UNUSED;\n+     rtx f;\n {\n+  int insertted = 0;\n+\n+  prologue = 0;\n #ifdef HAVE_prologue\n   if (HAVE_prologue)\n     {\n-      rtx head, seq;\n-\n-      /* The first insn (a NOTE_INSN_DELETED) is followed by zero or more\n-\t prologue insns and a NOTE_INSN_PROLOGUE_END.  */\n-      emit_note_after (NOTE_INSN_PROLOGUE_END, f);\n-      seq = gen_prologue ();\n-      head = emit_insn_after (seq, f);\n+      rtx seq;\n \n-      /* Include the new prologue insns in the first block.  Ignore them\n-\t if they form a basic block unto themselves.  */\n-      if (x_basic_block_head && n_basic_blocks\n-\t  && GET_CODE (BLOCK_HEAD (0)) != CODE_LABEL)\n-\tBLOCK_HEAD (0) = NEXT_INSN (f);\n+      start_sequence ();\n+      seq = gen_prologue();\n+      emit_insn (seq);\n \n       /* Retain a map of the prologue insns.  */\n-      prologue = record_insns (GET_CODE (seq) == SEQUENCE ? seq : head);\n+      if (GET_CODE (seq) != SEQUENCE)\n+\tseq = get_insns ();\n+      prologue = record_insns (seq);\n+\n+      emit_note (NULL, NOTE_INSN_PROLOGUE_END);\n+      seq = gen_sequence ();\n+      end_sequence ();\n+\n+      /* If optimization is off, and perhaps in an empty function,\n+\t the entry block will have no successors.  */\n+      if (ENTRY_BLOCK_PTR->succ)\n+\t{\n+\t  /* Can't deal with multiple successsors of the entry block.  */\n+\t  if (ENTRY_BLOCK_PTR->succ->succ_next)\n+\t    abort ();\n+\n+\t  insert_insn_on_edge (seq, ENTRY_BLOCK_PTR->succ);\n+\t  insertted = 1;\n+\t}\n+      else\n+\temit_insn_after (seq, f);\n     }\n-  else\n #endif\n-    prologue = 0;\n \n+  epilogue = 0;\n #ifdef HAVE_epilogue\n   if (HAVE_epilogue)\n     {\n-      rtx insn = get_last_insn ();\n-      rtx prev = prev_nonnote_insn (insn);\n+      edge e;\n+      basic_block bb = 0;\n+      rtx tail = get_last_insn ();\n+\n+      /* ??? This is gastly.  If function returns were not done via uses,\n+\t but via mark_regs_live_at_end, we could use insert_insn_on_edge\n+\t and all of this uglyness would go away.  */\n \n-      /* If we end with a BARRIER, we don't need an epilogue.  */\n-      if (! (prev && GET_CODE (prev) == BARRIER))\n+      switch (optimize)\n \t{\n-\t  rtx tail, seq, tem;\n-\t  rtx first_use = 0;\n-\t  rtx last_use = 0;\n-\n-\t  /* The last basic block ends with a NOTE_INSN_EPILOGUE_BEG, the\n-\t     epilogue insns, the USE insns at the end of a function,\n-\t     the jump insn that returns, and then a BARRIER.  */\n-\n-\t  /* Move the USE insns at the end of a function onto a list.  */\n-\t  while (prev\n-\t\t && GET_CODE (prev) == INSN\n-\t\t && GET_CODE (PATTERN (prev)) == USE)\n-\t    {\n-\t      tem = prev;\n+\tdefault:\n+\t  /* If the exit block has no non-fake predecessors, we don't\n+\t     need an epilogue.  Furthermore, only pay attention to the\n+\t     fallthru predecessors; if (conditional) return insns were\n+\t     generated, by definition we do not need to emit epilogue\n+\t     insns.  */\n+\n+\t  for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+\t    if ((e->flags & EDGE_FAKE) == 0\n+\t\t&& (e->flags & EDGE_FALLTHRU) != 0)\n+\t      break;\n+\t  if (e == NULL)\n+\t    break;\n+\n+\t  /* We can't handle multiple epilogues -- if one is needed,\n+\t     we won't be able to place it multiple times.\n+\n+\t     ??? Fix epilogue expanders to not assume they are the\n+\t     last thing done compiling the function.  Either that\n+\t     or copy_rtx each insn.\n+\n+\t     ??? Blah, it's not a simple expression to assert that\n+\t     we've exactly one fallthru exit edge.  */\n+\n+\t  bb = e->src;\n+\t  tail = bb->end;\n+\n+\t  /* ??? If the last insn of the basic block is a jump, then we\n+\t     are creating a new basic block.  Wimp out and leave these\n+\t     insns outside any block.  */\n+\t  if (GET_CODE (tail) == JUMP_INSN)\n+\t    bb = 0;\n+\n+\t  /* FALLTHRU */\n+\tcase 0:\n+\t  {\n+\t    rtx prev, seq, first_use;\n+\n+\t    /* Move the USE insns at the end of a function onto a list.  */\n+\t    prev = tail;\n+\t    if (GET_CODE (prev) == BARRIER\n+\t\t|| GET_CODE (prev) == NOTE)\n \t      prev = prev_nonnote_insn (prev);\n \n-\t      NEXT_INSN (PREV_INSN (tem)) = NEXT_INSN (tem);\n-\t      PREV_INSN (NEXT_INSN (tem)) = PREV_INSN (tem);\n-\t      if (first_use)\n-\t\t{\n-\t\t  NEXT_INSN (tem) = first_use;\n-\t\t  PREV_INSN (first_use) = tem;\n-\t\t}\n-\t      first_use = tem;\n-\t      if (!last_use)\n-\t\tlast_use = tem;\n-\t    }\n+\t    first_use = 0;\n+\t    if (prev\n+\t\t&& GET_CODE (prev) == INSN\n+\t\t&& GET_CODE (PATTERN (prev)) == USE)\n+\t      {\n+\t\t/* If the end of the block is the use, grab hold of something\n+\t\t   else so that we emit barriers etc in the right place.  */\n+\t\tif (prev == tail)\n+\t\t  {\n+\t\t    do \n+\t\t      tail = PREV_INSN (tail);\n+\t\t    while (GET_CODE (tail) == INSN\n+\t\t\t   && GET_CODE (PATTERN (tail)) == USE);\n+\t\t  }\n \n-\t  emit_barrier_after (insn);\n+\t\tdo\n+\t\t  {\n+\t\t    rtx use = prev;\n+\t\t    prev = prev_nonnote_insn (prev);\n+\n+\t\t    remove_insn (use);\n+\t\t    if (first_use)\n+\t\t      {\n+\t\t\tNEXT_INSN (use) = first_use;\n+\t\t\tPREV_INSN (first_use) = use;\n+\t\t      }\n+\t\t    else\n+\t\t      NEXT_INSN (use) = NULL_RTX;\n+\t\t    first_use = use;\n+\t\t  }\n+\t\twhile (prev\n+\t\t       && GET_CODE (prev) == INSN\n+\t\t       && GET_CODE (PATTERN (prev)) == USE);\n+\t      }\n \n-\t  seq = gen_epilogue ();\n-\t  tail = emit_jump_insn_after (seq, insn);\n+\t    /* The last basic block ends with a NOTE_INSN_EPILOGUE_BEG, the\n+\t       epilogue insns, the USE insns at the end of a function,\n+\t       the jump insn that returns, and then a BARRIER.  */\n \n-\t  /* Insert the USE insns immediately before the return insn, which\n-\t     must be the first instruction before the final barrier.  */\n-\t  if (first_use)\n-\t    {\n-\t      tem = prev_nonnote_insn (get_last_insn ());\n-\t      NEXT_INSN (PREV_INSN (tem)) = first_use;\n-\t      PREV_INSN (first_use) = PREV_INSN (tem);\n-\t      PREV_INSN (tem) = last_use;\n-\t      NEXT_INSN (last_use) = tem;\n-\t    }\n+\t    if (GET_CODE (tail) != BARRIER)\n+\t      {\n+\t\tprev = next_nonnote_insn (tail);\n+\t\tif (!prev || GET_CODE (prev) != BARRIER)\n+\t\t  emit_barrier_after (tail);\n+\t      }\n \n-\t  emit_note_after (NOTE_INSN_EPILOGUE_BEG, insn);\n+\t    seq = gen_epilogue ();\n+\t    prev = tail;\n+\t    tail = emit_jump_insn_after (seq, tail);\n \n-\t  /* Include the new epilogue insns in the last block.  Ignore\n-\t     them if they form a basic block unto themselves.  */\n-\t  if (x_basic_block_end && n_basic_blocks\n-\t      && GET_CODE (BLOCK_END (n_basic_blocks - 1)) != JUMP_INSN)\n-\t    BLOCK_END (n_basic_blocks - 1) = tail;\n+\t    /* Insert the USE insns immediately before the return insn, which\n+\t       must be the last instruction emitted in the sequence.  */\n+\t    if (first_use)\n+\t      emit_insns_before (first_use, tail);\n+\t    emit_note_after (NOTE_INSN_EPILOGUE_BEG, prev);\n \n-\t  /* Retain a map of the epilogue insns.  */\n-\t  epilogue = record_insns (GET_CODE (seq) == SEQUENCE ? seq : tail);\n-\t  return;\n+\t    /* Update the tail of the basic block.  */\n+\t    if (bb)\n+\t      bb->end = tail;\n+\n+\t    /* Retain a map of the epilogue insns.  */\n+\t    epilogue = record_insns (GET_CODE (seq) == SEQUENCE ? seq : tail);\n+\t  }\n \t}\n     }\n #endif\n-  epilogue = 0;\n+\n+  if (insertted)\n+    commit_edge_insertions ();\n }\n \n /* Reposition the prologue-end and epilogue-begin notes after instruction"}, {"sha": "878de9e950ebaff0ab6c2b3b33267ce7b48866ee", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -83,6 +83,7 @@ struct function\n   int has_computed_jump;\n   int is_thunk;\n   rtx nonlocal_goto_handler_slots;\n+  rtx nonlocal_goto_handler_labels;\n   rtx nonlocal_goto_stack_level;\n   tree nonlocal_labels;\n   int args_size;"}, {"sha": "9649b6e27258152c3be588fb9112822ca2ca8400", "filename": "gcc/global.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -648,7 +648,7 @@ global_conflicts ()\n \t are explicitly marked in basic_block_live_at_start.  */\n \n       {\n-\tregister regset old = basic_block_live_at_start[b];\n+\tregister regset old = BASIC_BLOCK (b)->global_live_at_start;\n \tint ax = 0;\n \n \tREG_SET_TO_HARD_REG_SET (hard_regs_live, old);\n@@ -671,12 +671,22 @@ global_conflicts ()\n \trecord_conflicts (block_start_allocnos, ax);\n \n #ifdef STACK_REGS\n-\t/* Pseudos can't go in stack regs at the start of a basic block\n-\t   that can be reached through a computed goto, since reg-stack\n-\t   can't handle computed gotos.  */\n-\tif (basic_block_computed_jump_target[b])\n-\t  for (ax = FIRST_STACK_REG; ax <= LAST_STACK_REG; ax++)\n-\t    record_one_conflict (ax);\n+\t{\n+\t  /* Pseudos can't go in stack regs at the start of a basic block\n+\t     that can be reached through a computed goto, since reg-stack\n+\t     can't handle computed gotos.  */\n+\t  /* ??? Seems more likely that reg-stack can't handle any abnormal\n+\t     edges, critical or not, computed goto or otherwise.  */\n+\n+\t  edge e;\n+\t  for (e = BASIC_BLOCK (b)->pred; e ; e = e->pred_next)\n+\t    if (e->flags & EDGE_ABNORMAL)\n+\t      break;\n+\n+\t  if (e != NULL)\n+\t    for (ax = FIRST_STACK_REG; ax <= LAST_STACK_REG; ax++)\n+\t      record_one_conflict (ax);\n+\t}\n #endif\n       }\n \n@@ -1598,11 +1608,14 @@ mark_elimination (from, to)\n   int i;\n \n   for (i = 0; i < n_basic_blocks; i++)\n-    if (REGNO_REG_SET_P (basic_block_live_at_start[i], from))\n-      {\n-\tCLEAR_REGNO_REG_SET (basic_block_live_at_start[i], from);\n-\tSET_REGNO_REG_SET (basic_block_live_at_start[i], to);\n-      }\n+    {\n+      register regset r = BASIC_BLOCK (i)->global_live_at_start; \n+      if (REGNO_REG_SET_P (r, from))\n+\t{\n+\t  CLEAR_REGNO_REG_SET (r, from);\n+\t  SET_REGNO_REG_SET (r, to);\n+\t}\n+    }\n }\n \f\n /* Used for communication between the following functions.  Holds the\n@@ -1672,13 +1685,13 @@ build_insn_chain (first)\n \t  int i;\n \t  CLEAR_REG_SET (live_relevant_regs);\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (REGNO_REG_SET_P (basic_block_live_at_start[b], i)\n+\t    if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, i)\n \t\t&& ! TEST_HARD_REG_BIT (eliminable_regset, i))\n \t      SET_REGNO_REG_SET (live_relevant_regs, i);\n \n \t  for (; i < max_regno; i++)\n \t    if (reg_renumber[i] >= 0\n-\t\t&& REGNO_REG_SET_P (basic_block_live_at_start[b], i))\n+\t\t&& REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, i))\n \t      SET_REGNO_REG_SET (live_relevant_regs, i);\n \t}\n "}, {"sha": "951494499648bba43f91b32728fad56d8aa17def", "filename": "gcc/graph.c", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -160,7 +160,8 @@ darkgrey\\n  shape: ellipse\" : \"white\",\n \t\"repeated_line_number\",\n \t\"range_start\",\n \t\"range_end\",\n-\t\"live\"\n+\t\"live\",\n+\t\"basic_block\"\n       };\n \n       fprintf (fp, \" %s\",\n@@ -191,14 +192,21 @@ draw_edge (fp, from, to, bb_edge, class)\n      int bb_edge;\n      int class;\n {\n+  char * color;\n   switch (graph_dump_format)\n     {\n     case vcg:\n+      color = \"\";\n+      if (class == 2)\n+\tcolor = \"color: red \";\n+      else if (bb_edge)\n+\tcolor = \"color: blue \";\n+      else if (class == 3)\n+\tcolor = \"color: green \";\n       fprintf (fp,\n \t       \"edge: { sourcename: \\\"%s.%d\\\" targetname: \\\"%s.%d\\\" %s\",\n \t       current_function_name, from,\n-\t       current_function_name, to,\n-\t       bb_edge ? \"color: blue \" : class ? \"color: red \" : \"\");\n+\t       current_function_name, to, color);\n       if (class)\n \tfprintf (fp, \"class: %d \", class);\n       fputs (\"}\\n\", fp);\n@@ -253,8 +261,8 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n   char *buf = (char *) alloca (namelen + suffixlen + extlen);\n   FILE *fp;\n \n-  /* Regenerate the basic block information.  */\n-  find_basic_blocks (rtx_first, max_reg_num (), NULL);\n+  if (basic_block_info == NULL)\n+    return;\n \n   memcpy (buf, base, namelen);\n   memcpy (buf + namelen, suffix, suffixlen);\n@@ -268,20 +276,14 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n     fprintf (fp, \"(nil)\\n\");\n   else\n     {\n-      int i, bb;\n+      int i;\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n       int *start = (int *) alloca (max_uid * sizeof (int));\n       int *end = (int *) alloca (max_uid * sizeof (int));\n       enum bb_state *in_bb_p = (enum bb_state *)\n \talloca (max_uid * sizeof (enum bb_state));\n-      /* Element I is a list of I's predecessors/successors.  */\n-      int_list_ptr *s_preds;\n-      int_list_ptr *s_succs;\n-      /* Element I is the number of predecessors/successors of basic\n-        block I.  */\n-      int *num_preds;\n-      int *num_succs;\n+      basic_block bb;\n \n       for (i = 0; i < max_uid; ++i)\n \t{\n@@ -292,28 +294,19 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n       for (i = n_basic_blocks - 1; i >= 0; --i)\n \t{\n \t  rtx x;\n-\t  start[INSN_UID (BLOCK_HEAD (i))] = i;\n-\t  end[INSN_UID (BLOCK_END (i))] = i;\n-\t  for (x = BLOCK_HEAD (i); x != NULL_RTX; x = NEXT_INSN (x))\n+\t  bb = BASIC_BLOCK (i);\n+\t  start[INSN_UID (bb->head)] = i;\n+\t  end[INSN_UID (bb->end)] = i;\n+\t  for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n \t    {\n \t      in_bb_p[INSN_UID (x)]\n \t\t= (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n \t\t ? IN_ONE_BB : IN_MULTIPLE_BB;\n-\t      if (x == BLOCK_END (i))\n+\t      if (x == bb->end)\n \t\tbreak;\n \t    }\n \t}\n \n-      /* Get the information about the basic blocks predecessors and\n-\t successors.  */\n-      s_preds = (int_list_ptr *) alloca (n_basic_blocks\n-\t\t\t\t\t * sizeof (int_list_ptr));\n-      s_succs = (int_list_ptr *) alloca (n_basic_blocks\n-\t\t\t\t\t * sizeof (int_list_ptr));\n-      num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n-      num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n-      compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n-\n       /* Tell print-rtl that we want graph output.  */\n       dump_for_graph = 1;\n \n@@ -336,53 +329,53 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n \t\tcontinue;\n \t    }\n \n-\t  if ((bb = start[INSN_UID (tmp_rtx)]) >= 0)\n+\t  if ((i = start[INSN_UID (tmp_rtx)]) >= 0)\n \t    {\n \t      /* We start a subgraph for each basic block.  */\n-\t      start_bb (fp, bb);\n+\t      start_bb (fp, i);\n \n-\t      if (bb == 0)\n+\t      if (i == 0)\n \t\tdraw_edge (fp, 0, INSN_UID (tmp_rtx), 1, 0);\n \t    }\n \n \t  /* Print the data for this node.  */\n \t  did_output = node_data (fp, tmp_rtx);\n \t  next_insn = next_nonnote_insn (tmp_rtx);\n \n-\t  if ((bb = end[INSN_UID (tmp_rtx)]) >= 0)\n+\t  if ((i = end[INSN_UID (tmp_rtx)]) >= 0)\n \t    {\n-\t      int_list_ptr p;\n+\t      edge e;\n+\n+\t      bb = BASIC_BLOCK (i);\n \n \t      /* End of the basic block.  */\n \t      end_bb (fp, bb);\n \n \t      /* Now specify the edges to all the successors of this\n \t\t basic block.  */\n-\t      for (p = s_succs[bb]; p != NULL; p = p->next)\n+\t      for (e = bb->succ; e ; e = e->succ_next)\n \t\t{\n-\t\t  int bb_succ = INT_LIST_VAL (p);\n-\n-\t\t  if (bb_succ >= 0)\n+\t\t  if (e->dest != EXIT_BLOCK_PTR)\n \t\t    {\n-\t\t      rtx block_head = BLOCK_HEAD (bb_succ);\n+\t\t      rtx block_head = e->dest->head;\n \n \t\t      draw_edge (fp, INSN_UID (tmp_rtx),\n \t\t\t\t INSN_UID (block_head),\n-\t\t\t\t next_insn != block_head, 0);\n+\t\t\t\t next_insn != block_head,\n+\t\t\t\t (e->flags & EDGE_ABNORMAL ? 2 : 0));\n \n-\t\t      if (BLOCK_HEAD (bb_succ) == next_insn)\n+\t\t      if (block_head == next_insn)\n \t\t\tedge_printed = 1;\n \t\t    }\n-\t\t  else if (bb_succ == EXIT_BLOCK)\n+\t\t  else\n \t\t    {\n \t\t      draw_edge (fp, INSN_UID (tmp_rtx), 999999,\n-\t\t\t\t next_insn != 0, 0);\n+\t\t\t\t next_insn != 0,\n+\t\t\t\t (e->flags & EDGE_ABNORMAL ? 2 : 0));\n \n \t\t      if (next_insn == 0)\n \t\t\tedge_printed = 1;\n \t\t    }\n-\t\t  else\n-\t\t    abort ();\n \t\t}\n \t    }\n \n@@ -395,8 +388,8 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n \t\t\t   next_insn ? INSN_UID (next_insn) : 999999, 0, 0);\n \t      else\n \t\t{\n-\t\t  /* We draw the remaining edges in class 2.  We have\n-\t\t     to skip oevr the barrier since these nodes are\n+\t\t  /* We draw the remaining edges in class 3.  We have\n+\t\t     to skip over the barrier since these nodes are\n \t\t     not printed at all.  */\n \t\t  do\n \t\t    next_insn = NEXT_INSN (next_insn);\n@@ -405,7 +398,7 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n \t\t\t     || GET_CODE (next_insn) == BARRIER));\n \n \t\t  draw_edge (fp, XINT (tmp_rtx, 0),\n-\t\t\t     next_insn ? INSN_UID (next_insn) : 999999, 0, 2);\n+\t\t\t     next_insn ? INSN_UID (next_insn) : 999999, 0, 3);\n \t\t}\n \t    }\n \t}"}, {"sha": "e9052b5f12bb0a09fa090b0dfc85df2f21ce6368", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -472,8 +472,8 @@ typedef struct\n     int next_in;\n     int next_out;\n   }\n-edge;\n-static edge *edge_table;\n+haifa_edge;\n+static haifa_edge *edge_table;\n \n #define NEXT_IN(edge) (edge_table[edge].next_in)\n #define NEXT_OUT(edge) (edge_table[edge].next_out)\n@@ -1082,7 +1082,7 @@ is_cfg_nonregular ()\n \n   /* If we have a label that could be the target of a nonlocal goto, then\n      the cfg is not well structured.  */\n-  if (nonlocal_label_rtx_list () != NULL)\n+  if (nonlocal_goto_handler_labels)\n     return 1;\n \n   /* If we have any forced labels, then the cfg is not well structured.  */\n@@ -1169,8 +1169,8 @@ build_control_flow (s_preds, s_succs, num_preds, num_succs)\n   bzero ((char *) in_edges, n_basic_blocks * sizeof (int));\n   bzero ((char *) out_edges, n_basic_blocks * sizeof (int));\n \n-  edge_table = (edge *) xmalloc ((nr_edges) * sizeof (edge));\n-  bzero ((char *) edge_table, ((nr_edges) * sizeof (edge)));\n+  edge_table = (haifa_edge *) xmalloc ((nr_edges) * sizeof (haifa_edge));\n+  bzero ((char *) edge_table, ((nr_edges) * sizeof (haifa_edge)));\n \n   nr_edges = 0;\n   for (i = 0; i < n_basic_blocks; i++)\n@@ -2153,7 +2153,8 @@ check_live_1 (src, x)\n \t\t{\n \t\t  int b = candidate_table[src].split_bbs.first_member[i];\n \n-\t\t  if (REGNO_REG_SET_P (basic_block_live_at_start[b], regno + j))\n+\t\t  if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start,\n+\t\t\t\t       regno + j))\n \t\t    {\n \t\t      return 0;\n \t\t    }\n@@ -2167,7 +2168,7 @@ check_live_1 (src, x)\n \t    {\n \t      int b = candidate_table[src].split_bbs.first_member[i];\n \n-\t      if (REGNO_REG_SET_P (basic_block_live_at_start[b], regno))\n+\t      if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, regno))\n \t\t{\n \t\t  return 0;\n \t\t}\n@@ -2227,7 +2228,8 @@ update_live_1 (src, x)\n \t\t{\n \t\t  int b = candidate_table[src].update_bbs.first_member[i];\n \n-\t\t  SET_REGNO_REG_SET (basic_block_live_at_start[b], regno + j);\n+\t\t  SET_REGNO_REG_SET (BASIC_BLOCK (b)->global_live_at_start,\n+\t\t\t\t     regno + j);\n \t\t}\n \t    }\n \t}\n@@ -2237,7 +2239,7 @@ update_live_1 (src, x)\n \t    {\n \t      int b = candidate_table[src].update_bbs.first_member[i];\n \n-\t      SET_REGNO_REG_SET (basic_block_live_at_start[b], regno);\n+\t      SET_REGNO_REG_SET (BASIC_BLOCK (b)->global_live_at_start, regno);\n \t    }\n \t}\n     }\n@@ -5135,7 +5137,7 @@ finish_sometimes_live (regs_sometimes_live, sometimes_max)\n \n /* functions for computation of registers live/usage info */\n \n-/* It is assumed that prior to scheduling basic_block_live_at_start (b)\n+/* It is assumed that prior to scheduling BASIC_BLOCK (b)->global_live_at_start\n    contains the registers that are alive at the entry to b.\n \n    Two passes follow: The first pass is performed before the scheduling\n@@ -5165,7 +5167,7 @@ find_pre_sched_live (bb)\n   int b = BB_TO_BLOCK (bb);\n \n   get_block_head_tail (bb, &head, &tail);\n-  COPY_REG_SET (bb_live_regs, basic_block_live_at_start[b]);\n+  COPY_REG_SET (bb_live_regs, BASIC_BLOCK (b)->global_live_at_start);\n   next_tail = NEXT_INSN (tail);\n \n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n@@ -5303,7 +5305,8 @@ find_post_sched_live (bb)\n \t    int b_succ;\n \n \t    b_succ = TO_BLOCK (e);\n-\t    IOR_REG_SET (bb_live_regs, basic_block_live_at_start[b_succ]);\n+\t    IOR_REG_SET (bb_live_regs,\n+\t\t\t BASIC_BLOCK (b_succ)->global_live_at_start);\n \t    e = NEXT_OUT (e);\n \t  }\n \twhile (e != first_edge);\n@@ -5325,7 +5328,7 @@ find_post_sched_live (bb)\n       && (GET_RTX_CLASS (GET_CODE (tail)) != 'i'))\n     {\n       if (current_nr_blocks > 1)\n-\tCOPY_REG_SET (basic_block_live_at_start[b], bb_live_regs);\n+\tCOPY_REG_SET (BASIC_BLOCK (b)->global_live_at_start, bb_live_regs);\n \n       return;\n     }\n@@ -5448,9 +5451,9 @@ find_post_sched_live (bb)\n \n   finish_sometimes_live (regs_sometimes_live, sometimes_max);\n \n-  /* In interblock scheduling, basic_block_live_at_start may have changed.  */\n+  /* In interblock scheduling, global_live_at_start may have changed.  */\n   if (current_nr_blocks > 1)\n-    COPY_REG_SET (basic_block_live_at_start[b], bb_live_regs);\n+    COPY_REG_SET (BASIC_BLOCK (b)->global_live_at_start, bb_live_regs);\n \n \n   FREE_REG_SET (old_live_regs);\n@@ -5522,7 +5525,7 @@ update_reg_usage ()\n \t   pseudos which are live in more than one block.\n \n \t   This is because combine might have made an optimization which\n-\t   invalidated basic_block_live_at_start and reg_n_calls_crossed,\n+\t   invalidated global_live_at_start and reg_n_calls_crossed,\n \t   but it does not update them.  If we update reg_n_calls_crossed\n \t   here, the two variables are now inconsistent, and this might\n \t   confuse the caller-save code into saving a register that doesn't\n@@ -8530,7 +8533,7 @@ schedule_insns (dump_file)\n \n \t  /* The scheduler runs after flow; therefore, we can't blindly call\n \t     back into find_basic_blocks since doing so could invalidate the\n-\t     info in basic_block_live_at_start.\n+\t     info in global_live_at_start.\n \n \t     Consider a block consisting entirely of dead stores; after life\n \t     analysis it would be a block of NOTE_INSN_DELETED notes.  If"}, {"sha": "7d25a97d3c5a6df29a07e37ea22865faa03a762c", "filename": "gcc/jump.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -3429,6 +3429,24 @@ condjump_label (insn)\n   return NULL_RTX;\n }\n \n+/* Return true if INSN is a (possibly conditional) return insn.  */\n+\n+static int\n+returnjump_p_1 (loc, data)\n+     rtx *loc;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *loc;\n+  return GET_CODE (x) == RETURN;\n+}\n+\n+int\n+returnjump_p (insn)\n+     rtx insn;\n+{\n+  return for_each_rtx (&PATTERN (insn), returnjump_p_1, NULL);\n+}\n+\n #ifdef HAVE_cc0\n \n /* Return 1 if X is an RTX that does nothing but set the condition codes"}, {"sha": "ea97f33f5b5cf6b3b11b278feb90ce0881207e66", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -966,7 +966,8 @@ update_equiv_regs ()\n \t\t    BLOCK_HEAD (block) = PREV_INSN (insn);\n \n \t\t  for (l = 0; l < n_basic_blocks; l++)\n-\t\t    CLEAR_REGNO_REG_SET (basic_block_live_at_start[l], regno);\n+\t\t    CLEAR_REGNO_REG_SET (BASIC_BLOCK (l)->global_live_at_start,\n+\t\t\t\t\t regno);\n \t\t}\n \t    }\n \t}\n@@ -1039,7 +1040,7 @@ block_alloc (b)\n \n   /* Initialize table of hardware registers currently live.  */\n \n-  REG_SET_TO_HARD_REG_SET (regs_live, basic_block_live_at_start[b]);\n+  REG_SET_TO_HARD_REG_SET (regs_live, BASIC_BLOCK (b)->global_live_at_start);\n \n   /* This loop scans the instructions of the basic block\n      and assigns quantities to registers."}, {"sha": "e72a77bf5e9085595a8d8174735c96d699b093af", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -22,9 +22,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n-#include \"bitmap.h\"\n #include \"real.h\"\n #include \"flags.h\"\n+#include \"basic-block.h\"\n \n \n /* How to print out a register name.\n@@ -170,6 +170,14 @@ print_rtx (in_rtx)\n \t    break;\n \t  }\n \n+\tif (i == 3 && GET_CODE (in_rtx) == NOTE\n+\t    && NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BASIC_BLOCK)\n+\t  {\n+\t    basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n+\t    fprintf (outfile, \" [bb %d]\", bb->index);\n+\t    break;\n+\t  }\n+\n \tif (XSTR (in_rtx, i) == 0)\n \t  fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n \telse"}, {"sha": "203e1af6007c3a7e6015c5d6737e9660197b3f6e", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -229,9 +229,23 @@ static rtx\n /* Get the basic block number of an insn.  See note at block_number\n    definition are validity of this information.  */\n \n-#define BLOCK_NUM(INSN)  \\\n-  ((INSN_UID (INSN) > max_uid)\t\\\n-   ? (abort() , -1) : block_number[INSN_UID (INSN)])\n+static int BLOCK_NUM PROTO((rtx));\n+\n+#ifdef __GNUC__\n+__inline__\n+#endif\n+static int\n+BLOCK_NUM(insn)\n+     rtx insn;\n+{\n+  int tmp = INSN_UID (insn);\n+  if (tmp > max_uid)\n+    abort ();\n+  tmp = block_number[tmp];\n+  if (tmp < 0)\n+    abort ();\n+  return tmp;\n+}\n \n extern rtx forced_labels;\n \n@@ -502,6 +516,7 @@ reg_to_stack (first, file)\n   bzero ((char *) block_out_reg_set, blocks * sizeof (HARD_REG_SET));\n \n   block_number = (int *) alloca ((max_uid + 1) * sizeof (int));\n+  memset (block_number, -1, (max_uid + 1) * sizeof (int));\n \n   find_blocks (first);\n   stack_reg_life_analysis (first, &stackentry);"}, {"sha": "1b6ec9a4b6a539bcd2b132479bb58dce4e1bc322", "filename": "gcc/regclass.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -2208,12 +2208,5 @@ reg_classes_intersect_p (c1, c2)\n void\n regset_release_memory ()\n {\n-  if (basic_block_live_at_start)\n-    {\n-      free_regset_vector (basic_block_live_at_start, n_basic_blocks);\n-      basic_block_live_at_start = 0;\n-    }\n-\n-  FREE_REG_SET (regs_live_at_setjmp);\n   bitmap_release_memory ();\n }"}, {"sha": "8cc913a52c27d61078259a159f2b734e43f6af86", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -267,7 +267,7 @@ mark_flags_life_zones (flags)\n       {\n \tint i;\n \tfor (i = 0; i < flags_nregs; ++i)\n-          live |= REGNO_REG_SET_P (basic_block_live_at_start[block],\n+          live |= REGNO_REG_SET_P (BASIC_BLOCK (block)->global_live_at_start,\n \t\t\t\t   flags_regno + i);\n       }\n #endif"}, {"sha": "a9bed7a9b0265682f9d6e8fc07dc269ffec77921", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -538,9 +538,9 @@ compute_use_by_pseudos (to, from)\n        if (r < 0)\n \t {\n \t   /* reload_combine uses the information from\n-\t      basic_block_live_at_start, which might still contain registers\n-\t      that have not actually been allocated since they have an\n-\t      equivalence.  */\n+\t      BASIC_BLOCK->global_live_at_start, which might still\n+\t      contain registers that have not actually been allocated\n+\t      since they have an equivalence.  */\n \t   if (! reload_completed)\n \t     abort ();\n \t }\n@@ -1060,7 +1060,7 @@ reload (first, global, dumpfile)\n \n   if (! frame_pointer_needed)\n     for (i = 0; i < n_basic_blocks; i++)\n-      CLEAR_REGNO_REG_SET (basic_block_live_at_start[i],\n+      CLEAR_REGNO_REG_SET (BASIC_BLOCK (i)->global_live_at_start,\n \t\t\t   HARD_FRAME_POINTER_REGNUM);\n \n   /* Come here (with failure set nonzero) if we can't get enough spill regs\n@@ -9494,8 +9494,8 @@ reload_combine ()\n \t{\n \t  HARD_REG_SET live;\n \n-\t  REG_SET_TO_HARD_REG_SET (live, basic_block_live_at_start[i]);\n-\t  compute_use_by_pseudos (&live, basic_block_live_at_start[i]);\n+\t  REG_SET_TO_HARD_REG_SET (live, BASIC_BLOCK (i)->global_live_at_start);\n+\t  compute_use_by_pseudos (&live, BASIC_BLOCK (i)->global_live_at_start);\n \t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n \t  IOR_HARD_REG_SET (ever_live_at_start, live);\n \t}"}, {"sha": "9f702a536cdc5ec2d5f3e6b67a253c23652a0f57", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -875,7 +875,7 @@ mark_target_live_regs (insns, target, res)\n      TARGET.  Otherwise, we must assume everything is live.  */\n   if (b != -1)\n     {\n-      regset regs_live = basic_block_live_at_start[b];\n+      regset regs_live = BASIC_BLOCK (b)->global_live_at_start;\n       int j;\n       int regno;\n       rtx start_insn, stop_insn;"}, {"sha": "801018e17fe585a97f1d6d1a6fb580aeba66bfac", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -184,7 +184,8 @@ char *note_insn_name[] = { 0                    , \"NOTE_INSN_DELETED\",\n \t\t\t   \"NOTE_INSN_DELETED_LABEL\", \"NOTE_INSN_FUNCTION_BEG\",\n \t\t\t   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n \t\t\t   \"NOTE_REPEATED_LINE_NUMBER\", \"NOTE_INSN_RANGE_START\",\n-\t\t\t   \"NOTE_INSN_RANGE_END\", \"NOTE_INSN_LIVE\" };\n+\t\t\t   \"NOTE_INSN_RANGE_END\", \"NOTE_INSN_LIVE\",\n+\t\t\t   \"NOTE_INSN_BASIC_BLOCK\" };\n \n char *reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_WAS_0\",\n \t\t\t  \"REG_EQUAL\", \"REG_RETVAL\", \"REG_LIBCALL\","}, {"sha": "bee3f052c3d2da9571d9e91854f0f822883be7c9", "filename": "gcc/rtl.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -91,6 +91,7 @@ typedef union rtunion_def\n   addr_diff_vec_flags rt_addr_diff_vec_flags;\n   struct bitmap_head_def *rtbit;\n   union tree_node *rttree;\n+  struct basic_block_def *bb;\n } rtunion;\n \n /* RTL expression (\"rtx\").  */\n@@ -404,6 +405,7 @@ extern char *reg_note_name[];\n #define NOTE_BLOCK_NUMBER(INSN) ((INSN)->fld[3].rtint)\n #define NOTE_RANGE_INFO(INSN)   ((INSN)->fld[3].rtx)\n #define NOTE_LIVE_INFO(INSN)    ((INSN)->fld[3].rtx)\n+#define NOTE_BASIC_BLOCK(INSN)\t((INSN)->fld[3].bb)\n \n /* If the NOTE_BLOCK_NUMBER field gets a -1, it means create a new\n    block node for a live range block.  */\n@@ -469,6 +471,8 @@ extern char *reg_note_name[];\n #define NOTE_INSN_RANGE_END -18\n /* Record which registers are currently live.  */\n #define NOTE_INSN_LIVE -19\n+/* Record the struct for the following basic block.  */\n+#define NOTE_INSN_BASIC_BLOCK -20\n \n #if 0 /* These are not used, and I don't know what they were for. --rms.  */\n #define NOTE_DECL_NAME(INSN) ((INSN)->fld[3].rtstr)\n@@ -932,6 +936,7 @@ extern rtx emit_insn_before\t\tPROTO((rtx, rtx));\n extern rtx emit_jump_insn_before\tPROTO((rtx, rtx));\n extern rtx emit_call_insn_before\tPROTO((rtx, rtx));\n extern rtx emit_barrier_before\t\tPROTO((rtx));\n+extern rtx emit_label_before\t\tPROTO((rtx, rtx));\n extern rtx emit_note_before\t\tPROTO((int, rtx));\n extern rtx emit_insn_after\t\tPROTO((rtx, rtx));\n extern rtx emit_jump_insn_after\t\tPROTO((rtx, rtx));\n@@ -982,7 +987,6 @@ extern rtx simplify_unary_operation\tPROTO((enum rtx_code, enum machine_mode, rtx\n extern rtx simplify_binary_operation\tPROTO((enum rtx_code, enum machine_mode, rtx, rtx));\n extern rtx simplify_ternary_operation\tPROTO((enum rtx_code, enum machine_mode, enum machine_mode, rtx, rtx, rtx));\n extern rtx simplify_relational_operation PROTO((enum rtx_code, enum machine_mode, rtx, rtx));\n-extern rtx nonlocal_label_rtx_list\tPROTO((void));\n extern rtx gen_move_insn\t\tPROTO((rtx, rtx));\n extern rtx gen_jump\t\t\tPROTO((rtx));\n extern rtx gen_beq\t\t\tPROTO((rtx));\n@@ -1300,6 +1304,7 @@ extern int comparison_dominates_p\tPROTO ((enum rtx_code, enum rtx_code));\n extern int condjump_p\t\t\tPROTO ((rtx));\n extern rtx condjump_label\t\tPROTO ((rtx));\n extern int simplejump_p\t\t\tPROTO ((rtx));\n+extern int returnjump_p\t\t\tPROTO ((rtx));\n extern int sets_cc0_p\t\t\tPROTO ((rtx));\n extern int invert_jump\t\t\tPROTO ((rtx, rtx));\n extern int rtx_renumbered_equal_p\tPROTO ((rtx, rtx));\n@@ -1415,6 +1420,10 @@ extern void expand_null_return\t\tPROTO((void));\n extern void emit_jump\t\t\tPROTO ((rtx));\n extern int preserve_subexpressions_p\tPROTO ((void));\n \n+/* List (chain of EXPR_LIST) of labels heading the current handlers for\n+   nonlocal gotos.  */\n+extern rtx nonlocal_goto_handler_labels;\n+\n /* In expr.c */\n extern void init_expr_once\t\tPROTO ((void));\n extern void move_by_pieces\t\tPROTO ((rtx, rtx, int, int));"}, {"sha": "1bcc779786ff6fa8dc65cae2550e331948b3dca5", "filename": "gcc/sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -2879,7 +2879,7 @@ schedule_block (b, file)\n \n   if (reload_completed == 0)\n     {\n-      COPY_REG_SET (bb_live_regs, basic_block_live_at_start[b]);\n+      COPY_REG_SET (bb_live_regs, BASIC_BLOCK (b)->global_live_at_start);\n       CLEAR_REG_SET (bb_dead_regs);\n \n       if (b == 0)"}, {"sha": "385920847ccd80c9a86a0f19568916651863646a", "filename": "gcc/stmt.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -428,7 +428,7 @@ static int using_eh_for_cleanups_p = 0;\n static int n_occurrences\t\tPROTO((int, char *));\n static void expand_goto_internal\tPROTO((tree, rtx, rtx));\n static int expand_fixup\t\t\tPROTO((tree, rtx, rtx));\n-static void expand_nl_handler_label\tPROTO((rtx, rtx));\n+static rtx expand_nl_handler_label\tPROTO((rtx, rtx));\n static void expand_nl_goto_receiver\tPROTO((void));\n static void expand_nl_goto_receivers\tPROTO((struct nesting *));\n static void fixup_gotos\t\t\tPROTO((struct nesting *, rtx, tree,\n@@ -3169,7 +3169,7 @@ remember_end_note (block)\n /* Emit a handler label for a nonlocal goto handler.\n    Also emit code to store the handler label in SLOT before BEFORE_INSN.  */\n \n-static void\n+static rtx\n expand_nl_handler_label (slot, before_insn)\n      rtx slot, before_insn;\n {\n@@ -3186,6 +3186,8 @@ expand_nl_handler_label (slot, before_insn)\n   emit_insns_before (insns, before_insn);\n \n   emit_label (handler_label);\n+\n+  return handler_label;\n }\n \n /* Emit code to restore vital registers at the beginning of a nonlocal goto\n@@ -3260,6 +3262,7 @@ expand_nl_goto_receivers (thisblock)\n   tree link;\n   rtx afterward = gen_label_rtx ();\n   rtx insns, slot;\n+  rtx label_list;\n   int any_invalid;\n \n   /* Record the handler address in the stack slot for that purpose,\n@@ -3283,14 +3286,18 @@ expand_nl_goto_receivers (thisblock)\n   /* Make a separate handler for each label.  */\n   link = nonlocal_labels;\n   slot = nonlocal_goto_handler_slots;\n+  label_list = NULL_RTX;\n   for (; link; link = TREE_CHAIN (link), slot = XEXP (slot, 1))\n     /* Skip any labels we shouldn't be able to jump to from here,\n        we generate one special handler for all of them below which just calls\n        abort.  */\n     if (! DECL_TOO_LATE (TREE_VALUE (link)))\n       {\n-\texpand_nl_handler_label (XEXP (slot, 0),\n-\t\t\t\t thisblock->data.block.first_insn);\n+\trtx lab;\n+\tlab = expand_nl_handler_label (XEXP (slot, 0),\n+\t\t\t\t       thisblock->data.block.first_insn);\n+\tlabel_list = gen_rtx_EXPR_LIST (VOIDmode, lab, label_list);\n+\n \texpand_nl_goto_receiver ();\n \n \t/* Jump to the \"real\" nonlocal label.  */\n@@ -3305,8 +3312,10 @@ expand_nl_goto_receivers (thisblock)\n   for (; link; link = TREE_CHAIN (link), slot = XEXP (slot, 1))\n     if (DECL_TOO_LATE (TREE_VALUE (link)))\n       {\n-\texpand_nl_handler_label (XEXP (slot, 0),\n-\t\t\t\t thisblock->data.block.first_insn);\n+\trtx lab;\n+\tlab = expand_nl_handler_label (XEXP (slot, 0),\n+\t\t\t\t       thisblock->data.block.first_insn);\n+\tlabel_list = gen_rtx_EXPR_LIST (VOIDmode, lab, label_list);\n \tany_invalid = 1;\n       }\n \n@@ -3318,6 +3327,7 @@ expand_nl_goto_receivers (thisblock)\n       emit_barrier ();\n     }\n \n+  nonlocal_goto_handler_labels = label_list;\n   emit_label (afterward);\n }\n "}, {"sha": "252bd90e668b372ec3ac2bc53892cacecdd49ca7", "filename": "gcc/toplev.c", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -292,6 +292,7 @@ int regmove_dump = 0;\n int sched_dump = 0;\n int local_reg_dump = 0;\n int global_reg_dump = 0;\n+int flow2_dump = 0;\n int sched2_dump = 0;\n int jump2_opt_dump = 0;\n #ifdef DELAY_SLOTS\n@@ -1286,6 +1287,7 @@ int regmove_time;\n int sched_time;\n int local_alloc_time;\n int global_alloc_time;\n+int flow2_time;\n int sched2_time;\n #ifdef DELAY_SLOTS\n int dbr_sched_time;\n@@ -2642,6 +2644,7 @@ compile_file (name)\n   sched_time = 0;\n   local_alloc_time = 0;\n   global_alloc_time = 0;\n+  flow2_time = 0;\n   sched2_time = 0;\n #ifdef DELAY_SLOTS\n   dbr_sched_time = 0;\n@@ -2759,6 +2762,12 @@ compile_file (name)\n       if (graph_dump_format != no_graph)\n \tclean_graph_dump_file (dump_base_name, \".greg\");\n     }\n+  if (flow2_dump)\n+    {\n+      clean_dump_file (\".flow2\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".flow2\");\n+    }\n   if (sched2_dump)\n     {\n       clean_dump_file (\".sched2\");\n@@ -3303,6 +3312,8 @@ compile_file (name)\n \tfinish_graph_dump_file (dump_base_name, \".lreg\");\n       if (global_reg_dump)\n \tfinish_graph_dump_file (dump_base_name, \".greg\");\n+      if (flow_dump)\n+\tfinish_graph_dump_file (dump_base_name, \".flow2\");\n       if (sched2_dump)\n \tfinish_graph_dump_file (dump_base_name, \".sched2\");\n       if (jump2_opt_dump)\n@@ -3346,6 +3357,7 @@ compile_file (name)\n       print_time (\"sched\", sched_time);\n       print_time (\"local-alloc\", local_alloc_time);\n       print_time (\"global-alloc\", global_alloc_time);\n+      print_time (\"flow2\", flow2_time);\n       print_time (\"sched2\", sched2_time);\n #ifdef DELAY_SLOTS\n       print_time (\"dbranch\", dbr_sched_time);\n@@ -4079,14 +4091,27 @@ rest_of_compilation (decl)\n \t}\n     }\n \n+  if (global_reg_dump)\n+    {\n+      TIMEVAR (dump_time, dump_global_regs (rtl_dump_file));\n+      close_dump_file (print_rtl_with_bb, insns);\n+      if (graph_dump_format != no_graph)\n+\tprint_rtl_graph_with_bb (dump_base_name, \".greg\", insns);\n+    }\n+\n   /* Re-create the death notes which were deleted during reload.  */\n+  if (flow2_dump)\n+    open_dump_file (\".flow2\", decl_printable_name (decl, 2));\n+  \n   if (optimize)\n-    TIMEVAR\n-      (flow_time,\n-       {\n-\t find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-\t life_analysis (insns, max_reg_num (), rtl_dump_file);\n-       });\n+    {\n+      TIMEVAR\n+\t(flow2_time,\n+\t {\n+\t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t   life_analysis (insns, max_reg_num (), rtl_dump_file);\n+\t });\n+    }\n \n   flow2_completed = 1;\n \n@@ -4097,13 +4122,13 @@ rest_of_compilation (decl)\n \n   thread_prologue_and_epilogue_insns (insns);\n \n-  if (global_reg_dump)\n+  if (flow2_dump)\n     {\n-      TIMEVAR (dump_time, dump_global_regs (rtl_dump_file));\n       close_dump_file (print_rtl_with_bb, insns);\n       if (graph_dump_format != no_graph)\n-\tprint_rtl_graph_with_bb (dump_base_name, \".greg\", insns);\n+\tprint_rtl_graph_with_bb (dump_base_name, \".flow2\", insns);\n     }\n+\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n       if (sched2_dump)\n@@ -4227,6 +4252,9 @@ rest_of_compilation (decl)\n \t     if (! quiet_flag)\n \t       fflush (asm_out_file);\n \n+\t     /* Release all memory allocated by flow.  */\n+\t     free_basic_block_vars (0);\n+\n \t     /* Release all memory held by regsets now */\n \t     regset_release_memory ();\n \t   });\n@@ -4258,7 +4286,7 @@ rest_of_compilation (decl)\n \n  exit_rest_of_compilation:\n \n-  free_bb_memory ();\n+  free_bb_mem ();\n \n   /* In case the function was not output,\n      don't leave any temporary anonymous types\n@@ -4770,6 +4798,7 @@ main (argc, argv)\n  \t\t    dbr_sched_dump = 1;\n #endif\n  \t\t    flow_dump = 1;\n+ \t\t    flow2_dump = 1;\n  \t\t    global_reg_dump = 1;\n  \t\t    jump_opt_dump = 1;\n  \t\t    addressof_dump = 1;\n@@ -4864,6 +4893,9 @@ main (argc, argv)\n \t\t  case 'v':\n \t\t    graph_dump_format = vcg;\n \t\t    break;\n+\t\t  case 'w':\n+\t\t    flow2_dump = 1;\n+\t\t    break;\n \t\t  case 'y':\n \t\t    set_yydebug (1);\n \t\t    break;"}, {"sha": "28c3e7b7cc309ae629f4410bdd2cc4c70455465d", "filename": "gcc/unroll.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -2129,8 +2129,12 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \tcase NOTE:\n \t  /* VTOP notes are valid only before the loop exit test.  If placed\n \t     anywhere else, loop may generate bad code.  */\n+\t  /* BASIC_BLOCK notes exist to stabilize basic block structures with\n+\t     the associated rtl.  We do not want to share the structure in \n+\t     this new block.  */\n \n \t  if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n \t      && (NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_VTOP\n \t\t  || (last_iteration && unroll_type != UNROLL_COMPLETELY)))\n \t    copy = emit_note (NOTE_SOURCE_FILE (insn),\n@@ -2175,7 +2179,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n       for (insn = copy_notes_from; insn != loop_end; insn = NEXT_INSN (insn))\n \t{\n \t  if (GET_CODE (insn) == NOTE\n-\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED)\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n \t    emit_note (NOTE_SOURCE_FILE (insn), NOTE_LINE_NUMBER (insn));\n \t}\n     }"}, {"sha": "7d4f6972f268c359edca92fc38131496d0893f84", "filename": "gcc/varray.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881bb1b1b60bca2b51088b8c6946feb96b0047f/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=e881bb1b1b60bca2b51088b8c6946feb96b0047f", "patch": "@@ -75,6 +75,7 @@ typedef union varray_data_tag {\n   struct sched_info_tag\t *sched[1];\n   struct reg_info_def\t *reg[1];\n   struct const_equiv_data const_equiv[1];\n+  struct basic_block_def *bb[1];\n } varray_data;\n \n /* Virtual array of pointers header.  */\n@@ -146,6 +147,9 @@ extern varray_type varray_init\tPROTO ((size_t, size_t, const char *));\n #define VARRAY_CONST_EQUIV_INIT(va, num, name) \\\n   va = varray_init (num, sizeof (struct const_equiv_data), name)\n \n+#define VARRAY_BB_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (struct basic_block_def *), name)\n+\n /* Free up memory allocated by the virtual array, but do not free any of the\n    elements involved.  */\n #define VARRAY_FREE(vp) \\\n@@ -189,6 +193,7 @@ extern varray_type varray_grow\tPROTO((varray_type, size_t));\n #define VARRAY_BITMAP(VA, N)\t((VA)->data.bitmap[ VARRAY_CHECK (VA, N) ])\n #define VARRAY_SCHED(VA, N)\t((VA)->data.sched[ VARRAY_CHECK (VA, N) ])\n #define VARRAY_REG(VA, N)\t((VA)->data.reg[ VARRAY_CHECK (VA, N) ])\n-#define VARRAY_CONST_EQUIV(VA, N) ((VA)->data.const_equiv[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_CONST_EQUIV(VA, N) ((VA)->data.const_equiv[VARRAY_CHECK (VA, N)])\n+#define VARRAY_BB(VA, N)\t((VA)->data.bb[ VARRAY_CHECK (VA, N) ])\n \n #endif /* _VARRAY_H_ */"}]}