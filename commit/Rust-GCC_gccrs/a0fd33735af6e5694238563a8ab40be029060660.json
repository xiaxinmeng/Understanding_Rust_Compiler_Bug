{"sha": "a0fd33735af6e5694238563a8ab40be029060660", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBmZDMzNzM1YWY2ZTU2OTQyMzg1NjNhOGFiNDBiZTAyOTA2MDY2MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-30T07:48:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-30T07:48:13Z"}, "message": "devirt-34.C: New testcase.\n\n\n\t* g++.dg/ipa/devirt-34.C: New testcase.\n\t* ipa-devirt.c (polymorphic_call_target_d): Rename nonconstruction_targets\n\tto speculative_targets\n\t(get_class_context): Fix handling of contextes without outer type;\n\tavoid matching non-polymorphic types in LTO.\n\t(possible_polymorphic_call_targets): Trun nonconstruction_targetsp\n\tparameter to speculative_targetsp; handle speculation.\n\t(dump_possible_polymorphic_call_targets): Update dumping.\n\nFrom-SVN: r213232", "tree": {"sha": "bb01706109f71a5e58004af1b340b038a77eb8d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb01706109f71a5e58004af1b340b038a77eb8d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0fd33735af6e5694238563a8ab40be029060660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0fd33735af6e5694238563a8ab40be029060660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0fd33735af6e5694238563a8ab40be029060660", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0fd33735af6e5694238563a8ab40be029060660/comments", "author": null, "committer": null, "parents": [{"sha": "bb3ec3881ef26805aa0b9a58b871004d25cca9bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb3ec3881ef26805aa0b9a58b871004d25cca9bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb3ec3881ef26805aa0b9a58b871004d25cca9bc"}], "stats": {"total": 152, "additions": 122, "deletions": 30}, "files": [{"sha": "1076c0c5cefcd9fe76b3c29af50f03897061197d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0fd33735af6e5694238563a8ab40be029060660/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0fd33735af6e5694238563a8ab40be029060660/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0fd33735af6e5694238563a8ab40be029060660", "patch": "@@ -1,3 +1,18 @@\n+2014-07-29  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/ipa/devirt-34.C: New testcase.\n+\t* ipa-devirt.c (polymorphic_call_target_d): Rename nonconstruction_targets\n+\tto speculative_targets\n+\t(get_class_context): Fix handling of contextes without outer type;\n+\tavoid matching non-polymorphic types in LTO.\n+\t(possible_polymorphic_call_targets): Trun nonconstruction_targetsp\n+\tparameter to speculative_targetsp; handle speculation.\n+\t(dump_possible_polymorphic_call_targets): Update dumping.\n+\n+2014-07-29  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* common.opt (Wodr): Enable by default.\n+\n 2014-07-29  Olivier Hainque  <hainque@adacore.com>\n \n \t* config/vxworksae.h (VXWORKS_OVERRIDE_OPTIONS): Define."}, {"sha": "927e0edf9a45386df6db098303d2ba8d1f4794ab", "filename": "gcc/common.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0fd33735af6e5694238563a8ab40be029060660/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0fd33735af6e5694238563a8ab40be029060660/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a0fd33735af6e5694238563a8ab40be029060660", "patch": "@@ -588,7 +588,7 @@ Wmissing-noreturn\n Common Alias(Wsuggest-attribute=noreturn)\n \n Wodr\n-Common Var(warn_odr_violations) Warning\n+Common Var(warn_odr_violations) Init(1) Warning\n Warn about some C++ One Definition Rule violations during link time optimization\n \n Woverflow"}, {"sha": "1c6d19dbc886c441d090b9954137a0926bc85f53", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 89, "deletions": 29, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0fd33735af6e5694238563a8ab40be029060660/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0fd33735af6e5694238563a8ab40be029060660/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=a0fd33735af6e5694238563a8ab40be029060660", "patch": "@@ -1615,7 +1615,7 @@ struct polymorphic_call_target_d\n   ipa_polymorphic_call_context context;\n   odr_type type;\n   vec <cgraph_node *> targets;\n-  int nonconstruction_targets;\n+  int speculative_targets;\n   bool complete;\n };\n \n@@ -1770,8 +1770,8 @@ get_class_context (ipa_polymorphic_call_context *context,\n \n  if (!context->outer_type)\n    {\n-     context->outer_type = expected_type;\n-     context->offset = offset;\n+     type = context->outer_type = expected_type;\n+     context->offset = offset = 0;\n    }\n   /* See if speculative type seem to be derrived from outer_type.\n      Then speculation is valid only if it really is a derivate and derived types\n@@ -1807,6 +1807,10 @@ get_class_context (ipa_polymorphic_call_context *context,\n \n       /* On a match, just return what we found.  */\n       if (TREE_CODE (type) == TREE_CODE (expected_type)\n+\t  && (!in_lto_p\n+\t      || (TREE_CODE (type) == RECORD_TYPE\n+\t\t  && TYPE_BINFO (type)\n+\t\t  && polymorphic_type_binfo_p (TYPE_BINFO (type))))\n \t  && types_same_for_odr (type, expected_type))\n \t{\n \t  if (speculative)\n@@ -2518,9 +2522,10 @@ devirt_variable_node_removal_hook (varpool_node *n,\n    in the target cache.  If user needs to visit every target list\n    just once, it can memoize them.\n \n-   NONCONSTRUCTION_TARGETS specify number of targets with asumption that\n-   the type is not in the construction.  Those targets appear first in the\n-   vector returned.\n+   SPECULATION_TARGETS specify number of targets that are speculatively\n+   likely.  These include targets specified by the speculative part\n+   of polymoprhic call context and also exclude all targets for classes\n+   in construction.\n \n    Returned vector is placed into cache.  It is NOT caller's responsibility\n    to free it.  The vector can be freed on cgraph_remove_node call if\n@@ -2532,7 +2537,7 @@ possible_polymorphic_call_targets (tree otr_type,\n \t\t\t\t   ipa_polymorphic_call_context context,\n \t\t\t           bool *completep,\n \t\t\t           void **cache_token,\n-\t\t\t\t   int *nonconstruction_targetsp)\n+\t\t\t\t   int *speculative_targetsp)\n {\n   static struct cgraph_node_hook_list *node_removal_hook_holder;\n   pointer_set_t *inserted;\n@@ -2557,8 +2562,8 @@ possible_polymorphic_call_targets (tree otr_type,\n \t*completep = false;\n       if (cache_token)\n \t*cache_token = NULL;\n-      if (nonconstruction_targetsp)\n-\t*nonconstruction_targetsp = 0;\n+      if (speculative_targetsp)\n+\t*speculative_targetsp = 0;\n       return nodes;\n     }\n \n@@ -2569,8 +2574,8 @@ possible_polymorphic_call_targets (tree otr_type,\n \t*completep = true;\n       if (cache_token)\n \t*cache_token = NULL;\n-      if (nonconstruction_targetsp)\n-\t*nonconstruction_targetsp = 0;\n+      if (speculative_targetsp)\n+\t*speculative_targetsp = 0;\n       return nodes;\n     }\n \n@@ -2581,15 +2586,15 @@ possible_polymorphic_call_targets (tree otr_type,\n \t      || TYPE_MAIN_VARIANT (context.outer_type) == context.outer_type);\n \n   /* Lookup the outer class type we want to walk.  */\n-  if (context.outer_type\n+  if ((context.outer_type || context.speculative_outer_type)\n       && !get_class_context (&context, otr_type))\n     {\n       if (completep)\n \t*completep = false;\n       if (cache_token)\n \t*cache_token = NULL;\n-      if (nonconstruction_targetsp)\n-\t*nonconstruction_targetsp = 0;\n+      if (speculative_targetsp)\n+\t*speculative_targetsp = 0;\n       return nodes;\n     }\n \n@@ -2638,8 +2643,8 @@ possible_polymorphic_call_targets (tree otr_type,\n     {\n       if (completep)\n \t*completep = (*slot)->complete;\n-      if (nonconstruction_targetsp)\n-\t*nonconstruction_targetsp = (*slot)->nonconstruction_targets;\n+      if (speculative_targetsp)\n+\t*speculative_targetsp = (*slot)->speculative_targets;\n       return (*slot)->targets;\n     }\n \n@@ -2653,10 +2658,57 @@ possible_polymorphic_call_targets (tree otr_type,\n   (*slot)->type = type;\n   (*slot)->otr_token = otr_token;\n   (*slot)->context = context;\n+  (*slot)->speculative_targets = 0;\n \n   inserted = pointer_set_create ();\n   matched_vtables = pointer_set_create ();\n \n+  if (context.speculative_outer_type)\n+    {\n+      odr_type speculative_outer_type;\n+      speculative_outer_type = get_odr_type (context.speculative_outer_type, true);\n+      if (TYPE_FINAL_P (speculative_outer_type->type))\n+\tcontext.speculative_maybe_derived_type = false;\n+      binfo = get_binfo_at_offset (TYPE_BINFO (speculative_outer_type->type),\n+\t\t\t\t   context.speculative_offset, otr_type);\n+      if (binfo)\n+\ttarget = gimple_get_virt_method_for_binfo (otr_token, binfo,\n+\t\t\t\t\t\t   &can_refer);\n+      else\n+\ttarget = NULL;\n+\n+      if (target)\n+\t{\n+\t  /* In the case we get complete method, we don't need \n+\t     to walk derivations.  */\n+\t  if (DECL_FINAL_P (target))\n+\t    context.speculative_maybe_derived_type = false;\n+\t}\n+      if (type_possibly_instantiated_p (speculative_outer_type->type))\n+\tmaybe_record_node (nodes, target, inserted, can_refer, &complete);\n+      if (binfo)\n+\tpointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n+      /* Next walk recursively all derived types.  */\n+      if (context.speculative_maybe_derived_type)\n+\t{\n+\t  /* For anonymous namespace types we can attempt to build full type.\n+\t     All derivations must be in this unit (unless we see partial unit).  */\n+\t  if (!type->all_derivations_known)\n+\t    complete = false;\n+\t  for (i = 0; i < speculative_outer_type->derived_types.length(); i++)\n+\t    possible_polymorphic_call_targets_1 (nodes, inserted,\n+\t\t\t\t\t\t matched_vtables,\n+\t\t\t\t\t\t otr_type,\n+\t\t\t\t\t\t speculative_outer_type->derived_types[i],\n+\t\t\t\t\t\t otr_token, speculative_outer_type->type,\n+\t\t\t\t\t\t context.speculative_offset, &complete,\n+\t\t\t\t\t\t bases_to_consider,\n+\t\t\t\t\t\t false);\n+\t}\n+      /* Finally walk bases, if asked to.  */\n+      (*slot)->speculative_targets = nodes.length();\n+    }\n+\n   /* First see virtual method of type itself.  */\n   binfo = get_binfo_at_offset (TYPE_BINFO (outer_type->type),\n \t\t\t       context.offset, otr_type);\n@@ -2713,7 +2765,8 @@ possible_polymorphic_call_targets (tree otr_type,\n     }\n \n   /* Finally walk bases, if asked to.  */\n-  (*slot)->nonconstruction_targets = nodes.length();\n+  if (!(*slot)->speculative_targets)\n+    (*slot)->speculative_targets = nodes.length();\n \n   /* Destructors are never called through construction virtual tables,\n      because the type is always known.  One of entries may be cxa_pure_virtual\n@@ -2742,8 +2795,8 @@ possible_polymorphic_call_targets (tree otr_type,\n   (*slot)->complete = complete;\n   if (completep)\n     *completep = complete;\n-  if (nonconstruction_targetsp)\n-    *nonconstruction_targetsp = (*slot)->nonconstruction_targets;\n+  if (speculative_targetsp)\n+    *speculative_targetsp = (*slot)->speculative_targets;\n \n   pointer_set_destroy (inserted);\n   pointer_set_destroy (matched_vtables);\n@@ -2763,13 +2816,13 @@ dump_possible_polymorphic_call_targets (FILE *f,\n   bool final;\n   odr_type type = get_odr_type (TYPE_MAIN_VARIANT (otr_type), false);\n   unsigned int i;\n-  int nonconstruction;\n+  int speculative;\n \n   if (!type)\n     return;\n   targets = possible_polymorphic_call_targets (otr_type, otr_token,\n \t\t\t\t\t       ctx,\n-\t\t\t\t\t       &final, NULL, &nonconstruction);\n+\t\t\t\t\t       &final, NULL, &speculative);\n   fprintf (f, \"  Targets of polymorphic call of type %i:\", type->id);\n   print_generic_expr (f, type->type, TDF_SLIM);\n   fprintf (f, \" token %i\\n\", (int)otr_token);\n@@ -2780,18 +2833,25 @@ dump_possible_polymorphic_call_targets (FILE *f,\n       fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n \t       ctx.offset);\n     }\n+  if (ctx.speculative_outer_type)\n+    {\n+      fprintf (f, \"    Speculatively contained in type:\");\n+      print_generic_expr (f, ctx.speculative_outer_type, TDF_SLIM);\n+      fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t       ctx.speculative_offset);\n+    }\n \n-  fprintf (f, \"    %s%s%s\\n      \",\n+  fprintf (f, \"    %s%s%s%s\\n      \",\n \t   final ? \"This is a complete list.\" :\n \t   \"This is partial list; extra targets may be defined in other units.\",\n \t   ctx.maybe_in_construction ? \" (base types included)\" : \"\",\n-\t   ctx.maybe_derived_type ? \" (derived types included)\" : \"\");\n+\t   ctx.maybe_derived_type ? \" (derived types included)\" : \"\",\n+\t   ctx.speculative_maybe_derived_type ? \" (speculative derived types included)\" : \"\");\n   for (i = 0; i < targets.length (); i++)\n     {\n       char *name = NULL;\n-      if (i == (unsigned)nonconstruction)\n-\tfprintf (f, \"\\n     If the type is in construction,\"\n-\t\t \" then additional tarets are:\\n\"\n+      if (i == (unsigned)speculative)\n+\tfprintf (f, \"\\n     Targets that are not likely:\\n\"\n \t\t \"      \");\n       if (in_lto_p)\n \tname = cplus_demangle_v3 (targets[i]->asm_name (), 0);\n@@ -2921,10 +2981,10 @@ ipa_devirt (void)\n \t    struct cgraph_node *likely_target = NULL;\n \t    void *cache_token;\n \t    bool final;\n-\t    int nonconstruction_targets;\n+\t    int speculative_targets;\n \t    vec <cgraph_node *>targets\n \t       = possible_polymorphic_call_targets\n-\t\t    (e, &final, &cache_token, &nonconstruction_targets);\n+\t\t    (e, &final, &cache_token, &speculative_targets);\n \t    unsigned int i;\n \n \t    if (dump_file)\n@@ -2963,7 +3023,7 @@ ipa_devirt (void)\n \t\t{\n \t\t  if (likely_target)\n \t\t    {\n-\t\t      if (i < (unsigned) nonconstruction_targets)\n+\t\t      if (i < (unsigned) speculative_targets)\n \t\t\t{\n \t\t\t  likely_target = NULL;\n \t\t\t  if (dump_file)"}, {"sha": "258a2aded46072a22a9ce83f02e65da02b8ffb73", "filename": "gcc/testsuite/g++.dg/ipa/devirt-34.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0fd33735af6e5694238563a8ab40be029060660/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0fd33735af6e5694238563a8ab40be029060660/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C?ref=a0fd33735af6e5694238563a8ab40be029060660", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-devirt\"  } */\n+struct A {virtual int t(){return 42;}};\n+struct B:A {virtual int t(){return 1;}};\n+int\n+t(struct B *b)\n+{\n+  struct A *a=b;\n+  a->t();\n+}\n+\n+/* We should guess that the pointer of type B probably points to an instance\n+   of B or its derivates and exclude A::t from list of likely targets.  */\n+\n+/* { dg-final { scan-ipa-dump \"Targets that are not likely\"  \"devirt\"  } } */\n+/* { dg-final { scan-ipa-dump \"1 speculatively devirtualized\"  \"devirt\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"devirt\" } } */"}]}