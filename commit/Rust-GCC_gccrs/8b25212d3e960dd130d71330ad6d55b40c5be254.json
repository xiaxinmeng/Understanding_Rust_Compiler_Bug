{"sha": "8b25212d3e960dd130d71330ad6d55b40c5be254", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIyNTIxMmQzZTk2MGRkMTMwZDcxMzMwYWQ2ZDU1YjQwYzViZTI1NA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:33:47Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:33:47Z"}, "message": "Make cgraph_edge::uid really unique.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* cgraph.c (symbol_table::create_edge): Always assign a new\n\tunique number.\n\t(symbol_table::free_edge): Do not recycle numbers.\n\t* cgraph.h (cgraph_edge::get): New method.\n\t* symbol-summary.h (symtab_removal): Use it.\n\t(symtab_duplication): Likewise.\n\t(call_summary::hashable_uid): Remove.\n\nFrom-SVN: r261319", "tree": {"sha": "5b0cf4f88de2297422b17172c003f1be6bc67986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b0cf4f88de2297422b17172c003f1be6bc67986"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b25212d3e960dd130d71330ad6d55b40c5be254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b25212d3e960dd130d71330ad6d55b40c5be254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b25212d3e960dd130d71330ad6d55b40c5be254", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b25212d3e960dd130d71330ad6d55b40c5be254/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fb50ad822bd57786b12a2fc90c61032c519a621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb50ad822bd57786b12a2fc90c61032c519a621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb50ad822bd57786b12a2fc90c61032c519a621"}], "stats": {"total": 55, "additions": 31, "deletions": 24}, "files": [{"sha": "a7424bb32c961fd9b7952d56df113a78bce49045", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b25212d3e960dd130d71330ad6d55b40c5be254/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b25212d3e960dd130d71330ad6d55b40c5be254/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b25212d3e960dd130d71330ad6d55b40c5be254", "patch": "@@ -1,3 +1,13 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.c (symbol_table::create_edge): Always assign a new\n+\tunique number.\n+\t(symbol_table::free_edge): Do not recycle numbers.\n+\t* cgraph.h (cgraph_edge::get): New method.\n+\t* symbol-summary.h (symtab_removal): Use it.\n+\t(symtab_duplication): Likewise.\n+\t(call_summary::hashable_uid): Remove.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-inline-analysis.c (inline_edge_removal_hook): Remove."}, {"sha": "cf6b35a1c83390af9e3e237c62796b0b55481218", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b25212d3e960dd130d71330ad6d55b40c5be254/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b25212d3e960dd130d71330ad6d55b40c5be254/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=8b25212d3e960dd130d71330ad6d55b40c5be254", "patch": "@@ -850,13 +850,12 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n       free_edges = NEXT_FREE_EDGE (edge);\n     }\n   else\n-    {\n-      edge = ggc_alloc<cgraph_edge> ();\n-      edge->uid = edges_max_uid++;\n-    }\n+    edge = ggc_alloc<cgraph_edge> ();\n \n   edges_count++;\n \n+  gcc_assert (++edges_max_uid != 0);\n+  edge->m_uid = edges_max_uid;\n   edge->aux = NULL;\n   edge->caller = caller;\n   edge->callee = callee;\n@@ -1010,14 +1009,11 @@ cgraph_edge::remove_caller (void)\n void\n symbol_table::free_edge (cgraph_edge *e)\n {\n-  int uid = e->uid;\n-\n   if (e->indirect_info)\n     ggc_free (e->indirect_info);\n \n   /* Clear out the edge so we do not dangle pointers.  */\n   memset (e, 0, sizeof (*e));\n-  e->uid = uid;\n   NEXT_FREE_EDGE (e) = free_edges;\n   free_edges = e;\n   edges_count--;"}, {"sha": "6d5a2b898a9d683d2fab2f2002a075bb5da15d47", "filename": "gcc/cgraph.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b25212d3e960dd130d71330ad6d55b40c5be254/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b25212d3e960dd130d71330ad6d55b40c5be254/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=8b25212d3e960dd130d71330ad6d55b40c5be254", "patch": "@@ -1626,6 +1626,7 @@ struct GTY(()) cgraph_indirect_call_info\n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n \t    for_user)) cgraph_edge {\n   friend class cgraph_node;\n+  friend class symbol_table;\n \n   /* Remove the edge in the cgraph.  */\n   void remove (void);\n@@ -1689,6 +1690,12 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Return true if the call can be hot.  */\n   bool maybe_hot_p (void);\n \n+  /* Get unique identifier of the edge.  */\n+  inline int get_uid ()\n+  {\n+    return m_uid;\n+  }\n+\n   /* Rebuild cgraph edges for current function node.  This needs to be run after\n      passes that don't update the cgraph.  */\n   static unsigned int rebuild_edges (void);\n@@ -1716,8 +1723,6 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* The stmt_uid of call_stmt.  This is used by LTO to recover the call_stmt\n      when the function is serialized in.  */\n   unsigned int lto_stmt_uid;\n-  /* Unique id of the edge.  */\n-  int uid;\n   /* Whether this edge was made direct by indirect inlining.  */\n   unsigned int indirect_inlining_edge : 1;\n   /* Whether this edge describes an indirect call with an undetermined\n@@ -1761,6 +1766,9 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Expected frequency of executions within the function.  */\n   sreal sreal_frequency ();\n private:\n+  /* Unique id of the edge.  */\n+  int m_uid;\n+\n   /* Remove the edge from the list of the callers of the callee.  */\n   void remove_caller (void);\n \n@@ -2011,7 +2019,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   friend class cgraph_node;\n   friend class cgraph_edge;\n \n-  symbol_table (): cgraph_max_uid (1)\n+  symbol_table (): cgraph_max_uid (1), edges_max_uid (1)\n   {\n   }\n "}, {"sha": "8c80f3093726137cfc0fdac1c2c7d193f65dfd2b", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b25212d3e960dd130d71330ad6d55b40c5be254/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b25212d3e960dd130d71330ad6d55b40c5be254/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=8b25212d3e960dd130d71330ad6d55b40c5be254", "patch": "@@ -375,19 +375,19 @@ class GTY((user)) call_summary <T *>\n      If a summary for an edge does not exist, it will be created.  */\n   T* get_create (cgraph_edge *edge)\n   {\n-    return get (hashable_uid (edge), true);\n+    return get (edge->get_uid (), true);\n   }\n \n   /* Getter for summary callgraph edge pointer.  */\n   T* get (cgraph_edge *edge)\n   {\n-    return get (hashable_uid (edge), false);\n+    return get (edge->get_uid (), false);\n   }\n \n   /* Remove edge from summary.  */\n   void remove (cgraph_edge *edge)\n   {\n-    int uid = hashable_uid (edge);\n+    int uid = edge->get_uid ();\n     T **v = m_map.get (uid);\n     if (v)\n       {\n@@ -405,7 +405,7 @@ class GTY((user)) call_summary <T *>\n   /* Return true if a summary for the given EDGE already exists.  */\n   bool exists (cgraph_edge *edge)\n   {\n-    return m_map.get (hashable_uid (edge)) != NULL;\n+    return m_map.get (edge->get_uid ()) != NULL;\n   }\n \n   /* Symbol removal hook that is registered to symbol table.  */\n@@ -428,13 +428,6 @@ class GTY((user)) call_summary <T *>\n   /* Getter for summary callgraph ID.  */\n   T *get (int uid, bool lazy_insert);\n \n-  /* Get a hashable uid of EDGE.  */\n-  int hashable_uid (cgraph_edge *edge)\n-  {\n-    /* Edge uids start at zero which our hash_map does not like.  */\n-    return edge->uid + 1;\n-  }\n-\n   /* Main summary store, where summary ID is used as key.  */\n   hash_map <map_hash, T *> m_map;\n   /* Internal summary removal hook pointer.  */\n@@ -511,7 +504,7 @@ call_summary<T *>::symtab_removal (cgraph_edge *edge, void *data)\n {\n   call_summary *summary = (call_summary <T *> *) (data);\n \n-  int h_uid = summary->hashable_uid (edge);\n+  int h_uid = edge->get_uid ();\n   T **v = summary->m_map.get (h_uid);\n \n   if (v)\n@@ -534,7 +527,7 @@ call_summary<T *>::symtab_duplication (cgraph_edge *edge1,\n     edge1_summary = summary->get_create (edge1);\n   else\n     {\n-      T **v = summary->m_map.get (summary->hashable_uid (edge1));\n+      T **v = summary->m_map.get (edge1->get_uid ());\n       if (v)\n \t{\n \t  /* This load is necessary, because we insert a new value!  */\n@@ -545,7 +538,7 @@ call_summary<T *>::symtab_duplication (cgraph_edge *edge1,\n   if (edge1_summary)\n     {\n       T *duplicate = summary->allocate_new ();\n-      summary->m_map.put (summary->hashable_uid (edge2), duplicate);\n+      summary->m_map.put (edge2->get_uid (), duplicate);\n       summary->duplicate (edge1, edge2, edge1_summary, duplicate);\n     }\n }"}]}