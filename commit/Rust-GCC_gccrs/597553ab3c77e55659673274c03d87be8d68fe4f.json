{"sha": "597553ab3c77e55659673274c03d87be8d68fe4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk3NTUzYWIzYzc3ZTU1NjU5NjczMjc0YzAzZDg3YmU4ZDY4ZmU0Zg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-11-28T13:47:26Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-11-28T13:47:26Z"}, "message": "re PR fortran/35810 ([TR 15581 / F2003] Automatic reallocation on assignment to allocatable variables)\n\n2010-11-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\t PR fortran/35810\n\t* trans-array.c (gfc_trans_array_constructor): If the loop->to\n\tis a VAR_DECL, assume this is dynamic. In this case, use the\n\tcounter to obtain the value and set loop->to appropriately.\n\t(gfc_conv_ss_descriptor): Always save the offset of a variable\n\tin info.saved_offset.\n\t(gfc_conv_ss_startstride): Do not attempt bound checking of the\n\tlhs of an assignment, if allocatable and f2003 is allowed.\n\t(gfc_conv_loop_setup): If possible, do not use an allocatable\n\tlhs variable for the loopspec.\n\t(gfc_is_reallocatable_lhs): New function.\n\t(get_std_lbound): New function.\n\t(gfc_alloc_allocatable_for_assignment): New function.\n\t* gfortran.h : Add flag_realloc_lhs to the options structure.\n\t* lang.opt : Add option f(no-)realloc-lhs.\n\t* invoke.texi : Document option f(no-)realloc-lhs.\n\t* options.c (gfc_init_options, gfc_post_options,\n\tgfc_handle_option): Incorporate f(no-)realloc-lhs with default\n\tto frealloc_lhs for -std > f95.\n\t* trans-array.h : Add primitive for previous.\n\t* trans-expr.c (gfc_conv_string_length): Return if character\n\tlength is a variable and the expression is NULL.\n\t(gfc_conv_procedure_call): If the call is of the kind x = f(...)\n\tand the lhs is allocatable and reallocation on assignment OK,\n\tcall gfc_alloc_allocatable_for_assignment. Do not generate the\n\tfunction call unless direct by reference.\n\t(realloc_lhs_loop_for_fcn_call): New function.\n\t(realloc_lhs_bounds_for_intrinsic_call): New function.\n\t(gfc_trans_arrayfunc_assign): Reallocation assignments need\n\ta loopinfo and for the loop bounds to be set.  With intrinsic\n\tfunctions, free the lhs data and let the library allocate the\n\tdata array. Done by the new functions above.\n\t(gfc_trans_assignment_1): If the lhs is allocatable and\n\treallocation on assignment is allowed, mark the lhs and use\n\tgfc_alloc_allocatable_for_assignment to make the reallocation.\n\t* trans.h : Add is_alloc_lhs bitfield to gfc_ss structure.\n\n2010-11-28  Paul Thomas  <pault@gcc.gnu.org\n\n\tPR fortran/35810\n\t* gfortran.dg/realloc_on_assign_1.f03: New test.\n\t* gfortran.dg/realloc_on_assign_2.f03: New test.\n\t* gfortran.dg/transpose_2.f90: dg-option -fno-realloc-lhs.\n\t* gfortran.dg/unpack_bounds_1.f90: The same.\n\t* gfortran.dg/cshift_bounds_2.f90: The same.\n\t* gfortran.dg/matmul_bounds_2.f90: The same.\n\t* gfortran.dg/matmul_bounds_3.f90: The same.\n\t* gfortran.dg/matmul_bounds_4.f90: The same.\n\t* gfortran.dg/matmul_bounds_5.f90: The same.\n\nFrom-SVN: r167220", "tree": {"sha": "22c201ed393b50d88c4f265a2798d7bbdbe6e26a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22c201ed393b50d88c4f265a2798d7bbdbe6e26a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/597553ab3c77e55659673274c03d87be8d68fe4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/597553ab3c77e55659673274c03d87be8d68fe4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/597553ab3c77e55659673274c03d87be8d68fe4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/597553ab3c77e55659673274c03d87be8d68fe4f/comments", "author": null, "committer": null, "parents": [{"sha": "18af637ed97554b264b1b56fb55c1767938c92cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18af637ed97554b264b1b56fb55c1767938c92cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18af637ed97554b264b1b56fb55c1767938c92cf"}], "stats": {"total": 977, "additions": 963, "deletions": 14}, "files": [{"sha": "12a8afc81bbce587d33eeb62ebe98199fa7279da", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,3 +1,42 @@\n+2010-11-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t PR fortran/35810\n+\t* trans-array.c (gfc_trans_array_constructor): If the loop->to\n+\tis a VAR_DECL, assume this is dynamic. In this case, use the\n+\tcounter to obtain the value and set loop->to appropriately.\n+\t(gfc_conv_ss_descriptor): Always save the offset of a variable\n+\tin info.saved_offset.\n+\t(gfc_conv_ss_startstride): Do not attempt bound checking of the\n+\tlhs of an assignment, if allocatable and f2003 is allowed.\n+\t(gfc_conv_loop_setup): If possible, do not use an allocatable\n+\tlhs variable for the loopspec.\n+\t(gfc_is_reallocatable_lhs): New function.\n+\t(get_std_lbound): New function.\n+\t(gfc_alloc_allocatable_for_assignment): New function.\n+\t* gfortran.h : Add flag_realloc_lhs to the options structure.\n+\t* lang.opt : Add option f(no-)realloc-lhs.\n+\t* invoke.texi : Document option f(no-)realloc-lhs.\n+\t* options.c (gfc_init_options, gfc_post_options,\n+\tgfc_handle_option): Incorporate f(no-)realloc-lhs with default\n+\tto frealloc_lhs for -std > f95.\n+\t* trans-array.h : Add primitive for previous.\n+\t* trans-expr.c (gfc_conv_string_length): Return if character\n+\tlength is a variable and the expression is NULL.\n+\t(gfc_conv_procedure_call): If the call is of the kind x = f(...)\n+\tand the lhs is allocatable and reallocation on assignment OK,\n+\tcall gfc_alloc_allocatable_for_assignment. Do not generate the\n+\tfunction call unless direct by reference.\n+\t(realloc_lhs_loop_for_fcn_call): New function.\n+\t(realloc_lhs_bounds_for_intrinsic_call): New function.\n+\t(gfc_trans_arrayfunc_assign): Reallocation assignments need\n+\ta loopinfo and for the loop bounds to be set.  With intrinsic\n+\tfunctions, free the lhs data and let the library allocate the\n+\tdata array. Done by the new functions above.\n+\t(gfc_trans_assignment_1): If the lhs is allocatable and\n+\treallocation on assignment is allowed, mark the lhs and use\n+\tgfc_alloc_allocatable_for_assignment to make the reallocation.\n+\t* trans.h : Add is_alloc_lhs bitfield to gfc_ss structure.\n+\n 2010-11-27  Tobias Burnus  <burnus@net-b.de>\n \t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n "}, {"sha": "d8dd14782e7d534a0b9cebdf82defabe9711e76c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -2238,6 +2238,7 @@ typedef struct\n   int flag_align_commons;\n   int flag_whole_file;\n   int flag_protect_parens;\n+  int flag_realloc_lhs;\n \n   int fpe;\n   int rtcheck;"}, {"sha": "3dcdbcc9763e876534c70ebef84816d5ccb65d54", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -171,7 +171,7 @@ and warnings}.\n -fblas-matmul-limit=@var{n} -frecursive -finit-local-zero @gol\n -finit-integer=@var{n} -finit-real=@var{<zero|inf|-inf|nan|snan>} @gol\n -finit-logical=@var{<true|false>} -finit-character=@var{n} @gol\n--fno-align-commons -fno-protect-parens}\n+-fno-align-commons -fno-protect-parens -frealloc-lhs}\n @end table\n \n @menu\n@@ -1458,6 +1458,13 @@ levels such that the compiler does not do any re-association. Using\n @code{COMPLEX} expressions to produce faster code. Note that for the re-association\n optimization @option{-fno-signed-zeros} and @option{-fno-trapping-math}\n need to be in effect.\n+\n+@item -frealloc-lhs\n+@opindex @code{frealloc-lhs}\n+@cindex Reallocate the LHS in assignments\n+An allocatable left-hand side of an intrinsic assignment is automatically\n+(re)allocated if it is either unallocated or has a different shape. The\n+option is enabled by default except when @option{-std=f95} is given.\n @end table\n \n @xref{Code Gen Options,,Options for Code Generation Conventions,"}, {"sha": "69b3144d65662392d2970a7182260e9f82c85bac", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -474,6 +474,10 @@ frange-check\n Fortran\n Enable range checking during compilation\n \n+frealloc-lhs\n+Fortran\n+Reallocate the LHS in assignments\n+\n frecord-marker=4\n Fortran RejectNegative\n Use a 4-byte record marker for unformatted files"}, {"sha": "1f1cdd111d6c082d4406b23176fc10138a726572", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -149,6 +149,7 @@ gfc_init_options (unsigned int decoded_options_count,\n   gfc_option.flag_init_character_value = (char)0;\n   gfc_option.flag_align_commons = 1;\n   gfc_option.flag_protect_parens = 1;\n+  gfc_option.flag_realloc_lhs = -1;\n   \n   gfc_option.fpe = 0;\n   gfc_option.rtcheck = 0;\n@@ -266,6 +267,16 @@ gfc_post_options (const char **pfilename)\n   if (flag_associative_math == -1)\n     flag_associative_math = (!flag_trapping_math && !flag_signed_zeros);\n \n+  /* By default, disable (re)allocation during assignment for -std=f95,\n+     and enable it for F2003/F2008/GNU/Legacy. */\n+  if (gfc_option.flag_realloc_lhs == -1)\n+    {\n+      if (gfc_option.allow_std & GFC_STD_F2003)\n+\tgfc_option.flag_realloc_lhs = 1;\n+      else\n+\tgfc_option.flag_realloc_lhs = 0;\n+    }\n+\n   /* -fbounds-check is equivalent to -fcheck=bounds */\n   if (flag_bounds_check)\n     gfc_option.rtcheck |= GFC_RTCHECK_BOUNDS;\n@@ -964,6 +975,10 @@ gfc_handle_option (size_t scode, const char *arg, int value,\n       gfc_option.flag_protect_parens = value;\n       break;\n \n+    case OPT_frealloc_lhs:\n+      gfc_option.flag_realloc_lhs = value;\n+      break;\n+\n     case OPT_fcheck_:\n       gfc_handle_runtime_check_option (arg);\n       break;"}, {"sha": "05ffef1ef0bbed22ee1b4076274a7ffa2642edf4", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 476, "deletions": 1, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1837,6 +1837,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n   tree offsetvar;\n   tree desc;\n   tree type;\n+  tree tmp;\n   bool dynamic;\n   bool old_first_len, old_typespec_chararray_ctor;\n   tree old_first_len_val;\n@@ -1949,6 +1950,9 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n \t}\n     }\n \n+  if (TREE_CODE (loop->to[0]) == VAR_DECL)\n+    dynamic = true;\n+\n   gfc_trans_create_temp_array (&loop->pre, &loop->post, loop, &ss->data.info,\n \t\t\t       type, NULL_TREE, dynamic, true, false, where);\n \n@@ -1963,12 +1967,23 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n   /* If the array grows dynamically, the upper bound of the loop variable\n      is determined by the array's final upper bound.  */\n   if (dynamic)\n-    loop->to[0] = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[0]);\n+    {\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     offsetvar, gfc_index_one_node);\n+      tmp = gfc_evaluate_now (tmp, &loop->pre);\n+      gfc_conv_descriptor_ubound_set (&loop->pre, desc, gfc_rank_cst[0], tmp);\n+      if (loop->to[0] && TREE_CODE (loop->to[0]) == VAR_DECL)\n+\tgfc_add_modify (&loop->pre, loop->to[0], tmp);\n+      else\n+\tloop->to[0] = tmp;\n+    }\n \n   if (TREE_USED (offsetvar))\n     pushdecl (offsetvar);\n   else\n     gcc_assert (INTEGER_CST_P (offset));\n+\n #if 0\n   /* Disable bound checking for now because it's probably broken.  */\n   if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n@@ -2181,6 +2196,11 @@ gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)\n \n       tmp = gfc_conv_array_offset (se.expr);\n       ss->data.info.offset = gfc_evaluate_now (tmp, block);\n+\n+      /* Make absolutely sure that the saved_offset is indeed saved\n+\t so that the variable is still accessible after the loops\n+\t are translated.  */\n+      ss->data.info.saved_offset = ss->data.info.offset;\n     }\n }\n \n@@ -3209,6 +3229,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  if (ss->type != GFC_SS_SECTION)\n \t    continue;\n \n+\t  /* Catch allocatable lhs in f2003.  */\n+\t  if (gfc_option.flag_realloc_lhs && ss->is_alloc_lhs)\n+\t    continue;\n+\n \t  gfc_start_block (&inner);\n \n \t  /* TODO: range checking for mapped dimensions.  */\n@@ -3676,6 +3700,11 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t      continue;\n \t    }\n \n+\t  /* Avoid using an allocatable lhs in an assignment, since\n+\t     there might be a reallocation coming.  */\n+\t  if (loopspec[n] && ss->is_alloc_lhs)\n+\t    continue;\n+\n \t  if (ss->type != GFC_SS_SECTION)\n \t    continue;\n \n@@ -6457,6 +6486,452 @@ gfc_copy_only_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n }\n \n \n+/* Returns the value of LBOUND for an expression.  This could be broken out\n+   from gfc_conv_intrinsic_bound but this seemed to be simpler.  This is\n+   called by gfc_alloc_allocatable_for_assignment.  */\n+static tree\n+get_std_lbound (gfc_expr *expr, tree desc, int dim, bool assumed_size)\n+{\n+  tree lbound;\n+  tree ubound;\n+  tree stride;\n+  tree cond, cond1, cond3, cond4;\n+  tree tmp;\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+    {\n+      tmp = gfc_rank_cst[dim];\n+      lbound = gfc_conv_descriptor_lbound_get (desc, tmp);\n+      ubound = gfc_conv_descriptor_ubound_get (desc, tmp);\n+      stride = gfc_conv_descriptor_stride_get (desc, tmp);\n+      cond1 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t       ubound, lbound);\n+      cond3 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t       stride, gfc_index_zero_node);\n+      cond3 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t       boolean_type_node, cond3, cond1);\n+      cond4 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       stride, gfc_index_zero_node);\n+      if (assumed_size)\n+\tcond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\ttmp, build_int_cst (gfc_array_index_type,\n+\t\t\t\t\t\t    expr->rank - 1));\n+      else\n+\tcond = boolean_false_node;\n+\n+      cond1 = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t       boolean_type_node, cond3, cond4);\n+      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t      boolean_type_node, cond, cond1);\n+\n+      return fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t      gfc_array_index_type, cond,\n+\t\t\t      lbound, gfc_index_one_node);\n+    }\n+  else if (expr->expr_type == EXPR_VARIABLE)\n+    {\n+      tmp = TREE_TYPE (expr->symtree->n.sym->backend_decl);\n+      return GFC_TYPE_ARRAY_LBOUND(tmp, dim);\n+    }\n+  else if (expr->expr_type == EXPR_FUNCTION)\n+    {\n+      /* A conversion function, so use the argument.  */\n+      expr = expr->value.function.actual->expr;\n+      if (expr->expr_type != EXPR_VARIABLE)\n+\treturn gfc_index_one_node;\n+      desc = TREE_TYPE (expr->symtree->n.sym->backend_decl);\n+      return get_std_lbound (expr, desc, dim, assumed_size);\n+    }\n+\n+  return gfc_index_one_node;\n+}\n+\n+\n+/* Returns true if an expression represents an lhs that can be reallocated\n+   on assignment.  */\n+\n+bool\n+gfc_is_reallocatable_lhs (gfc_expr *expr)\n+{\n+  gfc_ref * ref;\n+\n+  if (!expr->ref)\n+    return false;\n+\n+  /* An allocatable variable.  */\n+  if (expr->symtree->n.sym->attr.allocatable\n+\t&& expr->ref\n+\t&& expr->ref->type == REF_ARRAY\n+\t&& expr->ref->u.ar.type == AR_FULL)\n+    return true;\n+\n+  /* All that can be left are allocatable components.  */\n+  if (expr->symtree->n.sym->ts.type != BT_DERIVED\n+\t|| !expr->symtree->n.sym->ts.u.derived->attr.alloc_comp)\n+    return false;\n+\n+  /* Find a component ref followed by an array reference.  */\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    if (ref->next\n+\t  && ref->type == REF_COMPONENT\n+\t  && ref->next->type == REF_ARRAY\n+\t  && !ref->next->next)\n+      break;\n+\n+  if (!ref)\n+    return false;\n+\n+  /* Return true if valid reallocatable lhs.  */\n+  if (ref->u.c.component->attr.allocatable\n+\t&& ref->next->u.ar.type == AR_FULL)\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Allocate the lhs of an assignment to an allocatable array, otherwise\n+   reallocate it.  */\n+\n+tree\n+gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n+\t\t\t\t      gfc_expr *expr1,\n+\t\t\t\t      gfc_expr *expr2)\n+{\n+  stmtblock_t realloc_block;\n+  stmtblock_t alloc_block;\n+  stmtblock_t fblock;\n+  gfc_ss *rss;\n+  gfc_ss *lss;\n+  tree realloc_expr;\n+  tree alloc_expr;\n+  tree size1;\n+  tree size2;\n+  tree array1;\n+  tree cond;\n+  tree tmp;\n+  tree tmp2;\n+  tree lbound;\n+  tree ubound;\n+  tree desc;\n+  tree desc2;\n+  tree offset;\n+  tree jump_label1;\n+  tree jump_label2;\n+  tree neq_size;\n+  tree lbd;\n+  int n;\n+  int dim;\n+  gfc_array_spec * as;\n+\n+  /* x = f(...) with x allocatable.  In this case, expr1 is the rhs.\n+     Find the lhs expression in the loop chain and set expr1 and\n+     expr2 accordingly.  */\n+  if (expr1->expr_type == EXPR_FUNCTION && expr2 == NULL)\n+    {\n+      expr2 = expr1;\n+      /* Find the ss for the lhs.  */\n+      lss = loop->ss;\n+      for (; lss && lss != gfc_ss_terminator; lss = lss->loop_chain)\n+\tif (lss->expr && lss->expr->expr_type == EXPR_VARIABLE)\n+\t  break;\n+      if (lss == gfc_ss_terminator)\n+\treturn NULL_TREE;\n+      expr1 = lss->expr;\n+    }\n+\n+  /* Bail out if this is not a valid allocate on assignment.  */\n+  if (!gfc_is_reallocatable_lhs (expr1)\n+\t|| (expr2 && !expr2->rank))\n+    return NULL_TREE;\n+\n+  /* Find the ss for the lhs.  */\n+  lss = loop->ss;\n+  for (; lss && lss != gfc_ss_terminator; lss = lss->loop_chain)\n+    if (lss->expr == expr1)\n+      break;\n+\n+  if (lss == gfc_ss_terminator)\n+    return NULL_TREE;\n+\n+  /* Find an ss for the rhs. For operator expressions, we see the\n+     ss's for the operands. Any one of these will do.  */\n+  rss = loop->ss;\n+  for (; rss && rss != gfc_ss_terminator; rss = rss->loop_chain)\n+    if (rss->expr != expr1 && rss != loop->temp_ss)\n+      break;\n+\n+  if (expr2 && rss == gfc_ss_terminator)\n+    return NULL_TREE;\n+\n+  gfc_start_block (&fblock);\n+\n+  /* Since the lhs is allocatable, this must be a descriptor type.\n+     Get the data and array size.  */\n+  desc = lss->data.info.descriptor;\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)));\n+  array1 = gfc_conv_descriptor_data_get (desc);\n+  size1 = gfc_conv_descriptor_size (desc, expr1->rank);\n+\n+  /* Get the rhs size.  Fix both sizes.  */\n+  if (expr2)\n+    desc2 = rss->data.info.descriptor;\n+  else\n+    desc2 = NULL_TREE;\n+  size2 = gfc_index_one_node;\n+  for (n = 0; n < expr2->rank; n++)\n+    {\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     loop->to[n], loop->from[n]);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+      size2 = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t       gfc_array_index_type,\n+\t\t\t       tmp, size2);\n+    }\n+  size1 = gfc_evaluate_now (size1, &fblock);\n+  size2 = gfc_evaluate_now (size2, &fblock);\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t  size1, size2);\n+  neq_size = gfc_evaluate_now (cond, &fblock);\n+\n+  /* If the lhs is allocated and the lhs and rhs are equal length, jump\n+     past the realloc/malloc.  This allows F95 compliant expressions\n+     to escape allocation on assignment.  */\n+  jump_label1 = gfc_build_label_decl (NULL_TREE);\n+  jump_label2 = gfc_build_label_decl (NULL_TREE);\n+\n+  /* Allocate if data is NULL.  */\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t array1, build_int_cst (TREE_TYPE (array1), 0));\n+  tmp = build3_v (COND_EXPR, cond,\n+\t\t  build1_v (GOTO_EXPR, jump_label1),\n+\t\t  build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&fblock, tmp);\n+\n+  /* Reallocate if sizes are different.  */\n+  tmp = build3_v (COND_EXPR, neq_size,\n+\t\t  build1_v (GOTO_EXPR, jump_label1),\n+\t\t  build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&fblock, tmp);\n+\n+  if (expr2 && expr2->expr_type == EXPR_FUNCTION\n+\t&& expr2->value.function.isym\n+\t&& expr2->value.function.isym->conversion)\n+    {\n+      /* For conversion functions, take the arg.  */\n+      gfc_expr *arg = expr2->value.function.actual->expr;\n+      as = gfc_get_full_arrayspec_from_expr (arg);\n+    }\n+  else if (expr2)\n+    as = gfc_get_full_arrayspec_from_expr (expr2);\n+  else\n+    as = NULL;\n+\n+  /* Reset the lhs bounds if any are different from the rhs.  */ \n+  if (as && expr2->expr_type == EXPR_VARIABLE)\n+    {\n+      for (n = 0; n < expr1->rank; n++)\n+\t{\n+\t  /* First check the lbounds.  */\n+\t  dim = rss->data.info.dim[n];\n+\t  lbd = get_std_lbound (expr2, desc2, dim,\n+\t\t\t\tas->type == AS_ASSUMED_SIZE);\n+\t  lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[n]);\n+\t  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t  boolean_type_node, lbd, lbound);\n+\t  tmp = build3_v (COND_EXPR, cond,\n+\t\t\t  build1_v (GOTO_EXPR, jump_label1),\n+\t\t\t  build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&fblock, tmp);\n+\n+\t  /* Now check the shape.  */\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t loop->to[n], loop->from[n]);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t tmp, lbound);\n+\t  ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[n]);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t tmp, ubound);\n+\t  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t  boolean_type_node,\n+\t\t\t\t  tmp, gfc_index_zero_node);\n+\t  tmp = build3_v (COND_EXPR, cond,\n+\t\t\t  build1_v (GOTO_EXPR, jump_label1),\n+\t\t\t  build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&fblock, tmp);\t  \n+\t}\n+    }\n+\n+    /* Otherwise jump past the (re)alloc code.  */\n+    tmp = build1_v (GOTO_EXPR, jump_label2);\n+    gfc_add_expr_to_block (&fblock, tmp);\n+    \n+    /* Add the label to start automatic (re)allocation.  */\n+    tmp = build1_v (LABEL_EXPR, jump_label1);\n+    gfc_add_expr_to_block (&fblock, tmp);\n+\n+  /* Now modify the lhs descriptor and the associated scalarizer\n+     variables.\n+     7.4.1.3: If variable is or becomes an unallocated allocatable\n+     variable, then it is allocated with each deferred type parameter\n+     equal to the corresponding type parameters of expr , with the\n+     shape of expr , and with each lower bound equal to the\n+     corresponding element of LBOUND(expr).  */\n+  size1 = gfc_index_one_node;\n+  offset = gfc_index_zero_node;\n+\n+  for (n = 0; n < expr2->rank; n++)\n+    {\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     loop->to[n], loop->from[n]);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+\n+      lbound = gfc_index_one_node;\n+      ubound = tmp;\n+\n+      if (as)\n+\t{\n+\t  lbd = get_std_lbound (expr2, desc2, n,\n+\t\t\t\tas->type == AS_ASSUMED_SIZE);\n+\t  ubound = fold_build2_loc (input_location,\n+\t\t\t\t    MINUS_EXPR,\n+\t\t\t\t    gfc_array_index_type,\n+\t\t\t\t    ubound, lbound);\n+\t  ubound = fold_build2_loc (input_location,\n+\t\t\t\t    PLUS_EXPR,\n+\t\t\t\t    gfc_array_index_type,\n+\t\t\t\t    ubound, lbd);\n+\t  lbound = lbd;\n+\t}\n+\n+      gfc_conv_descriptor_lbound_set (&fblock, desc,\n+\t\t\t\t      gfc_rank_cst[n],\n+\t\t\t\t      lbound);\n+      gfc_conv_descriptor_ubound_set (&fblock, desc,\n+\t\t\t\t      gfc_rank_cst[n],\n+\t\t\t\t      ubound);\n+      gfc_conv_descriptor_stride_set (&fblock, desc,\n+\t\t\t\t      gfc_rank_cst[n],\n+\t\t\t\t      size1);\n+      lbound = gfc_conv_descriptor_lbound_get (desc,\n+\t\t\t\t\t       gfc_rank_cst[n]);\n+      tmp2 = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t      gfc_array_index_type,\n+\t\t\t      lbound, size1);\n+      offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\tgfc_array_index_type,\n+\t\t\t\toffset, tmp2);\n+      size1 = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t       gfc_array_index_type,\n+\t\t\t       tmp, size1);\n+    }\n+\n+  /* Set the lhs descriptor and scalarizer offsets.  For rank > 1,\n+     the array offset is saved and the info.offset is used for a\n+     running offset.  Use the saved_offset instead.  */\n+  tmp = gfc_conv_descriptor_offset (desc);\n+  gfc_add_modify (&fblock, tmp, offset);\n+  if (lss->data.info.saved_offset\n+\t&& TREE_CODE (lss->data.info.saved_offset) == VAR_DECL)\n+      gfc_add_modify (&fblock, lss->data.info.saved_offset, tmp);\n+\n+  /* Now set the deltas for the lhs.  */\n+  for (n = 0; n < expr1->rank; n++)\n+    {\n+      tmp = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[n]);\n+      dim = lss->data.info.dim[n];\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t     loop->from[dim]);\n+      if (lss->data.info.delta[dim]\n+\t    && TREE_CODE (lss->data.info.delta[dim]) == VAR_DECL)\n+\tgfc_add_modify (&fblock, lss->data.info.delta[dim], tmp);\n+    }\n+\n+  /* Get the new lhs size in bytes.  */\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+    {\n+      tmp = expr2->ts.u.cl->backend_decl;\n+      gcc_assert (expr1->ts.u.cl->backend_decl);\n+      tmp = fold_convert (TREE_TYPE (expr1->ts.u.cl->backend_decl), tmp);\n+      gfc_add_modify (&fblock, expr1->ts.u.cl->backend_decl, tmp);\n+    }\n+  else if (expr1->ts.type == BT_CHARACTER && expr1->ts.u.cl->backend_decl)\n+    {\n+      tmp = TYPE_SIZE_UNIT (TREE_TYPE (gfc_typenode_for_spec (&expr1->ts)));\n+      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t     expr1->ts.u.cl->backend_decl);\n+    }\n+  else\n+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));\n+  tmp = fold_convert (gfc_array_index_type, tmp);\n+  size2 = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t   gfc_array_index_type,\n+\t\t\t   tmp, size2);\n+  size2 = fold_convert (size_type_node, size2);\n+  size2 = gfc_evaluate_now (size2, &fblock);\n+\n+  /* Realloc expression.  Note that the scalarizer uses desc.data\n+     in the array reference - (*desc.data)[<element>]. */\n+  gfc_init_block (&realloc_block);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t     built_in_decls[BUILT_IN_REALLOC], 2,\n+\t\t\t     fold_convert (pvoid_type_node, array1),\n+\t\t\t     size2);\n+  gfc_conv_descriptor_data_set (&realloc_block,\n+\t\t\t\tdesc, tmp);\n+  realloc_expr = gfc_finish_block (&realloc_block);\n+\n+  /* Only reallocate if sizes are different.  */\n+  tmp = build3_v (COND_EXPR, neq_size, realloc_expr,\n+\t\t  build_empty_stmt (input_location));\n+  realloc_expr = tmp;\n+\n+\n+  /* Malloc expression.  */\n+  gfc_init_block (&alloc_block);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t     built_in_decls[BUILT_IN_MALLOC], 1,\n+\t\t\t     size2);\n+  gfc_conv_descriptor_data_set (&alloc_block,\n+\t\t\t\tdesc, tmp);\n+  tmp = gfc_conv_descriptor_dtype (desc);\n+  gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+  alloc_expr = gfc_finish_block (&alloc_block);\n+\n+  /* Malloc if not allocated; realloc otherwise.  */\n+  tmp = build_int_cst (TREE_TYPE (array1), 0);\n+  cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t  boolean_type_node,\n+\t\t\t  array1, tmp);\n+  tmp = build3_v (COND_EXPR, cond, alloc_expr, realloc_expr);\n+  gfc_add_expr_to_block (&fblock, tmp);\n+\n+  /* Make sure that the scalarizer data pointer is updated.  */\n+  if (lss->data.info.data\n+\t&& TREE_CODE (lss->data.info.data) == VAR_DECL)\n+    {\n+      tmp = gfc_conv_descriptor_data_get (desc);\n+      gfc_add_modify (&fblock, lss->data.info.data, tmp);\n+    }\n+\n+  /* Add the exit label.  */\n+  tmp = build1_v (LABEL_EXPR, jump_label2);\n+  gfc_add_expr_to_block (&fblock, tmp);\n+\n+  return gfc_finish_block (&fblock);\n+}\n+\n+\n /* NULLIFY an allocatable/pointer array on function entry, free it on exit.\n    Do likewise, recursively if necessary, with the allocatable components of\n    derived types.  */"}, {"sha": "1b3575969151829d2f88362e9f6201bf91b217e6", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -57,6 +57,10 @@ tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int);\n \n tree gfc_copy_only_alloc_comp (gfc_symbol *, tree, tree, int);\n \n+tree gfc_alloc_allocatable_for_assignment (gfc_loopinfo*, gfc_expr*, gfc_expr*);\n+\n+bool gfc_is_reallocatable_lhs (gfc_expr *);\n+\n /* Add initialization for deferred arrays.  */\n void gfc_trans_deferred_array (gfc_symbol *, gfc_wrapped_block *);\n /* Generate an initializer for a static pointer or allocatable array.  */"}, {"sha": "5857c0d3c08d4dc8e21e62c28daa29d0a12a5b11", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 166, "deletions": 3, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -335,14 +335,18 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)\n \n   gfc_init_se (&se, NULL);\n \n+  if (!cl->length\n+\t&& cl->backend_decl\n+\t&& TREE_CODE (cl->backend_decl) == VAR_DECL)\n+    return;\n+\n   /* If cl->length is NULL, use gfc_conv_expr to obtain the string length but\n      \"flatten\" array constructors by taking their first element; all elements\n      should be the same length or a cl->length should be present.  */\n   if (!cl->length)\n     {\n       gfc_expr* expr_flat;\n       gcc_assert (expr);\n-\n       expr_flat = gfc_copy_expr (expr);\n       flatten_array_ctors_without_strlen (expr_flat);\n       gfc_resolve_expr (expr_flat);\n@@ -3355,8 +3359,30 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n \n-\t  result = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\tse->expr);\n+\t  /* If the lhs of an assignment x = f(..) is allocatable and\n+\t     f2003 is allowed, we must do the automatic reallocation.\n+\t     TODO - deal with instrinsics, without using a temporary.  */\n+\t  if (gfc_option.flag_realloc_lhs\n+\t\t&& se->ss && se->ss->loop_chain\n+\t\t&& se->ss->loop_chain->is_alloc_lhs\n+\t\t&& !expr->value.function.isym\n+\t\t&& sym->result->as != NULL)\n+\t    {\n+\t      /* Evaluate the bounds of the result, if known.  */\n+\t      gfc_set_loop_bounds_from_array_spec (&mapping, se,\n+\t\t\t\t\t\t   sym->result->as);\n+\n+\t      /* Perform the automatic reallocation.  */\n+\t      tmp = gfc_alloc_allocatable_for_assignment (se->loop,\n+\t\t\t\t\t\t\t  expr, NULL);\n+\t      gfc_add_expr_to_block (&se->pre, tmp);\n+\n+\t      /* Pass the temporary as the first argument.  */\n+\t      result = info->descriptor;\n+\t    }\n+\t  else\n+\t    result = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t  se->expr);\n \t  VEC_safe_push (tree, gc, retargs, se->expr);\n \t}\n       else if (comp && comp->attr.dimension)\n@@ -3370,6 +3396,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Evaluate the bounds of the result, if known.  */\n \t  gfc_set_loop_bounds_from_array_spec (&mapping, se, comp->as);\n \n+\t  /* If the lhs of an assignment x = f(..) is allocatable and\n+\t     f2003 is allowed, we must not generate the function call\n+\t     here but should just send back the results of the mapping.\n+\t     This is signalled by the function ss being flagged.  */\n+\t  if (gfc_option.flag_realloc_lhs\n+\t\t&& se->ss && se->ss->is_alloc_lhs)\n+\t    {\n+\t      gfc_free_interface_mapping (&mapping);\n+\t      return has_alternate_specifier;\n+\t    }\n+\n \t  /* Create a temporary to store the result.  In case the function\n \t     returns a pointer, the temporary will be a shallow copy and\n \t     mustn't be deallocated.  */\n@@ -3394,6 +3431,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Evaluate the bounds of the result, if known.  */\n \t  gfc_set_loop_bounds_from_array_spec (&mapping, se, sym->result->as);\n \n+\t  /* If the lhs of an assignment x = f(..) is allocatable and\n+\t     f2003 is allowed, we must not generate the function call\n+\t     here but should just send back the results of the mapping.\n+\t     This is signalled by the function ss being flagged.  */\n+\t  if (gfc_option.flag_realloc_lhs\n+\t\t&& se->ss && se->ss->is_alloc_lhs)\n+\t    {\n+\t      gfc_free_interface_mapping (&mapping);\n+\t      return has_alternate_specifier;\n+\t    }\n+\n \t  /* Create a temporary to store the result.  In case the function\n \t     returns a pointer, the temporary will be a shallow copy and\n \t     mustn't be deallocated.  */\n@@ -5331,6 +5379,81 @@ arrayfunc_assign_needs_temporary (gfc_expr * expr1, gfc_expr * expr2)\n }\n \n \n+/* Provide the loop info so that the lhs descriptor can be built for\n+   reallocatable assignments from extrinsic function calls.  */\n+\n+static void\n+realloc_lhs_loop_for_fcn_call (gfc_se *se, locus *where, gfc_ss **ss)\n+{\n+  gfc_loopinfo loop;\n+  /* Signal that the function call should not be made by\n+     gfc_conv_loop_setup. */\n+  se->ss->is_alloc_lhs = 1;\n+  gfc_init_loopinfo (&loop);\n+  gfc_add_ss_to_loop (&loop, *ss);\n+  gfc_add_ss_to_loop (&loop, se->ss);\n+  gfc_conv_ss_startstride (&loop);\n+  gfc_conv_loop_setup (&loop, where);\n+  gfc_copy_loopinfo_to_se (se, &loop);\n+  gfc_add_block_to_block (&se->pre, &loop.pre);\n+  gfc_add_block_to_block (&se->pre, &loop.post);\n+  se->ss->is_alloc_lhs = 0;\n+}\n+\n+\n+static void\n+realloc_lhs_bounds_for_intrinsic_call (gfc_se *se, int rank)\n+{\n+  tree desc;\n+  tree tmp;\n+  tree offset;\n+  int n;\n+\n+  /* Use the allocation done by the library.  */\n+  desc = build_fold_indirect_ref_loc (input_location, se->expr);\n+  tmp = gfc_conv_descriptor_data_get (desc);\n+  tmp = gfc_call_free (fold_convert (pvoid_type_node, tmp));\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+  gfc_conv_descriptor_data_set (&se->pre, desc, null_pointer_node);\n+  /* Unallocated, the descriptor does not have a dtype.  */\n+  tmp = gfc_conv_descriptor_dtype (desc);\n+  gfc_add_modify (&se->pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+\n+  offset = gfc_index_zero_node;\n+  tmp = gfc_index_one_node;\n+  /* Now reset the bounds from zero based to unity based.  */\n+  for (n = 0 ; n < rank; n++)\n+    {\n+      /* Accumulate the offset.  */\n+      offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\tgfc_array_index_type,\n+\t\t\t\toffset, tmp);\n+      /* Now do the bounds.  */\n+      gfc_conv_descriptor_offset_set (&se->post, desc, tmp);\n+      tmp = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[n]);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+      gfc_conv_descriptor_lbound_set (&se->post, desc,\n+\t\t\t\t      gfc_rank_cst[n],\n+\t\t\t\t      gfc_index_one_node);\n+      gfc_conv_descriptor_ubound_set (&se->post, desc,\n+\t\t\t\t      gfc_rank_cst[n], tmp);\n+\n+      /* The extent for the next contribution to offset.  */\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[n]),\n+\t\t\t     gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[n]));\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+    }\n+  gfc_conv_descriptor_offset_set (&se->post, desc, offset);\n+}\n+\n+\n+\n /* Try to translate array(:) = func (...), where func is a transformational\n    array function, without using a temporary.  Returns NULL if this isn't the\n    case.  */\n@@ -5373,6 +5496,31 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   se.direct_byref = 1;\n   se.ss = gfc_walk_expr (expr2);\n   gcc_assert (se.ss != gfc_ss_terminator);\n+\n+  /* Reallocate on assignment needs the loopinfo for extrinsic functions.\n+     This is signalled to gfc_conv_procedure_call by setting is_alloc_lhs.\n+     Clearly, this cannot be done for an allocatable function result, since\n+     the shape of the result is unknown and, in any case, the function must\n+     correctly take care of the reallocation internally. For intrinsic\n+     calls, the array data is freed and the library takes care of allocation.\n+     TODO: Add logic of trans-array.c: gfc_alloc_allocatable_for_assignment\n+     to the library.  */    \n+  if (gfc_option.flag_realloc_lhs\n+\t&& gfc_is_reallocatable_lhs (expr1)\n+\t&& !gfc_expr_attr (expr1).codimension\n+\t&& !gfc_is_coindexed (expr1)\n+\t&& !(expr2->value.function.esym\n+\t    && expr2->value.function.esym->result->attr.allocatable))\n+    {\n+      if (!expr2->value.function.isym)\n+\t{\n+\t  realloc_lhs_loop_for_fcn_call (&se, &expr1->where, &ss);\n+\t  ss->is_alloc_lhs = 1;\n+\t}\n+      else\n+\trealloc_lhs_bounds_for_intrinsic_call (&se, expr1->rank);\n+    }\n+\n   gfc_conv_function_expr (&se, expr2);\n   gfc_add_block_to_block (&se.pre, &se.post);\n \n@@ -5603,6 +5751,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \n   /* Walk the lhs.  */\n   lss = gfc_walk_expr (expr1);\n+  if (gfc_is_reallocatable_lhs (expr1)\n+\t&& !(expr2->expr_type == EXPR_FUNCTION\n+\t     && expr2->value.function.isym != NULL))\n+    lss->is_alloc_lhs = 1;\n   rss = NULL;\n   if (lss != gfc_ss_terminator)\n     {\n@@ -5748,6 +5900,17 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t  gfc_add_expr_to_block (&body, tmp);\n \t}\n \n+      /* Allocate or reallocate lhs of allocatable array.  */\n+      if (gfc_option.flag_realloc_lhs\n+\t    && gfc_is_reallocatable_lhs (expr1)\n+\t    && !gfc_expr_attr (expr1).codimension\n+\t    && !gfc_is_coindexed (expr1))\n+\t{\n+\t  tmp = gfc_alloc_allocatable_for_assignment (&loop, expr1, expr2);\n+\t  if (tmp != NULL_TREE)\n+\t    gfc_add_expr_to_block (&loop.code[expr1->rank - 1], tmp);\n+\t}\n+\n       /* Generate the copying loops.  */\n       gfc_trans_scalarizing_loops (&loop, &body);\n "}, {"sha": "771b582c4f0d423691c833e08dd95ffe7fb9ccbe", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1048,7 +1048,12 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n       break;\n \n     case BT_CHARACTER:\n-      basetype = gfc_get_character_type (spec->kind, spec->u.cl);\n+#if 0\n+      if (spec->deferred)\n+\tbasetype = gfc_get_character_type (spec->kind, NULL);\n+      else\n+#endif\n+\tbasetype = gfc_get_character_type (spec->kind, spec->u.cl);\n       break;\n \n     case BT_DERIVED:"}, {"sha": "26ac0039e8d888061ff35ef1940cc34aeb2bb518", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -216,7 +216,7 @@ typedef struct gfc_ss\n      loops the terms appear in.  This will be 1 for the RHS expressions,\n      2 for the LHS expressions, and 3(=1|2) for the temporary.  The bit\n      'where' suppresses precalculation of scalars in WHERE assignments.  */\n-  unsigned useflags:2, where:1;\n+  unsigned useflags:2, where:1, is_alloc_lhs:1;\n }\n gfc_ss;\n #define gfc_get_ss() XCNEW (gfc_ss)"}, {"sha": "dccf14c94cd58b05f15cb3759934ebebc0be92de", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,3 +1,16 @@\n+2010-11-28  Paul Thomas  <pault@gcc.gnu.org\n+\n+\tPR fortran/35810\n+\t* gfortran.dg/realloc_on_assign_1.f03: New test.\n+\t* gfortran.dg/realloc_on_assign_2.f03: New test.\n+\t* gfortran.dg/transpose_2.f90: dg-option -fno-realloc-lhs.\n+\t* gfortran.dg/unpack_bounds_1.f90: The same.\n+\t* gfortran.dg/cshift_bounds_2.f90: The same.\n+\t* gfortran.dg/matmul_bounds_2.f90: The same.\n+\t* gfortran.dg/matmul_bounds_3.f90: The same.\n+\t* gfortran.dg/matmul_bounds_4.f90: The same.\n+\t* gfortran.dg/matmul_bounds_5.f90: The same.\n+\n 2010-11-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/46638"}, {"sha": "0f3c75f4e0d893898d13809dc46f4f291e727738", "filename": "gcc/testsuite/gfortran.dg/cshift_bounds_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_2.f90?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fbounds-check\" }\n+! { dg-options \"-fbounds-check -fno-realloc-lhs\" }\n ! { dg-shouldfail \"Incorrect extent in return value of CSHIFT intrinsic in dimension 2: is 3, should be 2\" }\n program main\n   integer, dimension(:,:), allocatable :: a, b"}, {"sha": "978751e70e6845d9922ee90111796dece3d2462c", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_2.f90?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fbounds-check\" }\n+! { dg-options \"-fbounds-check -fno-realloc-lhs\" }\n ! { dg-shouldfail \"Fortran runtime error: Incorrect extent in return array in MATMUL intrinsic for dimension 2: is 2, should be 3\" }\n program main\n   real, dimension(3,2) :: a"}, {"sha": "4b80f8c2be88a77d36dec3498f5fe95450f0bb50", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_3.f90?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fbounds-check\" }\n+! { dg-options \"-fbounds-check -fno-realloc-lhs\" }\n ! { dg-shouldfail \"Fortran runtime error: Incorrect extent in return array in MATMUL intrinsic for dimension 1: is 2, should be 3\" }\n program main\n   real, dimension(3,2) :: a"}, {"sha": "94add6ce8e7f4cd6f184ca4238cf522f3acb17be", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_4.f90?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fbounds-check\" }\n+! { dg-options \"-fbounds-check -fno-realloc-lhs\" }\n ! { dg-shouldfail \"Fortran runtime error: Incorrect extent in return array in MATMUL intrinsic: is 3, should be 2\" }\n program main\n   real, dimension(3) :: a"}, {"sha": "5261e8e443a8c680e4e3756583a7b94e00968bb0", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_5.f90?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fbounds-check\" }\n+! { dg-options \"-fbounds-check -fno-realloc-lhs\" }\n ! { dg-shouldfail \"Fortran runtime error: Incorrect extent in return array in MATMUL intrinsic: is 3, should be 2\" }\n program main\n   real, dimension(2,3) :: a"}, {"sha": "e80084d97f20be6eed2aad31f3c2d3c48ab8956f", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_1.f03", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_1.f03?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do run }\n+! Tests the patch that implements F2003 automatic allocation and\n+! reallocation of allocatable arrays on assignment.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  integer(4), allocatable :: a(:), b(:), c(:,:)\n+  integer(4) :: j\n+  integer(4) :: src(2:5) = [11,12,13,14]\n+  integer(4) :: mat(2:3,5:6)\n+  character(4), allocatable :: chr1(:)\n+  character(4) :: chr2(2) = [\"abcd\", \"wxyz\"]\n+\n+  allocate(a(1))\n+  mat = reshape (src, [2,2])\n+\n+  a = [4,3,2,1]\n+  if (size(a, 1) .ne. 4) call abort\n+  if (any (a .ne. [4,3,2,1])) call abort\n+\n+  a = [((42 - i), i = 1, 10)]\n+  if (size(a, 1) .ne. 10) call abort\n+  if (any (a .ne. [((42 - i), i = 1, 10)])) call abort\n+\n+  b = a\n+  if (size(b, 1) .ne. 10) call abort\n+  if (any (b .ne. a)) call abort\n+\n+  a = [4,3,2,1]\n+  if (size(a, 1) .ne. 4) call abort\n+  if (any (a .ne. [4,3,2,1])) call abort\n+\n+  a = b\n+  if (size(a, 1) .ne. 10) call abort\n+  if (any (a .ne. [((42 - i), i = 1, 10)])) call abort\n+\n+  j = 20\n+  a = [(i, i = 1, j)]\n+  if (size(a, 1) .ne. j) call abort\n+  if (any (a .ne. [(i, i = 1, j)])) call abort\n+\n+  a = foo (15)\n+  if (size(a, 1) .ne. 15) call abort\n+  if (any (a .ne. [((i + 15), i = 1, 15)])) call abort\n+\n+  a = src\n+  if (lbound(a, 1) .ne. lbound(src, 1)) call abort\n+  if (ubound(a, 1) .ne. ubound(src, 1)) call abort\n+  if (any (a .ne. [11,12,13,14])) call abort\n+\n+  k = 7\n+  a = b(k:8)\n+  if (lbound(a, 1) .ne. lbound (b(k:8), 1)) call abort\n+  if (ubound(a, 1) .ne. ubound (b(k:8), 1)) call abort\n+  if (any (a .ne. [35,34])) call abort\n+\n+  c = mat\n+  if (any (lbound (c) .ne. lbound (mat))) call abort\n+  if (any (ubound (c) .ne. ubound (mat))) call abort\n+  if (any (c .ne. mat)) call abort\n+\n+  deallocate (c)\n+  c = mat(2:,:)\n+  if (any (lbound (c) .ne. lbound (mat(2:,:)))) call abort\n+\n+  chr1 = chr2(2:1:-1)\n+  if (lbound(chr1, 1) .ne. 1) call abort\n+  if (any (chr1 .ne. chr2(2:1:-1))) call abort\n+\n+  b = c(1, :) + c(2, :)\n+  if (lbound(b, 1) .ne. lbound (c(1, :) + c(2, :), 1)) call abort\n+  if (any (b .ne. c(1, :) + c(2, :))) call abort\n+contains\n+  function foo (n) result(res)\n+    integer(4), allocatable, dimension(:) :: res\n+    integer(4) :: n\n+    allocate (res(n))\n+    res = [((i + 15), i = 1, n)]\n+  end function foo\n+end"}, {"sha": "d2a63318f85a397e8bf32adff163c7bee7234cff", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_2.f03", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -0,0 +1,143 @@\n+! { dg-do run }\n+! Tests the patch that implements F2003 automatic allocation and\n+! reallocation of allocatable arrays on assignment.  The tests\n+! below were generated in the final stages of the development of\n+! this patch.\n+!\n+! Contributed by Dominique Dhumieres <dominiq@lps.ens.fr>\n+!            and Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+  integer :: nglobal\n+  call test1\n+  call test2\n+  call test3\n+  call test4\n+  call test5\n+  call test6\n+  call test7\n+  call test8\n+contains\n+  subroutine test1\n+!\n+! Check that the bounds are set correctly, when assigning\n+! to an array that already has the correct shape.\n+!\n+    real :: a(10) = 1, b(51:60) = 2\n+    real, allocatable :: c(:), d(:)\n+    c=a\n+    if (lbound (c, 1) .ne. lbound(a, 1)) call abort\n+    if (ubound (c, 1) .ne. ubound(a, 1)) call abort\n+    c=b\n+    if (lbound (c, 1) .ne. lbound(b, 1)) call abort\n+    if (ubound (c, 1) .ne. ubound(b, 1)) call abort\n+    d=b\n+    if (lbound (d, 1) .ne. lbound(b, 1)) call abort\n+    if (ubound (d, 1) .ne. ubound(b, 1)) call abort\n+    d=a\n+    if (lbound (d, 1) .ne. lbound(a, 1)) call abort\n+    if (ubound (d, 1) .ne. ubound(a, 1)) call abort\n+  end subroutine\n+  subroutine test2\n+!\n+! Check that the bounds are set correctly, when making an\n+! assignment with an implicit conversion.  First with a\n+! non-descriptor variable....\n+!\n+    integer(4), allocatable :: a(:)\n+    integer(8) :: b(5:6)\n+    a = b\n+    if (lbound (a, 1) .ne. lbound(b, 1)) call abort\n+    if (ubound (a, 1) .ne. ubound(b, 1)) call abort\n+  end subroutine\n+  subroutine test3\n+!\n+! ...and now a descriptor variable.\n+!\n+    integer(4), allocatable :: a(:)\n+    integer(8), allocatable :: b(:)\n+    allocate (b(7:11))\n+    a = b\n+    if (lbound (a, 1) .ne. lbound(b, 1)) call abort\n+    if (ubound (a, 1) .ne. ubound(b, 1)) call abort\n+  end subroutine\n+  subroutine test4\n+!\n+! Check assignments of the kind a = f(...)\n+!\n+    integer, allocatable :: a(:)\n+    integer, allocatable :: c(:)\n+    a = f()\n+    if (any (a .ne. [1, 2, 3, 4])) call abort\n+    c = a + 8\n+    a = f (c)\n+    if (any ((a - 8) .ne. [1, 2, 3, 4])) call abort\n+    deallocate (c)\n+    a = f (c)\n+    if (any ((a - 4) .ne. [1, 2, 3, 4])) call abort\n+  end subroutine\n+  function f(b)\n+    integer, allocatable, optional :: b(:)\n+    integer :: f(4)\n+    if (.not.present (b)) then\n+      f = [1,2,3,4]\n+    elseif (.not.allocated (b)) then\n+      f = [5,6,7,8]\n+    else\n+      f = b\n+    end if\n+  end function f\n+  \n+  subroutine test5\n+!\n+! Extracted from rnflow.f90, Polyhedron benchmark suite,\n+! http://www.polyhedron.com\n+!\n+    integer, parameter :: ncls = 233, ival = 16, ipic = 17\n+    real, allocatable, dimension (:,:) :: utrsft\n+    real, allocatable, dimension (:,:) :: dtrsft\n+    real, allocatable, dimension (:,:) :: xwrkt\n+    allocate (utrsft(ncls, ncls), dtrsft(ncls, ncls))\n+    nglobal = 0\n+    xwrkt = trs2a2 (ival, ipic, ncls)\n+    if (any (shape (xwrkt) .ne. [ncls, ncls])) call abort\n+    xwrkt = invima (xwrkt, ival, ipic, ncls)\n+    if (nglobal .ne. 1) call abort\n+    if (sum(xwrkt) .ne. xwrkt(ival, ival)) call abort\n+  end subroutine\n+  function trs2a2 (j, k, m)\n+    real, dimension (1:m,1:m) :: trs2a2\n+    integer, intent (in)      :: j, k, m\n+    nglobal = nglobal + 1\n+    trs2a2 = 0.0\n+  end function trs2a2\n+  function invima (a, j, k, m)\n+    real, dimension (1:m,1:m)              :: invima\n+    real, dimension (1:m,1:m), intent (in) :: a\n+    integer, intent (in)            :: j, k\n+    invima (j, j) = 1.0 / (1.0 - a (j, j))\n+  end function invima\n+  subroutine test6\n+    character(kind=1, len=100), allocatable, dimension(:) :: str\n+    str = [ \"abc\" ]\n+    if (TRIM(str(1)) .ne. \"abc\") call abort\n+    if (len(str) .ne. 100) call abort\n+  end subroutine\n+  subroutine test7\n+    character(kind=4, len=100), allocatable, dimension(:) :: str\n+    character(kind=4, len=3) :: test = \"abc\"\n+    str = [ \"abc\" ]\n+    if (TRIM(str(1)) .ne. test) call abort\n+    if (len(str) .ne. 100) call abort\n+  end subroutine\n+  subroutine test8\n+    type t\n+      integer, allocatable :: a(:)\n+    end type t\n+    type(t) :: x\n+    x%a= [1,2,3]\n+    if (any (x%a .ne. [1,2,3])) call abort\n+    x%a = [4]\n+    if (any (x%a .ne. [4])) call abort\n+  end subroutine\n+end\n+"}, {"sha": "4ab3bc4bb1a8ce9e643dea60a3dda09e0afb450b", "filename": "gcc/testsuite/gfortran.dg/transpose_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_2.f90?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fbounds-check\" }\n+! { dg-options \"-fbounds-check -fno-realloc-lhs\" }\n ! { dg-shouldfail \"Incorrect extent in return value of TRANSPOSE intrinsic in dimension 1: is 2, should be 3\" }\n program main\n   implicit none"}, {"sha": "2b64128e9e65a3a4c4d2ddec4fb0d44dc30c0250", "filename": "gcc/testsuite/gfortran.dg/unpack_bounds_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/597553ab3c77e55659673274c03d87be8d68fe4f/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_1.f90?ref=597553ab3c77e55659673274c03d87be8d68fe4f", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fbounds-check\" }\n+! { dg-options \"-fbounds-check -fno-realloc-lhs\" }\n ! { dg-shouldfail \"Incorrect extent in return value of UNPACK intrinsic in dimension 2: is 1, should be 2\" }\n program main\n   integer, allocatable, dimension(:) :: vector"}]}