{"sha": "eedb4710a6c82c65caf53ee110fb2e53b29607c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVkYjQ3MTBhNmM4MmM2NWNhZjUzZWUxMTBmYjJlNTNiMjk2MDdjNw==", "commit": {"author": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-12-10T12:05:28Z"}, "committer": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-12-10T12:05:28Z"}, "message": "Cleaned up file format for a distribution.\n\nFrom-SVN: r111", "tree": {"sha": "3342c6a4a1da0680faf93cf5c07c55b4608787ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3342c6a4a1da0680faf93cf5c07c55b4608787ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eedb4710a6c82c65caf53ee110fb2e53b29607c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eedb4710a6c82c65caf53ee110fb2e53b29607c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eedb4710a6c82c65caf53ee110fb2e53b29607c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eedb4710a6c82c65caf53ee110fb2e53b29607c7/comments", "author": null, "committer": null, "parents": [{"sha": "b61e1345cbe8f0dd64c7243e027e0a6330a47507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61e1345cbe8f0dd64c7243e027e0a6330a47507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61e1345cbe8f0dd64c7243e027e0a6330a47507"}], "stats": {"total": 272, "additions": 142, "deletions": 130}, "files": [{"sha": "0fdbf62c353ad1d5b8b8a4fba2361d2970f9e850", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 72, "deletions": 68, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedb4710a6c82c65caf53ee110fb2e53b29607c7/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedb4710a6c82c65caf53ee110fb2e53b29607c7/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=eedb4710a6c82c65caf53ee110fb2e53b29607c7", "patch": "@@ -16,10 +16,14 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.c,v 0.8 1991/11/24 01:20:02 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.c,v 0.9 1991/12/03 02:01:23 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/11/24 01:20:02 $\n+  $Date: 1991/12/03 02:01:23 $\n   $Log: hash.c,v $\n+ * Revision 0.9  1991/12/03  02:01:23  dennisg\n+ * fixed assert macro.\n+ * added memory allocation adjustment macro for hash size allocation.\n+ *\n  * Revision 0.8  1991/11/24  01:20:02  dennisg\n  * changed shorts back to ints.\n  * the efficiency gained didn't out weight the grossness of the code.\n@@ -58,41 +62,41 @@\n  \n \n #include  <hash.h>\n-#include\t<hash-inline.h>\n+#include  <hash-inline.h>\n #include  <ObjC.h>\n-#include\t<ObjC-private.h>\n+#include  <ObjC-private.h>\n \n #include  <assert.h>\n #include  <libc.h>\n #include  <math.h>\n \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* These two macros determine\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhen a hash table is full and\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tby how much it should be \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpanded respectively.\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThese equations are \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpercentages. */\n-#define\tFULLNESS(cache)\t\\\n-\t ((((cache)->sizeOfHash * 75\t) / 100) <= (cache)->entriesInHash)\n-#define\tEXPANSION(cache) \\\n-\t(((cache)->sizeOfHash * 175 ) / 100 )\n-\n-#define\tMEMORY_ALLOCATION_ADJUST(i) \\\n-\t((i&0x01)?i:(i-1))\n+                                                /* These two macros determine\n+                                                  when a hash table is full and\n+                                                  by how much it should be \n+                                                  expanded respectively.\n+                                                  \n+                                                  These equations are \n+                                                  percentages. */\n+#define FULLNESS(cache) \\\n+   ((((cache)->sizeOfHash * 75  ) / 100) <= (cache)->entriesInHash)\n+#define EXPANSION(cache) \\\n+  (((cache)->sizeOfHash * 175 ) / 100 )\n+\n+#define MEMORY_ALLOCATION_ADJUST(i) \\\n+  ((i&0x01)?i:(i-1))\n \n Cache_t hash_new (u_int sizeOfHash) {\n \n   Cache_t retCache;\n-\t\n+  \n \n   assert(sizeOfHash);\n-\t\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Memory is allocated on this\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmachine in even address\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchunks.  Therefore the\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodulus must be odd. */\n-\tsizeOfHash = MEMORY_ALLOCATION_ADJUST(sizeOfHash);\n+  \n+                                                /* Memory is allocated on this\n+                                                  machine in even address\n+                                                  chunks.  Therefore the\n+                                                  modulus must be odd. */\n+  sizeOfHash = MEMORY_ALLOCATION_ADJUST(sizeOfHash);\n \n                                                 /* Allocate the cache \n                                                   structure.  calloc () insures\n@@ -108,7 +112,7 @@ Cache_t hash_new (u_int sizeOfHash) {\n   retCache->theNodeTable = calloc (sizeOfHash, sizeof (CacheNode_t));\n   assert(retCache->theNodeTable);\n   \n-  retCache->sizeOfHash\t= sizeOfHash;\n+  retCache->sizeOfHash  = sizeOfHash;\n \n   return retCache;\n }\n@@ -163,44 +167,44 @@ void hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n                                                   first element on the list. */\n   (* (*theCache)->theNodeTable)[ indx ] = aCacheNode;\n \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Bump the number of entries\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin the cache. */\n-\t++ (*theCache)->entriesInHash;\n-\t\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Check the hash table's\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfullness.   We're going\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tto expand if it is above\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe fullness level. */\n-\tif (FULLNESS (*theCache)) {\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* The hash table has reached\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tits fullness level.  Time to\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpand it. \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tI'm using a slow method \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\there but is built on other\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprimitive functions thereby\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincreasing its \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcorrectness. */\n-\t\tCacheNode_t\taNode = NULL;\n-\t\tCache_t\t\t\tnewCache = \n-\t\t\t\t\t\t\t\t\thash_new (MEMORY_ALLOCATION_ADJUST( EXPANSION (*theCache)));\n-\n-\t\tDEBUG_PRINTF (stderr, \"Expanding cache %#x from %d to %d\\n\",\n-\t\t\t*theCache, (*theCache)->sizeOfHash, newCache->sizeOfHash);\n-\t\t\t\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Copy the nodes from the\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfirst hash table to the\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew one. */\n-\t\twhile (aNode = hash_next (*theCache, aNode))\n-\t\t\thash_add (&newCache, aNode->theKey, aNode->theValue);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Trash the old cache. */\n-\t\thash_delete (*theCache);\n-\t\t\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Return a pointer to the new\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thash table. */\n-\t\t*theCache = newCache;\n-\t}\n+                                                /* Bump the number of entries\n+                                                  in the cache. */\n+  ++ (*theCache)->entriesInHash;\n+  \n+                                                /* Check the hash table's\n+                                                  fullness.   We're going\n+                                                  to expand if it is above\n+                                                  the fullness level. */\n+  if (FULLNESS (*theCache)) {\n+                                                /* The hash table has reached\n+                                                  its fullness level.  Time to\n+                                                  expand it. \n+                                                  \n+                                                  I'm using a slow method \n+                                                  here but is built on other\n+                                                  primitive functions thereby\n+                                                  increasing its \n+                                                  correctness. */\n+    CacheNode_t aNode = NULL;\n+    Cache_t     newCache = \n+                  hash_new (MEMORY_ALLOCATION_ADJUST( EXPANSION (*theCache)));\n+\n+    DEBUG_PRINTF (stderr, \"Expanding cache %#x from %d to %d\\n\",\n+      *theCache, (*theCache)->sizeOfHash, newCache->sizeOfHash);\n+      \n+                                                /* Copy the nodes from the\n+                                                  first hash table to the\n+                                                  new one. */\n+    while (aNode = hash_next (*theCache, aNode))\n+      hash_add (&newCache, aNode->theKey, aNode->theValue);\n+\n+                                                /* Trash the old cache. */\n+    hash_delete (*theCache);\n+    \n+                                                /* Return a pointer to the new\n+                                                  hash table. */\n+    *theCache = newCache;\n+  }\n }\n \n \n@@ -237,10 +241,10 @@ void hash_remove (Cache_t theCache, void* aKey) {\n     } while (!removed && aCacheNode);\n     assert(removed);\n   }\n-\t\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Decrement the number of\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentries in the hash table. */\n-\t--theCache->entriesInHash;\n+  \n+                                                /* Decrement the number of\n+                                                  entries in the hash table. */\n+  --theCache->entriesInHash;\n }\n \n "}, {"sha": "62b48f8b4012c513140a5fdd13e36f04797adbb3", "filename": "gcc/objc/hash.h", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedb4710a6c82c65caf53ee110fb2e53b29607c7/gcc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedb4710a6c82c65caf53ee110fb2e53b29607c7/gcc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.h?ref=eedb4710a6c82c65caf53ee110fb2e53b29607c7", "patch": "@@ -21,10 +21,14 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.h,v 0.6 1991/11/24 01:20:02 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.h,v 0.7 1991/12/03 02:01:23 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/11/24 01:20:02 $\n+  $Date: 1991/12/03 02:01:23 $\n   $Log: hash.h,v $\n+ * Revision 0.7  1991/12/03  02:01:23  dennisg\n+ * fixed assert macro.\n+ * added memory allocation adjustment macro for hash size allocation.\n+ *\n  * Revision 0.6  1991/11/24  01:20:02  dennisg\n  * changed shorts back to ints.\n  * the efficiency gained didn't out weight the grossness of the code.\n@@ -98,18 +102,18 @@ typedef struct cache {\n    */\n   CacheNode_t  (* theNodeTable)[];                /* Pointer to an array of\n                                                     hash nodes. */\n-\t/*\n-\t * Variables used to track the size of the hash\n-\t *\ttable so to determine when to resize it.\n-\t */\n+  /*\n+   * Variables used to track the size of the hash\n+   *  table so to determine when to resize it.\n+   */\n   u_int       sizeOfHash,                        /* Number of buckets \n                                                     allocated for the hash\n                                                     table  (number of array\n                                                     entries allocated for\n                                                     \"theNodeTable\").  Must be\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ta power of two. */\n-\t\t\t\t\t\t\tentriesInHash;\t\t\t\t\t\t\t\t\t\t\t/* Current number of entries\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin ther hash table. */\n+                                                    a power of two. */\n+              entriesInHash;                      /* Current number of entries\n+                                                    in ther hash table. */\n   /*\n    * Variables used to implement indexing\n    *  through the hash table.\n@@ -132,12 +136,12 @@ Cache_t hash_new (u_int sizeOfHash);\n void hash_delete (Cache_t theCache);\n                                                 /* Add the key/value pair\n                                                   to the hash table.  If the\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thash table reaches a \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlevel of fullnes then\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit will be resized. \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassert() if the key is \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\talready in the hash. */\n+                                                  hash table reaches a \n+                                                  level of fullnes then\n+                                                  it will be resized. \n+                                                   \n+                                                  assert() if the key is \n+                                                  already in the hash. */\n void hash_add (Cache_t* theCache, void* aKey, void* aValue);\n                                                 /* Remove the key/value pair\n                                                   from the hash table.  "}, {"sha": "2c19a7d55dcff3ba25f6c2976d40c7ba073fcfff", "filename": "gcc/objc/objc.h", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedb4710a6c82c65caf53ee110fb2e53b29607c7/gcc%2Fobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedb4710a6c82c65caf53ee110fb2e53b29607c7/gcc%2Fobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc.h?ref=eedb4710a6c82c65caf53ee110fb2e53b29607c7", "patch": "@@ -19,10 +19,14 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/include/RCS/ObjC.h,v 0.7 1991/11/29 22:00:10 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/include/RCS/ObjC.h,v 0.8 1991/12/01 01:29:29 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/11/29 22:00:10 $\n+  $Date: 1991/12/01 01:29:29 $\n   $Log: ObjC.h,v $\n+ * Revision 0.8  1991/12/01  01:29:29  dennisg\n+ * modified to remove changes previously made to\n+ * implement posing.  posing just got easy.\n+ *\n  * Revision 0.7  1991/11/29  22:00:10  dennisg\n  * modified to implement set functions.\n  *\n@@ -63,7 +67,7 @@ extern \"C\" {\n \n #include  <sys/types.h>\n #include  <hash.h>\n-#include\t<stdarg.h>\n+#include  <stdarg.h>\n \n \n #define nil ( id )0                             /* id of Nil instance */\n@@ -187,12 +191,12 @@ typedef struct objc_symtab {\n  *  module structure of the executable. \n  */\n typedef struct objc_module {\n-  u_long    \tversion;                        \t/* Compiler revision. */\n-  u_long    \tsize;                            \t/* sizeof(Module). */\n-  const char*\tname;                           \t/* Name of the file where the \n+  u_long      version;                          /* Compiler revision. */\n+  u_long      size;                             /* sizeof(Module). */\n+  const char* name;                             /* Name of the file where the \n                                                   module was generated.   The \n                                                   name includes the path. */\n-  Symtab_t  \tsymtab;                          \t/* Pointer to the Symtab of\n+  Symtab_t    symtab;                           /* Pointer to the Symtab of\n                                                   the module.  The Symtab\n                                                   holds an array of pointers to \n                                                   the classes and categories \n@@ -213,13 +217,13 @@ typedef struct objc_ivar_list {\n                                                   variable defined in the\n                                                   class. */\n   struct objc_ivar {\n-    const char* ivar_name;                     \t/* Name of the instance\n+    const char* ivar_name;                      /* Name of the instance\n                                                   variable as entered in the\n                                                   class definition. */\n-    const char* ivar_type;                     \t/* Description of the Ivar's\n+    const char* ivar_type;                      /* Description of the Ivar's\n                                                   type.  Useful for \n                                                   debuggers. */\n-    int   \t\t\tivar_offset;                  \t/* Byte offset from the base \n+    int         ivar_offset;                    /* Byte offset from the base \n                                                   address of the instance \n                                                   structure to the variable. */\n \n@@ -245,16 +249,16 @@ typedef struct objc_method_list {\n   int             method_count;               /* Number of methods defined in \n                                                 this structure. */\n   struct objc_method {\n-    SEL   \t\t\tmethod_name;                \t/* This variable is the method's \n+    SEL         method_name;                  /* This variable is the method's \n                                                 name.  It is a char*. \n                                                   The unique integer passed to \n                                                 objc_msgSend() is a char* too.  \n                                                 It is compared against \n                                                 method_name using strcmp(). */\n-    const char*\tmethod_types;                 /* Description of the method's\n+    const char* method_types;                 /* Description of the method's\n                                                 parameter list.  Useful for\n                                                 debuggers. */\n-    IMP   \t\t\tmethod_imp;                   /* Address of the method in the \n+    IMP         method_imp;                   /* Address of the method in the \n                                                 executable. */\n   } method_list[1];                           /* Variable length \n                                                 structure. */\n@@ -275,25 +279,25 @@ typedef struct objc_method_list {\n  *  messaging operations.  Therefore some members \n  *  change type.\n  * The compiler generates \"char* const\" and places a string\n- *\tin the following member variables:  isa and super_class.\n+ *  in the following member variables:  isa and super_class.\n  */\n typedef struct objc_metaClass {     \n-  struct objc_metaClass*\tisa;                /* Pointer to Object meta\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass. */\n-  struct objc_metaClass*\tsuper_class;        /* Pointer to meta class's\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsuper class. NULL for \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject. */\n-  const char*         \t\tname;               /* Name of the meta class. */\n-  long         \t\t\t\t\t \tversion;            /* Unknown. */\n-  long          \t\t\t\t\tinfo;               /* Bit mask.  See class masks \n+  struct objc_metaClass*  isa;                /* Pointer to Object meta\n+                                                class. */\n+  struct objc_metaClass*  super_class;        /* Pointer to meta class's\n+                                                super class. NULL for \n+                                                Object. */\n+  const char*             name;               /* Name of the meta class. */\n+  long                    version;            /* Unknown. */\n+  long                    info;               /* Bit mask.  See class masks \n                                                 defined above. */\n-  long          \t\t\t\t\tinstance_size;      /* Always 0 except for Object.\n+  long                    instance_size;      /* Always 0 except for Object.\n                                                 Should be ignored. */\n-  IvarList_t    \t\t\t\t\tivars;              /* Always NULL except for \n+  IvarList_t              ivars;              /* Always NULL except for \n                                                 Object.  Should be ignored. */\n-  MethodList_t \t\t\t\t\t \tmethods;            /* Linked List of factory methods \n+  MethodList_t            methods;            /* Linked List of factory methods \n                                                 for the class. */\n-  Cache_t       \t\t\t\t\tcache;              /* Used to cache factory methods\n+  Cache_t                 cache;              /* Used to cache factory methods\n                                                 defined for the class and its \n                                                 super classes.  Entries are\n                                                 made to the cache as the\n@@ -312,33 +316,33 @@ typedef struct objc_metaClass {\n  *  messaging operations.  Therefore some members \n  *  change type.\n  * The compiler generates \"char* const\" and places a string\n- *\tin the following member variables:  super_class.\n+ *  in the following member variables:  super_class.\n  */\n typedef struct objc_class {     \n-  MetaClass_t   \t\t\tisa;                    /* Pointer to the class's\n+  MetaClass_t         isa;                    /* Pointer to the class's\n                                                 meta class. */\n-  struct objc_class*\tsuper_class;            /* Pointer to the super \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass. NULL for class \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject. */\n+  struct objc_class*  super_class;            /* Pointer to the super \n+                                                class. NULL for class \n+                                                Object. */\n   const char*         name;                   /* Name of the class. */\n-  long          \t\t\tversion;                /* Unknown. */\n-  long          \t\t\tinfo;                   /* Bit mask.  See class masks \n+  long                version;                /* Unknown. */\n+  long                info;                   /* Bit mask.  See class masks \n                                                 defined above. */\n-  long          \t\t\tinstance_size;          /* Size in bytes of the class.  \n+  long                instance_size;          /* Size in bytes of the class.  \n                                                 The sum of the class definition \n                                                 and all super class \n                                                 definitions. */\n-  IvarList_t    \t\t\tivars;                  /* Pointer to a structure that\n+  IvarList_t          ivars;                  /* Pointer to a structure that\n                                                 describes the instance \n                                                 variables in the class\n                                                 definition.  NULL indicates\n                                                 no instance variables.  Does\n                                                 not include super class\n                                                 variables. */\n-  MethodList_t  \t\t\tmethods;                /* Linked list of instance\n+  MethodList_t        methods;                /* Linked list of instance\n                                                 methods defined for the \n                                                 class. */\n-  Cache_t      \t\t\t\tcache;                  /* Used to cache instance methods\n+  Cache_t             cache;                  /* Used to cache instance methods\n                                                 defined for the class and its \n                                                 super classes.  Entries are\n                                                 made to the cache as the\n@@ -375,39 +379,39 @@ typedef struct objc_category {\n  *  structures and passes it to objc_msgSuper(). \n  */\n typedef struct objc_super {\n-  id    \treceiver;                           /* Id of the object sending\n+  id      receiver;                           /* Id of the object sending\n                                                 the message. */\n   Class_t class;                              /* Object's super class. */\n } Super, *Super_t;\n \n /*\n  * _alloc points to the function, called through \n- *\tclass_createInstance(), used to allocate memory for \n- *\tnew instances.\n+ *  class_createInstance(), used to allocate memory for \n+ *  new instances.\n  */\n extern id (*_alloc)(Class_t aClass, u_int indexedIvarBytes);\n /*\n  * _dealloc points to the function, called \n- *\tthrough object_dispose(), used to free instances.\n+ *  through object_dispose(), used to free instances.\n  */\n extern id (*_dealloc)(id aObject);\n /*\n  * _realloc points to the function, called through \n- *\tobject_realloc(), used to reallocate memory for an object\n+ *  object_realloc(), used to reallocate memory for an object\n  */\n extern id (*_realloc)(id aObject, u_int numBytes);\n \n /*\n  * _copy points to the function, called through \n- *\tobject_copy(), used to create an exact copy of an object.\n+ *  object_copy(), used to create an exact copy of an object.\n  */\n-extern\tid (*_copy)(id aObject, u_int indexedIvarBytes);\n+extern  id (*_copy)(id aObject, u_int indexedIvarBytes);\n \n /*\n  * _error points to the function that the run-time \n- *\tsystem calls in response to an error.  By default, \n- *\tit prints formatted error messages to the standard \n- *\terror stream and calls abort() to produce a core file.\n+ *  system calls in response to an error.  By default, \n+ *  it prints formatted error messages to the standard \n+ *  error stream and calls abort() to produce a core file.\n  */\n extern void (*_error)(id aObject, const char* fmt, va_list ap);\n "}]}