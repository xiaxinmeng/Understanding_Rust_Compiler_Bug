{"sha": "95b88040e291954a8c18051e8167cce22bda804a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTViODgwNDBlMjkxOTU0YThjMTgwNTFlODE2N2NjZTIyYmRhODA0YQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-09-28T11:02:35Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-09-28T11:02:35Z"}, "message": "URLConnection.java: Reformatted.\n\n2004-09-28  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/URLConnection.java: Reformatted.\n\t* java/net/URLClassLoader.java: Reformatted.\n\t(getContent): Reordered return of content.\n\t(getContentHandler): Don't check for null explicitely.\n\nFrom-SVN: r88226", "tree": {"sha": "efb4af35b0764ce908ae970f7c912407f60277e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efb4af35b0764ce908ae970f7c912407f60277e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95b88040e291954a8c18051e8167cce22bda804a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95b88040e291954a8c18051e8167cce22bda804a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95b88040e291954a8c18051e8167cce22bda804a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95b88040e291954a8c18051e8167cce22bda804a/comments", "author": null, "committer": null, "parents": [{"sha": "1165dc50e84972ea884e0ef09d1910bc7e67e7b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1165dc50e84972ea884e0ef09d1910bc7e67e7b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1165dc50e84972ea884e0ef09d1910bc7e67e7b6"}], "stats": {"total": 80, "additions": 47, "deletions": 33}, "files": [{"sha": "3a60a56f84c62257018c05451a6bdc860375a425", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b88040e291954a8c18051e8167cce22bda804a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b88040e291954a8c18051e8167cce22bda804a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=95b88040e291954a8c18051e8167cce22bda804a", "patch": "@@ -1,3 +1,10 @@\n+2004-09-28  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/URLConnection.java: Reformatted.\n+\t* java/net/URLClassLoader.java: Reformatted.\n+\t(getContent): Reordered return of content.\n+\t(getContentHandler): Don't check for null explicitely.\n+\n 2004-09-27  Michael Koch  <konqueror@gmx.de>\n \n \t* java/io/BufferedInputStream.java"}, {"sha": "b991be8addf51b2d344663bd82ba9ccdfaa25905", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b88040e291954a8c18051e8167cce22bda804a/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b88040e291954a8c18051e8167cce22bda804a/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=95b88040e291954a8c18051e8167cce22bda804a", "patch": "@@ -858,7 +858,7 @@ protected Class findClass(final String className)\n \t    // Just try to read it in all at once\n \t    data = new byte[length];\n \t    int pos = 0;\n-\t    while(length - pos > 0)\n+\t    while (length - pos > 0)\n \t      {\n \t\tint len = in.read(data, pos, length - pos);\n \t\tif (len == -1)\n@@ -872,7 +872,7 @@ protected Class findClass(final String className)\n \t    // We don't know the data length.\n \t    // Have to read it in chunks.\n \t    ByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n-\t    byte b[] = new byte[4096];\n+\t    byte[] b = new byte[4096];\n \t    int l = 0;\n \t    while (l != -1)\n \t      {"}, {"sha": "3b3355cc11ec4884b4bd493413d4584d41ab672c", "filename": "libjava/java/net/URLConnection.java", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b88040e291954a8c18051e8167cce22bda804a/libjava%2Fjava%2Fnet%2FURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b88040e291954a8c18051e8167cce22bda804a/libjava%2Fjava%2Fnet%2FURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLConnection.java?ref=95b88040e291954a8c18051e8167cce22bda804a", "patch": "@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.net;\n \n import java.io.IOException;\n@@ -87,8 +88,8 @@\n  * by the actual content handlers as described in the description of that\n  * method.\n  *\n- * @author Aaron M. Renn <arenn@urbanophile.com>\n- * @author Warren Levy <warrenl@cygnus.com>\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Warren Levy (warrenl@cygnus.com)\n  */\n public abstract class URLConnection\n {\n@@ -370,7 +371,7 @@ public long getHeaderFieldDate(String name, long defaultValue)\n   {\n     if (! dateformats_initialized)\n       initializeDateFormats();\n-    \n+\n     if (position == null)\n       position = new ParsePosition(0);\n \n@@ -411,23 +412,29 @@ public String getHeaderFieldKey(int index)\n   }\n \n   /**\n-   * This method returns the content of the document pointed to by the URL\n-   * as an Object.  The type of object depends on the MIME type of the\n-   * object and particular content hander loaded.  Most text type content\n-   * handlers will return a subclass of InputStream.  Images usually return\n-   * a class that implements ImageProducer.  There is not guarantee what\n-   * type of object will be returned, however.\n-   * <p>\n-   * This class first determines the MIME type of the content, then creates\n-   * a ContentHandler object to process the input.  If the ContentHandlerFactory\n-   * is set, then that object is called to load a content handler, otherwise\n-   * a class called gnu.java.net.content.&lt;content_type&gt; is tried.\n-   * The default class will also be used if the content handler factory returns\n-   * a null content handler.\n-   *\n-   * @exception IOException If an error occurs\n+   * This method returns the content of the document pointed to by the\n+   * URL as an Object.  The type of object depends on the MIME type of\n+   * the object and particular content hander loaded.  Most text type\n+   * content handlers will return a subclass of\n+   * <code>InputStream</code>.  Images usually return a class that\n+   * implements <code>ImageProducer</code>.  There is not guarantee\n+   * what type of object will be returned, however.\n+   *\n+   * <p>This class first determines the MIME type of the content, then\n+   * creates a ContentHandler object to process the input.  If the\n+   * <code>ContentHandlerFactory</code> is set, then that object is\n+   * called to load a content handler, otherwise a class called\n+   * gnu.java.net.content.&lt;content_type&gt; is tried.  If this\n+   * handler does not exist, the method will simple return the\n+   * <code>InputStream</code> returned by\n+   * <code>getInputStream()</code>.  Note that the default\n+   * implementation of <code>getInputStream()</code> throws a\n+   * <code>UnknownServiceException</code> so subclasses are encouraged\n+   * to override this method.</p>\n+   *\n+   * @exception IOException If an error with the connection occurs.\n    * @exception UnknownServiceException If the protocol does not support the\n-   * content type\n+   * content type at all.\n    */\n   public Object getContent() throws IOException\n   {\n@@ -441,10 +448,10 @@ public Object getContent() throws IOException\n     String type = getContentType();\n     ContentHandler ch = getContentHandler(type);\n \n-    if (ch == null)\n-      return getInputStream();\n+    if (ch != null)\n+      return ch.getContent(this);\n \n-    return ch.getContent(this);\n+    return getInputStream();\n   }\n \n   /**\n@@ -888,20 +895,20 @@ public static synchronized void setContentHandlerFactory(ContentHandlerFactory f\n    */\n   public static String guessContentTypeFromName(String filename)\n   {\n-    int dot = filename.lastIndexOf (\".\");\n+    int dot = filename.lastIndexOf(\".\");\n     \n     if (dot != -1)\n       {\n \tif (dot == filename.length())\n-\t  return (\"application/octet-stream\");\n+\t  return \"application/octet-stream\";\n \telse\n-\t  filename = filename.substring (dot + 1);\n+\t  filename = filename.substring(dot + 1);\n       }\n     \n-    String type = MimeTypes.getMimeTypeFromExtension (filename);\n+    String type = MimeTypes.getMimeTypeFromExtension(filename);\n     \n     if (type == null)\n-      return(\"application/octet-stream\");\n+      return\"application/octet-stream\";\n \n     return type;\n   }\n@@ -957,7 +964,7 @@ public static FileNameMap getFileNameMap()\n    */\n   public static void setFileNameMap(FileNameMap map)\n   {\n-    // Throw an exception if an extant security mgr precludes\n+    // Throw an exception if an extant security manager precludes\n     // setting the factory.\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n@@ -968,12 +975,12 @@ public static void setFileNameMap(FileNameMap map)\n \n   private ContentHandler getContentHandler(String contentType)\n   {\n-    ContentHandler handler;\n-\n     // No content type so just handle it as the default.\n     if (contentType == null || contentType.equals(\"\"))\n       return null;\n \n+    ContentHandler handler;\n+\n     // See if a handler has been cached for this content type.\n     // For efficiency, if a content type has been searched for but not\n     // found, it will be in the hash table but as the contentType String\n@@ -1039,7 +1046,7 @@ else if (! ((cArray[i] >= 'A' && cArray[i] <= 'Z') ||\n       }\n \n     // Update the hashtable with the new content handler.\n-    if (handler != null && handler instanceof ContentHandler)\n+    if (handler instanceof ContentHandler)\n       {\n \thandlers.put(contentType, handler);\n \treturn handler;"}]}