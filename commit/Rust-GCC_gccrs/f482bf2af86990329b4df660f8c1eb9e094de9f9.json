{"sha": "f482bf2af86990329b4df660f8c1eb9e094de9f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ4MmJmMmFmODY5OTAzMjliNGRmNjYwZjhjMWViOWUwOTRkZTlmOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-01T07:51:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-02T05:55:29Z"}, "message": "tree-optimization/102155 - fix LIM fill_always_executed_in CFG walk\n\nThis fixes the CFG walk order of fill_always_executed_in to use\nRPO oder rather than the dominator based order computed by\nget_loop_body_in_dom_order.  That fixes correctness issues with\nunordered dominator children.\n\nThe RPO order computed by rev_post_order_and_mark_dfs_back_seme in\nits for-iteration mode is a good match for the algorithm.\n\n2021-09-01  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102155\n\t* tree-ssa-loop-im.c (fill_always_executed_in_1): Iterate\n\tover a part of the RPO array and do not recurse here.\n\tDump blocks marked as always executed.\n\t(fill_always_executed_in): Walk over the RPO array and\n\tprocess loops whose header we run into.\n\t(loop_invariant_motion_in_fun): Compute the first RPO\n\tusing rev_post_order_and_mark_dfs_back_seme in iteration\n\torder and pass that to fill_always_executed_in.", "tree": {"sha": "f0b1271a7b6cf34f7e2c5cc3b393103ee4bdf4e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0b1271a7b6cf34f7e2c5cc3b393103ee4bdf4e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f482bf2af86990329b4df660f8c1eb9e094de9f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f482bf2af86990329b4df660f8c1eb9e094de9f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f482bf2af86990329b4df660f8c1eb9e094de9f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f482bf2af86990329b4df660f8c1eb9e094de9f9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e16b2123dd1cf5bab23cda0ce65223e5d55eded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e16b2123dd1cf5bab23cda0ce65223e5d55eded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e16b2123dd1cf5bab23cda0ce65223e5d55eded"}], "stats": {"total": 136, "additions": 73, "deletions": 63}, "files": [{"sha": "f3706dcdb8a3f62615817e4f845924cb3169dc15", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 73, "deletions": 63, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f482bf2af86990329b4df660f8c1eb9e094de9f9/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f482bf2af86990329b4df660f8c1eb9e094de9f9/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=f482bf2af86990329b4df660f8c1eb9e094de9f9", "patch": "@@ -3025,92 +3025,88 @@ do_store_motion (void)\n /* Fills ALWAYS_EXECUTED_IN information for basic blocks of LOOP, i.e.\n    for each such basic block bb records the outermost loop for that execution\n    of its header implies execution of bb.  CONTAINS_CALL is the bitmap of\n-   blocks that contain a nonpure call.  */\n+   blocks that contain a nonpure call.  The blocks of LOOP start at index\n+   START of the RPO array of size N.  */\n \n static void\n-fill_always_executed_in_1 (class loop *loop, sbitmap contains_call)\n+fill_always_executed_in_1 (function *fun, class loop *loop,\n+\t\t\t   int *rpo, int start, int n, sbitmap contains_call)\n {\n-  basic_block bb = NULL, *bbs, last = NULL;\n-  unsigned i;\n-  edge e;\n+  basic_block last = NULL;\n   class loop *inn_loop = loop;\n \n-  if (ALWAYS_EXECUTED_IN (loop->header) == NULL)\n+  for (int i = start; i < n; i++)\n     {\n-      bbs = get_loop_body_in_dom_order (loop);\n-\n-      for (i = 0; i < loop->num_nodes; i++)\n-\t{\n-\t  edge_iterator ei;\n-\t  bb = bbs[i];\n-\n-\t  if (dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n-\t    last = bb;\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n+      /* Stop when we iterated over all blocks in this loop.  */\n+      if (!flow_bb_inside_loop_p (loop, bb))\n+\tbreak;\n \n-\t  if (bitmap_bit_p (contains_call, bb->index))\n-\t    break;\n+      if (dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\tlast = bb;\n \n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    {\n-\t      /* If there is an exit from this BB.  */\n-\t      if (!flow_bb_inside_loop_p (loop, e->dest))\n-\t\tbreak;\n-\t      /* Or we enter a possibly non-finite loop.  */\n-\t      if (flow_loop_nested_p (bb->loop_father,\n-\t\t\t\t      e->dest->loop_father)\n-\t\t  && ! finite_loop_p (e->dest->loop_father))\n-\t\tbreak;\n-\t    }\n-\t  if (e)\n-\t    break;\n+      if (bitmap_bit_p (contains_call, bb->index))\n+\tbreak;\n \n-\t  /* A loop might be infinite (TODO use simple loop analysis\n-\t     to disprove this if possible).  */\n-\t  if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  /* If there is an exit from this BB.  */\n+\t  if (!flow_bb_inside_loop_p (loop, e->dest))\n \t    break;\n-\n-\t  if (!flow_bb_inside_loop_p (inn_loop, bb))\n+\t  /* Or we enter a possibly non-finite loop.  */\n+\t  if (flow_loop_nested_p (bb->loop_father,\n+\t\t\t\t  e->dest->loop_father)\n+\t      && ! finite_loop_p (e->dest->loop_father))\n \t    break;\n+\t}\n+      if (e)\n+\tbreak;\n \n-\t  if (bb->loop_father->header == bb)\n-\t    {\n-\t      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n-\t\tbreak;\n+      /* A loop might be infinite (TODO use simple loop analysis\n+\t to disprove this if possible).  */\n+      if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+\tbreak;\n \n-\t      /* In a loop that is always entered we may proceed anyway.\n-\t\t But record that we entered it and stop once we leave it.  */\n-\t      inn_loop = bb->loop_father;\n-\t    }\n-\t}\n+      if (!flow_bb_inside_loop_p (inn_loop, bb))\n+\tbreak;\n \n-      while (1)\n+      if (bb->loop_father->header == bb)\n \t{\n-\t  SET_ALWAYS_EXECUTED_IN (last, loop);\n-\t  if (last == loop->header)\n+\t  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n \t    break;\n-\t  last = get_immediate_dominator (CDI_DOMINATORS, last);\n-\t}\n \n-      free (bbs);\n+\t  /* In a loop that is always entered we may proceed anyway.\n+\t     But record that we entered it and stop once we leave it.  */\n+\t  inn_loop = bb->loop_father;\n+\t}\n     }\n \n-  for (loop = loop->inner; loop; loop = loop->next)\n-    fill_always_executed_in_1 (loop, contains_call);\n+  while (1)\n+    {\n+      SET_ALWAYS_EXECUTED_IN (last, loop);\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE, \"bb %d is always executed in loop %d\\n\",\n+\t\t     last->index, loop->num);\n+      if (last == loop->header)\n+\tbreak;\n+      last = get_immediate_dominator (CDI_DOMINATORS, last);\n+    }\n }\n \n /* Fills ALWAYS_EXECUTED_IN information for basic blocks, i.e.\n    for each such basic block bb records the outermost loop for that execution\n    of its header implies execution of bb.  */\n \n static void\n-fill_always_executed_in (void)\n+fill_always_executed_in (function *fun, int *rpo, int n)\n {\n   basic_block bb;\n-  class loop *loop;\n \n-  auto_sbitmap contains_call (last_basic_block_for_fn (cfun));\n+  auto_sbitmap contains_call (last_basic_block_for_fn (fun));\n   bitmap_clear (contains_call);\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -3123,8 +3119,18 @@ fill_always_executed_in (void)\n \tbitmap_set_bit (contains_call, bb->index);\n     }\n \n-  for (loop = current_loops->tree_root->inner; loop; loop = loop->next)\n-    fill_always_executed_in_1 (loop, contains_call);\n+  /* The RPO order we iterate over is one that visits all blocks of a CFG\n+     cycle before leaving it.  That means we can visit a loop once we\n+     run into its header and we can skip it if it was determined as always\n+     entering when proccessing the containing loop.  */\n+  for (int i = 0; i < n; ++i)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n+      if (bb->loop_father->header == bb\n+\t  && !ALWAYS_EXECUTED_IN (bb))\n+\tfill_always_executed_in_1 (fun, bb->loop_father,\n+\t\t\t\t   rpo, i, n, contains_call);\n+    }\n }\n \n \n@@ -3227,23 +3233,27 @@ loop_invariant_motion_in_fun (function *fun, bool store_motion)\n   /* Gathers information about memory accesses in the loops.  */\n   analyze_memory_references (store_motion);\n \n-  /* Fills ALWAYS_EXECUTED_IN information for basic blocks.  */\n-  fill_always_executed_in ();\n+  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun) - NUM_FIXED_BLOCKS);\n+  auto_bitmap exit_bbs;\n+  bitmap_set_bit (exit_bbs, EXIT_BLOCK);\n+  edge entry = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (fun));\n+  int n = rev_post_order_and_mark_dfs_back_seme (fun, entry, exit_bbs, true,\n+\t\t\t\t\t\t rpo, NULL);\n \n-  int *rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n-  int n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n+  /* Fills ALWAYS_EXECUTED_IN information for basic blocks.  */\n+  fill_always_executed_in (fun, rpo, n);\n \n   /* For each statement determine the outermost loop in that it is\n      invariant and cost for computing the invariant.  */\n   for (int i = 0; i < n; ++i)\n     compute_invariantness (BASIC_BLOCK_FOR_FN (fun, rpo[i]));\n+  free (rpo);\n \n   /* Execute store motion.  Force the necessary invariants to be moved\n      out of the loops as well.  */\n   if (store_motion)\n     do_store_motion ();\n \n-  free (rpo);\n   rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n   n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n "}]}