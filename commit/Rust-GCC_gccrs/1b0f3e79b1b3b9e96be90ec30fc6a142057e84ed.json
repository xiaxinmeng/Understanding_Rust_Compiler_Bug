{"sha": "1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIwZjNlNzliMWIzYjllOTZiZTkwZWMzMGZjNmExNDIwNTdlODRlZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-05-30T22:23:19Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-05-30T22:23:19Z"}, "message": "fold-const.c (combine_comparisons, [...]): Use constant_boolean_node where appropriate.\n\n\n\t* fold-const.c (combine_comparisons, optimize_bit_field_compare,\n\trange_binop, fold_truthop, fold_binary_op_with_conditional_arg,\n\tfold_mathfn_compare, fold_inf_compare, fold,\n\tfold_relational_hi_lo, nondestructive_fold_binary_to_constant):\n\tUse constant_boolean_node where appropriate.  Don't bother using\n\tfold_convert on the second argument to omit_one_operand.\n\nFrom-SVN: r82468", "tree": {"sha": "f3558323670cd4f2721326e49c43e117833dbf67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3558323670cd4f2721326e49c43e117833dbf67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed/comments", "author": null, "committer": null, "parents": [{"sha": "29d64660c735aa0c52a29452342b631a09c1266e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d64660c735aa0c52a29452342b631a09c1266e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29d64660c735aa0c52a29452342b631a09c1266e"}], "stats": {"total": 151, "additions": 53, "deletions": 98}, "files": [{"sha": "0746702b562242d8f7f5693e0875825e09f4a3d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed", "patch": "@@ -1,3 +1,12 @@\n+2004-05-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (combine_comparisons, optimize_bit_field_compare,\n+\trange_binop, fold_truthop, fold_binary_op_with_conditional_arg,\n+\tfold_mathfn_compare, fold_inf_compare, fold,\n+\tfold_relational_hi_lo, nondestructive_fold_binary_to_constant):\n+\tUse constant_boolean_node where appropriate.  Don't bother using\n+\tfold_convert on the second argument to omit_one_operand.\n+\n 2004-05-30  Roger Sayle  <roger@eyesopen.com>\n \n \t* doc/c-tree.texi (Expressions): Document FLOOR_DIV_EXPR,"}, {"sha": "d2e333e0d42e14821dd04363182bcde2ffadade6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 44, "deletions": 98, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1b0f3e79b1b3b9e96be90ec30fc6a142057e84ed", "patch": "@@ -2298,9 +2298,9 @@ combine_comparisons (enum tree_code code, enum tree_code lcode,\n       }\n \n   if (compcode == COMPCODE_TRUE)\n-    return fold_convert (truth_type, integer_one_node);\n+    return constant_boolean_node (true, truth_type);\n   else if (compcode == COMPCODE_FALSE)\n-    return fold_convert (truth_type, integer_zero_node);\n+    return constant_boolean_node (false, truth_type);\n   else\n     return fold (build2 (compcode_to_comparison (compcode),\n \t\t\t truth_type, ll_arg, lr_arg));\n@@ -3141,9 +3141,7 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n \t{\n \t  warning (\"comparison is always %d due to width of bit-field\",\n \t\t   code == NE_EXPR);\n-\t  return fold_convert (compare_type,\n-\t\t\t       (code == NE_EXPR\n-\t\t\t\t? integer_one_node : integer_zero_node));\n+\t  return constant_boolean_node (code == NE_EXPR, compare_type);\n \t}\n     }\n   else\n@@ -3154,9 +3152,7 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n \t{\n \t  warning (\"comparison is always %d due to width of bit-field\",\n \t\t   code == NE_EXPR);\n-\t  return fold_convert (compare_type,\n-\t\t\t       (code == NE_EXPR\n-\t\t\t\t? integer_one_node : integer_zero_node));\n+\t  return constant_boolean_node (code == NE_EXPR, compare_type);\n \t}\n     }\n \n@@ -3479,7 +3475,7 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n       abort ();\n     }\n \n-  return fold_convert (type, result ? integer_one_node : integer_zero_node);\n+  return constant_boolean_node (result, type);\n }\n \f\n /* Given EXP, a logical expression, set the range it is testing into\n@@ -4212,7 +4208,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \treturn build2 (NE_EXPR, truth_type,\n \t\t       build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n \t\t\t       ll_arg, rl_arg),\n-\t\t       integer_zero_node);\n+\t\t       fold_convert (TREE_TYPE (ll_arg), integer_zero_node));\n \n       /* Convert (a == 0) && (b == 0) into (a | b) == 0.  */\n       if (code == TRUTH_AND_EXPR\n@@ -4222,7 +4218,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \treturn build2 (EQ_EXPR, truth_type,\n \t\t       build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n \t\t\t       ll_arg, rl_arg),\n-\t\t       integer_zero_node);\n+\t\t       fold_convert (TREE_TYPE (ll_arg), integer_zero_node));\n \n       return build2 (code, truth_type, lhs, rhs);\n     }\n@@ -4344,9 +4340,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n \n-\t  return fold_convert (truth_type,\n-\t\t\t       wanted_code == NE_EXPR\n-\t\t\t       ? integer_one_node : integer_zero_node);\n+\t  return constant_boolean_node (wanted_code == NE_EXPR, truth_type);\n \t}\n     }\n   if (r_const)\n@@ -4361,9 +4355,7 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n \n-\t  return fold_convert (truth_type,\n-\t\t\t       wanted_code == NE_EXPR\n-\t\t\t       ? integer_one_node : integer_zero_node);\n+\t  return constant_boolean_node (wanted_code == NE_EXPR, truth_type);\n \t}\n     }\n \n@@ -4491,12 +4483,12 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n       if (wanted_code == NE_EXPR)\n \t{\n \t  warning (\"`or' of unmatched not-equal tests is always 1\");\n-\t  return fold_convert (truth_type, integer_one_node);\n+\t  return constant_boolean_node (true, truth_type);\n \t}\n       else\n \t{\n \t  warning (\"`and' of mutually exclusive equal-tests is always 0\");\n-\t  return fold_convert (truth_type, integer_zero_node);\n+\t  return constant_boolean_node (false, truth_type);\n \t}\n     }\n \n@@ -4973,8 +4965,8 @@ fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n     {\n       tree testtype = TREE_TYPE (cond);\n       test = cond;\n-      true_value = fold_convert (testtype, integer_one_node);\n-      false_value = fold_convert (testtype, integer_zero_node);\n+      true_value = constant_boolean_node (true, testtype);\n+      false_value = constant_boolean_node (false, testtype);\n     }\n \n   if (lhs == 0)\n@@ -5054,16 +5046,12 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t{\n \t  /* sqrt(x) < y is always false, if y is negative.  */\n \t  if (code == EQ_EXPR || code == LT_EXPR || code == LE_EXPR)\n-\t    return omit_one_operand (type,\n-\t\t\t\t     fold_convert (type, integer_zero_node),\n-\t\t\t\t     arg);\n+\t    return omit_one_operand (type, integer_zero_node, arg);\n \n \t  /* sqrt(x) > y is always true, if y is negative and we\n \t     don't care about NaNs, i.e. negative values of x.  */\n \t  if (code == NE_EXPR || !HONOR_NANS (mode))\n-\t    return omit_one_operand (type,\n-\t\t\t\t     fold_convert (type, integer_one_node),\n-\t\t\t\t     arg);\n+\t    return omit_one_operand (type, integer_one_node, arg);\n \n \t  /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n \t  return fold (build2 (GE_EXPR, type, arg,\n@@ -5085,9 +5073,7 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \n \t      /* sqrt(x) > y is always false, when y is very large\n \t\t and we don't care about infinities.  */\n-\t      return omit_one_operand (type,\n-\t\t\t\t       fold_convert (type, integer_zero_node),\n-\t\t\t\t       arg);\n+\t      return omit_one_operand (type, integer_zero_node, arg);\n \t    }\n \n \t  /* sqrt(x) > c is the same as x > c*c.  */\n@@ -5106,9 +5092,7 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \t      /* sqrt(x) < y is always true, when y is a very large\n \t\t value and we don't care about NaNs or Infinities.  */\n \t      if (! HONOR_NANS (mode) && ! HONOR_INFINITIES (mode))\n-\t\treturn omit_one_operand (type,\n-\t\t\t\t\t fold_convert (type, integer_one_node),\n-\t\t\t\t\t arg);\n+\t\treturn omit_one_operand (type, integer_one_node, arg);\n \n \t      /* sqrt(x) < y is x != +Inf when y is very large and we\n \t\t don't care about NaNs.  */\n@@ -5192,16 +5176,12 @@ fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n       /* x > +Inf is always false, if with ignore sNANs.  */\n       if (HONOR_SNANS (mode))\n         return NULL_TREE;\n-      return omit_one_operand (type,\n-\t\t\t       fold_convert (type, integer_zero_node),\n-\t\t\t       arg0);\n+      return omit_one_operand (type, integer_zero_node, arg0);\n \n     case LE_EXPR:\n       /* x <= +Inf is always true, if we don't case about NaNs.  */\n       if (! HONOR_NANS (mode))\n-\treturn omit_one_operand (type,\n-\t\t\t\t fold_convert (type, integer_one_node),\n-\t\t\t\t arg0);\n+\treturn omit_one_operand (type, integer_one_node, arg0);\n \n       /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n       if (lang_hooks.decls.global_bindings_p () == 0\n@@ -7380,12 +7360,7 @@ fold (tree expr)\n \t  && DECL_P (TREE_OPERAND (arg0, 0))\n \t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n \t  && integer_zerop (arg1))\n-\t{\n-\t  if (code == EQ_EXPR)\n-\t    return fold_convert (type, integer_zero_node);\n-\t  else\n-\t    return fold_convert (type, integer_one_node);\n-\t}\n+\treturn constant_boolean_node (code != EQ_EXPR, type);\n \n       /* If this is an equality comparison of the address of two non-weak,\n \t unaliased symbols neither of which are extern (since we do not\n@@ -7403,14 +7378,9 @@ fold (tree expr)\n \t  && ! lookup_attribute (\"alias\",\n \t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg1, 0)))\n \t  && ! DECL_EXTERNAL (TREE_OPERAND (arg1, 0)))\n-\t{\n-\t  if (code == EQ_EXPR)\n-\t    return fold_convert (type, (operand_equal_p (arg0, arg1, 0)\n-\t\t    ? integer_one_node : integer_zero_node));\n-\t  else\n-\t    return fold_convert (type, (operand_equal_p (arg0, arg1, 0)\n-\t\t    ? integer_zero_node : integer_one_node));\n-\t}\n+\treturn constant_boolean_node (operand_equal_p (arg0, arg1, 0)\n+\t\t\t\t      ? code == EQ_EXPR : code != EQ_EXPR,\n+\t\t\t\t      type);\n \n       if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n \t{\n@@ -7456,7 +7426,7 @@ fold (tree expr)\n \t\t&& ! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1))))\n \t      {\n \t\ttem = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n-\t\treturn omit_one_operand (type, fold_convert (type, tem), arg0);\n+\t\treturn omit_one_operand (type, tem, arg0);\n \t      }\n \n \t    /* Fold comparisons against infinity.  */\n@@ -7632,18 +7602,14 @@ fold (tree expr)\n \t      switch (code)\n \t\t{\n \t\tcase GT_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   fold_convert (type,\n-\t\t\t\t\t\t\t integer_zero_node),\n-\t\t\t\t\t   arg0);\n+\t\t  return omit_one_operand (type, integer_zero_node, arg0);\n+\n \t\tcase GE_EXPR:\n \t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n \n \t\tcase LE_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   fold_convert (type,\n-\t\t\t\t\t\t\t integer_one_node),\n-\t\t\t\t\t   arg0);\n+\t\t  return omit_one_operand (type, integer_one_node, arg0);\n+\n \t\tcase LT_EXPR:\n \t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n \n@@ -7671,18 +7637,14 @@ fold (tree expr)\n \t      switch (code)\n \t\t{\n \t\tcase LT_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   fold_convert (type,\n-\t\t\t\t\t\t\t integer_zero_node),\n-\t\t\t\t\t   arg0);\n+\t\t  return omit_one_operand (type, integer_zero_node, arg0);\n+\n \t\tcase LE_EXPR:\n \t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n \n \t\tcase GE_EXPR:\n-\t\t  return omit_one_operand (type,\n-\t\t\t\t\t   fold_convert (type,\n-\t\t\t\t\t\t\t integer_one_node),\n-\t\t\t\t\t   arg0);\n+\t\t  return omit_one_operand (type, integer_one_node, arg0);\n+\n \t\tcase GT_EXPR:\n \t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n \n@@ -9316,16 +9278,14 @@ fold_relational_hi_lo (enum tree_code *code_p, const tree type, tree *op0_p,\n \tswitch (code)\n \t  {\n \t  case GT_EXPR:\n-\t    return omit_one_operand (type,\n-\t\t\t\t     fold_convert (type, integer_zero_node),\n-\t\t\t\t     op0);\n+\t    return omit_one_operand (type, integer_zero_node, op0);\n+\n \t  case GE_EXPR:\n \t    *code_p = EQ_EXPR;\n \t    break;\n \t  case LE_EXPR:\n-\t    return omit_one_operand (type,\n-\t\t\t\t     fold_convert (type, integer_one_node),\n-\t\t\t\t     op0);\n+\t    return omit_one_operand (type, integer_one_node, op0);\n+\n \t  case LT_EXPR:\n \t    *code_p = NE_EXPR;\n \t    break;\n@@ -9356,17 +9316,15 @@ fold_relational_hi_lo (enum tree_code *code_p, const tree type, tree *op0_p,\n        switch (code)\n \t  {\n \t  case LT_EXPR:\n-\t    return omit_one_operand (type,\n-\t\t\t\t     fold_convert (type, integer_zero_node),\n-\t\t\t\t     op0);\n+\t    return omit_one_operand (type, integer_zero_node, op0);\n+\n \t  case LE_EXPR:\n \t    *code_p = EQ_EXPR;\n \t    break;\n \n \t  case GE_EXPR:\n-\t    return omit_one_operand (type,\n-\t\t\t\t     fold_convert (type, integer_one_node),\n-\t\t\t\t     op0);\n+\t    return omit_one_operand (type, integer_one_node, op0);\n+\n \t  case GT_EXPR:\n \t    *code_p = NE_EXPR;\n \t    break;\n@@ -9686,12 +9644,7 @@ nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n       if (integer_zerop (op0))\n \treturn omit_one_operand (type, op0, op1);\n       if (TREE_CODE (op0) == INTEGER_CST && TREE_CODE (op1) == INTEGER_CST)\n-\t{\n-\t  int x1 = ! integer_zerop (op0);\n-\t  int x2 = ! integer_zerop (op1);\n-\n-\t  return ((x1 & x2) ? integer_one_node : integer_zero_node);\n-\t}\n+\treturn constant_boolean_node (true, type);\n       return NULL_TREE;\n \n     case TRUTH_OR_EXPR:\n@@ -9704,21 +9657,14 @@ nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n       if (TREE_CODE (op0) == INTEGER_CST && ! integer_zerop (op0))\n \treturn omit_one_operand (type, op0, op1);\n       if (TREE_CODE (op0) == INTEGER_CST && TREE_CODE (op1) == INTEGER_CST)\n-\t{\n-\t  int x1 = ! integer_zerop (op0);\n-\t  int x2 = ! integer_zerop (op1);\n-\n-\t  return ((x1 | x2) ? integer_one_node : integer_zero_node);\n-\t}\n+\treturn constant_boolean_node (false, type);\n       return NULL_TREE;\n \n     case TRUTH_XOR_EXPR:\n       if (TREE_CODE (op0) == INTEGER_CST && TREE_CODE (op1) == INTEGER_CST)\n \t{\n-\t  int x1 = ! integer_zerop (op0);\n-\t  int x2 = ! integer_zerop (op1);\n-\n-\t  return ((x1 ^ x2) ? integer_one_node : integer_zero_node);\n+\t  int x = ! integer_zerop (op0) ^ ! integer_zerop (op1);\n+\t  return constant_boolean_node (x, type);\n \t}\n       return NULL_TREE;\n "}]}