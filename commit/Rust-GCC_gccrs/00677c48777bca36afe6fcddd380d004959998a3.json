{"sha": "00677c48777bca36afe6fcddd380d004959998a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA2NzdjNDg3NzdiY2EzNmFmZTZmY2RkZDM4MGQwMDQ5NTk5OThhMw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-12-14T17:18:22Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-12-14T17:18:22Z"}, "message": "PR libstdc++/83427 detect weak result type from noexcept functions\n\n\tPR libstdc++/83427\n\t* include/bits/refwrap.h (_Maybe_unary_or_binary_function): Move here\n\tfrom <bits/std_function.h>.\n\t(_Mem_fn_traits_base, _Mem_fn_traits): Move here, from <functional>.\n\t(_Weak_result_type_impl, _Reference_wrapper_base): Deduce noexcept\n\tfor function types. Remove partial specializations for member\n\tfunctions.\n\t(_Weak_result_type_impl): Remove unused partial specializations for\n\tnon-referenceable function types and for references to functions.\n\t(_Weak_result_type_memfun, _Reference_wrapper_base_memfun): New\n\thelpers to handle member functions via _Mem_fn_traits.\n\t(_Weak_result_type, reference_wrapper): Derive from new helpers.\n\t* include/bits/std_function.h (_Maybe_unary_or_binary_function): Move\n\tto <bits/refwrap.h>.\n\t* include/std/functional (_Pack, _AllConvertible, _NotSame): Remove.\n\t(_Mem_fn_traits_base, _Mem_fn_traits): Move to <bits/refwrap.h>.\n\t* testsuite/20_util/bind/83427.cc: New test.\n\t* testsuite/20_util/bind/refqual.cc: Add noexcept to functions and\n\tcheck for weak result types.\n\t* testsuite/20_util/reference_wrapper/83427.cc: New test.\n\nFrom-SVN: r255651", "tree": {"sha": "92c8339eeda08ec4c2912c57f9aeb729e4d729e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92c8339eeda08ec4c2912c57f9aeb729e4d729e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00677c48777bca36afe6fcddd380d004959998a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00677c48777bca36afe6fcddd380d004959998a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00677c48777bca36afe6fcddd380d004959998a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00677c48777bca36afe6fcddd380d004959998a3/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db811328e004b0d97d25187dc985184c260955ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db811328e004b0d97d25187dc985184c260955ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db811328e004b0d97d25187dc985184c260955ee"}], "stats": {"total": 425, "additions": 209, "deletions": 216}, "files": [{"sha": "143739f1ce2c20043d12f625e7fbb02aa7cc9c93", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=00677c48777bca36afe6fcddd380d004959998a3", "patch": "@@ -1,5 +1,26 @@\n 2017-12-14  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/83427\n+\t* include/bits/refwrap.h (_Maybe_unary_or_binary_function): Move here\n+\tfrom <bits/std_function.h>.\n+\t(_Mem_fn_traits_base, _Mem_fn_traits): Move here, from <functional>.\n+\t(_Weak_result_type_impl, _Reference_wrapper_base): Deduce noexcept\n+\tfor function types. Remove partial specializations for member\n+\tfunctions.\n+\t(_Weak_result_type_impl): Remove unused partial specializations for\n+\tnon-referenceable function types and for references to functions.\n+\t(_Weak_result_type_memfun, _Reference_wrapper_base_memfun): New\n+\thelpers to handle member functions via _Mem_fn_traits.\n+\t(_Weak_result_type, reference_wrapper): Derive from new helpers.\n+\t* include/bits/std_function.h (_Maybe_unary_or_binary_function): Move\n+\tto <bits/refwrap.h>.\n+\t* include/std/functional (_Pack, _AllConvertible, _NotSame): Remove.\n+\t(_Mem_fn_traits_base, _Mem_fn_traits): Move to <bits/refwrap.h>.\n+\t* testsuite/20_util/bind/83427.cc: New test.\n+\t* testsuite/20_util/bind/refqual.cc: Add noexcept to functions and\n+\tcheck for weak result types.\n+\t* testsuite/20_util/reference_wrapper/83427.cc: New test.\n+\n \t* testsuite/26_numerics/complex/inserters_extractors/char/dr2714.cc:\n \tAdd tests using noskipws.\n "}, {"sha": "1b64cd8fbf547ddc0c0f87a33a5c3d30f8501c1d", "filename": "libstdc++-v3/include/bits/refwrap.h", "status": "modified", "additions": 110, "deletions": 132, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frefwrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frefwrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frefwrap.h?ref=00677c48777bca36afe6fcddd380d004959998a3", "patch": "@@ -44,6 +44,69 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  /**\n+   * Derives from @c unary_function or @c binary_function, or perhaps\n+   * nothing, depending on the number of arguments provided. The\n+   * primary template is the basis case, which derives nothing.\n+   */\n+  template<typename _Res, typename... _ArgTypes>\n+    struct _Maybe_unary_or_binary_function { };\n+\n+  /// Derives from @c unary_function, as appropriate.\n+  template<typename _Res, typename _T1>\n+    struct _Maybe_unary_or_binary_function<_Res, _T1>\n+    : std::unary_function<_T1, _Res> { };\n+\n+  /// Derives from @c binary_function, as appropriate.\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n+    : std::binary_function<_T1, _T2, _Res> { };\n+\n+  template<typename _Signature>\n+    struct _Mem_fn_traits;\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits_base\n+    {\n+      using __result_type = _Res;\n+      using __maybe_type\n+\t= _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;\n+      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;\n+    };\n+\n+#define _GLIBCXX_MEM_FN_TRAITS2(_CV, _REF, _LVAL, _RVAL)\t\t\\\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\t\\\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) _CV _REF>\t\\\n+    : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      using __vararg = false_type;\t\t\t\t\t\\\n+    };\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\t\\\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) _CV _REF>\t\\\n+    : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      using __vararg = true_type;\t\t\t\t\t\\\n+    };\n+\n+#define _GLIBCXX_MEM_FN_TRAITS(_REF, _LVAL, _RVAL)\t\t\\\n+  _GLIBCXX_MEM_FN_TRAITS2(\t\t, _REF, _LVAL, _RVAL)\t\\\n+  _GLIBCXX_MEM_FN_TRAITS2(const\t\t, _REF, _LVAL, _RVAL)\t\\\n+  _GLIBCXX_MEM_FN_TRAITS2(volatile\t, _REF, _LVAL, _RVAL)\t\\\n+  _GLIBCXX_MEM_FN_TRAITS2(const volatile, _REF, _LVAL, _RVAL)\n+\n+_GLIBCXX_MEM_FN_TRAITS( , true_type, true_type)\n+_GLIBCXX_MEM_FN_TRAITS(&, true_type, false_type)\n+_GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n+\n+#if __cplusplus > 201402L\n+_GLIBCXX_MEM_FN_TRAITS(noexcept, true_type, true_type)\n+_GLIBCXX_MEM_FN_TRAITS(& noexcept, true_type, false_type)\n+_GLIBCXX_MEM_FN_TRAITS(&& noexcept, false_type, true_type)\n+#endif\n+\n+#undef _GLIBCXX_MEM_FN_TRAITS\n+#undef _GLIBCXX_MEM_FN_TRAITS2\n+\n   /// If we have found a result_type, extract it.\n   template<typename _Functor, typename = __void_t<>>\n     struct _Maybe_get_result_type\n@@ -64,101 +127,52 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { };\n \n   /// Retrieve the result type for a function type.\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes......)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes...) _GLIBCXX_NOEXCEPT_QUAL>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve the result type for a function reference.\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>\n+  /// Retrieve the result type for a varargs function type.\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct _Weak_result_type_impl<_Res(_ArgTypes......) _GLIBCXX_NOEXCEPT_QUAL>\n     { typedef _Res result_type; };\n \n   /// Retrieve the result type for a function pointer.\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) _GLIBCXX_NOEXCEPT_QUAL>\n     { typedef _Res result_type; };\n \n-  /// Retrieve result type for a member function pointer.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n+  /// Retrieve the result type for a varargs function pointer.\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct\n+    _Weak_result_type_impl<_Res(*)(_ArgTypes......) _GLIBCXX_NOEXCEPT_QUAL>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve result type for a const member function pointer.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>\n-    { typedef _Res result_type; };\n-\n-  /// Retrieve result type for a volatile member function pointer.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n-    { typedef _Res result_type; };\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>\n-    { typedef _Res result_type; };\n+  // Let _Weak_result_type_impl perform the real work.\n+  template<typename _Functor,\n+\t   bool = is_member_function_pointer<_Functor>::value>\n+    struct _Weak_result_type_memfun\n+    : _Weak_result_type_impl<_Functor>\n+    { };\n \n-  /// Retrieve result type for a const volatile member function pointer.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)\n-\t\t\t\t  const volatile>\n-    { typedef _Res result_type; };\n+  // A pointer to member function has a weak result type.\n+  template<typename _MemFunPtr>\n+    struct _Weak_result_type_memfun<_MemFunPtr, true>\n+    {\n+      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;\n+    };\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)\n-\t\t\t\t  const volatile>\n-    { typedef _Res result_type; };\n+  // A pointer to data member doesn't have a weak result type.\n+  template<typename _Func, typename _Class>\n+    struct _Weak_result_type_memfun<_Func _Class::*, false>\n+    { };\n \n   /**\n    *  Strip top-level cv-qualifiers from the function object and let\n-   *  _Weak_result_type_impl perform the real work.\n+   *  _Weak_result_type_memfun perform the real work.\n   */\n   template<typename _Functor>\n     struct _Weak_result_type\n-    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n+    : _Weak_result_type_memfun<typename remove_cv<_Functor>::type>\n     { };\n \n   // Detect nested argument_type.\n@@ -201,8 +215,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { };\n \n   // - a function type (unary)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(_T1)>\n+  template<typename _Res, typename _T1 _GLIBCXX_NOEXCEPT_PARM>\n+    struct _Reference_wrapper_base<_Res(_T1) _GLIBCXX_NOEXCEPT_QUAL>\n     : unary_function<_T1, _Res>\n     { };\n \n@@ -222,8 +236,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { };\n \n   // - a function type (binary)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(_T1, _T2)>\n+  template<typename _Res, typename _T1, typename _T2 _GLIBCXX_NOEXCEPT_PARM>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2) _GLIBCXX_NOEXCEPT_QUAL>\n     : binary_function<_T1, _T2, _Res>\n     { };\n \n@@ -243,64 +257,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { };\n \n   // - a function pointer type (unary)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(*)(_T1)>\n+  template<typename _Res, typename _T1 _GLIBCXX_NOEXCEPT_PARM>\n+    struct _Reference_wrapper_base<_Res(*)(_T1) _GLIBCXX_NOEXCEPT_QUAL>\n     : unary_function<_T1, _Res>\n     { };\n \n   // - a function pointer type (binary)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n+  template<typename _Res, typename _T1, typename _T2 _GLIBCXX_NOEXCEPT_PARM>\n+    struct _Reference_wrapper_base<_Res(*)(_T1, _T2) _GLIBCXX_NOEXCEPT_QUAL>\n     : binary_function<_T1, _T2, _Res>\n     { };\n \n-  // - a pointer to member function type (unary, no qualifiers)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)()>\n-    : unary_function<_T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, no qualifiers)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n-    : binary_function<_T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, const)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() const>\n-    : unary_function<const _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, const)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n-    : binary_function<const _T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, volatile)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n-    : unary_function<volatile _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, volatile)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n-    : binary_function<volatile _T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, const volatile)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n-    : unary_function<const volatile _T1*, _Res>\n+  template<typename _Tp, bool = is_member_function_pointer<_Tp>::value>\n+    struct _Reference_wrapper_base_memfun\n+    : _Reference_wrapper_base<_Tp>\n     { };\n \n-  // - a pointer to member function type (binary, const volatile)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n-    : binary_function<const volatile _T1*, _T2, _Res>\n-    { };\n+  template<typename _MemFunPtr>\n+    struct _Reference_wrapper_base_memfun<_MemFunPtr, true>\n+    : _Mem_fn_traits<_MemFunPtr>::__maybe_type\n+    {\n+      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;\n+    };\n \n   /**\n    *  @brief Primary class template for reference_wrapper.\n@@ -309,7 +287,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   template<typename _Tp>\n     class reference_wrapper\n-    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n+    : public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type>\n     {\n       _Tp* _M_data;\n "}, {"sha": "94b7ee990679020cedfd4fd868feb387d6cbe124", "filename": "libstdc++-v3/include/bits/std_function.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h?ref=00677c48777bca36afe6fcddd380d004959998a3", "patch": "@@ -48,25 +48,6 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  /**\n-   * Derives from @c unary_function or @c binary_function, or perhaps\n-   * nothing, depending on the number of arguments provided. The\n-   * primary template is the basis case, which derives nothing.\n-   */\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Maybe_unary_or_binary_function { };\n-\n-  /// Derives from @c unary_function, as appropriate.\n-  template<typename _Res, typename _T1>\n-    struct _Maybe_unary_or_binary_function<_Res, _T1>\n-    : std::unary_function<_T1, _Res> { };\n-\n-  /// Derives from @c binary_function, as appropriate.\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n-    : std::binary_function<_T1, _T2, _Res> { };\n-\n-\n   /**\n    *  @brief Exception class thrown when class template function's\n    *  operator() is called with an empty target."}, {"sha": "f94c63b213e7f532276fb0e02c7f078bb561ce9e", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 2, "deletions": 63, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=00677c48777bca36afe6fcddd380d004959998a3", "patch": "@@ -55,7 +55,8 @@\n #include <type_traits>\n #include <bits/functional_hash.h>\n #include <bits/invoke.h>\n-#include <bits/std_function.h>\n+#include <bits/refwrap.h>\t// std::reference_wrapper and _Mem_fn_traits\n+#include <bits/std_function.h>\t// std::function\n #if __cplusplus > 201402L\n # include <unordered_map>\n # include <vector>\n@@ -82,68 +83,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n #endif\n \n-  template<typename... _Types>\n-    struct _Pack : integral_constant<size_t, sizeof...(_Types)>\n-    { };\n-\n-  template<typename _From, typename _To, bool = _From::value == _To::value>\n-    struct _AllConvertible : false_type\n-    { };\n-\n-  template<typename... _From, typename... _To>\n-    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>\n-    : __and_<is_convertible<_From, _To>...>\n-    { };\n-\n-  template<typename _Tp1, typename _Tp2>\n-    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,\n-\t\t\t\t    typename std::decay<_Tp2>::type>>;\n-\n-  template<typename _Signature>\n-    struct _Mem_fn_traits;\n-\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    struct _Mem_fn_traits_base\n-    {\n-      using __result_type = _Res;\n-      using __maybe_type\n-\t= _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;\n-      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;\n-    };\n-\n-#define _GLIBCXX_MEM_FN_TRAITS2(_CV, _REF, _LVAL, _RVAL)\t\t\\\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\t\\\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) _CV _REF>\t\\\n-    : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      using __vararg = false_type;\t\t\t\t\t\\\n-    };\t\t\t\t\t\t\t\t\t\\\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\t\\\n-    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) _CV _REF>\t\\\n-    : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      using __vararg = true_type;\t\t\t\t\t\\\n-    };\n-\n-#define _GLIBCXX_MEM_FN_TRAITS(_REF, _LVAL, _RVAL)\t\t\\\n-  _GLIBCXX_MEM_FN_TRAITS2(\t\t, _REF, _LVAL, _RVAL)\t\\\n-  _GLIBCXX_MEM_FN_TRAITS2(const\t\t, _REF, _LVAL, _RVAL)\t\\\n-  _GLIBCXX_MEM_FN_TRAITS2(volatile\t, _REF, _LVAL, _RVAL)\t\\\n-  _GLIBCXX_MEM_FN_TRAITS2(const volatile, _REF, _LVAL, _RVAL)\n-\n-_GLIBCXX_MEM_FN_TRAITS( , true_type, true_type)\n-_GLIBCXX_MEM_FN_TRAITS(&, true_type, false_type)\n-_GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n-\n-#if __cplusplus > 201402L\n-_GLIBCXX_MEM_FN_TRAITS(noexcept, true_type, true_type)\n-_GLIBCXX_MEM_FN_TRAITS(& noexcept, true_type, false_type)\n-_GLIBCXX_MEM_FN_TRAITS(&& noexcept, false_type, true_type)\n-#endif\n-\n-#undef _GLIBCXX_MEM_FN_TRAITS\n-#undef _GLIBCXX_MEM_FN_TRAITS2\n-\n   template<typename _MemFunPtr,\n \t   bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>\n     class _Mem_fn_base"}, {"sha": "e96841435f2307d941ba8c55a025ee4e00523203", "filename": "libstdc++-v3/testsuite/20_util/bind/83427.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F83427.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F83427.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F83427.cc?ref=00677c48777bca36afe6fcddd380d004959998a3", "patch": "@@ -0,0 +1,31 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <functional>\n+\n+// PR libstdc++/83427\n+\n+int f() noexcept { return 0; }\n+auto b = std::bind(f);\n+static_assert(std::is_same_v<decltype(b)::result_type, int>);\n+\n+struct X { long f() const & noexcept { return 0L; } };\n+auto b2 = std::bind(&X::f, X{});\n+static_assert(std::is_same_v<decltype(b2)::result_type, long>);"}, {"sha": "09fe6d52d37f91d33c4b8d5f00d2fda2029d36c9", "filename": "libstdc++-v3/testsuite/20_util/bind/refqual.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Frefqual.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Frefqual.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Frefqual.cc?ref=00677c48777bca36afe6fcddd380d004959998a3", "patch": "@@ -22,8 +22,8 @@\n \n struct X\n {\n-  int f() const& { return 0; }\n-  int g(int i, ...)& { return i; }\n+  int f() const& noexcept { return 0; }\n+  int g(int i, ...)& noexcept { return i; }\n };\n \n void\n@@ -34,6 +34,10 @@ test01()\n   VERIFY( b() == 0 );\n   auto bb = std::bind(&X::g, &x, 1, 2);\n   VERIFY( bb() == 1 );\n+\n+  // Check for weak result types:\n+  using T1 = decltype(b)::result_type;\n+  using T2 = decltype(bb)::result_type;\n }\n \n int"}, {"sha": "c4b360f0bb8657188573fbd7bb2afa2add80b5f6", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/83427.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F83427.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00677c48777bca36afe6fcddd380d004959998a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F83427.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F83427.cc?ref=00677c48777bca36afe6fcddd380d004959998a3", "patch": "@@ -0,0 +1,39 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <functional>\n+\n+// PR libstdc++/83427\n+\n+int f(short) noexcept { return 0; }\n+std::reference_wrapper<decltype(f)> r(f);\n+static_assert(std::is_same_v<decltype(r)::result_type, int>);\n+static_assert(std::is_same_v<decltype(r)::argument_type, short>);\n+\n+auto* p = &f;\n+std::reference_wrapper<decltype(&f)> r2(p);\n+static_assert(std::is_same_v<decltype(r2)::result_type, int>);\n+static_assert(std::is_same_v<decltype(r2)::argument_type, short>);\n+\n+struct X { long f() const & noexcept { return 0L; } };\n+auto m = &X::f;\n+std::reference_wrapper<decltype(m)> r3(m);\n+static_assert(std::is_same_v<decltype(r3)::result_type, long>);\n+static_assert(std::is_same_v<decltype(r3)::argument_type, const X*>);"}]}