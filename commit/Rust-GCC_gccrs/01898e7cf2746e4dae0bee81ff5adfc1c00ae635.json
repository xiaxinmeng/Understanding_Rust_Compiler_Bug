{"sha": "01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE4OThlN2NmMjc0NmU0ZGFlMGJlZTgxZmY1YWRmYzFjMDBhZTYzNQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-03-09T15:35:18Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-03-09T18:18:35Z"}, "message": "Separate function definitions from function pointers.\n\nFunction definitions can have substations (generics) where as function\npointers cannot. These are distinct elements and their separation is\nimportant to support wildcards (inference variables) on BareFunctionTypes.\n\nTo fix this the patch leverages the wrapper TyCtx which denotes a type that\nmust be infered.\n\nFixes #269", "tree": {"sha": "9e8518e0c4d7f08511b9a0ae448e055a63fa1870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e8518e0c4d7f08511b9a0ae448e055a63fa1870"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b35f5f10dc9d773b6cdaf60a30ce3e76d39bb35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b35f5f10dc9d773b6cdaf60a30ce3e76d39bb35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b35f5f10dc9d773b6cdaf60a30ce3e76d39bb35"}], "stats": {"total": 405, "additions": 359, "deletions": 46}, "files": [{"sha": "3f4a9ac274803a8f417306c0dd2a1312ea830543", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -315,6 +315,23 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n       ctx->get_mappings ()->lookup_location (type.get_ref ()));\n   }\n \n+  void visit (TyTy::FnPtr &type) override\n+  {\n+    Btype *result_type\n+      = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n+\n+    std::vector<Btype *> parameters;\n+    type.iterate_params ([&] (TyTy::BaseType *p) mutable -> bool {\n+      Btype *pty = TyTyResolveCompile::compile (ctx, p);\n+      parameters.push_back (pty);\n+      return true;\n+    });\n+\n+    translated = ctx->get_backend ()->function_ptr_type (\n+      result_type, parameters,\n+      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+  }\n+\n   void visit (TyTy::UnitType &) override\n   {\n     translated = ctx->get_backend ()->void_type ();"}, {"sha": "1b6651a413a5550c2c7316c4c2f46e828a507fa1", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -110,7 +110,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     // setup the params\n \n-    TyTy::BaseType *tyret = fntype->return_type ();\n+    TyTy::BaseType *tyret = fntype->get_return_type ();\n     std::vector<Bvariable *> param_vars;\n \n     size_t i = 0;\n@@ -273,7 +273,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     ctx->insert_function_decl (method.get_mappings ().get_hirid (), fndecl);\n \n     // setup the params\n-    TyTy::BaseType *tyret = fntype->return_type ();\n+    TyTy::BaseType *tyret = fntype->get_return_type ();\n     std::vector<Bvariable *> param_vars;\n \n     // insert self"}, {"sha": "527921837965e75a344c1e0820330908b6ef1d7a", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -141,7 +141,7 @@ class CompileItem : public HIRCompileBase\n \n     // setup the params\n \n-    TyTy::BaseType *tyret = fntype->return_type ();\n+    TyTy::BaseType *tyret = fntype->get_return_type ();\n     std::vector<Bvariable *> param_vars;\n \n     size_t i = 0;"}, {"sha": "815ebd516d59b0ba9805645df12577096e49a857", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -58,6 +58,8 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::FnPtr &type) override { gcc_unreachable (); }\n+\n   void visit (TyTy::UnitType &) override { translated = backend->void_type (); }\n \n   void visit (TyTy::FnType &type) override"}, {"sha": "204cce702e2f3e72ecc0a5d750145cb4c78b75c8", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -62,7 +62,9 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     }\n \n   // must be a tuple constructor\n-  if (tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n+  if (!is_fn)\n     {\n       Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n "}, {"sha": "3edb455b96c726ec9efbdc3f7de0c5fc328ba0b2", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -155,6 +155,11 @@ class Backend\n \t\t Btype *result_struct, Location location)\n     = 0;\n \n+  virtual Btype *function_ptr_type (Btype *result,\n+\t\t\t\t    const std::vector<Btype *> &praameters,\n+\t\t\t\t    Location location)\n+    = 0;\n+\n   // Get a struct type.\n   virtual Btype *struct_type (const std::vector<Btyped_identifier> &fields) = 0;\n "}, {"sha": "cf800c7e13bc334e25aeec0fa03f9fb79d4729d5", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -206,6 +206,8 @@ class Gcc_backend : public Backend\n \t\t\tconst std::vector<Btyped_identifier> &, Btype *,\n \t\t\tconst Location);\n \n+  Btype *function_ptr_type (Btype *, const std::vector<Btype *> &, Location);\n+\n   Btype *struct_type (const std::vector<Btyped_identifier> &);\n \n   Btype *array_type (Btype *, Bexpression *);\n@@ -990,6 +992,37 @@ Gcc_backend::function_type (const Btyped_identifier &receiver,\n   return this->make_type (build_pointer_type (fntype));\n }\n \n+Btype *\n+Gcc_backend::function_ptr_type (Btype *result_type,\n+\t\t\t\tconst std::vector<Btype *> &parameters,\n+\t\t\t\tLocation locus)\n+{\n+  tree args = NULL_TREE;\n+  tree *pp = &args;\n+\n+  for (auto &param : parameters)\n+    {\n+      tree t = param->get_tree ();\n+      if (t == error_mark_node)\n+\treturn this->error_type ();\n+\n+      *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n+      pp = &TREE_CHAIN (*pp);\n+    }\n+\n+  *pp = void_list_node;\n+\n+  tree result = result_type->get_tree ();\n+  if (result != void_type_node && int_size_in_bytes (result) == 0)\n+    result = void_type_node;\n+\n+  tree fntype = build_function_type (result, args);\n+  if (fntype == error_mark_node)\n+    return this->error_type ();\n+\n+  return this->make_type (build_pointer_type (fntype));\n+}\n+\n // Make a struct type.\n \n Btype *"}, {"sha": "d9e8d8b12a0f29b71c9ada49722e81e6b3cbf96d", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -169,7 +169,8 @@ class TypeCheckExpr : public TypeCheckBase\n       return;\n \n     bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n-\t\t      || function_tyty->get_kind () == TyTy::TypeKind::FNDEF;\n+\t\t      || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t      || function_tyty->get_kind () == TyTy::TypeKind::FNPTR;\n     if (!valid_tyty)\n       {\n \trust_error_at (expr.get_locus (),"}, {"sha": "03540557a381ab4947918affb70ee108fd7b2b8a", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -170,7 +170,7 @@ class TypeCheckImplItem : public TypeCheckBase\n \n     // need to get the return type from this\n     TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n-    auto expected_ret_tyty = resolve_fn_type->return_type ();\n+    auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n     auto result = TypeCheckExpr::Resolve (function.function_body.get (), false);\n@@ -202,7 +202,7 @@ class TypeCheckImplItem : public TypeCheckBase\n \n     // need to get the return type from this\n     TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n-    auto expected_ret_tyty = resolve_fn_type->return_type ();\n+    auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n     auto result"}, {"sha": "54fc3df5182a0c135cb43be27ff79e2158652d3e", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -72,7 +72,7 @@ class TypeCheckItem : public TypeCheckBase\n \n     // need to get the return type from this\n     TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n-    auto expected_ret_tyty = resolve_fn_type->return_type ();\n+    auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n     auto result = TypeCheckExpr::Resolve (function.function_body.get (), false);"}, {"sha": "0d7d07b6a001c918b2f9e78c268f06a72a7c993a", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -107,26 +107,17 @@ class TypeCheckType : public TypeCheckBase\n \t  ? TypeCheckType::Resolve (fntype.get_return_type ().get ())\n \t  : new TyTy::UnitType (fntype.get_mappings ().get_hirid ());\n \n-    std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+    std::vector<TyTy::TyCtx> params;\n     for (auto &param : fntype.get_function_params ())\n       {\n-\tstd::unique_ptr<HIR::Pattern> to_bind;\n-\n-\tbool is_ref = false;\n-\tbool is_mut = false;\n-\n-\tHIR::Pattern *pattern\n-\t  = new HIR::IdentifierPattern (param.get_name (), param.get_locus (),\n-\t\t\t\t\tis_ref, is_mut, std::move (to_bind));\n-\n \tTyTy::BaseType *ptype\n \t  = TypeCheckType::Resolve (param.get_type ().get ());\n-\tparams.push_back (\n-\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (pattern, ptype));\n+\tparams.push_back (TyTy::TyCtx (ptype->get_ref ()));\n       }\n \n-    translated = new TyTy::FnType (fntype.get_mappings ().get_hirid (),\n-\t\t\t\t   std::move (params), return_type);\n+    translated = new TyTy::FnPtr (fntype.get_mappings ().get_hirid (),\n+\t\t\t\t  std::move (params),\n+\t\t\t\t  TyTy::TyCtx (return_type->get_ref ()));\n   }\n \n   void visit (HIR::TupleType &tuple)"}, {"sha": "eac98686b53a6b869e4d0eb1a86802e17358ca2e", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -60,6 +60,7 @@ class TypeCheckCallExpr : private TyVisitor\n \n   // call fns\n   void visit (FnType &type) override;\n+  void visit (FnPtr &type) override;\n \n private:\n   TypeCheckCallExpr (HIR::CallExpr &c, Resolver::TypeCheckContext *context)\n@@ -101,6 +102,9 @@ class TypeCheckMethodCallExpr : private TyVisitor\n   void visit (ParamType &) override { gcc_unreachable (); }\n   void visit (StrType &) override { gcc_unreachable (); }\n \n+  // FIXME\n+  void visit (FnPtr &type) override { gcc_unreachable (); }\n+\n   // call fns\n   void visit (FnType &type) override;\n "}, {"sha": "4e48114f50c4f3d82787cc31174852dcc117750f", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -148,6 +148,14 @@ class BaseRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n+  virtual void visit (FnPtr &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n   virtual void visit (ArrayType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n@@ -526,7 +534,6 @@ class FnRules : public BaseRules\n \treturn;\n       }\n \n-    // FIXME add an abstract method for is_equal on BaseType\n     for (size_t i = 0; i < base->num_params (); i++)\n       {\n \tauto a = base->param_at (i).second;\n@@ -558,6 +565,99 @@ class FnRules : public BaseRules\n   FnType *base;\n };\n \n+class FnptrRules : public BaseRules\n+{\n+public:\n+  FnptrRules (FnPtr *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnPtr &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i);\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i).second;\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnPtr *base;\n+};\n+\n class ArrayRules : public BaseRules\n {\n public:"}, {"sha": "8ab7fffb2fa5c7d82b61514fa797be4293b14503", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -32,6 +32,7 @@ class TyVisitor\n   virtual void visit (ADTType &type) = 0;\n   virtual void visit (TupleType &type) = 0;\n   virtual void visit (FnType &type) = 0;\n+  virtual void visit (FnPtr &type) = 0;\n   virtual void visit (ArrayType &type) = 0;\n   virtual void visit (BoolType &type) = 0;\n   virtual void visit (IntType &type) = 0;"}, {"sha": "e7b221650868fca331f28de81c10f61d1a93d8de", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 120, "deletions": 17, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -401,25 +401,23 @@ bool\n FnType::is_equal (const BaseType &other) const\n {\n   if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const FnType &> (other);\n+  if (!get_return_type ()->is_equal (*other2.get_return_type ()))\n+    return false;\n+\n+  if (num_params () != other2.num_params ())\n+    return false;\n+\n+  for (size_t i = 0; i < num_params (); i++)\n     {\n-      return false;\n-    }\n-  else\n-    {\n-      auto other2 = static_cast<const FnType &> (other);\n-      if (!get_return_type ()->is_equal (*other2.get_return_type ()))\n+      auto lhs = param_at (i).second;\n+      auto rhs = other2.param_at (i).second;\n+      if (!lhs->is_equal (*rhs))\n \treturn false;\n-      if (num_params () != other2.num_params ())\n-\treturn false;\n-      for (size_t i = 0; i < num_params (); i++)\n-\t{\n-\t  auto lhs = param_at (i).second;\n-\t  auto rhs = other2.param_at (i).second;\n-\t  if (!lhs->is_equal (*rhs))\n-\t    return false;\n-\t}\n-      return true;\n     }\n+  return true;\n }\n \n BaseType *\n@@ -430,10 +428,68 @@ FnType::clone ()\n     cloned_params.push_back (\n       std::pair<HIR::Pattern *, BaseType *> (p.first, p.second->clone ()));\n \n-  return new FnType (get_ref (), get_ty_ref (), cloned_params,\n+  return new FnType (get_ref (), get_ty_ref (), std::move (cloned_params),\n \t\t     get_return_type ()->clone (), get_combined_refs ());\n }\n \n+void\n+FnPtr::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+FnPtr::as_string () const\n+{\n+  std::string params_str;\n+  iterate_params ([&] (BaseType *p) mutable -> bool {\n+    params_str += p->as_string () + \" ,\";\n+    return true;\n+  });\n+  return \"fnptr (\" + params_str + \") -> \" + get_return_type ()->as_string ();\n+}\n+\n+BaseType *\n+FnPtr::unify (BaseType *other)\n+{\n+  FnptrRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+FnPtr::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const FnPtr &> (other);\n+  auto this_ret_type = get_return_type ();\n+  auto other_ret_type = other2.get_return_type ();\n+  if (this_ret_type->is_equal (*other_ret_type))\n+    return false;\n+\n+  if (num_params () != other2.num_params ())\n+    return false;\n+\n+  for (size_t i = 0; i < num_params (); i++)\n+    {\n+      if (!param_at (i)->is_equal (*other2.param_at (i)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+BaseType *\n+FnPtr::clone ()\n+{\n+  std::vector<TyCtx> cloned_params;\n+  for (auto &p : params)\n+    cloned_params.push_back (TyCtx (p.get_ref ()));\n+\n+  return new FnPtr (get_ref (), get_ty_ref (), std::move (cloned_params),\n+\t\t    result_type, get_combined_refs ());\n+}\n+\n void\n ArrayType::accept_vis (TyVisitor &vis)\n {\n@@ -922,6 +978,53 @@ TypeCheckCallExpr::visit (FnType &type)\n   resolved = type.get_return_type ()->clone ();\n }\n \n+void\n+TypeCheckCallExpr::visit (FnPtr &type)\n+{\n+  if (call.num_params () != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     call.num_params (), type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n+    auto fnparam = type.param_at (i);\n+    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n+    if (argument_expr_tyty == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"failed to resolve type for argument expr in CallExpr\");\n+\treturn false;\n+      }\n+\n+    auto resolved_argument_type = fnparam->unify (argument_expr_tyty);\n+    if (resolved_argument_type == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"Type Resolution failure on parameter\");\n+\treturn false;\n+      }\n+\n+    context->insert_type (param->get_mappings (), resolved_argument_type);\n+\n+    i++;\n+    return true;\n+  });\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\", i,\n+\t\t     call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.get_return_type ()->clone ();\n+}\n+\n // method call checker\n \n void"}, {"sha": "3f22955c70ca4090314dee05162e763c59dd0c32", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -35,6 +35,7 @@ enum TypeKind\n   PARAM,\n   ARRAY,\n   FNDEF,\n+  FNPTR,\n   TUPLE,\n   BOOL,\n   CHAR,\n@@ -261,7 +262,7 @@ class TupleType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n-  virtual bool is_equal (const BaseType &other) const override;\n+  bool is_equal (const BaseType &other) const override;\n \n   size_t num_fields () const { return fields.size (); }\n \n@@ -433,7 +434,7 @@ class ADTType : public BaseType, public SubstitionRef<ADTType>\n \n   BaseType *unify (BaseType *other) override;\n \n-  virtual bool is_equal (const BaseType &other) const override;\n+  bool is_equal (const BaseType &other) const override;\n \n   size_t num_fields () const { return fields.size (); }\n \n@@ -524,11 +525,9 @@ class FnType : public BaseType\n \n   std::string get_name () const override final { return as_string (); }\n \n-  BaseType *return_type () { return type; }\n-\n   BaseType *unify (BaseType *other) override;\n \n-  virtual bool is_equal (const BaseType &other) const override;\n+  bool is_equal (const BaseType &other) const override;\n \n   size_t num_params () const { return params.size (); }\n \n@@ -561,6 +560,53 @@ class FnType : public BaseType\n   BaseType *type;\n };\n \n+class FnPtr : public BaseType\n+{\n+public:\n+  FnPtr (HirId ref, std::vector<TyCtx> params, TyCtx result_type,\n+\t std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::FNPTR, refs), params (std::move (params)),\n+      result_type (result_type)\n+  {}\n+\n+  FnPtr (HirId ref, HirId ty_ref, std::vector<TyCtx> params, TyCtx result_type,\n+\t std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::FNPTR, refs), params (params),\n+      result_type (result_type)\n+  {}\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *get_return_type () const { return result_type.get_tyty (); }\n+\n+  size_t num_params () const { return params.size (); }\n+\n+  BaseType *param_at (size_t idx) const { return params.at (idx).get_tyty (); }\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () final override;\n+\n+  void iterate_params (std::function<bool (BaseType *)> cb) const\n+  {\n+    for (auto &p : params)\n+      {\n+\tif (!cb (p.get_tyty ()))\n+\t  return;\n+      }\n+  }\n+\n+private:\n+  std::vector<TyCtx> params;\n+  TyCtx result_type;\n+};\n+\n class ArrayType : public BaseType\n {\n public:\n@@ -584,7 +630,7 @@ class ArrayType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n-  virtual bool is_equal (const BaseType &other) const override;\n+  bool is_equal (const BaseType &other) const override;\n \n   size_t get_capacity () const { return capacity; }\n "}, {"sha": "a27f0e49d6c9e84aaecf9253581a0220192b1c67", "filename": "gcc/testsuite/rust.test/compilable/function_reference4.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01898e7cf2746e4dae0bee81ff5adfc1c00ae635/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference4.rs?ref=01898e7cf2746e4dae0bee81ff5adfc1c00ae635", "patch": "@@ -0,0 +1,8 @@\n+fn test(a: i32) -> i32 {\n+    a + 1\n+}\n+\n+fn main() {\n+    let a: fn(_) -> _ = test;\n+    let b = a(1);\n+}"}]}