{"sha": "21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFkZmM2ZGM3NGFiMjFmZTZkNWRjNDg3YzIwY2IxMjFjYWNjNzUyOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-06-09T20:45:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-06-09T20:45:56Z"}, "message": "md.texi: Synchronize with later constraints.md change.\n\ngcc/\n\t* doc/md.texi: Synchronize with later constraints.md change.\n\t* longlong.h (umul_ppmm): Replace the MIPS asm implementation\n\twith a C implementation.\n\t* config/mips/mips.c (mips_legitimize_move): Remove MFHI and\n\tMFLO handling.\n\t(mips_subword): Assume TImode for CONST_INTs if TARGET_64BIT.\n\t(mips_split_doubleword_move): Use special MTHI and MFHI instructions\n\twhen moving to and from MD_REGNUM.\n\t(mips_output_move): Don't handle moves from GPRs to HI_REGNUM.\n\tHandle moves from LO_REGNUM to GPRs using MFLO, MACC or DMACC.\n\tHandle byte and halfword moves.\n\t(mips_hard_regno_mode_ok_p): Handle MD_REGS and DSP_ACC_REGS\n\tseparately.\n\t* config/mips/constraints.md (h): Turn into NO_REGS.\n\t(l, x): Update documentation.\n\t* config/mips/mips.md (UNSPEC_MFHILO): Delete.\n\t(UNSPEC_MFHI, UNSPEC_MTHI, UNSPEC_SET_HILO): New.\n\t(UNSPEC_TLS_LDM, UNSPEC_TLS_GET_TP): Renumber.\n\t(HILO): New mode iterator.\n\t(MOVE128): Add TI.\n\t(any_div): New code iterator.\n\t(u): Extend code attribute to div and udiv.\n\t(*add<mode>3_mips16, *movdi_64bit_mips16, *movsi_mips16): Use\n\td_operand in the splitters.  Remove redundant CONST_INT checks.\n\t(mulsi3_mult3, mul<mode>3_internal, mul<mode>3_r4000, *mul_acc_si)\n\t(*macc, *msac, *msac_using_macc, *macc2, *msac2, *mul_sub_si)\n\t(*muls): Remove \"=h\" clobbers.  Adjust peephole2s and define_splits\n\taccordingly, using normal moves instead of unspecs to move LO into\n\ta GPR.  Use d_operand and lo_operand instead of *_REG_P checks.\n\t(<u>mulsidi3): Handle expansion in C code.\n\t(<u>mulsidi3_32bit_internal): Rename to...\n\t(<u>mulsidi3_32bit): ...this.\n\t(<u>mulsidi3_32bit_r4000): Fix insn separator.\n\t(*<u>mulsidi3_64bit): Rename to...\n\t(<u>mulsidi3_64bit): ...this.  Combine DImode \"=h\" and \"=l\" clobbers\n\tinto a TImode \"=x\" clobber.  In the split, use an UNSPEC_SET_HILO\n\tto set LO and HI to the multiplication result.  Use a normal move\n\tfor MFLO and an unspec for MFHI.\n\t(*<u>mulsidi3_64bit_parts): Replace with...\n\t(<u>mulsidi3_64bit_hilo): ...this new instruction.\n\t(<su>mulsi3_highpart): Extend to TARGET_FIX_R4000.\n\t(<su>mulsi3_highpart_internal): Turn into a define_insn_and_split\n\tand extend it to TARGET_FIX_R4000.  Store the destination in a GPR\n\tinstead of HI.  Split the instruction into a separate multiplication\n\tand MFHI if !TARGET_FIX_R4000.\n\t(<su>muldi3_highpart): Likewise.\n\t(<su>mulsi3_highpart_mulhi_internal): Remove the first alternative\n\tand the \"=h\" clobber.\n\t(*<su>mulsi3_highpart_neg_mulhi_internal): Likewise.\n\t(<u>mulditi3): New expander.\n\t(<u>mulditi3_internal, <u>mulditi3_r4000): New patterns.\n\t(madsi): Remove \"=h\" clobber.\n\t(divmod<mode>4, udivmod<mode>4): Turn into define_insn_and_splits.\n\tForce the modulus result to be a GPR and split the instruction into\n\ta division followed by an MFHI after reload.\n\t(<u>divmod<GPR:mode>4_hilo_<HILO:mode>): New instruction.\n\t(*lea_high64): Use d_operand in the define_peephole2.  Likewise\n\tthe MIPS16 HIGH define_split.\n\t(*movdi_32bit, *movdi_gp32_fp64, *movdi_32bit_mips16): Change type\n\tof acc<->gpr moves to \"multi\".\n\t(*movdi_64bit): Replace the single \"x\" alternative with\n\talternatives for moving into and out of \"a\".\n\t(*movhi_internal, *movqi_internal): Likewise.  Use mips_output_move.\n\t(*movsi_internal): Extend the \"d<-A\" alternative to \"d<-a\".\n\t(*movdi_64bit_mips16, *movsi_mips16): Add d<-a alternatives.\n\tUse d_operand in the splitters.  Remove redundant CONST_INT checks.\n\t(*movhi_mips16, *movqi_mips16): Likewise.  Use mips_output_move.\n\t(movti): New expander.\n\t(*movti, *movti_mips16): New insns.\n\t(mfhilo_<mode>, *mfhilo_<mode>, *mfhilo_<mode>_macc): Delete.\n\t(mfhi<GPR:mode>_<HILO:mode>): New pattern.\n\t(mthi<GPR:mode>_<HILO:mode>): Likewise.\n\t* config/mips/predicates.md (fpr_operand): Delete.\n\t(d_operand): New predicate.\n\ngcc/testsuite/\n\t* gcc.dg/torture/mips-hilo-1.c: Delete.\n\t* gcc.target/mips/pr35232.c: Likewise.\n\t* gcc.target/mips/fix-vr4130-1.c: Use modulus to create an mfhi.\n\t* gcc.target/mips/fix-vr4130-3.c: Likewise.\n\t* gcc.target/mips/int-moves-1.c: New test.\n\t* gcc.target/mips/int-moves-2.c: Likewise.\n\t* gcc.target/mips/fix-r4000-1.c: Likewise.\n\t* gcc.target/mips/fix-r4000-2.c: Likewise.\n\t* gcc.target/mips/fix-r4000-3.c: Likewise.\n\t* gcc.target/mips/fix-r4000-4.c: Likewise.\n\t* gcc.target/mips/fix-r4000-5.c: Likewise.\n\t* gcc.target/mips/fix-r4000-6.c: Likewise.\n\t* gcc.target/mips/fix-r4000-7.c: Likewise.\n\t* gcc.target/mips/fix-r4000-8.c: Likewise.\n\t* gcc.target/mips/fix-r4000-9.c: Likewise.\n\t* gcc.target/mips/fix-r4000-10.c: Likewise.\n\t* gcc.target/mips/fix-r4000-11.c: Likewise.\n\t* gcc.target/mips/fix-r4000-12.c: Likewise.\n\t* gcc.target/mips/timode-1.c: Likewise.\n\t* gcc.target/mips/timode-2.c: Likewise.\n\nFrom-SVN: r136600", "tree": {"sha": "f6314c47b12d23fdd1338cdea0f0437befdc3b11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6314c47b12d23fdd1338cdea0f0437befdc3b11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e462a951b6de1354da41ecac9ee796e256a9fa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e462a951b6de1354da41ecac9ee796e256a9fa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e462a951b6de1354da41ecac9ee796e256a9fa5"}], "stats": {"total": 1460, "additions": 917, "deletions": 543}, "files": [{"sha": "f3fbaa29f93e58002b70efb8ba9bf1be27445e6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -1,3 +1,80 @@\n+2008-06-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* doc/md.texi: Synchronize with later constraints.md change.\n+\t* longlong.h (umul_ppmm): Replace the MIPS asm implementation\n+\twith a C implementation.\n+\t* config/mips/mips.c (mips_legitimize_move): Remove MFHI and\n+\tMFLO handling.\n+\t(mips_subword): Assume TImode for CONST_INTs if TARGET_64BIT.\n+\t(mips_split_doubleword_move): Use special MTHI and MFHI instructions\n+\twhen moving to and from MD_REGNUM.\n+\t(mips_output_move): Don't handle moves from GPRs to HI_REGNUM.\n+\tHandle moves from LO_REGNUM to GPRs using MFLO, MACC or DMACC.\n+\tHandle byte and halfword moves.\n+\t(mips_hard_regno_mode_ok_p): Handle MD_REGS and DSP_ACC_REGS\n+\tseparately.\n+\t* config/mips/constraints.md (h): Turn into NO_REGS.\n+\t(l, x): Update documentation.\n+\t* config/mips/mips.md (UNSPEC_MFHILO): Delete.\n+\t(UNSPEC_MFHI, UNSPEC_MTHI, UNSPEC_SET_HILO): New.\n+\t(UNSPEC_TLS_LDM, UNSPEC_TLS_GET_TP): Renumber.\n+\t(HILO): New mode iterator.\n+\t(MOVE128): Add TI.\n+\t(any_div): New code iterator.\n+\t(u): Extend code attribute to div and udiv.\n+\t(*add<mode>3_mips16, *movdi_64bit_mips16, *movsi_mips16): Use\n+\td_operand in the splitters.  Remove redundant CONST_INT checks.\n+\t(mulsi3_mult3, mul<mode>3_internal, mul<mode>3_r4000, *mul_acc_si)\n+\t(*macc, *msac, *msac_using_macc, *macc2, *msac2, *mul_sub_si)\n+\t(*muls): Remove \"=h\" clobbers.  Adjust peephole2s and define_splits\n+\taccordingly, using normal moves instead of unspecs to move LO into\n+\ta GPR.  Use d_operand and lo_operand instead of *_REG_P checks.\n+\t(<u>mulsidi3): Handle expansion in C code.\n+\t(<u>mulsidi3_32bit_internal): Rename to...\n+\t(<u>mulsidi3_32bit): ...this.\n+\t(<u>mulsidi3_32bit_r4000): Fix insn separator.\n+\t(*<u>mulsidi3_64bit): Rename to...\n+\t(<u>mulsidi3_64bit): ...this.  Combine DImode \"=h\" and \"=l\" clobbers\n+\tinto a TImode \"=x\" clobber.  In the split, use an UNSPEC_SET_HILO\n+\tto set LO and HI to the multiplication result.  Use a normal move\n+\tfor MFLO and an unspec for MFHI.\n+\t(*<u>mulsidi3_64bit_parts): Replace with...\n+\t(<u>mulsidi3_64bit_hilo): ...this new instruction.\n+\t(<su>mulsi3_highpart): Extend to TARGET_FIX_R4000.\n+\t(<su>mulsi3_highpart_internal): Turn into a define_insn_and_split\n+\tand extend it to TARGET_FIX_R4000.  Store the destination in a GPR\n+\tinstead of HI.  Split the instruction into a separate multiplication\n+\tand MFHI if !TARGET_FIX_R4000.\n+\t(<su>muldi3_highpart): Likewise.\n+\t(<su>mulsi3_highpart_mulhi_internal): Remove the first alternative\n+\tand the \"=h\" clobber.\n+\t(*<su>mulsi3_highpart_neg_mulhi_internal): Likewise.\n+\t(<u>mulditi3): New expander.\n+\t(<u>mulditi3_internal, <u>mulditi3_r4000): New patterns.\n+\t(madsi): Remove \"=h\" clobber.\n+\t(divmod<mode>4, udivmod<mode>4): Turn into define_insn_and_splits.\n+\tForce the modulus result to be a GPR and split the instruction into\n+\ta division followed by an MFHI after reload.\n+\t(<u>divmod<GPR:mode>4_hilo_<HILO:mode>): New instruction.\n+\t(*lea_high64): Use d_operand in the define_peephole2.  Likewise\n+\tthe MIPS16 HIGH define_split.\n+\t(*movdi_32bit, *movdi_gp32_fp64, *movdi_32bit_mips16): Change type\n+\tof acc<->gpr moves to \"multi\".\n+\t(*movdi_64bit): Replace the single \"x\" alternative with\n+\talternatives for moving into and out of \"a\".\n+\t(*movhi_internal, *movqi_internal): Likewise.  Use mips_output_move.\n+\t(*movsi_internal): Extend the \"d<-A\" alternative to \"d<-a\".\n+\t(*movdi_64bit_mips16, *movsi_mips16): Add d<-a alternatives.\n+\tUse d_operand in the splitters.  Remove redundant CONST_INT checks.\n+\t(*movhi_mips16, *movqi_mips16): Likewise.  Use mips_output_move.\n+\t(movti): New expander.\n+\t(*movti, *movti_mips16): New insns.\n+\t(mfhilo_<mode>, *mfhilo_<mode>, *mfhilo_<mode>_macc): Delete.\n+\t(mfhi<GPR:mode>_<HILO:mode>): New pattern.\n+\t(mthi<GPR:mode>_<HILO:mode>): Likewise.\n+\t* config/mips/predicates.md (fpr_operand): Delete.\n+\t(d_operand): New predicate.\n+\n 2008-06-09  Michael Meissner  <michael.meissner@amd.com>\n \n \t* config.gcc (i[34567]86-*-*): Put test in quotes to prevent"}, {"sha": "a387489f204c45da22a8e9ab902534e072b5648c", "filename": "gcc/config/mips/constraints.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fconfig%2Fmips%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fconfig%2Fmips%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fconstraints.md?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -29,14 +29,16 @@\n (define_register_constraint \"f\" \"TARGET_HARD_FLOAT ? FP_REGS : NO_REGS\"\n   \"A floating-point register (if available).\")\n \n-(define_register_constraint \"h\" \"TARGET_BIG_ENDIAN ? MD0_REG : MD1_REG\"\n-  \"The @code{hi} register.\")\n+(define_register_constraint \"h\" \"NO_REGS\"\n+  \"Formerly the @code{hi} register.  This constraint is no longer supported.\")\n \n (define_register_constraint \"l\" \"TARGET_BIG_ENDIAN ? MD1_REG : MD0_REG\"\n-  \"The @code{lo} register.\")\n+  \"The @code{lo} register.  Use this register to store values that are\n+   no bigger than a word.\")\n \n (define_register_constraint \"x\" \"MD_REGS\"\n-  \"The @code{hi} and @code{lo} registers.\")\n+  \"The concatenated @code{hi} and @code{lo} registers.  Use this register\n+   to store doubleword values.\")\n \n (define_register_constraint \"b\" \"ALL_REGS\"\n   \"@internal\")"}, {"sha": "eddb5a85389a33d614d01846b2a6f991ceb05028", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 71, "deletions": 32, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -2675,23 +2675,6 @@ mips_legitimize_move (enum machine_mode mode, rtx dest, rtx src)\n       return true;\n     }\n \n-  /* Check for individual, fully-reloaded mflo and mfhi instructions.  */\n-  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n-      && REG_P (src) && MD_REG_P (REGNO (src))\n-      && REG_P (dest) && GP_REG_P (REGNO (dest)))\n-    {\n-      int other_regno = REGNO (src) == HI_REGNUM ? LO_REGNUM : HI_REGNUM;\n-      if (GET_MODE_SIZE (mode) <= 4)\n-\temit_insn (gen_mfhilo_si (gen_lowpart (SImode, dest),\n-\t\t\t\t  gen_lowpart (SImode, src),\n-\t\t\t\t  gen_rtx_REG (SImode, other_regno)));\n-      else\n-\temit_insn (gen_mfhilo_di (gen_lowpart (DImode, dest),\n-\t\t\t\t  gen_lowpart (DImode, src),\n-\t\t\t\t  gen_rtx_REG (DImode, other_regno)));\n-      return true;\n-    }\n-\n   /* We need to deal with constants that would be legitimate\n      immediate_operands but aren't legitimate move_operands.  */\n   if (CONSTANT_P (src) && !move_operand (src, mode))\n@@ -3488,7 +3471,7 @@ mips_subword (rtx op, bool high_p)\n \n   mode = GET_MODE (op);\n   if (mode == VOIDmode)\n-    mode = DImode;\n+    mode = TARGET_64BIT ? TImode : DImode;\n \n   if (TARGET_BIG_ENDIAN ? !high_p : high_p)\n     byte = UNITS_PER_WORD;\n@@ -3539,6 +3522,8 @@ mips_split_64bit_move_p (rtx dest, rtx src)\n void\n mips_split_doubleword_move (rtx dest, rtx src)\n {\n+  rtx low_dest;\n+\n   if (FP_REG_RTX_P (dest) || FP_REG_RTX_P (src))\n     {\n       if (!TARGET_64BIT && GET_MODE (dest) == DImode)\n@@ -3552,12 +3537,27 @@ mips_split_doubleword_move (rtx dest, rtx src)\n       else\n \tgcc_unreachable ();\n     }\n+  else if (REG_P (dest) && REGNO (dest) == MD_REG_FIRST)\n+    {\n+      low_dest = mips_subword (dest, false);\n+      mips_emit_move (low_dest, mips_subword (src, false));\n+      if (TARGET_64BIT)\n+\temit_insn (gen_mthidi_ti (dest, mips_subword (src, true), low_dest));\n+      else\n+\temit_insn (gen_mthisi_di (dest, mips_subword (src, true), low_dest));\n+    }\n+  else if (REG_P (src) && REGNO (src) == MD_REG_FIRST)\n+    {\n+      mips_emit_move (mips_subword (dest, false), mips_subword (src, false));\n+      if (TARGET_64BIT)\n+\temit_insn (gen_mfhidi_ti (mips_subword (dest, true), src));\n+      else\n+\temit_insn (gen_mfhisi_di (mips_subword (dest, true), src));\n+    }\n   else\n     {\n       /* The operation can be split into two normal moves.  Decide in\n \t which order to do them.  */\n-      rtx low_dest;\n-\n       low_dest = mips_subword (dest, false);\n       if (REG_P (low_dest)\n \t  && reg_overlap_mentioned_p (low_dest, src))\n@@ -3600,8 +3600,9 @@ mips_output_move (rtx dest, rtx src)\n \t  if (GP_REG_P (REGNO (dest)))\n \t    return \"move\\t%0,%z1\";\n \n-\t  if (MD_REG_P (REGNO (dest)))\n-\t    return \"mt%0\\t%z1\";\n+\t  /* Moves to HI are handled by special .md insns.  */\n+\t  if (REGNO (dest) == LO_REGNUM)\n+\t    return \"mtlo\\t%z1\";\n \n \t  if (DSP_ACC_REG_P (REGNO (dest)))\n \t    {\n@@ -3624,14 +3625,29 @@ mips_output_move (rtx dest, rtx src)\n \t    }\n \t}\n       if (dest_code == MEM)\n-\treturn dbl_p ? \"sd\\t%z1,%0\" : \"sw\\t%z1,%0\";\n+\tswitch (GET_MODE_SIZE (mode))\n+\t  {\n+\t  case 1: return \"sb\\t%z1,%0\";\n+\t  case 2: return \"sh\\t%z1,%0\";\n+\t  case 4: return \"sw\\t%z1,%0\";\n+\t  case 8: return \"sd\\t%z1,%0\";\n+\t  }\n     }\n   if (dest_code == REG && GP_REG_P (REGNO (dest)))\n     {\n       if (src_code == REG)\n \t{\n-\t  /* Handled by separate patterns.  */\n-\t  gcc_assert (!MD_REG_P (REGNO (src)));\n+\t  /* Moves from HI are handled by special .md insns.  */\n+\t  if (REGNO (src) == LO_REGNUM)\n+\t    {\n+\t      /* When generating VR4120 or VR4130 code, we use MACC and\n+\t\t DMACC instead of MFLO.  This avoids both the normal\n+\t\t MIPS III HI/LO hazards and the errata related to\n+\t\t -mfix-vr4130.  */\n+\t      if (ISA_HAS_MACCHI)\n+\t\treturn dbl_p ? \"dmacc\\t%0,%.,%.\" : \"macc\\t%0,%.,%.\";\n+\t      return \"mflo\\t%0\";\n+\t    }\n \n \t  if (DSP_ACC_REG_P (REGNO (src)))\n \t    {\n@@ -3658,7 +3674,13 @@ mips_output_move (rtx dest, rtx src)\n \t}\n \n       if (src_code == MEM)\n-\treturn dbl_p ? \"ld\\t%0,%1\" : \"lw\\t%0,%1\";\n+\tswitch (GET_MODE_SIZE (mode))\n+\t  {\n+\t  case 1: return \"lbu\\t%0,%1\";\n+\t  case 2: return \"lhu\\t%0,%1\";\n+\t  case 4: return \"lw\\t%0,%1\";\n+\t  case 8: return \"ld\\t%0,%1\";\n+\t  }\n \n       if (src_code == CONST_INT)\n \t{\n@@ -8954,13 +8976,30 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n   if (ACC_REG_P (regno)\n       && (INTEGRAL_MODE_P (mode) || ALL_FIXED_POINT_MODE_P (mode)))\n     {\n-      if (size <= UNITS_PER_WORD)\n-\treturn true;\n+      if (MD_REG_P (regno))\n+\t{\n+\t  /* After a multiplication or division, clobbering HI makes\n+\t     the value of LO unpredictable, and vice versa.  This means\n+\t     that, for all interesting cases, HI and LO are effectively\n+\t     a single register.\n+\n+\t     We model this by requiring that any value that uses HI\n+\t     also uses LO.  */\n+\t  if (size <= UNITS_PER_WORD * 2)\n+\t    return regno == (size <= UNITS_PER_WORD ? LO_REGNUM : MD_REG_FIRST);\n+\t}\n+      else\n+\t{\n+\t  /* DSP accumulators do not have the same restrictions as\n+\t     HI and LO, so we can treat them as normal doubleword\n+\t     registers.  */\n+\t  if (size <= UNITS_PER_WORD)\n+\t    return true;\n \n-      if (size <= UNITS_PER_WORD * 2)\n-\treturn (DSP_ACC_REG_P (regno)\n-\t\t? ((regno - DSP_ACC_REG_FIRST) & 1) == 0\n-\t\t: regno == MD_REG_FIRST);\n+\t  if (size <= UNITS_PER_WORD * 2\n+\t      && ((regno - DSP_ACC_REG_FIRST) & 1) == 0)\n+\t    return true;\n+\t}\n     }\n \n   if (ALL_COP_REG_P (regno))"}, {"sha": "47441cd1c1e41826204c6cf7565c4564e567f23e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 428, "deletions": 400, "changes": 828, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -44,9 +44,11 @@\n    (UNSPEC_LOAD_CALL\t\t23)\n    (UNSPEC_LOAD_GOT\t\t24)\n    (UNSPEC_GP\t\t\t25)\n-   (UNSPEC_MFHILO\t\t26)\n-   (UNSPEC_TLS_LDM\t\t27)\n-   (UNSPEC_TLS_GET_TP\t\t28)\n+   (UNSPEC_MFHI\t\t\t26)\n+   (UNSPEC_MTHI\t\t\t27)\n+   (UNSPEC_SET_HILO\t\t28)\n+   (UNSPEC_TLS_LDM\t\t29)\n+   (UNSPEC_TLS_GET_TP\t\t30)\n    (UNSPEC_MFHC1\t\t31)\n    (UNSPEC_MTHC1\t\t32)\n    (UNSPEC_CLEAR_HAZARD\t\t33)\n@@ -484,6 +486,10 @@\n ;; modes.\n (define_mode_iterator GPR2 [SI (DI \"TARGET_64BIT\")])\n \n+;; This mode iterator allows :HILO to be used as the mode of the\n+;; concatenated HI and LO registers.\n+(define_mode_iterator HILO [(DI \"!TARGET_64BIT\") (TI \"TARGET_64BIT\")])\n+\n ;; This mode iterator allows :P to be used for patterns that operate on\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n (define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n@@ -497,7 +503,7 @@\n   [DI DF (V2SF \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\")])\n \n ;; 128-bit modes for which we provide move patterns on 64-bit targets.\n-(define_mode_iterator MOVE128 [TF])\n+(define_mode_iterator MOVE128 [TI TF])\n \n ;; This mode iterator allows the QI and HI extension patterns to be\n ;; defined from the same template.\n@@ -613,6 +619,10 @@\n ;; from the same template.\n (define_code_iterator any_shift [ashift ashiftrt lshiftrt])\n \n+;; This code iterator allows unsigned and signed division to be generated\n+;; from the same template.\n+(define_code_iterator any_div [div udiv])\n+\n ;; This code iterator allows all native floating-point comparisons to be\n ;; generated from the same template.\n (define_code_iterator fcond [unordered uneq unlt unle eq lt le])\n@@ -631,6 +641,7 @@\n ;; <u> expands to an empty string when doing a signed operation and\n ;; \"u\" when doing an unsigned operation.\n (define_code_attr u [(sign_extend \"\") (zero_extend \"u\")\n+\t\t     (div \"\") (udiv \"u\")\n \t\t     (gt \"\") (gtu \"u\")\n \t\t     (ge \"\") (geu \"u\")\n \t\t     (lt \"\") (ltu \"u\")\n@@ -865,13 +876,10 @@\n ;; simply adding a constant to a register.\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n+  [(set (match_operand:SI 0 \"d_operand\")\n \t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 1 \"const_int_operand\")))]\n   \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n    && ((INTVAL (operands[1]) > 0x7f\n \t&& INTVAL (operands[1]) <= 0x7f + 0x7f)\n        || (INTVAL (operands[1]) < - 0x80\n@@ -894,16 +902,11 @@\n })\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\")\n+  [(set (match_operand:SI 0 \"d_operand\")\n+\t(plus:SI (match_operand:SI 1 \"d_operand\")\n \t\t (match_operand:SI 2 \"const_int_operand\")))]\n   \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && REG_P (operands[1])\n-   && M16_REG_P (REGNO (operands[1]))\n    && REGNO (operands[0]) != REGNO (operands[1])\n-   && GET_CODE (operands[2]) == CONST_INT\n    && ((INTVAL (operands[2]) > 0x7\n \t&& INTVAL (operands[2]) <= 0x7 + 0x7f)\n        || (INTVAL (operands[2]) < - 0x8\n@@ -926,13 +929,10 @@\n })\n \n (define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n+  [(set (match_operand:DI 0 \"d_operand\")\n \t(plus:DI (match_dup 0)\n \t\t (match_operand:DI 1 \"const_int_operand\")))]\n   \"TARGET_MIPS16 && TARGET_64BIT && reload_completed && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n    && ((INTVAL (operands[1]) > 0xf\n \t&& INTVAL (operands[1]) <= 0xf + 0xf)\n        || (INTVAL (operands[1]) < - 0x10\n@@ -955,16 +955,11 @@\n })\n \n (define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\")\n+  [(set (match_operand:DI 0 \"d_operand\")\n+\t(plus:DI (match_operand:DI 1 \"d_operand\")\n \t\t (match_operand:DI 2 \"const_int_operand\")))]\n   \"TARGET_MIPS16 && TARGET_64BIT && reload_completed && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && REG_P (operands[1])\n-   && M16_REG_P (REGNO (operands[1]))\n    && REGNO (operands[0]) != REGNO (operands[1])\n-   && GET_CODE (operands[2]) == CONST_INT\n    && ((INTVAL (operands[2]) > 0x7\n \t&& INTVAL (operands[2]) <= 0x7 + 0xf)\n        || (INTVAL (operands[2]) < - 0x8\n@@ -1175,8 +1170,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,l\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d,d\")))\n-   (clobber (match_scratch:SI 3 \"=h,h\"))\n-   (clobber (match_scratch:SI 4 \"=l,X\"))]\n+   (clobber (match_scratch:SI 3 \"=l,X\"))]\n   \"ISA_HAS_MUL3\"\n {\n   if (which_alternative == 1)\n@@ -1195,30 +1189,26 @@\n ;; Operand 0: LO\n ;; Operand 1: GPR (1st multiplication operand)\n ;; Operand 2: GPR (2nd multiplication operand)\n-;; Operand 3: HI\n-;; Operand 4: GPR (destination)\n+;; Operand 3: GPR (destination)\n (define_peephole2\n   [(parallel\n-       [(set (match_operand:SI 0 \"register_operand\")\n-\t     (mult:SI (match_operand:SI 1 \"register_operand\")\n-\t\t      (match_operand:SI 2 \"register_operand\")))\n-        (clobber (match_operand:SI 3 \"register_operand\"))\n+       [(set (match_operand:SI 0 \"lo_operand\")\n+\t     (mult:SI (match_operand:SI 1 \"d_operand\")\n+\t\t      (match_operand:SI 2 \"d_operand\")))\n         (clobber (scratch:SI))])\n-   (set (match_operand:SI 4 \"register_operand\")\n-\t(unspec [(match_dup 0) (match_dup 3)] UNSPEC_MFHILO))]\n+   (set (match_operand:SI 3 \"d_operand\")\n+\t(match_dup 0))]\n   \"ISA_HAS_MUL3 && peep2_reg_dead_p (2, operands[0])\"\n   [(parallel\n-       [(set (match_dup 4)\n+       [(set (match_dup 3)\n \t     (mult:SI (match_dup 1)\n \t\t      (match_dup 2)))\n-        (clobber (match_dup 3))\n         (clobber (match_dup 0))])])\n \n (define_insn \"mul<mode>3_internal\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=l\")\n \t(mult:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t  (match_operand:GPR 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:GPR 3 \"=h\"))]\n+\t\t  (match_operand:GPR 2 \"register_operand\" \"d\")))]\n   \"!TARGET_FIX_R4000\"\n   \"<d>mult\\t%1,%2\"\n   [(set_attr \"type\" \"imul\")\n@@ -1228,8 +1218,7 @@\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n \t(mult:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n \t\t  (match_operand:GPR 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:GPR 3 \"=h\"))\n-   (clobber (match_scratch:GPR 4 \"=l\"))]\n+   (clobber (match_scratch:GPR 3 \"=l\"))]\n   \"TARGET_FIX_R4000\"\n   \"<d>mult\\t%1,%2\\;mflo\\t%0\"\n   [(set_attr \"type\" \"imul\")\n@@ -1243,16 +1232,13 @@\n ;; Operand 0: LO\n ;; Operand 1: GPR (1st multiplication operand)\n ;; Operand 2: GPR (2nd multiplication operand)\n-;; Operand 3: HI\n-;; Operand 4: GPR (destination)\n+;; Operand 3: GPR (destination)\n (define_peephole2\n-  [(parallel\n-       [(set (match_operand:SI 0 \"register_operand\")\n-\t     (mult:SI (match_operand:SI 1 \"register_operand\")\n-\t\t      (match_operand:SI 2 \"register_operand\")))\n-        (clobber (match_operand:SI 3 \"register_operand\"))])\n-   (set (match_operand:SI 4 \"register_operand\")\n-\t(unspec:SI [(match_dup 0) (match_dup 3)] UNSPEC_MFHILO))]\n+  [(set (match_operand:SI 0 \"lo_operand\")\n+\t(mult:SI (match_operand:SI 1 \"d_operand\")\n+\t\t (match_operand:SI 2 \"d_operand\")))\n+   (set (match_operand:SI 3 \"d_operand\")\n+\t(match_dup 0))]\n   \"ISA_HAS_MACC && !ISA_HAS_MUL3\"\n   [(set (match_dup 0)\n \t(const_int 0))\n@@ -1261,11 +1247,10 @@\n \t     (plus:SI (mult:SI (match_dup 1)\n \t\t\t       (match_dup 2))\n \t\t      (match_dup 0)))\n-\t(set (match_dup 4)\n+\t(set (match_dup 3)\n \t     (plus:SI (mult:SI (match_dup 1)\n \t\t\t       (match_dup 2))\n-\t\t      (match_dup 0)))\n-        (clobber (match_dup 3))])])\n+\t\t      (match_dup 0)))])])\n \n ;; Multiply-accumulate patterns\n \n@@ -1284,9 +1269,8 @@\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d,d\")\n \t\t\t  (match_operand:SI 2 \"register_operand\" \"d,d,d\"))\n \t\t (match_operand:SI 3 \"register_operand\" \"0,l,*d\")))\n-   (clobber (match_scratch:SI 4 \"=h,h,h\"))\n-   (clobber (match_scratch:SI 5 \"=X,3,l\"))\n-   (clobber (match_scratch:SI 6 \"=X,X,&d\"))]\n+   (clobber (match_scratch:SI 4 \"=X,3,l\"))\n+   (clobber (match_scratch:SI 5 \"=X,X,&d\"))]\n   \"(TARGET_MIPS3900\n    || GENERATE_MADD_MSUB)\n    && !TARGET_MIPS16\"\n@@ -1302,53 +1286,45 @@\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"4,4,8\")])\n \n-;; Split the above insn if we failed to get LO allocated.\n+;; Split *mul_acc_si if both the source and destination accumulator\n+;; values are GPRs.\n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\")\n-\t\t\t  (match_operand:SI 2 \"register_operand\"))\n-\t\t (match_operand:SI 3 \"register_operand\")))\n-   (clobber (match_scratch:SI 4))\n-   (clobber (match_scratch:SI 5))\n-   (clobber (match_scratch:SI 6))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\n-   && GP_REG_P (true_regnum (operands[0]))\n-   && GP_REG_P (true_regnum (operands[3]))\"\n-  [(parallel [(set (match_dup 6)\n+  [(set (match_operand:SI 0 \"d_operand\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"d_operand\")\n+\t\t\t  (match_operand:SI 2 \"d_operand\"))\n+\t\t (match_operand:SI 3 \"d_operand\")))\n+   (clobber (match_operand:SI 4 \"lo_operand\"))\n+   (clobber (match_operand:SI 5 \"d_operand\"))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n+  [(parallel [(set (match_dup 5)\n \t\t   (mult:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_dup 5))])\n-   (set (match_dup 0) (plus:SI (match_dup 6) (match_dup 3)))]\n+\t      (clobber (match_dup 4))])\n+   (set (match_dup 0) (plus:SI (match_dup 5) (match_dup 3)))]\n   \"\")\n \n-;; Splitter to copy result of MADD to a general register\n+;; Split *mul_acc_si if the destination accumulator value is in a GPR\n+;; and the source accumulator value is in LO.\n (define_split\n-  [(set (match_operand:SI                   0 \"register_operand\")\n-        (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\")\n-                          (match_operand:SI 2 \"register_operand\"))\n-                 (match_operand:SI          3 \"register_operand\")))\n-   (clobber (match_scratch:SI               4))\n-   (clobber (match_scratch:SI               5))\n-   (clobber (match_scratch:SI               6))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\n-   && GP_REG_P (true_regnum (operands[0]))\n-   && true_regnum (operands[3]) == LO_REGNUM\"\n+  [(set (match_operand:SI 0 \"d_operand\")\n+        (plus:SI (mult:SI (match_operand:SI 1 \"d_operand\")\n+                          (match_operand:SI 2 \"d_operand\"))\n+                 (match_operand:SI 3 \"lo_operand\")))\n+   (clobber (match_dup 3))\n+   (clobber (scratch:SI))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n   [(parallel [(set (match_dup 3)\n                    (plus:SI (mult:SI (match_dup 1) (match_dup 2))\n                             (match_dup 3)))\n-              (clobber (match_dup 4))\n-              (clobber (match_dup 5))\n-              (clobber (match_dup 6))])\n-   (set (match_dup 0) (unspec:SI [(match_dup 5) (match_dup 4)] UNSPEC_MFHILO))]\n-  \"\")\n+              (clobber (scratch:SI))\n+              (clobber (scratch:SI))])\n+   (set (match_dup 0) (match_dup 3))])\n \n (define_insn \"*macc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l,d\")\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t\t  (match_operand:SI 2 \"register_operand\" \"d,d\"))\n \t\t (match_operand:SI 3 \"register_operand\" \"0,l\")))\n-   (clobber (match_scratch:SI 4 \"=h,h\"))\n-   (clobber (match_scratch:SI 5 \"=X,3\"))]\n+   (clobber (match_scratch:SI 4 \"=X,3\"))]\n   \"ISA_HAS_MACC\"\n {\n   if (which_alternative == 1)\n@@ -1369,8 +1345,7 @@\n         (minus:SI (match_operand:SI 1 \"register_operand\" \"0,l\")\n                   (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d\")\n                            (match_operand:SI 3 \"register_operand\" \"d,d\"))))\n-   (clobber (match_scratch:SI 4 \"=h,h\"))\n-   (clobber (match_scratch:SI 5 \"=X,1\"))]\n+   (clobber (match_scratch:SI 4 \"=X,1\"))]\n   \"ISA_HAS_MSAC\"\n {\n   if (which_alternative == 1)\n@@ -1389,21 +1364,19 @@\n         (minus:SI (match_operand:SI 1 \"register_operand\" \"0,l\")\n                   (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d\")\n                            (match_operand:SI 3 \"register_operand\" \"d,d\"))))\n-   (clobber (match_scratch:SI 4 \"=h,h\"))\n-   (clobber (match_scratch:SI 5 \"=X,1\"))\n-   (clobber (match_scratch:SI 6 \"=d,d\"))]\n+   (clobber (match_scratch:SI 4 \"=X,1\"))\n+   (clobber (match_scratch:SI 5 \"=d,d\"))]\n   \"ISA_HAS_MACC && !ISA_HAS_MSAC\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 6)\n+  [(set (match_dup 5)\n \t(neg:SI (match_dup 3)))\n    (parallel\n        [(set (match_dup 0)\n \t     (plus:SI (mult:SI (match_dup 2)\n-\t\t\t       (match_dup 6))\n+\t\t\t       (match_dup 5))\n \t\t      (match_dup 1)))\n-\t(clobber (match_dup 4))\n-\t(clobber (match_dup 5))])]\n+\t(clobber (match_dup 4))])]\n   \"\"\n   [(set_attr \"type\"     \"imadd\")\n    (set_attr \"length\"\t\"8\")])\n@@ -1418,8 +1391,7 @@\n    (set (match_operand:SI 3 \"register_operand\" \"=d\")\n \t(plus:SI (mult:SI (match_dup 1)\n \t\t\t  (match_dup 2))\n-\t\t (match_dup 0)))\n-   (clobber (match_scratch:SI 4 \"=h\"))]\n+\t\t (match_dup 0)))]\n   \"ISA_HAS_MACC && reload_completed\"\n   \"macc\\t%3,%1,%2\"\n   [(set_attr \"type\"\t\"imadd\")\n@@ -1433,8 +1405,7 @@\n    (set (match_operand:SI 3 \"register_operand\" \"=d\")\n \t(minus:SI (match_dup 0)\n \t\t  (mult:SI (match_dup 1)\n-\t\t\t   (match_dup 2))))\n-   (clobber (match_scratch:SI 4 \"=h\"))]\n+\t\t\t   (match_dup 2))))]\n   \"ISA_HAS_MSAC && reload_completed\"\n   \"msac\\t%3,%1,%2\"\n   [(set_attr \"type\"\t\"imadd\")\n@@ -1445,23 +1416,19 @@\n ;;\n ;; Operand 0: LO\n ;; Operand 1: macc/msac\n-;; Operand 2: HI\n-;; Operand 3: GPR (destination)\n+;; Operand 2: GPR (destination)\n (define_peephole2\n   [(parallel\n-       [(set (match_operand:SI 0 \"register_operand\")\n+       [(set (match_operand:SI 0 \"lo_operand\")\n \t     (match_operand:SI 1 \"macc_msac_operand\"))\n-\t(clobber (match_operand:SI 2 \"register_operand\"))\n \t(clobber (scratch:SI))])\n-   (set (match_operand:SI 3 \"register_operand\")\n-\t(unspec:SI [(match_dup 0) (match_dup 2)] UNSPEC_MFHILO))]\n+   (set (match_operand:SI 2 \"d_operand\")\n+\t(match_dup 0))]\n   \"\"\n   [(parallel [(set (match_dup 0)\n \t\t   (match_dup 1))\n-\t      (set (match_dup 3)\n-\t\t   (match_dup 1))\n-\t      (clobber (match_dup 2))])]\n-  \"\")\n+\t      (set (match_dup 2)\n+\t\t   (match_dup 1))])])\n \n ;; When we have a three-address multiplication instruction, it should\n ;; be faster to do a separate multiply and add, rather than moving\n@@ -1475,32 +1442,26 @@\n ;; Operand 2: GPR (addend)\n ;; Operand 3: GPR (destination)\n ;; Operand 4: macc/msac\n-;; Operand 5: HI\n-;; Operand 6: new multiplication\n-;; Operand 7: new addition/subtraction\n+;; Operand 5: new multiplication\n+;; Operand 6: new addition/subtraction\n (define_peephole2\n   [(match_scratch:SI 0 \"d\")\n-   (set (match_operand:SI 1 \"register_operand\")\n-\t(match_operand:SI 2 \"register_operand\"))\n+   (set (match_operand:SI 1 \"lo_operand\")\n+\t(match_operand:SI 2 \"d_operand\"))\n    (match_dup 0)\n    (parallel\n-       [(set (match_operand:SI 3 \"register_operand\")\n+       [(set (match_operand:SI 3 \"d_operand\")\n \t     (match_operand:SI 4 \"macc_msac_operand\"))\n-\t(clobber (match_operand:SI 5 \"register_operand\"))\n \t(clobber (match_dup 1))])]\n-  \"ISA_HAS_MUL3\n-   && true_regnum (operands[1]) == LO_REGNUM\n-   && peep2_reg_dead_p (2, operands[1])\n-   && GP_REG_P (true_regnum (operands[3]))\"\n+  \"ISA_HAS_MUL3 && peep2_reg_dead_p (2, operands[1])\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (match_dup 6))\n-\t      (clobber (match_dup 5))\n+\t\t   (match_dup 5))\n \t      (clobber (match_dup 1))])\n    (set (match_dup 3)\n-\t(match_dup 7))]\n+\t(match_dup 6))]\n {\n-  operands[6] = XEXP (operands[4], GET_CODE (operands[4]) == PLUS ? 0 : 1);\n-  operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[4]), SImode,\n+  operands[5] = XEXP (operands[4], GET_CODE (operands[4]) == PLUS ? 0 : 1);\n+  operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[4]), SImode,\n \t\t\t\toperands[2], operands[0]);\n })\n \n@@ -1510,33 +1471,30 @@\n ;; Operand 1: LO\n ;; Operand 2: GPR (addend)\n ;; Operand 3: macc/msac\n-;; Operand 4: HI\n-;; Operand 5: GPR (destination)\n-;; Operand 6: new multiplication\n-;; Operand 7: new addition/subtraction\n+;; Operand 4: GPR (destination)\n+;; Operand 5: new multiplication\n+;; Operand 6: new addition/subtraction\n (define_peephole2\n   [(match_scratch:SI 0 \"d\")\n-   (set (match_operand:SI 1 \"register_operand\")\n-\t(match_operand:SI 2 \"register_operand\"))\n+   (set (match_operand:SI 1 \"lo_operand\")\n+\t(match_operand:SI 2 \"d_operand\"))\n    (match_dup 0)\n    (parallel\n        [(set (match_dup 1)\n \t     (match_operand:SI 3 \"macc_msac_operand\"))\n-\t(clobber (match_operand:SI 4 \"register_operand\"))\n \t(clobber (scratch:SI))])\n    (match_dup 0)\n-   (set (match_operand:SI 5 \"register_operand\")\n-\t(unspec:SI [(match_dup 1) (match_dup 4)] UNSPEC_MFHILO))]\n+   (set (match_operand:SI 4 \"d_operand\")\n+\t(match_dup 1))]\n   \"ISA_HAS_MUL3 && peep2_reg_dead_p (3, operands[1])\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (match_dup 6))\n-\t      (clobber (match_dup 4))\n+\t\t   (match_dup 5))\n \t      (clobber (match_dup 1))])\n-   (set (match_dup 5)\n-\t(match_dup 7))]\n+   (set (match_dup 4)\n+\t(match_dup 6))]\n {\n-  operands[6] = XEXP (operands[4], GET_CODE (operands[4]) == PLUS ? 0 : 1);\n-  operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[4]), SImode,\n+  operands[5] = XEXP (operands[3], GET_CODE (operands[3]) == PLUS ? 0 : 1);\n+  operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[3]), SImode,\n \t\t\t\toperands[2], operands[0]);\n })\n \n@@ -1545,9 +1503,8 @@\n         (minus:SI (match_operand:SI 1 \"register_operand\" \"0,l,*d\")\n                   (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n                            (match_operand:SI 3 \"register_operand\" \"d,d,d\"))))\n-   (clobber (match_scratch:SI 4 \"=h,h,h\"))\n-   (clobber (match_scratch:SI 5 \"=X,1,l\"))\n-   (clobber (match_scratch:SI 6 \"=X,X,&d\"))]\n+   (clobber (match_scratch:SI 4 \"=X,1,l\"))\n+   (clobber (match_scratch:SI 5 \"=X,X,&d\"))]\n   \"GENERATE_MADD_MSUB\"\n   \"@\n    msub\\t%2,%3\n@@ -1557,84 +1514,69 @@\n    (set_attr \"mode\"     \"SI\")\n    (set_attr \"length\"   \"4,8,8\")])\n \n-;; Split the above insn if we failed to get LO allocated.\n+;; Split *mul_sub_si if both the source and destination accumulator\n+;; values are GPRs.\n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (minus:SI (match_operand:SI 1 \"register_operand\")\n-                  (mult:SI (match_operand:SI 2 \"register_operand\")\n-                           (match_operand:SI 3 \"register_operand\"))))\n-   (clobber (match_scratch:SI 4))\n-   (clobber (match_scratch:SI 5))\n-   (clobber (match_scratch:SI 6))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\n-   && GP_REG_P (true_regnum (operands[0]))\n-   && GP_REG_P (true_regnum (operands[1]))\"\n-  [(parallel [(set (match_dup 6)\n+  [(set (match_operand:SI 0 \"d_operand\")\n+        (minus:SI (match_operand:SI 1 \"d_operand\")\n+                  (mult:SI (match_operand:SI 2 \"d_operand\")\n+                           (match_operand:SI 3 \"d_operand\"))))\n+   (clobber (match_operand:SI 4 \"lo_operand\"))\n+   (clobber (match_operand:SI 5 \"d_operand\"))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n+  [(parallel [(set (match_dup 5)\n                    (mult:SI (match_dup 2) (match_dup 3)))\n-              (clobber (match_dup 4))\n-              (clobber (match_dup 5))])\n-   (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 6)))]\n+              (clobber (match_dup 4))])\n+   (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 5)))]\n   \"\")\n \n-;; Splitter to copy result of MSUB to a general register\n+;; Split *mul_acc_si if the destination accumulator value is in a GPR\n+;; and the source accumulator value is in LO.\n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (minus:SI (match_operand:SI 1 \"register_operand\")\n-                  (mult:SI (match_operand:SI 2 \"register_operand\")\n-                           (match_operand:SI 3 \"register_operand\"))))\n-   (clobber (match_scratch:SI 4))\n-   (clobber (match_scratch:SI 5))\n-   (clobber (match_scratch:SI 6))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\n-   && GP_REG_P (true_regnum (operands[0]))\n-   && true_regnum (operands[1]) == LO_REGNUM\"\n+  [(set (match_operand:SI 0 \"d_operand\")\n+        (minus:SI (match_operand:SI 1 \"lo_operand\")\n+                  (mult:SI (match_operand:SI 2 \"d_operand\")\n+                           (match_operand:SI 3 \"d_operand\"))))\n+   (clobber (match_dup 1))\n+   (clobber (scratch:SI))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n   [(parallel [(set (match_dup 1)\n                    (minus:SI (match_dup 1)\n                              (mult:SI (match_dup 2) (match_dup 3))))\n-              (clobber (match_dup 4))\n-              (clobber (match_dup 5))\n-              (clobber (match_dup 6))])\n-   (set (match_dup 0) (unspec:SI [(match_dup 5) (match_dup 4)] UNSPEC_MFHILO))]\n+              (clobber (scratch:SI))\n+              (clobber (scratch:SI))])\n+   (set (match_dup 0) (match_dup 1))]\n   \"\")\n \n (define_insn \"*muls\"\n-  [(set (match_operand:SI                  0 \"register_operand\" \"=l,d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,d\")\n         (neg:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n                          (match_operand:SI 2 \"register_operand\" \"d,d\"))))\n-   (clobber (match_scratch:SI              3                    \"=h,h\"))\n-   (clobber (match_scratch:SI              4                    \"=X,l\"))]\n+   (clobber (match_scratch:SI 3 \"=X,l\"))]\n   \"ISA_HAS_MULS\"\n   \"@\n    muls\\t$0,%1,%2\n    muls\\t%0,%1,%2\"\n   [(set_attr \"type\"     \"imul,imul3\")\n    (set_attr \"mode\"     \"SI\")])\n \n-;; ??? We could define a mulditi3 pattern when TARGET_64BIT.\n-\n (define_expand \"<u>mulsidi3\"\n-  [(parallel\n-      [(set (match_operand:DI 0 \"register_operand\")\n-\t    (mult:DI (any_extend:DI (match_operand:SI 1 \"register_operand\"))\n-\t\t     (any_extend:DI (match_operand:SI 2 \"register_operand\"))))\n-       (clobber (scratch:DI))\n-       (clobber (scratch:DI))\n-       (clobber (scratch:DI))])]\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(mult:DI (any_extend:DI (match_operand:SI 1 \"register_operand\"))\n+\t\t (any_extend:DI (match_operand:SI 2 \"register_operand\"))))]\n   \"!TARGET_64BIT || !TARGET_FIX_R4000\"\n {\n-  if (!TARGET_64BIT)\n-    {\n-      if (!TARGET_FIX_R4000)\n-\temit_insn (gen_<u>mulsidi3_32bit_internal (operands[0], operands[1],\n-\t\t\t\t\t\t   operands[2]));\n-      else\n-\temit_insn (gen_<u>mulsidi3_32bit_r4000 (operands[0], operands[1],\n-\t\t\t\t\t        operands[2]));\n-      DONE;\n-    }\n+  if (TARGET_64BIT)\n+    emit_insn (gen_<u>mulsidi3_64bit (operands[0], operands[1], operands[2]));\n+  else if (TARGET_FIX_R4000)\n+    emit_insn (gen_<u>mulsidi3_32bit_r4000 (operands[0], operands[1],\n+\t\t\t\t\t    operands[2]));\n+  else\n+    emit_insn (gen_<u>mulsidi3_32bit (operands[0], operands[1], operands[2]));\n+  DONE;\n })\n \n-(define_insn \"<u>mulsidi3_32bit_internal\"\n+(define_insn \"<u>mulsidi3_32bit\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n \t(mult:DI (any_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n@@ -1649,42 +1591,35 @@\n \t\t (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n    (clobber (match_scratch:DI 3 \"=x\"))]\n   \"!TARGET_64BIT && TARGET_FIX_R4000\"\n-  \"mult<u>\\t%1,%2\\;mflo\\t%L0;mfhi\\t%M0\"\n+  \"mult<u>\\t%1,%2\\;mflo\\t%L0\\;mfhi\\t%M0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"length\" \"12\")])\n \n-(define_insn_and_split \"*<u>mulsidi3_64bit\"\n+(define_insn_and_split \"<u>mulsidi3_64bit\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(mult:DI (any_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))\n-   (clobber (match_scratch:DI 5 \"=d\"))]\n+   (clobber (match_scratch:TI 3 \"=x\"))\n+   (clobber (match_scratch:DI 4 \"=d\"))]\n   \"TARGET_64BIT && !TARGET_FIX_R4000\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel\n-       [(set (match_dup 3)\n-\t     (sign_extend:DI\n-\t\t(mult:SI (match_dup 1)\n-\t\t\t (match_dup 2))))\n-\t(set (match_dup 4)\n-\t     (ashiftrt:DI\n-\t\t(mult:DI (any_extend:DI (match_dup 1))\n-\t\t\t (any_extend:DI (match_dup 2)))\n-\t\t(const_int 32)))])\n-\n-   ;; OP5 <- LO, OP0 <- HI\n-   (set (match_dup 5) (unspec:DI [(match_dup 3) (match_dup 4)] UNSPEC_MFHILO))\n-   (set (match_dup 0) (unspec:DI [(match_dup 4) (match_dup 3)] UNSPEC_MFHILO))\n-\n-   ;; Zero-extend OP5.\n-   (set (match_dup 5)\n-\t(ashift:DI (match_dup 5)\n+  [(set (match_dup 3)\n+\t(unspec:TI [(mult:DI (any_extend:DI (match_dup 1))\n+\t\t\t     (any_extend:DI (match_dup 2)))]\n+\t\t   UNSPEC_SET_HILO))\n+\n+   ;; OP4 <- LO, OP0 <- HI\n+   (set (match_dup 4) (match_dup 5))\n+   (set (match_dup 0) (unspec:DI [(match_dup 3)] UNSPEC_MFHI))\n+\n+   ;; Zero-extend OP4.\n+   (set (match_dup 4)\n+\t(ashift:DI (match_dup 4)\n \t\t   (const_int 32)))\n-   (set (match_dup 5)\n-\t(lshiftrt:DI (match_dup 5)\n+   (set (match_dup 4)\n+\t(lshiftrt:DI (match_dup 4)\n \t\t     (const_int 32)))\n \n    ;; Shift OP0 into place.\n@@ -1695,24 +1630,21 @@\n    ;; OR the two halves together\n    (set (match_dup 0)\n \t(ior:DI (match_dup 0)\n-\t\t(match_dup 5)))]\n-  \"\"\n+\t\t(match_dup 4)))]\n+  { operands[5] = gen_rtx_REG (DImode, LO_REGNUM); }\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"length\" \"24\")])\n \n-(define_insn \"*<u>mulsidi3_64bit_parts\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(sign_extend:DI\n-\t   (mult:SI (match_operand:SI 2 \"register_operand\" \"d\")\n-\t\t    (match_operand:SI 3 \"register_operand\" \"d\"))))\n-   (set (match_operand:DI 1 \"register_operand\" \"=h\")\n-\t(ashiftrt:DI\n-\t   (mult:DI (any_extend:DI (match_dup 2))\n-\t\t    (any_extend:DI (match_dup 3)))\n-\t   (const_int 32)))]\n+(define_insn \"<u>mulsidi3_64bit_hilo\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+\t(unspec:TI\n+\t  [(mult:DI\n+\t     (any_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t     (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))]\n+\t  UNSPEC_SET_HILO))]\n   \"TARGET_64BIT && !TARGET_FIX_R4000\"\n-  \"mult<u>\\t%2,%3\"\n+  \"mult<u>\\t%1,%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"SI\")])\n \n@@ -1756,7 +1688,7 @@\n \t  (mult:DI (any_extend:DI (match_operand:SI 1 \"register_operand\"))\n \t\t   (any_extend:DI (match_operand:SI 2 \"register_operand\")))\n \t  (const_int 32))))]\n-  \"ISA_HAS_MULHI || !TARGET_FIX_R4000\"\n+  \"\"\n {\n   if (ISA_HAS_MULHI)\n     emit_insn (gen_<su>mulsi3_highpart_mulhi_internal (operands[0],\n@@ -1768,81 +1700,141 @@\n   DONE;\n })\n \n-(define_insn \"<su>mulsi3_highpart_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n+(define_insn_and_split \"<su>mulsi3_highpart_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(truncate:SI\n \t (lshiftrt:DI\n \t  (mult:DI (any_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t   (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n \t  (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=l\"))]\n-  \"!ISA_HAS_MULHI && !TARGET_FIX_R4000\"\n-  \"mult<u>\\t%1,%2\"\n+  \"!ISA_HAS_MULHI\"\n+  { return TARGET_FIX_R4000 ? \"mult<u>\\t%1,%2\\n\\tmfhi\\t%0\" : \"#\"; }\n+  \"&& reload_completed && !TARGET_FIX_R4000\"\n+  [(const_int 0)]\n+{\n+  rtx hilo;\n+\n+  if (TARGET_64BIT)\n+    {\n+      hilo = gen_rtx_REG (TImode, MD_REG_FIRST);\n+      emit_insn (gen_<u>mulsidi3_64bit_hilo (hilo, operands[1], operands[2]));\n+      emit_insn (gen_mfhisi_ti (operands[0], hilo));\n+    }\n+  else\n+    {\n+      hilo = gen_rtx_REG (DImode, MD_REG_FIRST);\n+      emit_insn (gen_<u>mulsidi3_32bit (hilo, operands[1], operands[2]));\n+      emit_insn (gen_mfhisi_di (operands[0], hilo));\n+    }\n+  DONE;\n+}\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"<su>mulsi3_highpart_mulhi_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h,d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (truncate:SI\n \t (lshiftrt:DI\n \t  (mult:DI\n-\t   (any_extend:DI (match_operand:SI 1 \"register_operand\" \"d,d\"))\n-\t   (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d,d\")))\n+\t   (any_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t   (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n \t  (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=l,l\"))\n-   (clobber (match_scratch:SI 4 \"=X,h\"))]\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"ISA_HAS_MULHI\"\n-  \"@\n-   mult<u>\\t%1,%2\n-   mulhi<u>\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"imul,imul3\")\n+  \"mulhi<u>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"imul3\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*<su>mulsi3_highpart_neg_mulhi_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h,d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (truncate:SI\n \t (lshiftrt:DI\n \t  (neg:DI\n \t   (mult:DI\n-\t    (any_extend:DI (match_operand:SI 1 \"register_operand\" \"d,d\"))\n-\t    (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d,d\"))))\n+\t    (any_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t    (any_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n \t  (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=l,l\"))\n-   (clobber (match_scratch:SI 4 \"=X,h\"))]\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"ISA_HAS_MULHI\"\n-  \"@\n-   mulshi<u>\\t%.,%1,%2\n-   mulshi<u>\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"imul,imul3\")\n+  \"mulshi<u>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"imul3\")\n    (set_attr \"mode\" \"SI\")])\n \n ;; Disable unsigned multiplication for -mfix-vr4120.  This is for VR4120\n ;; errata MD(0), which says that dmultu does not always produce the\n ;; correct result.\n-(define_insn \"<su>muldi3_highpart\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n+(define_insn_and_split \"<su>muldi3_highpart\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(truncate:DI\n \t (lshiftrt:TI\n-\t  (mult:TI\n-\t   (any_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n-\t   (any_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n+\t  (mult:TI (any_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n+\t\t   (any_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n \t  (const_int 64))))\n    (clobber (match_scratch:DI 3 \"=l\"))]\n-  \"TARGET_64BIT && !TARGET_FIX_R4000\n+  \"TARGET_64BIT && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)\"\n+  { return TARGET_FIX_R4000 ? \"dmult<u>\\t%1,%2\\n\\tmfhi\\t%0\" : \"#\"; }\n+  \"&& reload_completed && !TARGET_FIX_R4000\"\n+  [(const_int 0)]\n+{\n+  rtx hilo;\n+\n+  hilo = gen_rtx_REG (TImode, MD_REG_FIRST);\n+  emit_insn (gen_<u>mulditi3_internal (hilo, operands[1], operands[2]));\n+  emit_insn (gen_mfhidi_ti (operands[0], hilo));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_expand \"<u>mulditi3\"\n+  [(set (match_operand:TI 0 \"register_operand\")\n+\t(mult:TI (any_extend:TI (match_operand:DI 1 \"register_operand\"))\n+\t\t (any_extend:TI (match_operand:DI 2 \"register_operand\"))))]\n+  \"TARGET_64BIT && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)\"\n+{\n+  if (TARGET_FIX_R4000)\n+    emit_insn (gen_<u>mulditi3_r4000 (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_<u>mulditi3_internal (operands[0], operands[1],\n+\t\t\t\t\t operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"<u>mulditi3_internal\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+\t(mult:TI (any_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n+\t\t (any_extend:TI (match_operand:DI 2 \"register_operand\" \"d\"))))]\n+  \"TARGET_64BIT\n+   && !TARGET_FIX_R4000\n    && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)\"\n   \"dmult<u>\\t%1,%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"DI\")])\n \n+(define_insn \"<u>mulditi3_r4000\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=d\")\n+\t(mult:TI (any_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n+\t\t (any_extend:TI (match_operand:DI 2 \"register_operand\" \"d\"))))\n+   (clobber (match_scratch:TI 3 \"=x\"))]\n+  \"TARGET_64BIT\n+   && TARGET_FIX_R4000\n+   && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)\"\n+  \"dmult<u>\\t%1,%2\\;mflo\\t%L0\\;mfhi\\t%M0\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"length\" \"12\")])\n+\n ;; The R4650 supports a 32-bit multiply/ 64-bit accumulate\n ;; instruction.  The HI/LO registers are used as a 64-bit accumulator.\n \n (define_insn \"madsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"+l\")\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t  (match_operand:SI 2 \"register_operand\" \"d\"))\n-\t\t (match_dup 0)))\n-   (clobber (match_scratch:SI 3 \"=h\"))]\n+\t\t (match_dup 0)))]\n   \"TARGET_MAD\"\n   \"mad\\t%1,%2\"\n   [(set_attr \"type\"\t\"imadd\")\n@@ -2017,29 +2009,80 @@\n \n ;; VR4120 errata MD(A1): signed division instructions do not work correctly\n ;; with negative operands.  We use special libgcc functions instead.\n-(define_insn \"divmod<mode>4\"\n+(define_insn_and_split \"divmod<mode>4\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=l\")\n \t(div:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n \t\t (match_operand:GPR 2 \"register_operand\" \"d\")))\n-   (set (match_operand:GPR 3 \"register_operand\" \"=h\")\n+   (set (match_operand:GPR 3 \"register_operand\" \"=d\")\n \t(mod:GPR (match_dup 1)\n \t\t (match_dup 2)))]\n   \"!TARGET_FIX_VR4120\"\n-  { return mips_output_division (\"<d>div\\t$0,%1,%2\", operands); }\n-  [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx hilo;\n+\n+  if (TARGET_64BIT)\n+    {\n+      hilo = gen_rtx_REG (TImode, MD_REG_FIRST);\n+      emit_insn (gen_divmod<mode>4_hilo_ti (hilo, operands[1], operands[2]));\n+      emit_insn (gen_mfhi<mode>_ti (operands[3], hilo));\n+    }\n+  else\n+    {\n+      hilo = gen_rtx_REG (DImode, MD_REG_FIRST);\n+      emit_insn (gen_divmod<mode>4_hilo_di (hilo, operands[1], operands[2]));\n+      emit_insn (gen_mfhi<mode>_di (operands[3], hilo));\n+    }\n+  DONE;\n+}\n+ [(set_attr \"type\" \"idiv\")\n+  (set_attr \"mode\" \"<MODE>\")\n+  (set_attr \"length\" \"8\")])\n \n-(define_insn \"udivmod<mode>4\"\n+(define_insn_and_split \"udivmod<mode>4\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=l\")\n \t(udiv:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n \t\t  (match_operand:GPR 2 \"register_operand\" \"d\")))\n-   (set (match_operand:GPR 3 \"register_operand\" \"=h\")\n+   (set (match_operand:GPR 3 \"register_operand\" \"=d\")\n \t(umod:GPR (match_dup 1)\n \t\t  (match_dup 2)))]\n   \"\"\n-  { return mips_output_division (\"<d>divu\\t$0,%1,%2\", operands); }\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx hilo;\n+\n+  if (TARGET_64BIT)\n+    {\n+      hilo = gen_rtx_REG (TImode, MD_REG_FIRST);\n+      emit_insn (gen_udivmod<mode>4_hilo_ti (hilo, operands[1], operands[2]));\n+      emit_insn (gen_mfhi<mode>_ti (operands[3], hilo));\n+    }\n+  else\n+    {\n+      hilo = gen_rtx_REG (DImode, MD_REG_FIRST);\n+      emit_insn (gen_udivmod<mode>4_hilo_di (hilo, operands[1], operands[2]));\n+      emit_insn (gen_mfhi<mode>_di (operands[3], hilo));\n+    }\n+  DONE;\n+}\n+ [(set_attr \"type\" \"idiv\")\n+  (set_attr \"mode\" \"<MODE>\")\n+  (set_attr \"length\" \"8\")])\n+\n+(define_insn \"<u>divmod<GPR:mode>4_hilo_<HILO:mode>\"\n+  [(set (match_operand:HILO 0 \"register_operand\" \"=x\")\n+\t(unspec:HILO\n+\t  [(any_div:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t\t(match_operand:GPR 2 \"register_operand\" \"d\"))]\n+\t  UNSPEC_SET_HILO))]\n+  \"\"\n+  { return mips_output_division (\"<GPR:d>div<u>\\t%.,%1,%2\", operands); }\n   [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \f\n ;;\n ;;  ....................\n@@ -3241,7 +3284,7 @@\n ;;\tdsll32\top1,op1,0\n ;;\tdaddu\top1,op1,op0\n (define_peephole2\n-  [(set (match_operand:DI 1 \"register_operand\")\n+  [(set (match_operand:DI 1 \"d_operand\")\n \t(high:DI (match_operand:DI 2 \"absolute_symbolic_operand\")))\n    (match_scratch:DI 0 \"d\")]\n   \"TARGET_EXPLICIT_RELOCS && ABI_HAS_64BIT_SYMBOLS\"\n@@ -3294,8 +3337,8 @@\n ;;\n ;; on MIPS16 targets.\n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(high:SI (match_operand:SI 1 \"absolute_symbolic_operand\" \"\")))]\n+  [(set (match_operand:SI 0 \"d_operand\")\n+\t(high:SI (match_operand:SI 1 \"absolute_symbolic_operand\")))]\n   \"TARGET_MIPS16 && reload_completed\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (ashift:SI (match_dup 0) (const_int 16)))]\n@@ -3464,7 +3507,7 @@\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,multi,load,store,mthilo,mfhilo,mtc,load,mfc,store\")\n+  [(set_attr \"type\"\t\"multi,multi,load,store,multi,multi,mtc,load,mfc,store\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"   \"8,16,*,*,8,8,8,*,8,*\")])\n \n@@ -3475,7 +3518,7 @@\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,multi,load,store,mthilo,mfhilo,mtc,fpload,mfc,fpstore\")\n+  [(set_attr \"type\"\t\"multi,multi,load,store,multi,multi,mtc,fpload,mfc,fpstore\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"   \"8,16,*,*,8,8,8,*,8,*\")])\n \n@@ -3486,29 +3529,29 @@\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,multi,multi,multi,multi,load,store,mfhilo\")\n+  [(set_attr \"type\"\t\"multi,multi,multi,multi,multi,load,store,multi\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"8,8,8,8,12,*,*,8\")])\n \n (define_insn \"*movdi_64bit\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*d,*m,*x,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*d*J,*m,*f,*f,*J*d,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*d,*m,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*d*J,*m,*f,*f,*J*d,*a,*d,*m,*B*C*D,*B*C*D\"))]\n   \"TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,const,const,load,store,mtc,fpload,mfc,fpstore,mthilo,mtc,load,mfc,store\")\n+  [(set_attr \"type\"\t\"move,const,const,load,store,mtc,fpload,mfc,fpstore,mthilo,mfhilo,mtc,load,mfc,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,*,4,*,4,8,*,8,*\")])\n+   (set_attr \"length\"\t\"4,*,*,*,*,4,*,4,*,4,4,8,*,8,*\")])\n \n (define_insn \"*movdi_64bit_mips16\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,d,y,K,N,kf,U,m,d\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,m,*d\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,d,y,K,N,kf,U,m,d,*a\"))]\n   \"TARGET_64BIT && TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,const,load,store\")\n+  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,const,load,store,mfhilo\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n@@ -3523,22 +3566,20 @@\n \t\t (const_int 8)\n \t\t (const_string \"*\")\n \t\t (const_string \"*\")\n-\t\t (const_string \"*\")])])\n+\t\t (const_string \"*\")\n+\t\t (const_int 4)])])\n \n \n ;; On the mips16, we can split ld $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n ;; load are 2 2 byte instructions.\n \n (define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n+  [(set (match_operand:DI 0 \"d_operand\")\n \t(mem:DI (plus:DI (match_dup 0)\n \t\t\t (match_operand:DI 1 \"const_int_operand\"))))]\n   \"TARGET_64BIT && TARGET_MIPS16 && reload_completed\n    && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n    && ((INTVAL (operands[1]) < 0\n \t&& INTVAL (operands[1]) >= -0x10)\n        || (INTVAL (operands[1]) >= 32 * 8\n@@ -3589,7 +3630,7 @@\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*d,*m,*d,*z,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*d*J,*m,*f,*f,*z,*d,*J*d,*A,*d,*m,*B*C*D,*B*C*D\"))]\n+\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*d*J,*m,*f,*f,*z,*d,*J*d,*a,*d,*m,*B*C*D,*B*C*D\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n@@ -3599,13 +3640,13 @@\n    (set_attr \"length\"\t\"4,*,*,*,*,4,*,4,*,4,4,4,4,4,*,4,*\")])\n \n (define_insn \"*movsi_mips16\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,m\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,kf,U,m,d\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,m,*d\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,kf,U,m,d,*a\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,const,load,store\")\n+  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,const,load,store,mfhilo\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n@@ -3620,20 +3661,18 @@\n \t\t (const_int 8)\n \t\t (const_string \"*\")\n \t\t (const_string \"*\")\n-\t\t (const_string \"*\")])])\n+\t\t (const_string \"*\")\n+\t\t (const_int 4)])])\n \n ;; On the mips16, we can split lw $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n ;; load are 2 2 byte instructions.\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n+  [(set (match_operand:SI 0 \"d_operand\")\n \t(mem:SI (plus:SI (match_dup 0)\n \t\t\t (match_operand:SI 1 \"const_int_operand\"))))]\n   \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n    && ((INTVAL (operands[1]) < 0\n \t&& INTVAL (operands[1]) >= -0x80)\n        || (INTVAL (operands[1]) >= 32 * 4\n@@ -3669,12 +3708,9 @@\n ;; instructions.\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n+  [(set (match_operand:SI 0 \"d_operand\")\n \t(match_operand:SI 1 \"const_int_operand\"))]\n   \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n    && INTVAL (operands[1]) >= 0x100\n    && INTVAL (operands[1]) <= 0xff + 0x7f\"\n   [(set (match_dup 0) (match_dup 1))\n@@ -3797,36 +3833,24 @@\n })\n \n (define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*x\")\n-\t(match_operand:HI 1 \"move_operand\"         \"d,I,m,dJ,*d\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d\")\n+\t(match_operand:HI 1 \"move_operand\"         \"d,I,m,dJ,*d*J,*a\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], HImode)\n        || reg_or_0_operand (operands[1], HImode))\"\n-  \"@\n-    move\\t%0,%1\n-    li\\t%0,%1\n-    lhu\\t%0,%1\n-    sh\\t%z1,%0\n-    mt%0\\t%1\"\n-  [(set_attr \"type\"\t\"move,arith,load,store,mthilo\")\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\"\t\"move,arith,load,store,mthilo,mfhilo\")\n    (set_attr \"mode\"\t\"HI\")\n-   (set_attr \"length\"\t\"4,4,*,*,4\")])\n+   (set_attr \"length\"\t\"4,4,*,*,4,4\")])\n \n (define_insn \"*movhi_mips16\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m\")\n-\t(match_operand:HI 1 \"move_operand\"         \"d,d,y,K,N,m,d\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n+\t(match_operand:HI 1 \"move_operand\"         \"d,d,y,K,N,m,d,*a\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n-  \"@\n-    move\\t%0,%1\n-    move\\t%0,%1\n-    move\\t%0,%1\n-    li\\t%0,%1\n-    #\n-    lhu\\t%0,%1\n-    sh\\t%1,%0\"\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store\")\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store,mfhilo\")\n    (set_attr \"mode\"\t\"HI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n@@ -3839,6 +3863,7 @@\n \t\t\t       (const_int 8)\n \t\t\t       (const_int 12))\n \t\t (const_string \"*\")\n+\t\t (const_string \"*\")\n \t\t (const_string \"*\")])])\n \n \n@@ -3847,13 +3872,10 @@\n ;; load are 2 2 byte instructions.\n \n (define_split\n-  [(set (match_operand:HI 0 \"register_operand\")\n+  [(set (match_operand:HI 0 \"d_operand\")\n \t(mem:HI (plus:SI (match_dup 0)\n \t\t\t (match_operand:SI 1 \"const_int_operand\"))))]\n   \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n    && ((INTVAL (operands[1]) < 0\n \t&& INTVAL (operands[1]) >= -0x80)\n        || (INTVAL (operands[1]) >= 32 * 2\n@@ -3901,51 +3923,36 @@\n })\n \n (define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*x\")\n-\t(match_operand:QI 1 \"move_operand\"         \"d,I,m,dJ,*d\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d\")\n+\t(match_operand:QI 1 \"move_operand\"         \"d,I,m,dJ,*d*J,*a\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], QImode)\n        || reg_or_0_operand (operands[1], QImode))\"\n-  \"@\n-    move\\t%0,%1\n-    li\\t%0,%1\n-    lbu\\t%0,%1\n-    sb\\t%z1,%0\n-    mt%0\\t%1\"\n-  [(set_attr \"type\"\t\"move,arith,load,store,mthilo\")\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\"\t\"move,arith,load,store,mthilo,mfhilo\")\n    (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"4,4,*,*,4\")])\n+   (set_attr \"length\"\t\"4,4,*,*,4,4\")])\n \n (define_insn \"*movqi_mips16\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m\")\n-\t(match_operand:QI 1 \"move_operand\"         \"d,d,y,K,N,m,d\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n+\t(match_operand:QI 1 \"move_operand\"         \"d,d,y,K,N,m,d,*a\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n-  \"@\n-    move\\t%0,%1\n-    move\\t%0,%1\n-    move\\t%0,%1\n-    li\\t%0,%1\n-    #\n-    lbu\\t%0,%1\n-    sb\\t%1,%0\"\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store\")\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store,mfhilo\")\n    (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"4,4,4,4,8,*,*\")])\n+   (set_attr \"length\"\t\"4,4,4,4,8,*,*,4\")])\n \n ;; On the mips16, we can split lb $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n ;; load are 2 2 byte instructions.\n \n (define_split\n-  [(set (match_operand:QI 0 \"register_operand\")\n+  [(set (match_operand:QI 0 \"d_operand\")\n \t(mem:QI (plus:SI (match_dup 0)\n \t\t\t (match_operand:SI 1 \"const_int_operand\"))))]\n   \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && REG_P (operands[0])\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n    && ((INTVAL (operands[1]) < 0\n \t&& INTVAL (operands[1]) >= -0x80)\n        || (INTVAL (operands[1]) >= 32\n@@ -4065,6 +4072,39 @@\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"8,8,8,*,*\")])\n \n+;; 128-bit integer moves\n+\n+(define_expand \"movti\"\n+  [(set (match_operand:TI 0)\n+\t(match_operand:TI 1))]\n+  \"TARGET_64BIT\"\n+{\n+  if (mips_legitimize_move (TImode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+(define_insn \"*movti\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,d,m,*a,*d\")\n+\t(match_operand:TI 1 \"move_operand\" \"di,m,dJ,*d*J,*a\"))]\n+  \"TARGET_64BIT\n+   && !TARGET_MIPS16\n+   && (register_operand (operands[0], TImode)\n+       || reg_or_0_operand (operands[1], TImode))\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi,load,store,multi,multi\")\n+   (set_attr \"length\" \"8,*,*,8,8\")])\n+\n+(define_insn \"*movti_mips16\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n+\t(match_operand:TI 1 \"move_operand\" \"d,d,y,K,N,m,d,*a\"))]\n+  \"TARGET_64BIT\n+   && TARGET_MIPS16\n+   && (register_operand (operands[0], TImode)\n+       || register_operand (operands[1], TImode))\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi,multi,multi,multi,multi,load,store,multi\")\n+   (set_attr \"length\" \"8,8,8,12,16,*,*,8\")])\n+\n ;; 128-bit floating point moves\n \n (define_expand \"movtf\"\n@@ -4123,7 +4163,7 @@\n ;; When generating mips16 code, split moves of negative constants into\n ;; a positive \"li\" followed by a negation.\n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n+  [(set (match_operand 0 \"d_operand\")\n \t(match_operand 1 \"const_int_operand\"))]\n   \"TARGET_MIPS16 && reload_completed && INTVAL (operands[1]) < 0\"\n   [(set (match_dup 2)\n@@ -4172,44 +4212,33 @@\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"length\" \"4,8,*,*,*,8,8,8,*,*\")])\n \n-;; The HI and LO registers are not truly independent.  If we move an mthi\n-;; instruction before an mflo instruction, it will make the result of the\n-;; mflo unpredictable.  The same goes for mtlo and mfhi.\n-;;\n-;; We cope with this by making the mflo and mfhi patterns use both HI and LO.\n-;; Operand 1 is the register we want, operand 2 is the other one.\n+;; Extract the high part of a HI/LO value.  See mips_hard_regno_mode_ok_p\n+;; for the reason why we can't just use (reg:GPR HI_REGNUM).\n ;;\n-;; When generating VR4120 or VR4130 code, we use macc{,hi} and\n-;; dmacc{,hi} instead of mfhi and mflo.  This avoids both the normal\n-;; MIPS III hi/lo hazards and the errata related to -mfix-vr4130.\n-\n-(define_expand \"mfhilo_<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\")\n-\t(unspec:GPR [(match_operand:GPR 1 \"register_operand\")\n-\t\t     (match_operand:GPR 2 \"register_operand\")]\n-\t\t    UNSPEC_MFHILO))])\n-\n-(define_insn \"*mfhilo_<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n-\t(unspec:GPR [(match_operand:GPR 1 \"register_operand\" \"h,l\")\n-\t\t     (match_operand:GPR 2 \"register_operand\" \"l,h\")]\n-\t\t    UNSPEC_MFHILO))]\n-  \"!ISA_HAS_MACCHI\"\n-  \"mf%1\\t%0\"\n+;; When generating VR4120 or VR4130 code, we use MACCHI and DMACCHI\n+;; instead of MFHI.  This avoids both the normal MIPS III hi/lo hazards\n+;; and the errata related to -mfix-vr4130.\n+(define_insn \"mfhi<GPR:mode>_<HILO:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(unspec:GPR [(match_operand:HILO 1 \"register_operand\" \"x\")]\n+\t\t    UNSPEC_MFHI))]\n+  \"\"\n+  { return ISA_HAS_MACCHI ? \"<GPR:d>macchi\\t%0,%.,%.\" : \"mfhi\\t%0\"; }\n   [(set_attr \"type\" \"mfhilo\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_insn \"*mfhilo_<mode>_macc\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n-\t(unspec:GPR [(match_operand:GPR 1 \"register_operand\" \"h,l\")\n-\t\t     (match_operand:GPR 2 \"register_operand\" \"l,h\")]\n-\t\t    UNSPEC_MFHILO))]\n-  \"ISA_HAS_MACCHI\"\n-  \"@\n-   <d>macchi\\t%0,%.,%.\n-   <d>macc\\t%0,%.,%.\"\n-  [(set_attr \"type\" \"mfhilo\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+;; Set the high part of a HI/LO value, given that the low part has\n+;; already been set.  See mips_hard_regno_mode_ok_p for the reason\n+;; why we can't just use (reg:GPR HI_REGNUM).\n+(define_insn \"mthi<GPR:mode>_<HILO:mode>\"\n+  [(set (match_operand:HILO 0 \"register_operand\" \"=x\")\n+\t(unspec:HILO [(match_operand:GPR 1 \"reg_or_0_operand\" \"dJ\")\n+\t\t      (match_operand:GPR 2 \"register_operand\" \"l\")]\n+\t\t     UNSPEC_MTHI))]\n+  \"\"\n+  \"mthi\\t%z1\"\n+  [(set_attr \"type\" \"mthilo\")\n+   (set_attr \"mode\" \"SI\")])\n \n ;; Emit a doubleword move in which exactly one of the operands is\n ;; a floating-point register.  We can't just emit two normal moves\n@@ -5120,11 +5149,10 @@\n ;; On the mips16, we can split a 4 byte shift into 2 2 byte shifts.\n \n (define_split\n-  [(set (match_operand:GPR 0 \"register_operand\")\n-\t(any_shift:GPR (match_operand:GPR 1 \"register_operand\")\n+  [(set (match_operand:GPR 0 \"d_operand\")\n+\t(any_shift:GPR (match_operand:GPR 1 \"d_operand\")\n \t\t       (match_operand:GPR 2 \"const_int_operand\")))]\n   \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[2]) == CONST_INT\n    && INTVAL (operands[2]) > 8\n    && INTVAL (operands[2]) <= 16\"\n   [(set (match_dup 0) (any_shift:GPR (match_dup 1) (const_int 8)))"}, {"sha": "73db02749364921eb10bdb43dfc882fac7eba761", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -76,9 +76,11 @@\n        (ior (match_test \"op == CONST0_RTX (GET_MODE (op))\")\n \t    (match_test \"op == CONST1_RTX (GET_MODE (op))\"))))\n \n-(define_predicate \"fpr_operand\"\n+(define_predicate \"d_operand\"\n   (and (match_code \"reg\")\n-       (match_test \"FP_REG_P (REGNO (op))\")))\n+       (match_test \"TARGET_MIPS16\n+\t\t    ? M16_REG_P (REGNO (op))\n+\t\t    : GP_REG_P (REGNO (op))\")))\n \n (define_predicate \"lo_operand\"\n   (and (match_code \"reg\")"}, {"sha": "8884d71a291527b611ca86320dba0ededa70b686", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -2469,13 +2469,15 @@ generating MIPS16 code.\n A floating-point register (if available).\n \n @item h\n-The @code{hi} register.\n+Formerly the @code{hi} register.  This constraint is no longer supported.\n \n @item l\n-The @code{lo} register.\n+The @code{lo} register.  Use this register to store values that are\n+no bigger than a word.\n \n @item x\n-The @code{hi} and @code{lo} registers.\n+The concatenated @code{hi} and @code{lo} registers.  Use this register\n+to store doubleword values.\n \n @item c\n A register suitable for use in an indirect jump.  This will always be"}, {"sha": "38b4c6fb2219b1ea50ab8182e20cdc60844d98fc", "filename": "gcc/longlong.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -623,12 +623,12 @@ UDItype __umulsidi3 (USItype, USItype);\n #endif /* __m88000__ */\n \n #if defined (__mips__) && W_TYPE_SIZE == 32\n-#define umul_ppmm(w1, w0, u, v) \\\n-  __asm__ (\"multu %2,%3\"\t\t\t\t\t\t\\\n-\t   : \"=l\" ((USItype) (w0)),\t\t\t\t\t\\\n-\t     \"=h\" ((USItype) (w1))\t\t\t\t\t\\\n-\t   : \"d\" ((USItype) (u)),\t\t\t\t\t\\\n-\t     \"d\" ((USItype) (v)))\n+#define umul_ppmm(w1, w0, u, v)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    UDItype __x = (UDItype) (USItype) (u) * (USItype) (v);\t\t\\\n+    (w1) = (USItype) (__x >> 32);\t\t\t\t\t\\\n+    (w0) = (USItype) (__x);\t\t\t\t\t\t\\\n+  } while (0)\n #define UMUL_TIME 10\n #define UDIV_TIME 100\n "}, {"sha": "824355caf63a9e3d39094cdb306bf747c935113c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -1,3 +1,26 @@\n+2008-06-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.dg/torture/mips-hilo-1.c: Delete.\n+\t* gcc.target/mips/pr35232.c: Likewise.\n+\t* gcc.target/mips/fix-vr4130-1.c: Use modulus to create an mfhi.\n+\t* gcc.target/mips/fix-vr4130-3.c: Likewise.\n+\t* gcc.target/mips/int-moves-1.c: New test.\n+\t* gcc.target/mips/int-moves-2.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-1.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-2.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-3.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-4.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-5.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-6.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-7.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-8.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-9.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-10.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-11.c: Likewise.\n+\t* gcc.target/mips/fix-r4000-12.c: Likewise.\n+\t* gcc.target/mips/timode-1.c: Likewise.\n+\t* gcc.target/mips/timode-2.c: Likewise.\n+\n 2008-06-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/pack3.ads: New test."}, {"sha": "b7289666b7c588b4ad8e7902d53573866be2f9c4", "filename": "gcc/testsuite/gcc.dg/torture/mips-hilo-1.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e462a951b6de1354da41ecac9ee796e256a9fa5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e462a951b6de1354da41ecac9ee796e256a9fa5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-1.c?ref=0e462a951b6de1354da41ecac9ee796e256a9fa5", "patch": "@@ -1,73 +0,0 @@\n-/* f1 checks that an mtlo is not moved before an mfhi.  f2 does the same\n-   for an mthi and an mflo.  */\n-/* { dg-do run { target mips*-*-* } } */\n-/* { dg-options \"-mtune=rm7000\" } */\n-\n-extern void abort (void);\n-extern void exit (int);\n-\n-#define DECLARE(TYPE)\t\t\t\t\t\t\t\\\n-  TYPE __attribute__ ((noinline)) __attribute__ ((nomips16))\t\t\\\n-  f1##TYPE (TYPE x1, TYPE x2, TYPE x3)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    TYPE t1, t2;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    asm (\"mult\\t%1,%2\" : \"=h\" (t1) : \"d\" (x1), \"d\" (x2) : \"lo\");\t\\\n-    asm (\"mflo\\t%0\" : \"=r\" (t2) : \"l\" (x3) : \"hi\");\t\t\t\\\n-    return t1 + t2;\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  TYPE __attribute__ ((noinline)) __attribute__ ((nomips16))\t\t\\\n-  f2##TYPE (TYPE x1, TYPE x2, TYPE x3)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    TYPE t1, t2;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    asm (\"mult\\t%1,%2\" : \"=l\" (t1) : \"d\" (x1), \"d\" (x2) : \"hi\");\t\\\n-    asm (\"mfhi\\t%0\" : \"=r\" (t2) : \"h\" (x3) : \"lo\");\t\t\t\\\n-    return t1 + t2;\t\t\t\t\t\t\t\\\n-  }\n-\n-#define TEST(TYPE)\t\t\t\t\t\t\t\\\n-  if (f1##TYPE (1, 2, 10) != 10)\t\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-  if (f2##TYPE (1, 2, 40) != 42)\t\t\t\t\t\\\n-    abort ()\n-\n-typedef char c;\n-typedef signed char sc;\n-typedef unsigned char uc;\n-typedef short s;\n-typedef unsigned short us;\n-typedef int i;\n-typedef unsigned int ui;\n-typedef long long ll;\n-typedef unsigned long long ull;\n-\n-DECLARE (c)\n-DECLARE (sc)\n-DECLARE (uc)\n-DECLARE (s)\n-DECLARE (us)\n-DECLARE (i)\n-DECLARE (ui)\n-#if defined (__mips64)\n-DECLARE (ll)\n-DECLARE (ull)\n-#endif\n-\n-int\n-main ()\n-{\n-  TEST (c);\n-  TEST (sc);\n-  TEST (uc);\n-  TEST (s);\n-  TEST (us);\n-  TEST (i);\n-  TEST (ui);\n-#if defined (__mips64)\n-  TEST (ll);\n-  TEST (ull);\n-#endif\n-  exit (0);\n-}"}, {"sha": "adb32a2eed1317eedbdbaf0d4f1ce038d1ff175d", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-1.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-mips-options \"-march=r4000 -mfix-r4000 -O2 -dp\" } */\n+typedef int int32_t;\n+typedef int uint32_t;\n+int32_t foo (int32_t x, int32_t y) { return x * y; }\n+uint32_t bar (uint32_t x, uint32_t y) { return x * y; }\n+/* { dg-final { scan-assembler-times \"[concat {\\tmult\\t\\$[45],\\$[45][^\\n]+mulsi3_r4000[^\\n]+\\n\\tmflo\\t\\$2\\n}]\" 2 } } */"}, {"sha": "3c217b984cd0f4e924583a4becd6a63b53898e13", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-10.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-10.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,8 @@\n+/* ??? At the moment, lower-subreg.c decomposes the copy of the multiplication\n+   result to $2, which prevents the register allocators from storing the\n+   multiplication result in $2.  */\n+/* { dg-mips-options \"-mips3 -mfix-r4000 -mgp64 -O2 -fno-split-wide-types -dp -EL\" } */\n+typedef unsigned long long uint64_t;\n+typedef unsigned int uint128_t __attribute__((mode(TI)));\n+uint128_t foo (uint64_t x, uint64_t y) { return (uint128_t) x * y; }\n+/* { dg-final { scan-assembler \"[concat {\\tdmultu\\t\\$[45],\\$[45][^\\n]+umulditi3_r4000[^\\n]+\\n\\tmflo\\t\\$2\\n\\tmfhi\\t\\$3\\n}]\" } } */"}, {"sha": "528a30bbddd078b049a20394857129c767225f2a", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-11.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-11.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-mips-options \"-march=r4000 -mfix-r4000 -mgp64 -O2 -dp\" } */\n+typedef long long int64_t;\n+int64_t foo (int64_t x) { return x / 11993; }\n+/* { dg-final { scan-assembler \"[concat {\\tdmult\\t\\$4,\\$[0-9]+[^\\n]+smuldi3_highpart[^\\n]+\\n\\tmfhi\\t\\$[0-9]+\\n}]\" } } */"}, {"sha": "f03a7a0614750d4bc95d0d72d8d5edd524741f42", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-12.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-12.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-mips-options \"-march=r4000 -mfix-r4000 -mgp64 -O2 -dp\" } */\n+typedef unsigned long long uint64_t;\n+uint64_t foo (uint64_t x) { return x / 11993; }\n+/* { dg-final { scan-assembler \"[concat {\\tdmultu\\t\\$4,\\$[0-9]+[^\\n]+umuldi3_highpart[^\\n]+\\n\\tmfhi\\t\\$[0-9]+\\n}]\" } } */"}, {"sha": "038dd5ecd49318f23890cf2ccd47b52ff6a5b77f", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-2.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-mips-options \"-mips1 -mfix-r4000 -O2 -dp -EB\" } */\n+typedef int int32_t;\n+typedef long long int64_t;\n+int32_t foo (int32_t x, int32_t y) { return ((int64_t) x * y) >> 32; }\n+/* ??? A highpart pattern would be a better choice, but we currently\n+   don't use them.  */\n+/* { dg-final { scan-assembler \"[concat {\\tmult\\t\\$[45],\\$[45][^\\n]+mulsidi3_32bit_r4000[^\\n]+\\n\\tmflo\\t\\$3\\n\\tmfhi\\t\\$2\\n}]\" } } */"}, {"sha": "4318943049692c557f345448a89e80aed996c680", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-3.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-3.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-mips-options \"-mips1 -mfix-r4000 -O2 -dp -EB\" } */\n+typedef unsigned int uint32_t;\n+typedef unsigned long long uint64_t;\n+uint32_t foo (uint32_t x, uint32_t y) { return ((uint64_t) x * y) >> 32; }\n+/* ??? A highpart pattern would be a better choice, but we currently\n+   don't use them.  */\n+/* { dg-final { scan-assembler \"[concat {\\tmultu\\t\\$[45],\\$[45][^\\n]+umulsidi3_32bit_r4000[^\\n]+\\n\\tmflo\\t\\$3\\n\\tmfhi\\t\\$2\\n}]\" } } */"}, {"sha": "7acb2374d5a63746c1e87169bf50c927432358fe", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-4.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-4.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,8 @@\n+/* ??? At the moment, lower-subreg.c decomposes the copy of the multiplication\n+   result to $2, which prevents the register allocators from storing the\n+   multiplication result in $2.  */\n+/* { dg-mips-options \"-mips1 -mfix-r4000 -O2 -fno-split-wide-types -dp -EL\" } */\n+typedef int int32_t;\n+typedef long long int64_t;\n+int64_t foo (int32_t x, int32_t y) { return (int64_t) x * y; }\n+/* { dg-final { scan-assembler \"[concat {\\tmult\\t\\$[45],\\$[45][^\\n]+mulsidi3_32bit_r4000[^\\n]+\\n\\tmflo\\t\\$2\\n\\tmfhi\\t\\$3\\n}]\" } } */"}, {"sha": "86ab8a26eea2d76e3260621c5f6a99231a1c7810", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-5.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-5.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,8 @@\n+/* ??? At the moment, lower-subreg.c decomposes the copy of the multiplication\n+   result to $2, which prevents the register allocators from storing the\n+   multiplication result in $2.  */\n+/* { dg-mips-options \"-mips1 -mfix-r4000 -O2 -fno-split-wide-types -dp -EL\" } */\n+typedef unsigned int uint32_t;\n+typedef unsigned long long uint64_t;\n+uint64_t foo (uint32_t x, uint32_t y) { return (uint64_t) x * y; }\n+/* { dg-final { scan-assembler \"[concat {\\tmultu\\t\\$[45],\\$[45][^\\n]+umulsidi3_32bit_r4000[^\\n]+\\n\\tmflo\\t\\$2\\n\\tmfhi\\t\\$3\\n}]\" } } */"}, {"sha": "2c75deddeca195ac227f6ff86229d782a04a95ed", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-6.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-6.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-mips-options \"-march=r4000 -mfix-r4000 -mgp64 -O2 -dp\" } */\n+typedef long long int64_t;\n+typedef unsigned long long uint64_t;\n+int64_t foo (int64_t x, int64_t y) { return x * y; }\n+uint64_t bar (uint64_t x, uint64_t y) { return x * y; }\n+/* { dg-final { scan-assembler-times \"[concat {\\tdmult\\t\\$[45],\\$[45][^\\n]+muldi3_r4000[^\\n]+\\n\\tmflo\\t\\$2\\n}]\" 2 } } */"}, {"sha": "e7b9251ceb4936b1326e41c3f3d9d614a63a4e7e", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-7.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-7.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-mips-options \"-march=r4000 -mfix-r4000 -O2 -mgp64 -dp -EB\" } */\n+typedef long long int64_t;\n+typedef int int128_t __attribute__((mode(TI)));\n+int64_t foo (int64_t x, int64_t y) { return ((int128_t) x * y) >> 64; }\n+/* ??? A highpart pattern would be a better choice, but we currently\n+   don't use them.  */\n+/* { dg-final { scan-assembler \"[concat {\\tdmult\\t\\$[45],\\$[45][^\\n]+mulditi3[^\\n]+\\n\\tmflo\\t\\$3\\n\\tmfhi\\t\\$2\\n}]\" } } */"}, {"sha": "5089b99e08dcb8d920c5eb422c8041857325d2a5", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-8.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-8.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-mips-options \"-march=r4000 -mfix-r4000 -O2 -mgp64 -dp -EB\" } */\n+typedef unsigned long long uint64_t;\n+typedef unsigned int uint128_t __attribute__((mode(TI)));\n+uint64_t foo (uint64_t x, uint64_t y) { return ((uint128_t) x * y) >> 64; }\n+/* ??? A highpart pattern would be a better choice, but we currently\n+   don't use them.  */\n+/* { dg-final { scan-assembler \"[concat {\\tdmultu\\t\\$[45],\\$[45][^\\n]+umulditi3[^\\n]+\\n\\tmflo\\t\\$3\\n\\tmfhi\\t\\$2\\n}]\" } } */"}, {"sha": "55183396f07cb3be2c012244860a8e79a6e98e79", "filename": "gcc/testsuite/gcc.target/mips/fix-r4000-9.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-r4000-9.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,8 @@\n+/* ??? At the moment, lower-subreg.c decomposes the copy of the multiplication\n+   result to $2, which prevents the register allocators from storing the\n+   multiplication result in $2.  */\n+/* { dg-mips-options \"-mips3 -mfix-r4000 -mgp64 -O2 -fno-split-wide-types -dp -EL\" } */\n+typedef long long int64_t;\n+typedef int int128_t __attribute__((mode(TI)));\n+int128_t foo (int64_t x, int64_t y) { return (int128_t) x * y; }\n+/* { dg-final { scan-assembler \"[concat {\\tdmult\\t\\$[45],\\$[45][^\\n]+mulditi3_r4000[^\\n]+\\n\\tmflo\\t\\$2\\n\\tmfhi\\t\\$3\\n}]\" } } */"}, {"sha": "48840accd62909c921b491c6c82ab8ca9b638ad8", "filename": "gcc/testsuite/gcc.target/mips/fix-vr4130-1.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-vr4130-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-vr4130-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-vr4130-1.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -1,4 +1,8 @@\n /* { dg-do compile } */\n /* { dg-mips-options \"-march=vr4130 -mfix-vr4130\" } */\n-NOMIPS16 int foo (void) { int r; asm (\"# foo\" : \"=h\" (r)); return r; }\n+NOMIPS16 unsigned int\n+foo (unsigned int x, unsigned int y)\n+{\n+  return x % y;\n+}\n /* { dg-final { scan-assembler \"\\tmacchi\\t\" } } */"}, {"sha": "5cc32cafe43e42c38591f155bf19637fc2d7c4cd", "filename": "gcc/testsuite/gcc.target/mips/fix-vr4130-3.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-vr4130-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-vr4130-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffix-vr4130-3.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -1,10 +1,8 @@\n /* { dg-do compile } */\n /* { dg-mips-options \"-march=vr4130 -mgp64 -mfix-vr4130\" } */\n-NOMIPS16 long long\n-foo (void)\n+NOMIPS16 unsigned long long\n+foo (unsigned long long x, unsigned long long y)\n {\n-  long long r;\n-  asm (\"# foo\" : \"=h\" (r));\n-  return r;\n+  return x % y;\n }\n /* { dg-final { scan-assembler \"\\tdmacchi\\t\" } } */"}, {"sha": "62e659a93fe98c01777fa8f86e276bd5a8f15b79", "filename": "gcc/testsuite/gcc.target/mips/int-moves-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fint-moves-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fint-moves-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fint-moves-1.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile { target mips16_attribute } } */\n+/* { dg-mips-options \"-mgp64 -msoft-float -O2 -EL\" } */\n+/* { dg-add-options mips16_attribute } */\n+\n+typedef unsigned uint128_t __attribute__((mode(TI)));\n+\n+extern uint128_t g[16];\n+extern unsigned char gstuff[0x10000];\n+\n+NOMIPS16 uint128_t\n+foo (uint128_t i1, uint128_t i2, uint128_t i3, uint128_t i4,\n+     uint128_t *x, unsigned char *lstuff)\n+{\n+  g[0] = i1;\n+  g[1] = i2;\n+  g[2] = i3;\n+  g[3] = i4;\n+  x[0] = x[4];\n+  x[1] = 0;\n+  x[2] = ((uint128_t) 0x123456789abcdefULL << 64) | 0xaabbccddeeff1122ULL;\n+  x[3] = g[4];\n+  x[4] = *(uint128_t *) (lstuff + 0x7fff);\n+  return *(uint128_t *) (gstuff + 0x7fff);\n+}\n+\n+MIPS16 uint128_t\n+bar (uint128_t i1, uint128_t i2, uint128_t i3, uint128_t i4,\n+     uint128_t *x, unsigned char *lstuff)\n+{\n+  g[0] = i1;\n+  g[1] = i2;\n+  g[2] = i3;\n+  g[3] = i4;\n+  x[0] = x[4];\n+  x[1] = 0;\n+  x[2] = ((uint128_t) 0x123456789abcdefULL << 64) | 0xaabbccddeeff1122ULL;\n+  x[3] = g[4];\n+  x[4] = *(uint128_t *) (lstuff + 0x7fff);\n+  return *(uint128_t *) (gstuff + 0x7fff);\n+}"}, {"sha": "325bfceb029d29d84815d19faa1d91c3960caaeb", "filename": "gcc/testsuite/gcc.target/mips/int-moves-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fint-moves-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fint-moves-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fint-moves-2.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile { target mips16_attribute } } */\n+/* { dg-mips-options \"-mgp64 -msoft-float -O2 -EB\" } */\n+/* { dg-add-options mips16_attribute } */\n+\n+typedef unsigned uint128_t __attribute__((mode(TI)));\n+\n+extern uint128_t g[16];\n+extern unsigned char gstuff[0x10000];\n+\n+NOMIPS16 uint128_t\n+foo (uint128_t i1, uint128_t i2, uint128_t i3, uint128_t i4,\n+     uint128_t *x, unsigned char *lstuff)\n+{\n+  g[0] = i1;\n+  g[1] = i2;\n+  g[2] = i3;\n+  g[3] = i4;\n+  x[0] = x[4];\n+  x[1] = 0;\n+  x[2] = ((uint128_t) 0x123456789abcdefULL << 64) | 0xaabbccddeeff1122ULL;\n+  x[3] = g[4];\n+  x[4] = *(uint128_t *) (lstuff + 0x7fff);\n+  return *(uint128_t *) (gstuff + 0x7fff);\n+}\n+\n+MIPS16 uint128_t\n+bar (uint128_t i1, uint128_t i2, uint128_t i3, uint128_t i4,\n+     uint128_t *x, unsigned char *lstuff)\n+{\n+  g[0] = i1;\n+  g[1] = i2;\n+  g[2] = i3;\n+  g[3] = i4;\n+  x[0] = x[4];\n+  x[1] = 0;\n+  x[2] = ((uint128_t) 0x123456789abcdefULL << 64) | 0xaabbccddeeff1122ULL;\n+  x[3] = g[4];\n+  x[4] = *(uint128_t *) (lstuff + 0x7fff);\n+  return *(uint128_t *) (gstuff + 0x7fff);\n+}"}, {"sha": "c0e0649b52ea645d04e4cecb9f9ee6354b417b7e", "filename": "gcc/testsuite/gcc.target/mips/pr35232.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e462a951b6de1354da41ecac9ee796e256a9fa5/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr35232.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e462a951b6de1354da41ecac9ee796e256a9fa5/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr35232.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr35232.c?ref=0e462a951b6de1354da41ecac9ee796e256a9fa5", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-mips-options \"-O\" } */\n-\n-NOMIPS16 unsigned int\n-f1 (unsigned long long x)\n-{\n-  unsigned int r;\n-  asm (\"# %0\" : \"=a\" (r) : \"0\" (x));\n-  asm (\"# %0\" : \"=h\" (r) : \"0\" (r));\n-  return r;\n-}\n-\n-int\n-main (void)\n-{\n-  return f1 (4) != 4;\n-}"}, {"sha": "8f07db985590aa6409043f40cc865eba966c625b", "filename": "gcc/testsuite/gcc.target/mips/timode-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ftimode-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ftimode-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ftimode-1.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-mips-options \"-mgp64\" } */\n+typedef int int128_t __attribute__((mode(TI)));\n+typedef unsigned int uint128_t __attribute__((mode(TI)));\n+\n+#define UINT128_CONST(A, B) \\\n+  (((uint128_t) (0x ## A ## ULL) << 64) | (0x ## B ## ULL))\n+\n+volatile uint128_t a = UINT128_CONST (1111111111111111, a222222222222222);\n+volatile uint128_t b = UINT128_CONST (0000000000000005, 0000000000000003);\n+volatile uint128_t c = UINT128_CONST (5dddddddddddddde, e666666666666666);\n+volatile uint128_t d = UINT128_CONST (e612340000000000, 5000000000234500);\n+volatile uint128_t e = UINT128_CONST (43f011dddddddddf, 366666666689ab66);\n+volatile uint128_t f = UINT128_CONST (4210100000000000, 1000000000010100);\n+volatile uint128_t g = UINT128_CONST (a5e225dddddddddf, 6666666666aaee66);\n+volatile uint128_t h = UINT128_CONST (e7f235dddddddddf, 7666666666abef66);\n+volatile uint128_t i = UINT128_CONST (5e225dddddddddf6, 666666666aaee660);\n+volatile uint128_t j = UINT128_CONST (0a5e225ddddddddd, f6666666666aaee6);\n+volatile uint128_t k = UINT128_CONST (fa5e225ddddddddd, f6666666666aaee6);\n+\n+volatile int amount = 4;\n+\n+volatile uint128_t result;\n+\n+int\n+main (void)\n+{\n+  result = a * b;\n+  if (result != c)\n+    return 1;\n+\n+  result = c + d;\n+  if (result != e)\n+    return 1;\n+\n+  result = e - d;\n+  if (result != c)\n+    return 1;\n+\n+  result = d & e;\n+  if (result != f)\n+    return 1;\n+\n+  result = d ^ e;\n+  if (result != g)\n+    return 1;\n+\n+  result = d | e;\n+  if (result != h)\n+    return 1;\n+\n+  result = g << amount;\n+  if (result != i)\n+    return 1;\n+\n+  result = g >> amount;\n+  if (result != j)\n+    return 1;\n+\n+  result = (int128_t) g >> amount;\n+  if (result != k)\n+    return 1;\n+\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-not \"\\tjal\" } } */"}, {"sha": "025dc21810a2dad0f4cd3f9f6717218c141aa5fd", "filename": "gcc/testsuite/gcc.target/mips/timode-2.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ftimode-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21dfc6dc74ab21fe6d5dc487c20cb121cacc7528/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ftimode-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ftimode-2.c?ref=21dfc6dc74ab21fe6d5dc487c20cb121cacc7528", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run { target mips64 } } */\n+typedef int int128_t __attribute__((mode(TI)));\n+typedef unsigned int uint128_t __attribute__((mode(TI)));\n+\n+#define UINT128_CONST(A, B) \\\n+  (((uint128_t) (0x ## A ## ULL) << 64) | (0x ## B ## ULL))\n+\n+volatile uint128_t a = UINT128_CONST (1111111111111111, a222222222222222);\n+volatile uint128_t b = UINT128_CONST (0000000000000005, 0000000000000003);\n+volatile uint128_t c = UINT128_CONST (5dddddddddddddde, e666666666666666);\n+volatile uint128_t d = UINT128_CONST (e612340000000000, 5000000000234500);\n+volatile uint128_t e = UINT128_CONST (43f011dddddddddf, 366666666689ab66);\n+volatile uint128_t f = UINT128_CONST (4210100000000000, 1000000000010100);\n+volatile uint128_t g = UINT128_CONST (a5e225dddddddddf, 6666666666aaee66);\n+volatile uint128_t h = UINT128_CONST (e7f235dddddddddf, 7666666666abef66);\n+volatile uint128_t i = UINT128_CONST (5e225dddddddddf6, 666666666aaee660);\n+volatile uint128_t j = UINT128_CONST (0a5e225ddddddddd, f6666666666aaee6);\n+volatile uint128_t k = UINT128_CONST (fa5e225ddddddddd, f6666666666aaee6);\n+\n+volatile int amount = 4;\n+\n+volatile uint128_t result;\n+\n+int\n+main (void)\n+{\n+  result = a * b;\n+  if (result != c)\n+    return 1;\n+\n+  result = c + d;\n+  if (result != e)\n+    return 1;\n+\n+  result = e - d;\n+  if (result != c)\n+    return 1;\n+\n+  result = d & e;\n+  if (result != f)\n+    return 1;\n+\n+  result = d ^ e;\n+  if (result != g)\n+    return 1;\n+\n+  result = d | e;\n+  if (result != h)\n+    return 1;\n+\n+  result = g << amount;\n+  if (result != i)\n+    return 1;\n+\n+  result = g >> amount;\n+  if (result != j)\n+    return 1;\n+\n+  result = (int128_t) g >> amount;\n+  if (result != k)\n+    return 1;\n+\n+  return 0;\n+}"}]}