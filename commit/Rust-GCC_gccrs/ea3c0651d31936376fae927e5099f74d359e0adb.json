{"sha": "ea3c0651d31936376fae927e5099f74d359e0adb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEzYzA2NTFkMzE5MzYzNzZmYWU5MjdlNTA5OWY3NGQzNTllMGFkYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:35:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:35:07Z"}, "message": "[multiple changes]\n\n2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add entries in table Canonical_Aspects for aspects\n\tRefined_Depends and Refined_Global.\n\t* aspects.ads: Add entries in tables Aspect_Id, Aspect_Argument,\n\tAspect_Names, Aspect_Declay, Aspect_On_Body_Or_Stub_OK for\n\taspects Refined_Depends and Refined_Global.\n\t* einfo.adb (Contract): Subprogram bodies are now valid owners\n\tof contracts.\n\t(Set_Contract): Subprogram bodies are now valid\n\towners of contracts.\n\t(Write_Field24_Name): Output the contract\n\tattribute for subprogram bodies.\n\t* exp_ch6.adb (Expand_Subprogram_Contract): New routine.\n\t* exp_ch6.ads (Expand_Subprogram_Contract): New routine.\n\t* par-prag.adb: Pragmas Refined_Depends and Refined_Global do\n\tnot require any special processing by the parser.\n\t* sem_ch3.adb (Adjust_D): Renamed to Adjust_Decl.\n\t(Analyze_Declarations): Code reformatting. Analyze the contract\n\tof a subprogram body at the end of the declarative region.\n\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body):\n\tSubprogram bodies can now have contracts.  Use\n\tExpand_Subprogram_Contract to handle the various contract\n\tassertions.\n\t(Analyze_Subprogram_Body_Contract): New null routine.\n\t(Analyze_Subprogram_Body_Helper): Subprogram bodies can now have\n\tcontracts.  Use Expand_Subprogram_Contract to handle the various\n\tcontract assertions.\n\t(Analyze_Subprogram_Contract): Add local\n\tvariable Nam. Update the call to Analyze_PPC_In_Decl_Part. Capture\n\tthe pragma name in Nam.\n\t(Process_PPCs): Removed.\n\t* sem_ch6.ads (Analyze_Subprogram_Body_Contract): New routine.\n\t(Analyze_Subprogram_Contract): Update the comment on usage.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add null\n\timplementations for aspects Refined_Depends and Refined_Global.\n\t(Check_Aspect_At_Freeze_Point): Aspects Refined_Depends and\n\tRefined_Global do not need to be checked at the freeze point.\n\t* sem_prag.adb: Add entries in table Sig_Flags\n\tfor pragmas Refined_Depends and Refined_Global.\n\t(Analyze_Contract_Cases_In_Decl_Part): Add local\n\tvariable Restore. Use Restore to pop the scope.\n\t(Analyze_Depends_In_Decl_Part): Add local variable Restore. Use\n\tRestore to pop the scope.\n\t(Analyze_Global_In_Decl_List): Add local variable Restore. Use Restore\n\tto pop the scope.\n\t(Analyze_PPC_In_Decl_Part): Renamed to\n\tAnalyze_Pre_Post_Condition_In_Decl_Part.\n\t(Analyze_Pragma):\n\tAdd null implementations for pragmas Refined_Depends and\n\tRefined_Global. Refined_Pre and Refined_Post are now\n\thandled by routine Analyze_Refined_Pre_Post_Condition\n\texclusively.\n\t(Analyze_Refined_Depends_In_Decl_Part): New\n\tnull routine.\n\t(Analyze_Refined_Global_In_Decl_Part):\n\tNew null routine.\n\t(Analyze_Refined_Pre_Post):\n\tRenamed to Analyze_Refined_Pre_Post_Condition.\n\t(Analyze_Refined_Pre_Post_Condition): Analyze the boolean\n\texpression.\n\t(Check_Precondition_Postcondition): Update the call\n\tto Analyze_PPC_In_Decl_Part.\n\t* sem_prag.ads: Add entries in table\n\tPragma_On_Body_Or_Stub_OK for pragmas Refined_Depends\n\tand Refined_Global.\n\t(Analyze_PPC_In_Decl_Part): Renamed\n\tto Analyze_Pre_Post_Condition_In_Decl_Part.  Update the\n\tcomment on usage.\n\t(Analyze_Refined_Depends_In_Decl_Part): New routine.\n\t(Analyze_Refined_Global_In_Decl_Part): New routine.\n\t(Analyze_Test_Case_In_Decl_Part): Update the comment on usage.\n\t* sem_util.adb (Add_Contract_Item): Rename formal Item to Prag\n\tand update all occurrences.  Subprogram body contracts can now\n\tcontain pragmas Refined_Depends and Refined_Global.\n\t* sem_util.ads (Add_Contract_Item): Rename formal Item to\n\tPrag. Update the comment on usage.\n\t* sinfo.ads: Update the comment on structure and usage of\n\tN_Contract.\n\t* snames.ads-tmpl: Add new predefined names for Refined_Depends\n\tand Refined_Global. Add entries in table Pragma_Id for\n\tRefined_Depends and Refined_Global.\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* types.ads: Minor reformatting.\n\nFrom-SVN: r203365", "tree": {"sha": "5033b93dc220ac16f90eeba1b770e74614c9d3e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5033b93dc220ac16f90eeba1b770e74614c9d3e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea3c0651d31936376fae927e5099f74d359e0adb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea3c0651d31936376fae927e5099f74d359e0adb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea3c0651d31936376fae927e5099f74d359e0adb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea3c0651d31936376fae927e5099f74d359e0adb/comments", "author": null, "committer": null, "parents": [{"sha": "c76bf0bffda065a7364340bf64a9584ec250af7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c76bf0bffda065a7364340bf64a9584ec250af7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c76bf0bffda065a7364340bf64a9584ec250af7a"}], "stats": {"total": 2829, "additions": 1598, "deletions": 1231}, "files": [{"sha": "ce65c67ceaa44d7206173411077420598e2e3551", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -1,3 +1,90 @@\n+2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add entries in table Canonical_Aspects for aspects\n+\tRefined_Depends and Refined_Global.\n+\t* aspects.ads: Add entries in tables Aspect_Id, Aspect_Argument,\n+\tAspect_Names, Aspect_Declay, Aspect_On_Body_Or_Stub_OK for\n+\taspects Refined_Depends and Refined_Global.\n+\t* einfo.adb (Contract): Subprogram bodies are now valid owners\n+\tof contracts.\n+\t(Set_Contract): Subprogram bodies are now valid\n+\towners of contracts.\n+\t(Write_Field24_Name): Output the contract\n+\tattribute for subprogram bodies.\n+\t* exp_ch6.adb (Expand_Subprogram_Contract): New routine.\n+\t* exp_ch6.ads (Expand_Subprogram_Contract): New routine.\n+\t* par-prag.adb: Pragmas Refined_Depends and Refined_Global do\n+\tnot require any special processing by the parser.\n+\t* sem_ch3.adb (Adjust_D): Renamed to Adjust_Decl.\n+\t(Analyze_Declarations): Code reformatting. Analyze the contract\n+\tof a subprogram body at the end of the declarative region.\n+\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body):\n+\tSubprogram bodies can now have contracts.  Use\n+\tExpand_Subprogram_Contract to handle the various contract\n+\tassertions.\n+\t(Analyze_Subprogram_Body_Contract): New null routine.\n+\t(Analyze_Subprogram_Body_Helper): Subprogram bodies can now have\n+\tcontracts.  Use Expand_Subprogram_Contract to handle the various\n+\tcontract assertions.\n+\t(Analyze_Subprogram_Contract): Add local\n+\tvariable Nam. Update the call to Analyze_PPC_In_Decl_Part. Capture\n+\tthe pragma name in Nam.\n+\t(Process_PPCs): Removed.\n+\t* sem_ch6.ads (Analyze_Subprogram_Body_Contract): New routine.\n+\t(Analyze_Subprogram_Contract): Update the comment on usage.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add null\n+\timplementations for aspects Refined_Depends and Refined_Global.\n+\t(Check_Aspect_At_Freeze_Point): Aspects Refined_Depends and\n+\tRefined_Global do not need to be checked at the freeze point.\n+\t* sem_prag.adb: Add entries in table Sig_Flags\n+\tfor pragmas Refined_Depends and Refined_Global.\n+\t(Analyze_Contract_Cases_In_Decl_Part): Add local\n+\tvariable Restore. Use Restore to pop the scope.\n+\t(Analyze_Depends_In_Decl_Part): Add local variable Restore. Use\n+\tRestore to pop the scope.\n+\t(Analyze_Global_In_Decl_List): Add local variable Restore. Use Restore\n+\tto pop the scope.\n+\t(Analyze_PPC_In_Decl_Part): Renamed to\n+\tAnalyze_Pre_Post_Condition_In_Decl_Part.\n+\t(Analyze_Pragma):\n+\tAdd null implementations for pragmas Refined_Depends and\n+\tRefined_Global. Refined_Pre and Refined_Post are now\n+\thandled by routine Analyze_Refined_Pre_Post_Condition\n+\texclusively.\n+\t(Analyze_Refined_Depends_In_Decl_Part): New\n+\tnull routine.\n+\t(Analyze_Refined_Global_In_Decl_Part):\n+\tNew null routine.\n+\t(Analyze_Refined_Pre_Post):\n+\tRenamed to Analyze_Refined_Pre_Post_Condition.\n+\t(Analyze_Refined_Pre_Post_Condition): Analyze the boolean\n+\texpression.\n+\t(Check_Precondition_Postcondition): Update the call\n+\tto Analyze_PPC_In_Decl_Part.\n+\t* sem_prag.ads: Add entries in table\n+\tPragma_On_Body_Or_Stub_OK for pragmas Refined_Depends\n+\tand Refined_Global.\n+\t(Analyze_PPC_In_Decl_Part): Renamed\n+\tto Analyze_Pre_Post_Condition_In_Decl_Part.  Update the\n+\tcomment on usage.\n+\t(Analyze_Refined_Depends_In_Decl_Part): New routine.\n+\t(Analyze_Refined_Global_In_Decl_Part): New routine.\n+\t(Analyze_Test_Case_In_Decl_Part): Update the comment on usage.\n+\t* sem_util.adb (Add_Contract_Item): Rename formal Item to Prag\n+\tand update all occurrences.  Subprogram body contracts can now\n+\tcontain pragmas Refined_Depends and Refined_Global.\n+\t* sem_util.ads (Add_Contract_Item): Rename formal Item to\n+\tPrag. Update the comment on usage.\n+\t* sinfo.ads: Update the comment on structure and usage of\n+\tN_Contract.\n+\t* snames.ads-tmpl: Add new predefined names for Refined_Depends\n+\tand Refined_Global. Add entries in table Pragma_Id for\n+\tRefined_Depends and Refined_Global.\n+\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* types.ads: Minor reformatting.\n+\n 2013-10-10  Thomas Quinot  <quinot@adacore.com>\n \n \t* s-taprop-posix.adb: Add missing comment."}, {"sha": "0f21ad48b3757dfcb1ee9c36cb868a5bfd3a9222", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -466,6 +466,8 @@ package body Aspects is\n     Aspect_Pure_05                      => Aspect_Pure_05,\n     Aspect_Pure_12                      => Aspect_Pure_12,\n     Aspect_Pure_Function                => Aspect_Pure_Function,\n+    Aspect_Refined_Depends              => Aspect_Refined_Depends,\n+    Aspect_Refined_Global               => Aspect_Refined_Global,\n     Aspect_Refined_Post                 => Aspect_Refined_Post,\n     Aspect_Refined_Pre                  => Aspect_Refined_Pre,\n     Aspect_Remote_Access_Type           => Aspect_Remote_Access_Type,"}, {"sha": "50ac1aa58cb72461365e284e39b5f706d3ece103", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -111,6 +111,8 @@ package Aspects is\n       Aspect_Predicate,                     -- GNAT\n       Aspect_Priority,\n       Aspect_Read,\n+      Aspect_Refined_Depends,               -- GNAT\n+      Aspect_Refined_Global,                -- GNAT\n       Aspect_Refined_Post,                  -- GNAT\n       Aspect_Refined_Pre,                   -- GNAT\n       Aspect_Relative_Deadline,\n@@ -321,6 +323,8 @@ package Aspects is\n       Aspect_Predicate               => Expression,\n       Aspect_Priority                => Expression,\n       Aspect_Read                    => Name,\n+      Aspect_Refined_Depends         => Expression,\n+      Aspect_Refined_Global          => Expression,\n       Aspect_Refined_Post            => Expression,\n       Aspect_Refined_Pre             => Expression,\n       Aspect_Relative_Deadline       => Expression,\n@@ -419,6 +423,8 @@ package Aspects is\n       Aspect_Pure_12                      => Name_Pure_12,\n       Aspect_Pure_Function                => Name_Pure_Function,\n       Aspect_Read                         => Name_Read,\n+      Aspect_Refined_Depends              => Name_Refined_Depends,\n+      Aspect_Refined_Global               => Name_Refined_Global,\n       Aspect_Refined_Post                 => Name_Refined_Post,\n       Aspect_Refined_Pre                  => Name_Refined_Pre,\n       Aspect_Relative_Deadline            => Name_Relative_Deadline,\n@@ -612,6 +618,8 @@ package Aspects is\n       Aspect_Pure_12                      => Always_Delay,\n       Aspect_Pure_Function                => Always_Delay,\n       Aspect_Read                         => Always_Delay,\n+      Aspect_Refined_Depends              => Always_Delay,\n+      Aspect_Refined_Global               => Always_Delay,\n       Aspect_Relative_Deadline            => Always_Delay,\n       Aspect_Remote_Access_Type           => Always_Delay,\n       Aspect_Remote_Call_Interface        => Always_Delay,\n@@ -703,7 +711,9 @@ package Aspects is\n    --  Sem_Prag if the aspects below are implemented by a pragma.\n \n    Aspect_On_Body_Or_Stub_OK : constant array (Aspect_Id) of Boolean :=\n-     (Aspect_Refined_Post                 => True,\n+     (Aspect_Refined_Depends              => True,\n+      Aspect_Refined_Global               => True,\n+      Aspect_Refined_Post                 => True,\n       Aspect_Refined_Pre                  => True,\n       Aspect_SPARK_Mode                   => True,\n       Aspect_Warnings                     => True,"}, {"sha": "fb53f1bb8417b35f97b45943bfab12b3b98a7c16", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -1065,7 +1065,7 @@ package body Einfo is\n    function Contract (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Entry, E_Entry_Family)\n+        (Ekind_In (Id, E_Entry, E_Entry_Family, E_Subprogram_Body)\n           or else Is_Subprogram (Id)\n           or else Is_Generic_Subprogram (Id));\n       return Node24 (Id);\n@@ -3651,7 +3651,7 @@ package body Einfo is\n    procedure Set_Contract (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Entry, E_Entry_Family, E_Void)\n+        (Ekind_In (Id, E_Entry, E_Entry_Family, E_Subprogram_Body, E_Void)\n           or else Is_Subprogram (Id)\n           or else Is_Generic_Subprogram (Id));\n       Set_Node24 (Id, V);\n@@ -9012,10 +9012,15 @@ package body Einfo is\n \n          when E_Entry                                      |\n               E_Entry_Family                               |\n+              E_Subprogram_Body                            |\n               Subprogram_Kind                              |\n               Generic_Subprogram_Kind                      =>\n             Write_Str (\"Contract\");\n \n+            --  The Subprogram_Kind and Generic_Subrpogram_Kind entries\n+            --  here are odd, since the assertions for [Set_]Contract do not\n+            --  allow these possibilities ???\n+\n          when others                                       =>\n             Write_Str (\"Field24???\");\n       end case;"}, {"sha": "be89e27dca60eb062dc64a96a1b7fac67fff4338", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1044, "deletions": 0, "changes": 1044, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -8488,6 +8488,1050 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Simple_Function_Return;\n \n+   --------------------------------\n+   -- Expand_Subprogram_Contract --\n+   --------------------------------\n+\n+   procedure Expand_Subprogram_Contract\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id)\n+   is\n+      procedure Add_Invariant_And_Predicate_Checks\n+        (Subp_Id : Entity_Id;\n+         Stmts   : in out List_Id;\n+         Result  : out Node_Id);\n+      --  Process the result of function Subp_Id (if applicable) and all its\n+      --  formals. Add invariant and predicate checks where applicable. The\n+      --  routine appends all the checks to list Stmts. If Subp_Id denotes a\n+      --  function, Result contains the entity of parameter _Result, to be\n+      --  used in the creation of procedure _Postconditions.\n+\n+      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id);\n+      --  Append a node to a list. If there is no list, create a new one. When\n+      --  the item denotes a pragma, it is added to the list only when it is\n+      --  enabled.\n+\n+      procedure Build_Postconditions_Procedure\n+        (Subp_Id : Entity_Id;\n+         Stmts   : List_Id;\n+         Result  : Entity_Id);\n+      --  Create the body of procedure _Postconditions which handles various\n+      --  assertion actions on exit from subprogram Subp_Id. Stmts is the list\n+      --  of statements to be checked on exit. Parameter Result is the entity\n+      --  of parameter _Result when Subp_Id denotes a function.\n+\n+      function Build_Pragma_Check_Equivalent\n+        (Prag     : Node_Id;\n+         Subp_Id  : Entity_Id := Empty;\n+         Inher_Id : Entity_Id := Empty) return Node_Id;\n+      --  Transform a [refined] pre- or postcondition denoted by Prag into an\n+      --  equivalent pragma Check. When the pre- or postcondition is inherited,\n+      --  the routine corrects the references of all formals of Inher_Id to\n+      --  point to the formals of Subp_Id.\n+\n+      procedure Collect_Body_Postconditions (Stmts : in out List_Id);\n+      --  Process all postconditions found in the declarations of the body. The\n+      --  routine appends the pragma Check equivalents to list Stmts.\n+\n+      procedure Collect_Spec_Postconditions\n+        (Subp_Id : Entity_Id;\n+         Stmts   : in out List_Id);\n+      --  Process all [inherited] postconditions of subprogram spec Subp_Id.\n+      --  The routine appends the pragma Check equivalents to list Stmts.\n+\n+      procedure Collect_Spec_Preconditions (Subp_Id : Entity_Id);\n+      --  Process all [inherited] preconditions of subprogram spec Subp_Id. The\n+      --  routine prepends the pragma Check equivalents to the declarations of\n+      --  the body.\n+\n+      procedure Prepend_To_Declarations (Item : Node_Id);\n+      --  Prepend a single item to the declarations of the subprogram body\n+\n+      procedure Process_Contract_Cases\n+        (Subp_Id : Entity_Id;\n+         Stmts   : in out List_Id);\n+      --  Process pragma Contract_Cases of subprogram spec Subp_Id. The routine\n+      --  appends the expanded code to list Stmts.\n+\n+      ----------------------------------------\n+      -- Add_Invariant_And_Predicate_Checks --\n+      ----------------------------------------\n+\n+      procedure Add_Invariant_And_Predicate_Checks\n+        (Subp_Id : Entity_Id;\n+         Stmts   : in out List_Id;\n+         Result  : out Node_Id)\n+      is\n+         procedure Add_Invariant_Access_Checks (Id : Entity_Id);\n+         --  Id denotes the return value of a function or a formal parameter.\n+         --  Add an invariant check if the type of Id is access to a type with\n+         --  invariants. The routine appends the generated code to Stmts.\n+\n+         function Invariant_Checks_OK (Typ : Entity_Id) return Boolean;\n+         --  Determine whether type Typ can benefit from invariant checks. To\n+         --  qualify, the type must have a non-null invariant procedure and\n+         --  subprogram Subp_Id must appear visible from the point of view of\n+         --  the type.\n+\n+         function Predicate_Checks_OK (Typ : Entity_Id) return Boolean;\n+         --  Determine whether type Typ can benefit from predicate checks. To\n+         --  qualify, the type must have at least one checked predicate.\n+\n+         ---------------------------------\n+         -- Add_Invariant_Access_Checks --\n+         ---------------------------------\n+\n+         procedure Add_Invariant_Access_Checks (Id : Entity_Id) is\n+            Loc : constant Source_Ptr := Sloc (N);\n+            Ref : Node_Id;\n+            Typ : Entity_Id;\n+\n+         begin\n+            Typ := Etype (Id);\n+\n+            if Is_Access_Type (Typ) and then not Is_Access_Constant (Typ) then\n+               Typ := Designated_Type (Typ);\n+\n+               if Invariant_Checks_OK (Typ) then\n+                  Ref :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix => New_Occurrence_Of (Id, Loc));\n+                  Set_Etype (Ref, Typ);\n+\n+                  --  Generate:\n+                  --    if <Id> /= null then\n+                  --       <invariant_call (<Ref>)>\n+                  --    end if;\n+\n+                  Append_Enabled_Item\n+                    (Item =>\n+                       Make_If_Statement (Loc,\n+                         Condition =>\n+                           Make_Op_Ne (Loc,\n+                             Left_Opnd  => New_Occurrence_Of (Id, Loc),\n+                             Right_Opnd => Make_Null (Loc)),\n+                         Then_Statements => New_List (\n+                           Make_Invariant_Call (Ref))),\n+                     List => Stmts);\n+               end if;\n+            end if;\n+         end Add_Invariant_Access_Checks;\n+\n+         -------------------------\n+         -- Invariant_Checks_OK --\n+         -------------------------\n+\n+         function Invariant_Checks_OK (Typ : Entity_Id) return Boolean is\n+            function Has_Null_Body (Proc_Id : Entity_Id) return Boolean;\n+            --  Determine whether the body of procedure Proc_Id contains a sole\n+            --  null statement, possibly followed by an optional return.\n+\n+            function Has_Public_Visibility_Of_Subprogram return Boolean;\n+            --  Determine whether type Typ has public visibility of subprogram\n+            --  Subp_Id.\n+\n+            -------------------\n+            -- Has_Null_Body --\n+            -------------------\n+\n+            function Has_Null_Body (Proc_Id : Entity_Id) return Boolean is\n+               Body_Id : Entity_Id;\n+               Decl    : Node_Id;\n+               Spec    : Node_Id;\n+               Stmt1   : Node_Id;\n+               Stmt2   : Node_Id;\n+\n+            begin\n+               Spec := Parent (Proc_Id);\n+               Decl := Parent (Spec);\n+\n+               --  Retrieve the entity of the invariant procedure body\n+\n+               if Nkind (Spec) = N_Procedure_Specification\n+                 and then Nkind (Decl) = N_Subprogram_Declaration\n+               then\n+                  Body_Id := Corresponding_Body (Decl);\n+\n+               --  The body acts as a spec\n+\n+               else\n+                  Body_Id := Proc_Id;\n+               end if;\n+\n+               --  The body will be generated later\n+\n+               if No (Body_Id) then\n+                  return False;\n+               end if;\n+\n+               Spec := Parent (Body_Id);\n+               Decl := Parent (Spec);\n+\n+               pragma Assert\n+                 (Nkind (Spec) = N_Procedure_Specification\n+                   and then Nkind (Decl) = N_Subprogram_Body);\n+\n+               Stmt1 := First (Statements (Handled_Statement_Sequence (Decl)));\n+\n+               --  Look for a null statement followed by an optional return\n+               --  statement.\n+\n+               if Nkind (Stmt1) = N_Null_Statement then\n+                  Stmt2 := Next (Stmt1);\n+\n+                  if Present (Stmt2) then\n+                     return Nkind (Stmt2) = N_Simple_Return_Statement;\n+                  else\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               return False;\n+            end Has_Null_Body;\n+\n+            -----------------------------------------\n+            -- Has_Public_Visibility_Of_Subprogram --\n+            -----------------------------------------\n+\n+            function Has_Public_Visibility_Of_Subprogram return Boolean is\n+               Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n+               Vis_Decls : constant List_Id :=\n+                             Visible_Declarations (Specification\n+                               (Unit_Declaration_Node (Scope (Typ))));\n+            begin\n+               --  An Initialization procedure must be considered visible even\n+               --  though it is internally generated.\n+\n+               if Is_Init_Proc (Defining_Entity (Subp_Decl)) then\n+                  return True;\n+\n+               --  Internally generated code is never publicly visible except\n+               --  for a subprogram that is the implementation of an expression\n+               --  function. In that case the visibility is determined by the\n+               --  last check.\n+\n+               elsif not Comes_From_Source (Subp_Decl)\n+                 and then\n+                   (Nkind (Original_Node (Subp_Decl)) /= N_Expression_Function\n+                      or else not\n+                        Comes_From_Source (Defining_Entity (Subp_Decl)))\n+               then\n+                  return False;\n+\n+               --  Determine whether the subprogram is declared in the visible\n+               --  declarations of the package containing the type.\n+\n+               else\n+                  return List_Containing (Subp_Decl) = Vis_Decls;\n+               end if;\n+            end Has_Public_Visibility_Of_Subprogram;\n+\n+         --  Start of processing for Invariant_Checks_OK\n+\n+         begin\n+            return\n+              Has_Invariants (Typ)\n+                and then Present (Invariant_Procedure (Typ))\n+                and then not Has_Null_Body (Invariant_Procedure (Typ))\n+                and then Has_Public_Visibility_Of_Subprogram;\n+         end Invariant_Checks_OK;\n+\n+         -------------------------\n+         -- Predicate_Checks_OK --\n+         -------------------------\n+\n+         function Predicate_Checks_OK (Typ : Entity_Id) return Boolean is\n+            function Has_Checked_Predicate return Boolean;\n+            --  Determine whether type Typ has or inherits at least one\n+            --  predicate aspect or pragma, for which the applicable policy is\n+            --  Checked.\n+\n+            ---------------------------\n+            -- Has_Checked_Predicate --\n+            ---------------------------\n+\n+            function Has_Checked_Predicate return Boolean is\n+               Anc  : Entity_Id;\n+               Pred : Node_Id;\n+\n+            begin\n+               --  Climb the ancestor type chain staring from the input. This\n+               --  is done because the input type may lack aspect/pragma\n+               --  predicate and simply inherit those from its ancestor.\n+\n+               --  Note that predicate pragmas include all three cases of\n+               --  predicate aspects (Predicate, Dynamic_Predicate,\n+               --  Static_Predicate), so this routine checks for all three\n+               --  cases.\n+\n+               Anc := Typ;\n+               while Present (Anc) loop\n+                  Pred := Get_Pragma (Anc, Pragma_Predicate);\n+\n+                  if Present (Pred) and then not Is_Ignored (Pred) then\n+                     return True;\n+                  end if;\n+\n+                  Anc := Nearest_Ancestor (Anc);\n+               end loop;\n+\n+               return False;\n+            end Has_Checked_Predicate;\n+\n+         --  Start of processing for Predicate_Checks_OK\n+\n+         begin\n+            return\n+              Has_Predicates (Typ)\n+                and then Present (Predicate_Function (Typ))\n+                and then Has_Checked_Predicate;\n+         end Predicate_Checks_OK;\n+\n+         --  Local variables\n+\n+         Loc    : constant Source_Ptr := Sloc (N);\n+         Formal : Entity_Id;\n+         Typ    : Entity_Id;\n+\n+      --  Start of processing for Add_Invariant_And_Predicate_Checks\n+\n+      begin\n+         Result := Empty;\n+\n+         --  Do not generate any checks if no code is being generated\n+\n+         if not Expander_Active then\n+            return;\n+         end if;\n+\n+         --  Process the result of a function\n+\n+         if Ekind_In (Subp_Id, E_Function, E_Generic_Function) then\n+            Typ := Etype (Subp_Id);\n+\n+            --  Generate _Result which is used in procedure _Postconditions to\n+            --  verify the return value.\n+\n+            Result := Make_Defining_Identifier (Loc, Name_uResult);\n+            Set_Etype (Result, Typ);\n+\n+            --  Add an invariant check when the return type has invariants and\n+            --  the related function is visible to the outside.\n+\n+            if Invariant_Checks_OK (Typ) then\n+               Append_Enabled_Item\n+                 (Item =>\n+                    Make_Invariant_Call (New_Occurrence_Of (Result, Loc)),\n+                  List => Stmts);\n+            end if;\n+\n+            --  Add an invariant check when the return type is an access to a\n+            --  type with invariants.\n+\n+            Add_Invariant_Access_Checks (Result);\n+         end if;\n+\n+         --  Add invariant and predicates for all formals that qualify\n+\n+         Formal := First_Formal (Subp_Id);\n+         while Present (Formal) loop\n+            Typ := Etype (Formal);\n+\n+            if Ekind (Formal) /= E_In_Parameter\n+              or else Is_Access_Type (Typ)\n+            then\n+               if Invariant_Checks_OK (Typ) then\n+                  Append_Enabled_Item\n+                    (Item =>\n+                       Make_Invariant_Call (New_Occurrence_Of (Formal, Loc)),\n+                     List => Stmts);\n+               end if;\n+\n+               Add_Invariant_Access_Checks (Formal);\n+\n+               if Predicate_Checks_OK (Typ) then\n+                  Append_Enabled_Item\n+                    (Item =>\n+                       Make_Predicate_Check\n+                         (Typ, New_Reference_To (Formal, Loc)),\n+                     List => Stmts);\n+               end if;\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+      end Add_Invariant_And_Predicate_Checks;\n+\n+      -------------------------\n+      -- Append_Enabled_Item --\n+      -------------------------\n+\n+      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id) is\n+      begin\n+         --  Do not chain ignored or disabled pragmas\n+\n+         if Nkind (Item) = N_Pragma\n+           and then (Is_Ignored (Item) or else Is_Disabled (Item))\n+         then\n+            null;\n+\n+         --  Add the item\n+\n+         else\n+            if No (List) then\n+               List := New_List;\n+            end if;\n+\n+            Append (Item, List);\n+         end if;\n+      end Append_Enabled_Item;\n+\n+      ------------------------------------\n+      -- Build_Postconditions_Procedure --\n+      ------------------------------------\n+\n+      procedure Build_Postconditions_Procedure\n+        (Subp_Id : Entity_Id;\n+         Stmts   : List_Id;\n+         Result  : Entity_Id)\n+      is\n+         procedure Insert_After_Last_Declaration (Stmt : Node_Id);\n+         --  Insert node Stmt after the last declaration of the subprogram body\n+\n+         -----------------------------------\n+         -- Insert_After_Last_Declaration --\n+         -----------------------------------\n+\n+         procedure Insert_After_Last_Declaration (Stmt : Node_Id) is\n+            Decls : List_Id := Declarations (N);\n+\n+         begin\n+            --  Ensure that the body has a declaration list\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Declarations (N, Decls);\n+            end if;\n+\n+            Append_To (Decls, Stmt);\n+         end Insert_After_Last_Declaration;\n+\n+         --  Local variables\n+\n+         Loc     : constant Source_Ptr := Sloc (N);\n+         Params  : List_Id := No_List;\n+         Proc_Id : Entity_Id;\n+\n+      --  Start of processing for Build_Postconditions_Procedure\n+\n+      begin\n+         --  Do not create the routine if no code is being generated\n+\n+         if not Expander_Active then\n+            return;\n+\n+         --  Nothing to do if there are no actions to check on exit\n+\n+         elsif No (Stmts) then\n+            return;\n+         end if;\n+\n+         Proc_Id := Make_Defining_Identifier (Loc, Name_uPostconditions);\n+\n+         --  The related subprogram is a function, create the specification of\n+         --  parameter _Result.\n+\n+         if Present (Result) then\n+            Params := New_List (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Result,\n+                Parameter_Type      =>\n+                  New_Reference_To (Etype (Result), Loc)));\n+         end if;\n+\n+         --  Insert _Postconditions after the last declaration of the body.\n+         --  This ensures that the body will not cause any premature freezing\n+         --  as it may mention types:\n+\n+         --    procedure Proc (Obj : Array_Typ) is\n+         --       procedure _postconditions is\n+         --       begin\n+         --          ... Obj ...\n+         --       end _postconditions;\n+\n+         --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n+         --    begin\n+\n+         --  In the example above, Obj is of type T but the incorrect placement\n+         --  of _Postconditions will cause a crash in gigi due to an out of\n+         --  order reference. The body of _Postconditions must be placed after\n+         --  the declaration of Temp to preserve correct visibility.\n+\n+         Insert_After_Last_Declaration (\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name       => Proc_Id,\n+                 Parameter_Specifications => Params),\n+\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc, Stmts)));\n+\n+         --  Set the attributes of the related subprogram to capture the\n+         --  generated procedure.\n+\n+         if Ekind_In (Subp_Id, E_Generic_Procedure, E_Procedure) then\n+            Set_Postcondition_Proc (Subp_Id, Proc_Id);\n+         end if;\n+\n+         Set_Has_Postconditions (Subp_Id);\n+      end Build_Postconditions_Procedure;\n+\n+      -----------------------------------\n+      -- Build_Pragma_Check_Equivalent --\n+      -----------------------------------\n+\n+      function Build_Pragma_Check_Equivalent\n+        (Prag     : Node_Id;\n+         Subp_Id  : Entity_Id := Empty;\n+         Inher_Id : Entity_Id := Empty) return Node_Id\n+      is\n+         Loc          : constant Source_Ptr := Sloc (Prag);\n+         Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n+         Check_Prag   : Node_Id;\n+         Formals_Map  : Elist_Id;\n+         Inher_Formal : Entity_Id;\n+         Msg_Arg      : Node_Id;\n+         Nam          : Name_Id;\n+         Subp_Formal  : Entity_Id;\n+\n+      begin\n+         Formals_Map := No_Elist;\n+\n+         --  When the pre- or postcondition is inherited, map the formals of\n+         --  the inherited subprogram to those of the current subprogram.\n+\n+         if Present (Inher_Id) then\n+            pragma Assert (Present (Subp_Id));\n+\n+            Formals_Map := New_Elmt_List;\n+\n+            --  Create a relation <inherited formal> => <subprogram formal>\n+\n+            Inher_Formal := First_Formal (Inher_Id);\n+            Subp_Formal  := First_Formal (Subp_Id);\n+            while Present (Inher_Formal) and then Present (Subp_Formal) loop\n+               Append_Elmt (Inher_Formal, Formals_Map);\n+               Append_Elmt (Subp_Formal, Formals_Map);\n+\n+               Next_Formal (Inher_Formal);\n+               Next_Formal (Subp_Formal);\n+            end loop;\n+         end if;\n+\n+         --  Copy the original pragma while performing substitutions (if\n+         --  applicable).\n+\n+         Check_Prag :=\n+           New_Copy_Tree\n+             (Source    => Prag,\n+              Map       => Formals_Map,\n+              New_Scope => Current_Scope);\n+\n+         --  Mark the pragma as being internally generated and reset the\n+         --  Analyzed flag.\n+\n+         Set_Comes_From_Source (Check_Prag, False);\n+         Set_Analyzed          (Check_Prag, False);\n+\n+         --  For a postcondition pragma within a generic, preserve the pragma\n+         --  for later expansion. This is also used when an error was detected,\n+         --  thus setting Expander_Active to False.\n+\n+         if Prag_Nam = Name_Postcondition and then not Expander_Active then\n+            return Check_Prag;\n+         end if;\n+\n+         if Present (Corresponding_Aspect (Prag)) then\n+            Nam := Chars (Identifier (Corresponding_Aspect (Prag)));\n+         else\n+            Nam := Prag_Nam;\n+         end if;\n+\n+         --  Convert the copy into pragma Check by correcting the name and\n+         --  adding a check_kind argument.\n+\n+         Set_Pragma_Identifier\n+           (Check_Prag, Make_Identifier (Loc, Name_Check));\n+\n+         Prepend_To (Pragma_Argument_Associations (Check_Prag),\n+           Make_Pragma_Argument_Association (Loc,\n+             Expression => Make_Identifier (Loc, Nam)));\n+\n+         --  Update the error message when the pragma is inherited\n+\n+         if Present (Inher_Id) then\n+            Msg_Arg := Last (Pragma_Argument_Associations (Check_Prag));\n+\n+            if Chars (Msg_Arg) = Name_Message then\n+               String_To_Name_Buffer (Strval (Expression (Msg_Arg)));\n+\n+               --  Insert \"inherited\" to improve the error message\n+\n+               if Name_Buffer (1 .. 8) = \"failed p\" then\n+                  Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+                  Set_Strval (Expression (Msg_Arg), String_From_Name_Buffer);\n+               end if;\n+            end if;\n+         end if;\n+\n+         return Check_Prag;\n+      end Build_Pragma_Check_Equivalent;\n+\n+      ---------------------------------\n+      -- Collect_Body_Postconditions --\n+      ---------------------------------\n+\n+      procedure Collect_Body_Postconditions (Stmts : in out List_Id) is\n+         procedure Collect_Body_Postconditions_Of_Kind (Post_Nam : Name_Id);\n+         --  Process postconditions of a particular kind denoted by Post_Nam\n+\n+         -----------------------------------------\n+         -- Collect_Body_Postconditions_Of_Kind --\n+         -----------------------------------------\n+\n+         procedure Collect_Body_Postconditions_Of_Kind (Post_Nam : Name_Id) is\n+            Check_Prag : Node_Id;\n+            Decl       : Node_Id;\n+\n+         begin\n+            pragma Assert (Nam_In (Post_Nam, Name_Postcondition,\n+                                             Name_Refined_Post));\n+\n+            --  Inspect the declarations of the subprogram body looking for a\n+            --  pragma that matches the desired name.\n+\n+            Decl := First (Declarations (N));\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Pragma then\n+                  if Pragma_Name (Decl) = Post_Nam then\n+                     Analyze (Decl);\n+                     Check_Prag := Build_Pragma_Check_Equivalent (Decl);\n+\n+                     if Expander_Active then\n+                        Append_Enabled_Item\n+                          (Item => Check_Prag,\n+                           List => Stmts);\n+\n+                     --  When analyzing a generic unit, save the pragma for\n+                     --  later.\n+\n+                     else\n+                        Prepend_To_Declarations (Check_Prag);\n+                     end if;\n+                  end if;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Decl) then\n+                  null;\n+\n+               --  Postconditions in bodies are usually grouped at the top of\n+               --  the declarations. There is no point in inspecting the whole\n+               --  source list.\n+\n+               else\n+                  exit;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end Collect_Body_Postconditions_Of_Kind;\n+\n+      --  Start of processing for Collect_Body_Postconditions\n+\n+      begin\n+         Collect_Body_Postconditions_Of_Kind (Name_Refined_Post);\n+         Collect_Body_Postconditions_Of_Kind (Name_Postcondition);\n+      end Collect_Body_Postconditions;\n+\n+      ---------------------------------\n+      -- Collect_Spec_Postconditions --\n+      ---------------------------------\n+\n+      procedure Collect_Spec_Postconditions\n+        (Subp_Id : Entity_Id;\n+         Stmts   : in out List_Id)\n+      is\n+         Inher_Subps   : constant Subprogram_List :=\n+                           Inherited_Subprograms (Subp_Id);\n+         Check_Prag    : Node_Id;\n+         Prag          : Node_Id;\n+         Inher_Subp_Id : Entity_Id;\n+\n+      begin\n+         --  Process the contract of the spec\n+\n+         Prag := Pre_Post_Conditions (Contract (Subp_Id));\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Postcondition then\n+               Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+\n+               if Expander_Active then\n+                  Append_Enabled_Item\n+                    (Item => Check_Prag,\n+                     List => Stmts);\n+\n+               --  When analyzing a generic unit, save the pragma for later\n+\n+               else\n+                  Prepend_To_Declarations (Check_Prag);\n+               end if;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Process the contracts of all inherited subprograms, looking for\n+         --  class-wide postconditions.\n+\n+         for Index in Inher_Subps'Range loop\n+            Inher_Subp_Id := Inher_Subps (Index);\n+\n+            Prag := Pre_Post_Conditions (Contract (Inher_Subp_Id));\n+            while Present (Prag) loop\n+               if Pragma_Name (Prag) = Name_Postcondition\n+                 and then Class_Present (Prag)\n+               then\n+                  Check_Prag :=\n+                    Build_Pragma_Check_Equivalent\n+                      (Prag     => Prag,\n+                       Subp_Id  => Subp_Id,\n+                       Inher_Id => Inher_Subp_Id);\n+\n+                  if Expander_Active then\n+                     Append_Enabled_Item\n+                       (Item => Check_Prag,\n+                        List => Stmts);\n+\n+                  --  When analyzing a generic unit, save the pragma for later\n+\n+                  else\n+                     Prepend_To_Declarations (Check_Prag);\n+                  end if;\n+               end if;\n+\n+               Prag := Next_Pragma (Prag);\n+            end loop;\n+         end loop;\n+      end Collect_Spec_Postconditions;\n+\n+      --------------------------------\n+      -- Collect_Spec_Preconditions --\n+      --------------------------------\n+\n+      procedure Collect_Spec_Preconditions (Subp_Id : Entity_Id) is\n+         procedure Merge_Preconditions (From : Node_Id; Into : Node_Id);\n+         --  Merge two class-wide preconditions by \"or else\"-ing them. The\n+         --  changes are accumulated in parameter Into. Update the error\n+         --  message of Into.\n+\n+         -------------------------\n+         -- Merge_Preconditions --\n+         -------------------------\n+\n+         procedure Merge_Preconditions (From : Node_Id; Into : Node_Id) is\n+            function Expression_Arg (Prag : Node_Id) return Node_Id;\n+            --  Return the boolean expression argument of a precondition while\n+            --  updating its parenteses count for the subsequent merge.\n+\n+            function Message_Arg (Prag : Node_Id) return Node_Id;\n+            --  Return the message argument of a precondition\n+\n+            --------------------\n+            -- Expression_Arg --\n+            --------------------\n+\n+            function Expression_Arg (Prag : Node_Id) return Node_Id is\n+               Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+               Arg  : constant Node_Id := Get_Pragma_Arg (Next (First (Args)));\n+\n+            begin\n+               if Paren_Count (Arg) = 0 then\n+                  Set_Paren_Count (Arg, 1);\n+               end if;\n+\n+               return Arg;\n+            end Expression_Arg;\n+\n+            -----------------\n+            -- Message_Arg --\n+            -----------------\n+\n+            function Message_Arg (Prag : Node_Id) return Node_Id is\n+               Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+            begin\n+               return Get_Pragma_Arg (Last (Args));\n+            end Message_Arg;\n+\n+            --  Local variables\n+\n+            From_Expr : constant Node_Id := Expression_Arg (From);\n+            From_Msg  : constant Node_Id := Message_Arg    (From);\n+            Into_Expr : constant Node_Id := Expression_Arg (Into);\n+            Into_Msg  : constant Node_Id := Message_Arg    (Into);\n+            Loc       : constant Source_Ptr := Sloc (Into);\n+\n+         --  Start of processing for Merge_Preconditions\n+\n+         begin\n+            --  Merge the two preconditions by \"or else\"-ing them\n+\n+            Rewrite (Into_Expr,\n+              Make_Or_Else (Loc,\n+                Right_Opnd => Relocate_Node (Into_Expr),\n+                Left_Opnd  => From_Expr));\n+\n+            --  Merge the two error messages to produce a single message of the\n+            --  form:\n+\n+            --    failed precondition from ...\n+            --      also failed inherited precondition from ...\n+\n+            if not Exception_Locations_Suppressed then\n+               Start_String (Strval (Into_Msg));\n+               Store_String_Char (ASCII.LF);\n+               Store_String_Chars (\"  also \");\n+               Store_String_Chars (Strval (From_Msg));\n+\n+               Set_Strval (Into_Msg, End_String);\n+            end if;\n+         end Merge_Preconditions;\n+\n+         --  Local variables\n+\n+         Inher_Subps   : constant Subprogram_List :=\n+                           Inherited_Subprograms (Subp_Id);\n+         Check_Prag    : Node_Id;\n+         Class_Pre     : Node_Id := Empty;\n+         Inher_Subp_Id : Entity_Id;\n+         Prag          : Node_Id;\n+\n+      --  Start of processing for Collect_Spec_Preconditions\n+\n+      begin\n+         --  Process the contract of the spec\n+\n+         Prag := Pre_Post_Conditions (Contract (Subp_Id));\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Precondition then\n+               Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+\n+               --  Save the sole class-wide precondition (if any) for the next\n+               --  step where it will be merged with inherited preconditions.\n+\n+               if Class_Present (Prag) then\n+                  Class_Pre := Check_Prag;\n+\n+               --  Accumulate the corresponding Check pragmas to the top of the\n+               --  declarations. Prepending the items ensures that they will\n+               --  be evaluated in their original order.\n+\n+               else\n+                  Prepend_To_Declarations (Check_Prag);\n+               end if;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Process the contracts of all inherited subprograms, looking for\n+         --  class-wide preconditions.\n+\n+         for Index in Inher_Subps'Range loop\n+            Inher_Subp_Id := Inher_Subps (Index);\n+\n+            Prag := Pre_Post_Conditions (Contract (Inher_Subp_Id));\n+            while Present (Prag) loop\n+               if Pragma_Name (Prag) = Name_Precondition\n+                 and then Class_Present (Prag)\n+               then\n+                  Check_Prag :=\n+                    Build_Pragma_Check_Equivalent\n+                      (Prag     => Prag,\n+                       Subp_Id  => Subp_Id,\n+                       Inher_Id => Inher_Subp_Id);\n+\n+                  --  The spec or an inherited subprogram already yielded a\n+                  --  class-wide precondition. Merge the existing precondition\n+                  --  with the current one using \"or else\".\n+\n+                  if Present (Class_Pre) then\n+                     Merge_Preconditions (Check_Prag, Class_Pre);\n+                  else\n+                     Class_Pre := Check_Prag;\n+                  end if;\n+               end if;\n+\n+               Prag := Next_Pragma (Prag);\n+            end loop;\n+         end loop;\n+\n+         --  Add the merged class-wide preconditions (if any)\n+\n+         if Present (Class_Pre) then\n+            Prepend_To_Declarations (Class_Pre);\n+         end if;\n+      end Collect_Spec_Preconditions;\n+\n+      -----------------------------\n+      -- Prepend_To_Declarations --\n+      -----------------------------\n+\n+      procedure Prepend_To_Declarations (Item : Node_Id) is\n+         Decls : List_Id := Declarations (N);\n+\n+      begin\n+         --  Ensure that the body has a declarative list\n+\n+         if No (Decls) then\n+            Decls := New_List;\n+            Set_Declarations (N, Decls);\n+         end if;\n+\n+         Prepend_To (Decls, Item);\n+      end Prepend_To_Declarations;\n+\n+      ----------------------------\n+      -- Process_Contract_Cases --\n+      ----------------------------\n+\n+      procedure Process_Contract_Cases\n+        (Subp_Id : Entity_Id;\n+         Stmts   : in out List_Id)\n+      is\n+         Prag : Node_Id;\n+\n+      begin\n+         --  Do not build the Contract_Cases circuitry if no code is being\n+         --  generated.\n+\n+         if not Expander_Active then\n+            null;\n+         end if;\n+\n+         Prag := Contract_Test_Cases (Contract (Subp_Id));\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Contract_Cases then\n+               Expand_Contract_Cases\n+                 (CCs     => Prag,\n+                  Subp_Id => Subp_Id,\n+                  Decls   => Declarations (N),\n+                  Stmts   => Stmts);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end Process_Contract_Cases;\n+\n+      --  Local variables\n+\n+      Post_Stmts : List_Id := No_List;\n+      Result     : Entity_Id;\n+      Subp_Id    : Entity_Id;\n+\n+   --  Start of processing for Expand_Subprogram_Contract\n+\n+   begin\n+      if Present (Spec_Id) then\n+         Subp_Id := Spec_Id;\n+      else\n+         Subp_Id := Body_Id;\n+      end if;\n+\n+      --  Do not process a predicate function as its body will end up with a\n+      --  recursive call to itself and blow up the stack.\n+\n+      if Ekind (Subp_Id) = E_Function\n+        and then Is_Predicate_Function (Subp_Id)\n+      then\n+         return;\n+\n+      --  Do not process TSS subprograms\n+\n+      elsif Get_TSS_Name (Subp_Id) /= TSS_Null then\n+         return;\n+      end if;\n+\n+      --  The expansion of a subprogram contract involves the relocation of\n+      --  various contract assertions to the declarations of the body in a\n+      --  particular order. The order is as follows:\n+\n+      --    function Example (...) return ... is\n+      --       procedure _Postconditions (...) is\n+      --       begin\n+      --          <refined postconditions from body>\n+      --          <postconditions from body>\n+      --          <postconditions from spec>\n+      --          <inherited postconditions>\n+      --          <contract cases>\n+      --          <invariant check of function result (if applicable)>\n+      --          <invariant and predicate checks of parameters>\n+      --       end _Postconditions;\n+\n+      --       <inherited preconditions>\n+      --       <preconditions from spec>\n+      --       <preconditions from body>\n+      --       <refined preconditions from body>\n+\n+      --       <source declarations>\n+      --    begin\n+      --       <source statements>\n+\n+      --       _Preconditions (Result);\n+      --       return Result;\n+      --    end Example;\n+\n+      --  Routine _Postconditions holds all contract assertions that must be\n+      --  verified on exit from the related routine.\n+\n+      --  Collect all [inherited] preconditions from the spec, transform them\n+      --  into Check pragmas and add them to the declarations of the body in\n+      --  the order outlined above.\n+\n+      if Present (Spec_Id) then\n+         Collect_Spec_Preconditions (Spec_Id);\n+      end if;\n+\n+      --  Transform all [refined] postconditions of the body into Check\n+      --  pragmas. The resulting pragmas are accumulated in list Post_Stmts.\n+\n+      Collect_Body_Postconditions (Post_Stmts);\n+\n+      --  Transform all [inherited] postconditions from the spec into Check\n+      --  pragmas. The resulting pragmas are accumulated in list Post_Stmts.\n+\n+      if Present (Spec_Id) then\n+         Collect_Spec_Postconditions (Spec_Id, Post_Stmts);\n+\n+         --  Transform pragma Contract_Cases from the spec into its circuitry\n+\n+         Process_Contract_Cases (Spec_Id, Post_Stmts);\n+      end if;\n+\n+      --  Apply invariant and predicate checks on the result of a function (if\n+      --  applicable) and all formals. The resulting checks are accumulated in\n+      --  list Post_Stmts.\n+\n+      Add_Invariant_And_Predicate_Checks (Subp_Id, Post_Stmts, Result);\n+\n+      --  Construct procedure _Postconditions\n+\n+      Build_Postconditions_Procedure (Subp_Id, Post_Stmts, Result);\n+   end Expand_Subprogram_Contract;\n+\n    --------------------------------\n    -- Is_Build_In_Place_Function --\n    --------------------------------"}, {"sha": "02cca2401df90522af5c095277e79f4b37ba8673", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -82,6 +82,18 @@ package Exp_Ch6 is\n    --  Subp_Id's body. All generated code is added to list Stmts. If Stmts is\n    --  empty, a new list is created.\n \n+   procedure Expand_Subprogram_Contract\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id);\n+   --  Expand the contracts of a subprogram body and its correspoding spec (if\n+   --  any). This routine processes all [refined] pre- and postconditions as\n+   --  well as Contract_Cases, invariants and predicates. N is the body of the\n+   --  subprogram. Spec_Id denotes the entity of its specification. Body_Id\n+   --  denotes the entity of the subprogram body. This routine is not a \"pure\"\n+   --  expansion mechanism as it is invoked during analysis and may perform\n+   --  actions for generic subprograms or set up contract assertions for ASIS.\n+\n    procedure Freeze_Subprogram (N : Node_Id);\n    --  generate the appropriate expansions related to Subprogram freeze\n    --  nodes (e.g. the filling of the corresponding Dispatch Table for"}, {"sha": "e8bea1fced334af2eff41637bde181094724cdc8", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -1250,6 +1250,8 @@ begin\n            Pragma_Pure_12                        |\n            Pragma_Pure_Function                  |\n            Pragma_Queuing_Policy                 |\n+           Pragma_Refined_Depends                |\n+           Pragma_Refined_Global                 |\n            Pragma_Refined_Post                   |\n            Pragma_Refined_Pre                    |\n            Pragma_Relative_Deadline              |"}, {"sha": "30c5bc4adb85d5588d6758137fabfccdfe84acf1", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -1928,6 +1928,20 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_SPARK_Mode);\n \n+               --  Refined_Depends\n+\n+               --  ??? To be implemented\n+\n+               when Aspect_Refined_Depends =>\n+                  null;\n+\n+               --  Refined_Global\n+\n+               --  ??? To be implemented\n+\n+               when Aspect_Refined_Global =>\n+                  null;\n+\n                --  Refined_Post\n \n                when Aspect_Refined_Post =>\n@@ -7962,6 +7976,8 @@ package body Sem_Ch13 is\n               Aspect_Postcondition        |\n               Aspect_Pre                  |\n               Aspect_Precondition         |\n+              Aspect_Refined_Depends      |\n+              Aspect_Refined_Global       |\n               Aspect_Refined_Post         |\n               Aspect_Refined_Pre          |\n               Aspect_SPARK_Mode           |"}, {"sha": "1e6abf24cec7e33c99c2ec159521a010e42de3e9", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -2056,28 +2056,31 @@ package body Sem_Ch3 is\n    --------------------------\n \n    procedure Analyze_Declarations (L : List_Id) is\n-      D           : Node_Id;\n-      Freeze_From : Entity_Id := Empty;\n-      Next_Node   : Node_Id;\n+      Decl : Node_Id;\n \n-      procedure Adjust_D;\n-      --  Adjust D not to include implicit label declarations, since these\n+      procedure Adjust_Decl;\n+      --  Adjust Decl not to include implicit label declarations, since these\n       --  have strange Sloc values that result in elaboration check problems.\n       --  (They have the sloc of the label as found in the source, and that\n       --  is ahead of the current declarative part).\n \n-      --------------\n-      -- Adjust_D --\n-      --------------\n+      -----------------\n+      -- Adjust_Decl --\n+      -----------------\n \n-      procedure Adjust_D is\n+      procedure Adjust_Decl is\n       begin\n-         while Present (Prev (D))\n-           and then Nkind (D) = N_Implicit_Label_Declaration\n+         while Present (Prev (Decl))\n+           and then Nkind (Decl) = N_Implicit_Label_Declaration\n          loop\n-            Prev (D);\n+            Prev (Decl);\n          end loop;\n-      end Adjust_D;\n+      end Adjust_Decl;\n+\n+      --  Local variables\n+\n+      Freeze_From : Entity_Id := Empty;\n+      Next_Decl   : Node_Id;\n \n    --  Start of processing for Analyze_Declarations\n \n@@ -2086,23 +2089,23 @@ package body Sem_Ch3 is\n          Check_Later_Vs_Basic_Declarations (L, During_Parsing => False);\n       end if;\n \n-      D := First (L);\n-      while Present (D) loop\n+      Decl := First (L);\n+      while Present (Decl) loop\n \n          --  Package spec cannot contain a package declaration in SPARK\n \n-         if Nkind (D) = N_Package_Declaration\n+         if Nkind (Decl) = N_Package_Declaration\n            and then Nkind (Parent (L)) = N_Package_Specification\n          then\n             Check_SPARK_Restriction\n               (\"package specification cannot contain a package declaration\",\n-               D);\n+               Decl);\n          end if;\n \n          --  Complete analysis of declaration\n \n-         Analyze (D);\n-         Next_Node := Next (D);\n+         Analyze (Decl);\n+         Next_Decl := Next (Decl);\n \n          if No (Freeze_From) then\n             Freeze_From := First_Entity (Current_Scope);\n@@ -2124,7 +2127,7 @@ package body Sem_Ch3 is\n          --  be a freeze point once delayed freezing of bodies is implemented.\n          --  (This is needed in any case for early instantiations ???).\n \n-         if No (Next_Node) then\n+         if No (Next_Decl) then\n             if Nkind_In (Parent (L), N_Component_List,\n                                      N_Task_Definition,\n                                      N_Protected_Definition)\n@@ -2136,8 +2139,8 @@ package body Sem_Ch3 is\n                   Freeze_From := First_Entity (Current_Scope);\n                end if;\n \n-               Adjust_D;\n-               Freeze_All (Freeze_From, D);\n+               Adjust_Decl;\n+               Freeze_All (Freeze_From, Decl);\n                Freeze_From := Last_Entity (Current_Scope);\n \n             elsif Scope (Current_Scope) /= Standard_Standard\n@@ -2150,8 +2153,8 @@ package body Sem_Ch3 is\n                or else No (Private_Declarations (Parent (L)))\n                or else Is_Empty_List (Private_Declarations (Parent (L)))\n             then\n-               Adjust_D;\n-               Freeze_All (Freeze_From, D);\n+               Adjust_Decl;\n+               Freeze_All (Freeze_From, Decl);\n                Freeze_From := Last_Entity (Current_Scope);\n             end if;\n \n@@ -2170,44 +2173,39 @@ package body Sem_Ch3 is\n          --  care to attach the bodies at a proper place in the tree so as to\n          --  not cause unwanted freezing at that point.\n \n-         elsif not Analyzed (Next_Node)\n-           and then (Nkind_In (Next_Node, N_Subprogram_Body,\n+         elsif not Analyzed (Next_Decl)\n+           and then (Nkind_In (Next_Decl, N_Subprogram_Body,\n                                           N_Entry_Body,\n                                           N_Package_Body,\n                                           N_Protected_Body,\n                                           N_Task_Body)\n                        or else\n-                     Nkind (Next_Node) in N_Body_Stub)\n+                     Nkind (Next_Decl) in N_Body_Stub)\n          then\n-            Adjust_D;\n-            Freeze_All (Freeze_From, D);\n+            Adjust_Decl;\n+            Freeze_All (Freeze_From, Decl);\n             Freeze_From := Last_Entity (Current_Scope);\n          end if;\n \n-         D := Next_Node;\n+         Decl := Next_Decl;\n       end loop;\n \n-      --  One more thing to do, we need to scan the declarations to check for\n-      --  any precondition/postcondition pragmas (Pre/Post aspects have by this\n-      --  stage been converted into corresponding pragmas). It is at this point\n-      --  that we analyze the expressions in such pragmas, to implement the\n-      --  delayed visibility requirement.\n+      --  Analyze the contracts of a subprogram declaration or a body now due\n+      --  to delayed visibility requirements of aspects.\n \n-      declare\n-         Decl    : Node_Id;\n-         Subp_Id : Entity_Id;\n+      Decl := First (L);\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Subprogram_Body then\n+            Analyze_Subprogram_Body_Contract\n+              (Defining_Unit_Name (Specification (Decl)));\n \n-      begin\n-         Decl := First (L);\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Subprogram_Declaration then\n-               Subp_Id := Defining_Unit_Name (Specification (Decl));\n-               Analyze_Subprogram_Contract (Subp_Id);\n-            end if;\n+         elsif Nkind (Decl) = N_Subprogram_Declaration then\n+            Analyze_Subprogram_Contract\n+              (Defining_Unit_Name (Specification (Decl)));\n+         end if;\n \n-            Next (Decl);\n-         end loop;\n-      end;\n+         Next (Decl);\n+      end loop;\n    end Analyze_Declarations;\n \n    -----------------------------------"}, {"sha": "462a7f1732f4920407be89baac6327bcfb15b63b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 36, "deletions": 889, "changes": 925, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -212,17 +212,6 @@ package body Sem_Ch6 is\n    --  Create the declaration for an inequality operator that is implicitly\n    --  created by a user-defined equality operator that yields a boolean.\n \n-   procedure Process_PPCs\n-     (N       : Node_Id;\n-      Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id);\n-   --  Called from Analyze[_Generic]_Subprogram_Body to deal with scanning post\n-   --  conditions for the body and assembling and inserting the _postconditions\n-   --  procedure. N is the node for the subprogram body and Body_Id/Spec_Id are\n-   --  the entities for the body and separate spec (if there is no separate\n-   --  spec, Spec_Id is Empty). Note that invariants and predicates may also\n-   --  provide postconditions, and are also handled in this procedure.\n-\n    procedure Set_Formal_Validity (Formal_Id : Entity_Id);\n    --  Formal_Id is an formal parameter entity. This procedure deals with\n    --  setting the proper validity status for this entity, which depends on\n@@ -1120,7 +1109,7 @@ package body Sem_Ch6 is\n          --  Visible generic entity is callable within its own body\n \n          Set_Ekind          (Gen_Id,  Ekind (Body_Id));\n-         Set_Contract       (Body_Id, Empty);\n+         Set_Contract       (Body_Id, Make_Contract (Sloc (Body_Id)));\n          Set_Ekind          (Body_Id, E_Subprogram_Body);\n          Set_Convention     (Body_Id, Convention (Gen_Id));\n          Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Gen_Id));\n@@ -1156,13 +1145,14 @@ package body Sem_Ch6 is\n \n          Set_Actual_Subtypes (N, Current_Scope);\n \n-         --  Deal with preconditions and postconditions. In formal verification\n-         --  mode, we keep pre- and postconditions attached to entities rather\n-         --  than inserted in the code, in order to facilitate a distinct\n-         --  treatment for them.\n+         --  Deal with [refined] preconditions, postconditions, Contract_Cases,\n+         --  invariants and predicates associated with the body and its spec.\n+         --  Note that this is not pure expansion as Expand_Subprogram_Contract\n+         --  prepares the contract assertions for generic subprograms or for\n+         --  ASIS. Do not generate contract checks in SPARK mode.\n \n          if not SPARK_Mode then\n-            Process_PPCs (N, Gen_Id, Body_Id);\n+            Expand_Subprogram_Contract (N, Gen_Id, Body_Id);\n          end if;\n \n          --  If the generic unit carries pre- or post-conditions, copy them\n@@ -1981,6 +1971,18 @@ package body Sem_Ch6 is\n       end if;\n    end Analyze_Subprogram_Body;\n \n+   --------------------------------------\n+   -- Analyze_Subprogram_Body_Contract --\n+   --------------------------------------\n+\n+   --  ??? To be implemented\n+\n+   procedure Analyze_Subprogram_Body_Contract (Subp : Entity_Id) is\n+      pragma Unreferenced (Subp);\n+   begin\n+      null;\n+   end Analyze_Subprogram_Body_Contract;\n+\n    ------------------------------------\n    -- Analyze_Subprogram_Body_Helper --\n    ------------------------------------\n@@ -2933,7 +2935,7 @@ package body Sem_Ch6 is\n          end if;\n \n          Set_Corresponding_Body (Unit_Declaration_Node (Spec_Id), Body_Id);\n-         Set_Contract (Body_Id, Empty);\n+         Set_Contract (Body_Id, Make_Contract (Sloc (Body_Id)));\n          Set_Ekind (Body_Id, E_Subprogram_Body);\n          Set_Scope (Body_Id, Scope (Spec_Id));\n          Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Spec_Id));\n@@ -3117,13 +3119,14 @@ package body Sem_Ch6 is\n       HSS := Handled_Statement_Sequence (N);\n       Set_Actual_Subtypes (N, Current_Scope);\n \n-      --  Deal with preconditions and postconditions. In formal verification\n-      --  mode, we keep pre- and postconditions attached to entities rather\n-      --  than inserted in the code, in order to facilitate a distinct\n-      --  treatment for them.\n+      --  Deal with [refined] preconditions, postconditions, Contract_Cases,\n+      --  invariants and predicates associated with the body and its spec.\n+      --  Note that this is not pure expansion as Expand_Subprogram_Contract\n+      --  prepares the contract assertions for generic subprograms or for ASIS.\n+      --  Do not generate contract checks in SPARK mode.\n \n       if not SPARK_Mode then\n-         Process_PPCs (N, Spec_Id, Body_Id);\n+         Expand_Subprogram_Contract (N, Spec_Id, Body_Id);\n       end if;\n \n       --  Add a declaration for the Protection object, renaming declarations\n@@ -3535,6 +3538,7 @@ package body Sem_Ch6 is\n       Items       : constant Node_Id := Contract (Subp);\n       Error_CCase : Node_Id;\n       Error_Post  : Node_Id;\n+      Nam         : Name_Id;\n       Prag        : Node_Id;\n \n    --  Start of processing for Analyze_Subprogram_Contract\n@@ -3549,7 +3553,7 @@ package body Sem_Ch6 is\n \n          Prag := Pre_Post_Conditions (Items);\n          while Present (Prag) loop\n-            Analyze_PPC_In_Decl_Part (Prag, Subp);\n+            Analyze_Pre_Post_Condition_In_Decl_Part (Prag, Subp);\n \n             --  Verify whether a postcondition mentions attribute 'Result and\n             --  its expression introduces a post-state.\n@@ -3567,7 +3571,9 @@ package body Sem_Ch6 is\n \n          Prag := Contract_Test_Cases (Items);\n          while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Contract_Cases then\n+            Nam := Pragma_Name (Prag);\n+\n+            if Nam = Name_Contract_Cases then\n                Analyze_Contract_Cases_In_Decl_Part (Prag);\n \n                --  Verify whether contract-cases mention attribute 'Result and\n@@ -3581,7 +3587,7 @@ package body Sem_Ch6 is\n                end if;\n \n             else\n-               pragma Assert (Pragma_Name (Prag) = Name_Test_Case);\n+               pragma Assert (Nam = Name_Test_Case);\n                Analyze_Test_Case_In_Decl_Part (Prag, Subp);\n             end if;\n \n@@ -3592,10 +3598,12 @@ package body Sem_Ch6 is\n \n          Prag := Classifications (Contract (Subp));\n          while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Depends then\n+            Nam := Pragma_Name (Prag);\n+\n+            if Nam = Name_Depends then\n                Analyze_Depends_In_Decl_Part (Prag);\n             else\n-               pragma Assert (Pragma_Name (Prag) = Name_Global);\n+               pragma Assert (Nam = Name_Global);\n                Analyze_Global_In_Decl_Part (Prag);\n             end if;\n \n@@ -11248,867 +11256,6 @@ package body Sem_Ch6 is\n       end if;\n    end Process_Formals;\n \n-   ------------------\n-   -- Process_PPCs --\n-   ------------------\n-\n-   procedure Process_PPCs\n-     (N       : Node_Id;\n-      Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id)\n-   is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Prag  : Node_Id;\n-      Parms : List_Id;\n-\n-      Designator : Entity_Id;\n-      --  Subprogram designator, set from Spec_Id if present, else Body_Id\n-\n-      Precond : Node_Id := Empty;\n-      --  Set non-Empty if we prepend precondition to the declarations. This\n-      --  is used to hook up inherited preconditions (adding the condition\n-      --  expression with OR ELSE, and adding the message).\n-\n-      Inherited_Precond : Node_Id;\n-      --  Precondition inherited from parent subprogram\n-\n-      Inherited : constant Subprogram_List :=\n-                     Inherited_Subprograms (Spec_Id);\n-      --  List of subprograms inherited by this subprogram\n-\n-      Plist : List_Id := No_List;\n-      --  List of generated postconditions\n-\n-      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id);\n-      --  Append a node to a list. If there is no list, create a new one. When\n-      --  the item denotes a pragma, it is added to the list only when it is\n-      --  enabled.\n-\n-      procedure Check_Access_Invariants (E : Entity_Id);\n-      --  If the subprogram returns an access to a type with invariants, or\n-      --  has access parameters whose designated type has an invariant, then\n-      --  under the same visibility conditions as for other invariant checks,\n-      --  the type invariant must be applied to the returned value.\n-\n-      procedure Collect_Body_Postconditions (Post_Nam : Name_Id);\n-      --  Examine the declarations of the body, looking for pragmas with name\n-      --  Post_Nam. Parameter Post_Nam must denote either Name_Postcondition or\n-      --  Name_Refined_Post. Chain any relevant postconditions to Plist.\n-\n-      function Grab_PPC (Pspec : Entity_Id := Empty) return Node_Id;\n-      --  Prag contains an analyzed precondition or postcondition pragma. This\n-      --  function copies the pragma, changes it to the corresponding Check\n-      --  pragma and returns the Check pragma as the result. If Pspec is non-\n-      --  empty, this is the case of inheriting a PPC, where we must change\n-      --  references to parameters of the inherited subprogram to point to the\n-      --  corresponding parameters of the current subprogram.\n-\n-      function Has_Checked_Predicate (Typ : Entity_Id) return Boolean;\n-      --  Determine whether type Typ has or inherits at least one predicate\n-      --  aspect or pragma, for which the applicable policy is Checked.\n-\n-      function Has_Null_Body (Proc_Id : Entity_Id) return Boolean;\n-      --  Determine whether the body of procedure Proc_Id contains a sole null\n-      --  statement, possibly followed by an optional return.\n-\n-      procedure Insert_After_Last_Declaration (Nod : Node_Id);\n-      --  Insert node Nod after the last declaration of the context\n-\n-      function Is_Public_Subprogram_For (T : Entity_Id) return Boolean;\n-      --  T is the entity for a private type for which invariants are defined.\n-      --  This function returns True if the procedure corresponding to the\n-      --  value of Designator is a public procedure from the point of view of\n-      --  this type (i.e. its spec is in the visible part of the package that\n-      --  contains the declaration of the private type). A True value means\n-      --  that an invariant check is required (for an IN OUT parameter, or\n-      --  the returned value of a function.\n-\n-      -------------------------\n-      -- Append_Enabled_Item --\n-      -------------------------\n-\n-      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id) is\n-      begin\n-         --  Do not chain ignored or disabled pragmas\n-\n-         if Nkind (Item) = N_Pragma\n-           and then (Is_Ignored (Item) or else Is_Disabled (Item))\n-         then\n-            null;\n-\n-         --  Add the item\n-\n-         else\n-            if No (List) then\n-               List := New_List;\n-            end if;\n-\n-            Append (Item, List);\n-         end if;\n-      end Append_Enabled_Item;\n-\n-      -----------------------------\n-      -- Check_Access_Invariants --\n-      -----------------------------\n-\n-      procedure Check_Access_Invariants (E : Entity_Id) is\n-         Call : Node_Id;\n-         Obj  : Node_Id;\n-         Typ  : Entity_Id;\n-\n-      begin\n-         if Is_Access_Type (Etype (E))\n-           and then not Is_Access_Constant (Etype (E))\n-         then\n-            Typ := Designated_Type (Etype (E));\n-\n-            if Has_Invariants (Typ)\n-              and then Present (Invariant_Procedure (Typ))\n-              and then not Has_Null_Body (Invariant_Procedure (Typ))\n-              and then Is_Public_Subprogram_For (Typ)\n-            then\n-               Obj :=\n-                 Make_Explicit_Dereference (Loc,\n-                   Prefix => New_Occurrence_Of (E, Loc));\n-               Set_Etype (Obj, Typ);\n-\n-               Call := Make_Invariant_Call (Obj);\n-\n-               Append_Enabled_Item\n-                 (Make_If_Statement (Loc,\n-                    Condition =>\n-                      Make_Op_Ne (Loc,\n-                        Left_Opnd   => Make_Null (Loc),\n-                        Right_Opnd  => New_Occurrence_Of (E, Loc)),\n-                    Then_Statements => New_List (Call)),\n-                  List => Plist);\n-            end if;\n-         end if;\n-      end Check_Access_Invariants;\n-\n-      ---------------------------------\n-      -- Collect_Body_Postconditions --\n-      ---------------------------------\n-\n-      procedure Collect_Body_Postconditions (Post_Nam : Name_Id) is\n-         Next_Prag : Node_Id;\n-\n-      begin\n-         pragma Assert\n-           (Nam_In (Post_Nam, Name_Postcondition, Name_Refined_Post));\n-\n-         Prag := First (Declarations (N));\n-         while Present (Prag) loop\n-            Next_Prag := Next (Prag);\n-\n-            if Nkind (Prag) = N_Pragma then\n-\n-               --  Capture postcondition pragmas\n-\n-               if Pragma_Name (Prag) = Post_Nam then\n-                  Analyze (Prag);\n-\n-                  --  All Refined_Post pragmas must be relocated to the body\n-                  --  of the generated _Postconditions routine, otherwise they\n-                  --  will be duplicated twice - once in the declarations of\n-                  --  the body and once in _Postconditions.\n-\n-                  if Pragma_Name (Prag) = Name_Refined_Post then\n-                     Remove (Prag);\n-                  end if;\n-\n-                  --  If expansion is disabled, as in a generic unit, save\n-                  --  pragma for later expansion.\n-\n-                  if not Expander_Active then\n-                     Prepend (Grab_PPC, Declarations (N));\n-                  else\n-                     Append_Enabled_Item (Grab_PPC, Plist);\n-                  end if;\n-               end if;\n-\n-            --  Skip internally generated code\n-\n-            elsif not Comes_From_Source (Prag) then\n-               null;\n-\n-            else\n-               exit;\n-            end if;\n-\n-            Prag := Next_Prag;\n-         end loop;\n-      end Collect_Body_Postconditions;\n-\n-      --------------\n-      -- Grab_PPC --\n-      --------------\n-\n-      function Grab_PPC (Pspec : Entity_Id := Empty) return Node_Id is\n-         Nam : constant Name_Id := Pragma_Name (Prag);\n-         Map : Elist_Id;\n-         CP  : Node_Id;\n-\n-         Ename : Name_Id;\n-         --  Effective name of pragma (maybe Pre/Post rather than Precondition/\n-         --  Postcodition if the pragma came from a Pre/Post aspect). We need\n-         --  the name right when we generate the Check pragma, since we want\n-         --  the right set of check policies to apply.\n-\n-      begin\n-         --  Prepare map if this is the case where we have to map entities of\n-         --  arguments in the overridden subprogram to corresponding entities\n-         --  of the current subprogram.\n-\n-         if No (Pspec) then\n-            Map := No_Elist;\n-\n-         else\n-            declare\n-               PF : Entity_Id;\n-               CF : Entity_Id;\n-\n-            begin\n-               Map := New_Elmt_List;\n-               PF := First_Formal (Pspec);\n-               CF := First_Formal (Designator);\n-               while Present (PF) loop\n-                  Append_Elmt (PF, Map);\n-                  Append_Elmt (CF, Map);\n-                  Next_Formal (PF);\n-                  Next_Formal (CF);\n-               end loop;\n-            end;\n-         end if;\n-\n-         --  Now we can copy the tree, doing any required substitutions\n-\n-         CP := New_Copy_Tree (Prag, Map => Map, New_Scope => Current_Scope);\n-\n-         --  Set Analyzed to false, since we want to reanalyze the check\n-         --  procedure. Note that it is only at the outer level that we\n-         --  do this fiddling, for the spec cases, the already preanalyzed\n-         --  parameters are not affected.\n-\n-         Set_Analyzed (CP, False);\n-\n-         --  We also make sure Comes_From_Source is False for the copy\n-\n-         Set_Comes_From_Source (CP, False);\n-\n-         --  For a postcondition pragma within a generic, preserve the pragma\n-         --  for later expansion. This is also used when an error was detected,\n-         --  thus setting Expander_Active to False.\n-\n-         if Nam = Name_Postcondition\n-           and then not Expander_Active\n-         then\n-            return CP;\n-         end if;\n-\n-         --  Get effective name of aspect\n-\n-         if Present (Corresponding_Aspect (Prag)) then\n-            Ename := Chars (Identifier (Corresponding_Aspect (Prag)));\n-         else\n-            Ename := Nam;\n-         end if;\n-\n-         --  Change copy of pragma into corresponding pragma Check\n-\n-         Prepend_To (Pragma_Argument_Associations (CP),\n-           Make_Pragma_Argument_Association (Sloc (Prag),\n-             Expression => Make_Identifier (Loc, Ename)));\n-         Set_Pragma_Identifier (CP, Make_Identifier (Sloc (Prag), Name_Check));\n-\n-         --  If this is inherited case and the current message starts with\n-         --  \"failed p\", we change it to \"failed inherited p...\".\n-\n-         if Present (Pspec) then\n-            declare\n-               Msg : constant Node_Id :=\n-                       Last (Pragma_Argument_Associations (CP));\n-\n-            begin\n-               if Chars (Msg) = Name_Message then\n-                  String_To_Name_Buffer (Strval (Expression (Msg)));\n-\n-                  if Name_Buffer (1 .. 8) = \"failed p\" then\n-                     Insert_Str_In_Name_Buffer (\"inherited \", 8);\n-                     Set_Strval\n-                       (Expression (Last (Pragma_Argument_Associations (CP))),\n-                        String_From_Name_Buffer);\n-                  end if;\n-               end if;\n-            end;\n-         end if;\n-\n-         --  Return the check pragma\n-\n-         return CP;\n-      end Grab_PPC;\n-\n-      ---------------------------\n-      -- Has_Checked_Predicate --\n-      ---------------------------\n-\n-      function Has_Checked_Predicate (Typ : Entity_Id) return Boolean is\n-         Anc  : Entity_Id;\n-         Pred : Node_Id;\n-\n-      begin\n-         --  Climb the ancestor type chain staring from the input. This is done\n-         --  because the input type may lack aspect/pragma predicate and simply\n-         --  inherit those from its ancestor.\n-\n-         --  Note that predicate pragmas include all three cases of predicate\n-         --  aspects (Predicate, Dynamic_Predicate, Static_Predicate), so this\n-         --  routine checks for all three cases.\n-\n-         Anc := Typ;\n-         while Present (Anc) loop\n-            Pred := Get_Pragma (Anc, Pragma_Predicate);\n-\n-            if Present (Pred) and then not Is_Ignored (Pred) then\n-               return True;\n-            end if;\n-\n-            Anc := Nearest_Ancestor (Anc);\n-         end loop;\n-\n-         return False;\n-      end Has_Checked_Predicate;\n-\n-      -------------------\n-      -- Has_Null_Body --\n-      -------------------\n-\n-      function Has_Null_Body (Proc_Id : Entity_Id) return Boolean is\n-         Body_Id : Entity_Id;\n-         Decl    : Node_Id;\n-         Spec    : Node_Id;\n-         Stmt1   : Node_Id;\n-         Stmt2   : Node_Id;\n-\n-      begin\n-         Spec := Parent (Proc_Id);\n-         Decl := Parent (Spec);\n-\n-         --  Retrieve the entity of the invariant procedure body\n-\n-         if Nkind (Spec) = N_Procedure_Specification\n-           and then Nkind (Decl) = N_Subprogram_Declaration\n-         then\n-            Body_Id := Corresponding_Body (Decl);\n-\n-         --  The body acts as a spec\n-\n-         else\n-            Body_Id := Proc_Id;\n-         end if;\n-\n-         --  The body will be generated later\n-\n-         if No (Body_Id) then\n-            return False;\n-         end if;\n-\n-         Spec := Parent (Body_Id);\n-         Decl := Parent (Spec);\n-\n-         pragma Assert\n-           (Nkind (Spec) = N_Procedure_Specification\n-              and then Nkind (Decl) = N_Subprogram_Body);\n-\n-         Stmt1 := First (Statements (Handled_Statement_Sequence (Decl)));\n-\n-         --  Look for a null statement followed by an optional return statement\n-\n-         if Nkind (Stmt1) = N_Null_Statement then\n-            Stmt2 := Next (Stmt1);\n-\n-            if Present (Stmt2) then\n-               return Nkind (Stmt2) = N_Simple_Return_Statement;\n-            else\n-               return True;\n-            end if;\n-         end if;\n-\n-         return False;\n-      end Has_Null_Body;\n-\n-      -----------------------------------\n-      -- Insert_After_Last_Declaration --\n-      -----------------------------------\n-\n-      procedure Insert_After_Last_Declaration (Nod : Node_Id) is\n-         Decls : constant List_Id := Declarations (N);\n-\n-      begin\n-         if No (Decls) then\n-            Set_Declarations (N, New_List (Nod));\n-         else\n-            Append_To (Decls, Nod);\n-         end if;\n-      end Insert_After_Last_Declaration;\n-\n-      ------------------------------\n-      -- Is_Public_Subprogram_For --\n-      ------------------------------\n-\n-      --  The type T is a private type, its declaration is therefore in\n-      --  the list of public declarations of some package. The test for a\n-      --  public subprogram is that its declaration is in this same list\n-      --  of declarations for the same package (note that all the public\n-      --  declarations are in one list, and all the private declarations\n-      --  in another, so this deals with the public/private distinction).\n-\n-      function Is_Public_Subprogram_For (T : Entity_Id) return Boolean is\n-         DD : constant Node_Id := Unit_Declaration_Node (Designator);\n-         --  The subprogram declaration for the subprogram in question\n-\n-         TL : constant List_Id :=\n-                Visible_Declarations\n-                  (Specification (Unit_Declaration_Node (Scope (T))));\n-         --  The list of declarations containing the private declaration of\n-         --  the type. We know it is a private type, so we know its scope is\n-         --  the package in question, and we know it must be in the visible\n-         --  declarations of this package.\n-\n-      begin\n-         --  If the subprogram declaration is not a list member, it must be\n-         --  an Init_Proc, in which case we want to consider it to be a\n-         --  public subprogram, since we do get initializations to deal with.\n-         --  Other internally generated subprograms are not public.\n-\n-         if not Is_List_Member (DD)\n-           and then Is_Init_Proc (Defining_Entity (DD))\n-         then\n-            return True;\n-\n-         --  The declaration may have been generated for an expression function\n-         --  so check whether that function comes from source.\n-\n-         elsif not Comes_From_Source (DD)\n-           and then\n-             (Nkind (Original_Node (DD)) /= N_Expression_Function\n-               or else not Comes_From_Source (Defining_Entity (DD)))\n-         then\n-            return False;\n-\n-         --  Otherwise we test whether the subprogram is declared in the\n-         --  visible declarations of the package containing the type.\n-\n-         else\n-            return TL = List_Containing (DD);\n-         end if;\n-      end Is_Public_Subprogram_For;\n-\n-      --  Local variables\n-\n-      Formal     : Node_Id;\n-      Formal_Typ : Entity_Id;\n-      Func_Typ   : Entity_Id;\n-      Post_Proc  : Entity_Id;\n-      Result     : Node_Id;\n-\n-   --  Start of processing for Process_PPCs\n-\n-   begin\n-      --  Capture designator from spec if present, else from body\n-\n-      if Present (Spec_Id) then\n-         Designator := Spec_Id;\n-      else\n-         Designator := Body_Id;\n-      end if;\n-\n-      --  Do not process a predicate function as its body will contain a\n-      --  recursive call to itself and blow up the stack.\n-\n-      if Ekind (Designator) = E_Function\n-        and then Is_Predicate_Function (Designator)\n-      then\n-         return;\n-\n-      --  Internally generated subprograms, such as type-specific functions,\n-      --  don't get assertion checks.\n-\n-      elsif Get_TSS_Name (Designator) /= TSS_Null then\n-         return;\n-      end if;\n-\n-      --  Grab preconditions from spec\n-\n-      if Present (Spec_Id) then\n-\n-         --  Loop through PPC pragmas from spec. Note that preconditions from\n-         --  the body will be analyzed and converted when we scan the body\n-         --  declarations below.\n-\n-         Prag := Pre_Post_Conditions (Contract (Spec_Id));\n-         while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Precondition then\n-\n-               --  For Pre (or Precondition pragma), we simply prepend the\n-               --  pragma to the list of declarations right away so that it\n-               --  will be executed at the start of the procedure. Note that\n-               --  this processing reverses the order of the list, which is\n-               --  what we want since new entries were chained to the head of\n-               --  the list. There can be more than one precondition when we\n-               --  use pragma Precondition.\n-\n-               if not Class_Present (Prag) then\n-                  Prepend (Grab_PPC, Declarations (N));\n-\n-               --  For Pre'Class there can only be one pragma, and we save\n-               --  it in Precond for now. We will add inherited Pre'Class\n-               --  stuff before inserting this pragma in the declarations.\n-               else\n-                  Precond := Grab_PPC;\n-               end if;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Now deal with inherited preconditions\n-\n-         for J in Inherited'Range loop\n-            Prag := Pre_Post_Conditions (Contract (Inherited (J)));\n-\n-            while Present (Prag) loop\n-               if Pragma_Name (Prag) = Name_Precondition\n-                 and then Class_Present (Prag)\n-               then\n-                  Inherited_Precond := Grab_PPC (Inherited (J));\n-\n-                  --  No precondition so far, so establish this as the first\n-\n-                  if No (Precond) then\n-                     Precond := Inherited_Precond;\n-\n-                  --  Here we already have a precondition, add inherited one\n-\n-                  else\n-                     --  Add new precondition to old one using OR ELSE\n-\n-                     declare\n-                        New_Expr : constant Node_Id :=\n-                          Get_Pragma_Arg\n-                            (Next (First (Pragma_Argument_Associations\n-                                            (Inherited_Precond))));\n-                        Old_Expr : constant Node_Id :=\n-                          Get_Pragma_Arg\n-                            (Next (First (Pragma_Argument_Associations\n-                                             (Precond))));\n-\n-                     begin\n-                        if Paren_Count (Old_Expr) = 0 then\n-                           Set_Paren_Count (Old_Expr, 1);\n-                        end if;\n-\n-                        if Paren_Count (New_Expr) = 0 then\n-                           Set_Paren_Count (New_Expr, 1);\n-                        end if;\n-\n-                        Rewrite (Old_Expr,\n-                          Make_Or_Else (Sloc (Old_Expr),\n-                            Left_Opnd  => Relocate_Node (Old_Expr),\n-                            Right_Opnd => New_Expr));\n-                     end;\n-\n-                     --  Add new message in the form:\n-\n-                     --     failed precondition from bla\n-                     --       also failed inherited precondition from bla\n-                     --       ...\n-\n-                     --  Skip this if exception locations are suppressed\n-\n-                     if not Exception_Locations_Suppressed then\n-                        declare\n-                           New_Msg : constant Node_Id :=\n-                                       Get_Pragma_Arg\n-                                         (Last\n-                                            (Pragma_Argument_Associations\n-                                               (Inherited_Precond)));\n-                           Old_Msg : constant Node_Id :=\n-                                       Get_Pragma_Arg\n-                                         (Last\n-                                            (Pragma_Argument_Associations\n-                                               (Precond)));\n-                        begin\n-                           Start_String (Strval (Old_Msg));\n-                           Store_String_Chars (ASCII.LF & \"  also \");\n-                           Store_String_Chars (Strval (New_Msg));\n-                           Set_Strval (Old_Msg, End_String);\n-                        end;\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               Prag := Next_Pragma (Prag);\n-            end loop;\n-         end loop;\n-\n-         --  If we have built a precondition for Pre'Class (including any\n-         --  Pre'Class aspects inherited from parent subprograms), then we\n-         --  insert this composite precondition at this stage.\n-\n-         if Present (Precond) then\n-            Prepend (Precond, Declarations (N));\n-         end if;\n-      end if;\n-\n-      --  Build postconditions procedure if needed and prepend the following\n-      --  declaration to the start of the declarations for the subprogram.\n-\n-      --     procedure _postconditions [(_Result : resulttype)] is\n-      --     begin\n-      --        pragma Check (Refined_Post, condition);\n-      --        pragma Check (Refined_Post, condition);\n-      --        pragma Check (Postcondition, condition [,message]);\n-      --        pragma Check (Postcondition, condition [,message]);\n-      --        ...\n-      --        Invariant_Procedure (_Result) ...\n-      --        Invariant_Procedure (Arg1)\n-      --        ...\n-      --     end;\n-\n-      --  First we deal with the postconditions in the body\n-\n-      Collect_Body_Postconditions (Name_Refined_Post);\n-      Collect_Body_Postconditions (Name_Postcondition);\n-\n-      --  Now deal with any postconditions from the spec\n-\n-      if Present (Spec_Id) then\n-         Spec_Postconditions : declare\n-            procedure Process_Contract_Cases (Spec : Node_Id);\n-            --  This processes the Contract_Test_Cases from Spec, processing\n-            --  any contract-cases from the list. The caller has checked that\n-            --  Contract_Test_Cases is non-Empty.\n-\n-            procedure Process_Post_Conditions\n-              (Spec  : Node_Id;\n-               Class : Boolean);\n-            --  This processes the Pre_Post_Conditions from Spec, processing\n-            --  any postconditions from the list. If Class is True, then only\n-            --  postconditions marked with Class_Present are considered. The\n-            --  caller has checked that Pre_Post_Conditions is non-Empty.\n-\n-            ----------------------------\n-            -- Process_Contract_Cases --\n-            ----------------------------\n-\n-            procedure Process_Contract_Cases (Spec : Node_Id) is\n-            begin\n-               --  Loop through Contract_Cases pragmas from spec\n-\n-               Prag := Contract_Test_Cases (Contract (Spec));\n-               loop\n-                  if Pragma_Name (Prag) = Name_Contract_Cases then\n-                     Expand_Contract_Cases\n-                       (CCs     => Prag,\n-                        Subp_Id => Spec_Id,\n-                        Decls   => Declarations (N),\n-                        Stmts   => Plist);\n-                  end if;\n-\n-                  Prag := Next_Pragma (Prag);\n-                  exit when No (Prag);\n-               end loop;\n-            end Process_Contract_Cases;\n-\n-            -----------------------------\n-            -- Process_Post_Conditions --\n-            -----------------------------\n-\n-            procedure Process_Post_Conditions\n-              (Spec  : Node_Id;\n-               Class : Boolean)\n-            is\n-               Pspec : Node_Id;\n-\n-            begin\n-               if Class then\n-                  Pspec := Spec;\n-               else\n-                  Pspec := Empty;\n-               end if;\n-\n-               --  Loop through PPC pragmas from spec\n-\n-               Prag := Pre_Post_Conditions (Contract (Spec));\n-               loop\n-                  if Pragma_Name (Prag) = Name_Postcondition\n-                    and then (not Class or else Class_Present (Prag))\n-                  then\n-                     if not Expander_Active then\n-                        Prepend (Grab_PPC (Pspec), Declarations (N));\n-                     else\n-                        Append_Enabled_Item (Grab_PPC (Pspec), Plist);\n-                     end if;\n-                  end if;\n-\n-                  Prag := Next_Pragma (Prag);\n-                  exit when No (Prag);\n-               end loop;\n-            end Process_Post_Conditions;\n-\n-         --  Start of processing for Spec_Postconditions\n-\n-         begin\n-            --  Process postconditions expressed as contract-cases\n-\n-            if Present (Contract_Test_Cases (Contract (Spec_Id))) then\n-               Process_Contract_Cases (Spec_Id);\n-            end if;\n-\n-            --  Process spec postconditions\n-\n-            if Present (Pre_Post_Conditions (Contract (Spec_Id))) then\n-               Process_Post_Conditions (Spec_Id, Class => False);\n-            end if;\n-\n-            --  Process inherited postconditions\n-\n-            for J in Inherited'Range loop\n-               if Present (Pre_Post_Conditions (Contract (Inherited (J)))) then\n-                  Process_Post_Conditions (Inherited (J), Class => True);\n-               end if;\n-            end loop;\n-         end Spec_Postconditions;\n-      end if;\n-\n-      --  Add an invariant call to check the result of a function\n-\n-      if Ekind (Designator) /= E_Procedure and then Expander_Active then\n-         Func_Typ := Etype (Designator);\n-         Result   := Make_Defining_Identifier (Loc, Name_uResult);\n-\n-         Set_Etype (Result, Func_Typ);\n-\n-         --  Add argument for return\n-\n-         Parms := New_List (\n-           Make_Parameter_Specification (Loc,\n-             Defining_Identifier => Result,\n-             Parameter_Type      => New_Occurrence_Of (Func_Typ, Loc)));\n-\n-         --  Add invariant call if returning type with invariants and this is a\n-         --  public function, i.e. a function declared in the visible part of\n-         --  the package defining the private type.\n-\n-         if Has_Invariants (Func_Typ)\n-           and then Present (Invariant_Procedure (Func_Typ))\n-           and then not Has_Null_Body (Invariant_Procedure (Func_Typ))\n-           and then Is_Public_Subprogram_For (Func_Typ)\n-         then\n-            Append_Enabled_Item\n-              (Make_Invariant_Call (New_Occurrence_Of (Result, Loc)), Plist);\n-         end if;\n-\n-         --  Same if return value is an access to type with invariants\n-\n-         Check_Access_Invariants (Result);\n-\n-      --  Procedure case\n-\n-      else\n-         Parms := No_List;\n-      end if;\n-\n-      --  Add invariant calls and predicate calls for parameters. Note that\n-      --  this is done for functions as well, since in Ada 2012 they can have\n-      --  IN OUT args.\n-\n-      if Expander_Active then\n-         Formal := First_Formal (Designator);\n-         while Present (Formal) loop\n-            if Ekind (Formal) /= E_In_Parameter\n-              or else Is_Access_Type (Etype (Formal))\n-            then\n-               Formal_Typ := Etype (Formal);\n-\n-               if Has_Invariants (Formal_Typ)\n-                 and then Present (Invariant_Procedure (Formal_Typ))\n-                 and then not Has_Null_Body (Invariant_Procedure (Formal_Typ))\n-                 and then Is_Public_Subprogram_For (Formal_Typ)\n-               then\n-                  Append_Enabled_Item\n-                    (Make_Invariant_Call (New_Occurrence_Of (Formal, Loc)),\n-                     Plist);\n-               end if;\n-\n-               Check_Access_Invariants (Formal);\n-\n-               if Has_Predicates (Formal_Typ)\n-                 and then Present (Predicate_Function (Formal_Typ))\n-                 and then Has_Checked_Predicate (Formal_Typ)\n-               then\n-                  Append_Enabled_Item\n-                    (Make_Predicate_Check\n-                      (Formal_Typ, New_Occurrence_Of (Formal, Loc)),\n-                     Plist);\n-               end if;\n-            end if;\n-\n-            Next_Formal (Formal);\n-         end loop;\n-      end if;\n-\n-      --  Build and insert postcondition procedure\n-\n-      if Expander_Active and then Present (Plist) then\n-         Post_Proc :=\n-           Make_Defining_Identifier (Loc, Chars => Name_uPostconditions);\n-\n-         --  Insert the corresponding body of a post condition pragma after the\n-         --  last declaration of the context. This ensures that the body will\n-         --  not cause any premature freezing as it may mention types:\n-\n-         --    procedure Proc (Obj : Array_Typ) is\n-         --       procedure _postconditions is\n-         --       begin\n-         --          ... Obj ...\n-         --       end _postconditions;\n-\n-         --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n-         --    begin\n-\n-         --  In the example above, Obj is of type T but the incorrect placement\n-         --  of _postconditions will cause a crash in gigi due to an out of\n-         --  order reference. The body of _postconditions must be placed after\n-         --  the declaration of Temp to preserve correct visibility.\n-\n-         Insert_After_Last_Declaration (\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name       => Post_Proc,\n-                 Parameter_Specifications => Parms),\n-\n-             Declarations               => Empty_List,\n-\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Plist)));\n-\n-         Set_Ekind (Post_Proc, E_Procedure);\n-\n-         --  If this is a procedure, set the Postcondition_Proc attribute on\n-         --  the proper defining entity for the subprogram.\n-\n-         if Ekind (Designator) = E_Procedure then\n-            Set_Postcondition_Proc (Designator, Post_Proc);\n-         end if;\n-\n-         Set_Has_Postconditions (Designator);\n-      end if;\n-   end Process_PPCs;\n-\n    ----------------------------\n    -- Reference_Body_Formals --\n    ----------------------------"}, {"sha": "bc901cc8fab95a6c301673b3501cc4bf384191c5", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -46,9 +46,21 @@ package Sem_Ch6 is\n    procedure Analyze_Subprogram_Declaration          (N : Node_Id);\n    procedure Analyze_Subprogram_Body                 (N : Node_Id);\n \n+   procedure Analyze_Subprogram_Body_Contract (Subp : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of subprogram body\n+   --  Subp as if they appeared at the end of a declarative region. The aspects\n+   --  in question are:\n+   --    Refined_Depends\n+   --    Refined_Global\n+\n    procedure Analyze_Subprogram_Contract (Subp : Entity_Id);\n    --  Analyze all delayed aspects chained on the contract of subprogram Subp\n-   --  as if they appeared at the end of a declarative region.\n+   --  as if they appeared at the end of a declarative region. The aspects in\n+   --  question are:\n+   --    Contract_Cases\n+   --    Postcondition\n+   --    Precondition\n+   --    Test_Case\n \n    function Analyze_Subprogram_Specification (N : Node_Id) return Entity_Id;\n    --  Analyze subprogram specification in both subprogram declarations"}, {"sha": "7b0f71f15b0cadfcccf62adbe476fec32d04a268", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 241, "deletions": 244, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -404,6 +404,7 @@ package body Sem_Prag is\n       Arg1      : constant Node_Id := First (Pragma_Argument_Associations (N));\n       All_Cases : Node_Id;\n       CCase     : Node_Id;\n+      Restore   : Boolean := False;\n       Subp_Decl : Node_Id;\n       Subp_Id   : Entity_Id;\n \n@@ -431,6 +432,7 @@ package body Sem_Prag is\n             --  for subprogram bodies because the formals are already visible.\n \n             if Requires_Profile_Installation (N, Subp_Decl) then\n+               Restore := True;\n                Push_Scope (Subp_Id);\n                Install_Formals (Subp_Id);\n             end if;\n@@ -441,7 +443,7 @@ package body Sem_Prag is\n                Next (CCase);\n             end loop;\n \n-            if Requires_Profile_Installation (N, Subp_Decl) then\n+            if Restore then\n                End_Scope;\n             end if;\n          end if;\n@@ -1234,6 +1236,9 @@ package body Sem_Prag is\n       Last_Clause : Node_Id;\n       Subp_Decl   : Node_Id;\n \n+      Restore_Scope : Boolean := False;\n+      --  Gets set True if we do a Push_Scope needing a Pop_Scope on exit\n+\n    --  Start of processing for Analyze_Depends_In_Decl_Part\n \n    begin\n@@ -1287,6 +1292,7 @@ package body Sem_Prag is\n          --  bodies because the formals are already visible.\n \n          if Requires_Profile_Installation (N, Subp_Decl) then\n+            Restore_Scope := True;\n             Push_Scope (Subp_Id);\n             Install_Formals (Subp_Id);\n          end if;\n@@ -1317,7 +1323,7 @@ package body Sem_Prag is\n             Next (Clause);\n          end loop;\n \n-         if Requires_Profile_Installation (N, Subp_Decl) then\n+         if Restore_Scope then\n             End_Scope;\n          end if;\n \n@@ -1690,6 +1696,9 @@ package body Sem_Prag is\n       List      : Node_Id;\n       Subp_Decl : Node_Id;\n \n+      Restore_Scope : Boolean := False;\n+      --  Set True if we do a Push_Scope requiring a Pop_Scope on exit\n+\n    --  Start of processing for Analyze_Global_In_Decl_List\n \n    begin\n@@ -1714,171 +1723,19 @@ package body Sem_Prag is\n          --  subprogram declarations.\n \n          if Requires_Profile_Installation (N, Subp_Decl) then\n+            Restore_Scope := True;\n             Push_Scope (Subp_Id);\n             Install_Formals (Subp_Id);\n          end if;\n \n          Analyze_Global_List (List);\n \n-         if Requires_Profile_Installation (N, Subp_Decl) then\n+         if Restore_Scope then\n             End_Scope;\n          end if;\n       end if;\n    end Analyze_Global_In_Decl_Part;\n \n-   ------------------------------\n-   -- Analyze_PPC_In_Decl_Part --\n-   ------------------------------\n-\n-   procedure Analyze_PPC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n-      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n-\n-   begin\n-      --  Install formals and push subprogram spec onto scope stack so that we\n-      --  can see the formals from the pragma.\n-\n-      Install_Formals (S);\n-      Push_Scope (S);\n-\n-      --  Preanalyze the boolean expression, we treat this as a spec expression\n-      --  (i.e. similar to a default expression).\n-\n-      --  In ASIS mode, for a pragma generated from a source aspect, analyze\n-      --  directly the the original aspect expression, which is shared with\n-      --  the generated pragma.\n-\n-      if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n-         Preanalyze_Assert_Expression\n-           (Expression (Corresponding_Aspect (N)), Standard_Boolean);\n-      else\n-         Preanalyze_Assert_Expression\n-            (Get_Pragma_Arg (Arg1), Standard_Boolean);\n-      end if;\n-\n-      --  For a class-wide condition, a reference to a controlling formal must\n-      --  be interpreted as having the class-wide type (or an access to such)\n-      --  so that the inherited condition can be properly applied to any\n-      --  overriding operation (see ARM12 6.6.1 (7)).\n-\n-      if Class_Present (N) then\n-         Class_Wide_Condition : declare\n-            T   : constant Entity_Id := Find_Dispatching_Type (S);\n-\n-            ACW : Entity_Id := Empty;\n-            --  Access to T'class, created if there is a controlling formal\n-            --  that is an access parameter.\n-\n-            function Get_ACW return Entity_Id;\n-            --  If the expression has a reference to an controlling access\n-            --  parameter, create an access to T'class for the necessary\n-            --  conversions if one does not exist.\n-\n-            function Process (N : Node_Id) return Traverse_Result;\n-            --  ARM 6.1.1: Within the expression for a Pre'Class or Post'Class\n-            --  aspect for a primitive subprogram of a tagged type T, a name\n-            --  that denotes a formal parameter of type T is interpreted as\n-            --  having type T'Class. Similarly, a name that denotes a formal\n-            --  accessparameter of type access-to-T is interpreted as having\n-            --  type access-to-T'Class. This ensures the expression is well-\n-            --  defined for a primitive subprogram of a type descended from T.\n-            --  Note that this replacement is not done for selector names in\n-            --  parameter associations. These carry an entity for reference\n-            --  purposes, but semantically they are just identifiers.\n-\n-            -------------\n-            -- Get_ACW --\n-            -------------\n-\n-            function Get_ACW return Entity_Id is\n-               Loc  : constant Source_Ptr := Sloc (N);\n-               Decl : Node_Id;\n-\n-            begin\n-               if No (ACW) then\n-                  Decl := Make_Full_Type_Declaration (Loc,\n-                    Defining_Identifier => Make_Temporary (Loc, 'T'),\n-                    Type_Definition =>\n-                       Make_Access_To_Object_Definition (Loc,\n-                       Subtype_Indication =>\n-                         New_Occurrence_Of (Class_Wide_Type (T), Loc),\n-                       All_Present => True));\n-\n-                  Insert_Before (Unit_Declaration_Node (S), Decl);\n-                  Analyze (Decl);\n-                  ACW := Defining_Identifier (Decl);\n-                  Freeze_Before (Unit_Declaration_Node (S), ACW);\n-               end if;\n-\n-               return ACW;\n-            end Get_ACW;\n-\n-            -------------\n-            -- Process --\n-            -------------\n-\n-            function Process (N : Node_Id) return Traverse_Result is\n-               Loc : constant Source_Ptr := Sloc (N);\n-               Typ : Entity_Id;\n-\n-            begin\n-               if Is_Entity_Name (N)\n-                 and then Present (Entity (N))\n-                 and then Is_Formal (Entity (N))\n-                 and then Nkind (Parent (N)) /= N_Type_Conversion\n-                 and then\n-                   (Nkind (Parent (N)) /= N_Parameter_Association\n-                     or else N /= Selector_Name (Parent (N)))\n-               then\n-                  if Etype (Entity (N)) = T then\n-                     Typ := Class_Wide_Type (T);\n-\n-                  elsif Is_Access_Type (Etype (Entity (N)))\n-                    and then Designated_Type (Etype (Entity (N))) = T\n-                  then\n-                     Typ := Get_ACW;\n-                  else\n-                     Typ := Empty;\n-                  end if;\n-\n-                  if Present (Typ) then\n-                     Rewrite (N,\n-                       Make_Type_Conversion (Loc,\n-                         Subtype_Mark =>\n-                           New_Occurrence_Of (Typ, Loc),\n-                         Expression  => New_Occurrence_Of (Entity (N), Loc)));\n-                     Set_Etype (N, Typ);\n-                  end if;\n-               end if;\n-\n-               return OK;\n-            end Process;\n-\n-            procedure Replace_Type is new Traverse_Proc (Process);\n-\n-         --  Start of processing for Class_Wide_Condition\n-\n-         begin\n-            if not Present (T) then\n-               Error_Msg_Name_1 :=\n-                 Chars (Identifier (Corresponding_Aspect (N)));\n-\n-               Error_Msg_Name_2 := Name_Class;\n-\n-               Error_Msg_N\n-                 (\"aspect `%''%` can only be specified for a primitive \"\n-                  & \"operation of a tagged type\", Corresponding_Aspect (N));\n-            end if;\n-\n-            Replace_Type (Get_Pragma_Arg (Arg1));\n-         end Class_Wide_Condition;\n-      end if;\n-\n-      --  Remove the subprogram from the scope stack now that the pre-analysis\n-      --  of the precondition/postcondition is done.\n-\n-      End_Scope;\n-   end Analyze_PPC_In_Decl_Part;\n-\n    --------------------\n    -- Analyze_Pragma --\n    --------------------\n@@ -1922,15 +1779,9 @@ package body Sem_Prag is\n       --  In Ada 95 or 05 mode, these are implementation defined pragmas, so\n       --  should be caught by the No_Implementation_Pragmas restriction.\n \n-      procedure Analyze_Refined_Pre_Post\n-        (Body_Decl : out Node_Id;\n-         Spec_Id   : out Entity_Id;\n-         Legal     : out Boolean);\n+      procedure Analyze_Refined_Pre_Post_Condition;\n       --  Subsidiary routine to the analysis of pragmas Refined_Pre and\n-      --  Refined_Post. Body_Decl is the declaration of the subprogram body\n-      --  [stub] subject to the pragma. Spec_Id is the corresponding spec of\n-      --  the subprogram body [stub]. Flag Legal denotes whether the pragma\n-      --  passes all legality rules.\n+      --  Refined_Post.\n \n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n@@ -2458,26 +2309,18 @@ package body Sem_Prag is\n          end if;\n       end Ada_2012_Pragma;\n \n-      ------------------------------\n-      -- Analyze_Refined_Pre_Post --\n-      ------------------------------\n+      ----------------------------------------\n+      -- Analyze_Refined_Pre_Post_Condition --\n+      ----------------------------------------\n \n-      procedure Analyze_Refined_Pre_Post\n-        (Body_Decl : out Node_Id;\n-         Spec_Id   : out Entity_Id;\n-         Legal     : out Boolean)\n-      is\n+      procedure Analyze_Refined_Pre_Post_Condition is\n+         Body_Decl : Node_Id := Parent (N);\n          Pack_Spec : Node_Id;\n          Spec_Decl : Node_Id;\n+         Spec_Id   : Entity_Id;\n          Stmt      : Node_Id;\n \n       begin\n-         --  Assume that the pragma is illegal\n-\n-         Body_Decl := Parent (N);\n-         Spec_Id   := Empty;\n-         Legal     := False;\n-\n          GNAT_Pragma;\n          Check_Arg_Count (1);\n          Check_No_Identifiers;\n@@ -2576,10 +2419,10 @@ package body Sem_Prag is\n             return;\n          end if;\n \n-         --  If we get here, the placement and legality of the pragma is OK\n+         --  Analyze the boolean expression as a \"spec expression\"\n \n-         Legal := True;\n-      end Analyze_Refined_Pre_Post;\n+         Analyze_Pre_Post_Condition_In_Decl_Part (N, Spec_Id);\n+      end Analyze_Refined_Pre_Post_Condition;\n \n       --------------------------\n       -- Check_Ada_83_Warning --\n@@ -3791,7 +3634,7 @@ package body Sem_Prag is\n             --  analyzed.\n \n             if SPARK_Mode or else ASIS_Mode then\n-               Analyze_PPC_In_Decl_Part\n+               Analyze_Pre_Post_Condition_In_Decl_Part\n                  (N, Defining_Entity (Unit (Parent (PO))));\n             end if;\n \n@@ -16092,81 +15935,44 @@ package body Sem_Prag is\n          when Pragma_Rational =>\n             Set_Rational_Profile;\n \n-         ------------------\n-         -- Refined_Post --\n-         ------------------\n+         ---------------------\n+         -- Refined_Depends --\n+         ---------------------\n \n-         --  pragma Refined_Post (boolean_EXPRESSION);\n+         --  ??? To be implemented\n \n-         when Pragma_Refined_Post => Refined_Post : declare\n-            Body_Decl : Node_Id;\n-            Legal     : Boolean;\n-            Spec_Id   : Entity_Id;\n+         when Pragma_Refined_Depends =>\n+            null;\n \n-         begin\n-            --  Verify the legal placement of the pragma. The pragma is left\n-            --  intentionally semi-analyzed. Process_PPCs does the remaining\n-            --  analysis of the expression when Refined_Post is converted into\n-            --  pragma Check.\n+         --------------------\n+         -- Refined_Global --\n+         --------------------\n \n-            Analyze_Refined_Pre_Post (Body_Decl, Spec_Id, Legal);\n+         --  ??? To be implemented\n \n-            --  Analyze the expression when code generation is disabled because\n-            --  the contract of the related subprogram will never be processed.\n+         --  Would be better if these generated an error message saying that\n+         --  the feature was not yet implemented ???\n \n-            if Legal and then not Expander_Active then\n-               Analyze_And_Resolve (Get_Pragma_Arg (Arg1), Standard_Boolean);\n-            end if;\n-         end Refined_Post;\n+         when Pragma_Refined_Global =>\n+            null;\n+\n+         ------------------\n+         -- Refined_Post --\n+         ------------------\n+\n+         --  pragma Refined_Post (boolean_EXPRESSION);\n+\n+         when Pragma_Refined_Post =>\n+            Analyze_Refined_Pre_Post_Condition;\n \n          -----------------\n          -- Refined_Pre --\n          -----------------\n \n          --  pragma Refined_Pre (boolean_EXPRESSION);\n \n-         when Pragma_Refined_Pre => Refined_Pre : declare\n-            Body_Decl : Node_Id;\n-            Legal     : Boolean;\n-            Restore   : Boolean := False;\n-            Spec_Id   : Entity_Id;\n-\n-         begin\n-            Analyze_Refined_Pre_Post (Body_Decl, Spec_Id, Legal);\n-\n-            if Legal then\n-               pragma Assert (Present (Body_Decl));\n-               pragma Assert (Present (Spec_Id));\n-\n-               if Nkind (Body_Decl) = N_Subprogram_Body_Stub\n-                 and then No (Library_Unit (Body_Decl))\n-                 and then Current_Scope /= Spec_Id\n-               then\n-                  Restore := True;\n-                  Push_Scope (Spec_Id);\n-                  Install_Formals (Spec_Id);\n-               end if;\n-\n-               --  Convert pragma Refined_Pre into pragma Check. The analysis\n-               --  of the generated pragma will take care of the expression.\n-\n-               Rewrite (N,\n-                 Make_Pragma (Loc,\n-                   Chars                        => Name_Check,\n-                   Pragma_Argument_Associations => New_List (\n-                     Make_Pragma_Argument_Association (Loc,\n-                       Expression => Make_Identifier (Loc, Pname)),\n-\n-                     Make_Pragma_Argument_Association (Sloc (Arg1),\n-                       Expression => Relocate_Node (Get_Pragma_Arg (Arg1))))));\n-\n-               Analyze (N);\n-\n-               if Restore then\n-                  Pop_Scope;\n-               end if;\n-            end if;\n-         end Refined_Pre;\n+         when Pragma_Refined_Pre =>\n+            Analyze_Refined_Pre_Post_Condition;\n \n          -----------------------\n          -- Relative_Deadline --\n@@ -18499,6 +18305,195 @@ package body Sem_Prag is\n       when Pragma_Exit => null;\n    end Analyze_Pragma;\n \n+   ---------------------------------------------\n+   -- Analyze_Pre_Post_Condition_In_Decl_Part --\n+   ---------------------------------------------\n+\n+   procedure Analyze_Pre_Post_Condition_In_Decl_Part\n+     (Prag    : Node_Id;\n+      Subp_Id : Entity_Id)\n+   is\n+      Arg1    : constant Node_Id :=\n+                  First (Pragma_Argument_Associations (Prag));\n+      Expr    : Node_Id;\n+      Restore : Boolean := False;\n+\n+   begin\n+      --  Ensure that the subprogram and its formals are visible when analyzing\n+      --  the expression of the pragma.\n+\n+      if Current_Scope /= Subp_Id then\n+         Restore := True;\n+         Push_Scope (Subp_Id);\n+         Install_Formals (Subp_Id);\n+      end if;\n+\n+      --  Preanalyze the boolean expression, we treat this as a spec expression\n+      --  (i.e. similar to a default expression).\n+\n+      Expr := Get_Pragma_Arg (Arg1);\n+\n+      --  In ASIS mode, for a pragma generated from a source aspect, analyze\n+      --  the original aspect expression, which is shared with the generated\n+      --  pragma.\n+\n+      if ASIS_Mode and then Present (Corresponding_Aspect (Prag)) then\n+         Expr := Expression (Corresponding_Aspect (Prag));\n+      end if;\n+\n+      Preanalyze_Assert_Expression (Expr, Standard_Boolean);\n+\n+      --  For a class-wide condition, a reference to a controlling formal must\n+      --  be interpreted as having the class-wide type (or an access to such)\n+      --  so that the inherited condition can be properly applied to any\n+      --  overriding operation (see ARM12 6.6.1 (7)).\n+\n+      if Class_Present (Prag) then\n+         Class_Wide_Condition : declare\n+            T : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n+\n+            ACW : Entity_Id := Empty;\n+            --  Access to T'class, created if there is a controlling formal\n+            --  that is an access parameter.\n+\n+            function Get_ACW return Entity_Id;\n+            --  If the expression has a reference to an controlling access\n+            --  parameter, create an access to T'class for the necessary\n+            --  conversions if one does not exist.\n+\n+            function Process (N : Node_Id) return Traverse_Result;\n+            --  ARM 6.1.1: Within the expression for a Pre'Class or Post'Class\n+            --  aspect for a primitive subprogram of a tagged type T, a name\n+            --  that denotes a formal parameter of type T is interpreted as\n+            --  having type T'Class. Similarly, a name that denotes a formal\n+            --  accessparameter of type access-to-T is interpreted as having\n+            --  type access-to-T'Class. This ensures the expression is well-\n+            --  defined for a primitive subprogram of a type descended from T.\n+            --  Note that this replacement is not done for selector names in\n+            --  parameter associations. These carry an entity for reference\n+            --  purposes, but semantically they are just identifiers.\n+\n+            -------------\n+            -- Get_ACW --\n+            -------------\n+\n+            function Get_ACW return Entity_Id is\n+               Loc  : constant Source_Ptr := Sloc (Prag);\n+               Decl : Node_Id;\n+\n+            begin\n+               if No (ACW) then\n+                  Decl :=\n+                    Make_Full_Type_Declaration (Loc,\n+                      Defining_Identifier => Make_Temporary (Loc, 'T'),\n+                      Type_Definition     =>\n+                         Make_Access_To_Object_Definition (Loc,\n+                           Subtype_Indication =>\n+                             New_Occurrence_Of (Class_Wide_Type (T), Loc),\n+                           All_Present        => True));\n+\n+                  Insert_Before (Unit_Declaration_Node (Subp_Id), Decl);\n+                  Analyze (Decl);\n+                  ACW := Defining_Identifier (Decl);\n+                  Freeze_Before (Unit_Declaration_Node (Subp_Id), ACW);\n+               end if;\n+\n+               return ACW;\n+            end Get_ACW;\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n+            function Process (N : Node_Id) return Traverse_Result is\n+               Loc : constant Source_Ptr := Sloc (N);\n+               Typ : Entity_Id;\n+\n+            begin\n+               if Is_Entity_Name (N)\n+                 and then Present (Entity (N))\n+                 and then Is_Formal (Entity (N))\n+                 and then Nkind (Parent (N)) /= N_Type_Conversion\n+                 and then\n+                   (Nkind (Parent (N)) /= N_Parameter_Association\n+                     or else N /= Selector_Name (Parent (N)))\n+               then\n+                  if Etype (Entity (N)) = T then\n+                     Typ := Class_Wide_Type (T);\n+\n+                  elsif Is_Access_Type (Etype (Entity (N)))\n+                    and then Designated_Type (Etype (Entity (N))) = T\n+                  then\n+                     Typ := Get_ACW;\n+                  else\n+                     Typ := Empty;\n+                  end if;\n+\n+                  if Present (Typ) then\n+                     Rewrite (N,\n+                       Make_Type_Conversion (Loc,\n+                         Subtype_Mark =>\n+                           New_Occurrence_Of (Typ, Loc),\n+                         Expression  => New_Occurrence_Of (Entity (N), Loc)));\n+                     Set_Etype (N, Typ);\n+                  end if;\n+               end if;\n+\n+               return OK;\n+            end Process;\n+\n+            procedure Replace_Type is new Traverse_Proc (Process);\n+\n+         --  Start of processing for Class_Wide_Condition\n+\n+         begin\n+            if not Present (T) then\n+               Error_Msg_Name_1 :=\n+                 Chars (Identifier (Corresponding_Aspect (Prag)));\n+\n+               Error_Msg_Name_2 := Name_Class;\n+\n+               Error_Msg_N\n+                 (\"aspect `%''%` can only be specified for a primitive \"\n+                  & \"operation of a tagged type\", Corresponding_Aspect (Prag));\n+            end if;\n+\n+            Replace_Type (Get_Pragma_Arg (Arg1));\n+         end Class_Wide_Condition;\n+      end if;\n+\n+      --  Remove the subprogram from the scope stack now that the pre-analysis\n+      --  of the precondition/postcondition is done.\n+\n+      if Restore then\n+         End_Scope;\n+      end if;\n+   end Analyze_Pre_Post_Condition_In_Decl_Part;\n+\n+   ------------------------------------------\n+   -- Analyze_Refined_Depends_In_Decl_Part --\n+   ------------------------------------------\n+\n+   --  ??? To be implemented\n+\n+   procedure Analyze_Refined_Depends_In_Decl_Part (N : Node_Id) is\n+      pragma Unreferenced (N);\n+   begin\n+      null;\n+   end Analyze_Refined_Depends_In_Decl_Part;\n+\n+   -----------------------------------------\n+   -- Analyze_Refined_Global_In_Decl_Part --\n+   -----------------------------------------\n+\n+   --  ??? To be implemented\n+\n+   procedure Analyze_Refined_Global_In_Decl_Part (N : Node_Id) is\n+      pragma Unreferenced (N);\n+   begin\n+      null;\n+   end Analyze_Refined_Global_In_Decl_Part;\n+\n    ------------------------------------\n    -- Analyze_Test_Case_In_Decl_Part --\n    ------------------------------------\n@@ -19251,6 +19246,8 @@ package body Sem_Prag is\n       Pragma_Queuing_Policy                 => -1,\n       Pragma_Rational                       => -1,\n       Pragma_Ravenscar                      => -1,\n+      Pragma_Refined_Depends                => -1,\n+      Pragma_Refined_Global                 => -1,\n       Pragma_Refined_Post                   => -1,\n       Pragma_Refined_Pre                    => -1,\n       Pragma_Relative_Deadline              => -1,"}, {"sha": "3b8114fef0da90475fa93c959e8d4028146cfdd7", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -38,11 +38,13 @@ package Sem_Prag is\n    --  the pragmas below implement an aspect.\n \n    Pragma_On_Body_Or_Stub_OK : constant array (Pragma_Id) of Boolean :=\n-     (Pragma_Refined_Post => True,\n-      Pragma_Refined_Pre  => True,\n-      Pragma_SPARK_Mode   => True,\n-      Pragma_Warnings     => True,\n-      others              => False);\n+     (Pragma_Refined_Depends => True,\n+      Pragma_Refined_Global  => True,\n+      Pragma_Refined_Post    => True,\n+      Pragma_Refined_Pre     => True,\n+      Pragma_SPARK_Mode      => True,\n+      Pragma_Warnings        => True,\n+      others                 => False);\n \n    -----------------\n    -- Subprograms --\n@@ -60,21 +62,27 @@ package Sem_Prag is\n    procedure Analyze_Global_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Global\n \n-   procedure Analyze_PPC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n-   --  Special analyze routine for precondition/postcondition pragma that\n-   --  appears within a declarative part where the pragma is associated\n-   --  with a subprogram specification. N is the pragma node, and S is the\n-   --  entity for the related subprogram. This procedure does a preanalysis\n-   --  of the expressions in the pragma as \"spec expressions\" (see section\n-   --  in Sem \"Handling of Default and Per-Object Expressions...\").\n+   procedure Analyze_Pre_Post_Condition_In_Decl_Part\n+     (Prag    : Node_Id;\n+      Subp_Id : Entity_Id);\n+   --  Perform preanalysis of a [refined] precondition or postcondition that\n+   --  appears on a subprogram declaration or body [stub]. Prag denotes the\n+   --  pragma, Subp_Id is the entity of the related subprogram. The preanalysis\n+   --  of the expression is done as \"spec expression\" (see section \"Handling\n+   --  of Default and Per-Object Expressions in Sem).\n+\n+   procedure Analyze_Refined_Depends_In_Decl_Part (N : Node_Id);\n+   --  Preform full analysis of delayed pragma Refined_Depends\n+\n+   procedure Analyze_Refined_Global_In_Decl_Part (N : Node_Id);\n+   --  Perform full analysis of delayed pragma Refined_Global\n \n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id; S : Entity_Id);\n-   --  Special analyze routine for contract-case and test-case pragmas that\n-   --  appears within a declarative part where the pragma is associated with\n-   --  a subprogram specification. N is the pragma node, and S is the entity\n-   --  for the related subprogram. This procedure does a preanalysis of the\n-   --  expressions in the pragma as \"spec expressions\" (see section in Sem\n-   --  \"Handling of Default and Per-Object Expressions...\").\n+   --  Perform preanalysis of pragma Test_Case that applies to a subprogram\n+   --  declaration. Parameter N denotes the pragma, S is the entity of the\n+   --  related subprogram. The preanalysis of the expression is done as \"spec\n+   --  expression\" (see section \"Handling of Default and Per-Object Expressions\n+   --  in Sem).\n \n    procedure Check_Applicable_Policy (N : Node_Id);\n    --  N is either an N_Aspect or an N_Pragma node. There are two cases. If"}, {"sha": "6913c26088465309794d1b46a4092a246ea66419", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -212,36 +212,52 @@ package body Sem_Util is\n    -- Add_Contract_Item --\n    -----------------------\n \n-   procedure Add_Contract_Item (Item : Node_Id; Subp_Id : Entity_Id) is\n+   procedure Add_Contract_Item (Prag : Node_Id; Subp_Id : Entity_Id) is\n       Items : constant Node_Id := Contract (Subp_Id);\n       Nam   : Name_Id;\n \n    begin\n-      if Present (Items) and then Nkind (Item) = N_Pragma then\n-         Nam := Pragma_Name (Item);\n+      --  The related subprogram [body] must have a contract and the item to be\n+      --  added must be a pragma.\n \n-         if Nam_In (Nam, Name_Precondition, Name_Postcondition) then\n-            Set_Next_Pragma (Item, Pre_Post_Conditions (Items));\n-            Set_Pre_Post_Conditions (Items, Item);\n+      pragma Assert (Present (Items));\n+      pragma Assert (Nkind (Prag) = N_Pragma);\n \n-         elsif Nam_In (Nam, Name_Contract_Cases, Name_Test_Case) then\n-            Set_Next_Pragma (Item, Contract_Test_Cases (Items));\n-            Set_Contract_Test_Cases (Items, Item);\n+      Nam := Pragma_Name (Prag);\n \n-         elsif Nam_In (Nam, Name_Depends, Name_Global) then\n-            Set_Next_Pragma (Item, Classifications (Items));\n-            Set_Classifications (Items, Item);\n+      --  Contract items related to subprogram bodies\n+\n+      if Ekind (Subp_Id) = E_Subprogram_Body then\n+         if Nam_In (Nam, Name_Refined_Depends, Name_Refined_Global) then\n+            Set_Next_Pragma (Prag, Classifications (Items));\n+            Set_Classifications (Items, Prag);\n \n          --  The pragma is not a proper contract item\n \n          else\n             raise Program_Error;\n          end if;\n \n-      --  The subprogram has not been properly decorated or the item is illegal\n+      --  Contract items related to subprogram declarations\n \n       else\n-         raise Program_Error;\n+         if Nam_In (Nam, Name_Precondition, Name_Postcondition) then\n+            Set_Next_Pragma (Prag, Pre_Post_Conditions (Items));\n+            Set_Pre_Post_Conditions (Items, Prag);\n+\n+         elsif Nam_In (Nam, Name_Contract_Cases, Name_Test_Case) then\n+            Set_Next_Pragma (Prag, Contract_Test_Cases (Items));\n+            Set_Contract_Test_Cases (Items, Prag);\n+\n+         elsif Nam_In (Nam, Name_Depends, Name_Global) then\n+            Set_Next_Pragma (Prag, Classifications (Items));\n+            Set_Classifications (Items, Prag);\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n       end if;\n    end Add_Contract_Item;\n "}, {"sha": "3053bee8dcdf6c63507882fffc28e52738854333", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -43,10 +43,17 @@ package Sem_Util is\n    --  Add A to the list of access types to process when expanding the\n    --  freeze node of E.\n \n-   procedure Add_Contract_Item (Item : Node_Id; Subp_Id : Entity_Id);\n-   --  Add a contract item (pragma Precondition, Postcondition, Test_Case,\n-   --  Contract_Cases, Global, Depends) to the contract of a subprogram. Item\n-   --  denotes a pragma and Subp_Id is the related subprogram.\n+   procedure Add_Contract_Item (Prag : Node_Id; Subp_Id : Entity_Id);\n+   --  Add one of the following contract item to the contract of a subprogram.\n+   --  Prag denotes a pragma and Subp_Id is the related subprogram [body].\n+   --    Contract_Cases\n+   --    Depends\n+   --    Global\n+   --    Postcondition\n+   --    Precondition\n+   --    Refined_Depends\n+   --    Refined_Global\n+   --    Test_Case\n \n    procedure Add_Global_Declaration (N : Node_Id);\n    --  These procedures adds a declaration N at the library level, to be"}, {"sha": "83a1606cb38d3e37c2ebd8b9522994f3b540747d", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -7143,11 +7143,10 @@ package Sinfo is\n       --------------\n \n       --  This node is used to hold the various parts of an entry or subprogram\n-      --  contract, consisting in pre- and postconditions on the one hand, and\n-      --  test-cases on the other hand.\n+      --  [body] contract, consisting of precondition, postconditions, contract\n+      --  cases, test cases and global dependencies.\n \n-      --  It is referenced from an entry, a subprogram or a generic subprogram\n-      --  entity.\n+      --  The node appears in an entry and [generic] subprogram [body] entity.\n \n       --  Sprint syntax:  <none> as the node should not appear in the tree, but\n       --                  only attached to an entry or [generic] subprogram\n@@ -7160,9 +7159,10 @@ package Sinfo is\n       --  Classifications (Node3) (set to Empty if none)\n \n       --  Pre_Post_Conditions contains a collection of pragmas that correspond\n-      --  to pre- and postconditions associated with an entry or a subprogram.\n-      --  The pragmas can either come from source or be the byproduct of aspect\n-      --  expansion. The ordering in the list is in LIFO fashion.\n+      --  to pre- and postconditions associated with an entry or a subprogram\n+      --  [body or stub]. The pragmas can either come from source or be the\n+      --  byproduct of aspect expansion. The ordering in the list is in LIFO\n+      --  fashion.\n \n       --  Note that there might be multiple preconditions or postconditions\n       --  in this list, either because they come from separate pragmas in the\n@@ -7175,8 +7175,8 @@ package Sinfo is\n \n       --  Classifications contains pragmas that either categorize subprogram\n       --  inputs and outputs or establish dependencies between them. Currently\n-      --  pragmas Depends and Global are stored in this list. The ordering is\n-      --  in LIFO fashion.\n+      --  pragmas Depends, Global, Refined_Depends and Refined_Global are\n+      --  stored in this list. The ordering is in LIFO fashion.\n \n       -------------------\n       -- Expanded_Name --"}, {"sha": "8aed6308baea45a9d342ff2c46145d8e141450b8", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -580,6 +580,8 @@ package Snames is\n    Name_Pure_05                        : constant Name_Id := N + $; -- GNAT\n    Name_Pure_12                        : constant Name_Id := N + $; -- GNAT\n    Name_Pure_Function                  : constant Name_Id := N + $; -- GNAT\n+   Name_Refined_Depends                : constant Name_Id := N + $; -- GNAT\n+   Name_Refined_Global                 : constant Name_Id := N + $; -- GNAT\n    Name_Refined_Post                   : constant Name_Id := N + $; -- GNAT\n    Name_Refined_Pre                    : constant Name_Id := N + $; -- GNAT\n    Name_Relative_Deadline              : constant Name_Id := N + $; -- Ada 05\n@@ -1865,6 +1867,8 @@ package Snames is\n       Pragma_Pure_05,\n       Pragma_Pure_12,\n       Pragma_Pure_Function,\n+      Pragma_Refined_Depends,\n+      Pragma_Refined_Global,\n       Pragma_Refined_Post,\n       Pragma_Refined_Pre,\n       Pragma_Relative_Deadline,"}, {"sha": "4888d69e190499dfd2b83f642c48c304db735a32", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea3c0651d31936376fae927e5099f74d359e0adb/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=ea3c0651d31936376fae927e5099f74d359e0adb", "patch": "@@ -172,7 +172,7 @@ package Types is\n    for Physical_Line_Number'Size use 32;\n    --  Line number type, used for storing physical line numbers (i.e. line\n    --  numbers in the physical file being compiled, unaffected by the presence\n-   --  of source reference pragmas.\n+   --  of source reference pragmas).\n \n    type Column_Number is range 0 .. 32767;\n    for Column_Number'Size use 16;"}]}