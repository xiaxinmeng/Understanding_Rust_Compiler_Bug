{"sha": "3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JjYjFiYjBjNjUyZjhkODhlNjhlZDFkNTE1N2ZlYWQ0YTY2NzUzNg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-02-11T22:44:29Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-02-11T22:44:29Z"}, "message": "Minot for,matting imrpovemants and synchronisation with devo sources\n\nFrom-SVN: r31937", "tree": {"sha": "6cec572822bbe316028951805f3c6da3de63c804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cec572822bbe316028951805f3c6da3de63c804"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/comments", "author": null, "committer": null, "parents": [{"sha": "914a3b8c0eec767f0c634442d84b977ef5d5bdc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/914a3b8c0eec767f0c634442d84b977ef5d5bdc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/914a3b8c0eec767f0c634442d84b977ef5d5bdc3"}], "stats": {"total": 386, "additions": 198, "deletions": 188}, "files": [{"sha": "74fb280c8f714d7e466cf9277e8ba374e6cad303", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -106,6 +106,7 @@ extern char * output_move_double\t\tPARAMS ((rtx *));\n extern char * output_return_instruction\t\tPARAMS ((rtx, int, int));\n extern int    store_multiple_sequence\t\tPARAMS ((rtx *, int, int *, int *, HOST_WIDE_INT *));\n extern int    symbol_mentioned_p\t\tPARAMS ((rtx));\n+extern int    arm_is_longcall_p\t\t\tPARAMS ((rtx, int, int));\n #if defined AOF_ASSEMBLER \n extern rtx    aof_pic_entry\t\t\tPARAMS ((rtx));\n #endif /* AOF_ASSEMBLER */\n@@ -145,6 +146,7 @@ extern int    shift_operator\t\t\tPARAMS ((rtx, Mmode));\n extern int    shiftable_operator\t\tPARAMS ((rtx, Mmode));\n extern int    soft_df_operand\t\t\tPARAMS ((rtx, Mmode));\n extern int    store_multiple_operation\t\tPARAMS ((rtx, Mmode));\n+\n #if defined TREE_CODE\n extern rtx    arm_function_arg\t\t\tPARAMS ((CUMULATIVE_ARGS *, Mmode, tree, int));\n extern void   arm_init_cumulative_args\t\tPARAMS ((CUMULATIVE_ARGS *, tree, rtx, int));"}, {"sha": "1f57e8bd3f855a49682d2414ad8733f18134da5c", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -1,5 +1,5 @@\n /* Routines for GCC for ARM/pe.\n-   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.\n    Contributed by Doug Evans (dje@cygnus.com).\n \n This file is part of GNU CC.\n@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"expr.h\"\n #include \"toplev.h\"\n+#include \"arm-protos.h\"\n \n extern int current_function_anonymous_args;\n "}, {"sha": "66dfc6b2b10c763ae109368315a74c7559ac67db", "filename": "gcc/config/arm/pe.h", "status": "modified", "additions": 98, "deletions": 93, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Fpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Fpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.h?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for ARM with PE obj format.\n-   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Doug Evans (dje@cygnus.com).\n    \n This file is part of GNU CC.\n@@ -44,18 +44,22 @@ Boston, MA 02111-1307, USA.  */\n \n /* Experimental addition for pr 7885.\n    Ignore dllimport for functions.  */\n-#define TARGET_NOP_FUN_DLLIMPORT (target_flags & 0x20000)\n+#define TARGET_FLAG_NOP_FUN\t(1 << 24)\n+\n+#undef  TARGET_NOP_FUN_DLLIMPORT\n+#define TARGET_NOP_FUN_DLLIMPORT (target_flags & TARGET_FLAG_NOP_FUN)\n \n #undef  SUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES \\\n-{ \"nop-fun-dllimport\",\t\t 0x20000, \"Ignore dllimport attribute for functions\" }, \\\n-{ \"no-nop-fun-dllimport\",\t-0x20000, \"\" },\n+{ \"nop-fun-dllimport\",\t\t  TARGET_FLAG_NOP_FUN, \"Ignore dllimport attribute for functions\" }, \\\n+{ \"no-nop-fun-dllimport\",\t- TARGET_FLAG_NOP_FUN, \"\" },\n \n #undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT + 0x20000)\n+#define TARGET_DEFAULT\t(ARM_FLAG_SOFT_FLOAT | TARGET_FLAG_NOP_FUN)\n+\n \f\n #undef  WCHAR_TYPE\n-#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE \t\"short unsigned int\"\n #undef  WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE 16\n \n@@ -91,19 +95,10 @@ Boston, MA 02111-1307, USA.  */\n    The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n #undef  VALID_MACHINE_DECL_ATTRIBUTE\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n-arm_pe_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n-\n-#if 0 /* Needed when we tried type attributes.  */\n-/* A C expression whose value is zero if the attributes on\n-   TYPE1 and TYPE2 are incompatible, one if they are compatible,\n-   and two if they are nearly compatible (which causes a warning to be\n-   generated).  */\n-#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n-arm_pe_comp_type_attributes ((TYPE1), (TYPE2))\n-#endif\n+  arm_pe_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n #define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n-arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n+  arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n \n /* In addition to the stuff done in arm.h, we must mark dll symbols specially.\n    Definitions of dllexport'd objects install some info in the .drectve\n@@ -114,7 +109,7 @@ arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n    Note that we can be called twice on the same decl.  */\n #undef  ENCODE_SECTION_INFO\n #define ENCODE_SECTION_INFO(DECL) \\\n-arm_pe_encode_section_info (DECL)\n+  arm_pe_encode_section_info (DECL)\n \n /* Used to implement dllexport overriding dllimport semantics.  It's also used\n    to handle vtables - the first pass won't do anything because\n@@ -146,7 +141,7 @@ arm_pe_encode_section_info (DECL)\n \n #define UNIQUE_SECTION_P(DECL) DECL_ONE_ONLY (DECL)\n \n-#define UNIQUE_SECTION(DECL,RELOC) arm_pe_unique_section (DECL, RELOC)\n+#define UNIQUE_SECTION(DECL, RELOC) arm_pe_unique_section (DECL, RELOC)\n \n #define SUPPORTS_ONE_ONLY 1\n \n@@ -156,87 +151,97 @@ arm_pe_encode_section_info (DECL)\n    define this macro in such cases.  */\n #undef  ASM_OUTPUT_SECTION_NAME\n #define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n-  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n-  /* Functions may have been compiled at various levels of\t\\\n-     optimization so we can't use `same_size' here.  Instead,\t\\\n-     have the linker pick one.  */\t\t\t\t\\\n-  if ((DECL) && DECL_ONE_ONLY (DECL))\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.linkonce %s\\n\",\t\t\t\\\n-\t     TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n-\t     ? \"discard\" : \"same_size\");\t\t\t\\\n-} while (0)\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\\\n+      else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\\\n+      /* Functions may have been compiled at various levels of\t\\\n+\t optimization so we can't use `same_size' here.\t\t\\\n+\t Instead, have the linker pick one.  */\t\t\t\\\n+      if ((DECL) && DECL_ONE_ONLY (DECL))\t\t\t\\\n+\tfprintf (STREAM, \"\\t.linkonce %s\\n\",\t\t\t\\\n+\t\t TREE_CODE (DECL) == FUNCTION_DECL\t\t\\\n+\t\t ? \"discard\" : \"same_size\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* This outputs a lot of .req's to define alias for various registers.\n    Let's try to avoid this.  */\n #undef  ASM_FILE_START\n-#define ASM_FILE_START(STREAM) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  extern char * version_string;\t\t\t\t\t\\\n-  fprintf (STREAM, \"%s Generated by gcc %s for ARM/pe\\n\",\t\\\n-\t   ASM_COMMENT_START, version_string);\t\t\t\\\n-  output_file_directive ((STREAM), main_input_filename);\t\\\n-} while (0)\n+#define ASM_FILE_START(STREAM)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      extern char * version_string;\t\t\t\t\\\n+      asm_fprintf (STREAM, \"%@ Generated by gcc %s for ARM/pe\\n\",\\\n+\t   version_string);\t\t\t\t\t\\\n+      output_file_directive ((STREAM), main_input_filename);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Output a reference to a label.  */\n #undef  ASM_OUTPUT_LABELREF\n #define ASM_OUTPUT_LABELREF(STREAM, NAME)  \\\n-fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, ARM_STRIP_NAME_ENCODING (NAME))\n+  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, ARM_STRIP_NAME_ENCODING (NAME))\n \n /* Output a function definition label.  */\n #undef  ASM_DECLARE_FUNCTION_NAME\n #define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)   \\\n-do {\t\t\t\t\t\t\t\\\n-  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      drectve_section ();\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n-\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n-      function_section (DECL);\t\t\t\t\\\n+      if (arm_dllexport_name_p (NAME))\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  drectve_section ();\t\t\t\t\\\n+\t  fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\\\n+\t\t   ARM_STRIP_NAME_ENCODING (NAME));\t\\\n+\t  function_section (DECL);\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n+\tarm_poke_function_name ((STREAM), (NAME));\t\\\n+      ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\\\n     }\t\t\t\t\t\t\t\\\n-  if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n-    arm_poke_function_name ((STREAM), (NAME));\t\t\\\n-  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n-} while (0)\n+  while (0)\n \n /* Output a common block.  */\n #undef  ASM_OUTPUT_COMMON\n-#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED) \\\n-do {\t\t\t\t\t\t\t\\\n-  if (arm_dllexport_name_p (NAME))\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      drectve_section ();\t\t\t\t\\\n-      fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n-\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  if (! arm_dllimport_name_p (NAME))\t\t\t\\\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\\\n+  do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fprintf ((STREAM), \"\\t.comm\\t\"); \t\t\t\\\n-      assemble_name ((STREAM), (NAME));\t\t\t\\\n-      fprintf ((STREAM), \", %d\\t%s %d\\n\",\t\t\\\n-\t       (ROUNDED), ASM_COMMENT_START, (SIZE));\t\\\n+      if (arm_dllexport_name_p (NAME))\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  drectve_section ();\t\t\t\t\\\n+\t  fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\\\n+\t\t   ARM_STRIP_NAME_ENCODING (NAME));\t\\\n+\t}\t\t\t\t\t\t\\\n+      if (! arm_dllimport_name_p (NAME))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  fprintf ((STREAM), \"\\t.comm\\t\"); \t\t\\\n+\t  assemble_name ((STREAM), (NAME));\t\t\\\n+\t  asm_fprintf ((STREAM), \", %d\\t%@ %d\\n\",\t\\\n+\t\t   (ROUNDED), (SIZE));\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n-} while (0)\n+  while (0)\n \n /* Output the label for an initialized variable.  */\n #undef  ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \\\n-do {\t\t\t\t\t\t\t\\\n-  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \t\\\n+  do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      enum in_section save_section = in_section;\t\\\n-      drectve_section ();\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n-\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n-      switch_to_section (save_section, (DECL));\t\t\\\n+      if (arm_dllexport_name_p (NAME))\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  enum in_section save_section = in_section;\t\\\n+\t  drectve_section ();\t\t\t\t\\\n+\t  fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\\\n+\t\t   ARM_STRIP_NAME_ENCODING (NAME));\t\\\n+\t  switch_to_section (save_section, (DECL));\t\\\n+\t}\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\\\n     }\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n-} while (0)\n+  while (0)\n \f\n /* Support the ctors/dtors and other sections.  */\n \n@@ -272,21 +277,21 @@ drectve_section ()\t\t\t\t\t\t\t\\\n    The problem is that we want to temporarily switch sections in\n    ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n    afterwards.  */\n-#define SWITCH_TO_SECTION_FUNCTION \\\n-void \\\n-switch_to_section (section, decl) \\\n-     enum in_section section; \\\n-     tree decl; \\\n-{ \\\n-  switch (section) \\\n-    { \\\n-      case in_text: text_section (); break; \\\n-      case in_data: data_section (); break; \\\n-      case in_named: named_section (decl, NULL, 0); break; \\\n-      case in_rdata: rdata_section (); break; \\\n-      case in_ctors: ctors_section (); break; \\\n-      case in_dtors: dtors_section (); break; \\\n-      case in_drectve: drectve_section (); break; \\\n-      default: abort (); break; \\\n-    } \\\n+#define SWITCH_TO_SECTION_FUNCTION\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+switch_to_section (section, decl)\t\t\t\t\\\n+     enum in_section section;\t\t\t\t\t\\\n+     tree decl;\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  switch (section)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      case in_text: text_section (); break;\t\t\t\\\n+      case in_data: data_section (); break;\t\t\t\\\n+      case in_named: named_section (decl, NULL, 0); break;\t\\\n+      case in_rdata: rdata_section (); break;\t\t\t\\\n+      case in_ctors: ctors_section (); break;\t\t\t\\\n+      case in_dtors: dtors_section (); break;\t\t\t\\\n+      case in_drectve: drectve_section (); break;\t\t\\\n+      default: abort (); break;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }"}, {"sha": "76beab3eb4dd24d4abf65d921f1b337f117ae7b2", "filename": "gcc/config/arm/t-arm-elf", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Ft-arm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Ft-arm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-elf?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -1,6 +1,6 @@\n CROSS_LIBGCC1 = libgcc1-asm.a\n-LIB1ASMSRC = arm/lib1funcs.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls\n+LIB1ASMSRC    = arm/lib1funcs.asm\n+LIB1ASMFUNCS  = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX\n \n # We want fine grained libraries, so use the new code to build the\n # floating point emulation libraries.\n@@ -21,13 +21,51 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#endif' >> dp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n \n-# MULTILIB_OPTIONS  = mlittle-endian/mbig-endian mhard-float/msoft-float mapcs-32/mapcs-26 fno-leading-underscore/fleading-underscore\n-# MULTILIB_DIRNAMES = le be fpu soft 32bit 26bit elf under\n-# MULTILIB_EXCEPTIONS = \n-# MULTILIB_MATCHES  = \n+# MULTILIB_OPTIONS     = mlittle-endian/mbig-endian\n+# MULTILIB_DIRNAMES    = le be\n+# MULTILIB_EXCEPTIONS  = \n+# MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n+# \n+# MULTILIB_OPTIONS    += mhard-float/msoft-float\n+# MULTILIB_DIRNAMES   += fpu soft\n+# \n+# MULTILIB_OPTIONS    += mapcs-32/mapcs-26\n+# MULTILIB_DIRNAMES   += 32bit 26bit\n+# \n+# MULTILIB_OPTIONS    += mno-thumb-interwork/mthumb-interwork\n+# MULTILIB_DIRNAMES   += normal interwork\n+# MULTILIB_EXCEPTIONS += *mapcs-26/*mthumb-interwork*\n+# \n+# MULTILIB_OPTIONS    += fno-leading-underscore/fleading-underscore\n+# MULTILIB_DIRNAMES   += elf under\n+# \n+# MULTILIB_OPTIONS    += mcpu=arm7\n+# MULTILIB_DIRNAMES   += nofmult\n+# MULTILIB_EXCEPTIONS += *mthumb-interwork*/*mcpu=arm7*\n+# # We have to match all the arm cpu variants which do not have the\n+# # multiply instruction and treat them as if the user had specified\n+# # -mcpu=arm7.  Note that in the following the ? is interpreted as\n+# # an = for the purposes of matching command line options.\n+# # FIXME: There ought to be a better way to do this.\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7d\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7di\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm70\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm700\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm700i\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm710\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm710c\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7100\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7500\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm7500fe\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm6\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm60\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm600\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm610\n+# MULTILIB_MATCHES    += mcpu?arm7=mcpu?arm620\n+#  \n # EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n-# LIBGCC = stmp-multilib\n-# INSTALL_LIBGCC = install-multilib\n+# LIBGCC               = stmp-multilib\n+# INSTALL_LIBGCC       = install-multilib\n \n # If EXTRA_MULTILIB_PARTS is not defined above then define EXTRA_PARTS here\n EXTRA_PARTS = crtbegin.o crtend.o"}, {"sha": "ba799d829ea249ee4dba5d8fe78ca79fe189af99", "filename": "gcc/config/arm/t-bare", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Ft-bare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Ft-bare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-bare?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -1,6 +1,6 @@\n CROSS_LIBGCC1 = libgcc1-asm.a\n-LIB1ASMSRC = arm/lib1funcs.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls\n+LIB1ASMSRC    = arm/lib1funcs.asm\n+LIB1ASMFUNCS  = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX\n \n # We want fine grained libraries, so use the new code to build the\n # floating point emulation libraries.\n@@ -22,9 +22,11 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n \n # Avoid building a duplicate set of libraries for the default endian-ness.\n-MULTILIB_OPTIONS = mlittle-endian/mbig-endian mhard-float\n+MULTILIB_OPTIONS  = mlittle-endian/mbig-endian mhard-float\n MULTILIB_DIRNAMES = le be fpu\n-MULTILIB_MATCHES = \n+MULTILIB_MATCHES  = \n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n+\n+"}, {"sha": "fbf5212ff96db0a7084f6e8b4df2b052a8eccaa3", "filename": "gcc/config/arm/telf.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Ftelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Ftelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftelf.h?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -141,6 +141,13 @@ extern int arm_structure_size_boundary;\n    dwarf2.out. */ \n #define UNALIGNED_WORD_ASM_OP \".4byte\"\n \n+#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR)\t\t\t\\\n+ if (((ADDR)[0] == '.') && ((ADDR)[1] == 'L')) \t\t\t\\\n+   fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, (ADDR));\t\\\n+ else                                                     \t\\\n+  fprintf ((FILE), \"\\t%s\\t%s\",\t\t\t\t\t\\\n+           UNALIGNED_WORD_ASM_OP, (ADDR))\n+\n #define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\"}, {"sha": "aa24f9658cc07a107128a762b1431bbbfd2f10b7", "filename": "gcc/config/arm/thumb.c", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for ARM/Thumb\n-   Copyright (C) 1996 Cygnus Software Technologies Ltd\n+   Copyright (C) 1996, 2000 Cygnus Software Technologies Ltd\n    The basis of this contribution was generated by\n    \t\tRichard Earnshaw, Advanced RISC Machines Ltd\n \n@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"thumb-protos.h\"\n \n \f\n int current_function_anonymous_args = 0;\n@@ -492,8 +493,7 @@ dump_table (scan)\n }\n \n /* Non zero if the src operand needs to be fixed up */\n-static\n-int\n+static int\n fixit (src, mode)\n      rtx src;\n      enum machine_mode mode;\n@@ -513,8 +513,7 @@ fixit (src, mode)\n \t      && CONSTANT_POOL_ADDRESS_P (XEXP (src, 0))));\n }\n \n-/* Find the last barrier less than MAX_COUNT bytes from FROM, or create one. */\n-\n+/* Find the last barrier less than MAX_COUNT bytes from FROM, or create one.  */\n #define MAX_COUNT_SI 1000\n  \n static rtx\n@@ -530,7 +529,7 @@ find_barrier (from)\n       if (GET_CODE (from) == BARRIER)\n \treturn from;\n \n-      /* Count the length of this insn */\n+      /* Count the length of this insn.  */\n       if (GET_CODE (from) == INSN\n \t  && GET_CODE (PATTERN (from)) == SET\n \t  && CONSTANT_P (SET_SRC (PATTERN (from)))\n@@ -543,29 +542,29 @@ find_barrier (from)\n     }\n \n   /* We didn't find a barrier in time to\n-     dump our stuff, so we'll make one */\n+     dump our stuff, so we'll make one.  */\n   label = gen_label_rtx ();\n   \n   if (from)\n     from = PREV_INSN (from);\n   else\n     from = get_last_insn ();\n   \n-  /* Walk back to be just before any jump */\n+  /* Walk back to be just before any jump.  */\n   while (GET_CODE (from) == JUMP_INSN\n \t || GET_CODE (from) == NOTE\n \t || GET_CODE (from) == CODE_LABEL)\n     from = PREV_INSN (from);\n-  \n+\n   from = emit_jump_insn_after (gen_jump (label), from);\n   JUMP_LABEL (from) = label;\n   found_barrier = emit_barrier_after (from);\n   emit_label_after (label, found_barrier);\n+  \n   return found_barrier;\n }\n \n-/* Non zero if the insn is a move instruction which needs to be fixed. */\n- \n+/* Non zero if the insn is a move instruction which needs to be fixed.  */\n static int\n broken_move (insn)\n      rtx insn;\n@@ -628,16 +627,16 @@ thumb_reorg (first)\n       if (broken_move (insn))\n \t{\n \t  /* This is a broken move instruction, scan ahead looking for\n-\t     a barrier to stick the constant table behind */\n+\t     a barrier to stick the constant table behind.  */\n \t  rtx scan;\n \t  rtx barrier = find_barrier (insn);\n \n-\t  /* Now find all the moves between the points and modify them */\n+\t  /* Now find all the moves between the points and modify them.  */\n \t  for (scan = insn; scan != barrier; scan = NEXT_INSN (scan))\n \t    {\n \t      if (broken_move (scan))\n \t\t{\n-\t\t  /* This is a broken move instruction, add it to the pool */\n+\t\t  /* This is a broken move instruction, add it to the pool.  */\n \t\t  rtx pat = PATTERN (scan);\n \t\t  rtx src = SET_SRC (pat);\n \t\t  rtx dst = SET_DEST (pat);\n@@ -649,7 +648,7 @@ thumb_reorg (first)\n \t\t  /* If this is an HImode constant load, convert it into\n \t\t     an SImode constant load.  Since the register is always\n \t\t     32 bits this is safe.  We have to do this, since the\n-\t\t     load pc-relative instruction only does a 32-bit load. */\n+\t\t     load pc-relative instruction only does a 32-bit load.  */\n \t\t  if (mode == HImode)\n \t\t    {\n \t\t      mode = SImode;\n@@ -668,12 +667,12 @@ thumb_reorg (first)\n \t\t  /* Build a jump insn wrapper around the move instead\n \t\t     of an ordinary insn, because we want to have room for\n \t\t     the target label rtx in fld[7], which an ordinary\n-\t\t     insn doesn't have. */\n+\t\t     insn doesn't have.  */\n \t\t  newinsn = emit_jump_insn_after (gen_rtx (SET, VOIDmode,\n \t\t\t\t\t\t\t   dst, newsrc), scan);\n \t\t  JUMP_LABEL (newinsn) = pool_vector_label;\n \n-\t\t  /* But it's still an ordinary insn */\n+\t\t  /* But it's still an ordinary insn.  */\n \t\t  PUT_CODE (newinsn, INSN);\n \n \t\t  /* If debugging information is going to be emitted\n@@ -692,8 +691,7 @@ thumb_reorg (first)\n \t\t     pool will be marked.  Only necessary if debugging\n \t\t     info is being emitted.  Only necessary for\n \t\t     references to memory whose address is given by a\n-\t\t     symbol. */\n-\n+\t\t     symbol.  */\n \t\t  if (optimize > 0\n \t\t      && flag_expensive_optimizations\n \t\t      && write_symbols != NO_DEBUG\n@@ -702,19 +700,19 @@ thumb_reorg (first)\n \t\t    replace_symbols_in_block\n \t\t      (DECL_INITIAL (current_function_decl), src, newsrc);\n \t\t  \n-\t\t  /* Kill old insn */\n+\t\t  /* Kill old insn.  */\n \t\t  delete_insn (scan);\n \t\t  scan = newinsn;\n \t\t}\n \t    }\n+\t  \n \t  dump_table (barrier);\n \t}\n     }\n }\n \n \f\n-/* Routines for generating rtl */\n-\n+/* Routines for generating rtl.  */\n void\n thumb_expand_movstrqi (operands)\n      rtx *operands;\n@@ -888,7 +886,7 @@ thumb_exit (f, reg_containing_return_addr)\n       pops_needed += 2;\n     }\n \n-  /* If there is nothing to pop then just emit the BX instruction and return.*/\n+  /* If there is nothing to pop then just emit the BX instruction and return.  */\n   if (pops_needed == 0)\n     {\n       asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names [reg_containing_return_addr]);\n@@ -1355,7 +1353,7 @@ thumb_function_prologue (f, frame_size)\n \n   if (TARGET_BACKTRACE)\n     {\n-      char * name;\n+      const char * name;\n       int    offset;\n       int    work_register = 0;\n       \n@@ -1396,7 +1394,7 @@ thumb_function_prologue (f, frame_size)\n \t      break;\n \t}\n       \n-      name = reg_names[ work_register ];\n+      name = reg_names [work_register];\n       \n       asm_fprintf (f, \"\\tsub\\tsp, sp, #16\\t@ Create stack backtrace structure\\n\");\n       \n@@ -1722,7 +1720,7 @@ thumb_function_epilogue (f, frame_size)\n #endif\n }\n \n-/* The bits which aren't usefully expanded as rtl. */\n+/* The bits which aren't usefully expanded as rtl.  */\n char *\n thumb_unexpanded_epilogue ()\n {\n@@ -1771,14 +1769,10 @@ thumb_unexpanded_epilogue ()\n \t the register is used to hold a return value.  */\n \n       if (current_function_return_rtx != 0)\n-\t{\n-\t  mode = GET_MODE (current_function_return_rtx);\n-\t}\n+\tmode = GET_MODE (current_function_return_rtx);\n       else\n #endif\n-\t{\n-\t  mode = DECL_MODE (DECL_RESULT (current_function_decl));\n-\t}\n+\tmode = DECL_MODE (DECL_RESULT (current_function_decl));\n \n       size = GET_MODE_SIZE (mode);\n \n@@ -1787,11 +1781,8 @@ thumb_unexpanded_epilogue ()\n \tmask |=  1 << 3;\n \n       if (mask == 0)\n-\t{\n-\t  /* Oh dear!  We have no low registers into which we can pop high registers!  */\n-\n-\t  fatal (\"No low registers available for popping high registers\");\n-\t}\n+\t/* Oh dear!  We have no low registers into which we can pop high registers!  */\n+\tfatal (\"No low registers available for popping high registers\");\n       \n       for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)\n \tif (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg]\n@@ -1835,13 +1826,10 @@ thumb_unexpanded_epilogue ()\n   had_to_push_lr = (live_regs_mask || ! leaf_function || far_jump_used_p());\n   \n   if (TARGET_BACKTRACE && ((live_regs_mask & 0xFF) == 0) && regs_ever_live[ ARG_4_REGISTER ] != 0)\n-    {\n-      /* The stack backtrace structure creation code had to\n-\t push R7 in order to get a work register, so we pop\n-\t it now.   */\n-      \n-      live_regs_mask |= (1 << WORK_REGISTER);\n-    }\n+    /* The stack backtrace structure creation code had to\n+       push R7 in order to get a work register, so we pop\n+       it now.   */\n+    live_regs_mask |= (1 << WORK_REGISTER);\n   \n   if (current_function_pretend_args_size == 0 || TARGET_BACKTRACE)\n     {\n@@ -1852,15 +1840,13 @@ thumb_unexpanded_epilogue ()\n       /* Either no argument registers were pushed or a backtrace\n \t structure was created which includes an adjusted stack\n \t pointer, so just pop everything.  */\n-      \n       if (live_regs_mask)\n \tthumb_pushpop (asm_out_file, live_regs_mask, FALSE);\n       \n       /* We have either just popped the return address into the\n \t PC or it is was kept in LR for the entire function or\n \t it is still on the stack because we do not want to\n \t return by doing a pop {pc}.  */\n-      \n       if ((live_regs_mask & (1 << PROGRAM_COUNTER)) == 0)\n \tthumb_exit (asm_out_file,\n \t\t    (had_to_push_lr\n@@ -1876,10 +1862,8 @@ thumb_unexpanded_epilogue ()\n \tthumb_pushpop (asm_out_file, live_regs_mask, FALSE);\n \n       if (had_to_push_lr)\n-\t{\n-\t  /* Get the return address into a temporary register.  */\n-\t  thumb_pushpop (asm_out_file, 1 << ARG_4_REGISTER, 0);\n-\t}\n+\t/* Get the return address into a temporary register.  */\n+\tthumb_pushpop (asm_out_file, 1 << ARG_4_REGISTER, 0);\n       \n       /* Remove the argument registers that were pushed onto the stack.  */\n       asm_fprintf (asm_out_file, \"\\tadd\\t%s, %s, #%d\\n\","}, {"sha": "ab89828a6e1cbf9d891496c751e1e2cc01ca5f32", "filename": "gcc/config/arm/thumb.h", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Fthumb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Fthumb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.h?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -1296,37 +1296,5 @@ extern int making_const_table;\n /* Options specific to Thumb */\n \n /* True if a return instruction can be used in this function. */\n-int thumb_trivial_epilogue ();\n #define USE_RETURN (reload_completed && thumb_trivial_epilogue ())\n \n-extern char * thumb_unexpanded_epilogue ();\n-extern char * output_move_mem_multiple ();\n-extern char * thumb_load_double_from_address ();\n-extern char * output_return ();\n-extern int    far_jump_used_p();\n-extern int    is_called_in_ARM_mode ();\n-extern void   thumb_finalize_pic ();\n-extern void   thumb_reorg ();\n-extern void   thumb_override_options ();\n-extern int    is_pic ();\n-extern int    thumb_symbol_mentioned_p ();\n-extern void   thumb_function_prologue ();\n-extern void   thumb_function_epilogue ();\n-extern void   thumb_print_operand ();\n-extern void   thumb_final_prescan_insn ();\n-extern int    thumb_cmp_operand ();\n-extern void   thumb_expand_movstrqi ();\n-extern void   thumb_expand_prologue ();\n-extern void   thumb_expand_epilogue ();\n-extern int    arm_valid_machine_decl_attribute ();\n-extern void   thumb_init_expanders ();\n-\n-#ifndef RTX_CODE\n-struct rtx_def;\n-#define Rtx struct rtx_def *\n-#else\n-#define Rtx rtx\n-#endif\n-\n-extern Rtx    thumb_return_addr ();\n-"}, {"sha": "9308d16c1a8941110f27ed73193d769a3aca44bb", "filename": "gcc/config/arm/unknown-elf.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Funknown-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bcb1bb0c652f8d88e68ed1d5157fead4a667536/gcc%2Fconfig%2Farm%2Funknown-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funknown-elf.h?ref=3bcb1bb0c652f8d88e68ed1d5157fead4a667536", "patch": "@@ -107,6 +107,9 @@ func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n    dwarf2.out. */ \n #define UNALIGNED_WORD_ASM_OP \".4byte\"\n \n+#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR)                  \\\n+     fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, ADDR)\n+\n #define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)                   \\\n do {\t\t\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\\t%s\\t\", UNALIGNED_WORD_ASM_OP);\t\t\\"}]}