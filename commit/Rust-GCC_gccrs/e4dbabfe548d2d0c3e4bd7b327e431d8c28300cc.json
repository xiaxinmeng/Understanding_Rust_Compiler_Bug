{"sha": "e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRkYmFiZmU1NDhkMmQwYzNlNGJkN2IzMjdlNDMxZDhjMjgzMDBjYw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2016-04-24T08:45:38Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2016-04-24T08:45:38Z"}, "message": "make avail_stores a vec<rtx_insn *>\n\ngcc/ChangeLog:\n\n2016-04-24  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* print-rtl.c (print_rtx_insn_vec): New function.\n\t* print-rtl.h: New prototype.\n\t* store-motion.c (struct st_expr): Make avail_stores a vector.\n\t(st_expr_entry): Adjust.\n\t(free_st_expr_entry): Likewise.\n\t(print_store_motion_mems): Likewise.\n\t(find_moveable_store): Likewise.\n\t(compute_store_table): Likewise.\n\t(delete_store): Likewise.\n\t(build_store_vectors): Likewise.\n\nFrom-SVN: r235394", "tree": {"sha": "135f834a8194c86c2b3a36fae801ffa8a70ce8a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/135f834a8194c86c2b3a36fae801ffa8a70ce8a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/comments", "author": null, "committer": null, "parents": [{"sha": "5d911cafe95879bb3d1442a2fd6affbba1e9c279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d911cafe95879bb3d1442a2fd6affbba1e9c279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d911cafe95879bb3d1442a2fd6affbba1e9c279"}], "stats": {"total": 64, "additions": 48, "deletions": 16}, "files": [{"sha": "7b4b9c2f157f5e70131bfad3818fd9257f7cd493", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc", "patch": "@@ -1,3 +1,16 @@\n+2016-04-24  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* print-rtl.c (print_rtx_insn_vec): New function.\n+\t* print-rtl.h: New prototype.\n+\t* store-motion.c (struct st_expr): Make avail_stores a vector.\n+\t(st_expr_entry): Adjust.\n+\t(free_st_expr_entry): Likewise.\n+\t(print_store_motion_mems): Likewise.\n+\t(find_moveable_store): Likewise.\n+\t(compute_store_table): Likewise.\n+\t(delete_store): Likewise.\n+\t(build_store_vectors): Likewise.\n+\n 2016-04-24  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* reorg.c (try_merge_delay_insns): Make merged_insns a vector."}, {"sha": "a9051279ed7e1bea1fab385d47e2b3bb9ddaa912", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc", "patch": "@@ -870,6 +870,24 @@ print_simple_rtl (FILE *outf, const_rtx x)\n   flag_simple = 0;\n }\n \n+/* Print the elements of VEC to FILE.  */\n+\n+void\n+print_rtx_insn_vec (FILE *file, const vec<rtx_insn *> &vec)\n+{\n+  fputc('{', file);\n+\n+  unsigned int len = vec.length ();\n+  for (unsigned int i = 0; i < len; i++)\n+    {\n+      print_rtl (file, vec[i]);\n+      if (i < len - 1)\n+\tfputs (\", \", file);\n+    }\n+\n+  fputc ('}', file);\n+}\n+\n #ifndef GENERATOR_FILE\n /* The functions below  try to print RTL in a form resembling assembler\n    mnemonics.  Because this form is more concise than the \"traditional\" form"}, {"sha": "e585a639602d1e7ce3729823d06c40210e72695a", "filename": "gcc/print-rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/gcc%2Fprint-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/gcc%2Fprint-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.h?ref=e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifdef BUFSIZ\n extern void print_rtl (FILE *, const_rtx);\n #endif\n+extern void print_rtx_insn_vec (FILE *file, const vec<rtx_insn *> &vec);\n \n extern void dump_value_slim (FILE *, const_rtx, int);\n extern void dump_insn_slim (FILE *, const rtx_insn *);"}, {"sha": "301b69be86d91ee3d85f64fa4d14af8d227d5f30", "filename": "gcc/store-motion.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=e4dbabfe548d2d0c3e4bd7b327e431d8c28300cc", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"rtl-iter.h\"\n+#include \"print-rtl.h\"\n \n /* This pass implements downward store motion.\n    As of May 1, 2009, the pass is not enabled by default on any target,\n@@ -67,7 +68,7 @@ struct st_expr\n   /* INSN list of stores that are locally anticipatable.  */\n   rtx_insn_list *antic_stores;\n   /* INSN list of stores that are locally available.  */\n-  rtx_insn_list *avail_stores;\n+  vec<rtx_insn *> avail_stores;\n   /* Next in the list.  */\n   struct st_expr * next;\n   /* Store ID in the dataflow bitmaps.  */\n@@ -148,7 +149,7 @@ st_expr_entry (rtx x)\n   ptr->pattern      = x;\n   ptr->pattern_regs = NULL_RTX;\n   ptr->antic_stores = NULL;\n-  ptr->avail_stores = NULL;\n+  ptr->avail_stores.create (0);\n   ptr->reaching_reg = NULL_RTX;\n   ptr->index        = 0;\n   ptr->hash_index   = hash;\n@@ -164,7 +165,7 @@ static void\n free_st_expr_entry (struct st_expr * ptr)\n {\n   free_INSN_LIST_list (& ptr->antic_stores);\n-  free_INSN_LIST_list (& ptr->avail_stores);\n+   ptr->avail_stores.release ();\n \n   free (ptr);\n }\n@@ -240,10 +241,7 @@ print_store_motion_mems (FILE * file)\n \n       fprintf (file, \"\\n\t AVAIL stores : \");\n \n-      if (ptr->avail_stores)\n-\tprint_rtl (file, ptr->avail_stores);\n-      else\n-\tfprintf (file, \"(nil)\");\n+\tprint_rtx_insn_vec (file, ptr->avail_stores);\n \n       fprintf (file, \"\\n\\n\");\n     }\n@@ -591,11 +589,11 @@ find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n      it successfully before; if we failed before, do not bother to check\n      until we reach the insn that caused us to fail.  */\n   check_available = 0;\n-  if (!ptr->avail_stores)\n+  if (ptr->avail_stores.is_empty ())\n     check_available = 1;\n   else\n     {\n-      rtx_insn *tmp = ptr->avail_stores->insn ();\n+      rtx_insn *tmp = ptr->avail_stores.last ();\n       if (BLOCK_FOR_INSN (tmp) != bb)\n \tcheck_available = 1;\n     }\n@@ -619,7 +617,7 @@ find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n \t\t\t\t\t      &LAST_AVAIL_CHECK_FAILURE (ptr));\n     }\n   if (!check_available)\n-    ptr->avail_stores = alloc_INSN_LIST (insn, ptr->avail_stores);\n+    ptr->avail_stores.safe_push (insn);\n }\n \n /* Find available and anticipatable stores.  */\n@@ -697,7 +695,7 @@ compute_store_table (void)\n        ptr != NULL;\n        ptr = *prev_next_ptr_ptr)\n     {\n-      if (! ptr->avail_stores)\n+      if (ptr->avail_stores.is_empty ())\n \t{\n \t  *prev_next_ptr_ptr = ptr->next;\n \t  store_motion_mems_table->remove_elt_with_hash (ptr, ptr->hash_index);\n@@ -981,9 +979,10 @@ delete_store (struct st_expr * expr, basic_block bb)\n \n   reg = expr->reaching_reg;\n \n-  for (rtx_insn_list *i = expr->avail_stores; i; i = i->next ())\n+  unsigned int len = expr->avail_stores.length ();\n+  for (unsigned int i = len - 1; i < len; i--)\n     {\n-      rtx_insn *del = i->insn ();\n+      rtx_insn *del = expr->avail_stores[i];\n       if (BLOCK_FOR_INSN (del) == bb)\n \t{\n \t  /* We know there is only one since we deleted redundant\n@@ -1018,9 +1017,10 @@ build_store_vectors (void)\n \n   for (ptr = first_st_expr (); ptr != NULL; ptr = next_st_expr (ptr))\n     {\n-      for (st = ptr->avail_stores; st != NULL; st = st->next ())\n+      unsigned int len = ptr->avail_stores.length ();\n+      for (unsigned int i = len - 1; i < len; i--)\n \t{\n-\t  insn = st->insn ();\n+\t  insn = ptr->avail_stores[i];\n \t  bb = BLOCK_FOR_INSN (insn);\n \n \t  /* If we've already seen an available expression in this block,\n@@ -1032,7 +1032,7 @@ build_store_vectors (void)\n \t      rtx r = gen_reg_rtx_and_attrs (ptr->pattern);\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Removing redundant store:\\n\");\n-\t      replace_store_insn (r, st->insn (), bb, ptr);\n+\t      replace_store_insn (r, insn, bb, ptr);\n \t      continue;\n \t    }\n \t  bitmap_set_bit (st_avloc[bb->index], ptr->index);"}]}