{"sha": "c7cfe938ebe954ded2ecbef9ba151c459fc8dbbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdjZmU5MzhlYmU5NTRkZWQyZWNiZWY5YmExNTFjNDU5ZmM4ZGJiYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-06T13:00:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-06T13:00:51Z"}, "message": "(operand_equal_p): Rework to consider two expressions that have embedded identical SAVE_EXPRs as equivalent...\n\n(operand_equal_p): Rework to consider two expressions that have\nembedded identical SAVE_EXPRs as equivalent; also handle some more\ncases.\n\nFrom-SVN: r13385", "tree": {"sha": "8b85292929c2bdfb19b4896933221247acc18006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b85292929c2bdfb19b4896933221247acc18006"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7cfe938ebe954ded2ecbef9ba151c459fc8dbbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7cfe938ebe954ded2ecbef9ba151c459fc8dbbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7cfe938ebe954ded2ecbef9ba151c459fc8dbbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7cfe938ebe954ded2ecbef9ba151c459fc8dbbc/comments", "author": null, "committer": null, "parents": [{"sha": "8e84cfdd7c0d0ba1c1da92f64d83e7b72058e510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e84cfdd7c0d0ba1c1da92f64d83e7b72058e510", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e84cfdd7c0d0ba1c1da92f64d83e7b72058e510"}], "stats": {"total": 90, "additions": 57, "deletions": 33}, "files": [{"sha": "dedbeed49d84ff8197e08e33b1dff41d547eafe8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cfe938ebe954ded2ecbef9ba151c459fc8dbbc/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cfe938ebe954ded2ecbef9ba151c459fc8dbbc/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c7cfe938ebe954ded2ecbef9ba151c459fc8dbbc", "patch": "@@ -1735,44 +1735,56 @@ operand_equal_p (arg0, arg1, only_const)\n   STRIP_NOPS (arg0);\n   STRIP_NOPS (arg1);\n \n-  /* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.\n-     We don't care about side effects in that case because the SAVE_EXPR\n-     takes care of that for us.  */\n-  if (TREE_CODE (arg0) == SAVE_EXPR && arg0 == arg1)\n-    return ! only_const;\n-\n-  if (TREE_SIDE_EFFECTS (arg0) || TREE_SIDE_EFFECTS (arg1))\n+  if (TREE_CODE (arg0) != TREE_CODE (arg1)\n+      /* This is needed for conversions and for COMPONENT_REF.\n+\t Might as well play it safe and always test this.  */\n+      || TYPE_MODE (TREE_TYPE (arg0)) != TYPE_MODE (TREE_TYPE (arg1)))\n     return 0;\n \n-  if (TREE_CODE (arg0) == TREE_CODE (arg1)\n-      && TREE_CODE (arg0) == ADDR_EXPR\n-      && TREE_OPERAND (arg0, 0) == TREE_OPERAND (arg1, 0))\n-    return 1;\n-\n-  if (TREE_CODE (arg0) == TREE_CODE (arg1)\n-      && TREE_CODE (arg0) == INTEGER_CST\n-      && TREE_INT_CST_LOW (arg0) == TREE_INT_CST_LOW (arg1)\n-      && TREE_INT_CST_HIGH (arg0) == TREE_INT_CST_HIGH (arg1))\n+  /* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.\n+     We don't care about side effects in that case because the SAVE_EXPR\n+     takes care of that for us. In all other cases, two expressions are\n+     equal if they have no side effects.  If we have two identical\n+     expressions with side effects that should be treated the same due\n+     to the only side effects being identical SAVE_EXPR's, that will\n+     be detected in the recursive calls below.  */\n+  if (arg0 == arg1 && ! only_const\n+      && (TREE_CODE (arg0) == SAVE_EXPR\n+\t  || (! TREE_SIDE_EFFECTS (arg0) && ! TREE_SIDE_EFFECTS (arg1))))\n     return 1;\n \n-  /* Detect when real constants are equal.  */\n-  if (TREE_CODE (arg0) == TREE_CODE (arg1)\n-      && TREE_CODE (arg0) == REAL_CST)\n-    return REAL_VALUES_EQUAL (TREE_REAL_CST (arg0), TREE_REAL_CST (arg1));\n+  /* Next handle constant cases, those for which we can return 1 even\n+     if ONLY_CONST is set.  */\n+  if (TREE_CONSTANT (arg0) && TREE_CONSTANT (arg1))\n+    switch (TREE_CODE (arg0))\n+      {\n+      case INTEGER_CST:\n+\treturn (TREE_INT_CST_LOW (arg0) == TREE_INT_CST_LOW (arg1)\n+\t\t&& TREE_INT_CST_HIGH (arg0) == TREE_INT_CST_HIGH (arg1));\n+\n+      case REAL_CST:\n+\treturn REAL_VALUES_EQUAL (TREE_REAL_CST (arg0), TREE_REAL_CST (arg1));\n+\n+      case COMPLEX_CST:\n+\treturn (operand_equal_p (TREE_REALPART (arg0), TREE_REALPART (arg1),\n+\t\t\t\t only_const)\n+\t\t&& operand_equal_p (TREE_IMAGPART (arg0), TREE_IMAGPART (arg1),\n+\t\t\t\t    only_const));\n+\n+      case STRING_CST:\n+\treturn (TREE_STRING_LENGTH (arg0) == TREE_STRING_LENGTH (arg1)\n+\t\t&& ! strncmp (TREE_STRING_POINTER (arg0),\n+\t\t\t      TREE_STRING_POINTER (arg1),\n+\t\t\t      TREE_STRING_LENGTH (arg0)));\n+\n+      case ADDR_EXPR:\n+\treturn operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg1, 0),\n+\t\t\t\t0);\n+      }\n \n   if (only_const)\n     return 0;\n \n-  if (arg0 == arg1)\n-    return 1;\n-\n-  if (TREE_CODE (arg0) != TREE_CODE (arg1))\n-    return 0;\n-  /* This is needed for conversions and for COMPONENT_REF.\n-     Might as well play it safe and always test this.  */\n-  if (TYPE_MODE (TREE_TYPE (arg0)) != TYPE_MODE (TREE_TYPE (arg1)))\n-    return 0;\n-\n   switch (TREE_CODE_CLASS (TREE_CODE (arg0)))\n     {\n     case '1':\n@@ -1787,10 +1799,22 @@ operand_equal_p (arg0, arg1, only_const)\n \n     case '<':\n     case '2':\n-      return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t       TREE_OPERAND (arg1, 0), 0)\n+      if (operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg1, 0), 0)\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 1), TREE_OPERAND (arg1, 1),\n+\t\t\t      0))\n+\treturn 1;\n+\n+      /* For commutative ops, allow the other order.  */\n+      return ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MULT_EXPR\n+\t       || TREE_CODE (arg0) == MIN_EXPR || TREE_CODE (arg0) == MAX_EXPR\n+\t       || TREE_CODE (arg0) == BIT_IOR_EXPR\n+\t       || TREE_CODE (arg0) == BIT_XOR_EXPR\n+\t       || TREE_CODE (arg0) == BIT_AND_EXPR\n+\t       || TREE_CODE (arg0) == NE_EXPR || TREE_CODE (arg0) == EQ_EXPR)\n+\t      && operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t  TREE_OPERAND (arg1, 1), 0)\n \t      && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t  TREE_OPERAND (arg1, 1), 0));\n+\t\t\t\t  TREE_OPERAND (arg1, 0), 0));\n \n     case 'r':\n       switch (TREE_CODE (arg0))"}]}