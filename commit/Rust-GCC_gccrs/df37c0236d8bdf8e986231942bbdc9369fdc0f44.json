{"sha": "df37c0236d8bdf8e986231942bbdc9369fdc0f44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYzN2MwMjM2ZDhiZGY4ZTk4NjIzMTk0MmJiZGM5MzY5ZmRjMGY0NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-11T18:38:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-11T18:38:48Z"}, "message": "mn10300: Remove bset/bclr patterns.\n\nThese instructions do not use normal addressing modes and are\nincorrectly implemented for that.  Corrections to legitimate\naddresses expose problems here.\n\nDelete them for now.  To be re-instated later in the form of\natomic operation builtins.\n\nFrom-SVN: r168676", "tree": {"sha": "10e2418ee5e8d76e664d9af657c88e6a65322031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10e2418ee5e8d76e664d9af657c88e6a65322031"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df37c0236d8bdf8e986231942bbdc9369fdc0f44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df37c0236d8bdf8e986231942bbdc9369fdc0f44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df37c0236d8bdf8e986231942bbdc9369fdc0f44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df37c0236d8bdf8e986231942bbdc9369fdc0f44/comments", "author": null, "committer": null, "parents": [{"sha": "85a337b58a1a6088d085354aa28de8b5198e8d08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a337b58a1a6088d085354aa28de8b5198e8d08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85a337b58a1a6088d085354aa28de8b5198e8d08"}], "stats": {"total": 343, "additions": 11, "deletions": 332}, "files": [{"sha": "8f71dd1a876aa549a2fb950c0285cad65a82c5d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df37c0236d8bdf8e986231942bbdc9369fdc0f44", "patch": "@@ -1,5 +1,14 @@\n 2011-01-11  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/constraints.md (\"R\", \"T\"): Remove constraints.\n+\t* config/mn10300/mn10300.c (mn10300_mask_ok_for_mem_btst): Remove.\n+\t* config/mn10300/mn10300-protos.h: Update.\n+\t* config/mn10300/mn10300.md (movsi_internal): Don't use \"R\".\n+\t(*byte_clear, *byte_set, *bit_clear1, *bit_clear2, *bit_set): Remove.\n+\t(iorqi3, *am33_iorqi3, *mn10300_iorqi3): Remove.\n+\t(*test_int_bitfield, *test_byte_bitfield): Remove.\n+\t(*bit_test, *subreg_bit_test): Remove.\n+\n \t* config/mn10300/constraints.md (\"c\"): Rename from \"A\".\n \t(\"A\", \"D\"): New constraint letters.\n \t* config/mn10300/mn10300.md (fmasf4): Use the \"c\" constraint."}, {"sha": "0f7f45b28c68125abea29d8513c928110d24087a", "filename": "gcc/config/mn10300/constraints.md", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fconstraints.md?ref=df37c0236d8bdf8e986231942bbdc9369fdc0f44", "patch": "@@ -49,29 +49,6 @@\n   (and (match_code \"mem\")\n        (match_test \"!CONSTANT_ADDRESS_P (XEXP (op, 0))\")))\n \n-(define_memory_constraint \"R\"\n-  \"@internal\"\n-  (and (match_code \"mem\")\n-       (match_test \"mode == QImode\")\n-       (ior (match_test \"CONSTANT_ADDRESS_P (XEXP (op, 0))\")\n-\t    (and (match_test \"GET_CODE (XEXP (op, 0)) == REG\")\n-\t\t (match_test \"REG_OK_FOR_BIT_BASE_P (XEXP (op, 0))\")\n-\t\t (match_test \"XEXP (op, 0) != stack_pointer_rtx\"))\n-\t    (and (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")\n-\t\t (match_test \"GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\")\n-\t\t (match_test \"REG_OK_FOR_BIT_BASE_P (XEXP (XEXP (op, 0), 0))\")\n-\t\t (match_test \"XEXP (XEXP (op, 0), 0) != stack_pointer_rtx\")\n-\t\t (match_test \"GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\")\n-\t\t (match_test \"INT_8_BITS (INTVAL (XEXP (XEXP (op, 0), 1)))\")))))\n-\n-(define_memory_constraint \"T\"\n-  \"@internal\"\n-  (and (match_code \"mem\")\n-       (match_test \"mode == QImode\")\n-       (and (match_test \"GET_CODE (XEXP (op, 0)) == REG\")\n-\t    (match_test \"REG_OK_FOR_BIT_BASE_P (XEXP (op, 0))\")\n-\t    (match_test \"XEXP (op, 0) != stack_pointer_rtx\"))))\n-\n (define_constraint \"S\"\n   \"@internal\"\n   (if_then_else (match_test \"flag_pic\")"}, {"sha": "8979eb41d4568ec8f0ab98af4f0105174dfbd326", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=df37c0236d8bdf8e986231942bbdc9369fdc0f44", "patch": "@@ -46,7 +46,6 @@ extern int   mn10300_can_use_return_insn (void);\n extern void  mn10300_expand_prologue (void);\n extern void  mn10300_expand_epilogue (void);\n extern int   mn10300_initial_offset (int, int);\n-extern int   mn10300_mask_ok_for_mem_btst (int, int);\n \n #undef Mmode\n #undef Cstar"}, {"sha": "e801c47b3fa2b5f9f60cada4e565ce6c10da0d8f", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=df37c0236d8bdf8e986231942bbdc9369fdc0f44", "patch": "@@ -1768,27 +1768,6 @@ mn10300_output_cmp (rtx operand, rtx insn)\n   return \"cmp 0,%0\";\n }\n \n-/* Similarly, but when using a zero_extract pattern for a btst where\n-   the source operand might end up in memory.  */\n-int\n-mn10300_mask_ok_for_mem_btst (int len, int bit)\n-{\n-  unsigned int mask = 0;\n-\n-  while (len > 0)\n-    {\n-      mask |= (1 << bit);\n-      bit++;\n-      len--;\n-    }\n-\n-  /* MASK must bit into an 8bit value.  */\n-  return (((mask & 0xff) == mask)\n-\t  || ((mask & 0xff00) == mask)\n-\t  || ((mask & 0xff0000) == mask)\n-\t  || ((mask & 0xff000000) == mask));\n-}\n-\n /* Return 1 if X contains a symbolic expression.  We know these\n    expressions will have one of a few well defined forms, so\n    we need only check those forms.  */"}, {"sha": "04ec1b113a58ce82d567f41af3508399ec3838a0", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 2, "deletions": 275, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=df37c0236d8bdf8e986231942bbdc9369fdc0f44", "patch": "@@ -490,9 +490,9 @@\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t  \"=dax, dax,  m,   dax, axR, !*y\")\n+\t\t\t  \"=dax, dax,  m,   dax, ax,!*y\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t  \"0,    Idax, dax, im,  !*y, axR\"))\n+\t\t\t  \"0,    Idax, dax, im, !*y, ax\"))\n   ]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n@@ -1657,279 +1657,6 @@\n   \"\"\n   \"not %0\"\n )\n-\f\n-;; -----------------------------------------------------------------\n-;; BIT FIELDS\n-;; -----------------------------------------------------------------\n-\n-\n-;; These set/clear memory in byte sized chunks.\n-;;\n-;; They are no smaller/faster than loading the value into a register\n-;; and storing the register, but they don't need a scratch register\n-;; which may allow for better code generation.\n-(define_insn \"*byte_clear\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int 0))\n-   (clobber (reg:CC CC_REG))\n-   ]\n-  \"(! MEM_P (operands[0])) || (! MEM_VOLATILE_P (operands[0])\n-                               && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n-  \"@\n-  bclr 255,%A0\n-  clr %0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 66) (const_int 77))\n-\t\t\t  (const_int 11)\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_insn \"*byte_set\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int -1))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"(! MEM_P (operands[0])) || (! MEM_VOLATILE_P (operands[0])\n-                               && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n-  \"@\n-  bset 255,%A0\n-  mov -1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 66) (const_int 77))\n-\t\t\t  (const_int 11)\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_insn \"*bit_clear1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"+R,d\")\n-\t(subreg:QI\n-\t  (and:SI (subreg:SI (match_dup 0) 0)\n-\t\t  (match_operand:SI 1 \"const_int_operand\" \"i,i\")) 0))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"\"\n-  \"@\n-  bclr %N1,%A0\n-  and %1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 66) (const_int 77))\n-\t\t\t  (const_int 11)\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_insn \"*bit_clear2\"\n-  [(set (match_operand:QI 0 \"memory_operand\" \"=R,T\")\n-\t(and:QI\n-\t (match_dup 0)\n-\t (not:QI (match_operand:QI 1 \"nonmemory_operand\" \"i,d\"))))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"\"\n-  \"@\n-  bclr %U1,%A0\n-  bclr %1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 66) (const_int 77))\n-\t\t\t  (const_int 66)\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_insn \"*bit_set\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"+R,d\")\n-\t(subreg:QI\n-\t  (ior:SI (subreg:SI (match_dup 0) 0)\n-\t\t  (match_operand:SI 1 \"const_int_operand\" \"i,i\")) 0))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"\"\n-  \"@\n-  bset %U1,%A0\n-  or %1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 66) (const_int 77))\n-\t\t\t  (const_int 11)\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_expand \"iorqi3\"\n-  [(parallel [(set (match_operand:QI         0 \"nonimmediate_operand\")\n-\t\t   (ior:QI (match_operand:QI 1 \"nonimmediate_operand\")\n-\t\t\t   (match_operand:QI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*am33_iorqi3\"\n-  [(set (match_operand:QI         0 \"nonimmediate_operand\" \"=R,T,r\")\n-\t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t;; This constraint should really be nonmemory_operand,\n-\t\t;; but making it general_operand, along with the\n-\t\t;; condition that not both input operands are MEMs,\n-\t\t;; helps combine do a better job.\n-\t\t(match_operand:QI 2 \"general_operand\" \"i,d,ir\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33 && \n-   ((! MEM_P (operands[2])) || (! MEM_P (operands[1])))\"\n-  \"@\n-  bset %U2,%A0\n-  bset %2,%0\n-  or %2,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 66) (const_int 77))\n-\t\t\t  (const_int 66)\n-\t\t\t  (const_int 11)\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_insn \"*mn10300_iorqi3\"\n-  [(set (match_operand:QI         0 \"nonimmediate_operand\" \"=R,T,d\")\n-\t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t;; This constraint should really be nonmemory_operand,\n-\t\t;; but making it general_operand, along with the\n-\t\t;; condition that not both input operands are MEMs,\n-\t\t;; helps combine do a better job.\n-\t\t(match_operand:QI 2 \"general_operand\" \"i,d,id\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"(! MEM_P (operands[2])) || (! MEM_P (operands[1]))\"\n-  \"@\n-  bset %U2,%A0\n-  bset %2,%0\n-  or %2,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 66) (const_int 77))\n-\t\t\t  (const_int 66)\n-\t\t\t  (const_int 11)\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_insn \"*test_int_bitfield\"\n-  [(set (reg:CC CC_REG)\n-     (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t\t       (match_operand 1 \"const_int_operand\" \"\")\n-\t\t\t       (match_operand 2 \"const_int_operand\" \"\"))\n-\t      (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  int len = INTVAL (operands[1]);\n-  int bit = INTVAL (operands[2]);\n-  int mask = 0;\n-  rtx xoperands[2];\n-\n-  while (len > 0)\n-    {\n-      mask |= (1 << bit);\n-      bit++;\n-      len--;\n-    }\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = GEN_INT (trunc_int_for_mode (mask, SImode));\n-  output_asm_insn (\\\"btst %1,%0\\\", xoperands);\n-  return \\\"\\\";\n-}\"\n-)\n-\n-(define_insn \"*test_byte_bitfield\"\n-  [(set (reg:CC CC_REG)\n-     (compare (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"R,dx\")\n-\t\t\t       (match_operand 1 \"const_int_operand\" \"\")\n-\t\t\t       (match_operand 2 \"const_int_operand\" \"\"))\n-\t      (const_int 0)))]\n-  \"mn10300_mask_ok_for_mem_btst (INTVAL (operands[1]), INTVAL (operands[2]))\"\n-  \"*\n-{\n-  int len = INTVAL (operands[1]);\n-  int bit = INTVAL (operands[2]);\n-  int mask = 0;\n-  rtx xoperands[2];\n-\n-  while (len > 0)\n-    {\n-      mask |= (1 << bit);\n-      bit++;\n-      len--;\n-    }\n-\n-  /* If the source operand is not a reg (i.e. it is memory), then extract the\n-     bits from mask that we actually want to test.  Note that the mask will\n-     never cross a byte boundary.  */\n-  if (!REG_P (operands[0]))\n-    {\n-      if (mask & 0xff)\n-\tmask = mask & 0xff;\n-      else if (mask & 0xff00)\n-\tmask = (mask >> 8) & 0xff;\n-      else if (mask & 0xff0000)\n-\tmask = (mask >> 16) & 0xff;\n-      else if (mask & 0xff000000)\n-\tmask = (mask >> 24) & 0xff;\n-    }\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = GEN_INT (trunc_int_for_mode (mask, SImode));\n-  if (REG_P (operands[0]))\n-    output_asm_insn (\\\"btst %1,%0\\\", xoperands);\n-  else\n-    output_asm_insn (\\\"btst %U1,%A0\\\", xoperands);\n-  return \\\"\\\";\n-}\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t \t\t(const_int 11) (const_int 22))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t  \t\t(const_int 44) (const_int 55))\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_insn \"*bit_test\"\n-  [(set (reg:CC CC_REG)\n-\t(compare (and:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"\"))\n-\t\t (const_int 0)))\n-  ]\n-  \"\"\n-  \"btst %1,%0\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t       (const_int 11) (const_int 22)))]\n-)\n-\n-(define_insn \"*subreg_bit_test\"\n-  [(set (reg:CC CC_REG)\n-     (compare (and:SI\n-\t       (subreg:SI (match_operand:QI 0 \"nonimmediate_operand\" \"R,dx\") 0)\n-\t       (match_operand:SI 1 \"const_8bit_operand\" \"\"))\n-\t      (const_int 0)))]\n-  \"\"\n-  \"@\n-  btst %U1,%A0\n-  btst %1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 44) (const_int 55))\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 11) (const_int 22))\n-\t\t\t ])\n-  ]\n-)\n-\n \f\n ;; ----------------------------------------------------------------------\n ;; COMPARE AND BRANCH INSTRUCTIONS"}, {"sha": "df1b1f479663a2ebdccf9b9514a5eba1e8ac0af1", "filename": "gcc/config/mn10300/predicates.md", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df37c0236d8bdf8e986231942bbdc9369fdc0f44/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fpredicates.md?ref=df37c0236d8bdf8e986231942bbdc9369fdc0f44", "patch": "@@ -25,18 +25,6 @@\n   return (op == CONST1_RTX (SFmode));\n })\n \n-;; Return 1 if X is a CONST_INT that is only 8 bits wide.  This is\n-;; used for the btst insn which may examine memory or a register (the\n-;; memory variant only allows an unsigned 8-bit integer).\n-\n-(define_predicate \"const_8bit_operand\"\n-  (match_code \"const_int\")\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) >= 0\n-\t  && INTVAL (op) < 256);\n-})\n-\n ;; Return true if OP is a valid call operand.\n \n (define_predicate \"call_address_operand\""}]}