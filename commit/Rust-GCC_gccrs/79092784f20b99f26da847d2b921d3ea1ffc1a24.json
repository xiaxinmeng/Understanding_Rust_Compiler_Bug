{"sha": "79092784f20b99f26da847d2b921d3ea1ffc1a24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkwOTI3ODRmMjBiOTlmMjZkYTg0N2QyYjkyMWQzZWExZmZjMWEyNA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-20T15:15:23Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-22T13:56:27Z"}, "message": "Refactor the function query compilation function out\n\nThis is an initial stab to refactor the query based compilation for paths.", "tree": {"sha": "0748faa44dcc18f1f19683c0cdf5815ce70e5c48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0748faa44dcc18f1f19683c0cdf5815ce70e5c48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79092784f20b99f26da847d2b921d3ea1ffc1a24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79092784f20b99f26da847d2b921d3ea1ffc1a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79092784f20b99f26da847d2b921d3ea1ffc1a24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79092784f20b99f26da847d2b921d3ea1ffc1a24/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6c8bd136dd4e89752eaec6415ba651f3cd73b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c8bd136dd4e89752eaec6415ba651f3cd73b9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c8bd136dd4e89752eaec6415ba651f3cd73b9e"}], "stats": {"total": 283, "additions": 153, "deletions": 130}, "files": [{"sha": "9cceb1ef3fc12c761a489c1a421a4f76877ec6d5", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 147, "deletions": 130, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79092784f20b99f26da847d2b921d3ea1ffc1a24/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79092784f20b99f26da847d2b921d3ea1ffc1a24/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=79092784f20b99f26da847d2b921d3ea1ffc1a24", "patch": "@@ -89,164 +89,181 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n   TyTy::BaseType *lookup = nullptr;\n   bool ok = ctx->get_tyctx ()->lookup_type (mappings.get_hirid (), &lookup);\n   rust_assert (ok);\n-  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+  if (lookup->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n \n-  Bfunction *fn = nullptr;\n-  if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n+      Bfunction *fn = nullptr;\n+      if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t{\n+\t  resolved\n+\t    = ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+\t}\n+      else\n+\t{\n+\t  resolved\n+\t    = query_compile_function (ref, fntype, final_segment, mappings,\n+\t\t\t\t      expr_locus, is_qualified_path);\n+\t}\n+    }\n+  else\n     {\n-      // it must resolve to some kind of HIR::Item or HIR::InheritImplItem\n       HIR::Item *resolved_item\n \t= ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (),\n \t\t\t\t\t\t ref);\n-      if (resolved_item != nullptr)\n+      HirId parent_impl_id = UNKNOWN_HIRID;\n+      HIR::ImplItem *resolved_impl_item\n+\t= ctx->get_mappings ()->lookup_hir_implitem (mappings.get_crate_num (),\n+\t\t\t\t\t\t     ref, &parent_impl_id);\n+      bool is_impl_item = resolved_impl_item != nullptr;\n+      bool is_item = resolved_item != nullptr;\n+\n+      gcc_unreachable ();\n+    }\n+}\n+\n+Bexpression *\n+ResolvePathRef::query_compile_function (\n+  HirId ref, TyTy::FnType *fntype, const HIR::PathIdentSegment &final_segment,\n+  const Analysis::NodeMapping &mappings, Location expr_locus,\n+  bool is_qualified_path)\n+{\n+  HIR::Item *resolved_item\n+    = ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (), ref);\n+  bool is_hir_item = resolved_item != nullptr;\n+  if (is_hir_item)\n+    {\n+      if (!fntype->has_subsititions_defined ())\n+\tCompileItem::compile (resolved_item, ctx);\n+      else\n+\tCompileItem::compile (resolved_item, ctx, true, fntype);\n+    }\n+  else\n+    {\n+      HirId parent_impl_id = UNKNOWN_HIRID;\n+      HIR::ImplItem *resolved_item\n+\t= ctx->get_mappings ()->lookup_hir_implitem (mappings.get_crate_num (),\n+\t\t\t\t\t\t     ref, &parent_impl_id);\n+      bool is_impl_item = resolved_item != nullptr;\n+      if (is_impl_item)\n \t{\n-\t  if (!lookup->has_subsititions_defined ())\n-\t    CompileItem::compile (resolved_item, ctx);\n+\t  rust_assert (parent_impl_id != UNKNOWN_HIRID);\n+\t  HIR::Item *impl_ref\n+\t    = ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (),\n+\t\t\t\t\t\t     parent_impl_id);\n+\t  rust_assert (impl_ref != nullptr);\n+\t  HIR::ImplBlock *impl = static_cast<HIR::ImplBlock *> (impl_ref);\n+\n+\t  TyTy::BaseType *self = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    impl->get_type ()->get_mappings ().get_hirid (), &self);\n+\t  rust_assert (ok);\n+\n+\t  if (!fntype->has_subsititions_defined ())\n+\t    CompileInherentImplItem::Compile (self, resolved_item, ctx, true);\n \t  else\n-\t    CompileItem::compile (resolved_item, ctx, true, lookup);\n+\t    CompileInherentImplItem::Compile (self, resolved_item, ctx, true,\n+\t\t\t\t\t      fntype);\n \t}\n       else\n \t{\n-\t  HirId parent_impl_id = UNKNOWN_HIRID;\n-\t  HIR::ImplItem *resolved_item\n-\t    = ctx->get_mappings ()->lookup_hir_implitem (\n-\t      mappings.get_crate_num (), ref, &parent_impl_id);\n-\n-\t  if (resolved_item == nullptr)\n+\t  // it might be resolved to a trait item\n+\t  HIR::TraitItem *trait_item\n+\t    = ctx->get_mappings ()->lookup_hir_trait_item (\n+\t      mappings.get_crate_num (), ref);\n+\t  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+\t    trait_item->get_mappings ().get_hirid ());\n+\n+\t  Resolver::TraitReference *trait_ref\n+\t    = &Resolver::TraitReference::error_node ();\n+\t  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+\t    trait->get_mappings ().get_defid (), &trait_ref);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *receiver = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_receiver (mappings.get_hirid (),\n+\t\t\t\t\t\t   &receiver);\n+\t  rust_assert (ok);\n+\n+\t  if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n \t    {\n-\t      // it might be resolved to a trait item\n-\t      HIR::TraitItem *trait_item\n-\t\t= ctx->get_mappings ()->lookup_hir_trait_item (\n-\t\t  mappings.get_crate_num (), ref);\n-\t      HIR::Trait *trait\n-\t\t= ctx->get_mappings ()->lookup_trait_item_mapping (\n-\t\t  trait_item->get_mappings ().get_hirid ());\n-\n-\t      Resolver::TraitReference *trait_ref\n-\t\t= &Resolver::TraitReference::error_node ();\n-\t      bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n-\t\ttrait->get_mappings ().get_defid (), &trait_ref);\n-\t      rust_assert (ok);\n+\t      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+\t      receiver = p->resolve ();\n+\t    }\n \n-\t      TyTy::BaseType *receiver = nullptr;\n-\t      ok = ctx->get_tyctx ()->lookup_receiver (mappings.get_hirid (),\n-\t\t\t\t\t\t       &receiver);\n-\t      rust_assert (ok);\n+\t  // the type resolver can only resolve type bounds to their trait\n+\t  // item so its up to us to figure out if this path should resolve\n+\t  // to an trait-impl-block-item or if it can be defaulted to the\n+\t  // trait-impl-item's definition\n+\t  std::vector<Resolver::PathProbeCandidate> candidates;\n+\t  if (!is_qualified_path)\n+\t    {\n+\t      candidates\n+\t\t= Resolver::PathProbeType::Probe (receiver, final_segment, true,\n+\t\t\t\t\t\t  false, true);\n+\t    }\n \n-\t      if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n-\t\t{\n-\t\t  TyTy::ParamType *p\n-\t\t    = static_cast<TyTy::ParamType *> (receiver);\n-\t\t  receiver = p->resolve ();\n-\t\t}\n-\n-\t      // the type resolver can only resolve type bounds to their trait\n-\t      // item so its up to us to figure out if this path should resolve\n-\t      // to an trait-impl-block-item or if it can be defaulted to the\n-\t      // trait-impl-item's definition\n-\t      std::vector<Resolver::PathProbeCandidate> candidates;\n-\t      if (!is_qualified_path)\n-\t\t{\n-\t\t  candidates\n-\t\t    = Resolver::PathProbeType::Probe (receiver, final_segment,\n-\t\t\t\t\t\t      true, false, true);\n-\t\t}\n-\n-\t      if (candidates.size () == 0)\n-\t\t{\n-\t\t  // this means we are defaulting back to the trait_item if\n-\t\t  // possible\n-\t\t  Resolver::TraitItemReference *trait_item_ref = nullptr;\n-\t\t  bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n-\t\t\t\t\t\t\t      &trait_item_ref);\n-\t\t  rust_assert (ok); // found\n-\t\t  rust_assert (\n-\t\t    trait_item_ref->is_optional ()); // has definition\n-\n-\t\t  Analysis::NodeMapping trait_mappings\n-\t\t    = trait_item_ref->get_parent_trait_mappings ();\n-\t\t  auto associated_impl_id\n-\t\t    = ctx->get_tyctx ()\n-\t\t\t->lookup_associated_impl_mapping_for_self (\n-\t\t\t  trait_mappings.get_hirid (), receiver);\n-\n-\t\t  rust_assert (associated_impl_id != UNKNOWN_HIRID);\n-\n-\t\t  Resolver::AssociatedImplTrait *associated = nullptr;\n-\t\t  bool found_associated_trait_impl\n-\t\t    = ctx->get_tyctx ()->lookup_associated_trait_impl (\n-\t\t      associated_impl_id, &associated);\n-\t\t  rust_assert (found_associated_trait_impl);\n-\t\t  associated->setup_associated_types ();\n-\n-\t\t  CompileTraitItem::Compile (\n-\t\t    receiver, trait_item_ref->get_hir_trait_item (), ctx,\n-\t\t    fntype);\n-\n-\t\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-\t\t    {\n-\t\t      resolved = ctx->get_backend ()->error_expression ();\n-\t\t      rust_error_at (expr_locus,\n-\t\t\t\t     \"forward declaration was not compiled\");\n-\t\t      return;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  Resolver::PathProbeCandidate &candidate = candidates.at (0);\n-\t\t  rust_assert (candidate.is_impl_candidate ());\n-\n-\t\t  HIR::ImplBlock *impl = candidate.item.impl.parent;\n-\t\t  HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n-\n-\t\t  TyTy::BaseType *self = nullptr;\n-\t\t  bool ok = ctx->get_tyctx ()->lookup_type (\n-\t\t    impl->get_type ()->get_mappings ().get_hirid (), &self);\n-\t\t  rust_assert (ok);\n-\n-\t\t  if (!lookup->has_subsititions_defined ())\n-\t\t    CompileInherentImplItem::Compile (self, impl_item, ctx,\n-\t\t\t\t\t\t      true);\n-\t\t  else\n-\t\t    CompileInherentImplItem::Compile (self, impl_item, ctx,\n-\t\t\t\t\t\t      true, lookup);\n-\n-\t\t  lookup->set_ty_ref (\n-\t\t    impl_item->get_impl_mappings ().get_hirid ());\n-\t\t}\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      // this means we are defaulting back to the trait_item if\n+\t      // possible\n+\t      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+\t      bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n+\t\t\t\t\t\t\t  &trait_item_ref);\n+\t      rust_assert (ok);\t\t\t\t    // found\n+\t      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+\t      Analysis::NodeMapping trait_mappings\n+\t\t= trait_item_ref->get_parent_trait_mappings ();\n+\t      auto associated_impl_id\n+\t\t= ctx->get_tyctx ()->lookup_associated_impl_mapping_for_self (\n+\t\t  trait_mappings.get_hirid (), receiver);\n+\n+\t      rust_assert (associated_impl_id != UNKNOWN_HIRID);\n+\n+\t      Resolver::AssociatedImplTrait *associated = nullptr;\n+\t      bool found_associated_trait_impl\n+\t\t= ctx->get_tyctx ()->lookup_associated_trait_impl (\n+\t\t  associated_impl_id, &associated);\n+\t      rust_assert (found_associated_trait_impl);\n+\t      associated->setup_associated_types ();\n+\n+\t      CompileTraitItem::Compile (receiver,\n+\t\t\t\t\t trait_item_ref->get_hir_trait_item (),\n+\t\t\t\t\t ctx, fntype);\n \t    }\n \t  else\n \t    {\n-\t      rust_assert (parent_impl_id != UNKNOWN_HIRID);\n-\t      HIR::Item *impl_ref = ctx->get_mappings ()->lookup_hir_item (\n-\t\tmappings.get_crate_num (), parent_impl_id);\n-\t      rust_assert (impl_ref != nullptr);\n-\t      HIR::ImplBlock *impl = static_cast<HIR::ImplBlock *> (impl_ref);\n+\t      Resolver::PathProbeCandidate &candidate = candidates.at (0);\n+\t      rust_assert (candidate.is_impl_candidate ());\n+\n+\t      HIR::ImplBlock *impl = candidate.item.impl.parent;\n+\t      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n \n \t      TyTy::BaseType *self = nullptr;\n \t      bool ok = ctx->get_tyctx ()->lookup_type (\n \t\timpl->get_type ()->get_mappings ().get_hirid (), &self);\n \t      rust_assert (ok);\n \n-\t      if (!lookup->has_subsititions_defined ())\n-\t\tCompileInherentImplItem::Compile (self, resolved_item, ctx,\n-\t\t\t\t\t\t  true);\n+\t      if (!fntype->has_subsititions_defined ())\n+\t\tCompileInherentImplItem::Compile (self, impl_item, ctx, true);\n \t      else\n-\t\tCompileInherentImplItem::Compile (self, resolved_item, ctx,\n-\t\t\t\t\t\t  true, lookup);\n+\t\tCompileInherentImplItem::Compile (self, impl_item, ctx, true,\n+\t\t\t\t\t\t  fntype);\n+\n+\t      fntype->set_ty_ref (impl_item->get_impl_mappings ().get_hirid ());\n \t    }\n \t}\n+    }\n \n-      if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n-\t{\n-\t  resolved = ctx->get_backend ()->error_expression ();\n-\t  rust_error_at (expr_locus, \"forward declaration was not compiled\");\n-\t  return;\n-\t}\n+  Bfunction *fn;\n+  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+    {\n+      rust_error_at (expr_locus, \"forward declaration was not compiled\");\n+      return ctx->get_backend ()->error_expression ();\n     }\n \n-  resolved = ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+  return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n }\n \n } // namespace Compile"}, {"sha": "6c234d17f8e99f4e847fc425612a15064fc8b762", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79092784f20b99f26da847d2b921d3ea1ffc1a24/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79092784f20b99f26da847d2b921d3ea1ffc1a24/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=79092784f20b99f26da847d2b921d3ea1ffc1a24", "patch": "@@ -58,6 +58,12 @@ class ResolvePathRef : public HIRCompileBase\n \t\tconst Analysis::NodeMapping &mappings, Location locus,\n \t\tbool is_qualified_path);\n \n+  Bexpression *\n+  query_compile_function (HirId ref, TyTy::FnType *fntype,\n+\t\t\t  const HIR::PathIdentSegment &final_segment,\n+\t\t\t  const Analysis::NodeMapping &mappings,\n+\t\t\t  Location expr_locus, bool is_qualified_path);\n+\n   Bexpression *resolved;\n };\n "}]}