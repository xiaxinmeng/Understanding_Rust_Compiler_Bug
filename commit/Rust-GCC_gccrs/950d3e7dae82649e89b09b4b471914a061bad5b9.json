{"sha": "950d3e7dae82649e89b09b4b471914a061bad5b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUwZDNlN2RhZTgyNjQ5ZTg5YjA5YjRiNDcxOTE0YTA2MWJhZDViOQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-11-15T14:02:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T14:02:46Z"}, "message": "sem_ch3.ads, [...] (Build_Discriminal): Add link to original discriminant.\n\n2005-11-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.ads, sem_ch3.adb (Build_Discriminal): Add link to original\n\tdiscriminant.\n\t(Build_Private_Derived_Type): The entity of the created full view of the\n\tderived type does not come from source. If after installing the private\n\tdeclarations of the parent scope the parent is still private, use its\n\tfull view to construct the full declaration of the derived type.\n\t(Build_Derived_Record_Type): Relax the condition that controls the\n\texecution of the check that verifies that the partial view and\n\tthe full view agree in the set of implemented interfaces. In\n\taddition, this test now only takes into account the progenitors.\n\t(Derive_Interface_Subprograms): No need to derive subprograms\n\tof ancestors that are interfaces.\n\t(Derive_Subprograms): Remove formal No_Predefined_Prims and the\n\tassociated code.\n\tChange name Is_Package to Is_Package_Or_Generic_Package\n\t(Complete_Subprograms_Derivation): Handle the case in which the full\n\tview is a transitive derivation of the ancestor of the partial view.\n\t(Process_Full_View): Rename local subprogram Find_Interface_In_\n\tDescendant to Find_Ancestor_Interface to leave the code more clear.\n\tRemove wrong code that avoids the generation of an error message\n\twhen the immediate ancestor of the partial view is an interface.\n\tIn addition some minor reorganization of the code has been done to\n\tleave it more clear.\n\t(Analyze_Type_Declaration): If type has previous incomplete tagged\n\tpartial view, inherit properly its primitive operations.\n\t(Collect_Interfaces): Make public, for analysis of formal\n\tinterfaces.\n\t(Analyze_Interface_Declaration): New procedure for use for regular and\n\tformal interface declarations.\n\t(Build_Derived_Record_Type): Add support for private types to the code\n\tthat checks if a tagged type implements abstract interfaces.\n\t(Check_Aliased_Component_Type): The test applies in the spec of an\n\tinstance as well.\n\t(Access_Type_Declaration): Clean up declaration of malformed type\n\tdeclared as an access to its own classwide type, to prevent cascaded\n\tcrash.\n\t(Collect_Interfaces): For private extensions and for derived task types\n\tand derived protected types, the parent may be an interface that must\n\tbe included in the interface list.\n\t(Access_Definition): If the designated type is an interface that may\n\tcontain tasks, create Master_Id for it before analyzing the expression\n\tof the declaration, which may be an allocator.\n\t(Record_Type_Declaration): Set properly the interface kind, for use\n\tin allocators, the creation of master id's for task interfaces, etc.\n\nFrom-SVN: r107000", "tree": {"sha": "b8252a5759d785b023e59a4ccb542ef6464937aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8252a5759d785b023e59a4ccb542ef6464937aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/950d3e7dae82649e89b09b4b471914a061bad5b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/950d3e7dae82649e89b09b4b471914a061bad5b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/950d3e7dae82649e89b09b4b471914a061bad5b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/950d3e7dae82649e89b09b4b471914a061bad5b9/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04814daddf1ff25af29ca2bf11e3e0dbbfc9e780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780"}], "stats": {"total": 455, "additions": 261, "deletions": 194}, "files": [{"sha": "a799427e013aff397b53ef487e643fcef820ac32", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 246, "deletions": 188, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/950d3e7dae82649e89b09b4b471914a061bad5b9/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/950d3e7dae82649e89b09b4b471914a061bad5b9/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=950d3e7dae82649e89b09b4b471914a061bad5b9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -171,14 +171,6 @@ package body Sem_Ch3 is\n    --  False is for an implicit derived full type for a type derived from a\n    --  private type (see Build_Derived_Type).\n \n-   procedure Collect_Interfaces\n-     (N            : Node_Id;\n-      Derived_Type : Entity_Id);\n-   --  Ada 2005 (AI-251): Subsidiary procedure to Build_Derived_Record_Type.\n-   --  Collect the list of interfaces that are not already implemented by the\n-   --  ancestors. This is the list of interfaces for which we must provide\n-   --  additional tag components.\n-\n    procedure Complete_Subprograms_Derivation\n      (Partial_View : Entity_Id;\n       Derived_Type : Entity_Id);\n@@ -799,6 +791,20 @@ package body Sem_Ch3 is\n          Set_Has_Delayed_Freeze (Current_Scope);\n       end if;\n \n+      --  Ada 2005: if the designated type is an interface that may contain\n+      --  tasks, create a Master entity for the declaration. This must be done\n+      --  before expansion of the full declaration, because the declaration\n+      --  may include an expression that is an allocator, whose expansion needs\n+      --  the proper Master for the created tasks.\n+\n+      if Nkind (Related_Nod) = N_Object_Declaration\n+         and then Expander_Active\n+         and then Is_Interface (Desig_Type)\n+         and then Is_Limited_Record (Desig_Type)\n+      then\n+         Build_Class_Wide_Master (Anon_Type);\n+      end if;\n+\n       return Anon_Type;\n    end Access_Definition;\n \n@@ -985,6 +991,10 @@ package body Sem_Ch3 is\n       then\n          Error_Msg_N\n            (\"access type cannot designate its own classwide type\", S);\n+\n+         --  Clean up indication of tagged status to prevent cascaded errors\n+\n+         Set_Is_Tagged_Type (T, False);\n       end if;\n \n       Set_Etype (T, T);\n@@ -1584,6 +1594,33 @@ package body Sem_Ch3 is\n       Set_Is_Pure (T, F);\n    end Analyze_Incomplete_Type_Decl;\n \n+   -----------------------------------\n+   -- Analyze_Interface_Declaration --\n+   -----------------------------------\n+\n+   procedure Analyze_Interface_Declaration (T : Entity_Id; Def : Node_Id) is\n+   begin\n+      Set_Is_Tagged_Type      (T);\n+\n+      Set_Is_Limited_Record   (T, Limited_Present (Def)\n+                                   or else Task_Present (Def)\n+                                   or else Protected_Present (Def)\n+                                   or else Synchronized_Present (Def));\n+\n+      --  Type is abstract if full declaration carries keyword, or if\n+      --  previous partial view did.\n+\n+      Set_Is_Abstract  (T);\n+      Set_Is_Interface (T);\n+\n+      Set_Is_Limited_Interface      (T, Limited_Present (Def));\n+      Set_Is_Protected_Interface    (T, Protected_Present (Def));\n+      Set_Is_Synchronized_Interface (T, Synchronized_Present (Def));\n+      Set_Is_Task_Interface         (T, Task_Present (Def));\n+      Set_Abstract_Interfaces       (T, New_Elmt_List);\n+      Set_Primitive_Operations      (T, New_Elmt_List);\n+   end Analyze_Interface_Declaration;\n+\n    -----------------------------\n    -- Analyze_Itype_Reference --\n    -----------------------------\n@@ -1958,7 +1995,7 @@ package body Sem_Ch3 is\n       if Constant_Present (N)\n         and then No (E)\n       then\n-         if not Is_Package (Current_Scope) then\n+         if not Is_Package_Or_Generic_Package (Current_Scope) then\n             Error_Msg_N\n               (\"invalid context for deferred constant declaration ('R'M 7.4)\",\n                 N);\n@@ -2589,7 +2626,7 @@ package body Sem_Ch3 is\n          return;\n       end if;\n \n-      if (not Is_Package (Current_Scope)\n+      if (not Is_Package_Or_Generic_Package (Current_Scope)\n            and then Nkind (Parent (N)) /= N_Generic_Subprogram_Declaration)\n         or else In_Private_Part (Current_Scope)\n \n@@ -3011,6 +3048,51 @@ package body Sem_Ch3 is\n                                        or else\n                                      In_Package_Body (Current_Scope));\n \n+      procedure Check_Ops_From_Incomplete_Type;\n+      --  If there is a tagged incomplete partial view of the type, transfer\n+      --  its operations to the full view, and indicate that the type of the\n+      --  controlling parameter (s) is this full view.\n+\n+      ------------------------------------\n+      -- Check_Ops_From_Incomplete_Type --\n+      ------------------------------------\n+\n+      procedure Check_Ops_From_Incomplete_Type is\n+         Elmt   : Elmt_Id;\n+         Formal : Entity_Id;\n+         Op     : Entity_Id;\n+\n+      begin\n+         if Prev /= T\n+           and then Ekind (Prev) = E_Incomplete_Type\n+           and then Is_Tagged_Type (Prev)\n+           and then Is_Tagged_Type (T)\n+         then\n+            Elmt := First_Elmt (Primitive_Operations (Prev));\n+            while Present (Elmt) loop\n+               Op := Node (Elmt);\n+               Prepend_Elmt (Op, Primitive_Operations (T));\n+\n+               Formal := First_Formal (Op);\n+               while Present (Formal) loop\n+                  if Etype (Formal) = Prev then\n+                     Set_Etype (Formal, T);\n+                  end if;\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+\n+               if Etype (Op) = Prev then\n+                  Set_Etype (Op, T);\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end if;\n+      end Check_Ops_From_Incomplete_Type;\n+\n+   --  Start of processing for Analyze_Type_Declaration\n+\n    begin\n       Prev := Find_Type_Name (N);\n \n@@ -3149,6 +3231,7 @@ package body Sem_Ch3 is\n       --  Some common processing for all types\n \n       Set_Depends_On_Private (T, Has_Private_Component (T));\n+      Check_Ops_From_Incomplete_Type;\n \n       --  Both the declared entity, and its anonymous base type if one\n       --  was created, need freeze nodes allocated.\n@@ -3787,7 +3870,8 @@ package body Sem_Ch3 is\n       if Number_Dimensions (Parent_Type) = 1\n         and then not Is_Limited_Type (Parent_Type)\n         and then not Is_Derived_Type (Parent_Type)\n-        and then not Is_Package (Scope (Base_Type (Parent_Type)))\n+        and then not Is_Package_Or_Generic_Package\n+                       (Scope (Base_Type (Parent_Type)))\n       then\n          if not Is_Constrained (Parent_Type)\n            and then Is_Constrained (Derived_Type)\n@@ -4438,6 +4522,7 @@ package body Sem_Ch3 is\n                Full_Decl := New_Copy_Tree (N);\n                Full_Der  := New_Copy (Derived_Type);\n                Set_Comes_From_Source (Full_Decl, False);\n+               Set_Comes_From_Source (Full_Der, False);\n \n                Insert_After (N, Full_Decl);\n \n@@ -4493,8 +4578,18 @@ package body Sem_Ch3 is\n             --  view, the completion does not derive them anew.\n \n             if not Is_Tagged_Type (Parent_Type) then\n-               Build_Derived_Record_Type\n-                 (Full_Decl, Parent_Type, Full_Der, False);\n+\n+               --  If the parent is itself derived from another private type,\n+               --  installing the private declarations has not affected its\n+               --  privacy status, so use its own full view explicitly.\n+\n+               if Is_Private_Type (Parent_Type) then\n+                  Build_Derived_Record_Type\n+                    (Full_Decl, Full_View (Parent_Type), Full_Der, False);\n+               else\n+                  Build_Derived_Record_Type\n+                    (Full_Decl, Parent_Type, Full_Der, False);\n+               end if;\n \n             else\n                --  If full view of parent is tagged, the completion\n@@ -5895,113 +5990,37 @@ package body Sem_Ch3 is\n                Collect_Interfaces (Type_Definition (N), Derived_Type);\n             end if;\n \n-            --  Check that the full view and the partial view agree\n-            --  in the set of implemented interfaces\n+            --  Ada 2005 (AI-251): The progenitor types specified in a private\n+            --  extension declaration and the progenitor types specified in the\n+            --  corresponding declaration of a record extension given in the\n+            --  private part need not be the same; the only requirement is that\n+            --  the private extension must be descended from each interface\n+            --  from which the record extension is descended (AARM 7.3, 20.1/2)\n \n-            if Has_Private_Declaration (Derived_Type)\n-              and then Present (Abstract_Interfaces (Derived_Type))\n-              and then not Is_Empty_Elmt_List\n-                             (Abstract_Interfaces (Derived_Type))\n-            then\n+            if Has_Private_Declaration (Derived_Type) then\n                declare\n                   N_Partial : constant Node_Id := Parent (Tagged_Partial_View);\n-                  N_Full    : constant Node_Id := Parent (Derived_Type);\n-\n-                  Iface_Partial      : Entity_Id;\n-                  Iface_Full         : Entity_Id;\n-                  Num_Ifaces_Partial : Natural := 0;\n-                  Num_Ifaces_Full    : Natural := 0;\n-                  Same_Interfaces    : Boolean := True;\n+                  Iface_Partial : Entity_Id;\n \n                begin\n-                  if Nkind (N_Partial) /= N_Private_Extension_Declaration then\n-                     Error_Msg_N\n-                       (\"(Ada 2005) interfaces only allowed in private\"\n-                        & \" extension declarations\", N_Partial);\n-                  end if;\n-\n-                  --  Count the interfaces implemented by the partial view\n-\n                   if Nkind (N_Partial) = N_Private_Extension_Declaration\n                     and then not Is_Empty_List (Interface_List (N_Partial))\n                   then\n                      Iface_Partial := First (Interface_List (N_Partial));\n-                     while Present (Iface_Partial) loop\n-                        Num_Ifaces_Partial := Num_Ifaces_Partial + 1;\n-                        Next (Iface_Partial);\n-                     end loop;\n-                  end if;\n-\n-                  --  Take into account the case in which the partial\n-                  --  view is a directly derived from an interface\n-\n-                  if Is_Interface (Etype\n-                                   (Defining_Identifier (N_Partial)))\n-                  then\n-                     Num_Ifaces_Partial := Num_Ifaces_Partial + 1;\n-                  end if;\n-\n-                  --  Count the interfaces implemented by the full view\n-\n-                  if not Is_Empty_List (Interface_List\n-                                        (Type_Definition (N_Full)))\n-                  then\n-                     Iface_Full := First (Interface_List\n-                                          (Type_Definition (N_Full)));\n-                     while Present (Iface_Full) loop\n-                        Num_Ifaces_Full := Num_Ifaces_Full + 1;\n-                        Next (Iface_Full);\n-                     end loop;\n-                  end if;\n-\n-                  --  Take into account the case in which the full\n-                  --  view is a directly derived from an interface\n-\n-                  if Is_Interface (Etype\n-                                   (Defining_Identifier (N_Full)))\n-                  then\n-                     Num_Ifaces_Full := Num_Ifaces_Full + 1;\n-                  end if;\n-\n-                  if Num_Ifaces_Full > 0\n-                    and then Num_Ifaces_Full = Num_Ifaces_Partial\n-                  then\n-                     --  Check that the full-view and the private-view have\n-                     --  the same list of interfaces.\n-\n-                     Iface_Full := First (Interface_List\n-                                           (Type_Definition (N_Full)));\n-                     while Present (Iface_Full) loop\n-                        Iface_Partial := First (Interface_List (N_Partial));\n-                        while Present (Iface_Partial)\n-                          and then Etype (Iface_Partial) /= Etype (Iface_Full)\n-                        loop\n-                           Next (Iface_Partial);\n-                        end loop;\n \n-                        --  If not found we check if the partial view is a\n-                        --  direct derivation of the interface.\n-\n-                        if not Present (Iface_Partial)\n-                             and then\n-                           Etype (Tagged_Partial_View) /= Etype (Iface_Full)\n+                     while Present (Iface_Partial) loop\n+                        if not Interface_Present_In_Ancestor\n+                                 (Derived_Type, Etype (Iface_Partial))\n                         then\n-                           Same_Interfaces := False;\n+                           Error_Msg_N\n+                             (\"(Ada 2005) full type and private extension must\"\n+                              & \" have the same progenitors\", Derived_Type);\n                            exit;\n                         end if;\n \n-                        Next (Iface_Full);\n+                        Next (Iface_Partial);\n                      end loop;\n                   end if;\n-\n-                  if Num_Ifaces_Partial /= Num_Ifaces_Full\n-                    or else not Same_Interfaces\n-                  then\n-                     Error_Msg_N\n-                       (\"(Ada 2005) full declaration and private declaration\"\n-                        & \" must have the same list of interfaces\",\n-                        Derived_Type);\n-                  end if;\n                end;\n             end if;\n          end if;\n@@ -6132,7 +6151,14 @@ package body Sem_Ch3 is\n                E : Entity_Id;\n \n             begin\n-               E := Derived_Type;\n+               --  Handle private types\n+\n+               if Present (Full_View (Derived_Type)) then\n+                  E := Full_View (Derived_Type);\n+               else\n+                  E := Derived_Type;\n+               end if;\n+\n                loop\n                   if Is_Interface (E)\n                     or else (Present (Abstract_Interfaces (E))\n@@ -6145,11 +6171,22 @@ package body Sem_Ch3 is\n \n                   exit when Etype (E) = E\n \n+                     --  Handle private types\n+\n+                     or else (Present (Full_View (Etype (E)))\n+                               and then Full_View (Etype (E)) = E)\n+\n                      --  Protect the frontend against wrong source\n \n                     or else Etype (E) = Derived_Type;\n \n-                  E := Etype (E);\n+                  --  Climb to the ancestor type handling private types\n+\n+                  if Present (Full_View (Etype (E))) then\n+                     E := Full_View (Etype (E));\n+                  else\n+                     E := Etype (E);\n+                  end if;\n                end loop;\n             end;\n          end if;\n@@ -6168,7 +6205,7 @@ package body Sem_Ch3 is\n \n             if Present (Tagged_Partial_View) then\n                Derive_Subprograms\n-                 (Parent_Type, Derived_Type, Predefined_Prims_Only => True);\n+                 (Parent_Type, Derived_Type);\n \n                Complete_Subprograms_Derivation\n                  (Partial_View => Tagged_Partial_View,\n@@ -6452,10 +6489,11 @@ package body Sem_Ch3 is\n       then\n          CR_Disc := Make_Defining_Identifier (Sloc (Discrim), Chars (Discrim));\n \n-         Set_Ekind     (CR_Disc, E_In_Parameter);\n-         Set_Mechanism (CR_Disc, Default_Mechanism);\n-         Set_Etype     (CR_Disc, Etype (Discrim));\n-         Set_CR_Discriminant (Discrim, CR_Disc);\n+         Set_Ekind            (CR_Disc, E_In_Parameter);\n+         Set_Mechanism        (CR_Disc, Default_Mechanism);\n+         Set_Etype            (CR_Disc, Etype (Discrim));\n+         Set_Discriminal_Link (CR_Disc, Discrim);\n+         Set_CR_Discriminant  (Discrim, CR_Disc);\n       end if;\n    end Build_Discriminal;\n \n@@ -7179,7 +7217,7 @@ package body Sem_Ch3 is\n                if Is_Aliased (C)\n                  and then Has_Discriminants (Etype (C))\n                  and then not Is_Constrained (Etype (C))\n-                 and then not In_Instance\n+                 and then not In_Instance_Body\n                  and then Ada_Version < Ada_05\n                then\n                   Error_Msg_N\n@@ -7194,7 +7232,8 @@ package body Sem_Ch3 is\n             if Has_Aliased_Components (T)\n               and then Has_Discriminants (Component_Type (T))\n               and then not Is_Constrained (Component_Type (T))\n-              and then not In_Instance\n+              and then not In_Instance_Body\n+              and then Ada_Version < Ada_05\n             then\n                Error_Msg_N\n                  (\"aliased component type must be constrained ('R'M 3.6(11))\",\n@@ -7363,7 +7402,7 @@ package body Sem_Ch3 is\n                Post_Error;\n             end if;\n \n-         elsif Is_Package (E) then\n+         elsif Is_Package_Or_Generic_Package (E) then\n             if Unit_Requires_Body (E) then\n                if not Has_Completion (E)\n                  and then Nkind (Parent (Unit_Declaration_Node (E))) /=\n@@ -7643,6 +7682,29 @@ package body Sem_Ch3 is\n \n             Next (Intf);\n          end loop;\n+\n+      --  A type extension may be written as a derivation from an interface.\n+      --  The completion will have to implement the same, or derive from a\n+      --  type that implements it as well.\n+\n+      elsif Nkind (N) = N_Private_Extension_Declaration\n+        and then Is_Interface (Etype (Derived_Type))\n+      then\n+         Add_Interface (Etype (Derived_Type));\n+      end if;\n+\n+      --  Same for task and protected types, that can derive directly from\n+      --  an interface (and implement additional interfaces that will be\n+      --  present in the interface list of the declaration).\n+\n+      if Nkind (N) = N_Task_Type_Declaration\n+        or else Nkind (N) = N_Protected_Type_Declaration\n+        or else Nkind (N) = N_Single_Protected_Declaration\n+        or else Nkind (N) = N_Single_Task_Declaration\n+      then\n+         if Is_Interface (Etype (Derived_Type)) then\n+            Add_Interface (Etype (Derived_Type));\n+         end if;\n       end if;\n    end Collect_Interfaces;\n \n@@ -7873,6 +7935,25 @@ package body Sem_Ch3 is\n       E       : Entity_Id;\n \n    begin\n+      --  Handle the case in which the full-view is a transitive\n+      --  derivation of the ancestor of the partial view.\n+\n+      --   type I is interface;\n+      --   type T is new I with ...\n+\n+      --   package H is\n+      --      type DT is new I with private;\n+      --   private\n+      --      type DT is new T with ...\n+      --   end;\n+\n+      if Etype (Partial_View) /= Etype (Derived_Type)\n+        and then Is_Interface (Etype (Partial_View))\n+        and then Is_Ancestor (Etype (Partial_View), Etype (Derived_Type))\n+      then\n+         return;\n+      end if;\n+\n       if Is_Tagged_Type (Partial_View) then\n          Elmt_P := First_Elmt (Primitive_Operations (Partial_View));\n       else\n@@ -8795,7 +8876,7 @@ package body Sem_Ch3 is\n \n    --  For concurrent types, the associated record value type carries the same\n    --  discriminants, so when we constrain a concurrent type, we must constrain\n-   --  the value type as well.\n+   --  the corresponding record type as well.\n \n    procedure Constrain_Concurrent\n      (Def_Id      : in out Entity_Id;\n@@ -9970,10 +10051,12 @@ package body Sem_Ch3 is\n          then\n             AI := First_Elmt (Abstract_Interfaces (T));\n             while Present (AI) loop\n-               Derive_Subprograms\n-                 (Parent_Type         => Node (AI),\n-                  Derived_Type        => Derived_Type,\n-                  No_Predefined_Prims => True);\n+               if not Is_Ancestor (Node (AI), Derived_Type) then\n+                  Derive_Subprograms\n+                    (Parent_Type         => Node (AI),\n+                     Derived_Type        => Derived_Type,\n+                     No_Predefined_Prims => True);\n+               end if;\n \n                Next_Elmt (AI);\n             end loop;\n@@ -10391,8 +10474,7 @@ package body Sem_Ch3 is\n      (Parent_Type           : Entity_Id;\n       Derived_Type          : Entity_Id;\n       Generic_Actual        : Entity_Id := Empty;\n-      No_Predefined_Prims   : Boolean   := False;\n-      Predefined_Prims_Only : Boolean   := False)\n+      No_Predefined_Prims   : Boolean   := False)\n    is\n       Op_List     : constant Elist_Id :=\n                       Collect_Primitive_Operations (Parent_Type);\n@@ -10436,7 +10518,13 @@ package body Sem_Ch3 is\n             if No_Predefined_Prims and then Is_Predef then\n                null;\n \n-            elsif Predefined_Prims_Only and then not Is_Predef then\n+            --  We don't need to derive alias entities associated with\n+            --  abstract interfaces\n+\n+            elsif Is_Dispatching_Operation (Subp)\n+               and then Present (Alias (Subp))\n+               and then Present (Abstract_Interface_Alias (Subp))\n+            then\n                null;\n \n             elsif No (Generic_Actual) then\n@@ -13098,15 +13186,15 @@ package body Sem_Ch3 is\n       Full_Parent : Entity_Id;\n       Full_Indic  : Node_Id;\n \n-      function Find_Interface_In_Descendant\n+      function Find_Ancestor_Interface\n         (Typ : Entity_Id) return Entity_Id;\n       --  Find an implemented interface in the derivation chain of Typ\n \n-      ----------------------------------\n-      -- Find_Interface_In_Descendant --\n-      ----------------------------------\n+      -----------------------------\n+      -- Find_Ancestor_Interface --\n+      -----------------------------\n \n-      function Find_Interface_In_Descendant\n+      function Find_Ancestor_Interface\n         (Typ : Entity_Id) return Entity_Id\n       is\n          T : Entity_Id;\n@@ -13127,7 +13215,7 @@ package body Sem_Ch3 is\n          end loop;\n \n          return Empty;\n-      end Find_Interface_In_Descendant;\n+      end Find_Ancestor_Interface;\n \n    --  Start of processing for Process_Full_View\n \n@@ -13180,37 +13268,36 @@ package body Sem_Ch3 is\n             Iface_Def : Node_Id;\n \n          begin\n-            Iface := Find_Interface_In_Descendant (Full_T);\n+            Iface := Find_Ancestor_Interface (Full_T);\n \n             if Present (Iface) then\n                Iface_Def := Type_Definition (Parent (Iface));\n-            end if;\n \n-            --  The full view derives from an interface descendant, but the\n-            --  partial view does not share the same tagged type.\n+               --  The full view derives from an interface descendant, but the\n+               --  partial view does not share the same tagged type.\n \n-            if Present (Iface)\n-              and then Is_Tagged_Type (Priv_T)\n-              and then Etype (Full_T) /= Etype (Priv_T)\n-            then\n-               Error_Msg_N (\"(Ada 2005) tagged partial view cannot be \" &\n-                            \"completed by a type that implements an \" &\n-                            \"interface\", Priv_T);\n-            end if;\n+               if Is_Tagged_Type (Priv_T)\n+                 and then Etype (Priv_T) /= Etype (Full_T)\n+                 and then Etype (Priv_T) /= Iface\n+               then\n+                  Error_Msg_N (\"(Ada 2005) tagged partial view cannot be \" &\n+                               \"completed by a type that implements an \" &\n+                               \"interface\", Priv_T);\n+               end if;\n \n-            --  The full view derives from a limited, protected,\n-            --  synchronized or task interface descendant, but the\n-            --  partial view is not labeled as limited.\n+               --  The full view derives from a limited, protected,\n+               --  synchronized or task interface descendant, but the\n+               --  partial view is not labeled as limited.\n \n-            if Present (Iface)\n-              and then (Limited_Present      (Iface_Def)\n-                     or Protected_Present    (Iface_Def)\n-                     or Synchronized_Present (Iface_Def)\n-                     or Task_Present         (Iface_Def))\n-              and then not Limited_Present (Parent (Priv_T))\n-            then\n-               Error_Msg_N (\"(Ada 2005) non-limited private type cannot be \" &\n-                            \"completed by a limited type\", Priv_T);\n+               if (Limited_Present               (Iface_Def)\n+                    or else Protected_Present    (Iface_Def)\n+                    or else Synchronized_Present (Iface_Def)\n+                    or else Task_Present         (Iface_Def))\n+                 and then not Limited_Present (Parent (Priv_T))\n+               then\n+                  Error_Msg_N (\"(Ada 2005) non-limited private type cannot be \"\n+                               & \"completed by a limited type\", Priv_T);\n+               end if;\n             end if;\n          end;\n       end if;\n@@ -13242,24 +13329,9 @@ package body Sem_Ch3 is\n             return;\n \n          elsif not Is_Ancestor (Base_Type (Priv_Parent), Full_Parent) then\n-\n-            --  Ada 2005 (AI-251): No error needed if the immediate\n-            --  ancestor of the partial view is an interface\n-            --\n-            --  Example:\n-            --\n-            --       type PT1 is new I1 with private;\n-            --    private\n-            --       type PT1 is new T and I1 with null record;\n-\n-            if Is_Interface (Base_Type (Priv_Parent)) then\n-               null;\n-\n-            else\n-               Error_Msg_N\n-                 (\"parent of full type must descend from parent\"\n-                     & \" of private extension\", Full_Indic);\n-            end if;\n+            Error_Msg_N\n+              (\"parent of full type must descend from parent\"\n+                  & \" of private extension\", Full_Indic);\n \n          --  Check the rules of 7.3(10): if the private extension inherits\n          --  known discriminants, then the full type must also inherit those\n@@ -14409,17 +14481,7 @@ package body Sem_Ch3 is\n \n       else\n          Is_Tagged := True;\n-         Set_Is_Tagged_Type      (T);\n-\n-         Set_Is_Limited_Record   (T, Limited_Present (Def)\n-                                      or else Task_Present (Def)\n-                                      or else Protected_Present (Def));\n-\n-         --  Type is abstract if full declaration carries keyword, or if\n-         --  previous partial view did.\n-\n-         Set_Is_Abstract  (T);\n-         Set_Is_Interface (T);\n+         Analyze_Interface_Declaration (T, Def);\n       end if;\n \n       --  First pass: if there are self-referential access components,\n@@ -14428,17 +14490,14 @@ package body Sem_Ch3 is\n \n       Check_Anonymous_Access_Types (Component_List (Def));\n \n-      --  Ada 2005 (AI-251): Complete the initialization of attributes\n-      --  associated with abstract interfaces and decorate the names in the\n-      --  list of ancestor interfaces (if any).\n-\n       if Ada_Version >= Ada_05\n         and then Present (Interface_List (Def))\n       then\n          declare\n             Iface     : Node_Id;\n             Iface_Def : Node_Id;\n             Iface_Typ : Entity_Id;\n+\n          begin\n             Iface := First (Interface_List (Def));\n             while Present (Iface) loop\n@@ -14521,9 +14580,8 @@ package body Sem_Ch3 is\n \n                Next (Iface);\n             end loop;\n-\n             Set_Abstract_Interfaces (T, New_Elmt_List);\n-            Collect_Interfaces (Type_Definition (N), T);\n+            Collect_Interfaces (Def, T);\n          end;\n       end if;\n "}, {"sha": "95354d60b278f8ee3db35c6ebe726b1606396185", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/950d3e7dae82649e89b09b4b471914a061bad5b9/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/950d3e7dae82649e89b09b4b471914a061bad5b9/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=950d3e7dae82649e89b09b4b471914a061bad5b9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,6 +62,9 @@ package Sem_Ch3  is\n    --  Called to analyze a list of declarations (in what context ???). Also\n    --  performs necessary freezing actions (more description needed ???)\n \n+   procedure Analyze_Interface_Declaration (T : Entity_Id; Def : Node_Id);\n+   --  Analyze an interface declaration or a formal interface declaration\n+\n    procedure Analyze_Per_Use_Expression (N : Node_Id; T : Entity_Id);\n    --  Default and per object expressions do not freeze their components,\n    --  and must be analyzed and resolved accordingly. The analysis is\n@@ -97,6 +100,15 @@ package Sem_Ch3  is\n    --  rather than on the declarations that require completion in the package\n    --  declaration.\n \n+   procedure Collect_Interfaces\n+     (N            : Node_Id;\n+      Derived_Type : Entity_Id);\n+   --  Ada 2005 (AI-251): Subsidiary procedure to Build_Derived_Record_Type\n+   --  and Analyze_Formal_Interface_Type.\n+   --  Collect the list of interfaces that are not already implemented by the\n+   --  ancestors. This is the list of interfaces for which we must provide\n+   --  additional tag components.\n+\n    procedure Derive_Subprogram\n      (New_Subp     : in out Entity_Id;\n       Parent_Subp  : Entity_Id;\n@@ -114,8 +126,7 @@ package Sem_Ch3  is\n      (Parent_Type           : Entity_Id;\n       Derived_Type          : Entity_Id;\n       Generic_Actual        : Entity_Id := Empty;\n-      No_Predefined_Prims   : Boolean   := False;\n-      Predefined_Prims_Only : Boolean   := False);\n+      No_Predefined_Prims   : Boolean   := False);\n    --  To complete type derivation, collect/retrieve the primitive operations\n    --  of the parent type, and replace the subsidiary subtypes with the derived\n    --  type, to build the specs of the inherited ops. For generic actuals, the\n@@ -124,9 +135,7 @@ package Sem_Ch3  is\n    --  the derived subprograms are aliased to those of the actual, not those of\n    --  the ancestor. The last two params are used in case of derivation from\n    --  abstract interface types: No_Predefined_Prims is used to avoid the\n-   --  derivation of predefined primitives from the interface, and Predefined\n-   --  Prims_Only is used to complete the derivation predefined primitives\n-   --  in case of private tagged types implementing interfaces.\n+   --  derivation of predefined primitives from an abstract interface.\n    --\n    --  Note: one might expect this to be private to the package body, but\n    --  there is one rather unusual usage in package Exp_Dist."}]}