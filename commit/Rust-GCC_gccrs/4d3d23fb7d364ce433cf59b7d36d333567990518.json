{"sha": "4d3d23fb7d364ce433cf59b7d36d333567990518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQzZDIzZmI3ZDM2NGNlNDMzY2Y1OWI3ZDM2ZDMzMzU2Nzk5MDUxOA==", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.vnet.ibm.com", "date": "2017-05-30T11:02:14Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-05-30T11:02:14Z"}, "message": "Vector peeling cost model 6/6\n\ngcc/ChangeLog:\n\n2017-05-24  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n\n\t* tree-vect-data-refs.c (vect_get_peeling_costs_all_drs):\n\tIntroduce unknown_misalignment parameter and remove vf.\n\t(vect_peeling_hash_get_lowest_cost):\n\tPass unknown_misalignment parameter.\n\t(vect_enhance_data_refs_alignment):\n\tFix unsupportable data ref treatment.\n\nFrom-SVN: r248680", "tree": {"sha": "6c6e7e683d779b7801758293fdfd105f9bab2d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c6e7e683d779b7801758293fdfd105f9bab2d4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d3d23fb7d364ce433cf59b7d36d333567990518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3d23fb7d364ce433cf59b7d36d333567990518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d3d23fb7d364ce433cf59b7d36d333567990518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3d23fb7d364ce433cf59b7d36d333567990518/comments", "author": {"login": "rdapp1", "id": 22046046, "node_id": "MDQ6VXNlcjIyMDQ2MDQ2", "avatar_url": "https://avatars.githubusercontent.com/u/22046046?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp1", "html_url": "https://github.com/rdapp1", "followers_url": "https://api.github.com/users/rdapp1/followers", "following_url": "https://api.github.com/users/rdapp1/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp1/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp1/subscriptions", "organizations_url": "https://api.github.com/users/rdapp1/orgs", "repos_url": "https://api.github.com/users/rdapp1/repos", "events_url": "https://api.github.com/users/rdapp1/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4bfb347c0249384240209d0f414eaef5ac5adc48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bfb347c0249384240209d0f414eaef5ac5adc48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bfb347c0249384240209d0f414eaef5ac5adc48"}], "stats": {"total": 122, "additions": 80, "deletions": 42}, "files": [{"sha": "433c15a486465b49f292bc527ad7a3c7d04d1f5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3d23fb7d364ce433cf59b7d36d333567990518/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3d23fb7d364ce433cf59b7d36d333567990518/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d3d23fb7d364ce433cf59b7d36d333567990518", "patch": "@@ -1,3 +1,12 @@\n+2017-05-24  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n+\n+\t* tree-vect-data-refs.c (vect_get_peeling_costs_all_drs):\n+\tIntroduce unknown_misalignment parameter and remove vf.\n+\t(vect_peeling_hash_get_lowest_cost):\n+\tPass unknown_misalignment parameter.\n+\t(vect_enhance_data_refs_alignment):\n+\tFix unsupportable data ref treatment.\n+\n 2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n \n \t* tree-vect-data-refs.c (vect_get_data_access_cost):"}, {"sha": "5103ba1e6f295dfbfbd6806ef56e6adc0682fff7", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 71, "deletions": 42, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3d23fb7d364ce433cf59b7d36d333567990518/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3d23fb7d364ce433cf59b7d36d333567990518/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=4d3d23fb7d364ce433cf59b7d36d333567990518", "patch": "@@ -1239,14 +1239,16 @@ vect_peeling_hash_get_most_frequent (_vect_peel_info **slot,\n }\n \n /* Get the costs of peeling NPEEL iterations checking data access costs\n-   for all data refs. */\n+   for all data refs.  If UNKNOWN_MISALIGNMENT is true, we assume DR0's\n+   misalignment will be zero after peeling.  */\n \n static void\n vect_get_peeling_costs_all_drs (struct data_reference *dr0,\n \t\t\t\tunsigned int *inside_cost,\n \t\t\t\tunsigned int *outside_cost,\n \t\t\t\tstmt_vector_for_cost *body_cost_vec,\n-\t\t\t\tunsigned int npeel, unsigned int vf)\n+\t\t\t\tunsigned int npeel,\n+\t\t\t\tbool unknown_misalignment)\n {\n   gimple *stmt = DR_STMT (dr0);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -1274,7 +1276,7 @@ vect_get_peeling_costs_all_drs (struct data_reference *dr0,\n \n       int save_misalignment;\n       save_misalignment = DR_MISALIGNMENT (dr);\n-      if (dr == dr0 && npeel == vf / 2)\n+      if (unknown_misalignment && dr == dr0)\n \tSET_DR_MISALIGNMENT (dr, 0);\n       else\n \tvect_update_misalignment_for_peel (dr, dr0, npeel);\n@@ -1305,7 +1307,7 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n   epilogue_cost_vec.create (2);\n \n   vect_get_peeling_costs_all_drs (elem->dr, &inside_cost, &outside_cost,\n-\t\t\t\t  &body_cost_vec, elem->npeel, 0);\n+\t\t\t\t  &body_cost_vec, elem->npeel, false);\n \n   outside_cost += vect_get_known_peeling_cost\n     (loop_vinfo, elem->npeel, &dummy,\n@@ -1517,6 +1519,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  enum dr_alignment_support supportable_dr_alignment;\n   struct data_reference *dr0 = NULL, *first_store = NULL;\n   struct data_reference *dr;\n   unsigned int i, j;\n@@ -1528,6 +1531,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   unsigned int npeel = 0;\n   bool one_misalignment_known = false;\n   bool one_misalignment_unknown = false;\n+  bool one_dr_unsupportable = false;\n+  struct data_reference *unsupportable_dr = NULL;\n   unsigned int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   unsigned possible_npeel_number = 1;\n   tree vectype;\n@@ -1599,6 +1604,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \tcontinue;\n \n+      supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n       do_peeling = vector_alignment_reachable_p (dr);\n       if (do_peeling)\n         {\n@@ -1637,8 +1643,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t  else\n \t\t    possible_npeel_number = vf / nelements;\n \n-\t\t  /* NPEEL_TMP is 0 when there is no misalignment, increment\n-\t\t     the peeling amount by one in order to ...  */\n+\t\t  /* NPEEL_TMP is 0 when there is no misalignment, but also\n+\t\t     allow peeling NELEMENTS.  */\n \t\t  if (DR_MISALIGNMENT (dr) == 0)\n \t\t    possible_npeel_number++;\n \t\t}\n@@ -1684,10 +1690,18 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t    dr0 = dr;\n \t\t}\n \n+\t      one_misalignment_unknown = true;\n+\n+\t      /* Check for data refs with unsupportable alignment that\n+\t         can be peeled.  */\n+\t      if (!supportable_dr_alignment)\n+\t      {\n+\t\tone_dr_unsupportable = true;\n+\t\tunsupportable_dr = dr;\n+\t      }\n+\n \t      if (!first_store && DR_IS_WRITE (dr))\n \t\tfirst_store = dr;\n-\n-\t      one_misalignment_unknown = true;\n             }\n         }\n       else\n@@ -1732,7 +1746,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       vect_get_peeling_costs_all_drs (dr0,\n \t\t\t\t      &load_inside_cost,\n \t\t\t\t      &load_outside_cost,\n-\t\t\t\t      &dummy, vf / 2, vf);\n+\t\t\t\t      &dummy, vf / 2, true);\n       dummy.release ();\n \n       if (first_store)\n@@ -1741,7 +1755,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  vect_get_peeling_costs_all_drs (first_store,\n \t\t\t\t\t  &store_inside_cost,\n \t\t\t\t\t  &store_outside_cost,\n-\t\t\t\t\t  &dummy, vf / 2, vf);\n+\t\t\t\t\t  &dummy, vf / 2, true);\n \t  dummy.release ();\n \t}\n       else\n@@ -1805,43 +1819,59 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   if (peel_for_known_alignment.peel_info.dr != NULL\n       && peel_for_unknown_alignment.inside_cost\n       >= peel_for_known_alignment.inside_cost)\n-    best_peel = peel_for_known_alignment;\n+    {\n+      best_peel = peel_for_known_alignment;\n \n-  /* Calculate the penalty for no peeling, i.e. leaving everything\n-     unaligned.\n-     TODO: use something like an adapted vect_get_peeling_costs_all_drs.  */\n-  unsigned nopeel_inside_cost = 0;\n-  unsigned nopeel_outside_cost = 0;\n+      /* If the best peeling for known alignment has NPEEL == 0, perform no\n+         peeling at all except if there is an unsupportable dr that we can\n+         align.  */\n+      if (best_peel.peel_info.npeel == 0 && !one_dr_unsupportable)\n+\tdo_peeling = false;\n+    }\n \n-  stmt_vector_for_cost dummy;\n-  dummy.create (2);\n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n-    vect_get_data_access_cost (dr, &nopeel_inside_cost,\n-\t\t\t       &nopeel_outside_cost, &dummy);\n-  dummy.release ();\n+  /* If there is an unsupportable data ref, prefer this over all choices so far\n+     since we'd have to discard a chosen peeling except when it accidentally\n+     aligned the unsupportable data ref.  */\n+  if (one_dr_unsupportable)\n+    dr0 = unsupportable_dr;\n+  else if (do_peeling)\n+    {\n+      /* Calculate the penalty for no peeling, i.e. leaving everything\n+\t unaligned.\n+\t TODO: Adapt vect_get_peeling_costs_all_drs and use here.  */\n+      unsigned nopeel_inside_cost = 0;\n+      unsigned nopeel_outside_cost = 0;\n \n-  /* Add epilogue costs.  As we do not peel for alignment here, no prologue\n-     costs will be recorded.  */\n-  stmt_vector_for_cost prologue_cost_vec, epilogue_cost_vec;\n-  prologue_cost_vec.create (2);\n-  epilogue_cost_vec.create (2);\n+      stmt_vector_for_cost dummy;\n+      dummy.create (2);\n+      FOR_EACH_VEC_ELT (datarefs, i, dr)\n+\tvect_get_data_access_cost (dr, &nopeel_inside_cost,\n+\t\t\t\t   &nopeel_outside_cost, &dummy);\n+      dummy.release ();\n \n-  int dummy2;\n-  nopeel_outside_cost += vect_get_known_peeling_cost\n-    (loop_vinfo, 0, &dummy2,\n-     &LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n-     &prologue_cost_vec, &epilogue_cost_vec);\n+      /* Add epilogue costs.  As we do not peel for alignment here, no prologue\n+\t costs will be recorded.  */\n+      stmt_vector_for_cost prologue_cost_vec, epilogue_cost_vec;\n+      prologue_cost_vec.create (2);\n+      epilogue_cost_vec.create (2);\n \n-  prologue_cost_vec.release ();\n-  epilogue_cost_vec.release ();\n+      int dummy2;\n+      nopeel_outside_cost += vect_get_known_peeling_cost\n+\t(loop_vinfo, 0, &dummy2,\n+\t &LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n+\t &prologue_cost_vec, &epilogue_cost_vec);\n+\n+      prologue_cost_vec.release ();\n+      epilogue_cost_vec.release ();\n \n-  npeel = best_peel.peel_info.npeel;\n-  dr0 = best_peel.peel_info.dr;\n+      npeel = best_peel.peel_info.npeel;\n+      dr0 = best_peel.peel_info.dr;\n \n-  /* If no peeling is not more expensive than the best peeling we\n-     have so far, don't perform any peeling.  */\n-  if (nopeel_inside_cost <= best_peel.inside_cost)\n-    do_peeling = false;\n+      /* If no peeling is not more expensive than the best peeling we\n+\t have so far, don't perform any peeling.  */\n+      if (nopeel_inside_cost <= best_peel.inside_cost)\n+\tdo_peeling = false;\n+    }\n \n   if (do_peeling)\n     {\n@@ -2019,8 +2049,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      break;\n \t    }\n \n-\t  enum dr_alignment_support supportable_dr_alignment =\n-\t    vect_supportable_dr_alignment (dr, false);\n+\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n \n           if (!supportable_dr_alignment)\n             {"}]}