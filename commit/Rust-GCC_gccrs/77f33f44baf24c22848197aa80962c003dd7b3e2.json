{"sha": "77f33f44baf24c22848197aa80962c003dd7b3e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdmMzNmNDRiYWYyNGMyMjg0ODE5N2FhODA5NjJjMDAzZGQ3YjNlMg==", "commit": {"author": {"name": "Richard Henderson", "email": "richard.henderson@linaro.org", "date": "2018-10-31T09:29:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2018-10-31T09:29:29Z"}, "message": "aarch64: Simplify LSE cas generation\n\nThe cas insn is a single insn, and if expanded properly need not\nbe split after reload.  Use the proper inputs for the insn.\n\n\t* config/aarch64/aarch64.c (aarch64_expand_compare_and_swap):\n\tForce oldval into the rval register for TARGET_LSE; emit the compare\n\tduring initial expansion so that it may be deleted if unused.\n\t(aarch64_gen_atomic_cas): Remove.\n\t* config/aarch64/atomics.md (@aarch64_compare_and_swap<SHORT>_lse):\n\tChange =&r to +r for operand 0; use match_dup for operand 2;\n\tremove is_weak and mod_f operands as unused.  Drop the split\n\tand merge with...\n\t(@aarch64_atomic_cas<SHORT>): ... this pattern's output; remove.\n\t(@aarch64_compare_and_swap<GPI>_lse): Similarly.\n\t(@aarch64_atomic_cas<GPI>): Similarly.\n\nFrom-SVN: r265656", "tree": {"sha": "a1fc76d6ee8e85ab16d6ba4a95070461a6e27c8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1fc76d6ee8e85ab16d6ba4a95070461a6e27c8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77f33f44baf24c22848197aa80962c003dd7b3e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f33f44baf24c22848197aa80962c003dd7b3e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77f33f44baf24c22848197aa80962c003dd7b3e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f33f44baf24c22848197aa80962c003dd7b3e2/comments", "author": {"login": "rth7680", "id": 2529319, "node_id": "MDQ6VXNlcjI1MjkzMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2529319?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rth7680", "html_url": "https://github.com/rth7680", "followers_url": "https://api.github.com/users/rth7680/followers", "following_url": "https://api.github.com/users/rth7680/following{/other_user}", "gists_url": "https://api.github.com/users/rth7680/gists{/gist_id}", "starred_url": "https://api.github.com/users/rth7680/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rth7680/subscriptions", "organizations_url": "https://api.github.com/users/rth7680/orgs", "repos_url": "https://api.github.com/users/rth7680/repos", "events_url": "https://api.github.com/users/rth7680/events{/privacy}", "received_events_url": "https://api.github.com/users/rth7680/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "187cea947e54d08eaed2587edeb49a5cc1fe8d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187cea947e54d08eaed2587edeb49a5cc1fe8d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187cea947e54d08eaed2587edeb49a5cc1fe8d6a"}], "stats": {"total": 182, "additions": 63, "deletions": 119}, "files": [{"sha": "3c764c56f4e89378115235284305bae07bc85a45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f33f44baf24c22848197aa80962c003dd7b3e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f33f44baf24c22848197aa80962c003dd7b3e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77f33f44baf24c22848197aa80962c003dd7b3e2", "patch": "@@ -1,3 +1,17 @@\n+2018-10-31  Richard Henderson  <richard.henderson@linaro.org>\n+\n+\t* config/aarch64/aarch64.c (aarch64_expand_compare_and_swap):\n+\tForce oldval into the rval register for TARGET_LSE; emit the compare\n+\tduring initial expansion so that it may be deleted if unused.\n+\t(aarch64_gen_atomic_cas): Remove.\n+\t* config/aarch64/atomics.md (@aarch64_compare_and_swap<SHORT>_lse):\n+\tChange =&r to +r for operand 0; use match_dup for operand 2;\n+\tremove is_weak and mod_f operands as unused.  Drop the split\n+\tand merge with...\n+\t(@aarch64_atomic_cas<SHORT>): ... this pattern's output; remove.\n+\t(@aarch64_compare_and_swap<GPI>_lse): Similarly.\n+\t(@aarch64_atomic_cas<GPI>): Similarly.\n+\n 2018-10-31  Richard Biener  <rguenther@suse.de>\n \n \t* tree-eh.c (replace_trapping_overflow): Simplify ABS_EXPR case"}, {"sha": "f662533c1088190eab32e97b8fca9b4978362863", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f33f44baf24c22848197aa80962c003dd7b3e2/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f33f44baf24c22848197aa80962c003dd7b3e2/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=77f33f44baf24c22848197aa80962c003dd7b3e2", "patch": "@@ -563,7 +563,6 @@ rtx aarch64_load_tp (rtx);\n \n void aarch64_expand_compare_and_swap (rtx op[]);\n void aarch64_split_compare_and_swap (rtx op[]);\n-void aarch64_gen_atomic_cas (rtx, rtx, rtx, rtx, rtx);\n \n bool aarch64_atomic_ldop_supported_p (enum rtx_code);\n void aarch64_gen_atomic_ldop (enum rtx_code, rtx, rtx, rtx, rtx, rtx);"}, {"sha": "9d53cf97b4cd9f58ffa87eb2d3fdeb66468c1715", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f33f44baf24c22848197aa80962c003dd7b3e2/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f33f44baf24c22848197aa80962c003dd7b3e2/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=77f33f44baf24c22848197aa80962c003dd7b3e2", "patch": "@@ -14620,16 +14620,27 @@ aarch64_expand_compare_and_swap (rtx operands[])\n     }\n \n   if (TARGET_LSE)\n-    emit_insn (gen_aarch64_compare_and_swap_lse (mode, rval, mem, oldval,\n-\t\t\t\t\t\t newval, is_weak, mod_s,\n-\t\t\t\t\t\t mod_f));\n+    {\n+      /* The CAS insn requires oldval and rval overlap, but we need to\n+\t have a copy of oldval saved across the operation to tell if\n+\t the operation is successful.  */\n+      if (mode == QImode || mode == HImode)\n+\trval = copy_to_mode_reg (SImode, gen_lowpart (SImode, oldval));\n+      else if (reg_overlap_mentioned_p (rval, oldval))\n+        rval = copy_to_mode_reg (mode, oldval);\n+      else\n+\temit_move_insn (rval, oldval);\n+      emit_insn (gen_aarch64_compare_and_swap_lse (mode, rval, mem,\n+\t\t\t\t\t\t   newval, mod_s));\n+      aarch64_gen_compare_reg (EQ, rval, oldval);\n+    }\n   else\n     emit_insn (gen_aarch64_compare_and_swap (mode, rval, mem, oldval, newval,\n \t\t\t\t\t     is_weak, mod_s, mod_f));\n \n-\n   if (mode == QImode || mode == HImode)\n-    emit_move_insn (operands[1], gen_lowpart (mode, rval));\n+    rval = gen_lowpart (mode, rval);\n+  emit_move_insn (operands[1], rval);\n \n   x = gen_rtx_REG (CCmode, CC_REGNUM);\n   x = gen_rtx_EQ (SImode, x, const0_rtx);\n@@ -14679,31 +14690,6 @@ aarch64_emit_post_barrier (enum memmodel model)\n     }\n }\n \n-/* Emit an atomic compare-and-swap operation.  RVAL is the destination register\n-   for the data in memory.  EXPECTED is the value expected to be in memory.\n-   DESIRED is the value to store to memory.  MEM is the memory location.  MODEL\n-   is the memory ordering to use.  */\n-\n-void\n-aarch64_gen_atomic_cas (rtx rval, rtx mem,\n-\t\t\trtx expected, rtx desired,\n-\t\t\trtx model)\n-{\n-  machine_mode mode;\n-\n-  mode = GET_MODE (mem);\n-\n-  /* Move the expected value into the CAS destination register.  */\n-  emit_insn (gen_rtx_SET (rval, expected));\n-\n-  /* Emit the CAS.  */\n-  emit_insn (gen_aarch64_atomic_cas (mode, rval, mem, desired, model));\n-\n-  /* Compare the expected value with the value loaded by the CAS, to establish\n-     whether the swap was made.  */\n-  aarch64_gen_compare_reg (EQ, rval, expected);\n-}\n-\n /* Split a compare and swap pattern.  */\n \n void"}, {"sha": "22660850af16fc40d7745bf253388a6b7e5ea157", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 33, "deletions": 88, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77f33f44baf24c22848197aa80962c003dd7b3e2/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77f33f44baf24c22848197aa80962c003dd7b3e2/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=77f33f44baf24c22848197aa80962c003dd7b3e2", "patch": "@@ -85,56 +85,50 @@\n   }\n )\n \n-(define_insn_and_split \"@aarch64_compare_and_swap<mode>_lse\"\n-  [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n-    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n-   (set (match_operand:SI 0 \"register_operand\" \"=&r\")\t\t;; val out\n+(define_insn \"@aarch64_compare_and_swap<mode>_lse\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+r\")\t\t;; val out\n     (zero_extend:SI\n-      (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\"))) ;; memory\n+     (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\"))) ;; memory\n    (set (match_dup 1)\n     (unspec_volatile:SHORT\n-      [(match_operand:SI 2 \"aarch64_plus_operand\" \"rI\")\t;; expected\n-       (match_operand:SHORT 3 \"aarch64_reg_or_zero\" \"rZ\")\t;; desired\n-       (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n-       (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n-       (match_operand:SI 6 \"const_int_operand\")]\t;; mod_f\n+      [(match_dup 0)\t\t\t\t\t\t;; expected\n+       (match_operand:SHORT 2 \"aarch64_reg_or_zero\" \"rZ\")\t;; desired\n+       (match_operand:SI 3 \"const_int_operand\")]\t\t;; mod_s\n       UNSPECV_ATOMIC_CMPSW))]\n   \"TARGET_LSE\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  {\n-    aarch64_gen_atomic_cas (operands[0], operands[1],\n-\t\t\t    operands[2], operands[3],\n-\t\t\t    operands[5]);\n-    DONE;\n-  }\n-)\n+{\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+  if (is_mm_relaxed (model))\n+    return \"cas<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else if (is_mm_acquire (model) || is_mm_consume (model))\n+    return \"casa<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else if (is_mm_release (model))\n+    return \"casl<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else\n+    return \"casal<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+})\n \n-(define_insn_and_split \"@aarch64_compare_and_swap<mode>_lse\"\n-  [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n-    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n-   (set (match_operand:GPI 0 \"register_operand\" \"=&r\")\t\t;; val out\n+(define_insn \"@aarch64_compare_and_swap<mode>_lse\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"+r\")\t\t;; val out\n     (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\"))   ;; memory\n    (set (match_dup 1)\n     (unspec_volatile:GPI\n-      [(match_operand:GPI 2 \"aarch64_plus_operand\" \"rI\")\t;; expect\n-       (match_operand:GPI 3 \"aarch64_reg_or_zero\" \"rZ\")\t\t;; desired\n-       (match_operand:SI 4 \"const_int_operand\")\t\t\t;; is_weak\n-       (match_operand:SI 5 \"const_int_operand\")\t\t\t;; mod_s\n-       (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n+      [(match_dup 0)\t\t\t\t\t\t;; expected\n+       (match_operand:GPI 2 \"aarch64_reg_or_zero\" \"rZ\")\t\t;; desired\n+       (match_operand:SI 3 \"const_int_operand\")]\t\t;; mod_s\n       UNSPECV_ATOMIC_CMPSW))]\n   \"TARGET_LSE\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  {\n-    aarch64_gen_atomic_cas (operands[0], operands[1],\n-\t\t\t    operands[2], operands[3],\n-\t\t\t    operands[5]);\n-    DONE;\n-  }\n-)\n+{\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+  if (is_mm_relaxed (model))\n+    return \"cas<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else if (is_mm_acquire (model) || is_mm_consume (model))\n+    return \"casa<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else if (is_mm_release (model))\n+    return \"casl<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+  else\n+    return \"casal<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n+})\n \n (define_expand \"atomic_exchange<mode>\"\n  [(match_operand:ALLI 0 \"register_operand\" \"\")\n@@ -610,55 +604,6 @@\n       return \"swpal<atomic_sfx>\\t%<w>2, %<w>0, %1\";\n   })\n \n-;; Atomic compare-and-swap: HI and smaller modes.\n-\n-(define_insn \"@aarch64_atomic_cas<mode>\"\n- [(set (match_operand:SI 0 \"register_operand\" \"+&r\")\t\t  ;; out\n-   (zero_extend:SI\n-    (match_operand:SHORT 1 \"aarch64_sync_memory_operand\" \"+Q\")))  ;; memory.\n-  (set (match_dup 1)\n-   (unspec_volatile:SHORT\n-    [(match_dup 0)\n-     (match_operand:SHORT 2 \"aarch64_reg_or_zero\" \"rZ\")\t;; value.\n-     (match_operand:SI 3 \"const_int_operand\" \"\")]\t;; model.\n-    UNSPECV_ATOMIC_CAS))]\n- \"TARGET_LSE && reload_completed\"\n-{\n-  enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n-  if (is_mm_relaxed (model))\n-    return \"cas<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n-  else if (is_mm_acquire (model) || is_mm_consume (model))\n-    return \"casa<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n-  else if (is_mm_release (model))\n-    return \"casl<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n-  else\n-    return \"casal<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n-})\n-\n-;; Atomic compare-and-swap: SI and larger modes.\n-\n-(define_insn \"@aarch64_atomic_cas<mode>\"\n- [(set (match_operand:GPI 0 \"register_operand\" \"+&r\")\t      ;; out\n-   (match_operand:GPI 1 \"aarch64_sync_memory_operand\" \"+Q\"))  ;; memory.\n-  (set (match_dup 1)\n-   (unspec_volatile:GPI\n-    [(match_dup 0)\n-     (match_operand:GPI 2 \"aarch64_reg_or_zero\" \"rZ\")\t;; value.\n-     (match_operand:SI 3 \"const_int_operand\" \"\")]\t;; model.\n-    UNSPECV_ATOMIC_CAS))]\n-  \"TARGET_LSE && reload_completed\"\n-{\n-    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n-    if (is_mm_relaxed (model))\n-      return \"cas<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n-    else if (is_mm_acquire (model) || is_mm_consume (model))\n-      return \"casa<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n-    else if (is_mm_release (model))\n-      return \"casl<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n-    else\n-      return \"casal<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n-})\n-\n ;; Atomic load-op: Load data, operate, store result, keep data.\n \n (define_insn \"@aarch64_atomic_load<atomic_ldop><mode>\""}]}