{"sha": "3c6331c29f1376ed220246e7dead94bc527a9aa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M2MzMxYzI5ZjEzNzZlZDIyMDI0NmU3ZGVhZDk0YmM1MjdhOWFhOQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-06-01T19:15:18Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-06-02T06:02:07Z"}, "message": "Libsanitizer: merge from master.\n\nMerged from revision b638b63b99d66786cb37336292604a2ae3490cfd.\n\nThe patch successfully bootstraps on x86_64-linux-gnu and\nppc64le-linux-gnu. I also tested ppc64-linux-gnu that exposed:\nhttps://reviews.llvm.org/D80864 (which is fixed on master).\n\nAbidiff looks happy and I made UBSAN and ASAN bootstrap on\nx86_64-linux-gnu.\n\nI'm planning to do merge from master twice a year, once now and\nnext time short before stage1 closes.\n\nI am going to install the patches as merge from master is obvious\nand I haven't made anything special.\n\nlibsanitizer/ChangeLog:\n\n\t* MERGE: Merge from master.", "tree": {"sha": "df4288713dd999fd2b0783cf0f82a7a127ed5964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df4288713dd999fd2b0783cf0f82a7a127ed5964"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c6331c29f1376ed220246e7dead94bc527a9aa9", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEE6I4wzqqylQBfXaRhTcGC3A+nN4UFAl7V618ACgkQTcGC3A+n\nN4U7UAf8CUKGpu4ZvRnOYCdxhXZO9kFQqR80MMVPts8n4lE0FAA5QhH2FsxEMJ/F\nrGNH0icy6eyuX03g7qhXZFH5U78Zm9gqZ4IWcXEnZ7Z1x8t8467Mv8Tz+SbwKn+7\npA1T+piPKWrM28GLcKNJu/VQqmFjIoOehphEUvF+UVbOGh07Kqafn7Hqk2/o1NYQ\nPGy+6kWW+lkTACkMHaSWPfDRoEtC9MgeZ6JFCFknbiZ9g8urZOba4pV4aw5xt7+Q\ns/8isBkqfSEOB97oxqbt2F0ebegSdPc4GJz++SZMen4v7bA5eW/RRR22NQTQNSq8\n3BZ5gTv62qU0LDj3b75JcUX5AOslKg==\n=gHxN\n-----END PGP SIGNATURE-----", "payload": "tree df4288713dd999fd2b0783cf0f82a7a127ed5964\nparent 2b11374cb8d864dff3792e7c84188ba7e8f136e7\nauthor Martin Liska <mliska@suse.cz> 1591038918 +0200\ncommitter Martin Liska <mliska@suse.cz> 1591077727 +0200\n\nLibsanitizer: merge from master.\n\nMerged from revision b638b63b99d66786cb37336292604a2ae3490cfd.\n\nThe patch successfully bootstraps on x86_64-linux-gnu and\nppc64le-linux-gnu. I also tested ppc64-linux-gnu that exposed:\nhttps://reviews.llvm.org/D80864 (which is fixed on master).\n\nAbidiff looks happy and I made UBSAN and ASAN bootstrap on\nx86_64-linux-gnu.\n\nI'm planning to do merge from master twice a year, once now and\nnext time short before stage1 closes.\n\nI am going to install the patches as merge from master is obvious\nand I haven't made anything special.\n\nlibsanitizer/ChangeLog:\n\n\t* MERGE: Merge from master.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c6331c29f1376ed220246e7dead94bc527a9aa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c6331c29f1376ed220246e7dead94bc527a9aa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c6331c29f1376ed220246e7dead94bc527a9aa9/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b11374cb8d864dff3792e7c84188ba7e8f136e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b11374cb8d864dff3792e7c84188ba7e8f136e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b11374cb8d864dff3792e7c84188ba7e8f136e7"}], "stats": {"total": 3321, "additions": 2551, "deletions": 770}, "files": [{"sha": "e14e830ea7de88d38d915f9b9472499c4d0a5522", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -1,4 +1,4 @@\n-82588e05cc32bb30807e480abd4e689b0dee132a\n+b638b63b99d66786cb37336292604a2ae3490cfd\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "9d7dbc6f264cea7b80a71a91da37cfa0cfbbd0db", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -154,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -199,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);"}, {"sha": "344a64bd83d330553bca41f066b004092b6632df", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -80,12 +80,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else"}, {"sha": "41fb49ee46d460774a487c638b2c58531b8ac8d0", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -163,7 +163,7 @@ static const u64 kDefaultShort64bitShadowOffset =\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kSPARC64_ShadowOffset64 = 1ULL << 43;  // 0x80000000000\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000"}, {"sha": "99e8678aa78575adc11e4dcc80fc0331799de609", "filename": "libsanitizer/asan/asan_report.cpp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -160,6 +160,9 @@ class ScopedInErrorReport {\n       BlockingMutexLock l(&error_message_buf_mutex);\n       internal_memcpy(buffer_copy.data(),\n                       error_message_buffer, kErrorMessageBufferSize);\n+      // Clear error_message_buffer so that if we find other errors\n+      // we don't re-log this error.\n+      error_message_buffer_pos = 0;\n     }\n \n     LogFullErrorReport(buffer_copy.data());"}, {"sha": "f0df8bd4b374dd3bac528af5b121f14b2bdf5d33", "filename": "libsanitizer/asan/asan_thread.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fasan%2Fasan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -480,6 +480,8 @@ bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n   return true;\n }\n \n+void GetAllThreadAllocatorCachesLocked(InternalMmapVector<uptr> *caches) {}\n+\n void ForEachExtraStackRange(tid_t os_id, RangeIteratorCallback callback,\n                             void *arg) {\n   __asan::AsanThread *t = __asan::GetAsanThreadByOsIDLocked(os_id);"}, {"sha": "56eae3d40f968f6bd5f07e34c25856d9d0be3767", "filename": "libsanitizer/include/sanitizer/linux_syscall_hooks.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -1845,6 +1845,10 @@\n #define __sanitizer_syscall_post_rt_sigaction(res, signum, act, oldact, sz)    \\\n   __sanitizer_syscall_post_impl_rt_sigaction(res, (long)signum, (long)act,     \\\n                                              (long)oldact, (long)sz)\n+#define __sanitizer_syscall_pre_sigaltstack(ss, oss)                           \\\n+  __sanitizer_syscall_pre_impl_sigaltstack((long)ss, (long)oss)\n+#define __sanitizer_syscall_post_sigaltstack(res, ss, oss)                     \\\n+  __sanitizer_syscall_post_impl_sigaltstack(res, (long)ss, (long)oss)\n \n // And now a few syscalls we don't handle yet.\n #define __sanitizer_syscall_pre_afs_syscall(...)\n@@ -1912,7 +1916,6 @@\n #define __sanitizer_syscall_pre_setreuid32(...)\n #define __sanitizer_syscall_pre_set_thread_area(...)\n #define __sanitizer_syscall_pre_setuid32(...)\n-#define __sanitizer_syscall_pre_sigaltstack(...)\n #define __sanitizer_syscall_pre_sigreturn(...)\n #define __sanitizer_syscall_pre_sigsuspend(...)\n #define __sanitizer_syscall_pre_stty(...)\n@@ -1992,7 +1995,6 @@\n #define __sanitizer_syscall_post_setreuid32(res, ...)\n #define __sanitizer_syscall_post_set_thread_area(res, ...)\n #define __sanitizer_syscall_post_setuid32(res, ...)\n-#define __sanitizer_syscall_post_sigaltstack(res, ...)\n #define __sanitizer_syscall_post_sigreturn(res, ...)\n #define __sanitizer_syscall_post_sigsuspend(res, ...)\n #define __sanitizer_syscall_post_stty(res, ...)\n@@ -3075,6 +3077,8 @@ void __sanitizer_syscall_pre_impl_rt_sigaction(long signum, long act,\n                                                long oldact, long sz);\n void __sanitizer_syscall_post_impl_rt_sigaction(long res, long signum, long act,\n                                                 long oldact, long sz);\n+void __sanitizer_syscall_pre_impl_sigaltstack(long ss, long oss);\n+void __sanitizer_syscall_post_impl_sigaltstack(long res, long ss, long oss);\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "370da0ea72ed8b927371ee73c40bfc21d2c79540", "filename": "libsanitizer/include/sanitizer/netbsd_syscall_hooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -20,7 +20,7 @@\n // DO NOT EDIT! THIS FILE HAS BEEN GENERATED!\n //\n // Generated with: generate_netbsd_syscalls.awk\n-// Generated date: 2019-11-01\n+// Generated date: 2019-12-24\n // Generated from: syscalls.master,v 1.296 2019/09/22 22:59:39 christos Exp\n //\n //===----------------------------------------------------------------------===//"}, {"sha": "96b8ad58541cbb1c050dbf4f85dadbb3b44a98fe", "filename": "libsanitizer/include/sanitizer/tsan_interface.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -38,34 +38,34 @@ void __tsan_release(void *addr);\n \n // Mutex has static storage duration and no-op constructor and destructor.\n // This effectively makes tsan ignore destroy annotation.\n-const unsigned __tsan_mutex_linker_init      = 1 << 0;\n+static const unsigned __tsan_mutex_linker_init      = 1 << 0;\n // Mutex is write reentrant.\n-const unsigned __tsan_mutex_write_reentrant  = 1 << 1;\n+static const unsigned __tsan_mutex_write_reentrant  = 1 << 1;\n // Mutex is read reentrant.\n-const unsigned __tsan_mutex_read_reentrant   = 1 << 2;\n+static const unsigned __tsan_mutex_read_reentrant   = 1 << 2;\n // Mutex does not have static storage duration, and must not be used after\n // its destructor runs.  The opposite of __tsan_mutex_linker_init.\n // If this flag is passed to __tsan_mutex_destroy, then the destruction\n // is ignored unless this flag was previously set on the mutex.\n-const unsigned __tsan_mutex_not_static       = 1 << 8;\n+static const unsigned __tsan_mutex_not_static       = 1 << 8;\n \n // Mutex operation flags:\n \n // Denotes read lock operation.\n-const unsigned __tsan_mutex_read_lock        = 1 << 3;\n+static const unsigned __tsan_mutex_read_lock        = 1 << 3;\n // Denotes try lock operation.\n-const unsigned __tsan_mutex_try_lock         = 1 << 4;\n+static const unsigned __tsan_mutex_try_lock         = 1 << 4;\n // Denotes that a try lock operation has failed to acquire the mutex.\n-const unsigned __tsan_mutex_try_lock_failed  = 1 << 5;\n+static const unsigned __tsan_mutex_try_lock_failed  = 1 << 5;\n // Denotes that the lock operation acquires multiple recursion levels.\n // Number of levels is passed in recursion parameter.\n // This is useful for annotation of e.g. Java builtin monitors,\n // for which wait operation releases all recursive acquisitions of the mutex.\n-const unsigned __tsan_mutex_recursive_lock   = 1 << 6;\n+static const unsigned __tsan_mutex_recursive_lock   = 1 << 6;\n // Denotes that the unlock operation releases all recursion levels.\n // Number of released levels is returned and later must be passed to\n // the corresponding __tsan_mutex_post_lock annotation.\n-const unsigned __tsan_mutex_recursive_unlock = 1 << 7;\n+static const unsigned __tsan_mutex_recursive_unlock = 1 << 7;\n \n // Annotate creation of a mutex.\n // Supported flags: mutex creation flags.\n@@ -152,7 +152,7 @@ void __tsan_set_fiber_name(void *fiber, const char *name);\n \n // Flags for __tsan_switch_to_fiber:\n // Do not establish a happens-before relation between fibers\n-const unsigned __tsan_switch_to_fiber_no_sync = 1 << 0;\n+static const unsigned __tsan_switch_to_fiber_no_sync = 1 << 0;\n \n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "80a6e2fa70169d26dfc1ed5899732656a5c037c9", "filename": "libsanitizer/lsan/lsan.cpp", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -15,7 +15,6 @@\n \n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_flag_parser.h\"\n-#include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"lsan_allocator.h\"\n #include \"lsan_common.h\"\n #include \"lsan_thread.h\"\n@@ -87,17 +86,6 @@ static void InitializeFlags() {\n   __sanitizer_set_report_path(common_flags()->log_path);\n }\n \n-static void OnStackUnwind(const SignalContext &sig, const void *,\n-                          BufferedStackTrace *stack) {\n-  stack->Unwind(StackTrace::GetNextInstructionPc(sig.pc), sig.bp, sig.context,\n-                common_flags()->fast_unwind_on_fatal);\n-}\n-\n-static void LsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n-  HandleDeadlySignal(siginfo, context, GetCurrentThread(), &OnStackUnwind,\n-                     nullptr);\n-}\n-\n extern \"C\" void __lsan_init() {\n   CHECK(!lsan_init_is_running);\n   if (lsan_inited)\n@@ -114,10 +102,7 @@ extern \"C\" void __lsan_init() {\n   InitializeInterceptors();\n   InitializeThreadRegistry();\n   InstallDeadlySignalHandlers(LsanOnDeadlySignal);\n-  u32 tid = ThreadCreate(0, 0, true);\n-  CHECK_EQ(tid, 0);\n-  ThreadStart(tid, GetTid());\n-  SetCurrentThread(tid);\n+  InitializeMainThread();\n \n   if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit)\n     Atexit(DoLeakCheck);"}, {"sha": "1e82ad72f0058b2d2e73248b580c8d1b49c3945e", "filename": "libsanitizer/lsan/lsan.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -12,6 +12,11 @@\n //===----------------------------------------------------------------------===//\n \n #include \"lsan_thread.h\"\n+#if SANITIZER_POSIX\n+#include \"lsan_posix.h\"\n+#elif SANITIZER_FUCHSIA\n+#include \"lsan_fuchsia.h\"\n+#endif\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n \n@@ -33,6 +38,7 @@ namespace __lsan {\n \n void InitializeInterceptors();\n void ReplaceSystemMalloc();\n+void LsanOnDeadlySignal(int signo, void *siginfo, void *context);\n \n #define ENSURE_LSAN_INITED do {   \\\n   CHECK(!lsan_init_is_running);   \\"}, {"sha": "bda9d8cdf746dd46a643e1ea97873ee9a1a2c89e", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -66,7 +66,10 @@ template <typename AddressSpaceView>\n using PrimaryAllocatorASVT = SizeClassAllocator32<AP32<AddressSpaceView>>;\n using PrimaryAllocator = PrimaryAllocatorASVT<LocalAddressSpaceView>;\n #elif defined(__x86_64__) || defined(__powerpc64__)\n-# if defined(__powerpc64__)\n+# if SANITIZER_FUCHSIA\n+const uptr kAllocatorSpace = ~(uptr)0;\n+const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n+# elif defined(__powerpc64__)\n const uptr kAllocatorSpace = 0xa0000000000ULL;\n const uptr kAllocatorSize  = 0x20000000000ULL;  // 2T.\n # else"}, {"sha": "32ea4e88003877c72fed5c19231303550cc1cf58", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -211,6 +211,13 @@ void ForEachExtraStackRangeCb(uptr begin, uptr end, void* arg) {\n   ScanRangeForPointers(begin, end, frontier, \"FAKE STACK\", kReachable);\n }\n \n+#if SANITIZER_FUCHSIA\n+\n+// Fuchsia handles all threads together with its own callback.\n+static void ProcessThreads(SuspendedThreadsList const &, Frontier *) {}\n+\n+#else\n+\n // Scans thread data (stacks and TLS) for heap pointers.\n static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n                            Frontier *frontier) {\n@@ -308,6 +315,8 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n   }\n }\n \n+#endif  // SANITIZER_FUCHSIA\n+\n void ScanRootRegion(Frontier *frontier, const RootRegion &root_region,\n                     uptr region_begin, uptr region_end, bool is_readable) {\n   uptr intersection_begin = Max(root_region.begin, region_begin);\n@@ -443,25 +452,23 @@ void ProcessPC(Frontier *frontier) {\n }\n \n // Sets the appropriate tag on each chunk.\n-static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n-  // Holds the flood fill frontier.\n-  Frontier frontier;\n-\n-  ForEachChunk(CollectIgnoredCb, &frontier);\n-  ProcessGlobalRegions(&frontier);\n-  ProcessThreads(suspended_threads, &frontier);\n-  ProcessRootRegions(&frontier);\n-  FloodFillTag(&frontier, kReachable);\n+static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads,\n+                              Frontier *frontier) {\n+  ForEachChunk(CollectIgnoredCb, frontier);\n+  ProcessGlobalRegions(frontier);\n+  ProcessThreads(suspended_threads, frontier);\n+  ProcessRootRegions(frontier);\n+  FloodFillTag(frontier, kReachable);\n \n-  CHECK_EQ(0, frontier.size());\n-  ProcessPC(&frontier);\n+  CHECK_EQ(0, frontier->size());\n+  ProcessPC(frontier);\n \n   // The check here is relatively expensive, so we do this in a separate flood\n   // fill. That way we can skip the check for chunks that are reachable\n   // otherwise.\n   LOG_POINTERS(\"Processing platform-specific allocations.\\n\");\n-  ProcessPlatformSpecificAllocations(&frontier);\n-  FloodFillTag(&frontier, kReachable);\n+  ProcessPlatformSpecificAllocations(frontier);\n+  FloodFillTag(frontier, kReachable);\n \n   // Iterate over leaked chunks and mark those that are reachable from other\n   // leaked chunks.\n@@ -521,11 +528,6 @@ static void PrintMatchedSuppressions() {\n   Printf(\"%s\\n\\n\", line);\n }\n \n-struct CheckForLeaksParam {\n-  bool success;\n-  LeakReport leak_report;\n-};\n-\n static void ReportIfNotSuspended(ThreadContextBase *tctx, void *arg) {\n   const InternalMmapVector<tid_t> &suspended_threads =\n       *(const InternalMmapVector<tid_t> *)arg;\n@@ -538,6 +540,14 @@ static void ReportIfNotSuspended(ThreadContextBase *tctx, void *arg) {\n   }\n }\n \n+#if SANITIZER_FUCHSIA\n+\n+// Fuchsia provides a libc interface that guarantees all threads are\n+// covered, and SuspendedThreadList is never really used.\n+static void ReportUnsuspendedThreads(const SuspendedThreadsList &) {}\n+\n+#else  // !SANITIZER_FUCHSIA\n+\n static void ReportUnsuspendedThreads(\n     const SuspendedThreadsList &suspended_threads) {\n   InternalMmapVector<tid_t> threads(suspended_threads.ThreadCount());\n@@ -550,13 +560,15 @@ static void ReportUnsuspendedThreads(\n       &ReportIfNotSuspended, &threads);\n }\n \n+#endif  // !SANITIZER_FUCHSIA\n+\n static void CheckForLeaksCallback(const SuspendedThreadsList &suspended_threads,\n                                   void *arg) {\n   CheckForLeaksParam *param = reinterpret_cast<CheckForLeaksParam *>(arg);\n   CHECK(param);\n   CHECK(!param->success);\n   ReportUnsuspendedThreads(suspended_threads);\n-  ClassifyAllChunks(suspended_threads);\n+  ClassifyAllChunks(suspended_threads, &param->frontier);\n   ForEachChunk(CollectLeaksCb, &param->leak_report);\n   // Clean up for subsequent leak checks. This assumes we did not overwrite any\n   // kIgnored tags.\n@@ -569,7 +581,6 @@ static bool CheckForLeaks() {\n       return false;\n   EnsureMainThreadIDIsCorrect();\n   CheckForLeaksParam param;\n-  param.success = false;\n   LockStuffAndStopTheWorld(CheckForLeaksCallback, &param);\n \n   if (!param.success) {"}, {"sha": "6252d52c19781ca01635a2c3678de786c6e26ad6", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -40,7 +40,7 @@\n #elif defined(__arm__) && \\\n     SANITIZER_LINUX && !SANITIZER_ANDROID\n #define CAN_SANITIZE_LEAKS 1\n-#elif SANITIZER_NETBSD\n+#elif SANITIZER_NETBSD || SANITIZER_FUCHSIA\n #define CAN_SANITIZE_LEAKS 1\n #else\n #define CAN_SANITIZE_LEAKS 0\n@@ -126,12 +126,24 @@ struct RootRegion {\n   uptr size;\n };\n \n+// LockStuffAndStopTheWorld can start to use Scan* calls to collect into\n+// this Frontier vector before the StopTheWorldCallback actually runs.\n+// This is used when the OS has a unified callback API for suspending\n+// threads and enumerating roots.\n+struct CheckForLeaksParam {\n+  Frontier frontier;\n+  LeakReport leak_report;\n+  bool success = false;\n+};\n+\n InternalMmapVector<RootRegion> const *GetRootRegions();\n void ScanRootRegion(Frontier *frontier, RootRegion const &region,\n                     uptr region_begin, uptr region_end, bool is_readable);\n+void ForEachExtraStackRangeCb(uptr begin, uptr end, void* arg);\n // Run stoptheworld while holding any platform-specific locks, as well as the\n // allocator and thread registry locks.\n-void LockStuffAndStopTheWorld(StopTheWorldCallback callback, void* argument);\n+void LockStuffAndStopTheWorld(StopTheWorldCallback callback,\n+                              CheckForLeaksParam* argument);\n \n void ScanRangeForPointers(uptr begin, uptr end,\n                           Frontier *frontier,\n@@ -211,6 +223,7 @@ ThreadRegistry *GetThreadRegistryLocked();\n bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n                            uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n                            uptr *cache_end, DTLS **dtls);\n+void GetAllThreadAllocatorCachesLocked(InternalMmapVector<uptr> *caches);\n void ForEachExtraStackRange(tid_t os_id, RangeIteratorCallback callback,\n                             void *arg);\n // If called from the main thread, updates the main thread's TID in the thread"}, {"sha": "caedbf1559698d5ca0fb89840134e9fc8c1d7fbf", "filename": "libsanitizer/lsan/lsan_common_fuchsia.cpp", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_fuchsia.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,166 @@\n+//=-- lsan_common_fuchsia.cpp --------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Implementation of common leak checking functionality. Fuchsia-specific code.\n+//\n+//===---------------------------------------------------------------------===//\n+\n+#include \"lsan_common.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n+#if CAN_SANITIZE_LEAKS && SANITIZER_FUCHSIA\n+#include <zircon/sanitizer.h>\n+\n+#include \"lsan_allocator.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_thread_registry.h\"\n+\n+// Ensure that the Zircon system ABI is linked in.\n+#pragma comment(lib, \"zircon\")\n+\n+namespace __lsan {\n+\n+void InitializePlatformSpecificModules() {}\n+\n+LoadedModule *GetLinker() { return nullptr; }\n+\n+__attribute__((tls_model(\"initial-exec\"))) THREADLOCAL int disable_counter;\n+bool DisabledInThisThread() { return disable_counter > 0; }\n+void DisableInThisThread() { disable_counter++; }\n+void EnableInThisThread() {\n+  if (disable_counter == 0) {\n+    DisableCounterUnderflow();\n+  }\n+  disable_counter--;\n+}\n+\n+// There is nothing left to do after the globals callbacks.\n+void ProcessGlobalRegions(Frontier *frontier) {}\n+\n+// Nothing to do here.\n+void ProcessPlatformSpecificAllocations(Frontier *frontier) {}\n+\n+// On Fuchsia, we can intercept _Exit gracefully, and return a failing exit\n+// code if required at that point.  Calling Die() here is undefined\n+// behavior and causes rare race conditions.\n+void HandleLeaks() {}\n+\n+int ExitHook(int status) {\n+  return status == 0 && HasReportedLeaks() ? common_flags()->exitcode : status;\n+}\n+\n+void LockStuffAndStopTheWorld(StopTheWorldCallback callback,\n+                              CheckForLeaksParam *argument) {\n+  LockThreadRegistry();\n+  LockAllocator();\n+\n+  struct Params {\n+    InternalMmapVector<uptr> allocator_caches;\n+    StopTheWorldCallback callback;\n+    CheckForLeaksParam *argument;\n+  } params = {{}, callback, argument};\n+\n+  // Callback from libc for globals (data/bss modulo relro), when enabled.\n+  auto globals = +[](void *chunk, size_t size, void *data) {\n+    auto params = static_cast<const Params *>(data);\n+    uptr begin = reinterpret_cast<uptr>(chunk);\n+    uptr end = begin + size;\n+    ScanGlobalRange(begin, end, &params->argument->frontier);\n+  };\n+\n+  // Callback from libc for thread stacks.\n+  auto stacks = +[](void *chunk, size_t size, void *data) {\n+    auto params = static_cast<const Params *>(data);\n+    uptr begin = reinterpret_cast<uptr>(chunk);\n+    uptr end = begin + size;\n+    ScanRangeForPointers(begin, end, &params->argument->frontier, \"STACK\",\n+                         kReachable);\n+  };\n+\n+  // Callback from libc for thread registers.\n+  auto registers = +[](void *chunk, size_t size, void *data) {\n+    auto params = static_cast<const Params *>(data);\n+    uptr begin = reinterpret_cast<uptr>(chunk);\n+    uptr end = begin + size;\n+    ScanRangeForPointers(begin, end, &params->argument->frontier, \"REGISTERS\",\n+                         kReachable);\n+  };\n+\n+  if (flags()->use_tls) {\n+    // Collect the allocator cache range from each thread so these\n+    // can all be excluded from the reported TLS ranges.\n+    GetAllThreadAllocatorCachesLocked(&params.allocator_caches);\n+    __sanitizer::Sort(params.allocator_caches.data(),\n+                      params.allocator_caches.size());\n+  }\n+\n+  // Callback from libc for TLS regions.  This includes thread_local\n+  // variables as well as C11 tss_set and POSIX pthread_setspecific.\n+  auto tls = +[](void *chunk, size_t size, void *data) {\n+    auto params = static_cast<const Params *>(data);\n+    uptr begin = reinterpret_cast<uptr>(chunk);\n+    uptr end = begin + size;\n+    auto i = __sanitizer::InternalLowerBound(params->allocator_caches, 0,\n+                                             params->allocator_caches.size(),\n+                                             begin, CompareLess<uptr>());\n+    if (i < params->allocator_caches.size() &&\n+        params->allocator_caches[i] >= begin &&\n+        end - params->allocator_caches[i] <= sizeof(AllocatorCache)) {\n+      // Split the range in two and omit the allocator cache within.\n+      ScanRangeForPointers(begin, params->allocator_caches[i],\n+                           &params->argument->frontier, \"TLS\", kReachable);\n+      uptr begin2 = params->allocator_caches[i] + sizeof(AllocatorCache);\n+      ScanRangeForPointers(begin2, end, &params->argument->frontier, \"TLS\",\n+                           kReachable);\n+    } else {\n+      ScanRangeForPointers(begin, end, &params->argument->frontier, \"TLS\",\n+                           kReachable);\n+    }\n+  };\n+\n+  // This stops the world and then makes callbacks for various memory regions.\n+  // The final callback is the last thing before the world starts up again.\n+  __sanitizer_memory_snapshot(\n+      flags()->use_globals ? globals : nullptr,\n+      flags()->use_stacks ? stacks : nullptr,\n+      flags()->use_registers ? registers : nullptr,\n+      flags()->use_tls ? tls : nullptr,\n+      [](zx_status_t, void *data) {\n+        auto params = static_cast<const Params *>(data);\n+\n+        // We don't use the thread registry at all for enumerating the threads\n+        // and their stacks, registers, and TLS regions.  So use it separately\n+        // just for the allocator cache, and to call ForEachExtraStackRange,\n+        // which ASan needs.\n+        if (flags()->use_stacks) {\n+          GetThreadRegistryLocked()->RunCallbackForEachThreadLocked(\n+              [](ThreadContextBase *tctx, void *arg) {\n+                ForEachExtraStackRange(tctx->os_id, ForEachExtraStackRangeCb,\n+                                       arg);\n+              },\n+              &params->argument->frontier);\n+        }\n+\n+        params->callback({}, params->argument);\n+      },\n+      &params);\n+\n+  UnlockAllocator();\n+  UnlockThreadRegistry();\n+}\n+\n+}  // namespace __lsan\n+\n+// This is declared (in extern \"C\") by <zircon/sanitizer.h>.\n+// _Exit calls this directly to intercept and change the status value.\n+int __sanitizer_process_exit_hook(int status) {\n+  return __lsan::ExitHook(status);\n+}\n+\n+#endif"}, {"sha": "c97ef31593dfa8eaf287ae215849e8cad5f7302c", "filename": "libsanitizer/lsan/lsan_common_linux.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -134,7 +134,8 @@ static int LockStuffAndStopTheWorldCallback(struct dl_phdr_info *info,\n // while holding the libdl lock in the parent thread, we can safely reenter it\n // in the tracer. The solution is to run stoptheworld from a dl_iterate_phdr()\n // callback in the parent thread.\n-void LockStuffAndStopTheWorld(StopTheWorldCallback callback, void *argument) {\n+void LockStuffAndStopTheWorld(StopTheWorldCallback callback,\n+                              CheckForLeaksParam *argument) {\n   DoStopTheWorldParam param = {callback, argument};\n   dl_iterate_phdr(LockStuffAndStopTheWorldCallback, &param);\n }"}, {"sha": "8516a176eb467ef53095ce75921d26838b4113ad", "filename": "libsanitizer/lsan/lsan_common_mac.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_mac.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -193,7 +193,8 @@ void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n // causes rare race conditions.\n void HandleLeaks() {}\n \n-void LockStuffAndStopTheWorld(StopTheWorldCallback callback, void *argument) {\n+void LockStuffAndStopTheWorld(StopTheWorldCallback callback,\n+                              CheckForLeaksParam *argument) {\n   LockThreadRegistry();\n   LockAllocator();\n   StopTheWorld(callback, argument);"}, {"sha": "40e65c6fb7293641b1d7b1dd795398fd8bb12801", "filename": "libsanitizer/lsan/lsan_fuchsia.cpp", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_fuchsia.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,123 @@\n+//=-- lsan_fuchsia.cpp ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Standalone LSan RTL code specific to Fuchsia.\n+//\n+//===---------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n+#if SANITIZER_FUCHSIA\n+#include <zircon/sanitizer.h>\n+\n+#include \"lsan.h\"\n+#include \"lsan_allocator.h\"\n+\n+using namespace __lsan;\n+\n+namespace __lsan {\n+\n+void LsanOnDeadlySignal(int signo, void *siginfo, void *context) {}\n+\n+ThreadContext::ThreadContext(int tid) : ThreadContextLsanBase(tid) {}\n+\n+struct OnCreatedArgs {\n+  uptr stack_begin, stack_end;\n+};\n+\n+// On Fuchsia, the stack bounds of a new thread are available before\n+// the thread itself has started running.\n+void ThreadContext::OnCreated(void *arg) {\n+  // Stack bounds passed through from __sanitizer_before_thread_create_hook\n+  // or InitializeMainThread.\n+  auto args = reinterpret_cast<const OnCreatedArgs *>(arg);\n+  stack_begin_ = args->stack_begin;\n+  stack_end_ = args->stack_end;\n+}\n+\n+struct OnStartedArgs {\n+  uptr cache_begin, cache_end;\n+};\n+\n+void ThreadContext::OnStarted(void *arg) {\n+  auto args = reinterpret_cast<const OnStartedArgs *>(arg);\n+  cache_begin_ = args->cache_begin;\n+  cache_end_ = args->cache_end;\n+}\n+\n+void ThreadStart(u32 tid) {\n+  OnStartedArgs args;\n+  GetAllocatorCacheRange(&args.cache_begin, &args.cache_end);\n+  CHECK_EQ(args.cache_end - args.cache_begin, sizeof(AllocatorCache));\n+  ThreadContextLsanBase::ThreadStart(tid, GetTid(), ThreadType::Regular, &args);\n+}\n+\n+void InitializeMainThread() {\n+  OnCreatedArgs args;\n+  __sanitizer::GetThreadStackTopAndBottom(true, &args.stack_end,\n+                                          &args.stack_begin);\n+  u32 tid = ThreadCreate(0, GetThreadSelf(), true, &args);\n+  CHECK_EQ(tid, 0);\n+  ThreadStart(tid);\n+}\n+\n+void GetAllThreadAllocatorCachesLocked(InternalMmapVector<uptr> *caches) {\n+  GetThreadRegistryLocked()->RunCallbackForEachThreadLocked(\n+      [](ThreadContextBase *tctx, void *arg) {\n+        auto ctx = static_cast<ThreadContext *>(tctx);\n+        static_cast<decltype(caches)>(arg)->push_back(ctx->cache_begin());\n+      },\n+      caches);\n+}\n+\n+}  // namespace __lsan\n+\n+// These are declared (in extern \"C\") by <zircon/sanitizer.h>.\n+// The system runtime will call our definitions directly.\n+\n+// This is called before each thread creation is attempted.  So, in\n+// its first call, the calling thread is the initial and sole thread.\n+void *__sanitizer_before_thread_create_hook(thrd_t thread, bool detached,\n+                                            const char *name, void *stack_base,\n+                                            size_t stack_size) {\n+  uptr user_id = reinterpret_cast<uptr>(thread);\n+  ENSURE_LSAN_INITED;\n+  EnsureMainThreadIDIsCorrect();\n+  OnCreatedArgs args;\n+  args.stack_begin = reinterpret_cast<uptr>(stack_base);\n+  args.stack_end = args.stack_begin + stack_size;\n+  u32 parent_tid = GetCurrentThread();\n+  u32 tid = ThreadCreate(parent_tid, user_id, detached, &args);\n+  return reinterpret_cast<void *>(static_cast<uptr>(tid));\n+}\n+\n+// This is called after creating a new thread (in the creating thread),\n+// with the pointer returned by __sanitizer_before_thread_create_hook (above).\n+void __sanitizer_thread_create_hook(void *hook, thrd_t thread, int error) {\n+  u32 tid = static_cast<u32>(reinterpret_cast<uptr>(hook));\n+  // On success, there is nothing to do here.\n+  if (error != thrd_success) {\n+    // Clean up the thread registry for the thread creation that didn't happen.\n+    GetThreadRegistryLocked()->FinishThread(tid);\n+  }\n+}\n+\n+// This is called in the newly-created thread before it runs anything else,\n+// with the pointer returned by __sanitizer_before_thread_create_hook (above).\n+void __sanitizer_thread_start_hook(void *hook, thrd_t self) {\n+  u32 tid = static_cast<u32>(reinterpret_cast<uptr>(hook));\n+  ThreadStart(tid);\n+}\n+\n+// Each thread runs this just before it exits,\n+// with the pointer returned by BeforeThreadCreateHook (above).\n+// All per-thread destructors have already been called.\n+void __sanitizer_thread_exit_hook(void *hook, thrd_t self) { ThreadFinish(); }\n+\n+#endif  // SANITIZER_FUCHSIA"}, {"sha": "65d20ea21148d26a7d644f3f3a0af7546afaa7e1", "filename": "libsanitizer/lsan/lsan_fuchsia.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_fuchsia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_fuchsia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_fuchsia.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,35 @@\n+//=-- lsan_fuchsia.h ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Standalone LSan RTL code specific to Fuchsia.\n+//\n+//===---------------------------------------------------------------------===//\n+\n+#ifndef LSAN_FUCHSIA_H\n+#define LSAN_FUCHSIA_H\n+\n+#include \"lsan_thread.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n+#if !SANITIZER_FUCHSIA\n+#error \"lsan_fuchsia.h is used only on Fuchsia systems (SANITIZER_FUCHSIA)\"\n+#endif\n+\n+namespace __lsan {\n+\n+class ThreadContext : public ThreadContextLsanBase {\n+ public:\n+  explicit ThreadContext(int tid);\n+  void OnCreated(void *arg) override;\n+  void OnStarted(void *arg) override;\n+};\n+\n+}  // namespace __lsan\n+\n+#endif  // LSAN_FUCHSIA_H"}, {"sha": "9ce9b78c5a5ff6c59cfdbfb84166f47e5dfab25c", "filename": "libsanitizer/lsan/lsan_interceptors.cpp", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -22,7 +22,9 @@\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n #include \"sanitizer_common/sanitizer_platform_limits_netbsd.h\"\n #include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n+#if SANITIZER_POSIX\n #include \"sanitizer_common/sanitizer_posix.h\"\n+#endif\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"lsan.h\"\n #include \"lsan_allocator.h\"\n@@ -61,6 +63,9 @@ INTERCEPTOR(void, free, void *p) {\n }\n \n INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n+  // This hack is not required for Fuchsia because there are no dlsym calls\n+  // involved in setting up interceptors.\n+#if !SANITIZER_FUCHSIA\n   if (lsan_init_is_running) {\n     // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n     const uptr kCallocPoolSize = 1024;\n@@ -72,6 +77,7 @@ INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n     CHECK(allocated < kCallocPoolSize);\n     return mem;\n   }\n+#endif  // !SANITIZER_FUCHSIA\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n   return lsan_calloc(nmemb, size, stack);\n@@ -100,7 +106,7 @@ INTERCEPTOR(void*, valloc, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n   return lsan_valloc(size, stack);\n }\n-#endif\n+#endif  // !SANITIZER_MAC\n \n #if SANITIZER_INTERCEPT_MEMALIGN\n INTERCEPTOR(void*, memalign, uptr alignment, uptr size) {\n@@ -307,7 +313,7 @@ INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n \n ///// Thread initialization and finalization. /////\n \n-#if !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n+#if !SANITIZER_NETBSD && !SANITIZER_FREEBSD && !SANITIZER_FUCHSIA\n static unsigned g_thread_finalize_key;\n \n static void thread_finalize(void *v) {\n@@ -394,6 +400,8 @@ INTERCEPTOR(char *, strerror, int errnum) {\n #define LSAN_MAYBE_INTERCEPT_STRERROR\n #endif\n \n+#if SANITIZER_POSIX\n+\n struct ThreadParam {\n   void *(*callback)(void *arg);\n   void *param;\n@@ -416,7 +424,6 @@ extern \"C\" void *__lsan_thread_start_func(void *arg) {\n   int tid = 0;\n   while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n     internal_sched_yield();\n-  SetCurrentThread(tid);\n   ThreadStart(tid, GetTid());\n   atomic_store(&p->tid, 0, memory_order_release);\n   return callback(param);\n@@ -477,9 +484,13 @@ INTERCEPTOR(void, _exit, int status) {\n #define COMMON_INTERCEPT_FUNCTION(name) INTERCEPT_FUNCTION(name)\n #include \"sanitizer_common/sanitizer_signal_interceptors.inc\"\n \n+#endif  // SANITIZER_POSIX\n+\n namespace __lsan {\n \n void InitializeInterceptors() {\n+  // Fuchsia doesn't use interceptors that require any setup.\n+#if !SANITIZER_FUCHSIA\n   InitializeSignalInterceptors();\n \n   INTERCEPT_FUNCTION(malloc);\n@@ -515,6 +526,8 @@ void InitializeInterceptors() {\n     Die();\n   }\n #endif\n+\n+#endif  // !SANITIZER_FUCHSIA\n }\n \n } // namespace __lsan"}, {"sha": "47c2f21b5a6bc3e69c7bb1cfee34a4c7bff0edc9", "filename": "libsanitizer/lsan/lsan_linux.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_linux.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -6,13 +6,13 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// This file is a part of LeakSanitizer. Linux/NetBSD-specific code.\n+// This file is a part of LeakSanitizer. Linux/NetBSD/Fuchsia-specific code.\n //\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n \n-#if SANITIZER_LINUX || SANITIZER_NETBSD\n+#if SANITIZER_LINUX || SANITIZER_NETBSD || SANITIZER_FUCHSIA\n \n #include \"lsan_allocator.h\"\n \n@@ -29,4 +29,4 @@ void ReplaceSystemMalloc() {}\n \n } // namespace __lsan\n \n-#endif  // SANITIZER_LINUX || SANITIZER_NETBSD\n+#endif  // SANITIZER_LINUX || SANITIZER_NETBSD || SANITIZER_FUCHSIA"}, {"sha": "8e05915dd1b990bb664b156101d35b8266595a5b", "filename": "libsanitizer/lsan/lsan_posix.cpp", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_posix.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,96 @@\n+//=-- lsan_posix.cpp -----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Standalone LSan RTL code common to POSIX-like systems.\n+//\n+//===---------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n+#if SANITIZER_POSIX\n+#include \"lsan.h\"\n+#include \"lsan_allocator.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n+\n+namespace __lsan {\n+\n+ThreadContext::ThreadContext(int tid) : ThreadContextLsanBase(tid) {}\n+\n+struct OnStartedArgs {\n+  uptr stack_begin;\n+  uptr stack_end;\n+  uptr cache_begin;\n+  uptr cache_end;\n+  uptr tls_begin;\n+  uptr tls_end;\n+  DTLS *dtls;\n+};\n+\n+void ThreadContext::OnStarted(void *arg) {\n+  auto args = reinterpret_cast<const OnStartedArgs *>(arg);\n+  stack_begin_ = args->stack_begin;\n+  stack_end_ = args->stack_end;\n+  tls_begin_ = args->tls_begin;\n+  tls_end_ = args->tls_end;\n+  cache_begin_ = args->cache_begin;\n+  cache_end_ = args->cache_end;\n+  dtls_ = args->dtls;\n+}\n+\n+void ThreadStart(u32 tid, tid_t os_id, ThreadType thread_type) {\n+  OnStartedArgs args;\n+  uptr stack_size = 0;\n+  uptr tls_size = 0;\n+  GetThreadStackAndTls(tid == 0, &args.stack_begin, &stack_size,\n+                       &args.tls_begin, &tls_size);\n+  args.stack_end = args.stack_begin + stack_size;\n+  args.tls_end = args.tls_begin + tls_size;\n+  GetAllocatorCacheRange(&args.cache_begin, &args.cache_end);\n+  args.dtls = DTLS_Get();\n+  ThreadContextLsanBase::ThreadStart(tid, os_id, thread_type, &args);\n+}\n+\n+bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n+                           uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n+                           uptr *cache_end, DTLS **dtls) {\n+  ThreadContext *context = static_cast<ThreadContext *>(\n+      GetThreadRegistryLocked()->FindThreadContextByOsIDLocked(os_id));\n+  if (!context)\n+    return false;\n+  *stack_begin = context->stack_begin();\n+  *stack_end = context->stack_end();\n+  *tls_begin = context->tls_begin();\n+  *tls_end = context->tls_end();\n+  *cache_begin = context->cache_begin();\n+  *cache_end = context->cache_end();\n+  *dtls = context->dtls();\n+  return true;\n+}\n+\n+void InitializeMainThread() {\n+  u32 tid = ThreadCreate(0, 0, true);\n+  CHECK_EQ(tid, 0);\n+  ThreadStart(tid, GetTid());\n+}\n+\n+static void OnStackUnwind(const SignalContext &sig, const void *,\n+                          BufferedStackTrace *stack) {\n+  stack->Unwind(StackTrace::GetNextInstructionPc(sig.pc), sig.bp, sig.context,\n+                common_flags()->fast_unwind_on_fatal);\n+}\n+\n+void LsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n+  HandleDeadlySignal(siginfo, context, GetCurrentThread(), &OnStackUnwind,\n+                     nullptr);\n+}\n+\n+}  // namespace __lsan\n+\n+#endif  // SANITIZER_POSIX"}, {"sha": "840e427c55e33de22690fe03e4bee8ef837f63ad", "filename": "libsanitizer/lsan/lsan_posix.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_posix.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,49 @@\n+//=-- lsan_posix.h -----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Standalone LSan RTL code common to POSIX-like systems.\n+//\n+//===---------------------------------------------------------------------===//\n+\n+#ifndef LSAN_POSIX_H\n+#define LSAN_POSIX_H\n+\n+#include \"lsan_thread.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n+#if !SANITIZER_POSIX\n+#error \"lsan_posix.h is used only on POSIX-like systems (SANITIZER_POSIX)\"\n+#endif\n+\n+namespace __sanitizer {\n+struct DTLS;\n+}\n+\n+namespace __lsan {\n+\n+class ThreadContext : public ThreadContextLsanBase {\n+ public:\n+  explicit ThreadContext(int tid);\n+  void OnStarted(void *arg) override;\n+  uptr tls_begin() { return tls_begin_; }\n+  uptr tls_end() { return tls_end_; }\n+  DTLS *dtls() { return dtls_; }\n+\n+ private:\n+  uptr tls_begin_ = 0;\n+  uptr tls_end_ = 0;\n+  DTLS *dtls_ = nullptr;\n+};\n+\n+void ThreadStart(u32 tid, tid_t os_id,\n+                 ThreadType thread_type = ThreadType::Regular);\n+\n+}  // namespace __lsan\n+\n+#endif  // LSAN_POSIX_H"}, {"sha": "40bdc254bb62251510ec656e0b4bd0250b14389b", "filename": "libsanitizer/lsan/lsan_thread.cpp", "status": "modified", "additions": 23, "deletions": 75, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -13,80 +13,48 @@\n \n #include \"lsan_thread.h\"\n \n+#include \"lsan.h\"\n+#include \"lsan_allocator.h\"\n+#include \"lsan_common.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n-#include \"lsan_allocator.h\"\n-#include \"lsan_common.h\"\n \n namespace __lsan {\n \n static ThreadRegistry *thread_registry;\n \n static ThreadContextBase *CreateThreadContext(u32 tid) {\n   void *mem = MmapOrDie(sizeof(ThreadContext), \"ThreadContext\");\n-  return new(mem) ThreadContext(tid);\n+  return new (mem) ThreadContext(tid);\n }\n \n static const uptr kMaxThreads = 1 << 13;\n static const uptr kThreadQuarantineSize = 64;\n \n void InitializeThreadRegistry() {\n   static ALIGNED(64) char thread_registry_placeholder[sizeof(ThreadRegistry)];\n-  thread_registry = new(thread_registry_placeholder)\n-    ThreadRegistry(CreateThreadContext, kMaxThreads, kThreadQuarantineSize);\n+  thread_registry = new (thread_registry_placeholder)\n+      ThreadRegistry(CreateThreadContext, kMaxThreads, kThreadQuarantineSize);\n }\n \n-ThreadContext::ThreadContext(int tid)\n-    : ThreadContextBase(tid),\n-      stack_begin_(0),\n-      stack_end_(0),\n-      cache_begin_(0),\n-      cache_end_(0),\n-      tls_begin_(0),\n-      tls_end_(0),\n-      dtls_(nullptr) {}\n-\n-struct OnStartedArgs {\n-  uptr stack_begin, stack_end,\n-       cache_begin, cache_end,\n-       tls_begin, tls_end;\n-  DTLS *dtls;\n-};\n-\n-void ThreadContext::OnStarted(void *arg) {\n-  OnStartedArgs *args = reinterpret_cast<OnStartedArgs *>(arg);\n-  stack_begin_ = args->stack_begin;\n-  stack_end_ = args->stack_end;\n-  tls_begin_ = args->tls_begin;\n-  tls_end_ = args->tls_end;\n-  cache_begin_ = args->cache_begin;\n-  cache_end_ = args->cache_end;\n-  dtls_ = args->dtls;\n-}\n+ThreadContextLsanBase::ThreadContextLsanBase(int tid)\n+    : ThreadContextBase(tid) {}\n \n-void ThreadContext::OnFinished() {\n+void ThreadContextLsanBase::OnFinished() {\n   AllocatorThreadFinish();\n   DTLS_Destroy();\n }\n \n-u32 ThreadCreate(u32 parent_tid, uptr user_id, bool detached) {\n-  return thread_registry->CreateThread(user_id, detached, parent_tid,\n-                                       /* arg */ nullptr);\n+u32 ThreadCreate(u32 parent_tid, uptr user_id, bool detached, void *arg) {\n+  return thread_registry->CreateThread(user_id, detached, parent_tid, arg);\n }\n \n-void ThreadStart(u32 tid, tid_t os_id, ThreadType thread_type) {\n-  OnStartedArgs args;\n-  uptr stack_size = 0;\n-  uptr tls_size = 0;\n-  GetThreadStackAndTls(tid == 0, &args.stack_begin, &stack_size,\n-                       &args.tls_begin, &tls_size);\n-  args.stack_end = args.stack_begin + stack_size;\n-  args.tls_end = args.tls_begin + tls_size;\n-  GetAllocatorCacheRange(&args.cache_begin, &args.cache_end);\n-  args.dtls = DTLS_Get();\n-  thread_registry->StartThread(tid, os_id, thread_type, &args);\n+void ThreadContextLsanBase::ThreadStart(u32 tid, tid_t os_id,\n+                                        ThreadType thread_type, void *arg) {\n+  thread_registry->StartThread(tid, os_id, thread_type, arg);\n+  SetCurrentThread(tid);\n }\n \n void ThreadFinish() {\n@@ -95,7 +63,8 @@ void ThreadFinish() {\n }\n \n ThreadContext *CurrentThreadContext() {\n-  if (!thread_registry) return nullptr;\n+  if (!thread_registry)\n+    return nullptr;\n   if (GetCurrentThread() == kInvalidTid)\n     return nullptr;\n   // No lock needed when getting current thread.\n@@ -111,12 +80,12 @@ static bool FindThreadByUid(ThreadContextBase *tctx, void *arg) {\n }\n \n u32 ThreadTid(uptr uid) {\n-  return thread_registry->FindThread(FindThreadByUid, (void*)uid);\n+  return thread_registry->FindThread(FindThreadByUid, (void *)uid);\n }\n \n void ThreadJoin(u32 tid) {\n   CHECK_NE(tid, kInvalidTid);\n-  thread_registry->JoinThread(tid, /* arg */nullptr);\n+  thread_registry->JoinThread(tid, /* arg */ nullptr);\n }\n \n void EnsureMainThreadIDIsCorrect() {\n@@ -126,37 +95,16 @@ void EnsureMainThreadIDIsCorrect() {\n \n ///// Interface to the common LSan module. /////\n \n-bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n-                           uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n-                           uptr *cache_end, DTLS **dtls) {\n-  ThreadContext *context = static_cast<ThreadContext *>(\n-      thread_registry->FindThreadContextByOsIDLocked(os_id));\n-  if (!context) return false;\n-  *stack_begin = context->stack_begin();\n-  *stack_end = context->stack_end();\n-  *tls_begin = context->tls_begin();\n-  *tls_end = context->tls_end();\n-  *cache_begin = context->cache_begin();\n-  *cache_end = context->cache_end();\n-  *dtls = context->dtls();\n-  return true;\n-}\n-\n void ForEachExtraStackRange(tid_t os_id, RangeIteratorCallback callback,\n-                            void *arg) {\n-}\n+                            void *arg) {}\n \n-void LockThreadRegistry() {\n-  thread_registry->Lock();\n-}\n+void LockThreadRegistry() { thread_registry->Lock(); }\n \n-void UnlockThreadRegistry() {\n-  thread_registry->Unlock();\n-}\n+void UnlockThreadRegistry() { thread_registry->Unlock(); }\n \n ThreadRegistry *GetThreadRegistryLocked() {\n   thread_registry->CheckLocked();\n   return thread_registry;\n }\n \n-} // namespace __lsan\n+}  // namespace __lsan"}, {"sha": "0ab1582de662513eb128e9513bf8be1623a81e1d", "filename": "libsanitizer/lsan/lsan_thread.h", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Flsan%2Flsan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -16,45 +16,44 @@\n \n #include \"sanitizer_common/sanitizer_thread_registry.h\"\n \n-namespace __sanitizer {\n-struct DTLS;\n-}\n-\n namespace __lsan {\n \n-class ThreadContext : public ThreadContextBase {\n+class ThreadContextLsanBase : public ThreadContextBase {\n  public:\n-  explicit ThreadContext(int tid);\n-  void OnStarted(void *arg) override;\n+  explicit ThreadContextLsanBase(int tid);\n   void OnFinished() override;\n   uptr stack_begin() { return stack_begin_; }\n   uptr stack_end() { return stack_end_; }\n-  uptr tls_begin() { return tls_begin_; }\n-  uptr tls_end() { return tls_end_; }\n   uptr cache_begin() { return cache_begin_; }\n   uptr cache_end() { return cache_end_; }\n-  DTLS *dtls() { return dtls_; }\n \n- private:\n-  uptr stack_begin_, stack_end_,\n-       cache_begin_, cache_end_,\n-       tls_begin_, tls_end_;\n-  DTLS *dtls_;\n+  // The argument is passed on to the subclass's OnStarted member function.\n+  static void ThreadStart(u32 tid, tid_t os_id, ThreadType thread_type,\n+                          void *onstarted_arg);\n+\n+ protected:\n+  uptr stack_begin_ = 0;\n+  uptr stack_end_ = 0;\n+  uptr cache_begin_ = 0;\n+  uptr cache_end_ = 0;\n };\n \n+// This subclass of ThreadContextLsanBase is declared in an OS-specific header.\n+class ThreadContext;\n+\n void InitializeThreadRegistry();\n+void InitializeMainThread();\n \n-void ThreadStart(u32 tid, tid_t os_id,\n-                 ThreadType thread_type = ThreadType::Regular);\n+u32 ThreadCreate(u32 tid, uptr uid, bool detached, void *arg = nullptr);\n void ThreadFinish();\n-u32 ThreadCreate(u32 tid, uptr uid, bool detached);\n void ThreadJoin(u32 tid);\n u32 ThreadTid(uptr uid);\n \n u32 GetCurrentThread();\n void SetCurrentThread(u32 tid);\n ThreadContext *CurrentThreadContext();\n void EnsureMainThreadIDIsCorrect();\n+\n }  // namespace __lsan\n \n #endif  // LSAN_THREAD_H"}, {"sha": "ec77b9cbfee8c896c98811ca4150347a66f65e83", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -25,7 +25,7 @@ const char *PrimaryAllocatorName = \"SizeClassAllocator\";\n const char *SecondaryAllocatorName = \"LargeMmapAllocator\";\n \n // ThreadSanitizer for Go uses libc malloc/free.\n-#if SANITIZER_GO || defined(SANITIZER_USE_MALLOC)\n+#if defined(SANITIZER_USE_MALLOC)\n # if SANITIZER_LINUX && !SANITIZER_ANDROID\n extern \"C\" void *__libc_malloc(uptr size);\n #  if !SANITIZER_GO\n@@ -213,7 +213,7 @@ void *LowLevelAllocator::Allocate(uptr size) {\n   // Align allocation size.\n   size = RoundUpTo(size, low_level_alloc_min_alignment);\n   if (allocated_end_ - allocated_current_ < (sptr)size) {\n-    uptr size_to_allocate = Max(size, GetPageSizeCached());\n+    uptr size_to_allocate = RoundUpTo(size, GetPageSizeCached());\n     allocated_current_ =\n         (char*)MmapOrDie(size_to_allocate, __func__);\n     allocated_end_ = allocated_current_ + size_to_allocate;"}, {"sha": "1d9a29c70f308b4d589880d6d652b1066b39188d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary64.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -72,11 +72,15 @@ class SizeClassAllocator64 {\n   void Init(s32 release_to_os_interval_ms) {\n     uptr TotalSpaceSize = kSpaceSize + AdditionalSize();\n     if (kUsingConstantSpaceBeg) {\n+      CHECK(IsAligned(kSpaceBeg, SizeClassMap::kMaxSize));\n       CHECK_EQ(kSpaceBeg, address_range.Init(TotalSpaceSize,\n                                              PrimaryAllocatorName, kSpaceBeg));\n     } else {\n-      NonConstSpaceBeg = address_range.Init(TotalSpaceSize,\n-                                            PrimaryAllocatorName);\n+      // Combined allocator expects that an 2^N allocation is always aligned to\n+      // 2^N. For this to work, the start of the space needs to be aligned as\n+      // high as the largest size class (which also needs to be a power of 2).\n+      NonConstSpaceBeg = address_range.InitAligned(\n+          TotalSpaceSize, SizeClassMap::kMaxSize, PrimaryAllocatorName);\n       CHECK_NE(NonConstSpaceBeg, ~(uptr)0);\n     }\n     SetReleaseToOSIntervalMs(release_to_os_interval_ms);\n@@ -220,7 +224,7 @@ class SizeClassAllocator64 {\n \n   // Test-only.\n   void TestOnlyUnmap() {\n-    UnmapWithCallbackOrDie(SpaceBeg(), kSpaceSize + AdditionalSize());\n+    UnmapWithCallbackOrDie((uptr)address_range.base(), address_range.size());\n   }\n \n   static void FillMemoryProfile(uptr start, uptr rss, bool file, uptr *stats,"}, {"sha": "87efda5bd372153e04ebd2667859216d9b3ff7c3", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -274,6 +274,7 @@ uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {\n   return name_len;\n }\n \n+#if !SANITIZER_GO\n void PrintCmdline() {\n   char **argv = GetArgv();\n   if (!argv) return;\n@@ -282,6 +283,7 @@ void PrintCmdline() {\n     Printf(\"%s \", argv[i]);\n   Printf(\"\\n\\n\");\n }\n+#endif\n \n // Malloc hooks.\n static const int kMaxMallocFreeHooks = 5;"}, {"sha": "ac16e0e47efc5c159c8011a73e417dcda9733063", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -143,6 +143,7 @@ void RunFreeHooks(const void *ptr);\n class ReservedAddressRange {\n  public:\n   uptr Init(uptr size, const char *name = nullptr, uptr fixed_addr = 0);\n+  uptr InitAligned(uptr size, uptr align, const char *name = nullptr);\n   uptr Map(uptr fixed_addr, uptr size, const char *name = nullptr);\n   uptr MapOrDie(uptr fixed_addr, uptr size, const char *name = nullptr);\n   void Unmap(uptr addr, uptr size);\n@@ -552,7 +553,7 @@ bool operator!=(const InternalMmapVectorNoCtor<T> &lhs,\n template<typename T>\n class InternalMmapVector : public InternalMmapVectorNoCtor<T> {\n  public:\n-  InternalMmapVector() { InternalMmapVectorNoCtor<T>::Initialize(1); }\n+  InternalMmapVector() { InternalMmapVectorNoCtor<T>::Initialize(0); }\n   explicit InternalMmapVector(uptr cnt) {\n     InternalMmapVectorNoCtor<T>::Initialize(cnt);\n     this->resize(cnt);\n@@ -855,7 +856,7 @@ INLINE uptr GetPthreadDestructorIterations() {\n #endif\n }\n \n-void *internal_start_thread(void(*func)(void*), void *arg);\n+void *internal_start_thread(void *(*func)(void*), void *arg);\n void internal_join_thread(void *th);\n void MaybeStartBackgroudThread();\n "}, {"sha": "57f8b2d29442ca86f2e1f816e123ba390c70279c", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 177, "deletions": 13, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -79,13 +79,15 @@\n #define devname __devname50\n #define fgetpos __fgetpos50\n #define fsetpos __fsetpos50\n+#define fstatvfs __fstatvfs90\n+#define fstatvfs1 __fstatvfs190\n #define fts_children __fts_children60\n #define fts_close __fts_close60\n #define fts_open __fts_open60\n #define fts_read __fts_read60\n #define fts_set __fts_set60\n #define getitimer __getitimer50\n-#define getmntinfo __getmntinfo13\n+#define getmntinfo __getmntinfo90\n #define getpwent __getpwent50\n #define getpwnam __getpwnam50\n #define getpwnam_r __getpwnam_r50\n@@ -95,6 +97,7 @@\n #define getutxent __getutxent50\n #define getutxid __getutxid50\n #define getutxline __getutxline50\n+#define getvfsstat __getvfsstat90\n #define pututxline __pututxline50\n #define glob __glob30\n #define gmtime __gmtime50\n@@ -110,12 +113,15 @@\n #define setitimer __setitimer50\n #define setlocale __setlocale50\n #define shmctl __shmctl50\n+#define sigaltstack __sigaltstack14\n #define sigemptyset __sigemptyset14\n #define sigfillset __sigfillset14\n #define sigpending __sigpending14\n #define sigprocmask __sigprocmask14\n #define sigtimedwait __sigtimedwait50\n #define stat __stat50\n+#define statvfs __statvfs90\n+#define statvfs1 __statvfs190\n #define time __time50\n #define times __times13\n #define unvis __unvis50\n@@ -128,11 +134,7 @@ extern const short *_tolower_tab_;\n \n // Platform-specific options.\n #if SANITIZER_MAC\n-namespace __sanitizer {\n-bool PlatformHasDifferentMemcpyAndMemmove();\n-}\n-#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE \\\n-  (__sanitizer::PlatformHasDifferentMemcpyAndMemmove())\n+#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n #elif SANITIZER_WINDOWS64\n #define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n #else\n@@ -4177,11 +4179,27 @@ INTERCEPTOR(int, pthread_mutex_unlock, void *m) {\n \n #if SANITIZER_INTERCEPT___PTHREAD_MUTEX\n INTERCEPTOR(int, __pthread_mutex_lock, void *m) {\n-  return WRAP(pthread_mutex_lock)(m);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __pthread_mutex_lock, m);\n+  COMMON_INTERCEPTOR_MUTEX_PRE_LOCK(ctx, m);\n+  int res = REAL(__pthread_mutex_lock)(m);\n+  if (res == errno_EOWNERDEAD)\n+    COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m);\n+  if (res == 0 || res == errno_EOWNERDEAD)\n+    COMMON_INTERCEPTOR_MUTEX_POST_LOCK(ctx, m);\n+  if (res == errno_EINVAL)\n+    COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n+  return res;\n }\n \n INTERCEPTOR(int, __pthread_mutex_unlock, void *m) {\n-  return WRAP(pthread_mutex_unlock)(m);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __pthread_mutex_unlock, m);\n+  COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m);\n+  int res = REAL(__pthread_mutex_unlock)(m);\n+  if (res == errno_EINVAL)\n+    COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n+  return res;\n }\n \n #define INIT___PTHREAD_MUTEX_LOCK \\\n@@ -6411,12 +6429,11 @@ INTERCEPTOR(SSIZE_T, recvfrom, int fd, void *buf, SIZE_T len, int flags,\n   if (srcaddr) srcaddr_sz = *addrlen;\n   (void)srcaddr_sz;  // prevent \"set but not used\" warning\n   SSIZE_T res = REAL(recvfrom)(fd, buf, len, flags, srcaddr, addrlen);\n-  if (res > 0) {\n+  if (res > 0)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, Min((SIZE_T)res, len));\n-    if (srcaddr)\n-      COMMON_INTERCEPTOR_INITIALIZE_RANGE(srcaddr,\n-                                          Min((SIZE_T)*addrlen, srcaddr_sz));\n-  }\n+  if (res >= 0 && srcaddr)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(srcaddr,\n+                                        Min((SIZE_T)*addrlen, srcaddr_sz));\n   return res;\n }\n #define INIT_RECV_RECVFROM          \\\n@@ -9623,6 +9640,148 @@ INTERCEPTOR(int, getentropy, void *buf, SIZE_T buflen) {\n #define INIT_GETENTROPY\n #endif\n \n+#if SANITIZER_INTERCEPT_QSORT\n+// Glibc qsort uses a temporary buffer allocated either on stack or on heap.\n+// Poisoned memory from there may get copied into the comparator arguments,\n+// where it needs to be dealt with. But even that is not enough - the results of\n+// the sort may be copied into the input/output array based on the results of\n+// the comparator calls, but directly from the temp memory, bypassing the\n+// unpoisoning done in wrapped_qsort_compar. We deal with this by, again,\n+// unpoisoning the entire array after the sort is done.\n+//\n+// We can not check that the entire array is initialized at the beginning. IMHO,\n+// it's fine for parts of the sorted objects to contain uninitialized memory,\n+// ex. as padding in structs.\n+typedef int (*qsort_compar_f)(const void *, const void *);\n+static THREADLOCAL qsort_compar_f qsort_compar;\n+static THREADLOCAL SIZE_T qsort_size;\n+int wrapped_qsort_compar(const void *a, const void *b) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, qsort_size);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, qsort_size);\n+  return qsort_compar(a, b);\n+}\n+\n+INTERCEPTOR(void, qsort, void *base, SIZE_T nmemb, SIZE_T size,\n+            qsort_compar_f compar) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, qsort, base, nmemb, size, compar);\n+  // Run the comparator over all array elements to detect any memory issues.\n+  if (nmemb > 1) {\n+    for (SIZE_T i = 0; i < nmemb - 1; ++i) {\n+      void *p = (void *)((char *)base + i * size);\n+      void *q = (void *)((char *)base + (i + 1) * size);\n+      COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n+      compar(p, q);\n+    }\n+  }\n+  qsort_compar_f old_compar = qsort_compar;\n+  qsort_compar = compar;\n+  SIZE_T old_size = qsort_size;\n+  qsort_size = size;\n+  REAL(qsort)(base, nmemb, size, wrapped_qsort_compar);\n+  qsort_compar = old_compar;\n+  qsort_size = old_size;\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, base, nmemb * size);\n+}\n+#define INIT_QSORT COMMON_INTERCEPT_FUNCTION(qsort)\n+#else\n+#define INIT_QSORT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_QSORT_R\n+typedef int (*qsort_r_compar_f)(const void *, const void *, void *);\n+static THREADLOCAL qsort_r_compar_f qsort_r_compar;\n+static THREADLOCAL SIZE_T qsort_r_size;\n+int wrapped_qsort_r_compar(const void *a, const void *b, void *arg) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, qsort_r_size);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, qsort_r_size);\n+  return qsort_r_compar(a, b, arg);\n+}\n+\n+INTERCEPTOR(void, qsort_r, void *base, SIZE_T nmemb, SIZE_T size,\n+            qsort_r_compar_f compar, void *arg) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, qsort_r, base, nmemb, size, compar, arg);\n+  // Run the comparator over all array elements to detect any memory issues.\n+  if (nmemb > 1) {\n+    for (SIZE_T i = 0; i < nmemb - 1; ++i) {\n+      void *p = (void *)((char *)base + i * size);\n+      void *q = (void *)((char *)base + (i + 1) * size);\n+      COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n+      compar(p, q, arg);\n+    }\n+  }\n+  qsort_r_compar_f old_compar = qsort_r_compar;\n+  qsort_r_compar = compar;\n+  SIZE_T old_size = qsort_r_size;\n+  qsort_r_size = size;\n+  REAL(qsort_r)(base, nmemb, size, wrapped_qsort_r_compar, arg);\n+  qsort_r_compar = old_compar;\n+  qsort_r_size = old_size;\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, base, nmemb * size);\n+}\n+#define INIT_QSORT_R COMMON_INTERCEPT_FUNCTION(qsort_r)\n+#else\n+#define INIT_QSORT_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SIGALTSTACK\n+INTERCEPTOR(int, sigaltstack, void *ss, void *oss) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigaltstack, ss, oss);\n+  int r = REAL(sigaltstack)(ss, oss);\n+  if (r == 0 && oss != nullptr) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oss, struct_stack_t_sz);\n+  }\n+  return r;\n+}\n+#define INIT_SIGALTSTACK COMMON_INTERCEPT_FUNCTION(sigaltstack)\n+#else\n+#define INIT_SIGALTSTACK\n+#endif\n+\n+#if SANITIZER_INTERCEPT_UNAME\n+INTERCEPTOR(int, uname, struct utsname *utsname) {\n+#if SANITIZER_LINUX\n+  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n+    return internal_uname(utsname);\n+#endif\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, uname, utsname);\n+  int res = REAL(uname)(utsname);\n+  if (!res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, utsname,\n+                                   __sanitizer::struct_utsname_sz);\n+  return res;\n+}\n+#define INIT_UNAME COMMON_INTERCEPT_FUNCTION(uname)\n+#else\n+#define INIT_UNAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT___XUNAME\n+// FreeBSD's <sys/utsname.h> define uname() as\n+// static __inline int uname(struct utsname *name) {\n+//   return __xuname(SYS_NMLN, (void*)name);\n+// }\n+INTERCEPTOR(int, __xuname, int size, void *utsname) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __xuname, size, utsname);\n+  int res = REAL(__xuname)(size, utsname);\n+  if (!res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, utsname,\n+                                   __sanitizer::struct_utsname_sz);\n+  return res;\n+}\n+#define INIT___XUNAME COMMON_INTERCEPT_FUNCTION(__xuname)\n+#else\n+#define INIT___XUNAME\n+#endif\n+\n+#include \"sanitizer_common_interceptors_netbsd_compat.inc\"\n+\n static void InitializeCommonInterceptors() {\n #if SI_POSIX\n   static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n@@ -9924,6 +10083,11 @@ static void InitializeCommonInterceptors() {\n   INIT_CRYPT;\n   INIT_CRYPT_R;\n   INIT_GETENTROPY;\n+  INIT_QSORT;\n+  INIT_QSORT_R;\n+  INIT_SIGALTSTACK;\n+  INIT_UNAME;\n+  INIT___XUNAME;\n \n   INIT___PRINTF_CHK;\n }"}, {"sha": "6aa73ec8c6a2b940d9d83a86d0ffa04016ae154e", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_netbsd_compat.inc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_netbsd_compat.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_netbsd_compat.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_netbsd_compat.inc?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,128 @@\n+//===-- sanitizer_common_interceptors_netbsd_compat.inc ---------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Common function interceptors for tools like AddressSanitizer,\n+// ThreadSanitizer, MemorySanitizer, etc.\n+//\n+// Interceptors for NetBSD old function calls that have been versioned.\n+//\n+// NetBSD minimal version supported 9.0.\n+// NetBSD current version supported 9.99.26.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#if SANITIZER_NETBSD\n+\n+// First undef all mangled symbols.\n+// Next, define compat interceptors.\n+// Finally, undef INIT_ and redefine it.\n+// This allows to avoid preprocessor issues.\n+\n+#undef fstatvfs\n+#undef fstatvfs1\n+#undef getmntinfo\n+#undef getvfsstat\n+#undef statvfs\n+#undef statvfs1\n+\n+INTERCEPTOR(int, statvfs, char *path, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, statvfs, path, buf);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://github.com/google/sanitizers/issues/321.\n+  int res = REAL(statvfs)(path, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs90_sz);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, fstatvfs, int fd, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs, fd, buf);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://github.com/google/sanitizers/issues/321.\n+  int res = REAL(fstatvfs)(fd, buf);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs90_sz);\n+    if (fd >= 0)\n+      COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  }\n+  return res;\n+}\n+\n+#undef INIT_STATVFS\n+#define INIT_STATVFS \\\n+  COMMON_INTERCEPT_FUNCTION(statvfs); \\\n+  COMMON_INTERCEPT_FUNCTION(fstatvfs); \\\n+  COMMON_INTERCEPT_FUNCTION(__statvfs90); \\\n+  COMMON_INTERCEPT_FUNCTION(__fstatvfs90)\n+\n+INTERCEPTOR(int, __getmntinfo13, void **mntbufp, int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __getmntinfo13, mntbufp, flags);\n+  int cnt = REAL(__getmntinfo13)(mntbufp, flags);\n+  if (cnt > 0 && mntbufp) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mntbufp, sizeof(void *));\n+    if (*mntbufp)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *mntbufp, cnt * struct_statvfs90_sz);\n+  }\n+  return cnt;\n+}\n+\n+#undef INIT_GETMNTINFO\n+#define INIT_GETMNTINFO \\\n+  COMMON_INTERCEPT_FUNCTION(__getmntinfo13); \\\n+  COMMON_INTERCEPT_FUNCTION(__getmntinfo90)\n+\n+INTERCEPTOR(int, getvfsstat, void *buf, SIZE_T bufsize, int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getvfsstat, buf, bufsize, flags);\n+  int ret = REAL(getvfsstat)(buf, bufsize, flags);\n+  if (buf && ret > 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, ret * struct_statvfs90_sz);\n+  return ret;\n+}\n+\n+#undef INIT_GETVFSSTAT\n+#define INIT_GETVFSSTAT \\\n+  COMMON_INTERCEPT_FUNCTION(getvfsstat); \\\n+  COMMON_INTERCEPT_FUNCTION(__getvfsstat90)\n+\n+INTERCEPTOR(int, statvfs1, const char *path, void *buf, int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, statvfs1, path, buf, flags);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  int res = REAL(statvfs1)(path, buf, flags);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs90_sz);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, fstatvfs1, int fd, void *buf, int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs1, fd, buf, flags);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+  int res = REAL(fstatvfs1)(fd, buf, flags);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs90_sz);\n+    if (fd >= 0)\n+      COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  }\n+  return res;\n+}\n+\n+#undef INIT_STATVFS1\n+#define INIT_STATVFS1 \\\n+  COMMON_INTERCEPT_FUNCTION(statvfs1); \\\n+  COMMON_INTERCEPT_FUNCTION(fstatvfs1); \\\n+  COMMON_INTERCEPT_FUNCTION(__statvfs190); \\\n+  COMMON_INTERCEPT_FUNCTION(__fstatvfs190)\n+\n+#endif"}, {"sha": "0c918ebb4a9d651692d66b1ea88f4e07b536cb2c", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cpp", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -30,7 +30,7 @@ SANITIZER_WEAK_ATTRIBUTE StackDepotStats *StackDepotGetStats() {\n   return nullptr;\n }\n \n-void BackgroundThread(void *arg) {\n+void *BackgroundThread(void *arg) {\n   const uptr hard_rss_limit_mb = common_flags()->hard_rss_limit_mb;\n   const uptr soft_rss_limit_mb = common_flags()->soft_rss_limit_mb;\n   const bool heap_profile = common_flags()->heap_profile;\n@@ -129,6 +129,16 @@ void SetSandboxingCallback(void (*f)()) {\n   sandboxing_callback = f;\n }\n \n+uptr ReservedAddressRange::InitAligned(uptr size, uptr align,\n+                                       const char *name) {\n+  CHECK(IsPowerOfTwo(align));\n+  if (align <= GetPageSizeCached())\n+    return Init(size, name);\n+  uptr start = Init(size + align, name);\n+  start += align - (start & (align - 1));\n+  return start;\n+}\n+\n }  // namespace __sanitizer\n \n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_sandbox_on_notify,"}, {"sha": "532ac9ead3498954a409767ee475edea0e50b469", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -2885,6 +2885,23 @@ POST_SYSCALL(getrandom)(long res, void *buf, uptr count, long flags) {\n     POST_WRITE(buf, res);\n   }\n }\n+\n+PRE_SYSCALL(sigaltstack)(const void *ss, void *oss) {\n+  if (ss != nullptr) {\n+    PRE_READ(ss, struct_stack_t_sz);\n+  }\n+  if (oss != nullptr) {\n+    PRE_WRITE(oss, struct_stack_t_sz);\n+  }\n+}\n+\n+POST_SYSCALL(sigaltstack)(long res, void *ss, void *oss) {\n+  if (res == 0) {\n+    if (oss != nullptr) {\n+      POST_WRITE(oss, struct_stack_t_sz);\n+    }\n+  }\n+}\n }  // extern \"C\"\n \n #undef PRE_SYSCALL"}, {"sha": "a52db08433e3b4de99c29062ef86770c45e1bc02", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_fuchsia.cpp", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -27,15 +27,15 @@\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_FUCHSIA\n+#include <zircon/process.h>\n+#include <zircon/sanitizer.h>\n+#include <zircon/syscalls.h>\n+\n #include \"sanitizer_atomic.h\"\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_symbolizer_fuchsia.h\"\n \n-#include <zircon/process.h>\n-#include <zircon/sanitizer.h>\n-#include <zircon/syscalls.h>\n-\n using namespace __sanitizer;\n \n namespace __sancov {\n@@ -82,7 +82,8 @@ class TracePcGuardController final {\n   void TracePcGuard(u32 *guard, uptr pc) {\n     atomic_uint32_t *guard_ptr = reinterpret_cast<atomic_uint32_t *>(guard);\n     u32 idx = atomic_exchange(guard_ptr, 0, memory_order_relaxed);\n-    if (idx > 0) array_[idx] = pc;\n+    if (idx > 0)\n+      array_[idx] = pc;\n   }\n \n   void Dump() {\n@@ -140,6 +141,10 @@ class TracePcGuardController final {\n                         internal_getpid());\n       _zx_object_set_property(vmo_, ZX_PROP_NAME, vmo_name_,\n                               internal_strlen(vmo_name_));\n+      uint64_t size = DataSize();\n+      status = _zx_object_set_property(vmo_, ZX_PROP_VMO_CONTENT_SIZE, &size,\n+                                       sizeof(size));\n+      CHECK_EQ(status, ZX_OK);\n \n       // Map the largest possible view we might need into the VMO.  Later\n       // we might need to increase the VMO's size before we can use larger\n@@ -172,6 +177,10 @@ class TracePcGuardController final {\n \n       zx_status_t status = _zx_vmo_set_size(vmo_, DataSize());\n       CHECK_EQ(status, ZX_OK);\n+      uint64_t size = DataSize();\n+      status = _zx_object_set_property(vmo_, ZX_PROP_VMO_CONTENT_SIZE, &size,\n+                                       sizeof(size));\n+      CHECK_EQ(status, ZX_OK);\n \n       return first_index;\n     }\n@@ -204,13 +213,15 @@ SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(const uptr *pcs,\n }\n \n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_guard, u32 *guard) {\n-  if (!*guard) return;\n+  if (!*guard)\n+    return;\n   __sancov::pc_guard_controller.TracePcGuard(guard, GET_CALLER_PC() - 1);\n }\n \n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_guard_init,\n                              u32 *start, u32 *end) {\n-  if (start == end || *start) return;\n+  if (start == end || *start)\n+    return;\n   __sancov::pc_guard_controller.InitTracePcGuard(start, end);\n }\n "}, {"sha": "d7ab0c3d98c15b5f56ac7b3eaa6615dad8e67eff", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_interface.inc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -29,4 +29,5 @@ INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_pc_guard_init)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_pc_indir)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_switch)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_8bit_counters_init)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_bool_flag_init)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_pcs_init)"}, {"sha": "73ebeb5fa14add217a92fd83af3f25e54a7385bb", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep_new.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -207,6 +207,7 @@ SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_div8, void) {}\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_gep, void) {}\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_indir, void) {}\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_8bit_counters_init, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_bool_flag_init, void) {}\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_pcs_init, void) {}\n }  // extern \"C\"\n // Weak definition for code instrumented with -fsanitize-coverage=stack-depth"}, {"sha": "26681f0493d736258ed7db99867a14c0ed562bd0", "filename": "libsanitizer/sanitizer_common/sanitizer_file.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -87,8 +87,8 @@ bool IsAbsolutePath(const char *path);\n // The child process will close all fds after STDERR_FILENO\n // before passing control to a program.\n pid_t StartSubprocess(const char *filename, const char *const argv[],\n-                      fd_t stdin_fd = kInvalidFd, fd_t stdout_fd = kInvalidFd,\n-                      fd_t stderr_fd = kInvalidFd);\n+                      const char *const envp[], fd_t stdin_fd = kInvalidFd,\n+                      fd_t stdout_fd = kInvalidFd, fd_t stderr_fd = kInvalidFd);\n // Checks if specified process is still running\n bool IsProcessRunning(pid_t pid);\n // Waits for the process to finish and returns its exit code."}, {"sha": "9e274268bf2a613c40589820d939d99adc00dc7e", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.cpp", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -56,9 +56,16 @@ char *FlagParser::ll_strndup(const char *s, uptr n) {\n }\n \n void FlagParser::PrintFlagDescriptions() {\n+  char buffer[128];\n+  buffer[sizeof(buffer) - 1] = '\\0';\n   Printf(\"Available flags for %s:\\n\", SanitizerToolName);\n-  for (int i = 0; i < n_flags_; ++i)\n-    Printf(\"\\t%s\\n\\t\\t- %s\\n\", flags_[i].name, flags_[i].desc);\n+  for (int i = 0; i < n_flags_; ++i) {\n+    bool truncated = !(flags_[i].handler->Format(buffer, sizeof(buffer)));\n+    CHECK_EQ(buffer[sizeof(buffer) - 1], '\\0');\n+    const char *truncation_str = truncated ? \" Truncated\" : \"\";\n+    Printf(\"\\t%s\\n\\t\\t- %s (Current Value%s: %s)\\n\", flags_[i].name,\n+           flags_[i].desc, truncation_str, buffer);\n+  }\n }\n \n void FlagParser::fatal_error(const char *err) {"}, {"sha": "fac5dff3463337732626ba0d7c77db460cdb4dbc", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.h", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -22,9 +22,23 @@ namespace __sanitizer {\n class FlagHandlerBase {\n  public:\n   virtual bool Parse(const char *value) { return false; }\n+  // Write the C string representation of the current value (truncated to fit)\n+  // into the buffer of size `size`. Returns false if truncation occurred and\n+  // returns true otherwise.\n+  virtual bool Format(char *buffer, uptr size) {\n+    if (size > 0)\n+      buffer[0] = '\\0';\n+    return false;\n+  }\n \n  protected:\n   ~FlagHandlerBase() {}\n+\n+  inline bool FormatString(char *buffer, uptr size, const char *str_to_use) {\n+    uptr num_symbols_should_write =\n+        internal_snprintf(buffer, size, \"%s\", str_to_use);\n+    return num_symbols_should_write < size;\n+  }\n };\n \n template <typename T>\n@@ -34,6 +48,7 @@ class FlagHandler : public FlagHandlerBase {\n  public:\n   explicit FlagHandler(T *t) : t_(t) {}\n   bool Parse(const char *value) final;\n+  bool Format(char *buffer, uptr size) final;\n };\n \n inline bool ParseBool(const char *value, bool *b) {\n@@ -59,6 +74,11 @@ inline bool FlagHandler<bool>::Parse(const char *value) {\n   return false;\n }\n \n+template <>\n+inline bool FlagHandler<bool>::Format(char *buffer, uptr size) {\n+  return FormatString(buffer, size, *t_ ? \"true\" : \"false\");\n+}\n+\n template <>\n inline bool FlagHandler<HandleSignalMode>::Parse(const char *value) {\n   bool b;\n@@ -75,12 +95,23 @@ inline bool FlagHandler<HandleSignalMode>::Parse(const char *value) {\n   return false;\n }\n \n+template <>\n+inline bool FlagHandler<HandleSignalMode>::Format(char *buffer, uptr size) {\n+  uptr num_symbols_should_write = internal_snprintf(buffer, size, \"%d\", *t_);\n+  return num_symbols_should_write < size;\n+}\n+\n template <>\n inline bool FlagHandler<const char *>::Parse(const char *value) {\n   *t_ = value;\n   return true;\n }\n \n+template <>\n+inline bool FlagHandler<const char *>::Format(char *buffer, uptr size) {\n+  return FormatString(buffer, size, *t_);\n+}\n+\n template <>\n inline bool FlagHandler<int>::Parse(const char *value) {\n   const char *value_end;\n@@ -90,6 +121,12 @@ inline bool FlagHandler<int>::Parse(const char *value) {\n   return ok;\n }\n \n+template <>\n+inline bool FlagHandler<int>::Format(char *buffer, uptr size) {\n+  uptr num_symbols_should_write = internal_snprintf(buffer, size, \"%d\", *t_);\n+  return num_symbols_should_write < size;\n+}\n+\n template <>\n inline bool FlagHandler<uptr>::Parse(const char *value) {\n   const char *value_end;\n@@ -99,6 +136,12 @@ inline bool FlagHandler<uptr>::Parse(const char *value) {\n   return ok;\n }\n \n+template <>\n+inline bool FlagHandler<uptr>::Format(char *buffer, uptr size) {\n+  uptr num_symbols_should_write = internal_snprintf(buffer, size, \"%p\", *t_);\n+  return num_symbols_should_write < size;\n+}\n+\n template <>\n inline bool FlagHandler<s64>::Parse(const char *value) {\n   const char *value_end;\n@@ -108,6 +151,12 @@ inline bool FlagHandler<s64>::Parse(const char *value) {\n   return ok;\n }\n \n+template <>\n+inline bool FlagHandler<s64>::Format(char *buffer, uptr size) {\n+  uptr num_symbols_should_write = internal_snprintf(buffer, size, \"%lld\", *t_);\n+  return num_symbols_should_write < size;\n+}\n+\n class FlagParser {\n   static const int kMaxFlags = 200;\n   struct Flag {"}, {"sha": "684ee1e0b9995633ca91aa85f8df3ddcd4c77c65", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cpp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -75,11 +75,13 @@ void SubstituteForFlagValue(const char *s, char *out, uptr out_size) {\n class FlagHandlerInclude : public FlagHandlerBase {\n   FlagParser *parser_;\n   bool ignore_missing_;\n+  const char *original_path_;\n \n  public:\n   explicit FlagHandlerInclude(FlagParser *parser, bool ignore_missing)\n-      : parser_(parser), ignore_missing_(ignore_missing) {}\n+      : parser_(parser), ignore_missing_(ignore_missing), original_path_(\"\") {}\n   bool Parse(const char *value) final {\n+    original_path_ = value;\n     if (internal_strchr(value, '%')) {\n       char *buf = (char *)MmapOrDie(kMaxPathLength, \"FlagHandlerInclude\");\n       SubstituteForFlagValue(value, buf, kMaxPathLength);\n@@ -89,6 +91,12 @@ class FlagHandlerInclude : public FlagHandlerBase {\n     }\n     return parser_->ParseFile(value, ignore_missing_);\n   }\n+  bool Format(char *buffer, uptr size) {\n+    // Note `original_path_` isn't actually what's parsed due to `%`\n+    // substitutions. Printing the substituted path would require holding onto\n+    // mmap'ed memory.\n+    return FormatString(buffer, size, original_path_);\n+  }\n };\n \n void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {"}, {"sha": "82b227eab6dab73dbce734891a4a138dcb94da99", "filename": "libsanitizer/sanitizer_common/sanitizer_freebsd.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -19,11 +19,11 @@\n // x86-64 FreeBSD 9.2 and older define 'ucontext_t' incorrectly in\n // 32-bit mode.\n #if SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32)\n-# include <osreldate.h>\n-# if __FreeBSD_version <= 902001  // v9.2\n-#  include <link.h>\n-#  include <sys/param.h>\n-#  include <ucontext.h>\n+#include <osreldate.h>\n+#if __FreeBSD_version <= 902001  // v9.2\n+#include <link.h>\n+#include <sys/param.h>\n+#include <ucontext.h>\n \n namespace __sanitizer {\n \n@@ -68,8 +68,8 @@ typedef struct __xmcontext {\n } xmcontext_t;\n \n typedef struct __xucontext {\n-  sigset_t  uc_sigmask;\n-  xmcontext_t  uc_mcontext;\n+  sigset_t uc_sigmask;\n+  xmcontext_t uc_mcontext;\n \n   struct __ucontext *uc_link;\n   stack_t uc_stack;\n@@ -122,15 +122,16 @@ struct xdl_phdr_info {\n   void *dlpi_tls_data;\n };\n \n-typedef int (*__xdl_iterate_hdr_callback)(struct xdl_phdr_info*, size_t, void*);\n-typedef int xdl_iterate_phdr_t(__xdl_iterate_hdr_callback, void*);\n+typedef int (*__xdl_iterate_hdr_callback)(struct xdl_phdr_info *, size_t,\n+                                          void *);\n+typedef int xdl_iterate_phdr_t(__xdl_iterate_hdr_callback, void *);\n \n #define xdl_iterate_phdr(callback, param) \\\n-  (((xdl_iterate_phdr_t*) dl_iterate_phdr)((callback), (param)))\n+  (((xdl_iterate_phdr_t *)dl_iterate_phdr)((callback), (param)))\n \n }  // namespace __sanitizer\n \n-# endif  // __FreeBSD_version <= 902001\n+#endif  // __FreeBSD_version <= 902001\n #endif  // SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32)\n \n #endif  // SANITIZER_FREEBSD_H"}, {"sha": "6d1ad794677062b94d08f7ca69543a090d03254f", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -66,6 +66,10 @@ uptr internal_getpid() {\n   return pid;\n }\n \n+int internal_dlinfo(void *handle, int request, void *p) {\n+  UNIMPLEMENTED();\n+}\n+\n uptr GetThreadSelf() { return reinterpret_cast<uptr>(thrd_current()); }\n \n tid_t GetTid() { return GetThreadSelf(); }"}, {"sha": "96f9cde7ef1919c955477f31c69362011c962ec8", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -18,12 +18,18 @@\n #include \"sanitizer_common.h\"\n \n #include <zircon/sanitizer.h>\n+#include <zircon/syscalls/object.h>\n \n namespace __sanitizer {\n \n extern uptr MainThreadStackBase, MainThreadStackSize;\n extern sanitizer_shadow_bounds_t ShadowBounds;\n \n+struct MemoryMappingLayoutData {\n+  InternalMmapVector<zx_info_maps_t> data;\n+  size_t current;  // Current index into the vector.\n+};\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_FUCHSIA"}, {"sha": "576807ea3a6a1f4f0b409eaecfdb6fe3d4fd8c37", "filename": "libsanitizer/sanitizer_common/sanitizer_interceptors_ioctl_netbsd.inc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -24,7 +24,7 @@ struct ioctl_desc {\n   const char *name;\n };\n \n-const unsigned ioctl_table_max = 1236;\n+const unsigned ioctl_table_max = 1238;\n static ioctl_desc ioctl_table[ioctl_table_max];\n static unsigned ioctl_table_size = 0;\n \n@@ -166,9 +166,6 @@ static void ioctl_table_fill() {\n   _(FE_ENABLE_HIGH_LNB_VOLTAGE, READ, sizeof(int));\n   _(FE_SET_FRONTEND_TUNE_MODE, READ, sizeof(unsigned int));\n   _(FE_DISHNETWORK_SEND_LEGACY_CMD, READ, sizeof(unsigned long));\n-  /* Entries from file: dev/filemon/filemon.h */\n-  _(FILEMON_SET_FD, READWRITE, sizeof(int));\n-  _(FILEMON_SET_PID, READWRITE, sizeof(int));\n   /* Entries from file: dev/hdaudio/hdaudioio.h */\n   _(HDAUDIO_FGRP_INFO, READWRITE, struct_plistref_sz);\n   _(HDAUDIO_FGRP_GETCONFIG, READWRITE, struct_plistref_sz);\n@@ -449,9 +446,6 @@ static void ioctl_table_fill() {\n   _(STICIO_STOPQ, NONE, 0);\n   /* Entries from file: dev/usb/ukyopon.h */\n   _(UKYOPON_IDENTIFY, WRITE, struct_ukyopon_identify_sz);\n-  /* Entries from file: dev/usb/urio.h */\n-  _(URIO_SEND_COMMAND, READWRITE, struct_urio_command_sz);\n-  _(URIO_RECV_COMMAND, READWRITE, struct_urio_command_sz);\n   /* Entries from file: dev/usb/usb.h */\n   _(USB_REQUEST, READWRITE, struct_usb_ctl_request_sz);\n   _(USB_SETDEBUG, READ, sizeof(int));\n@@ -653,6 +647,7 @@ static void ioctl_table_fill() {\n   _(NVMM_IOC_MACHINE_CONFIGURE, READ, struct_nvmm_ioc_machine_configure_sz);\n   _(NVMM_IOC_VCPU_CREATE, READ, struct_nvmm_ioc_vcpu_create_sz);\n   _(NVMM_IOC_VCPU_DESTROY, READ, struct_nvmm_ioc_vcpu_destroy_sz);\n+  _(NVMM_IOC_VCPU_CONFIGURE, READ, struct_nvmm_ioc_vcpu_configure_sz);\n   _(NVMM_IOC_VCPU_SETSTATE, READ, struct_nvmm_ioc_vcpu_setstate_sz);\n   _(NVMM_IOC_VCPU_GETSTATE, READ, struct_nvmm_ioc_vcpu_getstate_sz);\n   _(NVMM_IOC_VCPU_INJECT, READ, struct_nvmm_ioc_vcpu_inject_sz);\n@@ -735,6 +730,7 @@ static void ioctl_table_fill() {\n   _(IOC_NPF_SAVE, WRITE, struct_nvlist_ref_sz);\n   _(IOC_NPF_RULE, READWRITE, struct_nvlist_ref_sz);\n   _(IOC_NPF_CONN_LOOKUP, READWRITE, struct_nvlist_ref_sz);\n+  _(IOC_NPF_TABLE_REPLACE, READWRITE, struct_nvlist_ref_sz);\n   /* Entries from file: net/if_pppoe.h */\n   _(PPPOESETPARMS, READ, struct_pppoediscparms_sz);\n   _(PPPOEGETPARMS, READWRITE, struct_pppoediscparms_sz);\n@@ -1403,8 +1399,14 @@ static void ioctl_table_fill() {\n   _(SNDCTL_DSP_SETRECVOL, READ, sizeof(unsigned int));\n   _(SNDCTL_DSP_SKIP, NONE, 0);\n   _(SNDCTL_DSP_SILENCE, NONE, 0);\n+  /* Entries from file: dev/filemon/filemon.h (compat <= 9.99.26) */\n+  _(FILEMON_SET_FD, READWRITE, sizeof(int));\n+  _(FILEMON_SET_PID, READWRITE, sizeof(int));\n+  /* Entries from file: dev/usb/urio.h (compat <= 9.99.43) */\n+  _(URIO_SEND_COMMAND, READWRITE, struct_urio_command_sz);\n+  _(URIO_RECV_COMMAND, READWRITE, struct_urio_command_sz);\n #undef _\n-}  // NOLINT\n+} // NOLINT\n \n static bool ioctl_initialized = false;\n "}, {"sha": "be8023e9e16ce86bf856ae5b9ffe297348a4f6d0", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -109,8 +109,10 @@ extern \"C\" {\n                                            __sanitizer::u32*);\n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n   void __sanitizer_cov_8bit_counters_init();\n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  void __sanitizer_cov_pcs_init();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+  __sanitizer_cov_bool_flag_init();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+  __sanitizer_cov_pcs_init();\n } // extern \"C\"\n \n #endif  // SANITIZER_INTERFACE_INTERNAL_H"}, {"sha": "d0ffc79b06107d72315a0bb4c1f1a9c7cfcb75c3", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -105,7 +105,7 @@\n // FIXME: do we have anything like this on Mac?\n #ifndef SANITIZER_CAN_USE_PREINIT_ARRAY\n #if ((SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_OPENBSD || \\\n-     SANITIZER_FUCHSIA) && !defined(PIC)\n+     SANITIZER_FUCHSIA || SANITIZER_NETBSD) && !defined(PIC)\n #define SANITIZER_CAN_USE_PREINIT_ARRAY 1\n // Before Solaris 11.4, .preinit_array is fully supported only with GNU ld.\n // FIXME: Check for those conditions."}, {"sha": "ec0a6ded009b0773d66d492375ed0831c9058b4c", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -72,6 +72,8 @@ unsigned int internal_sleep(unsigned int seconds);\n uptr internal_getpid();\n uptr internal_getppid();\n \n+int internal_dlinfo(void *handle, int request, void *p);\n+\n // Threading\n uptr internal_sched_yield();\n "}, {"sha": "2168301fd69d2261ea95a0a9497b417201cec7bf", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "modified", "additions": 136, "deletions": 15, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -26,7 +26,7 @@\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n \n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX && !SANITIZER_GO\n #include <asm/param.h>\n #endif\n \n@@ -166,7 +166,7 @@ namespace __sanitizer {\n #if !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n #if !SANITIZER_S390 && !SANITIZER_OPENBSD\n uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n-                   OFF_T offset) {\n+                   u64 offset) {\n #if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n   return internal_syscall(SYSCALL(mmap), (uptr)addr, length, prot, flags, fd,\n                           offset);\n@@ -552,13 +552,14 @@ const char *GetEnv(const char *name) {\n #endif\n }\n \n-#if !SANITIZER_FREEBSD && !SANITIZER_NETBSD && !SANITIZER_OPENBSD\n+#if !SANITIZER_FREEBSD && !SANITIZER_NETBSD && !SANITIZER_OPENBSD && \\\n+    !SANITIZER_GO\n extern \"C\" {\n SANITIZER_WEAK_ATTRIBUTE extern void *__libc_stack_end;\n }\n #endif\n \n-#if !SANITIZER_GO && !SANITIZER_FREEBSD && !SANITIZER_NETBSD &&                \\\n+#if !SANITIZER_FREEBSD && !SANITIZER_NETBSD &&                \\\n     !SANITIZER_OPENBSD\n static void ReadNullSepFileToArray(const char *path, char ***arr,\n                                    int arr_size) {\n@@ -604,16 +605,21 @@ static void GetArgsAndEnv(char ***argv, char ***envp) {\n #else // SANITIZER_FREEBSD\n #if !SANITIZER_GO\n   if (&__libc_stack_end) {\n-#endif // !SANITIZER_GO\n     uptr* stack_end = (uptr*)__libc_stack_end;\n-    int argc = *stack_end;\n+    // Normally argc can be obtained from *stack_end, however, on ARM glibc's\n+    // _start clobbers it:\n+    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/arm/start.S;hb=refs/heads/release/2.31/master#l75\n+    // Do not special-case ARM and infer argc from argv everywhere.\n+    int argc = 0;\n+    while (stack_end[argc + 1]) argc++;\n     *argv = (char**)(stack_end + 1);\n     *envp = (char**)(stack_end + argc + 2);\n-#if !SANITIZER_GO\n   } else {\n+#endif // !SANITIZER_GO\n     static const int kMaxArgv = 2000, kMaxEnvp = 2000;\n     ReadNullSepFileToArray(\"/proc/self/cmdline\", argv, kMaxArgv);\n     ReadNullSepFileToArray(\"/proc/self/environ\", envp, kMaxEnvp);\n+#if !SANITIZER_GO\n   }\n #endif // !SANITIZER_GO\n #endif // SANITIZER_FREEBSD\n@@ -735,6 +741,14 @@ uptr internal_getppid() {\n   return internal_syscall(SYSCALL(getppid));\n }\n \n+int internal_dlinfo(void *handle, int request, void *p) {\n+#if SANITIZER_FREEBSD\n+  return dlinfo(handle, request, p);\n+#else\n+  UNIMPLEMENTED();\n+#endif\n+}\n+\n uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count) {\n #if SANITIZER_FREEBSD\n   return internal_syscall(SYSCALL(getdirentries), fd, (uptr)dirp, count, NULL);\n@@ -1006,9 +1020,8 @@ static uptr GetKernelAreaSize() {\n   // is modified (e.g. under schroot) so check this as well.\n   struct utsname uname_info;\n   int pers = personality(0xffffffffUL);\n-  if (!(pers & PER_MASK)\n-      && uname(&uname_info) == 0\n-      && internal_strstr(uname_info.machine, \"64\"))\n+  if (!(pers & PER_MASK) && internal_uname(&uname_info) == 0 &&\n+      internal_strstr(uname_info.machine, \"64\"))\n     return 0;\n #endif  // SANITIZER_ANDROID\n \n@@ -1063,7 +1076,8 @@ uptr GetMaxUserVirtualAddress() {\n \n #if !SANITIZER_ANDROID\n uptr GetPageSize() {\n-#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))\n+#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__)) && \\\n+    defined(EXEC_PAGESIZE)\n   return EXEC_PAGESIZE;\n #elif SANITIZER_FREEBSD || SANITIZER_NETBSD\n // Use sysctl as sysconf can trigger interceptors internally.\n@@ -1619,6 +1633,12 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n }\n #endif  // defined(__x86_64__) && SANITIZER_LINUX\n \n+#if SANITIZER_LINUX\n+int internal_uname(struct utsname *buf) {\n+  return internal_syscall(SYSCALL(uname), buf);\n+}\n+#endif\n+\n #if SANITIZER_ANDROID\n #if __ANDROID_API__ < 21\n extern \"C\" __attribute__((weak)) int dl_iterate_phdr(\n@@ -1701,7 +1721,7 @@ HandleSignalMode GetHandleSignalMode(int signum) {\n }\n \n #if !SANITIZER_GO\n-void *internal_start_thread(void(*func)(void *arg), void *arg) {\n+void *internal_start_thread(void *(*func)(void *arg), void *arg) {\n   // Start the thread with signals blocked, otherwise it can steal user signals.\n   __sanitizer_sigset_t set, old;\n   internal_sigfillset(&set);\n@@ -1712,7 +1732,7 @@ void *internal_start_thread(void(*func)(void *arg), void *arg) {\n #endif\n   internal_sigprocmask(SIG_SETMASK, &set, &old);\n   void *th;\n-  real_pthread_create(&th, nullptr, (void*(*)(void *arg))func, arg);\n+  real_pthread_create(&th, nullptr, func, arg);\n   internal_sigprocmask(SIG_SETMASK, &old, nullptr);\n   return th;\n }\n@@ -1721,7 +1741,7 @@ void internal_join_thread(void *th) {\n   real_pthread_join(th, nullptr);\n }\n #else\n-void *internal_start_thread(void (*func)(void *), void *arg) { return 0; }\n+void *internal_start_thread(void *(*func)(void *), void *arg) { return 0; }\n \n void internal_join_thread(void *th) {}\n #endif\n@@ -1846,6 +1866,105 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n #endif\n   u32 instr = *(u32 *)pc;\n   return (instr >> 21) & 1 ? WRITE: READ;\n+#elif defined(__riscv)\n+  unsigned long pc = ucontext->uc_mcontext.__gregs[REG_PC];\n+  unsigned faulty_instruction = *(uint16_t *)pc;\n+\n+#if defined(__riscv_compressed)\n+  if ((faulty_instruction & 0x3) != 0x3) {  // it's a compressed instruction\n+    // set op_bits to the instruction bits [1, 0, 15, 14, 13]\n+    unsigned op_bits =\n+        ((faulty_instruction & 0x3) << 3) | (faulty_instruction >> 13);\n+    unsigned rd = faulty_instruction & 0xF80;  // bits 7-11, inclusive\n+    switch (op_bits) {\n+      case 0b10'010:  // c.lwsp (rd != x0)\n+#if __riscv_xlen == 64\n+      case 0b10'011:  // c.ldsp (rd != x0)\n+#endif\n+        return rd ? SignalContext::READ : SignalContext::UNKNOWN;\n+      case 0b00'010:  // c.lw\n+#if __riscv_flen >= 32 && __riscv_xlen == 32\n+      case 0b10'011:  // c.flwsp\n+#endif\n+#if __riscv_flen >= 32 || __riscv_xlen == 64\n+      case 0b00'011:  // c.flw / c.ld\n+#endif\n+#if __riscv_flen == 64\n+      case 0b00'001:  // c.fld\n+      case 0b10'001:  // c.fldsp\n+#endif\n+        return SignalContext::READ;\n+      case 0b00'110:  // c.sw\n+      case 0b10'110:  // c.swsp\n+#if __riscv_flen >= 32 || __riscv_xlen == 64\n+      case 0b00'111:  // c.fsw / c.sd\n+      case 0b10'111:  // c.fswsp / c.sdsp\n+#endif\n+#if __riscv_flen == 64\n+      case 0b00'101:  // c.fsd\n+      case 0b10'101:  // c.fsdsp\n+#endif\n+        return SignalContext::WRITE;\n+      default:\n+        return SignalContext::UNKNOWN;\n+    }\n+  }\n+#endif\n+\n+  unsigned opcode = faulty_instruction & 0x7f;         // lower 7 bits\n+  unsigned funct3 = (faulty_instruction >> 12) & 0x7;  // bits 12-14, inclusive\n+  switch (opcode) {\n+    case 0b0000011:  // loads\n+      switch (funct3) {\n+        case 0b000:  // lb\n+        case 0b001:  // lh\n+        case 0b010:  // lw\n+#if __riscv_xlen == 64\n+        case 0b011:  // ld\n+#endif\n+        case 0b100:  // lbu\n+        case 0b101:  // lhu\n+          return SignalContext::READ;\n+        default:\n+          return SignalContext::UNKNOWN;\n+      }\n+    case 0b0100011:  // stores\n+      switch (funct3) {\n+        case 0b000:  // sb\n+        case 0b001:  // sh\n+        case 0b010:  // sw\n+#if __riscv_xlen == 64\n+        case 0b011:  // sd\n+#endif\n+          return SignalContext::WRITE;\n+        default:\n+          return SignalContext::UNKNOWN;\n+      }\n+#if __riscv_flen >= 32\n+    case 0b0000111:  // floating-point loads\n+      switch (funct3) {\n+        case 0b010:  // flw\n+#if __riscv_flen == 64\n+        case 0b011:  // fld\n+#endif\n+          return SignalContext::READ;\n+        default:\n+          return SignalContext::UNKNOWN;\n+      }\n+    case 0b0100111:  // floating-point stores\n+      switch (funct3) {\n+        case 0b010:  // fsw\n+#if __riscv_flen == 64\n+        case 0b011:  // fsd\n+#endif\n+          return SignalContext::WRITE;\n+        default:\n+          return SignalContext::UNKNOWN;\n+      }\n+#endif\n+    default:\n+      return SignalContext::UNKNOWN;\n+  }\n #else\n   (void)ucontext;\n   return UNKNOWN;  // FIXME: Implement.\n@@ -2011,7 +2130,9 @@ void CheckASLR() {\n   }\n \n   if (UNLIKELY(paxflags & CTL_PROC_PAXFLAGS_ASLR)) {\n-    Printf(\"This sanitizer is not compatible with enabled ASLR\\n\");\n+    Printf(\"This sanitizer is not compatible with enabled ASLR.\\n\"\n+           \"To disable ASLR, please run \\\"paxctl +a %s\\\" and try again.\\n\",\n+           GetArgv()[0]);\n     Die();\n   }\n #elif SANITIZER_PPC64V2"}, {"sha": "c162d1ca5d2851fabf422d593523ab43de321250", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -25,6 +25,7 @@\n #include \"sanitizer_posix.h\"\n \n struct link_map;  // Opaque type returned by dlopen().\n+struct utsname;\n \n namespace __sanitizer {\n // Dirent structure for getdents(). Note that this structure is different from\n@@ -65,6 +66,7 @@ void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr);\n #endif\n+int internal_uname(struct utsname *buf);\n #elif SANITIZER_FREEBSD\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n #elif SANITIZER_NETBSD"}, {"sha": "4d17c9686e4ed25bc8cd6771f5087d14f7be82dd", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -35,6 +35,10 @@\n #include <sys/resource.h>\n #include <syslog.h>\n \n+#if !defined(ElfW)\n+#define ElfW(type) Elf_##type\n+#endif\n+\n #if SANITIZER_FREEBSD\n #include <pthread_np.h>\n #include <osreldate.h>\n@@ -50,6 +54,7 @@\n #if SANITIZER_NETBSD\n #include <sys/sysctl.h>\n #include <sys/tls.h>\n+#include <lwp.h>\n #endif\n \n #if SANITIZER_SOLARIS\n@@ -399,13 +404,7 @@ uptr ThreadSelf() {\n \n #if SANITIZER_NETBSD\n static struct tls_tcb * ThreadSelfTlsTcb() {\n-  struct tls_tcb * tcb;\n-# ifdef __HAVE___LWP_GETTCB_FAST\n-  tcb = (struct tls_tcb *)__lwp_gettcb_fast();\n-# elif defined(__HAVE___LWP_GETPRIVATE_FAST)\n-  tcb = (struct tls_tcb *)__lwp_getprivate_fast();\n-# endif\n-  return tcb;\n+  return (struct tls_tcb *)_lwp_getprivate();\n }\n \n uptr ThreadSelf() {\n@@ -698,13 +697,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n "}, {"sha": "bb2f5b5f9f7df1309a9519c25ed0c86d76ed8c7a", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_s390.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -15,19 +15,20 @@\n \n #if SANITIZER_LINUX && SANITIZER_S390\n \n-#include \"sanitizer_libc.h\"\n-#include \"sanitizer_linux.h\"\n-\n+#include <dlfcn.h>\n #include <errno.h>\n #include <sys/syscall.h>\n #include <sys/utsname.h>\n #include <unistd.h>\n \n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_linux.h\"\n+\n namespace __sanitizer {\n \n // --------------- sanitizer_libc.h\n uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n-                   OFF_T offset) {\n+                   u64 offset) {\n   struct s390_mmap_params {\n     unsigned long addr;\n     unsigned long length;\n@@ -123,7 +124,7 @@ static bool FixedCVE_2016_2143() {\n   struct utsname buf;\n   unsigned int major, minor, patch = 0;\n   // This should never fail, but just in case...\n-  if (uname(&buf))\n+  if (internal_uname(&buf))\n     return false;\n   const char *ptr = buf.release;\n   major = internal_simple_strtoll(ptr, &ptr, 10);"}, {"sha": "7550545ea6fa2fccac96b16f20f63577292c1278", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -30,14 +30,15 @@\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n #include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_ptrauth.h\"\n \n #if !SANITIZER_IOS\n #include <crt_externs.h>  // for _NSGetEnviron\n #else\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -208,6 +209,10 @@ uptr internal_getpid() {\n   return getpid();\n }\n \n+int internal_dlinfo(void *handle, int request, void *p) {\n+  UNIMPLEMENTED();\n+}\n+\n int internal_sigaction(int signum, const void *act, void *oldact) {\n   return sigaction(signum,\n                    (const struct sigaction *)act, (struct sigaction *)oldact);\n@@ -242,7 +247,8 @@ int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n                       (size_t)newlen);\n }\n \n-static fd_t internal_spawn_impl(const char *argv[], pid_t *pid) {\n+static fd_t internal_spawn_impl(const char *argv[], const char *envp[],\n+                                pid_t *pid) {\n   fd_t master_fd = kInvalidFd;\n   fd_t slave_fd = kInvalidFd;\n \n@@ -298,8 +304,8 @@ static fd_t internal_spawn_impl(const char *argv[], pid_t *pid) {\n \n   // posix_spawn\n   char **argv_casted = const_cast<char **>(argv);\n-  char **env = GetEnviron();\n-  res = posix_spawn(pid, argv[0], &acts, &attrs, argv_casted, env);\n+  char **envp_casted = const_cast<char **>(envp);\n+  res = posix_spawn(pid, argv[0], &acts, &attrs, argv_casted, envp_casted);\n   if (res != 0) return kInvalidFd;\n \n   // Disable echo in the new terminal, disable CR.\n@@ -316,7 +322,7 @@ static fd_t internal_spawn_impl(const char *argv[], pid_t *pid) {\n   return fd;\n }\n \n-fd_t internal_spawn(const char *argv[], pid_t *pid) {\n+fd_t internal_spawn(const char *argv[], const char *envp[], pid_t *pid) {\n   // The client program may close its stdin and/or stdout and/or stderr thus\n   // allowing open/posix_openpt to reuse file descriptors 0, 1 or 2. In this\n   // case the communication is broken if either the parent or the child tries to\n@@ -331,7 +337,7 @@ fd_t internal_spawn(const char *argv[], pid_t *pid) {\n       break;\n   }\n \n-  fd_t fd = internal_spawn_impl(argv, pid);\n+  fd_t fd = internal_spawn_impl(argv, envp, pid);\n \n   for (; count > 0; count--) {\n     internal_close(low_fds[count]);\n@@ -623,19 +629,13 @@ MacosVersion GetMacosVersionInternal() {\n   if (*p != '.') return MACOS_VERSION_UNKNOWN;\n \n   switch (major) {\n-    case 9: return MACOS_VERSION_LEOPARD;\n-    case 10: return MACOS_VERSION_SNOW_LEOPARD;\n     case 11: return MACOS_VERSION_LION;\n     case 12: return MACOS_VERSION_MOUNTAIN_LION;\n     case 13: return MACOS_VERSION_MAVERICKS;\n     case 14: return MACOS_VERSION_YOSEMITE;\n     case 15: return MACOS_VERSION_EL_CAPITAN;\n     case 16: return MACOS_VERSION_SIERRA;\n-    case 17:\n-      // Not a typo, 17.5 Darwin Kernel Version maps to High Sierra 10.13.4.\n-      if (minor >= 5)\n-        return MACOS_VERSION_HIGH_SIERRA_DOT_RELEASE_4;\n-      return MACOS_VERSION_HIGH_SIERRA;\n+    case 17: return MACOS_VERSION_HIGH_SIERRA;\n     case 18: return MACOS_VERSION_MOJAVE;\n     case 19: return MACOS_VERSION_CATALINA;\n     default:\n@@ -656,13 +656,21 @@ MacosVersion GetMacosVersion() {\n   return result;\n }\n \n-bool PlatformHasDifferentMemcpyAndMemmove() {\n-  // On OS X 10.7 memcpy() and memmove() are both resolved\n-  // into memmove$VARIANT$sse42.\n-  // See also https://github.com/google/sanitizers/issues/34.\n-  // TODO(glider): need to check dynamically that memcpy() and memmove() are\n-  // actually the same function.\n-  return GetMacosVersion() == MACOS_VERSION_SNOW_LEOPARD;\n+DarwinKernelVersion GetDarwinKernelVersion() {\n+  char buf[100];\n+  size_t len = sizeof(buf);\n+  int res = internal_sysctlbyname(\"kern.osrelease\", buf, &len, nullptr, 0);\n+  CHECK_EQ(res, 0);\n+\n+  // Format: <major>.<minor>.<patch>\\0\n+  CHECK_GE(len, 6);\n+  const char *p = buf;\n+  u16 major = internal_simple_strtoll(p, &p, /*base=*/10);\n+  CHECK_EQ(*p, '.');\n+  p += 1;\n+  u16 minor = internal_simple_strtoll(p, &p, /*base=*/10);\n+\n+  return DarwinKernelVersion(major, minor);\n }\n \n uptr GetRSS() {\n@@ -677,13 +685,13 @@ uptr GetRSS() {\n   return info.resident_size;\n }\n \n-void *internal_start_thread(void(*func)(void *arg), void *arg) {\n+void *internal_start_thread(void *(*func)(void *arg), void *arg) {\n   // Start the thread with signals blocked, otherwise it can steal user signals.\n   __sanitizer_sigset_t set, old;\n   internal_sigfillset(&set);\n   internal_sigprocmask(SIG_SETMASK, &set, &old);\n   pthread_t th;\n-  pthread_create(&th, 0, (void*(*)(void *arg))func, arg);\n+  pthread_create(&th, 0, func, arg);\n   internal_sigprocmask(SIG_SETMASK, &old, 0);\n   return th;\n }\n@@ -760,16 +768,24 @@ bool SignalContext::IsTrueFaultingAddress() const {\n   return si->si_signo == SIGSEGV && si->si_code != 0;\n }\n \n+#if defined(__aarch64__) && defined(arm_thread_state64_get_sp)\n+  #define AARCH64_GET_REG(r) \\\n+    (uptr)ptrauth_strip(     \\\n+        (void *)arm_thread_state64_get_##r(ucontext->uc_mcontext->__ss), 0)\n+#else\n+  #define AARCH64_GET_REG(r) ucontext->uc_mcontext->__ss.__##r\n+#endif\n+\n static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   ucontext_t *ucontext = (ucontext_t*)context;\n # if defined(__aarch64__)\n-  *pc = ucontext->uc_mcontext->__ss.__pc;\n+  *pc = AARCH64_GET_REG(pc);\n #   if defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_8_0\n-  *bp = ucontext->uc_mcontext->__ss.__fp;\n+  *bp = AARCH64_GET_REG(fp);\n #   else\n-  *bp = ucontext->uc_mcontext->__ss.__lr;\n+  *bp = AARCH64_GET_REG(lr);\n #   endif\n-  *sp = ucontext->uc_mcontext->__ss.__sp;\n+  *sp = AARCH64_GET_REG(sp);\n # elif defined(__x86_64__)\n   *pc = ucontext->uc_mcontext->__ss.__rip;\n   *bp = ucontext->uc_mcontext->__ss.__rbp;\n@@ -787,13 +803,16 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n # endif\n }\n \n-void SignalContext::InitPcSpBp() { GetPcSpBp(context, &pc, &sp, &bp); }\n+void SignalContext::InitPcSpBp() {\n+  addr = (uptr)ptrauth_strip((void *)addr, 0);\n+  GetPcSpBp(context, &pc, &sp, &bp);\n+}\n \n void InitializePlatformEarly() {\n-  // Only use xnu_fast_mmap when on x86_64 and the OS supports it.\n+  // Only use xnu_fast_mmap when on x86_64 and the kernel supports it.\n   use_xnu_fast_mmap =\n #if defined(__x86_64__)\n-      GetMacosVersion() >= MACOS_VERSION_HIGH_SIERRA_DOT_RELEASE_4;\n+      GetDarwinKernelVersion() >= DarwinKernelVersion(17, 5);\n #else\n       false;\n #endif\n@@ -1123,6 +1142,8 @@ void SignalContext::DumpAllRegisters(void *context) {\n   ucontext_t *ucontext = (ucontext_t*)context;\n # define DUMPREG64(r) \\\n     Printf(\"%s = 0x%016llx  \", #r, ucontext->uc_mcontext->__ss.__ ## r);\n+# define DUMPREGA64(r) \\\n+    Printf(\"   %s = 0x%016llx  \", #r, AARCH64_GET_REG(r));\n # define DUMPREG32(r) \\\n     Printf(\"%s = 0x%08x  \", #r, ucontext->uc_mcontext->__ss.__ ## r);\n # define DUMPREG_(r)   Printf(\" \"); DUMPREG(r);\n@@ -1148,7 +1169,7 @@ void SignalContext::DumpAllRegisters(void *context) {\n   DUMPREG(x[16]); DUMPREG(x[17]); DUMPREG(x[18]); DUMPREG(x[19]); Printf(\"\\n\");\n   DUMPREG(x[20]); DUMPREG(x[21]); DUMPREG(x[22]); DUMPREG(x[23]); Printf(\"\\n\");\n   DUMPREG(x[24]); DUMPREG(x[25]); DUMPREG(x[26]); DUMPREG(x[27]); Printf(\"\\n\");\n-  DUMPREG(x[28]); DUMPREG___(fp); DUMPREG___(lr); DUMPREG___(sp); Printf(\"\\n\");\n+  DUMPREG(x[28]); DUMPREGA64(fp); DUMPREGA64(lr); DUMPREGA64(sp); Printf(\"\\n\");\n # elif defined(__arm__)\n #  define DUMPREG(r) DUMPREG32(r)\n   DUMPREG_(r[0]); DUMPREG_(r[1]); DUMPREG_(r[2]); DUMPREG_(r[3]); Printf(\"\\n\");"}, {"sha": "34dc2c05dcf4b7cae1b544d507ba2103681a663b", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -33,22 +33,35 @@ struct MemoryMappingLayoutData {\n enum MacosVersion {\n   MACOS_VERSION_UNINITIALIZED = 0,\n   MACOS_VERSION_UNKNOWN,\n-  MACOS_VERSION_LEOPARD,\n-  MACOS_VERSION_SNOW_LEOPARD,\n-  MACOS_VERSION_LION,\n+  MACOS_VERSION_LION,  // macOS 10.7; oldest currently supported\n   MACOS_VERSION_MOUNTAIN_LION,\n   MACOS_VERSION_MAVERICKS,\n   MACOS_VERSION_YOSEMITE,\n   MACOS_VERSION_EL_CAPITAN,\n   MACOS_VERSION_SIERRA,\n   MACOS_VERSION_HIGH_SIERRA,\n-  MACOS_VERSION_HIGH_SIERRA_DOT_RELEASE_4,\n   MACOS_VERSION_MOJAVE,\n   MACOS_VERSION_CATALINA,\n   MACOS_VERSION_UNKNOWN_NEWER\n };\n \n+struct DarwinKernelVersion {\n+  u16 major;\n+  u16 minor;\n+\n+  DarwinKernelVersion(u16 major, u16 minor) : major(major), minor(minor) {}\n+\n+  bool operator==(const DarwinKernelVersion &other) const {\n+    return major == other.major && minor == other.minor;\n+  }\n+  bool operator>=(const DarwinKernelVersion &other) const {\n+    return major >= other.major ||\n+           (major == other.major && minor >= other.minor);\n+  }\n+};\n+\n MacosVersion GetMacosVersion();\n+DarwinKernelVersion GetDarwinKernelVersion();\n \n char **GetEnviron();\n "}, {"sha": "647bcdfe105e66633aed488b20b54904d1dd01b7", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -61,12 +61,10 @@ INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n   malloc_zone_t *new_zone = (malloc_zone_t *)p;\n   internal_memcpy(new_zone, &sanitizer_zone, sizeof(sanitizer_zone));\n   new_zone->zone_name = NULL;  // The name will be changed anyway.\n-  if (GetMacosVersion() >= MACOS_VERSION_LION) {\n-    // Prevent the client app from overwriting the zone contents.\n-    // Library functions that need to modify the zone will set PROT_WRITE on it.\n-    // This matches the behavior of malloc_create_zone() on OSX 10.7 and higher.\n-    mprotect(new_zone, allocated_size, PROT_READ);\n-  }\n+  // Prevent the client app from overwriting the zone contents.\n+  // Library functions that need to modify the zone will set PROT_WRITE on it.\n+  // This matches the behavior of malloc_create_zone() on OSX 10.7 and higher.\n+  mprotect(new_zone, allocated_size, PROT_READ);\n   // We're explicitly *NOT* registering the zone.\n   return new_zone;\n }\n@@ -75,11 +73,9 @@ INTERCEPTOR(void, malloc_destroy_zone, malloc_zone_t *zone) {\n   COMMON_MALLOC_ENTER();\n   // We don't need to do anything here.  We're not registering new zones, so we\n   // don't to unregister.  Just un-mprotect and free() the zone.\n-  if (GetMacosVersion() >= MACOS_VERSION_LION) {\n-    uptr page_size = GetPageSizeCached();\n-    uptr allocated_size = RoundUpTo(sizeof(sanitizer_zone), page_size);\n-    mprotect(zone, allocated_size, PROT_READ | PROT_WRITE);\n-  }\n+  uptr page_size = GetPageSizeCached();\n+  uptr allocated_size = RoundUpTo(sizeof(sanitizer_zone), page_size);\n+  mprotect(zone, allocated_size, PROT_READ | PROT_WRITE);\n   if (zone->zone_name) {\n     COMMON_MALLOC_FREE((void *)zone->zone_name);\n   }"}, {"sha": "d9aff51d8ae793a9a50ef38b2baff802da62b2bb", "filename": "libsanitizer/sanitizer_common/sanitizer_netbsd.cpp", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -95,7 +95,7 @@ static void *GetRealLibcAddress(const char *symbol) {\n \n // --------------- sanitizer_libc.h\n uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n-                   OFF_T offset) {\n+                   u64 offset) {\n   CHECK(&__mmap);\n   return (uptr)__mmap(addr, length, prot, flags, fd, 0, offset);\n }\n@@ -265,6 +265,11 @@ uptr internal_getppid() {\n   return _REAL(getppid);\n }\n \n+int internal_dlinfo(void *handle, int request, void *p) {\n+  DEFINE__REAL(int, dlinfo, void *a, int b, void *c);\n+  return _REAL(dlinfo, handle, request, p);\n+}\n+\n uptr internal_getdents(fd_t fd, void *dirp, unsigned int count) {\n   DEFINE__REAL(int, __getdents30, int a, void *b, size_t c);\n   return _REAL(__getdents30, fd, dirp, count);"}, {"sha": "9dd6d285f594034d44d78a325ea7a24279f0d5df", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -90,6 +90,24 @@\n # define SI_IOS 0\n #endif\n \n+#if SANITIZER_IOSSIM\n+# define SI_IOSSIM 1\n+#else\n+# define SI_IOSSIM 0\n+#endif\n+\n+#if SANITIZER_WATCHOS\n+# define SI_WATCHOS 1\n+#else\n+# define SI_WATCHOS 0\n+#endif\n+\n+#if SANITIZER_TVOS\n+# define SI_TVOS 1\n+#else\n+# define SI_TVOS 0\n+#endif\n+\n #if SANITIZER_FUCHSIA\n # define SI_NOT_FUCHSIA 0\n #else\n@@ -575,5 +593,11 @@\n #define SANITIZER_INTERCEPT_ATEXIT SI_NETBSD\n #define SANITIZER_INTERCEPT_PTHREAD_ATFORK SI_NETBSD\n #define SANITIZER_INTERCEPT_GETENTROPY SI_FREEBSD\n+#define SANITIZER_INTERCEPT_QSORT \\\n+  (SI_POSIX && !SI_IOSSIM && !SI_WATCHOS && !SI_TVOS && !SI_ANDROID)\n+#define SANITIZER_INTERCEPT_QSORT_R (SI_LINUX && !SI_ANDROID)\n+#define SANITIZER_INTERCEPT_SIGALTSTACK SI_POSIX\n+#define SANITIZER_INTERCEPT_UNAME (SI_POSIX && !SI_FREEBSD)\n+#define SANITIZER_INTERCEPT___XUNAME SI_FREEBSD\n \n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "dcc6c71c07d8ae7873c7903761d8537e4bfe7d11", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.cpp", "status": "modified", "additions": 310, "deletions": 304, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -15,342 +15,348 @@\n \n #if SANITIZER_FREEBSD\n \n+#include <sys/capsicum.h>\n+#include <sys/consio.h>\n+#include <sys/filio.h>\n+#include <sys/ipc.h>\n+#include <sys/kbio.h>\n+#include <sys/link_elf.h>\n+#include <sys/mman.h>\n+#include <sys/mount.h>\n+#include <sys/mqueue.h>\n+#include <sys/msg.h>\n+#include <sys/mtio.h>\n+#include <sys/ptrace.h>\n+#include <sys/resource.h>\n+#include <sys/signal.h>\n+#include <sys/socket.h>\n+#include <sys/sockio.h>\n+#include <sys/soundcard.h>\n+#include <sys/stat.h>\n+#include <sys/statvfs.h>\n+#include <sys/time.h>\n+#include <sys/timeb.h>\n+#include <sys/times.h>\n+#include <sys/timespec.h>\n+#include <sys/types.h>\n+#include <sys/ucontext.h>\n+#include <sys/utsname.h>\n+//\n #include <arpa/inet.h>\n+#include <net/ethernet.h>\n+#include <net/if.h>\n+#include <net/ppp_defs.h>\n+#include <net/route.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/ip_mroute.h>\n+//\n #include <dirent.h>\n-#include <fts.h>\n+#include <dlfcn.h>\n #include <fstab.h>\n+#include <fts.h>\n+#include <glob.h>\n #include <grp.h>\n+#include <ifaddrs.h>\n #include <limits.h>\n-#include <net/if.h>\n-#include <netdb.h>\n #include <poll.h>\n #include <pthread.h>\n #include <pwd.h>\n #include <regex.h>\n+#include <semaphore.h>\n #include <signal.h>\n #include <stddef.h>\n-#include <sys/mman.h>\n-#include <sys/capsicum.h>\n-#include <sys/resource.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/times.h>\n-#include <sys/types.h>\n-#include <sys/utsname.h>\n-#include <termios.h>\n-#include <time.h>\n-\n-#include <net/route.h>\n-#include <sys/mount.h>\n-#include <sys/sockio.h>\n-#include <sys/socket.h>\n-#include <sys/filio.h>\n-#include <sys/signal.h>\n-#include <sys/timespec.h>\n-#include <sys/timeb.h>\n-#include <sys/mqueue.h>\n-#include <sys/msg.h>\n-#include <sys/ipc.h>\n-#include <sys/msg.h>\n-#include <sys/statvfs.h>\n-#include <sys/soundcard.h>\n-#include <sys/mtio.h>\n-#include <sys/consio.h>\n-#include <sys/kbio.h>\n-#include <sys/link_elf.h>\n-#include <netinet/ip_mroute.h>\n-#include <netinet/in.h>\n-#include <net/ethernet.h>\n-#include <net/ppp_defs.h>\n-#include <glob.h>\n #include <stdio.h>\n #include <stringlist.h>\n #include <term.h>\n+#include <termios.h>\n+#include <time.h>\n+#include <utime.h>\n #include <utmpx.h>\n-#include <wchar.h>\n #include <vis.h>\n+#include <wchar.h>\n+#include <wordexp.h>\n \n #define _KERNEL  // to declare 'shminfo' structure\n-# include <sys/shm.h>\n+#include <sys/shm.h>\n #undef _KERNEL\n \n #undef INLINE  // to avoid clashes with sanitizers' definitions\n \n #undef IOC_DIRMASK\n \n-# include <utime.h>\n-# include <sys/ptrace.h>\n-# include <semaphore.h>\n-\n-#include <ifaddrs.h>\n-#include <sys/ucontext.h>\n-#include <wordexp.h>\n-\n // Include these after system headers to avoid name clashes and ambiguities.\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n #include \"sanitizer_platform_limits_freebsd.h\"\n \n namespace __sanitizer {\n-  unsigned struct_cap_rights_sz = sizeof(cap_rights_t);\n-  unsigned struct_utsname_sz = sizeof(struct utsname);\n-  unsigned struct_stat_sz = sizeof(struct stat);\n-  unsigned struct_rusage_sz = sizeof(struct rusage);\n-  unsigned struct_tm_sz = sizeof(struct tm);\n-  unsigned struct_passwd_sz = sizeof(struct passwd);\n-  unsigned struct_group_sz = sizeof(struct group);\n-  unsigned siginfo_t_sz = sizeof(siginfo_t);\n-  unsigned struct_sigaction_sz = sizeof(struct sigaction);\n-  unsigned struct_itimerval_sz = sizeof(struct itimerval);\n-  unsigned pthread_t_sz = sizeof(pthread_t);\n-  unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);\n-  unsigned pthread_cond_t_sz = sizeof(pthread_cond_t);\n-  unsigned pid_t_sz = sizeof(pid_t);\n-  unsigned timeval_sz = sizeof(timeval);\n-  unsigned uid_t_sz = sizeof(uid_t);\n-  unsigned gid_t_sz = sizeof(gid_t);\n-  unsigned fpos_t_sz = sizeof(fpos_t);\n-  unsigned mbstate_t_sz = sizeof(mbstate_t);\n-  unsigned sigset_t_sz = sizeof(sigset_t);\n-  unsigned struct_timezone_sz = sizeof(struct timezone);\n-  unsigned struct_tms_sz = sizeof(struct tms);\n-  unsigned struct_sigevent_sz = sizeof(struct sigevent);\n-  unsigned struct_sched_param_sz = sizeof(struct sched_param);\n-  unsigned struct_statfs_sz = sizeof(struct statfs);\n-  unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n-  unsigned ucontext_t_sz = sizeof(ucontext_t);\n-  unsigned struct_rlimit_sz = sizeof(struct rlimit);\n-  unsigned struct_timespec_sz = sizeof(struct timespec);\n-  unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n-  unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n-  unsigned struct_timeb_sz = sizeof(struct timeb);\n-  unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n-  unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n-  unsigned struct_statvfs_sz = sizeof(struct statvfs);\n-  unsigned struct_shminfo_sz = sizeof(struct shminfo);\n-  unsigned struct_shm_info_sz = sizeof(struct shm_info);\n-  unsigned struct_regmatch_sz = sizeof(regmatch_t);\n-  unsigned struct_regex_sz = sizeof(regex_t);\n-  unsigned struct_fstab_sz = sizeof(struct fstab);\n-  unsigned struct_FTS_sz = sizeof(FTS);\n-  unsigned struct_FTSENT_sz = sizeof(FTSENT);\n-  unsigned struct_StringList_sz = sizeof(StringList);\n-\n-  const uptr sig_ign = (uptr)SIG_IGN;\n-  const uptr sig_dfl = (uptr)SIG_DFL;\n-  const uptr sig_err = (uptr)SIG_ERR;\n-  const uptr sa_siginfo = (uptr)SA_SIGINFO;\n-\n-  int shmctl_ipc_stat = (int)IPC_STAT;\n-  int shmctl_ipc_info = (int)IPC_INFO;\n-  int shmctl_shm_info = (int)SHM_INFO;\n-  int shmctl_shm_stat = (int)SHM_STAT;\n-  unsigned struct_utmpx_sz = sizeof(struct utmpx);\n-\n-  int map_fixed = MAP_FIXED;\n-\n-  int af_inet = (int)AF_INET;\n-  int af_inet6 = (int)AF_INET6;\n-\n-  uptr __sanitizer_in_addr_sz(int af) {\n-    if (af == AF_INET)\n-      return sizeof(struct in_addr);\n-    else if (af == AF_INET6)\n-      return sizeof(struct in6_addr);\n-    else\n-      return 0;\n-  }\n-\n-  unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n-  int glob_nomatch = GLOB_NOMATCH;\n-  int glob_altdirfunc = GLOB_ALTDIRFUNC;\n-\n-  unsigned path_max = PATH_MAX;\n-\n-  // ioctl arguments\n-  unsigned struct_ifreq_sz = sizeof(struct ifreq);\n-  unsigned struct_termios_sz = sizeof(struct termios);\n-  unsigned struct_winsize_sz = sizeof(struct winsize);\n+void *__sanitizer_get_link_map_by_dlopen_handle(void *handle) {\n+  void *p = nullptr;\n+  return internal_dlinfo(handle, RTLD_DI_LINKMAP, &p) == 0 ? p : nullptr;\n+}\n+\n+unsigned struct_cap_rights_sz = sizeof(cap_rights_t);\n+unsigned struct_utsname_sz = sizeof(struct utsname);\n+unsigned struct_stat_sz = sizeof(struct stat);\n+unsigned struct_rusage_sz = sizeof(struct rusage);\n+unsigned struct_tm_sz = sizeof(struct tm);\n+unsigned struct_passwd_sz = sizeof(struct passwd);\n+unsigned struct_group_sz = sizeof(struct group);\n+unsigned siginfo_t_sz = sizeof(siginfo_t);\n+unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+unsigned struct_stack_t_sz = sizeof(stack_t);\n+unsigned struct_itimerval_sz = sizeof(struct itimerval);\n+unsigned pthread_t_sz = sizeof(pthread_t);\n+unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);\n+unsigned pthread_cond_t_sz = sizeof(pthread_cond_t);\n+unsigned pid_t_sz = sizeof(pid_t);\n+unsigned timeval_sz = sizeof(timeval);\n+unsigned uid_t_sz = sizeof(uid_t);\n+unsigned gid_t_sz = sizeof(gid_t);\n+unsigned fpos_t_sz = sizeof(fpos_t);\n+unsigned mbstate_t_sz = sizeof(mbstate_t);\n+unsigned sigset_t_sz = sizeof(sigset_t);\n+unsigned struct_timezone_sz = sizeof(struct timezone);\n+unsigned struct_tms_sz = sizeof(struct tms);\n+unsigned struct_sigevent_sz = sizeof(struct sigevent);\n+unsigned struct_sched_param_sz = sizeof(struct sched_param);\n+unsigned struct_statfs_sz = sizeof(struct statfs);\n+unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n+unsigned ucontext_t_sz = sizeof(ucontext_t);\n+unsigned struct_rlimit_sz = sizeof(struct rlimit);\n+unsigned struct_timespec_sz = sizeof(struct timespec);\n+unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n+unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n+unsigned struct_timeb_sz = sizeof(struct timeb);\n+unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n+unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n+unsigned struct_statvfs_sz = sizeof(struct statvfs);\n+unsigned struct_shminfo_sz = sizeof(struct shminfo);\n+unsigned struct_shm_info_sz = sizeof(struct shm_info);\n+unsigned struct_regmatch_sz = sizeof(regmatch_t);\n+unsigned struct_regex_sz = sizeof(regex_t);\n+unsigned struct_fstab_sz = sizeof(struct fstab);\n+unsigned struct_FTS_sz = sizeof(FTS);\n+unsigned struct_FTSENT_sz = sizeof(FTSENT);\n+unsigned struct_StringList_sz = sizeof(StringList);\n+\n+const uptr sig_ign = (uptr)SIG_IGN;\n+const uptr sig_dfl = (uptr)SIG_DFL;\n+const uptr sig_err = (uptr)SIG_ERR;\n+const uptr sa_siginfo = (uptr)SA_SIGINFO;\n+\n+int shmctl_ipc_stat = (int)IPC_STAT;\n+int shmctl_ipc_info = (int)IPC_INFO;\n+int shmctl_shm_info = (int)SHM_INFO;\n+int shmctl_shm_stat = (int)SHM_STAT;\n+unsigned struct_utmpx_sz = sizeof(struct utmpx);\n+\n+int map_fixed = MAP_FIXED;\n+\n+int af_inet = (int)AF_INET;\n+int af_inet6 = (int)AF_INET6;\n+\n+uptr __sanitizer_in_addr_sz(int af) {\n+  if (af == AF_INET)\n+    return sizeof(struct in_addr);\n+  else if (af == AF_INET6)\n+    return sizeof(struct in6_addr);\n+  else\n+    return 0;\n+}\n+\n+unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n+int glob_nomatch = GLOB_NOMATCH;\n+int glob_altdirfunc = GLOB_ALTDIRFUNC;\n+\n+unsigned path_max = PATH_MAX;\n+\n+// ioctl arguments\n+unsigned struct_ifreq_sz = sizeof(struct ifreq);\n+unsigned struct_termios_sz = sizeof(struct termios);\n+unsigned struct_winsize_sz = sizeof(struct winsize);\n #if SOUND_VERSION >= 0x040000\n-  unsigned struct_copr_buffer_sz = 0;\n-  unsigned struct_copr_debug_buf_sz = 0;\n-  unsigned struct_copr_msg_sz = 0;\n+unsigned struct_copr_buffer_sz = 0;\n+unsigned struct_copr_debug_buf_sz = 0;\n+unsigned struct_copr_msg_sz = 0;\n #else\n-  unsigned struct_copr_buffer_sz = sizeof(struct copr_buffer);\n-  unsigned struct_copr_debug_buf_sz = sizeof(struct copr_debug_buf);\n-  unsigned struct_copr_msg_sz = sizeof(struct copr_msg);\n+unsigned struct_copr_buffer_sz = sizeof(struct copr_buffer);\n+unsigned struct_copr_debug_buf_sz = sizeof(struct copr_debug_buf);\n+unsigned struct_copr_msg_sz = sizeof(struct copr_msg);\n #endif\n-  unsigned struct_midi_info_sz = sizeof(struct midi_info);\n-  unsigned struct_mtget_sz = sizeof(struct mtget);\n-  unsigned struct_mtop_sz = sizeof(struct mtop);\n-  unsigned struct_sbi_instrument_sz = sizeof(struct sbi_instrument);\n-  unsigned struct_seq_event_rec_sz = sizeof(struct seq_event_rec);\n-  unsigned struct_synth_info_sz = sizeof(struct synth_info);\n-  unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n-  unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n-  unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n-  unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n-  const unsigned long __sanitizer_bufsiz = BUFSIZ;\n-\n-  const unsigned IOCTL_NOT_PRESENT = 0;\n-\n-  unsigned IOCTL_FIOASYNC = FIOASYNC;\n-  unsigned IOCTL_FIOCLEX = FIOCLEX;\n-  unsigned IOCTL_FIOGETOWN = FIOGETOWN;\n-  unsigned IOCTL_FIONBIO = FIONBIO;\n-  unsigned IOCTL_FIONCLEX = FIONCLEX;\n-  unsigned IOCTL_FIOSETOWN = FIOSETOWN;\n-  unsigned IOCTL_SIOCADDMULTI = SIOCADDMULTI;\n-  unsigned IOCTL_SIOCATMARK = SIOCATMARK;\n-  unsigned IOCTL_SIOCDELMULTI = SIOCDELMULTI;\n-  unsigned IOCTL_SIOCGIFADDR = SIOCGIFADDR;\n-  unsigned IOCTL_SIOCGIFBRDADDR = SIOCGIFBRDADDR;\n-  unsigned IOCTL_SIOCGIFCONF = SIOCGIFCONF;\n-  unsigned IOCTL_SIOCGIFDSTADDR = SIOCGIFDSTADDR;\n-  unsigned IOCTL_SIOCGIFFLAGS = SIOCGIFFLAGS;\n-  unsigned IOCTL_SIOCGIFMETRIC = SIOCGIFMETRIC;\n-  unsigned IOCTL_SIOCGIFMTU = SIOCGIFMTU;\n-  unsigned IOCTL_SIOCGIFNETMASK = SIOCGIFNETMASK;\n-  unsigned IOCTL_SIOCGPGRP = SIOCGPGRP;\n-  unsigned IOCTL_SIOCSIFADDR = SIOCSIFADDR;\n-  unsigned IOCTL_SIOCSIFBRDADDR = SIOCSIFBRDADDR;\n-  unsigned IOCTL_SIOCSIFDSTADDR = SIOCSIFDSTADDR;\n-  unsigned IOCTL_SIOCSIFFLAGS = SIOCSIFFLAGS;\n-  unsigned IOCTL_SIOCSIFMETRIC = SIOCSIFMETRIC;\n-  unsigned IOCTL_SIOCSIFMTU = SIOCSIFMTU;\n-  unsigned IOCTL_SIOCSIFNETMASK = SIOCSIFNETMASK;\n-  unsigned IOCTL_SIOCSPGRP = SIOCSPGRP;\n-  unsigned IOCTL_TIOCCONS = TIOCCONS;\n-  unsigned IOCTL_TIOCEXCL = TIOCEXCL;\n-  unsigned IOCTL_TIOCGETD = TIOCGETD;\n-  unsigned IOCTL_TIOCGPGRP = TIOCGPGRP;\n-  unsigned IOCTL_TIOCGWINSZ = TIOCGWINSZ;\n-  unsigned IOCTL_TIOCMBIC = TIOCMBIC;\n-  unsigned IOCTL_TIOCMBIS = TIOCMBIS;\n-  unsigned IOCTL_TIOCMGET = TIOCMGET;\n-  unsigned IOCTL_TIOCMSET = TIOCMSET;\n-  unsigned IOCTL_TIOCNOTTY = TIOCNOTTY;\n-  unsigned IOCTL_TIOCNXCL = TIOCNXCL;\n-  unsigned IOCTL_TIOCOUTQ = TIOCOUTQ;\n-  unsigned IOCTL_TIOCPKT = TIOCPKT;\n-  unsigned IOCTL_TIOCSCTTY = TIOCSCTTY;\n-  unsigned IOCTL_TIOCSETD = TIOCSETD;\n-  unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n-  unsigned IOCTL_TIOCSTI = TIOCSTI;\n-  unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n-  unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n-  unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n-  unsigned IOCTL_MTIOCGET = MTIOCGET;\n-  unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n-  unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE = SNDCTL_DSP_GETBLKSIZE;\n-  unsigned IOCTL_SNDCTL_DSP_GETFMTS = SNDCTL_DSP_GETFMTS;\n-  unsigned IOCTL_SNDCTL_DSP_NONBLOCK = SNDCTL_DSP_NONBLOCK;\n-  unsigned IOCTL_SNDCTL_DSP_POST = SNDCTL_DSP_POST;\n-  unsigned IOCTL_SNDCTL_DSP_RESET = SNDCTL_DSP_RESET;\n-  unsigned IOCTL_SNDCTL_DSP_SETFMT = SNDCTL_DSP_SETFMT;\n-  unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT = SNDCTL_DSP_SETFRAGMENT;\n-  unsigned IOCTL_SNDCTL_DSP_SPEED = SNDCTL_DSP_SPEED;\n-  unsigned IOCTL_SNDCTL_DSP_STEREO = SNDCTL_DSP_STEREO;\n-  unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE = SNDCTL_DSP_SUBDIVIDE;\n-  unsigned IOCTL_SNDCTL_DSP_SYNC = SNDCTL_DSP_SYNC;\n-  unsigned IOCTL_SNDCTL_FM_4OP_ENABLE = SNDCTL_FM_4OP_ENABLE;\n-  unsigned IOCTL_SNDCTL_FM_LOAD_INSTR = SNDCTL_FM_LOAD_INSTR;\n-  unsigned IOCTL_SNDCTL_MIDI_INFO = SNDCTL_MIDI_INFO;\n-  unsigned IOCTL_SNDCTL_MIDI_PRETIME = SNDCTL_MIDI_PRETIME;\n-  unsigned IOCTL_SNDCTL_SEQ_CTRLRATE = SNDCTL_SEQ_CTRLRATE;\n-  unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT = SNDCTL_SEQ_GETINCOUNT;\n-  unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT = SNDCTL_SEQ_GETOUTCOUNT;\n-  unsigned IOCTL_SNDCTL_SEQ_NRMIDIS = SNDCTL_SEQ_NRMIDIS;\n-  unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS = SNDCTL_SEQ_NRSYNTHS;\n-  unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND = SNDCTL_SEQ_OUTOFBAND;\n-  unsigned IOCTL_SNDCTL_SEQ_PANIC = SNDCTL_SEQ_PANIC;\n-  unsigned IOCTL_SNDCTL_SEQ_PERCMODE = SNDCTL_SEQ_PERCMODE;\n-  unsigned IOCTL_SNDCTL_SEQ_RESET = SNDCTL_SEQ_RESET;\n-  unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES = SNDCTL_SEQ_RESETSAMPLES;\n-  unsigned IOCTL_SNDCTL_SEQ_SYNC = SNDCTL_SEQ_SYNC;\n-  unsigned IOCTL_SNDCTL_SEQ_TESTMIDI = SNDCTL_SEQ_TESTMIDI;\n-  unsigned IOCTL_SNDCTL_SEQ_THRESHOLD = SNDCTL_SEQ_THRESHOLD;\n-  unsigned IOCTL_SNDCTL_SYNTH_INFO = SNDCTL_SYNTH_INFO;\n-  unsigned IOCTL_SNDCTL_SYNTH_MEMAVL = SNDCTL_SYNTH_MEMAVL;\n-  unsigned IOCTL_SNDCTL_TMR_CONTINUE = SNDCTL_TMR_CONTINUE;\n-  unsigned IOCTL_SNDCTL_TMR_METRONOME = SNDCTL_TMR_METRONOME;\n-  unsigned IOCTL_SNDCTL_TMR_SELECT = SNDCTL_TMR_SELECT;\n-  unsigned IOCTL_SNDCTL_TMR_SOURCE = SNDCTL_TMR_SOURCE;\n-  unsigned IOCTL_SNDCTL_TMR_START = SNDCTL_TMR_START;\n-  unsigned IOCTL_SNDCTL_TMR_STOP = SNDCTL_TMR_STOP;\n-  unsigned IOCTL_SNDCTL_TMR_TEMPO = SNDCTL_TMR_TEMPO;\n-  unsigned IOCTL_SNDCTL_TMR_TIMEBASE = SNDCTL_TMR_TIMEBASE;\n-  unsigned IOCTL_SOUND_MIXER_READ_ALTPCM = SOUND_MIXER_READ_ALTPCM;\n-  unsigned IOCTL_SOUND_MIXER_READ_BASS = SOUND_MIXER_READ_BASS;\n-  unsigned IOCTL_SOUND_MIXER_READ_CAPS = SOUND_MIXER_READ_CAPS;\n-  unsigned IOCTL_SOUND_MIXER_READ_CD = SOUND_MIXER_READ_CD;\n-  unsigned IOCTL_SOUND_MIXER_READ_DEVMASK = SOUND_MIXER_READ_DEVMASK;\n-  unsigned IOCTL_SOUND_MIXER_READ_ENHANCE = SOUND_MIXER_READ_ENHANCE;\n-  unsigned IOCTL_SOUND_MIXER_READ_IGAIN = SOUND_MIXER_READ_IGAIN;\n-  unsigned IOCTL_SOUND_MIXER_READ_IMIX = SOUND_MIXER_READ_IMIX;\n-  unsigned IOCTL_SOUND_MIXER_READ_LINE = SOUND_MIXER_READ_LINE;\n-  unsigned IOCTL_SOUND_MIXER_READ_LINE1 = SOUND_MIXER_READ_LINE1;\n-  unsigned IOCTL_SOUND_MIXER_READ_LINE2 = SOUND_MIXER_READ_LINE2;\n-  unsigned IOCTL_SOUND_MIXER_READ_LINE3 = SOUND_MIXER_READ_LINE3;\n-  unsigned IOCTL_SOUND_MIXER_READ_LOUD = SOUND_MIXER_READ_LOUD;\n-  unsigned IOCTL_SOUND_MIXER_READ_MIC = SOUND_MIXER_READ_MIC;\n-  unsigned IOCTL_SOUND_MIXER_READ_MUTE = SOUND_MIXER_READ_MUTE;\n-  unsigned IOCTL_SOUND_MIXER_READ_OGAIN = SOUND_MIXER_READ_OGAIN;\n-  unsigned IOCTL_SOUND_MIXER_READ_PCM = SOUND_MIXER_READ_PCM;\n-  unsigned IOCTL_SOUND_MIXER_READ_RECLEV = SOUND_MIXER_READ_RECLEV;\n-  unsigned IOCTL_SOUND_MIXER_READ_RECMASK = SOUND_MIXER_READ_RECMASK;\n-  unsigned IOCTL_SOUND_MIXER_READ_RECSRC = SOUND_MIXER_READ_RECSRC;\n-  unsigned IOCTL_SOUND_MIXER_READ_SPEAKER = SOUND_MIXER_READ_SPEAKER;\n-  unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS = SOUND_MIXER_READ_STEREODEVS;\n-  unsigned IOCTL_SOUND_MIXER_READ_SYNTH = SOUND_MIXER_READ_SYNTH;\n-  unsigned IOCTL_SOUND_MIXER_READ_TREBLE = SOUND_MIXER_READ_TREBLE;\n-  unsigned IOCTL_SOUND_MIXER_READ_VOLUME = SOUND_MIXER_READ_VOLUME;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM = SOUND_MIXER_WRITE_ALTPCM;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_BASS = SOUND_MIXER_WRITE_BASS;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_CD = SOUND_MIXER_WRITE_CD;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE = SOUND_MIXER_WRITE_ENHANCE;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN = SOUND_MIXER_WRITE_IGAIN;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_IMIX = SOUND_MIXER_WRITE_IMIX;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_LINE = SOUND_MIXER_WRITE_LINE;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_LINE1 = SOUND_MIXER_WRITE_LINE1;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_LINE2 = SOUND_MIXER_WRITE_LINE2;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_LINE3 = SOUND_MIXER_WRITE_LINE3;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_LOUD = SOUND_MIXER_WRITE_LOUD;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_MIC = SOUND_MIXER_WRITE_MIC;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_MUTE = SOUND_MIXER_WRITE_MUTE;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN = SOUND_MIXER_WRITE_OGAIN;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_PCM = SOUND_MIXER_WRITE_PCM;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV = SOUND_MIXER_WRITE_RECLEV;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC = SOUND_MIXER_WRITE_RECSRC;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER = SOUND_MIXER_WRITE_SPEAKER;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH = SOUND_MIXER_WRITE_SYNTH;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE = SOUND_MIXER_WRITE_TREBLE;\n-  unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME = SOUND_MIXER_WRITE_VOLUME;\n-  unsigned IOCTL_VT_ACTIVATE = VT_ACTIVATE;\n-  unsigned IOCTL_VT_GETMODE = VT_GETMODE;\n-  unsigned IOCTL_VT_OPENQRY = VT_OPENQRY;\n-  unsigned IOCTL_VT_RELDISP = VT_RELDISP;\n-  unsigned IOCTL_VT_SETMODE = VT_SETMODE;\n-  unsigned IOCTL_VT_WAITACTIVE = VT_WAITACTIVE;\n-  unsigned IOCTL_GIO_SCRNMAP = GIO_SCRNMAP;\n-  unsigned IOCTL_KDDISABIO = KDDISABIO;\n-  unsigned IOCTL_KDENABIO = KDENABIO;\n-  unsigned IOCTL_KDGETLED = KDGETLED;\n-  unsigned IOCTL_KDGETMODE = KDGETMODE;\n-  unsigned IOCTL_KDGKBMODE = KDGKBMODE;\n-  unsigned IOCTL_KDGKBTYPE = KDGKBTYPE;\n-  unsigned IOCTL_KDMKTONE = KDMKTONE;\n-  unsigned IOCTL_KDSETLED = KDSETLED;\n-  unsigned IOCTL_KDSETMODE = KDSETMODE;\n-  unsigned IOCTL_KDSKBMODE = KDSKBMODE;\n-  unsigned IOCTL_KIOCSOUND = KIOCSOUND;\n-  unsigned IOCTL_PIO_SCRNMAP = PIO_SCRNMAP;\n-  unsigned IOCTL_SNDCTL_DSP_GETISPACE = SNDCTL_DSP_GETISPACE;\n-\n-  const int si_SEGV_MAPERR = SEGV_MAPERR;\n-  const int si_SEGV_ACCERR = SEGV_ACCERR;\n-  const int unvis_valid = UNVIS_VALID;\n-  const int unvis_validpush = UNVIS_VALIDPUSH;\n-} // namespace __sanitizer\n+unsigned struct_midi_info_sz = sizeof(struct midi_info);\n+unsigned struct_mtget_sz = sizeof(struct mtget);\n+unsigned struct_mtop_sz = sizeof(struct mtop);\n+unsigned struct_sbi_instrument_sz = sizeof(struct sbi_instrument);\n+unsigned struct_seq_event_rec_sz = sizeof(struct seq_event_rec);\n+unsigned struct_synth_info_sz = sizeof(struct synth_info);\n+unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n+unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n+unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n+unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n+const unsigned long __sanitizer_bufsiz = BUFSIZ;\n+\n+const unsigned IOCTL_NOT_PRESENT = 0;\n+\n+unsigned IOCTL_FIOASYNC = FIOASYNC;\n+unsigned IOCTL_FIOCLEX = FIOCLEX;\n+unsigned IOCTL_FIOGETOWN = FIOGETOWN;\n+unsigned IOCTL_FIONBIO = FIONBIO;\n+unsigned IOCTL_FIONCLEX = FIONCLEX;\n+unsigned IOCTL_FIOSETOWN = FIOSETOWN;\n+unsigned IOCTL_SIOCADDMULTI = SIOCADDMULTI;\n+unsigned IOCTL_SIOCATMARK = SIOCATMARK;\n+unsigned IOCTL_SIOCDELMULTI = SIOCDELMULTI;\n+unsigned IOCTL_SIOCGIFADDR = SIOCGIFADDR;\n+unsigned IOCTL_SIOCGIFBRDADDR = SIOCGIFBRDADDR;\n+unsigned IOCTL_SIOCGIFCONF = SIOCGIFCONF;\n+unsigned IOCTL_SIOCGIFDSTADDR = SIOCGIFDSTADDR;\n+unsigned IOCTL_SIOCGIFFLAGS = SIOCGIFFLAGS;\n+unsigned IOCTL_SIOCGIFMETRIC = SIOCGIFMETRIC;\n+unsigned IOCTL_SIOCGIFMTU = SIOCGIFMTU;\n+unsigned IOCTL_SIOCGIFNETMASK = SIOCGIFNETMASK;\n+unsigned IOCTL_SIOCGPGRP = SIOCGPGRP;\n+unsigned IOCTL_SIOCSIFADDR = SIOCSIFADDR;\n+unsigned IOCTL_SIOCSIFBRDADDR = SIOCSIFBRDADDR;\n+unsigned IOCTL_SIOCSIFDSTADDR = SIOCSIFDSTADDR;\n+unsigned IOCTL_SIOCSIFFLAGS = SIOCSIFFLAGS;\n+unsigned IOCTL_SIOCSIFMETRIC = SIOCSIFMETRIC;\n+unsigned IOCTL_SIOCSIFMTU = SIOCSIFMTU;\n+unsigned IOCTL_SIOCSIFNETMASK = SIOCSIFNETMASK;\n+unsigned IOCTL_SIOCSPGRP = SIOCSPGRP;\n+unsigned IOCTL_TIOCCONS = TIOCCONS;\n+unsigned IOCTL_TIOCEXCL = TIOCEXCL;\n+unsigned IOCTL_TIOCGETD = TIOCGETD;\n+unsigned IOCTL_TIOCGPGRP = TIOCGPGRP;\n+unsigned IOCTL_TIOCGWINSZ = TIOCGWINSZ;\n+unsigned IOCTL_TIOCMBIC = TIOCMBIC;\n+unsigned IOCTL_TIOCMBIS = TIOCMBIS;\n+unsigned IOCTL_TIOCMGET = TIOCMGET;\n+unsigned IOCTL_TIOCMSET = TIOCMSET;\n+unsigned IOCTL_TIOCNOTTY = TIOCNOTTY;\n+unsigned IOCTL_TIOCNXCL = TIOCNXCL;\n+unsigned IOCTL_TIOCOUTQ = TIOCOUTQ;\n+unsigned IOCTL_TIOCPKT = TIOCPKT;\n+unsigned IOCTL_TIOCSCTTY = TIOCSCTTY;\n+unsigned IOCTL_TIOCSETD = TIOCSETD;\n+unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n+unsigned IOCTL_TIOCSTI = TIOCSTI;\n+unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n+unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n+unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n+unsigned IOCTL_MTIOCGET = MTIOCGET;\n+unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n+unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE = SNDCTL_DSP_GETBLKSIZE;\n+unsigned IOCTL_SNDCTL_DSP_GETFMTS = SNDCTL_DSP_GETFMTS;\n+unsigned IOCTL_SNDCTL_DSP_NONBLOCK = SNDCTL_DSP_NONBLOCK;\n+unsigned IOCTL_SNDCTL_DSP_POST = SNDCTL_DSP_POST;\n+unsigned IOCTL_SNDCTL_DSP_RESET = SNDCTL_DSP_RESET;\n+unsigned IOCTL_SNDCTL_DSP_SETFMT = SNDCTL_DSP_SETFMT;\n+unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT = SNDCTL_DSP_SETFRAGMENT;\n+unsigned IOCTL_SNDCTL_DSP_SPEED = SNDCTL_DSP_SPEED;\n+unsigned IOCTL_SNDCTL_DSP_STEREO = SNDCTL_DSP_STEREO;\n+unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE = SNDCTL_DSP_SUBDIVIDE;\n+unsigned IOCTL_SNDCTL_DSP_SYNC = SNDCTL_DSP_SYNC;\n+unsigned IOCTL_SNDCTL_FM_4OP_ENABLE = SNDCTL_FM_4OP_ENABLE;\n+unsigned IOCTL_SNDCTL_FM_LOAD_INSTR = SNDCTL_FM_LOAD_INSTR;\n+unsigned IOCTL_SNDCTL_MIDI_INFO = SNDCTL_MIDI_INFO;\n+unsigned IOCTL_SNDCTL_MIDI_PRETIME = SNDCTL_MIDI_PRETIME;\n+unsigned IOCTL_SNDCTL_SEQ_CTRLRATE = SNDCTL_SEQ_CTRLRATE;\n+unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT = SNDCTL_SEQ_GETINCOUNT;\n+unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT = SNDCTL_SEQ_GETOUTCOUNT;\n+unsigned IOCTL_SNDCTL_SEQ_NRMIDIS = SNDCTL_SEQ_NRMIDIS;\n+unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS = SNDCTL_SEQ_NRSYNTHS;\n+unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND = SNDCTL_SEQ_OUTOFBAND;\n+unsigned IOCTL_SNDCTL_SEQ_PANIC = SNDCTL_SEQ_PANIC;\n+unsigned IOCTL_SNDCTL_SEQ_PERCMODE = SNDCTL_SEQ_PERCMODE;\n+unsigned IOCTL_SNDCTL_SEQ_RESET = SNDCTL_SEQ_RESET;\n+unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES = SNDCTL_SEQ_RESETSAMPLES;\n+unsigned IOCTL_SNDCTL_SEQ_SYNC = SNDCTL_SEQ_SYNC;\n+unsigned IOCTL_SNDCTL_SEQ_TESTMIDI = SNDCTL_SEQ_TESTMIDI;\n+unsigned IOCTL_SNDCTL_SEQ_THRESHOLD = SNDCTL_SEQ_THRESHOLD;\n+unsigned IOCTL_SNDCTL_SYNTH_INFO = SNDCTL_SYNTH_INFO;\n+unsigned IOCTL_SNDCTL_SYNTH_MEMAVL = SNDCTL_SYNTH_MEMAVL;\n+unsigned IOCTL_SNDCTL_TMR_CONTINUE = SNDCTL_TMR_CONTINUE;\n+unsigned IOCTL_SNDCTL_TMR_METRONOME = SNDCTL_TMR_METRONOME;\n+unsigned IOCTL_SNDCTL_TMR_SELECT = SNDCTL_TMR_SELECT;\n+unsigned IOCTL_SNDCTL_TMR_SOURCE = SNDCTL_TMR_SOURCE;\n+unsigned IOCTL_SNDCTL_TMR_START = SNDCTL_TMR_START;\n+unsigned IOCTL_SNDCTL_TMR_STOP = SNDCTL_TMR_STOP;\n+unsigned IOCTL_SNDCTL_TMR_TEMPO = SNDCTL_TMR_TEMPO;\n+unsigned IOCTL_SNDCTL_TMR_TIMEBASE = SNDCTL_TMR_TIMEBASE;\n+unsigned IOCTL_SOUND_MIXER_READ_ALTPCM = SOUND_MIXER_READ_ALTPCM;\n+unsigned IOCTL_SOUND_MIXER_READ_BASS = SOUND_MIXER_READ_BASS;\n+unsigned IOCTL_SOUND_MIXER_READ_CAPS = SOUND_MIXER_READ_CAPS;\n+unsigned IOCTL_SOUND_MIXER_READ_CD = SOUND_MIXER_READ_CD;\n+unsigned IOCTL_SOUND_MIXER_READ_DEVMASK = SOUND_MIXER_READ_DEVMASK;\n+unsigned IOCTL_SOUND_MIXER_READ_ENHANCE = SOUND_MIXER_READ_ENHANCE;\n+unsigned IOCTL_SOUND_MIXER_READ_IGAIN = SOUND_MIXER_READ_IGAIN;\n+unsigned IOCTL_SOUND_MIXER_READ_IMIX = SOUND_MIXER_READ_IMIX;\n+unsigned IOCTL_SOUND_MIXER_READ_LINE = SOUND_MIXER_READ_LINE;\n+unsigned IOCTL_SOUND_MIXER_READ_LINE1 = SOUND_MIXER_READ_LINE1;\n+unsigned IOCTL_SOUND_MIXER_READ_LINE2 = SOUND_MIXER_READ_LINE2;\n+unsigned IOCTL_SOUND_MIXER_READ_LINE3 = SOUND_MIXER_READ_LINE3;\n+unsigned IOCTL_SOUND_MIXER_READ_LOUD = SOUND_MIXER_READ_LOUD;\n+unsigned IOCTL_SOUND_MIXER_READ_MIC = SOUND_MIXER_READ_MIC;\n+unsigned IOCTL_SOUND_MIXER_READ_MUTE = SOUND_MIXER_READ_MUTE;\n+unsigned IOCTL_SOUND_MIXER_READ_OGAIN = SOUND_MIXER_READ_OGAIN;\n+unsigned IOCTL_SOUND_MIXER_READ_PCM = SOUND_MIXER_READ_PCM;\n+unsigned IOCTL_SOUND_MIXER_READ_RECLEV = SOUND_MIXER_READ_RECLEV;\n+unsigned IOCTL_SOUND_MIXER_READ_RECMASK = SOUND_MIXER_READ_RECMASK;\n+unsigned IOCTL_SOUND_MIXER_READ_RECSRC = SOUND_MIXER_READ_RECSRC;\n+unsigned IOCTL_SOUND_MIXER_READ_SPEAKER = SOUND_MIXER_READ_SPEAKER;\n+unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS = SOUND_MIXER_READ_STEREODEVS;\n+unsigned IOCTL_SOUND_MIXER_READ_SYNTH = SOUND_MIXER_READ_SYNTH;\n+unsigned IOCTL_SOUND_MIXER_READ_TREBLE = SOUND_MIXER_READ_TREBLE;\n+unsigned IOCTL_SOUND_MIXER_READ_VOLUME = SOUND_MIXER_READ_VOLUME;\n+unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM = SOUND_MIXER_WRITE_ALTPCM;\n+unsigned IOCTL_SOUND_MIXER_WRITE_BASS = SOUND_MIXER_WRITE_BASS;\n+unsigned IOCTL_SOUND_MIXER_WRITE_CD = SOUND_MIXER_WRITE_CD;\n+unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE = SOUND_MIXER_WRITE_ENHANCE;\n+unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN = SOUND_MIXER_WRITE_IGAIN;\n+unsigned IOCTL_SOUND_MIXER_WRITE_IMIX = SOUND_MIXER_WRITE_IMIX;\n+unsigned IOCTL_SOUND_MIXER_WRITE_LINE = SOUND_MIXER_WRITE_LINE;\n+unsigned IOCTL_SOUND_MIXER_WRITE_LINE1 = SOUND_MIXER_WRITE_LINE1;\n+unsigned IOCTL_SOUND_MIXER_WRITE_LINE2 = SOUND_MIXER_WRITE_LINE2;\n+unsigned IOCTL_SOUND_MIXER_WRITE_LINE3 = SOUND_MIXER_WRITE_LINE3;\n+unsigned IOCTL_SOUND_MIXER_WRITE_LOUD = SOUND_MIXER_WRITE_LOUD;\n+unsigned IOCTL_SOUND_MIXER_WRITE_MIC = SOUND_MIXER_WRITE_MIC;\n+unsigned IOCTL_SOUND_MIXER_WRITE_MUTE = SOUND_MIXER_WRITE_MUTE;\n+unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN = SOUND_MIXER_WRITE_OGAIN;\n+unsigned IOCTL_SOUND_MIXER_WRITE_PCM = SOUND_MIXER_WRITE_PCM;\n+unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV = SOUND_MIXER_WRITE_RECLEV;\n+unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC = SOUND_MIXER_WRITE_RECSRC;\n+unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER = SOUND_MIXER_WRITE_SPEAKER;\n+unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH = SOUND_MIXER_WRITE_SYNTH;\n+unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE = SOUND_MIXER_WRITE_TREBLE;\n+unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME = SOUND_MIXER_WRITE_VOLUME;\n+unsigned IOCTL_VT_ACTIVATE = VT_ACTIVATE;\n+unsigned IOCTL_VT_GETMODE = VT_GETMODE;\n+unsigned IOCTL_VT_OPENQRY = VT_OPENQRY;\n+unsigned IOCTL_VT_RELDISP = VT_RELDISP;\n+unsigned IOCTL_VT_SETMODE = VT_SETMODE;\n+unsigned IOCTL_VT_WAITACTIVE = VT_WAITACTIVE;\n+unsigned IOCTL_GIO_SCRNMAP = GIO_SCRNMAP;\n+unsigned IOCTL_KDDISABIO = KDDISABIO;\n+unsigned IOCTL_KDENABIO = KDENABIO;\n+unsigned IOCTL_KDGETLED = KDGETLED;\n+unsigned IOCTL_KDGETMODE = KDGETMODE;\n+unsigned IOCTL_KDGKBMODE = KDGKBMODE;\n+unsigned IOCTL_KDGKBTYPE = KDGKBTYPE;\n+unsigned IOCTL_KDMKTONE = KDMKTONE;\n+unsigned IOCTL_KDSETLED = KDSETLED;\n+unsigned IOCTL_KDSETMODE = KDSETMODE;\n+unsigned IOCTL_KDSKBMODE = KDSKBMODE;\n+unsigned IOCTL_KIOCSOUND = KIOCSOUND;\n+unsigned IOCTL_PIO_SCRNMAP = PIO_SCRNMAP;\n+unsigned IOCTL_SNDCTL_DSP_GETISPACE = SNDCTL_DSP_GETISPACE;\n+\n+const int si_SEGV_MAPERR = SEGV_MAPERR;\n+const int si_SEGV_ACCERR = SEGV_ACCERR;\n+const int unvis_valid = UNVIS_VALID;\n+const int unvis_validpush = UNVIS_VALIDPUSH;\n+}  // namespace __sanitizer\n \n using namespace __sanitizer;\n "}, {"sha": "5e0ca9c7d78236821e41226edf33a4b551f3ee5d", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -18,18 +18,17 @@\n \n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n-\n #include \"sanitizer_platform_limits_posix.h\"\n \n-// FreeBSD's dlopen() returns a pointer to an Obj_Entry structure that\n-// incorporates the map structure.\n-# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-    ((link_map*)((handle) == nullptr ? nullptr : ((char*)(handle) + 560)))\n // Get sys/_types.h, because that tells us whether 64-bit inodes are\n // used in struct dirent below.\n #include <sys/_types.h>\n \n namespace __sanitizer {\n+void *__sanitizer_get_link_map_by_dlopen_handle(void *handle);\n+#define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n+  (link_map *)__sanitizer_get_link_map_by_dlopen_handle(handle)\n+\n extern unsigned struct_utsname_sz;\n extern unsigned struct_stat_sz;\n #if defined(__powerpc64__)\n@@ -53,6 +52,7 @@ extern unsigned struct_timezone_sz;\n extern unsigned struct_tms_sz;\n extern unsigned struct_itimerspec_sz;\n extern unsigned struct_sigevent_sz;\n+extern unsigned struct_stack_t_sz;\n extern unsigned struct_sched_param_sz;\n extern unsigned struct_statfs64_sz;\n extern unsigned struct_statfs_sz;\n@@ -147,7 +147,7 @@ struct __sanitizer_ifaddrs {\n   unsigned int ifa_flags;\n   void *ifa_addr;     // (struct sockaddr *)\n   void *ifa_netmask;  // (struct sockaddr *)\n-# undef ifa_dstaddr\n+#undef ifa_dstaddr\n   void *ifa_dstaddr;  // (struct sockaddr *)\n   void *ifa_data;\n };\n@@ -630,27 +630,27 @@ extern unsigned struct_cap_rights_sz;\n \n extern unsigned struct_fstab_sz;\n extern unsigned struct_StringList_sz;\n-} // namespace __sanitizer\n+}  // namespace __sanitizer\n \n #define CHECK_TYPE_SIZE(TYPE) \\\n   COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n \n-#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n-  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *) NULL)->MEMBER) == \\\n-                 sizeof(((CLASS *) NULL)->MEMBER));                \\\n-  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==          \\\n+#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n+  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *)NULL)->MEMBER) == \\\n+                 sizeof(((CLASS *)NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==         \\\n                  offsetof(CLASS, MEMBER))\n \n // For sigaction, which is a function and struct at the same time,\n // and thus requires explicit \"struct\" in sizeof() expression.\n-#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n-  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *) NULL)->MEMBER) == \\\n-                 sizeof(((struct CLASS *) NULL)->MEMBER));                \\\n-  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==          \\\n+#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n+  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *)NULL)->MEMBER) == \\\n+                 sizeof(((struct CLASS *)NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==         \\\n                  offsetof(struct CLASS, MEMBER))\n \n #define SIGACTION_SYMNAME sigaction\n \n #endif\n \n-#endif // SANITIZER_FREEBSD\n+#endif  // SANITIZER_FREEBSD"}, {"sha": "c51327e1269e081cb0e231b75cbce71b62601e88", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -26,12 +26,9 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n #define ino_t __kernel_ino_t"}, {"sha": "25da334b63f098b47d43d5cdd6f1cec58f2a0de9", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.cpp", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -17,6 +17,7 @@\n \n #define _KMEMUSER\n #define RAY_DO_SIGLEV\n+#define __LEGACY_PT_LWPINFO\n \n // clang-format off\n #include <sys/param.h>\n@@ -71,6 +72,15 @@\n #include <sys/msg.h>\n #include <sys/mtio.h>\n #include <sys/ptrace.h>\n+\n+// Compat for NetBSD < 9.99.30.\n+#ifndef PT_LWPSTATUS\n+#define PT_LWPSTATUS 24\n+#endif\n+#ifndef PT_LWPNEXT\n+#define PT_LWPNEXT 25\n+#endif\n+\n #include <sys/resource.h>\n #include <sys/sem.h>\n #include <sys/sha1.h>\n@@ -109,7 +119,12 @@\n #include <dev/dmover/dmover_io.h>\n #include <dev/dtv/dtvio_demux.h>\n #include <dev/dtv/dtvio_frontend.h>\n+#if !__NetBSD_Prereq__(9, 99, 26)\n #include <dev/filemon/filemon.h>\n+#else\n+#define FILEMON_SET_FD          _IOWR('S', 1, int)\n+#define FILEMON_SET_PID         _IOWR('S', 2, pid_t)\n+#endif\n #include <dev/hdaudio/hdaudioio.h>\n #include <dev/hdmicec/hdmicecio.h>\n #include <dev/hpc/hpcfbio.h>\n@@ -146,12 +161,121 @@\n #include <net/slip.h>\n #include <netbt/hci.h>\n #include <netinet/ip_compat.h>\n+#if __has_include(<netinet/ip_fil.h>)\n #include <netinet/ip_fil.h>\n #include <netinet/ip_nat.h>\n #include <netinet/ip_proxy.h>\n+#else\n+/* Fallback for MKIPFILTER=no */\n+\n+typedef struct ap_control {\n+  char apc_label[16];\n+  char apc_config[16];\n+  unsigned char apc_p;\n+  unsigned long apc_cmd;\n+  unsigned long apc_arg;\n+  void *apc_data;\n+  size_t apc_dsize;\n+} ap_ctl_t;\n+\n+typedef struct ipftq {\n+  ipfmutex_t ifq_lock;\n+  unsigned int ifq_ttl;\n+  void *ifq_head;\n+  void **ifq_tail;\n+  void *ifq_next;\n+  void **ifq_pnext;\n+  int ifq_ref;\n+  unsigned int ifq_flags;\n+} ipftq_t;\n+\n+typedef struct ipfobj {\n+  uint32_t ipfo_rev;\n+  uint32_t ipfo_size;\n+  void *ipfo_ptr;\n+  int ipfo_type;\n+  int ipfo_offset;\n+  int ipfo_retval;\n+  unsigned char ipfo_xxxpad[28];\n+} ipfobj_t;\n+\n+#define SIOCADNAT _IOW('r', 60, struct ipfobj)\n+#define SIOCRMNAT _IOW('r', 61, struct ipfobj)\n+#define SIOCGNATS _IOWR('r', 62, struct ipfobj)\n+#define SIOCGNATL _IOWR('r', 63, struct ipfobj)\n+#define SIOCPURGENAT _IOWR('r', 100, struct ipfobj)\n+#endif\n #include <netinet6/in6_var.h>\n #include <netinet6/nd6.h>\n+#if !__NetBSD_Prereq__(9, 99, 51)\n #include <netsmb/smb_dev.h>\n+#else\n+struct smbioc_flags {\n+  int ioc_level;\n+  int ioc_mask;\n+  int ioc_flags;\n+};\n+struct smbioc_oshare {\n+  int ioc_opt;\n+  int ioc_stype;\n+  char ioc_share[129];\n+  char ioc_password[129];\n+  uid_t ioc_owner;\n+  gid_t ioc_group;\n+  mode_t ioc_mode;\n+  mode_t ioc_rights;\n+};\n+struct smbioc_ossn {\n+  int ioc_opt;\n+  uint32_t ioc_svlen;\n+  struct sockaddr *ioc_server;\n+  uint32_t ioc_lolen;\n+  struct sockaddr *ioc_local;\n+  char ioc_srvname[16];\n+  int ioc_timeout;\n+  int ioc_retrycount;\n+  char ioc_localcs[16];\n+  char ioc_servercs[16];\n+  char ioc_user[129];\n+  char ioc_workgroup[129];\n+  char ioc_password[129];\n+  uid_t ioc_owner;\n+  gid_t ioc_group;\n+  mode_t ioc_mode;\n+  mode_t ioc_rights;\n+};\n+struct smbioc_lookup {\n+  int ioc_level;\n+  int ioc_flags;\n+  struct smbioc_ossn ioc_ssn;\n+  struct smbioc_oshare ioc_sh;\n+};\n+struct smbioc_rq {\n+  u_char ioc_cmd;\n+  u_char ioc_twc;\n+  void *ioc_twords;\n+  u_short ioc_tbc;\n+  void *ioc_tbytes;\n+  int ioc_rpbufsz;\n+  char *ioc_rpbuf;\n+  u_char ioc_rwc;\n+  u_short ioc_rbc;\n+};\n+struct smbioc_rw {\n+  u_int16_t ioc_fh;\n+  char *ioc_base;\n+  off_t ioc_offset;\n+  int ioc_cnt;\n+};\n+#define SMBIOC_OPENSESSION _IOW('n', 100, struct smbioc_ossn)\n+#define SMBIOC_OPENSHARE _IOW('n', 101, struct smbioc_oshare)\n+#define SMBIOC_REQUEST _IOWR('n', 102, struct smbioc_rq)\n+#define SMBIOC_T2RQ _IOWR('n', 103, struct smbioc_t2rq)\n+#define SMBIOC_SETFLAGS _IOW('n', 104, struct smbioc_flags)\n+#define SMBIOC_LOOKUP _IOW('n', 106, struct smbioc_lookup)\n+#define SMBIOC_READ _IOWR('n', 107, struct smbioc_rw)\n+#define SMBIOC_WRITE _IOWR('n', 108, struct smbioc_rw)\n+#endif\n #include <dev/biovar.h>\n #include <dev/bluetooth/btdev.h>\n #include <dev/bluetooth/btsco.h>\n@@ -175,7 +299,21 @@\n #include <dev/sun/vuid_event.h>\n #include <dev/tc/sticio.h>\n #include <dev/usb/ukyopon.h>\n+#if !__NetBSD_Prereq__(9, 99, 44)\n #include <dev/usb/urio.h>\n+#else\n+struct urio_command {\n+  unsigned short length;\n+  int request;\n+  int requesttype;\n+  int value;\n+  int index;\n+  void *buffer;\n+  int timeout;\n+};\n+#define URIO_SEND_COMMAND      _IOWR('U', 200, struct urio_command)\n+#define URIO_RECV_COMMAND      _IOWR('U', 201, struct urio_command)\n+#endif\n #include <dev/usb/usb.h>\n #include <dev/usb/utoppy.h>\n #include <dev/vme/xio.h>\n@@ -184,6 +322,7 @@\n #include <dev/wscons/wsdisplay_usl_io.h>\n #include <fs/autofs/autofs_ioctl.h>\n #include <dirent.h>\n+#include <dlfcn.h>\n #include <glob.h>\n #include <grp.h>\n #include <ifaddrs.h>\n@@ -229,9 +368,15 @@\n \n // Include these after system headers to avoid name clashes and ambiguities.\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n #include \"sanitizer_platform_limits_netbsd.h\"\n \n namespace __sanitizer {\n+void *__sanitizer_get_link_map_by_dlopen_handle(void* handle) {\n+  void *p = nullptr;\n+  return internal_dlinfo(handle, RTLD_DI_LINKMAP, &p) == 0 ? p : nullptr;\n+}\n+\n unsigned struct_utsname_sz = sizeof(struct utsname);\n unsigned struct_stat_sz = sizeof(struct stat);\n unsigned struct_rusage_sz = sizeof(struct rusage);\n@@ -240,6 +385,7 @@ unsigned struct_passwd_sz = sizeof(struct passwd);\n unsigned struct_group_sz = sizeof(struct group);\n unsigned siginfo_t_sz = sizeof(siginfo_t);\n unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+unsigned struct_stack_t_sz = sizeof(stack_t);\n unsigned struct_itimerval_sz = sizeof(struct itimerval);\n unsigned pthread_t_sz = sizeof(pthread_t);\n unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);\n@@ -287,6 +433,8 @@ int ptrace_pt_get_event_mask = PT_GET_EVENT_MASK;\n int ptrace_pt_get_process_state = PT_GET_PROCESS_STATE;\n int ptrace_pt_set_siginfo = PT_SET_SIGINFO;\n int ptrace_pt_get_siginfo = PT_GET_SIGINFO;\n+int ptrace_pt_lwpstatus = PT_LWPSTATUS;\n+int ptrace_pt_lwpnext = PT_LWPNEXT;\n int ptrace_piod_read_d = PIOD_READ_D;\n int ptrace_piod_write_d = PIOD_WRITE_D;\n int ptrace_piod_read_i = PIOD_READ_I;\n@@ -319,6 +467,8 @@ int ptrace_pt_getdbregs = -1;\n \n unsigned struct_ptrace_ptrace_io_desc_struct_sz = sizeof(struct ptrace_io_desc);\n unsigned struct_ptrace_ptrace_lwpinfo_struct_sz = sizeof(struct ptrace_lwpinfo);\n+unsigned struct_ptrace_ptrace_lwpstatus_struct_sz =\n+    sizeof(struct __sanitizer_ptrace_lwpstatus);\n unsigned struct_ptrace_ptrace_event_struct_sz = sizeof(ptrace_event_t);\n unsigned struct_ptrace_ptrace_siginfo_struct_sz = sizeof(ptrace_siginfo_t);\n \n@@ -698,6 +848,7 @@ unsigned struct_nvmm_ioc_machine_configure_sz =\n     sizeof(nvmm_ioc_machine_configure);\n unsigned struct_nvmm_ioc_vcpu_create_sz = sizeof(nvmm_ioc_vcpu_create);\n unsigned struct_nvmm_ioc_vcpu_destroy_sz = sizeof(nvmm_ioc_vcpu_destroy);\n+unsigned struct_nvmm_ioc_vcpu_configure_sz = sizeof(nvmm_ioc_vcpu_configure);\n unsigned struct_nvmm_ioc_vcpu_setstate_sz = sizeof(nvmm_ioc_vcpu_destroy);\n unsigned struct_nvmm_ioc_vcpu_getstate_sz = sizeof(nvmm_ioc_vcpu_getstate);\n unsigned struct_nvmm_ioc_vcpu_inject_sz = sizeof(nvmm_ioc_vcpu_inject);\n@@ -1458,6 +1609,7 @@ unsigned IOCTL_NVMM_IOC_MACHINE_DESTROY = NVMM_IOC_MACHINE_DESTROY;\n unsigned IOCTL_NVMM_IOC_MACHINE_CONFIGURE = NVMM_IOC_MACHINE_CONFIGURE;\n unsigned IOCTL_NVMM_IOC_VCPU_CREATE = NVMM_IOC_VCPU_CREATE;\n unsigned IOCTL_NVMM_IOC_VCPU_DESTROY = NVMM_IOC_VCPU_DESTROY;\n+unsigned IOCTL_NVMM_IOC_VCPU_CONFIGURE = NVMM_IOC_VCPU_CONFIGURE;\n unsigned IOCTL_NVMM_IOC_VCPU_SETSTATE = NVMM_IOC_VCPU_SETSTATE;\n unsigned IOCTL_NVMM_IOC_VCPU_GETSTATE = NVMM_IOC_VCPU_GETSTATE;\n unsigned IOCTL_NVMM_IOC_VCPU_INJECT = NVMM_IOC_VCPU_INJECT;\n@@ -1534,6 +1686,7 @@ unsigned IOCTL_IOC_NPF_STATS = IOC_NPF_STATS;\n unsigned IOCTL_IOC_NPF_SAVE = IOC_NPF_SAVE;\n unsigned IOCTL_IOC_NPF_RULE = IOC_NPF_RULE;\n unsigned IOCTL_IOC_NPF_CONN_LOOKUP = IOC_NPF_CONN_LOOKUP;\n+unsigned IOCTL_IOC_NPF_TABLE_REPLACE = IOC_NPF_TABLE_REPLACE;\n unsigned IOCTL_PPPOESETPARMS = PPPOESETPARMS;\n unsigned IOCTL_PPPOEGETPARMS = PPPOEGETPARMS;\n unsigned IOCTL_PPPOEGETSESSION = PPPOEGETSESSION;\n@@ -2392,4 +2545,42 @@ CHECK_SIZE_AND_OFFSET(modctl_load_t, ml_flags);\n CHECK_SIZE_AND_OFFSET(modctl_load_t, ml_props);\n CHECK_SIZE_AND_OFFSET(modctl_load_t, ml_propslen);\n \n+// Compat with 9.0\n+struct statvfs90 {\n+  unsigned long f_flag;\n+  unsigned long f_bsize;\n+  unsigned long f_frsize;\n+  unsigned long f_iosize;\n+\n+  u64 f_blocks;\n+  u64 f_bfree;\n+  u64 f_bavail;\n+  u64 f_bresvd;\n+\n+  u64 f_files;\n+  u64 f_ffree;\n+  u64 f_favail;\n+  u64 f_fresvd;\n+\n+  u64 f_syncreads;\n+  u64 f_syncwrites;\n+\n+  u64 f_asyncreads;\n+  u64 f_asyncwrites;\n+\n+  struct {\n+    s32 __fsid_val[2];\n+  } f_fsidx;\n+  unsigned long f_fsid;\n+  unsigned long f_namemax;\n+  u32 f_owner;\n+\n+  u32 f_spare[4];\n+\n+  char f_fstypename[32];\n+  char f_mntonname[32];\n+  char f_mntfromname[32];\n+};\n+unsigned struct_statvfs90_sz = sizeof(struct statvfs90);\n+\n #endif  // SANITIZER_NETBSD"}, {"sha": "d80280d9bf8c837635435463e80b01354f391f9b", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.h", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -19,18 +19,11 @@\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n \n-#define _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, shift) \\\n-  ((link_map *)((handle) == nullptr ? nullptr : ((char *)(handle) + (shift))))\n-\n-#if defined(__x86_64__)\n-#define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 264)\n-#elif defined(__i386__)\n-#define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 136)\n-#endif\n-\n namespace __sanitizer {\n+void *__sanitizer_get_link_map_by_dlopen_handle(void *handle);\n+# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n+    (link_map *)__sanitizer_get_link_map_by_dlopen_handle(handle)\n+\n extern unsigned struct_utsname_sz;\n extern unsigned struct_stat_sz;\n extern unsigned struct_rusage_sz;\n@@ -48,6 +41,7 @@ extern unsigned struct_timezone_sz;\n extern unsigned struct_tms_sz;\n extern unsigned struct_itimerspec_sz;\n extern unsigned struct_sigevent_sz;\n+extern unsigned struct_stack_t_sz;\n extern unsigned struct_sched_param_sz;\n extern unsigned struct_statfs_sz;\n extern unsigned struct_sockaddr_sz;\n@@ -412,6 +406,8 @@ extern int ptrace_pt_get_event_mask;\n extern int ptrace_pt_get_process_state;\n extern int ptrace_pt_set_siginfo;\n extern int ptrace_pt_get_siginfo;\n+extern int ptrace_pt_lwpstatus;\n+extern int ptrace_pt_lwpnext;\n extern int ptrace_piod_read_d;\n extern int ptrace_piod_write_d;\n extern int ptrace_piod_read_i;\n@@ -436,8 +432,17 @@ struct __sanitizer_ptrace_lwpinfo {\n   int pl_event;\n };\n \n+struct __sanitizer_ptrace_lwpstatus {\n+  __sanitizer_lwpid_t pl_lwpid;\n+  __sanitizer_sigset_t pl_sigpend;\n+  __sanitizer_sigset_t pl_sigmask;\n+  char pl_name[20];\n+  void *pl_private;\n+};\n+\n extern unsigned struct_ptrace_ptrace_io_desc_struct_sz;\n extern unsigned struct_ptrace_ptrace_lwpinfo_struct_sz;\n+extern unsigned struct_ptrace_ptrace_lwpstatus_struct_sz;\n extern unsigned struct_ptrace_ptrace_event_struct_sz;\n extern unsigned struct_ptrace_ptrace_siginfo_struct_sz;\n \n@@ -862,6 +867,7 @@ extern unsigned struct_nvmm_ioc_machine_destroy_sz;\n extern unsigned struct_nvmm_ioc_machine_configure_sz;\n extern unsigned struct_nvmm_ioc_vcpu_create_sz;\n extern unsigned struct_nvmm_ioc_vcpu_destroy_sz;\n+extern unsigned struct_nvmm_ioc_vcpu_configure_sz;\n extern unsigned struct_nvmm_ioc_vcpu_setstate_sz;\n extern unsigned struct_nvmm_ioc_vcpu_getstate_sz;\n extern unsigned struct_nvmm_ioc_vcpu_inject_sz;\n@@ -1611,6 +1617,7 @@ extern unsigned IOCTL_NVMM_IOC_MACHINE_DESTROY;\n extern unsigned IOCTL_NVMM_IOC_MACHINE_CONFIGURE;\n extern unsigned IOCTL_NVMM_IOC_VCPU_CREATE;\n extern unsigned IOCTL_NVMM_IOC_VCPU_DESTROY;\n+extern unsigned IOCTL_NVMM_IOC_VCPU_CONFIGURE;\n extern unsigned IOCTL_NVMM_IOC_VCPU_SETSTATE;\n extern unsigned IOCTL_NVMM_IOC_VCPU_GETSTATE;\n extern unsigned IOCTL_NVMM_IOC_VCPU_INJECT;\n@@ -1685,6 +1692,7 @@ extern unsigned IOCTL_IOC_NPF_STATS;\n extern unsigned IOCTL_IOC_NPF_SAVE;\n extern unsigned IOCTL_IOC_NPF_RULE;\n extern unsigned IOCTL_IOC_NPF_CONN_LOOKUP;\n+extern unsigned IOCTL_IOC_NPF_TABLE_REPLACE;\n extern unsigned IOCTL_PPPOESETPARMS;\n extern unsigned IOCTL_PPPOEGETPARMS;\n extern unsigned IOCTL_PPPOEGETSESSION;\n@@ -2406,6 +2414,9 @@ struct __sanitizer_cdbw {\n \n #define SIGACTION_SYMNAME __sigaction14\n \n+// Compat with 9.0\n+extern unsigned struct_statvfs90_sz;\n+\n #endif  // SANITIZER_NETBSD\n \n #endif"}, {"sha": "1420ecbfa568479b17a7aac28ffe27b036add125", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_openbsd.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -72,6 +72,7 @@ unsigned struct_passwd_sz = sizeof(struct passwd);\n unsigned struct_group_sz = sizeof(struct group);\n unsigned siginfo_t_sz = sizeof(siginfo_t);\n unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+unsigned struct_stack_t_sz = sizeof(stack_t);\n unsigned struct_itimerval_sz = sizeof(struct itimerval);\n unsigned pthread_t_sz = sizeof(pthread_t);\n unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);"}, {"sha": "8a1948723605e3f8548364b5cdf96e9daaeb0c38", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_openbsd.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -50,6 +50,7 @@ extern unsigned struct_timezone_sz;\n extern unsigned struct_tms_sz;\n extern unsigned struct_itimerspec_sz;\n extern unsigned struct_sigevent_sz;\n+extern unsigned struct_stack_t_sz;\n extern unsigned struct_statfs_sz;\n extern unsigned struct_sockaddr_sz;\n "}, {"sha": "e71515f12e94e6fb8ac06b53c83c49dee84f3720", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -179,6 +179,7 @@ namespace __sanitizer {\n   unsigned struct_group_sz = sizeof(struct group);\n   unsigned siginfo_t_sz = sizeof(siginfo_t);\n   unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+  unsigned struct_stack_t_sz = sizeof(stack_t);\n   unsigned struct_itimerval_sz = sizeof(struct itimerval);\n   unsigned pthread_t_sz = sizeof(pthread_t);\n   unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);"}, {"sha": "f6c8a1450a9323e2725146cfc4e83b2f2faf88f8", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -47,6 +47,7 @@ extern unsigned struct_timezone_sz;\n extern unsigned struct_tms_sz;\n extern unsigned struct_itimerspec_sz;\n extern unsigned struct_sigevent_sz;\n+extern unsigned struct_stack_t_sz;\n extern unsigned struct_sched_param_sz;\n extern unsigned struct_statfs64_sz;\n extern unsigned struct_regex_sz;\n@@ -82,7 +83,7 @@ const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__mips__)\n const unsigned struct_kernel_stat_sz = SANITIZER_ANDROID\n                                            ? FIRST_32_SECOND_64(104, 128)\n-                                           : FIRST_32_SECOND_64(144, 216);\n+                                           : FIRST_32_SECOND_64(160, 216);\n const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n const unsigned struct_kernel_stat_sz = 64;"}, {"sha": "6ec1a1bdd114cf32a37b8d73be433d8997c35122", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -72,6 +72,7 @@ namespace __sanitizer {\n   unsigned struct_group_sz = sizeof(struct group);\n   unsigned siginfo_t_sz = sizeof(siginfo_t);\n   unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+  unsigned struct_stack_t_sz = sizeof(stack_t);\n   unsigned struct_itimerval_sz = sizeof(struct itimerval);\n   unsigned pthread_t_sz = sizeof(pthread_t);\n   unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);"}, {"sha": "85995e79792d211910676a2cd04337e20125a487", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -38,6 +38,7 @@ extern unsigned struct_timezone_sz;\n extern unsigned struct_tms_sz;\n extern unsigned struct_itimerspec_sz;\n extern unsigned struct_sigevent_sz;\n+extern unsigned struct_stack_t_sz;\n extern unsigned struct_sched_param_sz;\n extern unsigned struct_statfs64_sz;\n extern unsigned struct_statfs_sz;"}, {"sha": "e21661b42f8d2725ab1005bb5d93b023ffbf60bc", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cpp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -347,9 +347,17 @@ int GetNamedMappingFd(const char *name, uptr size, int *flags) {\n   CHECK(internal_strlen(name) < sizeof(shmname) - 10);\n   internal_snprintf(shmname, sizeof(shmname), \"/dev/shm/%zu [%s]\",\n                     internal_getpid(), name);\n+  int o_cloexec = 0;\n+#if defined(O_CLOEXEC)\n+  o_cloexec = O_CLOEXEC;\n+#endif\n   int fd = ReserveStandardFds(\n-      internal_open(shmname, O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, S_IRWXU));\n+      internal_open(shmname, O_RDWR | O_CREAT | O_TRUNC | o_cloexec, S_IRWXU));\n   CHECK_GE(fd, 0);\n+  if (!o_cloexec) {\n+    int res = fcntl(fd, F_SETFD, FD_CLOEXEC);\n+    CHECK_EQ(0, res);\n+  }\n   int res = internal_ftruncate(fd, size);\n   CHECK_EQ(0, res);\n   res = internal_unlink(shmname);"}, {"sha": "a1b49702da23b7ec5fa9f0e4cb18ccec727509c2", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -39,7 +39,7 @@ uptr internal_write(fd_t fd, const void *buf, uptr count);\n \n // Memory\n uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n-                   int fd, OFF_T offset);\n+                   int fd, u64 offset);\n uptr internal_munmap(void *addr, uptr length);\n int internal_mprotect(void *addr, uptr length, int prot);\n \n@@ -63,7 +63,7 @@ uptr internal_ptrace(int request, int pid, void *addr, void *data);\n uptr internal_waitpid(int pid, int *status, int options);\n \n int internal_fork();\n-fd_t internal_spawn(const char *argv[], pid_t *pid);\n+fd_t internal_spawn(const char *argv[], const char *envp[], pid_t *pid);\n \n int internal_sysctl(const int *name, unsigned int namelen, void *oldp,\n                     uptr *oldlenp, const void *newp, uptr newlen);"}, {"sha": "f920172c06d634963b4d20a1748fc913f22d3e25", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -426,7 +426,8 @@ void AdjustStackSize(void *attr_) {\n #endif // !SANITIZER_GO\n \n pid_t StartSubprocess(const char *program, const char *const argv[],\n-                      fd_t stdin_fd, fd_t stdout_fd, fd_t stderr_fd) {\n+                      const char *const envp[], fd_t stdin_fd, fd_t stdout_fd,\n+                      fd_t stderr_fd) {\n   auto file_closer = at_scope_exit([&] {\n     if (stdin_fd != kInvalidFd) {\n       internal_close(stdin_fd);\n@@ -469,7 +470,8 @@ pid_t StartSubprocess(const char *program, const char *const argv[],\n \n     for (int fd = sysconf(_SC_OPEN_MAX); fd > 2; fd--) internal_close(fd);\n \n-    execv(program, const_cast<char **>(&argv[0]));\n+    internal_execve(program, const_cast<char **>(&argv[0]),\n+                    const_cast<char *const *>(envp));\n     internal__exit(1);\n   }\n "}, {"sha": "665ed45fa93e1c45566c6609294a56dadfd29774", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -15,18 +15,19 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD ||                \\\n-    SANITIZER_OPENBSD || SANITIZER_MAC || SANITIZER_SOLARIS\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n+    SANITIZER_OPENBSD || SANITIZER_MAC || SANITIZER_SOLARIS ||  \\\n+    SANITIZER_FUCHSIA\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_fuchsia.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_mac.h\"\n #include \"sanitizer_mutex.h\"\n \n namespace __sanitizer {\n \n-\n // Memory protection masks.\n static const uptr kProtectionRead = 1;\n static const uptr kProtectionWrite = 2;"}, {"sha": "cc3e9be06458e4999f46105ac5a0bfab5776d9b1", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_fuchsia.cpp", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_fuchsia.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,80 @@\n+//===-- sanitizer_procmaps_fuchsia.cpp\n+//----------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Information about the process mappings (Fuchsia-specific parts).\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_FUCHSIA\n+#include <zircon/process.h>\n+#include <zircon/syscalls.h>\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+namespace __sanitizer {\n+\n+// The cache flag is ignored on Fuchsia because a process can always get this\n+// information via its process-self handle.\n+MemoryMappingLayout::MemoryMappingLayout(bool) { Reset(); }\n+\n+void MemoryMappingLayout::Reset() {\n+  data_.data.clear();\n+  data_.current = 0;\n+\n+  size_t count;\n+  zx_status_t status = _zx_object_get_info(\n+      _zx_process_self(), ZX_INFO_PROCESS_MAPS, nullptr, 0, nullptr, &count);\n+  if (status != ZX_OK) {\n+    return;\n+  }\n+\n+  size_t filled;\n+  do {\n+    data_.data.resize(count);\n+    status = _zx_object_get_info(\n+        _zx_process_self(), ZX_INFO_PROCESS_MAPS, data_.data.data(),\n+        count * sizeof(zx_info_maps_t), &filled, &count);\n+    if (status != ZX_OK) {\n+      data_.data.clear();\n+      return;\n+    }\n+  } while (filled < count);\n+}\n+\n+MemoryMappingLayout::~MemoryMappingLayout() {}\n+\n+bool MemoryMappingLayout::Error() const { return data_.data.empty(); }\n+\n+bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n+  while (data_.current < data_.data.size()) {\n+    const auto &entry = data_.data[data_.current++];\n+    if (entry.type == ZX_INFO_MAPS_TYPE_MAPPING) {\n+      segment->start = entry.base;\n+      segment->end = entry.base + entry.size;\n+      segment->offset = entry.u.mapping.vmo_offset;\n+      const auto flags = entry.u.mapping.mmu_flags;\n+      segment->protection =\n+          ((flags & ZX_VM_PERM_READ) ? kProtectionRead : 0) |\n+          ((flags & ZX_VM_PERM_WRITE) ? kProtectionWrite : 0) |\n+          ((flags & ZX_VM_PERM_EXECUTE) ? kProtectionExecute : 0);\n+      if (segment->filename && segment->filename_size > 0) {\n+        uptr len = Min(sizeof(entry.name), segment->filename_size) - 1;\n+        internal_strncpy(segment->filename, entry.name, len);\n+        segment->filename[len] = 0;\n+      }\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FUCHSIA"}, {"sha": "4d0d96a64f622f07adf9ae0363e0bc461deaaca3", "filename": "libsanitizer/sanitizer_common/sanitizer_ptrauth.h", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,21 @@\n+//===-- sanitizer_ptrauth.h -------------------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_PTRAUTH_H\n+#define SANITIZER_PTRAUTH_H\n+\n+#if __has_feature(ptrauth_calls)\n+#include <ptrauth.h>\n+#else\n+// Copied from <ptrauth.h>\n+#define ptrauth_strip(__value, __key) __value\n+#define ptrauth_auth_data(__value, __old_key, __old_data) __value\n+#define ptrauth_string_discriminator(__string) ((int)0)\n+#endif\n+\n+#endif // SANITIZER_PTRAUTH_H"}, {"sha": "29bcfcfa6f1581a456e9a5183e8de51a14d1c834", "filename": "libsanitizer/sanitizer_common/sanitizer_rtems.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -49,6 +49,10 @@ uptr internal_getpid() {\n   return getpid();\n }\n \n+int internal_dlinfo(void *handle, int request, void *p) {\n+  UNIMPLEMENTED();\n+}\n+\n bool FileExists(const char *filename) {\n   struct stat st;\n   if (stat(filename, &st))"}, {"sha": "ef14fb704eed394acf0be36505eaae5f952fa6d2", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -60,8 +60,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -84,21 +84,14 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n #else"}, {"sha": "3a246443ed9953f37c259bf386f6abe0827b7c3b", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_fuchsia.cpp", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_fuchsia.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -0,0 +1,42 @@\n+//===-- sanitizer_stoptheworld_fuchsia.cpp -------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// See sanitizer_stoptheworld.h for details.\n+//\n+//===---------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_FUCHSIA\n+\n+#include <zircon/sanitizer.h>\n+\n+#include \"sanitizer_stoptheworld.h\"\n+\n+namespace __sanitizer {\n+\n+// The Fuchsia implementation stops the world but doesn't offer a real\n+// SuspendedThreadsList argument.  This is enough for ASan's use case,\n+// and LSan does not use this API on Fuchsia.\n+void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n+  struct Params {\n+    StopTheWorldCallback callback;\n+    void *argument;\n+  } params = {callback, argument};\n+  __sanitizer_memory_snapshot(\n+      nullptr, nullptr, nullptr, nullptr,\n+      [](zx_status_t, void *data) {\n+        auto params = reinterpret_cast<Params *>(data);\n+        params->callback({}, params->argument);\n+      },\n+      &params);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FUCHSIA"}, {"sha": "6c577426ad566af339d1b634b4ec3aa37f974cfa", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_mac.cpp", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -50,7 +50,7 @@ struct RunThreadArgs {\n   void *argument;\n };\n \n-void RunThread(void *arg) {\n+void *RunThread(void *arg) {\n   struct RunThreadArgs *run_args = (struct RunThreadArgs *)arg;\n   SuspendedThreadsListMac suspended_threads_list;\n \n@@ -59,7 +59,7 @@ void RunThread(void *arg) {\n   kern_return_t err = task_threads(mach_task_self(), &threads, &num_threads);\n   if (err != KERN_SUCCESS) {\n     VReport(1, \"Failed to get threads for task (errno %d).\\n\", err);\n-    return;\n+    return nullptr;\n   }\n \n   thread_t thread_self = mach_thread_self();\n@@ -76,6 +76,7 @@ void RunThread(void *arg) {\n   for (unsigned int i = 0; i < num_suspended; ++i) {\n     thread_resume(suspended_threads_list.GetThread(i));\n   }\n+  return nullptr;\n }\n \n void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n@@ -159,7 +160,11 @@ PtraceRegistersStatus SuspendedThreadsListMac::GetRegistersAndSP(\n   }\n \n   internal_memcpy(buffer, &regs, sizeof(regs));\n+#if defined(__aarch64__) && defined(arm_thread_state64_get_sp)\n+  *sp = arm_thread_state64_get_sp(regs);\n+#else\n   *sp = regs.SP_REG;\n+#endif\n \n   // On x86_64 and aarch64, we must account for the stack redzone, which is 128\n   // bytes."}, {"sha": "1ed21343254d5fa0f4a372d5e7eee5ba8ecc88a0", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_netbsd_libcdep.cpp", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -120,10 +120,18 @@ bool ThreadSuspender::SuspendAllThreads() {\n \n   VReport(2, \"Attached to process %d.\\n\", pid_);\n \n+#ifdef PT_LWPNEXT\n+  struct ptrace_lwpstatus pl;\n+  int op = PT_LWPNEXT;\n+#else\n   struct ptrace_lwpinfo pl;\n-  int val;\n+  int op = PT_LWPINFO;\n+#endif\n+\n   pl.pl_lwpid = 0;\n-  while ((val = ptrace(PT_LWPINFO, pid_, (void *)&pl, sizeof(pl))) != -1 &&\n+\n+  int val;\n+  while ((val = ptrace(op, pid_, (void *)&pl, sizeof(pl))) != -1 &&\n          pl.pl_lwpid != 0) {\n     suspended_threads_list_.Append(pl.pl_lwpid);\n     VReport(2, \"Appended thread %d in process %d.\\n\", pl.pl_lwpid, pid_);"}, {"sha": "0c4b84c767aa153f87674462da96e99377997cab", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -126,4 +126,10 @@ Symbolizer::SymbolizerScope::~SymbolizerScope() {\n     sym_->end_hook_();\n }\n \n+void Symbolizer::LateInitializeTools() {\n+  for (auto &tool : tools_) {\n+    tool.LateInitialize();\n+  }\n+}\n+\n }  // namespace __sanitizer"}, {"sha": "2476b0ea7bf7d858e99269433fc1625f1973c9e1", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -209,6 +209,9 @@ class Symbolizer final {\n    private:\n     const Symbolizer *sym_;\n   };\n+\n+  // Calls `LateInitialize()` on all items in `tools_`.\n+  void LateInitializeTools();\n };\n \n #ifdef SANITIZER_WINDOWS"}, {"sha": "e4c351e667b4d3d630ec5587903da12e9badf30e", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_internal.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -69,6 +69,11 @@ class SymbolizerTool {\n   virtual const char *Demangle(const char *name) {\n     return nullptr;\n   }\n+\n+  // Called during the LateInitialize phase of Sanitizer initialization.\n+  // Usually this is a safe place to call code that might need to use user\n+  // memory allocators.\n+  virtual void LateInitialize() {}\n };\n \n // SymbolizerProcess encapsulates communication between the tool and\n@@ -86,6 +91,8 @@ class SymbolizerProcess {\n   // Customizable by subclasses.\n   virtual bool StartSymbolizerSubprocess();\n   virtual bool ReadFromSymbolizer(char *buffer, uptr max_length);\n+  // Return the environment to run the symbolizer in.\n+  virtual char **GetEnvP() { return GetEnviron(); }\n \n  private:\n   virtual bool ReachedEndOfOutput(const char *buffer, uptr length) const {"}, {"sha": "490c6fe89beb5bfc2681aeb6dbd679e0c2c475b8", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cpp", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -39,29 +39,29 @@ const char *ExtractToken(const char *str, const char *delims, char **result) {\n }\n \n const char *ExtractInt(const char *str, const char *delims, int *result) {\n-  char *buff;\n+  char *buff = nullptr;\n   const char *ret = ExtractToken(str, delims, &buff);\n-  if (buff != 0) {\n+  if (buff) {\n     *result = (int)internal_atoll(buff);\n   }\n   InternalFree(buff);\n   return ret;\n }\n \n const char *ExtractUptr(const char *str, const char *delims, uptr *result) {\n-  char *buff;\n+  char *buff = nullptr;\n   const char *ret = ExtractToken(str, delims, &buff);\n-  if (buff != 0) {\n+  if (buff) {\n     *result = (uptr)internal_atoll(buff);\n   }\n   InternalFree(buff);\n   return ret;\n }\n \n const char *ExtractSptr(const char *str, const char *delims, sptr *result) {\n-  char *buff;\n+  char *buff = nullptr;\n   const char *ret = ExtractToken(str, delims, &buff);\n-  if (buff != 0) {\n+  if (buff) {\n     *result = (sptr)internal_atoll(buff);\n   }\n   InternalFree(buff);\n@@ -83,7 +83,7 @@ const char *ExtractTokenUpToDelimiter(const char *str, const char *delimiter,\n \n SymbolizedStack *Symbolizer::SymbolizePC(uptr addr) {\n   BlockingMutexLock l(&mu_);\n-  const char *module_name;\n+  const char *module_name = nullptr;\n   uptr module_offset;\n   ModuleArch arch;\n   SymbolizedStack *res = SymbolizedStack::New(addr);\n@@ -103,7 +103,7 @@ SymbolizedStack *Symbolizer::SymbolizePC(uptr addr) {\n \n bool Symbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n   BlockingMutexLock l(&mu_);\n-  const char *module_name;\n+  const char *module_name = nullptr;\n   uptr module_offset;\n   ModuleArch arch;\n   if (!FindModuleNameAndOffsetForAddress(addr, &module_name, &module_offset,\n@@ -124,7 +124,7 @@ bool Symbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n \n bool Symbolizer::SymbolizeFrame(uptr addr, FrameInfo *info) {\n   BlockingMutexLock l(&mu_);\n-  const char *module_name;\n+  const char *module_name = nullptr;\n   if (!FindModuleNameAndOffsetForAddress(\n           addr, &module_name, &info->module_offset, &info->module_arch))\n     return false;\n@@ -175,7 +175,7 @@ bool Symbolizer::FindModuleNameAndOffsetForAddress(uptr address,\n                                                    uptr *module_offset,\n                                                    ModuleArch *module_arch) {\n   const LoadedModule *module = FindModuleForAddress(address);\n-  if (module == nullptr)\n+  if (!module)\n     return false;\n   *module_name = module->full_name();\n   *module_offset = address - module->base_address();\n@@ -292,7 +292,7 @@ LLVMSymbolizer::LLVMSymbolizer(const char *path, LowLevelAllocator *allocator)\n // Windows, so extract tokens from the right hand side first. The column info is\n // also optional.\n static const char *ParseFileLineInfo(AddressInfo *info, const char *str) {\n-  char *file_line_info = 0;\n+  char *file_line_info = nullptr;\n   str = ExtractToken(str, \"\\n\", &file_line_info);\n   CHECK(file_line_info);\n \n@@ -323,7 +323,7 @@ void ParseSymbolizePCOutput(const char *str, SymbolizedStack *res) {\n   bool top_frame = true;\n   SymbolizedStack *last = res;\n   while (true) {\n-    char *function_name = 0;\n+    char *function_name = nullptr;\n     str = ExtractToken(str, \"\\n\", &function_name);\n     CHECK(function_name);\n     if (function_name[0] == '\\0') {\n@@ -402,54 +402,51 @@ bool LLVMSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   AddressInfo *info = &stack->info;\n   const char *buf = FormatAndSendCommand(\n       \"CODE\", info->module, info->module_offset, info->module_arch);\n-  if (buf) {\n-    ParseSymbolizePCOutput(buf, stack);\n-    return true;\n-  }\n-  return false;\n+  if (!buf)\n+    return false;\n+  ParseSymbolizePCOutput(buf, stack);\n+  return true;\n }\n \n bool LLVMSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n   const char *buf = FormatAndSendCommand(\n       \"DATA\", info->module, info->module_offset, info->module_arch);\n-  if (buf) {\n-    ParseSymbolizeDataOutput(buf, info);\n-    info->start += (addr - info->module_offset); // Add the base address.\n-    return true;\n-  }\n-  return false;\n+  if (!buf)\n+    return false;\n+  ParseSymbolizeDataOutput(buf, info);\n+  info->start += (addr - info->module_offset); // Add the base address.\n+  return true;\n }\n \n bool LLVMSymbolizer::SymbolizeFrame(uptr addr, FrameInfo *info) {\n   const char *buf = FormatAndSendCommand(\n       \"FRAME\", info->module, info->module_offset, info->module_arch);\n-  if (buf) {\n-    ParseSymbolizeFrameOutput(buf, &info->locals);\n-    return true;\n-  }\n-  return false;\n+  if (!buf)\n+    return false;\n+  ParseSymbolizeFrameOutput(buf, &info->locals);\n+  return true;\n }\n \n const char *LLVMSymbolizer::FormatAndSendCommand(const char *command_prefix,\n                                                  const char *module_name,\n                                                  uptr module_offset,\n                                                  ModuleArch arch) {\n   CHECK(module_name);\n-  if (arch == kModuleArchUnknown) {\n-    if (internal_snprintf(buffer_, kBufferSize, \"%s \\\"%s\\\" 0x%zx\\n\",\n-                          command_prefix, module_name,\n-                          module_offset) >= static_cast<int>(kBufferSize)) {\n-      Report(\"WARNING: Command buffer too small\");\n-      return nullptr;\n-    }\n-  } else {\n-    if (internal_snprintf(buffer_, kBufferSize, \"%s \\\"%s:%s\\\" 0x%zx\\n\",\n-                          command_prefix, module_name, ModuleArchToString(arch),\n-                          module_offset) >= static_cast<int>(kBufferSize)) {\n-      Report(\"WARNING: Command buffer too small\");\n-      return nullptr;\n-    }\n+  int size_needed = 0;\n+  if (arch == kModuleArchUnknown)\n+    size_needed = internal_snprintf(buffer_, kBufferSize, \"%s \\\"%s\\\" 0x%zx\\n\",\n+                                    command_prefix, module_name, module_offset);\n+  else\n+    size_needed = internal_snprintf(buffer_, kBufferSize,\n+                                    \"%s \\\"%s:%s\\\" 0x%zx\\n\", command_prefix,\n+                                    module_name, ModuleArchToString(arch),\n+                                    module_offset);\n+\n+  if (size_needed >= static_cast<int>(kBufferSize)) {\n+    Report(\"WARNING: Command buffer too small\");\n+    return nullptr;\n   }\n+\n   return symbolizer_process_->SendCommand(buffer_);\n }\n \n@@ -492,16 +489,16 @@ const char *SymbolizerProcess::SendCommand(const char *command) {\n     Report(\"WARNING: Failed to use and restart external symbolizer!\\n\");\n     failed_to_start_ = true;\n   }\n-  return 0;\n+  return nullptr;\n }\n \n const char *SymbolizerProcess::SendCommandImpl(const char *command) {\n   if (input_fd_ == kInvalidFd || output_fd_ == kInvalidFd)\n-      return 0;\n+      return nullptr;\n   if (!WriteToSymbolizer(command, internal_strlen(command)))\n-      return 0;\n+      return nullptr;\n   if (!ReadFromSymbolizer(buffer_, kBufferSize))\n-      return 0;\n+      return nullptr;\n   return buffer_;\n }\n "}, {"sha": "cc233408d0cebfc19a17f40803a80b09c2b8f157", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cpp", "status": "modified", "additions": 82, "deletions": 6, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -20,6 +20,7 @@\n \n #include <dlfcn.h>\n #include <errno.h>\n+#include <mach/mach.h>\n #include <stdlib.h>\n #include <sys/wait.h>\n #include <unistd.h>\n@@ -31,6 +32,9 @@ bool DlAddrSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   Dl_info info;\n   int result = dladdr((const void *)addr, &info);\n   if (!result) return false;\n+\n+  CHECK(addr >= reinterpret_cast<uptr>(info.dli_saddr));\n+  stack->info.function_offset = addr - reinterpret_cast<uptr>(info.dli_saddr);\n   const char *demangled = DemangleSwiftAndCXX(info.dli_sname);\n   if (!demangled) return false;\n   stack->info.function = internal_strdup(demangled);\n@@ -47,18 +51,65 @@ bool DlAddrSymbolizer::SymbolizeData(uptr addr, DataInfo *datainfo) {\n   return true;\n }\n \n+#define K_ATOS_ENV_VAR \"__check_mach_ports_lookup\"\n+\n+// This cannot live in `AtosSymbolizerProcess` because instances of that object\n+// are allocated by the internal allocator which under ASan is poisoned with\n+// kAsanInternalHeapMagic.\n+static char kAtosMachPortEnvEntry[] = K_ATOS_ENV_VAR \"=000000000000000\";\n+\n class AtosSymbolizerProcess : public SymbolizerProcess {\n  public:\n-  explicit AtosSymbolizerProcess(const char *path, pid_t parent_pid)\n+  explicit AtosSymbolizerProcess(const char *path)\n       : SymbolizerProcess(path, /*use_posix_spawn*/ true) {\n-    // Put the string command line argument in the object so that it outlives\n-    // the call to GetArgV.\n-    internal_snprintf(pid_str_, sizeof(pid_str_), \"%d\", parent_pid);\n+    pid_str_[0] = '\\0';\n+  }\n+\n+  void LateInitialize() {\n+    if (SANITIZER_IOSSIM) {\n+      // `putenv()` may call malloc/realloc so it is only safe to do this\n+      // during LateInitialize() or later (i.e. we can't do this in the\n+      // constructor).  We also can't do this in `StartSymbolizerSubprocess()`\n+      // because in TSan we switch allocators when we're symbolizing.\n+      // We use `putenv()` rather than `setenv()` so that we can later directly\n+      // write into the storage without LibC getting involved to change what the\n+      // variable is set to\n+      int result = putenv(kAtosMachPortEnvEntry);\n+      CHECK_EQ(result, 0);\n+    }\n   }\n \n  private:\n   bool StartSymbolizerSubprocess() override {\n     // Configure sandbox before starting atos process.\n+\n+    // Put the string command line argument in the object so that it outlives\n+    // the call to GetArgV.\n+    internal_snprintf(pid_str_, sizeof(pid_str_), \"%d\", internal_getpid());\n+\n+    if (SANITIZER_IOSSIM) {\n+      // `atos` in the simulator is restricted in its ability to retrieve the\n+      // task port for the target process (us) so we need to do extra work\n+      // to pass our task port to it.\n+      mach_port_t ports[]{mach_task_self()};\n+      kern_return_t ret =\n+          mach_ports_register(mach_task_self(), ports, /*count=*/1);\n+      CHECK_EQ(ret, KERN_SUCCESS);\n+\n+      // Set environment variable that signals to `atos` that it should look\n+      // for our task port. We can't call `setenv()` here because it might call\n+      // malloc/realloc. To avoid that we instead update the\n+      // `mach_port_env_var_entry_` variable with our current PID.\n+      uptr count = internal_snprintf(kAtosMachPortEnvEntry,\n+                                     sizeof(kAtosMachPortEnvEntry),\n+                                     K_ATOS_ENV_VAR \"=%s\", pid_str_);\n+      CHECK_GE(count, sizeof(K_ATOS_ENV_VAR) + internal_strlen(pid_str_));\n+      // Document our assumption but without calling `getenv()` in normal\n+      // builds.\n+      DCHECK(getenv(K_ATOS_ENV_VAR));\n+      DCHECK_EQ(internal_strcmp(getenv(K_ATOS_ENV_VAR), pid_str_), 0);\n+    }\n+\n     return SymbolizerProcess::StartSymbolizerSubprocess();\n   }\n \n@@ -82,8 +133,14 @@ class AtosSymbolizerProcess : public SymbolizerProcess {\n   }\n \n   char pid_str_[16];\n+  // Space for `\\0` in `K_ATOS_ENV_VAR` is reused for `=`.\n+  static_assert(sizeof(kAtosMachPortEnvEntry) ==\n+                    (sizeof(K_ATOS_ENV_VAR) + sizeof(pid_str_)),\n+                \"sizes should match\");\n };\n \n+#undef K_ATOS_ENV_VAR\n+\n static bool ParseCommandOutput(const char *str, uptr addr, char **out_name,\n                                char **out_module, char **out_file, uptr *line,\n                                uptr *start_address) {\n@@ -135,7 +192,7 @@ static bool ParseCommandOutput(const char *str, uptr addr, char **out_name,\n }\n \n AtosSymbolizer::AtosSymbolizer(const char *path, LowLevelAllocator *allocator)\n-    : process_(new(*allocator) AtosSymbolizerProcess(path, getpid())) {}\n+    : process_(new (*allocator) AtosSymbolizerProcess(path)) {}\n \n bool AtosSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   if (!process_) return false;\n@@ -145,12 +202,29 @@ bool AtosSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   const char *buf = process_->SendCommand(command);\n   if (!buf) return false;\n   uptr line;\n+  uptr start_address = AddressInfo::kUnknown;\n   if (!ParseCommandOutput(buf, addr, &stack->info.function, &stack->info.module,\n-                          &stack->info.file, &line, nullptr)) {\n+                          &stack->info.file, &line, &start_address)) {\n     process_ = nullptr;\n     return false;\n   }\n   stack->info.line = (int)line;\n+\n+  if (start_address == AddressInfo::kUnknown) {\n+    // Fallback to dladdr() to get function start address if atos doesn't report\n+    // it.\n+    Dl_info info;\n+    int result = dladdr((const void *)addr, &info);\n+    if (result)\n+      start_address = reinterpret_cast<uptr>(info.dli_saddr);\n+  }\n+\n+  // Only assig to `function_offset` if we were able to get the function's\n+  // start address.\n+  if (start_address != AddressInfo::kUnknown) {\n+    CHECK(addr >= start_address);\n+    stack->info.function_offset = addr - start_address;\n+  }\n   return true;\n }\n \n@@ -168,6 +242,8 @@ bool AtosSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n   return true;\n }\n \n+void AtosSymbolizer::LateInitialize() { process_->LateInitialize(); }\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_MAC"}, {"sha": "8996131fc138508cb9074fd8d69d8df4ef05a5bc", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -35,6 +35,7 @@ class AtosSymbolizer : public SymbolizerTool {\n \n   bool SymbolizePC(uptr addr, SymbolizedStack *stack) override;\n   bool SymbolizeData(uptr addr, DataInfo *info) override;\n+  void LateInitialize() override;\n \n  private:\n   AtosSymbolizerProcess *process_;"}, {"sha": "2963af953609e3e18c28db1e7393261076150f6f", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_markup.cpp", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -94,7 +94,9 @@ Symbolizer *Symbolizer::PlatformInit() {\n   return new (symbolizer_allocator_) Symbolizer({});\n }\n \n-void Symbolizer::LateInitialize() { Symbolizer::GetOrInit(); }\n+void Symbolizer::LateInitialize() {\n+  Symbolizer::GetOrInit()->LateInitializeTools();\n+}\n \n void StartReportDeadlySignal() {}\n void ReportDeadlySignal(const SignalContext &sig, u32 tid,"}, {"sha": "d7b931bc23795deabbef0febaba039903a07ad27", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cpp", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -151,9 +151,19 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n   GetArgV(path_, argv);\n   pid_t pid;\n \n+  // Report how symbolizer is being launched for debugging purposes.\n+  if (Verbosity() >= 3) {\n+    // Only use `Report` for first line so subsequent prints don't get prefixed\n+    // with current PID.\n+    Report(\"Launching Symbolizer process: \");\n+    for (unsigned index = 0; index < kArgVMax && argv[index]; ++index)\n+      Printf(\"%s \", argv[index]);\n+    Printf(\"\\n\");\n+  }\n+\n   if (use_posix_spawn_) {\n #if SANITIZER_MAC\n-    fd_t fd = internal_spawn(argv, &pid);\n+    fd_t fd = internal_spawn(argv, const_cast<const char **>(GetEnvP()), &pid);\n     if (fd == kInvalidFd) {\n       Report(\"WARNING: failed to spawn external symbolizer (errno: %d)\\n\",\n              errno);\n@@ -173,7 +183,7 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n       return false;\n     }\n \n-    pid = StartSubprocess(path_, argv, /* stdin */ outfd[0],\n+    pid = StartSubprocess(path_, argv, GetEnvP(), /* stdin */ outfd[0],\n                           /* stdout */ infd[1]);\n     if (pid < 0) {\n       internal_close(infd[0]);\n@@ -478,7 +488,7 @@ Symbolizer *Symbolizer::PlatformInit() {\n }\n \n void Symbolizer::LateInitialize() {\n-  Symbolizer::GetOrInit();\n+  Symbolizer::GetOrInit()->LateInitializeTools();\n   InitializeSwiftDemangler();\n }\n "}, {"sha": "373437e7ee2ad2d3b357ac519bfb105d5b59a25f", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -310,7 +310,7 @@ Symbolizer *Symbolizer::PlatformInit() {\n }\n \n void Symbolizer::LateInitialize() {\n-  Symbolizer::GetOrInit();\n+  Symbolizer::GetOrInit()->LateInitializeTools();\n }\n \n }  // namespace __sanitizer"}, {"sha": "02b7e11b1677f49e9f371d97d1905849a8c4a796", "filename": "libsanitizer/sanitizer_common/sanitizer_syscalls_netbsd.inc", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -42,7 +42,7 @@\n // DO NOT EDIT! THIS FILE HAS BEEN GENERATED!\n //\n // Generated with: generate_netbsd_syscalls.awk\n-// Generated date: 2019-11-01\n+// Generated date: 2019-12-24\n // Generated from: syscalls.master,v 1.296 2019/09/22 22:59:39 christos Exp\n //\n //===----------------------------------------------------------------------===//\n@@ -323,6 +323,16 @@ PRE_SYSCALL(ptrace)\n     PRE_READ(addr_, struct_ptrace_ptrace_siginfo_struct_sz);\n   } else if (req_ == ptrace_pt_get_siginfo) {\n     PRE_WRITE(addr_, struct_ptrace_ptrace_siginfo_struct_sz);\n+  } else if (req_ == ptrace_pt_lwpstatus) {\n+    struct __sanitizer_ptrace_lwpstatus *addr =\n+        (struct __sanitizer_ptrace_lwpstatus *)addr_;\n+    PRE_READ(&addr->pl_lwpid, sizeof(__sanitizer_lwpid_t));\n+    PRE_WRITE(addr, struct_ptrace_ptrace_lwpstatus_struct_sz);\n+  } else if (req_ == ptrace_pt_lwpnext) {\n+    struct __sanitizer_ptrace_lwpstatus *addr =\n+        (struct __sanitizer_ptrace_lwpstatus *)addr_;\n+    PRE_READ(&addr->pl_lwpid, sizeof(__sanitizer_lwpid_t));\n+    PRE_WRITE(addr, struct_ptrace_ptrace_lwpstatus_struct_sz);\n   } else if (req_ == ptrace_pt_setregs) {\n     PRE_READ(addr_, struct_ptrace_reg_struct_sz);\n   } else if (req_ == ptrace_pt_getregs) {\n@@ -366,6 +376,16 @@ POST_SYSCALL(ptrace)\n       POST_READ(addr_, struct_ptrace_ptrace_siginfo_struct_sz);\n     } else if (req_ == ptrace_pt_get_siginfo) {\n       POST_WRITE(addr_, struct_ptrace_ptrace_siginfo_struct_sz);\n+    } else if (req_ == ptrace_pt_lwpstatus) {\n+      struct __sanitizer_ptrace_lwpstatus *addr =\n+          (struct __sanitizer_ptrace_lwpstatus *)addr_;\n+      POST_READ(&addr->pl_lwpid, sizeof(__sanitizer_lwpid_t));\n+      POST_WRITE(addr, struct_ptrace_ptrace_lwpstatus_struct_sz);\n+    } else if (req_ == ptrace_pt_lwpnext) {\n+      struct __sanitizer_ptrace_lwpstatus *addr =\n+          (struct __sanitizer_ptrace_lwpstatus *)addr_;\n+      POST_READ(&addr->pl_lwpid, sizeof(__sanitizer_lwpid_t));\n+      POST_WRITE(addr, struct_ptrace_ptrace_lwpstatus_struct_sz);\n     } else if (req_ == ptrace_pt_setregs) {\n       POST_READ(addr_, struct_ptrace_reg_struct_sz);\n     } else if (req_ == ptrace_pt_getregs) {"}, {"sha": "fca15beb61612dfb5d301ce6a9b430602a687689", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cpp", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -94,6 +94,10 @@ uptr internal_getpid() {\n   return GetProcessId(GetCurrentProcess());\n }\n \n+int internal_dlinfo(void *handle, int request, void *p) {\n+  UNIMPLEMENTED();\n+}\n+\n // In contrast to POSIX, on Windows GetCurrentThreadId()\n // returns a system-unique identifier.\n tid_t GetTid() {\n@@ -787,7 +791,7 @@ uptr GetRSS() {\n   return counters.WorkingSetSize;\n }\n \n-void *internal_start_thread(void (*func)(void *arg), void *arg) { return 0; }\n+void *internal_start_thread(void *(*func)(void *arg), void *arg) { return 0; }\n void internal_join_thread(void *th) { }\n \n // ---------------------- BlockingMutex ---------------- {{{1\n@@ -1060,7 +1064,8 @@ char **GetEnviron() {\n }\n \n pid_t StartSubprocess(const char *program, const char *const argv[],\n-                      fd_t stdin_fd, fd_t stdout_fd, fd_t stderr_fd) {\n+                      const char *const envp[], fd_t stdin_fd, fd_t stdout_fd,\n+                      fd_t stderr_fd) {\n   // FIXME: implement on this platform\n   // Should be implemented based on\n   // SymbolizerProcess::StarAtSymbolizerSubprocess"}, {"sha": "c91b29cb22b4786af5e66c32b4b28a469dacc5c3", "filename": "libsanitizer/tsan/tsan_clock.cpp", "status": "modified", "additions": 63, "deletions": 5, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_clock.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_clock.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -30,6 +30,14 @@\n //       dst->clock[i] = max(dst->clock[i], clock[i]);\n //   }\n //\n+//   void ThreadClock::releaseStoreAcquire(SyncClock *sc) const {\n+//     for (int i = 0; i < kMaxThreads; i++) {\n+//       tmp = clock[i];\n+//       clock[i] = max(clock[i], sc->clock[i]);\n+//       sc->clock[i] = tmp;\n+//     }\n+//   }\n+//\n //   void ThreadClock::ReleaseStore(SyncClock *dst) const {\n //     for (int i = 0; i < kMaxThreads; i++)\n //       dst->clock[i] = clock[i];\n@@ -107,13 +115,14 @@ static void UnrefClockBlock(ClockCache *c, u32 idx, uptr blocks) {\n ThreadClock::ThreadClock(unsigned tid, unsigned reused)\n     : tid_(tid)\n     , reused_(reused + 1)  // 0 has special meaning\n+    , last_acquire_()\n+    , global_acquire_()\n     , cached_idx_()\n     , cached_size_()\n     , cached_blocks_() {\n   CHECK_LT(tid, kMaxTidInClock);\n   CHECK_EQ(reused_, ((u64)reused_ << kClkBits) >> kClkBits);\n   nclk_ = tid_ + 1;\n-  last_acquire_ = 0;\n   internal_memset(clk_, 0, sizeof(clk_));\n }\n \n@@ -177,6 +186,49 @@ void ThreadClock::acquire(ClockCache *c, SyncClock *src) {\n   }\n }\n \n+void ThreadClock::releaseStoreAcquire(ClockCache *c, SyncClock *sc) {\n+  DCHECK_LE(nclk_, kMaxTid);\n+  DCHECK_LE(sc->size_, kMaxTid);\n+\n+  if (sc->size_ == 0) {\n+    // ReleaseStore will correctly set release_store_tid_,\n+    // which can be important for future operations.\n+    ReleaseStore(c, sc);\n+    return;\n+  }\n+\n+  nclk_ = max(nclk_, (uptr) sc->size_);\n+\n+  // Check if we need to resize sc.\n+  if (sc->size_ < nclk_)\n+    sc->Resize(c, nclk_);\n+\n+  bool acquired = false;\n+\n+  sc->Unshare(c);\n+  // Update sc->clk_.\n+  sc->FlushDirty();\n+  uptr i = 0;\n+  for (ClockElem &ce : *sc) {\n+    u64 tmp = clk_[i];\n+    if (clk_[i] < ce.epoch) {\n+      clk_[i] = ce.epoch;\n+      acquired = true;\n+    }\n+    ce.epoch = tmp;\n+    ce.reused = 0;\n+    i++;\n+  }\n+  sc->release_store_tid_ = kInvalidTid;\n+  sc->release_store_reused_ = 0;\n+\n+  if (acquired) {\n+    CPP_STAT_INC(StatClockAcquiredSomething);\n+    last_acquire_ = clk_[tid_];\n+    ResetCached(c);\n+  }\n+}\n+\n void ThreadClock::release(ClockCache *c, SyncClock *dst) {\n   DCHECK_LE(nclk_, kMaxTid);\n   DCHECK_LE(dst->size_, kMaxTid);\n@@ -196,7 +248,7 @@ void ThreadClock::release(ClockCache *c, SyncClock *dst) {\n   // Check if we had not acquired anything from other threads\n   // since the last release on dst. If so, we need to update\n   // only dst->elem(tid_).\n-  if (dst->elem(tid_).epoch > last_acquire_) {\n+  if (!HasAcquiredAfterRelease(dst)) {\n     UpdateCurrentThread(c, dst);\n     if (dst->release_store_tid_ != tid_ ||\n         dst->release_store_reused_ != reused_)\n@@ -222,8 +274,6 @@ void ThreadClock::release(ClockCache *c, SyncClock *dst) {\n   // Clear 'acquired' flag in the remaining elements.\n   if (nclk_ < dst->size_)\n     CPP_STAT_INC(StatClockReleaseClearTail);\n-  for (uptr i = nclk_; i < dst->size_; i++)\n-    dst->elem(i).reused = 0;\n   dst->release_store_tid_ = kInvalidTid;\n   dst->release_store_reused_ = 0;\n   // If we've acquired dst, remember this fact,\n@@ -269,7 +319,7 @@ void ThreadClock::ReleaseStore(ClockCache *c, SyncClock *dst) {\n \n   if (dst->release_store_tid_ == tid_ &&\n       dst->release_store_reused_ == reused_ &&\n-      dst->elem(tid_).epoch > last_acquire_) {\n+      !HasAcquiredAfterRelease(dst)) {\n     CPP_STAT_INC(StatClockStoreFast);\n     UpdateCurrentThread(c, dst);\n     return;\n@@ -351,6 +401,14 @@ bool ThreadClock::IsAlreadyAcquired(const SyncClock *src) const {\n   return true;\n }\n \n+// Checks whether the current thread has acquired anything\n+// from other clocks after releasing to dst (directly or indirectly).\n+bool ThreadClock::HasAcquiredAfterRelease(const SyncClock *dst) const {\n+  const u64 my_epoch = dst->elem(tid_).epoch;\n+  return my_epoch <= last_acquire_ ||\n+      my_epoch <= atomic_load_relaxed(&global_acquire_);\n+}\n+\n // Sets a single element in the vector clock.\n // This function is called only from weird places like AcquireGlobal.\n void ThreadClock::set(ClockCache *c, unsigned tid, u64 v) {"}, {"sha": "736cdae06ba21fdcd6c5f350f112b3e8fdcbc119", "filename": "libsanitizer/tsan/tsan_clock.h", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_clock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_clock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -134,10 +134,12 @@ class ThreadClock {\n   uptr size() const;\n \n   void acquire(ClockCache *c, SyncClock *src);\n+  void releaseStoreAcquire(ClockCache *c, SyncClock *src);\n   void release(ClockCache *c, SyncClock *dst);\n   void acq_rel(ClockCache *c, SyncClock *dst);\n   void ReleaseStore(ClockCache *c, SyncClock *dst);\n   void ResetCached(ClockCache *c);\n+  void NoteGlobalAcquire(u64 v);\n \n   void DebugReset();\n   void DebugDump(int(*printf)(const char *s, ...));\n@@ -150,6 +152,53 @@ class ThreadClock {\n   // Current thread time when it acquired something from other threads.\n   u64 last_acquire_;\n \n+  // Last time another thread has done a global acquire of this thread's clock.\n+  // It helps to avoid problem described in:\n+  // https://github.com/golang/go/issues/39186\n+  // See test/tsan/java_finalizer2.cpp for a regression test.\n+  // Note the failuire is _extremely_ hard to hit, so if you are trying\n+  // to reproduce it, you may want to run something like:\n+  // $ go get golang.org/x/tools/cmd/stress\n+  // $ stress -p=64 ./a.out\n+  //\n+  // The crux of the problem is roughly as follows.\n+  // A number of O(1) optimizations in the clocks algorithm assume proper\n+  // transitive cumulative propagation of clock values. The AcquireGlobal\n+  // operation may produce an inconsistent non-linearazable view of\n+  // thread clocks. Namely, it may acquire a later value from a thread\n+  // with a higher ID, but fail to acquire an earlier value from a thread\n+  // with a lower ID. If a thread that executed AcquireGlobal then releases\n+  // to a sync clock, it will spoil the sync clock with the inconsistent\n+  // values. If another thread later releases to the sync clock, the optimized\n+  // algorithm may break.\n+  //\n+  // The exact sequence of events that leads to the failure.\n+  // - thread 1 executes AcquireGlobal\n+  // - thread 1 acquires value 1 for thread 2\n+  // - thread 2 increments clock to 2\n+  // - thread 2 releases to sync object 1\n+  // - thread 3 at time 1\n+  // - thread 3 acquires from sync object 1\n+  // - thread 3 increments clock to 2\n+  // - thread 1 acquires value 2 for thread 3\n+  // - thread 1 releases to sync object 2\n+  // - sync object 2 clock has 1 for thread 2 and 2 for thread 3\n+  // - thread 3 releases to sync object 2\n+  // - thread 3 sees value 2 in the clock for itself\n+  //   and decides that it has already released to the clock\n+  //   and did not acquire anything from other threads after that\n+  //   (the last_acquire_ check in release operation)\n+  // - thread 3 does not update the value for thread 2 in the clock from 1 to 2\n+  // - thread 4 acquires from sync object 2\n+  // - thread 4 detects a false race with thread 2\n+  //   as it should have been synchronized with thread 2 up to time 2,\n+  //   but because of the broken clock it is now synchronized only up to time 1\n+  //\n+  // The global_acquire_ value helps to prevent this scenario.\n+  // Namely, thread 3 will not trust any own clock values up to global_acquire_\n+  // for the purposes of the last_acquire_ optimization.\n+  atomic_uint64_t global_acquire_;\n+\n   // Cached SyncClock (without dirty entries and release_store_tid_).\n   // We reuse it for subsequent store-release operations without intervening\n   // acquire operations. Since it is shared (and thus constant), clock value\n@@ -164,6 +213,7 @@ class ThreadClock {\n   u64 clk_[kMaxTidInClock];  // Fixed size vector clock.\n \n   bool IsAlreadyAcquired(const SyncClock *src) const;\n+  bool HasAcquiredAfterRelease(const SyncClock *dst) const;\n   void UpdateCurrentThread(ClockCache *c, SyncClock *dst) const;\n };\n \n@@ -185,6 +235,14 @@ ALWAYS_INLINE uptr ThreadClock::size() const {\n   return nclk_;\n }\n \n+ALWAYS_INLINE void ThreadClock::NoteGlobalAcquire(u64 v) {\n+  // Here we rely on the fact that AcquireGlobal is protected by\n+  // ThreadRegistryLock, thus only one thread at a time executes it\n+  // and values passed to this function should not go backwards.\n+  CHECK_LE(atomic_load_relaxed(&global_acquire_), v);\n+  atomic_store_relaxed(&global_acquire_, v);\n+}\n+\n ALWAYS_INLINE SyncClock::Iter SyncClock::begin() {\n   return Iter(this);\n }"}, {"sha": "718957c370315c13e5f280dd0f77b9f910dd2398", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -891,13 +891,16 @@ void DestroyThreadState() {\n   ThreadFinish(thr);\n   ProcUnwire(proc, thr);\n   ProcDestroy(proc);\n+  DTLS_Destroy();\n+  cur_thread_finalize();\n+}\n+\n+void PlatformCleanUpThreadState(ThreadState *thr) {\n   ThreadSignalContext *sctx = thr->signal_ctx;\n   if (sctx) {\n     thr->signal_ctx = 0;\n     UnmapOrDie(sctx, sizeof(*sctx));\n   }\n-  DTLS_Destroy();\n-  cur_thread_finalize();\n }\n }  // namespace __tsan\n \n@@ -1016,7 +1019,7 @@ TSAN_INTERCEPTOR(int, pthread_create,\n \n TSAN_INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n   SCOPED_INTERCEPTOR_RAW(pthread_join, th, ret);\n-  int tid = ThreadTid(thr, pc, (uptr)th);\n+  int tid = ThreadConsumeTid(thr, pc, (uptr)th);\n   ThreadIgnoreBegin(thr, pc);\n   int res = BLOCK_REAL(pthread_join)(th, ret);\n   ThreadIgnoreEnd(thr, pc);\n@@ -1029,8 +1032,8 @@ TSAN_INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n DEFINE_REAL_PTHREAD_FUNCTIONS\n \n TSAN_INTERCEPTOR(int, pthread_detach, void *th) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_detach, th);\n-  int tid = ThreadTid(thr, pc, (uptr)th);\n+  SCOPED_INTERCEPTOR_RAW(pthread_detach, th);\n+  int tid = ThreadConsumeTid(thr, pc, (uptr)th);\n   int res = REAL(pthread_detach)(th);\n   if (res == 0) {\n     ThreadDetach(thr, pc, tid);\n@@ -1050,8 +1053,8 @@ TSAN_INTERCEPTOR(void, pthread_exit, void *retval) {\n \n #if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, pthread_tryjoin_np, void *th, void **ret) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_tryjoin_np, th, ret);\n-  int tid = ThreadTid(thr, pc, (uptr)th);\n+  SCOPED_INTERCEPTOR_RAW(pthread_tryjoin_np, th, ret);\n+  int tid = ThreadConsumeTid(thr, pc, (uptr)th);\n   ThreadIgnoreBegin(thr, pc);\n   int res = REAL(pthread_tryjoin_np)(th, ret);\n   ThreadIgnoreEnd(thr, pc);\n@@ -1064,8 +1067,8 @@ TSAN_INTERCEPTOR(int, pthread_tryjoin_np, void *th, void **ret) {\n \n TSAN_INTERCEPTOR(int, pthread_timedjoin_np, void *th, void **ret,\n                  const struct timespec *abstime) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_timedjoin_np, th, ret, abstime);\n-  int tid = ThreadTid(thr, pc, (uptr)th);\n+  SCOPED_INTERCEPTOR_RAW(pthread_timedjoin_np, th, ret, abstime);\n+  int tid = ThreadConsumeTid(thr, pc, (uptr)th);\n   ThreadIgnoreBegin(thr, pc);\n   int res = BLOCK_REAL(pthread_timedjoin_np)(th, ret, abstime);\n   ThreadIgnoreEnd(thr, pc);"}, {"sha": "7256d64e50795c9e038bec5755aace9bb554fb21", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -1021,6 +1021,7 @@ int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n     void(*cleanup)(void *arg), void *arg);\n \n void DestroyThreadState();\n+void PlatformCleanUpThreadState(ThreadState *thr);\n \n }  // namespace __tsan\n "}, {"sha": "f92ecc5e40f6dc04d54062857fa90b1c9a6cf4a3", "filename": "libsanitizer/tsan/tsan_platform_mac.cpp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -19,6 +19,7 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_posix.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n+#include \"sanitizer_common/sanitizer_ptrauth.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_rtl.h\"\n@@ -75,9 +76,14 @@ static uptr main_thread_identity = 0;\n ALIGNED(64) static char main_thread_state[sizeof(ThreadState)];\n static ThreadState *main_thread_state_loc = (ThreadState *)main_thread_state;\n \n+// We cannot use pthread_self() before libpthread has been initialized.  Our\n+// current heuristic for guarding this is checking `main_thread_identity` which\n+// is only assigned in `__tsan::InitializePlatform`.\n static ThreadState **cur_thread_location() {\n+  if (main_thread_identity == 0)\n+    return &main_thread_state_loc;\n   uptr thread_identity = (uptr)pthread_self();\n-  if (thread_identity == main_thread_identity || main_thread_identity == 0)\n+  if (thread_identity == main_thread_identity)\n     return &main_thread_state_loc;\n   return (ThreadState **)MemToShadow(thread_identity);\n }\n@@ -269,6 +275,8 @@ void InitializePlatform() {\n uptr ExtractLongJmpSp(uptr *env) {\n   uptr mangled_sp = env[LONG_JMP_SP_ENV_SLOT];\n   uptr sp = mangled_sp ^ longjmp_xor_key;\n+  sp = (uptr)ptrauth_auth_data((void *)sp, ptrauth_key_asdb,\n+                               ptrauth_string_discriminator(\"sp\"));\n   return sp;\n }\n "}, {"sha": "13c9b770f50a3ccece2b906fe492de72df596773", "filename": "libsanitizer/tsan/tsan_rtl.cpp", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -144,7 +144,7 @@ static void MemoryProfiler(Context *ctx, fd_t fd, int i) {\n   WriteToFile(fd, buf.data(), internal_strlen(buf.data()));\n }\n \n-static void BackgroundThread(void *arg) {\n+static void *BackgroundThread(void *arg) {\n   // This is a non-initialized non-user thread, nothing to see here.\n   // We don't use ScopedIgnoreInterceptors, because we want ignores to be\n   // enabled even when the thread function exits (e.g. during pthread thread\n@@ -220,6 +220,7 @@ static void BackgroundThread(void *arg) {\n       }\n     }\n   }\n+  return nullptr;\n }\n \n static void StartBackgroundThread() {\n@@ -494,14 +495,23 @@ int Finalize(ThreadState *thr) {\n void ForkBefore(ThreadState *thr, uptr pc) {\n   ctx->thread_registry->Lock();\n   ctx->report_mtx.Lock();\n+  // Ignore memory accesses in the pthread_atfork callbacks.\n+  // If any of them triggers a data race we will deadlock\n+  // on the report_mtx.\n+  // We could ignore interceptors and sync operations as well,\n+  // but so far it's unclear if it will do more good or harm.\n+  // Unnecessarily ignoring things can lead to false positives later.\n+  ThreadIgnoreBegin(thr, pc);\n }\n \n void ForkParentAfter(ThreadState *thr, uptr pc) {\n+  ThreadIgnoreEnd(thr, pc);  // Begin is in ForkBefore.\n   ctx->report_mtx.Unlock();\n   ctx->thread_registry->Unlock();\n }\n \n void ForkChildAfter(ThreadState *thr, uptr pc) {\n+  ThreadIgnoreEnd(thr, pc);  // Begin is in ForkBefore.\n   ctx->report_mtx.Unlock();\n   ctx->thread_registry->Unlock();\n "}, {"sha": "d3bb61ff87d3f8ba1a3f953da4eeb67f9dc216d2", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -775,7 +775,7 @@ int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached);\n void ThreadStart(ThreadState *thr, int tid, tid_t os_id,\n                  ThreadType thread_type);\n void ThreadFinish(ThreadState *thr);\n-int ThreadTid(ThreadState *thr, uptr pc, uptr uid);\n+int ThreadConsumeTid(ThreadState *thr, uptr pc, uptr uid);\n void ThreadJoin(ThreadState *thr, uptr pc, int tid);\n void ThreadDetach(ThreadState *thr, uptr pc, int tid);\n void ThreadFinalize(ThreadState *thr);\n@@ -813,10 +813,12 @@ void Acquire(ThreadState *thr, uptr pc, uptr addr);\n // approximation of the actual required synchronization.\n void AcquireGlobal(ThreadState *thr, uptr pc);\n void Release(ThreadState *thr, uptr pc, uptr addr);\n+void ReleaseStoreAcquire(ThreadState *thr, uptr pc, uptr addr);\n void ReleaseStore(ThreadState *thr, uptr pc, uptr addr);\n void AfterSleep(ThreadState *thr, uptr pc);\n void AcquireImpl(ThreadState *thr, uptr pc, SyncClock *c);\n void ReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c);\n+void ReleaseStoreAcquireImpl(ThreadState *thr, uptr pc, SyncClock *c);\n void ReleaseStoreImpl(ThreadState *thr, uptr pc, SyncClock *c);\n void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c);\n "}, {"sha": "ebd0d722181885d3b19670d8fc9a9983d25d77d1", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cpp", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -415,8 +415,10 @@ static void UpdateClockCallback(ThreadContextBase *tctx_base, void *arg) {\n   ThreadState *thr = reinterpret_cast<ThreadState*>(arg);\n   ThreadContext *tctx = static_cast<ThreadContext*>(tctx_base);\n   u64 epoch = tctx->epoch1;\n-  if (tctx->status == ThreadStatusRunning)\n+  if (tctx->status == ThreadStatusRunning) {\n     epoch = tctx->thr->fast_state.epoch();\n+    tctx->thr->clock.NoteGlobalAcquire(epoch);\n+  }\n   thr->clock.set(&thr->proc()->clock_cache, tctx->tid, epoch);\n }\n \n@@ -429,6 +431,18 @@ void AcquireGlobal(ThreadState *thr, uptr pc) {\n       UpdateClockCallback, thr);\n }\n \n+void ReleaseStoreAcquire(ThreadState *thr, uptr pc, uptr addr) {\n+  DPrintf(\"#%d: ReleaseStoreAcquire %zx\\n\", thr->tid, addr);\n+  if (thr->ignore_sync)\n+    return;\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n+  thr->fast_state.IncrementEpoch();\n+  // Can't increment epoch w/o writing to the trace as well.\n+  TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n+  ReleaseStoreAcquireImpl(thr, pc, &s->clock);\n+  s->mtx.Unlock();\n+}\n+\n void Release(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: Release %zx\\n\", thr->tid, addr);\n   if (thr->ignore_sync)\n@@ -482,6 +496,15 @@ void AcquireImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n   StatInc(thr, StatSyncAcquire);\n }\n \n+void ReleaseStoreAcquireImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n+  if (thr->ignore_sync)\n+    return;\n+  thr->clock.set(thr->fast_state.epoch());\n+  thr->fast_synch_epoch = thr->fast_state.epoch();\n+  thr->clock.releaseStoreAcquire(&thr->proc()->clock_cache, c);\n+  StatInc(thr, StatSyncReleaseStoreAcquire);\n+}\n+\n void ReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n   if (thr->ignore_sync)\n     return;"}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "d80146735ea794b098596645d63f39a993cfe168", "filename": "libsanitizer/tsan/tsan_rtl_thread.cpp", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -144,6 +144,9 @@ void ThreadContext::OnFinished() {\n   thr->clock.ResetCached(&thr->proc()->clock_cache);\n #if !SANITIZER_GO\n   thr->last_sleep_clock.ResetCached(&thr->proc()->clock_cache);\n+#endif\n+#if !SANITIZER_GO\n+  PlatformCleanUpThreadState(thr);\n #endif\n   thr->~ThreadState();\n #if TSAN_COLLECT_STATS\n@@ -285,19 +288,34 @@ void ThreadFinish(ThreadState *thr) {\n   ctx->thread_registry->FinishThread(thr->tid);\n }\n \n-static bool FindThreadByUid(ThreadContextBase *tctx, void *arg) {\n-  uptr uid = (uptr)arg;\n-  if (tctx->user_id == uid && tctx->status != ThreadStatusInvalid) {\n+struct ConsumeThreadContext {\n+  uptr uid;\n+  ThreadContextBase *tctx;\n+};\n+\n+static bool ConsumeThreadByUid(ThreadContextBase *tctx, void *arg) {\n+  ConsumeThreadContext *findCtx = (ConsumeThreadContext *)arg;\n+  if (tctx->user_id == findCtx->uid && tctx->status != ThreadStatusInvalid) {\n+    if (findCtx->tctx) {\n+      // Ensure that user_id is unique. If it's not the case we are screwed.\n+      // Something went wrong before, but now there is no way to recover.\n+      // Returning a wrong thread is not an option, it may lead to very hard\n+      // to debug false positives (e.g. if we join a wrong thread).\n+      Report(\"ThreadSanitizer: dup thread with used id 0x%zx\\n\", findCtx->uid);\n+      Die();\n+    }\n+    findCtx->tctx = tctx;\n     tctx->user_id = 0;\n-    return true;\n   }\n   return false;\n }\n \n-int ThreadTid(ThreadState *thr, uptr pc, uptr uid) {\n-  int res = ctx->thread_registry->FindThread(FindThreadByUid, (void*)uid);\n-  DPrintf(\"#%d: ThreadTid uid=%zu tid=%d\\n\", thr->tid, uid, res);\n-  return res;\n+int ThreadConsumeTid(ThreadState *thr, uptr pc, uptr uid) {\n+  ConsumeThreadContext findCtx = {uid, nullptr};\n+  ctx->thread_registry->FindThread(ConsumeThreadByUid, &findCtx);\n+  int tid = findCtx.tctx ? findCtx.tctx->tid : ThreadRegistry::kUnknownTid;\n+  DPrintf(\"#%d: ThreadTid uid=%zu tid=%d\\n\", thr->tid, uid, tid);\n+  return tid;\n }\n \n void ThreadJoin(ThreadState *thr, uptr pc, int tid) {"}, {"sha": "8b26a59bb2ed77f14b592de7c4f6321cebc2519f", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -68,6 +68,7 @@ enum StatType {\n   StatSyncDestroyed,\n   StatSyncAcquire,\n   StatSyncRelease,\n+  StatSyncReleaseStoreAcquire,\n \n   // Clocks - acquire.\n   StatClockAcquire,"}, {"sha": "2c1529a7d92c5ee821fcf9e1affe140b3ff392a5", "filename": "libsanitizer/ubsan/ubsan_checks.inc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_checks.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_checks.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_checks.inc?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -18,6 +18,8 @@\n \n UBSAN_CHECK(GenericUB, \"undefined-behavior\", \"undefined\")\n UBSAN_CHECK(NullPointerUse, \"null-pointer-use\", \"null\")\n+UBSAN_CHECK(NullPointerUseWithNullability, \"null-pointer-use\",\n+            \"nullability-assign\")\n UBSAN_CHECK(NullptrWithOffset, \"nullptr-with-offset\", \"pointer-overflow\")\n UBSAN_CHECK(NullptrWithNonZeroOffset, \"nullptr-with-nonzero-offset\",\n             \"pointer-overflow\")\n@@ -59,6 +61,10 @@ UBSAN_CHECK(InvalidEnumLoad, \"invalid-enum-load\", \"enum\")\n UBSAN_CHECK(FunctionTypeMismatch, \"function-type-mismatch\", \"function\")\n UBSAN_CHECK(InvalidNullReturn, \"invalid-null-return\",\n             \"returns-nonnull-attribute\")\n+UBSAN_CHECK(InvalidNullReturnWithNullability, \"invalid-null-return\",\n+            \"nullability-return\")\n UBSAN_CHECK(InvalidNullArgument, \"invalid-null-argument\", \"nonnull-attribute\")\n+UBSAN_CHECK(InvalidNullArgumentWithNullability, \"invalid-null-argument\",\n+            \"nullability-arg\")\n UBSAN_CHECK(DynamicTypeMismatch, \"dynamic-type-mismatch\", \"vptr\")\n UBSAN_CHECK(CFIBadType, \"cfi-bad-type\", \"cfi\")"}, {"sha": "721c2273f133a3b4f7158b7e7297d7e9078eaffa", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -54,7 +54,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }"}, {"sha": "7f6a46fb6cf08531142f7a5b36734f46a08cde48", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -36,6 +36,45 @@ bool ignoreReport(SourceLocation SLoc, ReportOptions Opts, ErrorType ET) {\n   return SLoc.isDisabled() || IsPCSuppressed(ET, Opts.pc, SLoc.getFilename());\n }\n \n+/// Situations in which we might emit a check for the suitability of a\n+/// pointer or glvalue. Needs to be kept in sync with CodeGenFunction.h in\n+/// clang.\n+enum TypeCheckKind {\n+  /// Checking the operand of a load. Must be suitably sized and aligned.\n+  TCK_Load,\n+  /// Checking the destination of a store. Must be suitably sized and aligned.\n+  TCK_Store,\n+  /// Checking the bound value in a reference binding. Must be suitably sized\n+  /// and aligned, but is not required to refer to an object (until the\n+  /// reference is used), per core issue 453.\n+  TCK_ReferenceBinding,\n+  /// Checking the object expression in a non-static data member access. Must\n+  /// be an object within its lifetime.\n+  TCK_MemberAccess,\n+  /// Checking the 'this' pointer for a call to a non-static member function.\n+  /// Must be an object within its lifetime.\n+  TCK_MemberCall,\n+  /// Checking the 'this' pointer for a constructor call.\n+  TCK_ConstructorCall,\n+  /// Checking the operand of a static_cast to a derived pointer type. Must be\n+  /// null or an object within its lifetime.\n+  TCK_DowncastPointer,\n+  /// Checking the operand of a static_cast to a derived reference type. Must\n+  /// be an object within its lifetime.\n+  TCK_DowncastReference,\n+  /// Checking the operand of a cast to a base object. Must be suitably sized\n+  /// and aligned.\n+  TCK_Upcast,\n+  /// Checking the operand of a cast to a virtual base object. Must be an\n+  /// object within its lifetime.\n+  TCK_UpcastToVirtualBase,\n+  /// Checking the value assigned to a _Nonnull pointer. Must not be null.\n+  TCK_NonnullAssign,\n+  /// Checking the operand of a dynamic_cast or a typeid expression.  Must be\n+  /// null or an object within its lifetime.\n+  TCK_DynamicOperation\n+};\n+\n const char *TypeCheckKinds[] = {\n     \"load of\", \"store to\", \"reference binding to\", \"member access within\",\n     \"member call on\", \"constructor call on\", \"downcast of\", \"downcast of\",\n@@ -50,7 +89,9 @@ static void handleTypeMismatchImpl(TypeMismatchData *Data, ValueHandle Pointer,\n   uptr Alignment = (uptr)1 << Data->LogAlignment;\n   ErrorType ET;\n   if (!Pointer)\n-    ET = ErrorType::NullPointerUse;\n+    ET = (Data->TypeCheckKind == TCK_NonnullAssign)\n+             ? ErrorType::NullPointerUseWithNullability\n+             : ErrorType::NullPointerUse;\n   else if (Pointer & (Alignment - 1))\n     ET = ErrorType::MisalignedPointerUse;\n   else\n@@ -71,6 +112,7 @@ static void handleTypeMismatchImpl(TypeMismatchData *Data, ValueHandle Pointer,\n \n   switch (ET) {\n   case ErrorType::NullPointerUse:\n+  case ErrorType::NullPointerUseWithNullability:\n     Diag(Loc, DL_Error, ET, \"%0 null pointer of type %1\")\n         << TypeCheckKinds[Data->TypeCheckKind] << Data->Type;\n     break;\n@@ -604,7 +646,8 @@ static void handleNonNullReturn(NonNullReturnData *Data, SourceLocation *LocPtr,\n     UNREACHABLE(\"source location pointer is null!\");\n \n   SourceLocation Loc = LocPtr->acquire();\n-  ErrorType ET = ErrorType::InvalidNullReturn;\n+  ErrorType ET = IsAttr ? ErrorType::InvalidNullReturn\n+                        : ErrorType::InvalidNullReturnWithNullability;\n \n   if (ignoreReport(Loc, Opts, ET))\n     return;\n@@ -648,7 +691,8 @@ void __ubsan::__ubsan_handle_nullability_return_v1_abort(\n static void handleNonNullArg(NonNullArgData *Data, ReportOptions Opts,\n                              bool IsAttr) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  ErrorType ET = ErrorType::InvalidNullArgument;\n+  ErrorType ET = IsAttr ? ErrorType::InvalidNullArgument\n+                        : ErrorType::InvalidNullArgumentWithNullability;\n \n   if (ignoreReport(Loc, Opts, ET))\n     return;\n@@ -819,21 +863,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "22ca96422381c104798588f64c5ae370f3ef2f07", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -207,20 +207,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "e0be5a72ec42fbabd7f6f5dce31d8a3f56bc18cc", "filename": "libsanitizer/ubsan/ubsan_init.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_init.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_init.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -37,10 +37,12 @@ static void CommonStandaloneInit() {\n   SanitizerToolName = GetSanititizerToolName();\n   CacheBinaryName();\n   InitializeFlags();\n+  __sanitizer::InitializePlatformEarly();\n   __sanitizer_set_report_path(common_flags()->log_path);\n   AndroidLogInit();\n   InitializeCoverage(common_flags()->coverage, common_flags()->coverage_dir);\n   CommonInit();\n+  Symbolizer::LateInitialize();\n }\n \n void __ubsan::InitAsStandalone() {"}, {"sha": "71d7fb18c9b3a5e94039e3843113050f31fa1c9f", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -12,7 +12,6 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n     defined(__NetBSD__) || defined(__OpenBSD__) || \\\n@@ -22,6 +21,5 @@\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}, {"sha": "4f1708ba1901f2b53c24852e1eb63061eb707f99", "filename": "libsanitizer/ubsan/ubsan_type_hash_itanium.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6331c29f1376ed220246e7dead94bc527a9aa9/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cpp?ref=3c6331c29f1376ed220246e7dead94bc527a9aa9", "patch": "@@ -16,6 +16,7 @@\n #include \"ubsan_type_hash.h\"\n \n #include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_ptrauth.h\"\n \n // The following are intended to be binary compatible with the definitions\n // given in the Itanium ABI. We make no attempt to be ODR-compatible with\n@@ -194,6 +195,7 @@ struct VtablePrefix {\n   std::type_info *TypeInfo;\n };\n VtablePrefix *getVtablePrefix(void *Vtable) {\n+  Vtable = ptrauth_auth_data(Vtable, ptrauth_key_cxx_vtable_pointer, 0);\n   VtablePrefix *Vptr = reinterpret_cast<VtablePrefix*>(Vtable);\n   VtablePrefix *Prefix = Vptr - 1;\n   if (!IsAccessibleMemoryRange((uptr)Prefix, sizeof(VtablePrefix)))"}]}