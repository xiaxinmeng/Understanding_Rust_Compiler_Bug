{"sha": "9c5fdae6338380b3dd9d98c9540fb69c242baae7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM1ZmRhZTYzMzgzODBiM2RkOWQ5OGM5NTQwZmI2OWMyNDJiYWFlNw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-06-29T17:58:44Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-06-29T17:58:44Z"}, "message": "re PR java/1262 (Method with default access can be overridden in another package)\n\n\tPR java/1262\n\t* class.c (layout_class_method): Do not override package-private\n\tmethod if its in a different package.\n\t(split_qualified_name): Move here from parse.y. Rename from\n\tbreakdown_qualified. Add comment.\n\t(in_same_package): Move here from parse.y. Add comment.\n\t* java-tree.h (break_down_qualified, in_same_package): Declare.\n\t(in_same_package): Likewise.\n\t* parse.y (breakdown_qualified, in_same_package): Moved to class.c.\n\tCallers updated.\n\nFrom-SVN: r83867", "tree": {"sha": "0f8408bfb477df09486959aa6bb0df4f087e0bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f8408bfb477df09486959aa6bb0df4f087e0bb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c5fdae6338380b3dd9d98c9540fb69c242baae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c5fdae6338380b3dd9d98c9540fb69c242baae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c5fdae6338380b3dd9d98c9540fb69c242baae7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c5fdae6338380b3dd9d98c9540fb69c242baae7/comments", "author": null, "committer": null, "parents": [{"sha": "4961683533a0f3dd4ecd4aef5d2084463be1e582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4961683533a0f3dd4ecd4aef5d2084463be1e582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4961683533a0f3dd4ecd4aef5d2084463be1e582"}], "stats": {"total": 156, "additions": 95, "deletions": 61}, "files": [{"sha": "0544670b65c4b97171f110777a8c217d2e4c72fb", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c5fdae6338380b3dd9d98c9540fb69c242baae7/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c5fdae6338380b3dd9d98c9540fb69c242baae7/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=9c5fdae6338380b3dd9d98c9540fb69c242baae7", "patch": "@@ -1,3 +1,16 @@\n+2004-06-29  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tPR java/1262\n+\t* class.c (layout_class_method): Do not override package-private\n+\tmethod if its in a different package.\n+\t(split_qualified_name): Move here from parse.y. Rename from\n+\tbreakdown_qualified. Add comment.\n+\t(in_same_package): Move here from parse.y. Add comment.\n+\t* java-tree.h (break_down_qualified, in_same_package): Declare.\n+\t(in_same_package): Likewise.\n+\t* parse.y (breakdown_qualified, in_same_package): Moved to class.c.\n+\tCallers updated.\n+\n 2004-06-29  Andrew Haley  <aph@redhat.com>\n \n \t* except.c (expand_start_java_handler): Push a new binding level."}, {"sha": "03b18286aa489a2fdf3d229b4952ba4c70d9c9a5", "filename": "gcc/java/class.c", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c5fdae6338380b3dd9d98c9540fb69c242baae7/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c5fdae6338380b3dd9d98c9540fb69c242baae7/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=9c5fdae6338380b3dd9d98c9540fb69c242baae7", "patch": "@@ -2214,9 +2214,24 @@ layout_class_method (tree this_class, tree super_class,\n     {\n       tree method_sig =\n \tbuild_java_argument_signature (TREE_TYPE (method_decl));\n+      bool method_override = false;\n       tree super_method = lookup_argument_method (super_class, method_name,\n \t\t\t\t\t\t  method_sig);\n-      if (super_method != NULL_TREE && ! METHOD_PRIVATE (super_method))\n+      if (super_method != NULL_TREE)\n+        {\n+\t  method_override = true;\n+\t  if (! METHOD_PUBLIC (super_method) && \n+\t      ! METHOD_PROTECTED (super_method))\n+\t    {\n+\t      /* Don't override private method, or default-access method in \n+\t\t another package.  */\n+\t      if (METHOD_PRIVATE (super_method) ||\n+\t\t  ! in_same_package (TYPE_NAME (this_class), \n+\t\t\t\t     TYPE_NAME (super_class)))\n+\t\tmethod_override = false;\n+\t   }\n+\t}\n+      if (method_override)\n \t{\n \t  tree method_index = get_method_index (super_method);\n \t  set_method_index (method_decl, method_index);\n@@ -2538,4 +2553,63 @@ java_treetreehash_create (size_t size, int gc)\n \t\t\t      java_treetreehash_compare, free, xcalloc, free);\n }\n \n+/* Break down qualified IDENTIFIER into package and class-name components.\n+   For example, given SOURCE \"pkg.foo.Bar\", LEFT will be set to\n+   \"pkg.foo\", and RIGHT to \"Bar\". */\n+\n+int\n+split_qualified_name (tree *left, tree *right, tree source)\n+{\n+  char *p, *base;\n+  int l = IDENTIFIER_LENGTH (source);\n+\n+  base = alloca (l + 1);\n+  memcpy (base, IDENTIFIER_POINTER (source), l + 1);\n+\n+  /* Breakdown NAME into REMAINDER . IDENTIFIER.  */\n+  p = base + l - 1;\n+  while (*p != '.' && p != base)\n+    p--;\n+\n+  /* We didn't find a '.'. Return an error.  */\n+  if (p == base)\n+    return 1;\n+\n+  *p = '\\0';\n+  if (right)\n+    *right = get_identifier (p+1);\n+  *left = get_identifier (base);\n+\n+  return 0;\n+}\n+\n+/* Given two classes (TYPE_DECL) or class names (IDENTIFIER), return TRUE \n+   if the classes are from the same package. */\n+\n+int\n+in_same_package (tree name1, tree name2)\n+{\n+  tree tmp;\n+  tree pkg1;\n+  tree pkg2;\n+\n+  if (TREE_CODE (name1) == TYPE_DECL)\n+    name1 = DECL_NAME (name1);\n+  if (TREE_CODE (name2) == TYPE_DECL)\n+    name2 = DECL_NAME (name2);\n+\n+  if (QUALIFIED_P (name1) != QUALIFIED_P (name2))\n+    /* One in empty package. */\n+    return 0;\n+\n+  if (QUALIFIED_P (name1) == 0 && QUALIFIED_P (name2) == 0)\n+    /* Both in empty package. */\n+    return 1;\n+\n+  split_qualified_name (&pkg1, &tmp, name1);\n+  split_qualified_name (&pkg2, &tmp, name2);\n+\n+  return (pkg1 == pkg2);\n+}\n+\n #include \"gt-java-class.h\""}, {"sha": "be9a64d26308fc8ba506f1cca164ce0c9743e483", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c5fdae6338380b3dd9d98c9540fb69c242baae7/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c5fdae6338380b3dd9d98c9540fb69c242baae7/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=9c5fdae6338380b3dd9d98c9540fb69c242baae7", "patch": "@@ -1359,6 +1359,9 @@ extern tree make_catch_class_record (tree, tree);\n extern tree emit_catch_table (tree);\n \n extern void gen_indirect_dispatch_tables (tree type);\n+extern int split_qualified_name (tree *left, tree *right, tree source);\n+extern int in_same_package (tree, tree);\n+\n \n #define DECL_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n "}, {"sha": "adac725cd17543367b72b5232bacca1c79929e07", "filename": "gcc/java/parse.y", "status": "modified", "additions": 4, "deletions": 60, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c5fdae6338380b3dd9d98c9540fb69c242baae7/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c5fdae6338380b3dd9d98c9540fb69c242baae7/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=9c5fdae6338380b3dd9d98c9540fb69c242baae7", "patch": "@@ -122,8 +122,6 @@ static tree resolve_expression_name (tree, tree *);\n static tree maybe_create_class_interface_decl (tree, tree, tree, tree);\n static int check_class_interface_creation (int, int, tree, tree, tree, tree);\n static tree patch_method_invocation (tree, tree, tree, int, int *, tree *);\n-static int breakdown_qualified (tree *, tree *, tree);\n-static int in_same_package (tree, tree);\n static tree resolve_and_layout (tree, tree);\n static tree qualify_and_find (tree, tree, tree);\n static tree resolve_no_layout (tree, tree);\n@@ -5744,7 +5742,7 @@ do_resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n \t class and then treat Id as a member type.  If we can't find Q\n \t as a class then we fall through.  */\n       tree q, left, left_type, right;\n-      if (breakdown_qualified (&left, &right, TYPE_NAME (class_type)) == 0)\n+      if (split_qualified_name (&left, &right, TYPE_NAME (class_type)) == 0)\n \t{\n \t  BUILD_PTR_FROM_NAME (left_type, left);\n \t  q = do_resolve_class (enclosing, left_type, decl, cl);\n@@ -6823,7 +6821,7 @@ process_imports (void)\n \t     inner class.  The only way for us to know is to try again\n \t     after having dropped a qualifier. If we can't break it further,\n \t     we have an error. */\n-\t  if (breakdown_qualified (&left, NULL, to_be_found))\n+\t  if (split_qualified_name (&left, NULL, to_be_found))\n \t    break;\n \n \t  to_be_found = left;\n@@ -7257,7 +7255,7 @@ check_pkg_class_access (tree class_name, tree cl, bool verbose, tree this_decl)\n       /* Access to a private class within the same package is\n          allowed. */\n       tree l, r;\n-      breakdown_qualified (&l, &r, class_name);\n+      split_qualified_name (&l, &r, class_name);\n       if (!QUALIFIED_P (class_name) && !ctxp->package)\n \t/* Both in the empty package. */\n         return 0;\n@@ -10193,7 +10191,7 @@ class_in_current_package (tree class)\n     return 1;\n \n   /* Compare the left part of the name of CLASS with the package name */\n-  breakdown_qualified (&left, NULL, DECL_NAME (TYPE_NAME (class)));\n+  split_qualified_name (&left, NULL, DECL_NAME (TYPE_NAME (class)));\n   if (ctxp->package == left)\n     {\n       cicp_cache = class;\n@@ -11345,60 +11343,6 @@ qualify_ambiguous_name (tree id)\n     RESOLVE_PACKAGE_NAME_P (id) = 1;\n }\n \n-static int\n-breakdown_qualified (tree *left, tree *right, tree source)\n-{\n-  char *p, *base;\n-  int l = IDENTIFIER_LENGTH (source);\n-\n-  base = alloca (l + 1);\n-  memcpy (base, IDENTIFIER_POINTER (source), l + 1);\n-\n-  /* Breakdown NAME into REMAINDER . IDENTIFIER.  */\n-  p = base + l - 1;\n-  while (*p != '.' && p != base)\n-    p--;\n-\n-  /* We didn't find a '.'. Return an error.  */\n-  if (p == base)\n-    return 1;\n-\n-  *p = '\\0';\n-  if (right)\n-    *right = get_identifier (p+1);\n-  *left = get_identifier (base);\n-\n-  return 0;\n-}\n-\n-/* Return TRUE if two classes are from the same package. */\n-\n-static int\n-in_same_package (tree name1, tree name2)\n-{\n-  tree tmp;\n-  tree pkg1;\n-  tree pkg2;\n-\n-  if (TREE_CODE (name1) == TYPE_DECL)\n-    name1 = DECL_NAME (name1);\n-  if (TREE_CODE (name2) == TYPE_DECL)\n-    name2 = DECL_NAME (name2);\n-\n-  if (QUALIFIED_P (name1) != QUALIFIED_P (name2))\n-    /* One in empty package. */\n-    return 0;\n-\n-  if (QUALIFIED_P (name1) == 0 && QUALIFIED_P (name2) == 0)\n-    /* Both in empty package. */\n-    return 1;\n-\n-  breakdown_qualified (&pkg1, &tmp, name1);\n-  breakdown_qualified (&pkg2, &tmp, name2);\n-\n-  return (pkg1 == pkg2);\n-}\n-\n /* Patch tree nodes in a function body. When a BLOCK is found, push\n    local variable decls if present.\n    Same as java_complete_lhs, but does resolve static finals to values. */"}]}