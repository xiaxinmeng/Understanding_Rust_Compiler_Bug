{"sha": "d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNjYzNmMTBkYWM3YjkzYzdiNjJkN2UzMGIxNWYxNzFmZWMzZThhNQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@redhat.com", "date": "2002-09-30T05:19:09Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2002-09-30T05:19:09Z"}, "message": "Add Proxy support.\n\nFrom-SVN: r57635", "tree": {"sha": "20a978bd321eb1dcc849c21ce9a31b82bad5ac75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20a978bd321eb1dcc849c21ce9a31b82bad5ac75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/comments", "author": {"login": "atgreen", "id": 89993, "node_id": "MDQ6VXNlcjg5OTkz", "avatar_url": "https://avatars.githubusercontent.com/u/89993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atgreen", "html_url": "https://github.com/atgreen", "followers_url": "https://api.github.com/users/atgreen/followers", "following_url": "https://api.github.com/users/atgreen/following{/other_user}", "gists_url": "https://api.github.com/users/atgreen/gists{/gist_id}", "starred_url": "https://api.github.com/users/atgreen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atgreen/subscriptions", "organizations_url": "https://api.github.com/users/atgreen/orgs", "repos_url": "https://api.github.com/users/atgreen/repos", "events_url": "https://api.github.com/users/atgreen/events{/privacy}", "received_events_url": "https://api.github.com/users/atgreen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ccf7aef4284066b77a1424df2d282be17d2b2083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf7aef4284066b77a1424df2d282be17d2b2083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccf7aef4284066b77a1424df2d282be17d2b2083"}], "stats": {"total": 2485, "additions": 2250, "deletions": 235}, "files": [{"sha": "4b0cc0fcd2442cd6e3ea33b38a7185da6c51523f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -1,3 +1,26 @@\n+2002-09-29  Anthony Green  <green@redhat.com>\n+\n+\t* java/lang/reflect/UndeclaredThrowableException.java: New file.\n+\tImported from GNU Classpath.\n+\t* java/lang/reflect/natProxy.cc: New file.\n+\t* java/lang/reflect/InvocationHandler.java: New file.  Imported\n+\tfrom GNU Classpath.\n+\t* java/lang/reflect/Proxy.java: New file.  Imported from GNU\n+\tClasspath.\n+\t* gnu/java/lang/reflect/TypeSignature.java: Refresh from GNU\n+\tClasspath.\t\n+\t* gnu/classpath/Configuration.java.in (HAVE_NATIVE_GET_PROXY_DATA,\n+\tHAVE_NATIVE_GET_PROXY_CLASS, HAVE_NATIVE_GENERATE_PROXY_CLASS):\n+\tNew statics.\n+\t* gcj/javaprims.h (\"Java\"): Add new classes.\n+\t* java/lang/reflect/Proxy.java: Fix check for duplicate interfaces.\n+\t* Makefile.am (java/lang/reflect/Proxy$$ProxyData.h): Create this.\n+ \tjava/lang/reflect/Proxy$$ProxyType.h): And this.\n+\t(inner_nat_headers): Add these new headers.\n+\t(ordinary_java_source_files): Add new files.\n+\t(nat_source_files): Add new file.\n+\t* Makefile.in: Rebuilt.\n+\n 2002-09-28  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* configure.host: Handle arm*-elf, strongarm*-elf and xscale*-elf with"}, {"sha": "5d2a18209a06c49fc6571318b7f25eaa3d218689", "filename": "libjava/Makefile.am", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -249,7 +249,9 @@ ordinary_nat_headers = $(ordinary_java_source_files:.java=.h) \\\n \t$(built_java_source_files:.java=.h)\n \n inner_nat_headers = java/io/ObjectOutputStream$$PutField.h \\\n-\tjava/io/ObjectInputStream$$GetField.h\n+\tjava/io/ObjectInputStream$$GetField.h \\\n+\tjava/lang/reflect/Proxy$$ProxyData.h \\\n+\tjava/lang/reflect/Proxy$$ProxyType.h\n \n nat_headers = $(ordinary_nat_headers) $(inner_nat_headers)\n \n@@ -309,6 +311,18 @@ java/lang/reflect/Method.h: java/lang/reflect/Method.class\n \t    -friend 'jobject _Jv_JNI_ToReflectedMethod (_Jv_JNIEnv *, jclass, jmethodID, jboolean);' \\\n \t    $(basename $<)\n \n+java/lang/reflect/Proxy.h: java/lang/reflect/Proxy.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t    $(basename $<)\n+\n+java/lang/reflect/Proxy$$ProxyData.h: java/lang/reflect/Proxy.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t'java/lang/reflect/Proxy$$ProxyData'\n+\n+java/lang/reflect/Proxy$$ProxyType.h: java/lang/reflect/Proxy.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t'java/lang/reflect/Proxy$$ProxyType'\n+\n gnu/gcj/runtime/VMClassLoader.h: gnu/gcj/runtime/VMClassLoader.class\n \t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n \t    -friend 'class ::java::lang::ClassLoader;' \\\n@@ -1873,11 +1887,14 @@ java/lang/reflect/AccessibleObject.java\t\\\n java/lang/reflect/Array.java \\\n java/lang/reflect/Constructor.java \\\n java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationHandler.java \\\n java/lang/reflect/InvocationTargetException.java \\\n java/lang/reflect/Member.java \\\n java/lang/reflect/Method.java \\\n java/lang/reflect/Modifier.java\t\\\n+java/lang/reflect/Proxy.java \\\n java/lang/reflect/ReflectPermission.java \\\n+java/lang/reflect/UndeclaredThrowableException.java \\\n java/math/BigDecimal.java \\\n java/math/BigInteger.java \\\n java/net/Authenticator.java \\\n@@ -2242,6 +2259,7 @@ java/lang/reflect/natArray.cc \\\n java/lang/reflect/natConstructor.cc \\\n java/lang/reflect/natField.cc \\\n java/lang/reflect/natMethod.cc \\\n+java/lang/reflect/natProxy.cc \\\n java/net/natNetworkInterface.cc \\\n java/net/natInetAddress.cc \\\n java/net/natPlainDatagramSocketImpl.cc \\"}, {"sha": "a0f6851409b4fc9e3b06f6a75aad2271df0c4b95", "filename": "libjava/Makefile.in", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -246,7 +246,9 @@ ordinary_nat_headers = $(ordinary_java_source_files:.java=.h) \\\n \n \n inner_nat_headers = java/io/ObjectOutputStream$$PutField.h \\\n-\tjava/io/ObjectInputStream$$GetField.h\n+\tjava/io/ObjectInputStream$$GetField.h \\\n+\tjava/lang/reflect/Proxy$$ProxyData.h \\\n+\tjava/lang/reflect/Proxy$$ProxyType.h\n \n \n nat_headers = $(ordinary_nat_headers) $(inner_nat_headers)\n@@ -1635,11 +1637,14 @@ java/lang/reflect/AccessibleObject.java\t\\\n java/lang/reflect/Array.java \\\n java/lang/reflect/Constructor.java \\\n java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationHandler.java \\\n java/lang/reflect/InvocationTargetException.java \\\n java/lang/reflect/Member.java \\\n java/lang/reflect/Method.java \\\n java/lang/reflect/Modifier.java\t\\\n+java/lang/reflect/Proxy.java \\\n java/lang/reflect/ReflectPermission.java \\\n+java/lang/reflect/UndeclaredThrowableException.java \\\n java/math/BigDecimal.java \\\n java/math/BigInteger.java \\\n java/net/Authenticator.java \\\n@@ -2003,6 +2008,7 @@ java/lang/reflect/natArray.cc \\\n java/lang/reflect/natConstructor.cc \\\n java/lang/reflect/natField.cc \\\n java/lang/reflect/natMethod.cc \\\n+java/lang/reflect/natProxy.cc \\\n java/net/natNetworkInterface.cc \\\n java/net/natInetAddress.cc \\\n java/net/natPlainDatagramSocketImpl.cc \\\n@@ -2157,11 +2163,11 @@ java/lang/natStringBuffer.lo java/lang/natSystem.lo \\\n java/lang/natThread.lo java/lang/natVMThrowable.lo \\\n java/lang/ref/natReference.lo java/lang/reflect/natArray.lo \\\n java/lang/reflect/natConstructor.lo java/lang/reflect/natField.lo \\\n-java/lang/reflect/natMethod.lo java/net/natNetworkInterface.lo \\\n-java/net/natInetAddress.lo java/net/natPlainDatagramSocketImpl.lo \\\n-java/net/natPlainSocketImpl.lo java/text/natCollator.lo \\\n-java/util/natTimeZone.lo java/util/zip/natDeflater.lo \\\n-java/util/zip/natInflater.lo\n+java/lang/reflect/natMethod.lo java/lang/reflect/natProxy.lo \\\n+java/net/natNetworkInterface.lo java/net/natInetAddress.lo \\\n+java/net/natPlainDatagramSocketImpl.lo java/net/natPlainSocketImpl.lo \\\n+java/text/natCollator.lo java/util/natTimeZone.lo \\\n+java/util/zip/natDeflater.lo java/util/zip/natInflater.lo\n libgcjx_la_OBJECTS =  gnu/gcj/xlib/natClip.lo \\\n gnu/gcj/xlib/natColormap.lo gnu/gcj/xlib/natDisplay.lo \\\n gnu/gcj/xlib/natDrawable.lo gnu/gcj/xlib/natFont.lo \\\n@@ -2854,29 +2860,32 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/reflect/AccessibleObject.P \\\n .deps/java/lang/reflect/Array.P .deps/java/lang/reflect/Constructor.P \\\n .deps/java/lang/reflect/Field.P \\\n+.deps/java/lang/reflect/InvocationHandler.P \\\n .deps/java/lang/reflect/InvocationTargetException.P \\\n .deps/java/lang/reflect/Member.P .deps/java/lang/reflect/Method.P \\\n-.deps/java/lang/reflect/Modifier.P \\\n+.deps/java/lang/reflect/Modifier.P .deps/java/lang/reflect/Proxy.P \\\n .deps/java/lang/reflect/ReflectPermission.P \\\n+.deps/java/lang/reflect/UndeclaredThrowableException.P \\\n .deps/java/lang/reflect/natArray.P \\\n .deps/java/lang/reflect/natConstructor.P \\\n .deps/java/lang/reflect/natField.P .deps/java/lang/reflect/natMethod.P \\\n-.deps/java/lang/s_atan.P .deps/java/lang/s_ceil.P \\\n-.deps/java/lang/s_copysign.P .deps/java/lang/s_cos.P \\\n-.deps/java/lang/s_fabs.P .deps/java/lang/s_floor.P \\\n-.deps/java/lang/s_rint.P .deps/java/lang/s_scalbn.P \\\n-.deps/java/lang/s_sin.P .deps/java/lang/s_tan.P \\\n-.deps/java/lang/sf_fabs.P .deps/java/lang/sf_rint.P \\\n-.deps/java/lang/strtod.P .deps/java/lang/w_acos.P \\\n-.deps/java/lang/w_asin.P .deps/java/lang/w_atan2.P \\\n-.deps/java/lang/w_exp.P .deps/java/lang/w_fmod.P \\\n-.deps/java/lang/w_log.P .deps/java/lang/w_pow.P \\\n-.deps/java/lang/w_remainder.P .deps/java/lang/w_sqrt.P \\\n-.deps/java/math/BigDecimal.P .deps/java/math/BigInteger.P \\\n-.deps/java/net/Authenticator.P .deps/java/net/BindException.P \\\n-.deps/java/net/ConnectException.P .deps/java/net/ContentHandler.P \\\n-.deps/java/net/ContentHandlerFactory.P .deps/java/net/DatagramPacket.P \\\n-.deps/java/net/DatagramSocket.P .deps/java/net/DatagramSocketImpl.P \\\n+.deps/java/lang/reflect/natProxy.P .deps/java/lang/s_atan.P \\\n+.deps/java/lang/s_ceil.P .deps/java/lang/s_copysign.P \\\n+.deps/java/lang/s_cos.P .deps/java/lang/s_fabs.P \\\n+.deps/java/lang/s_floor.P .deps/java/lang/s_rint.P \\\n+.deps/java/lang/s_scalbn.P .deps/java/lang/s_sin.P \\\n+.deps/java/lang/s_tan.P .deps/java/lang/sf_fabs.P \\\n+.deps/java/lang/sf_rint.P .deps/java/lang/strtod.P \\\n+.deps/java/lang/w_acos.P .deps/java/lang/w_asin.P \\\n+.deps/java/lang/w_atan2.P .deps/java/lang/w_exp.P \\\n+.deps/java/lang/w_fmod.P .deps/java/lang/w_log.P \\\n+.deps/java/lang/w_pow.P .deps/java/lang/w_remainder.P \\\n+.deps/java/lang/w_sqrt.P .deps/java/math/BigDecimal.P \\\n+.deps/java/math/BigInteger.P .deps/java/net/Authenticator.P \\\n+.deps/java/net/BindException.P .deps/java/net/ConnectException.P \\\n+.deps/java/net/ContentHandler.P .deps/java/net/ContentHandlerFactory.P \\\n+.deps/java/net/DatagramPacket.P .deps/java/net/DatagramSocket.P \\\n+.deps/java/net/DatagramSocketImpl.P \\\n .deps/java/net/DatagramSocketImplFactory.P .deps/java/net/FileNameMap.P \\\n .deps/java/net/HttpURLConnection.P .deps/java/net/InetAddress.P \\\n .deps/java/net/InetSocketAddress.P .deps/java/net/JarURLConnection.P \\\n@@ -3776,7 +3785,7 @@ maintainer-clean-recursive:\n \tdot_seen=no; \\\n \trev=''; list='$(SUBDIRS)'; for subdir in $$list; do \\\n \t  rev=\"$$subdir $$rev\"; \\\n-\t  test \"$$subdir\" = \".\" && dot_seen=yes; \\\n+\t  test \"$$subdir\" != \".\" || dot_seen=yes; \\\n \tdone; \\\n \ttest \"$$dot_seen\" = \"no\" && rev=\". $$rev\"; \\\n \ttarget=`echo $@ | sed s/-recursive//`; \\\n@@ -4162,6 +4171,18 @@ java/lang/reflect/Method.h: java/lang/reflect/Method.class\n \t    -friend 'jobject _Jv_JNI_ToReflectedMethod (_Jv_JNIEnv *, jclass, jmethodID, jboolean);' \\\n \t    $(basename $<)\n \n+java/lang/reflect/Proxy.h: java/lang/reflect/Proxy.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t    $(basename $<)\n+\n+java/lang/reflect/Proxy$$ProxyData.h: java/lang/reflect/Proxy.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t'java/lang/reflect/Proxy$$ProxyData'\n+\n+java/lang/reflect/Proxy$$ProxyType.h: java/lang/reflect/Proxy.class\n+\t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n+\t'java/lang/reflect/Proxy$$ProxyType'\n+\n gnu/gcj/runtime/VMClassLoader.h: gnu/gcj/runtime/VMClassLoader.class\n \t$(GCJH) -classpath '' -bootclasspath $(top_builddir) \\\n \t    -friend 'class ::java::lang::ClassLoader;' \\"}, {"sha": "9ec51a6906df6ac92bdbc298d82d2de42d9c6af0", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "8ed649432a21f9521099432ba7de25b991d3c47e", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -230,11 +230,16 @@ extern \"Java\"\n         class Array;\n         class Constructor;\n         class Field;\n+\tclass InvocationHandler;\n         class InvocationTargetException;\n         class Member;\n         class Method;\n         class Modifier;\n+\tclass Proxy;\n+\tclass Proxy$ProxyData;\n+\tclass Proxy$ProxyType;\n         class ReflectPermission;\n+\tclass UndeclaredThrowableException;\n       };\n     };\n "}, {"sha": "1002b62bd8bf920e09ab8e224173765d4ba7e636", "filename": "libjava/gnu/classpath/Configuration.java.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fgnu%2Fclasspath%2FConfiguration.java.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fgnu%2Fclasspath%2FConfiguration.java.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2FConfiguration.java.in?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -51,4 +51,9 @@ public interface Configuration\n \n   // For libgcj we never load the JNI libraries.\n   boolean INIT_LOAD_LIBRARY = false;\n+\t\n+  // For libgcj we have native methods for proxy support....\n+  boolean HAVE_NATIVE_GET_PROXY_DATA = false;\n+  boolean HAVE_NATIVE_GET_PROXY_CLASS = false;\n+  boolean HAVE_NATIVE_GENERATE_PROXY_CLASS = false;\n }"}, {"sha": "e9c8861c611fb09b1c2513a815cde83c88e4c510", "filename": "libjava/gnu/java/lang/reflect/TypeSignature.java", "status": "modified", "additions": 186, "deletions": 198, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fgnu%2Fjava%2Flang%2Freflect%2FTypeSignature.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fgnu%2Fjava%2Flang%2Freflect%2FTypeSignature.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flang%2Freflect%2FTypeSignature.java?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -1,13 +1,13 @@\n /* TypeSignature.java -- Class used to compute type signatures\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -44,230 +44,218 @@\n import java.lang.reflect.Method;\n \n /**\n-   This class provides static methods that can be used to compute\n-   type-signatures of <code>Class</code>s or <code>Member</code>s.\n-   More specific methods are also provided for computing the\n-   type-signature of <code>Constructor</code>s and\n-   <code>Method</code>s.  Methods are also provided to go in the\n-   reverse direction.\n-*/\n+ * This class provides static methods that can be used to compute\n+ * type-signatures of <code>Class</code>s or <code>Member</code>s.\n+ * More specific methods are also provided for computing the\n+ * type-signature of <code>Constructor</code>s and\n+ * <code>Method</code>s.  Methods are also provided to go in the\n+ * reverse direction.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ */\n public class TypeSignature\n {\n- \n   /**\n-     Returns a <code>String</code> representing the type-encoding of\n-     CLAZZ.  Type-encodings are computed as follows:\n+   * Returns a <code>String</code> representing the type-encoding of a class.\n+   * The .class file format has different encodings for classes, depending\n+   * on whether it must be disambiguated from primitive types or not; hence\n+   * the descriptor parameter to choose between them. If you are planning\n+   * on decoding primitive types along with classes, then descriptor should\n+   * be true for correct results. Type-encodings are computed as follows:\n+   *\n+   * <pre>\n+   * boolean -> \"Z\"\n+   * byte    -> \"B\"\n+   * char    -> \"C\"\n+   * double  -> \"D\"\n+   * float   -> \"F\"\n+   * int     -> \"I\"\n+   * long    -> \"J\"\n+   * short   -> \"S\"\n+   * void    -> \"V\"\n+   * arrays  -> \"[\" + descriptor format of component type\n+   * object  -> class format: fully qualified name with '.' replaced by '/'\n+   *            descriptor format: \"L\" + class format + \";\"\n+   * </pre>\n+   *\n+   * @param type the class name to encode\n+   * @param descriptor true to return objects in descriptor format\n+   * @return the class name, as it appears in bytecode constant pools\n+   * @see #getClassForEncoding(String)\n+   */\n+  public static String getEncodingOfClass(String type, boolean descriptor)\n+  {\n+    if (! descriptor || type.charAt(0) == '[')\n+      return type.replace('.', '/');\n+    if (type.equals(\"boolean\"))\n+      return \"Z\";\n+    if (type.equals(\"byte\"))\n+      return \"B\";\n+    if (type.equals(\"short\"))\n+      return \"S\";\n+    if (type.equals(\"char\"))\n+      return \"C\";\n+    if (type.equals(\"int\"))\n+      return \"I\";\n+    if (type.equals(\"long\"))\n+      return \"J\";\n+    if (type.equals(\"float\"))\n+      return \"F\";\n+    if (type.equals(\"double\"))\n+      return \"D\";\n+    if (type.equals(\"void\"))\n+      return \"V\";\n+    return 'L' + type.replace('.', '/') + ';';\n+  }\n \n-     <pre>\n-     boolean -> \"Z\"\n-     byte    -> \"B\"\n-     char    -> \"C\"\n-     double  -> \"D\"\n-     float   -> \"F\"\n-     int     -> \"I\"\n-     long    -> \"J\"\n-     short   -> \"S\"\n-     void    -> \"V\"\n-     arrays  -> \"[\" + type-encoding of component type\n-     object  -> \"L\"\n-                 + fully qualified class name with \".\"'s replaced by \"/\"'s\n-                 + \";\"</pre>\n-  */\n-  public static String getEncodingOfClass( Class clazz )\n+  /**\n+   * Gets the descriptor encoding for a class.\n+   *\n+   * @param clazz the class to encode\n+   * @param descriptor true to return objects in descriptor format\n+   * @return the class name, as it appears in bytecode constant pools\n+   * @see #getEncodingOfClass(String, boolean)\n+   */\n+  public static String getEncodingOfClass(Class clazz, boolean descriptor)\n   {\n-    if( clazz.isPrimitive() )\n-    {\n-      if( clazz == Boolean.TYPE )\n-\treturn \"Z\";\n-      if( clazz == Byte.TYPE )\n-\treturn \"B\";\n-      if( clazz == Character.TYPE )\n-\treturn \"C\";\n-      if( clazz == Double.TYPE )\n-\treturn \"D\";\n-      if( clazz == Float.TYPE )\n-\treturn \"F\";\n-      if( clazz == Integer.TYPE )\n-\treturn \"I\";\n-      if( clazz == Long.TYPE )\n-\treturn \"J\";\n-      if( clazz == Short.TYPE )\n-\treturn \"S\";\n-      if( clazz == Void.TYPE )\n-\treturn \"V\";\n-      else\n-\tthrow new RuntimeException( \"Unknown primitive class \" + clazz );\n-    }\n-    else if( clazz.isArray() )\n-    {\n-      return '[' + getEncodingOfClass( clazz.getComponentType() );\n-    }\n-    else\n-    {\n-      String classname = clazz.getName();\n-      int name_len = classname.length();\n-      char[] buf = new char[ name_len + 2 ];\n-      buf[0] = 'L';\n-      classname.getChars( 0, name_len, buf, 1 );\n-      \n-      int i;\n-      for( i=1; i <= name_len; i++ )\n-      {\n-\tif( buf[i] == '.' )\n-\t  buf[i] = '/';\n-      }\n-      \n-      buf[i] = ';';\n-      return new String( buf );\n-    }\n+    return getEncodingOfClass(clazz.getName(), descriptor);\n   }\n \n-  \n   /**\n-     This function is the inverse of <code>getEncodingOfClass</code>.\n+   * Gets the descriptor encoding for a class.\n+   *\n+   * @param clazz the class to encode\n+   * @return the class name, as it appears in bytecode constant pools\n+   * @see #getEncodingOfClass(String, boolean)\n+   */\n+  public static String getEncodingOfClass(Class clazz)\n+  {\n+    return getEncodingOfClass(clazz.getName(), true);\n+  }\n \n-     @see getEncodingOfClass\n \n-     @exception ClassNotFoundException If class encoded as type_code\n-     cannot be located.\n-  */\n-  public static Class getClassForEncoding( String type_code )\n+  /**\n+   * This function is the inverse of <code>getEncodingOfClass</code>. This\n+   * accepts both object and descriptor formats, but must know which style\n+   * of string is being passed in (usually, descriptor should be true). In\n+   * descriptor format, \"I\" is treated as int.class, in object format, it\n+   * is treated as a class named I in the unnamed package.\n+   *\n+   * @param type_code the class name to decode\n+   * @param descriptor if the string is in descriptor format\n+   * @return the corresponding Class object\n+   * @throws ClassNotFoundException if the class cannot be located\n+   * @see #getEncodingOfClass(Class, boolean)\n+   */\n+  public static Class getClassForEncoding(String type_code, boolean descriptor)\n     throws ClassNotFoundException\n   {\n-    if( type_code.equals( \"B\" ) )\n-      return Byte.TYPE;\n-    if( type_code.equals( \"C\" ) )\n-      return Character.TYPE;\n-    if( type_code.equals( \"D\" ) )\n-      return Double.TYPE;\n-    if( type_code.equals( \"F\" ) )\n-      return Float.TYPE;\n-    if( type_code.equals( \"I\" ) )\n-      return Integer.TYPE;\n-    if( type_code.equals( \"J\" ) )\n-      return Long.TYPE;\n-    if( type_code.equals( \"S\" ) )\n-      return Short.TYPE;\n-    if( type_code.equals( \"Z\" ) )\n-      return Boolean.TYPE;\n-    if( type_code.charAt( 0 ) == 'L' )\n-    {\n-      return Class.forName(\n-\ttype_code.substring( 1, type_code.length() - 1 ).replace( '/', '.' ));\n-    }\n-    if( type_code.charAt( 0 ) == '[' )\n-    {\n-      int last_bracket = type_code.lastIndexOf( '[' );\n-      String brackets = type_code.substring( 0, last_bracket + 1 );\n-      String component = type_code.substring( last_bracket + 1 );\n-      \n-// ??? This is what the Classpath implementation did, but I don't\n-// think that it's correct.  The JLS says that Class.forName takes the\n-// classname of an array element in fully qualified form, whereas this\n-// code is tring to strip off the punctuation.\n-\n-//        if( component.charAt( 0 ) == 'L' )\n-//  \tcomponent =\n-//  \t  component.substring( 1, component.length() - 1 ).replace('/', '.');\n-\n-      if( component.charAt( 0 ) == 'L' )\n-  \tcomponent = component.replace('/', '.');\n-\t\n-      return Class.forName( brackets + component );\n-    }\n-    else\n-      throw new ClassNotFoundException( \"Type code cannot be parsed as a valid class name\" );\n+    if (descriptor)\n+      {\n+        switch (type_code.charAt(0))\n+          {\n+          case 'B':\n+            return byte.class;\n+          case 'C':\n+            return char.class;\n+          case 'D':\n+            return double.class;\n+          case 'F':\n+            return float.class;\n+          case 'I':\n+            return int.class;\n+          case 'J':\n+            return long.class;\n+          case 'S':\n+            return short.class;\n+          case 'V':\n+            return void.class;\n+          case 'Z':\n+            return boolean.class;\n+          default:\n+            throw new ClassNotFoundException(\"Invalid class name: \"\n+                                             + type_code);\n+          case 'L':\n+            type_code = type_code.substring(1, type_code.length() - 1);\n+            // Fallthrough.\n+          case '[':\n+          }\n+      }\n+    return Class.forName(type_code.replace('/', '.'));\n   }\n-  \n \n   /**\n-     Returns a <code>String</code> representing the type-encoding of\n-     M.  The type-encoding of a method is:\n+   * Gets the Class object for a type name.\n+   *\n+   * @param type_code the class name to decode\n+   * @return the corresponding Class object\n+   * @throws ClassNotFoundException if the class cannot be located\n+   * @see #getClassForEncoding(String, boolean)\n+   */\n+  public static Class getClassForEncoding(String type_code)\n+    throws ClassNotFoundException\n+  {\n+    return getClassForEncoding(type_code, true);\n+  }\n \n-     \"(\" + type-encodings of parameter types + \")\" \n-     + type-encoding of return type\n-  */\n-  public static String getEncodingOfMethod( Method m )\n+  /**\n+   * Returns a <code>String</code> representing the type-encoding of a\n+   * method.  The type-encoding of a method is:\n+   *\n+   * \"(\" + parameter type descriptors + \")\" + return type descriptor\n+   *\n+   * XXX This could be faster if it were implemented natively.\n+   *\n+   * @param m the method to encode\n+   * @return the encoding\n+   */\n+  public static String getEncodingOfMethod(Method m)\n   {\n-    String returnEncoding = getEncodingOfClass( m.getReturnType() );\n     Class[] paramTypes = m.getParameterTypes();\n-    String[] paramEncodings = new String[ paramTypes.length ];\n-\n-    String paramEncoding;\n-    int size = 2; // make room for parens\n-    for( int i=0; i < paramTypes.length; i++ )\n-    {\n-      paramEncoding = getEncodingOfClass( paramTypes[i] );\n-      size += paramEncoding.length();\n-      paramEncodings[i] = paramEncoding;\n-    }\n-    \n-    size += returnEncoding.length();\n-\n-    StringBuffer buf = new StringBuffer( size );\n-    buf.append( '(' );\n-    \n-    for( int i=0; i < paramTypes.length; i++ )\n-    {\n-      buf.append( paramEncodings[i] );\n-    }\n-    \n-    buf.append( ')' );\n-    buf.append( returnEncoding );\n-    \n+    StringBuffer buf = new StringBuffer().append('(');\n+    for (int i = 0; i < paramTypes.length; i++)\n+      buf.append(getEncodingOfClass(paramTypes[i].getName(), true));\n+    buf.append(')').append(getEncodingOfClass(m.getReturnType().getName(),\n+                                              true));\n     return buf.toString();\n   }\n \n-\n   /**\n-     Returns a <code>String</code> representing the type-encoding of\n-     C.  The type-encoding of a method is:\n-\n-     \"(\" + type-encodings of parameter types + \")V\" \n-  */\n-  public static String getEncodingOfConstructor( Constructor c )\n+   * Returns a <code>String</code> representing the type-encoding of a\n+   * constructor. The type-encoding of a method is:\n+   *\n+   * \"(\" + parameter type descriptors + \")V\"\n+   *\n+   * XXX This could be faster if it were implemented natively.\n+   *\n+   * @param c the constructor to encode\n+   * @return the encoding\n+   */\n+  public static String getEncodingOfConstructor(Constructor c)\n   {\n     Class[] paramTypes = c.getParameterTypes();\n-    String[] paramEncodings = new String[ paramTypes.length ];\n-\n-    String paramEncoding;\n-    int size = 3; // make room for parens and V for return type\n-    for( int i=0; i < paramTypes.length; i++ )\n-    {\n-      paramEncoding = getEncodingOfClass( paramTypes[i] );\n-      size += paramEncoding.length();\n-      paramEncodings[i] = paramEncoding;\n-    }\n-    \n-    StringBuffer buf = new StringBuffer( size );\n-    buf.append( '(' );\n-    \n-    for( int i=0; i < paramTypes.length; i++ )\n-    {\n-      buf.append( paramEncodings[i] );\n-    }\n-    \n-    buf.append( \")V\" );\n-    \n+    StringBuffer buf = new StringBuffer().append('(');\n+    for (int i = 0; i < paramTypes.length; i++)\n+      buf.append(getEncodingOfClass(paramTypes[i].getName(), true));\n+    buf.append(\")V\");\n     return buf.toString();\n   }\n \n-\n   /**\n-     Returns a <code>String</code> representing the type-encoding of\n-     MEM.  <code>Constructor</code>s are handled by\n-     <code>getEncodingOfConstructor</code>.  <code>Method</code>s are\n-     handled by <code>getEncodingOfMethod</code>.  <code>Field</code>s\n-     are handled by returning the encoding of the type of the\n-     <code>Field</code>.\n-  */\n-  public static String getEncodingOfMember( Member mem )\n+   * Returns a <code>String</code> representing the type-encoding of a\n+   * class member. This appropriately handles Constructors, Methods, and\n+   * Fields.\n+   *\n+   * @param mem the member to encode\n+   * @return the encoding\n+   */\n+  public static String getEncodingOfMember(Member mem)\n   {\n-    if( mem instanceof Constructor )\n-      return getEncodingOfConstructor( (Constructor)mem );\n-    if( mem instanceof Method )\n-      return getEncodingOfMethod( (Method)mem );\n+    if (mem instanceof Constructor)\n+      return getEncodingOfConstructor((Constructor) mem);\n+    if (mem instanceof Method)\n+      return getEncodingOfMethod((Method) mem);\n     else // Field\n-      return getEncodingOfClass( ((Field)mem).getType() );\n+      return getEncodingOfClass(((Field) mem).getType().getName(), true);\n   }\n-}\n+} // class TypeSignature"}, {"sha": "ebcd4250ab00616e16d177a3590cd73178b419c7", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "11b75548e53c0673b0dc75e0904a0e6fe60ebc1a", "filename": "libjava/java/lang/VMClassLoader.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMClassLoader.java?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -43,10 +43,10 @@ class VMClassLoader {\n      * @return the class that was defined.\n      * @exception ClassFormatError if the byte array is not in proper classfile format.\n      */\n-  // Not yet needed for libgcj.\n-//      final static native Class defineClass(ClassLoader cl, String name, \n-//  \t     byte[] data, int offset, int len) throws ClassFormatError;\n-    \n+    final static native Class defineClass(ClassLoader cl, String name, \n+\t\t\t\t\t  byte[] data, int offset, int len) \n+\tthrows ClassFormatError;\n+\n     /** \n      * Helper to resolve all references to other classes from this class.\n      * @param c the class to resolve."}, {"sha": "c229943ecc5feded01579c758e31e154868a37d2", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -170,6 +170,16 @@ java::lang::ClassLoader::markClassErrorState0 (java::lang::Class *klass)\n   klass->notifyAll ();\n }\n \n+jclass\n+java::lang::VMClassLoader::defineClass (java::lang::ClassLoader *cl, \n+\t\t\t\t\tjstring name,\n+\t\t\t\t\tjbyteArray data, \n+\t\t\t\t\tjint offset,\n+\t\t\t\t\tjint length)\n+{\n+  return cl->defineClass (name, data, offset, length);\n+}\n+\n jclass\n java::lang::VMClassLoader::getPrimitiveClass (jchar type)\n {\n@@ -269,6 +279,7 @@ _Jv_PrepareCompiledClass (jclass klass)\n       else if (pool->tags[index] == JV_CONSTANT_String)\n \t{\n \t  jstring str;\n+\n \t  str = _Jv_NewStringUtf8Const (pool->data[index].utf8);\n \t  pool->data[index].o = str;\n \t  pool->tags[index] |= JV_CONSTANT_ResolvedFlag;"}, {"sha": "91907e280c7f6003fc5d1c46938f88197f9c209b", "filename": "libjava/java/lang/reflect/InvocationHandler.java", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2Freflect%2FInvocationHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2Freflect%2FInvocationHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FInvocationHandler.java?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -0,0 +1,136 @@\n+/* java.lang.reflect.InvocationHandler - dynamically executes methods in\n+   proxy instances\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.lang.reflect;\n+\n+/**\n+ * This interface defines an invocation handler.  Suppose you are using\n+ * reflection, and found a method that requires that its parameter\n+ * be an object of a given interface.  You want to call this method,\n+ * but have no idea what classes implement that interface.  So, you can\n+ * create a {@link Proxy} instance, a convenient way to dynamically\n+ * generate a class that meets all the necessary properties of that\n+ * interface.  But in order for the proxy instance to do any good, it\n+ * needs to know what to do when interface methods are invoked!  So,\n+ * this interface is basically a cool wrapper that provides runtime\n+ * code generation needed by proxy instances.<p>\n+ *\n+ * While this interface was designed for use by Proxy, it will also\n+ * work on any object in general.<p>\n+ *\n+ * Hints for implementing this class:<br>\n+ * <ul>\n+ *  <li>Don't forget that Object.equals, Object.hashCode, and\n+ *      Object.toString will call this handler.  In particular,\n+ *      a naive call to proxy.equals, proxy.hashCode, or proxy.toString\n+ *      will put you in an infinite loop.  And remember that string\n+ *      concatenation also invokes toString.</li>\n+ *  <li>Obey the contract of the Method object you are handling, or\n+ *      the proxy instance will be forced to throw a\n+ *      {@link NullPointerException}, {@link ClassCastException},\n+ *      or {@link UndeclaredThrowableException}.</li>\n+ *  <li>Be prepared to wrap/unwrap primitives as necessary.</li>\n+ *  <li>The Method object may be owned by a different interface than\n+ *      what was actually used as the qualifying type of the method\n+ *      invocation in the Java source code. This means that it might\n+ *      not always be safe to throw an exception listed as belonging\n+ *      to the method's throws clause.</li>\n+ * </ul>\n+ *\n+ * <p><small>For a fun time, create an InvocationHandler that handles the\n+ * methods of a proxy instance of the InvocationHandler interface!</small>\n+ *\n+ * @see Proxy\n+ * @see UndeclaredThrowableException\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.3\n+ * @status updated to 1.4\n+ */\n+public interface InvocationHandler\n+{\n+  /**\n+   * When a method is invoked on a proxy instance, it is wrapped and\n+   * this method is called instead, so that you may decide at runtime\n+   * how the original method should behave.\n+   *\n+   * @param proxy the instance that the wrapped method should be\n+   *        invoked on.  When this method is called by a Proxy object,\n+   *        `proxy' will be an instance of {@link Proxy}, and oddly enough,\n+   *        <code>Proxy.getInvocationHandler(proxy)</code> will return\n+   *        <code>this</code>!\n+   * @param method the reflected method to invoke on the proxy.\n+   *        When this method is called by a Proxy object, 'method'\n+   *        will be the reflection object owned by the declaring\n+   *        class or interface, which may be a supertype of the\n+   *        interfaces the proxy directly implements.\n+   * @param args the arguments passed to the original method, or\n+   *        <code>null</code> if the method takes no arguments.\n+   *        (But also be prepared to handle a 0-length array).\n+   *        Arguments of primitive type, such as <code>boolean</code>\n+   *        or <code>int</code>, are wrapped in the appropriate\n+   *        class such as {@link Boolean} or {@link Integer}.\n+   * @return whatever is necessary to return from the wrapped method.\n+   *         If the wrapped method is <code>void</code>, the proxy\n+   *         instance will ignore it.  If the wrapped method returns\n+   *         a primitive, this must be the correct wrapper type whose value\n+   *         is exactly assignable to the appropriate type (no widening\n+   *         will be performed); a null object in this case causes a\n+   *         {@link NullPointerException}.  In all remaining cases, if\n+   *         the returned object is not assignment compatible to the\n+   *         declared type of the original method, the proxy instance\n+   *         will generate a {@link ClassCastException}.\n+   * @throws Throwable this interface is listed as throwing anything,\n+   *         but the implementation should only throw unchecked\n+   *         exceptions and exceptions listed in the throws clause of\n+   *         all methods being overridden by the proxy instance.  If\n+   *         something is thrown that is not compatible with the throws\n+   *         clause of all overridden methods, the proxy instance will\n+   *         wrap the exception in an UndeclaredThrowableException.\n+   *         Note that an exception listed in the throws clause of the\n+   *         `method' parameter might not be declared in additional\n+   *         interfaces also implemented by the proxy object.\n+   *\n+   * @see Proxy\n+   * @see UndeclaredThrowableException\n+   */\n+  Object invoke(Object proxy, Method method, Object[] args)\n+    throws Throwable;\n+\n+}"}, {"sha": "972ac19c37ac3449cc67be470c000358b8a26fe5", "filename": "libjava/java/lang/reflect/Proxy.java", "status": "added", "additions": 1586, "deletions": 0, "changes": 1586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2Freflect%2FProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2Freflect%2FProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FProxy.java?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -0,0 +1,1586 @@\n+/* Proxy.java -- build a proxy class that implements reflected interfaces\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.lang.reflect;\n+\n+import java.io.Serializable;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import gnu.classpath.Configuration;\n+import gnu.java.lang.reflect.TypeSignature;\n+\n+/**\n+ * This class allows you to dynamically create an instance of any (or\n+ * even multiple) interfaces by reflection, and decide at runtime\n+ * how that instance will behave by giving it an appropriate\n+ * {@link InvocationHandler}.  Proxy classes serialize specially, so\n+ * that the proxy object can be reused between VMs, without requiring\n+ * a persistent copy of the generated class code.\n+ *\n+ * <h3>Creation</h3>\n+ * To create a proxy for some interface Foo:\n+ *\n+ * <pre>\n+ *   InvocationHandler handler = new MyInvocationHandler(...);\n+ *   Class proxyClass = Proxy.getProxyClass(\n+ *       Foo.class.getClassLoader(), new Class[] { Foo.class });\n+ *   Foo f = (Foo) proxyClass\n+ *       .getConstructor(new Class[] { InvocationHandler.class })\n+ *       .newInstance(new Object[] { handler });\n+ * </pre>\n+ * or more simply:\n+ * <pre>\n+ *   Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),\n+ *                                        new Class[] { Foo.class },\n+ *                                        handler);\n+ * </pre>\n+ *\n+ * <h3>Dynamic Proxy Classes</h3>\n+ * A dynamic proxy class is created at runtime, and has the following\n+ * properties:\n+ * <ul>\n+ *  <li>The class is <code>public</code> and <code>final</code>,\n+ *      and is neither <code>abstract</code> nor an inner class.</li>\n+ *  <li>The class has no canonical name (there is no formula you can use\n+ *      to determine or generate its name), but begins with the\n+ *      sequence \"$Proxy\".  Abuse this knowledge at your own peril.\n+ *      (For now, '$' in user identifiers is legal, but it may not\n+ *      be that way forever. You weren't using '$' in your\n+ *      identifiers, were you?)</li>\n+ *  <li>The class extends Proxy, and explicitly implements all the\n+ *      interfaces specified at creation, in order (this is important\n+ *      for determining how method invocation is resolved).  Note that\n+ *      a proxy class implements {@link Serializable}, at least\n+ *      implicitly, since Proxy does, but true serial behavior\n+ *      depends on using a serializable invocation handler as well.</li>\n+ *  <li>If at least one interface is non-public, the proxy class\n+ *      will be in the same package.  Otherwise, the package is\n+ *      unspecified.  This will work even if the package is sealed\n+ *      from user-generated classes, because Proxy classes are\n+ *      generated by a trusted source.  Meanwhile, the proxy class\n+ *      belongs to the classloader you designated.</li>\n+ *  <li>Reflection works as expected: {@link Class#getInterfaces()} and\n+ *      {@link Class#getMethods()} work as they do on normal classes.</li>\n+ *  <li>The method {@link #isProxyClass()} will distinguish between\n+ *      true proxy classes and user extensions of this class.  It only\n+ *      returns true for classes created by {@link #getProxyClass}.</li>\n+ *  <li>The {@link ProtectionDomain} of a proxy class is the same as for\n+ *      bootstrap classes, such as Object or Proxy, since it is created by\n+ *      a trusted source.  This protection domain will typically be granted\n+ *      {@link java.security.AllPermission}. But this is not a security\n+ *      risk, since there are adequate permissions on reflection, which is\n+ *      the only way to create an instance of the proxy class.</li>\n+ *  <li>The proxy class contains a single constructor, which takes as\n+ *      its only argument an {@link InvocationHandler}.  The method\n+ *      {@link #newInstance} is shorthand to do the necessary\n+ *      reflection.</li>\n+ * </ul>\n+ *\n+ * <h3>Proxy Instances</h3>\n+ * A proxy instance is an instance of a proxy class.  It has the\n+ * following properties, many of which follow from the properties of a\n+ * proxy class listed above:\n+ * <ul>\n+ *  <li>For a proxy class with Foo listed as one of its interfaces, the\n+ *      expression <code>proxy instanceof Foo</code> will return true,\n+ *      and the expression <code>(Foo) proxy</code> will succeed without\n+ *      a {@link ClassCastException}.</li>\n+ *  <li>Each proxy instance has an invocation handler, which can be\n+ *      accessed by {@link #getInvocationHandler(Object)}.  Any call\n+ *      to an interface method, including {@link Object#hashcode()},\n+ *      {@link Object#equals(Object)}, or {@link Object#toString()},\n+ *      but excluding the public final methods of Object, will be\n+ *      encoded and passed to the {@link InvocationHandler#invoke}\n+ *      method of this handler.</li>\n+ * </ul>\n+ *\n+ * <h3>Inheritance Issues</h3>\n+ * A proxy class may inherit a method from more than one interface.\n+ * The order in which interfaces are listed matters, because it determines\n+ * which reflected {@link Method} object will be passed to the invocation\n+ * handler.  This means that the dynamically generated class cannot\n+ * determine through which interface a method is being invoked.<p>\n+ *\n+ * In short, if a method is declared in Object (namely, hashCode,\n+ * equals, or toString), then Object will be used; otherwise, the\n+ * leftmost interface that inherits or declares a method will be used,\n+ * even if it has a more permissive throws clause than what the proxy\n+ * class is allowed. Thus, in the invocation handler, it is not always\n+ * safe to assume that every class listed in the throws clause of the\n+ * passed Method object can safely be thrown; fortunately, the Proxy\n+ * instance is robust enough to wrap all illegal checked exceptions in\n+ * {@link UndeclaredThrowableException}.\n+ *\n+ * @see InvocationHandler\n+ * @see UndeclaredThrowableException\n+ * @see Class\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.3\n+ * @status updated to 1.4, except for the use of ProtectionDomain\n+ */\n+public class Proxy implements Serializable\n+{\n+  /**\n+   * Compatible with JDK 1.3+.\n+   */\n+  private static final long serialVersionUID = -2222568056686623797L;\n+\n+  /**\n+   * Map of ProxyType to proxy class.\n+   *\n+   * @XXX This prevents proxy classes from being garbage collected.\n+   * java.util.WeakHashSet is not appropriate, because that collects the\n+   * keys, but we are interested in collecting the elements.\n+   */\n+  private static final Map proxyClasses = new HashMap();\n+\n+  /**\n+   * The invocation handler for this proxy instance.  For Proxy, this\n+   * field is unused, but it appears here in order to be serialized in all\n+   * proxy classes.\n+   *\n+   * <em>NOTE</em>: This implementation is more secure for proxy classes\n+   * than what Sun specifies. Sun does not require h to be immutable, but\n+   * this means you could change h after the fact by reflection.  However,\n+   * by making h immutable, we may break non-proxy classes which extend\n+   * Proxy.\n+   * @serial invocation handler associated with this proxy instance\n+   */\n+  protected final InvocationHandler h;\n+\n+  /**\n+   * Constructs a new Proxy from a subclass (usually a proxy class),\n+   * with the specified invocation handler.\n+   *\n+   * <em>NOTE</em>: This throws a NullPointerException if you attempt\n+   * to create a proxy instance with a null handler using reflection.\n+   * This behavior is not yet specified by Sun; see Sun Bug 4487672.\n+   *\n+   * @param handler the invocation handler, may be null if the subclass\n+   *        is not a proxy class\n+   * @throws NullPointerException if handler is null and this is a proxy\n+   *         instance\n+   */\n+  protected Proxy(InvocationHandler handler)\n+  {\n+    if (handler == null && isProxyClass(getClass()))\n+      throw new NullPointerException(\"invalid handler\");\n+    h = handler;\n+  }\n+\n+  /**\n+   * Returns the proxy {@link Class} for the given ClassLoader and array\n+   * of interfaces, dynamically generating it if necessary.\n+   *\n+   * There are several restrictions on this method, the violation of\n+   * which will result in an IllegalArgumentException or\n+   * NullPointerException:\n+   * <ul>\n+   *  <li>All objects in `interfaces' must represent distinct interfaces.\n+   *      Classes, primitive types, null, and duplicates are forbidden.</li>\n+   *  <li>The interfaces must be visible in the specified ClassLoader.\n+   *      In other words, for each interface i:\n+   *      <code>Class.forName(i.getName(), false, loader) == i</code>\n+   *      must be true.</li>\n+   *  <li>All non-public interfaces (if any) must reside in the same\n+   *      package, or the proxy class would be non-instantiable.  If\n+   *      there are no non-public interfaces, the package of the proxy\n+   *      class is unspecified.</li>\n+   *  <li>All interfaces must be compatible - if two declare a method\n+   *      with the same name and parameters, the return type must be\n+   *      the same and the throws clause of the proxy class will be\n+   *      the maximal subset of subclasses of the throws clauses for\n+   *      each method that is overridden.</li>\n+   *  <li>VM constraints limit the number of interfaces a proxy class\n+   *      may directly implement (however, the indirect inheritance\n+   *      of {@link Serializable} does not count against this limit).\n+   *      Even though most VMs can theoretically have 65535\n+   *      superinterfaces for a class, the actual limit is smaller\n+   *      because a class's constant pool is limited to 65535 entries,\n+   *      and not all entries can be interfaces.</li>\n+   * </ul><p>\n+   *\n+   * Note that different orders of interfaces produce distinct classes.\n+   *\n+   * @param loader the class loader to define the proxy class in; null\n+   *        implies the bootstrap class loader\n+   * @param interfaces the array of interfaces the proxy class implements,\n+   *        may be empty, but not null\n+   * @return the Class object of the proxy class\n+   * @throws IllegalArgumentException if the constraints above were\n+   *         violated, except for problems with null\n+   * @throws NullPointerException if `interfaces' is null or contains\n+   *         a null entry\n+   */\n+  // synchronized so that we aren't trying to build the same class\n+  // simultaneously in two threads\n+  public static synchronized Class getProxyClass(ClassLoader loader,\n+                                                 Class[] interfaces)\n+  {\n+    interfaces = (Class[]) interfaces.clone();\n+    ProxyType pt = new ProxyType(loader, interfaces);\n+    Class clazz = (Class) proxyClasses.get(pt);\n+    if (clazz == null)\n+      {\n+        if (Configuration.HAVE_NATIVE_GET_PROXY_CLASS)\n+          clazz = getProxyClass0(loader, interfaces);\n+        else\n+          {\n+            ProxyData data = (Configuration.HAVE_NATIVE_GET_PROXY_DATA\n+                              ? getProxyData0(loader, interfaces)\n+                              : ProxyData.getProxyData(pt));\n+\n+            // FIXME workaround for bug in gcj 3.0.x\n+            // Not needed with the latest gcj from cvs\n+            //clazz = (Configuration.HAVE_NATIVE_GENERATE_PROXY_CLASS\n+            //\t       ? generateProxyClass0(loader, data)\n+            //         : new ClassFactory(data).generate(loader));\n+            if (Configuration.HAVE_NATIVE_GENERATE_PROXY_CLASS)\n+              clazz = generateProxyClass0(loader, data);\n+            else\n+              {\n+                ClassFactory cf = new ClassFactory(data);\n+                clazz = cf.generate(loader);\n+              }\n+          }\n+\n+        Object check = proxyClasses.put(pt, clazz);\n+        // assert check == null && clazz != null;\n+        if (check != null || clazz == null)\n+          throw new InternalError(/*\"Fatal flaw in getProxyClass\"*/);\n+      }\n+    return clazz;\n+  }\n+\n+  /**\n+   * Combines several methods into one.  This is equivalent to:\n+   * <pre>\n+   *   Proxy.getProxyClass(loader, interfaces)\n+   *       .getConstructor(new Class[] {InvocationHandler.class})\n+   *       .newInstance(new Object[] {handler});\n+   * </pre>\n+   * except that it will not fail with the normal problems caused\n+   * by reflection.  It can still fail for the same reasons documented\n+   * in getProxyClass, or if handler is null.\n+   *\n+   * @param loader the class loader to define the proxy class in; null\n+   *        implies the bootstrap class loader\n+   * @param interfaces the array of interfaces the proxy class implements,\n+   *        may be empty, but not null\n+   * @param handler the invocation handler, may not be null\n+   * @return a proxy instance implementing the specified interfaces\n+   * @throws IllegalArgumentException if the constraints for getProxyClass\n+   *         were violated, except for problems with null\n+   * @throws NullPointerException if `interfaces' is null or contains\n+   *         a null entry, or if handler is null\n+   * @see #getProxyClass(ClassLoader, Class[])\n+   * @see Class#getConstructor(Class[])\n+   * @see Constructor#newInstance(Object[])\n+   */\n+  public static Object newProxyInstance(ClassLoader loader,\n+                                        Class[] interfaces,\n+                                        InvocationHandler handler)\n+  {\n+    try\n+      {\n+        // getProxyClass() and Proxy() throw the necessary exceptions\n+        return getProxyClass(loader, interfaces)\n+          .getConstructor(new Class[] {InvocationHandler.class})\n+          .newInstance(new Object[] {handler});\n+      }\n+    catch (RuntimeException e)\n+      {\n+        // Let IllegalArgumentException, NullPointerException escape.\n+        // assert e instanceof IllegalArgumentException\n+        //   || e instanceof NullPointerException;\n+        throw e;\n+      }\n+    catch (InvocationTargetException e)\n+      {\n+        // Let wrapped NullPointerException escape.\n+        // assert e.getTargetException() instanceof NullPointerException\n+        throw (NullPointerException) e.getCause();\n+      }\n+    catch (Exception e)\n+      {\n+        // Covers InstantiationException, IllegalAccessException,\n+        // NoSuchMethodException, none of which should be generated\n+        // if the proxy class was generated correctly.\n+        // assert false;\n+        throw (Error) new InternalError(\"Unexpected: \" + e).initCause(e);\n+      }\n+  }\n+\n+  /**\n+   * Returns true if and only if the Class object is a dynamically created\n+   * proxy class (created by <code>getProxyClass</code> or by the\n+   * syntactic sugar of <code>newProxyInstance</code>).\n+   *\n+   * <p>This check is secure (in other words, it is not simply\n+   * <code>clazz.getSuperclass() == Proxy.class</code>), it will not\n+   * be spoofed by non-proxy classes that extend Proxy.\n+   *\n+   * @param clazz the class to check, must not be null\n+   * @return true if the class represents a proxy class\n+   * @throws NullPointerException if clazz is null\n+   */\n+  // This is synchronized on the off chance that another thread is\n+  // trying to add a class to the map at the same time we read it.\n+  public static synchronized boolean isProxyClass(Class clazz)\n+  {\n+    if (! Proxy.class.isAssignableFrom(clazz))\n+      return false;\n+    // This is a linear search, even though we could do an O(1) search\n+    // using new ProxyType(clazz.getClassLoader(), clazz.getInterfaces()).\n+    return proxyClasses.containsValue(clazz);\n+  }\n+\n+  /**\n+   * Returns the invocation handler for the given proxy instance.<p>\n+   *\n+   * <em>NOTE</em>: We guarantee a non-null result if successful,\n+   * but Sun allows the creation of a proxy instance with a null\n+   * handler.  See the comments for {@link #Proxy(InvocationHandler)}.\n+   *\n+   * @param proxy the proxy instance, must not be null\n+   * @return the invocation handler, guaranteed non-null.\n+   * @throws IllegalArgumentException if\n+   *         <code>Proxy.isProxyClass(proxy.getClass())</code> returns false.\n+   * @throws NullPointerException if proxy is null\n+   */\n+  public static InvocationHandler getInvocationHandler(Object proxy)\n+  {\n+    if (! isProxyClass(proxy.getClass()))\n+      throw new IllegalArgumentException(\"not a proxy instance\");\n+    return ((Proxy) proxy).h;\n+  }\n+\n+  /**\n+   * Optional native method to replace (and speed up) the pure Java\n+   * implementation of getProxyClass.  Only needed if\n+   * Configuration.HAVE_NATIVE_GET_PROXY_CLASS is true, this does the\n+   * work of both getProxyData0 and generateProxyClass0 with no\n+   * intermediate form in Java. The native code may safely assume that\n+   * this class must be created, and does not already exist.\n+   *\n+   * @param loader the class loader to define the proxy class in; null\n+   *        implies the bootstrap class loader\n+   * @param interfaces the interfaces the class will extend\n+   * @return the generated proxy class\n+   * @throws IllegalArgumentException if the constraints for getProxyClass\n+   *         were violated, except for problems with null\n+   * @throws NullPointerException if `interfaces' is null or contains\n+   *         a null entry, or if handler is null\n+   * @see Configuration#HAVE_NATIVE_GET_PROXY_CLASS\n+   * @see #getProxyClass(ClassLoader, Class[])\n+   * @see #getProxyData0(ClassLoader, Class[])\n+   * @see #generateProxyClass0(ProxyData)\n+   */\n+  private static native Class getProxyClass0(ClassLoader loader,\n+                                             Class[] interfaces);\n+\n+  /**\n+   * Optional native method to replace (and speed up) the pure Java\n+   * implementation of getProxyData.  Only needed if\n+   * Configuration.HAVE_NATIVE_GET_PROXY_DATA is true. The native code\n+   * may safely assume that a new ProxyData object must be created which\n+   * does not duplicate any existing ones.\n+   *\n+   * @param loader the class loader to define the proxy class in; null\n+   *        implies the bootstrap class loader\n+   * @param interfaces the interfaces the class will extend\n+   * @return all data that is required to make this proxy class\n+   * @throws IllegalArgumentException if the constraints for getProxyClass\n+   *         were violated, except for problems with null\n+   * @throws NullPointerException if `interfaces' is null or contains\n+   *         a null entry, or if handler is null\n+   * @see Configuration.HAVE_NATIVE_GET_PROXY_DATA\n+   * @see #getProxyClass(ClassLoader, Class[])\n+   * @see #getProxyClass0(ClassLoader, Class[])\n+   * @see ProxyType#getProxyData()\n+   */\n+  private static native ProxyData getProxyData0(ClassLoader loader,\n+                                                Class[] interfaces);\n+\n+  /**\n+   * Optional native method to replace (and speed up) the pure Java\n+   * implementation of generateProxyClass.  Only needed if\n+   * Configuration.HAVE_NATIVE_GENERATE_PROXY_CLASS is true. The native\n+   * code may safely assume that a new Class must be created, and that\n+   * the ProxyData object does not describe any existing class.\n+   *\n+   * @param loader the class loader to define the proxy class in; null\n+   *        implies the bootstrap class loader\n+   * @param data the struct of information to convert to a Class. This\n+   *        has already been verified for all problems except exceeding\n+   *        VM limitations\n+   * @return the newly generated class\n+   * @throws IllegalArgumentException if VM limitations are exceeded\n+   * @see #getProxyClass(ClassLoader, Class[])\n+   * @see #getProxyClass0(ClassLoader, Class[])\n+   * @see ProxyData#generateProxyClass(ClassLoader)\n+   */\n+  private static native Class generateProxyClass0(ClassLoader loader,\n+                                                  ProxyData data);\n+\n+\f\n+  /**\n+   * Helper class for mapping unique ClassLoader and interface combinations\n+   * to proxy classes.\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private static final class ProxyType\n+  {\n+    /**\n+     * Store the class loader (may be null)\n+     */\n+    final ClassLoader loader;\n+\n+    /**\n+     * Store the interfaces (never null, all elements are interfaces)\n+     */\n+    final Class[] interfaces;\n+\n+    /**\n+     * Construct the helper object.\n+     *\n+     * @param loader the class loader to define the proxy class in; null\n+     *        implies the bootstrap class loader\n+     * @param interfaces an array of interfaces\n+     */\n+    ProxyType(ClassLoader loader, Class[] interfaces)\n+    {\n+      this.loader = loader;\n+      this.interfaces = interfaces;\n+    }\n+\n+    /**\n+     * Calculates the hash code.\n+     *\n+     * @return a combination of the classloader and interfaces hashcodes.\n+     */\n+    public int hashCode()\n+    {\n+      int hash = (loader == null) ? 0 : loader.hashCode();\n+      for (int i = 0; i < interfaces.length; i++)\n+        hash = hash * 31 + interfaces[i].hashCode();\n+      return hash;\n+    }\n+\n+    /**\n+     * Calculates equality.\n+     *\n+     * @param the object to compare to\n+     * @return true if it is a ProxyType with same data\n+     */\n+    public boolean equals(Object other)\n+    {\n+      ProxyType pt = (ProxyType) other;\n+      if (loader != pt.loader || interfaces.length != pt.interfaces.length)\n+        return false;\n+      int i = interfaces.length;\n+      while (--i >= 0)\n+        if (interfaces[i] != pt.interfaces[i])\n+          return false;\n+      return true;\n+    }\n+  } // class ProxyType\n+\n+\f\n+  /**\n+   * Helper class which allows hashing of a method name and signature\n+   * without worrying about return type, declaring class, or throws clause,\n+   * and which reduces the maximally common throws clause between two methods\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private static final class ProxySignature\n+  {\n+    /**\n+     * The core signatures which all Proxy instances handle.\n+     */\n+    static final HashMap coreMethods = new HashMap();\n+    static\n+    {\n+      try\n+        {\n+          ProxySignature sig\n+            = new ProxySignature(Object.class\n+                                 .getMethod(\"equals\",\n+                                            new Class[] {Object.class}));\n+          coreMethods.put(sig, sig);\n+          sig = new ProxySignature(Object.class.getMethod(\"hashCode\", null));\n+          coreMethods.put(sig, sig);\n+          sig = new ProxySignature(Object.class.getMethod(\"toString\", null));\n+          coreMethods.put(sig, sig);\n+        }\n+      catch (Exception e)\n+        {\n+          // assert false;\n+          throw (Error) new InternalError(\"Unexpected: \" + e).initCause(e);\n+        }\n+    }\n+\n+    /**\n+     * The underlying Method object, never null\n+     */\n+    final Method method;\n+\n+    /**\n+     * The set of compatible thrown exceptions, may be empty\n+     */\n+    final Set exceptions = new HashSet();\n+\n+    /**\n+     * Construct a signature\n+     *\n+     * @param method the Method this signature is based on, never null\n+     */\n+    ProxySignature(Method method)\n+    {\n+      this.method = method;\n+      Class[] exc = method.getExceptionTypes();\n+      int i = exc.length;\n+      while (--i >= 0)\n+        {\n+          // discard unchecked exceptions\n+          if (Error.class.isAssignableFrom(exc[i])\n+              || RuntimeException.class.isAssignableFrom(exc[i]))\n+            continue;\n+          exceptions.add(exc[i]);\n+        }\n+    }\n+\n+    /**\n+     * Given a method, make sure it's return type is identical\n+     * to this, and adjust this signature's throws clause appropriately\n+     *\n+     * @param other the signature to merge in\n+     * @throws IllegalArgumentException if the return types conflict\n+     */\n+    void checkCompatibility(ProxySignature other)\n+    {\n+      if (method.getReturnType() != other.method.getReturnType())\n+        throw new IllegalArgumentException(\"incompatible return types: \"\n+                                           + method + \", \" + other.method);\n+\n+      // if you can think of a more efficient way than this O(n^2) search,\n+      // implement it!\n+      int size1 = exceptions.size();\n+      int size2 = other.exceptions.size();\n+      boolean[] valid1 = new boolean[size1];\n+      boolean[] valid2 = new boolean[size2];\n+      Iterator itr = exceptions.iterator();\n+      int pos = size1;\n+      while (--pos >= 0)\n+        {\n+          Class c1 = (Class) itr.next();\n+          Iterator itr2 = other.exceptions.iterator();\n+          int pos2 = size2;\n+          while (--pos2 >= 0)\n+            {\n+              Class c2 = (Class) itr2.next();\n+              if (c2.isAssignableFrom(c1))\n+                valid1[pos] = true;\n+              if (c1.isAssignableFrom(c2))\n+                valid2[pos2] = true;\n+            }\n+        }\n+      pos = size1;\n+      itr = exceptions.iterator();\n+      while (--pos >= 0)\n+        {\n+          itr.next();\n+          if (! valid1[pos])\n+            itr.remove();\n+        }\n+      pos = size2;\n+      itr = other.exceptions.iterator();\n+      while (--pos >= 0)\n+        {\n+          itr.next();\n+          if (! valid2[pos])\n+            itr.remove();\n+        }\n+      exceptions.addAll(other.exceptions);\n+    }\n+\n+    /**\n+     * Calculates the hash code.\n+     *\n+     * @return a combination of name and parameter types\n+     */\n+    public int hashCode()\n+    {\n+      int hash = method.getName().hashCode();\n+      Class[] types = method.getParameterTypes();\n+      for (int i = 0; i < types.length; i++)\n+        hash = hash * 31 + types[i].hashCode();\n+      return hash;\n+    }\n+\n+    /**\n+     * Calculates equality.\n+     *\n+     * @param the object to compare to\n+     * @return true if it is a ProxySignature with same data\n+     */\n+    public boolean equals(Object other)\n+    {\n+      ProxySignature ps = (ProxySignature) other;\n+      Class[] types1 = method.getParameterTypes();\n+      Class[] types2 = ps.method.getParameterTypes();\n+      if (! method.getName().equals(ps.method.getName())\n+          || types1.length != types2.length)\n+        return false;\n+      int i = types1.length;\n+      while (--i >= 0)\n+        if (types1[i] != types2[i])\n+          return false;\n+      return true;\n+    }\n+  } // class ProxySignature\n+\n+\f\n+  /**\n+   * A flat representation of all data needed to generate bytecode/instantiate\n+   * a proxy class.  This is basically a struct.\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private static final class ProxyData\n+  {\n+    /**\n+     * The package this class is in.  Possibly null, meaning the unnamed\n+     * package.\n+     */\n+    Package pack;\n+\n+    /**\n+     * The interfaces this class implements.  Non-null, but possibly empty.\n+     */\n+    Class[] interfaces;\n+\n+    /**\n+     * The Method objects this class must pass as the second argument to\n+     * invoke (also useful for determining what methods this class has).\n+     * Non-null, non-empty (includes at least Object.hashCode, Object.equals,\n+     * and Object.toString).\n+     */\n+    Method[] methods;\n+\n+    /**\n+     * The exceptions that do not need to be wrapped in\n+     * UndeclaredThrowableException. exceptions[i] is the same as, or a\n+     * subset of subclasses, of methods[i].getExceptionTypes(), depending on\n+     * compatible throws clauses with multiple inheritance. It is unspecified\n+     * if these lists include or exclude subclasses of Error and\n+     * RuntimeException, but excluding them is harmless and generates a\n+     * smaller class.\n+     */\n+    Class[][] exceptions;\n+\n+    /**\n+     * For unique id's\n+     */\n+    private static int count = 0;\n+\n+    /**\n+     * The id of this proxy class\n+     */\n+    final int id = count++;\n+\n+    /**\n+     * Construct a ProxyData with uninitialized data members.\n+     */\n+    ProxyData()\n+    {\n+    }\n+\n+    /**\n+     * Verifies that the arguments are legal, and sets up remaining data\n+     * This should only be called when a class must be generated, as\n+     * it is expensive.\n+     *\n+     * @param pt the ProxyType to convert to ProxyData\n+     * @return the flattened, verified ProxyData structure for use in\n+     *         class generation\n+     * @throws IllegalArgumentException if `interfaces' contains\n+     *         non-interfaces or incompatible combinations, and verify is true\n+     * @throws NullPointerException if interfaces is null or contains null\n+     */\n+    static ProxyData getProxyData(ProxyType pt)\n+    {\n+      Map method_set = (Map) ProxySignature.coreMethods.clone();\n+      boolean in_package = false; // true if we encounter non-public interface\n+\n+      ProxyData data = new ProxyData();\n+      data.interfaces = pt.interfaces;\n+\n+      // if interfaces is too large, we croak later on when the constant\n+      // pool overflows\n+      int i = data.interfaces.length;\n+      while (--i >= 0)\n+        {\n+          Class inter = data.interfaces[i];\n+          if (! inter.isInterface())\n+            throw new IllegalArgumentException(\"not an interface: \" + inter);\n+          try\n+            {\n+              if (Class.forName(inter.getName(), false, pt.loader) != inter)\n+                throw new IllegalArgumentException(\"not accessible in \"\n+                                                   + \"classloader: \" + inter);\n+            }\n+          catch (ClassNotFoundException e)\n+            {\n+              throw new IllegalArgumentException(\"not accessible in \"\n+                                                 + \"classloader: \" + inter);\n+            }\n+          if (! Modifier.isPublic(inter.getModifiers()))\n+            if (in_package)\n+              {\n+                Package p = inter.getPackage();\n+                if (data.pack != inter.getPackage())\n+                  throw new IllegalArgumentException(\"non-public interfaces \"\n+                                                     + \"from different \"\n+                                                     + \"packages\");\n+              }\n+            else\n+              {\n+                in_package = true;\n+                data.pack = inter.getPackage();\n+              }\n+          for (int j = i-1; j >= 0; j--)\n+            if (data.interfaces[j] == inter)\n+              throw new IllegalArgumentException(\"duplicate interface: \"\n+                                                 + inter);\n+          Method[] methods = inter.getMethods();\n+          int j = methods.length;\n+          while (--j >= 0)\n+            {\n+              ProxySignature sig = new ProxySignature(methods[j]);\n+              ProxySignature old = (ProxySignature) method_set.put(sig, sig);\n+              if (old != null)\n+                sig.checkCompatibility(old);\n+            }\n+        }\n+\n+      i = method_set.size();\n+      data.methods = new Method[i];\n+      data.exceptions = new Class[i][];\n+      Iterator itr = method_set.values().iterator();\n+      while (--i >= 0)\n+        {\n+          ProxySignature sig = (ProxySignature) itr.next();\n+          data.methods[i] = sig.method;\n+          data.exceptions[i] = (Class[]) sig.exceptions\n+            .toArray(new Class[sig.exceptions.size()]);\n+        }\n+      return data;\n+    }\n+  } // class ProxyData\n+\n+\f\n+  /**\n+   * Does all the work of building a class. By making this a nested class,\n+   * this code is not loaded in memory if the VM has a native\n+   * implementation instead.\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private static final class ClassFactory\n+  {\n+    /** Constants for assisting the compilation */\n+    private static final byte POOL = 0;\n+    private static final byte FIELD = 1;\n+    private static final byte METHOD = 2;\n+    private static final byte INTERFACE = 3;\n+    private static final String CTOR_SIG\n+      = \"(Ljava/lang/reflect/InvocationHandler;)V\";\n+    private static final String INVOKE_SIG = \"(Ljava/lang/Object;\"\n+      + \"Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;\";\n+\n+    /** Bytecodes for insertion in the class definition byte[] */\n+    private static final char ACONST_NULL = 1;\n+    private static final char ICONST_0 = 3;\n+    private static final char BIPUSH = 16;\n+    private static final char SIPUSH = 17;\n+    private static final char ILOAD = 21;\n+    private static final char ILOAD_0 = 26;\n+    private static final char ALOAD_0 = 42;\n+    private static final char ALOAD_1 = 43;\n+    private static final char AALOAD = 50;\n+    private static final char AASTORE = 83;\n+    private static final char DUP = 89;\n+    private static final char DUP_X1 = 90;\n+    private static final char SWAP = 95;\n+    private static final char IRETURN = 172;\n+    private static final char LRETURN = 173;\n+    private static final char FRETURN = 174;\n+    private static final char DRETURN = 175;\n+    private static final char ARETURN = 176;\n+    private static final char RETURN = 177;\n+    private static final char GETSTATIC = 178;\n+    private static final char GETFIELD = 180;\n+    private static final char INVOKEVIRTUAL = 182;\n+    private static final char INVOKESPECIAL = 183;\n+    private static final char INVOKESTATIC = 184;\n+    private static final char INVOKEINTERFACE = 185;\n+    private static final char NEW = 187;\n+    private static final char ANEWARRAY = 189;\n+    private static final char ATHROW = 191;\n+    private static final char CHECKCAST = 192;\n+\n+    // Implementation note: we use StringBuffers to hold the byte data, since\n+    // they automatically grow.  However, we only use the low 8 bits of\n+    // every char in the array, so we are using twice the necessary memory\n+    // for the ease StringBuffer provides.\n+\n+    /** The constant pool. */\n+    private final StringBuffer pool = new StringBuffer();\n+    /** The rest of the class data. */\n+    private final StringBuffer stream = new StringBuffer();\n+\n+    /** Map of strings to byte sequences, to minimize size of pool. */\n+    private final Map poolEntries = new HashMap();\n+\n+    /** The VM name of this proxy class. */\n+    private final String qualName;\n+\n+    /**\n+     * The Method objects the proxy class refers to when calling the\n+     * invocation handler.\n+     */\n+    private final Method[] methods;\n+\n+    /**\n+     * Initializes the buffers with the bytecode contents for a proxy class.\n+     *\n+     * @param data the remainder of the class data\n+     * @throws IllegalArgumentException if anything else goes wrong this\n+     *         late in the game; as far as I can tell, this will only happen\n+     *         if the constant pool overflows, which is possible even when\n+     *         the user doesn't exceed the 65535 interface limit\n+     */\n+    ClassFactory(ProxyData data)\n+    {\n+      methods = data.methods;\n+\n+      // magic = 0xcafebabe\n+      // minor_version = 0\n+      // major_version = 46\n+      // constant_pool_count: place-holder for now\n+      pool.append(\"\\u00ca\\u00fe\\u00ba\\u00be\\0\\0\\0\\56\\0\\0\");\n+      // constant_pool[], filled in as we go\n+\n+      // access_flags\n+      putU2(Modifier.SUPER | Modifier.FINAL | Modifier.PUBLIC);\n+      // this_class\n+      qualName = ((data.pack == null ? \"\" : data.pack.getName() + '.')\n+                  + \"$Proxy\" + data.id);\n+      putU2(classInfo(TypeSignature.getEncodingOfClass(qualName, false)));\n+      // super_class\n+      putU2(classInfo(\"java/lang/reflect/Proxy\"));\n+\n+      // interfaces_count\n+      putU2(data.interfaces.length);\n+      // interfaces[]\n+      for (int i = 0; i < data.interfaces.length; i++)\n+        putU2(classInfo(data.interfaces[i]));\n+\n+      // Recall that Proxy classes serialize specially, so we do not need\n+      // to worry about a <clinit> method for this field.  Instead, we\n+      // just assign it by reflection after the class is successfully loaded.\n+      // fields_count - private static Method[] m;\n+      putU2(1);\n+      // fields[]\n+      // m.access_flags\n+      putU2(Modifier.PRIVATE | Modifier.STATIC);\n+      // m.name_index\n+      putU2(utf8Info(\"m\"));\n+      // m.descriptor_index\n+      putU2(utf8Info(\"[Ljava/lang/reflect/Method;\"));\n+      // m.attributes_count\n+      putU2(0);\n+      // m.attributes[]\n+\n+      // methods_count - # handler methods, plus <init>\n+      putU2(methods.length + 1);\n+      // methods[]\n+      // <init>.access_flags\n+      putU2(Modifier.PUBLIC);\n+      // <init>.name_index\n+      putU2(utf8Info(\"<init>\"));\n+      // <init>.descriptor_index\n+      putU2(utf8Info(CTOR_SIG));\n+      // <init>.attributes_count - only Code is needed\n+      putU2(1);\n+      // <init>.Code.attribute_name_index\n+      putU2(utf8Info(\"Code\"));\n+      // <init>.Code.attribute_length = 18\n+      // <init>.Code.info:\n+      //   $Proxynn(InvocationHandler h) { super(h); }\n+      // <init>.Code.max_stack = 2\n+      // <init>.Code.max_locals = 2\n+      // <init>.Code.code_length = 6\n+      // <init>.Code.code[]\n+      stream.append(\"\\0\\0\\0\\22\\0\\2\\0\\2\\0\\0\\0\\6\" + ALOAD_0 + ALOAD_1\n+                    + INVOKESPECIAL);\n+      putU2(refInfo(METHOD, \"java/lang/reflect/Proxy\", \"<init>\", CTOR_SIG));\n+      // <init>.Code.exception_table_length = 0\n+      // <init>.Code.exception_table[]\n+      // <init>.Code.attributes_count = 0\n+      // <init>.Code.attributes[]\n+      stream.append(RETURN + \"\\0\\0\\0\\0\");\n+\n+      for (int i = methods.length - 1; i >= 0; i--)\n+        emitMethod(i, data.exceptions[i]);\n+\n+      // attributes_count\n+      putU2(0);\n+      // attributes[] - empty; omit SourceFile attribute\n+      // XXX should we mark this with a Synthetic attribute?\n+    }\n+\n+    /**\n+     * Produce the bytecode for a single method.\n+     *\n+     * @param i the index of the method we are building\n+     * @param e the exceptions possible for the method\n+     */\n+    private void emitMethod(int i, Class[] e)\n+    {\n+      // First, we precalculate the method length and other information.\n+\n+      Method m = methods[i];\n+      Class[] paramtypes = m.getParameterTypes();\n+      int wrap_overhead = 0; // max words taken by wrapped primitive\n+      int param_count = 1; // 1 for this\n+      int code_length = 16; // aload_0, getfield, aload_0, getstatic, const,\n+      // aaload, const/aconst_null, invokeinterface\n+      if (i > 5)\n+        {\n+          if (i > Byte.MAX_VALUE)\n+            code_length += 2; // sipush\n+          else\n+            code_length++; // bipush\n+        }\n+      if (paramtypes.length > 0)\n+        {\n+          code_length += 3; // anewarray\n+          if (paramtypes.length > Byte.MAX_VALUE)\n+            code_length += 2; // sipush\n+          else if (paramtypes.length > 5)\n+            code_length++; // bipush\n+          for (int j = 0; j < paramtypes.length; j++)\n+            {\n+              code_length += 4; // dup, const, load, store\n+              Class type = paramtypes[j];\n+              if (j > 5)\n+                {\n+                  if (j > Byte.MAX_VALUE)\n+                    code_length += 2; // sipush\n+                  else\n+                    code_length++; // bipush\n+                }\n+              if (param_count >= 4)\n+                code_length++; // 2-byte load\n+              param_count++;\n+              if (type.isPrimitive())\n+                {\n+                  code_length += 7; // new, dup, invokespecial\n+                  if (type == long.class || type == double.class)\n+                    {\n+                      wrap_overhead = 3;\n+                      param_count++;\n+                    }\n+                  else if (wrap_overhead < 2)\n+                    wrap_overhead = 2;\n+                }\n+            }\n+        }\n+      int end_pc = code_length;\n+      Class ret_type = m.getReturnType();\n+      if (ret_type == void.class)\n+        code_length++; // return\n+      else if (ret_type.isPrimitive())\n+        code_length += 7; // cast, invokevirtual, return\n+      else\n+        code_length += 4; // cast, return\n+      int exception_count = 0;\n+      boolean throws_throwable = false;\n+      for (int j = 0; j < e.length; j++)\n+        if (e[j] == Throwable.class)\n+          {\n+            throws_throwable = true;\n+            break;\n+          }\n+      if (! throws_throwable)\n+        {\n+          exception_count = e.length + 3; // Throwable, Error, RuntimeException\n+          code_length += 9; // new, dup_x1, swap, invokespecial, athrow\n+        }\n+      int handler_pc = code_length - 1;\n+      StringBuffer signature = new StringBuffer(\"(\");\n+      for (int j = 0; j < paramtypes.length; j++)\n+        signature.append(TypeSignature.getEncodingOfClass(paramtypes[j]));\n+      signature.append(\")\").append(TypeSignature.getEncodingOfClass(ret_type));\n+\n+      // Now we have enough information to emit the method.\n+\n+      // handler.access_flags\n+      putU2(Modifier.PUBLIC | Modifier.FINAL);\n+      // handler.name_index\n+      putU2(utf8Info(m.getName()));\n+      // handler.descriptor_index\n+      putU2(utf8Info(signature.toString()));\n+      // handler.attributes_count - Code is necessary, Exceptions possible\n+      putU2(e.length > 0 ? 2 : 1);\n+\n+      // handler.Code.info:\n+      //   type name(args) {\n+      //     try {\n+      //       return (type) h.invoke(this, methods[i], new Object[] {args});\n+      //     } catch (<declared Exceptions> e) {\n+      //       throw e;\n+      //     } catch (Throwable t) {\n+      //       throw new UndeclaredThrowableException(t);\n+      //     }\n+      //   }\n+      // Special cases:\n+      //  if arg_n is primitive, wrap it\n+      //  if method throws Throwable, try-catch is not needed\n+      //  if method returns void, return statement not needed\n+      //  if method returns primitive, unwrap it\n+      //  save space by sharing code for all the declared handlers\n+\n+      // handler.Code.attribute_name_index\n+      putU2(utf8Info(\"Code\"));\n+      // handler.Code.attribute_length\n+      putU4(12 + code_length + 8 * exception_count);\n+      // handler.Code.max_stack\n+      putU2(param_count == 1 ? 4 : 7 + wrap_overhead);\n+      // handler.Code.max_locals\n+      putU2(param_count);\n+      // handler.Code.code_length\n+      putU4(code_length);\n+      // handler.Code.code[]\n+      putU1(ALOAD_0);\n+      putU1(GETFIELD);\n+      putU2(refInfo(FIELD, \"java/lang/reflect/Proxy\", \"h\",\n+                    \"Ljava/lang/reflect/InvocationHandler;\"));\n+      putU1(ALOAD_0);\n+      putU1(GETSTATIC);\n+      putU2(refInfo(FIELD, TypeSignature.getEncodingOfClass(qualName, false),\n+                    \"m\", \"[Ljava/lang/reflect/Method;\"));\n+      putConst(i);\n+      putU1(AALOAD);\n+      if (paramtypes.length > 0)\n+        {\n+          putConst(paramtypes.length);\n+          putU1(ANEWARRAY);\n+          putU2(classInfo(\"java/lang/Object\"));\n+          param_count = 1;\n+          for (int j = 0; j < paramtypes.length; j++, param_count++)\n+            {\n+              putU1(DUP);\n+              putConst(j);\n+              if (paramtypes[j].isPrimitive())\n+                {\n+                  putU1(NEW);\n+                  putU2(classInfo(wrapper(paramtypes[j])));\n+                  putU1(DUP);\n+                }\n+              putLoad(param_count, paramtypes[j]);\n+              if (paramtypes[j].isPrimitive())\n+                {\n+                  putU1(INVOKESPECIAL);\n+                  putU2(refInfo(METHOD, wrapper(paramtypes[j]), \"<init>\",\n+                                '(' + (TypeSignature\n+                                       .getEncodingOfClass(paramtypes[j])\n+                                       + \")V\")));\n+                  if (paramtypes[j] == long.class\n+                      || paramtypes[j] == double.class)\n+                    param_count++;\n+                }\n+              putU1(AASTORE);\n+            }\n+        }\n+      else\n+        putU1(ACONST_NULL);\n+      putU1(INVOKEINTERFACE);\n+      putU2(refInfo(INTERFACE, \"java/lang/reflect/InvocationHandler\",\n+                    \"invoke\", INVOKE_SIG));\n+      putU1(4); // InvocationHandler, this, Method, Object[]\n+      putU1(0);\n+      if (ret_type == void.class)\n+        putU1(RETURN);\n+      else if (ret_type.isPrimitive())\n+        {\n+          putU1(CHECKCAST);\n+          putU2(classInfo(wrapper(ret_type)));\n+          putU1(INVOKEVIRTUAL);\n+          putU2(refInfo(METHOD, wrapper(ret_type),\n+                        ret_type.getName() + \"Value\",\n+                        \"()\" + TypeSignature.getEncodingOfClass(ret_type)));\n+          if (ret_type == long.class)\n+            putU1(LRETURN);\n+          else if (ret_type == float.class)\n+            putU1(FRETURN);\n+          else if (ret_type == double.class)\n+            putU1(DRETURN);\n+          else\n+            putU1(IRETURN);\n+        }\n+      else\n+        {\n+          putU1(CHECKCAST);\n+          putU2(classInfo(ret_type));\n+          putU1(ARETURN);\n+        }\n+      if (! throws_throwable)\n+        {\n+          putU1(NEW);\n+          putU2(classInfo(\"java/lang/reflect/UndeclaredThrowableException\"));\n+          putU1(DUP_X1);\n+          putU1(SWAP);\n+          putU1(INVOKESPECIAL);\n+          putU2(refInfo(METHOD,\n+                        \"java/lang/reflect/UndeclaredThrowableException\",\n+                        \"<init>\", \"(Ljava/lang/Throwable;)V\"));\n+          putU1(ATHROW);\n+        }\n+\n+      // handler.Code.exception_table_length\n+      putU2(exception_count);\n+      // handler.Code.exception_table[]\n+      if (! throws_throwable)\n+        {\n+          // handler.Code.exception_table.start_pc\n+          putU2(0);\n+          // handler.Code.exception_table.end_pc\n+          putU2(end_pc);\n+          // handler.Code.exception_table.handler_pc\n+          putU2(handler_pc);\n+          // handler.Code.exception_table.catch_type\n+          putU2(classInfo(\"java/lang/Error\"));\n+          // handler.Code.exception_table.start_pc\n+          putU2(0);\n+          // handler.Code.exception_table.end_pc\n+          putU2(end_pc);\n+          // handler.Code.exception_table.handler_pc\n+          putU2(handler_pc);\n+          // handler.Code.exception_table.catch_type\n+          putU2(classInfo(\"java/lang/RuntimeException\"));\n+          for (int j = 0; j < e.length; j++)\n+            {\n+              // handler.Code.exception_table.start_pc\n+              putU2(0);\n+              // handler.Code.exception_table.end_pc\n+              putU2(end_pc);\n+              // handler.Code.exception_table.handler_pc\n+              putU2(handler_pc);\n+              // handler.Code.exception_table.catch_type\n+              putU2(classInfo(e[j]));\n+            }\n+          // handler.Code.exception_table.start_pc\n+          putU2(0);\n+          // handler.Code.exception_table.end_pc\n+          putU2(end_pc);\n+          // handler.Code.exception_table.handler_pc -\n+          //   -8 for undeclared handler, which falls thru to normal one\n+          putU2(handler_pc - 8);\n+          // handler.Code.exception_table.catch_type\n+          putU2(0);\n+        }\n+      // handler.Code.attributes_count\n+      putU2(0);\n+      // handler.Code.attributes[]\n+\n+      if (e.length > 0)\n+        {\n+          // handler.Exceptions.attribute_name_index\n+          putU2(utf8Info(\"Exceptions\"));\n+          // handler.Exceptions.attribute_length\n+          putU4(2 * e.length + 2);\n+          // handler.Exceptions.number_of_exceptions\n+          putU2(e.length);\n+          // handler.Exceptions.exception_index_table[]\n+          for (int j = 0; j < e.length; j++)\n+            putU2(classInfo(e[j]));\n+        }\n+    }\n+\n+    /**\n+     * Creates the Class object that corresponds to the bytecode buffers\n+     * built when this object was constructed.\n+     *\n+     * @param loader the class loader to define the proxy class in; null\n+     *        implies the bootstrap class loader\n+     * @return the proxy class Class object\n+     */\n+    final Class generate(ClassLoader loader)\n+    {\n+      byte[] bytecode = new byte[pool.length() + stream.length()];\n+      // More efficient to bypass calling charAt() repetitively.\n+      char[] c = pool.toString().toCharArray();\n+      int i = c.length;\n+      while (--i >= 0)\n+        bytecode[i] = (byte) c[i];\n+      c = stream.toString().toCharArray();\n+      i = c.length;\n+      int j = bytecode.length;\n+      while (i > 0)\n+        bytecode[--j] = (byte) c[--i];\n+\n+      // Patch the constant pool size, which we left at 0 earlier.\n+      int count = poolEntries.size() + 1;\n+      bytecode[8] = (byte) (count >> 8);\n+      bytecode[9] = (byte) count;\n+\n+      try\n+        {\n+          // XXX Do we require more native support here?\n+\n+          // XXX Security hole - it is possible for another thread to grab the\n+          // VMClassLoader.defineClass Method object, and abuse it while we\n+          // have temporarily made it accessible. Do we need to add some\n+          // synchronization lock to prevent user reflection while we use it?\n+\n+          // XXX This is waiting on VM support for protection domains.\n+\n+          Class vmClassLoader = Class.forName(\"java.lang.VMClassLoader\");\n+          Class[] types = {ClassLoader.class, String.class,\n+                           byte[].class, int.class, int.class,\n+                           /* ProtectionDomain.class */ };\n+          Method m = vmClassLoader.getDeclaredMethod(\"defineClass\", types);\n+\n+          // Bypass the security check of setAccessible(true), since this\n+          // is trusted code. But note the comment above about the security\n+          // risk of doing this outside a synchronized block.\n+          m.flag = true;\n+          Object[] args = {loader, qualName, bytecode, new Integer(0),\n+                           new Integer(bytecode.length),\n+                           /* Object.class.getProtectionDomain() */ };\n+          Class clazz = (Class) m.invoke(null, args);\n+          m.flag = false;\n+\n+          // Finally, initialize the m field of the proxy class, before\n+          // returning it.\n+\n+          // No security risk here, since clazz has not been exposed yet,\n+          // so user code cannot grab the same reflection object.\n+          Field f = clazz.getDeclaredField(\"m\");\n+          f.flag = true;\n+          // we can share the array, because it is not publicized\n+          f.set(null, methods);\n+          f.flag = false;\n+\n+          return clazz;\n+        }\n+      catch (Throwable e)\n+        {\n+          // assert false;\n+          throw (Error) new InternalError(\"Unexpected: \" + e).initCause(e);\n+        }\n+    }\n+\n+    /**\n+     * Put a single byte on the stream.\n+     *\n+     * @param i the information to add (only lowest 8 bits are used)\n+     */\n+    private void putU1(int i)\n+    {\n+      stream.append((char) i);\n+    }\n+\n+    /**\n+     * Put two bytes on the stream.\n+     *\n+     * @param i the information to add (only lowest 16 bits are used)\n+     */\n+    private void putU2(int i)\n+    {\n+      stream.append((char) (i >> 8)).append((char) i);\n+    }\n+\n+    /**\n+     * Put four bytes on the stream.\n+     *\n+     * @param i the information to add (treated as unsigned)\n+     */\n+    private void putU4(int i)\n+    {\n+      stream.append((char) (i >> 24)).append((char) (i >> 16));\n+      stream.append((char) (i >> 8)).append((char) i);\n+    }\n+\n+    /**\n+     * Put bytecode to load a constant integer on the stream. This only\n+     * needs to work for values less than Short.MAX_VALUE.\n+     *\n+     * @param i the int to add\n+     */\n+    private void putConst(int i)\n+    {\n+      if (i >= -1 && i <= 5)\n+        putU1(ICONST_0 + i);\n+      else if (i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE)\n+        {\n+          putU1(BIPUSH);\n+          putU1(i);\n+        }\n+      else\n+        {\n+          putU1(SIPUSH);\n+          putU2(i);\n+        }\n+    }\n+\n+    /**\n+     * Put bytecode to load a given local variable on the stream.\n+     *\n+     * @param i the slot to load\n+     * @param type the base type of the load\n+     */\n+    private void putLoad(int i, Class type)\n+    {\n+      int offset = 0;\n+      if (type == long.class)\n+        offset = 1;\n+      else if (type == float.class)\n+        offset = 2;\n+      else if (type == double.class)\n+        offset = 3;\n+      else if (! type.isPrimitive())\n+        offset = 4;\n+      if (i < 4)\n+        putU1(ILOAD_0 + 4 * offset + i);\n+      else\n+        {\n+          putU1(ILOAD + offset);\n+          putU1(i);\n+        }\n+    }\n+\n+    /**\n+     * Given a primitive type, return its wrapper class name.\n+     *\n+     * @param clazz the primitive type (but not void.class)\n+     * @return the internal form of the wrapper class name\n+     */\n+    private String wrapper(Class clazz)\n+    {\n+      if (clazz == boolean.class)\n+        return \"java/lang/Boolean\";\n+      if (clazz == byte.class)\n+        return \"java/lang/Byte\";\n+      if (clazz == short.class)\n+        return \"java/lang/Short\";\n+      if (clazz == char.class)\n+        return \"java/lang/Character\";\n+      if (clazz == int.class)\n+        return \"java/lang/Integer\";\n+      if (clazz == long.class)\n+        return \"java/lang/Long\";\n+      if (clazz == float.class)\n+        return \"java/lang/Float\";\n+      if (clazz == double.class)\n+        return \"java/lang/Double\";\n+      // assert false;\n+      return null;\n+    }\n+\n+    /**\n+     * Returns the entry of this String in the Constant pool, adding it\n+     * if necessary.\n+     *\n+     * @param str the String to resolve\n+     * @return the index of the String in the constant pool\n+     */\n+    private char utf8Info(String str)\n+    {\n+      String utf8 = toUtf8(str);\n+      int len = utf8.length();\n+      return poolIndex(\"\\1\" + (char) (len >> 8) + (char) (len & 0xff) + utf8);\n+    }\n+\n+    /**\n+     * Returns the entry of the appropriate class info structure in the\n+     * Constant pool, adding it if necessary.\n+     *\n+     * @param name the class name, in internal form\n+     * @return the index of the ClassInfo in the constant pool\n+     */\n+    private char classInfo(String name)\n+    {\n+      char index = utf8Info(name);\n+      char[] c = {7, (char) (index >> 8), (char) (index & 0xff)};\n+      return poolIndex(new String(c));\n+    }\n+\n+    /**\n+     * Returns the entry of the appropriate class info structure in the\n+     * Constant pool, adding it if necessary.\n+     *\n+     * @param clazz the class type\n+     * @return the index of the ClassInfo in the constant pool\n+     */\n+    private char classInfo(Class clazz)\n+    {\n+      return classInfo(TypeSignature.getEncodingOfClass(clazz.getName(),\n+                                                        false));\n+    }\n+\n+    /**\n+     * Returns the entry of the appropriate fieldref, methodref, or\n+     * interfacemethodref info structure in the Constant pool, adding it\n+     * if necessary.\n+     *\n+     * @param structure FIELD, METHOD, or INTERFACE\n+     * @param clazz the class name, in internal form\n+     * @param name the simple reference name\n+     * @param type the type of the reference\n+     * @return the index of the appropriate Info structure in the constant pool\n+     */\n+    private char refInfo(byte structure, String clazz, String name,\n+                         String type)\n+    {\n+      char cindex = classInfo(clazz);\n+      char ntindex = nameAndTypeInfo(name, type);\n+      // relies on FIELD == 1, METHOD == 2, INTERFACE == 3\n+      char[] c = {(char) (structure + 8),\n+                  (char) (cindex >> 8), (char) (cindex & 0xff),\n+                  (char) (ntindex >> 8), (char) (ntindex & 0xff)};\n+      return poolIndex(new String(c));\n+    }\n+\n+    /**\n+     * Returns the entry of the appropriate nameAndTyperef info structure\n+     * in the Constant pool, adding it if necessary.\n+     *\n+     * @param name the simple name\n+     * @param type the reference type\n+     * @return the index of the NameAndTypeInfo structure in the constant pool\n+     */\n+    private char nameAndTypeInfo(String name, String type)\n+    {\n+      char nindex = utf8Info(name);\n+      char tindex = utf8Info(type);\n+      char[] c = {12, (char) (nindex >> 8), (char) (nindex & 0xff),\n+                  (char) (tindex >> 8), (char) (tindex & 0xff)};\n+      return poolIndex(new String(c));\n+    }\n+\n+    /**\n+     * Converts a regular string to a UTF8 string, where the upper byte\n+     * of every char is 0, and '\\\\u0000' is not in the string.  This is\n+     * basically to use a String as a fancy byte[], and while it is less\n+     * efficient in memory use, it is easier for hashing.\n+     *\n+     * @param str the original, in straight unicode\n+     * @return a modified string, in UTF8 format in the low bytes\n+     */\n+    private String toUtf8(String str)\n+    {\n+      final char[] ca = str.toCharArray();\n+      final int len = ca.length;\n+\n+      // Avoid object creation, if str is already fits UTF8.\n+      int i;\n+      for (i = 0; i < len; i++)\n+        if (ca[i] == 0 || ca[i] > '\\u007f')\n+          break;\n+      if (i == len)\n+        return str;\n+\n+      final StringBuffer sb = new StringBuffer(str);\n+      sb.setLength(i);\n+      for ( ; i < len; i++)\n+        {\n+          final char c = ca[i];\n+          if (c > 0 && c <= '\\u007f')\n+            sb.append(c);\n+          else if (c <= '\\u07ff') // includes '\\0'\n+            {\n+              sb.append((char) (0xc0 | (c >> 6)));\n+              sb.append((char) (0x80 | (c & 0x6f)));\n+            }\n+          else\n+            {\n+              sb.append((char) (0xe0 | (c >> 12)));\n+              sb.append((char) (0x80 | ((c >> 6) & 0x6f)));\n+              sb.append((char) (0x80 | (c & 0x6f)));\n+            }\n+        }\n+      return sb.toString();\n+    }\n+\n+    /**\n+     * Returns the location of a byte sequence (conveniently wrapped in\n+     * a String with all characters between \\u0001 and \\u00ff inclusive)\n+     * in the constant pool, adding it if necessary.\n+     *\n+     * @param sequence the byte sequence to look for\n+     * @return the index of the sequence\n+     * @throws IllegalArgumentException if this would make the constant\n+     *         pool overflow\n+     */\n+    private char poolIndex(String sequence)\n+    {\n+      Integer i = (Integer) poolEntries.get(sequence);\n+      if (i == null)\n+        {\n+          // pool starts at index 1\n+          int size = poolEntries.size() + 1;\n+          if (size >= 65535)\n+            throw new IllegalArgumentException(\"exceeds VM limitations\");\n+          i = new Integer(size);\n+          poolEntries.put(sequence, i);\n+          pool.append(sequence);\n+        }\n+      return (char) i.intValue();\n+    }\n+  } // class ClassFactory\n+}"}, {"sha": "d9596922bebecdd89e6800118b4f2fac1e045763", "filename": "libjava/java/lang/reflect/UndeclaredThrowableException.java", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2Freflect%2FUndeclaredThrowableException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2Freflect%2FUndeclaredThrowableException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FUndeclaredThrowableException.java?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -0,0 +1,128 @@\n+/* UndeclaredThrowableException.java -- wraps an undeclared checked exception\n+   thrown by a Proxy invocation handler\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.lang.reflect;\n+\n+/**\n+ * This exception class is thrown by a {@link Proxy} instance if\n+ * the {@link InvocationHandler#invoke(Object, Method, Object[]) invoke}\n+ * method of that instance's InvocationHandler attempts to throw an\n+ * exception that not declared by the throws clauses of all of the\n+ * interface methods that the proxy instance is implementing.\n+ *\n+ * <p>When thrown by Proxy, this class will always wrap a checked\n+ * exception, never {@link Error} or {@link RuntimeException},\n+ * which are unchecked.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Proxy\n+ * @see InvocationHandler\n+ * @since 1.3\n+ * @status updated to 1.4\n+ */\n+public class UndeclaredThrowableException extends RuntimeException\n+{\n+  /**\n+   * Compatible with JDK 1.3+.\n+   */\n+  private static final long serialVersionUID = 330127114055056639L;\n+\n+  /**\n+   * The immutable exception that this wraps. This field is redundant\n+   * with {@link Throwable#cause}, but is necessary for serial compatibility.\n+   *\n+   * @serial the chained exception\n+   */\n+  private final Throwable undeclaredThrowable;\n+\n+  /**\n+   * Wraps the given checked exception into a RuntimeException, with no\n+   * detail message.  {@link Throwable#initCause(Throwable)} will fail\n+   * on this instance.\n+   *\n+   * @param cause the undeclared throwable that caused this exception,\n+   *        may be null\n+   */\n+  public UndeclaredThrowableException(Throwable cause)\n+  {\n+    this(cause, null);\n+  }\n+\n+  /**\n+   * Wraps the given checked exception into a RuntimeException, with the\n+   * specified detail message.  {@link Throwable#initCause(Throwable)} will\n+   * fail on this instance.\n+   *\n+   * @param cause the undeclared throwable that caused this exception,\n+   *        may be null\n+   * @param message the message, may be null\n+   */\n+  public UndeclaredThrowableException(Throwable cause, String message)\n+  {\n+    super(message, cause);\n+    undeclaredThrowable = cause;\n+  }\n+\n+  /**\n+   * Returns the cause of this exception.  If this exception was created\n+   * by a {@link Proxy} instance, it will be a non-null checked\n+   * exception.  This method pre-dates exception chaining, and is now\n+   * simply a longer way to call <code>getCause()</code>.\n+   *\n+   * @return the cause of this exception, may be null\n+   * @see #getCause()\n+   */\n+  public Throwable getUndeclaredThrowable()\n+  {\n+    return undeclaredThrowable;\n+  }\n+\n+  /**\n+   * Returns the cause of this exception.  If this exception was created\n+   * by a {@link Proxy} instance, it will be a non-null checked\n+   * exception.\n+   *\n+   * @return the cause of this exception, may be null\n+   * @since 1.4\n+   */\n+  public Throwable getCause()\n+  {\n+    return undeclaredThrowable;\n+  }\n+}"}, {"sha": "1a24858fa78411a3fa2ecc04e0ba4d6f3e0af6b4", "filename": "libjava/java/lang/reflect/natProxy.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2Freflect%2FnatProxy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Fjava%2Flang%2Freflect%2FnatProxy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatProxy.cc?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -0,0 +1,38 @@\n+// natProxy.cc - Native code for Proxy class.\n+\n+/* Copyright (C) 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/ClassLoader.h>\n+#include <java/lang/reflect/Proxy.h>\n+#include <java/lang/reflect/Proxy$ProxyData.h>\n+\n+::java::lang::Class *\n+java::lang::reflect::Proxy::getProxyClass0 (::java::lang::ClassLoader *, JArray< ::java::lang::Class *> *)\n+{\n+  return 0;\n+}\n+\n+::java::lang::reflect::Proxy$ProxyData *\n+java::lang::reflect::Proxy::getProxyData0 (::java::lang::ClassLoader *, JArray< ::java::lang::Class *> *)\n+{\n+  return 0;\n+}\n+\n+::java::lang::Class *\n+java::lang::reflect::Proxy::generateProxyClass0 (::java::lang::ClassLoader *, \n+\t\t\t\t\t\t ::java::lang::reflect::Proxy$ProxyData *)\n+{\n+  return 0;\n+}"}, {"sha": "adb0e1e246b3afe2ba69df98868e317547d8ba4d", "filename": "libjava/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FChangeLog?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -1,3 +1,13 @@\n+2002-09-29  Anthony Green  <green@redhat.com>\n+\n+\t* libjava.lang/TestProxy.java: New file.\n+\t* libjava.lang/TestProxy.out: Ditto.\n+\n+2002-09-29  Anthony Green  <green@redhat.com>\n+\n+\t* libjava.lang/utf8concat.java: New file.\n+\t* libjava.lang/utf8concat.out: Ditto.\n+\n 2002-08-26  Tom Tromey  <tromey@redhat.com>\n \n \t* libjava.compile/narrow_case.java: New file."}, {"sha": "46247a6c279fcb2be09a4ea734de606c1e5af881", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "d1411a6f0a8921428b3d8adf719d27324fa99fe3", "filename": "libjava/testsuite/libjava.lang/TestProxy.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2Flibjava.lang%2FTestProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2Flibjava.lang%2FTestProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FTestProxy.java?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -0,0 +1,34 @@\n+import java.lang.reflect.*;\n+import java.net.*;\n+\n+public class TestProxy\n+{\n+  public class MyInvocationHandler implements InvocationHandler\n+  {\n+    public Object invoke (Object proxy,\n+\t\t\t  Method method,\n+\t\t\t  Object[] args)\n+      throws Throwable\n+    {\n+      System.out.println (args[0]);\n+      return null;\n+    }\n+  }\n+\n+  public static void main (String[] args)\n+  {\n+    try {\n+      InvocationHandler ih = new MyInvocationHandler();\n+      \n+      SocketOptions c = (SocketOptions)\n+\tProxy.newProxyInstance (SocketOptions.class.getClassLoader(),\n+\t\t\t\tnew Class[]{SocketOptions.class},\n+\t\t\t\tih);\n+      \n+      c.getOption (555);\n+\n+    } catch (Exception e) {\n+      e.printStackTrace ();\n+    }\n+  }\n+}"}, {"sha": "3749383ded246790596d2f39db4dd8b71f525bbc", "filename": "libjava/testsuite/libjava.lang/TestProxy.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2Flibjava.lang%2FTestProxy.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2Flibjava.lang%2FTestProxy.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FTestProxy.out?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -0,0 +1 @@\n+555"}, {"sha": "8b8f47ee1a0c44edaf475bd4d6cd0c6cd732d822", "filename": "libjava/testsuite/libjava.lang/utf8concat.java", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2Flibjava.lang%2Futf8concat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2Flibjava.lang%2Futf8concat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Futf8concat.java?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5", "patch": "@@ -0,0 +1,11 @@\n+public class utf8concat\n+{\n+  private static String s;\n+\n+  public static void main (String[] args)\n+  {\n+    // This causes a crash at runtime because the compiler is\n+    // producing an invalid UTF-8 string literal.\n+    s = \"abc\" + (char)183;\n+  }\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libjava/testsuite/libjava.lang/utf8concat.out", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2Flibjava.lang%2Futf8concat.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5/libjava%2Ftestsuite%2Flibjava.lang%2Futf8concat.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Futf8concat.out?ref=d3cc3f10dac7b93c7b62d7e30b15f171fec3e8a5"}]}