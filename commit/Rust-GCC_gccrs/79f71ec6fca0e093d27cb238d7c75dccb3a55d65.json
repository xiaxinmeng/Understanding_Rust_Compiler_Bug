{"sha": "79f71ec6fca0e093d27cb238d7c75dccb3a55d65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlmNzFlYzZmY2EwZTA5M2QyN2NiMjM4ZDdjNzVkY2NiM2E1NWQ2NQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-07-15T10:38:36Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-07-15T12:23:55Z"}, "message": "Abstract out non_null adjustments in ranger.\n\nThere are 4 exact copies of the non-null range adjusting code in the\nranger.  This patch abstracts the functionality into a separate method.\n\nAs a follow-up I would like to remove the varying_p check, since I have\nseen incoming ranges such as [0, 0xff....ef] which are not varying, but\nare not-null.  Removing the varying restriction catches those.\n\ngcc/ChangeLog:\n\n\t* gimple-range-cache.cc (non_null_ref::adjust_range): New.\n\t(ranger_cache::range_of_def): Call adjust_range.\n\t(ranger_cache::entry_range): Same.\n\t* gimple-range-cache.h (non_null_ref::adjust_range): New.\n\t* gimple-range.cc (gimple_ranger::range_of_expr): Call\n\tadjust_range.\n\t(gimple_ranger::range_on_entry): Same.", "tree": {"sha": "0569b94e87376cc51232c650d3a2a2f9923bf426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0569b94e87376cc51232c650d3a2a2f9923bf426"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79f71ec6fca0e093d27cb238d7c75dccb3a55d65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f71ec6fca0e093d27cb238d7c75dccb3a55d65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f71ec6fca0e093d27cb238d7c75dccb3a55d65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f71ec6fca0e093d27cb238d7c75dccb3a55d65/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e321f2a6383e378f64e556707de1cdae0a8562d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e321f2a6383e378f64e556707de1cdae0a8562d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e321f2a6383e378f64e556707de1cdae0a8562d"}], "stats": {"total": 45, "additions": 30, "deletions": 15}, "files": [{"sha": "23597ade80205f0a7085d10383ce356408152fae", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f71ec6fca0e093d27cb238d7c75dccb3a55d65/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f71ec6fca0e093d27cb238d7c75dccb3a55d65/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=79f71ec6fca0e093d27cb238d7c75dccb3a55d65", "patch": "@@ -81,6 +81,29 @@ non_null_ref::non_null_deref_p (tree name, basic_block bb, bool search_dom)\n   return false;\n }\n \n+// If NAME has a non-null dereference in block BB, adjust R with the\n+// non-zero information from non_null_deref_p, and return TRUE.  If\n+// SEARCH_DOM is true, non_null_deref_p should search the dominator tree.\n+\n+bool\n+non_null_ref::adjust_range (irange &r, tree name, basic_block bb,\n+\t\t\t    bool search_dom)\n+{\n+  // Check if pointers have any non-null dereferences.  Non-call\n+  // exceptions mean we could throw in the middle of the block, so just\n+  // punt for now on those.\n+  if (!cfun->can_throw_non_call_exceptions\n+      && r.varying_p ()\n+      && non_null_deref_p (name, bb, search_dom))\n+    {\n+      int_range<2> nz;\n+      nz.set_nonzero (TREE_TYPE (name));\n+      r.intersect (nz);\n+      return true;\n+    }\n+  return false;\n+}\n+\n // Allocate an populate the bitmap for NAME.  An ON bit for a block\n // index indicates there is a non-null reference in that block.  In\n // order to populate the bitmap, a quick run of all the immediate uses\n@@ -857,9 +880,8 @@ ranger_cache::range_of_def (irange &r, tree name, basic_block bb)\n \tr = gimple_range_global (name);\n     }\n \n-  if (bb && r.varying_p () && m_non_null.non_null_deref_p (name, bb, false) &&\n-      !cfun->can_throw_non_call_exceptions)\n-    r = range_nonzero (TREE_TYPE (name));\n+  if (bb)\n+    m_non_null.adjust_range (r, name, bb, false);\n }\n \n // Get the range of NAME as it occurs on entry to block BB.\n@@ -878,12 +900,7 @@ ranger_cache::entry_range (irange &r, tree name, basic_block bb)\n   if (!m_on_entry.get_bb_range (r, name, bb))\n     range_of_def (r, name);\n \n-  // Check if pointers have any non-null dereferences.  Non-call\n-  // exceptions mean we could throw in the middle of the block, so just\n-  // punt for now on those.\n-  if (r.varying_p () && m_non_null.non_null_deref_p (name, bb, false) &&\n-      !cfun->can_throw_non_call_exceptions)\n-    r = range_nonzero (TREE_TYPE (name));\n+  m_non_null.adjust_range (r, name, bb, false);\n }\n \n // Get the range of NAME as it occurs on exit from block BB."}, {"sha": "f842e9c092aa4b8cc9e517228c5877639cd4f0c2", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f71ec6fca0e093d27cb238d7c75dccb3a55d65/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f71ec6fca0e093d27cb238d7c75dccb3a55d65/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=79f71ec6fca0e093d27cb238d7c75dccb3a55d65", "patch": "@@ -34,6 +34,8 @@ class non_null_ref\n   non_null_ref ();\n   ~non_null_ref ();\n   bool non_null_deref_p (tree name, basic_block bb, bool search_dom = true);\n+  bool adjust_range (irange &r, tree name, basic_block bb,\n+\t\t     bool search_dom = true);\n private:\n   vec <bitmap> m_nn;\n   void process_name (tree name);"}, {"sha": "b210787d0b7bcde0f87d83b3efd5308e7c07d0f4", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f71ec6fca0e093d27cb238d7c75dccb3a55d65/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f71ec6fca0e093d27cb238d7c75dccb3a55d65/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=79f71ec6fca0e093d27cb238d7c75dccb3a55d65", "patch": "@@ -69,9 +69,7 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n   if (def_stmt && gimple_bb (def_stmt) == bb)\n     {\n       range_of_stmt (r, def_stmt, expr);\n-      if (!cfun->can_throw_non_call_exceptions && r.varying_p () &&\n-\t  m_cache.m_non_null.non_null_deref_p (expr, bb))\n-\tr = range_nonzero (TREE_TYPE (expr));\n+      m_cache.m_non_null.adjust_range (r, expr, bb, true);\n     }\n   else\n     // Otherwise OP comes from outside this block, use range on entry.\n@@ -95,9 +93,7 @@ gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n   if (m_cache.block_range (entry_range, bb, name))\n     r.intersect (entry_range);\n \n-  if (!cfun->can_throw_non_call_exceptions && r.varying_p () &&\n-      m_cache.m_non_null.non_null_deref_p (name, bb))\n-    r = range_nonzero (TREE_TYPE (name));\n+  m_cache.m_non_null.adjust_range (r, name, bb, true);\n }\n \n // Calculate the range for NAME at the end of block BB and return it in R."}]}