{"sha": "77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdlOGEwY2M5ZDg3YzdiYmRlYmRkNWViOTJjMGEzNTZkNmVkNTllYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-04T17:11:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-04T17:11:32Z"}, "message": "c-common.c (builtin_define_with_hex_fp_value): New.\n\n        * c-common.c (builtin_define_with_hex_fp_value): New.\n        (builtin_define_float_constants): Use it.  Fix H_FLOAT mant_dig.\n\nFrom-SVN: r56800", "tree": {"sha": "19405e2842799424bf1f946d1925e30c0746bab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19405e2842799424bf1f946d1925e30c0746bab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea/comments", "author": null, "committer": null, "parents": [{"sha": "a9c60612ab729d36a4499da90ac10087ccc818ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c60612ab729d36a4499da90ac10087ccc818ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c60612ab729d36a4499da90ac10087ccc818ba"}], "stats": {"total": 98, "additions": 69, "deletions": 29}, "files": [{"sha": "511d469b0964a244d9462a014ef4d2e4e8416551", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea", "patch": "@@ -1,3 +1,8 @@\n+2002-09-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-common.c (builtin_define_with_hex_fp_value): New.\n+\t(builtin_define_float_constants): Use it.  Fix H_FLOAT mant_dig.\n+\n 2002-09-04  Janis Johnson  <janis187@us.ibm.com>\n \n \t* doc/invoke.texi (-fshort-wchar): Move to Code Generation Options."}, {"sha": "1a03d7c8b1cdfc9d1302c340ef105d4abadec7bb", "filename": "gcc/c-common.c", "status": "modified", "additions": 64, "deletions": 29, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=77e8a0cc9d87c7bbdebdd5eb92c0a356d6ed59ea", "patch": "@@ -764,6 +764,9 @@ static void builtin_define_with_value PARAMS ((const char *, const char *,\n                                                int));\n static void builtin_define_with_int_value PARAMS ((const char *,\n \t\t\t\t\t\t   HOST_WIDE_INT));\n+static void builtin_define_with_hex_fp_value PARAMS ((const char *, tree,\n+\t\t\t\t\t\t      int, const char *,\n+\t\t\t\t\t\t      const char *));\n static void builtin_define_type_max PARAMS ((const char *, tree, int));\n static void cpp_define_data_format PARAMS ((cpp_reader *));\n static void builtin_define_type_precision PARAMS ((const char *, tree));\n@@ -4806,6 +4809,7 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n   char name[64], buf[128];\n   int mant_dig, max_exp, min_exp;\n   int dig, min_10_exp, max_10_exp;\n+  int decimal_dig;\n \n   /* ??? This information should be shared with real.c.  */\n \n@@ -4879,7 +4883,7 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n \t    }\n \t  break;\n \tcase 128: /* H_FLOAT */\n-\t  mant_dig = 114;\n+\t  mant_dig = 113;\n \t  min_exp = -16383;\n \t  max_exp = 16383;\n \t  break;\n@@ -4994,54 +4998,56 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n   sprintf (name, \"__%s_MAX_10_EXP__\", name_prefix);\n   builtin_define_with_int_value (name, max_10_exp);\n \n+  /* The number of decimal digits, n, such that any floating-point number\n+     can be rounded to n decimal digits and back again without change to\n+     the value. \n+\n+\tp * log10(b)\t\t\tif b is a power of 10\n+\tceil(1 + p * log10(b))\t\totherwise\n+\n+     The only macro we care about is this number for the widest supported\n+     floating type, but we want this value for rendering constants below.  */\n+  {\n+    double d_decimal_dig = 1 + mant_dig * log10_b;\n+    decimal_dig = d_decimal_dig;\n+    if (decimal_dig < d_decimal_dig)\n+      decimal_dig++;\n+  }\n+  if (type == long_double_type_node)\n+    builtin_define_with_int_value (\"__DECIMAL_DIG__\", decimal_dig);\n+\n   /* Since, for the supported formats, B is always a power of 2, we\n-     construct the following numbers directly as a hexadecimal constants.  */\n+     construct the following numbers directly as a hexadecimal\n+     constants.  */\n \n   /* The maximum representable finite floating-point number,\n-\t(1 - b**-p) * b**max_exp  */\n+     (1 - b**-p) * b**max_exp  */\n   {\n     int i, n;\n     char *p;\n-    sprintf (name, \"__%s_MAX__\", name_prefix);\n \n     strcpy (buf, \"0x0.\");\n-\n     n = mant_dig * log2_b;\n     for (i = 0, p = buf + 4; i + 3 < n; i += 4)\n       *p++ = 'f';\n     if (i < n)\n       *p++ = \"08ce\"[n - i];\n-    sprintf (p, \"p%d%s\", max_exp * log2_b, fp_suffix);\n-    builtin_define_with_value (name, buf, 0);\n+    sprintf (p, \"p%d\", max_exp * log2_b);\n   }\n+  sprintf (name, \"__%s_MAX__\", name_prefix);\n+  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n \n-  /* The minimum normalized positive floating-point number, b**(min_exp-1).  */\n+  /* The minimum normalized positive floating-point number,\n+     b**(min_exp-1).  */\n   sprintf (name, \"__%s_MIN__\", name_prefix);\n-  sprintf (buf, \"0x1p%d%s\", (min_exp - 1) * log2_b, fp_suffix);\n-  builtin_define_with_value (name, buf, 0);\n+  sprintf (buf, \"0x1p%d\", (min_exp - 1) * log2_b);\n+  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n \n   /* The difference between 1 and the least value greater than 1 that is\n      representable in the given floating point type, b**(1-p).  */\n   sprintf (name, \"__%s_EPSILON__\", name_prefix);\n-  sprintf (buf, \"0x1p%d%s\", (1 - mant_dig) * log2_b, fp_suffix);\n-  builtin_define_with_value (name, buf, 0);\n-\n-  if (type == long_double_type_node)\n-    {\n-      /* The number of decimal digits, n, such that any floating-point number\n-\t in the widest supported floating type with pmax radix b digits can be\n-\t rounded to a floating-point number with n decimal digits and back\n-\t again without change to the value,\n-\n-\t        pmax log10(b)                   if b is a power of 10\n-\t        ceil(1 + pmax * log10(b))       otherwise\n-      */\n-      double d_decimal_dig = 1 + mant_dig * log10_b;\n-      int decimal_dig = d_decimal_dig;\n-      if (decimal_dig < d_decimal_dig)\n-\tdecimal_dig++;\n-      builtin_define_with_int_value (\"__DECIMAL_DIG__\", decimal_dig);\n-    }\n+  sprintf (buf, \"0x1p%d\", (1 - mant_dig) * log2_b);\n+  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n }\n \n /* Hook that registers front end and target-specific built-ins.  */\n@@ -5256,6 +5262,35 @@ builtin_define_with_int_value (macro, value)\n   cpp_define (parse_in, buf);\n }\n \n+/* Pass an object-like macro a hexadecimal floating-point value.  */\n+static void\n+builtin_define_with_hex_fp_value (macro, type, digits, hex_str, fp_suffix)\n+     const char *macro;\n+     tree type;\n+     int digits;\n+     const char *hex_str;\n+     const char *fp_suffix;\n+{\n+  REAL_VALUE_TYPE real;\n+  char dec_str[64], buf[256];\n+\n+  /* Hex values are really cool and convenient, except that they're\n+     not supported in strict ISO C90 mode.  First, the \"p-\" sequence\n+     is not valid as part of a preprocessor number.  Second, we get a\n+     pedwarn from the preprocessor, which has no context, so we can't\n+     suppress the warning with __extension__.\n+\n+     So instead what we do is construct the number in hex (because \n+     it's easy to get the exact correct value), parse it as a real,\n+     then print it back out as decimal.  */\n+\n+  real = REAL_VALUE_HTOF (hex_str, TYPE_MODE (type));\n+  REAL_VALUE_TO_DECIMAL (real, dec_str, digits);\n+\n+  sprintf (buf, \"%s=%s%s\", macro, dec_str, fp_suffix);\n+  cpp_define (parse_in, buf);\n+}\n+\n /* Define MAX for TYPE based on the precision of the type, which is assumed\n    to be signed.  IS_LONG is 1 for type \"long\" and 2 for \"long long\".  */\n "}]}