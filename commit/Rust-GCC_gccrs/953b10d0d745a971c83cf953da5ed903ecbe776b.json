{"sha": "953b10d0d745a971c83cf953da5ed903ecbe776b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUzYjEwZDBkNzQ1YTk3MWM4M2NmOTUzZGE1ZWQ5MDNlY2JlNzc2Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-16T22:08:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-16T22:08:32Z"}, "message": "h8300.md (andhi3): If 2nd operand is a CONST_INT that meets the 'J' constraint...\n\n        * h8300/h8300.md (andhi3): If 2nd operand is a CONST_INT that\n        meets the 'J' constraint, then only two bytes are needed for\n        this insn.  Improve code generated for the h8300h when both\n        operands are registers.\n        (iorhi3, xorhi3): Likewise.  Rework to be nearly identical to andhi3.\n        (andsi3): If 2nd operand is a CONST_INT that meets the 'J'\n        constraint, then only two bytes are need for this insn.\n        Improve code generated for the h8300h regardless of the\n        type of the 2nd operand.  Make this pattern work on the h8300 too.\n        (iorsi3, xorsi3): Likewise.  Rework to be nearly identical to andsi3.\n        (iorqi3_internal): Make this pattern look more like andqi3_internal.\n        (one_cmplhi2, one_cmplsi2): Fix length computation for H8300H.\n\nFrom-SVN: r11830", "tree": {"sha": "adae723a0f162ff9f11788659b1ea8a6ed759354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adae723a0f162ff9f11788659b1ea8a6ed759354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/953b10d0d745a971c83cf953da5ed903ecbe776b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953b10d0d745a971c83cf953da5ed903ecbe776b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/953b10d0d745a971c83cf953da5ed903ecbe776b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953b10d0d745a971c83cf953da5ed903ecbe776b/comments", "author": null, "committer": null, "parents": [{"sha": "70cff8f545f04281a8cf0e8d6ee604ee8026fe32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70cff8f545f04281a8cf0e8d6ee604ee8026fe32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70cff8f545f04281a8cf0e8d6ee604ee8026fe32"}], "stats": {"total": 249, "additions": 155, "deletions": 94}, "files": [{"sha": "4c8f512d2d9f49657337cc4d55847193b0e3ca4e", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 155, "deletions": 94, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953b10d0d745a971c83cf953da5ed903ecbe776b/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953b10d0d745a971c83cf953da5ed903ecbe776b/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=953b10d0d745a971c83cf953da5ed903ecbe776b", "patch": "@@ -48,6 +48,11 @@\n ;; would be more efficient time and space-wise.  Similar sequences\n ;; can be found using bit-set insns dec, etc\n \n+;; Many logical operations should have \"bit\" variants if only one\n+;; bit is going to be operated on.\n+\n+;; Should be HI & SImode tstXX insns which test one bit using btst.\n+\n \n (define_attr \"type\" \"branch,bcs,return,call,arith,move,float,multi\"\n   (const_string \"arith\"))\n@@ -943,60 +948,86 @@\n     DONE;\n }\")\n \n-;; ??? Should have a bclr case here also.\n-;; ??? This should be symmetric with iorhi3.\n-\n (define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"rn\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"J,rn\")))]\n   \"\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int i = INTVAL (operands[2]);\n+\n       if ((i & 0x00ff) != 0x00ff) \n \toutput_asm_insn (\\\"and\t%s2,%s0\\\", operands);\n       if ((i & 0xff00) != 0xff00) \n \toutput_asm_insn (\\\"and\t%t2,%t0\\\", operands);\n       return \\\"\\\";\n     }\n+  if (TARGET_H8300H)\n+    return \\\"and.w %T2,%T0\\\";\n   return \\\"and\t%s2,%s0\\;and\t%t2,%t0;\\\";\n }\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-;; ??? There is an iorsi3 for TARGET_H8300.  Should we have andsi3?\n+  [(set_attr \"type\" \"arith,multi\")\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n \n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n-  \"TARGET_H8300H\"\n-  \"@\n-   and\t%S2,%S0\n-   and\t%S2,%S0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4,6\")\n-   (set_attr \"cc\" \"set\")])\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"J,rn\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+\n+      /* ??? If we used e0..e7, then we could sub.w eX,eX to\n+\t clear the high word if (i & 0xffff0000) == 0.  */\n+\n+      /* The h8300h can't do byte-wise operations on the\n+\t upper 16bits of 32bit registers.  However, if\n+\t those bits aren't going to change, then we can\n+\t work on the low-order bits.  */\n+      if (TARGET_H8300H\n+\t  && (i & 0xffff0000) != 0xffff0000)\n+        return \\\"and.l\t%S2,%S0\\\";\n+\n+      if ((i & 0x000000ff) != 0x000000ff) \n+\toutput_asm_insn (\\\"and\t%w2,%w0\\\", operands);\n+      if ((i & 0x0000ff00) != 0x0000ff00) \n+\toutput_asm_insn (\\\"and\t%x2,%x0\\\", operands);\n+      if ((i & 0x00ff0000) != 0x00ff0000) \n+\toutput_asm_insn (\\\"and\t%y2,%y0\\\", operands);\n+      if ((i & 0xff000000) != 0xff000000) \n+\toutput_asm_insn (\\\"and\t%z2,%z0\\\", operands);\n+      return \\\"\\\";\n+    }\n+  if (TARGET_H8300H)\n+    return \\\"and.l\t%S2,%S0\\\";\n+  return \\\"and\t%w2,%w0\\;and\t%x2,%x0\\;and\t%y2,%y0\\;and\t%z2,%z0\\;\\\";\n+}\"\n+  [(set_attr \"type\" \"arith,multi\")\n+   (set_attr \"length\" \"2,8\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n \n ;; ----------------------------------------------------------------------\n ;; OR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"iorqi3_internal\"\n-  [(set (match_operand:QI 0 \"bit_operand\" \"=U,r\")\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n \t(ior:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"P,rn\")))]\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,P\")))]\n   \"register_operand (operands[0], QImode) || p_operand (operands[2], QImode)\"\n   \"@\n-   bset\t%V2,%R0\n-   or\t%X2,%X0\"\n+   or\t%X2,%X0\n+   bset\t%V2,%R0\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4,2\")\n-   (set_attr \"cc\" \"none_0hit,set\")])\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"set,none_0hit\")])\n \n (define_expand \"iorqi3\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n@@ -1009,70 +1040,67 @@\n     DONE;\n }\")\n \n-;; ??? Should have a bset case here also.\n-;; ??? This should be symmetric with andhi3.\n-\n (define_insn \"iorhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r,r\")\n \t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"J,rn\")))]\n   \"\"\n   \"*\n {\n-  if (TARGET_H8300)\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  int i = INTVAL (operands[2]);\n-\t  if ((i & 0x00ff) != 0) \n-\t    output_asm_insn (\\\"or\t%s2,%s0\\\", operands);\n-\t  if ((i & 0xff00) != 0) \n-\t    output_asm_insn (\\\"or\t%t2,%t0\\\", operands);\n-\t  return \\\"\\\";\n-\t}\n-      return \\\"or\t%s2,%s0\\;or\t%t2,%t0; %2 or2\\\";\n-    }\n-  else\n+  if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      return \\\"or\t%S2,%S0\\\";\n+      int i = INTVAL (operands[2]);\n+\n+      if ((i & 0x00ff) != 0) \n+\toutput_asm_insn (\\\"or\t%s2,%s0\\\", operands);\n+      if ((i & 0xff00) != 0) \n+\toutput_asm_insn (\\\"or\t%t2,%t0\\\", operands);\n+      return \\\"\\\";\n     }\n+  if (TARGET_H8300H)\n+    return \\\"or.w\t%T2,%T0\\\";\n+  return \\\"or\t%s2,%s0\\;or\t%t2,%t0; %2 or2\\\";\n }\"\n-  [(set_attr \"type\" \"multi\")\n+  [(set_attr \"type\" \"arith,multi\")\n    (set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n \n (define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"ri\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"J,rn\")))]\n   \"\"\n   \"*\n {\n-  if (TARGET_H8300)\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  int i = INTVAL (operands[2]);\n-\t  if ((i & 0x000000ff) != 0) \n-\t    output_asm_insn (\\\"or\t%w2,%w0\\\", operands);\n-\t  if ((i & 0x0000ff00) != 0) \n-\t    output_asm_insn (\\\"or\t%x2,%x0\\\", operands);\n-\t  if ((i & 0x00ff0000) != 0) \n-\t    output_asm_insn (\\\"or\t%y2,%y0\\\", operands);\n-\t  if ((i & 0xff000000) != 0) \n-\t    output_asm_insn (\\\"or\t%z2,%z0\\\", operands);\n-\t  return \\\"\\\";\n-\t}\n-      return \\\"or\t%w2,%w0\\;or\t%x2,%x0\\;or\t%y2,%y0\\;or\t%z2,%z0\\;\\\";\n-    }\n-  else\n+  if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      return \\\"or\t%S2,%S0\\\";\n+      int i = INTVAL (operands[2]);\n+\n+      /* The h8300h can't do byte-wise operations on the\n+\t upper 16bits of 32bit registers.  However, if\n+\t those bits aren't going to change, then we can\n+\t work on the low-order bits.  */\n+      if (TARGET_H8300H\n+\t  && (i & 0xffff0000) != 0x00000000)\n+        return \\\"or.l\t%S2,%S0\\\";\n+\t\n+      if ((i & 0x000000ff) != 0) \n+\toutput_asm_insn (\\\"or\t%w2,%w0\\\", operands);\n+      if ((i & 0x0000ff00) != 0) \n+\toutput_asm_insn (\\\"or\t%x2,%x0\\\", operands);\n+      if ((i & 0x00ff0000) != 0) \n+\toutput_asm_insn (\\\"or\t%y2,%y0\\\", operands);\n+      if ((i & 0xff000000) != 0) \n+\toutput_asm_insn (\\\"or\t%z2,%z0\\\", operands);\n+      return \\\"\\\";\n     }\n+  if (TARGET_H8300H)\n+    return \\\"or.l\t%S2,%S0\\\";\n+  return \\\"or\t%w2,%w0\\;or\t%x2,%x0\\;or\t%y2,%y0\\;or\t%z2,%z0\\;\\\";\n }\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"arith,multi\")\n+   (set_attr \"length\" \"2,8\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n \n ;; ----------------------------------------------------------------------\n ;; XOR INSTRUCTIONS\n@@ -1101,37 +1129,67 @@\n     DONE;\n }\")\n \n-;; ??? This should be symmetric with andhi3.\n-\n (define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"rn\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"J,rn\")))]\n   \"\"\n   \"*\n {\n-  if (TARGET_H8300)\n-    return \\\"xor\t%s2,%s0\\;xor\t%t2,%t0\\\";\n-  else\n-    return \\\"xor\t%S2,%S0\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n \n-;; ??? There is an iorsi3 for TARGET_H8300.  Should we have xorsi3?\n+      if ((i & 0x00ff) != 0) \n+\toutput_asm_insn (\\\"xor\t%s2,%s0\\\", operands);\n+      if ((i & 0xff00) != 0) \n+\toutput_asm_insn (\\\"xor\t%t2,%t0\\\", operands);\n+      return \\\"\\\";\n+    }\n+  if (TARGET_H8300H)\n+    return \\\"xor.w\t%T2,%T0\\\";\n+  return \\\"xor\t%s2,%s0\\;xor\t%t2,%t0\\\";\n+}\"\n+  [(set_attr \"type\" \"arith,multi\")\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n \n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n-  \"TARGET_H8300H\"\n-  \"@\n-   xor\t%S2,%S0\n-   xor\t%S2,%S0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4,6\")\n-   (set_attr \"cc\" \"set\")])\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"J,rn\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+\n+      /* The h8300h can't do byte-wise operations on the\n+\t upper 16bits of 32bit registers.  However, if\n+\t those bits aren't going to change, then we can\n+\t work on the low-order bits.  */\n+      if (TARGET_H8300H\n+\t  && (i & 0xffff0000) != 0x00000000)\n+        return \\\"xor.l\t%S2,%S0\\\";\n+\n+      if ((i & 0x000000ff) != 0) \n+\toutput_asm_insn (\\\"xor\t%w2,%w0\\\", operands);\n+      if ((i & 0x0000ff00) != 0) \n+\toutput_asm_insn (\\\"xor\t%x2,%x0\\\", operands);\n+      if ((i & 0x00ff0000) != 0) \n+\toutput_asm_insn (\\\"xor\t%y2,%y0\\\", operands);\n+      if ((i & 0xff000000) != 0) \n+\toutput_asm_insn (\\\"xor\t%z2,%z0\\\", operands);\n+      return \\\"\\\";\n+    }\n+  if (TARGET_H8300H)\n+    return \\\"xor.l\t%S2,%S0\\\";\n+  return \\\"xor\t%w2,%w0\\;xor\t%x2,%x0\\;xor\t%y2,%y0\\;xor\t%z2,%z0\\;\\\";\n+}\"\n+  [(set_attr \"type\" \"arith,multi\")\n+   (set_attr \"length\" \"2,8\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; NEGATION INSTRUCTIONS\n@@ -1233,8 +1291,11 @@\n     return \\\"not\t%T0\\\";\n }\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 8)\n+\t\t      (const_int 2)))])\n \n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1252,7 +1313,7 @@\n    (set (attr \"length\")\n \t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n \t\t      (const_int 8)\n-\t\t      (const_int 4)))])\n+\t\t      (const_int 2)))])\n \t\t\t\n \f\n ;; ----------------------------------------------------------------------"}]}