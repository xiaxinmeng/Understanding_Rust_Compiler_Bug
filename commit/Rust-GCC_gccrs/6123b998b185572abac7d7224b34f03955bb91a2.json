{"sha": "6123b998b185572abac7d7224b34f03955bb91a2", "node_id": "C_kwDOANBUbNoAKDYxMjNiOTk4YjE4NTU3MmFiYWM3ZDcyMjRiMzRmMDM5NTViYjkxYTI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-28T18:10:15Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-28T18:10:15Z"}, "message": "match.pd: Optimize MIN_EXPR <addr1, addr2> etc. addr1 < addr2 would be simplified [PR102951]\n\nThis patch outlines the decision whether address comparison can be folded\nor not from the match.pd simple comparison simplification and uses it\nboth there and in a new minmax simplification, such that we fold e.g.\nMAX (&a[2], &a[1]) etc.\nSome of the Wstringop-overflow-62.c changes might look weird, but that\nseems to be mainly due to gimple_fold_builtin_memset not bothering to\ncopy over location, will fix that incrementally.\n\n2021-10-28  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/102951\n\t* fold-const.h (address_compare): Declare.\n\t* fold-const.c (address_compare): New function.\n\t* match.pd (cmp (convert1?@2 addr@0) (convert2? addr@1)): Use\n\taddress_compare helper.\n\t(minmax cmp (convert1?@2 addr@0) (convert2?@3 addr@1)): New\n\tsimplification.\n\n\t* gcc.dg/tree-ssa/pr102951.c: New test.\n\t* gcc.dg/Wstringop-overflow-62.c: Adjust expected diagnostics.", "tree": {"sha": "37da95c6b820de59031915d527b40bb48263829e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37da95c6b820de59031915d527b40bb48263829e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6123b998b185572abac7d7224b34f03955bb91a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6123b998b185572abac7d7224b34f03955bb91a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6123b998b185572abac7d7224b34f03955bb91a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6123b998b185572abac7d7224b34f03955bb91a2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d123daec0c237533cf974334d98bc6d357d4273e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d123daec0c237533cf974334d98bc6d357d4273e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d123daec0c237533cf974334d98bc6d357d4273e"}], "stats": {"total": 349, "additions": 220, "deletions": 129}, "files": [{"sha": "54f91f0149cee3665241d3c1061e6b3d70ed8e59", "filename": "gcc/fold-const.c", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6123b998b185572abac7d7224b34f03955bb91a2", "patch": "@@ -16492,6 +16492,132 @@ tree_nonzero_bits (const_tree t)\n   return wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (t)));\n }\n \n+/* Helper function for address compare simplifications in match.pd.\n+   OP0 and OP1 are ADDR_EXPR operands being compared by CODE.\n+   BASE0, BASE1, OFF0 and OFF1 are set by the function.\n+   GENERIC is true if GENERIC folding and false for GIMPLE folding.\n+   Returns 0 if OP0 is known to be unequal to OP1 regardless of OFF{0,1},\n+   1 if bases are known to be equal and OP0 cmp OP1 depends on OFF0 cmp OFF1,\n+   and 2 if unknown.  */\n+\n+int\n+address_compare (tree_code code, tree type, tree op0, tree op1,\n+\t\t tree &base0, tree &base1, poly_int64 &off0, poly_int64 &off1,\n+\t\t bool generic)\n+{\n+  gcc_checking_assert (TREE_CODE (op0) == ADDR_EXPR);\n+  gcc_checking_assert (TREE_CODE (op1) == ADDR_EXPR);\n+  base0 = get_addr_base_and_unit_offset (TREE_OPERAND (op0, 0), &off0);\n+  base1 = get_addr_base_and_unit_offset (TREE_OPERAND (op1, 0), &off1);\n+  if (base0 && TREE_CODE (base0) == MEM_REF)\n+    {\n+      off0 += mem_ref_offset (base0).force_shwi ();\n+      base0 = TREE_OPERAND (base0, 0);\n+    }\n+  if (base1 && TREE_CODE (base1) == MEM_REF)\n+    {\n+      off1 += mem_ref_offset (base1).force_shwi ();\n+      base1 = TREE_OPERAND (base1, 0);\n+    }\n+  if (base0 == NULL_TREE || base1 == NULL_TREE)\n+    return 2;\n+\n+  int equal = 2;\n+  /* Punt in GENERIC on variables with value expressions;\n+     the value expressions might point to fields/elements\n+     of other vars etc.  */\n+  if (generic\n+      && ((VAR_P (base0) && DECL_HAS_VALUE_EXPR_P (base0))\n+\t  || (VAR_P (base1) && DECL_HAS_VALUE_EXPR_P (base1))))\n+    return 2;\n+  else if (decl_in_symtab_p (base0) && decl_in_symtab_p (base1))\n+    {\n+      symtab_node *node0 = symtab_node::get_create (base0);\n+      symtab_node *node1 = symtab_node::get_create (base1);\n+      equal = node0->equal_address_to (node1);\n+    }\n+  else if ((DECL_P (base0)\n+\t    || TREE_CODE (base0) == SSA_NAME\n+\t    || TREE_CODE (base0) == STRING_CST)\n+\t   && (DECL_P (base1)\n+\t       || TREE_CODE (base1) == SSA_NAME\n+\t       || TREE_CODE (base1) == STRING_CST))\n+    equal = (base0 == base1);\n+  if (equal == 1)\n+    {\n+      if (code == EQ_EXPR\n+\t  || code == NE_EXPR\n+\t  /* If the offsets are equal we can ignore overflow.  */\n+\t  || known_eq (off0, off1)\n+\t  || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0))\n+\t  /* Or if we compare using pointers to decls or strings.  */\n+\t  || (POINTER_TYPE_P (type)\n+\t      && (DECL_P (base0) || TREE_CODE (base0) == STRING_CST)))\n+\treturn 1;\n+      return 2;\n+    }\n+  if (equal != 0)\n+    return equal;\n+  if (code != EQ_EXPR && code != NE_EXPR)\n+    return 2;\n+\n+  HOST_WIDE_INT ioff0 = -1, ioff1 = -1;\n+  off0.is_constant (&ioff0);\n+  off1.is_constant (&ioff1);\n+  if ((DECL_P (base0) && TREE_CODE (base1) == STRING_CST)\n+       || (TREE_CODE (base0) == STRING_CST && DECL_P (base1))\n+       || (TREE_CODE (base0) == STRING_CST\n+\t   && TREE_CODE (base1) == STRING_CST\n+\t   && ioff0 >= 0 && ioff1 >= 0\n+\t   && ioff0 < TREE_STRING_LENGTH (base0)\n+\t   && ioff1 < TREE_STRING_LENGTH (base1)\n+\t  /* This is a too conservative test that the STRING_CSTs\n+\t     will not end up being string-merged.  */\n+\t   && strncmp (TREE_STRING_POINTER (base0) + ioff0,\n+\t\t       TREE_STRING_POINTER (base1) + ioff1,\n+\t\t       MIN (TREE_STRING_LENGTH (base0) - ioff0,\n+\t\t\t    TREE_STRING_LENGTH (base1) - ioff1)) != 0))\n+    ;\n+  else if (!DECL_P (base0) || !DECL_P (base1))\n+    return 2;\n+  /* If this is a pointer comparison, ignore for now even\n+     valid equalities where one pointer is the offset zero\n+     of one object and the other to one past end of another one.  */\n+  else if (!INTEGRAL_TYPE_P (type))\n+    ;\n+  /* Assume that automatic variables can't be adjacent to global\n+     variables.  */\n+  else if (is_global_var (base0) != is_global_var (base1))\n+    ;\n+  else\n+    {\n+      tree sz0 = DECL_SIZE_UNIT (base0);\n+      tree sz1 = DECL_SIZE_UNIT (base1);\n+      /* If sizes are unknown, e.g. VLA or not representable, punt.  */\n+      if (!tree_fits_poly_int64_p (sz0) || !tree_fits_poly_int64_p (sz1))\n+\treturn 2;\n+\n+      poly_int64 size0 = tree_to_poly_int64 (sz0);\n+      poly_int64 size1 = tree_to_poly_int64 (sz1);\n+      /* If one offset is pointing (or could be) to the beginning of one\n+\t object and the other is pointing to one past the last byte of the\n+\t other object, punt.  */\n+      if (maybe_eq (off0, 0) && maybe_eq (off1, size1))\n+\tequal = 2;\n+      else if (maybe_eq (off1, 0) && maybe_eq (off0, size0))\n+\tequal = 2;\n+      /* If both offsets are the same, there are some cases we know that are\n+\t ok.  Either if we know they aren't zero, or if we know both sizes\n+\t are no zero.  */\n+      if (equal == 2\n+\t  && known_eq (off0, off1)\n+\t  && (known_ne (off0, 0)\n+\t      || (known_ne (size0, 0) && known_ne (size1, 0))))\n+\tequal = 0;\n+     }\n+  return equal;\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "fed476842c7f7672ac5afd10bebb61ee188b31fa", "filename": "gcc/fold-const.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=6123b998b185572abac7d7224b34f03955bb91a2", "patch": "@@ -213,6 +213,8 @@ extern bool negate_mathfn_p (combined_fn);\n extern const char *getbyterep (tree, unsigned HOST_WIDE_INT *);\n extern const char *c_getstr (tree);\n extern wide_int tree_nonzero_bits (const_tree);\n+extern int address_compare (tree_code, tree, tree, tree, tree &, tree &,\n+\t\t\t    poly_int64 &, poly_int64 &, bool);\n \n /* Return OFF converted to a pointer offset type suitable as offset for\n    POINTER_PLUS_EXPR.  Use location LOC for this conversion.  */"}, {"sha": "0734c45700c1dd010466b9dd56ed34b7983c8a06", "filename": "gcc/match.pd", "status": "modified", "additions": 47, "deletions": 125, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=6123b998b185572abac7d7224b34f03955bb91a2", "patch": "@@ -3009,6 +3009,30 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     @0\n     @2)))\n \n+/* Simplify min (&var[off0], &var[off1]) etc. depending on whether\n+   the addresses are known to be less, equal or greater.  */\n+(for minmax (min max)\n+     cmp (lt gt)\n+ (simplify\n+  (minmax (convert1?@2 addr@0) (convert2?@3 addr@1))\n+  (with\n+   {\n+     poly_int64 off0, off1;\n+     tree base0, base1;\n+     int equal = address_compare (cmp, TREE_TYPE (@2), @0, @1, base0, base1,\n+\t\t\t\t  off0, off1, GENERIC);\n+   }\n+   (if (equal == 1)\n+    (if (minmax == MIN_EXPR)\n+     (if (known_le (off0, off1))\n+      @2\n+      (if (known_gt (off0, off1))\n+       @3))\n+     (if (known_ge (off0, off1))\n+      @2\n+      (if (known_lt (off0, off1))\n+       @3)))))))\n+\n /* (convert (minmax ((convert (x) c)))) -> minmax (x c) if x is promoted\n    and the outer convert demotes the expression back to x's type.  */\n (for minmax (min max)\n@@ -5291,132 +5315,30 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (with\n    {\n      poly_int64 off0, off1;\n-     tree base0 = get_addr_base_and_unit_offset (TREE_OPERAND (@0, 0), &off0);\n-     tree base1 = get_addr_base_and_unit_offset (TREE_OPERAND (@1, 0), &off1);\n-     if (base0 && TREE_CODE (base0) == MEM_REF)\n-       {\n-\t off0 += mem_ref_offset (base0).force_shwi ();\n-         base0 = TREE_OPERAND (base0, 0);\n-       }\n-     if (base1 && TREE_CODE (base1) == MEM_REF)\n-       {\n-\t off1 += mem_ref_offset (base1).force_shwi ();\n-         base1 = TREE_OPERAND (base1, 0);\n-       }\n+     tree base0, base1;\n+     int equal = address_compare (cmp, TREE_TYPE (@2), @0, @1, base0, base1,\n+\t\t\t\t  off0, off1, GENERIC);\n    }\n-   (if (base0 && base1)\n-    (with\n-     {\n-       int equal = 2;\n-       /* Punt in GENERIC on variables with value expressions;\n-\t  the value expressions might point to fields/elements\n-\t  of other vars etc.  */\n-       if (GENERIC\n-\t   && ((VAR_P (base0) && DECL_HAS_VALUE_EXPR_P (base0))\n-\t       || (VAR_P (base1) && DECL_HAS_VALUE_EXPR_P (base1))))\n-\t ;\n-       else if (decl_in_symtab_p (base0)\n-\t\t&& decl_in_symtab_p (base1))\n-         equal = symtab_node::get_create (base0)\n-\t           ->equal_address_to (symtab_node::get_create (base1));\n-       else if ((DECL_P (base0)\n-\t\t || TREE_CODE (base0) == SSA_NAME\n-\t\t || TREE_CODE (base0) == STRING_CST)\n-\t\t&& (DECL_P (base1)\n-\t\t    || TREE_CODE (base1) == SSA_NAME\n-\t\t    || TREE_CODE (base1) == STRING_CST))\n-         equal = (base0 == base1);\n-       if (equal == 0)\n-\t {\n-\t   HOST_WIDE_INT ioff0 = -1, ioff1 = -1;\n-\t   off0.is_constant (&ioff0);\n-\t   off1.is_constant (&ioff1);\n-\t   if ((DECL_P (base0) && TREE_CODE (base1) == STRING_CST)\n-\t       || (TREE_CODE (base0) == STRING_CST && DECL_P (base1))\n-\t       || (TREE_CODE (base0) == STRING_CST\n-\t\t   && TREE_CODE (base1) == STRING_CST\n-\t\t   && ioff0 >= 0 && ioff1 >= 0\n-\t\t   && ioff0 < TREE_STRING_LENGTH (base0)\n-\t\t   && ioff1 < TREE_STRING_LENGTH (base1)\n-\t\t   /* This is a too conservative test that the STRING_CSTs\n-\t\t      will not end up being string-merged.  */\n-\t\t   && strncmp (TREE_STRING_POINTER (base0) + ioff0,\n-\t\t\t       TREE_STRING_POINTER (base1) + ioff1,\n-\t\t\t       MIN (TREE_STRING_LENGTH (base0) - ioff0,\n-\t\t\t\t    TREE_STRING_LENGTH (base1) - ioff1)) != 0))\n-\t     ;\n-\t   else if (!DECL_P (base0) || !DECL_P (base1))\n-\t     equal = 2;\n-\t   else if (cmp != EQ_EXPR && cmp != NE_EXPR)\n-\t     equal = 2;\n-\t   /* If this is a pointer comparison, ignore for now even\n-\t      valid equalities where one pointer is the offset zero\n-\t      of one object and the other to one past end of another one.  */\n-\t   else if (!INTEGRAL_TYPE_P (TREE_TYPE (@2)))\n-\t     ;\n-\t   /* Assume that automatic variables can't be adjacent to global\n-\t      variables.  */\n-\t   else if (is_global_var (base0) != is_global_var (base1))\n-\t     ;\n-\t   else\n-\t     {\n-\t       tree sz0 = DECL_SIZE_UNIT (base0);\n-\t       tree sz1 = DECL_SIZE_UNIT (base1);\n-\t       /* If sizes are unknown, e.g. VLA or not representable,\n-\t\t  punt.  */\n-\t       if (!tree_fits_poly_int64_p (sz0)\n-\t\t   || !tree_fits_poly_int64_p (sz1))\n-\t\t equal = 2;\n-\t       else\n-\t\t {\n-\t\t   poly_int64 size0 = tree_to_poly_int64 (sz0);\n-\t\t   poly_int64 size1 = tree_to_poly_int64 (sz1);\n-\t\t   /* If one offset is pointing (or could be) to the beginning\n-\t\t      of one object and the other is pointing to one past the\n-\t\t      last byte of the other object, punt.  */\n-\t\t   if (maybe_eq (off0, 0) && maybe_eq (off1, size1))\n-\t\t     equal = 2;\n-\t\t   else if (maybe_eq (off1, 0) && maybe_eq (off0, size0))\n-\t\t     equal = 2;\n-\t\t   /* If both offsets are the same, there are some cases\n-\t\t      we know that are ok.  Either if we know they aren't\n-\t\t      zero, or if we know both sizes are no zero.  */\n-\t\t   if (equal == 2\n-\t\t       && known_eq (off0, off1)\n-\t\t       && (known_ne (off0, 0)\n-\t\t\t   || (known_ne (size0, 0) && known_ne (size1, 0))))\n-\t\t     equal = 0;\n-\t\t }\n-\t     }\n-\t }\n-     }\n-     (if (equal == 1\n-\t  && (cmp == EQ_EXPR || cmp == NE_EXPR\n-\t      /* If the offsets are equal we can ignore overflow.  */\n-\t      || known_eq (off0, off1)\n-\t      || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0))\n-\t\t /* Or if we compare using pointers to decls or strings.  */\n-\t      || (POINTER_TYPE_P (TREE_TYPE (@2))\n-\t\t  && (DECL_P (base0) || TREE_CODE (base0) == STRING_CST))))\n-      (switch\n-       (if (cmp == EQ_EXPR && (known_eq (off0, off1) || known_ne (off0, off1)))\n-\t{ constant_boolean_node (known_eq (off0, off1), type); })\n-       (if (cmp == NE_EXPR && (known_eq (off0, off1) || known_ne (off0, off1)))\n-\t{ constant_boolean_node (known_ne (off0, off1), type); })\n-       (if (cmp == LT_EXPR && (known_lt (off0, off1) || known_ge (off0, off1)))\n-\t{ constant_boolean_node (known_lt (off0, off1), type); })\n-       (if (cmp == LE_EXPR && (known_le (off0, off1) || known_gt (off0, off1)))\n-\t{ constant_boolean_node (known_le (off0, off1), type); })\n-       (if (cmp == GE_EXPR && (known_ge (off0, off1) || known_lt (off0, off1)))\n-\t{ constant_boolean_node (known_ge (off0, off1), type); })\n-       (if (cmp == GT_EXPR && (known_gt (off0, off1) || known_le (off0, off1)))\n-\t{ constant_boolean_node (known_gt (off0, off1), type); }))\n-      (if (equal == 0)\n-\t(switch\n-\t (if (cmp == EQ_EXPR)\n-\t  { constant_boolean_node (false, type); })\n-\t (if (cmp == NE_EXPR)\n-\t  { constant_boolean_node (true, type); })))))))))\n+   (if (equal == 1)\n+    (switch\n+     (if (cmp == EQ_EXPR && (known_eq (off0, off1) || known_ne (off0, off1)))\n+      { constant_boolean_node (known_eq (off0, off1), type); })\n+     (if (cmp == NE_EXPR && (known_eq (off0, off1) || known_ne (off0, off1)))\n+      { constant_boolean_node (known_ne (off0, off1), type); })\n+     (if (cmp == LT_EXPR && (known_lt (off0, off1) || known_ge (off0, off1)))\n+      { constant_boolean_node (known_lt (off0, off1), type); })\n+     (if (cmp == LE_EXPR && (known_le (off0, off1) || known_gt (off0, off1)))\n+      { constant_boolean_node (known_le (off0, off1), type); })\n+     (if (cmp == GE_EXPR && (known_ge (off0, off1) || known_lt (off0, off1)))\n+      { constant_boolean_node (known_ge (off0, off1), type); })\n+     (if (cmp == GT_EXPR && (known_gt (off0, off1) || known_le (off0, off1)))\n+      { constant_boolean_node (known_gt (off0, off1), type); }))\n+    (if (equal == 0)\n+     (switch\n+      (if (cmp == EQ_EXPR)\n+       { constant_boolean_node (false, type); })\n+      (if (cmp == NE_EXPR)\n+       { constant_boolean_node (true, type); })))))))\n \n /* Simplify pointer equality compares using PTA.  */\n (for neeq (ne eq)"}, {"sha": "e39ab2fb45a3a5f797725f9ae4032bb41bfe28d6", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-62.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c?ref=6123b998b185572abac7d7224b34f03955bb91a2", "patch": "@@ -217,14 +217,14 @@ void test_max (void)\n   {\n     /* Exercise both pointers pointing to the same object plus constant\n        offset.  */\n-    char a2[2];               // { dg-message \"at offset 1 into destination object 'a2' of size 2\" \"note\" }\n+    char a2[2];\n     char *pi = a2 + 1;\n     char *pj = a2 + 2;\n \n     char *q = MAX (pi, pj);\n \n-    memset (q, 0, 1);\n-    memset (q, 0, 2);         // { dg-warning \"writing 2 bytes into a region of size 1 \" }\n+    memset (q, 0, 1);         // { dg-warning \"writing 1 byte into a region of size 0 \" \"\" { target *-*-* } 0 }\n+    memset (q, 0, 2);         // { dg-warning \"writing 2 bytes into a region of size 0 \" }\n   }\n \n   {\n@@ -345,7 +345,7 @@ void test_max (void)\n        not reflected in the determaxed offset).  */\n     char *q = MAX (p1, p2);\n \n-    memset (q, 0, 1);         // { dg-warning \"writing 1 byte into a region of size 0 \" }\n+    memset (q, 0, 1);\n   }\n \n   {"}, {"sha": "42b6fe68b7e9ccbc82b9f765089f6cdcb2eecc05", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr102951.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102951.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6123b998b185572abac7d7224b34f03955bb91a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102951.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102951.c?ref=6123b998b185572abac7d7224b34f03955bb91a2", "patch": "@@ -0,0 +1,41 @@\n+/* PR tree-optimization/102951 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ccp1\" } */\n+/* { dg-final { scan-tree-dump-times \"return \\&a\\\\\\[1\\\\\\];\" 2 \"ccp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"return \\&a\\\\\\[4\\\\\\];\" 2 \"ccp1\" } } */\n+/* { dg-final { scan-tree-dump-not \"MIN_EXPR\" \"ccp1\" } } */\n+/* { dg-final { scan-tree-dump-not \"MAX_EXPR\" \"ccp1\" } } */\n+\n+extern int a[5];\n+\n+int *\n+foo (void)\n+{\n+  int *p1 = &a[1];\n+  int *p2 = &a[2];\n+  return p1 < p2 ? p1 : p2;\n+}\n+\n+int *\n+bar (void)\n+{\n+  int *p1 = &a[1];\n+  int *p2 = &a[2];\n+  return p1 <= p2 ? p1 : p2;\n+}\n+\n+int *\n+baz (void)\n+{\n+  int *p1 = &a[3];\n+  int *p2 = &a[4];\n+  return p1 > p2 ? p1 : p2;\n+}\n+\n+int *\n+qux (void)\n+{\n+  int *p1 = &a[3];\n+  int *p2 = &a[4];\n+  return p1 >= p2 ? p1 : p2;\n+}"}]}