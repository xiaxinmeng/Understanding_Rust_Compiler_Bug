{"sha": "2de2b3f93b964081665a990a8b5645709302d834", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRlMmIzZjkzYjk2NDA4MTY2NWE5OTBhOGI1NjQ1NzA5MzAyZDgzNA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-03-24T14:03:24Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-03-24T14:03:24Z"}, "message": "S/390: arch12: Support new vector floating point modes.\n\nThis patch adds support for the new floating point vector elements (SF\nand TF) introduced with arch12.\n\ngcc/ChangeLog:\n\n2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_expand_vec_compare): Support other\n\tvector floating point modes than just V2DF.\n\t(s390_expand_vcond): Likewise.\n\t(s390_hard_regno_mode_ok): Allow SFmode values in VRs.\n\t(s390_cannot_change_mode_class): Prevent mode changes between TF\n\tand V1TF in vector registers.\n\t* config/s390/s390.md (DF, SF): New mode attributes.\n\t(\"*cmp<mode>_ccs\", \"add<mode>3\", \"sub<mode>3\", \"mul<mode>3\")\n\t(\"fma<mode>4\", \"fms<mode>4\", \"div<mode>3\", \"*neg<mode>2\"): Add\n\tSFmode support for VRs.\n\t* config/s390/vector.md (V_HW, V_HW2, VT_HW, ti*, nonvec): Add new\n\tvector fp modes.\n\t(VFT, VF_HW): New mode iterators.\n\t(vw, sdx): New mode attributes.\n\t(\"addv2df3\", \"subv2df3\", \"mulv2df3\", \"divv2df3\", \"sqrtv2df2\")\n\t(\"fmav2df4\",\"fmsv2df4\", \"negv2df2\", \"absv2df2\", \"*negabsv2df2\")\n\t(\"smaxv2df3\", \"sminv2df3\", \"*vec_cmp<VFCMP_HW_OP:code>v2df_nocc\")\n\t(\"vec_cmpuneqv2df\", \"vec_cmpltgtv2df\", \"vec_orderedv2df\")\n\t(\"vec_unorderedv2df\"): Adjust the v2df only patterns to support\n\talso the new vector floating point modes.  Renaming to ...\n\n\t(\"add<mode>3\", \"sub<mode>3\", \"mul<mode>3\", \"div<mode>3\")\n\t(\"sqrt<mode>2\", \"fma<mode>4\", \"fms<mode>4\", \"neg<mode>2\")\n\t(\"abs<mode>2\", \"negabs<mode>2\", \"smax<mode>3\")\n\t(\"smin<mode>3\", \"*vec_cmp<VFCMP_HW_OP:code><mode>_nocc\")\n\t(\"vec_cmpuneq<mode>\", \"vec_cmpltgt<mode>\", \"vec_ordered<mode>\")\n\t(\"vec_unordered<mode>\"): ... these.\n\n\t(\"neg_fma<mode>4\", \"neg_fms<mode>4\", \"*smax<mode>3_vxe\")\n\t(\"*smin<mode>3_vxe\", \"*sminv2df3_vx\", \"*vec_extendv4sf\")\n\t(\"*vec_extendv2df\"): New insn definitions.\n\ngcc/testsuite/ChangeLog:\n\n2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/vxe/negfma-1.c: New test.\n\nFrom-SVN: r246458", "tree": {"sha": "c7a824e4b8094939d8ab3a5b9cb226e07bf9c896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7a824e4b8094939d8ab3a5b9cb226e07bf9c896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2de2b3f93b964081665a990a8b5645709302d834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de2b3f93b964081665a990a8b5645709302d834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de2b3f93b964081665a990a8b5645709302d834", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de2b3f93b964081665a990a8b5645709302d834/comments", "author": null, "committer": null, "parents": [{"sha": "7d2fd07577b71f2ef3143ffb80ca6223d06dd396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2fd07577b71f2ef3143ffb80ca6223d06dd396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d2fd07577b71f2ef3143ffb80ca6223d06dd396"}], "stats": {"total": 559, "additions": 388, "deletions": 171}, "files": [{"sha": "7083cd982edfb4da5b2ec1a3bd1c0899608c8639", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de2b3f93b964081665a990a8b5645709302d834/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de2b3f93b964081665a990a8b5645709302d834/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2de2b3f93b964081665a990a8b5645709302d834", "patch": "@@ -1,3 +1,37 @@\n+2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_expand_vec_compare): Support other\n+\tvector floating point modes than just V2DF.\n+\t(s390_expand_vcond): Likewise.\n+\t(s390_hard_regno_mode_ok): Allow SFmode values in VRs.\n+\t(s390_cannot_change_mode_class): Prevent mode changes between TF\n+\tand V1TF in vector registers.\n+\t* config/s390/s390.md (DF, SF): New mode attributes.\n+\t(\"*cmp<mode>_ccs\", \"add<mode>3\", \"sub<mode>3\", \"mul<mode>3\")\n+\t(\"fma<mode>4\", \"fms<mode>4\", \"div<mode>3\", \"*neg<mode>2\"): Add\n+\tSFmode support for VRs.\n+\t* config/s390/vector.md (V_HW, V_HW2, VT_HW, ti*, nonvec): Add new\n+\tvector fp modes.\n+\t(VFT, VF_HW): New mode iterators.\n+\t(vw, sdx): New mode attributes.\n+\t(\"addv2df3\", \"subv2df3\", \"mulv2df3\", \"divv2df3\", \"sqrtv2df2\")\n+\t(\"fmav2df4\",\"fmsv2df4\", \"negv2df2\", \"absv2df2\", \"*negabsv2df2\")\n+\t(\"smaxv2df3\", \"sminv2df3\", \"*vec_cmp<VFCMP_HW_OP:code>v2df_nocc\")\n+\t(\"vec_cmpuneqv2df\", \"vec_cmpltgtv2df\", \"vec_orderedv2df\")\n+\t(\"vec_unorderedv2df\"): Adjust the v2df only patterns to support\n+\talso the new vector floating point modes.  Renaming to ...\n+\n+\t(\"add<mode>3\", \"sub<mode>3\", \"mul<mode>3\", \"div<mode>3\")\n+\t(\"sqrt<mode>2\", \"fma<mode>4\", \"fms<mode>4\", \"neg<mode>2\")\n+\t(\"abs<mode>2\", \"negabs<mode>2\", \"smax<mode>3\")\n+\t(\"smin<mode>3\", \"*vec_cmp<VFCMP_HW_OP:code><mode>_nocc\")\n+\t(\"vec_cmpuneq<mode>\", \"vec_cmpltgt<mode>\", \"vec_ordered<mode>\")\n+\t(\"vec_unordered<mode>\"): ... these.\n+\n+\t(\"neg_fma<mode>4\", \"neg_fms<mode>4\", \"*smax<mode>3_vxe\")\n+\t(\"*smin<mode>3_vxe\", \"*sminv2df3_vx\", \"*vec_extendv4sf\")\n+\t(\"*vec_extendv2df\"): New insn definitions.\n+\n 2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md (\"*adddi3_sign\", \"*subdi3_sign\", \"mulditi3\")"}, {"sha": "bb2d743dd55d9985bf3a484a77ea1d8df64f86f7", "filename": "gcc/config/s390/s390-builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Fconfig%2Fs390%2Fs390-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Fconfig%2Fs390%2Fs390-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-builtins.def?ref=2de2b3f93b964081665a990a8b5645709302d834", "patch": "@@ -2496,7 +2496,7 @@ B_DEF      (s390_vec_ctsl,              vec_ctsl,           0,\n B_DEF      (s390_vec_ctul,              vec_ctul,           0,                  B_VX,               O2_U3,              BT_FN_UV2DI_V2DF_INT)                    /* vclgdb */\n B_DEF      (s390_vcgdb,                 vec_df_to_di_s64,   0,                  B_VX,               O2_U3,              BT_FN_V2DI_V2DF_INT)                     /* vcgdb */\n B_DEF      (s390_vclgdb,                vec_df_to_di_u64,   0,                  B_VX,               O2_U3,              BT_FN_UV2DI_V2DF_INT)                    /* vclgdb */\n-B_DEF      (s390_vfidb,                 vfidb,              0,                  B_VX,               O2_U4 | O3_U3,      BT_FN_V2DF_V2DF_UCHAR_UCHAR)\n+B_DEF      (s390_vfidb,                 vfiv2df,            0,                  B_VX,               O2_U4 | O3_U3,      BT_FN_V2DF_V2DF_UCHAR_UCHAR)\n B_DEF      (s390_vec_ld2f,              vec_ld2f,           0,                  B_VX,               0,                  BT_FN_V2DF_FLTCONSTPTR)                  /* vldeb */\n B_DEF      (s390_vec_st2f,              vec_st2f,           0,                  B_VX,               0,                  BT_FN_VOID_V2DF_FLTPTR)                  /* vledb */\n B_DEF      (s390_vfmadb,                fmav2df4,           0,                  B_VX,               0,                  BT_FN_V2DF_V2DF_V2DF_V2DF)"}, {"sha": "1d26979cdea05072190441d7da34d8ed00567ff8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=2de2b3f93b964081665a990a8b5645709302d834", "patch": "@@ -6201,7 +6201,7 @@ s390_expand_vec_compare (rtx target, enum rtx_code cond,\n   bool neg_p = false, swap_p = false;\n   rtx tmp;\n \n-  if (GET_MODE (cmp_op1) == V2DFmode)\n+  if (GET_MODE_CLASS (GET_MODE (cmp_op1)) == MODE_VECTOR_FLOAT)\n     {\n       switch (cond)\n \t{\n@@ -6447,7 +6447,8 @@ s390_expand_vcond (rtx target, rtx then, rtx els,\n \n   /* We always use an integral type vector to hold the comparison\n      result.  */\n-  result_mode = cmp_mode == V2DFmode ? V2DImode : cmp_mode;\n+  result_mode = mode_for_vector (int_mode_for_mode (GET_MODE_INNER (cmp_mode)),\n+\t\t\t\t GET_MODE_NUNITS (cmp_mode));\n   result_target = gen_reg_rtx (result_mode);\n \n   /* We allow vector immediates as comparison operands that\n@@ -10112,6 +10113,7 @@ s390_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n       return ((GET_MODE_CLASS (mode) == MODE_INT\n \t       && s390_class_max_nregs (VEC_REGS, mode) == 1)\n \t      || mode == DFmode\n+\t      || (TARGET_VXE && mode == SFmode)\n \t      || s390_vector_mode_supported_p (mode));\n       break;\n     case FP_REGS:\n@@ -10256,6 +10258,13 @@ s390_cannot_change_mode_class (machine_mode from_mode,\n   machine_mode small_mode;\n   machine_mode big_mode;\n \n+  /* V1TF and TF have different representations in vector\n+     registers.  */\n+  if (reg_classes_intersect_p (VEC_REGS, rclass)\n+      && ((from_mode == V1TFmode && to_mode == TFmode)\n+\t  || (from_mode == TFmode && to_mode == V1TFmode)))\n+    return 1;\n+\n   if (GET_MODE_SIZE (from_mode) == GET_MODE_SIZE (to_mode))\n     return 0;\n "}, {"sha": "7e9add7c340a1f553971bb9354e7f4cfc8a7b65e", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 80, "deletions": 64, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=2de2b3f93b964081665a990a8b5645709302d834", "patch": "@@ -674,6 +674,12 @@\n (define_mode_attr DFDI [(TF \"0\") (DF \"*\") (SF \"0\")\n \t\t\t(TD \"0\") (DD \"0\") (DD \"0\")\n \t\t\t(TI \"0\") (DI \"*\") (SI \"0\")])\n+(define_mode_attr DF [(TF \"0\") (DF \"*\") (SF \"0\")\n+\t\t      (TD \"0\") (DD \"0\") (DD \"0\")\n+\t\t      (TI \"0\") (DI \"0\") (SI \"0\")])\n+(define_mode_attr SF [(TF \"0\") (DF \"0\") (SF \"*\")\n+\t\t      (TD \"0\") (DD \"0\") (DD \"0\")\n+\t\t      (TI \"0\") (DI \"0\") (SI \"0\")])\n \n ;; This attribute is used in the operand constraint list\n ;; for instructions dealing with the sign bit of 32 or 64bit fp values.\n@@ -1325,20 +1331,21 @@\n  })\n \n \n-; cxtr, cdtr, cxbr, cdbr, cebr, cdb, ceb, wfcdb\n+; VX: TFmode in FPR pairs: use cxbr instead of wfcxb\n+; cxtr, cdtr, cxbr, cdbr, cebr, cdb, ceb, wfcsb, wfcdb\n (define_insn \"*cmp<mode>_ccs\"\n   [(set (reg CC_REGNUM)\n-        (compare (match_operand:FP 0 \"register_operand\" \"f,f,v\")\n-                 (match_operand:FP 1 \"general_operand\"  \"f,R,v\")))]\n+        (compare (match_operand:FP 0 \"register_operand\" \"f,f,v,v\")\n+                 (match_operand:FP 1 \"general_operand\"  \"f,R,v,v\")))]\n   \"s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT\"\n   \"@\n    c<xde><bt>r\\t%0,%1\n    c<xde>b\\t%0,%1\n-   wfcdb\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RXE,VRR\")\n-   (set_attr \"cpu_facility\" \"*,*,vx\")\n-   (set_attr \"enabled\" \"*,<DSF>,<DFDI>\")])\n-\n+   wfcdb\\t%0,%1\n+   wfcsb\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RRE,RXE,VRR,VRR\")\n+   (set_attr \"cpu_facility\" \"*,*,vx,vxe\")\n+   (set_attr \"enabled\" \"*,<DSF>,<DF>,<SF>\")])\n \n ; Compare and Branch instructions\n \n@@ -5159,6 +5166,7 @@\n ; extend(sf|df)(df|tf)2 instruction pattern(s).\n ;\n \n+; wflls\n (define_insn \"*extendsfdf2_z13\"\n   [(set (match_operand:DF                  0 \"register_operand\"     \"=f,f,v\")\n         (float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\"  \"f,R,v\")))]\n@@ -5811,20 +5819,21 @@\n ; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n ; FIXME: wfadb does not clobber cc\n (define_insn \"add<mode>3\"\n-  [(set (match_operand:FP 0 \"register_operand\"              \"=f,f,f,v\")\n-        (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%f,0,0,v\")\n-\t\t (match_operand:FP 2 \"general_operand\"       \"f,f,R,v\")))\n+  [(set (match_operand:FP          0 \"register_operand\"     \"=f,f,f,v,v\")\n+        (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%f,0,0,v,v\")\n+\t\t (match_operand:FP 2 \"general_operand\"       \"f,f,R,v,v\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    a<xde>tr\\t%0,%1,%2\n    a<xde>br\\t%0,%2\n    a<xde>b\\t%0,%2\n-   wfadb\\t%v0,%v1,%v2\"\n-  [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR\")\n+   wfadb\\t%v0,%v1,%v2\n+   wfasb\\t%v0,%v1,%v2\"\n+  [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR,VRR\")\n    (set_attr \"type\"         \"fsimp<mode>\")\n-   (set_attr \"cpu_facility\" \"*,*,*,vx\")\n-   (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DFDI>\")])\n+   (set_attr \"cpu_facility\" \"*,*,*,vx,vxe\")\n+   (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DF>,<SF>\")])\n \n ; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n (define_insn \"*add<mode>3_cc\"\n@@ -6249,28 +6258,30 @@\n ; sub(tf|df|sf|td|dd)3 instruction pattern(s).\n ;\n \n+; FIXME: (clobber (match_scratch:CC 3 \"=c,c,c,X,X\")) does not work - why?\n ; sxbr, sdbr, sebr, sdb, seb, sxtr, sdtr\n (define_insn \"sub<mode>3\"\n-  [(set (match_operand:FP           0 \"register_operand\" \"=f,f,f,v\")\n-        (minus:FP (match_operand:FP 1 \"register_operand\"  \"f,0,0,v\")\n-                  (match_operand:FP 2 \"general_operand\"   \"f,f,R,v\")))\n+  [(set (match_operand:FP           0 \"register_operand\" \"=f,f,f,v,v\")\n+        (minus:FP (match_operand:FP 1 \"register_operand\"  \"f,0,0,v,v\")\n+\t\t  (match_operand:FP 2 \"general_operand\"   \"f,f,R,v,v\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    s<xde>tr\\t%0,%1,%2\n    s<xde>br\\t%0,%2\n    s<xde>b\\t%0,%2\n-   wfsdb\\t%v0,%v1,%v2\"\n-  [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR\")\n+   wfsdb\\t%v0,%v1,%v2\n+   wfssb\\t%v0,%v1,%v2\"\n+  [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR,VRR\")\n    (set_attr \"type\"         \"fsimp<mode>\")\n-   (set_attr \"cpu_facility\" \"*,*,*,vx\")\n-   (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DFDI>\")])\n+   (set_attr \"cpu_facility\" \"*,*,*,vx,vxe\")\n+   (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DF>,<SF>\")])\n \n ; sxbr, sdbr, sebr, sdb, seb, sxtr, sdtr\n (define_insn \"*sub<mode>3_cc\"\n   [(set (reg CC_REGNUM)\n \t(compare (minus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"f,0,0\")\n-                           (match_operand:FP 2 \"general_operand\"      \"f,f,R\"))\n+\t\t\t   (match_operand:FP 2 \"general_operand\"      \"f,f,R\"))\n \t\t (match_operand:FP 3 \"const0_operand\" \"\")))\n    (set (match_operand:FP 0 \"register_operand\" \"=f,f,f\")\n \t(minus:FP (match_dup 1) (match_dup 2)))]\n@@ -6736,51 +6747,54 @@\n \n ; mxbr, mdbr, meebr, mxb, mxb, meeb, mdtr, mxtr\n (define_insn \"mul<mode>3\"\n-  [(set (match_operand:FP          0 \"register_operand\"     \"=f,f,f,v\")\n-        (mult:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%f,0,0,v\")\n-                 (match_operand:FP 2 \"general_operand\"       \"f,f,R,v\")))]\n+  [(set (match_operand:FP          0 \"register_operand\"     \"=f,f,f,v,v\")\n+        (mult:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%f,0,0,v,v\")\n+\t\t (match_operand:FP 2 \"general_operand\"       \"f,f,R,v,v\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    m<xdee>tr\\t%0,%1,%2\n    m<xdee>br\\t%0,%2\n    m<xdee>b\\t%0,%2\n-   wfmdb\\t%v0,%v1,%v2\"\n-  [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR\")\n+   wfmdb\\t%v0,%v1,%v2\n+   wfmsb\\t%v0,%v1,%v2\"\n+  [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR,VRR\")\n    (set_attr \"type\"         \"fmul<mode>\")\n-   (set_attr \"cpu_facility\" \"*,*,*,vx\")\n-   (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DFDI>\")])\n+   (set_attr \"cpu_facility\" \"*,*,*,vx,vxe\")\n+   (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DF>,<SF>\")])\n \n ; madbr, maebr, maxb, madb, maeb\n (define_insn \"fma<mode>4\"\n-  [(set (match_operand:DSF          0 \"register_operand\"     \"=f,f,v\")\n-\t(fma:DSF (match_operand:DSF 1 \"nonimmediate_operand\" \"%f,f,v\")\n-\t\t (match_operand:DSF 2 \"nonimmediate_operand\"  \"f,R,v\")\n-\t\t (match_operand:DSF 3 \"register_operand\"      \"0,0,v\")))]\n+  [(set (match_operand:DSF          0 \"register_operand\"     \"=f,f,v,v\")\n+\t(fma:DSF (match_operand:DSF 1 \"nonimmediate_operand\" \"%f,f,v,v\")\n+\t\t (match_operand:DSF 2 \"nonimmediate_operand\"  \"f,R,v,v\")\n+\t\t (match_operand:DSF 3 \"register_operand\"      \"0,0,v,v\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    ma<xde>br\\t%0,%1,%2\n    ma<xde>b\\t%0,%1,%2\n-   wfmadb\\t%v0,%v1,%v2,%v3\"\n-  [(set_attr \"op_type\"      \"RRE,RXE,VRR\")\n+   wfmadb\\t%v0,%v1,%v2,%v3\n+   wfmasb\\t%v0,%v1,%v2,%v3\"\n+  [(set_attr \"op_type\"      \"RRE,RXE,VRR,VRR\")\n    (set_attr \"type\"         \"fmadd<mode>\")\n-   (set_attr \"cpu_facility\" \"*,*,vx\")\n-   (set_attr \"enabled\"      \"*,*,<DFDI>\")])\n+   (set_attr \"cpu_facility\" \"*,*,vx,vxe\")\n+   (set_attr \"enabled\"      \"*,*,<DF>,<SF>\")])\n \n ; msxbr, msdbr, msebr, msxb, msdb, mseb\n (define_insn \"fms<mode>4\"\n-  [(set (match_operand:DSF                   0 \"register_operand\"     \"=f,f,v\")\n-\t(fma:DSF (match_operand:DSF          1 \"nonimmediate_operand\" \"%f,f,v\")\n-\t\t (match_operand:DSF          2 \"nonimmediate_operand\"  \"f,R,v\")\n-\t\t (neg:DSF (match_operand:DSF 3 \"register_operand\"      \"0,0,v\"))))]\n+  [(set (match_operand:DSF                   0 \"register_operand\"     \"=f,f,v,v\")\n+\t(fma:DSF (match_operand:DSF          1 \"nonimmediate_operand\" \"%f,f,v,v\")\n+\t\t (match_operand:DSF          2 \"nonimmediate_operand\"  \"f,R,v,v\")\n+\t\t (neg:DSF (match_operand:DSF 3 \"register_operand\"      \"0,0,v,v\"))))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    ms<xde>br\\t%0,%1,%2\n    ms<xde>b\\t%0,%1,%2\n-   wfmsdb\\t%v0,%v1,%v2,%v3\"\n-  [(set_attr \"op_type\"      \"RRE,RXE,VRR\")\n+   wfmsdb\\t%v0,%v1,%v2,%v3\n+   wfmssb\\t%v0,%v1,%v2,%v3\"\n+  [(set_attr \"op_type\"      \"RRE,RXE,VRR,VRR\")\n    (set_attr \"type\"         \"fmadd<mode>\")\n-   (set_attr \"cpu_facility\" \"*,*,vx\")\n-   (set_attr \"enabled\"      \"*,*,<DFDI>\")])\n+   (set_attr \"cpu_facility\" \"*,*,vx,vxe\")\n+   (set_attr \"enabled\"      \"*,*,<DF>,<SF>\")])\n \n ;;\n ;;- Divide and modulo instructions.\n@@ -7212,19 +7226,20 @@\n \n ; dxbr, ddbr, debr, dxb, ddb, deb, ddtr, dxtr\n (define_insn \"div<mode>3\"\n-  [(set (match_operand:FP         0 \"register_operand\" \"=f,f,f,v\")\n-        (div:FP (match_operand:FP 1 \"register_operand\"  \"f,0,0,v\")\n-\t\t(match_operand:FP 2 \"general_operand\"   \"f,f,R,v\")))]\n+  [(set (match_operand:FP         0 \"register_operand\" \"=f,f,f,v,v\")\n+        (div:FP (match_operand:FP 1 \"register_operand\"  \"f,0,0,v,v\")\n+\t\t(match_operand:FP 2 \"general_operand\"   \"f,f,R,v,v\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    d<xde>tr\\t%0,%1,%2\n    d<xde>br\\t%0,%2\n    d<xde>b\\t%0,%2\n-   wfddb\\t%v0,%v1,%v2\"\n-  [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR\")\n+   wfddb\\t%v0,%v1,%v2\n+   wfdsb\\t%v0,%v1,%v2\"\n+  [(set_attr \"op_type\"      \"RRF,RRE,RXE,VRR,VRR\")\n    (set_attr \"type\"         \"fdiv<mode>\")\n-   (set_attr \"cpu_facility\" \"*,*,*,vx\")\n-   (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DFDI>\")])\n+   (set_attr \"cpu_facility\" \"*,*,*,vx,vxe\")\n+   (set_attr \"enabled\"      \"<nBFP>,<nDFP>,<DSF>,<DF>,<SF>\")])\n \n \n ;;\n@@ -8423,11 +8438,10 @@\n \n (define_expand \"neg<mode>2\"\n   [(parallel\n-    [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n-          (neg:BFP (match_operand:BFP 1 \"register_operand\" \"f\")))\n+    [(set (match_operand:BFP          0 \"register_operand\")\n+          (neg:BFP (match_operand:BFP 1 \"register_operand\")))\n      (clobber (reg:CC CC_REGNUM))])]\n-  \"TARGET_HARD_FLOAT\"\n-  \"\")\n+  \"TARGET_HARD_FLOAT\")\n \n ; lcxbr, lcdbr, lcebr\n (define_insn \"*neg<mode>2_cc\"\n@@ -8463,18 +8477,20 @@\n \n ; lcxbr, lcdbr, lcebr\n ; FIXME: wflcdb does not clobber cc\n+; FIXME: Does wflcdb ever match here?\n (define_insn \"*neg<mode>2\"\n-  [(set (match_operand:BFP          0 \"register_operand\" \"=f,v\")\n-        (neg:BFP (match_operand:BFP 1 \"register_operand\"  \"f,v\")))\n+  [(set (match_operand:BFP          0 \"register_operand\" \"=f,v,v\")\n+        (neg:BFP (match_operand:BFP 1 \"register_operand\"  \"f,v,v\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    lc<xde>br\\t%0,%1\n-   wflcdb\\t%0,%1\"\n-  [(set_attr \"op_type\"      \"RRE,VRR\")\n-   (set_attr \"cpu_facility\" \"*,vx\")\n-   (set_attr \"type\"         \"fsimp<mode>,*\")\n-   (set_attr \"enabled\"      \"*,<DFDI>\")])\n+   wflcdb\\t%0,%1\n+   wflcsb\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,VRR,VRR\")\n+   (set_attr \"cpu_facility\" \"*,vx,vxe\")\n+   (set_attr \"type\"         \"fsimp<mode>,*,*\")\n+   (set_attr \"enabled\"      \"*,<DF>,<SF>\")])\n \n \n ;;"}, {"sha": "7535b9ddb1707c805dd5ee39ddf37e568e3ecf2f", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 209, "deletions": 104, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=2de2b3f93b964081665a990a8b5645709302d834", "patch": "@@ -26,16 +26,16 @@\n   [V1QI V2QI V4QI V8QI V16QI V1HI V2HI V4HI V8HI V1SI V2SI V4SI V1DI V2DI V1SF\n    V2SF V4SF V1DF V2DF V1TF V1TI TI])\n \n-; All vector modes directly supported by the hardware having full vector reg size\n+; All modes directly supported by the hardware having full vector reg size\n ; V_HW2 is duplicate of V_HW for having two iterators expanding\n ; independently e.g. vcond\n-(define_mode_iterator V_HW  [V16QI V8HI V4SI V2DI V2DF])\n-(define_mode_iterator V_HW2 [V16QI V8HI V4SI V2DI V2DF])\n+(define_mode_iterator V_HW  [V16QI V8HI V4SI V2DI V2DF (V4SF \"TARGET_VXE\") (V1TF \"TARGET_VXE\")])\n+(define_mode_iterator V_HW2 [V16QI V8HI V4SI V2DI V2DF (V4SF \"TARGET_VXE\") (V1TF \"TARGET_VXE\")])\n \n (define_mode_iterator V_HW_64 [V2DI V2DF])\n \n ; Including TI for instructions that support it (va, vn, ...)\n-(define_mode_iterator VT_HW [V16QI V8HI V4SI V2DI V2DF V1TI TI])\n+(define_mode_iterator VT_HW [V16QI V8HI V4SI V2DI V2DF V1TI TI (V4SF \"TARGET_VXE\") (V1TF \"TARGET_VXE\")])\n \n ; All full size integer vector modes supported in a vector register + TImode\n (define_mode_iterator VIT_HW    [V16QI V8HI V4SI V2DI V1TI TI])\n@@ -51,6 +51,15 @@\n (define_mode_iterator VI  [V1QI V2QI V4QI V8QI V16QI V1HI V2HI V4HI V8HI V1SI V2SI V4SI V1DI V2DI])\n (define_mode_iterator VI_QHS [V1QI V2QI V4QI V8QI V16QI V1HI V2HI V4HI V8HI V1SI V2SI V4SI])\n \n+(define_mode_iterator VFT [(V1SF \"TARGET_VXE\") (V2SF \"TARGET_VXE\") (V4SF \"TARGET_VXE\")\n+\t\t\t   V1DF V2DF\n+\t\t\t   (V1TF \"TARGET_VXE\")])\n+\n+; FP vector modes directly supported by the HW.  This does not include\n+; vector modes using only part of a vector register and should be used\n+; for instructions which might trigger IEEE exceptions.\n+(define_mode_iterator VF_HW [(V4SF \"TARGET_VXE\") V2DF (V1TF \"TARGET_VXE\")])\n+\n (define_mode_iterator V_8   [V1QI])\n (define_mode_iterator V_16  [V2QI  V1HI])\n (define_mode_iterator V_32  [V4QI  V2HI V1SI V1SF])\n@@ -59,26 +68,30 @@\n \n (define_mode_iterator V_128_NOSINGLE [V16QI V8HI V4SI V4SF V2DI V2DF])\n \n-; A blank for vector modes and a * for TImode.  This is used to hide\n-; the TImode expander name in case it is defined already.  See addti3\n-; for an example.\n-(define_mode_attr ti* [(V1QI \"\") (V2QI \"\") (V4QI \"\") (V8QI \"\") (V16QI \"\")\n-\t\t       (V1HI \"\") (V2HI \"\") (V4HI \"\") (V8HI \"\")\n-\t\t       (V1SI \"\") (V2SI \"\") (V4SI \"\")\n-\t\t       (V1DI \"\") (V2DI \"\")\n-\t\t       (V1TI \"*\") (TI \"*\")])\n+; Empty string for all but TImode.  This is used to hide the TImode\n+; expander name in case it is defined already.  See addti3 for an\n+; example.\n+(define_mode_attr ti* [(V1QI \"\")  (V2QI \"\") (V4QI \"\") (V8QI \"\") (V16QI \"\")\n+\t\t       (V1HI \"\")  (V2HI \"\") (V4HI \"\") (V8HI \"\")\n+\t\t       (V1SI \"\")  (V2SI \"\") (V4SI \"\")\n+\t\t       (V1DI \"\")  (V2DI \"\")\n+\t\t       (V1TI \"\")  (TI \"*\")\n+\t\t       (V1SF \"\")  (V2SF \"\") (V4SF \"\")\n+\t\t       (V1DF \"\")  (V2DF \"\")\n+\t\t       (V1TF \"\")  (TF \"\")])\n \n ; The element type of the vector.\n (define_mode_attr non_vec[(V1QI \"QI\") (V2QI \"QI\") (V4QI \"QI\") (V8QI \"QI\") (V16QI \"QI\")\n \t\t\t  (V1HI \"HI\") (V2HI \"HI\") (V4HI \"HI\") (V8HI \"HI\")\n \t\t\t  (V1SI \"SI\") (V2SI \"SI\") (V4SI \"SI\")\n \t\t\t  (V1DI \"DI\") (V2DI \"DI\")\n-\t\t\t  (V1TI \"TI\")\n+\t\t\t  (V1TI \"TI\") (TI \"TI\")\n \t\t\t  (V1SF \"SF\") (V2SF \"SF\") (V4SF \"SF\")\n \t\t\t  (V1DF \"DF\") (V2DF \"DF\")\n-\t\t\t  (V1TF \"TF\")])\n+\t\t\t  (V1TF \"TF\") (TF \"TF\")])\n \n-; The instruction suffix\n+; The instruction suffix for integer instructions and instructions\n+; which do not care about whether it is floating point or integer.\n (define_mode_attr bhfgq[(V1QI \"b\") (V2QI \"b\") (V4QI \"b\") (V8QI \"b\") (V16QI \"b\")\n \t\t\t(V1HI \"h\") (V2HI \"h\") (V4HI \"h\") (V8HI \"h\")\n \t\t\t(V1SI \"f\") (V2SI \"f\") (V4SI \"f\")\n@@ -105,6 +118,13 @@\n \t\t\t    (V1SF \"V1SI\") (V2SF \"V2SI\") (V4SF \"V4SI\")\n \t\t\t    (V1DF \"V1DI\") (V2DF \"V2DI\")\n \t\t\t    (V1TF \"V1TI\")])\n+(define_mode_attr vw [(SF \"w\") (V1SF \"w\") (V2SF \"v\") (V4SF \"v\")\n+\t\t      (DF \"w\") (V1DF \"w\") (V2DF \"v\")\n+\t\t      (TF \"w\") (V1TF \"w\")])\n+\n+(define_mode_attr sdx [(SF \"s\") (V1SF \"s\") (V2SF \"s\") (V4SF \"s\")\n+\t\t       (DF \"d\") (V1DF \"d\") (V2DF \"d\")\n+\t\t       (TF \"x\") (V1TF \"x\")])\n \n ; Vector with doubled element size.\n (define_mode_attr vec_double [(V1QI \"V1HI\") (V2QI \"V1HI\") (V4QI \"V2HI\") (V8QI \"V4HI\") (V16QI \"V8HI\")\n@@ -1029,92 +1049,139 @@\n ;; Vector floating point arithmetic instructions\n ;;\n \n-(define_insn \"addv2df3\"\n-  [(set (match_operand:V2DF            0 \"register_operand\" \"=v\")\n-\t(plus:V2DF (match_operand:V2DF 1 \"register_operand\" \"%v\")\n-\t\t   (match_operand:V2DF 2 \"register_operand\"  \"v\")))]\n+; vfasb, vfadb, wfasb, wfadb, wfaxb\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:VF_HW             0 \"register_operand\" \"=v\")\n+\t(plus:VF_HW (match_operand:VF_HW 1 \"register_operand\" \"%v\")\n+\t\t    (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n-  \"vfadb\\t%v0,%v1,%v2\"\n+  \"<vw>fa<sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"subv2df3\"\n-  [(set (match_operand:V2DF             0 \"register_operand\" \"=v\")\n-\t(minus:V2DF (match_operand:V2DF 1 \"register_operand\" \"%v\")\n-\t\t    (match_operand:V2DF 2 \"register_operand\"  \"v\")))]\n+; vfssb, vfsdb, wfssb, wfsdb, wfsxb\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:VF_HW              0 \"register_operand\" \"=v\")\n+\t(minus:VF_HW (match_operand:VF_HW 1 \"register_operand\" \"%v\")\n+\t\t     (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n-  \"vfsdb\\t%v0,%v1,%v2\"\n+  \"<vw>fs<sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"mulv2df3\"\n-  [(set (match_operand:V2DF            0 \"register_operand\" \"=v\")\n-\t(mult:V2DF (match_operand:V2DF 1 \"register_operand\" \"%v\")\n-\t\t   (match_operand:V2DF 2 \"register_operand\"  \"v\")))]\n+; vfmsb, vfmdb, wfmsb, wfmdb, wfmxb\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:VF_HW             0 \"register_operand\" \"=v\")\n+\t(mult:VF_HW (match_operand:VF_HW 1 \"register_operand\" \"%v\")\n+\t\t    (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n-  \"vfmdb\\t%v0,%v1,%v2\"\n+  \"<vw>fm<sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"divv2df3\"\n-  [(set (match_operand:V2DF           0 \"register_operand\" \"=v\")\n-\t(div:V2DF (match_operand:V2DF 1 \"register_operand\"  \"v\")\n-\t\t  (match_operand:V2DF 2 \"register_operand\"  \"v\")))]\n+; vfdsb, vfddb, wfdsb, wfddb, wfdxb\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:VF_HW            0 \"register_operand\" \"=v\")\n+\t(div:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")\n+\t\t   (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n-  \"vfddb\\t%v0,%v1,%v2\"\n+  \"<vw>fd<sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"sqrtv2df2\"\n-  [(set (match_operand:V2DF            0 \"register_operand\" \"=v\")\n-\t(sqrt:V2DF (match_operand:V2DF 1 \"register_operand\"  \"v\")))]\n+; vfsqsb, vfsqdb, wfsqsb, wfsqdb, wfsqxb\n+(define_insn \"sqrt<mode>2\"\n+  [(set (match_operand:VF_HW           0 \"register_operand\" \"=v\")\n+\t(sqrt:VF_HW (match_operand:VF_HW 1 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n-  \"vfsqdb\\t%v0,%v1\"\n+  \"<vw>fsq<sdx>b\\t%v0,%v1\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"fmav2df4\"\n-  [(set (match_operand:V2DF           0 \"register_operand\" \"=v\")\n-\t(fma:V2DF (match_operand:V2DF 1 \"register_operand\" \"%v\")\n-\t\t  (match_operand:V2DF 2 \"register_operand\"  \"v\")\n-\t\t  (match_operand:V2DF 3 \"register_operand\"  \"v\")))]\n+; vfmasb, vfmadb, wfmasb, wfmadb, wfmaxb\n+(define_insn \"fma<mode>4\"\n+  [(set (match_operand:VF_HW            0 \"register_operand\" \"=v\")\n+\t(fma:VF_HW (match_operand:VF_HW 1 \"register_operand\" \"%v\")\n+\t\t   (match_operand:VF_HW 2 \"register_operand\"  \"v\")\n+\t\t   (match_operand:VF_HW 3 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n-  \"vfmadb\\t%v0,%v1,%v2,%v3\"\n+  \"<vw>fma<sdx>b\\t%v0,%v1,%v2,%v3\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"fmsv2df4\"\n-  [(set (match_operand:V2DF                     0 \"register_operand\" \"=v\")\n-\t(fma:V2DF (match_operand:V2DF           1 \"register_operand\" \"%v\")\n-\t\t  (match_operand:V2DF           2 \"register_operand\"  \"v\")\n-\t\t  (neg:V2DF (match_operand:V2DF 3 \"register_operand\"  \"v\"))))]\n+; vfmssb, vfmsdb, wfmssb, wfmsdb, wfmsxb\n+(define_insn \"fms<mode>4\"\n+  [(set (match_operand:VF_HW                     0 \"register_operand\" \"=v\")\n+\t(fma:VF_HW (match_operand:VF_HW          1 \"register_operand\" \"%v\")\n+\t\t   (match_operand:VF_HW          2 \"register_operand\"  \"v\")\n+\t\t (neg:VF_HW (match_operand:VF_HW 3 \"register_operand\"  \"v\"))))]\n   \"TARGET_VX\"\n-  \"vfmsdb\\t%v0,%v1,%v2,%v3\"\n+  \"<vw>fms<sdx>b\\t%v0,%v1,%v2,%v3\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+; vfnmasb, vfnmadb, wfnmasb, wfnmadb, wfnmaxb\n+(define_insn \"neg_fma<mode>4\"\n+  [(set (match_operand:VF_HW             0 \"register_operand\" \"=v\")\n+\t(neg:VF_HW\n+\t (fma:VF_HW (match_operand:VF_HW 1 \"register_operand\" \"%v\")\n+\t\t    (match_operand:VF_HW 2 \"register_operand\"  \"v\")\n+\t\t    (match_operand:VF_HW 3 \"register_operand\"  \"v\"))))]\n+  \"TARGET_VXE\"\n+  \"<vw>fnma<sdx>b\\t%v0,%v1,%v2,%v3\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+; vfnmssb, vfnmsdb, wfnmssb, wfnmsdb, wfnmsxb\n+(define_insn \"neg_fms<mode>4\"\n+  [(set (match_operand:VF_HW                      0 \"register_operand\" \"=v\")\n+\t(neg:VF_HW\n+\t (fma:VF_HW (match_operand:VF_HW          1 \"register_operand\" \"%v\")\n+\t\t    (match_operand:VF_HW          2 \"register_operand\"  \"v\")\n+\t\t  (neg:VF_HW (match_operand:VF_HW 3 \"register_operand\"  \"v\")))))]\n+  \"TARGET_VXE\"\n+  \"<vw>fnms<sdx>b\\t%v0,%v1,%v2,%v3\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"negv2df2\"\n-  [(set (match_operand:V2DF           0 \"register_operand\" \"=v\")\n-\t(neg:V2DF (match_operand:V2DF 1 \"register_operand\"  \"v\")))]\n+; vflcsb, vflcdb, wflcsb, wflcdb, wflcxb\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:VFT          0 \"register_operand\" \"=v\")\n+\t(neg:VFT (match_operand:VFT 1 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n-  \"vflcdb\\t%v0,%v1\"\n+  \"<vw>flc<sdx>b\\t%v0,%v1\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"absv2df2\"\n-  [(set (match_operand:V2DF           0 \"register_operand\" \"=v\")\n-\t(abs:V2DF (match_operand:V2DF 1 \"register_operand\"  \"v\")))]\n+; vflpsb, vflpdb, wflpsb, wflpdb, wflpxb\n+(define_insn \"abs<mode>2\"\n+  [(set (match_operand:VFT          0 \"register_operand\" \"=v\")\n+\t(abs:VFT (match_operand:VFT 1 \"register_operand\"  \"v\")))]\n   \"TARGET_VX\"\n-  \"vflpdb\\t%v0,%v1\"\n+  \"<vw>flp<sdx>b\\t%v0,%v1\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n-(define_insn \"*negabsv2df2\"\n-  [(set (match_operand:V2DF                     0 \"register_operand\" \"=v\")\n-\t(neg:V2DF (abs:V2DF (match_operand:V2DF 1 \"register_operand\"  \"v\"))))]\n+; vflnsb, vflndb, wflnsb, wflndb, wflnxb\n+(define_insn \"negabs<mode>2\"\n+  [(set (match_operand:VFT                   0 \"register_operand\" \"=v\")\n+\t(neg:VFT (abs:VFT (match_operand:VFT 1 \"register_operand\"  \"v\"))))]\n   \"TARGET_VX\"\n-  \"vflndb\\t%v0,%v1\"\n+  \"<vw>fln<sdx>b\\t%v0,%v1\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+(define_expand \"smax<mode>3\"\n+  [(set (match_operand:VF_HW             0 \"register_operand\")\n+\t(smax:VF_HW (match_operand:VF_HW 1 \"register_operand\")\n+\t\t    (match_operand:VF_HW 2 \"register_operand\")))]\n+  \"TARGET_VX\")\n+\n+; vfmaxsb, vfmaxdb, wfmaxsb, wfmaxdb, wfmaxxb\n+(define_insn \"*smax<mode>3_vxe\"\n+  [(set (match_operand:VF_HW             0 \"register_operand\" \"=v\")\n+\t(smax:VF_HW (match_operand:VF_HW 1 \"register_operand\" \"%v\")\n+\t\t    (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n+  \"TARGET_VXE\"\n+  \"<vw>fmax<sdx>b\\t%v0,%v1,%v2,4\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n ; Emulate with compare + select\n-(define_insn_and_split \"smaxv2df3\"\n+(define_insn_and_split \"*smaxv2df3_vx\"\n   [(set (match_operand:V2DF            0 \"register_operand\" \"=v\")\n \t(smax:V2DF (match_operand:V2DF 1 \"register_operand\" \"%v\")\n \t\t   (match_operand:V2DF 2 \"register_operand\"  \"v\")))]\n-  \"TARGET_VX\"\n+  \"TARGET_VX && !TARGET_VXE\"\n   \"#\"\n-  \"\"\n+  \"&& 1\"\n   [(set (match_dup 3)\n \t(gt:V2DI (match_dup 1) (match_dup 2)))\n    (set (match_dup 0)\n@@ -1127,14 +1194,29 @@\n   operands[4] = CONST0_RTX (V2DImode);\n })\n \n+(define_expand \"smin<mode>3\"\n+  [(set (match_operand:VF_HW             0 \"register_operand\")\n+\t(smin:VF_HW (match_operand:VF_HW 1 \"register_operand\")\n+\t\t    (match_operand:VF_HW 2 \"register_operand\")))]\n+  \"TARGET_VX\")\n+\n+; vfminsb, vfmindb, wfminsb, wfmindb, wfminxb\n+(define_insn \"*smin<mode>3_vxe\"\n+  [(set (match_operand:VF_HW             0 \"register_operand\" \"=v\")\n+\t(smin:VF_HW (match_operand:VF_HW 1 \"register_operand\" \"%v\")\n+\t\t    (match_operand:VF_HW 2 \"register_operand\"  \"v\")))]\n+  \"TARGET_VXE\"\n+  \"<vw>fmin<sdx>b\\t%v0,%v1,%v2,4\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n ; Emulate with compare + select\n-(define_insn_and_split \"sminv2df3\"\n+(define_insn_and_split \"*sminv2df3_vx\"\n   [(set (match_operand:V2DF            0 \"register_operand\" \"=v\")\n \t(smin:V2DF (match_operand:V2DF 1 \"register_operand\" \"%v\")\n \t\t   (match_operand:V2DF 2 \"register_operand\"  \"v\")))]\n-  \"TARGET_VX\"\n+  \"TARGET_VX && !TARGET_VXE\"\n   \"#\"\n-  \"\"\n+  \"&& 1\"\n   [(set (match_dup 3)\n \t(gt:V2DI (match_dup 1) (match_dup 2)))\n    (set (match_dup 0)\n@@ -1166,65 +1248,66 @@\n ;;\n \n ; EQ, GT, GE\n-(define_insn \"*vec_cmp<VFCMP_HW_OP:code>v2df_nocc\"\n-  [(set (match_operand:V2DI                   0 \"register_operand\" \"=v\")\n-\t(VFCMP_HW_OP:V2DI (match_operand:V2DF 1 \"register_operand\"  \"v\")\n-\t\t\t  (match_operand:V2DF 2 \"register_operand\"  \"v\")))]\n+; vfcesb, vfcedb, wfcexb, vfchsb, vfchdb, wfchxb, vfchesb, vfchedb, wfchexb\n+(define_insn \"*vec_cmp<VFCMP_HW_OP:code><mode>_nocc\"\n+  [(set (match_operand:<tointvec>                  0 \"register_operand\" \"=v\")\n+\t(VFCMP_HW_OP:<tointvec> (match_operand:VFT 1 \"register_operand\"  \"v\")\n+\t\t\t     (match_operand:VFT 2 \"register_operand\"  \"v\")))]\n    \"TARGET_VX\"\n-   \"vfc<VFCMP_HW_OP:asm_fcmp_op>db\\t%v0,%v1,%v2\"\n+   \"<vw>fc<VFCMP_HW_OP:asm_fcmp_op><sdx>b\\t%v0,%v1,%v2\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n ; Expanders for not directly supported comparisons\n \n ; UNEQ a u== b -> !(a > b | b > a)\n-(define_expand \"vec_cmpuneqv2df\"\n-  [(set (match_operand:V2DI          0 \"register_operand\" \"=v\")\n-\t(gt:V2DI (match_operand:V2DF 1 \"register_operand\"  \"v\")\n-\t\t (match_operand:V2DF 2 \"register_operand\"  \"v\")))\n+(define_expand \"vec_cmpuneq<mode>\"\n+  [(set (match_operand:<tointvec>         0 \"register_operand\" \"=v\")\n+\t(gt:<tointvec> (match_operand:VFT 1 \"register_operand\"  \"v\")\n+\t\t    (match_operand:VFT 2 \"register_operand\"  \"v\")))\n    (set (match_dup 3)\n-\t(gt:V2DI (match_dup 2) (match_dup 1)))\n-   (set (match_dup 0) (ior:V2DI (match_dup 0) (match_dup 3)))\n-   (set (match_dup 0) (not:V2DI (match_dup 0)))]\n+\t(gt:<tointvec> (match_dup 2) (match_dup 1)))\n+   (set (match_dup 0) (ior:<tointvec> (match_dup 0) (match_dup 3)))\n+   (set (match_dup 0) (not:<tointvec> (match_dup 0)))]\n   \"TARGET_VX\"\n {\n-  operands[3] = gen_reg_rtx (V2DImode);\n+  operands[3] = gen_reg_rtx (<tointvec>mode);\n })\n \n ; LTGT a <> b -> a > b | b > a\n-(define_expand \"vec_cmpltgtv2df\"\n-  [(set (match_operand:V2DI          0 \"register_operand\" \"=v\")\n-\t(gt:V2DI (match_operand:V2DF 1 \"register_operand\"  \"v\")\n-\t\t (match_operand:V2DF 2 \"register_operand\"  \"v\")))\n-   (set (match_dup 3) (gt:V2DI (match_dup 2) (match_dup 1)))\n-   (set (match_dup 0) (ior:V2DI (match_dup 0) (match_dup 3)))]\n+(define_expand \"vec_cmpltgt<mode>\"\n+  [(set (match_operand:<tointvec>         0 \"register_operand\" \"=v\")\n+\t(gt:<tointvec> (match_operand:VFT 1 \"register_operand\"  \"v\")\n+\t\t    (match_operand:VFT 2 \"register_operand\"  \"v\")))\n+   (set (match_dup 3) (gt:<tointvec> (match_dup 2) (match_dup 1)))\n+   (set (match_dup 0) (ior:<tointvec> (match_dup 0) (match_dup 3)))]\n   \"TARGET_VX\"\n {\n-  operands[3] = gen_reg_rtx (V2DImode);\n+  operands[3] = gen_reg_rtx (<tointvec>mode);\n })\n \n ; ORDERED (a, b): a >= b | b > a\n-(define_expand \"vec_orderedv2df\"\n-  [(set (match_operand:V2DI          0 \"register_operand\" \"=v\")\n-\t(ge:V2DI (match_operand:V2DF 1 \"register_operand\"  \"v\")\n-\t\t (match_operand:V2DF 2 \"register_operand\"  \"v\")))\n-   (set (match_dup 3) (gt:V2DI (match_dup 2) (match_dup 1)))\n-   (set (match_dup 0) (ior:V2DI (match_dup 0) (match_dup 3)))]\n+(define_expand \"vec_ordered<mode>\"\n+  [(set (match_operand:<tointvec>          0 \"register_operand\" \"=v\")\n+\t(ge:<tointvec> (match_operand:VFT 1 \"register_operand\"  \"v\")\n+\t\t (match_operand:VFT 2 \"register_operand\"  \"v\")))\n+   (set (match_dup 3) (gt:<tointvec> (match_dup 2) (match_dup 1)))\n+   (set (match_dup 0) (ior:<tointvec> (match_dup 0) (match_dup 3)))]\n   \"TARGET_VX\"\n {\n-  operands[3] = gen_reg_rtx (V2DImode);\n+  operands[3] = gen_reg_rtx (<tointvec>mode);\n })\n \n ; UNORDERED (a, b): !ORDERED (a, b)\n-(define_expand \"vec_unorderedv2df\"\n-  [(set (match_operand:V2DI          0 \"register_operand\" \"=v\")\n-\t(ge:V2DI (match_operand:V2DF 1 \"register_operand\"  \"v\")\n-\t\t (match_operand:V2DF 2 \"register_operand\"  \"v\")))\n-   (set (match_dup 3) (gt:V2DI (match_dup 2) (match_dup 1)))\n-   (set (match_dup 0) (ior:V2DI (match_dup 0) (match_dup 3)))\n-   (set (match_dup 0) (not:V2DI (match_dup 0)))]\n+(define_expand \"vec_unordered<mode>\"\n+  [(set (match_operand:<tointvec>          0 \"register_operand\" \"=v\")\n+\t(ge:<tointvec> (match_operand:VFT 1 \"register_operand\"  \"v\")\n+\t\t (match_operand:VFT 2 \"register_operand\"  \"v\")))\n+   (set (match_dup 3) (gt:<tointvec> (match_dup 2) (match_dup 1)))\n+   (set (match_dup 0) (ior:<tointvec> (match_dup 0) (match_dup 3)))\n+   (set (match_dup 0) (not:<tointvec> (match_dup 0)))]\n   \"TARGET_VX\"\n {\n-  operands[3] = gen_reg_rtx (V2DImode);\n+  operands[3] = gen_reg_rtx (<tointvec>mode);\n })\n \n (define_insn \"*vec_load_pair<mode>\"\n@@ -1563,6 +1646,28 @@\n   \"vupllf\\t%0,%1\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+;; vector load lengthened\n+\n+; vflls\n+(define_insn \"*vec_extendv4sf\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(float_extend:V2DF\n+\t (vec_select:V2SF\n+\t  (match_operand:V4SF 1 \"register_operand\" \"v\")\n+\t  (parallel [(const_int 0) (const_int 2)]))))]\n+  \"TARGET_VX\"\n+  \"vldeb\\t%v0,%v1\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+(define_insn \"*vec_extendv2df\"\n+  [(set (match_operand:V1TF 0 \"register_operand\" \"=v\")\n+\t(float_extend:V1TF\n+\t (vec_select:V1DF\n+\t  (match_operand:V2DF 1 \"register_operand\" \"v\")\n+\t  (parallel [(const_int 0)]))))]\n+  \"TARGET_VXE\"\n+  \"wflld\\t%v0,%v1\"\n+  [(set_attr \"op_type\" \"VRR\")])\n \n ; reduc_smin\n ; reduc_smax"}, {"sha": "bd0a9b01db387a490acbe9c3a8e61bf79f45fa92", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2de2b3f93b964081665a990a8b5645709302d834", "patch": "@@ -1,3 +1,7 @@\n+2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/vxe/negfma-1.c: New test.\n+\n 2017-03-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/arch12/aghsghmgh-1.c: New test."}, {"sha": "4c976b02495c9a7b486d1b412846cc7995f851a7", "filename": "gcc/testsuite/gcc.target/s390/vxe/negfma-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvxe%2Fnegfma-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de2b3f93b964081665a990a8b5645709302d834/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvxe%2Fnegfma-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvxe%2Fnegfma-1.c?ref=2de2b3f93b964081665a990a8b5645709302d834", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mzarch -march=arch12\" } */\n+\n+typedef float       v4sf __attribute__((vector_size(16)));\n+typedef double      v2df __attribute__((vector_size(16)));\n+typedef long double v1tf __attribute__((vector_size(16)));\n+\n+v4sf\n+neg_vfnmasb (v4sf a, v4sf b, v4sf c)\n+{\n+  return -(a * b + c);\n+}\n+/* { dg-final { scan-assembler-times \"vfnmasb\\t%v24,%v24,%v26,%v28\" 1 } } */\n+\n+v2df\n+neg_vfnmadb (v2df a, v2df b, v2df c)\n+{\n+  return -(a * b + c);\n+}\n+/* { dg-final { scan-assembler-times \"vfnmadb\\t%v24,%v24,%v26,%v28\" 1 } } */\n+\n+v1tf\n+neg_wfnmaxb (v1tf a, v1tf b, v1tf c)\n+{\n+  return -(a * b + c);\n+}\n+/* { dg-final { scan-assembler-times \"wfnmaxb\\t%v24,%v24,%v26,%v28\" 1 } } */\n+\n+\n+v4sf\n+neg_vfnmssb (v4sf a, v4sf b, v4sf c)\n+{\n+  return -(a * b - c);\n+}\n+/* { dg-final { scan-assembler-times \"vfnmssb\\t%v24,%v24,%v26,%v28\" 1 } } */\n+\n+v2df\n+neg_vfnmsdb (v2df a, v2df b, v2df c)\n+{\n+  return -(a * b - c);\n+}\n+/* { dg-final { scan-assembler-times \"vfnmsdb\\t%v24,%v24,%v26,%v28\" 1 } } */\n+\n+v1tf\n+neg_wfnmsxb (v1tf a, v1tf b, v1tf c)\n+{\n+  return -(a * b - c);\n+}\n+/* { dg-final { scan-assembler-times \"wfnmsxb\\t%v24,%v24,%v26,%v28\" 1 } } */"}]}