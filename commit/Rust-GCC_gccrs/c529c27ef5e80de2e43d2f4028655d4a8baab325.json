{"sha": "c529c27ef5e80de2e43d2f4028655d4a8baab325", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUyOWMyN2VmNWU4MGRlMmU0M2QyZjQwMjg2NTVkNGE4YmFhYjMyNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-18T18:59:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-18T18:59:04Z"}, "message": "tree-nested.c (save_tmp_var): New.\n\n        * tree-nested.c (save_tmp_var): New.\n        (struct walk_stmt_info): Add is_lhs.\n        (walk_stmts) <MODIFY_EXPR>: Be more accurate with setting of\n        val_only; set is_lhs.\n        (convert_nonlocal_reference): Use save_tmp_var when is_lhs;\n        clear is_lhs when appropriate.\n        (convert_local_reference): Likewise.\n\nFrom-SVN: r92357", "tree": {"sha": "cc43180a0c7b02ac101ebced1a00c222d34777b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc43180a0c7b02ac101ebced1a00c222d34777b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c529c27ef5e80de2e43d2f4028655d4a8baab325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c529c27ef5e80de2e43d2f4028655d4a8baab325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c529c27ef5e80de2e43d2f4028655d4a8baab325", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c529c27ef5e80de2e43d2f4028655d4a8baab325/comments", "author": null, "committer": null, "parents": [{"sha": "8cd0dbef04ac7763be165345db6570b0861225d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd0dbef04ac7763be165345db6570b0861225d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd0dbef04ac7763be165345db6570b0861225d2"}], "stats": {"total": 70, "additions": 62, "deletions": 8}, "files": [{"sha": "77b5100c7d9f6f9ee6dd75aecdbfcd789ba7b454", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c529c27ef5e80de2e43d2f4028655d4a8baab325/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c529c27ef5e80de2e43d2f4028655d4a8baab325/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c529c27ef5e80de2e43d2f4028655d4a8baab325", "patch": "@@ -1,3 +1,13 @@\n+2004-12-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-nested.c (save_tmp_var): New.\n+\t(struct walk_stmt_info): Add is_lhs.\n+\t(walk_stmts) <MODIFY_EXPR>: Be more accurate with setting of\n+\tval_only; set is_lhs.\n+\t(convert_nonlocal_reference): Use save_tmp_var when is_lhs;\n+\tclear is_lhs when appropriate.\n+\t(convert_local_reference): Likewise.\n+\n 2004-12-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm/ieee754-sf.S (floatdisf): Fix label definition in FPA"}, {"sha": "70b377724706087733faf66cf02ace038dfeffd8", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c529c27ef5e80de2e43d2f4028655d4a8baab325/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c529c27ef5e80de2e43d2f4028655d4a8baab325/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=c529c27ef5e80de2e43d2f4028655d4a8baab325", "patch": "@@ -376,6 +376,23 @@ tsi_gimplify_val (struct nesting_info *info, tree exp, tree_stmt_iterator *tsi)\n     return init_tmp_var (info, exp, tsi);\n }\n \n+/* Similarly, but copy from the temporary and insert the statement\n+   after the iterator.  */\n+\n+static tree\n+save_tmp_var (struct nesting_info *info, tree exp,\n+\t      tree_stmt_iterator *tsi)\n+{\n+  tree t, stmt;\n+\n+  t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n+  stmt = build (MODIFY_EXPR, TREE_TYPE (t), exp, t);\n+  SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n+  tsi_link_after (tsi, stmt, TSI_SAME_STMT);\n+\n+  return t;\n+}\n+\n /* Build or return the type used to represent a nested function trampoline.  */\n \n static GTY(()) tree trampoline_type;\n@@ -517,6 +534,7 @@ struct walk_stmt_info\n   tree_stmt_iterator tsi;\n   struct nesting_info *info;\n   bool val_only;\n+  bool is_lhs;\n   bool changed;\n };\n \n@@ -567,12 +585,18 @@ walk_stmts (struct walk_stmt_info *wi, tree *tp)\n       break;\n \n     case MODIFY_EXPR:\n-      /* The immediate arguments of a MODIFY_EXPR may use COMPONENT_REF.  */\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), wi->callback, wi, NULL);\n-      wi->val_only = false;\n+      /* A formal temporary lhs may use a COMPONENT_REF rhs.  */\n+      wi->val_only = !is_gimple_formal_tmp_var (TREE_OPERAND (t, 0));\n       walk_tree (&TREE_OPERAND (t, 1), wi->callback, wi, NULL);\n+\n+      /* If the rhs is appropriate for a memory, we may use a\n+\t COMPONENT_REF on the lhs.  */\n+      wi->val_only = !is_gimple_mem_rhs (TREE_OPERAND (t, 1));\n+      wi->is_lhs = true;\n+      walk_tree (&TREE_OPERAND (t, 0), wi->callback, wi, NULL);\n+\n       wi->val_only = true;\n+      wi->is_lhs = false;\n       break;\n \n     default:\n@@ -789,8 +813,14 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \t      x = init_tmp_var (info, x, &wi->tsi);\n \t      x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n \t    }\n+\n \t  if (wi->val_only)\n-\t    x = init_tmp_var (info, x, &wi->tsi);\n+\t    {\n+\t      if (wi->is_lhs)\n+\t\tx = save_tmp_var (info, x, &wi->tsi);\n+\t      else\n+\t\tx = init_tmp_var (info, x, &wi->tsi);\n+\t    }\n \n \t  *tp = x;\n \t}\n@@ -802,6 +832,7 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \t{\n \t  *walk_subtrees = 1;\n \t  wi->val_only = true;\n+\t  wi->is_lhs = false;\n \t}\n       break;\n \n@@ -818,8 +849,9 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n       {\n \tbool save_val_only = wi->val_only;\n \n-\twi->changed = false;\n \twi->val_only = false;\n+\twi->is_lhs = false;\n+\twi->changed = false;\n \twalk_tree (&TREE_OPERAND (t, 0), convert_nonlocal_reference, wi, NULL);\n \twi->val_only = true;\n \n@@ -848,6 +880,7 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \t anything that describes the references.  Otherwise, we lose track\n \t of whether a NOP_EXPR or VIEW_CONVERT_EXPR needs a simple value.  */\n       wi->val_only = true;\n+      wi->is_lhs = false;\n       for (; handled_component_p (t); tp = &TREE_OPERAND (t, 0), t = *tp)\n \t{\n \t  if (TREE_CODE (t) == COMPONENT_REF)\n@@ -880,6 +913,7 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \t{\n \t  *walk_subtrees = 1;\n           wi->val_only = true;\n+\t  wi->is_lhs = false;\n \t}\n       break;\n     }\n@@ -922,8 +956,15 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \t  wi->changed = true;\n \n \t  x = get_frame_field (info, info->context, field, &wi->tsi);\n+\n \t  if (wi->val_only)\n-\t    x = init_tmp_var (info, x, &wi->tsi);\n+\t    {\n+\t      if (wi->is_lhs)\n+\t\tx = save_tmp_var (info, x, &wi->tsi);\n+\t      else\n+\t\tx = init_tmp_var (info, x, &wi->tsi);\n+\t    }\n+\n \t  *tp = x;\n \t}\n       break;\n@@ -932,8 +973,9 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n       {\n \tbool save_val_only = wi->val_only;\n \n-\twi->changed = false;\n \twi->val_only = false;\n+\twi->is_lhs = false;\n+\twi->changed = false;\n \twalk_tree (&TREE_OPERAND (t, 0), convert_local_reference, wi, NULL);\n \twi->val_only = save_val_only;\n \n@@ -963,6 +1005,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \t anything that describes the references.  Otherwise, we lose track\n \t of whether a NOP_EXPR or VIEW_CONVERT_EXPR needs a simple value.  */\n       wi->val_only = true;\n+      wi->is_lhs = false;\n       for (; handled_component_p (t); tp = &TREE_OPERAND (t, 0), t = *tp)\n \t{\n \t  if (TREE_CODE (t) == COMPONENT_REF)\n@@ -995,6 +1038,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \t{\n \t  *walk_subtrees = 1;\n \t  wi->val_only = true;\n+\t  wi->is_lhs = false;\n \t}\n       break;\n     }"}]}