{"sha": "6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwYjdjNzAzZGFlNGM1MzdiOGFhMzZjMmQ3MjZkNWMzYTI2ZGZmMA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2007-11-26T06:31:13Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2007-11-26T06:31:13Z"}, "message": "expr.c (build_jni_stub): Use the computed jni func type for variable meth.\n\n* expr.c (build_jni_stub): Use the computed jni func type for\nvariable meth.\n\nFrom-SVN: r130428", "tree": {"sha": "388d0e4a5d91f6f66a30d8c6539033660d785856", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/388d0e4a5d91f6f66a30d8c6539033660d785856"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0/comments", "author": null, "committer": null, "parents": [{"sha": "0ab57536c03b3a35b8eba043414a42f3fb27cac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab57536c03b3a35b8eba043414a42f3fb27cac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ab57536c03b3a35b8eba043414a42f3fb27cac5"}], "stats": {"total": 53, "additions": 32, "deletions": 21}, "files": [{"sha": "65c4482ac3be524a51c2d679eba15d3bae1dd760", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0", "patch": "@@ -1,3 +1,8 @@\n+2007-11-26  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* expr.c (build_jni_stub): Use the computed jni func type for\n+\tvariable meth.\n+\n 2007-11-26  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* class.c (JAVA_TREEHASHHASH_H): Use TYPE_UID."}, {"sha": "a482a96923567b69a44a736adbab893d3ce07e79", "filename": "gcc/java/expr.c", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=6e0b7c703dae4c537b8aa36c2d726d5c3a26dff0", "patch": "@@ -2651,17 +2651,6 @@ build_jni_stub (tree method)\n       TREE_CHAIN (env_var) = res_var;\n     }\n \n-  meth_var = build_decl (VAR_DECL, get_identifier (\"meth\"), ptr_type_node);\n-  TREE_STATIC (meth_var) = 1;\n-  TREE_PUBLIC (meth_var) = 0;\n-  DECL_EXTERNAL (meth_var) = 0;\n-  DECL_CONTEXT (meth_var) = method;\n-  DECL_ARTIFICIAL (meth_var) = 1;\n-  DECL_INITIAL (meth_var) = null_pointer_node;\n-  TREE_USED (meth_var) = 1;\n-  chainon (env_var, meth_var);\n-  build_result_decl (method);\n-\n   method_args = DECL_ARGUMENTS (method);\n   block = build_block (env_var, NULL_TREE, method_args, NULL_TREE);\n   TREE_SIDE_EFFECTS (block) = 1;\n@@ -2725,23 +2714,40 @@ build_jni_stub (tree method)\n \n   jni_func_type = build_pointer_type (tem);\n \n-  jnifunc = build3 (COND_EXPR, ptr_type_node,\n+  /* Use the actual function type, rather than a generic pointer type,\n+     such that this decl keeps the actual pointer type from being\n+     garbage-collected.  If it is, we end up using canonical types\n+     with different uids for equivalent function types, and this in\n+     turn causes utf8 identifiers and output order to vary.  */\n+  meth_var = build_decl (VAR_DECL, get_identifier (\"meth\"), jni_func_type);\n+  TREE_STATIC (meth_var) = 1;\n+  TREE_PUBLIC (meth_var) = 0;\n+  DECL_EXTERNAL (meth_var) = 0;\n+  DECL_CONTEXT (meth_var) = method;\n+  DECL_ARTIFICIAL (meth_var) = 1;\n+  DECL_INITIAL (meth_var) = null_pointer_node;\n+  TREE_USED (meth_var) = 1;\n+  chainon (env_var, meth_var);\n+  build_result_decl (method);\n+\n+  jnifunc = build3 (COND_EXPR, jni_func_type,\n \t\t    build2 (NE_EXPR, boolean_type_node,\n \t\t\t    meth_var, build_int_cst (TREE_TYPE (meth_var), 0)),\n \t\t    meth_var,\n-\t\t    build2 (MODIFY_EXPR, ptr_type_node, meth_var,\n-\t\t\t    build_call_nary (ptr_type_node,\n-\t\t\t\t\t     build_address_of\n-\t\t\t\t\t       (soft_lookupjnimethod_node),\n-\t\t\t\t\t     4,\n-\t\t\t\t\t     jniarg0, jniarg1,\n-\t\t\t\t\t     jniarg2, jniarg3)));\n+\t\t    build2 (MODIFY_EXPR, jni_func_type, meth_var,\n+\t\t\t    build1\n+\t\t\t    (NOP_EXPR, jni_func_type,\n+\t\t\t     build_call_nary (ptr_type_node,\n+\t\t\t\t\t      build_address_of\n+\t\t\t\t\t      (soft_lookupjnimethod_node),\n+\t\t\t\t\t      4,\n+\t\t\t\t\t      jniarg0, jniarg1,\n+\t\t\t\t\t      jniarg2, jniarg3))));\n \n   /* Now we make the actual JNI call via the resulting function\n      pointer.    */\n   call = build_call_list (TREE_TYPE (TREE_TYPE (method)),\n-\t\t\t  build1 (NOP_EXPR, jni_func_type, jnifunc),\n-\t\t\t  args);\n+\t\t\t  jnifunc, args);\n \n   /* If the JNI call returned a result, capture it here.  If we had to\n      unwrap JNI object results, we would do that here.  */"}]}