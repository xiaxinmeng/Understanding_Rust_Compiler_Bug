{"sha": "0edd264dfc29db3c30641771d46634b4ef3ffe10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVkZDI2NGRmYzI5ZGIzYzMwNjQxNzcxZDQ2NjM0YjRlZjNmZmUxMA==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.vnet.ibm.com", "date": "2017-01-18T20:56:16Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2017-01-18T20:56:16Z"}, "message": "rs6000-protos.h (expand_strn_compare): Add arg.\n\n2017-01-18  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n\t* config/rs6000/rs6000-protos.h (expand_strn_compare): Add arg.\n\t* config/rs6000/rs6000.c (expand_strn_compare): Add ability to expand\n\tstrcmp. Fix bug where comparison didn't stop with zero byte. Fix\n\tcase where N arg is SIZE_MAX.\n\t* config/rs6000/rs6000.md (cmpstrnsi): Args to expand_strn_compare.\n\t(cmpstrsi): Add pattern.\n2017-01-18  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n\t* gcc.dg/strcmp-1.c: New test.\n\t* gcc.dg/strncmp-1.c: Add test for a bug that escaped.\n\nFrom-SVN: r244598", "tree": {"sha": "7b74e876028ea84d7f5106ead28c3723393320c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b74e876028ea84d7f5106ead28c3723393320c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0edd264dfc29db3c30641771d46634b4ef3ffe10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0edd264dfc29db3c30641771d46634b4ef3ffe10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0edd264dfc29db3c30641771d46634b4ef3ffe10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0edd264dfc29db3c30641771d46634b4ef3ffe10/comments", "author": null, "committer": null, "parents": [{"sha": "551914b748a9bafe51ed7192c3e7b3d4366211bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551914b748a9bafe51ed7192c3e7b3d4366211bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/551914b748a9bafe51ed7192c3e7b3d4366211bb"}], "stats": {"total": 1045, "additions": 934, "deletions": 111}, "files": [{"sha": "77732e9a7d095d58d82823e6820d22c9086cc2bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0edd264dfc29db3c30641771d46634b4ef3ffe10", "patch": "@@ -1,3 +1,11 @@\n+2017-01-18  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n+\t* config/rs6000/rs6000-protos.h (expand_strn_compare): Add arg.\n+\t* config/rs6000/rs6000.c (expand_strn_compare): Add ability to expand\n+\tstrcmp. Fix bug where comparison didn't stop with zero byte. Fix\n+\tcase where N arg is SIZE_MAX.\n+\t* config/rs6000/rs6000.md (cmpstrnsi): Args to expand_strn_compare.\n+\t(cmpstrsi): Add pattern.\n+\n 2017-01-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add"}, {"sha": "0b18994df4068da7907f1149fd632a0623ce6821", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=0edd264dfc29db3c30641771d46634b4ef3ffe10", "patch": "@@ -78,7 +78,7 @@ extern void rs6000_scale_v2df (rtx, rtx, int);\n extern int expand_block_clear (rtx[]);\n extern int expand_block_move (rtx[]);\n extern bool expand_block_compare (rtx[]);\n-extern bool expand_strn_compare (rtx[]);\n+extern bool expand_strn_compare (rtx[], int);\n extern const char * rs6000_output_load_multiple (rtx[]);\n extern bool rs6000_is_valid_mask (rtx, int *, int *, machine_mode);\n extern bool rs6000_is_valid_and_mask (rtx, machine_mode);"}, {"sha": "44d18e97f6d3c5e9a9453d69c7e18f9f02ff9607", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 235, "deletions": 83, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0edd264dfc29db3c30641771d46634b4ef3ffe10", "patch": "@@ -19355,8 +19355,9 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n    WORD_MODE_OK indicates using WORD_MODE is allowed, else SImode is\n    the largest allowable mode.  */\n static machine_mode\n-select_block_compare_mode (HOST_WIDE_INT offset, HOST_WIDE_INT bytes,\n-\t\t\t   HOST_WIDE_INT align, bool word_mode_ok)\n+select_block_compare_mode (unsigned HOST_WIDE_INT offset,\n+\t\t\t   unsigned HOST_WIDE_INT bytes,\n+\t\t\t   unsigned HOST_WIDE_INT align, bool word_mode_ok)\n {\n   /* First see if we can do a whole load unit\n      as that will be more efficient than a larger load + shift.  */\n@@ -19367,7 +19368,7 @@ select_block_compare_mode (HOST_WIDE_INT offset, HOST_WIDE_INT bytes,\n      Do largest chunk possible without violating alignment rules.  */\n \n   /* The most we can read without potential page crossing.  */\n-  HOST_WIDE_INT maxread = ROUND_UP (bytes, align);\n+  unsigned HOST_WIDE_INT maxread = ROUND_UP (bytes, align);\n \n   if (word_mode_ok && bytes >= UNITS_PER_WORD)\n     return word_mode;\n@@ -19408,8 +19409,9 @@ select_block_compare_mode (HOST_WIDE_INT offset, HOST_WIDE_INT bytes,\n \n /* Compute the alignment of pointer+OFFSET where the original alignment\n    of pointer was BASE_ALIGN.  */\n-static HOST_WIDE_INT\n-compute_current_alignment (HOST_WIDE_INT base_align, HOST_WIDE_INT offset)\n+static unsigned HOST_WIDE_INT\n+compute_current_alignment (unsigned HOST_WIDE_INT base_align,\n+\t\t\t   unsigned HOST_WIDE_INT offset)\n {\n   if (offset == 0)\n     return base_align;\n@@ -19445,7 +19447,7 @@ expand_block_compare (rtx operands[])\n   if (!CONST_INT_P (align_rtx))\n     return false;\n \n-  int base_align = INTVAL (align_rtx) / BITS_PER_UNIT;\n+  unsigned int base_align = UINTVAL (align_rtx) / BITS_PER_UNIT;\n \n   /* SLOW_UNALIGNED_ACCESS -- don't do unaligned stuff */\n   if (SLOW_UNALIGNED_ACCESS (word_mode, MEM_ALIGN (orig_src1))\n@@ -19455,8 +19457,8 @@ expand_block_compare (rtx operands[])\n   gcc_assert (GET_MODE (target) == SImode);\n \n   /* Anything to move? */\n-  HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n-  if (bytes <= 0)\n+  unsigned HOST_WIDE_INT bytes = UINTVAL (bytes_rtx);\n+  if (bytes == 0)\n     return true;\n \n   /* The code generated for p7 and older is not faster than glibc\n@@ -19477,14 +19479,14 @@ expand_block_compare (rtx operands[])\n \n   /* Strategy phase.  How many ops will this take and should we expand it?  */\n \n-  int offset = 0;\n+  unsigned HOST_WIDE_INT offset = 0;\n   machine_mode load_mode =\n     select_block_compare_mode (offset, bytes, base_align, word_mode_ok);\n-  int load_mode_size = GET_MODE_SIZE (load_mode);\n+  unsigned int load_mode_size = GET_MODE_SIZE (load_mode);\n \n   /* We don't want to generate too much code.  */\n   if (ROUND_UP (bytes, load_mode_size) / load_mode_size\n-      > rs6000_block_compare_inline_limit)\n+      > (unsigned HOST_WIDE_INT) rs6000_block_compare_inline_limit)\n     return false;\n \n   bool generate_6432_conversion = false;\n@@ -19515,7 +19517,7 @@ expand_block_compare (rtx operands[])\n \n   while (bytes > 0)\n     {\n-      int align = compute_current_alignment (base_align, offset);\n+      unsigned int align = compute_current_alignment (base_align, offset);\n       if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n \tload_mode = select_block_compare_mode (offset, bytes, align,\n \t\t\t\t\t       word_mode_ok);\n@@ -19528,7 +19530,7 @@ expand_block_compare (rtx operands[])\n \t{\n \t  /* Move this load back so it doesn't go past the end.\n \t     P8/P9 can do this efficiently.  */\n-\t  int extra_bytes = load_mode_size - bytes;\n+\t  unsigned int extra_bytes = load_mode_size - bytes;\n \t  cmp_bytes = bytes;\n \t  if (extra_bytes < offset)\n \t    {\n@@ -19542,7 +19544,7 @@ expand_block_compare (rtx operands[])\n \t   so this forces a non-overlapping load and a shift to get\n \t   rid of the extra bytes.  */\n \tcmp_bytes = bytes;\n-      \n+\n       src1 = adjust_address (orig_src1, load_mode, offset);\n       src2 = adjust_address (orig_src2, load_mode, offset);\n \n@@ -19727,29 +19729,43 @@ expand_strncmp_align_check (rtx strncmp_label, rtx src, HOST_WIDE_INT bytes)\n    OPERANDS[0] is the target (result).\n    OPERANDS[1] is the first source.\n    OPERANDS[2] is the second source.\n+   If NO_LENGTH is zero, then:\n    OPERANDS[3] is the length.\n-   OPERANDS[4] is the alignment in bytes.  */\n+   OPERANDS[4] is the alignment in bytes.\n+   If NO_LENGTH is nonzero, then:\n+   OPERANDS[3] is the alignment in bytes.  */\n bool\n-expand_strn_compare (rtx operands[])\n+expand_strn_compare (rtx operands[], int no_length)\n {\n   rtx target = operands[0];\n   rtx orig_src1 = operands[1];\n   rtx orig_src2 = operands[2];\n-  rtx bytes_rtx = operands[3];\n-  rtx align_rtx = operands[4];\n-  HOST_WIDE_INT cmp_bytes = 0;\n+  rtx bytes_rtx, align_rtx;\n+  if (no_length)\n+    {\n+      bytes_rtx = NULL;\n+      align_rtx = operands[3];\n+    }\n+  else\n+    {\n+      bytes_rtx = operands[3];\n+      align_rtx = operands[4];\n+    }\n+  unsigned HOST_WIDE_INT cmp_bytes = 0;\n   rtx src1 = orig_src1;\n   rtx src2 = orig_src2;\n \n-  /* If this is not a fixed size compare, just call strncmp.  */\n-  if (!CONST_INT_P (bytes_rtx))\n+  /* If we have a length, it must be constant. This simplifies things\n+     a bit as we don't have to generate code to check if we've exceeded\n+     the length. Later this could be expanded to handle this case.  */\n+  if (!no_length && !CONST_INT_P (bytes_rtx))\n     return false;\n \n   /* This must be a fixed size alignment.  */\n   if (!CONST_INT_P (align_rtx))\n     return false;\n \n-  int base_align = INTVAL (align_rtx);\n+  unsigned int base_align = UINTVAL (align_rtx);\n   int align1 = MEM_ALIGN (orig_src1) / BITS_PER_UNIT;\n   int align2 = MEM_ALIGN (orig_src2) / BITS_PER_UNIT;\n \n@@ -19760,25 +19776,44 @@ expand_strn_compare (rtx operands[])\n \n   gcc_assert (GET_MODE (target) == SImode);\n \n-  HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n-\n   /* If we have an LE target without ldbrx and word_mode is DImode,\n      then we must avoid using word_mode.  */\n   int word_mode_ok = !(!BYTES_BIG_ENDIAN && !TARGET_LDBRX\n \t\t       && word_mode == DImode);\n \n-  int word_mode_size = GET_MODE_SIZE (word_mode);\n+  unsigned int word_mode_size = GET_MODE_SIZE (word_mode);\n+\n+  unsigned HOST_WIDE_INT offset = 0;\n+  unsigned HOST_WIDE_INT bytes; /* N from the strncmp args if available.  */\n+  unsigned HOST_WIDE_INT compare_length; /* How much to compare inline.  */\n+  if (no_length)\n+    /* Use this as a standin to determine the mode to use.  */\n+    bytes = rs6000_string_compare_inline_limit * word_mode_size;\n+  else\n+    bytes = UINTVAL (bytes_rtx);\n \n-  int offset = 0;\n   machine_mode load_mode =\n     select_block_compare_mode (offset, bytes, base_align, word_mode_ok);\n-  int load_mode_size = GET_MODE_SIZE (load_mode);\n+  unsigned int load_mode_size = GET_MODE_SIZE (load_mode);\n+  compare_length = rs6000_string_compare_inline_limit * load_mode_size;\n \n-  /* We don't want to generate too much code.  Also if bytes is\n-     4096 or larger we always want the library strncmp anyway.  */\n-  int groups = ROUND_UP (bytes, load_mode_size) / load_mode_size;\n-  if (bytes >= 4096 || groups > rs6000_string_compare_inline_limit)\n-    return false;\n+  /* If we have equality at the end of the last compare and we have not\n+     found the end of the string, we need to call strcmp/strncmp to\n+     compare the remainder.  */\n+  bool equality_compare_rest = false;\n+\n+  if (no_length)\n+    {\n+      bytes = compare_length;\n+      equality_compare_rest = true;\n+    }\n+  else\n+    {\n+      if (bytes <= compare_length)\n+\tcompare_length = bytes;\n+      else\n+\tequality_compare_rest = true;\n+    }\n \n   rtx result_reg = gen_reg_rtx (word_mode);\n   rtx final_move_label = gen_label_rtx ();\n@@ -19798,9 +19833,13 @@ expand_strn_compare (rtx operands[])\n \t bgt\tcr7,L(pagecross) */\n \n       if (align1 < 8)\n-\texpand_strncmp_align_check (strncmp_label, src1, bytes);\n+\texpand_strncmp_align_check (strncmp_label, src1, compare_length);\n       if (align2 < 8)\n-\texpand_strncmp_align_check (strncmp_label, src2, bytes);\n+\texpand_strncmp_align_check (strncmp_label, src2, compare_length);\n+\n+      /* After the runtime alignment checks, we can use any alignment we\n+\t like as we know there is no 4k boundary crossing.  */\n+      base_align = 8;\n \n       /* Now generate the following sequence:\n \t - branch to begin_compare\n@@ -19811,7 +19850,7 @@ expand_strn_compare (rtx operands[])\n \n       rtx cmp_ref = gen_rtx_LABEL_REF (VOIDmode, begin_compare_label);\n       jmp = emit_jump_insn (gen_rtx_SET (pc_rtx, cmp_ref));\n-      JUMP_LABEL(jmp) = begin_compare_label;\n+      JUMP_LABEL (jmp) = begin_compare_label;\n       LABEL_NUSES (begin_compare_label) += 1;\n       emit_barrier ();\n \n@@ -19829,22 +19868,30 @@ expand_strn_compare (rtx operands[])\n \t  src2 = replace_equiv_address (src2, src2_reg);\n \t}\n \n-      /* -m32 -mpowerpc64 results in word_mode being DImode even\n-\t though otherwise it is 32-bit. The length arg to strncmp\n-\t is a size_t which will be the same size as pointers.  */\n-      rtx len_rtx;\n-      if (TARGET_64BIT)\n-\tlen_rtx = gen_reg_rtx(DImode);\n+      if (no_length)\n+\temit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \"strcmp\"),\n+\t\t\t\t target, LCT_NORMAL, GET_MODE (target), 2,\n+\t\t\t\t force_reg (Pmode, XEXP (src1, 0)), Pmode,\n+\t\t\t\t force_reg (Pmode, XEXP (src2, 0)), Pmode);\n       else\n-\tlen_rtx = gen_reg_rtx(SImode);\n+\t{\n+\t  /* -m32 -mpowerpc64 results in word_mode being DImode even\n+\t     though otherwise it is 32-bit. The length arg to strncmp\n+\t     is a size_t which will be the same size as pointers.  */\n+\t  rtx len_rtx;\n+\t  if (TARGET_64BIT)\n+\t    len_rtx = gen_reg_rtx (DImode);\n+\t  else\n+\t    len_rtx = gen_reg_rtx (SImode);\n \n-      emit_move_insn (len_rtx, bytes_rtx);\n+\t  emit_move_insn (len_rtx, bytes_rtx);\n \n-      emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \"strncmp\"),\n-\t\t\t       target, LCT_NORMAL, GET_MODE (target), 3,\n-\t\t\t       force_reg (Pmode, XEXP (src1, 0)), Pmode,\n-\t\t\t       force_reg (Pmode, XEXP (src2, 0)), Pmode,\n-\t\t\t       len_rtx, GET_MODE (len_rtx));\n+\t  emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \"strncmp\"),\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 3,\n+\t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n+\t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode,\n+\t\t\t\t   len_rtx, GET_MODE (len_rtx));\n+\t}\n \n       rtx fin_ref = gen_rtx_LABEL_REF (VOIDmode, final_label);\n       jmp = emit_jump_insn (gen_rtx_SET (pc_rtx, fin_ref));\n@@ -19860,10 +19907,12 @@ expand_strn_compare (rtx operands[])\n \n   /* Generate sequence of ld/ldbrx, cmpb to compare out\n      to the length specified.  */\n-  while (bytes > 0)\n+  unsigned HOST_WIDE_INT bytes_to_compare = compare_length;\n+  while (bytes_to_compare > 0)\n     {\n       /* Compare sequence:\n          check each 8B with: ld/ld cmpd bne\n+\t If equal, use rldicr/cmpb to check for zero byte.\n          cleanup code at end:\n          cmpb          get byte that differs\n          cmpb          look for zero byte\n@@ -19875,33 +19924,34 @@ expand_strn_compare (rtx operands[])\n \n          The last compare can branch around the cleanup code if the\n          result is zero because the strings are exactly equal.  */\n-      int align = compute_current_alignment (base_align, offset);\n+      unsigned int align = compute_current_alignment (base_align, offset);\n       if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n-\tload_mode = select_block_compare_mode (offset, bytes, align,\n+\tload_mode = select_block_compare_mode (offset, bytes_to_compare, align,\n \t\t\t\t\t       word_mode_ok);\n       else\n-\tload_mode = select_block_compare_mode (0, bytes, align, word_mode_ok);\n+\tload_mode = select_block_compare_mode (0, bytes_to_compare, align,\n+\t\t\t\t\t       word_mode_ok);\n       load_mode_size = GET_MODE_SIZE (load_mode);\n-      if (bytes >= load_mode_size)\n+      if (bytes_to_compare >= load_mode_size)\n \tcmp_bytes = load_mode_size;\n       else if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n \t{\n \t  /* Move this load back so it doesn't go past the end.\n \t     P8/P9 can do this efficiently.  */\n-\t  int extra_bytes = load_mode_size - bytes;\n-\t  cmp_bytes = bytes;\n+\t  unsigned int extra_bytes = load_mode_size - bytes_to_compare;\n+\t  cmp_bytes = bytes_to_compare;\n \t  if (extra_bytes < offset)\n \t    {\n \t      offset -= extra_bytes;\n \t      cmp_bytes = load_mode_size;\n-\t      bytes = cmp_bytes;\n+\t      bytes_to_compare = cmp_bytes;\n \t    }\n \t}\n       else\n \t/* P7 and earlier can't do the overlapping load trick fast,\n \t   so this forces a non-overlapping load and a shift to get\n \t   rid of the extra bytes.  */\n-\tcmp_bytes = bytes;\n+\tcmp_bytes = bytes_to_compare;\n \n       src1 = adjust_address (orig_src1, load_mode, offset);\n       src2 = adjust_address (orig_src2, load_mode, offset);\n@@ -19964,46 +20014,148 @@ expand_strn_compare (rtx operands[])\n \t    }\n \t}\n \n-      int remain = bytes - cmp_bytes;\n+      /* Cases to handle.  A and B are chunks of the two strings.\n+\t 1: Not end of comparison:\n+\t A != B: branch to cleanup code to compute result.\n+\t A == B: check for 0 byte, next block if not found.\n+\t 2: End of the inline comparison:\n+\t A != B: branch to cleanup code to compute result.\n+\t A == B: check for 0 byte, call strcmp/strncmp\n+\t 3: compared requested N bytes:\n+\t A == B: branch to result 0.\n+\t A != B: cleanup code to compute result.  */\n+\n+      unsigned HOST_WIDE_INT remain = bytes_to_compare - cmp_bytes;\n \n       rtx dst_label;\n-      if (remain > 0)\n+      if (remain > 0 || equality_compare_rest)\n \t{\n+\t  /* Branch to cleanup code, otherwise fall through to do\n+\t     more compares.  */\n \t  if (!cleanup_label)\n \t    cleanup_label = gen_label_rtx ();\n \t  dst_label = cleanup_label;\n \t}\n       else\n+\t/* Branch to end and produce result of 0.  */\n \tdst_label = final_move_label;\n \n       rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, dst_label);\n       rtx cond = gen_reg_rtx (CCmode);\n \n-      if (remain == 0)\n-\t{\n-\t  /* For the last chunk, subf. also\n-\t     generates the zero result we need.  */\n-\t  rtx tmp = gen_rtx_MINUS (word_mode, tmp_reg_src1, tmp_reg_src2);\n-\t  rs6000_emit_dot_insn (result_reg, tmp, 1, cond);\n-\t}\n-      else\n-\temit_move_insn (cond, gen_rtx_COMPARE (CCmode,\n-\t\t\t\t\t       tmp_reg_src1, tmp_reg_src2));\n+      /* Always produce the 0 result, it is needed if\n+\t cmpb finds a 0 byte in this chunk.  */\n+      rtx tmp = gen_rtx_MINUS (word_mode, tmp_reg_src1, tmp_reg_src2);\n+      rs6000_emit_dot_insn (result_reg, tmp, 1, cond);\n \n       rtx cmp_rtx;\n-      if (remain > 0)\n-\tcmp_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n-      else\n+      if (remain == 0 && !equality_compare_rest)\n \tcmp_rtx = gen_rtx_EQ (VOIDmode, cond, const0_rtx);\n+      else\n+\tcmp_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n \n       rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n \t\t\t\t\t lab_ref, pc_rtx);\n       rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n       JUMP_LABEL (j) = dst_label;\n       LABEL_NUSES (dst_label) += 1;\n \n+      if (remain > 0 || equality_compare_rest)\n+\t{\n+\t  /* Generate a cmpb to test for a 0 byte and branch\n+\t     to final result if found.  */\n+\t  rtx cmpb_zero = gen_reg_rtx (word_mode);\n+\t  rtx lab_ref_fin = gen_rtx_LABEL_REF (VOIDmode, final_move_label);\n+\t  rtx condz = gen_reg_rtx (CCmode);\n+\t  rtx zero_reg = gen_reg_rtx (word_mode);\n+\t  if (word_mode == SImode)\n+\t    {\n+\t      emit_insn (gen_movsi (zero_reg, GEN_INT (0)));\n+\t      emit_insn (gen_cmpbsi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n+\t      if (cmp_bytes < word_mode_size)\n+\t\t{\n+\t\t  /* Don't want to look at zero bytes past end.  */\n+\t\t  HOST_WIDE_INT mb =\n+\t\t    BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n+\t\t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n+\t\t  emit_insn (gen_andsi3_mask (cmpb_zero, cmpb_zero, mask));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_movdi (zero_reg, GEN_INT (0)));\n+\t      emit_insn (gen_cmpbdi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n+\t      if (cmp_bytes < word_mode_size)\n+\t\t{\n+\t\t  /* Don't want to look at zero bytes past end.  */\n+\t\t  HOST_WIDE_INT mb =\n+\t\t    BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n+\t\t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n+\t\t  emit_insn (gen_anddi3_mask (cmpb_zero, cmpb_zero, mask));\n+\t\t}\n+\t    }\n+\n+\t  emit_move_insn (condz, gen_rtx_COMPARE (CCmode, cmpb_zero, zero_reg));\n+\t  rtx cmpnz_rtx = gen_rtx_NE (VOIDmode, condz, const0_rtx);\n+\t  rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmpnz_rtx,\n+\t\t\t\t\t     lab_ref_fin, pc_rtx);\n+\t  rtx j2 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t  JUMP_LABEL (j2) = final_move_label;\n+\t  LABEL_NUSES (final_move_label) += 1;\n+\n+\t}\n+\n       offset += cmp_bytes;\n-      bytes -= cmp_bytes;\n+      bytes_to_compare -= cmp_bytes;\n+    }\n+\n+  if (equality_compare_rest)\n+    {\n+      /* Update pointers past what has been compared already.  */\n+      src1 = adjust_address (orig_src1, load_mode, offset);\n+      src2 = adjust_address (orig_src2, load_mode, offset);\n+\n+      if (!REG_P (XEXP (src1, 0)))\n+\t{\n+\t  rtx src1_reg = copy_addr_to_reg (XEXP (src1, 0));\n+\t  src1 = replace_equiv_address (src1, src1_reg);\n+\t}\n+      set_mem_size (src1, cmp_bytes);\n+\n+      if (!REG_P (XEXP (src2, 0)))\n+\t{\n+\t  rtx src2_reg = copy_addr_to_reg (XEXP (src2, 0));\n+\t  src2 = replace_equiv_address (src2, src2_reg);\n+\t}\n+      set_mem_size (src2, cmp_bytes);\n+\n+      /* Construct call to strcmp/strncmp to compare the rest of the string.  */\n+      if (no_length)\n+\temit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \"strcmp\"),\n+\t\t\t\t target, LCT_NORMAL, GET_MODE (target), 2,\n+\t\t\t\t force_reg (Pmode, XEXP (src1, 0)), Pmode,\n+\t\t\t\t force_reg (Pmode, XEXP (src2, 0)), Pmode);\n+      else\n+\t{\n+\t  rtx len_rtx;\n+\t  if (TARGET_64BIT)\n+\t    len_rtx = gen_reg_rtx (DImode);\n+\t  else\n+\t    len_rtx = gen_reg_rtx (SImode);\n+\n+\t  emit_move_insn (len_rtx, GEN_INT (bytes - compare_length));\n+\t  emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \"strncmp\"),\n+\t\t\t\t   target, LCT_NORMAL, GET_MODE (target), 3,\n+\t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n+\t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode,\n+\t\t\t\t   len_rtx, GET_MODE (len_rtx));\n+\t}\n+\n+      rtx fin_ref = gen_rtx_LABEL_REF (VOIDmode, final_label);\n+      rtx jmp = emit_jump_insn (gen_rtx_SET (pc_rtx, fin_ref));\n+      JUMP_LABEL (jmp) = final_label;\n+      LABEL_NUSES (final_label) += 1;\n+      emit_barrier ();\n     }\n \n   if (cleanup_label)\n@@ -20027,43 +20179,43 @@ expand_strn_compare (rtx operands[])\n   rtx rot_amt = gen_reg_rtx (word_mode);\n   rtx zero_reg = gen_reg_rtx (word_mode);\n \n-  rtx rot1_1 = gen_reg_rtx(word_mode);\n-  rtx rot1_2 = gen_reg_rtx(word_mode);\n-  rtx rot2_1 = gen_reg_rtx(word_mode);\n-  rtx rot2_2 = gen_reg_rtx(word_mode);\n+  rtx rot1_1 = gen_reg_rtx (word_mode);\n+  rtx rot1_2 = gen_reg_rtx (word_mode);\n+  rtx rot2_1 = gen_reg_rtx (word_mode);\n+  rtx rot2_2 = gen_reg_rtx (word_mode);\n \n   if (word_mode == SImode)\n     {\n       emit_insn (gen_cmpbsi3 (cmpb_diff, tmp_reg_src1, tmp_reg_src2));\n-      emit_insn (gen_movsi (zero_reg, GEN_INT(0)));\n+      emit_insn (gen_movsi (zero_reg, GEN_INT (0)));\n       emit_insn (gen_cmpbsi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n       emit_insn (gen_one_cmplsi2 (cmpb_diff,cmpb_diff));\n       emit_insn (gen_iorsi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n       emit_insn (gen_clzsi2 (rot_amt, cmpb_diff));\n       emit_insn (gen_addsi3 (rot_amt, rot_amt, GEN_INT (8)));\n       emit_insn (gen_rotlsi3 (rot1_1, tmp_reg_src1,\n \t\t\t      gen_lowpart (SImode, rot_amt)));\n-      emit_insn (gen_andsi3_mask (rot1_2, rot1_1, GEN_INT(0xff)));\n+      emit_insn (gen_andsi3_mask (rot1_2, rot1_1, GEN_INT (0xff)));\n       emit_insn (gen_rotlsi3 (rot2_1, tmp_reg_src2,\n \t\t\t      gen_lowpart (SImode, rot_amt)));\n-      emit_insn (gen_andsi3_mask (rot2_2, rot2_1, GEN_INT(0xff)));\n+      emit_insn (gen_andsi3_mask (rot2_2, rot2_1, GEN_INT (0xff)));\n       emit_insn (gen_subsi3 (result_reg, rot1_2, rot2_2));\n     }\n   else\n     {\n       emit_insn (gen_cmpbdi3 (cmpb_diff, tmp_reg_src1, tmp_reg_src2));\n-      emit_insn (gen_movdi (zero_reg, GEN_INT(0)));\n+      emit_insn (gen_movdi (zero_reg, GEN_INT (0)));\n       emit_insn (gen_cmpbdi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n       emit_insn (gen_one_cmpldi2 (cmpb_diff,cmpb_diff));\n       emit_insn (gen_iordi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n       emit_insn (gen_clzdi2 (rot_amt, cmpb_diff));\n       emit_insn (gen_adddi3 (rot_amt, rot_amt, GEN_INT (8)));\n       emit_insn (gen_rotldi3 (rot1_1, tmp_reg_src1,\n \t\t\t      gen_lowpart (SImode, rot_amt)));\n-      emit_insn (gen_anddi3_mask (rot1_2, rot1_1, GEN_INT(0xff)));\n+      emit_insn (gen_anddi3_mask (rot1_2, rot1_1, GEN_INT (0xff)));\n       emit_insn (gen_rotldi3 (rot2_1, tmp_reg_src2,\n \t\t\t      gen_lowpart (SImode, rot_amt)));\n-      emit_insn (gen_anddi3_mask (rot2_2, rot2_1, GEN_INT(0xff)));\n+      emit_insn (gen_anddi3_mask (rot2_2, rot2_1, GEN_INT (0xff)));\n       emit_insn (gen_subdi3 (result_reg, rot1_2, rot2_2));\n     }\n "}, {"sha": "9ef3b11d12a4fd416af5d0b6db68a1a7c3157c56", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0edd264dfc29db3c30641771d46634b4ef3ffe10", "patch": "@@ -9102,7 +9102,26 @@\n \t      (use (match_operand:SI 4))])]\n   \"TARGET_CMPB && (BYTES_BIG_ENDIAN || TARGET_LDBRX)\"\n {\n-  if (expand_strn_compare (operands))\n+  if (expand_strn_compare (operands, 0))\n+    DONE;\n+  else\t\n+    FAIL;\n+})\n+\n+;; String compare insn.\n+;; Argument 0 is the target (result)\n+;; Argument 1 is the destination\n+;; Argument 2 is the source\n+;; Argument 3 is the alignment\n+\n+(define_expand \"cmpstrsi\"\n+  [(parallel [(set (match_operand:SI 0)\n+               (compare:SI (match_operand:BLK 1)\n+                           (match_operand:BLK 2)))\n+\t      (use (match_operand:SI 3))])]\n+  \"TARGET_CMPB && (BYTES_BIG_ENDIAN || TARGET_LDBRX)\"\n+{\n+  if (expand_strn_compare (operands, 1))\n     DONE;\n   else\t\n     FAIL;"}, {"sha": "bd946aa53a2eb9d639db694b07a02fbdc29d773b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0edd264dfc29db3c30641771d46634b4ef3ffe10", "patch": "@@ -1,3 +1,7 @@\n+2017-01-18  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n+\t* gcc.dg/strcmp-1.c: New test.\n+\t* gcc.dg/strncmp-1.c: Add test for a bug that escaped.\n+\n 2017-01-18  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit.dg/test-threads.c (dejagnu_pass): Remove decl."}, {"sha": "c5b4db9fe30c571f4d978f64d38849e87e5ec7b9", "filename": "gcc/testsuite/gcc.dg/strcmp-1.c", "status": "added", "additions": 635, "deletions": 0, "changes": 635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmp-1.c?ref=0edd264dfc29db3c30641771d46634b4ef3ffe10", "patch": "@@ -0,0 +1,635 @@\n+/* Test strcmp builtin expansion for compilation and proper execution.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target ptr32plus } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define RUN_TEST(SZ, ALIGN) test_strcmp_ ## SZ ## _ ## ALIGN ()\n+\n+#define DEF_TEST(SZ, ALIGN)                                                 \\\n+static void test_strcmp_ ## SZ ## _ ## ALIGN (void) {     \t\t    \\\n+  char one[3 * (SZ > 10 ? SZ : 10)];\t\t\t\t\t    \\\n+  char two[3 * (SZ > 10 ? SZ : 10)];\t\t\t\t\t    \\\n+  char three[8192] __attribute__ ((aligned (4096)));       \t\t    \\\n+  char four[8192] __attribute__ ((aligned (4096)));        \t\t    \\\n+  int i,j;                                                                  \\\n+  memset(one,0,sizeof(one));\t\t\t\t   \t\t    \\\n+  memset(two,0,sizeof(two));\t\t\t\t   \t\t    \\\n+  memset(three,0,sizeof(three));\t\t\t   \t\t    \\\n+  memset(four,0,sizeof(four));\t\t\t\t   \t\t    \\\n+  for (i = 0 ; i < SZ ; i++)\t\t\t   \t\t            \\\n+    {\t\t\t\t\t\t\t   \t\t    \\\n+      int r1;\t\t\t\t\t           \t\t    \\\n+      char *a = one + (i & 1) * ALIGN;\t\t\t   \t\t    \\\n+      char *b = two + (i & 1) * ALIGN;\t\t\t   \t\t    \\\n+      memset(a, '-', SZ);\t\t\t\t\t   \t    \\\n+      memset(b, '-', SZ);\t\t\t\t\t   \t    \\\n+      a[i] = '1';\t\t\t\t\t   \t\t    \\\n+      b[i] = '2';\t\t\t\t\t   \t\t    \\\n+      a[SZ] = 0;\t\t\t\t\t\t\t    \\\n+      b[SZ] = 0;\t\t\t\t\t   \t\t    \\\n+      if (!((r1 = strcmp (b, a)) > 0))   \t\t   \t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      if (!((r1 = strcmp (a, b)) < 0))\t\t\t   \t            \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      b[i] = '1';\t\t\t\t\t   \t\t    \\\n+      if (!((r1 = strcmp (a, b)) == 0))\t\t   \t\t            \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      for(j = i; j < SZ ; j++)\t\t\t   \t\t            \\\n+\t{\t\t\t\t\t\t   \t\t    \\\n+\t  a[j] = '1';            \t\t\t   \t\t    \\\n+\t  b[j] = '2';\t\t\t                   \t\t    \\\n+\t}\t\t\t\t\t\t   \t\t    \\\n+      if (!((r1 = strcmp (b, a)) > 0))\t\t   \t\t            \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      if (!((r1 = strcmp (a, b)) < 0))\t\t   \t\t            \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      for(j = 0; j < i ; j++)\t\t\t\t\t\t    \\\n+        {\t\t\t\t\t\t\t\t    \\\n+\t  memset(a, '-', SZ);\t\t\t\t\t\t    \\\n+\t  memset(b, '-', SZ);\t\t\t\t\t\t    \\\n+\t  a[j] = '\\0';\t\t\t\t\t\t\t    \\\n+\t  a[j+1] = '1';\t\t\t\t\t\t\t    \\\n+\t  b[j] = '\\0';\t\t\t\t\t\t\t    \\\n+\t  b[j+1] = '2';\t\t\t\t\t\t\t    \\\n+\t  if ((r1 = strcmp (b, a)) != 0)\t\t\t\t    \\\n+\t    abort ();\t\t\t\t\t\t\t    \\\n+\t}                                                                   \\\n+      a = three + 4096 - (SZ / 2 + (i & 1) * ALIGN);\t\t   \t    \\\n+      b = four + 4096 - (SZ / 2 + (i & 1) * ALIGN);\t\t   \t    \\\n+      memset(a, '-', SZ);\t\t\t\t\t   \t    \\\n+      memset(b, '-', SZ);\t\t\t\t\t   \t    \\\n+      a[i] = '1';\t\t\t\t\t   \t\t    \\\n+      b[i] = '2';\t\t\t\t\t   \t\t    \\\n+      a[SZ] = 0;\t\t\t\t\t\t\t    \\\n+      b[SZ] = 0;\t\t\t\t\t   \t\t    \\\n+      if (!((r1 = strcmp(b, a)) > 0))   \t\t   \t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      if (!((r1 = strcmp(a, b)) < 0))\t\t\t   \t            \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      b[i] = '1';\t\t\t\t\t   \t\t    \\\n+      if (!((r1 = strcmp(a, b)) == 0))\t\t   \t\t            \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+    }\t\t\t\t\t\t\t                    \\\n+}                                                                \n+\n+#ifdef TEST_ALL\n+DEF_TEST(1,1)\n+DEF_TEST(1,2)\n+DEF_TEST(1,4)\n+DEF_TEST(1,8)\n+DEF_TEST(1,16)\n+DEF_TEST(2,1)\n+DEF_TEST(2,2)\n+DEF_TEST(2,4)\n+DEF_TEST(2,8)\n+DEF_TEST(2,16)\n+DEF_TEST(3,1)\n+DEF_TEST(3,2)\n+DEF_TEST(3,4)\n+DEF_TEST(3,8)\n+DEF_TEST(3,16)\n+DEF_TEST(4,1)\n+DEF_TEST(4,2)\n+DEF_TEST(4,4)\n+DEF_TEST(4,8)\n+DEF_TEST(4,16)\n+DEF_TEST(5,1)\n+DEF_TEST(5,2)\n+DEF_TEST(5,4)\n+DEF_TEST(5,8)\n+DEF_TEST(5,16)\n+DEF_TEST(6,1)\n+DEF_TEST(6,2)\n+DEF_TEST(6,4)\n+DEF_TEST(6,8)\n+DEF_TEST(6,16)\n+DEF_TEST(7,1)\n+DEF_TEST(7,2)\n+DEF_TEST(7,4)\n+DEF_TEST(7,8)\n+DEF_TEST(7,16)\n+DEF_TEST(8,1)\n+DEF_TEST(8,2)\n+DEF_TEST(8,4)\n+DEF_TEST(8,8)\n+DEF_TEST(8,16)\n+DEF_TEST(9,1)\n+DEF_TEST(9,2)\n+DEF_TEST(9,4)\n+DEF_TEST(9,8)\n+DEF_TEST(9,16)\n+DEF_TEST(10,1)\n+DEF_TEST(10,2)\n+DEF_TEST(10,4)\n+DEF_TEST(10,8)\n+DEF_TEST(10,16)\n+DEF_TEST(11,1)\n+DEF_TEST(11,2)\n+DEF_TEST(11,4)\n+DEF_TEST(11,8)\n+DEF_TEST(11,16)\n+DEF_TEST(12,1)\n+DEF_TEST(12,2)\n+DEF_TEST(12,4)\n+DEF_TEST(12,8)\n+DEF_TEST(12,16)\n+DEF_TEST(13,1)\n+DEF_TEST(13,2)\n+DEF_TEST(13,4)\n+DEF_TEST(13,8)\n+DEF_TEST(13,16)\n+DEF_TEST(14,1)\n+DEF_TEST(14,2)\n+DEF_TEST(14,4)\n+DEF_TEST(14,8)\n+DEF_TEST(14,16)\n+DEF_TEST(15,1)\n+DEF_TEST(15,2)\n+DEF_TEST(15,4)\n+DEF_TEST(15,8)\n+DEF_TEST(15,16)\n+DEF_TEST(16,1)\n+DEF_TEST(16,2)\n+DEF_TEST(16,4)\n+DEF_TEST(16,8)\n+DEF_TEST(16,16)\n+DEF_TEST(17,1)\n+DEF_TEST(17,2)\n+DEF_TEST(17,4)\n+DEF_TEST(17,8)\n+DEF_TEST(17,16)\n+DEF_TEST(18,1)\n+DEF_TEST(18,2)\n+DEF_TEST(18,4)\n+DEF_TEST(18,8)\n+DEF_TEST(18,16)\n+DEF_TEST(19,1)\n+DEF_TEST(19,2)\n+DEF_TEST(19,4)\n+DEF_TEST(19,8)\n+DEF_TEST(19,16)\n+DEF_TEST(20,1)\n+DEF_TEST(20,2)\n+DEF_TEST(20,4)\n+DEF_TEST(20,8)\n+DEF_TEST(20,16)\n+DEF_TEST(21,1)\n+DEF_TEST(21,2)\n+DEF_TEST(21,4)\n+DEF_TEST(21,8)\n+DEF_TEST(21,16)\n+DEF_TEST(22,1)\n+DEF_TEST(22,2)\n+DEF_TEST(22,4)\n+DEF_TEST(22,8)\n+DEF_TEST(22,16)\n+DEF_TEST(23,1)\n+DEF_TEST(23,2)\n+DEF_TEST(23,4)\n+DEF_TEST(23,8)\n+DEF_TEST(23,16)\n+DEF_TEST(24,1)\n+DEF_TEST(24,2)\n+DEF_TEST(24,4)\n+DEF_TEST(24,8)\n+DEF_TEST(24,16)\n+DEF_TEST(25,1)\n+DEF_TEST(25,2)\n+DEF_TEST(25,4)\n+DEF_TEST(25,8)\n+DEF_TEST(25,16)\n+DEF_TEST(26,1)\n+DEF_TEST(26,2)\n+DEF_TEST(26,4)\n+DEF_TEST(26,8)\n+DEF_TEST(26,16)\n+DEF_TEST(27,1)\n+DEF_TEST(27,2)\n+DEF_TEST(27,4)\n+DEF_TEST(27,8)\n+DEF_TEST(27,16)\n+DEF_TEST(28,1)\n+DEF_TEST(28,2)\n+DEF_TEST(28,4)\n+DEF_TEST(28,8)\n+DEF_TEST(28,16)\n+DEF_TEST(29,1)\n+DEF_TEST(29,2)\n+DEF_TEST(29,4)\n+DEF_TEST(29,8)\n+DEF_TEST(29,16)\n+DEF_TEST(30,1)\n+DEF_TEST(30,2)\n+DEF_TEST(30,4)\n+DEF_TEST(30,8)\n+DEF_TEST(30,16)\n+DEF_TEST(31,1)\n+DEF_TEST(31,2)\n+DEF_TEST(31,4)\n+DEF_TEST(31,8)\n+DEF_TEST(31,16)\n+DEF_TEST(32,1)\n+DEF_TEST(32,2)\n+DEF_TEST(32,4)\n+DEF_TEST(32,8)\n+DEF_TEST(32,16)\n+DEF_TEST(33,1)\n+DEF_TEST(33,2)\n+DEF_TEST(33,4)\n+DEF_TEST(33,8)\n+DEF_TEST(33,16)\n+DEF_TEST(34,1)\n+DEF_TEST(34,2)\n+DEF_TEST(34,4)\n+DEF_TEST(34,8)\n+DEF_TEST(34,16)\n+DEF_TEST(35,1)\n+DEF_TEST(35,2)\n+DEF_TEST(35,4)\n+DEF_TEST(35,8)\n+DEF_TEST(35,16)\n+DEF_TEST(36,1)\n+DEF_TEST(36,2)\n+DEF_TEST(36,4)\n+DEF_TEST(36,8)\n+DEF_TEST(36,16)\n+DEF_TEST(37,1)\n+DEF_TEST(37,2)\n+DEF_TEST(37,4)\n+DEF_TEST(37,8)\n+DEF_TEST(37,16)\n+DEF_TEST(38,1)\n+DEF_TEST(38,2)\n+DEF_TEST(38,4)\n+DEF_TEST(38,8)\n+DEF_TEST(38,16)\n+DEF_TEST(39,1)\n+DEF_TEST(39,2)\n+DEF_TEST(39,4)\n+DEF_TEST(39,8)\n+DEF_TEST(39,16)\n+DEF_TEST(40,1)\n+DEF_TEST(40,2)\n+DEF_TEST(40,4)\n+DEF_TEST(40,8)\n+DEF_TEST(40,16)\n+DEF_TEST(41,1)\n+DEF_TEST(41,2)\n+DEF_TEST(41,4)\n+DEF_TEST(41,8)\n+DEF_TEST(41,16)\n+DEF_TEST(42,1)\n+DEF_TEST(42,2)\n+DEF_TEST(42,4)\n+DEF_TEST(42,8)\n+DEF_TEST(42,16)\n+DEF_TEST(43,1)\n+DEF_TEST(43,2)\n+DEF_TEST(43,4)\n+DEF_TEST(43,8)\n+DEF_TEST(43,16)\n+DEF_TEST(44,1)\n+DEF_TEST(44,2)\n+DEF_TEST(44,4)\n+DEF_TEST(44,8)\n+DEF_TEST(44,16)\n+DEF_TEST(45,1)\n+DEF_TEST(45,2)\n+DEF_TEST(45,4)\n+DEF_TEST(45,8)\n+DEF_TEST(45,16)\n+DEF_TEST(46,1)\n+DEF_TEST(46,2)\n+DEF_TEST(46,4)\n+DEF_TEST(46,8)\n+DEF_TEST(46,16)\n+DEF_TEST(47,1)\n+DEF_TEST(47,2)\n+DEF_TEST(47,4)\n+DEF_TEST(47,8)\n+DEF_TEST(47,16)\n+DEF_TEST(48,1)\n+DEF_TEST(48,2)\n+DEF_TEST(48,4)\n+DEF_TEST(48,8)\n+DEF_TEST(48,16)\n+DEF_TEST(49,1)\n+DEF_TEST(49,2)\n+DEF_TEST(49,4)\n+DEF_TEST(49,8)\n+DEF_TEST(49,16)\n+DEF_TEST(100,1)\n+DEF_TEST(100,2)\n+DEF_TEST(100,4)\n+DEF_TEST(100,8)\n+DEF_TEST(100,16)\n+#else\n+DEF_TEST(3,1)\n+DEF_TEST(4,1)\n+DEF_TEST(4,2)\n+DEF_TEST(4,4)\n+DEF_TEST(5,1)\n+DEF_TEST(6,1)\n+DEF_TEST(7,1)\n+DEF_TEST(8,1)\n+DEF_TEST(8,2)\n+DEF_TEST(8,4)\n+DEF_TEST(8,8)\n+DEF_TEST(9,1)\n+DEF_TEST(16,1)\n+DEF_TEST(16,2)\n+DEF_TEST(16,4)\n+DEF_TEST(16,8)\n+DEF_TEST(16,16)\n+DEF_TEST(32,1)\n+DEF_TEST(32,2)\n+DEF_TEST(32,4)\n+DEF_TEST(32,8)\n+DEF_TEST(32,16)\n+DEF_TEST(100,1)\n+DEF_TEST(100,2)\n+DEF_TEST(100,4)\n+DEF_TEST(100,8)\n+DEF_TEST(100,16)\n+#endif\n+\n+int\n+main(int argc, char **argv)\n+{\n+\n+#ifdef TEST_ALL\n+  RUN_TEST(1,1);\n+  RUN_TEST(1,2);\n+  RUN_TEST(1,4);\n+  RUN_TEST(1,8);\n+  RUN_TEST(1,16);\n+  RUN_TEST(2,1);\n+  RUN_TEST(2,2);\n+  RUN_TEST(2,4);\n+  RUN_TEST(2,8);\n+  RUN_TEST(2,16);\n+  RUN_TEST(3,1);\n+  RUN_TEST(3,2);\n+  RUN_TEST(3,4);\n+  RUN_TEST(3,8);\n+  RUN_TEST(3,16);\n+  RUN_TEST(4,1);\n+  RUN_TEST(4,2);\n+  RUN_TEST(4,4);\n+  RUN_TEST(4,8);\n+  RUN_TEST(4,16);\n+  RUN_TEST(5,1);\n+  RUN_TEST(5,2);\n+  RUN_TEST(5,4);\n+  RUN_TEST(5,8);\n+  RUN_TEST(5,16);\n+  RUN_TEST(6,1);\n+  RUN_TEST(6,2);\n+  RUN_TEST(6,4);\n+  RUN_TEST(6,8);\n+  RUN_TEST(6,16);\n+  RUN_TEST(7,1);\n+  RUN_TEST(7,2);\n+  RUN_TEST(7,4);\n+  RUN_TEST(7,8);\n+  RUN_TEST(7,16);\n+  RUN_TEST(8,1);\n+  RUN_TEST(8,2);\n+  RUN_TEST(8,4);\n+  RUN_TEST(8,8);\n+  RUN_TEST(8,16);\n+  RUN_TEST(9,1);\n+  RUN_TEST(9,2);\n+  RUN_TEST(9,4);\n+  RUN_TEST(9,8);\n+  RUN_TEST(9,16);\n+  RUN_TEST(10,1);\n+  RUN_TEST(10,2);\n+  RUN_TEST(10,4);\n+  RUN_TEST(10,8);\n+  RUN_TEST(10,16);\n+  RUN_TEST(11,1);\n+  RUN_TEST(11,2);\n+  RUN_TEST(11,4);\n+  RUN_TEST(11,8);\n+  RUN_TEST(11,16);\n+  RUN_TEST(12,1);\n+  RUN_TEST(12,2);\n+  RUN_TEST(12,4);\n+  RUN_TEST(12,8);\n+  RUN_TEST(12,16);\n+  RUN_TEST(13,1);\n+  RUN_TEST(13,2);\n+  RUN_TEST(13,4);\n+  RUN_TEST(13,8);\n+  RUN_TEST(13,16);\n+  RUN_TEST(14,1);\n+  RUN_TEST(14,2);\n+  RUN_TEST(14,4);\n+  RUN_TEST(14,8);\n+  RUN_TEST(14,16);\n+  RUN_TEST(15,1);\n+  RUN_TEST(15,2);\n+  RUN_TEST(15,4);\n+  RUN_TEST(15,8);\n+  RUN_TEST(15,16);\n+  RUN_TEST(16,1);\n+  RUN_TEST(16,2);\n+  RUN_TEST(16,4);\n+  RUN_TEST(16,8);\n+  RUN_TEST(16,16);\n+  RUN_TEST(17,1);\n+  RUN_TEST(17,2);\n+  RUN_TEST(17,4);\n+  RUN_TEST(17,8);\n+  RUN_TEST(17,16);\n+  RUN_TEST(18,1);\n+  RUN_TEST(18,2);\n+  RUN_TEST(18,4);\n+  RUN_TEST(18,8);\n+  RUN_TEST(18,16);\n+  RUN_TEST(19,1);\n+  RUN_TEST(19,2);\n+  RUN_TEST(19,4);\n+  RUN_TEST(19,8);\n+  RUN_TEST(19,16);\n+  RUN_TEST(20,1);\n+  RUN_TEST(20,2);\n+  RUN_TEST(20,4);\n+  RUN_TEST(20,8);\n+  RUN_TEST(20,16);\n+  RUN_TEST(21,1);\n+  RUN_TEST(21,2);\n+  RUN_TEST(21,4);\n+  RUN_TEST(21,8);\n+  RUN_TEST(21,16);\n+  RUN_TEST(22,1);\n+  RUN_TEST(22,2);\n+  RUN_TEST(22,4);\n+  RUN_TEST(22,8);\n+  RUN_TEST(22,16);\n+  RUN_TEST(23,1);\n+  RUN_TEST(23,2);\n+  RUN_TEST(23,4);\n+  RUN_TEST(23,8);\n+  RUN_TEST(23,16);\n+  RUN_TEST(24,1);\n+  RUN_TEST(24,2);\n+  RUN_TEST(24,4);\n+  RUN_TEST(24,8);\n+  RUN_TEST(24,16);\n+  RUN_TEST(25,1);\n+  RUN_TEST(25,2);\n+  RUN_TEST(25,4);\n+  RUN_TEST(25,8);\n+  RUN_TEST(25,16);\n+  RUN_TEST(26,1);\n+  RUN_TEST(26,2);\n+  RUN_TEST(26,4);\n+  RUN_TEST(26,8);\n+  RUN_TEST(26,16);\n+  RUN_TEST(27,1);\n+  RUN_TEST(27,2);\n+  RUN_TEST(27,4);\n+  RUN_TEST(27,8);\n+  RUN_TEST(27,16);\n+  RUN_TEST(28,1);\n+  RUN_TEST(28,2);\n+  RUN_TEST(28,4);\n+  RUN_TEST(28,8);\n+  RUN_TEST(28,16);\n+  RUN_TEST(29,1);\n+  RUN_TEST(29,2);\n+  RUN_TEST(29,4);\n+  RUN_TEST(29,8);\n+  RUN_TEST(29,16);\n+  RUN_TEST(30,1);\n+  RUN_TEST(30,2);\n+  RUN_TEST(30,4);\n+  RUN_TEST(30,8);\n+  RUN_TEST(30,16);\n+  RUN_TEST(31,1);\n+  RUN_TEST(31,2);\n+  RUN_TEST(31,4);\n+  RUN_TEST(31,8);\n+  RUN_TEST(31,16);\n+  RUN_TEST(32,1);\n+  RUN_TEST(32,2);\n+  RUN_TEST(32,4);\n+  RUN_TEST(32,8);\n+  RUN_TEST(32,16);\n+  RUN_TEST(33,1);\n+  RUN_TEST(33,2);\n+  RUN_TEST(33,4);\n+  RUN_TEST(33,8);\n+  RUN_TEST(33,16);\n+  RUN_TEST(34,1);\n+  RUN_TEST(34,2);\n+  RUN_TEST(34,4);\n+  RUN_TEST(34,8);\n+  RUN_TEST(34,16);\n+  RUN_TEST(35,1);\n+  RUN_TEST(35,2);\n+  RUN_TEST(35,4);\n+  RUN_TEST(35,8);\n+  RUN_TEST(35,16);\n+  RUN_TEST(36,1);\n+  RUN_TEST(36,2);\n+  RUN_TEST(36,4);\n+  RUN_TEST(36,8);\n+  RUN_TEST(36,16);\n+  RUN_TEST(37,1);\n+  RUN_TEST(37,2);\n+  RUN_TEST(37,4);\n+  RUN_TEST(37,8);\n+  RUN_TEST(37,16);\n+  RUN_TEST(38,1);\n+  RUN_TEST(38,2);\n+  RUN_TEST(38,4);\n+  RUN_TEST(38,8);\n+  RUN_TEST(38,16);\n+  RUN_TEST(39,1);\n+  RUN_TEST(39,2);\n+  RUN_TEST(39,4);\n+  RUN_TEST(39,8);\n+  RUN_TEST(39,16);\n+  RUN_TEST(40,1);\n+  RUN_TEST(40,2);\n+  RUN_TEST(40,4);\n+  RUN_TEST(40,8);\n+  RUN_TEST(40,16);\n+  RUN_TEST(41,1);\n+  RUN_TEST(41,2);\n+  RUN_TEST(41,4);\n+  RUN_TEST(41,8);\n+  RUN_TEST(41,16);\n+  RUN_TEST(42,1);\n+  RUN_TEST(42,2);\n+  RUN_TEST(42,4);\n+  RUN_TEST(42,8);\n+  RUN_TEST(42,16);\n+  RUN_TEST(43,1);\n+  RUN_TEST(43,2);\n+  RUN_TEST(43,4);\n+  RUN_TEST(43,8);\n+  RUN_TEST(43,16);\n+  RUN_TEST(44,1);\n+  RUN_TEST(44,2);\n+  RUN_TEST(44,4);\n+  RUN_TEST(44,8);\n+  RUN_TEST(44,16);\n+  RUN_TEST(45,1);\n+  RUN_TEST(45,2);\n+  RUN_TEST(45,4);\n+  RUN_TEST(45,8);\n+  RUN_TEST(45,16);\n+  RUN_TEST(46,1);\n+  RUN_TEST(46,2);\n+  RUN_TEST(46,4);\n+  RUN_TEST(46,8);\n+  RUN_TEST(46,16);\n+  RUN_TEST(47,1);\n+  RUN_TEST(47,2);\n+  RUN_TEST(47,4);\n+  RUN_TEST(47,8);\n+  RUN_TEST(47,16);\n+  RUN_TEST(48,1);\n+  RUN_TEST(48,2);\n+  RUN_TEST(48,4);\n+  RUN_TEST(48,8);\n+  RUN_TEST(48,16);\n+  RUN_TEST(49,1);\n+  RUN_TEST(49,2);\n+  RUN_TEST(49,4);\n+  RUN_TEST(49,8);\n+  RUN_TEST(49,16);\n+#else\n+  RUN_TEST(3,1);\n+  RUN_TEST(4,1);\n+  RUN_TEST(4,2);\n+  RUN_TEST(4,4);\n+  RUN_TEST(5,1);\n+  RUN_TEST(6,1);\n+  RUN_TEST(7,1);\n+  RUN_TEST(8,1);\n+  RUN_TEST(8,2);\n+  RUN_TEST(8,4);\n+  RUN_TEST(8,8);\n+  RUN_TEST(9,1);\n+  RUN_TEST(16,1);\n+  RUN_TEST(16,2);\n+  RUN_TEST(16,4);\n+  RUN_TEST(16,8);\n+  RUN_TEST(16,16);\n+  RUN_TEST(32,1);\n+  RUN_TEST(32,2);\n+  RUN_TEST(32,4);\n+  RUN_TEST(32,8);\n+  RUN_TEST(32,16);\n+#endif\n+  return 0;\n+}"}, {"sha": "f9d26f76e9b3c23e24ed7eca6fd27992b075e6dd", "filename": "gcc/testsuite/gcc.dg/strncmp-1.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0edd264dfc29db3c30641771d46634b4ef3ffe10/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-1.c?ref=0edd264dfc29db3c30641771d46634b4ef3ffe10", "patch": "@@ -1,4 +1,4 @@\n-/* Test memcmp builtin expansion for compilation and proper execution.  */\n+/* Test strncmp builtin expansion for compilation and proper execution.  */\n /* { dg-do run } */\n /* { dg-options \"-O2\" } */\n /* { dg-require-effective-target ptr32plus } */\n@@ -32,31 +32,32 @@ static void test_strncmp_ ## SZ ## _ ## ALIGN (void) {     \t\t    \\\n       a[SZ] = 0;\t\t\t\t\t\t\t    \\\n       b[SZ] = 0;\t\t\t\t\t   \t\t    \\\n       if (!((r1 = strncmp (b, a, SZ)) > 0))   \t\t   \t\t    \\\n-        {\t\t\t\t\t\t\t\t    \\\n-\t  abort ();\t\t\t\t\t\t\t    \\\n-\t}\t\t\t\t\t\t\t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n       if (!((r1 = strncmp (a, b, SZ)) < 0))\t\t\t   \t    \\\n-        {\t\t\t\t\t\t\t\t    \\\n-\t  abort ();\t\t\t\t\t\t\t    \\\n-\t}                            \t\t\t\t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n       b[i] = '1';\t\t\t\t\t   \t\t    \\\n       if (!((r1 = strncmp (a, b, SZ)) == 0))\t\t   \t\t    \\\n-        {\t\t\t\t\t\t\t\t    \\\n-\t  abort ();\t\t\t\t\t\t\t    \\\n-\t}                            \t\t\t\t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n       for(j = i; j < SZ ; j++)\t\t\t   \t\t            \\\n \t{\t\t\t\t\t\t   \t\t    \\\n \t  a[j] = '1';            \t\t\t   \t\t    \\\n \t  b[j] = '2';\t\t\t                   \t\t    \\\n \t}\t\t\t\t\t\t   \t\t    \\\n-      if (!((r1 = strncmp(b, a, SZ)) > 0))\t\t   \t\t    \\\n-        {\t\t\t\t\t\t\t\t    \\\n-\t  abort ();\t\t\t\t\t\t\t    \\\n-\t}             \t\t\t\t\t\t\t    \\\n-      if (!((r1 = strncmp(a, b, SZ)) < 0))\t\t   \t\t    \\\n+      if (!((r1 = strncmp (b, a, SZ)) > 0))\t\t   \t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      if (!((r1 = strncmp (a, b, SZ)) < 0))\t\t   \t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      for(j = 0; j < i ; j++)\t\t\t\t\t\t    \\\n         {\t\t\t\t\t\t\t\t    \\\n-\t  abort ();\t\t\t\t\t\t\t    \\\n-\t}\t\t   \t\t\t\t\t\t    \\\n+\t  memset(a, '-', SZ);\t\t\t\t\t\t    \\\n+\t  memset(b, '-', SZ);\t\t\t\t\t\t    \\\n+\t  a[j] = '\\0';\t\t\t\t\t\t\t    \\\n+\t  a[j+1] = '1';\t\t\t\t\t\t\t    \\\n+\t  b[j] = '\\0';\t\t\t\t\t\t\t    \\\n+\t  b[j+1] = '2';\t\t\t\t\t\t\t    \\\n+\t  if ((r1 = strncmp (b, a, SZ)) != 0)\t\t\t\t    \\\n+\t    abort ();\t\t\t\t\t\t\t    \\\n+\t}                                                                   \\\n       a = three + 4096 - (SZ / 2 + (i & 1) * ALIGN);\t\t   \t    \\\n       b = four + 4096 - (SZ / 2 + (i & 1) * ALIGN);\t\t   \t    \\\n       memset(a, '-', SZ);\t\t\t\t\t   \t    \\\n@@ -66,18 +67,12 @@ static void test_strncmp_ ## SZ ## _ ## ALIGN (void) {     \t\t    \\\n       a[SZ] = 0;\t\t\t\t\t\t\t    \\\n       b[SZ] = 0;\t\t\t\t\t   \t\t    \\\n       if (!((r1 = strncmp(b, a, SZ)) > 0))   \t\t   \t\t    \\\n-        {\t\t\t\t\t\t\t\t    \\\n-\t  abort ();\t\t\t\t\t\t\t    \\\n-\t}\t\t\t\t\t\t\t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n       if (!((r1 = strncmp(a, b, SZ)) < 0))\t\t\t   \t    \\\n-        {\t\t\t\t\t\t\t\t    \\\n-\t  abort ();\t\t\t\t\t\t\t    \\\n-\t}                            \t\t\t\t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n       b[i] = '1';\t\t\t\t\t   \t\t    \\\n       if (!((r1 = strncmp(a, b, SZ)) == 0))\t\t   \t\t    \\\n-        {\t\t\t\t\t\t\t\t    \\\n-\t  abort ();\t\t\t\t\t\t\t    \\\n-\t}                            \t\t\t\t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n     }\t\t\t\t\t\t\t                    \\\n }                                                                \n \n@@ -327,6 +322,11 @@ DEF_TEST(49,2)\n DEF_TEST(49,4)\n DEF_TEST(49,8)\n DEF_TEST(49,16)\n+DEF_TEST(100,1)\n+DEF_TEST(100,2)\n+DEF_TEST(100,4)\n+DEF_TEST(100,8)\n+DEF_TEST(100,16)\n #else\n DEF_TEST(3,1)\n DEF_TEST(4,1)\n@@ -350,6 +350,11 @@ DEF_TEST(32,2)\n DEF_TEST(32,4)\n DEF_TEST(32,8)\n DEF_TEST(32,16)\n+DEF_TEST(100,1)\n+DEF_TEST(100,2)\n+DEF_TEST(100,4)\n+DEF_TEST(100,8)\n+DEF_TEST(100,16)\n #endif\n \n int"}]}