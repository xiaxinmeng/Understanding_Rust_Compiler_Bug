{"sha": "ca6b827f15363a172395ccf8bac434d482a2ff2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E2YjgyN2YxNTM2M2ExNzIzOTVjY2Y4YmFjNDM0ZDQ4MmEyZmYyZg==", "commit": {"author": {"name": "Nic Ferrier", "email": "nferrier@gcc.gnu.org", "date": "2002-02-01T23:43:35Z"}, "committer": {"name": "Nic Ferrier", "email": "nferrier@gcc.gnu.org", "date": "2002-02-01T23:43:35Z"}, "message": "* gcj.texi (About CNI): New node.\n\nFrom-SVN: r49417", "tree": {"sha": "edf3f50a8ce32dc86b13eaca052d1b94409dd1c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edf3f50a8ce32dc86b13eaca052d1b94409dd1c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca6b827f15363a172395ccf8bac434d482a2ff2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6b827f15363a172395ccf8bac434d482a2ff2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca6b827f15363a172395ccf8bac434d482a2ff2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6b827f15363a172395ccf8bac434d482a2ff2f/comments", "author": null, "committer": null, "parents": [{"sha": "d3c52658629a1d170df67278db4c56e4a2742283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3c52658629a1d170df67278db4c56e4a2742283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3c52658629a1d170df67278db4c56e4a2742283"}], "stats": {"total": 871, "additions": 870, "deletions": 1}, "files": [{"sha": "3e9f31cf134e37b4784340f700c29d84b31112af", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 870, "deletions": 1, "changes": 871, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6b827f15363a172395ccf8bac434d482a2ff2f/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6b827f15363a172395ccf8bac434d482a2ff2f/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=ca6b827f15363a172395ccf8bac434d482a2ff2f", "patch": "@@ -123,6 +123,7 @@ files and object files, and it can read both Java source code and\n * Invoking jcf-dump::   Print information about class files\n * Invoking gij::\tInterpreting Java bytecodes\n * Invoking jv-convert:: Converting from one encoding to another\n+* About CNI::           Description of the Cygnus Native Interface\n * Resources::\t\tWhere to look for more information\n @end menu\n \n@@ -395,7 +396,7 @@ question actually does violate array bounds constraints.\n \n @item -fjni\n With @code{gcj} there are two options for writing native methods: CNI\n-and JNI.  By default @code{gcj} assumes you are using CNI.  If you are\n+and JNI@.  By default @code{gcj} assumes you are using CNI@.  If you are\n compiling a class with native methods, and these methods are implemented\n using JNI, then you must use @code{-fjni}.  This option causes\n @code{gcj} to generate stubs which will invoke the underlying JNI\n@@ -831,6 +832,874 @@ Print version information, then exit.\n \n @c man end\n \n+@node About CNI\n+@chapter About CNI\n+\n+This documents CNI, the Cygnus Native Interface,\n+which is is a convenient way to write Java native methods using C++.\n+This is a more efficient, more convenient, but less portable\n+alternative to the standard JNI (Java Native Interface).\n+\n+@menu\n+* Basic concepts::              Introduction to using CNI@.\n+* Packages::                    How packages are mapped to C++.\n+* Primitive types::             Handling Java types in C++.\n+* Interfaces::                  How Java interfaces map to C++.\n+* Objects and Classes::         C++ and Java classes.\n+* Class Initialization::        How objects are initialized.\n+* Object allocation::           How to create Java objects in C++.\n+* Arrays::                      Dealing with Java arrays in C++.\n+* Methods::                     Java methods in C++.\n+* Strings::                     Information about Java Strings.\n+* Mixing with C++::             How CNI can interoperate with C++.\n+* Exception Handling::          How exceptions are handled.\n+* Synchronization::             Synchronizing between Java and C++.\n+* Reflection::                  Using reflection from C++.\n+@end menu\n+\n+\n+@node Basic concepts\n+@section Basic concepts\n+\n+In terms of languages features, Java is mostly a subset\n+of C++.  Java has a few important extensions, plus a powerful standard\n+class library, but on the whole that does not change the basic similarity.\n+Java is a hybrid object-oriented language, with a few native types,\n+in addition to class types.  It is class-based, where a class may have\n+static as well as per-object fields, and static as well as instance methods.\n+Non-static methods may be virtual, and may be overloaded.  Overloading is\n+resolved at compile time by matching the actual argument types against\n+the parameter types.  Virtual methods are implemented using indirect calls\n+through a dispatch table (virtual function table).  Objects are\n+allocated on the heap, and initialized using a constructor method.\n+Classes are organized in a package hierarchy.\n+\n+All of the listed attributes are also true of C++, though C++ has\n+extra features (for example in C++ objects may be allocated not just\n+on the heap, but also statically or in a local stack frame).  Because\n+@code{gcj} uses the same compiler technology as G++ (the GNU\n+C++ compiler), it is possible to make the intersection of the two\n+languages use the same ABI (object representation and calling\n+conventions).  The key idea in CNI is that Java objects are C++\n+objects, and all Java classes are C++ classes (but not the other way\n+around).  So the most important task in integrating Java and C++ is to\n+remove gratuitous incompatibilities.\n+\n+You write CNI code as a regular C++ source file.  (You do have to use\n+a Java/CNI-aware C++ compiler, specifically a recent version of G++.)\n+\n+@noindent A CNI C++ source file must have:\n+\n+@example\n+#include <gcj/cni.h>\n+@end example\n+\n+@noindent and then must include one header file for each Java class it uses, e.g.:\n+\n+@example\n+#include <java/lang/Character.h>\n+#include <java/util/Date.h>\n+#include <java/lang/IndexOutOfBoundsException.h>\n+@end example\n+\n+@noindent These header files are automatically generated by @code{gcjh}.\n+\n+\n+CNI provides some functions and macros to make using Java objects and\n+primitive types from C++ easier.  In general, these CNI functions and\n+macros start with the @code{Jv} prefix, for example the function\n+@code{JvNewObjectArray}.  This convention is used to avoid conflicts\n+with other libraries.  Internal functions in CNI start with the prefix\n+@code{_Jv_}.  You should not call these; if you find a need to, let us\n+know and we will try to come up with an alternate solution.  (This\n+manual lists @code{_Jv_AllocBytes} as an example; CNI should instead\n+provide a @code{JvAllocBytes} function.)\n+\n+\n+@subsection Limitations\n+\n+Whilst a Java class is just a C++ class that doesn't mean that you are\n+freed from the shackles of Java, a @acronym{CNI} C++ class must adhere to the\n+rules of the Java programming language.\n+\n+For example: it is not possible to declare a method in a CNI class\n+that will take a C string (@code{char*}) as an argument, or to declare a\n+member variable of some non-Java datatype.\n+\n+\n+@node Packages\n+@section Packages\n+\n+The only global names in Java are class names, and packages.  A\n+@dfn{package} can contain zero or more classes, and also zero or more\n+sub-packages.  Every class belongs to either an unnamed package or a\n+package that has a hierarchical and globally unique name.\n+\n+A Java package is mapped to a C++ @dfn{namespace}.  The Java class\n+@code{java.lang.String} is in the package @code{java.lang}, which is a\n+sub-package of @code{java}.  The C++ equivalent is the class\n+@code{java::lang::String}, which is in the namespace @code{java::lang}\n+which is in the namespace @code{java}.\n+\n+@noindent Here is how you could express this:\n+\n+@example\n+(// @r{Declare the class(es), possibly in a header file:}\n+namespace java @{\n+  namespace lang @{\n+    class Object;\n+    class String;\n+    ...\n+  @}\n+@}\n+\n+class java::lang::String : public java::lang::Object\n+@{\n+  ...\n+@};\n+@end example\n+\n+@noindent The @code{gcjh} tool automatically generates the nessary namespace\n+declarations.\n+\n+\n+@subsection Leaving out package names\n+\n+Always using the fully-qualified name of a java class can be\n+tiresomely verbose.  Using the full qualified name also ties the code\n+to a single package making code changes necessary should the class\n+move from one package to another.  The Java @code{package} declaration\n+specifies that the following class declarations are in the named\n+package, without having to explicitly name the full package\n+qualifiers.  The @code{package} declaration can be\n+followed by zero or more @code{import} declarations, which\n+allows either a single class or all the classes in a package to be\n+named by a simple identifier.  C++ provides something similar with the\n+@code{using} declaration and directive.\n+\n+@noindent In Java:\n+\n+@example\n+import @var{package-name}.@var{class-name};\n+@end example\n+\n+@noindent allows the program text to refer to @var{class-name} as a shorthand for \n+the fully qualified name: @code{@var{package-name}.@var{class-name}}.\n+\n+\n+@noindent To achieve the same effect C++, you have to do this:\n+\n+@example\n+using @var{package-name}::@var{class-name};\n+@end example\n+\n+\n+@noindent Java can also cause imports on demand, like this:\n+\n+@example\n+import @var{package-name}.*;\n+@end example\n+\n+@noindent Doing this allows any class from the package @var{package-name} to be\n+refered to only by its class-name within the program text.\n+\n+\n+@noindent The same effect can be achieved in C++ like this:\n+\n+@example\n+using namespace @var{package-name};\n+@end example\n+\n+\n+@node Primitive types\n+@section Primitive types\n+\n+Java provides 8 @dfn{primitives} types which represent integers, floats, \n+characters and booleans (and also the void type).  C++ has its own\n+very similar concrete types.  Such types in C++ however are not always\n+implemented in the same way (an int might be 16, 32 or 64 bits for example) \n+so CNI provides a special C++ type for each primitive Java type:\n+\n+@multitable @columnfractions .20 .25 .60\n+@item @strong{Java type}   @tab @strong{C/C++ typename} @tab @strong{Description}\n+@item @code{char}        @tab @code{jchar}          @tab 16 bit Unicode character\n+@item @code{boolean}     @tab @code{jboolean}       @tab logical (true or false) values\n+@item @code{byte}        @tab @code{jbyte}          @tab 8-bit signed integer\n+@item @code{short}       @tab @code{jshort}         @tab 16 bit signed integer\n+@item @code{int}         @tab @code{jint}           @tab 32 bit signed integer\n+@item @code{long}        @tab @code{jlong}          @tab 64 bit signed integer\n+@item @code{float}       @tab @code{jfloat}         @tab 32 bit IEEE floating point number\n+@item @code{double}      @tab @code{jdouble}        @tab 64 bit IEEE floating point number\n+@item @code{void}        @tab @code{void}           @tab no value\n+@end multitable\n+\n+When refering to a Java type You should always use these C++ typenames (e.g.: @code{jint})\n+to avoid disappointment.\n+\n+\n+@subsection Reference types associated with primitive types\n+\n+In Java each primitive type has an associated reference type, \n+e.g.: @code{boolean} has an associated @code{java.lang.Boolean} class.\n+In order to make working with such classes easier GCJ provides the macro\n+@code{JvPrimClass}:\n+\n+@deffn macro JvPrimClass type\n+Return a pointer to the @code{Class} object corresponding to the type supplied.\n+\n+@example\n+JvPrimClass(void) @result{} java.lang.Void.TYPE\n+@end example\n+\n+@end deffn\n+\n+\n+@node Interfaces\n+@section Interfaces\n+\n+A Java class can @dfn{implement} zero or more\n+@dfn{interfaces}, in addition to inheriting from\n+a single base class. \n+\n+@acronym{CNI} allows CNI code to implement methods of interfaces.\n+You can also call methods through interface references, with some\n+limitations.\n+\n+@acronym{CNI} doesn't understand interface inheritance at all yet.  So,\n+you can only call an interface method when the declared type of the\n+field being called matches the interface which declares that\n+method.  The workaround is to cast the interface reference to the right\n+superinterface.\n+ \n+For example if you have: \n+\n+@example \n+interface A \n+@{ \n+  void a(); \n+@} \n+ \n+interface B extends A \n+@{ \n+  void b(); \n+@} \n+@end example\n+ \n+and declare a variable of type @code{B} in C++, you can't call\n+@code{a()} unless you cast it to an @code{A} first.\n+\n+@node Objects and Classes\n+@section Objects and Classes\n+\n+@subsection Classes\n+\n+All Java classes are derived from @code{java.lang.Object}.  C++ does\n+not have a unique root class, but we use the C++ class\n+@code{java::lang::Object} as the C++ version of the\n+@code{java.lang.Object} Java class.  All other Java classes are mapped\n+into corresponding C++ classes derived from @code{java::lang::Object}.\n+\n+Interface inheritance (the @code{implements} keyword) is currently not\n+reflected in the C++ mapping.\n+\n+\n+@subsection Object fields\n+\n+Each object contains an object header, followed by the instance fields\n+of the class, in order.  The object header consists of a single\n+pointer to a dispatch or virtual function table.  (There may be extra\n+fields @emph{in front of} the object, for example for memory\n+management, but this is invisible to the application, and the\n+reference to the object points to the dispatch table pointer.)\n+\n+The fields are laid out in the same order, alignment, and size as in\n+C++.  Specifically, 8-bite and 16-bit native types (@code{byte},\n+@code{short}, @code{char}, and @code{boolean}) are @emph{not} widened\n+to 32 bits.  Note that the Java VM does extend 8-bit and 16-bit types\n+to 32 bits when on the VM stack or temporary registers.\n+\n+If you include the @code{gcjh}-generated header for a\n+class, you can access fields of Java classes in the @emph{natural}\n+way.  For example, given the following Java class:\n+\n+@example\n+public class Int\n+@{\n+  public int i;\n+  public Integer (int i) @{ this.i = i; @}\n+  public static zero = new Integer(0);\n+@}\n+@end example\n+\n+you can write:\n+\n+@example\n+#include <gcj/cni.h>;\n+#include <Int>;\n+\n+Int*\n+mult (Int *p, jint k)\n+@{\n+  if (k == 0)\n+    return Int::zero;  // @r{Static member access.}\n+  return new Int(p->i * k);\n+@}\n+@end example\n+\n+\n+@subsection Access specifiers\n+\n+CNI does not strictly enforce the Java access\n+specifiers, because Java permissions cannot be directly mapped\n+into C++ permission.  Private Java fields and methods are mapped\n+to private C++ fields and methods, but other fields and methods\n+are mapped to public fields and methods.\n+\n+\n+\n+@node Class Initialization\n+@section Class Initialization\n+\n+Java requires that each class be automatically initialized at the time \n+of the first active use.  Initializing a class involves \n+initializing the static fields, running code in class initializer \n+methods, and initializing base classes.  There may also be \n+some implementation specific actions, such as allocating \n+@code{String} objects corresponding to string literals in\n+the code.\n+\n+The GCJ compiler inserts calls to @code{JvInitClass} at appropriate\n+places to ensure that a class is initialized when required.  The C++\n+compiler does not insert these calls automatically---it is the\n+programmer's responsibility to make sure classes are initialized.\n+However, this is fairly painless because of the conventions assumed by\n+the Java system.\n+\n+First, @code{libgcj} will make sure a class is initialized\n+before an instance of that object is created.  This is one\n+of the responsibilities of the @code{new} operation.  This is\n+taken care of both in Java code, and in C++ code.  (When the G++\n+compiler sees a @code{new} of a Java class, it will call\n+a routine in @code{libgcj} to allocate the object, and that\n+routine will take care of initializing the class.)  It follows that you can\n+access an instance field, or call an instance (non-static)\n+method and be safe in the knowledge that the class and all\n+of its base classes have been initialized.\n+\n+Invoking a static method is also safe.  This is because the\n+Java compiler adds code to the start of a static method to make sure\n+the class is initialized.  However, the C++ compiler does not\n+add this extra code.  Hence, if you write a native static method\n+using CNI, you are responsible for calling @code{JvInitClass}\n+before doing anything else in the method (unless you are sure\n+it is safe to leave it out).\n+\n+Accessing a static field also requires the class of the\n+field to be initialized.  The Java compiler will generate code\n+to call @code{Jv_InitClass} before getting or setting the field.\n+However, the C++ compiler will not generate this extra code,\n+so it is your responsibility to make sure the class is\n+initialized before you access a static field from C++.\n+\n+\n+@node Object allocation\n+@section Object allocation\n+\n+New Java objects are allocated using a\n+@dfn{class instance creation expression}, e.g.:\n+\n+@example\n+new @var{Type} ( ... )\n+@end example\n+\n+The same syntax is used in C++.  The main difference is that\n+C++ objects have to be explicitly deleted; in Java they are\n+automatically deleted by the garbage collector.\n+Using @acronym{CNI}, you can allocate a new Java object\n+using standard C++ syntax and the C++ compiler will allocate\n+memory from the garbage collector.  If you have overloaded\n+constructors, the compiler will choose the correct one\n+using standard C++ overload resolution rules.  \n+\n+@noindent For example:\n+\n+@example\n+java::util::Hashtable *ht = new java::util::Hashtable(120);\n+@end example\n+\n+@deftypefun void* _Jv_AllocBytes (jsize @var{size})\n+Allocates @var{size} bytes from the heap.  The memory is not scanned\n+by the garbage collector but it freed if no references to it are discovered.\n+@end deftypefun\n+\n+\n+@node Arrays\n+@section Arrays\n+\n+While in many ways Java is similar to C and C++, it is quite different\n+in its treatment of arrays.  C arrays are based on the idea of pointer\n+arithmetic, which would be incompatible with Java's security\n+requirements.  Java arrays are true objects (array types inherit from\n+@code{java.lang.Object}).  An array-valued variable is one that\n+contains a reference (pointer) to an array object.\n+\n+Referencing a Java array in C++ code is done using the\n+@code{JArray} template, which as defined as follows:\n+\n+@example\n+class __JArray : public java::lang::Object\n+@{\n+public:\n+  int length;\n+@};\n+\n+template<class T>\n+class JArray : public __JArray\n+@{\n+  T data[0];\n+public:\n+  T& operator[](jint i) @{ return data[i]; @}\n+@};\n+@end example\n+\n+\n+There are a number of @code{typedef}s which correspond to @code{typedef}s \n+from the @acronym{JNI}.  Each is the type of an array holding objects\n+of the relevant type:\n+\n+@example\n+typedef __JArray *jarray;\n+typedef JArray<jobject> *jobjectArray;\n+typedef JArray<jboolean> *jbooleanArray;\n+typedef JArray<jbyte> *jbyteArray;\n+typedef JArray<jchar> *jcharArray;\n+typedef JArray<jshort> *jshortArray;\n+typedef JArray<jint> *jintArray;\n+typedef JArray<jlong> *jlongArray;\n+typedef JArray<jfloat> *jfloatArray;\n+typedef JArray<jdouble> *jdoubleArray;\n+@end example\n+\n+\n+@deftypemethod {template<class T>} T* elements (JArray<T> @var{array})\n+This template function can be used to get a pointer to the elements of\n+the @code{array}.  For instance, you can fetch a pointer to the\n+integers that make up an @code{int[]} like so:\n+\n+@example\n+extern jintArray foo;\n+jint *intp = elements (foo);\n+@end example\n+\n+The name of this function may change in the future.\n+@end deftypemethod\n+\n+\n+@deftypefun jobjectArray JvNewObjectArray (jsize @var{length}, jclass @var{klass}, jobject @var{init})\n+Here @code{klass} is the type of elements of the array and\n+@code{init} is the initial value put into every slot in the array.\n+@end deftypefun\n+\n+\n+@subsection Creating arrays\n+\n+For each primitive type there is a function which can be used to\n+create a new array of that type.  The name of the function is of the\n+form:\n+\n+@example\n+JvNew@var{Type}Array\n+@end example\n+\n+@noindent For example:\n+\n+@example\n+JvNewBooleanArray\n+@end example\n+\n+@noindent can be used to create an array of Java primitive boolean types.\n+\n+@noindent The following function definition is the template for all such functions:\n+\n+@deftypefun jbooleanArray JvNewBooleanArray (jint @var{length})\n+Create's an array @var{length} indices long.\n+@end deftypefun\n+\n+@deftypefun jsize JvGetArrayLength (jarray @var{array})\n+Returns the length of the @var{array}.\n+@end deftypefun\n+\n+\n+@node Methods\n+@section Methods\n+\n+Java methods are mapped directly into C++ methods.\n+The header files generated by @code{gcjh}\n+include the appropriate method definitions.\n+Basically, the generated methods have the same names and\n+@emph{corresponding} types as the Java methods,\n+and are called in the natural manner.\n+\n+@subsection Overloading\n+\n+Both Java and C++ provide method overloading, where multiple\n+methods in a class have the same name, and the correct one is chosen\n+(at compile time) depending on the argument types.\n+The rules for choosing the correct method are (as expected) more complicated\n+in C++ than in Java, but given a set of overloaded methods\n+generated by @code{gcjh} the C++ compiler will choose\n+the expected one.\n+\n+Common assemblers and linkers are not aware of C++ overloading,\n+so the standard implementation strategy is to encode the\n+parameter types of a method into its assembly-level name.\n+This encoding is called @dfn{mangling},\n+and the encoded name is the @dfn{mangled name}.\n+The same mechanism is used to implement Java overloading.\n+For C++/Java interoperability, it is important that both the Java\n+and C++ compilers use the @emph{same} encoding scheme.\n+\n+@subsection Static methods\n+\n+Static Java methods are invoked in @acronym{CNI} using the standard\n+C++ syntax, using the @code{::} operator rather\n+than the @code{.} operator.  \n+\n+@noindent For example:\n+\n+@example\n+jint i = java::lang::Math::round((jfloat) 2.3);\n+@end example\n+\n+@noindent C++ method definition syntax is used to define a static native method.\n+For example:\n+\n+@example\n+#include <java/lang/Integer>\n+java::lang::Integer*\n+java::lang::Integer::getInteger(jstring str)\n+@{\n+  ...\n+@}\n+@end example\n+\n+\n+@subsection Object Constructors\n+\n+Constructors are called implicitly as part of object allocation\n+using the @code{new} operator.  \n+\n+@noindent For example:\n+\n+@example\n+java::lang::Integer *x = new java::lang::Integer(234);\n+@end example\n+\n+Java does not allow a constructor to be a native method.\n+This limitation can be coded round however because a constructor\n+can @emph{call} a native method.\n+\n+\n+@subsection Instance methods\n+\n+Calling a Java instance method from a C++ @acronym{CNI} method is done \n+using the standard C++ syntax, e.g.:\n+\n+@example\n+// @r{First create the Java object.}\n+java::lang::Integer *x = new java::lang::Integer(234);\n+// @r{Now call a method.}\n+jint prim_value = x->intValue();\n+if (x->longValue == 0) \n+  ...\n+@end example\n+\n+@noindent Defining a Java native instance method is also done the natural way:\n+\n+@example\n+#include <java/lang/Integer.h>\n+\n+jdouble\n+java::lang:Integer::doubleValue()\n+@{\n+  return (jdouble) value;\n+@}\n+@end example\n+\n+\n+@subsection Interface methods\n+\n+In Java you can call a method using an interface reference.  This is\n+supported, but not completly.  @xref{Interfaces}.\n+\n+\n+\n+\n+@node Strings\n+@section Strings\n+\n+@acronym{CNI} provides a number of utility functions for\n+working with Java Java @code{String} objects.\n+The names and interfaces are analogous to those of @acronym{JNI}.\n+\n+\n+@deftypefun jstring JvNewString (const char* @var{chars}, jsize @var{len})\n+Returns a Java @code{String} object with characters from the C string\n+@var{chars} up to the index @var{len} in that array.\n+@end deftypefun\n+\n+@deftypefun jstring JvNewStringLatin1 (const char* @var{bytes}, jsize @var{len})\n+Returns a Java @code{String} made up of @var{len} bytes from @var{bytes}.\n+@end deftypefun\n+\n+\n+@deftypefun jstring JvNewStringLatin1 (const char* @var{bytes})\n+As above but the length of the @code{String} is @code{strlen(@var{bytes})}.\n+@end deftypefun\n+\n+@deftypefun jstring JvNewStringUTF (const char* @var{bytes})\n+Returns a @code{String} which is made up of the UTF encoded characters\n+present in the C string @var{bytes}.\n+@end deftypefun\n+\n+@deftypefun jchar* JvGetStringChars (jstring @var{str})\n+Returns a pointer to an array of characters making up the @code{String} @var{str}.\n+@end deftypefun\n+\n+@deftypefun int JvGetStringUTFLength (jstring @var{str})\n+Returns the number of bytes required to encode the contents of the\n+@code{String} @var{str} in UTF-8.\n+@end deftypefun\n+\n+@deftypefun jsize JvGetStringUTFRegion (jstring @var{str}, jsize @var{start}, jsize @var{len}, char* @var{buf})\n+Puts the UTF-8 encoding of a region of the @code{String} @var{str} into \n+the buffer @code{buf}.  The region to fetch is marked by @var{start} and @var{len}.\n+\n+Note that @var{buf} is a buffer, not a C string.  It is @emph{not} \n+null terminated.\n+@end deftypefun\n+\n+\n+@node Mixing with C++\n+@section Interoperating with C/C++\n+\n+Because @acronym{CNI} is designed to represent Java classes and methods it\n+cannot be mixed readily with C/C++ types.\n+\n+One important restriction is that Java classes cannot have non-Java\n+type instance or static variables and cannot have methods which take\n+non-Java types as arguments or return non-Java types.\n+\n+@noindent None of the following is possible with CNI:\n+\n+@example\n+\n+class ::MyClass : public java::lang::Object\n+@{\n+   char* variable;  // @r{char* is not a valid Java type.}\n+@}\n+\n+\n+uint\n+::SomeClass::someMethod (char *arg)\n+@{\n+  .\n+  .\n+  .\n+@}   // @r{@code{uint} is not a valid Java type, neither is @code{char*}}\n+@end example\n+\n+@noindent Of course, it is ok to use C/C++ types within the scope of a method:\n+\n+\n+@example\n+jint\n+::SomeClass::otherMethod (jstring str)\n+@{\n+   char *arg = ...\n+   .\n+   .\n+   .\n+@}\n+@end example\n+\n+But this restriction can cause a problem so @acronym{CNI} includes the\n+@code{GcjRaw} class.  The @code{GcjRaw} class is a @dfn{non-scanned reference} \n+type.  In other words variables declared of type @code{GcjRaw} can\n+contain any data and are not checked by the compiler in any way.\n+\n+This means that you can put C/C++ data structures (including classes)\n+in your @acronym{CNI} classes, as long as you use the appropriate cast.\n+\n+@noindent Here are some examples:\n+\n+@example\n+\n+class ::MyClass : public java::lang::Object\n+@{\n+   GcjRaw string;\n+\n+   MyClass ();\n+   GcjRaw getText ();\n+   void printText ();\n+@}\n+\n+::MyClass::MyClass ()\n+@{\n+   char* text = ...\n+   string = text;\n+@}\n+\n+GcjRaw\n+::MyClass::getText ()\n+@{\n+   return string;\n+@}\n+\n+void\n+::MyClass::printText ()\n+@{\n+  printf(\"%s\\n\", (char*) string);\n+@}\n+@end example\n+\n+\n+@node Exception Handling\n+@section Exception Handling\n+\n+While C++ and Java share a common exception handling framework,\n+things are not yet perfectly integrated.  The main issue is that the\n+run-time type information facilities of the two\n+languages are not integrated.\n+\n+Still, things work fairly well.  You can throw a Java exception from\n+C++ using the ordinary @code{throw} construct, and this\n+exception can be caught by Java code.  Similarly, you can catch an\n+exception thrown from Java using the C++ @code{catch}\n+construct.\n+\n+@noindent Here is an example:\n+\n+@example\n+if (i >= count)\n+   throw new java::lang::IndexOutOfBoundsException();\n+@end example\n+\n+Normally, G++ will automatically detect when you are writing C++\n+code that uses Java exceptions, and handle them appropriately.\n+However, if C++ code only needs to execute destructors when Java\n+exceptions are thrown through it, GCC will guess incorrectly.  Sample\n+problematic code:\n+\n+@example\n+struct S @{ ~S(); @};\n+\n+extern void bar();    // @r{Is implemented in Java and may throw exceptions.}\n+\n+void foo()\n+@{\n+  S s;\n+  bar();\n+@}\n+@end example\n+\n+The usual effect of an incorrect guess is a link failure, complaining of\n+a missing routine called @code{__gxx_personality_v0}.\n+\n+You can inform the compiler that Java exceptions are to be used in a\n+translation unit, irrespective of what it might think, by writing\n+@code{#pragma GCC java_exceptions} at the head of the\n+file.  This @code{#pragma} must appear before any\n+functions that throw or catch exceptions, or run destructors when\n+exceptions are thrown through them.\n+\n+@node Synchronization\n+@section Synchronization\n+\n+Each Java object has an implicit monitor.\n+The Java VM uses the instruction @code{monitorenter} to acquire\n+and lock a monitor, and @code{monitorexit} to release it.\n+\n+The corresponding CNI macros are @code{JvMonitorEnter} and \n+@code{JvMonitorExit} (JNI has similar  methods @code{MonitorEnter}\n+and @code{MonitorExit}).  \n+\n+\n+The Java source language does not provide direct access to these primitives.\n+Instead, there is a @code{synchronized} statement that does an\n+implicit @code{monitorenter} before entry to the block,\n+and does a @code{monitorexit} on exit from the block.\n+Note that the lock has to be released even when the block is abnormally\n+terminated by an exception, which means there is an implicit\n+@code{try finally} surrounding synchronization locks.\n+\n+From C++, it makes sense to use a destructor to release a lock.\n+@acronym{CNI} defines the following utility class:\n+\n+@example\n+class JvSynchronize() @{\n+  jobject obj;\n+  JvSynchronize(jobject o) @{ obj = o; JvMonitorEnter(o); @}\n+  ~JvSynchronize() @{ JvMonitorExit(obj); @}\n+@};\n+@end example\n+\n+So this Java code:\n+\n+@example\n+synchronized (OBJ)\n+@{\n+   CODE\n+@}\n+@end example\n+\n+@noindent might become this C++ code:\n+\n+@example\n+@{\n+   JvSynchronize dummy (OBJ);\n+   CODE;\n+@}\n+@end example\n+\n+Java also has methods with the @code{synchronized} attribute.\n+This is equivalent to wrapping the entire method body in a\n+@code{synchronized} statement.\n+(Alternatively, an implementation could require the caller to do\n+the synchronization.  This is not practical for a compiler, because\n+each virtual method call would have to test at run-time if\n+synchronization is needed.)  Since in @code{gcj}\n+the @code{synchronized} attribute is handled by the\n+method implementation, it is up to the programmer\n+of a synchronized native method to handle the synchronization\n+(in the C++ implementation of the method).\n+In otherwords, you need to manually add @code{JvSynchronize}\n+in a @code{native synchornized} method.\n+\n+\n+@node Reflection\n+@section Reflection\n+\n+Reflection is possible with CNI code, it functions similarly to how it\n+functions with JNI@.\n+\n+@c clean this up...  I mean, what are the types jfieldID and jmethodID in JNI?\n+The types @code{jfieldID} and @code{jmethodID}\n+are as in JNI@.\n+\n+@noindent The functions:\n+\n+@itemize\n+@item @code{JvFromReflectedField},\n+@item @code{JvFromReflectedMethod},\n+@item @code{JvToReflectedField}\n+@item @code{JvToFromReflectedMethod}\n+@end itemize\n+\n+@noindent will be added shortly, as will other functions corresponding to JNI@.\n+\n+\n+\n @node Resources\n @chapter Resources\n "}]}