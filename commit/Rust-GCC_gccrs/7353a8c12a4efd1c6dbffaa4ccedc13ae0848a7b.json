{"sha": "7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM1M2E4YzEyYTRlZmQxYzZkYmZmYWE0Y2NlZGMxM2FlMDg0OGE3Yg==", "commit": {"author": {"name": "Leehod Baruch", "email": "leehod@il.ibm.com", "date": "2005-02-03T16:22:22Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-02-03T16:22:22Z"}, "message": "tree-vectorizer.h (LOC): New type.\n\n        * tree-vectorizer.h (LOC): New type.\n        (UNKNOWN_LOC, EXPR_LOC, LOC_FILE, LOC_LINE): New macros.\n        (loop_line_number): New field in struct _loop_vec_info.\n        (LOOP_VINFO_LOC, LOOP_LOC): New macros.\n\n        * tree-vectorizer.c (input.h): Included.\n        (find_loop_location): New function.\n        (vect_debug_stats): Argument changed from loop to LOC. Computation of\n        loop line number removed.\n        (vect_debug_details): Likewise.\n        (new_loop_vec_info): Initialize new field LOOP_VINFO_LOC.\n\n        (slpeel_make_loop_iterate_ntimes): Call find_loop_location. Argument in\n        call to vect_debug_details/stats changed from loop to loop_loc.\n        (slpeel_tree_duplicate_loop_to_edge_cfg): Likewise.\n        (slpeel_tree_peel_loop_to_edge): Likewise.\n\n        (vect_analyze_offset_expr): Argument in call to vect_debug_details/stats\n        changed from NULL to UNKNOWN_LOC.\n        (vect_get_base_and_offset):\n        (vect_create_addr_base_for_vector_ref):\n        (get_vectype_for_scalar_type):\n        (vect_create_data_ref_ptr):\n        (vect_init_vector):\n        (vect_get_vec_def_for_operand):\n        (vect_finish_stmt_generation):\n        (vectorizable_assignment):\n        (vectorizable_operation):\n        (vectorizable_store):\n        (vectorizable_load):\n        (vect_transform_stmt):\n        (vect_update_ivs_after_vectorizer):\n        (vect_do_peeling_for_loop_bound):\n        (vect_do_peeling_for_alignment):\n        (vect_transform_loop):\n        (vect_is_simple_use):\n        (vect_analyze_operations):\n        (vect_is_simple_iv_evolution):\n        (vect_analyze_scalar_cycles):\n        (vect_analyze_data_ref_dependences):\n        (vect_compute_data_ref_alignment):\n        (vect_enhance_data_refs_alignment):\n        (vect_analyze_data_ref_access):\n        (vect_analyze_data_ref_accesses):\n        (vect_analyze_pointer_ref_access):\n        (vect_get_memtag_and_dr):\n        (vect_analyze_data_refs):\n        (vect_mark_relevant):\n        (vect_stmt_relevant_p):\n        (vect_mark_stmts_to_be_vectorized):\n        (vect_can_advance_ivs_p):\n        (vect_get_loop_niters):\n        (vect_analyze_loop):\n        (vectorize_loops): Likewise.\n\n        (vectorizable_load): Argument in call to vect_debug_details/stats\n        changed from loop to LOOP_LOC (loop_vinfo).\n        (vect_transform_loop):\n        (vect_analyze_operations):\n        (vect_analyze_scalar_cycles):\n        (vect_analyze_data_ref_dependence):\n        (vect_enhance_data_refs_alignment):\n        (vect_analyze_data_ref_accesses):\n        (vect_analyze_pointer_ref_access):\n        (vect_analyze_data_refs):\n        (vect_analyze_loop): Likewise.\n\n        (vect_analyze_loop_form): Argument in call to vect_debug_details/stats\n        changed from loop to loop_loc.\n\n        (vect_enhance_data_refs_alignment): Removed unused variable loop.\n\nFrom-SVN: r94662", "tree": {"sha": "b157d80f51fd99c8e66b6d2648dda3eeef4e3f5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b157d80f51fd99c8e66b6d2648dda3eeef4e3f5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b/comments", "author": null, "committer": null, "parents": [{"sha": "ef302293136af29f6b167bb87f647fca3d423767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef302293136af29f6b167bb87f647fca3d423767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef302293136af29f6b167bb87f647fca3d423767"}], "stats": {"total": 494, "additions": 275, "deletions": 219}, "files": [{"sha": "758614bf09a2bbd4f7455da66c8ca472f2efd5ed", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 256, "deletions": 219, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b", "patch": "@@ -143,6 +143,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-chrec.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"input.h\"\n #include \"tree-vectorizer.h\"\n #include \"tree-pass.h\"\n #include \"langhooks.h\"\n@@ -178,6 +179,7 @@ static void rename_variables_in_loop (struct loop *);\n #ifdef ENABLE_CHECKING\n static void slpeel_verify_cfg_after_peeling (struct loop *, struct loop *);\n #endif\n+static LOC find_loop_location (struct loop *);\n \n \n /*************************************************************************\n@@ -265,8 +267,13 @@ loop_vec_info new_loop_vec_info (struct loop *loop);\n void destroy_loop_vec_info (loop_vec_info);\n stmt_vec_info new_stmt_vec_info (tree, loop_vec_info);\n \n-static bool vect_debug_stats (struct loop *loop);\n-static bool vect_debug_details (struct loop *loop);\n+/*************************************************************************\n+  Vectorization Debug Information.\n+ *************************************************************************/\n+\n+/* Utilities for output formatting. */\n+static bool vect_debug_stats (LOC);\n+static bool vect_debug_details (LOC);\n \n \f\n /*************************************************************************\n@@ -668,6 +675,7 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   tree step = build_int_cst (TREE_TYPE (niters), 1);\n   tree then_label;\n   tree else_label;\n+  LOC loop_loc;\n \n   orig_cond = get_loop_exit_condition (loop);\n #ifdef ENABLE_CHECKING\n@@ -699,7 +707,8 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   /* Remove old loop exit test:  */\n   bsi_remove (&loop_cond_bsi);\n \n-  if (vect_debug_stats (loop) || vect_debug_details (loop))\n+  loop_loc = find_loop_location (loop);\n+  if (vect_debug_details (loop_loc))\n     print_generic_expr (dump_file, cond_stmt, TDF_SLIM);\n \n   loop->nb_iterations = niters;\n@@ -965,6 +974,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   basic_block bb_before_first_loop;\n   basic_block bb_between_loops;\n   edge exit_e = loop->exit_edges [0];\n+  LOC loop_loc;\n   \n   if (!slpeel_can_duplicate_loop_p (loop, e))\n     return NULL;\n@@ -992,7 +1002,9 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   \n   if (!(new_loop = slpeel_tree_duplicate_loop_to_edge_cfg (loop, loops, e)))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      loop_loc = find_loop_location (loop);\n+      if (vect_debug_stats (loop_loc)\n+          || vect_debug_details (loop_loc))\n         fprintf (dump_file, \"tree_duplicate_loop_to_edge_cfg failed.\\n\");\n       return NULL;\n     }\n@@ -1106,6 +1118,48 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   return new_loop;\n }\n \n+/* Function vect_get_loop_location.\n+\n+   Extract the location of the loop in the source code.\n+   If the loop is not well formed for vectorization, an estimated\n+   location is calculated.\n+   Return the loop location if succeed and NULL if not.  */\n+\n+static LOC\n+find_loop_location (struct loop *loop)\n+{\n+  tree node = NULL_TREE;\n+  basic_block bb;\n+  block_stmt_iterator si;\n+\n+  if (!loop)\n+    return UNKNOWN_LOC;\n+\n+  node = get_loop_exit_condition (loop);\n+\n+  if (node && EXPR_P (node) && EXPR_HAS_LOCATION (node)\n+      && EXPR_FILENAME (node) && EXPR_LINENO (node))\n+    return EXPR_LOC (node);\n+\n+  /* If we got here the loop is probably not \"well formed\",\n+     try to estimate the loop location */\n+\n+  if (!loop->header)\n+    return UNKNOWN_LOC;\n+\n+  bb = loop->header;\n+\n+  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+    {\n+      node = bsi_stmt (si);\n+      if (node && EXPR_P (node) && EXPR_HAS_LOCATION (node))\n+        return EXPR_LOC (node);\n+    }\n+\n+  return UNKNOWN_LOC;\n+}\n+\n+\n \f\n /* Here the proper Vectorizer starts.  */\n \n@@ -1185,6 +1239,7 @@ new_loop_vec_info (struct loop *loop)\n   VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREF_READS (res), 20,\n \t\t\t   \"loop_read_datarefs\");\n   LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n+  LOOP_VINFO_LOC (res) = UNKNOWN_LOC;\n \n   return res;\n }\n@@ -1238,42 +1293,18 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n    For vectorization statistics dumps.  */\n \n static bool\n-vect_debug_stats (struct loop *loop)\n+vect_debug_stats (LOC loc)\n {\n-  basic_block bb;\n-  block_stmt_iterator si;\n-  tree node = NULL_TREE;\n-\n   if (!dump_file || !(dump_flags & TDF_STATS))\n     return false;\n \n-  if (!loop)\n-    {\n-      fprintf (dump_file, \"\\n\");\n-      return true;\n-    }\n-\n-  if (!loop->header)\n-    return false;\n-\n-  bb = loop->header;\n-\n-  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-    {\n-      node = bsi_stmt (si);\n-      if (node && EXPR_P (node) && EXPR_LOCUS (node))\n-        break;\n-    }\n-\n-  if (node && EXPR_P (node) && EXPR_LOCUS (node) \n-      && EXPR_FILENAME (node) && EXPR_LINENO (node))\n-    {\n-      fprintf (dump_file, \"\\nloop at %s:%d: \", \n-\tEXPR_FILENAME (node), EXPR_LINENO (node));\n-      return true;\n-    }\n+  if (loc == UNKNOWN_LOC)\n+    fprintf (dump_file, \"\\n\");\n+  else\n+    fprintf (dump_file, \"\\nloop at %s:%d: \",\n+             LOC_FILE (loc), LOC_LINE (loc));\n \n-  return false;\n+  return true;\n }\n \n \n@@ -1282,42 +1313,18 @@ vect_debug_stats (struct loop *loop)\n    For vectorization debug dumps.  */\n \n static bool\n-vect_debug_details (struct loop *loop)\n+vect_debug_details (LOC loc)\n {\n-   basic_block bb;\n-   block_stmt_iterator si;\n-   tree node = NULL_TREE;\n-\n   if (!dump_file || !(dump_flags & TDF_DETAILS))\n     return false;\n-\n-  if (!loop)\n-    {\n-      fprintf (dump_file, \"\\n\");\n-      return true;\n-    }\n-\n-  if (!loop->header)\n-    return false;\n-\n-  bb = loop->header;\n-\n-  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-    {\n-      node = bsi_stmt (si);\n-      if (node && EXPR_P (node) && EXPR_LOCUS (node))\n-\tbreak;\n-    }\n-\n-  if (node && EXPR_P (node) && EXPR_LOCUS (node)\n-      && EXPR_FILENAME (node) && EXPR_LINENO (node))\n-    {\n-      fprintf (dump_file, \"\\nloop at %s:%d: \", \n-               EXPR_FILENAME (node), EXPR_LINENO (node));\n-      return true;\n-    }\n-\n-  return false;\n+   \n+  if (loc == UNKNOWN_LOC)\n+    fprintf (dump_file, \"\\n\");\n+  else\n+    fprintf (dump_file, \"\\nloop at %s:%d: \",\n+             LOC_FILE (loc), LOC_LINE (loc));\n+    \n+  return true;\n }\n \n \n@@ -1470,7 +1477,7 @@ vect_analyze_offset_expr (tree expr,\n   if (!BINARY_CLASS_P (expr))\n     {\n       /* We expect to get binary expressions (PLUS/MINUS and MULT).  */\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         {\n \t  fprintf (dump_file, \"Not binary expression \");\n           print_generic_expr (dump_file, expr, TDF_SLIM);\n@@ -1715,7 +1722,7 @@ vect_get_base_and_offset (struct data_reference *dr,\n       /* Check that there is no remainder in bits.  */\n       if (pbitpos%BITS_PER_UNIT)\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"bit offset alignment.\");\n \t  return NULL_TREE;\n \t}\n@@ -1744,7 +1751,7 @@ vect_get_base_and_offset (struct data_reference *dr,\n \n       *initial_offset = size_binop (PLUS_EXPR, *initial_offset, this_offset);\n \n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         {\n           print_generic_expr (dump_file, expr, TDF_SLIM);\n           fprintf (dump_file, \"\\n --> total offset for ref: \");\n@@ -1965,7 +1972,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   TREE_OPERAND (vec_stmt, 0) = new_temp;\n   append_to_statement_list_force (vec_stmt, new_stmt_list);\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"created \");\n       print_generic_expr (dump_file, vec_stmt, TDF_SLIM);\n@@ -1996,7 +2003,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n   nunits = UNITS_PER_SIMD_WORD / nbytes;\n \n   vectype = build_vector_type (scalar_type, nunits);\n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"get vectype with %d units of type \", nunits);\n       print_generic_expr (dump_file, scalar_type, TDF_SLIM);\n@@ -2005,7 +2012,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n   if (!vectype)\n     return NULL_TREE;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"vectype: \");\n       print_generic_expr (dump_file, vectype, TDF_SLIM);\n@@ -2016,7 +2023,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n       /* TODO: tree-complex.c sometimes can parallelize operations\n          on generic vectors.  We can vectorize the loop in that case,\n          but then we should re-run the lowering pass.  */\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"mode not supported by target.\");\n       return NULL_TREE;\n     }\n@@ -2120,7 +2127,7 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tree type, tmp, size;\n \n   base_name = unshare_expr (DR_BASE_NAME (dr));\n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       tree data_ref_base = base_name;\n       fprintf (dump_file, \"create array_ref of type: \");\n@@ -2287,7 +2294,7 @@ vect_init_vector (tree stmt, tree vector_var)\n   new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n   gcc_assert (!new_bb);\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"created new init_stmt: \");\n       print_generic_expr (dump_file, init_stmt, TDF_SLIM);\n@@ -2327,7 +2334,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   tree def;\n   int i;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"vect_get_vec_def_for_operand: \");\n       print_generic_expr (dump_file, op, TDF_SLIM);\n@@ -2342,7 +2349,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n       tree vec_cst;\n \n       /* Build a tree with vector elements.  */\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"Create vector_cst. nunits = %d\", nunits);\n \n       for (i = nunits - 1; i >= 0; --i)\n@@ -2360,7 +2367,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   def_stmt = SSA_NAME_DEF_STMT (op);\n   def_stmt_info = vinfo_for_stmt (def_stmt);\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"vect_get_vec_def_for_operand: def_stmt: \");\n       print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n@@ -2386,7 +2393,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   bb = bb_for_stmt (def_stmt);\n   if (TREE_CODE (def_stmt) == PHI_NODE && flow_bb_inside_loop_p (loop, bb))\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"reduction/induction - unsupported.\");\n       internal_error (\"no support for reduction/induction\"); /* FORNOW */\n     }\n@@ -2409,7 +2416,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n       def = op;\n       break;\n     default:\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \t{\n           fprintf (dump_file, \"unsupported defining stmt: \");\n \t  print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n@@ -2419,7 +2426,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n \n   /* Build a tree with vector elements. Create 'vec_inv = {inv,inv,..,inv}'  */\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"Create vector_inv.\");\n \n   for (i = nunits - 1; i >= 0; --i)\n@@ -2441,7 +2448,7 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n {\n   bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"add new stmt: \");\n       print_generic_expr (dump_file, vec_stmt, TDF_SLIM);\n@@ -2491,7 +2498,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op = TREE_OPERAND (stmt, 1);\n   if (!vect_is_simple_use (op, loop_vinfo, NULL))\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"use not simple.\");\n       return false;\n     }\n@@ -2503,7 +2510,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     }\n \n   /** Transform.  **/\n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"transform assignment.\");\n \n   /* Handle def.  */\n@@ -2564,7 +2571,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op_type = TREE_CODE_LENGTH (code);\n   if (op_type != unary_op && op_type != binary_op)\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"num. args = %d (not unary/binary op).\", op_type);\n       return false;\n     }\n@@ -2574,7 +2581,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       op = TREE_OPERAND (operation, i);\n       if (!vect_is_simple_use (op, loop_vinfo, NULL))\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"use not simple.\");\n \t  return false;\n \t}\t\n@@ -2583,14 +2590,14 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   /* Supportable by target?  */\n   if (!optab)\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"no optab.\");\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n   if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"op not supported by target.\");\n       return false;\n     }\n@@ -2603,7 +2610,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"transform binary/unary operation.\");\n \n   /* Handle def.  */\n@@ -2672,7 +2679,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op = TREE_OPERAND (stmt, 1);\n   if (!vect_is_simple_use (op, loop_vinfo, NULL))\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"use not simple.\");\n       return false;\n     }\n@@ -2695,7 +2702,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"transform store\");\n \n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n@@ -2770,7 +2777,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     (e.g. - data copies).  */\n   if (mov_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"Aligned load, but unsupported type.\");\n       return false;\n     }\n@@ -2783,7 +2790,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"transform load.\");\n \n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n@@ -2990,7 +2997,7 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n       is_store = true;\n       break;\n     default:\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"stmt not supported.\");\n       gcc_unreachable ();\n     }\n@@ -3163,7 +3170,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       /* Skip virtual phi's.  */\n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"virtual phi. skip.\");\n \t  continue;\n \t}\n@@ -3227,7 +3234,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   int loop_num;\n #endif\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_transtorm_for_unknown_loop_bound>>\\n\");\n \n   /* Generate the following variables on the preheader of original loop:\n@@ -3429,7 +3436,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   tree n_iters;\n   struct loop *new_loop;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_do_peeling_for_alignment>>\\n\");\n \n   ni_name = vect_build_loop_niters (loop_vinfo);\n@@ -3477,7 +3484,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   tree ratio = NULL;\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vec_transform_loop>>\\n\");\n \n   \n@@ -3526,7 +3533,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t  stmt_vec_info stmt_info;\n \t  bool is_store;\n \n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    {\n \t      fprintf (dump_file, \"------>vectorizing statement: \");\n \t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -3546,7 +3553,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t\t == vectorization_factor);\n #endif\n \t  /* -------- vectorize statement ------------ */\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"transform statement.\");\n \n \t  is_store = vect_transform_stmt (stmt, &si);\n@@ -3566,9 +3573,9 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \n   slpeel_make_loop_iterate_ntimes (loop, ratio);\n \n-  if (vect_debug_details (loop))\n+  if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n     fprintf (dump_file,\"Success! loop vectorized.\");\n-  if (vect_debug_stats (loop))\n+  if (vect_debug_stats (LOOP_LOC (loop_vinfo)))\n     fprintf (dump_file, \"LOOP VECTORIZED.\");\n }\n \n@@ -3605,7 +3612,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def)\n   def_stmt = SSA_NAME_DEF_STMT (operand);\n   if (def_stmt == NULL_TREE )\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"no def_stmt.\");\n       return false;\n     }\n@@ -3617,7 +3624,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def)\n       tree arg = TREE_OPERAND (def_stmt, 0);\n       if (TREE_CODE (arg) == INTEGER_CST || TREE_CODE (arg) == REAL_CST)\n \treturn true;\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \t{\n \t  fprintf (dump_file, \"Unexpected empty stmt: \");\n \t  print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n@@ -3630,7 +3637,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def)\n   bb = bb_for_stmt (def_stmt);\n   if (TREE_CODE (def_stmt) == PHI_NODE && flow_bb_inside_loop_p (loop, bb))\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"reduction/induction - unsupported.\");\n       return false; /* FORNOW: not supported yet.  */\n     }\n@@ -3664,7 +3671,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   bool ok;\n   tree scalar_type;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_analyze_operations>>\\n\");\n \n   for (i = 0; i < nbbs; i++)\n@@ -3678,7 +3685,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \t  tree vectype;\n \n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    {\n \t      fprintf (dump_file, \"==> examining statement: \");\n \t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -3695,14 +3702,15 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n \t    {\n-\t      if (vect_debug_details (NULL))\n+\t      if (vect_debug_details (UNKNOWN_LOC))\n \t        fprintf (dump_file, \"irrelevant.\");\n \t      continue;\n \t    }\n \n \t  if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n \t    {\n-\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+                  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \t\t{\n                   fprintf (dump_file, \"not vectorized: vector stmt in loop:\");\n \t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -3717,7 +3725,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  else\n \t    scalar_type = TREE_TYPE (stmt);\n \n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    {\n \t      fprintf (dump_file, \"get vectype for scalar type:  \");\n \t      print_generic_expr (dump_file, scalar_type, TDF_SLIM);\n@@ -3726,15 +3734,16 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vectype)\n \t    {\n-\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+                  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \t\t{\n                   fprintf (dump_file, \"not vectorized: unsupported data-type \");\n \t\t  print_generic_expr (dump_file, scalar_type, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n \n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    {\n \t      fprintf (dump_file, \"vectype: \");\n \t      print_generic_expr (dump_file, vectype, TDF_SLIM);\n@@ -3748,7 +3757,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t  if (!ok)\n \t    {\n-\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+                  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \t\t{\n                   fprintf (dump_file, \"not vectorized: stmt not supported: \");\n \t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -3757,7 +3767,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t    }\n \n \t  nunits = GET_MODE_NUNITS (TYPE_MODE (vectype));\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"nunits = %d\", nunits);\n \n \t  if (vectorization_factor)\n@@ -3766,7 +3776,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t         This restriction will be relaxed in the future.  */\n \t      if (nunits != vectorization_factor)\n \t\t{\n-\t          if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t          if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+                      || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \t\t    fprintf (dump_file, \"not vectorized: mixed data-types\");\n \t\t  return false;\n \t\t}\n@@ -3785,39 +3796,45 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n   if (vectorization_factor <= 1)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+          || vect_debug_details (LOOP_LOC (loop_vinfo)))\n         fprintf (dump_file, \"not vectorized: unsupported data-type\");\n       return false;\n     }\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n \n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && vect_debug_details (NULL))\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file,\n         \"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n         vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+          || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"not vectorized: iteration count too small.\");\n       return false;\n     }\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+          || vect_debug_details (LOOP_LOC (loop_vinfo)))\n         fprintf (dump_file, \"epilog loop required.\");\n       if (!vect_can_advance_ivs_p (loop_vinfo))\n         {\n-          if (vect_debug_stats (loop) || vect_debug_details (loop))\n+          if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+              || vect_debug_details (LOOP_LOC (loop_vinfo)))\n             fprintf (dump_file, \"not vectorized: can't create epilog loop 1.\");\n           return false;\n         }\n       if (!slpeel_can_duplicate_loop_p (loop, loop->exit_edges[0]))\n         {\n-          if (vect_debug_stats (loop) || vect_debug_details (loop))\n+          if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+              || vect_debug_details (LOOP_LOC (loop_vinfo)))\n             fprintf (dump_file, \"not vectorized: can't create epilog loop 2.\");\n           return false;\n         }\n@@ -3899,7 +3916,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n   step_expr = evolution_part;\n   init_expr = unshare_expr (initial_condition_in_loop_num (access_fn, loop_nb));\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"step: \");\n       print_generic_expr (dump_file, step_expr, TDF_SLIM);\n@@ -3912,15 +3929,15 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n \n   if (TREE_CODE (step_expr) != INTEGER_CST)\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"step unknown.\");\n       return false;\n     }\n \n   if (strict)\n     if (!integer_onep (step_expr))\n       {\n-        if (vect_debug_details (NULL))\n+        if (vect_debug_details (UNKNOWN_LOC))\n \t  print_generic_expr (dump_file, step_expr, TDF_SLIM);\n         return false;\n       }\n@@ -3973,14 +3990,14 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n   basic_block bb = loop->header;\n   tree dummy;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_analyze_scalar_cycles>>\\n\");\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree access_fn = NULL;\n \n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \t{\n           fprintf (dump_file, \"Analyze phi: \");\n           print_generic_expr (dump_file, phi, TDF_SLIM);\n@@ -3991,7 +4008,7 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n \n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"virtual phi. skip.\");\n \t  continue;\n \t}\n@@ -4013,12 +4030,13 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n \n       if (!access_fn)\n \t{\n-\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t  if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+              || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \t    fprintf (dump_file, \"not vectorized: unsupported scalar cycle.\");\n \t  return false;\n \t}\n \n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         {\n            fprintf (dump_file, \"Access function of PHI: \");\n            print_generic_expr (dump_file, access_fn, TDF_SLIM);\n@@ -4027,7 +4045,8 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n       if (!vect_is_simple_iv_evolution (loop->num, access_fn, &dummy, \n \t\t\t\t\t&dummy, false))\n \t{\n-\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t  if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+              || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \t    fprintf (dump_file, \"not vectorized: unsupported scalar cycle.\");\n \t  return false;\n \t}\n@@ -4049,11 +4068,11 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n {\n   bool differ_p; \n   struct data_dependence_relation *ddr;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   \n   if (!array_base_name_differ_p (dra, drb, &differ_p))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))   \n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_details (LOOP_LOC (loop_vinfo)))   \n         {\n           fprintf (dump_file,\n                 \"not vectorized: can't determine dependence between: \");\n@@ -4073,7 +4092,8 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     return false;\n   \n-  if (vect_debug_stats (loop) || vect_debug_details (loop))\n+  if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+      || vect_debug_details (LOOP_LOC (loop_vinfo)))\n     {\n       fprintf (dump_file,\n \t\"not vectorized: possible dependence between data-refs \");\n@@ -4103,10 +4123,10 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n \n   /* Examine store-store (output) dependences.  */\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_analyze_dependences>>\\n\");\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"compare all store-store pairs.\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_refs); i++)\n@@ -4124,7 +4144,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n \n   /* Examine load-store (true/anti) dependences.  */\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"compare all load-store pairs.\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_refs); i++)\n@@ -4166,7 +4186,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   bool base_aligned_p;\n   tree misalign;\n    \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"vect_compute_data_ref_alignment:\");\n \n   /* Initialize misalignment to unknown.  */\n@@ -4179,7 +4199,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n   if (!misalign)\n     {\n-      if (vect_debug_details (NULL)) \n+      if (vect_debug_details (UNKNOWN_LOC)) \n \t{\n \t  fprintf (dump_file, \"Unknown alignment for access: \");\n \t  print_generic_expr (dump_file, base, TDF_SLIM);\n@@ -4191,7 +4211,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n     {\n       if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype)))\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    {\n \t      fprintf (dump_file, \"can't force alignment of ref: \");\n \t      print_generic_expr (dump_file, ref, TDF_SLIM);\n@@ -4202,7 +4222,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       /* Force the alignment of the decl.\n \t NOTE: This is the only change to the code we make during\n \t the analysis phase, before deciding to vectorize the loop.  */\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"force alignment\");\n       DECL_ALIGN (base) = TYPE_ALIGN (vectype);\n       DECL_USER_ALIGN (base) = 1;\n@@ -4221,14 +4241,14 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   if (tree_int_cst_sgn (misalign) < 0)\n     {\n       /* Negative misalignment value.  */\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"unexpected misalign value\");\n       return false;\n     }\n \n   DR_MISALIGNMENT (dr) = tree_low_cst (misalign, 1);\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"misalign = %d\", DR_MISALIGNMENT (dr));\n \n   return true;\n@@ -4284,7 +4304,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   unsigned int i;\n \n   /*\n@@ -4399,12 +4418,12 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (!LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"Peeling for alignment will not be applied.\");\n       return;\n     }\n   else\n-    if (vect_debug_details (loop))\n+    if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n       fprintf (dump_file, \"Peeling for alignment will be applied.\");\n \n \n@@ -4429,7 +4448,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (dr == LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n \t{\n \t  DR_MISALIGNMENT (dr) = 0;\n-\t  if (vect_debug_details (loop) || vect_debug_stats (loop))\n+\t  if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n+\t      || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n \t    fprintf (dump_file, \"Alignment of access forced using peeling.\");\n \t}\n       else\n@@ -4441,7 +4461,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (dr == LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n \t{\n \t  DR_MISALIGNMENT (dr) = 0;\n-\t  if (vect_debug_details (loop) || vect_debug_stats (loop))\n+\t  if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n+\t      || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n \t    fprintf (dump_file, \"Alignment of access forced using peeling.\");\n \t}\n       else\n@@ -4462,11 +4483,10 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_analyze_data_refs_alignment>>\\n\");\n \n \n@@ -4475,7 +4495,8 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (!vect_compute_data_refs_alignment (loop_vinfo))\n     {\n-      if (vect_debug_details (loop) || vect_debug_stats (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \n \t\t \"not vectorized: can't calculate alignment for data ref.\");\n       return false;\n@@ -4497,12 +4518,14 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n \t{\n-\t  if (vect_debug_details (loop) || vect_debug_stats (loop))\n+\t  if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n+\t      || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n \t    fprintf (dump_file, \"not vectorized: unsupported unaligned load.\");\n \t  return false;\n \t}\n       if (supportable_dr_alignment != dr_aligned \n-\t  && (vect_debug_details (loop) || vect_debug_stats (loop)))\n+\t  && (vect_debug_details (LOOP_LOC (loop_vinfo)) \n+\t      || vect_debug_stats (LOOP_LOC (loop_vinfo))))\n \tfprintf (dump_file, \"Vectorizing an unaligned access.\");\n     }\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n@@ -4511,12 +4534,14 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n \t{\n-\t  if (vect_debug_details (loop) || vect_debug_stats (loop))\n+\t  if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n+\t      || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n \t    fprintf (dump_file, \"not vectorized: unsupported unaligned store.\");\n \t  return false;\n \t}\n       if (supportable_dr_alignment != dr_aligned \n-\t  && (vect_debug_details (loop) || vect_debug_stats (loop)))\n+\t  && (vect_debug_details (LOOP_LOC (loop_vinfo)) \n+\t      || vect_debug_stats (LOOP_LOC (loop_vinfo))))\n \tfprintf (dump_file, \"Vectorizing an unaligned access.\");\n     }\n \n@@ -4539,7 +4564,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n   if (!step || tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"not consecutive access\");\n       return false;\n     }\n@@ -4563,7 +4588,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_analyze_data_ref_accesses>>\\n\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n@@ -4572,8 +4597,8 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n       bool ok = vect_analyze_data_ref_access (dr);\n       if (!ok)\n \t{\n-\t  if (vect_debug_stats (LOOP_VINFO_LOOP (loop_vinfo))\n-\t      || vect_debug_details (LOOP_VINFO_LOOP (loop_vinfo)))\n+\t  if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+\t      || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \t    fprintf (dump_file, \"not vectorized: complicated access pattern.\");\n \t  return false;\n \t}\n@@ -4585,8 +4610,8 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n       bool ok = vect_analyze_data_ref_access (dr);\n       if (!ok)\n \t{\n-\t  if (vect_debug_stats (LOOP_VINFO_LOOP (loop_vinfo))\n-\t      || vect_debug_details (LOOP_VINFO_LOOP (loop_vinfo))) \n+\t  if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n+\t      || vect_debug_details (LOOP_LOC (loop_vinfo))) \n \t    fprintf (dump_file, \"not vectorized: complicated access pattern.\");\n \t  return false;\n \t}\n@@ -4620,20 +4645,22 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n \n   if (!access_fn)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n         fprintf (dump_file, \"not vectorized: complicated pointer access.\");\t\n       return NULL;\n     }\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     {\n       fprintf (dump_file, \"Access function of ptr: \");\n       print_generic_expr (dump_file, access_fn, TDF_SLIM);\n     }\n \n   if (!vect_is_simple_iv_evolution (loopnum, access_fn, &init, &step, false))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop)) \n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n \tfprintf (dump_file, \"not vectorized: pointer access is not simple.\");\t\n       return NULL;\n     }\n@@ -4642,15 +4669,17 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n \n   if (!expr_invariant_in_loop_p (loop, init))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop)) \n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n \tfprintf (dump_file, \n \t\t \"not vectorized: initial condition is not loop invariant.\");\t\n       return NULL;\n     }\n \n   if (TREE_CODE (step) != INTEGER_CST)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop)) \n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n \tfprintf (dump_file, \n \t\t\"not vectorized: non constant step for pointer access.\");\t\n       return NULL;\n@@ -4659,15 +4688,17 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n   reftype = TREE_TYPE (TREE_OPERAND (memref, 0));\n   if (TREE_CODE (reftype) != POINTER_TYPE) \n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"not vectorized: unexpected pointer access form.\");\t\n       return NULL;\n     }\n \n   reftype = TREE_TYPE (init);\n   if (TREE_CODE (reftype) != POINTER_TYPE) \n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop)) \n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n \tfprintf (dump_file, \"not vectorized: unexpected pointer access form.\");\n       return NULL;\n     }\n@@ -4676,7 +4707,8 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n   if (tree_int_cst_compare (TYPE_SIZE_UNIT (innertype), step))\n     {\n       /* FORNOW: support only consecutive access */\n-      if (vect_debug_stats (loop) || vect_debug_details (loop)) \n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n \tfprintf (dump_file, \"not vectorized: non consecutive access.\");\t\n       return NULL;\n     }\n@@ -4692,7 +4724,7 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n \n   indx_access_fn = \n \tbuild_polynomial_chrec (loopnum, integer_zero_node, integer_one_node);\n-  if (vect_debug_details (NULL)) \n+  if (vect_debug_details (LOOP_LOC (loop_vinfo))) \n     {\n       fprintf (dump_file, \"Access function of ptr indx: \");\n       print_generic_expr (dump_file, indx_access_fn, TDF_SLIM);\n@@ -4766,7 +4798,7 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n \t    }\n \t  if (!tag)\n \t    {\n-\t      if (vect_debug_details (NULL))\n+\t      if (vect_debug_details (UNKNOWN_LOC))\n \t\tfprintf (dump_file, \"not vectorized: no memtag for ref.\");\n \t      return NULL_TREE;\n \t    }\n@@ -4924,7 +4956,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n   int j;\n   struct data_reference *dr;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_analyze_data_refs>>\\n\");\n \n   for (j = 0; j < nbbs; j++)\n@@ -4956,7 +4988,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \n \t  if (nvuses && (nv_may_defs || nv_must_defs))\n \t    {\n-\t      if (vect_debug_details (NULL))\n+\t      if (vect_debug_details (UNKNOWN_LOC))\n \t\t{\n \t\t  fprintf (dump_file, \"unexpected vdefs and vuses in stmt: \");\n \t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -4966,7 +4998,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \n \t  if (TREE_CODE (stmt) != MODIFY_EXPR)\n \t    {\n-\t      if (vect_debug_details (NULL))\n+\t      if (vect_debug_details (UNKNOWN_LOC))\n \t\t{\n \t\t  fprintf (dump_file, \"unexpected vops in stmt: \");\n \t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -4991,7 +5023,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vectype)\n \t    {\n-\t      if (vect_debug_details (NULL))\n+\t      if (vect_debug_details (UNKNOWN_LOC))\n \t\t{\n \t\t  fprintf (dump_file, \"no vectype for stmt: \");\n \t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -5008,7 +5040,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t\t\t\t\t  vectype, &dr);\n \t  if (!symbl)\n \t    {\n-\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n+\t\t  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n \t\t{\n \t\t  fprintf (dump_file, \"not vectorized: unhandled data ref: \"); \n \t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -5037,7 +5070,7 @@ vect_mark_relevant (varray_type *worklist, tree stmt)\n {\n   stmt_vec_info stmt_info;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"mark relevant.\");\n \n   if (TREE_CODE (stmt) == PHI_NODE)\n@@ -5050,7 +5083,7 @@ vect_mark_relevant (varray_type *worklist, tree stmt)\n \n   if (!stmt_info)\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \t{\n \t  fprintf (dump_file, \"mark relevant: no stmt info!!.\");\n \t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -5060,7 +5093,7 @@ vect_mark_relevant (varray_type *worklist, tree stmt)\n \n   if (STMT_VINFO_RELEVANT_P (stmt_info))\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"already marked relevant.\");\n       return;\n     }\n@@ -5101,7 +5134,7 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n   v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n   if (v_may_defs || v_must_defs)\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         fprintf (dump_file, \"vec_stmt_relevant_p: stmt has vdefs.\");\n       return true;\n     }\n@@ -5115,7 +5148,7 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n       basic_block bb = bb_for_stmt (use);\n       if (!flow_bb_inside_loop_p (loop, bb))\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"vec_stmt_relevant_p: used out of loop.\");\n \t  return true;\n \t}\n@@ -5158,21 +5191,21 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   basic_block bb;\n   tree phi;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<vect_mark_stmts_to_be_vectorized>>\\n\");\n \n   bb = loop->header;\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         {\n           fprintf (dump_file, \"init: phi relevant? \");\n           print_generic_expr (dump_file, phi, TDF_SLIM);\n         }\n \n       if (vect_stmt_relevant_p (phi, loop_vinfo))\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"unsupported reduction/induction.\");\n           return false;\n \t}\n@@ -5189,7 +5222,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t{\n \t  stmt = bsi_stmt (si);\n \n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    {\n \t      fprintf (dump_file, \"init: stmt relevant? \");\n \t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -5211,7 +5244,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       stmt = VARRAY_TOP_TREE (worklist);\n       VARRAY_POP (worklist);\n \n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \t{\n           fprintf (dump_file, \"worklist: examine stmt: \");\n           print_generic_expr (dump_file, stmt, TDF_SLIM);\n@@ -5231,15 +5264,15 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      basic_block bb;\n \t      if (!vect_is_simple_use (arg, loop_vinfo, &def_stmt))\n \t\t{\n-\t\t  if (vect_debug_details (NULL))\t\n+\t\t  if (vect_debug_details (UNKNOWN_LOC))\t\n \t\t    fprintf (dump_file, \"worklist: unsupported use.\");\n \t\t  varray_clear (worklist);\n \t\t  return false;\n \t\t}\n \t      if (!def_stmt)\n \t\tcontinue;\n \n-\t      if (vect_debug_details (NULL))\n+\t      if (vect_debug_details (UNKNOWN_LOC))\n \t        {\n \t          fprintf (dump_file, \"worklist: def_stmt: \");\n \t\t  print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n@@ -5267,7 +5300,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n               basic_block bb;\n               if (!vect_is_simple_use (use, loop_vinfo, &def_stmt))\n                 {\n-                  if (vect_debug_details (NULL))        \n+                  if (vect_debug_details (UNKNOWN_LOC))        \n                     fprintf (dump_file, \"worklist: unsupported use.\");\n                   varray_clear (worklist);\n                   return false;\n@@ -5276,7 +5309,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      if (!def_stmt)\n \t\tcontinue;\n \n-              if (vect_debug_details (NULL))\n+              if (vect_debug_details (UNKNOWN_LOC))\n                 {\n                   fprintf (dump_file, \"worklist: examine use %d: \", i);\n                   print_generic_expr (dump_file, use, TDF_SLIM);\n@@ -5317,7 +5350,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n       tree access_fn = NULL;\n       tree evolution_part;\n \n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \t{\n           fprintf (dump_file, \"Analyze phi: \");\n           print_generic_expr (dump_file, phi, TDF_SLIM);\n@@ -5328,7 +5361,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"virtual phi. skip.\");\n \t  continue;\n \t}\n@@ -5340,12 +5373,12 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (!access_fn)\n \t{\n-\t  if (vect_debug_details (NULL))\n+\t  if (vect_debug_details (UNKNOWN_LOC))\n \t    fprintf (dump_file, \"No Access function.\");\n \t  return false;\n \t}\n \n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n         {\n \t  fprintf (dump_file, \"Access function of PHI: \");\n \t  print_generic_expr (dump_file, access_fn, TDF_SLIM);\n@@ -5379,7 +5412,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n {\n   tree niters;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<get_loop_niters>>\\n\");\n \n   niters = number_of_iterations_in_loop (loop);\n@@ -5389,7 +5422,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n     {\n       *number_of_iterations = niters;\n \n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \t{\n \t  fprintf (dump_file, \"==> get_loop_niters:\" );\n \t  print_generic_expr (dump_file, *number_of_iterations, TDF_SLIM);\n@@ -5417,8 +5450,11 @@ vect_analyze_loop_form (struct loop *loop)\n   tree loop_cond;\n   tree number_of_iterations = NULL;\n   bool rescan = false;\n+  LOC loop_loc;\n+\n+  loop_loc = find_loop_location (loop);\n \n-  if (vect_debug_details (loop))\n+  if (vect_debug_details (loop_loc))\n     fprintf (dump_file, \"\\n<<vect_analyze_loop_form>>\\n\");\n \n   if (loop->inner\n@@ -5427,7 +5463,7 @@ vect_analyze_loop_form (struct loop *loop)\n       || EDGE_COUNT (loop->header->preds) != 2\n       || loop->num_entries != 1)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\t\n \t{\n \t  fprintf (dump_file, \"not vectorized: bad loop form. \");\n \t  if (loop->inner)\n@@ -5451,7 +5487,7 @@ vect_analyze_loop_form (struct loop *loop)\n      executable statements, and the latch is empty.  */\n   if (!empty_block_p (loop->latch))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n         fprintf (dump_file, \"not vectorized: unexpectd loop form.\");\n       return NULL;\n     }\n@@ -5479,30 +5515,30 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (empty_block_p (loop->header))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n         fprintf (dump_file, \"not vectorized: empty loop.\");\n       return NULL;\n     }\n \n   loop_cond = vect_get_loop_niters (loop, &number_of_iterations);\n   if (!loop_cond)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n \tfprintf (dump_file, \"not vectorized: complicated exit condition.\");\n       return NULL;\n     }\n   \n   if (!number_of_iterations) \n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n \tfprintf (dump_file, \n \t\t \"not vectorized: number of iterations cannot be computed.\");\n       return NULL;\n     }\n \n   if (chrec_contains_undetermined (number_of_iterations))\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (loop_loc))\n         fprintf (dump_file, \"Infinite number of iterations.\");\n       return false;\n     }\n@@ -5512,7 +5548,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (loop_loc))\n         {\n           fprintf (dump_file, \"loop bound unknown.\\n\");\n           fprintf (dump_file, \"Symbolic number of iterations is \");\n@@ -5522,12 +5558,13 @@ vect_analyze_loop_form (struct loop *loop)\n   else\n   if (LOOP_VINFO_INT_NITERS (loop_vinfo) == 0)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\tfprintf (dump_file, \"not vectorized: number of iterations = 0.\");\n+      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n+        fprintf (dump_file, \"not vectorized: number of iterations = 0.\");\n       return NULL;\n     }\n \n   LOOP_VINFO_EXIT_COND (loop_vinfo) = loop_cond;\n+  LOOP_VINFO_LOC (loop_vinfo) = loop_loc;\n \n   return loop_vinfo;\n }\n@@ -5545,15 +5582,15 @@ vect_analyze_loop (struct loop *loop)\n   bool ok;\n   loop_vec_info loop_vinfo;\n \n-  if (vect_debug_details (NULL))\n+  if (vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\n<<<<<<< analyze_loop_nest >>>>>>>\\n\");\n \n   /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n \n   loop_vinfo = vect_analyze_loop_form (loop);\n   if (!loop_vinfo)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"bad loop form.\");\n       return NULL;\n     }\n@@ -5567,7 +5604,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_refs (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"bad data references.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -5578,9 +5615,9 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"unexpected pattern.\");\n-      if (vect_debug_details (loop))\n+      if (vect_debug_stats (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"not vectorized: unexpected pattern.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -5592,7 +5629,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_scalar_cycles (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"bad scalar cycle.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -5604,7 +5641,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_ref_dependences (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"bad data dependence.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -5616,7 +5653,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_ref_accesses (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"bad data access.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -5628,7 +5665,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"bad data alignment.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -5640,7 +5677,7 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_operations (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (loop))\n+      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n \tfprintf (dump_file, \"bad operation or unsupported loop bound.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n@@ -5679,7 +5716,7 @@ vectorize_loops (struct loops *loops)\n   /* FORNOW: until more sophisticated machine modelling is in place.  */\n   if (!UNITS_PER_SIMD_WORD)\n     {\n-      if (vect_debug_details (NULL))\n+      if (vect_debug_details (UNKNOWN_LOC))\n \tfprintf (dump_file, \"vectorizer: target vector size is not defined.\");\n       return;\n     }\n@@ -5714,7 +5751,7 @@ vectorize_loops (struct loops *loops)\n       num_vectorized_loops++;\n     }\n \n-  if (vect_debug_stats (NULL) || vect_debug_details (NULL))\n+  if (vect_debug_stats (UNKNOWN_LOC) || vect_debug_details (UNKNOWN_LOC))\n     fprintf (dump_file, \"\\nvectorized %u loops in function.\\n\",\n \t     num_vectorized_loops);\n "}, {"sha": "537e963542c33ec0202c2bbfd1c44cf4ed9c8e78", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7353a8c12a4efd1c6dbffaa4ccedc13ae0848a7b", "patch": "@@ -22,6 +22,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_TREE_VECTORIZER_H\n #define GCC_TREE_VECTORIZER_H\n \n+#ifdef USE_MAPPED_LOCATION\n+  typedef source_location LOC;\n+  #define UNKNOWN_LOC UNKNOWN_LOCATION\n+  #define EXPR_LOC(e) EXPR_LOCATION(e)\n+  #define LOC_FILE(l) LOCATION_FILE (l)\n+  #define LOC_LINE(l) LOCATION_LINE (l)\n+#else\n+  typedef source_locus LOC;\n+  #define UNKNOWN_LOC NULL\n+  #define EXPR_LOC(e) EXPR_LOCUS(e)\n+  #define LOC_FILE(l) (l)->file\n+  #define LOC_LINE(l) (l)->line\n+#endif\n+\n /* Used for naming of new temporaries.  */\n enum vect_var_kind {\n   vect_simple_var,\n@@ -78,6 +92,8 @@ typedef struct _loop_vec_info {\n   /* All data references in the loop that are being read from.  */\n   varray_type data_ref_reads;\n \n+  /* The loop location in the source.  */\n+  LOC loop_line_number;\n } *loop_vec_info;\n \n /* Access Functions.  */\n@@ -92,6 +108,9 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_INT_NITERS(L) (TREE_INT_CST_LOW ((L)->num_iters))\n #define LOOP_DO_PEELING_FOR_ALIGNMENT(L) (L)->do_peeling_for_alignment\n #define LOOP_VINFO_UNALIGNED_DR(L) (L)->unaligned_dr\n+#define LOOP_VINFO_LOC(L)          (L)->loop_line_number\n+\n+#define LOOP_LOC(L)    LOOP_VINFO_LOC(L)\n \n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\"}]}