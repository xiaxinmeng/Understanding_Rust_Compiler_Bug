{"sha": "5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZiMGUyNDZmNGQxNmRkMWYzNDFjYzM0ZGVkMTFlYjQ4MTNmZTUwZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-12T18:53:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-12T18:53:17Z"}, "message": "Makefile.in (target-globals.o): Depend on $(RTL_H).\n\ngcc/\n\t* Makefile.in (target-globals.o): Depend on $(RTL_H).\n\t* rtl.h: (target_rtl): New structure.\n\t(default_target_rtl): Declare.\n\t(this_target_rtl): Declare as a variable or define as a macro.\n\t(global_rtl, pic_offset_table_rtx, return_address_pointer_rtx):\n\tRedefine as macros.\n\t* emit-rtl.c (default_target_rtl): New variable.\n\t(this_target_rtl): New conditional variable.\n\t(global_rtl, static_regno_reg_rtx, pic_offset_table_rtx)\n\t(return_address_pointer_rtx): Delete.\n\t(initial_regno_reg_rtx): New macro.\n\t(init_emit): Use initial_regno_reg_rtx instead of static_regno_reg_rtx.\n\t(init_emit_regs): Likewise.\n\t* target-globals.h (this_target_rtl): Declare.\n\t(target_globals): Add a rtl field.\n\t(restore_target_globals): Copy the rtl field to this_target_rtl.\n\t* target-globals.c: Include rtl.h.\n\t(default_target_globals): Initialize the rtl field.\n\t(save_target_globals): Likewise.\n\nFrom-SVN: r162088", "tree": {"sha": "cafe482a7a09e052682a76fb7e607508ee8298a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cafe482a7a09e052682a76fb7e607508ee8298a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "939dcd0d38af0571a15f1bcff788d593ed33d5eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939dcd0d38af0571a15f1bcff788d593ed33d5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939dcd0d38af0571a15f1bcff788d593ed33d5eb"}], "stats": {"total": 132, "additions": 86, "deletions": 46}, "files": [{"sha": "16b777252160b117ebae447d2f7cc4cd3741598b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "patch": "@@ -1,3 +1,25 @@\n+2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* Makefile.in (target-globals.o): Depend on $(RTL_H).\n+\t* rtl.h: (target_rtl): New structure.\n+\t(default_target_rtl): Declare.\n+\t(this_target_rtl): Declare as a variable or define as a macro.\n+\t(global_rtl, pic_offset_table_rtx, return_address_pointer_rtx):\n+\tRedefine as macros.\n+\t* emit-rtl.c (default_target_rtl): New variable.\n+\t(this_target_rtl): New conditional variable.\n+\t(global_rtl, static_regno_reg_rtx, pic_offset_table_rtx)\n+\t(return_address_pointer_rtx): Delete.\n+\t(initial_regno_reg_rtx): New macro.\n+\t(init_emit): Use initial_regno_reg_rtx instead of static_regno_reg_rtx.\n+\t(init_emit_regs): Likewise.\n+\t* target-globals.h (this_target_rtl): Declare.\n+\t(target_globals): Add a rtl field.\n+\t(restore_target_globals): Copy the rtl field to this_target_rtl.\n+\t* target-globals.c: Include rtl.h.\n+\t(default_target_globals): Initialize the rtl field.\n+\t(save_target_globals): Likewise.\n+\n 2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* Makefile.in (target-globals.o): Depend on $(REGS_H)."}, {"sha": "919c5ae8c5e3ccce640c8791103d2fa3b617d519", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "patch": "@@ -3477,7 +3477,7 @@ lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(EXPR_H) $(EXCEPT_H) $(REGS_H) $(TREE_PASS_H) $(DF_H)\n target-globals.o : target-globals.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) insn-config.h $(MACHMODE_H) $(GGC_H) $(TOPLEV_H) target-globals.h \\\n-   $(FLAGS_H) $(REGS_H)\n+   $(FLAGS_H) $(REGS_H) $(RTL_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\"}, {"sha": "bb9f63a66d4fbf3a719fd299a10b5910de92ca41", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 39, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "patch": "@@ -61,6 +61,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"target.h\"\n \n+struct target_rtl default_target_rtl;\n+#if SWITCHABLE_TARGET\n+struct target_rtl *this_target_rtl = &default_target_rtl;\n+#endif\n+\n+#define initial_regno_reg_rtx (this_target_rtl->x_initial_regno_reg_rtx)\n+\n /* Commonly used modes.  */\n \n enum machine_mode byte_mode;\t/* Mode whose width is BITS_PER_UNIT.  */\n@@ -84,19 +91,6 @@ rtx * regno_reg_rtx;\n \n static GTY(()) int label_num = 1;\n \n-/* Commonly used rtx's, so that we only need space for one copy.\n-   These are initialized once for the entire compilation.\n-   All of these are unique; no other rtx-object will be equal to any\n-   of these.  */\n-\n-rtx global_rtl[GR_MAX];\n-\n-/* Commonly used RTL for hard registers.  These objects are not necessarily\n-   unique, so we allocate them separately from global_rtl.  They are\n-   initialized once per compilation unit, then copied into regno_reg_rtx\n-   at the beginning of each function.  */\n-static GTY(()) rtx static_regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n-\n /* We record floating-point CONST_DOUBLEs in each floating-point mode for\n    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we\n    record a copy of const[012]_rtx.  */\n@@ -115,30 +109,6 @@ REAL_VALUE_TYPE dconsthalf;\n FIXED_VALUE_TYPE fconst0[MAX_FCONST0];\n FIXED_VALUE_TYPE fconst1[MAX_FCONST1];\n \n-/* All references to the following fixed hard registers go through\n-   these unique rtl objects.  On machines where the frame-pointer and\n-   arg-pointer are the same register, they use the same unique object.\n-\n-   After register allocation, other rtl objects which used to be pseudo-regs\n-   may be clobbered to refer to the frame-pointer register.\n-   But references that were originally to the frame-pointer can be\n-   distinguished from the others because they contain frame_pointer_rtx.\n-\n-   When to use frame_pointer_rtx and hard_frame_pointer_rtx is a little\n-   tricky: until register elimination has taken place hard_frame_pointer_rtx\n-   should be used if it is being set, and frame_pointer_rtx otherwise.  After\n-   register elimination hard_frame_pointer_rtx should always be used.\n-   On machines where the two registers are same (most) then these are the\n-   same.\n-\n-   In an inline procedure, the stack and frame pointer rtxs may not be\n-   used for anything else.  */\n-rtx pic_offset_table_rtx;\t/* (REG:Pmode PIC_OFFSET_TABLE_REGNUM) */\n-\n-/* This is used to implement __builtin_return_address for some machines.\n-   See for instance the MIPS port.  */\n-rtx return_address_pointer_rtx;\t/* (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM) */\n-\n /* We make one copy of (const_int C) where C is in\n    [- MAX_SAVED_CONST_INT, MAX_SAVED_CONST_INT]\n    to save space during the compilation and simplify comparisons of\n@@ -5576,7 +5546,7 @@ init_emit (void)\n \n   /* Put copies of all the hard registers into regno_reg_rtx.  */\n   memcpy (regno_reg_rtx,\n-\t  static_regno_reg_rtx,\n+\t  initial_regno_reg_rtx,\n \t  FIRST_PSEUDO_REGISTER * sizeof (rtx));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n@@ -5703,7 +5673,7 @@ init_emit_regs (void)\n   /* Initialize RTL for commonly used hard registers.  These are\n      copied into regno_reg_rtx as we begin to compile each function.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    static_regno_reg_rtx[i] = gen_raw_REG (reg_raw_mode[i], i);\n+    initial_regno_reg_rtx[i] = gen_raw_REG (reg_raw_mode[i], i);\n \n #ifdef RETURN_ADDRESS_POINTER_REGNUM\n   return_address_pointer_rtx"}, {"sha": "366b5fd87959580a04c797690f1b8495d761725c", "filename": "gcc/rtl.h", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "patch": "@@ -2006,8 +2006,53 @@ enum global_rtl_index\n   GR_MAX\n };\n \n-/* Pointers to standard pieces of rtx are stored here.  */\n-extern GTY(()) rtx global_rtl[GR_MAX];\n+/* Target-dependent globals.  */\n+struct GTY(()) target_rtl {\n+  /* All references to the hard registers in global_rtl_index go through\n+     these unique rtl objects.  On machines where the frame-pointer and\n+     arg-pointer are the same register, they use the same unique object.\n+\n+     After register allocation, other rtl objects which used to be pseudo-regs\n+     may be clobbered to refer to the frame-pointer register.\n+     But references that were originally to the frame-pointer can be\n+     distinguished from the others because they contain frame_pointer_rtx.\n+\n+     When to use frame_pointer_rtx and hard_frame_pointer_rtx is a little\n+     tricky: until register elimination has taken place hard_frame_pointer_rtx\n+     should be used if it is being set, and frame_pointer_rtx otherwise.  After\n+     register elimination hard_frame_pointer_rtx should always be used.\n+     On machines where the two registers are same (most) then these are the\n+     same.  */\n+  rtx x_global_rtl[GR_MAX];\n+\n+  /* A unique representation of (REG:Pmode PIC_OFFSET_TABLE_REGNUM).  */\n+  rtx x_pic_offset_table_rtx;\n+\n+  /* A unique representation of (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM).\n+     This is used to implement __builtin_return_address for some machines;\n+     see for instance the MIPS port.  */\n+  rtx x_return_address_pointer_rtx;\n+\n+  /* Commonly used RTL for hard registers.  These objects are not\n+     necessarily unique, so we allocate them separately from global_rtl.\n+     They are initialized once per compilation unit, then copied into\n+     regno_reg_rtx at the beginning of each function.  */\n+  rtx x_initial_regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n+};\n+\n+extern GTY(()) struct target_rtl default_target_rtl;\n+#if SWITCHABLE_TARGET\n+extern struct target_rtl *this_target_rtl;\n+#else\n+#define this_target_rtl (&default_target_rtl)\n+#endif\n+\n+#define global_rtl\t\t\t\t\\\n+  (this_target_rtl->x_global_rtl)\n+#define pic_offset_table_rtx \\\n+  (this_target_rtl->x_pic_offset_table_rtx)\n+#define return_address_pointer_rtx \\\n+  (this_target_rtl->x_return_address_pointer_rtx)\n \n /* Standard pieces of rtx, to be substituted directly into things.  */\n #define pc_rtx                  (global_rtl[GR_PC])\n@@ -2021,9 +2066,6 @@ extern GTY(()) rtx global_rtl[GR_MAX];\n #define hard_frame_pointer_rtx\t(global_rtl[GR_HARD_FRAME_POINTER])\n #define arg_pointer_rtx\t\t(global_rtl[GR_ARG_POINTER])\n \n-extern GTY(()) rtx pic_offset_table_rtx;\n-extern GTY(()) rtx return_address_pointer_rtx;\n-\n /* Include the RTL generation functions.  */\n \n #ifndef GENERATOR_FILE"}, {"sha": "26b2fa390f263afcceca69291b05189f2ae39ea1", "filename": "gcc/target-globals.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "patch": "@@ -28,11 +28,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target-globals.h\"\n #include \"flags.h\"\n #include \"regs.h\"\n+#include \"rtl.h\"\n \n #if SWITCHABLE_TARGET\n struct target_globals default_target_globals = {\n   &default_target_flag_state,\n-  &default_target_regs\n+  &default_target_regs,\n+  &default_target_rtl\n };\n \n struct target_globals *\n@@ -43,6 +45,7 @@ save_target_globals (void)\n   g = ggc_alloc_target_globals ();\n   g->flag_state = XCNEW (struct target_flag_state);\n   g->regs = XCNEW (struct target_regs);\n+  g->rtl = ggc_alloc_cleared_target_rtl ();\n   restore_target_globals (g);\n   target_reinit ();\n   return g;"}, {"sha": "f8db59c18277908f1cd4707ceab3502a46f2feff", "filename": "gcc/target-globals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "patch": "@@ -23,10 +23,12 @@ along with GCC; see the file COPYING3.  If not see\n #if SWITCHABLE_TARGET\n extern struct target_flag_state *this_target_flag_state;\n extern struct target_regs *this_target_regs;\n+extern struct target_rtl *this_target_rtl;\n \n struct GTY(()) target_globals {\n   struct target_flag_state *GTY((skip)) flag_state;\n   struct target_regs *GTY((skip)) regs;\n+  struct target_rtl *rtl;\n };\n \n extern struct target_globals default_target_globals;\n@@ -38,6 +40,7 @@ restore_target_globals (struct target_globals *g)\n {\n   this_target_flag_state = g->flag_state;\n   this_target_regs = g->regs;\n+  this_target_rtl = g->rtl;\n }\n #endif\n "}]}