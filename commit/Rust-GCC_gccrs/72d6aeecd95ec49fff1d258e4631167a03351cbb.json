{"sha": "72d6aeecd95ec49fff1d258e4631167a03351cbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJkNmFlZWNkOTVlYzQ5ZmZmMWQyNThlNDYzMTE2N2EwMzM1MWNiYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-06T12:29:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-06T12:29:27Z"}, "message": "Restructure vect_analyze_loop\n\nOnce vect_analyze_loop has found a valid loop_vec_info X, we carry\non searching for alternatives if (1) X doesn't satisfy simdlen or\n(2) we want to vectorize the epilogue of X.  I have a patch that\noptionally adds a third reason: we want to see if there are cheaper\nalternatives to X.\n\nThis patch restructures vect_analyze_loop so that it's easier\nto add more reasons for continuing.  There's supposed to be no\nbehavioural change.\n\nIf we wanted to, we could allow vectorisation of epilogues once\nloop->simdlen has been reached by changing \"loop->simdlen\" to\n\"simdlen\" in the new vect_epilogues condition.  That should be\na separate change though.\n\n2019-11-06  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-loop.c (vect_analyze_loop): Break out of the main\n\tloop when we've finished, rather than returning directly from\n\tthe loop.  Use a local variable to track whether we're still\n\tsearching for the preferred simdlen.  Make vect_epilogues\n\trecord whether the next iteration should try to treat the\n\tloop as an epilogue.\n\nFrom-SVN: r277879", "tree": {"sha": "8b8727a7b29d7018382a537635114d75a45e8c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b8727a7b29d7018382a537635114d75a45e8c4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72d6aeecd95ec49fff1d258e4631167a03351cbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d6aeecd95ec49fff1d258e4631167a03351cbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d6aeecd95ec49fff1d258e4631167a03351cbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d6aeecd95ec49fff1d258e4631167a03351cbb/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "756b23a81c539aec9f8108cb8d6a6313aef02a99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/756b23a81c539aec9f8108cb8d6a6313aef02a99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/756b23a81c539aec9f8108cb8d6a6313aef02a99"}], "stats": {"total": 146, "additions": 77, "deletions": 69}, "files": [{"sha": "a8a8968c9bc3c81df8f293ed63cf2c169113757e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d6aeecd95ec49fff1d258e4631167a03351cbb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d6aeecd95ec49fff1d258e4631167a03351cbb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72d6aeecd95ec49fff1d258e4631167a03351cbb", "patch": "@@ -1,3 +1,12 @@\n+2019-11-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop): Break out of the main\n+\tloop when we've finished, rather than returning directly from\n+\tthe loop.  Use a local variable to track whether we're still\n+\tsearching for the preferred simdlen.  Make vect_epilogues\n+\trecord whether the next iteration should try to treat the\n+\tloop as an epilogue.\n+\n 2019-11-06  Vineet Gupta  <vgupta@synopsys.com>\n \n \t* config/arc/arc-c.c (arc_cpu_cpp_builtins) : Add"}, {"sha": "f8049047a8e3818cc1ff52e6e1ca6adfc3d2af91", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 68, "deletions": 69, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d6aeecd95ec49fff1d258e4631167a03351cbb/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d6aeecd95ec49fff1d258e4631167a03351cbb/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=72d6aeecd95ec49fff1d258e4631167a03351cbb", "patch": "@@ -2382,16 +2382,13 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n   poly_uint64 lowest_th = 0;\n   unsigned vectorized_loops = 0;\n \n-  /* Only vectorize epilogues if PARAM_VECT_EPILOGUES_NOMASK is enabled, this\n-     is not a simd loop and it is the most inner loop.  */\n-  bool vect_epilogues\n-    = !loop->simdlen && loop->inner == NULL\n-      && PARAM_VALUE (PARAM_VECT_EPILOGUES_NOMASK);\n+  bool vect_epilogues = false;\n+  opt_result res = opt_result::success ();\n+  unsigned HOST_WIDE_INT simdlen = loop->simdlen;\n   while (1)\n     {\n       /* Check the CFG characteristics of the loop (nesting, entry/exit).  */\n-      opt_loop_vec_info loop_vinfo\n-\t= vect_analyze_loop_form (loop, shared);\n+      opt_loop_vec_info loop_vinfo = vect_analyze_loop_form (loop, shared);\n       if (!loop_vinfo)\n \t{\n \t  if (dump_enabled_p ())\n@@ -2404,67 +2401,70 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \n       bool fatal = false;\n \n-      if (vect_epilogues && first_loop_vinfo)\n+      if (vect_epilogues)\n \tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = first_loop_vinfo;\n \n-      opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts);\n+      res = vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts);\n       if (next_size == 0)\n \tautodetected_vector_size = loop_vinfo->vector_size;\n \n+      loop->aux = NULL;\n       if (res)\n \t{\n \t  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n \t  vectorized_loops++;\n \n-\t  if ((loop->simdlen\n-\t       && maybe_ne (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n-\t\t\t    (unsigned HOST_WIDE_INT) loop->simdlen))\n-\t      || vect_epilogues)\n+\t  /* Once we hit the desired simdlen for the first time,\n+\t     discard any previous attempts.  */\n+\t  if (simdlen\n+\t      && known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), simdlen))\n \t    {\n-\t      if (first_loop_vinfo == NULL)\n-\t\t{\n-\t\t  first_loop_vinfo = loop_vinfo;\n-\t\t  lowest_th\n-\t\t    = LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo);\n-\t\t  loop->aux = NULL;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Keep track of vector sizes that we know we can vectorize\n-\t\t     the epilogue with.  Only vectorize first epilogue.  */\n-\t\t  if (vect_epilogues\n-\t\t      && first_loop_vinfo->epilogue_vinfos.is_empty ())\n-\t\t    {\n-\t\t      loop->aux = NULL;\n-\t\t      first_loop_vinfo->epilogue_vinfos.reserve (1);\n-\t\t      first_loop_vinfo->epilogue_vinfos.quick_push (loop_vinfo);\n-\t\t      LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = first_loop_vinfo;\n-\t\t      poly_uint64 th\n-\t\t\t= LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo);\n-\t\t      gcc_assert (!LOOP_REQUIRES_VERSIONING (loop_vinfo)\n-\t\t\t\t  || maybe_ne (lowest_th, 0U));\n-\t\t      /* Keep track of the known smallest versioning\n-\t\t\t threshold.  */\n-\t\t      if (ordered_p (lowest_th, th))\n-\t\t\tlowest_th = ordered_min (lowest_th, th);\n-\t\t    }\n-\t\t  else\n-\t\t    delete loop_vinfo;\n-\t\t}\n+\t      delete first_loop_vinfo;\n+\t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n+\t      LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = NULL;\n+\t      simdlen = 0;\n \t    }\n-\t  else\n+\n+\t  if (first_loop_vinfo == NULL)\n \t    {\n-\t      delete first_loop_vinfo;\n-\t      return loop_vinfo;\n+\t      first_loop_vinfo = loop_vinfo;\n+\t      lowest_th = LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo);\n+\t    }\n+\t  else if (vect_epilogues)\n+\t    {\n+\t      first_loop_vinfo->epilogue_vinfos.safe_push (loop_vinfo);\n+\t      poly_uint64 th = LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo);\n+\t      gcc_assert (!LOOP_REQUIRES_VERSIONING (loop_vinfo)\n+\t\t\t  || maybe_ne (lowest_th, 0U));\n+\t      /* Keep track of the known smallest versioning\n+\t\t threshold.  */\n+\t      if (ordered_p (lowest_th, th))\n+\t\tlowest_th = ordered_min (lowest_th, th);\n \t    }\n+\t  else\n+\t    delete loop_vinfo;\n+\n+\t  /* Only vectorize epilogues if PARAM_VECT_EPILOGUES_NOMASK is\n+\t     enabled, this is not a simd loop and it is the innermost loop.  */\n+\t  vect_epilogues = (!loop->simdlen\n+\t\t\t    && loop->inner == NULL\n+\t\t\t    && PARAM_VALUE (PARAM_VECT_EPILOGUES_NOMASK)\n+\t\t\t    /* For now only allow one epilogue loop.  */\n+\t\t\t    && first_loop_vinfo->epilogue_vinfos.is_empty ());\n+\n+\t  /* Commit to first_loop_vinfo if we have no reason to try\n+\t     alternatives.  */\n+\t  if (!simdlen && !vect_epilogues)\n+\t    break;\n \t}\n       else\n-\tdelete loop_vinfo;\n-\n-      if (fatal)\n \t{\n-\t  gcc_checking_assert (first_loop_vinfo == NULL);\n-\t  return opt_loop_vec_info::propagate_failure (res);\n+\t  delete loop_vinfo;\n+\t  if (fatal)\n+\t    {\n+\t      gcc_checking_assert (first_loop_vinfo == NULL);\n+\t      break;\n+\t    }\n \t}\n \n       if (next_size < vector_sizes.length ()\n@@ -2473,24 +2473,7 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \n       if (next_size == vector_sizes.length ()\n \t  || known_eq (autodetected_vector_size, 0U))\n-\t{\n-\t  if (first_loop_vinfo)\n-\t    {\n-\t      loop->aux = (loop_vec_info) first_loop_vinfo;\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t   \"***** Choosing vector size \");\n-\t\t  dump_dec (MSG_NOTE, first_loop_vinfo->vector_size);\n-\t\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n-\t      LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo) = lowest_th;\n-\n-\t      return first_loop_vinfo;\n-\t    }\n-\t  else\n-\t    return opt_loop_vec_info::propagate_failure (res);\n-\t}\n+\tbreak;\n \n       /* Try the next biggest vector size.  */\n       next_vector_size = vector_sizes[next_size++];\n@@ -2503,6 +2486,22 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t  dump_printf (MSG_NOTE, \"\\n\");\n \t}\n     }\n+\n+  if (first_loop_vinfo)\n+    {\n+      loop->aux = (loop_vec_info) first_loop_vinfo;\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"***** Choosing vector size \");\n+\t  dump_dec (MSG_NOTE, first_loop_vinfo->vector_size);\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n+      LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo) = lowest_th;\n+      return first_loop_vinfo;\n+    }\n+\n+  return opt_loop_vec_info::propagate_failure (res);\n }\n \n /* Return true if there is an in-order reduction function for CODE, storing"}]}