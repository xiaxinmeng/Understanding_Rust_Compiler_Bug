{"sha": "158b52c9616a3bc0b1c2622e3627a544318fd329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4YjUyYzk2MTZhM2JjMGIxYzI2MjJlMzYyN2E1NDQzMThmZDMyOQ==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2020-04-04T00:34:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-16T13:07:15Z"}, "message": "[Ada] Implement AI12-0249, AI12-0295 (user-defined numeric & string literals)\n\n2020-06-16  Steve Baird  <baird@adacore.com>\n\ngcc/ada/\n\n\t* snames.ads-tmpl: Define names of the three new aspects.\n\t* aspects.ads: Define the three new aspects.\n\t* sem_util.ads, sem_util.adb, sem_dim.adb: Move the function\n\tString_From_Numeric_Literal from being declared in the body of\n\tpackage Sem_Dim to being declared in the visible part of package\n\tSem_Util.\n\t* sem_ch13.ads, sem_ch13.adb: Declare new visible procedure\n\tValidate_Literal_Aspect. This is where most of the legality\n\tchecking occurs for an aspect specification for one of the three\n\tnew aspects, as well as resolution of the subprogram named in\n\tthe aspect specification. Follow example of other aspects (e.g.,\n\tValidate_Literal_Aspect is called in much the same way as\n\tValidate_Iterable_Aspect in Analyze_Aspects_At_Freeze_Point; a\n\tsmall amount of legality checking is performed in\n\tAnalyze_One_Aspect in much the same way as for Default_Value or\n\tDefault_Component_Value aspects). Most of the work is done in\n\tValidate_Literal_Aspect.\n\t* contracts.adb (Add_Contract_Item): Call\n\tValidate_Literal_Aspect in much the same way that\n\tValidate_Iterable_Aspect was already being called.\n\t* sem_res.adb (Resolve): Rewrite a literal as a call if it is a\n\tuser-defined literal.  This is where the dynamic semantics of\n\tthe 3 new aspects are implemented.\n\t* sem_ch6.adb (Fully_Conformant_Expressions): Two numeric\n\tliterals that have different text but the same value (e.g.,\n\t12345 and 12_345) do not conform if they are user-defined\n\tliterals. Introduce a new function\n\tUser_Defined_Numeric_Literal_Mismatch to avoid duplication in\n\tmaking this check.\n\t* sem_type.adb (Has_Compatible_Type): A numeric literal can be\n\tcompatible with a non-numeric type (and a string literal can be\n\tcompatible with a non-string type) if it can be interpreted as a\n\tuser-defined literal.", "tree": {"sha": "709b9976644cf03e951725847b9157d209ef0d1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/709b9976644cf03e951725847b9157d209ef0d1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/158b52c9616a3bc0b1c2622e3627a544318fd329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158b52c9616a3bc0b1c2622e3627a544318fd329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/158b52c9616a3bc0b1c2622e3627a544318fd329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158b52c9616a3bc0b1c2622e3627a544318fd329/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51e2de474edf2be4997862eb878a5abf5b2a323b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e2de474edf2be4997862eb878a5abf5b2a323b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51e2de474edf2be4997862eb878a5abf5b2a323b"}], "stats": {"total": 446, "additions": 377, "deletions": 69}, "files": [{"sha": "cf292ae579bcbee2fefcaacaea1ecedd133d6f8e", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -109,6 +109,7 @@ package Aspects is\n       Aspect_Initial_Condition,             -- GNAT\n       Aspect_Initializes,                   -- GNAT\n       Aspect_Input,\n+      Aspect_Integer_Literal,\n       Aspect_Interrupt_Priority,\n       Aspect_Invariant,                     -- GNAT\n       Aspect_Iterator_Element,\n@@ -133,6 +134,7 @@ package Aspects is\n       Aspect_Priority,\n       Aspect_Put_Image,\n       Aspect_Read,\n+      Aspect_Real_Literal,\n       Aspect_Refined_Depends,               -- GNAT\n       Aspect_Refined_Global,                -- GNAT\n       Aspect_Refined_Post,                  -- GNAT\n@@ -149,6 +151,7 @@ package Aspects is\n       Aspect_Storage_Pool,\n       Aspect_Storage_Size,\n       Aspect_Stream_Size,\n+      Aspect_String_Literal,\n       Aspect_Suppress,\n       Aspect_Synchronization,\n       Aspect_Test_Case,                     -- GNAT\n@@ -373,6 +376,7 @@ package Aspects is\n       Aspect_Initial_Condition          => Expression,\n       Aspect_Initializes                => Expression,\n       Aspect_Input                      => Name,\n+      Aspect_Integer_Literal            => Name,\n       Aspect_Interrupt_Priority         => Expression,\n       Aspect_Invariant                  => Expression,\n       Aspect_Iterable                   => Expression,\n@@ -397,6 +401,7 @@ package Aspects is\n       Aspect_Priority                   => Expression,\n       Aspect_Put_Image                  => Name,\n       Aspect_Read                       => Name,\n+      Aspect_Real_Literal               => Name,\n       Aspect_Refined_Depends            => Expression,\n       Aspect_Refined_Global             => Expression,\n       Aspect_Refined_Post               => Expression,\n@@ -413,6 +418,7 @@ package Aspects is\n       Aspect_Storage_Pool               => Name,\n       Aspect_Storage_Size               => Expression,\n       Aspect_Stream_Size                => Expression,\n+      Aspect_String_Literal             => Name,\n       Aspect_Suppress                   => Name,\n       Aspect_Synchronization            => Name,\n       Aspect_Test_Case                  => Expression,\n@@ -467,6 +473,7 @@ package Aspects is\n       Aspect_Initial_Condition            => False,\n       Aspect_Initializes                  => False,\n       Aspect_Input                        => False,\n+      Aspect_Integer_Literal              => False,\n       Aspect_Interrupt_Priority           => False,\n       Aspect_Invariant                    => False,\n       Aspect_Iterable                     => False,\n@@ -491,6 +498,7 @@ package Aspects is\n       Aspect_Priority                     => False,\n       Aspect_Put_Image                    => False,\n       Aspect_Read                         => False,\n+      Aspect_Real_Literal                 => False,\n       Aspect_Refined_Depends              => False,\n       Aspect_Refined_Global               => False,\n       Aspect_Refined_Post                 => False,\n@@ -507,6 +515,7 @@ package Aspects is\n       Aspect_Storage_Pool                 => True,\n       Aspect_Storage_Size                 => True,\n       Aspect_Stream_Size                  => True,\n+      Aspect_String_Literal               => False,\n       Aspect_Suppress                     => False,\n       Aspect_Synchronization              => False,\n       Aspect_Test_Case                    => False,\n@@ -614,6 +623,7 @@ package Aspects is\n       Aspect_Initial_Condition            => Name_Initial_Condition,\n       Aspect_Initializes                  => Name_Initializes,\n       Aspect_Input                        => Name_Input,\n+      Aspect_Integer_Literal              => Name_Integer_Literal,\n       Aspect_Interrupt_Handler            => Name_Interrupt_Handler,\n       Aspect_Interrupt_Priority           => Name_Interrupt_Priority,\n       Aspect_Invariant                    => Name_Invariant,\n@@ -650,6 +660,7 @@ package Aspects is\n       Aspect_Pure_Function                => Name_Pure_Function,\n       Aspect_Put_Image                    => Name_Put_Image,\n       Aspect_Read                         => Name_Read,\n+      Aspect_Real_Literal                 => Name_Real_Literal,\n       Aspect_Refined_Depends              => Name_Refined_Depends,\n       Aspect_Refined_Global               => Name_Refined_Global,\n       Aspect_Refined_Post                 => Name_Refined_Post,\n@@ -672,6 +683,7 @@ package Aspects is\n       Aspect_Storage_Pool                 => Name_Storage_Pool,\n       Aspect_Storage_Size                 => Name_Storage_Size,\n       Aspect_Stream_Size                  => Name_Stream_Size,\n+      Aspect_String_Literal               => Name_String_Literal,\n       Aspect_Suppress                     => Name_Suppress,\n       Aspect_Suppress_Debug_Info          => Name_Suppress_Debug_Info,\n       Aspect_Suppress_Initialization      => Name_Suppress_Initialization,\n@@ -832,6 +844,7 @@ package Aspects is\n       Aspect_Inline                       => Always_Delay,\n       Aspect_Inline_Always                => Always_Delay,\n       Aspect_Input                        => Always_Delay,\n+      Aspect_Integer_Literal              => Always_Delay,\n       Aspect_Interrupt_Handler            => Always_Delay,\n       Aspect_Interrupt_Priority           => Always_Delay,\n       Aspect_Invariant                    => Always_Delay,\n@@ -857,6 +870,7 @@ package Aspects is\n       Aspect_Pure_Function                => Always_Delay,\n       Aspect_Put_Image                    => Always_Delay,\n       Aspect_Read                         => Always_Delay,\n+      Aspect_Real_Literal                 => Always_Delay,\n       Aspect_Relative_Deadline            => Always_Delay,\n       Aspect_Remote_Access_Type           => Always_Delay,\n       Aspect_Remote_Call_Interface        => Always_Delay,\n@@ -869,6 +883,7 @@ package Aspects is\n       Aspect_Static_Predicate             => Always_Delay,\n       Aspect_Storage_Pool                 => Always_Delay,\n       Aspect_Stream_Size                  => Always_Delay,\n+      Aspect_String_Literal               => Always_Delay,\n       Aspect_Suppress                     => Always_Delay,\n       Aspect_Suppress_Debug_Info          => Always_Delay,\n       Aspect_Suppress_Initialization      => Always_Delay,"}, {"sha": "337e4b60b54cbdfd59b20b6538848b239229789b", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -425,21 +425,37 @@ package body Contracts is\n             Analyze_Task_Contract (Defining_Entity (Decl));\n \n          --  For type declarations, we need to do the preanalysis of Iterable\n-         --  aspect specifications.\n+         --  and the 3 Xxx_Literal aspect specifications.\n \n          --  Other type aspects need to be resolved here???\n \n          elsif Nkind (Decl) = N_Private_Type_Declaration\n            and then Present (Aspect_Specifications (Decl))\n          then\n             declare\n-               E  : constant Entity_Id := Defining_Identifier (Decl);\n-               It : constant Node_Id   := Find_Aspect (E, Aspect_Iterable);\n+               E  : constant Entity_Id  := Defining_Identifier (Decl);\n+               It : constant Node_Id    := Find_Aspect (E, Aspect_Iterable);\n+               I_Lit : constant Node_Id :=\n+                 Find_Aspect (E, Aspect_Integer_Literal);\n+               R_Lit : constant Node_Id :=\n+                 Find_Aspect (E, Aspect_Real_Literal);\n+               S_Lit : constant Node_Id :=\n+                 Find_Aspect (E, Aspect_String_Literal);\n \n             begin\n                if Present (It) then\n                   Validate_Iterable_Aspect (E, It);\n                end if;\n+\n+               if Present (I_Lit) then\n+                  Validate_Literal_Aspect (E, I_Lit);\n+               end if;\n+               if Present (R_Lit) then\n+                  Validate_Literal_Aspect (E, R_Lit);\n+               end if;\n+               if Present (S_Lit) then\n+                  Validate_Literal_Aspect (E, S_Lit);\n+               end if;\n             end;\n          end if;\n "}, {"sha": "583bb98185f9e90e9bafbea750006a698febfdb3", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 154, "deletions": 1, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -1461,6 +1461,12 @@ package body Sem_Ch13 is\n                            ASN, E);\n                      end if;\n \n+                  when Aspect_Integer_Literal\n+                     | Aspect_Real_Literal\n+                     | Aspect_String_Literal\n+                  =>\n+                     Validate_Literal_Aspect (E, ASN);\n+\n                   when Aspect_Iterable =>\n                      Validate_Iterable_Aspect (E, ASN);\n \n@@ -3750,6 +3756,24 @@ package body Sem_Ch13 is\n \n                   Aitem := Empty;\n \n+               when Aspect_Integer_Literal\n+                  | Aspect_Real_Literal\n+                  | Aspect_String_Literal\n+               =>\n+\n+                  if not Is_First_Subtype (E) then\n+                     Error_Msg_N\n+                       (\"may only be specified for a first subtype\", Aspect);\n+                     goto Continue;\n+                  end if;\n+\n+                  if Ada_Version < Ada_2020 then\n+                     Check_Restriction\n+                       (No_Implementation_Aspect_Specifications, N);\n+                  end if;\n+\n+                  Aitem := Empty;\n+\n                --  Case 3b: The aspects listed below don't correspond to\n                --  pragmas/attributes and don't need delayed analysis.\n \n@@ -9868,7 +9892,10 @@ package body Sem_Ch13 is\n       elsif A_Id = Aspect_Variable_Indexing or else\n             A_Id = Aspect_Constant_Indexing or else\n             A_Id = Aspect_Default_Iterator  or else\n-            A_Id = Aspect_Iterator_Element\n+            A_Id = Aspect_Iterator_Element  or else\n+            A_Id = Aspect_Integer_Literal   or else\n+            A_Id = Aspect_Real_Literal      or else\n+            A_Id = Aspect_String_Literal\n       then\n          --  Make type unfrozen before analysis, to prevent spurious errors\n          --  about late attributes.\n@@ -9989,6 +10016,9 @@ package body Sem_Ch13 is\n       Ident : constant Node_Id := Identifier (ASN);\n       --  Identifier (use Entity field to save expression)\n \n+      Expr : constant Node_Id := Expression (ASN);\n+      --  For cases where using Entity (Identifier) doesn't work\n+\n       A_Id : constant Aspect_Id := Get_Aspect_Id (Chars (Ident));\n \n       T : Entity_Id := Empty;\n@@ -10137,6 +10167,20 @@ package body Sem_Ch13 is\n             Analyze (Expression (ASN));\n             return;\n \n+         --  Same for Literal aspects, where the expression is a function\n+         --  name. Legality rules are checked separately. Use Expr to avoid\n+         --  losing track of the previous resolution of Expression.\n+\n+         when Aspect_Integer_Literal\n+            | Aspect_Real_Literal\n+            | Aspect_String_Literal\n+         =>\n+            Set_Entity (Expression (ASN), Entity (Expr));\n+            Set_Etype (Expression (ASN), Etype (Expr));\n+            Set_Is_Overloaded (Expression (ASN), False);\n+            Analyze (Expression (ASN));\n+            return;\n+\n          --  Ditto for Iterable, legality checks in Validate_Iterable_Aspect.\n \n          when Aspect_Iterable =>\n@@ -15122,6 +15166,115 @@ package body Sem_Ch13 is\n       end if;\n    end Validate_Iterable_Aspect;\n \n+   ------------------------------\n+   -- Validate_Literal_Aspect --\n+   ------------------------------\n+\n+   procedure Validate_Literal_Aspect (Typ : Entity_Id; ASN : Node_Id) is\n+      A_Id        : constant Aspect_Id := Get_Aspect_Id (ASN);\n+      pragma Assert ((A_Id = Aspect_Integer_Literal) or\n+                     (A_Id = Aspect_Real_Literal) or\n+                     (A_Id = Aspect_String_Literal));\n+      Func_Name   : constant Node_Id := Expression (ASN);\n+      Overloaded  : Boolean := Is_Overloaded (Func_Name);\n+\n+      I           : Interp_Index;\n+      It          : Interp;\n+      Param_Type  : Entity_Id;\n+      Match_Found : Boolean := False;\n+      Is_Match    : Boolean;\n+      Match       : Interp;\n+   begin\n+      if not Is_Type (Typ) then\n+         Error_Msg_N (\"aspect can only be specified for a type\", ASN);\n+         return;\n+      elsif not Is_First_Subtype (Typ) then\n+         Error_Msg_N (\"aspect cannot be specified for a subtype\", ASN);\n+         return;\n+      end if;\n+\n+      if A_Id = Aspect_String_Literal then\n+         if Is_String_Type (Typ) then\n+            Error_Msg_N (\"aspect cannot be specified for a string type\", ASN);\n+            return;\n+         end if;\n+         Param_Type := Standard_Wide_Wide_String;\n+      else\n+         if Is_Numeric_Type (Typ) then\n+            Error_Msg_N (\"aspect cannot be specified for a numeric type\", ASN);\n+            return;\n+         end if;\n+         Param_Type := Standard_String;\n+      end if;\n+\n+      if not Overloaded and then not Present (Entity (Func_Name)) then\n+         Analyze (Func_Name);\n+         Overloaded := Is_Overloaded (Func_Name);\n+      end if;\n+\n+      if Overloaded then\n+         Get_First_Interp (Func_Name, I => I, It => It);\n+      else\n+         --  only one possible interpretation\n+         It.Nam := Entity (Func_Name);\n+         pragma Assert (Present (It.Nam));\n+      end if;\n+\n+      while It.Nam /= Empty loop\n+         Is_Match := False;\n+\n+         if Ekind (It.Nam) = E_Function\n+           and then Base_Type (Etype (It.Nam)) = Typ\n+         then\n+            declare\n+               Params : constant List_Id :=\n+                 Parameter_Specifications (Parent (It.Nam));\n+               Param_Spec : Node_Id;\n+               Param_Id   : Entity_Id;\n+            begin\n+               if List_Length (Params) = 1 then\n+                  Param_Spec := First (Params);\n+                  if not More_Ids (Param_Spec) then\n+                     Param_Id := Defining_Identifier (Param_Spec);\n+                     if Base_Type (Etype (Param_Id)) = Param_Type\n+                        and then Ekind (Param_Id) = E_In_Parameter\n+                     then\n+                        Is_Match := True;\n+                     end if;\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+\n+         if Is_Match then\n+            if Match_Found then\n+               Error_Msg_N (\"aspect specification is ambiguous\", ASN);\n+               return;\n+            end if;\n+            Match_Found := True;\n+            Match := It;\n+         end if;\n+\n+         exit when not Overloaded;\n+\n+         if not Is_Match then\n+            Remove_Interp (I => I);\n+         end if;\n+\n+         Get_Next_Interp (I => I, It => It);\n+      end loop;\n+\n+      if not Match_Found then\n+         Error_Msg_N\n+           (\"function name in aspect specification cannot be resolved\", ASN);\n+         return;\n+      end if;\n+\n+      Set_Entity (Func_Name, Match.Nam);\n+      Set_Etype (Func_Name, Etype (Match.Nam));\n+      Set_Is_Overloaded (Func_Name, False);\n+   end Validate_Literal_Aspect;\n+\n    -----------------------------------\n    -- Validate_Unchecked_Conversion --\n    -----------------------------------"}, {"sha": "85063a621b8afecd6e8a0a0fdd788f03ad733733", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -345,6 +345,10 @@ package Sem_Ch13 is\n    --  for First, Next, and Has_Element. Optionally an Element primitive may\n    --  also be defined.\n \n+   procedure Validate_Literal_Aspect (Typ : Entity_Id; ASN : Node_Id);\n+   --  Check legality of Integer_Literal, Real_Literal, and String_Literal\n+   --  aspect specifications.\n+\n    procedure Install_Discriminants (E : Entity_Id);\n    --  Make visible the discriminants of type entity E\n "}, {"sha": "1b3cba8de11cc23e83461cda1da103f17568c226", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -9401,6 +9401,28 @@ package body Sem_Ch6 is\n          end if;\n       end FCO;\n \n+      function User_Defined_Numeric_Literal_Mismatch return Boolean;\n+      --  Usually literals with the same value like 12345 and 12_345\n+      --  or 123.0 and 123.00 conform, but not if they are\n+      --  user-defined literals.\n+\n+      -------------------------------------------\n+      -- User_Defined_Numeric_Literal_Mismatch --\n+      -------------------------------------------\n+\n+      function User_Defined_Numeric_Literal_Mismatch return Boolean is\n+         E1_Is_User_Defined : constant Boolean :=\n+           not Nkind_In (Given_E1, N_Integer_Literal, N_Real_Literal);\n+         E2_Is_User_Defined : constant Boolean :=\n+           not Nkind_In (Given_E2, N_Integer_Literal, N_Real_Literal);\n+      begin\n+         pragma Assert (E1_Is_User_Defined = E2_Is_User_Defined);\n+\n+         return E1_Is_User_Defined and then\n+           not String_Equal (String_From_Numeric_Literal (E1),\n+                             String_From_Numeric_Literal (E2));\n+      end User_Defined_Numeric_Literal_Mismatch;\n+\n       --  Local variables\n \n       Result : Boolean;\n@@ -9662,7 +9684,8 @@ package body Sem_Ch6 is\n                  FCL (Expressions (E1), Expressions (E2));\n \n             when N_Integer_Literal =>\n-               return (Intval (E1) = Intval (E2));\n+               return (Intval (E1) = Intval (E2))\n+                 and then not User_Defined_Numeric_Literal_Mismatch;\n \n             when N_Null =>\n                return True;\n@@ -9748,7 +9771,8 @@ package body Sem_Ch6 is\n                  FCE (High_Bound (E1), High_Bound (E2));\n \n             when N_Real_Literal =>\n-               return (Realval (E1) = Realval (E2));\n+               return (Realval (E1) = Realval (E2))\n+                 and then not User_Defined_Numeric_Literal_Mismatch;\n \n             when N_Selected_Component =>\n                return"}, {"sha": "d22e5d26bebc629f02e0d79fae84a36ffaa5cbf0", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -40,7 +40,6 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n-with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n@@ -377,10 +376,6 @@ package body Sem_Dim is\n    procedure Set_Symbol (E : Entity_Id; Val : String_Id);\n    --  Associate a symbol representation of a dimension vector with a subtype\n \n-   function String_From_Numeric_Literal (N : Node_Id) return String_Id;\n-   --  Return the string that corresponds to the numeric litteral N as it\n-   --  appears in the source.\n-\n    function Symbol_Of (E : Entity_Id) return String_Id;\n    --  E denotes a subtype with a dimension. Return the symbol representation\n    --  of the dimension vector.\n@@ -3740,63 +3735,6 @@ package body Sem_Dim is\n       Symbol_Table.Set (E, Val);\n    end Set_Symbol;\n \n-   ---------------------------------\n-   -- String_From_Numeric_Literal --\n-   ---------------------------------\n-\n-   function String_From_Numeric_Literal (N : Node_Id) return String_Id is\n-      Loc     : constant Source_Ptr        := Sloc (N);\n-      Sbuffer : constant Source_Buffer_Ptr :=\n-                  Source_Text (Get_Source_File_Index (Loc));\n-      Src_Ptr : Source_Ptr := Loc;\n-\n-      C : Character  := Sbuffer (Src_Ptr);\n-      --  Current source program character\n-\n-      function Belong_To_Numeric_Literal (C : Character) return Boolean;\n-      --  Return True if C belongs to a numeric literal\n-\n-      -------------------------------\n-      -- Belong_To_Numeric_Literal --\n-      -------------------------------\n-\n-      function Belong_To_Numeric_Literal (C : Character) return Boolean is\n-      begin\n-         case C is\n-            when '0' .. '9'\n-               | '_' | '.' | 'e' | '#' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n-            =>\n-               return True;\n-\n-            --  Make sure '+' or '-' is part of an exponent.\n-\n-            when '+' | '-' =>\n-               declare\n-                  Prev_C : constant Character := Sbuffer (Src_Ptr - 1);\n-               begin\n-                  return Prev_C = 'e' or else Prev_C = 'E';\n-               end;\n-\n-            --  All other character doesn't belong to a numeric literal\n-\n-            when others =>\n-               return False;\n-         end case;\n-      end Belong_To_Numeric_Literal;\n-\n-   --  Start of processing for String_From_Numeric_Literal\n-\n-   begin\n-      Start_String;\n-      while Belong_To_Numeric_Literal (C) loop\n-         Store_String_Char (C);\n-         Src_Ptr := Src_Ptr + 1;\n-         C       := Sbuffer (Src_Ptr);\n-      end loop;\n-\n-      return End_String;\n-   end String_From_Numeric_Literal;\n-\n    ---------------\n    -- Symbol_Of --\n    ---------------"}, {"sha": "bdd954fb8b6e68fdc4ca1b9d326b484202f8047f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -2142,6 +2143,12 @@ package body Sem_Res is\n          return;\n       end Resolution_Failed;\n \n+      Literal_Aspect_Map :\n+        constant array (N_Numeric_Or_String_Literal) of Aspect_Id :=\n+          (N_Integer_Literal => Aspect_Integer_Literal,\n+           N_Real_Literal    => Aspect_Real_Literal,\n+           N_String_Literal  => Aspect_String_Literal);\n+\n    --  Start of processing for Resolve\n \n    begin\n@@ -2845,6 +2852,80 @@ package body Sem_Res is\n                end;\n             end if;\n \n+            --  Rewrite Literal as a call if the corresponding literal aspect\n+            --  is set.\n+\n+            if Nkind (N) in N_Numeric_Or_String_Literal\n+              and then Present\n+                         (Find_Aspect (Typ, Literal_Aspect_Map (Nkind (N))))\n+            then\n+               declare\n+                  function Literal_Text (N : Node_Id) return String_Id;\n+                  --  Returns the text of a literal node\n+\n+                  -------------------\n+                  --  Literal_Text --\n+                  -------------------\n+\n+                  function Literal_Text (N : Node_Id) return String_Id is\n+                  begin\n+                     pragma Assert (Nkind (N) in N_Numeric_Or_String_Literal);\n+\n+                     if Nkind (N) = N_String_Literal then\n+                        return Strval (N);\n+                     else\n+                        return String_From_Numeric_Literal (N);\n+                     end if;\n+                  end Literal_Text;\n+\n+                  Lit_Aspect : constant Aspect_Id :=\n+                    Literal_Aspect_Map (Nkind (N));\n+\n+                  Callee : constant Entity_Id :=\n+                    Entity (Expression (Find_Aspect (Typ, Lit_Aspect)));\n+\n+                  Loc  : constant Source_Ptr := Sloc (N);\n+\n+                  Name : constant Node_Id :=\n+                    Make_Identifier (Loc, Chars (Callee));\n+\n+                  Param : constant Node_Id :=\n+                    Make_String_Literal (Loc, Literal_Text (N));\n+\n+                  Params : constant List_Id := New_List (Param);\n+\n+                  Call : Node_Id :=\n+                    Make_Function_Call\n+                      (Sloc                   => Loc,\n+                       Name                   => Name,\n+                       Parameter_Associations => Params);\n+               begin\n+                  Set_Entity (Name, Callee);\n+                  Set_Is_Overloaded (Name, False);\n+                  if Lit_Aspect = Aspect_String_Literal then\n+                     Set_Etype (Param, Standard_Wide_Wide_String);\n+                  else\n+                     Set_Etype (Param, Standard_String);\n+                  end if;\n+                  Set_Etype (Call, Etype (Callee));\n+\n+                  --  Conversion needed in case of an inherited aspect\n+                  --  of a derived type.\n+                  --\n+                  --  ??? Need to do something different here for downward\n+                  --  tagged conversion case (which is only possible in the\n+                  --  case of a null extension); the current call to\n+                  --  Convert_To results in an error message about an illegal\n+                  --  downward conversion.\n+\n+                  Call := Convert_To (Typ, Call);\n+\n+                  Rewrite (N, Call);\n+               end;\n+               Analyze_And_Resolve (N, Typ);\n+               return;\n+            end if;\n+\n             --  Looks like we have a type error, but check for special case\n             --  of Address wanted, integer found, with the configuration pragma\n             --  Allow_Integer_Address active. If we have this case, introduce"}, {"sha": "a2244185ceed79ed7c73c0260354048fee4d3778", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Alloc;\n with Debug;    use Debug;\n@@ -2427,7 +2428,19 @@ package body Sem_Type is\n            or else\n              (not Is_Tagged_Type (Typ)\n                and then Ekind (Typ) /= E_Anonymous_Access_Type\n-               and then Covers (Etype (N), Typ));\n+               and then Covers (Etype (N), Typ))\n+\n+           or else\n+             (Nkind (N) = N_Integer_Literal\n+               and then Present (Find_Aspect (Typ, Aspect_Integer_Literal)))\n+\n+           or else\n+             (Nkind (N) = N_Real_Literal\n+               and then Present (Find_Aspect (Typ, Aspect_Real_Literal)))\n+\n+           or else\n+             (Nkind (N) = N_String_Literal\n+               and then Present (Find_Aspect (Typ, Aspect_String_Literal)));\n \n       --  Overloaded case\n "}, {"sha": "43bffc96f4e2c0b35c448d8914f72b5e65ee9fd3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -26720,6 +26720,63 @@ package body Sem_Util is\n       return Statically_Names_Object (Prefix (N));\n    end Statically_Names_Object;\n \n+   ---------------------------------\n+   -- String_From_Numeric_Literal --\n+   ---------------------------------\n+\n+   function String_From_Numeric_Literal (N : Node_Id) return String_Id is\n+      Loc     : constant Source_Ptr        := Sloc (N);\n+      Sbuffer : constant Source_Buffer_Ptr :=\n+                  Source_Text (Get_Source_File_Index (Loc));\n+      Src_Ptr : Source_Ptr := Loc;\n+\n+      C : Character  := Sbuffer (Src_Ptr);\n+      --  Current source program character\n+\n+      function Belongs_To_Numeric_Literal (C : Character) return Boolean;\n+      --  Return True if C belongs to the numeric literal\n+\n+      --------------------------------\n+      -- Belongs_To_Numeric_Literal --\n+      --------------------------------\n+\n+      function Belongs_To_Numeric_Literal (C : Character) return Boolean is\n+      begin\n+         case C is\n+            when '0' .. '9'\n+               | '_' | '.' | 'e' | '#' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n+            =>\n+               return True;\n+\n+            --  Make sure '+' or '-' is part of an exponent\n+\n+            when '+' | '-' =>\n+               declare\n+                  Prev_C : constant Character := Sbuffer (Src_Ptr - 1);\n+               begin\n+                  return Prev_C = 'e' or else Prev_C = 'E';\n+               end;\n+\n+            --  Other characters cannot belong to a numeric literal\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end Belongs_To_Numeric_Literal;\n+\n+   --  Start of processing for String_From_Numeric_Literal\n+\n+   begin\n+      Start_String;\n+      while Belongs_To_Numeric_Literal (C) loop\n+         Store_String_Char (C);\n+         Src_Ptr := Src_Ptr + 1;\n+         C       := Sbuffer (Src_Ptr);\n+      end loop;\n+\n+      return End_String;\n+   end String_From_Numeric_Literal;\n+\n    --------------------------------------\n    -- Subject_To_Loop_Entry_Attributes --\n    --------------------------------------"}, {"sha": "6cd626e1542caf7ac0d37d5c975f6ab8b5571329", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -2929,6 +2929,10 @@ package Sem_Util is\n    function Statically_Names_Object (N : Node_Id) return Boolean;\n    --  Return True iff N is a name that \"statically names\" an object.\n \n+   function String_From_Numeric_Literal (N : Node_Id) return String_Id;\n+   --  Return the string that corresponds to the numeric literal N as it\n+   --  appears in the source.\n+\n    function Subject_To_Loop_Entry_Attributes (N : Node_Id) return Boolean;\n    --  Determine whether node N is a loop statement subject to at least one\n    --  'Loop_Entry attribute."}, {"sha": "0e807b057c94515aa7bf07964cb00e78ecbc33d0", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158b52c9616a3bc0b1c2622e3627a544318fd329/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=158b52c9616a3bc0b1c2622e3627a544318fd329", "patch": "@@ -148,8 +148,11 @@ package Snames is\n    Name_Dimension_System               : constant Name_Id := N + $;\n    Name_Disable_Controlled             : constant Name_Id := N + $;\n    Name_Dynamic_Predicate              : constant Name_Id := N + $;\n+   Name_Integer_Literal                : constant Name_Id := N + $;\n+   Name_Real_Literal                   : constant Name_Id := N + $;\n    Name_Relaxed_Initialization         : constant Name_Id := N + $;\n    Name_Static_Predicate               : constant Name_Id := N + $;\n+   Name_String_Literal                 : constant Name_Id := N + $;\n    Name_Synchronization                : constant Name_Id := N + $;\n    Name_Unimplemented                  : constant Name_Id := N + $;\n "}]}