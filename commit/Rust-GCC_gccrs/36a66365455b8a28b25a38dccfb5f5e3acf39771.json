{"sha": "36a66365455b8a28b25a38dccfb5f5e3acf39771", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZhNjYzNjU0NTViOGEyOGIyNWEzOGRjY2ZiNWY1ZTNhY2YzOTc3MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T15:49:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T15:49:30Z"}, "message": "[multiple changes]\n\n2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-cbmutr.adb (Allocate_Node): Remove the two parameter version.\n\t(Insert_Child): Add local variable First. Capture the index of the\n\tfirst node being created to ensure correct cursor construction\n\tlater on. Use the three parameter version of Allocate_Node\n\twhen creating multiple children as this method allows aspect\n\tDefault_Value to take effect (if applicable).\n\n2014-07-29  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_aggr.adb (Safe_Slice_Assignment): Remove.\n\t(Expand_Array_Aggregate): For a safe slice assignment, just set\n\tthe target and use the common code path.\n\nFrom-SVN: r213216", "tree": {"sha": "ed2742e243a16eda019fea3c15e43e9e78e0e924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed2742e243a16eda019fea3c15e43e9e78e0e924"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36a66365455b8a28b25a38dccfb5f5e3acf39771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a66365455b8a28b25a38dccfb5f5e3acf39771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a66365455b8a28b25a38dccfb5f5e3acf39771", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a66365455b8a28b25a38dccfb5f5e3acf39771/comments", "author": null, "committer": null, "parents": [{"sha": "e1ea35da691b74cd1ba071abad1dc1ded738cb92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ea35da691b74cd1ba071abad1dc1ded738cb92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ea35da691b74cd1ba071abad1dc1ded738cb92"}], "stats": {"total": 244, "additions": 86, "deletions": 158}, "files": [{"sha": "14891b76a4acd82179232410b17320560fc9b3f3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a66365455b8a28b25a38dccfb5f5e3acf39771/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a66365455b8a28b25a38dccfb5f5e3acf39771/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=36a66365455b8a28b25a38dccfb5f5e3acf39771", "patch": "@@ -1,3 +1,18 @@\n+2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-cbmutr.adb (Allocate_Node): Remove the two parameter version.\n+\t(Insert_Child): Add local variable First. Capture the index of the\n+\tfirst node being created to ensure correct cursor construction\n+\tlater on. Use the three parameter version of Allocate_Node\n+\twhen creating multiple children as this method allows aspect\n+\tDefault_Value to take effect (if applicable).\n+\n+2014-07-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_aggr.adb (Safe_Slice_Assignment): Remove.\n+\t(Expand_Array_Aggregate): For a safe slice assignment, just set\n+\tthe target and use the common code path.\n+\n 2014-07-29  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_util.adb, sem_util.ads, sem_res.adb, exp_ch6.adb: Invert"}, {"sha": "c8120036cb50f083822e09633561cddd0b840791", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a66365455b8a28b25a38dccfb5f5e3acf39771/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a66365455b8a28b25a38dccfb5f5e3acf39771/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=36a66365455b8a28b25a38dccfb5f5e3acf39771", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2011-2013, Free Software Foundation, Inc.      --\n+--             Copyright (C) 2011-2014, Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -94,10 +94,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       New_Item  : Element_Type;\n       New_Node  : out Count_Type);\n \n-   procedure Allocate_Node\n-     (Container : in out Tree;\n-      New_Node  : out Count_Type);\n-\n    procedure Allocate_Node\n      (Container : in out Tree;\n       Stream    : not null access Root_Stream_Type'Class;\n@@ -318,15 +314,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Allocate_Node (Container, Initialize_Element'Access, New_Node);\n    end Allocate_Node;\n \n-   procedure Allocate_Node\n-     (Container : in out Tree;\n-      New_Node  : out Count_Type)\n-   is\n-      procedure Initialize_Element (Index : Count_Type) is null;\n-   begin\n-      Allocate_Node (Container, Initialize_Element'Access, New_Node);\n-   end Allocate_Node;\n-\n    -------------------\n    -- Ancestor_Find --\n    -------------------\n@@ -1583,6 +1570,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Count     : Count_Type := 1)\n    is\n       Nodes : Tree_Node_Array renames Container.Nodes;\n+      First : Count_Type;\n       Last  : Count_Type;\n \n       New_Item : Element_Type;\n@@ -1634,11 +1622,12 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  initialized elements at the given position.\n \n       Allocate_Node (Container, New_Item, Position.Node);\n+      First := Position.Node;\n       Nodes (Position.Node).Parent := Parent.Node;\n \n       Last := Position.Node;\n       for J in Count_Type'(2) .. Count loop\n-         Allocate_Node (Container, Nodes (Last).Next);\n+         Allocate_Node (Container, New_Item, Nodes (Last).Next);\n          Nodes (Nodes (Last).Next).Parent := Parent.Node;\n          Nodes (Nodes (Last).Next).Prev := Last;\n \n@@ -1654,7 +1643,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n       Container.Count := Container.Count + Count;\n \n-      Position.Container := Parent.Container;\n+      Position := Cursor'(Parent.Container, First);\n    end Insert_Child;\n \n    -------------------------"}, {"sha": "ff1cb4a00649100f784dbac4c87051551964e5a9", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 66, "deletions": 142, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a66365455b8a28b25a38dccfb5f5e3acf39771/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a66365455b8a28b25a38dccfb5f5e3acf39771/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=36a66365455b8a28b25a38dccfb5f5e3acf39771", "patch": "@@ -289,11 +289,6 @@ package body Exp_Aggr is\n    --  If this transformation is not possible, N is unchanged and False is\n    --  returned.\n \n-   function Safe_Slice_Assignment (N : Node_Id) return Boolean;\n-   --  If a slice assignment has an aggregate with a single others_choice,\n-   --  the assignment can be done in place even if bounds are not static,\n-   --  by converting it into a loop over the discrete range of the slice.\n-\n    function Two_Dim_Packed_Array_Handled (N : Node_Id) return Boolean;\n    --  If the type of the aggregate is a two-dimensional bit_packed array\n    --  it may be transformed into an array of bytes with constant values,\n@@ -404,8 +399,8 @@ package body Exp_Aggr is\n       elsif Restriction_Active (No_Elaboration_Code)\n         or else Restriction_Active (No_Implicit_Loops)\n         or else Is_Two_Dim_Packed_Array (Typ)\n-        or else ((Ekind (Current_Scope) = E_Package\n-                 and then Static_Elaboration_Desired (Current_Scope)))\n+        or else (Ekind (Current_Scope) = E_Package\n+                   and then Static_Elaboration_Desired (Current_Scope))\n       then\n          Max_Aggr_Size := 2 ** 24;\n \n@@ -443,9 +438,7 @@ package body Exp_Aggr is\n          --  is an object declaration with non-static bounds it will trip gcc;\n          --  such an aggregate must be expanded into a single assignment.\n \n-         if Hiv = Lov\n-           and then Nkind (Parent (N)) = N_Object_Declaration\n-         then\n+         if Hiv = Lov and then Nkind (Parent (N)) = N_Object_Declaration then\n             declare\n                Index_Type : constant Entity_Id :=\n                  Etype\n@@ -454,8 +447,8 @@ package body Exp_Aggr is\n \n             begin\n                if not Compile_Time_Known_Value (Type_Low_Bound (Index_Type))\n-                  or else not Compile_Time_Known_Value\n-                                (Type_High_Bound (Index_Type))\n+                 or else not Compile_Time_Known_Value\n+                               (Type_High_Bound (Index_Type))\n                then\n                   if Present (Component_Associations (N)) then\n                      Indx :=\n@@ -603,7 +596,7 @@ package body Exp_Aggr is\n             --  Recursion to following indexes for multiple dimension case\n \n             if Present (Next_Index (Index))\n-               and then not Component_Check (Expr, Next_Index (Index))\n+              and then not Component_Check (Expr, Next_Index (Index))\n             then\n                return False;\n             end if;\n@@ -653,11 +646,11 @@ package body Exp_Aggr is\n       end if;\n \n       --  Checks 5 (if the component type is tagged, then we may need to do\n-      --    tag adjustments. Perhaps this should be refined to check for any\n-      --    component associations that actually need tag adjustment, similar\n-      --    to the test in Component_Not_OK_For_Backend for record aggregates\n-      --    with tagged components, but not clear whether it's worthwhile ???;\n-      --    in the case of the JVM, object tags are handled implicitly)\n+      --  tag adjustments. Perhaps this should be refined to check for any\n+      --  component associations that actually need tag adjustment, similar\n+      --  to the test in Component_Not_OK_For_Backend for record aggregates\n+      --  with tagged components, but not clear whether it's worthwhile ???;\n+      --  in the case of the JVM, object tags are handled implicitly)\n \n       if Is_Tagged_Type (Component_Type (Typ))\n         and then Tagged_Type_Expansion\n@@ -934,7 +927,8 @@ package body Exp_Aggr is\n             end case;\n \n             if Local_Compile_Time_Known_Value (Low)\n-              and then Local_Compile_Time_Known_Value (High)\n+                 and then\n+               Local_Compile_Time_Known_Value (High)\n             then\n                Is_Empty :=\n                  UI_Gt (Local_Expr_Value (Low), Local_Expr_Value (High));\n@@ -956,7 +950,8 @@ package body Exp_Aggr is\n             return True;\n \n          elsif Local_Compile_Time_Known_Value (L)\n-           and then Local_Compile_Time_Known_Value (H)\n+                 and then\n+               Local_Compile_Time_Known_Value (H)\n          then\n             return UI_Eq (Local_Expr_Value (L), Local_Expr_Value (H));\n          end if;\n@@ -1053,9 +1048,7 @@ package body Exp_Aggr is\n             Expr_Q := Expr;\n          end if;\n \n-         if Present (Etype (N))\n-           and then Etype (N) /= Any_Composite\n-         then\n+         if Present (Etype (N)) and then Etype (N) /= Any_Composite then\n             Comp_Type := Component_Type (Etype (N));\n             pragma Assert (Comp_Type = Ctype); --  AI-287\n \n@@ -1066,13 +1059,13 @@ package body Exp_Aggr is\n             --  the formal parameter Ctype.\n \n             --  ??? Some assert pragmas have been added to check if this new\n-            --      formal can be used to replace this code in all cases.\n+            --  formal can be used to replace this code in all cases.\n \n             if Present (Expr) then\n \n-               --  This is a multidimensional array. Recover the component\n-               --  type from the outermost aggregate, because subaggregates\n-               --  do not have an assigned type.\n+               --  This is a multidimensional array. Recover the component type\n+               --  from the outermost aggregate, because subaggregates do not\n+               --  have an assigned type.\n \n                declare\n                   P : Node_Id;\n@@ -1265,8 +1258,8 @@ package body Exp_Aggr is\n               and then not Is_Limited_Type (Comp_Type)\n               and then not\n                 (Is_Array_Type (Comp_Type)\n-                   and then Is_Controlled (Component_Type (Comp_Type))\n-                   and then Nkind (Expr) = N_Aggregate)\n+                  and then Is_Controlled (Component_Type (Comp_Type))\n+                  and then Nkind (Expr) = N_Aggregate)\n             then\n                Append_To (L,\n                  Make_Adjust_Call (\n@@ -1621,9 +1614,7 @@ package body Exp_Aggr is\n       --  entity in the current scope, because it will be needed if build-\n       --  in-place functions are called in the expanded code.\n \n-      if Nkind (Parent (N)) = N_Object_Declaration\n-        and then Has_Task (Typ)\n-      then\n+      if Nkind (Parent (N)) = N_Object_Declaration and then Has_Task (Typ) then\n          Build_Master_Entity (Defining_Identifier (Parent (N)));\n       end if;\n \n@@ -2189,9 +2180,7 @@ package body Exp_Aggr is\n          --  proper scope is the scope of the target rather than the\n          --  potentially transient current scope.\n \n-         if Is_Controlled (Typ)\n-           and then Ancestor_Is_Subtype_Mark\n-         then\n+         if Is_Controlled (Typ) and then Ancestor_Is_Subtype_Mark then\n             Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n             Set_Assignment_OK (Ref);\n \n@@ -2223,8 +2212,8 @@ package body Exp_Aggr is\n            and then Present (Entity (Expr))\n            and then Ekind (Entity (Expr)) = E_In_Parameter\n            and then Present (Discriminal_Link (Entity (Expr)))\n-           and then Scope (Discriminal_Link (Entity (Expr)))\n-                      = Base_Type (Etype (N))\n+           and then Scope (Discriminal_Link (Entity (Expr))) =\n+                                                       Base_Type (Etype (N))\n          then\n             Rewrite (Expr,\n               Make_Selected_Component (Loc,\n@@ -2427,7 +2416,7 @@ package body Exp_Aggr is\n \n             elsif Is_Limited_Type (Etype (Ancestor))\n               and then Nkind_In (Unqualify (Ancestor), N_Aggregate,\n-                                                    N_Extension_Aggregate)\n+                                                       N_Extension_Aggregate)\n             then\n                Ancestor_Is_Expression := True;\n \n@@ -2596,9 +2585,7 @@ package body Exp_Aggr is\n       --  constructor to ensure the proper initialization of the _Tag\n       --  component.\n \n-      if Is_CPP_Class (Root_Type (Typ))\n-        and then CPP_Num_Prims (Typ) > 0\n-      then\n+      if Is_CPP_Class (Root_Type (Typ)) and then CPP_Num_Prims (Typ) > 0 then\n          Invoke_Constructor : declare\n             CPP_Parent : constant Entity_Id := Enclosing_CPP_Parent (Typ);\n \n@@ -2952,7 +2939,7 @@ package body Exp_Aggr is\n                         if Nkind (Ass) = N_Assignment_Statement\n                           and then Nkind (Name (Ass)) = N_Selected_Component\n                           and then Chars (Selector_Name (Name (Ass))) =\n-                             Chars (Disc)\n+                                                                 Chars (Disc)\n                         then\n                            Set_Expression\n                              (Ass, New_Copy_Tree (Expression (Comp)));\n@@ -3382,7 +3369,7 @@ package body Exp_Aggr is\n          --  known discriminants if available.\n \n          if Has_Unknown_Discriminants (Typ)\n-            and then Present (Underlying_Record_View (Typ))\n+           and then Present (Underlying_Record_View (Typ))\n          then\n             T := Underlying_Record_View (Typ);\n          else\n@@ -3487,7 +3474,7 @@ package body Exp_Aggr is\n                elsif Is_Entity_Name (Expression (Expr))\n                  and then Present (Entity (Expression (Expr)))\n                  and then Ekind (Entity (Expression (Expr))) =\n-                   E_Enumeration_Literal\n+                                                       E_Enumeration_Literal\n                then\n                   null;\n \n@@ -3581,8 +3568,7 @@ package body Exp_Aggr is\n          --  See ACATS c460010 for an example.\n \n          if Hiv < Lov\n-           or else (not Compile_Time_Known_Value (Blo)\n-                     and then Others_Present)\n+           or else (not Compile_Time_Known_Value (Blo) and then Others_Present)\n          then\n             return False;\n          end if;\n@@ -3636,7 +3622,7 @@ package body Exp_Aggr is\n                if Present (Next_Index (Ix))\n                  and then\n                    not Flatten\n-                        (Expression (Elmt), Next_Index (Ix), Next_Index (Ixb))\n+                         (Expression (Elmt), Next_Index (Ix), Next_Index (Ixb))\n                then\n                   return False;\n                end if;\n@@ -3679,9 +3665,8 @@ package body Exp_Aggr is\n                                 or else Restriction_Active (No_Implicit_Loops)\n                                 or else\n                                   (Ekind (Current_Scope) = E_Package\n-                                    and then\n-                                      Static_Elaboration_Desired\n-                                        (Current_Scope))\n+                                    and then Static_Elaboration_Desired\n+                                               (Current_Scope))\n                                 or else Is_Preelaborated (P)\n                                 or else (Ekind (P) = E_Package_Body\n                                           and then\n@@ -3834,9 +3819,7 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n-      if Is_Bit_Packed_Array (Typ)\n-        and then not Handle_Bit_Packed\n-      then\n+      if Is_Bit_Packed_Array (Typ) and then not Handle_Bit_Packed then\n          return;\n       end if;\n \n@@ -4388,7 +4371,7 @@ package body Exp_Aggr is\n                return Compile_Time_Known_Value (Comp)\n \n                  or else (Is_Entity_Name (Comp)\n-                           and then  Present (Entity (Comp))\n+                           and then Present (Entity (Comp))\n                            and then No (Renamed_Object (Entity (Comp))))\n \n                  or else (Nkind (Comp) = N_Attribute_Reference\n@@ -4749,8 +4732,7 @@ package body Exp_Aggr is\n \n             elsif Nkind (Indx) = N_Function_Call\n               and then Is_Entity_Name (Name (Indx))\n-              and then\n-                Has_Pragma_Pure_Function (Entity (Name (Indx)))\n+              and then Has_Pragma_Pure_Function (Entity (Name (Indx)))\n             then\n                return True;\n \n@@ -4777,8 +4759,7 @@ package body Exp_Aggr is\n \n          elsif Nkind (N) = N_Indexed_Component\n            and then Safe_Left_Hand_Side (Prefix (N))\n-           and then\n-             Is_Safe_Index (First (Expressions (N)))\n+           and then Is_Safe_Index (First (Expressions (N)))\n          then\n             return True;\n \n@@ -4968,9 +4949,7 @@ package body Exp_Aggr is\n       --  that Convert_To_Positional succeeded and reanalyzed the rewritten\n       --  aggregate.\n \n-      elsif Analyzed (N)\n-        and then N /= Original_Node (N)\n-      then\n+      elsif Analyzed (N) and then N /= Original_Node (N) then\n          return;\n       end if;\n \n@@ -5165,13 +5144,21 @@ package body Exp_Aggr is\n             end if;\n          end if;\n \n+      --  If a slice assignment has an aggregate with a single others_choice,\n+      --  the assignment can be done in place even if bounds are not static,\n+      --  by converting it into a loop over the discrete range of the slice.\n+\n       elsif Maybe_In_Place_OK\n         and then Nkind (Name (Parent (N))) = N_Slice\n-        and then Safe_Slice_Assignment (N)\n+        and then Comes_From_Source (N)\n+        and then Is_Others_Aggregate (N)\n       then\n-         --  Safe_Slice_Assignment rewrites assignment as a loop\n+         Tmp := Name (Parent (N));\n \n-         return;\n+         --  Set type of aggregate to be type of lhs in assignment, in order\n+         --  to suppress redundant length checks.\n+\n+         Set_Etype (N, Etype (Tmp));\n \n       --  Step 5\n \n@@ -5958,9 +5945,7 @@ package body Exp_Aggr is\n             --  extension aggregate, the parent expr is replaced by an\n             --  aggregate formed by selected components of this expr.\n \n-            if Present (Parent_Expr)\n-              and then Is_Empty_List (Comps)\n-            then\n+            if Present (Parent_Expr) and then Is_Empty_List (Comps) then\n                Comp := First_Component_Or_Discriminant (Typ);\n                while Present (Comp) loop\n \n@@ -6026,17 +6011,20 @@ package body Exp_Aggr is\n                   First_Comp := First (Component_Associations (N));\n                   Parent_Comps := New_List;\n                   while Present (First_Comp)\n-                    and then Scope (Original_Record_Component (\n-                            Entity (First (Choices (First_Comp))))) /= Base_Typ\n+                    and then\n+                      Scope (Original_Record_Component\n+                               (Entity (First (Choices (First_Comp))))) /=\n+                                                                    Base_Typ\n                   loop\n                      Comp := First_Comp;\n                      Next (First_Comp);\n                      Remove (Comp);\n                      Append (Comp, Parent_Comps);\n                   end loop;\n \n-                  Parent_Aggr := Make_Aggregate (Loc,\n-                    Component_Associations => Parent_Comps);\n+                  Parent_Aggr :=\n+                    Make_Aggregate (Loc,\n+                      Component_Associations => Parent_Comps);\n                   Set_Etype (Parent_Aggr, Etype (Base_Type (Typ)));\n \n                   --  Find the _parent component\n@@ -6129,8 +6117,7 @@ package body Exp_Aggr is\n          Expr := Expression (C);\n \n          if Present (Expr)\n-           and then\n-             Nkind_In (Expr, N_Aggregate, N_Extension_Aggregate)\n+           and then Nkind_In (Expr, N_Aggregate, N_Extension_Aggregate)\n            and then Has_Default_Init_Comps (Expr)\n          then\n             return True;\n@@ -6156,7 +6143,7 @@ package body Exp_Aggr is\n          Kind := Nkind (Node);\n       end if;\n \n-      if Kind /= N_Aggregate and then Kind /= N_Extension_Aggregate then\n+      if not Nkind_In (Kind, N_Aggregate, N_Extension_Aggregate) then\n          return False;\n       else\n          return Expansion_Delayed (Node);\n@@ -6591,8 +6578,8 @@ package body Exp_Aggr is\n         and then Number_Discriminants (Bas) /= Number_Discriminants (Par)\n         and then Nkind (Decl) = N_Full_Type_Declaration\n         and then Nkind (Type_Definition (Decl)) = N_Record_Definition\n-        and then Present\n-          (Variant_Part (Component_List (Type_Definition (Decl))))\n+        and then\n+          Present (Variant_Part (Component_List (Type_Definition (Decl))))\n         and then Nkind (N) /= N_Extension_Aggregate\n       then\n \n@@ -6614,6 +6601,7 @@ package body Exp_Aggr is\n       Typ      : Entity_Id) return Boolean\n    is\n       L1, L2, H1, H2 : Node_Id;\n+\n    begin\n       --  No sliding if the type of the object is not established yet, if it is\n       --  an unconstrained type whose actual subtype comes from the aggregate,\n@@ -6648,70 +6636,6 @@ package body Exp_Aggr is\n       end if;\n    end Must_Slide;\n \n-   ---------------------------\n-   -- Safe_Slice_Assignment --\n-   ---------------------------\n-\n-   function Safe_Slice_Assignment (N : Node_Id) return Boolean is\n-      Loc        : constant Source_Ptr := Sloc (Parent (N));\n-      Pref       : constant Node_Id    := Prefix (Name (Parent (N)));\n-      Range_Node : constant Node_Id    := Discrete_Range (Name (Parent (N)));\n-      Expr       : Node_Id;\n-      L_J        : Entity_Id;\n-      L_Iter     : Node_Id;\n-      L_Body     : Node_Id;\n-      Stat       : Node_Id;\n-\n-   begin\n-      --  Generate: for J in Range loop Pref (J) := Expr; end loop;\n-\n-      if Comes_From_Source (N)\n-        and then No (Expressions (N))\n-        and then Nkind (First (Choices (First (Component_Associations (N)))))\n-                   = N_Others_Choice\n-      then\n-         Expr := Expression (First (Component_Associations (N)));\n-         L_J := Make_Temporary (Loc, 'J');\n-\n-         L_Iter :=\n-           Make_Iteration_Scheme (Loc,\n-             Loop_Parameter_Specification =>\n-               Make_Loop_Parameter_Specification\n-                 (Loc,\n-                  Defining_Identifier         => L_J,\n-                  Discrete_Subtype_Definition => Relocate_Node (Range_Node)));\n-\n-         L_Body :=\n-           Make_Assignment_Statement (Loc,\n-              Name =>\n-                Make_Indexed_Component (Loc,\n-                  Prefix      => Relocate_Node (Pref),\n-                  Expressions => New_List (New_Occurrence_Of (L_J, Loc))),\n-               Expression => Relocate_Node (Expr));\n-\n-         --  Construct the final loop\n-\n-         Stat :=\n-           Make_Implicit_Loop_Statement\n-             (Node             => Parent (N),\n-              Identifier       => Empty,\n-              Iteration_Scheme => L_Iter,\n-              Statements       => New_List (L_Body));\n-\n-         --  Set type of aggregate to be type of lhs in assignment,\n-         --  to suppress redundant length checks.\n-\n-         Set_Etype (N, Etype (Name (Parent (N))));\n-\n-         Rewrite (Parent (N), Stat);\n-         Analyze (Parent (N));\n-         return True;\n-\n-      else\n-         return False;\n-      end if;\n-   end Safe_Slice_Assignment;\n-\n    ----------------------------------\n    -- Two_Dim_Packed_Array_Handled --\n    ----------------------------------\n@@ -6724,10 +6648,10 @@ package body Exp_Aggr is\n       Packed_Array : constant Entity_Id  :=\n                        Packed_Array_Impl_Type (Base_Type (Typ));\n \n-      One_Comp  : Node_Id;\n+      One_Comp : Node_Id;\n       --  Expression in original aggregate\n \n-      One_Dim   : Node_Id;\n+      One_Dim : Node_Id;\n       --  One-dimensional subaggregate\n \n    begin"}]}