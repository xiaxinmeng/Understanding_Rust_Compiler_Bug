{"sha": "90cb08ca01e22a2b720274611c4e5b05c961ee2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjYjA4Y2EwMWUyMmEyYjcyMDI3NDYxMWM0ZTViMDVjOTYxZWUyYw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-08-22T13:41:05Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-08-22T13:41:05Z"}, "message": "combine: Do another check before splitting a parallel (PR86771)\n\nWhen combine splits a resulting parallel into its two SETs, it has to\nplace one at i2, and the other stays at i3.  This does not work if the\ndestination of the SET that will be placed at i2 is modified between\ni2 and i3.  This patch fixes it.\n\n\n\t* combine.c (try_combine): Do not allow splitting a resulting PARALLEL\n\tof two SETs into those two SETs, one to be placed at i2, if that SETs\n\tdestination is modified between i2 and i3.\n\nFrom-SVN: r263776", "tree": {"sha": "db943e0a4811520e72183aad1413716632f942a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db943e0a4811520e72183aad1413716632f942a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90cb08ca01e22a2b720274611c4e5b05c961ee2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90cb08ca01e22a2b720274611c4e5b05c961ee2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90cb08ca01e22a2b720274611c4e5b05c961ee2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90cb08ca01e22a2b720274611c4e5b05c961ee2c/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18bc19a7aa4cd08d45d64f6741b8b1e0f48f262b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18bc19a7aa4cd08d45d64f6741b8b1e0f48f262b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18bc19a7aa4cd08d45d64f6741b8b1e0f48f262b"}], "stats": {"total": 16, "additions": 14, "deletions": 2}, "files": [{"sha": "fb267ab40ad9ac5080b9590ac32e676f6b8a5f40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cb08ca01e22a2b720274611c4e5b05c961ee2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cb08ca01e22a2b720274611c4e5b05c961ee2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90cb08ca01e22a2b720274611c4e5b05c961ee2c", "patch": "@@ -1,3 +1,9 @@\n+2018-08-22  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* combine.c (try_combine): Do not allow splitting a resulting PARALLEL\n+\tof two SETs into those two SETs, one to be placed at i2, if that SETs\n+\tdestination is modified between i2 and i3.\n+\n 2018-08-22  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/86725"}, {"sha": "d322614ed577971535feea08de5f0b3f2e08770d", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cb08ca01e22a2b720274611c4e5b05c961ee2c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cb08ca01e22a2b720274611c4e5b05c961ee2c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=90cb08ca01e22a2b720274611c4e5b05c961ee2c", "patch": "@@ -4036,7 +4036,10 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n      other insns to combine, but the destination of that SET is still live.\n \n      Also do this if we started with two insns and (at least) one of the\n-     resulting sets is a noop; this noop will be deleted later.  */\n+     resulting sets is a noop; this noop will be deleted later.\n+\n+     Also do this if we started with two insns neither of which was a simple\n+     move.  */\n \n   else if (insn_code_number < 0 && asm_noperands (newpat) < 0\n \t   && GET_CODE (newpat) == PARALLEL\n@@ -4066,13 +4069,15 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t one which uses any regs/memory set in between i2 and i3 can't\n \t be first.  The PARALLEL might also have been pre-existing in i3,\n \t so we need to make sure that we won't wrongly hoist a SET to i2\n-\t that would conflict with a death note present in there.  */\n+\t that would conflict with a death note present in there, or would\n+\t have its dest modified between i2 and i3.  */\n       if (!modified_between_p (SET_SRC (set1), i2, i3)\n \t  && !(REG_P (SET_DEST (set1))\n \t       && find_reg_note (i2, REG_DEAD, SET_DEST (set1)))\n \t  && !(GET_CODE (SET_DEST (set1)) == SUBREG\n \t       && find_reg_note (i2, REG_DEAD,\n \t\t\t\t SUBREG_REG (SET_DEST (set1))))\n+\t  && !modified_between_p (SET_DEST (set1), i2, i3)\n \t  && (!HAVE_cc0 || !reg_referenced_p (cc0_rtx, set0))\n \t  /* If I3 is a jump, ensure that set0 is a jump so that\n \t     we do not create invalid RTL.  */\n@@ -4088,6 +4093,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t       && !(GET_CODE (SET_DEST (set0)) == SUBREG\n \t\t    && find_reg_note (i2, REG_DEAD,\n \t\t\t\t      SUBREG_REG (SET_DEST (set0))))\n+\t       && !modified_between_p (SET_DEST (set0), i2, i3)\n \t       && (!HAVE_cc0 || !reg_referenced_p (cc0_rtx, set1))\n \t       /* If I3 is a jump, ensure that set1 is a jump so that\n \t\t  we do not create invalid RTL.  */"}]}