{"sha": "048d0d36c2021df68c27dcc308f8f0717f0537bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ4ZDBkMzZjMjAyMWRmNjhjMjdkY2MzMDhmOGYwNzE3ZjA1MzdiZg==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@ispras.ru", "date": "2006-03-16T05:29:44Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2006-03-16T05:29:44Z"}, "message": "ia64.c (stops_p): Added explicit initialization.\n\n2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n\n        * config/ia64/ia64.c (stops_p): Added explicit initialization.\n        (ia64_first_cycle_multipass_dfa_lookahead_guard_spec,\n        ia64_h_i_d_extended, ia64_set_sched_flags, ia64_speculate_insn,\n        ia64_needs_block_p, ia64_gen_check, ia64_sched_init_global,\n\tia64_sched_finish_global): New static functions to implement\n\thooks from gcc_target.sched.\n\t(spec_check_no, max_uid, pending_data_specs): New static variables.\n        (ia64_mode_to_int, ia64_gen_spec_insn, ia64_spec_check_p,\n\tia64_spec_check_src_p): New static functions.\n        (ia64_adjust_cost): Renamed to ia64_adjust_cost_2.\n        (TARGET_SCHED_ADJUST_COST): Removed.\n        (TARGET_SCHED_ADJUST_COST_2, TARGET_SCHED_INIT_GLOBAL,\n\tTARGET_SCHED_FINISH_GLOBAL, TARGET_SCHED_H_I_D_EXTENDED,\n\tTARGET_SCHED_SPECULATE_INSN, TARGET_SCHED_NEEDS_BLOCK_P,\n\tTARGET_SCHED_GEN_CHECK,\n\tTARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC,\n        TARGET_SCHED_SET_SCHED_FLAGS): New macros.\n        (update_set_flags, group_barrier_needed, set_src_needs_barrier):\n\tFixed to handle speculation checks.\n        (rtx_needs_barrier): Fixed to handle speculative loads and\n        their checks.\n        (ia64_variable_issue): Added code to count speculative loads and their\n        checks.\n        (ia64_first_cycle_multipass_dfa_lookahead_guard): Fixed to handle\n        speculative loads.\n        (enum SPEC_MODES, enum SPEC_GEN_LD_MAP, SPEC_GEN_CHECK_OFFSET):\n        New enumerations.\n        (SPEC_GEN_EXTEND_OFFSET, SPEC_N, SPEC_GEN_CHECK_MUTATION_OFFSET):\n        New constants.\n        (ia64_ld_address_bypass_p): Fixed to handle speculative loads.\n\t(ia64_reorg): Reset stops_p to NULL after it is freed.\n        * config/ia64/ia64.md (UNSPEC_LDA, UNSPEC_LDS, UNSPEC_LDSA,\n\tUNSPEC_LDCCLR, UNSPEC_CHKACLR, UNSPEC_CHKS): New constants.\n        (itanium_class): chk_s renamed to chk_s_i.  New constants: chk_s_f,\n        chk_a.\n        (data_speculative, control_speculative, check_load): New attributes.\n        (mov<mode>_advanced, mov<mode>_speculative,\n        mov<mode>_speculative_advanced, zero_extend<mode>di2_advanced,\n        zero_extend<mode>di2_speculative,\n        zero_extend<mode>di2_speculative_advanced): New patterns for\n        data and control speculative loads.\n        (mov<mode>_clr, zero_extend<mode>di2_clr): New patterns for\n        check loads.\n        (advanced_load_check_clr_<mode>, speculation_check_<mode>):\n        New pattern for data and control speculation checks.\n\t(MODE, MODE_FOR_EXTEND, output_a, output_s, output_sa, output_c_clr,\n\tld_reg_constr, ldc_reg_constr, chk_reg_constr, mem_constr,\n\treg_pred_prefix, ld_class, chka_class, chks_class, attr_yes):\n\tAuxiliary definitions for the patterns.\n        * config/ia64/itanium1.md (1_fldc, 1_fldpc, 1_ldc, 1_chk_s_f, 1_chk_a,\n        1b_fldc, 1b_fldpc, 1b_ldc, 1b_chk_s_f, 1b_chk_a): New resource\n        constraints.\n\t(1_fld, 1_fldp, 1_ld, 1b_fld, 1b_fldp, 1b_ld): Add a condition\n        for speculation.\n        (1_chk_s, 1b_chk_s): Renamed to 1_chk_s_i, 1b_chk_s_i.\n        * config/ia64/itanium2.md (2_flda, 2_fldc, 2_fldpc, 2_ldc, 2_chk_s_f,\n\t2_chk_a, 2b_flda, 2b_fldc, 2b_fldpc, 2b_ldc, 2b_chk_s_f, 2b_chk_a):\n\tNew resource constraints.\n\t(2_fld, 2_fldp, 2_ld, 2b_fld, 2b_fldp, 2b_ld): Add a condition\n        for speculation.\n        (2_chk_s, 2b_chk_s): Renamed to 2_chk_s_i, 2b_chk_s_i.\n        * config/ia64/ia64.opt (msched-br-data-spec, msched-ar-data-spec,\n        msched-control-spec, msched-br-in-data-spec, msched-ar-in-data-spec,\n        msched-in-control-spec, msched-ldc, msched-control-ldc,\n        msched-spec-verbose, msched-prefer-non-data-spec-insns,\n        msched-prefer-non-control-spec-insns,\n\tmsched-count-spec-in-critical-path): New flags to tune speculative\n\tscheduling.\n\t* doc/invoke.texi (msched-br-data-spec, msched-ar-data-spec,\n        msched-control-spec, msched-br-in-data-spec, msched-ar-in-data-spec,\n        msched-in-control-spec, msched-ldc, msched-control-ldc,\n        msched-spec-verbose, msched-prefer-non-data-spec-insns,\n        msched-prefer-non-control-spec-insns,\n\tmsched-count-spec-in-critical-path): Document new flags.\n\nFrom-SVN: r112129", "tree": {"sha": "9c0c7c41fc38a764a7476c54f865b7174e711e1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0c7c41fc38a764a7476c54f865b7174e711e1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/048d0d36c2021df68c27dcc308f8f0717f0537bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048d0d36c2021df68c27dcc308f8f0717f0537bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/048d0d36c2021df68c27dcc308f8f0717f0537bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048d0d36c2021df68c27dcc308f8f0717f0537bf/comments", "author": null, "committer": null, "parents": [{"sha": "496d7bb03214b7835638fa14d7275e89d3bec954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496d7bb03214b7835638fa14d7275e89d3bec954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/496d7bb03214b7835638fa14d7275e89d3bec954"}], "stats": {"total": 1428, "additions": 1357, "deletions": 71}, "files": [{"sha": "579f7a3c58f13e7ac2d870273dd77aa1a654a5e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=048d0d36c2021df68c27dcc308f8f0717f0537bf", "patch": "@@ -1,3 +1,80 @@\n+2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n+\n+        * config/ia64/ia64.c (stops_p): Added explicit initialization.\n+        (ia64_first_cycle_multipass_dfa_lookahead_guard_spec,\n+        ia64_h_i_d_extended, ia64_set_sched_flags, ia64_speculate_insn,\n+        ia64_needs_block_p, ia64_gen_check, ia64_sched_init_global,\n+\tia64_sched_finish_global): New static functions to implement\n+\thooks from gcc_target.sched.\n+\t(spec_check_no, max_uid, pending_data_specs): New static variables.\n+        (ia64_mode_to_int, ia64_gen_spec_insn, ia64_spec_check_p,\n+\tia64_spec_check_src_p): New static functions.\n+        (ia64_adjust_cost): Renamed to ia64_adjust_cost_2.\n+        (TARGET_SCHED_ADJUST_COST): Removed.\n+        (TARGET_SCHED_ADJUST_COST_2, TARGET_SCHED_INIT_GLOBAL,\n+\tTARGET_SCHED_FINISH_GLOBAL, TARGET_SCHED_H_I_D_EXTENDED,\n+\tTARGET_SCHED_SPECULATE_INSN, TARGET_SCHED_NEEDS_BLOCK_P,\n+\tTARGET_SCHED_GEN_CHECK,\n+\tTARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC,\n+        TARGET_SCHED_SET_SCHED_FLAGS): New macros.\n+        (update_set_flags, group_barrier_needed, set_src_needs_barrier):\n+\tFixed to handle speculation checks.\n+        (rtx_needs_barrier): Fixed to handle speculative loads and\n+        their checks.\n+        (ia64_variable_issue): Added code to count speculative loads and their\n+        checks.\n+        (ia64_first_cycle_multipass_dfa_lookahead_guard): Fixed to handle\n+        speculative loads.\n+        (enum SPEC_MODES, enum SPEC_GEN_LD_MAP, SPEC_GEN_CHECK_OFFSET):\n+        New enumerations.\n+        (SPEC_GEN_EXTEND_OFFSET, SPEC_N, SPEC_GEN_CHECK_MUTATION_OFFSET):\n+        New constants.\n+        (ia64_ld_address_bypass_p): Fixed to handle speculative loads.\n+\t(ia64_reorg): Reset stops_p to NULL after it is freed.\n+        * config/ia64/ia64.md (UNSPEC_LDA, UNSPEC_LDS, UNSPEC_LDSA,\n+\tUNSPEC_LDCCLR, UNSPEC_CHKACLR, UNSPEC_CHKS): New constants.\n+        (itanium_class): chk_s renamed to chk_s_i.  New constants: chk_s_f,\n+        chk_a.\n+        (data_speculative, control_speculative, check_load): New attributes.\n+        (mov<mode>_advanced, mov<mode>_speculative,\n+        mov<mode>_speculative_advanced, zero_extend<mode>di2_advanced,\n+        zero_extend<mode>di2_speculative,\n+        zero_extend<mode>di2_speculative_advanced): New patterns for\n+        data and control speculative loads.\n+        (mov<mode>_clr, zero_extend<mode>di2_clr): New patterns for\n+        check loads.\n+        (advanced_load_check_clr_<mode>, speculation_check_<mode>):\n+        New pattern for data and control speculation checks.\n+\t(MODE, MODE_FOR_EXTEND, output_a, output_s, output_sa, output_c_clr,\n+\tld_reg_constr, ldc_reg_constr, chk_reg_constr, mem_constr,\n+\treg_pred_prefix, ld_class, chka_class, chks_class, attr_yes):\n+\tAuxiliary definitions for the patterns.\n+        * config/ia64/itanium1.md (1_fldc, 1_fldpc, 1_ldc, 1_chk_s_f, 1_chk_a,\n+        1b_fldc, 1b_fldpc, 1b_ldc, 1b_chk_s_f, 1b_chk_a): New resource\n+        constraints.\n+\t(1_fld, 1_fldp, 1_ld, 1b_fld, 1b_fldp, 1b_ld): Add a condition\n+        for speculation.\n+        (1_chk_s, 1b_chk_s): Renamed to 1_chk_s_i, 1b_chk_s_i.\n+        * config/ia64/itanium2.md (2_flda, 2_fldc, 2_fldpc, 2_ldc, 2_chk_s_f,\n+\t2_chk_a, 2b_flda, 2b_fldc, 2b_fldpc, 2b_ldc, 2b_chk_s_f, 2b_chk_a):\n+\tNew resource constraints.\n+\t(2_fld, 2_fldp, 2_ld, 2b_fld, 2b_fldp, 2b_ld): Add a condition\n+        for speculation.\n+        (2_chk_s, 2b_chk_s): Renamed to 2_chk_s_i, 2b_chk_s_i.\n+        * config/ia64/ia64.opt (msched-br-data-spec, msched-ar-data-spec,\n+        msched-control-spec, msched-br-in-data-spec, msched-ar-in-data-spec,\n+        msched-in-control-spec, msched-ldc, msched-control-ldc,\n+        msched-spec-verbose, msched-prefer-non-data-spec-insns,\n+        msched-prefer-non-control-spec-insns,\n+\tmsched-count-spec-in-critical-path): New flags to tune speculative\n+\tscheduling.\n+\t* doc/invoke.texi (msched-br-data-spec, msched-ar-data-spec,\n+        msched-control-spec, msched-br-in-data-spec, msched-ar-in-data-spec,\n+        msched-in-control-spec, msched-ldc, msched-control-ldc,\n+        msched-spec-verbose, msched-prefer-non-data-spec-insns,\n+        msched-prefer-non-control-spec-insns,\n+\tmsched-count-spec-in-critical-path): Document new flags.\n+\n 2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n \n         * target.h (struct spec_info_def): New opaque declaration."}, {"sha": "2fb1c153366940674dd4a5cd8c5944211a4e563c", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 717, "deletions": 17, "changes": 734, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=048d0d36c2021df68c27dcc308f8f0717f0537bf", "patch": "@@ -158,7 +158,17 @@ static void ia64_dependencies_evaluation_hook (rtx, rtx);\n static void ia64_init_dfa_pre_cycle_insn (void);\n static rtx ia64_dfa_pre_cycle_insn (void);\n static int ia64_first_cycle_multipass_dfa_lookahead_guard (rtx);\n+static bool ia64_first_cycle_multipass_dfa_lookahead_guard_spec (rtx);\n static int ia64_dfa_new_cycle (FILE *, int, rtx, int, int, int *);\n+static void ia64_h_i_d_extended (void);\n+static int ia64_mode_to_int (enum machine_mode);\n+static void ia64_set_sched_flags (spec_info_t);\n+static int ia64_speculate_insn (rtx, ds_t, rtx *);\n+static rtx ia64_gen_spec_insn (rtx, ds_t, int, bool, bool);\n+static bool ia64_needs_block_p (rtx);\n+static rtx ia64_gen_check (rtx, rtx, bool);\n+static int ia64_spec_check_p (rtx);\n+static int ia64_spec_check_src_p (rtx);\n static rtx gen_tls_get_addr (void);\n static rtx gen_thread_pointer (void);\n static int find_gr_spill (int);\n@@ -200,8 +210,10 @@ static void ia64_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void ia64_output_function_end_prologue (FILE *);\n \n static int ia64_issue_rate (void);\n-static int ia64_adjust_cost (rtx, rtx, rtx, int);\n+static int ia64_adjust_cost_2 (rtx, int, rtx, int);\n static void ia64_sched_init (FILE *, int, int);\n+static void ia64_sched_init_global (FILE *, int, int);\n+static void ia64_sched_finish_global (FILE *, int);\n static void ia64_sched_finish (FILE *, int);\n static int ia64_dfa_sched_reorder (FILE *, int, rtx *, int *, int, int);\n static int ia64_sched_reorder (FILE *, int, rtx *, int *, int);\n@@ -313,8 +325,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P  ia64_in_small_data_p\n \n-#undef TARGET_SCHED_ADJUST_COST\n-#define TARGET_SCHED_ADJUST_COST ia64_adjust_cost\n+#undef TARGET_SCHED_ADJUST_COST_2\n+#define TARGET_SCHED_ADJUST_COST_2 ia64_adjust_cost_2\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE ia64_issue_rate\n #undef TARGET_SCHED_VARIABLE_ISSUE\n@@ -323,6 +335,10 @@ static const struct attribute_spec ia64_attribute_table[] =\n #define TARGET_SCHED_INIT ia64_sched_init\n #undef TARGET_SCHED_FINISH\n #define TARGET_SCHED_FINISH ia64_sched_finish\n+#undef TARGET_SCHED_INIT_GLOBAL\n+#define TARGET_SCHED_INIT_GLOBAL ia64_sched_init_global\n+#undef TARGET_SCHED_FINISH_GLOBAL\n+#define TARGET_SCHED_FINISH_GLOBAL ia64_sched_finish_global\n #undef TARGET_SCHED_REORDER\n #define TARGET_SCHED_REORDER ia64_sched_reorder\n #undef TARGET_SCHED_REORDER2\n@@ -346,6 +362,25 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_SCHED_DFA_NEW_CYCLE\n #define TARGET_SCHED_DFA_NEW_CYCLE ia64_dfa_new_cycle\n \n+#undef TARGET_SCHED_H_I_D_EXTENDED\n+#define TARGET_SCHED_H_I_D_EXTENDED ia64_h_i_d_extended\n+\n+#undef TARGET_SCHED_SET_SCHED_FLAGS\n+#define TARGET_SCHED_SET_SCHED_FLAGS ia64_set_sched_flags\n+\n+#undef TARGET_SCHED_SPECULATE_INSN\n+#define TARGET_SCHED_SPECULATE_INSN ia64_speculate_insn\n+\n+#undef TARGET_SCHED_NEEDS_BLOCK_P\n+#define TARGET_SCHED_NEEDS_BLOCK_P ia64_needs_block_p\n+\n+#undef TARGET_SCHED_GEN_CHECK\n+#define TARGET_SCHED_GEN_CHECK ia64_gen_check\n+\n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC\\\n+  ia64_first_cycle_multipass_dfa_lookahead_guard_spec\n+\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ia64_function_ok_for_sibcall\n #undef TARGET_ARG_PARTIAL_BYTES\n@@ -5414,13 +5449,15 @@ update_set_flags (rtx x, struct reg_flags *pflags)\n       return;\n \n     case IF_THEN_ELSE:\n-      /* There are three cases here:\n+      /* There are four cases here:\n \t (1) The destination is (pc), in which case this is a branch,\n \t nothing here applies.\n \t (2) The destination is ar.lc, in which case this is a\n \t doloop_end_internal,\n \t (3) The destination is an fp register, in which case this is\n \t an fselect instruction.\n+\t (4) The condition has (unspec [(reg)] UNSPEC_LDC), in which case \n+\t this is a check load.\n \t In all cases, nothing we do in this function applies.  */\n       return;\n \n@@ -5465,18 +5502,29 @@ set_src_needs_barrier (rtx x, struct reg_flags flags, int pred)\n       /* X is a conditional branch.  */\n       /* ??? This seems redundant, as the caller sets this bit for\n \t all JUMP_INSNs.  */\n-      flags.is_branch = 1;\n+      if (!ia64_spec_check_src_p (src))\n+\tflags.is_branch = 1;\n       return rtx_needs_barrier (src, flags, pred);\n     }\n \n-  need_barrier = rtx_needs_barrier (src, flags, pred);\n+  if (ia64_spec_check_src_p (src))\n+    /* Avoid checking one register twice (in condition \n+       and in 'then' section) for ldc pattern.  */\n+    {\n+      gcc_assert (REG_P (XEXP (src, 2)));\n+      need_barrier = rtx_needs_barrier (XEXP (src, 2), flags, pred);\n+\t\t  \n+      /* We process MEM below.  */\n+      src = XEXP (src, 1);\n+    }\n+\n+  need_barrier |= rtx_needs_barrier (src, flags, pred);\n \n   dst = SET_DEST (x);\n   if (GET_CODE (dst) == ZERO_EXTRACT)\n     {\n       need_barrier |= rtx_needs_barrier (XEXP (dst, 1), flags, pred);\n       need_barrier |= rtx_needs_barrier (XEXP (dst, 2), flags, pred);\n-      dst = XEXP (dst, 0);\n     }\n   return need_barrier;\n }\n@@ -5725,6 +5773,11 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \tcase UNSPEC_SETF_EXP:\n         case UNSPEC_ADDP4:\n \tcase UNSPEC_FR_SQRT_RECIP_APPROX:\n+\tcase UNSPEC_LDA:\n+\tcase UNSPEC_LDS:\n+\tcase UNSPEC_LDSA:\n+\tcase UNSPEC_CHKACLR:\n+        case UNSPEC_CHKS:\n \t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n \t  break;\n \n@@ -5872,7 +5925,8 @@ group_barrier_needed (rtx insn)\n       break;\n \n     case JUMP_INSN:\n-      flags.is_branch = 1;\n+      if (!ia64_spec_check_p (insn))\n+\tflags.is_branch = 1;\n \n       /* Don't bundle a jump following a call.  */\n       if ((pat = prev_active_insn (insn))\n@@ -6126,7 +6180,15 @@ static state_t prev_cycle_state = NULL;\n /* The following array element values are TRUE if the corresponding\n    insn requires to add stop bits before it.  */\n \n-static char *stops_p;\n+static char *stops_p = NULL;\n+\n+/* The following array element values are ZERO for non-speculative\n+   instructions and hold corresponding speculation check number for\n+   speculative instructions.  */\n+static int *spec_check_no = NULL;\n+\n+/* Size of spec_check_no array.  */\n+static int max_uid = 0;\n \n /* The following variable is used to set up the mentioned above array.  */\n \n@@ -6148,6 +6210,9 @@ static int *clocks;\n \n static int *add_cycles;\n \n+/* The following variable value is number of data speculations in progress.  */\n+static int pending_data_specs = 0;\n+\n static rtx ia64_single_set (rtx);\n static void ia64_emit_insn_before (rtx, rtx);\n \n@@ -6197,16 +6262,18 @@ ia64_single_set (rtx insn)\n   return ret;\n }\n \n-/* Adjust the cost of a scheduling dependency.  Return the new cost of\n-   a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n+/* Adjust the cost of a scheduling dependency.\n+   Return the new cost of a dependency of type DEP_TYPE or INSN on DEP_INSN.\n+   COST is the current cost.  */\n \n static int\n-ia64_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n+ia64_adjust_cost_2 (rtx insn, int dep_type1, rtx dep_insn, int cost)\n {\n+  enum reg_note dep_type = (enum reg_note) dep_type1;\n   enum attr_itanium_class dep_class;\n   enum attr_itanium_class insn_class;\n \n-  if (REG_NOTE_KIND (link) != REG_DEP_OUTPUT)\n+  if (dep_type != REG_DEP_OUTPUT)\n     return cost;\n \n   insn_class = ia64_safe_itanium_class (insn);\n@@ -6293,6 +6360,26 @@ ia64_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n   init_insn_group_barriers ();\n }\n \n+/* We're beginning a scheduling pass.  Check assertion.  */\n+\n+static void\n+ia64_sched_init_global (FILE *dump ATTRIBUTE_UNUSED,\n+                        int sched_verbose ATTRIBUTE_UNUSED,\n+                        int max_ready ATTRIBUTE_UNUSED)\n+{  \n+  gcc_assert (!pending_data_specs);\n+}\n+\n+/* Scheduling pass is now finished.  Free/reset static variable.  */\n+static void\n+ia64_sched_finish_global (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t\t  int sched_verbose ATTRIBUTE_UNUSED)\n+{\n+  free (spec_check_no);\n+  spec_check_no = 0;\n+  max_uid = 0;\n+}\n+\n /* We are about to being issuing insns for this clock cycle.\n    Override the default sort algorithm to better slot instructions.  */\n \n@@ -6415,6 +6502,16 @@ ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n \t\t     rtx insn ATTRIBUTE_UNUSED,\n \t\t     int can_issue_more ATTRIBUTE_UNUSED)\n {\n+  if (current_sched_info->flags & DO_SPECULATION)\n+    /* Modulo scheduling does not extend h_i_d when emitting\n+       new instructions.  Deal with it.  */\n+    {\n+      if (DONE_SPEC (insn) & BEGIN_DATA)\n+\tpending_data_specs++;\n+      if (CHECK_SPEC (insn) & BEGIN_DATA)\n+\tpending_data_specs--;\n+    }\n+\n   last_scheduled_insn = insn;\n   memcpy (prev_cycle_state, curr_state, dfa_state_size);\n   if (reload_completed)\n@@ -6437,8 +6534,22 @@ static int\n ia64_first_cycle_multipass_dfa_lookahead_guard (rtx insn)\n {\n   gcc_assert (insn  && INSN_P (insn));\n-  return (!reload_completed\n-\t  || !safe_group_barrier_needed (insn));\n+  return ((!reload_completed\n+\t   || !safe_group_barrier_needed (insn))\n+\t  && ia64_first_cycle_multipass_dfa_lookahead_guard_spec (insn));\n+}\n+\n+/* We are choosing insn from the ready queue.  Return nonzero if INSN\n+   can be chosen.  */\n+\n+static bool\n+ia64_first_cycle_multipass_dfa_lookahead_guard_spec (rtx insn)\n+{\n+  gcc_assert (insn  && INSN_P (insn));\n+  /* Size of ALAT is 32.  As far as we perform conservative data speculation,\n+     we keep ALAT half-empty.  */\n+  return (pending_data_specs < 16\n+\t  || !(TODO_SPEC (insn) & BEGIN_DATA));\n }\n \n /* The following variable value is pseudo-insn used by the DFA insn\n@@ -6526,6 +6637,578 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n   return 0;\n }\n \n+/* Implement targetm.sched.h_i_d_extended hook.\n+   Extend internal data structures.  */\n+static void\n+ia64_h_i_d_extended (void)\n+{\n+  if (current_sched_info->flags & DO_SPECULATION)\n+    {\n+      int new_max_uid = get_max_uid () + 1;\n+\n+      spec_check_no = xrecalloc (spec_check_no, new_max_uid,\n+\t\t\t\t max_uid, sizeof (*spec_check_no));\n+      max_uid = new_max_uid;\n+    }\n+\n+  if (stops_p != NULL) \n+    {\n+      int new_clocks_length = get_max_uid () + 1;\n+      \n+      stops_p = xrecalloc (stops_p, new_clocks_length, clocks_length, 1);\n+      \n+      if (ia64_tune == PROCESSOR_ITANIUM)\n+\t{\n+\t  clocks = xrecalloc (clocks, new_clocks_length, clocks_length,\n+\t\t\t      sizeof (int));\n+\t  add_cycles = xrecalloc (add_cycles, new_clocks_length, clocks_length,\n+\t\t\t\t  sizeof (int));\n+\t}\n+      \n+      clocks_length = new_clocks_length;\n+    }\n+}\n+\n+/* Constants that help mapping 'enum machine_mode' to int.  */\n+enum SPEC_MODES\n+  {\n+    SPEC_MODE_INVALID = -1,\n+    SPEC_MODE_FIRST = 0,\n+    SPEC_MODE_FOR_EXTEND_FIRST = 1,\n+    SPEC_MODE_FOR_EXTEND_LAST = 3,\n+    SPEC_MODE_LAST = 8\n+  };\n+\n+/* Return index of the MODE.  */\n+static int\n+ia64_mode_to_int (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case BImode: return 0; /* SPEC_MODE_FIRST  */\n+    case QImode: return 1; /* SPEC_MODE_FOR_EXTEND_FIRST  */\n+    case HImode: return 2;\n+    case SImode: return 3; /* SPEC_MODE_FOR_EXTEND_LAST  */\n+    case DImode: return 4;\n+    case SFmode: return 5;\n+    case DFmode: return 6;\n+    case XFmode: return 7;\n+    case TImode:\n+      /* ??? This mode needs testing.  Bypasses for ldfp8 instruction are not\n+\t mentioned in itanium[12].md.  Predicate fp_register_operand also\n+\t needs to be defined.  Bottom line: better disable for now.  */\n+      return SPEC_MODE_INVALID;\n+    default:     return SPEC_MODE_INVALID;\n+    }\n+}\n+\n+/* Provide information about speculation capabilities.  */\n+static void\n+ia64_set_sched_flags (spec_info_t spec_info)\n+{\n+  unsigned int *flags = &(current_sched_info->flags);\n+\n+  if (*flags & SCHED_RGN\n+      || *flags & SCHED_EBB)  \n+    {\n+      int mask = 0;\n+\n+      if ((mflag_sched_br_data_spec && !reload_completed)\n+\t  || (mflag_sched_ar_data_spec && reload_completed))\n+\t{\n+\t  mask |= BEGIN_DATA;\n+\t  \n+\t  if ((mflag_sched_br_in_data_spec && !reload_completed)\n+\t      || (mflag_sched_ar_in_data_spec && reload_completed))\n+\t    mask |= BE_IN_DATA;\n+\t}\n+      \n+      if (mflag_sched_control_spec)\n+\t{\n+\t  mask |= BEGIN_CONTROL;\n+\t  \n+\t  if (mflag_sched_in_control_spec)\n+\t    mask |= BE_IN_CONTROL;\n+\t}\n+\n+      gcc_assert (*flags & USE_GLAT);\n+\n+      if (mask)\n+\t{\n+\t  *flags |= USE_DEPS_LIST | DETACH_LIFE_INFO | DO_SPECULATION;\n+\t  \n+\t  spec_info->mask = mask;\n+\t  spec_info->flags = 0;\n+      \n+\t  if ((mask & DATA_SPEC) && mflag_sched_prefer_non_data_spec_insns)\n+\t    spec_info->flags |= PREFER_NON_DATA_SPEC;\n+\n+\t  if ((mask & CONTROL_SPEC)\n+\t      && mflag_sched_prefer_non_control_spec_insns)\n+\t    spec_info->flags |= PREFER_NON_CONTROL_SPEC;\n+\n+\t  if (mflag_sched_spec_verbose)\n+\t    {\n+\t      if (sched_verbose >= 1)\n+\t\tspec_info->dump = sched_dump;\n+\t      else\n+\t\tspec_info->dump = stderr;\n+\t    }\n+\t  else\n+\t    spec_info->dump = 0;\n+\t  \n+\t  if (mflag_sched_count_spec_in_critical_path)\n+\t    spec_info->flags |= COUNT_SPEC_IN_CRITICAL_PATH;\n+\t}\n+    }\n+}\n+\n+/* Implement targetm.sched.speculate_insn hook.\n+   Check if the INSN can be TS speculative.\n+   If 'no' - return -1.\n+   If 'yes' - generate speculative pattern in the NEW_PAT and return 1.\n+   If current pattern of the INSN already provides TS speculation, return 0.  */\n+static int\n+ia64_speculate_insn (rtx insn, ds_t ts, rtx *new_pat)\n+{  \n+  rtx pat, reg, mem, mem_reg;\n+  int mode_no, gen_p = 1;\n+  bool extend_p;\n+  \n+  gcc_assert (!(ts & ~BEGIN_SPEC) && ts);\n+           \n+  pat = PATTERN (insn);\n+\n+  if (GET_CODE (pat) == COND_EXEC)\n+    pat = COND_EXEC_CODE (pat);\n+\n+  if (GET_CODE (pat) != SET)\n+    return -1;\n+  reg = SET_DEST (pat);\n+  if (!REG_P (reg))\n+    return -1;\n+\n+  mem = SET_SRC (pat);  \n+  if (GET_CODE (mem) == ZERO_EXTEND)\n+    {\n+      mem = XEXP (mem, 0);\n+      extend_p = true;      \n+    }\n+  else\n+    extend_p = false;\n+\n+  if (GET_CODE (mem) == UNSPEC)\n+    {\n+      int code;\n+      \n+      code = XINT (mem, 1);\n+      if (code != UNSPEC_LDA && code != UNSPEC_LDS && code != UNSPEC_LDSA)\n+\treturn -1;\n+\n+      if ((code == UNSPEC_LDA && !(ts & BEGIN_CONTROL))\n+\t  || (code == UNSPEC_LDS && !(ts & BEGIN_DATA))\n+\t  || code == UNSPEC_LDSA)\n+\tgen_p = 0;\n+\n+      mem = XVECEXP (mem, 0, 0);\n+      gcc_assert (MEM_P (mem));\n+    }\n+  if (!MEM_P (mem))\n+    return -1;\n+  mem_reg = XEXP (mem, 0);\n+  if (!REG_P (mem_reg))\n+    return -1;\n+     \n+  /* We should use MEM's mode since REG's mode in presence of ZERO_EXTEND\n+     will always be DImode.  */\n+  mode_no = ia64_mode_to_int (GET_MODE (mem));\n+  \n+  if (mode_no == SPEC_MODE_INVALID\n+      || (extend_p\n+\t  && !(SPEC_MODE_FOR_EXTEND_FIRST <= mode_no\n+\t       && mode_no <= SPEC_MODE_FOR_EXTEND_LAST)))\n+    return -1;\n+\n+  extract_insn_cached (insn);\n+  gcc_assert (reg == recog_data.operand[0] && mem == recog_data.operand[1]);\n+  *new_pat = ia64_gen_spec_insn (insn, ts, mode_no, gen_p != 0, extend_p);\n+\n+  return gen_p;\n+}\n+\n+enum\n+  {\n+    /* Offset to reach ZERO_EXTEND patterns.  */\n+    SPEC_GEN_EXTEND_OFFSET = SPEC_MODE_LAST - SPEC_MODE_FOR_EXTEND_FIRST + 1,\n+    /* Number of patterns for each speculation mode.  */\n+    SPEC_N = (SPEC_MODE_LAST\n+              + SPEC_MODE_FOR_EXTEND_LAST - SPEC_MODE_FOR_EXTEND_FIRST + 2)\n+  };\n+\n+enum SPEC_GEN_LD_MAP\n+  {\n+    /* Offset to ld.a patterns.  */\n+    SPEC_GEN_A = 0 * SPEC_N,\n+    /* Offset to ld.s patterns.  */\n+    SPEC_GEN_S = 1 * SPEC_N,\n+    /* Offset to ld.sa patterns.  */\n+    SPEC_GEN_SA = 2 * SPEC_N,\n+    /* Offset to ld.sa patterns.  For this patterns corresponding ld.c will\n+       mutate to chk.s.  */\n+    SPEC_GEN_SA_FOR_S = 3 * SPEC_N\n+  };\n+\n+/* These offsets are used to get (4 * SPEC_N).  */\n+enum SPEC_GEN_CHECK_OFFSET\n+  {\n+    SPEC_GEN_CHKA_FOR_A_OFFSET = 4 * SPEC_N - SPEC_GEN_A,\n+    SPEC_GEN_CHKA_FOR_SA_OFFSET = 4 * SPEC_N - SPEC_GEN_SA\n+  };\n+\n+/* If GEN_P is true, calculate the index of needed speculation check and return\n+   speculative pattern for INSN with speculative mode TS, machine mode\n+   MODE_NO and with ZERO_EXTEND (if EXTEND_P is true).\n+   If GEN_P is false, just calculate the index of needed speculation check.  */\n+static rtx\n+ia64_gen_spec_insn (rtx insn, ds_t ts, int mode_no, bool gen_p, bool extend_p)\n+{\n+  rtx pat, new_pat;\n+  int load_no;\n+  int shift = 0;\n+\n+  static rtx (* const gen_load[]) (rtx, rtx) = {\n+    gen_movbi_advanced,\n+    gen_movqi_advanced,\n+    gen_movhi_advanced,\n+    gen_movsi_advanced,\n+    gen_movdi_advanced,\n+    gen_movsf_advanced,\n+    gen_movdf_advanced,\n+    gen_movxf_advanced,\n+    gen_movti_advanced,\n+    gen_zero_extendqidi2_advanced,\n+    gen_zero_extendhidi2_advanced,\n+    gen_zero_extendsidi2_advanced,\n+\n+    gen_movbi_speculative,\n+    gen_movqi_speculative,\n+    gen_movhi_speculative,\n+    gen_movsi_speculative,\n+    gen_movdi_speculative,\n+    gen_movsf_speculative,\n+    gen_movdf_speculative,\n+    gen_movxf_speculative,\n+    gen_movti_speculative,\n+    gen_zero_extendqidi2_speculative,\n+    gen_zero_extendhidi2_speculative,\n+    gen_zero_extendsidi2_speculative,\n+\n+    gen_movbi_speculative_advanced,\n+    gen_movqi_speculative_advanced,\n+    gen_movhi_speculative_advanced,\n+    gen_movsi_speculative_advanced,\n+    gen_movdi_speculative_advanced,\n+    gen_movsf_speculative_advanced,\n+    gen_movdf_speculative_advanced,\n+    gen_movxf_speculative_advanced,\n+    gen_movti_speculative_advanced,\n+    gen_zero_extendqidi2_speculative_advanced,\n+    gen_zero_extendhidi2_speculative_advanced,\n+    gen_zero_extendsidi2_speculative_advanced,\n+\n+    gen_movbi_speculative_advanced,\n+    gen_movqi_speculative_advanced,\n+    gen_movhi_speculative_advanced,\n+    gen_movsi_speculative_advanced,\n+    gen_movdi_speculative_advanced,\n+    gen_movsf_speculative_advanced,\n+    gen_movdf_speculative_advanced,\n+    gen_movxf_speculative_advanced,\n+    gen_movti_speculative_advanced,\n+    gen_zero_extendqidi2_speculative_advanced,\n+    gen_zero_extendhidi2_speculative_advanced,\n+    gen_zero_extendsidi2_speculative_advanced\n+  };\n+\n+  load_no = extend_p ? mode_no + SPEC_GEN_EXTEND_OFFSET : mode_no;\n+\n+  if (ts & BEGIN_DATA)\n+    {\n+      /* We don't need recovery because even if this is ld.sa\n+\t ALAT entry will be allocated only if NAT bit is set to zero. \n+\t So it is enough to use ld.c here.  */\t  \n+\n+      if (ts & BEGIN_CONTROL)\n+\t{\t      \n+\t  load_no += SPEC_GEN_SA;\n+\n+\t  if (!mflag_sched_ldc)\n+\t    shift = SPEC_GEN_CHKA_FOR_SA_OFFSET;\n+\t}\n+      else\n+\t{\n+\t  load_no += SPEC_GEN_A;\n+\n+\t  if (!mflag_sched_ldc)\t\t\n+\t    shift = SPEC_GEN_CHKA_FOR_A_OFFSET;\n+\t}\n+    }\n+  else if (ts & BEGIN_CONTROL)\n+    {\n+      /* ld.sa can be used instead of ld.s to avoid basic block splitting.  */\n+      if (!mflag_control_ldc)\n+\tload_no += SPEC_GEN_S;\n+      else\n+\t{\n+\t  gcc_assert (mflag_sched_ldc);\n+\t  load_no += SPEC_GEN_SA_FOR_S;\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  /* Set the desired check index.  We add '1', because zero element in this\n+     array means, that instruction with such uid is non-speculative.  */\n+  spec_check_no[INSN_UID (insn)] = load_no + shift + 1;\n+\n+  if (!gen_p)\n+    return 0;\n+\n+  new_pat = gen_load[load_no] (copy_rtx (recog_data.operand[0]),\n+\t\t\t       copy_rtx (recog_data.operand[1]));\n+\n+  pat = PATTERN (insn);\n+  if (GET_CODE (pat) == COND_EXEC)\n+    new_pat = gen_rtx_COND_EXEC (VOIDmode, copy_rtx \n+\t\t\t\t (COND_EXEC_TEST (pat)), new_pat);\n+\n+  return new_pat;\n+}\n+\n+/* Offset to branchy checks.  */\n+enum { SPEC_GEN_CHECK_MUTATION_OFFSET = 5 * SPEC_N };\n+\n+/* Return nonzero, if INSN needs branchy recovery check.  */\n+static bool\n+ia64_needs_block_p (rtx insn)\n+{\n+  int check_no;\n+\n+  check_no = spec_check_no[INSN_UID(insn)] - 1;\n+  gcc_assert (0 <= check_no && check_no < SPEC_GEN_CHECK_MUTATION_OFFSET);\n+\n+  return ((SPEC_GEN_S <= check_no && check_no < SPEC_GEN_S + SPEC_N)\n+\t  || (4 * SPEC_N <= check_no && check_no < 4 * SPEC_N + SPEC_N));\n+}\n+\n+/* Generate (or regenerate, if (MUTATE_P)) recovery check for INSN.\n+   If (LABEL != 0 || MUTATE_P), generate branchy recovery check.\n+   Otherwise, generate a simple check.  */\n+static rtx\n+ia64_gen_check (rtx insn, rtx label, bool mutate_p)\n+{\n+  rtx op1, pat, check_pat;\n+\n+  static rtx (* const gen_check[]) (rtx, rtx) = {\n+    gen_movbi_clr,\n+    gen_movqi_clr,\n+    gen_movhi_clr,\n+    gen_movsi_clr,\n+    gen_movdi_clr,\n+    gen_movsf_clr,\n+    gen_movdf_clr,\n+    gen_movxf_clr,\n+    gen_movti_clr,\n+    gen_zero_extendqidi2_clr,\n+    gen_zero_extendhidi2_clr,\n+    gen_zero_extendsidi2_clr,\n+\n+    gen_speculation_check_bi,\n+    gen_speculation_check_qi,\n+    gen_speculation_check_hi,\n+    gen_speculation_check_si,\n+    gen_speculation_check_di,\n+    gen_speculation_check_sf,\n+    gen_speculation_check_df,\n+    gen_speculation_check_xf,\n+    gen_speculation_check_ti,\n+    gen_speculation_check_di,\n+    gen_speculation_check_di,\n+    gen_speculation_check_di,\n+\n+    gen_movbi_clr,\n+    gen_movqi_clr,\n+    gen_movhi_clr,\n+    gen_movsi_clr,\n+    gen_movdi_clr,\n+    gen_movsf_clr,\n+    gen_movdf_clr,\n+    gen_movxf_clr,\n+    gen_movti_clr,\n+    gen_zero_extendqidi2_clr,\n+    gen_zero_extendhidi2_clr,\n+    gen_zero_extendsidi2_clr,\n+\n+    gen_movbi_clr,\n+    gen_movqi_clr,\n+    gen_movhi_clr,\n+    gen_movsi_clr,\n+    gen_movdi_clr,\n+    gen_movsf_clr,\n+    gen_movdf_clr,\n+    gen_movxf_clr,\n+    gen_movti_clr,\n+    gen_zero_extendqidi2_clr,\n+    gen_zero_extendhidi2_clr,\n+    gen_zero_extendsidi2_clr,\n+\n+    gen_advanced_load_check_clr_bi,\n+    gen_advanced_load_check_clr_qi,\n+    gen_advanced_load_check_clr_hi,\n+    gen_advanced_load_check_clr_si,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_sf,\n+    gen_advanced_load_check_clr_df,\n+    gen_advanced_load_check_clr_xf,\n+    gen_advanced_load_check_clr_ti,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_di,\n+\n+    /* Following checks are generated during mutation.  */\n+    gen_advanced_load_check_clr_bi,\n+    gen_advanced_load_check_clr_qi,\n+    gen_advanced_load_check_clr_hi,\n+    gen_advanced_load_check_clr_si,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_sf,\n+    gen_advanced_load_check_clr_df,\n+    gen_advanced_load_check_clr_xf,\n+    gen_advanced_load_check_clr_ti,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_di,\n+\n+    0,0,0,0,0,0,0,0,0,0,0,0,\n+\n+    gen_advanced_load_check_clr_bi,\n+    gen_advanced_load_check_clr_qi,\n+    gen_advanced_load_check_clr_hi,\n+    gen_advanced_load_check_clr_si,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_sf,\n+    gen_advanced_load_check_clr_df,\n+    gen_advanced_load_check_clr_xf,\n+    gen_advanced_load_check_clr_ti,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_di,\n+    gen_advanced_load_check_clr_di,\n+\n+    gen_speculation_check_bi,\n+    gen_speculation_check_qi,\n+    gen_speculation_check_hi,\n+    gen_speculation_check_si,\n+    gen_speculation_check_di,\n+    gen_speculation_check_sf,\n+    gen_speculation_check_df,\n+    gen_speculation_check_xf,\n+    gen_speculation_check_ti,\n+    gen_speculation_check_di,\n+    gen_speculation_check_di,\n+    gen_speculation_check_di\n+  };\n+\n+  extract_insn_cached (insn);\n+\n+  if (label)\n+    {\n+      gcc_assert (mutate_p || ia64_needs_block_p (insn));\n+      op1 = label;\n+    }\n+  else\n+    {\n+      gcc_assert (!mutate_p && !ia64_needs_block_p (insn));\n+      op1 = copy_rtx (recog_data.operand[1]);\n+    }\n+      \n+  if (mutate_p)\n+    /* INSN is ld.c.\n+       Find the speculation check number by searching for original\n+       speculative load in the RESOLVED_DEPS list of INSN.\n+       As long as patterns are unique for each instruction, this can be\n+       accomplished by matching ORIG_PAT fields.  */\n+    {\n+      rtx link;\n+      int check_no = 0;\n+      rtx orig_pat = ORIG_PAT (insn);\n+\n+      for (link = RESOLVED_DEPS (insn); link; link = XEXP (link, 1))\n+\t{\n+\t  rtx x = XEXP (link, 0);\n+\n+\t  if (ORIG_PAT (x) == orig_pat)\n+\t    check_no = spec_check_no[INSN_UID (x)];\n+\t}\n+      gcc_assert (check_no);\n+\n+      spec_check_no[INSN_UID (insn)] = (check_no\n+\t\t\t\t\t+ SPEC_GEN_CHECK_MUTATION_OFFSET);\n+    }\n+\n+  check_pat = (gen_check[spec_check_no[INSN_UID (insn)] - 1]\n+\t       (copy_rtx (recog_data.operand[0]), op1));\n+    \n+  pat = PATTERN (insn);\n+  if (GET_CODE (pat) == COND_EXEC)\n+    check_pat = gen_rtx_COND_EXEC (VOIDmode, copy_rtx (COND_EXEC_TEST (pat)),\n+\t\t\t\t   check_pat);\n+\n+  return check_pat;\n+}\n+\n+/* Return nonzero, if X is branchy recovery check.  */\n+static int\n+ia64_spec_check_p (rtx x)\n+{\n+  x = PATTERN (x);\n+  if (GET_CODE (x) == COND_EXEC)\n+    x = COND_EXEC_CODE (x);\n+  if (GET_CODE (x) == SET)\n+    return ia64_spec_check_src_p (SET_SRC (x));\n+  return 0;\n+}\n+\n+/* Return nonzero, if SRC belongs to recovery check.  */\n+static int\n+ia64_spec_check_src_p (rtx src)\n+{\n+  if (GET_CODE (src) == IF_THEN_ELSE)\n+    {\n+      rtx t;\n+\n+      t = XEXP (src, 0);\n+      if (GET_CODE (t) == NE)\n+\t{\n+\t  t = XEXP (t, 0);\t    \n+\n+\t  if (GET_CODE (t) == UNSPEC)\n+\t    {\n+\t      int code;\n+\t      \n+\t      code = XINT (t, 1);\n+\t     \n+\t      if (code == UNSPEC_CHKACLR\n+\t\t  || code == UNSPEC_CHKS\n+\t\t  || code == UNSPEC_LDCCLR)\n+\t\t{\n+\t\t  gcc_assert (code != 0);\n+\t\t  return code;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n \f\n \n /* The following page contains abstract data `bundle states' which are\n@@ -6996,7 +7679,7 @@ get_next_important_insn (rtx insn, rtx tail)\n    automata only says that we can issue an insn possibly inserting\n    some nops before it and using some template.  Therefore insn\n    bundling in this function is implemented by using DFA\n-   (deterministic finite automata).  We follows all possible insn\n+   (deterministic finite automata).  We follow all possible insn\n    sequences by inserting 0-2 nops (that is what the NDFA describe for\n    insn scheduling) before/after each insn being bundled.  We know the\n    start of simulated processor cycle from insn scheduling (insn\n@@ -7086,7 +7769,7 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t      break;\n \t    }\n       }\n-  /* Froward pass: generation of bundle states.  */\n+  /* Forward pass: generation of bundle states.  */\n   for (insn = get_next_important_insn (NEXT_INSN (prev_head_insn), tail);\n        insn != NULL_RTX;\n        insn = next_insn)\n@@ -7619,11 +8302,27 @@ ia64_ld_address_bypass_p (rtx producer, rtx consumer)\n   gcc_assert (src);\n   mem = SET_SRC (src);\n   gcc_assert (mem);\n+ \n   if (GET_CODE (mem) == UNSPEC && XVECLEN (mem, 0) > 0)\n     mem = XVECEXP (mem, 0, 0);\n+  else if (GET_CODE (mem) == IF_THEN_ELSE)\n+    /* ??? Is this bypass neccessary for ld.c?  */\n+    {\n+      gcc_assert (XINT (XEXP (XEXP (mem, 0), 0), 1) == UNSPEC_LDCCLR);\n+      mem = XEXP (mem, 1);\n+    }\n+     \n   while (GET_CODE (mem) == SUBREG || GET_CODE (mem) == ZERO_EXTEND)\n     mem = XEXP (mem, 0);\n \n+  if (GET_CODE (mem) == UNSPEC)\n+    {\n+      int c = XINT (mem, 1);\n+\n+      gcc_assert (c == UNSPEC_LDA || c == UNSPEC_LDS || c == UNSPEC_LDSA);\n+      mem = XVECEXP (mem, 0, 0);\n+    }\n+\n   /* Note that LO_SUM is used for GOT loads.  */\n   gcc_assert (GET_CODE (mem) == LO_SUM || GET_CODE (mem) == MEM);\n \n@@ -7804,6 +8503,7 @@ ia64_reorg (void)\n \t  free (clocks);\n \t}\n       free (stops_p);\n+      stops_p = NULL;\n       emit_insn_group_barriers (dump_file);\n \n       ia64_final_schedule = 0;"}, {"sha": "f25ad76be16e570eb74eb759c173ab361ca0f256", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 203, "deletions": 5, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=048d0d36c2021df68c27dcc308f8f0717f0537bf", "patch": "@@ -81,6 +81,12 @@\n    (UNSPEC_SHRP\t\t\t29)\n    (UNSPEC_COPYSIGN\t\t30)\n    (UNSPEC_VECT_EXTR\t\t31)\n+   (UNSPEC_LDA                  40)\n+   (UNSPEC_LDS                  41)\n+   (UNSPEC_LDSA                 42)\n+   (UNSPEC_LDCCLR               43)\n+   (UNSPEC_CHKACLR              45)\n+   (UNSPEC_CHKS                 47)\t\n   ])\n \n (define_constants\n@@ -124,18 +130,19 @@\n \n (define_attr \"itanium_class\" \"unknown,ignore,stop_bit,br,fcmp,fcvtfx,fld,\n \tfldp,fmac,fmisc,frar_i,frar_m,frbr,frfr,frpr,ialu,icmp,ilog,ishf,\n-\tld,chk_s,long_i,mmalua,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,\n+\tld,chk_s_i,chk_s_f,chk_a,long_i,mmalua,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,\n         st,syst_m0, syst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop,\n         nop_b,nop_f,nop_i,nop_m,nop_x,lfetch,pre_cycle\"\n   (const_string \"unknown\"))\n \n-;; chk_s has an I and an M form; use type A for convenience.\n+;; chk_s_i has an I and an M form; use type A for convenience.\n (define_attr \"type\" \"unknown,A,I,M,F,B,L,X,S\"\n   (cond [(eq_attr \"itanium_class\" \"ld,st,fld,fldp,stf,sem,nop_m\") (const_string \"M\")\n \t (eq_attr \"itanium_class\" \"rse_m,syst_m,syst_m0\") (const_string \"M\")\n \t (eq_attr \"itanium_class\" \"frar_m,toar_m,frfr,tofr\") (const_string \"M\")\n \t (eq_attr \"itanium_class\" \"lfetch\") (const_string \"M\")\n-\t (eq_attr \"itanium_class\" \"chk_s,ialu,icmp,ilog,mmalua\")\n+         (eq_attr \"itanium_class\" \"chk_s_f,chk_a\") (const_string \"M\")\n+\t (eq_attr \"itanium_class\" \"chk_s_i,ialu,icmp,ilog,mmalua\")\n \t   (const_string \"A\")\n \t (eq_attr \"itanium_class\" \"fmisc,fmac,fcmp,xmpy\") (const_string \"F\")\n \t (eq_attr \"itanium_class\" \"fcvtfx,nop_f\") (const_string \"F\")\n@@ -170,6 +177,12 @@\n ;; when we have full intrinsics support.\n \n (define_attr \"first_insn\" \"no,yes\" (const_string \"no\"))\n+\n+(define_attr \"data_speculative\" \"no,yes\" (const_string \"no\"))\n+\n+(define_attr \"control_speculative\" \"no,yes\" (const_string \"no\"))\n+\n+(define_attr \"check_load\" \"no,yes\" (const_string \"no\"))\n \f\n ;; DFA descriptions of ia64 processors used for insn scheduling and\n ;; bundling.\n@@ -372,6 +385,191 @@\n }\n   [(set_attr \"itanium_class\" \"ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,fld,stf,frbr,tobr,frar_i,toar_i,frar_m,toar_m,frpr,topr\")])\n \n+(define_mode_macro MODE [BI QI HI SI DI SF DF XF TI])\n+(define_mode_macro MODE_FOR_EXTEND [QI HI SI])\n+\n+(define_mode_attr output_a [\n+  (BI \"ld1.a %0 = %1%P1\")\n+  (QI \"ld1.a %0 = %1%P1\")\n+  (HI \"ld2.a %0 = %1%P1\")\n+  (SI \"ld4.a %0 = %1%P1\")\n+  (DI\n+   \"@\n+    ld8.a %0 = %1%P1\n+    ldf8.a %0 = %1%P1\")\n+  (SF\n+   \"@\n+    ldfs.a %0 = %1%P1\n+    ld4.a %0 = %1%P1\")\n+  (DF\n+   \"@\n+    ldfd.a %0 = %1%P1\n+    ld8.a %0 = %1%P1\")\n+  (XF \"ldfe.a %0 = %1%P1\")\n+  (TI \"ldfp8.a %X0 = %1%P1\")])\n+\n+(define_mode_attr output_s [\n+  (BI \"ld1.s %0 = %1%P1\")\n+  (QI \"ld1.s %0 = %1%P1\")\n+  (HI \"ld2.s %0 = %1%P1\")\n+  (SI \"ld4.s %0 = %1%P1\")\n+  (DI\n+   \"@\n+    ld8.s %0 = %1%P1\n+    ldf8.s %0 = %1%P1\")\n+  (SF\n+   \"@\n+    ldfs.s %0 = %1%P1\n+    ld4.s %0 = %1%P1\")\n+  (DF\n+   \"@\n+    ldfd.s %0 = %1%P1\n+    ld8.s %0 = %1%P1\")\n+  (XF \"ldfe.s %0 = %1%P1\")\n+  (TI \"ldfp8.s %X0 = %1%P1\")])\n+\n+(define_mode_attr output_sa [\n+  (BI \"ld1.sa %0 = %1%P1\")\n+  (QI \"ld1.sa %0 = %1%P1\")\n+  (HI \"ld2.sa %0 = %1%P1\")\n+  (SI \"ld4.sa %0 = %1%P1\")\n+  (DI\n+   \"@\n+    ld8.sa %0 = %1%P1\n+    ldf8.sa %0 = %1%P1\")\n+  (SF\n+   \"@\n+    ldfs.sa %0 = %1%P1\n+    ld4.sa %0 = %1%P1\")\n+  (DF\n+   \"@\n+    ldfd.sa %0 = %1%P1\n+    ld8.sa %0 = %1%P1\")\n+  (XF \"ldfe.sa %0 = %1%P1\")\n+  (TI \"ldfp8.sa %X0 = %1%P1\")])\n+\n+(define_mode_attr output_c_clr [\n+  (BI \"ld1.c.clr%O1 %0 = %1%P1\")\n+  (QI \"ld1.c.clr%O1 %0 = %1%P1\")\n+  (HI \"ld2.c.clr%O1 %0 = %1%P1\")\n+  (SI \"ld4.c.clr%O1 %0 = %1%P1\")\n+  (DI\n+   \"@\n+    ld8.c.clr%O1 %0 = %1%P1\n+    ldf8.c.clr %0 = %1%P1\")\n+  (SF\n+   \"@\n+    ldfs.c.clr %0 = %1%P1\n+    ld4.c.clr%O1 %0 = %1%P1\")\n+  (DF\n+   \"@\n+    ldfd.c.clr %0 = %1%P1\n+    ld8.c.clr%O1 %0 = %1%P1\")\n+  (XF \"ldfe.c.clr %0 = %1%P1\")\n+  (TI \"ldfp8.c.clr %X0 = %1%P1\")])\n+\n+(define_mode_attr ld_reg_constr [(BI \"=*r\") (QI \"=r\") (HI \"=r\") (SI \"=r\") (DI \"=r,*f\") (SF \"=f,*r\") (DF \"=f,*r\") (XF \"=f\") (TI \"=*x\")])\n+(define_mode_attr ldc_reg_constr [(BI \"+*r\") (QI \"+r\") (HI \"+r\") (SI \"+r\") (DI \"+r,*f\") (SF \"+f,*r\") (DF \"+f,*r\") (XF \"+f\") (TI \"+*x\")])\n+(define_mode_attr chk_reg_constr [(BI \"*r\") (QI \"r\") (HI \"r\") (SI \"r\") (DI \"r,*f\") (SF \"f,*r\") (DF \"f,*r\") (XF \"f\") (TI \"*x\")])\n+\n+(define_mode_attr mem_constr [(BI \"*m\") (QI \"m\") (HI \"m\") (SI \"m\") (DI \"m,Q\") (SF \"Q,m\") (DF \"Q,m\") (XF \"m\") (TI \"Q\")])\n+\n+(define_mode_attr reg_pred_prefix [(BI \"gr\") (QI \"gr\") (HI \"gr\") (SI \"gr\") (DI \"grfr\") (SF \"grfr\") (DF \"grfr\") (XF \"fr\") (TI \"fr\")])\n+\n+(define_mode_attr ld_class [(BI \"ld\") (QI \"ld\") (HI \"ld\") (SI \"ld\") (DI \"ld,fld\") (SF \"fld,ld\") (DF \"fld,ld\") (XF \"fld\") (TI \"fldp\")])\n+(define_mode_attr chka_class [(BI \"chk_a\") (QI \"chk_a\") (HI \"chk_a\") (SI \"chk_a\") (DI \"chk_a,chk_a\") (SF \"chk_a,chk_a\") (DF \"chk_a,chk_a\") (XF \"chk_a\") (TI \"chk_a\")])\n+(define_mode_attr chks_class [(BI \"chk_s_i\") (QI \"chk_s_i\") (HI \"chk_s_i\") (SI \"chk_s_i\") (DI \"chk_s_i,chk_s_f\") (SF \"chk_s_f,chk_s_i\") (DF \"chk_s_f,chk_s_i\") (XF \"chk_s_f\") (TI \"chk_s_i\")])\n+\n+(define_mode_attr attr_yes [(BI \"yes\") (QI \"yes\") (HI \"yes\") (SI \"yes\") (DI \"yes,yes\") (SF \"yes,yes\") (DF \"yes,yes\") (XF \"yes\") (TI \"yes\")])\n+\n+(define_insn \"mov<mode>_advanced\"\n+  [(set (match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<ld_reg_constr>\")\n+\t(unspec:MODE [(match_operand:MODE 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDA))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"<output_a>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"data_speculative\" \"<attr_yes>\")])\n+\n+(define_insn \"zero_extend<mode>di2_advanced\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+\t(zero_extend:DI (unspec:MODE_FOR_EXTEND [(match_operand:MODE_FOR_EXTEND 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDA)))]\n+  \"\"\n+  \"<output_a>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"data_speculative\" \"<attr_yes>\")])\n+\n+(define_insn \"mov<mode>_speculative\"\n+  [(set (match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<ld_reg_constr>\")\n+\t(unspec:MODE [(match_operand:MODE 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDS))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"<output_s>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"control_speculative\" \"<attr_yes>\")])\n+\n+(define_insn \"zero_extend<mode>di2_speculative\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+\t(zero_extend:DI (unspec:MODE_FOR_EXTEND [(match_operand:MODE_FOR_EXTEND 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDS)))]\n+  \"\"\n+  \"<output_s>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"control_speculative\" \"<attr_yes>\")])\n+\n+(define_insn \"mov<mode>_speculative_advanced\"\n+  [(set (match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<ld_reg_constr>\")\n+\t(unspec:MODE [(match_operand:MODE 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDSA))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"<output_sa>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"data_speculative\" \"<attr_yes>\")\n+   (set_attr \"control_speculative\" \"<attr_yes>\")])\n+\n+(define_insn \"zero_extend<mode>di2_speculative_advanced\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+\t(zero_extend:DI (unspec:MODE_FOR_EXTEND [(match_operand:MODE_FOR_EXTEND 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDSA)))]\n+  \"\"\n+  \"<output_sa>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"data_speculative\" \"<attr_yes>\")\n+   (set_attr \"control_speculative\" \"<attr_yes>\")])\n+\n+(define_insn \"mov<mode>_clr\"\n+  [(set (match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<ldc_reg_constr>\")\n+\t(if_then_else:MODE (ne (unspec [(match_dup 0)] UNSPEC_LDCCLR) (const_int 0))\n+\t\t\t   (match_operand:MODE 1 \"memory_operand\" \"<mem_constr>\")\n+\t\t\t   (match_dup 0)))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"<output_c_clr>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"check_load\" \"<attr_yes>\")])\n+\n+(define_insn \"zero_extend<mode>di2_clr\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"+r\")\n+\t(if_then_else:DI (ne (unspec [(match_dup 0)] UNSPEC_LDCCLR) (const_int 0))\n+\t\t\t (zero_extend:DI (match_operand:MODE_FOR_EXTEND 1 \"memory_operand\" \"<mem_constr>\"))\n+\t\t\t (match_dup 0)))]\n+  \"\"\n+  \"<output_c_clr>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"check_load\" \"<attr_yes>\")])\n+\n+(define_insn \"advanced_load_check_clr_<mode>\"\n+  [(set (pc)\n+        (if_then_else (ne (unspec [(match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<chk_reg_constr>\")] UNSPEC_CHKACLR) (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"chk.a.clr %0, %l1\"\n+  [(set_attr \"itanium_class\" \"<chka_class>\")])\n+\n+(define_insn \"speculation_check_<mode>\"\n+  [(set (pc) \n+        (if_then_else (ne (unspec [(match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<chk_reg_constr>\")] UNSPEC_CHKS) (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"chk.s %0, %l1\"\n+  [(set_attr \"itanium_class\" \"<chks_class>\")])\n+\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(match_operand 1 \"symbolic_operand\" \"\"))]\n@@ -6114,7 +6312,7 @@\n   [(trap_if (const_int 1) (match_operand 0 \"const_int_operand\" \"\"))]\n   \"\"\n   \"break %0\"\n-  [(set_attr \"itanium_class\" \"chk_s\")])\n+  [(set_attr \"itanium_class\" \"chk_s_i\")])\n \n (define_expand \"conditional_trap\"\n   [(trap_if (match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\"))]\n@@ -6130,7 +6328,7 @@\n \t    (match_operand 2 \"const_int_operand\" \"\"))]\n   \"\"\n   \"(%J0) break %2\"\n-  [(set_attr \"itanium_class\" \"chk_s\")\n+  [(set_attr \"itanium_class\" \"chk_s_i\")\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"break_f\""}, {"sha": "1166020b0b6052d6e128a83223ce3d5c9967d358", "filename": "gcc/config/ia64/ia64.opt", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fia64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fia64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.opt?ref=048d0d36c2021df68c27dcc308f8f0717f0537bf", "patch": "@@ -96,3 +96,50 @@ mtune=\n Target RejectNegative Joined\n Schedule code for given CPU\n \n+msched-br-data-spec\n+Target Report Var(mflag_sched_br_data_spec) Init(0)\n+Use data speculation before reload\n+\n+msched-ar-data-spec\n+Target Report Var(mflag_sched_ar_data_spec) Init(1)\n+Use data speculation after reload\n+\n+msched-control-spec\n+Target Report Var(mflag_sched_control_spec) Init(0)\n+Use control speculation\n+\n+msched-br-in-data-spec\n+Target Report Var(mflag_sched_br_in_data_spec) Init(1)\n+Use in block data speculation before reload\n+\n+msched-ar-in-data-spec\n+Target Report Var(mflag_sched_ar_in_data_spec) Init(1)\n+Use in block data speculation after reload\n+\n+msched-in-control-spec\n+Target Report Var(mflag_sched_in_control_spec) Init(1)\n+Use in block control speculation\n+\n+msched-ldc\n+Target Report Var(mflag_sched_ldc) Init(1)\n+Use simple data speculation check\n+\n+msched-control-ldc\n+Target Report Var(mflag_control_ldc) Init(0)\n+Use simple data speculation check for control speculation\n+\n+msched-spec-verbose\n+Common Report Var(mflag_sched_spec_verbose) Init(0)\n+Print information about speculative motions.\n+\n+msched-prefer-non-data-spec-insns\n+Common Report Var(mflag_sched_prefer_non_data_spec_insns) Init(0)\n+If set, data speculative instructions will be choosen for schedule only if there are no other choices at the moment \n+\n+msched-prefer-non-control-spec-insns\n+Common Report Var(mflag_sched_prefer_non_control_spec_insns) Init(0)\n+If set, control speculative instructions will be choosen for schedule only if there are no other choices at the moment \n+\n+msched-count-spec-in-critical-path\n+Common Report Var(mflag_sched_count_spec_in_critical_path) Init(0)\n+Count speculative dependencies while calculating priority of instructions"}, {"sha": "f9b7f91a9cd432f7e88dc407f2a752f1d4bed48f", "filename": "gcc/config/ia64/itanium1.md", "status": "modified", "additions": 88, "deletions": 25, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fitanium1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fitanium1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium1.md?ref=048d0d36c2021df68c27dcc308f8f0717f0537bf", "patch": "@@ -525,14 +525,29 @@\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"fcvtfx\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_F\")\n+\n (define_insn_reservation \"1_fld\"     9\n-  (and (and (eq_attr \"cpu\" \"itanium\")\n-            (eq_attr \"itanium_class\" \"fld\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"fld\"))\n+\t    (eq_attr \"check_load\" \"no\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_fldc\"    0\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"fld\"))\n+\t    (eq_attr \"check_load\" \"yes\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+\n (define_insn_reservation \"1_fldp\"    9\n-  (and (and (eq_attr \"cpu\" \"itanium\")\n-            (eq_attr \"itanium_class\" \"fldp\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"fldp\"))\n+\t    (eq_attr \"check_load\" \"no\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_fldpc\"   0\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"fldp\"))\n+\t    (eq_attr \"check_load\" \"yes\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+\n (define_insn_reservation \"1_fmac\"    5\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"fmac\"))\n@@ -604,8 +619,14 @@\n        (eq (symbol_ref \"bundling_p\") (const_int 0)))\n     \"1_I+1_not_ui1\")\n (define_insn_reservation \"1_ld\"      2\n-  (and (and (eq_attr \"cpu\" \"itanium\")\n-            (eq_attr \"itanium_class\" \"ld\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"ld\"))\n+\t    (eq_attr \"check_load\" \"no\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_ldc\"     0\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"ld\"))\n+\t    (eq_attr \"check_load\" \"yes\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n (define_insn_reservation \"1_long_i\"  1\n   (and (and (eq_attr \"cpu\" \"itanium\")\n@@ -696,10 +717,19 @@\n             (eq_attr \"itanium_class\" \"xtd\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_I\")\n \n-(define_insn_reservation \"1_chk_s\"   0\n+(define_insn_reservation \"1_chk_s_i\" 0\n   (and (and (eq_attr \"cpu\" \"itanium\")\n-            (eq_attr \"itanium_class\" \"chk_s\"))\n+            (eq_attr \"itanium_class\" \"chk_s_i\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_A\")\n+(define_insn_reservation \"1_chk_s_f\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"chk_s_f\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_chk_a\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"chk_a\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+\n (define_insn_reservation \"1_lfetch\"  0\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"lfetch\"))\n@@ -943,15 +973,15 @@\n (define_bypass  2 \"1_ilog,1_xtd\" \"1_ld\"  \"ia64_ld_address_bypass_p\")\n (define_bypass  2 \"1_ilog,1_xtd\" \"1_st\"  \"ia64_st_address_bypass_p\")\n \n-(define_bypass  3 \"1_ld\" \"1_mmmul,1_mmshf\")\n+(define_bypass  3 \"1_ld,1_ldc\" \"1_mmmul,1_mmshf\")\n (define_bypass  3 \"1_ld\" \"1_ld\"  \"ia64_ld_address_bypass_p\")\n (define_bypass  3 \"1_ld\" \"1_st\"  \"ia64_st_address_bypass_p\")\n \n ;; Intel docs say only LD, ST, IALU, ILOG, ISHF consumers have latency 4,\n ;;      but HP engineers say any non-MM operation.\n (define_bypass  4 \"1_mmmul,1_mmshf,1_mmalua\"\n-     \"1_br,1_fcmp,1_fcvtfx,1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,\\\n-      1_frbr,1_frfr,1_frpr,1_ialu,1_icmp,1_ilog,1_ishf,1_ld,1_chk_s,\\\n+     \"1_br,1_fcmp,1_fcvtfx,1_fld,1_fldc,1_fmac,1_fmisc,1_frar_i,1_frar_m,\\\n+      1_frbr,1_frfr,1_frpr,1_ialu,1_icmp,1_ilog,1_ishf,1_ld,1_ldc,1_chk_s_i,1_chk_s_f,1_chk_a,\\\n       1_long_i,1_rse_m,1_sem,1_stf,1_st,1_syst_m0,1_syst_m,\\\n       1_tbit,1_toar_i,1_toar_m,1_tobr,1_tofr,1_topr,1_xmpy,1_xtd\")\n \n@@ -965,15 +995,15 @@\n (define_bypass  8 \"1_fmisc,1_fcvtfx,1_fmac,1_xmpy\"  \"1_stf\")\n \n ;; We don't use here fcmp because scall may be predicated.\n-(define_bypass  0 \"1_fcvtfx,1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,\\\n+(define_bypass  0 \"1_fcvtfx,1_fld,1_fldc,1_fmac,1_fmisc,1_frar_i,1_frar_m,\\\n                    1_frbr,1_frfr,1_frpr,1_ialu,1_ialu_addr,1_ilog,1_ishf,\\\n-\t           1_ld,1_long_i,1_mmalua,1_mmmul,1_mmshf,1_mmshfi,1_toar_m,\\\n-\t\t   1_tofr,1_xmpy,1_xtd\" \"1_scall\")\n+\t           1_ld,1_ldc,1_long_i,1_mmalua,1_mmmul,1_mmshf,1_mmshfi,\\\n+                   1_toar_m,1_tofr,1_xmpy,1_xtd\" \"1_scall\")\n \n (define_bypass  0 \"1_unknown,1_ignore,1_stop_bit,1_br,1_fcmp,1_fcvtfx,\\\n-                   1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,1_frbr,1_frfr,\\\n-                   1_frpr,1_ialu,1_ialu_addr,1_icmp,1_ilog,1_ishf,1_ld,\\\n-                   1_chk_s,1_long_i,1_mmalua,1_mmmul,1_mmshf,1_mmshfi,1_nop,\\\n+                   1_fld,1_fldc,1_fmac,1_fmisc,1_frar_i,1_frar_m,1_frbr,1_frfr,\\\n+                   1_frpr,1_ialu,1_ialu_addr,1_icmp,1_ilog,1_ishf,1_ld,1_ldc,\\\n+                   1_chk_s_i,1_chk_s_f,1_chk_a,1_long_i,1_mmalua,1_mmmul,1_mmshf,1_mmshfi,1_nop,\\\n                    1_nop_b,1_nop_f,1_nop_i,1_nop_m,1_nop_x,1_rse_m,1_scall,\\\n                    1_sem,1_stf,1_st,1_syst_m0,1_syst_m,1_tbit,1_toar_i,\\\n                    1_toar_m,1_tobr,1_tofr,1_topr,1_xmpy,1_xtd,1_lfetch\"\n@@ -1407,14 +1437,29 @@\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"fcvtfx\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_F\")\n+\n (define_insn_reservation \"1b_fld\"     9\n-  (and (and (eq_attr \"cpu\" \"itanium\")\n-            (eq_attr \"itanium_class\" \"fld\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"fld\"))\n+\t    (eq_attr \"check_load\" \"no\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_fldc\"    0\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"fld\"))\n+\t    (eq_attr \"check_load\" \"yes\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+\n (define_insn_reservation \"1b_fldp\"    9\n-  (and (and (eq_attr \"cpu\" \"itanium\")\n-            (eq_attr \"itanium_class\" \"fldp\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"fldp\"))\n+\t    (eq_attr \"check_load\" \"no\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_fldpc\"   0\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"fldp\"))\n+\t    (eq_attr \"check_load\" \"yes\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+\n (define_insn_reservation \"1b_fmac\"    5\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"fmac\"))\n@@ -1480,10 +1525,18 @@\n             (eq_attr \"itanium_class\" \"ishf\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0)))\n   \"1b_I+1b_not_ui1\")\n+\n (define_insn_reservation \"1b_ld\"      2\n-  (and (and (eq_attr \"cpu\" \"itanium\")\n-            (eq_attr \"itanium_class\" \"ld\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"ld\"))\n+\t    (eq_attr \"check_load\" \"no\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_ldc\"     0\n+  (and (and (and (eq_attr \"cpu\" \"itanium\")\n+\t\t (eq_attr \"itanium_class\" \"ld\"))\n+\t    (eq_attr \"check_load\" \"yes\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+\n (define_insn_reservation \"1b_long_i\"  1\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"long_i\"))\n@@ -1566,10 +1619,20 @@\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"xtd\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_I\")\n-(define_insn_reservation \"1b_chk_s\"   0\n+\n+(define_insn_reservation \"1b_chk_s_i\" 0\n   (and (and (eq_attr \"cpu\" \"itanium\")\n-            (eq_attr \"itanium_class\" \"chk_s\"))\n+            (eq_attr \"itanium_class\" \"chk_s_i\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_A\")\n+(define_insn_reservation \"1b_chk_s_f\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"chk_s_f\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_chk_a\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"chk_a\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+\n (define_insn_reservation \"1b_lfetch\"  0\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"lfetch\"))"}, {"sha": "a10971df7ded899c2e98791b74ff7704dd854153", "filename": "gcc/config/ia64/itanium2.md", "status": "modified", "additions": 111, "deletions": 23, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fitanium2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fconfig%2Fia64%2Fitanium2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium2.md?ref=048d0d36c2021df68c27dcc308f8f0717f0537bf", "patch": "@@ -731,14 +731,38 @@\n             (eq_attr \"itanium_class\" \"fcvtfx\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_F\")\n (define_insn_reservation \"2_fld\"     6\n-  (and (and (eq_attr \"cpu\" \"itanium2\")\n-            (eq_attr \"itanium_class\" \"fld\"))\n-       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_M\")\n+  (and (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                      (eq_attr \"itanium_class\" \"fld\"))\n+                 (eq_attr \"data_speculative\" \"no\"))\n+            (eq_attr \"check_load\" \"no\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M\")\n+(define_insn_reservation \"2_flda\"    6\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                 (eq_attr \"itanium_class\" \"fld\"))\n+            (eq_attr \"data_speculative\" \"yes\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um01\")\n+(define_insn_reservation \"2_fldc\"    0\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                 (eq_attr \"itanium_class\" \"fld\"))\n+            (eq_attr \"check_load\" \"yes\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um01\")\n+\n (define_insn_reservation \"2_fldp\"    6\n-  (and (and (eq_attr \"cpu\" \"itanium2\")\n-            (eq_attr \"itanium_class\" \"fldp\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+\t\t (eq_attr \"itanium_class\" \"fldp\"))\n+\t    (eq_attr \"check_load\" \"no\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um01\")\n+(define_insn_reservation \"2_fldpc\"   0\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+\t\t (eq_attr \"itanium_class\" \"fldp\"))\n+\t    (eq_attr \"check_load\" \"yes\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0)))\n   \"2_M_only_um01\")\n+\n (define_insn_reservation \"2_fmac\"    4\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"fmac\"))\n@@ -801,11 +825,19 @@\n             (eq_attr \"itanium_class\" \"ishf\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0)))\n   \"2_I+2_only_ui0\")\n+\n (define_insn_reservation \"2_ld\"      1\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                 (eq_attr \"itanium_class\" \"ld\"))\n+            (eq_attr \"check_load\" \"no\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um01\")\n+(define_insn_reservation \"2_ldc\"     0\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n-            (eq_attr \"itanium_class\" \"ld\"))\n+            (eq_attr \"check_load\" \"yes\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0)))\n   \"2_M_only_um01\")\n+\n (define_insn_reservation \"2_long_i\"  1\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"long_i\"))\n@@ -909,11 +941,22 @@\n             (eq_attr \"itanium_class\" \"xtd\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_I\")\n \n-(define_insn_reservation \"2_chk_s\"   0\n+(define_insn_reservation \"2_chk_s_i\" 0\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n-            (eq_attr \"itanium_class\" \"chk_s\"))\n+            (eq_attr \"itanium_class\" \"chk_s_i\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0)))\n   \"2_I|2_M_only_um23\")\n+(define_insn_reservation \"2_chk_s_f\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"chk_s_f\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um23\")\n+(define_insn_reservation \"2_chk_a\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"chk_a\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um01\")\n+\n (define_insn_reservation \"2_lfetch\"  0\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"lfetch\"))\n@@ -1025,23 +1068,23 @@\n (define_bypass  0 \"2_tbit\" \"2_br,2_scall\")\n (define_bypass  2 \"2_ld\" \"2_ld\"  \"ia64_ld_address_bypass_p\")\n (define_bypass  2 \"2_ld\" \"2_st\"  \"ia64_st_address_bypass_p\")\n-(define_bypass  2 \"2_ld\" \"2_mmalua,2_mmmul,2_mmshf\")\n+(define_bypass  2 \"2_ld,2_ldc\" \"2_mmalua,2_mmmul,2_mmshf\")\n (define_bypass  3 \"2_ilog\" \"2_mmalua,2_mmmul,2_mmshf\")\n (define_bypass  3 \"2_ialu\" \"2_mmalua,2_mmmul,2_mmshf\")\n-(define_bypass  3 \"2_mmalua,2_mmmul,2_mmshf\" \"2_ialu,2_ilog,2_ishf,2_st,2_ld\")\n+(define_bypass  3 \"2_mmalua,2_mmmul,2_mmshf\" \"2_ialu,2_ilog,2_ishf,2_st,2_ld,2_ldc\")\n (define_bypass  6 \"2_tofr\"  \"2_frfr,2_stf\")\n (define_bypass  7 \"2_fmac\"  \"2_frfr,2_stf\")\n \n ;; We don't use here fcmp because scall may be predicated.\n-(define_bypass  0 \"2_fcvtfx,2_fld,2_fmac,2_fmisc,2_frar_i,2_frar_m,\\\n-                   2_frbr,2_frfr,2_frpr,2_ialu,2_ilog,2_ishf,2_ld,2_long_i,\\\n+(define_bypass  0 \"2_fcvtfx,2_fld,2_flda,2_fldc,2_fmac,2_fmisc,2_frar_i,2_frar_m,\\\n+                   2_frbr,2_frfr,2_frpr,2_ialu,2_ilog,2_ishf,2_ld,2_ldc,2_long_i,\\\n                    2_mmalua,2_mmmul,2_mmshf,2_mmshfi,2_toar_m,2_tofr,\\\n \t\t   2_xmpy,2_xtd\"\n                   \"2_scall\")\n \n-(define_bypass  0 \"2_unknown,2_ignore,2_stop_bit,2_br,2_fcmp,2_fcvtfx,2_fld,\\\n+(define_bypass  0 \"2_unknown,2_ignore,2_stop_bit,2_br,2_fcmp,2_fcvtfx,2_fld,2_flda,2_fldc,\\\n                    2_fmac,2_fmisc,2_frar_i,2_frar_m,2_frbr,2_frfr,2_frpr,\\\n-                   2_ialu,2_icmp,2_ilog,2_ishf,2_ld,2_chk_s,2_long_i,\\\n+                   2_ialu,2_icmp,2_ilog,2_ishf,2_ld,2_ldc,2_chk_s_i,2_chk_s_f,2_chk_a,2_long_i,\\\n \t\t   2_mmalua,2_mmmul,2_mmshf,2_mmshfi,2_nop,2_nop_b,2_nop_f,\\\n                    2_nop_i,2_nop_m,2_nop_x,2_rse_m,2_scall,2_sem,2_stf,2_st,\\\n                    2_syst_m0,2_syst_m,2_tbit,2_toar_i,2_toar_m,2_tobr,2_tofr,\\\n@@ -1543,14 +1586,38 @@\n             (eq_attr \"itanium_class\" \"fcvtfx\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_F\")\n (define_insn_reservation \"2b_fld\"     6\n-  (and (and (eq_attr \"cpu\" \"itanium2\")\n-            (eq_attr \"itanium_class\" \"fld\"))\n-       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_M\")\n+  (and (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                      (eq_attr \"itanium_class\" \"fld\"))\n+                 (eq_attr \"data_speculative\" \"no\"))\n+            (eq_attr \"check_load\" \"no\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M\")\n+(define_insn_reservation \"2b_flda\"    6\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                 (eq_attr \"itanium_class\" \"fld\"))\n+            (eq_attr \"data_speculative\" \"yes\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um01\")\n+(define_insn_reservation \"2b_fldc\"    0\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                 (eq_attr \"itanium_class\" \"fld\"))\n+            (eq_attr \"check_load\" \"yes\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um01\")\n+\n (define_insn_reservation \"2b_fldp\"    6\n-  (and (and (eq_attr \"cpu\" \"itanium2\")\n-            (eq_attr \"itanium_class\" \"fldp\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+\t\t (eq_attr \"itanium_class\" \"fldp\"))\n+\t    (eq_attr \"check_load\" \"no\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um01\")\n+(define_insn_reservation \"2b_fldpc\"   0\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+\t\t (eq_attr \"itanium_class\" \"fldp\"))\n+\t    (eq_attr \"check_load\" \"yes\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0)))\n   \"2b_M_only_um01\")\n+\n (define_insn_reservation \"2b_fmac\"    4\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"fmac\"))\n@@ -1611,11 +1678,20 @@\n             (eq_attr \"itanium_class\" \"ishf\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0)))\n   \"2b_I+2b_only_ui0\")\n+\n (define_insn_reservation \"2b_ld\"      1\n-  (and (and (eq_attr \"cpu\" \"itanium2\")\n-            (eq_attr \"itanium_class\" \"ld\"))\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                 (eq_attr \"itanium_class\" \"ld\"))\n+            (eq_attr \"check_load\" \"no\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0)))\n   \"2b_M_only_um01\")\n+(define_insn_reservation \"2b_ldc\"     0\n+  (and (and (and (eq_attr \"cpu\" \"itanium2\")\n+                 (eq_attr \"itanium_class\" \"ld\"))\n+            (eq_attr \"check_load\" \"yes\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um01\")\n+\n (define_insn_reservation \"2b_long_i\"  1\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"long_i\"))\n@@ -1714,11 +1790,23 @@\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"xtd\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_I\")\n-(define_insn_reservation \"2b_chk_s\"   0\n+\n+(define_insn_reservation \"2b_chk_s_i\" 0\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n-            (eq_attr \"itanium_class\" \"chk_s\"))\n+            (eq_attr \"itanium_class\" \"chk_s_i\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0)))\n   \"2b_I|2b_M_only_um23\")\n+(define_insn_reservation \"2b_chk_s_f\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"chk_s_f\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um23\")\n+(define_insn_reservation \"2b_chk_a\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"chk_a\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um01\")\n+\n (define_insn_reservation \"2b_lfetch\"  0\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"lfetch\"))"}, {"sha": "533841931b74942d3c5a9dbbfd8fc2696f0c801e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 114, "deletions": 1, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d0d36c2021df68c27dcc308f8f0717f0537bf/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=048d0d36c2021df68c27dcc308f8f0717f0537bf", "patch": "@@ -549,7 +549,13 @@ Objective-C and Objective-C++ Dialects}.\n -minline-sqrt-min-latency -minline-sqrt-max-throughput @gol\n -mno-dwarf2-asm -mearly-stop-bits @gol\n -mfixed-range=@var{register-range} -mtls-size=@var{tls-size} @gol\n--mtune=@var{cpu-type} -mt -pthread -milp32 -mlp64}\n+-mtune=@var{cpu-type} -mt -pthread -milp32 -mlp64 @gol\n+-mno-sched-br-data-spec -msched-ar-data-spec -mno-sched-control-spec @gol\n+-msched-br-in-data-spec -msched-ar-in-data-spec -msched-in-control-spec @gol\n+-msched-ldc -mno-sched-control-ldc -mno-sched-spec-verbose @gol\n+-mno-sched-prefer-non-data-spec-insns @gol\n+-mno-sched-prefer-non-control-spec-insns @gol\n+-mno-sched-count-spec-in-critical-path}\n \n @emph{M32R/D Options}\n @gccoptlist{-m32r2 -m32rx -m32r @gol\n@@ -9734,6 +9740,113 @@ The 32-bit environment sets int, long and pointer to 32 bits.\n The 64-bit environment sets int to 32 bits and long and pointer\n to 64 bits.  These are HP-UX specific flags.\n \n+@item -mno-sched-br-data-spec\n+@itemx -msched-br-data-spec\n+@opindex -mno-sched-br-data-spec\n+@opindex -msched-br-data-spec\n+(Dis/En)able data speculative scheduling before reload.\n+This will result in generation of the ld.a instructions and\n+the corresponding check instructions (ld.c / chk.a).\n+The default is 'disable'.\n+\n+@item -msched-ar-data-spec\n+@itemx -mno-sched-ar-data-spec\n+@opindex -msched-ar-data-spec\n+@opindex -mno-sched-ar-data-spec\n+(En/Dis)able data speculative scheduling after reload.\n+This will result in generation of the ld.a instructions and\n+the corresponding check instructions (ld.c / chk.a).\n+The default is 'enable'.\n+\n+@item -mno-sched-control-spec\n+@itemx -msched-control-spec\n+@opindex -mno-sched-control-spec\n+@opindex -msched-control-spec\n+(Dis/En)able control speculative scheduling.  This feature is\n+available only during region scheduling (i.e. before reload).\n+This will result in generation of the ld.s instructions and\n+the corresponding check instructions chk.s .\n+The default is 'disable'.\n+\n+@item -msched-br-in-data-spec\n+@itemx -mno-sched-br-in-data-spec\n+@opindex -msched-br-in-data-spec\n+@opindex -mno-sched-br-in-data-spec\n+(En/Dis)able speculative scheduling of the instructions that\n+are dependent on the data speculative loads before reload.\n+This is effective only with @option{-msched-br-data-spec} enabled.\n+The default is 'enable'.\n+\n+@item -msched-ar-in-data-spec\n+@itemx -mno-sched-ar-in-data-spec\n+@opindex -msched-ar-in-data-spec\n+@opindex -mno-sched-ar-in-data-spec\n+(En/Dis)able speculative scheduling of the instructions that\n+are dependent on the data speculative loads after reload.\n+This is effective only with @option{-msched-ar-data-spec} enabled.\n+The default is 'enable'.\n+\n+@item -msched-in-control-spec\n+@itemx -mno-sched-in-control-spec\n+@opindex -msched-in-control-spec\n+@opindex -mno-sched-in-control-spec\n+(En/Dis)able speculative scheduling of the instructions that\n+are dependent on the control speculative loads.\n+This is effective only with @option{-msched-control-spec} enabled.\n+The default is 'enable'.\n+\n+@item -msched-ldc\n+@itemx -mno-sched-ldc\n+@opindex -msched-ldc\n+@opindex -mno-sched-ldc\n+(En/Dis)able use of simple data speculation checks ld.c .\n+If disabled, only chk.a instructions will be emitted to check\n+data speculative loads.\n+The default is 'enable'.\n+\n+@item -mno-sched-control-ldc\n+@itemx -msched-control-ldc\n+@opindex -mno-sched-control-ldc\n+@opindex -msched-control-ldc \n+(Dis/En)able use of ld.c instructions to check control speculative loads.\n+If enabled, in case of control speculative load with no speculatively\n+scheduled dependent instructions this load will be emitted as ld.sa and\n+ld.c will be used to check it.\n+The default is 'disable'.\n+\n+@item -mno-sched-spec-verbose\n+@itemx -msched-spec-verbose\n+@opindex -mno-sched-spec-verbose\n+@opindex -msched-spec-verbose\n+(Dis/En)able printing of the information about speculative motions.\n+\n+@item -mno-sched-prefer-non-data-spec-insns\n+@itemx -msched-prefer-non-data-spec-insns\n+@opindex -mno-sched-prefer-non-data-spec-insns\n+@opindex -msched-prefer-non-data-spec-insns\n+If enabled, data speculative instructions will be choosen for schedule\n+only if there are no other choices at the moment.  This will make\n+the use of the data speculation much more conservative.\n+The default is 'disable'.\n+\n+@item -mno-sched-prefer-non-control-spec-insns\n+@itemx -msched-prefer-non-control-spec-insns\n+@opindex -mno-sched-prefer-non-control-spec-insns\n+@opindex -msched-prefer-non-control-spec-insns\n+If enabled, control speculative instructions will be choosen for schedule\n+only if there are no other choices at the moment.  This will make\n+the use of the control speculation much more conservative.\n+The default is 'disable'.\n+\n+@item -mno-sched-count-spec-in-critical-path\n+@itemx -msched-count-spec-in-critical-path\n+@opindex -mno-sched-count-spec-in-critical-path\n+@opindex -msched-count-spec-in-critical-path\n+If enabled, speculative depedencies will be considered during\n+computation of the instructions priorities.  This will make the use of the\n+speculation a bit more conservative.\n+The default is 'disable'.\n+\n @end table\n \n @node M32C Options"}]}