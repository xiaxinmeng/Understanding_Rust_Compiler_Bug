{"sha": "b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg1MWUzZWU1NWQ3MWVhOGU0NGI4ZmFjMWUzYmUwMzU4NWUxZTBkZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-28T13:41:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-28T13:41:25Z"}, "message": "fold-const.c (negate_expr_p): Adjust the division case to properly avoid introducing undefined overflow.\n\n2015-10-28  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.c (negate_expr_p): Adjust the division case to\n\tproperly avoid introducing undefined overflow.\n\t(fold_negate_expr): Likewise.\n\nFrom-SVN: r229484", "tree": {"sha": "756c919bcfca1afd0e194fc442fe824eee93e406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/756c919bcfca1afd0e194fc442fe824eee93e406"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "056b09955b97083e9dfcd9825160a408433143bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/056b09955b97083e9dfcd9825160a408433143bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/056b09955b97083e9dfcd9825160a408433143bf"}], "stats": {"total": 89, "additions": 34, "deletions": 55}, "files": [{"sha": "410537bc5593812c499832f97ab520af383e7f69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd", "patch": "@@ -1,3 +1,9 @@\n+2015-10-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.c (negate_expr_p): Adjust the division case to\n+\tproperly avoid introducing undefined overflow.\n+\t(fold_negate_expr): Likewise.\n+\n 2015-10-28  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/65962"}, {"sha": "016c0dd918187a34eae73f7d85596cbc8ff0ae18", "filename": "gcc/fold-const.c", "status": "modified", "additions": 28, "deletions": 55, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b851e3ee55d71ea8e44b8fac1e3be03585e1e0dd", "patch": "@@ -488,29 +488,19 @@ negate_expr_p (tree t)\n     case TRUNC_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      /* In general we can't negate A / B, because if A is INT_MIN and\n-\t B is 1, we may turn this into INT_MIN / -1 which is undefined\n-\t and actually traps on some architectures.  But if overflow is\n-\t undefined, we can negate, because - (INT_MIN / 1) is an\n-\t overflow.  */\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (t)))\n-\t{\n-\t  if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t)))\n-\t    break;\n-\t  /* If overflow is undefined then we have to be careful because\n-\t     we ask whether it's ok to associate the negate with the\n-\t     division which is not ok for example for\n-\t     -((a - b) / c) where (-(a - b)) / c may invoke undefined\n-\t     overflow because of negating INT_MIN.  So do not use\n-\t     negate_expr_p here but open-code the two important cases.  */\n-\t  if (TREE_CODE (TREE_OPERAND (t, 0)) == NEGATE_EXPR\n-\t      || (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST\n-\t\t  && may_negate_without_overflow_p (TREE_OPERAND (t, 0))))\n-\t    return true;\n-\t}\n-      else if (negate_expr_p (TREE_OPERAND (t, 0)))\n+      if (TYPE_UNSIGNED (type))\n+\tbreak;\n+      if (negate_expr_p (TREE_OPERAND (t, 0)))\n \treturn true;\n-      return negate_expr_p (TREE_OPERAND (t, 1));\n+      /* In general we can't negate B in A / B, because if A is INT_MIN and\n+\t B is 1, we may turn this into INT_MIN / -1 which is undefined\n+\t and actually traps on some architectures.  */\n+      if (! INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t  || TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))\n+\t  || (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST\n+\t      && ! integer_onep (TREE_OPERAND (t, 1))))\n+\treturn negate_expr_p (TREE_OPERAND (t, 1));\n+      break;\n \n     case NOP_EXPR:\n       /* Negate -((double)float) as (double)(-float).  */\n@@ -680,40 +670,23 @@ fold_negate_expr (location_t loc, tree t)\n     case TRUNC_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      /* In general we can't negate A / B, because if A is INT_MIN and\n+      if (TYPE_UNSIGNED (type))\n+\tbreak;\n+      if (negate_expr_p (TREE_OPERAND (t, 0)))\n+\treturn fold_build2_loc (loc, TREE_CODE (t), type,\n+\t\t\t\tnegate_expr (TREE_OPERAND (t, 0)),\n+\t\t\t\tTREE_OPERAND (t, 1));\n+      /* In general we can't negate B in A / B, because if A is INT_MIN and\n \t B is 1, we may turn this into INT_MIN / -1 which is undefined\n-\t and actually traps on some architectures.  But if overflow is\n-\t undefined, we can negate, because - (INT_MIN / 1) is an\n-\t overflow.  */\n-      if (!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))\n-        {\n-\t  const char * const warnmsg = G_(\"assuming signed overflow does not \"\n-\t\t\t\t\t  \"occur when negating a division\");\n-          tem = TREE_OPERAND (t, 1);\n-          if (negate_expr_p (tem))\n-\t    {\n-\t      if (INTEGRAL_TYPE_P (type)\n-\t\t  && (TREE_CODE (tem) != INTEGER_CST\n-\t\t      || integer_onep (tem)))\n-\t\tfold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_MISC);\n-\t      return fold_build2_loc (loc, TREE_CODE (t), type,\n-\t\t\t\t  TREE_OPERAND (t, 0), negate_expr (tem));\n-\t    }\n-\t  /* If overflow is undefined then we have to be careful because\n-\t     we ask whether it's ok to associate the negate with the\n-\t     division which is not ok for example for\n-\t     -((a - b) / c) where (-(a - b)) / c may invoke undefined\n-\t     overflow because of negating INT_MIN.  So do not use\n-\t     negate_expr_p here but open-code the two important cases.  */\n-          tem = TREE_OPERAND (t, 0);\n-\t  if ((INTEGRAL_TYPE_P (type)\n-\t       && (TREE_CODE (tem) == NEGATE_EXPR\n-\t\t   || (TREE_CODE (tem) == INTEGER_CST\n-\t\t       && may_negate_without_overflow_p (tem))))\n-\t      || !INTEGRAL_TYPE_P (type))\n-\t    return fold_build2_loc (loc, TREE_CODE (t), type,\n-\t\t\t\t    negate_expr (tem), TREE_OPERAND (t, 1));\n-        }\n+\t and actually traps on some architectures.  */\n+      if ((! INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t   || TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))\n+\t   || (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST\n+\t       && ! integer_onep (TREE_OPERAND (t, 1))))\n+\t  && negate_expr_p (TREE_OPERAND (t, 1)))\n+\treturn fold_build2_loc (loc, TREE_CODE (t), type,\n+\t\t\t\tTREE_OPERAND (t, 0),\n+\t\t\t\tnegate_expr (TREE_OPERAND (t, 1)));\n       break;\n \n     case NOP_EXPR:"}]}