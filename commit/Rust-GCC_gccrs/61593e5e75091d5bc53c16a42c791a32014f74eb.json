{"sha": "61593e5e75091d5bc53c16a42c791a32014f74eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE1OTNlNWU3NTA5MWQ1YmM1M2MxNmE0MmM3OTFhMzIwMTRmNzRlYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-14T16:29:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-14T16:29:22Z"}, "message": "lto-streamer-in.c (maybe_fixup_handled_component): Remove.\n\n2010-07-14  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-streamer-in.c (maybe_fixup_handled_component): Remove.\n\t(maybe_fixup_decls): Likewise.\n\t(input_gimple_stmt): Do not fixup anything.\n\t* lto-streamer-out.c (output_gimple_stmt): Make sure all\n\tnon-automatic variable uses are wrapped inside a MEM_REF.\n\nFrom-SVN: r162185", "tree": {"sha": "715579bf52abde6a4c4d6aa16b7edf3a21562657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/715579bf52abde6a4c4d6aa16b7edf3a21562657"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61593e5e75091d5bc53c16a42c791a32014f74eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61593e5e75091d5bc53c16a42c791a32014f74eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61593e5e75091d5bc53c16a42c791a32014f74eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61593e5e75091d5bc53c16a42c791a32014f74eb/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc7fcda12bd16c2c7515d9d1d1350c3547916e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7fcda12bd16c2c7515d9d1d1350c3547916e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc7fcda12bd16c2c7515d9d1d1350c3547916e5c"}], "stats": {"total": 173, "additions": 27, "deletions": 146}, "files": [{"sha": "bacd3d4c846ebc4e8cadf9e5e75648838cfe0dd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61593e5e75091d5bc53c16a42c791a32014f74eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61593e5e75091d5bc53c16a42c791a32014f74eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61593e5e75091d5bc53c16a42c791a32014f74eb", "patch": "@@ -1,3 +1,11 @@\n+2010-07-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-streamer-in.c (maybe_fixup_handled_component): Remove.\n+\t(maybe_fixup_decls): Likewise.\n+\t(input_gimple_stmt): Do not fixup anything.\n+\t* lto-streamer-out.c (output_gimple_stmt): Make sure all\n+\tnon-automatic variable uses are wrapped inside a MEM_REF.\n+\n 2010-07-14  Richard Henderson  <rth@redhat.com>\n \n \t* passes.c (rest_of_decl_compilation): Do not call assemble_variable"}, {"sha": "274418e838ee038f600dc33393827d4835d35352", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61593e5e75091d5bc53c16a42c791a32014f74eb/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61593e5e75091d5bc53c16a42c791a32014f74eb/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=61593e5e75091d5bc53c16a42c791a32014f74eb", "patch": "@@ -872,124 +872,6 @@ input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n     }\n }\n \n-\n-/* Fixup the reference tree OP for replaced VAR_DECLs with mismatched\n-   types.  */\n-\n-static void\n-maybe_fixup_handled_component (tree op)\n-{\n-  tree decl_type;\n-  tree wanted_type;\n-\n-  while (handled_component_p (TREE_OPERAND (op, 0)))\n-    op = TREE_OPERAND (op, 0);\n-  if (TREE_CODE (TREE_OPERAND (op, 0)) != VAR_DECL)\n-    return;\n-\n-  decl_type = TREE_TYPE (TREE_OPERAND (op, 0));\n-\n-  switch (TREE_CODE (op))\n-    {\n-    case COMPONENT_REF:\n-      /* The DECL_CONTEXT of the field-decl is the record type we look for.  */\n-      wanted_type = DECL_CONTEXT (TREE_OPERAND (op, 1));\n-      break;\n-\n-    case ARRAY_REF:\n-      if (TREE_CODE (decl_type) == ARRAY_TYPE\n-\t  && (TREE_TYPE (decl_type) == TREE_TYPE (op)\n-\t      || useless_type_conversion_p (TREE_TYPE (op),\n-\t\t\t\t\t    TREE_TYPE (decl_type))))\n-\treturn;\n-      /* An unknown size array type should be ok.  But we do not\n-         lower the lower bound in all cases - ugh.  */\n-      wanted_type = build_array_type (TREE_TYPE (op), NULL_TREE);\n-      break;\n-\n-    case ARRAY_RANGE_REF:\n-      if (TREE_CODE (decl_type) == ARRAY_TYPE\n-\t  && (TREE_TYPE (decl_type) == TREE_TYPE (TREE_TYPE (op))\n-\t      || useless_type_conversion_p (TREE_TYPE (TREE_TYPE (op)),\n-\t\t\t\t\t    TREE_TYPE (decl_type))))\n-\treturn;\n-      /* An unknown size array type should be ok.  But we do not\n-         lower the lower bound in all cases - ugh.  */\n-      wanted_type = build_array_type (TREE_TYPE (TREE_TYPE (op)), NULL_TREE);\n-      break;\n-\n-    case BIT_FIELD_REF:\n-    case VIEW_CONVERT_EXPR:\n-      /* Very nice - nothing to do.  */\n-      return;\n-\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-      if (TREE_CODE (decl_type) == COMPLEX_TYPE\n-\t  && (TREE_TYPE (decl_type) == TREE_TYPE (op)\n-\t      || useless_type_conversion_p (TREE_TYPE (op),\n-\t\t\t\t\t    TREE_TYPE (decl_type))))\n-\treturn;\n-      wanted_type = build_complex_type (TREE_TYPE (op));\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (!useless_type_conversion_p (wanted_type, decl_type))\n-    TREE_OPERAND (op, 0) = build1 (VIEW_CONVERT_EXPR, wanted_type,\n-\t\t\t\t   TREE_OPERAND (op, 0));\n-}\n-\n-/* Fixup reference tree operands for substituted prevailing decls\n-   with mismatched types in STMT.  This handles plain DECLs where\n-   we need the stmt for context to lookup the required type.  */\n-\n-static void\n-maybe_fixup_decls (gimple stmt)\n-{\n-  /* We have to fixup replaced decls here in case there were\n-     inter-TU type mismatches.  Catch the most common cases\n-     for now - this way we'll get testcases for the rest as\n-     the type verifier will complain.  */\n-  if (gimple_assign_single_p (stmt))\n-    {\n-      tree lhs = gimple_assign_lhs (stmt);\n-      tree rhs = gimple_assign_rhs1 (stmt);\n-\n-      /* First catch loads and aggregate copies by adjusting the rhs.  */\n-      if (TREE_CODE (rhs) == VAR_DECL)\n-\t{\n-\t  if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n-\t    gimple_assign_set_rhs1 (stmt, build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t  TREE_TYPE (lhs), rhs));\n-\t}\n-      /* Then catch scalar stores.  */\n-      else if (TREE_CODE (lhs) == VAR_DECL)\n-\t{\n-\t  if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n-\t    gimple_assign_set_lhs (stmt, build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t TREE_TYPE (rhs), lhs));\n-\t}\n-    }\n-  else if (is_gimple_call (stmt))\n-    {\n-      tree lhs = gimple_call_lhs (stmt);\n-\n-      if (lhs && TREE_CODE (lhs) == VAR_DECL)\n-\t{\n-\t  if (!useless_type_conversion_p (TREE_TYPE (lhs),\n-\t\t\t\t\t  gimple_call_return_type (stmt)))\n-\t    gimple_call_set_lhs (stmt, build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t       gimple_call_return_type (stmt),\n-\t\t\t\t\t       lhs));\n-\t}\n-\n-      /* Arguments, especially for varargs functions will be funny...  */\n-    }\n-}\n-\n /* Read a statement with tag TAG in function FN from block IB using\n    descriptors in DATA_IN.  */\n \n@@ -1064,21 +946,6 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t  if (!op)\n \t    continue;\n \n-\t  /* Fixup reference tree operands for substituted prevailing decls\n-\t     with mismatched types.  For plain VAR_DECLs we need to look\n-\t     at context to determine the wanted type - we do that below\n-\t     after the stmt is completed.  */\n-\t  if (TREE_CODE (op) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (op, 0)) == VAR_DECL\n-\t      && !useless_type_conversion_p (TREE_TYPE (TREE_TYPE (op)),\n-\t\t\t\t\t     TREE_TYPE (TREE_OPERAND (op, 0))))\n-\t    {\n-\t      TREE_OPERAND (op, 0)\n-\t\t= build1 (VIEW_CONVERT_EXPR, TREE_TYPE (TREE_TYPE (op)),\n-\t\t\t  TREE_OPERAND (op, 0));\n-\t      continue;\n-\t    }\n-\n \t  /* Fixup FIELD_DECLs in COMPONENT_REFs, they are not handled\n \t     by decl merging.  */\n \t  if (TREE_CODE (op) == ADDR_EXPR)\n@@ -1110,17 +977,8 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t\t    TREE_OPERAND (op, 1) = tem;\n \t\t}\n \n-\t      /* Preserve the last handled component for the fixup of\n-\t         its operand below.  */\n-\t      if (!handled_component_p (TREE_OPERAND (op, 0)))\n-\t\tbreak;\n \t      op = TREE_OPERAND (op, 0);\n \t    }\n-\n-\t  /* Fixup reference tree operands for substituted prevailing decls\n-\t     with mismatched types.  */\n-\t  if (handled_component_p (op))\n-\t    maybe_fixup_handled_component (op);\n \t}\n       break;\n \n@@ -1160,10 +1018,6 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n   if (code == GIMPLE_CALL)\n     gimple_call_reset_alias_info (stmt);\n \n-  /* Fixup reference tree operands for substituted prevailing decls\n-     with mismatched types.  */\n-  maybe_fixup_decls (stmt);\n-\n   /* Mark the statement modified so its operand vectors can be filled in.  */\n   gimple_set_modified (stmt, true);\n "}, {"sha": "7b78ce521487982dad34ab53ae1976032f08a15e", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61593e5e75091d5bc53c16a42c791a32014f74eb/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61593e5e75091d5bc53c16a42c791a32014f74eb/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=61593e5e75091d5bc53c16a42c791a32014f74eb", "patch": "@@ -1706,6 +1706,25 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n       for (i = 0; i < gimple_num_ops (stmt); i++)\n \t{\n \t  tree op = gimple_op (stmt, i);\n+\t  /* Wrap all uses of non-automatic variables inside MEM_REFs\n+\t     so that we do not have to deal with type mismatches on\n+\t     merged symbols during IL read in.  */\n+\t  if (op)\n+\t    {\n+\t      tree *basep = &op;\n+\t      if (handled_component_p (*basep))\n+\t\tbasep = &TREE_OPERAND (*basep, 0);\n+\t      if (TREE_CODE (*basep) == VAR_DECL\n+\t\t  && !auto_var_in_fn_p (*basep, current_function_decl))\n+\t\t{\n+\t\t  bool volatilep = TREE_THIS_VOLATILE (*basep);\n+\t\t  *basep = build2 (MEM_REF, TREE_TYPE (*basep),\n+\t\t\t\t   build_fold_addr_expr (*basep),\n+\t\t\t\t   build_int_cst (build_pointer_type\n+\t\t\t\t\t\t  (TREE_TYPE (*basep)), 0));\n+\t\t  TREE_THIS_VOLATILE (*basep) = volatilep;\n+\t\t}\n+\t    }\n \t  lto_output_tree_ref (ob, op);\n \t}\n       break;"}]}