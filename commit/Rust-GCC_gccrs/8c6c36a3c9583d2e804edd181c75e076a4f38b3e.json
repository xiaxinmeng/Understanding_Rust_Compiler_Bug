{"sha": "8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM2YzM2YTNjOTU4M2QyZTgwNGVkZDE4MWM3NWUwNzZhNGYzOGIzZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2007-11-07T20:48:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-11-07T20:48:08Z"}, "message": "re PR rtl-optimization/33822 (-g -O -mstrict-align causes an ICE in set_variable_part,)\n\n\tPR rtl-optimization/33822\n\t* rtl.h (REG_OFFSET): Fix comment.\n\t* var-tracking.c (INT_MEM_OFFSET): New macro.\n\t(var_mem_set): Use it.\n\t(var_mem_delete_and_set): Likewise.\n\t(var_mem_delete): Likewise.\n\t(same_variable_part_p): Likewise.\n\t(vt_get_decl_and_offset): Likewise.\n\t(offset_valid_for_tracked_p): New predicate.\n\t(count_uses): Do not track locations with invalid offsets.\n\t(add_uses): Likewise.\n\t(add_stores): Likewise.\n\nFrom-SVN: r129970", "tree": {"sha": "e242c9c5a82d38692b13f502a139a829581391e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e242c9c5a82d38692b13f502a139a829581391e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83eb8eb789ffa18d8fe0aad243adaa753f532385", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83eb8eb789ffa18d8fe0aad243adaa753f532385", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83eb8eb789ffa18d8fe0aad243adaa753f532385"}], "stats": {"total": 82, "additions": 67, "deletions": 15}, "files": [{"sha": "d005a094b3e2740a47760b0d113d96b7c3dca232", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "patch": "@@ -1,3 +1,18 @@\n+2007-11-07  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR rtl-optimization/33822\n+\t* rtl.h (REG_OFFSET): Fix comment.\n+\t* var-tracking.c (INT_MEM_OFFSET): New macro.\n+\t(var_mem_set): Use it.\n+\t(var_mem_delete_and_set): Likewise.\n+\t(var_mem_delete): Likewise.\n+\t(same_variable_part_p): Likewise.\n+\t(vt_get_decl_and_offset): Likewise.\n+\t(offset_valid_for_tracked_p): New predicate.\n+\t(count_uses): Do not track locations with invalid offsets.\n+\t(add_uses): Likewise.\n+\t(add_stores): Likewise.\n+\n 2007-11-07  Tom Tromey  <tromey@redhat.com>\n \n \t* Makefile.in (tree-ssa-structalias.o): Depend on $(FUNCTION_H)"}, {"sha": "ef3a97e7ef6308e6978d879bd2f663eba9976646", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "patch": "@@ -1210,8 +1210,8 @@ do {\t\t\t\t\t\t\\\n    refer to part of a DECL.  */\n #define REG_EXPR(RTX) (REG_ATTRS (RTX) == 0 ? 0 : REG_ATTRS (RTX)->decl)\n \n-/* For a MEM rtx, the offset from the start of MEM_DECL, if known, as a\n-   RTX that is always a CONST_INT.  */\n+/* For a REG rtx, the offset from the start of REG_EXPR, if known, as an\n+   HOST_WIDE_INT.  */\n #define REG_OFFSET(RTX) (REG_ATTRS (RTX) == 0 ? 0 : REG_ATTRS (RTX)->offset)\n \n /* Copy the attributes that apply to memory locations from RHS to LHS.  */"}, {"sha": "60e2429a50e31fedd1faac0bd29b021751665863", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "patch": "@@ -1,3 +1,7 @@\n+2007-11-07  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* gcc.dg/out-of-bounds-1.c: New test.\n+\n 2007-11-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/33501"}, {"sha": "14c4591a40a160b6894abec7ee705d3638c44444", "filename": "gcc/testsuite/gcc.dg/out-of-bounds-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2Ftestsuite%2Fgcc.dg%2Fout-of-bounds-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2Ftestsuite%2Fgcc.dg%2Fout-of-bounds-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fout-of-bounds-1.c?ref=8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "patch": "@@ -0,0 +1,13 @@\n+/* PR rtl-optimization/33822 */\n+/* Origin: Andrew Pinski <pinskia@gcc.gnu.org> */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-options \"-O -g -mstrict-align\" { target powerpc*-*-* } } */\n+\n+void ProjectOverlay(const float localTextureAxis[2], char *lump)\n+{\n+   const void *d = &localTextureAxis;\n+   int size = sizeof(float)*8 ;\n+   __builtin_memcpy( &lump[ 0 ], d, size );  \n+}"}, {"sha": "46752fa1ef0b1990ca9e64f53452e60fae187ba3", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6c36a3c9583d2e804edd181c75e076a4f38b3e/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=8c6c36a3c9583d2e804edd181c75e076a4f38b3e", "patch": "@@ -267,6 +267,9 @@ typedef const struct variable_def *const_variable;\n /* Pointer to the BB's information specific to variable tracking pass.  */\n #define VTI(BB) ((variable_tracking_info) (BB)->aux)\n \n+/* Macro to access MEM_OFFSET as an HOST_WIDE_INT.  Evaluates MEM twice.  */\n+#define INT_MEM_OFFSET(mem) (MEM_OFFSET (mem) ? INTVAL (MEM_OFFSET (mem)) : 0)\n+\n /* Alloc pool for struct attrs_def.  */\n static alloc_pool attrs_pool;\n \n@@ -986,7 +989,7 @@ var_mem_set (dataflow_set *set, rtx loc, enum var_init_status initialized,\n \t     rtx set_src)\n {\n   tree decl = MEM_EXPR (loc);\n-  HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n+  HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);\n \n   decl = var_debug_decl (decl);\n \n@@ -1005,7 +1008,7 @@ var_mem_delete_and_set (dataflow_set *set, rtx loc, bool modify,\n \t\t\tenum var_init_status initialized, rtx set_src)\n {\n   tree decl = MEM_EXPR (loc);\n-  HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n+  HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);\n \n   decl = var_debug_decl (decl);\n \n@@ -1025,7 +1028,7 @@ static void\n var_mem_delete (dataflow_set *set, rtx loc, bool clobber)\n {\n   tree decl = MEM_EXPR (loc);\n-  HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n+  HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);\n \n   decl = var_debug_decl (decl);\n   if (clobber)\n@@ -1642,6 +1645,18 @@ track_expr_p (tree expr)\n   return 1;\n }\n \n+/* Return true if OFFSET is a valid offset for a register or memory\n+   access we want to track.  This is used to reject out-of-bounds\n+   accesses that can cause assertions to fail later.  Note that we\n+   don't reject negative offsets because they can be generated for\n+   paradoxical subregs on big-endian architectures.  */\n+\n+static inline bool\n+offset_valid_for_tracked_p (HOST_WIDE_INT offset)\n+{\n+  return (-MAX_VAR_PARTS < offset) && (offset < MAX_VAR_PARTS);\n+}\n+\n /* Determine whether a given LOC refers to the same variable part as\n    EXPR+OFFSET.  */\n \n@@ -1662,7 +1677,7 @@ same_variable_part_p (rtx loc, tree expr, HOST_WIDE_INT offset)\n   else if (MEM_P (loc))\n     {\n       expr2 = MEM_EXPR (loc);\n-      offset2 = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n+      offset2 = INT_MEM_OFFSET (loc);\n     }\n   else\n     return false;\n@@ -1740,7 +1755,8 @@ count_uses (rtx *loc, void *insn)\n     }\n   else if (MEM_P (*loc)\n \t   && MEM_EXPR (*loc)\n-\t   && track_expr_p (MEM_EXPR (*loc)))\n+\t   && track_expr_p (MEM_EXPR (*loc))\n+\t   && offset_valid_for_tracked_p (INT_MEM_OFFSET (*loc)))\n     {\n       VTI (bb)->n_mos++;\n     }\n@@ -1776,7 +1792,9 @@ add_uses (rtx *loc, void *insn)\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n-      if (REG_EXPR (*loc) && track_expr_p (REG_EXPR (*loc)))\n+      if (REG_EXPR (*loc)\n+\t  && track_expr_p (REG_EXPR (*loc))\n+\t  && offset_valid_for_tracked_p (REG_OFFSET (*loc)))\n \t{\n \t  mo->type = MO_USE;\n \t  mo->u.loc = var_lowpart (mode_for_reg_attrs (*loc), *loc);\n@@ -1790,7 +1808,8 @@ add_uses (rtx *loc, void *insn)\n     }\n   else if (MEM_P (*loc)\n \t   && MEM_EXPR (*loc)\n-\t   && track_expr_p (MEM_EXPR (*loc)))\n+\t   && track_expr_p (MEM_EXPR (*loc))\n+\t   && offset_valid_for_tracked_p (INT_MEM_OFFSET (*loc)))\n     {\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n@@ -1824,8 +1843,9 @@ add_stores (rtx loc, const_rtx expr, void *insn)\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n       if (GET_CODE (expr) == CLOBBER\n-\t  || ! REG_EXPR (loc)\n-\t  || ! track_expr_p (REG_EXPR (loc)))\n+\t  || !(REG_EXPR (loc)\n+\t       && track_expr_p (REG_EXPR (loc))\n+\t       && offset_valid_for_tracked_p (REG_OFFSET (loc))))\n \t{\n \t  mo->type = MO_CLOBBER;\n \t  mo->u.loc = loc;\n@@ -1859,7 +1879,8 @@ add_stores (rtx loc, const_rtx expr, void *insn)\n     }\n   else if (MEM_P (loc)\n \t   && MEM_EXPR (loc)\n-\t   && track_expr_p (MEM_EXPR (loc)))\n+\t   && track_expr_p (MEM_EXPR (loc))\n+\t   && offset_valid_for_tracked_p (INT_MEM_OFFSET (loc)))\n     {\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n@@ -1885,8 +1906,7 @@ add_stores (rtx loc, const_rtx expr, void *insn)\n \t    {\n \t      if (same_variable_part_p (SET_SRC (expr),\n \t\t\t\t\tMEM_EXPR (loc),\n-\t\t\t\t\tMEM_OFFSET (loc)\n-\t\t\t\t\t? INTVAL (MEM_OFFSET (loc)) : 0))\n+\t\t\t\t\tINT_MEM_OFFSET (loc)))\n \t\tmo->type = MO_COPY;\n \t      else\n \t\tmo->type = MO_SET;\n@@ -3075,7 +3095,7 @@ vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)\n       if (MEM_ATTRS (rtl))\n \t{\n \t  *declp = MEM_EXPR (rtl);\n-\t  *offsetp = MEM_OFFSET (rtl) ? INTVAL (MEM_OFFSET (rtl)) : 0;\n+\t  *offsetp = INT_MEM_OFFSET (rtl);\n \t  return true;\n \t}\n     }"}]}