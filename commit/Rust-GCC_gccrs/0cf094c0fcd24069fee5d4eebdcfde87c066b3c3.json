{"sha": "0cf094c0fcd24069fee5d4eebdcfde87c066b3c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNmMDk0YzBmY2QyNDA2OWZlZTVkNGVlYmRjZmRlODdjMDY2YjNjMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-06-25T13:58:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-06-25T13:58:43Z"}, "message": "* lto-streamer-out.c (DFS::hash_scc): Fix typos & formatting glitches.\n\nFrom-SVN: r224942", "tree": {"sha": "1e79056c616d2bb1e91f8057f3208878261a5f70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e79056c616d2bb1e91f8057f3208878261a5f70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cf094c0fcd24069fee5d4eebdcfde87c066b3c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cf094c0fcd24069fee5d4eebdcfde87c066b3c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cf094c0fcd24069fee5d4eebdcfde87c066b3c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cf094c0fcd24069fee5d4eebdcfde87c066b3c3/comments", "author": null, "committer": null, "parents": [{"sha": "f43d102e0eea58abec2599dbb009c980a820bf0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43d102e0eea58abec2599dbb009c980a820bf0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f43d102e0eea58abec2599dbb009c980a820bf0f"}], "stats": {"total": 92, "additions": 47, "deletions": 45}, "files": [{"sha": "a414549449e62407e1d86d229722639df65ebff1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf094c0fcd24069fee5d4eebdcfde87c066b3c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf094c0fcd24069fee5d4eebdcfde87c066b3c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cf094c0fcd24069fee5d4eebdcfde87c066b3c3", "patch": "@@ -1,3 +1,7 @@\n+2015-06-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* lto-streamer-out.c (DFS::hash_scc): Fix typos & formatting glitches.\n+\n 2015-06-25  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* match.pd: Add patterns for vec_conds between 1 and 0."}, {"sha": "cb1c4a153e342b1e203799b208989489cb032276", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf094c0fcd24069fee5d4eebdcfde87c066b3c3/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf094c0fcd24069fee5d4eebdcfde87c066b3c3/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=0cf094c0fcd24069fee5d4eebdcfde87c066b3c3", "patch": "@@ -1364,54 +1364,51 @@ DFS::scc_entry_compare (const void *p1_, const void *p2_)\n   return 0;\n }\n \n-/* Return a hash value for the SCC on the SCC stack from FIRST with\n-   size SIZE.  */\n+/* Return a hash value for the SCC on the SCC stack from FIRST with SIZE.  */\n \n hashval_t\n-DFS::hash_scc (struct output_block *ob,\n-\t       unsigned first, unsigned size)\n+DFS::hash_scc (struct output_block *ob, unsigned first, unsigned size)\n {\n   unsigned int last_classes = 0, iterations = 0;\n \n   /* Compute hash values for the SCC members.  */\n   for (unsigned i = 0; i < size; ++i)\n-    sccstack[first+i].hash = hash_tree (ob->writer_cache, NULL,\n-\t\t\t\t\tsccstack[first+i].t);\n+    sccstack[first+i].hash\n+      = hash_tree (ob->writer_cache, NULL, sccstack[first+i].t);\n \n   if (size == 1)\n     return sccstack[first].hash;\n \n   /* We aim to get unique hash for every tree within SCC and compute hash value\n-     of the whole SCC by combing all values together in an stable (entry point\n+     of the whole SCC by combining all values together in a stable (entry-point\n      independent) order.  This guarantees that the same SCC regions within\n      different translation units will get the same hash values and therefore\n      will be merged at WPA time.\n \n-     Often the hashes are already unique.  In that case we compute scc hash\n+     Often the hashes are already unique.  In that case we compute the SCC hash\n      by combining individual hash values in an increasing order.\n \n-     If thre are duplicates we seek at least one tree with unique hash (and\n-     pick one with minimal hash and this property).  Then we obtain stable\n-     order by DFS walk starting from this unique tree and then use index\n+     If there are duplicates, we seek at least one tree with unique hash (and\n+     pick one with minimal hash and this property).  Then we obtain a stable\n+     order by DFS walk starting from this unique tree and then use the index\n      within this order to make individual hash values unique.\n \n      If there is no tree with unique hash, we iteratively propagate the hash\n      values across the internal edges of SCC.  This usually quickly leads\n      to unique hashes.  Consider, for example, an SCC containing two pointers\n-     that are identical except for type they point and assume that these\n-     types are also part of the SCC.\n-     The propagation will add the points-to type information into their hash\n-     values.  */\n+     that are identical except for the types they point to and assume that\n+     these types are also part of the SCC.  The propagation will add the\n+     points-to type information into their hash values.  */\n   do\n     {\n-      /* Sort the SCC so we can easily see check for uniqueness.  */\n+      /* Sort the SCC so we can easily check for uniqueness.  */\n       qsort (&sccstack[first], size, sizeof (scc_entry), scc_entry_compare);\n \n       unsigned int classes = 1;\n       int firstunique = -1;\n \n-      /* Find tree with lowest unique hash (if it exists) and compute\n-\t number of equivalence classes.  */\n+      /* Find the tree with lowest unique hash (if it exists) and compute\n+\t the number of equivalence classes.  */\n       if (sccstack[first].hash != sccstack[first+1].hash)\n \tfirstunique = 0;\n       for (unsigned i = 1; i < size; ++i)\n@@ -1424,7 +1421,7 @@ DFS::hash_scc (struct output_block *ob,\n \t      firstunique = i;\n \t  }\n \n-      /* If we found tree with unique hash; stop the iteration.  */\n+      /* If we found a tree with unique hash, stop the iteration.  */\n       if (firstunique != -1\n \t  /* Also terminate if we run out of iterations or if the number of\n \t     equivalence classes is no longer increasing.\n@@ -1436,13 +1433,13 @@ DFS::hash_scc (struct output_block *ob,\n           hashval_t scc_hash;\n \n \t  /* If some hashes are not unique (CLASSES != SIZE), use the DFS walk\n-\t     starting from FIRSTUNIQUE to obstain stable order.  */\n+\t     starting from FIRSTUNIQUE to obtain a stable order.  */\n \t  if (classes != size && firstunique != -1)\n \t    {\n \t      hash_map <tree, hashval_t> map(size*2);\n \n \t      /* Store hash values into a map, so we can associate them with\n-\t\t reordered SCC.  */\n+\t\t the reordered SCC.  */\n \t      for (unsigned i = 0; i < size; ++i)\n \t\tmap.put (sccstack[first+i].t, sccstack[first+i].hash);\n \n@@ -1455,40 +1452,42 @@ DFS::hash_scc (struct output_block *ob,\n \n \t      /* Update hash values of individual members by hashing in the\n \t\t index within the stable order.  This ensures uniqueness.\n-\t\t Also compute the scc_hash by mixing in all hash values in the\n-\t\t stable order we obtained.  */\n+\t\t Also compute the SCC hash by mixing in all hash values in\n+\t\t the stable order we obtained.  */\n \t      sccstack[first].hash = *map.get (sccstack[first].t);\n \t      scc_hash = sccstack[first].hash;\n \t      for (unsigned i = 1; i < size; ++i)\n \t\t{\n \t\t  sccstack[first+i].hash\n \t\t    = iterative_hash_hashval_t (i,\n \t\t\t\t\t\t*map.get (sccstack[first+i].t));\n-\t\t  scc_hash = iterative_hash_hashval_t (scc_hash,\n-\t\t\t\t\t\t       sccstack[first+i].hash);\n+\t\t  scc_hash\n+\t\t    = iterative_hash_hashval_t (scc_hash,\n+\t\t\t\t\t\tsccstack[first+i].hash);\n \t\t}\n \t    }\n-\t  /* If we got unique hash values for each tree, then sort already\n-\t     ensured entry point independent order.  Only compute the final\n-\t     scc hash.\n+\t  /* If we got a unique hash value for each tree, then sort already\n+\t     ensured entry-point independent order.  Only compute the final\n+\t     SCC hash.\n \n \t     If we failed to find the unique entry point, we go by the same\n-\t     route. We will eventually introduce unwanted hash conflicts.  */\n+\t     route.  We will eventually introduce unwanted hash conflicts.  */\n \t  else\n \t    {\n \t      scc_hash = sccstack[first].hash;\n \t      for (unsigned i = 1; i < size; ++i)\n-\t\tscc_hash = iterative_hash_hashval_t (scc_hash,\n-\t\t\t\t\t\t     sccstack[first+i].hash);\n-\t      /* We can not 100% guarantee that the hash will not conflict in\n-\t\t in a way so the unique hash is not found.  This however\n-\t\t should be extremely rare situation.  ICE for now so possible\n-\t\t issues are found and evaulated.  */\n+\t\tscc_hash\n+\t\t  = iterative_hash_hashval_t (scc_hash, sccstack[first+i].hash);\n+\n+\t      /* We cannot 100% guarantee that the hash won't conflict so as\n+\t\t to make it impossible to find a unique hash.  This however\n+\t\t should be an extremely rare case.  ICE for now so possible\n+\t\t issues are found and evaluated.  */\n \t      gcc_checking_assert (classes == size);\n \t    }\n \n-\t  /* To avoid conflicts across SCCs iteratively hash the whole SCC\n-\t     hash into the hash of each of the elements.  */\n+\t  /* To avoid conflicts across SCCs, iteratively hash the whole SCC\n+\t     hash into the hash of each element.  */\n \t  for (unsigned i = 0; i < size; ++i)\n \t    sccstack[first+i].hash\n \t      = iterative_hash_hashval_t (sccstack[first+i].hash, scc_hash);\n@@ -1500,15 +1499,14 @@ DFS::hash_scc (struct output_block *ob,\n \n       /* We failed to identify the entry point; propagate hash values across\n \t the edges.  */\n-      {\n-\thash_map <tree, hashval_t> map(size*2);\n-\tfor (unsigned i = 0; i < size; ++i)\n-\t  map.put (sccstack[first+i].t, sccstack[first+i].hash);\n+      hash_map <tree, hashval_t> map(size*2);\n \n-\tfor (unsigned i = 0; i < size; i++)\n-\t  sccstack[first+i].hash = hash_tree (ob->writer_cache, &map,\n-\t\t\t\t\t      sccstack[first+i].t);\n-      }\n+      for (unsigned i = 0; i < size; ++i)\n+\tmap.put (sccstack[first+i].t, sccstack[first+i].hash);\n+\n+      for (unsigned i = 0; i < size; i++)\n+\tsccstack[first+i].hash\n+\t  = hash_tree (ob->writer_cache, &map, sccstack[first+i].t);\n     }\n   while (true);\n }"}]}