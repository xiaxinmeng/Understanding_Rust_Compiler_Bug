{"sha": "e7d55c6b81733335d81e35f7c0116bbdffccb682", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdkNTVjNmI4MTczMzMzNWQ4MWUzNWY3YzAxMTZiYmRmZmNjYjY4Mg==", "commit": {"author": {"name": "Senthil Kumar Selvaraj", "email": "saaadhu@gcc.gnu.org", "date": "2020-08-13T07:49:26Z"}, "committer": {"name": "Senthil Kumar Selvaraj", "email": "saaadhu@gcc.gnu.org", "date": "2020-08-21T12:29:40Z"}, "message": "Allow try_split to split RTX_FRAME_RELATED_P insns\n\nInstead of rejecting RTX_FRAME_RELATED_P insns, allow try_split to split\nsuch insns, provided the split is after reload, and the result of the split\nis a single insn.\n\nrecog.c:peep2_attempt already splits an RTX_FRAME_RELATED_P insn splitting\nto a single insn. This patch refactors existing code copying frame related\ninfo to a separate function (copy_frame_info_to_split_insn) and calls it\nfrom both peep2_attempt and try_split.\n\n2020-08-21  Senthil Kumar Selvaraj  <saaadhu@gcc.gnu.org>\n\ngcc/ChangeLog:\n\n\t* emit-rtl.c (try_split): Call copy_frame_info_to_split_insn\n\tto split certain RTX_FRAME_RELATED_P insns.\n\t* recog.c (copy_frame_info_to_split_insn): New function.\n\t(peep2_attempt): Split copying of frame related info of\n\tRTX_FRAME_RELATED_P insns into above function and call it.\n\t* recog.h (copy_frame_info_to_split_insn): Declare it.", "tree": {"sha": "6e580a14c242d86acc268077652207657f7dcf5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e580a14c242d86acc268077652207657f7dcf5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7d55c6b81733335d81e35f7c0116bbdffccb682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d55c6b81733335d81e35f7c0116bbdffccb682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7d55c6b81733335d81e35f7c0116bbdffccb682", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d55c6b81733335d81e35f7c0116bbdffccb682/comments", "author": {"login": "saaadhu", "id": 532256, "node_id": "MDQ6VXNlcjUzMjI1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/532256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saaadhu", "html_url": "https://github.com/saaadhu", "followers_url": "https://api.github.com/users/saaadhu/followers", "following_url": "https://api.github.com/users/saaadhu/following{/other_user}", "gists_url": "https://api.github.com/users/saaadhu/gists{/gist_id}", "starred_url": "https://api.github.com/users/saaadhu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saaadhu/subscriptions", "organizations_url": "https://api.github.com/users/saaadhu/orgs", "repos_url": "https://api.github.com/users/saaadhu/repos", "events_url": "https://api.github.com/users/saaadhu/events{/privacy}", "received_events_url": "https://api.github.com/users/saaadhu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saaadhu", "id": 532256, "node_id": "MDQ6VXNlcjUzMjI1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/532256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saaadhu", "html_url": "https://github.com/saaadhu", "followers_url": "https://api.github.com/users/saaadhu/followers", "following_url": "https://api.github.com/users/saaadhu/following{/other_user}", "gists_url": "https://api.github.com/users/saaadhu/gists{/gist_id}", "starred_url": "https://api.github.com/users/saaadhu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saaadhu/subscriptions", "organizations_url": "https://api.github.com/users/saaadhu/orgs", "repos_url": "https://api.github.com/users/saaadhu/repos", "events_url": "https://api.github.com/users/saaadhu/events{/privacy}", "received_events_url": "https://api.github.com/users/saaadhu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "988fb2f597d67cdf3603654372c020c28448441f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/988fb2f597d67cdf3603654372c020c28448441f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/988fb2f597d67cdf3603654372c020c28448441f"}], "stats": {"total": 155, "additions": 90, "deletions": 65}, "files": [{"sha": "3706f0a03fd8ccba7625e51012807333df69d99f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d55c6b81733335d81e35f7c0116bbdffccb682/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d55c6b81733335d81e35f7c0116bbdffccb682/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e7d55c6b81733335d81e35f7c0116bbdffccb682", "patch": "@@ -3822,10 +3822,6 @@ try_split (rtx pat, rtx_insn *trial, int last)\n   int njumps = 0;\n   rtx_insn *call_insn = NULL;\n \n-  /* We're not good at redistributing frame information.  */\n-  if (RTX_FRAME_RELATED_P (trial))\n-    return trial;\n-\n   if (any_condjump_p (trial)\n       && (note = find_reg_note (trial, REG_BR_PROB, 0)))\n     split_branch_probability\n@@ -3842,6 +3838,7 @@ try_split (rtx pat, rtx_insn *trial, int last)\n   if (!seq)\n     return trial;\n \n+  int split_insn_count = 0;\n   /* Avoid infinite loop if any insn of the result matches\n      the original pattern.  */\n   insn_last = seq;\n@@ -3850,11 +3847,25 @@ try_split (rtx pat, rtx_insn *trial, int last)\n       if (INSN_P (insn_last)\n \t  && rtx_equal_p (PATTERN (insn_last), pat))\n \treturn trial;\n+      split_insn_count++;\n       if (!NEXT_INSN (insn_last))\n \tbreak;\n       insn_last = NEXT_INSN (insn_last);\n     }\n \n+  /* We're not good at redistributing frame information if\n+     the split occurs before reload or if it results in more\n+     than one insn.  */\n+  if (RTX_FRAME_RELATED_P (trial))\n+    {\n+      if (!reload_completed || split_insn_count != 1)\n+        return trial;\n+\n+      rtx_insn *new_insn = seq;\n+      rtx_insn *old_insn = trial;\n+      copy_frame_info_to_split_insn (old_insn, new_insn);\n+    }\n+\n   /* We will be adding the new sequence to the function.  The splitters\n      may have introduced invalid RTL sharing, so unshare the sequence now.  */\n   unshare_all_rtl_in_chain (seq);"}, {"sha": "ce83b7f52183c503a015c06dcfb9d189cf22871c", "filename": "gcc/recog.c", "status": "modified", "additions": 73, "deletions": 61, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d55c6b81733335d81e35f7c0116bbdffccb682/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d55c6b81733335d81e35f7c0116bbdffccb682/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=e7d55c6b81733335d81e35f7c0116bbdffccb682", "patch": "@@ -3277,6 +3277,78 @@ peep2_reinit_state (regset live)\n   COPY_REG_SET (peep2_insn_data[MAX_INSNS_PER_PEEP2].live_before, live);\n }\n \n+/* Copies frame related info of an insn (OLD_INSN) to the single\n+   insn (NEW_INSN) that was obtained by splitting OLD_INSN.  */\n+\n+void\n+copy_frame_info_to_split_insn (rtx_insn *old_insn, rtx_insn *new_insn)\n+{\n+  bool any_note = false;\n+  rtx note;\n+\n+  if (!RTX_FRAME_RELATED_P (old_insn))\n+    return;\n+\n+  RTX_FRAME_RELATED_P (new_insn) = 1;\n+\n+  /* Allow the backend to fill in a note during the split.  */\n+  for (note = REG_NOTES (new_insn); note ; note = XEXP (note, 1))\n+    switch (REG_NOTE_KIND (note))\n+      {\n+      case REG_FRAME_RELATED_EXPR:\n+      case REG_CFA_DEF_CFA:\n+      case REG_CFA_ADJUST_CFA:\n+      case REG_CFA_OFFSET:\n+      case REG_CFA_REGISTER:\n+      case REG_CFA_EXPRESSION:\n+      case REG_CFA_RESTORE:\n+      case REG_CFA_SET_VDRAP:\n+        any_note = true;\n+        break;\n+      default:\n+        break;\n+      }\n+\n+  /* If the backend didn't supply a note, copy one over.  */\n+  if (!any_note)\n+    for (note = REG_NOTES (old_insn); note ; note = XEXP (note, 1))\n+      switch (REG_NOTE_KIND (note))\n+        {\n+        case REG_FRAME_RELATED_EXPR:\n+        case REG_CFA_DEF_CFA:\n+        case REG_CFA_ADJUST_CFA:\n+        case REG_CFA_OFFSET:\n+        case REG_CFA_REGISTER:\n+        case REG_CFA_EXPRESSION:\n+        case REG_CFA_RESTORE:\n+        case REG_CFA_SET_VDRAP:\n+          add_reg_note (new_insn, REG_NOTE_KIND (note), XEXP (note, 0));\n+          any_note = true;\n+          break;\n+        default:\n+          break;\n+        }\n+\n+  /* If there still isn't a note, make sure the unwind info sees the\n+     same expression as before the split.  */\n+  if (!any_note)\n+    {\n+      rtx old_set, new_set;\n+\n+      /* The old insn had better have been simple, or annotated.  */\n+      old_set = single_set (old_insn);\n+      gcc_assert (old_set != NULL);\n+\n+      new_set = single_set (new_insn);\n+      if (!new_set || !rtx_equal_p (new_set, old_set))\n+        add_reg_note (new_insn, REG_FRAME_RELATED_EXPR, old_set);\n+    }\n+\n+  /* Copy prologue/epilogue status.  This is required in order to keep\n+     proper placement of EPILOGUE_BEG and the DW_CFA_remember_state.  */\n+  maybe_copy_prologue_epilogue_insn (old_insn, new_insn);\n+}\n+\n /* While scanning basic block BB, we found a match of length MATCH_LEN,\n    starting at INSN.  Perform the replacement, removing the old insns and\n    replacing them with ATTEMPT.  Returns the last insn emitted, or NULL\n@@ -3297,9 +3369,6 @@ peep2_attempt (basic_block bb, rtx_insn *insn, int match_len, rtx_insn *attempt)\n   old_insn = peep2_insn_data[peep2_current].insn;\n   if (RTX_FRAME_RELATED_P (old_insn))\n     {\n-      bool any_note = false;\n-      rtx note;\n-\n       if (match_len != 0)\n \treturn NULL;\n \n@@ -3313,64 +3382,7 @@ peep2_attempt (basic_block bb, rtx_insn *insn, int match_len, rtx_insn *attempt)\n \treturn NULL;\n \n       /* We have a 1-1 replacement.  Copy over any frame-related info.  */\n-      RTX_FRAME_RELATED_P (new_insn) = 1;\n-\n-      /* Allow the backend to fill in a note during the split.  */\n-      for (note = REG_NOTES (new_insn); note ; note = XEXP (note, 1))\n-\tswitch (REG_NOTE_KIND (note))\n-\t  {\n-\t  case REG_FRAME_RELATED_EXPR:\n-\t  case REG_CFA_DEF_CFA:\n-\t  case REG_CFA_ADJUST_CFA:\n-\t  case REG_CFA_OFFSET:\n-\t  case REG_CFA_REGISTER:\n-\t  case REG_CFA_EXPRESSION:\n-\t  case REG_CFA_RESTORE:\n-\t  case REG_CFA_SET_VDRAP:\n-\t    any_note = true;\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-\n-      /* If the backend didn't supply a note, copy one over.  */\n-      if (!any_note)\n-        for (note = REG_NOTES (old_insn); note ; note = XEXP (note, 1))\n-\t  switch (REG_NOTE_KIND (note))\n-\t    {\n-\t    case REG_FRAME_RELATED_EXPR:\n-\t    case REG_CFA_DEF_CFA:\n-\t    case REG_CFA_ADJUST_CFA:\n-\t    case REG_CFA_OFFSET:\n-\t    case REG_CFA_REGISTER:\n-\t    case REG_CFA_EXPRESSION:\n-\t    case REG_CFA_RESTORE:\n-\t    case REG_CFA_SET_VDRAP:\n-\t      add_reg_note (new_insn, REG_NOTE_KIND (note), XEXP (note, 0));\n-\t      any_note = true;\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\n-      /* If there still isn't a note, make sure the unwind info sees the\n-\t same expression as before the split.  */\n-      if (!any_note)\n-\t{\n-\t  rtx old_set, new_set;\n-\n-\t  /* The old insn had better have been simple, or annotated.  */\n-\t  old_set = single_set (old_insn);\n-\t  gcc_assert (old_set != NULL);\n-\n-\t  new_set = single_set (new_insn);\n-\t  if (!new_set || !rtx_equal_p (new_set, old_set))\n-\t    add_reg_note (new_insn, REG_FRAME_RELATED_EXPR, old_set);\n-\t}\n-\n-      /* Copy prologue/epilogue status.  This is required in order to keep\n-\t proper placement of EPILOGUE_BEG and the DW_CFA_remember_state.  */\n-      maybe_copy_prologue_epilogue_insn (old_insn, new_insn);\n+      copy_frame_info_to_split_insn (old_insn, new_insn);\n     }\n \n   /* If we are splitting a CALL_INSN, look for the CALL_INSN"}, {"sha": "ae3675f5c82168791b6dbafc62d0296c281b8b03", "filename": "gcc/recog.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d55c6b81733335d81e35f7c0116bbdffccb682/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d55c6b81733335d81e35f7c0116bbdffccb682/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=e7d55c6b81733335d81e35f7c0116bbdffccb682", "patch": "@@ -150,6 +150,8 @@ extern rtx_insn *peephole2_insns (rtx, rtx_insn *, int *);\n extern int store_data_bypass_p (rtx_insn *, rtx_insn *);\n extern int if_test_bypass_p (rtx_insn *, rtx_insn *);\n \n+extern void copy_frame_info_to_split_insn (rtx_insn *, rtx_insn *);\n+\n #ifndef GENERATOR_FILE\n /* Try recognizing the instruction INSN,\n    and return the code number that results."}]}