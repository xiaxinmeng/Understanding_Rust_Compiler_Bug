{"sha": "a242b0831cacdde49bc174bbf188cfdc2777bf80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI0MmIwODMxY2FjZGRlNDliYzE3NGJiZjE4OGNmZGMyNzc3YmY4MA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2001-08-24T16:01:42Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-24T16:01:42Z"}, "message": "expmed.c: Default-#define HAVE_insv, HAVE_extv, and HAVE_extzv to zero.\n\n\t* expmed.c: Default-#define HAVE_insv, HAVE_extv, and HAVE_extzv\n\tto zero.\n\t(mode_for_extraction): No need for #ifdefs.  Add default-case abort\n\tto switch.\n\t(store_bit_field): Eliminate insv_bitsize variable.  Put HAVE_insv\n\tin if controlling use of insv.\n\t(extract_bit_field): Likewise, for extv and extzv.\n\nFrom-SVN: r45150", "tree": {"sha": "33a603de13883851b6faaf26026a8ea091b5422d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33a603de13883851b6faaf26026a8ea091b5422d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a242b0831cacdde49bc174bbf188cfdc2777bf80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a242b0831cacdde49bc174bbf188cfdc2777bf80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a242b0831cacdde49bc174bbf188cfdc2777bf80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a242b0831cacdde49bc174bbf188cfdc2777bf80/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "653753c5e73991a3bb3811f3a380f628a28de5da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653753c5e73991a3bb3811f3a380f628a28de5da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/653753c5e73991a3bb3811f3a380f628a28de5da"}], "stats": {"total": 61, "additions": 28, "deletions": 33}, "files": [{"sha": "b4010931cdf08d553105f32fbeaf95ee6aff91f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a242b0831cacdde49bc174bbf188cfdc2777bf80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a242b0831cacdde49bc174bbf188cfdc2777bf80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a242b0831cacdde49bc174bbf188cfdc2777bf80", "patch": "@@ -1,3 +1,13 @@\n+2001-08-24  Zack Weinberg  <zackw@panix.com>\n+\n+\t* expmed.c: Default-#define HAVE_insv, HAVE_extv, and HAVE_extzv\n+\tto zero.\n+\t(mode_for_extraction): No need for #ifdefs.  Add default-case abort\n+\tto switch.\n+\t(store_bit_field): Eliminate insv_bitsize variable.  Put HAVE_insv\n+\tin if controlling use of insv.\n+\t(extract_bit_field): Likewise, for extv and extzv.\n+\n Fri Aug 24 17:27:46 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (movcc peep2): Fix load of 0."}, {"sha": "7cbc8573f7d681b17ce02072f96d6ae7c5de6922", "filename": "gcc/expmed.c", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a242b0831cacdde49bc174bbf188cfdc2777bf80/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a242b0831cacdde49bc174bbf188cfdc2777bf80/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a242b0831cacdde49bc174bbf188cfdc2777bf80", "patch": "@@ -77,14 +77,17 @@ static int sdiv_pow2_cheap, smod_pow2_cheap;\n \n /* Reduce conditional compilation elsewhere.  */\n #ifndef HAVE_insv\n+#define HAVE_insv\t0\n #define CODE_FOR_insv\tCODE_FOR_nothing\n #define gen_insv(a,b,c,d) NULL_RTX\n #endif\n #ifndef HAVE_extv\n+#define HAVE_extv\t0\n #define CODE_FOR_extv\tCODE_FOR_nothing\n #define gen_extv(a,b,c,d) NULL_RTX\n #endif\n #ifndef HAVE_extzv\n+#define HAVE_extzv\t0\n #define CODE_FOR_extzv\tCODE_FOR_nothing\n #define gen_extzv(a,b,c,d) NULL_RTX\n #endif\n@@ -232,34 +235,31 @@ mode_for_extraction (pattern, opno)\n   switch (pattern)\n     {\n     case EP_insv:\n-#ifdef HAVE_insv\n       if (HAVE_insv)\n \t{\n \t  data = &insn_data[CODE_FOR_insv];\n \t  break;\n \t}\n-#endif\n       return MAX_MACHINE_MODE;\n \n     case EP_extv:\n-#ifdef HAVE_extv\n       if (HAVE_extv)\n \t{\n \t  data = &insn_data[CODE_FOR_extv];\n \t  break;\n \t}\n-#endif\n       return MAX_MACHINE_MODE;\n \n     case EP_extzv:\n-#ifdef HAVE_extzv\n       if (HAVE_extzv)\n \t{\n \t  data = &insn_data[CODE_FOR_extzv];\n \t  break;\n \t}\n-#endif\n       return MAX_MACHINE_MODE;\n+\n+    default:\n+      abort ();\n     }\n \n   if (opno == -1)\n@@ -304,12 +304,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   unsigned HOST_WIDE_INT bitpos = bitnum % unit;\n   register rtx op0 = str_rtx;\n \n-  unsigned HOST_WIDE_INT insv_bitsize;\n-  enum machine_mode op_mode;\n-\n-  op_mode = mode_for_extraction (EP_insv, 3);\n-  if (op_mode != MAX_MACHINE_MODE)\n-    insv_bitsize = GET_MODE_BITSIZE (op_mode);\n+  enum machine_mode op_mode = mode_for_extraction (EP_insv, 3);\n \n   /* It is wrong to have align==0, since every object is aligned at\n      least at a bit boundary.  This usually means a bug elsewhere.  */\n@@ -542,13 +537,13 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   /* Now OFFSET is nonzero only if OP0 is memory\n      and is therefore always measured in bytes.  */\n \n-  if (op_mode != MAX_MACHINE_MODE\n+  if (HAVE_insv\n       && GET_MODE (value) != BLKmode\n       && !(bitsize == 1 && GET_CODE (value) == CONST_INT)\n       /* Ensure insv's size is wide enough for this field.  */\n-      && (insv_bitsize >= bitsize)\n+      && (GET_MODE_BITSIZE (op_mode) >= bitsize)\n       && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n-\t    && (bitsize + bitpos > insv_bitsize)))\n+\t    && (bitsize + bitpos > GET_MODE_BITSIZE (op_mode))))\n     {\n       int xbitpos = bitpos;\n       rtx value1;\n@@ -1042,18 +1037,8 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n   enum machine_mode int_mode;\n-  unsigned HOST_WIDE_INT extv_bitsize;\n-  enum machine_mode extv_mode;\n-  unsigned HOST_WIDE_INT extzv_bitsize;\n-  enum machine_mode extzv_mode;\n-\n-  extv_mode = mode_for_extraction (EP_extv, 0);\n-  if (extv_mode != MAX_MACHINE_MODE)\n-    extv_bitsize = GET_MODE_BITSIZE (extv_mode);\n-\n-  extzv_mode = mode_for_extraction (EP_extzv, 0);\n-  if (extzv_mode != MAX_MACHINE_MODE)\n-    extzv_bitsize = GET_MODE_BITSIZE (extzv_mode);\n+  enum machine_mode extv_mode = mode_for_extraction (EP_extv, 0);\n+  enum machine_mode extzv_mode = mode_for_extraction (EP_extzv, 0);\n \n   /* Discount the part of the structure before the desired byte.\n      We need to know how many bytes are safe to reference after it.  */\n@@ -1287,10 +1272,10 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n   if (unsignedp)\n     {\n-      if (extzv_mode != MAX_MACHINE_MODE\n-\t  && (extzv_bitsize >= bitsize)\n+      if (HAVE_extzv\n+\t  && (GET_MODE_BITSIZE (extzv_mode) >= bitsize)\n \t  && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n-\t\t&& (bitsize + bitpos > extzv_bitsize)))\n+\t\t&& (bitsize + bitpos > GET_MODE_BITSIZE (extzv_mode))))\n \t{\n \t  unsigned HOST_WIDE_INT xbitpos = bitpos, xoffset = offset;\n \t  rtx bitsize_rtx, bitpos_rtx;\n@@ -1420,10 +1405,10 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n     }\n   else\n     {\n-      if (extv_mode != MAX_MACHINE_MODE\n-\t  && (extv_bitsize >= bitsize)\n+      if (HAVE_extv\n+\t  && (GET_MODE_BITSIZE (extv_mode) >= bitsize)\n \t  && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n-\t\t&& (bitsize + bitpos > extv_bitsize)))\n+\t\t&& (bitsize + bitpos > GET_MODE_BITSIZE (extv_mode))))\n \t{\n \t  int xbitpos = bitpos, xoffset = offset;\n \t  rtx bitsize_rtx, bitpos_rtx;"}]}