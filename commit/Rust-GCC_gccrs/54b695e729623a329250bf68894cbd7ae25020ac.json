{"sha": "54b695e729623a329250bf68894cbd7ae25020ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRiNjk1ZTcyOTYyM2EzMjkyNTBiZjY4ODk0Y2JkN2FlMjUwMjBhYw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2005-01-14T21:22:14Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2005-01-14T21:22:14Z"}, "message": "rs6000.h (CLASS_MAX_NREGS): DF goes in 1 register on e500v2.\n\n\t* config/rs6000/rs6000.h (CLASS_MAX_NREGS): DF goes in 1 register\n\ton e500v2.\n\t(CANNOT_CHANGE_MODE_CLASS): Restrict DI mode changes on e500v2.\n\t(PREDICATE_CODES): Add rs6k_nonimmediate_operand.\n\n\t* config/rs6000/rs6000.c (invalid_e500_subreg): New.\n\t(rs6k_nonimmediate_operand): New.\n\t(rs6000_legitimate_offset_address_p): Handle DI modes on e500v2\n\tcorrectly.\n\t(legitimate_lo_sum_address_p): Same.\n\t(rs6000_legitimize_address): Same.\n\t(rs6000_legitimize_reload_address): Same.\n\t(rs6000_legitimate_address): Same.\n\t(spe_build_register_parallel): Pass DF and DC modes in a DI\n\tregister.\n\n\t* config/rs6000/rs6000.md (\"*movsi_internal1\"): Change predicate\n\tto rs6k_nonimmediate_operand.\n\n\t* config/rs6000/spe.md (\"*frob_df_di\"): New.\n\t(\"*frob_di_df\"): New.\n\t(\"*frob_di_df_2\"): New.\n\t(\"*mov_sidf_e500_subreg0\"): New.\n\t(\"*mov_sidf_e500_subreg4\"): New.\n\t(\"*movdf_e500_double\"): Change predicate to\n\trs6k_nonimmediate_operand.\n\nFrom-SVN: r93665", "tree": {"sha": "44ec03ace9a33d611bf37e4c25c9c7ffad7a7728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44ec03ace9a33d611bf37e4c25c9c7ffad7a7728"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54b695e729623a329250bf68894cbd7ae25020ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54b695e729623a329250bf68894cbd7ae25020ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54b695e729623a329250bf68894cbd7ae25020ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54b695e729623a329250bf68894cbd7ae25020ac/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd3395a50bf61702cce7c573f02caebbfd536fc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd3395a50bf61702cce7c573f02caebbfd536fc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd3395a50bf61702cce7c573f02caebbfd536fc2"}], "stats": {"total": 162, "additions": 137, "deletions": 25}, "files": [{"sha": "53e9844f42894918fc8a4e243b55d3225b6536bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54b695e729623a329250bf68894cbd7ae25020ac", "patch": "@@ -1,3 +1,32 @@\n+2005-01-14  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* config/rs6000/rs6000.h (CLASS_MAX_NREGS): DF goes in 1 register\n+\ton e500v2.\n+\t(CANNOT_CHANGE_MODE_CLASS): Restrict DI mode changes on e500v2.\n+\t(PREDICATE_CODES): Add rs6k_nonimmediate_operand.\n+\n+\t* config/rs6000/rs6000.c (invalid_e500_subreg): New.\n+\t(rs6k_nonimmediate_operand): New.\n+\t(rs6000_legitimate_offset_address_p): Handle DI modes on e500v2\n+\tcorrectly.\n+\t(legitimate_lo_sum_address_p): Same.\n+\t(rs6000_legitimize_address): Same.\n+\t(rs6000_legitimize_reload_address): Same.\n+\t(rs6000_legitimate_address): Same.\n+\t(spe_build_register_parallel): Pass DF and DC modes in a DI\n+\tregister.\n+\n+\t* config/rs6000/rs6000.md (\"*movsi_internal1\"): Change predicate\n+\tto rs6k_nonimmediate_operand.\n+\n+\t* config/rs6000/spe.md (\"*frob_df_di\"): New.\n+\t(\"*frob_di_df\"): New.\n+\t(\"*frob_di_df_2\"): New.\n+\t(\"*mov_sidf_e500_subreg0\"): New.\n+\t(\"*mov_sidf_e500_subreg4\"): New.\n+\t(\"*movdf_e500_double\"): Change predicate to\n+\trs6k_nonimmediate_operand.\n+\n 2005-01-14  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* postreload.c (move2add_note_store): Only call"}, {"sha": "a8586a63aa34432db1fa772e5f56335e4ee7aed0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=54b695e729623a329250bf68894cbd7ae25020ac", "patch": "@@ -710,6 +710,7 @@ static rtx spe_expand_builtin (tree, rtx, bool *);\n static rtx spe_expand_stv_builtin (enum insn_code, tree);\n static rtx spe_expand_predicate_builtin (enum insn_code, tree, rtx);\n static rtx spe_expand_evsel_builtin (enum insn_code, tree, rtx);\n+static bool invalid_e500_subreg (rtx, enum machine_mode);\n static int rs6000_emit_int_cmove (rtx, rtx, rtx, rtx);\n static rs6000_stack_t *rs6000_stack_info (void);\n static void debug_stack_info (rs6000_stack_t *);\n@@ -3035,6 +3036,39 @@ input_operand (rtx op, enum machine_mode mode)\n   return 0;\n }\n \n+/* Return TRUE if OP is an invalid SUBREG operation on the e500.  */\n+static bool\n+invalid_e500_subreg (rtx op, enum machine_mode mode)\n+{\n+  /* Reject (subreg:SI (reg:DF)).  */\n+  if (GET_CODE (op) == SUBREG\n+      && mode == SImode\n+      && REG_P (SUBREG_REG (op))\n+      && GET_MODE (SUBREG_REG (op)) == DFmode)\n+    return true;\n+\n+  /* Reject (subreg:DF (reg:DI)).  */\n+  if (GET_CODE (op) == SUBREG\n+      && mode == DFmode\n+      && REG_P (SUBREG_REG (op))\n+      && GET_MODE (SUBREG_REG (op)) == DImode)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Just like nonimmediate_operand, but return 0 for invalid SUBREG's\n+   on the e500.  */\n+int\n+rs6k_nonimmediate_operand (rtx op, enum machine_mode mode)\n+{\n+  if (TARGET_E500_DOUBLE\n+      && GET_CODE (op) == SUBREG\n+      && invalid_e500_subreg (op, mode))\n+    return 0;\n+\n+  return nonimmediate_operand (op, mode);\n+}\n \n /* Darwin, AIX increases natural record alignment to doubleword if the first\n    field is an FP double while the FP fields remain word aligned.  */\n@@ -3248,6 +3282,14 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n \treturn SPE_CONST_OFFSET_OK (offset);\n \n     case DImode:\n+      /* On e500v2, we may have:\n+\n+\t   (subreg:DF (mem:DI (plus (reg) (const_int))) 0).\n+\n+         Which gets addressed with evldd instructions.  */\n+      if (TARGET_E500_DOUBLE)\n+\treturn SPE_CONST_OFFSET_OK (offset);\n+\n       if (mode == DFmode || !TARGET_POWERPC64)\n \textra = 4;\n       else if (offset & 3)\n@@ -3326,7 +3368,8 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n     return false;\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n-  if (TARGET_E500_DOUBLE && mode == DFmode)\n+  /* Restrict addressing for DI because of our SUBREG hackery.  */\n+  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == DImode))\n     return false;\n   x = XEXP (x, 1);\n \n@@ -3403,7 +3446,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t       || TARGET_POWERPC64\n-\t       || ((mode != DFmode || TARGET_E500_DOUBLE) && mode != TFmode))\n+\t       || (((mode != DImode && mode != DFmode) || TARGET_E500_DOUBLE)\n+\t\t   && mode != TFmode))\n \t   && (TARGET_POWERPC64 || mode != DImode)\n \t   && mode != TImode)\n     {\n@@ -3423,8 +3467,11 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return reg;\n     }\n   else if (SPE_VECTOR_MODE (mode)\n-\t   || (TARGET_E500_DOUBLE && mode == DFmode))\n+\t   || (TARGET_E500_DOUBLE && (mode == DFmode\n+\t\t\t\t      || mode == DImode)))\n     {\n+      if (mode == DImode)\n+\treturn NULL_RTX;\n       /* We accept [reg + reg] and [reg + OFFSET].  */\n \n       if (GET_CODE (x) == PLUS)\n@@ -3834,7 +3881,8 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && REG_MODE_OK_FOR_BASE_P (XEXP (x, 0), mode)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && !SPE_VECTOR_MODE (mode)\n-      && !(TARGET_E500_DOUBLE && mode == DFmode)\n+      && !(TARGET_E500_DOUBLE && (mode == DFmode\n+\t\t\t\t  || mode == DImode))\n       && !ALTIVEC_VECTOR_MODE (mode))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n@@ -3942,7 +3990,8 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n   if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n       && !ALTIVEC_VECTOR_MODE (mode)\n       && !SPE_VECTOR_MODE (mode)\n-      && !(TARGET_E500_DOUBLE && mode == DFmode)\n+      /* Restrict addressing for DI because of our SUBREG hackery.  */\n+      && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == DImode))\n       && TARGET_UPDATE\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n@@ -5084,31 +5133,23 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n static rtx\n spe_build_register_parallel (enum machine_mode mode, int gregno)\n {\n-  rtx r1, r2, r3, r4;\n-  enum machine_mode inner = SImode;\n+  rtx r1, r3;\n \n   if (mode == DFmode)\n     {\n-      r1 = gen_rtx_REG (inner, gregno);\n-      r1 = gen_rtx_EXPR_LIST (SImode, r1, const0_rtx);\n-      r2 = gen_rtx_REG (inner, gregno + 1);\n-      r2 = gen_rtx_EXPR_LIST (SImode, r2, GEN_INT (4));\n-      return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r2));\n+      r1 = gen_rtx_REG (DImode, gregno);\n+      r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n+      return gen_rtx_PARALLEL (mode, gen_rtvec (1, r1));\n     }\n   else if (mode == DCmode)\n     {\n-      r1 = gen_rtx_REG (inner, gregno);\n-      r1 = gen_rtx_EXPR_LIST (SImode, r1, const0_rtx);\n-      r2 = gen_rtx_REG (inner, gregno + 1);\n-      r2 = gen_rtx_EXPR_LIST (SImode, r2, GEN_INT (4));\n-      r3 = gen_rtx_REG (inner, gregno + 2);\n-      r3 = gen_rtx_EXPR_LIST (SImode, r3, GEN_INT (8));\n-      r4 = gen_rtx_REG (inner, gregno + 3);\n-      r4 = gen_rtx_EXPR_LIST (SImode, r4, GEN_INT (12));\n-      return gen_rtx_PARALLEL (mode, gen_rtvec (4, r1, r2, r3, r4));\n+      r1 = gen_rtx_REG (DImode, gregno);\n+      r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n+      r3 = gen_rtx_REG (DImode, gregno + 2);\n+      r3 = gen_rtx_EXPR_LIST (VOIDmode, r3, GEN_INT (8));\n+      return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r3));\n     }\n-\n-  abort ();\n+  abort();\n   return NULL_RTX;\n }\n "}, {"sha": "215fdcdab2027487854ecb73954366b0b3247541", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=54b695e729623a329250bf68894cbd7ae25020ac", "patch": "@@ -1429,6 +1429,8 @@ enum reg_class\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n  (((CLASS) == FLOAT_REGS) \t\t\t\t\t\t\\\n   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n+  : (TARGET_E500_DOUBLE && (CLASS) == GENERAL_REGS && (MODE) == DFmode) \\\n+  ? 1                                                                   \\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n \n@@ -1442,6 +1444,8 @@ enum reg_class\n    ? reg_classes_intersect_p (FLOAT_REGS, CLASS)\t\t\t  \\\n    : (TARGET_E500_DOUBLE && (((TO) == DFmode) + ((FROM) == DFmode)) == 1) \\\n    ? reg_classes_intersect_p (GENERAL_REGS, CLASS)\t\t\t  \\\n+   : (TARGET_E500_DOUBLE && (((TO) == DImode) + ((FROM) == DImode)) == 1) \\\n+   ? reg_classes_intersect_p (GENERAL_REGS, CLASS)\t\t\t  \\\n    : (TARGET_SPE && (SPE_VECTOR_MODE (FROM) + SPE_VECTOR_MODE (TO)) == 1) \\\n    ? reg_classes_intersect_p (GENERAL_REGS, CLASS)\t\t\t  \\\n    : 0)\n@@ -2588,6 +2592,7 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\t   \\\n   {\"input_operand\", {SUBREG, MEM, REG, CONST_INT,\t\t\t   \\\n \t\t     CONST_DOUBLE, SYMBOL_REF}},\t\t\t   \\\n+  {\"rs6k_nonimmediate_operand\", {SUBREG, MEM, REG}},\t\t   \t   \\\n   {\"load_multiple_operation\", {PARALLEL}},\t\t\t\t   \\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t   \\\n   {\"lmw_operation\", {PARALLEL}},\t\t\t\t\t   \\"}, {"sha": "890088e33857baa3e1f9fd113870f3d11881bf25", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=54b695e729623a329250bf68894cbd7ae25020ac", "patch": "@@ -7709,7 +7709,7 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*movsi_internal1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,r,*q,*c*l,*h,*h\")\n+  [(set (match_operand:SI 0 \"rs6k_nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,r,*q,*c*l,*h,*h\")\n \t(match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,R,*h,r,r,r,0\"))]\n   \"gpc_reg_operand (operands[0], SImode)\n    || gpc_reg_operand (operands[1], SImode)\""}, {"sha": "c43adcb85f977888c5829332dc256ea5cd1a3b90", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b695e729623a329250bf68894cbd7ae25020ac/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=54b695e729623a329250bf68894cbd7ae25020ac", "patch": "@@ -2192,8 +2192,45 @@\n    (set_attr  \"length\" \"4\")])\n \n ;; Double-precision floating point instructions.\n+\n+;; FIXME: Add o=r option.\n+(define_insn \"*frob_df_di\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r\")\n+        (subreg:DF (match_operand:DI 1 \"input_operand\" \"r,m\") 0))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"@\n+   evmergelo %0,%H1,%L1\n+   evldd%X1 %0,%y1\")\n+\n+(define_insn \"*frob_di_df\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r\")\n+        (subreg:DI (match_operand:DF 1 \"input_operand\" \"r\") 0))]\n+  \"TARGET_E500_DOUBLE\" /*one of these can be an mr */\n+  \"evmergehi %H0,%1,%1\\;evmergelo %L0,%1,%1\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"*frob_di_df_2\"\n+  [(set (subreg:DF (match_operand:DI 0 \"register_operand\" \"=&r\") 0)\n+\t(match_operand:DF 1 \"register_operand\" \"r\"))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"evmergehi %H0,%1,%1\\;evmergelo %L0,%1,%1\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"*mov_sidf_e500_subreg0\"\n+  [(set (subreg:SI (match_operand:DF 0 \"register_operand\" \"+r\") 0)\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"evmergelo %0,%1,%0\")\n+\n+(define_insn \"*mov_sidf_e500_subreg4\"\n+  [(set (subreg:SI (match_operand:DF 0 \"register_operand\" \"+r\") 4)\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"mr %0,%1\")\n+\n+;; FIXME: Allow r=CONST0.\n (define_insn \"*movdf_e500_double\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+  [(set (match_operand:DF 0 \"rs6k_nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:DF 1 \"input_operand\" \"r,m,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\n     && (gpc_reg_operand (operands[0], DFmode)"}]}