{"sha": "f7d11ebda135b0cac3e37ebe53faa47276a541c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdkMTFlYmRhMTM1YjBjYWMzZTM3ZWJlNTNmYWE0NzI3NmE1NDFjMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-10-24T17:45:23Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-10-24T17:45:23Z"}, "message": "Primes.java: Removed.\n\n\t* libjava.lang/Primes.java: Removed.\n\t* libjava.lang/Primes.out: Removed.\n\nFrom-SVN: r58498", "tree": {"sha": "2c43573d01080f6b9f2746628443c21082934271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c43573d01080f6b9f2746628443c21082934271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7d11ebda135b0cac3e37ebe53faa47276a541c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d11ebda135b0cac3e37ebe53faa47276a541c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d11ebda135b0cac3e37ebe53faa47276a541c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d11ebda135b0cac3e37ebe53faa47276a541c0/comments", "author": null, "committer": null, "parents": [{"sha": "862a2d830eae90c2439f45a2b16c29f7e7150746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862a2d830eae90c2439f45a2b16c29f7e7150746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862a2d830eae90c2439f45a2b16c29f7e7150746"}], "stats": {"total": 269, "additions": 5, "deletions": 264}, "files": [{"sha": "18cfe853c8a8fab052aa0698cc82a73a17763d29", "filename": "libjava/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d11ebda135b0cac3e37ebe53faa47276a541c0/libjava%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d11ebda135b0cac3e37ebe53faa47276a541c0/libjava%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FChangeLog?ref=f7d11ebda135b0cac3e37ebe53faa47276a541c0", "patch": "@@ -1,3 +1,8 @@\n+2002-10-24  Tom Tromey  <tromey@redhat.com>\n+\n+\t* libjava.lang/Primes.java: Removed.\n+\t* libjava.lang/Primes.out: Removed.\n+\n 2002-10-23  Tom Tromey  <tromey@redhat.com>\n \n \tFor PR java/6388:"}, {"sha": "d6e4336726a4c10aa4173a22ed859789c7173b22", "filename": "libjava/testsuite/libjava.lang/Primes.java", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862a2d830eae90c2439f45a2b16c29f7e7150746/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862a2d830eae90c2439f45a2b16c29f7e7150746/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.java?ref=862a2d830eae90c2439f45a2b16c29f7e7150746", "patch": "@@ -1,213 +0,0 @@\n-// Primes.java\r\n-\r\n-/** Copyright 1998\r\n- * Roedy Green\r\n- * Canadian Mind Products\r\n- * 5317 Barker Avenue\r\n- * Burnaby, BC Canada V5H 2N6\r\n- * tel: (604) 435-3016\r\n- * mailto:roedy@mindprod.com\r\n- * http://mindprod.com\r\n- */\r\n-// May be freely distributed for any purpose but military\r\n-\r\n-import java.util.BitSet;\r\n-\r\n-/**\r\n-  * @author Roedy Green\r\n-  * @version 1.10 1998 November 10\r\n-  * Calculate primes using Eratostheses Sieve.\r\n-  * Tell if a given number is prime.\r\n-  * Find a prime just below a given number.\r\n-  * Find a prime just above a given number.\r\n-  */\r\n-  \r\n-/* \r\n- * version 1.1 1998 November 10 - new address and phone.  \r\n- */\r\n-class Primes\r\n-    {\r\n-\r\n-    /**\r\n-      * constructors\r\n-      */\r\n-    Primes()\r\n-        {\r\n-        ensureCapacity(1000);\r\n-        }\r\n-\r\n-    /**\r\n-      * @param capacity - largest number you will be asking if prime.\r\n-      * If give too small a number, it will automatically grow by\r\n-      * recomputing the sieve array.\r\n-      */\r\n-    Primes (int capacity)\r\n-        {\r\n-        ensureCapacity(capacity);\r\n-        }\r\n-\r\n-    /**\r\n-      * @param candidate - is this a prime?\r\n-      */\r\n-    public boolean isPrime(int candidate)\r\n-        {\r\n-        ensureCapacity(candidate);\r\n-        if (candidate < 3) return candidate != 0;\r\n-        if (candidate % 2 == 0 ) return false;\r\n-        return !b.get(candidate/2);\r\n-        }\r\n-\r\n-    /**\r\n-      * @return first prime higher than candidate\r\n-      */\r\n-    public int above(int candidate)\r\n-    {\r\n-        do\r\n-            {\r\n-            // see what we can find in the existing sieve\r\n-            for (int i=candidate+1; i<= sieveCapacity; i++)\r\n-                {\r\n-                if (isPrime(i)) return i;\r\n-                }\r\n-            // Keep building ever bigger sieves till we succeed.\r\n-            // The next prime P' is between P+2 and P^2 - 2.\r\n-            // However that is a rather pessimistic upper bound.\r\n-            // Ideally some theorem would tell us how big we need to build\r\n-            // to find one.\r\n-            ensureCapacity(Math.max(candidate*2, sieveCapacity*2));\r\n-            } // end do\r\n-        while (true);\r\n-        } // end above\r\n-\r\n-    /**\r\n-      * @param return first prime less than candidate\r\n-      */\r\n-    public int below (int candidate)\r\n-    {\r\n-        for (candidate--; candidate > 0; candidate--)\r\n-            {\r\n-            if (isPrime(candidate)) return candidate;\r\n-            }\r\n-        // candidate was 1 or 0 or -ve\r\n-        return 0;\r\n-        }\r\n-\r\n-    /**\r\n-      * calc all primes in the range 1..n,\r\n-      * not the first n primes.\r\n-      * @param n, highest candidate, not necessarily prime.\r\n-      * @return list of primes 1..n in an array\r\n-      */\r\n-    public final int[] getPrimes(int n)\r\n-        {\r\n-        // calculate the primes\r\n-        ensureCapacity(n);\r\n-\r\n-        // pass 1: count primes\r\n-        int countPrimes = 0;\r\n-        for (int i = 0; i <= n; i++)\r\n-            {\r\n-            if (isPrime(i)) countPrimes++;\r\n-            }\r\n-\r\n-        // pass 2: construct array of primes\r\n-        int [] primes = new int[countPrimes];\r\n-        countPrimes = 0;\r\n-        for (int i = 0; i <= n; i++)\r\n-            {\r\n-            if (isPrime(i)) primes[countPrimes++] = i;\r\n-            }\r\n-        return primes;\r\n-        } // end getPrimes\r\n-\r\n-    /**\r\n-      * calculate the sieve, bit map of all primes 0..n\r\n-      * @param n highest number evalutated by the sieve, not necessarily prime.\r\n-      */\r\n-    private final void sieve ( int n )\r\n-        {\r\n-        // Presume BitSet b set is big enough for our purposes.\r\n-        // Presume all even numbers are already marked composite, effectively.\r\n-        // Presume all odd numbers are already marked prime (0 in bit map).\r\n-        int last = (int)(Math.sqrt(n))+1;\r\n-        for (int candidate = 3; candidate <= last; candidate += 2)\r\n-            {\r\n-            // only look at odd numbers\r\n-            if (!b.get(candidate/2) /* if candidate is prime */)\r\n-                {\r\n-                // Our candidate is prime.\r\n-                // Only bother to mark multiples of primes. Others already done.\r\n-                // no need to mark even multiples, already done\r\n-                int incr = candidate*2;\r\n-                for ( int multiple = candidate + incr; multiple < n; multiple += incr)\r\n-                    {\r\n-                    b.set(multiple/2); // mark multiple as composite\r\n-                    } // end for multiple\r\n-                } // end if\r\n-            } // end for candidate\r\n-        // at this point our sieve b is correct, except for 0..2\r\n-        } // end sieve\r\n-\r\n-    /**\r\n-      * Ensure have a sieve to tackle primes as big as n.\r\n-      * If we don't allocate a sieve big enough and calculate it.\r\n-      * @param n - ensure sieve big enough to evaluate n for primality.\r\n-      */\r\n-    private void ensureCapacity (int n)\r\n-        {\r\n-        if ( n > sieveCapacity )\r\n-            {\r\n-            b = new BitSet((n+1)/2);\r\n-            // starts out all 0, presume all numbers prime\r\n-            sieveCapacity = n;\r\n-            sieve(n);\r\n-            }\r\n-        // otherwise existing sieve is fine\r\n-        } // end ensureCapacity\r\n-\r\n-    private int sieveCapacity;\r\n-    // biggest number we have computed in our sieve.\r\n-    // our BitSet array is indexed 0..N (odd only)\r\n-\r\n-    private BitSet b; /* true for each odd number if is composite */\r\n-\r\n-    /**\r\n-      * Demonstrate and test the methods\r\n-      */\r\n-    public static void main (String[] args)\r\n-        {\r\n-        // print primes 1..101\r\n-        Primes calc = new Primes(106);\r\n-        int[] primes = calc.getPrimes(101);\r\n-        for (int i=0; i<primes.length; i++)\r\n-            {\r\n-            System.out.println(primes[i]);\r\n-            }\r\n-\r\n-        // demonstrate isPrime, above, below\r\n-        System.out.println(calc.isPrime(149));\r\n-        System.out.println(calc.below(149));\r\n-        System.out.println(calc.above(149));\r\n-\r\n-        // print all the primes just greater than powers of 2\r\n-        calc = new Primes(10000000);\r\n-        for (int pow=8; pow < 10000000; pow*=2)\r\n-            System.out.println(calc.above(pow));\r\n-\r\n-        // Validate that isPrime works by comparing it with brute force\r\n-        for (int i=3; i<=151; i++)\r\n-            {\r\n-            boolean prime = true;\r\n-            for (int j=2; j<i; j++)\r\n-                {\r\n-                if (i % j == 0 )\r\n-                    {\r\n-                    prime = false;\r\n-                    break;\r\n-                    }\r\n-                } // end for j\r\n-            if ( calc.isPrime(i) != prime ) System.out.println(i + \" oops\");\r\n-            } // end for i\r\n-\r\n-        } // end main\r\n-} // end Primes\r"}, {"sha": "279398b6233bb897ede4744beb625285482e870c", "filename": "libjava/testsuite/libjava.lang/Primes.out", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862a2d830eae90c2439f45a2b16c29f7e7150746/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862a2d830eae90c2439f45a2b16c29f7e7150746/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.out?ref=862a2d830eae90c2439f45a2b16c29f7e7150746", "patch": "@@ -1,51 +0,0 @@\n-1\n-2\n-3\n-5\n-7\n-11\n-13\n-17\n-19\n-23\n-29\n-31\n-37\n-41\n-43\n-47\n-53\n-59\n-61\n-67\n-71\n-73\n-79\n-83\n-89\n-97\n-101\n-true\n-139\n-151\n-11\n-17\n-37\n-67\n-131\n-257\n-521\n-1031\n-2053\n-4099\n-8209\n-16411\n-32771\n-65537\n-131101\n-262147\n-524309\n-1048583\n-2097169\n-4194319\n-8388617"}]}