{"sha": "322913f8769f6c7cac6a992debb430757e0e0c05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIyOTEzZjg3NjlmNmM3Y2FjNmE5OTJkZWJiNDMwNzU3ZTBlMGMwNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-02-19T14:45:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-02-19T14:45:16Z"}, "message": "expr.c (expand_expr_real_1): For a bit-field destination type...\n\n\t* expr.c (expand_expr_real_1) <case VIEW_CONVERT_EXPR>: For a bit-field\n\tdestination type, extract only the valid bits if the source type is not\n\tintegral and has a different mode.\n\nFrom-SVN: r207902", "tree": {"sha": "ac0e212d9e729fb65c18549463678f0d9037031a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac0e212d9e729fb65c18549463678f0d9037031a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/322913f8769f6c7cac6a992debb430757e0e0c05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/322913f8769f6c7cac6a992debb430757e0e0c05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/322913f8769f6c7cac6a992debb430757e0e0c05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/322913f8769f6c7cac6a992debb430757e0e0c05/comments", "author": null, "committer": null, "parents": [{"sha": "ffdeb7023fb9bff52a925e785715b9d24a2484dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffdeb7023fb9bff52a925e785715b9d24a2484dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffdeb7023fb9bff52a925e785715b9d24a2484dd"}], "stats": {"total": 66, "additions": 62, "deletions": 4}, "files": [{"sha": "eca2f7a780bf8cd53ce88b7505080cc2f58843c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322913f8769f6c7cac6a992debb430757e0e0c05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322913f8769f6c7cac6a992debb430757e0e0c05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=322913f8769f6c7cac6a992debb430757e0e0c05", "patch": "@@ -1,3 +1,9 @@\n+2014-02-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.c (expand_expr_real_1) <case VIEW_CONVERT_EXPR>: For a bit-field\n+\tdestination type, extract only the valid bits if the source type is not\n+\tintegral and has a different mode.\n+\n 2014-02-19  Richard Biener  <rguenther@suse.de>\n \n \tPR ipa/60243"}, {"sha": "be62c539e25d62eba0f708b0f3a5f48a6731ae64", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322913f8769f6c7cac6a992debb430757e0e0c05/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322913f8769f6c7cac6a992debb430757e0e0c05/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=322913f8769f6c7cac6a992debb430757e0e0c05", "patch": "@@ -10436,6 +10436,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       else if (INTEGRAL_TYPE_P (type) && INTEGRAL_TYPE_P (TREE_TYPE (treeop0)))\n \top0 = convert_modes (mode, GET_MODE (op0), op0,\n \t\t\t     TYPE_UNSIGNED (TREE_TYPE (treeop0)));\n+      /* If the output type is a bit-field type, do an extraction.  */\n+      else if (reduce_bit_field)\n+\treturn extract_bit_field (op0, TYPE_PRECISION (type), 0,\n+\t\t\t\t  TYPE_UNSIGNED (type), NULL_RTX,\n+\t\t\t\t  mode, mode);\n       /* As a last resort, spill op0 to memory, and reload it in a\n \t different mode.  */\n       else if (!MEM_P (op0))\n@@ -10458,10 +10463,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  op0 = target;\n \t}\n \n-      /* At this point, OP0 is in the correct mode.  If the output type is\n-\t such that the operand is known to be aligned, indicate that it is.\n-\t Otherwise, we need only be concerned about alignment for non-BLKmode\n-\t results.  */\n+      /* If OP0 is (now) a MEM, we need to deal with alignment issues.  If the\n+\t output type is such that the operand is known to be aligned, indicate\n+\t that it is.  Otherwise, we need only be concerned about alignment for\n+\t non-BLKmode results.  */\n       if (MEM_P (op0))\n \t{\n \t  enum insn_code icode;"}, {"sha": "c34f640710b7d4ec7412f91b6537d3d803bda278", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322913f8769f6c7cac6a992debb430757e0e0c05/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322913f8769f6c7cac6a992debb430757e0e0c05/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=322913f8769f6c7cac6a992debb430757e0e0c05", "patch": "@@ -1,3 +1,7 @@\n+2014-02-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt31.adb: New test.\n+\n 2014-02-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.dg/torture/pr60092.c: xfail execution on *-*-solaris2.11* at -O0."}, {"sha": "51aa3556cec7fff8bf6ec7e108db748bda2661ca", "filename": "gcc/testsuite/gnat.dg/opt31.adb", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322913f8769f6c7cac6a992debb430757e0e0c05/gcc%2Ftestsuite%2Fgnat.dg%2Fopt31.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322913f8769f6c7cac6a992debb430757e0e0c05/gcc%2Ftestsuite%2Fgnat.dg%2Fopt31.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt31.adb?ref=322913f8769f6c7cac6a992debb430757e0e0c05", "patch": "@@ -0,0 +1,43 @@\n+-- { dg-do run }\n+-- { dg-options \"-O\" }\n+\n+with Interfaces; use Interfaces;\n+with Unchecked_Conversion;\n+\n+procedure Opt31 is\n+\n+  type Unsigned_24 is new Unsigned_32 range 0 .. 2**24 - 1;\n+  subtype Time_T is Unsigned_24 range 0 .. 24 * 60 * 60 * 128 - 1;\n+\n+  type Messages_T is array (Positive range <>) of Unsigned_8;\n+  subtype T_3Bytes is Messages_T (1 .. 3);\n+\n+  type Rec1 is record\n+    F : Time_T;\n+  end record;\n+  for Rec1 use record\n+    F at 0 range 0 .. 23;\n+  end record;\n+  for Rec1'Size use 24;\n+\n+  type Rec2 is record\n+    I1,I2,I3,I4 : Integer;\n+    R1 : Rec1;\n+  end record;\n+\n+  function Conv is new Unchecked_Conversion (T_3Bytes, Rec1);\n+\n+  procedure Decode (M : Messages_T) is\n+    My_Rec2 : Rec2;\n+  begin\n+    My_Rec2.R1 := Conv (M (1 .. 3));\n+    if not My_Rec2.R1.F'Valid then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+  Message : Messages_T (1 .. 4) := (16#18#, 16#0C#, 16#0C#, 16#18#);\n+\n+begin\n+  Decode (Message);\n+end;"}]}