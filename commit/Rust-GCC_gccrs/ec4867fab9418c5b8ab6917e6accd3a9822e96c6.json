{"sha": "ec4867fab9418c5b8ab6917e6accd3a9822e96c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM0ODY3ZmFiOTQxOGM1YjhhYjY5MTdlNmFjY2QzYTk4MjJlOTZjNg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T18:07:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:07:52Z"}, "message": "sem_ch6.ads, [...] (Analyze_Subprogram_Declaration): A null procedure cannot be a protected operation (it is a basic_declaration...\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n        \n\t* sem_ch6.ads, sem_ch6.adb (Analyze_Subprogram_Declaration): A null\n\tprocedure cannot be a protected operation (it is a basic_declaration,\n\tnot a subprogram_declaration).\n\t(Check_Overriding_Indicator): Rename formal Does_Override to Overridden_\n\tSubp. Add logic for entry processing.\n\t(Check_Synchronized_Overriding): New procedure in New_Overloaded_Entity.\n\tDetermine whether an entry or subprogram of a protected or task type\n\toverride an inherited primitive of an implemented interface.\n\t(New_Overloaded_Entity): Add calls to Check_Synchronized_Overriding.\n\tUpdate the actual used in calls to Check_Overriding_Indicator.\n\t(Analyze_Generic_Subprogram_Body): If the subprogram is a child unit,\n\tgenerate the proper reference to the parent unit, for cross-reference.\n\t(Analyze_Subprogram_Declaration): Protect Is_Controlling_Formal with\n\tIs_Formal.\n\tAdd -gnatd.l --Use Ada 95 semantics for limited function returns,\n\t(Add_Extra_Formal): Revise procedure to allow passing in associated\n\tentity, scope, and name suffix, and handle setting of the new\n\tExtra_Formals field.\n\t(Create_Extra_Formals): Change existing calls to Add_Extra_Formal to\n\tpass new parameters. Add support for adding the new extra access formal\n\tfor functions whose calls are treated as build-in-place.\n\t(Analyze_A_Return_Statement): Correct casing in error message.\n\tMove Pop_Scope to after Analyze_Function_Return, because an extended\n\treturn statement really is a full-fledged scope. Otherwise, visibility\n\tdoesn't work right. Correct use of \"\\\" for continuation messages.\n\t(Analyze_Function_Return): Call Analyze on the Obj_Decl, rather than\n\tevilly trying to call Analyze_Object_Declaration directly. Otherwise,\n\tthe node doesn't get properly marked as analyzed.\n\t(Analyze_Subprogram_Body): If subprogram is a function that returns\n\tan anonymous access type that denotes a task, build a Master Entity\n\tfor it.\n\t(Analyze_Return_Type): Add call to Null_Exclusion_Static_Checks. Verify\n\tproper usage of null exclusion in a result definition.\n\t(Process_Formals): Code cleanup and new error message.\n\t(Process_Formals): Detect incorrect application of null exclusion to\n\tnon-access types.\n\t(Conforming_Types): Handle conformance between [sub]types and itypes\n\t generated for entities that have null exclusions applied to them.\n\t(Maybe_Primitive_Operation): Add an additional type retrieval when the\n\t base type is an access subtype. This case arrises with null exclusions.\n\t(New_Overloaded_Entity): Do not remove the overriden entity from the\n\thomonym chain if it corresponds with an abstract interface primitive.\n\t(Process_Formals): Replace membership test agains Incomplete_Kind with a\n\tcall to the synthesized predicate Is_Incomplete_Type.\n\t(Analyze_Subprogram_Body): Check wrong placement of abstract interface\n\tprimitives.\n\t(Analyze_Subprogram_Declaration): Check that abstract interface\n\tprimitives are abstract or null.\n\t(Analyze_Subprogram_Specification): Remove previous check for abstract\n\tinterfaces because it was not complete.\n\t(Has_Interface_Formals): Removed.\n\nFrom-SVN: r118304", "tree": {"sha": "be108e443bbb52fd089a4cba0257c1efb3491355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be108e443bbb52fd089a4cba0257c1efb3491355"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec4867fab9418c5b8ab6917e6accd3a9822e96c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec4867fab9418c5b8ab6917e6accd3a9822e96c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec4867fab9418c5b8ab6917e6accd3a9822e96c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec4867fab9418c5b8ab6917e6accd3a9822e96c6/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a806772b8dfacc2c8cd8dcfbaf83c034634e4da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da"}], "stats": {"total": 1325, "additions": 1094, "deletions": 231}, "files": [{"sha": "4d8fdb2aa4c87e2564dbfb36aaa1c32dbcab4c39", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1087, "deletions": 230, "changes": 1317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4867fab9418c5b8ab6917e6accd3a9822e96c6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4867fab9418c5b8ab6917e6accd3a9822e96c6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ec4867fab9418c5b8ab6917e6accd3a9822e96c6", "patch": "@@ -31,12 +31,15 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Tss;  use Exp_Tss;\n+with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n with Lib.Xref; use Lib.Xref;\n+with Layout;   use Layout;\n with Namet;    use Namet;\n with Lib;      use Lib;\n with Nlists;   use Nlists;\n@@ -77,20 +80,32 @@ with Validsw;  use Validsw;\n \n package body Sem_Ch6 is\n \n-   --  The following flag is used to indicate that two formals in two\n-   --  subprograms being checked for conformance differ only in that one is\n-   --  an access parameter while the other is of a general access type with\n-   --  the same designated type. In this case, if the rest of the signatures\n-   --  match, a call to either subprogram may be ambiguous, which is worth\n-   --  a warning. The flag is set in Compatible_Types, and the warning emitted\n-   --  in New_Overloaded_Entity.\n+   Enable_New_Return_Processing : constant Boolean := True;\n+   --  ??? This flag is temporary. False causes the compiler to use the old\n+   --  version of Analyze_Return_Statement; True, the new version, which does\n+   --  not yet work. You probably want this to match the corresponding thing\n+   --  in exp_ch5.adb.\n \n    May_Hide_Profile : Boolean := False;\n+   --  This flag is used to indicate that two formals in two subprograms being\n+   --  checked for conformance differ only in that one is an access parameter\n+   --  while the other is of a general access type with the same designated\n+   --  type. In this case, if the rest of the signatures match, a call to\n+   --  either subprogram may be ambiguous, which is worth a warning. The flag\n+   --  is set in Compatible_Types, and the warning emitted in\n+   --  New_Overloaded_Entity.\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Analyze_A_Return_Statement (N : Node_Id);\n+   --  Common processing for simple_ and extended_return_statements\n+\n+   procedure Analyze_Function_Return (N : Node_Id);\n+   --  Subsidiary to Analyze_A_Return_Statement.\n+   --  Called when the return statement applies to a [generic] function.\n+\n    procedure Analyze_Return_Type (N : Node_Id);\n    --  Subsidiary to Process_Formals: analyze subtype mark in function\n    --  specification, in a context where the formals are visible and hide\n@@ -136,13 +151,12 @@ package body Sem_Ch6 is\n    --  be called.\n \n    procedure Check_Overriding_Indicator\n-     (Subp          : Entity_Id;\n-      Does_Override : Boolean);\n+     (Subp            : Entity_Id;\n+      Overridden_Subp : Entity_Id := Empty);\n    --  Verify the consistency of an overriding_indicator given for subprogram\n-   --  declaration, body, renaming, or instantiation. The flag Does_Override\n-   --  is set if the scope into which we are introducing the subprogram\n-   --  contains a type-conformant subprogram that becomes hidden by the new\n-   --  subprogram.\n+   --  declaration, body, renaming, or instantiation. Overridden_Subp is set\n+   --  if the scope into which we are introducing the subprogram contains a\n+   --  type-conformant subprogram that becomes hidden by the new subprogram.\n \n    procedure Check_Subprogram_Order (N : Node_Id);\n    --  N is the N_Subprogram_Body node for a subprogram. This routine applies\n@@ -212,6 +226,136 @@ package body Sem_Ch6 is\n    --  setting the proper validity status for this entity, which depends\n    --  on the kind of parameter and the validity checking mode.\n \n+   --------------------------------\n+   -- Analyze_A_Return_Statement --\n+   --------------------------------\n+\n+   procedure Analyze_A_Return_Statement (N : Node_Id) is\n+      --  ???This should be called Analyze_Return_Statement, and\n+      --  Analyze_Return_Statement should be called\n+      --  Analyze_Simple_Return_Statement!\n+\n+      pragma Assert (Nkind (N) = N_Return_Statement\n+                     or else Nkind (N) = N_Extended_Return_Statement);\n+\n+      Returns_Object : constant Boolean :=\n+        Nkind (N) = N_Extended_Return_Statement\n+         or else\n+           (Nkind (N) = N_Return_Statement and then Present (Expression (N)));\n+\n+      --  True if we're returning something; that is, \"return <expression>;\"\n+      --  or \"return Result : T [:= ...]\". False for \"return;\".\n+      --  Used for error checking: If Returns_Object is True, N should apply\n+      --  to a function body; otherwise N should apply to a procedure body,\n+      --  entry body, accept statement, or extended return statement.\n+\n+      function Find_What_It_Applies_To return Entity_Id;\n+      --  Find the entity representing the innermost enclosing body, accept\n+      --  statement, or extended return statement. If the result is a\n+      --  callable construct or extended return statement, then this will be\n+      --  the value of the Return_Applies_To attribute. Otherwise, the program\n+      --  is illegal. See RM-6.5(4/2). I am disinclined to call this\n+      --  Find_The_Construct_To_Which_This_Return_Statement_Applies. ;-)\n+\n+      -----------------------------\n+      -- Find_What_It_Applies_To --\n+      -----------------------------\n+\n+      function Find_What_It_Applies_To return Entity_Id is\n+         Result : Entity_Id := Empty;\n+\n+      begin\n+         --  Loop outward through the Scope_Stack, skipping blocks and loops\n+\n+         for J in reverse 0 .. Scope_Stack.Last loop\n+            Result := Scope_Stack.Table (J).Entity;\n+            exit when Ekind (Result) /= E_Block and then\n+                      Ekind (Result) /= E_Loop;\n+         end loop;\n+\n+         pragma Assert (Present (Result));\n+         return Result;\n+\n+      end Find_What_It_Applies_To;\n+\n+      Scope_Id   : constant Entity_Id   := Find_What_It_Applies_To;\n+      Kind       : constant Entity_Kind := Ekind (Scope_Id);\n+\n+      Loc        : constant Source_Ptr  := Sloc (N);\n+      Stm_Entity : constant Entity_Id   :=\n+                     New_Internal_Entity\n+                       (E_Return_Statement, Current_Scope, Loc, 'R');\n+\n+   --  Start of processing for Analyze_A_Return_Statement\n+\n+   begin\n+\n+      Set_Return_Statement_Entity (N, Stm_Entity);\n+\n+      Set_Etype (Stm_Entity, Standard_Void_Type);\n+      Set_Return_Applies_To (Stm_Entity, Scope_Id);\n+\n+      --  Place the Return entity on scope stack, to simplify enforcement\n+      --  of 6.5 (4/2): an inner return statement will apply to this extended\n+      --  return.\n+\n+      if Nkind (N) = N_Extended_Return_Statement then\n+         New_Scope (Stm_Entity);\n+      end if;\n+\n+      --  Check that pragma No_Return is obeyed:\n+\n+      if No_Return (Scope_Id) then\n+         Error_Msg_N (\"RETURN statement not allowed (No_Return)\", N);\n+      end if;\n+\n+      --  Check that functions return objects, and other things do not:\n+\n+      if Kind = E_Function or else Kind = E_Generic_Function then\n+         if not Returns_Object then\n+            Error_Msg_N (\"missing expression in return from function\", N);\n+         end if;\n+\n+      elsif Kind = E_Procedure or else Kind = E_Generic_Procedure then\n+         if Returns_Object then\n+            Error_Msg_N (\"procedure cannot return value (use function)\", N);\n+         end if;\n+\n+      elsif Kind = E_Entry or else Kind = E_Entry_Family then\n+         if Returns_Object then\n+            if Is_Protected_Type (Scope (Scope_Id)) then\n+               Error_Msg_N (\"entry body cannot return value\", N);\n+            else\n+               Error_Msg_N (\"accept statement cannot return value\", N);\n+            end if;\n+         end if;\n+\n+      elsif Kind = E_Return_Statement then\n+\n+         --  We are nested within another return statement, which must be an\n+         --  extended_return_statement.\n+\n+         if Returns_Object then\n+            Error_Msg_N\n+              (\"extended_return_statement cannot return value; \" &\n+               \"use `\"\"RETURN;\"\"`\", N);\n+         end if;\n+\n+      else\n+         Error_Msg_N (\"illegal context for return statement\", N);\n+      end if;\n+\n+      if Kind = E_Function or else Kind = E_Generic_Function then\n+         Analyze_Function_Return (N);\n+      end if;\n+\n+      if Nkind (N) = N_Extended_Return_Statement then\n+         End_Scope;\n+      end if;\n+\n+      Check_Unreachable_Code (N);\n+   end Analyze_A_Return_Statement;\n+\n    ---------------------------------------------\n    -- Analyze_Abstract_Subprogram_Declaration --\n    ---------------------------------------------\n@@ -237,6 +381,15 @@ package body Sem_Ch6 is\n       Generate_Reference_To_Formals (Designator);\n    end Analyze_Abstract_Subprogram_Declaration;\n \n+   ----------------------------------------\n+   -- Analyze_Extended_Return_Statement  --\n+   ----------------------------------------\n+\n+   procedure Analyze_Extended_Return_Statement (N : Node_Id) is\n+   begin\n+      Analyze_A_Return_Statement (N);\n+   end Analyze_Extended_Return_Statement;\n+\n    ----------------------------\n    -- Analyze_Function_Call  --\n    ----------------------------\n@@ -282,6 +435,292 @@ package body Sem_Ch6 is\n       Analyze_Call (N);\n    end Analyze_Function_Call;\n \n+   -----------------------------\n+   -- Analyze_Function_Return --\n+   -----------------------------\n+\n+   procedure Analyze_Function_Return (N : Node_Id) is\n+      Loc        : constant Source_Ptr  := Sloc (N);\n+      Stm_Entity : constant Entity_Id   := Return_Statement_Entity (N);\n+      Scope_Id   : constant Entity_Id   := Return_Applies_To (Stm_Entity);\n+\n+      R_Type : constant Entity_Id   := Etype (Scope_Id);\n+      --  Function result subtype\n+\n+      procedure Check_Limited_Return (Expr : Node_Id);\n+      --  Check the appropriate (Ada 95 or Ada 2005) rules for returning\n+      --  limited types. Used only for simple return statements.\n+      --  Expr is the expression returned.\n+\n+      procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id);\n+      --  Check that the return_subtype_indication properly matches the result\n+      --  subtype of the function, as required by RM-6.5(5.1/2-5.3/2).\n+\n+      --------------------------\n+      -- Check_Limited_Return --\n+      --------------------------\n+\n+      procedure Check_Limited_Return (Expr : Node_Id) is\n+      begin\n+         --  Ada 2005 (AI-318-02): Return-by-reference types have been\n+         --  removed and replaced by anonymous access results. This is an\n+         --  incompatibility with Ada 95. Not clear whether this should be\n+         --  enforced yet or perhaps controllable with special switch. ???\n+\n+         if Is_Limited_Type (R_Type)\n+           and then Comes_From_Source (N)\n+           and then not In_Instance_Body\n+           and then not OK_For_Limited_Init_In_05 (Expr)\n+         then\n+            --  Error in Ada 2005\n+\n+            if Ada_Version >= Ada_05\n+              and then not Debug_Flag_Dot_L\n+              and then not GNAT_Mode\n+            then\n+               Error_Msg_N\n+                 (\"(Ada 2005) cannot copy object of a limited type \" &\n+                  \"('R'M'-2005 6.5(5.5/2))\", Expr);\n+               if Is_Inherently_Limited_Type (R_Type) then\n+                  Error_Msg_N\n+                    (\"\\return by reference not permitted in Ada 2005\", Expr);\n+               end if;\n+\n+            --  Warn in Ada 95 mode, to give folks a heads up about this\n+            --  incompatibility.\n+\n+            --  In GNAT mode, this is just a warning, to allow it to be\n+            --  evilly turned off. Otherwise it is a real error.\n+\n+            elsif Warn_On_Ada_2005_Compatibility or GNAT_Mode then\n+               if Is_Inherently_Limited_Type (R_Type) then\n+                  Error_Msg_N\n+                    (\"return by reference not permitted in Ada 2005 \" &\n+                     \"('R'M'-2005 6.5(5.5/2))?\", Expr);\n+               else\n+                  Error_Msg_N\n+                    (\"cannot copy object of a limited type in Ada 2005 \" &\n+                     \"('R'M'-2005 6.5(5.5/2))?\", Expr);\n+               end if;\n+\n+            --  Ada 95 mode, compatibility warnings disabled\n+\n+            else\n+               return; --  skip continuation messages below\n+            end if;\n+\n+            Error_Msg_N\n+              (\"\\consider switching to return of access type\", Expr);\n+            Explain_Limited_Type (R_Type, Expr);\n+         end if;\n+      end Check_Limited_Return;\n+\n+      -------------------------------------\n+      -- Check_Return_Subtype_Indication --\n+      -------------------------------------\n+\n+      procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id) is\n+         Return_Obj  : constant Node_Id   := Defining_Identifier (Obj_Decl);\n+         R_Stm_Type  : constant Entity_Id := Etype (Return_Obj);\n+         --  Subtype given in the extended return statement;\n+         --  this must match R_Type.\n+\n+         Subtype_Ind : constant Node_Id :=\n+                         Object_Definition (Original_Node (Obj_Decl));\n+\n+         R_Type_Is_Anon_Access :\n+           constant Boolean :=\n+             Ekind (R_Type) = E_Anonymous_Access_Subprogram_Type\n+               or else\n+             Ekind (R_Type) = E_Anonymous_Access_Protected_Subprogram_Type\n+               or else\n+             Ekind (R_Type) = E_Anonymous_Access_Type;\n+         --  True if return type of the function is an anonymous access type\n+         --  Can't we make Is_Anonymous_Access_Type in einfo ???\n+\n+         R_Stm_Type_Is_Anon_Access :\n+           constant Boolean :=\n+             Ekind (R_Type) = E_Anonymous_Access_Subprogram_Type\n+               or else\n+             Ekind (R_Type) = E_Anonymous_Access_Protected_Subprogram_Type\n+               or else\n+             Ekind (R_Type) = E_Anonymous_Access_Type;\n+         --  True if type of the return object is an anonymous access type\n+\n+      begin\n+         --  First, avoid cascade errors:\n+\n+         if Error_Posted (Obj_Decl) or else Error_Posted (Subtype_Ind) then\n+            return;\n+         end if;\n+\n+         --  \"return access T\" case; check that the return statement also has\n+         --  \"access T\", and that the subtypes statically match:\n+\n+         if R_Type_Is_Anon_Access then\n+            if R_Stm_Type_Is_Anon_Access then\n+               if not Subtypes_Statically_Match (R_Stm_Type, R_Type) then\n+                  Error_Msg_N\n+                    (\"subtypes must statically match\", Subtype_Ind);\n+               end if;\n+            else\n+               Error_Msg_N (\"must use anonymous access type\", Subtype_Ind);\n+            end if;\n+\n+         --  Subtype_indication case; check that the types are the same, and\n+         --  statically match if appropriate:\n+\n+         elsif Base_Type (R_Stm_Type) = Base_Type (R_Type) then\n+            if Is_Constrained (R_Type) then\n+               if not Subtypes_Statically_Match (R_Stm_Type, R_Type) then\n+                  Error_Msg_N\n+                    (\"subtypes must statically match\", Subtype_Ind);\n+               end if;\n+            end if;\n+\n+         else\n+            Error_Msg_N\n+              (\"wrong type for return_subtype_indication\", Subtype_Ind);\n+         end if;\n+      end Check_Return_Subtype_Indication;\n+\n+      ---------------------\n+      -- Local Variables --\n+      ---------------------\n+\n+      Expr : Node_Id;\n+\n+   --  Start of processing for Analyze_Function_Return\n+\n+   begin\n+      Set_Return_Present (Scope_Id);\n+\n+      if Nkind (N) = N_Return_Statement then\n+         Expr := Expression (N);\n+         Analyze_And_Resolve (Expr, R_Type);\n+         Check_Limited_Return (Expr);\n+\n+      else\n+         --  Analyze parts specific to extended_return_statement:\n+\n+         declare\n+            Obj_Decl : constant Node_Id :=\n+                         Last (Return_Object_Declarations (N));\n+\n+            HSS : constant Node_Id := Handled_Statement_Sequence (N);\n+\n+         begin\n+            Expr := Expression (Obj_Decl);\n+\n+            --  Note: The check for OK_For_Limited_Init will happen in\n+            --  Analyze_Object_Declaration; we treat it as a normal\n+            --  object declaration.\n+\n+            Analyze (Obj_Decl);\n+\n+            Set_Is_Return_Object (Defining_Identifier (Obj_Decl));\n+            Check_Return_Subtype_Indication (Obj_Decl);\n+\n+            if Present (HSS) then\n+               Analyze (HSS);\n+\n+               if Present (Exception_Handlers (HSS)) then\n+\n+                  --  ???Has_Nested_Block_With_Handler needs to be set.\n+                  --  Probably by creating an actual N_Block_Statement.\n+                  --  Probably in Expand.\n+\n+                  null;\n+               end if;\n+            end if;\n+\n+            Check_References (Stm_Entity);\n+         end;\n+      end if;\n+\n+      --  ???Check for not-yet-implemented cases of AI-318.  Currently we\n+      --  warn, because that's convenient for our own use.  We might want to\n+      --  change these warnings to errors at some point.  This will go away\n+      --  once AI-318 is fully implemented.\n+      --\n+      --  In the first version, we plan not to implement limited function\n+      --  returns when the result type contains tasks or protected objects,\n+      --  and when the result subtype is unconstrained.\n+\n+      if Ada_Version >= Ada_05\n+        and then not Debug_Flag_Dot_L\n+        and then Is_Inherently_Limited_Type (R_Type)\n+      then\n+         if Has_Task (R_Type) then\n+            Error_Msg_N (\"(Ada 2005) return of task objects\" &\n+                         \" is not yet implemented\", N);\n+         end if;\n+\n+         if Is_Controlled (R_Type)\n+           or else Has_Controlled_Component (R_Type)\n+         then\n+            Error_Msg_N\n+              (\"(Ada 2005) return of limited controlled objects\" &\n+               \" is not yet implemented\", N);\n+         end if;\n+\n+         if\n+           Is_Composite_Type (R_Type) and then not Is_Constrained (R_Type)\n+         then\n+            Error_Msg_N\n+              (\"(Ada 2005) return of unconstrained limited composite objects\" &\n+               \" is not yet implemented\", N);\n+         end if;\n+      end if;\n+\n+      if Present (Expr)\n+        and then Present (Etype (Expr)) --  Could be False in case of errors.\n+      then\n+         --  Ada 2005 (AI-318-02): When the result type is an anonymous\n+         --  access type, apply an implicit conversion of the expression\n+         --  to that type to force appropriate static and run-time\n+         --  accessibility checks.\n+\n+         if Ada_Version >= Ada_05\n+           and then Ekind (R_Type) = E_Anonymous_Access_Type\n+         then\n+            Rewrite (Expr, Convert_To (R_Type, Relocate_Node (Expr)));\n+            Analyze_And_Resolve (Expr, R_Type);\n+         end if;\n+\n+         if (Is_Class_Wide_Type (Etype (Expr))\n+              or else Is_Dynamically_Tagged (Expr))\n+           and then not Is_Class_Wide_Type (R_Type)\n+         then\n+            Error_Msg_N\n+              (\"dynamically tagged expression not allowed!\", Expr);\n+         end if;\n+\n+         Apply_Constraint_Check (Expr, R_Type);\n+\n+         --  ??? A real run-time accessibility check is needed in cases\n+         --  involving dereferences of access parameters. For now we just\n+         --  check the static cases.\n+\n+         if (Ada_Version < Ada_05 or else Debug_Flag_Dot_L)\n+           and then Is_Inherently_Limited_Type (Etype (Scope_Id))\n+           and then Object_Access_Level (Expr) >\n+                      Subprogram_Access_Level (Scope_Id)\n+         then\n+            Rewrite (N,\n+              Make_Raise_Program_Error (Loc,\n+                Reason => PE_Accessibility_Check_Failed));\n+            Analyze (N);\n+\n+            Error_Msg_N\n+              (\"cannot return a local value by reference?\", N);\n+            Error_Msg_NE\n+              (\"\\& will be raised at run time?\",\n+               N, Standard_Program_Error);\n+         end if;\n+      end if;\n+   end Analyze_Function_Return;\n+\n    -------------------------------------\n    -- Analyze_Generic_Subprogram_Body --\n    -------------------------------------\n@@ -390,10 +829,11 @@ package body Sem_Ch6 is\n \n          --  Visible generic entity is callable within its own body\n \n-         Set_Ekind (Gen_Id, Ekind (Body_Id));\n-         Set_Ekind (Body_Id, E_Subprogram_Body);\n-         Set_Convention (Body_Id, Convention (Gen_Id));\n-         Set_Scope (Body_Id, Scope (Gen_Id));\n+         Set_Ekind          (Gen_Id,  Ekind (Body_Id));\n+         Set_Ekind          (Body_Id, E_Subprogram_Body);\n+         Set_Convention     (Body_Id, Convention (Gen_Id));\n+         Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Gen_Id));\n+         Set_Scope          (Body_Id, Scope (Gen_Id));\n          Check_Fully_Conformant (Body_Id, Gen_Id, Body_Id);\n \n          if Nkind (N) = N_Subprogram_Body_Stub then\n@@ -419,6 +859,10 @@ package body Sem_Ch6 is\n          Set_Is_Immediately_Visible (Gen_Id);\n          Reference_Body_Formals (Gen_Id, Body_Id);\n \n+         if Is_Child_Unit (Gen_Id) then\n+            Generate_Reference (Gen_Id, Scope (Gen_Id), 'k', False);\n+         end if;\n+\n          Set_Actual_Subtypes (N, Current_Scope);\n          Analyze_Declarations (Declarations (N));\n          Check_Completion;\n@@ -718,7 +1162,16 @@ package body Sem_Ch6 is\n       Kind     : Entity_Kind;\n       R_Type   : Entity_Id;\n \n+      Stm_Entity : constant Entity_Id   :=\n+                     New_Internal_Entity\n+                       (E_Return_Statement, Current_Scope, Loc, 'R');\n+\n    begin\n+      if Enable_New_Return_Processing then --  ???Temporary hack.\n+         Analyze_A_Return_Statement (N);\n+         return;\n+      end if;\n+\n       --  Find subprogram or accept statement enclosing the return statement\n \n       Scope_Id := Empty;\n@@ -730,6 +1183,9 @@ package body Sem_Ch6 is\n \n       pragma Assert (Present (Scope_Id));\n \n+      Set_Return_Statement_Entity (N, Stm_Entity);\n+      Set_Return_Applies_To (Stm_Entity, Scope_Id);\n+\n       Kind := Ekind (Scope_Id);\n       Expr := Expression (N);\n \n@@ -746,7 +1202,6 @@ package body Sem_Ch6 is\n          if Kind = E_Function or else Kind = E_Generic_Function then\n             Set_Return_Present (Scope_Id);\n             R_Type := Etype (Scope_Id);\n-            Set_Return_Type (N, R_Type);\n             Analyze_And_Resolve (Expr, R_Type);\n \n             --  Ada 2005 (AI-318-02): When the result type is an anonymous\n@@ -791,7 +1246,7 @@ package body Sem_Ch6 is\n             --  involving dereferences of access parameters. For now we just\n             --  check the static cases.\n \n-            if Is_Return_By_Reference_Type (Etype (Scope_Id))\n+            if Is_Inherently_Limited_Type (Etype (Scope_Id))\n               and then Object_Access_Level (Expr)\n                 > Subprogram_Access_Level (Scope_Id)\n             then\n@@ -842,22 +1297,15 @@ package body Sem_Ch6 is\n       Typ        : Entity_Id := Empty;\n \n    begin\n+      --  Normal case where result definition does not indicate an error\n+\n       if Result_Definition (N) /= Error then\n          if Nkind (Result_Definition (N)) = N_Access_Definition then\n             Typ := Access_Definition (N, Result_Definition (N));\n             Set_Parent (Typ, Result_Definition (N));\n             Set_Is_Local_Anonymous_Access (Typ);\n             Set_Etype (Designator, Typ);\n \n-            --  Ada 2005 (AI-231): Static checks\n-\n-            --  Null_Exclusion_Static_Checks needs to be extended to handle\n-            --  null exclusion checks for function specifications. ???\n-\n-            --  if Null_Exclusion_Present (N) then\n-            --     Null_Exclusion_Static_Checks (Param_Spec);\n-            --  end if;\n-\n          --  Subtype_Mark case\n \n          else\n@@ -875,6 +1323,12 @@ package body Sem_Ch6 is\n             end if;\n          end if;\n \n+         --  Ada 2005 (AI-231): Ensure proper usage of null exclusion\n+\n+         Null_Exclusion_Static_Checks (N);\n+\n+      --  Case where result definition does indicate an error\n+\n       else\n          Set_Etype (Designator, Any_Type);\n       end if;\n@@ -904,6 +1358,12 @@ package body Sem_Ch6 is\n       Missing_Ret  : Boolean;\n       P_Ent        : Entity_Id;\n \n+      procedure Check_Anonymous_Return;\n+      --  (Ada 2005): if a function returns an access type that denotes a task,\n+      --  or a type that contains tasks, we must create a master entity for\n+      --  the anonymous type, which typically will be used in an allocator\n+      --  in the body of the function.\n+\n       procedure Check_Inline_Pragma (Spec : in out Node_Id);\n       --  Look ahead to recognize a pragma that may appear after the body.\n       --  If there is a previous spec, check that it appears in the same\n@@ -921,6 +1381,48 @@ package body Sem_Ch6 is\n       --  indicator, check that it is consistent with the known status of the\n       --  entity.\n \n+      ----------------------------\n+      -- Check_Anonymous_Return --\n+      ----------------------------\n+\n+      procedure Check_Anonymous_Return is\n+         Decl : Node_Id;\n+         Scop : Entity_Id;\n+\n+      begin\n+         if Present (Spec_Id) then\n+            Scop := Spec_Id;\n+         else\n+            Scop := Body_Id;\n+         end if;\n+\n+         if Ekind (Scop) = E_Function\n+           and then Ekind (Etype (Scop)) = E_Anonymous_Access_Type\n+           and then Has_Task (Designated_Type (Etype (Scop)))\n+           and then Expander_Active\n+         then\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uMaster),\n+                Constant_Present => True,\n+                Object_Definition =>\n+                  New_Reference_To (RTE (RE_Master_Id), Loc),\n+                Expression =>\n+                  Make_Explicit_Dereference (Loc,\n+                    New_Reference_To (RTE (RE_Current_Master), Loc)));\n+\n+            if Present (Declarations (N)) then\n+               Prepend (Decl, Declarations (N));\n+            else\n+               Set_Declarations (N, New_List (Decl));\n+            end if;\n+\n+            Set_Master_Id (Etype (Scop), Defining_Identifier (Decl));\n+            Set_Has_Master_Entity (Scop);\n+         end if;\n+      end Check_Anonymous_Return;\n+\n       -------------------------\n       -- Check_Inline_Pragma --\n       -------------------------\n@@ -1388,6 +1890,7 @@ package body Sem_Ch6 is\n          Set_Corresponding_Body (Unit_Declaration_Node (Spec_Id), Body_Id);\n          Set_Ekind (Body_Id, E_Subprogram_Body);\n          Set_Scope (Body_Id, Scope (Spec_Id));\n+         Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Spec_Id));\n \n       --  Case of subprogram body with no previous spec\n \n@@ -1413,6 +1916,61 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n+      --  Ada 2005 (AI-251): Check wrong placement of abstract interface\n+      --  primitives.\n+\n+      if Ada_Version >= Ada_05\n+        and then Comes_From_Source (N)\n+      then\n+         declare\n+            E    : Entity_Id;\n+            Etyp : Entity_Id;\n+\n+         begin\n+            --  Check the type of the formals\n+\n+            E := First_Entity (Body_Id);\n+            while Present (E) loop\n+               Etyp := Etype (E);\n+\n+               if Is_Access_Type (Etyp) then\n+                  Etyp := Directly_Designated_Type (Etyp);\n+               end if;\n+\n+               if not Is_Class_Wide_Type (Etyp)\n+                 and then Is_Interface (Etyp)\n+               then\n+                  Error_Msg_Name_1 := Chars (Defining_Entity (N));\n+                  Error_Msg_N\n+                    (\"(Ada 2005) abstract interface primitives must be\" &\n+                     \" defined in package specs\", N);\n+                  exit;\n+               end if;\n+\n+               Next_Entity (E);\n+            end loop;\n+\n+            --  In case of functions, check the type of the result\n+\n+            if Ekind (Body_Id) = E_Function then\n+               Etyp := Etype (Body_Id);\n+\n+               if Is_Access_Type (Etyp) then\n+                  Etyp := Directly_Designated_Type (Etyp);\n+               end if;\n+\n+               if not Is_Class_Wide_Type (Etyp)\n+                 and then Is_Interface (Etyp)\n+               then\n+                  Error_Msg_Name_1 := Chars (Defining_Entity (N));\n+                  Error_Msg_N\n+                    (\"(Ada 2005) abstract interface primitives must be\" &\n+                     \" defined in package specs\", N);\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+\n       --  If this is the proper body of a stub, we must verify that the stub\n       --  conforms to the body, and to the previous spec if one was present.\n       --  we know already that the body conforms to that spec. This test is\n@@ -1456,7 +2014,7 @@ package body Sem_Ch6 is\n       if Nkind (N) = N_Subprogram_Body_Stub then\n          return;\n \n-      elsif  Present (Spec_Id)\n+      elsif Present (Spec_Id)\n         and then Expander_Active\n         and then\n           (Is_Always_Inlined (Spec_Id)\n@@ -1474,6 +2032,8 @@ package body Sem_Ch6 is\n          Install_Private_With_Clauses (Body_Id);\n       end if;\n \n+      Check_Anonymous_Return;\n+\n       --  Now we can go on to analyze the body\n \n       HSS := Handled_Statement_Sequence (N);\n@@ -1641,7 +2201,6 @@ package body Sem_Ch6 is\n \n          if Present (Spec_Id) then\n             E1 := First_Entity (Spec_Id);\n-\n             while Present (E1) loop\n                if Ekind (E1) = E_Out_Parameter then\n                   E2 := First_Entity (Body_Id);\n@@ -1705,6 +2264,50 @@ package body Sem_Ch6 is\n       New_Overloaded_Entity (Designator);\n       Check_Delayed_Subprogram (Designator);\n \n+      --  Ada 2005 (AI-251): Abstract interface primitives must be abstract\n+      --  or null.\n+\n+      if Ada_Version >= Ada_05\n+        and then Comes_From_Source (N)\n+        and then Is_Dispatching_Operation (Designator)\n+      then\n+         declare\n+            E    : Entity_Id;\n+            Etyp : Entity_Id;\n+\n+         begin\n+            if Has_Controlling_Result (Designator) then\n+               Etyp := Etype (Designator);\n+\n+            else\n+               E := First_Entity (Designator);\n+               while Present (E)\n+                 and then Is_Formal (E)\n+                 and then not Is_Controlling_Formal (E)\n+               loop\n+                  Next_Entity (E);\n+               end loop;\n+\n+               Etyp := Etype (E);\n+            end if;\n+\n+            if Is_Access_Type (Etyp) then\n+               Etyp := Directly_Designated_Type (Etyp);\n+            end if;\n+\n+            if Is_Interface (Etyp)\n+              and then not Is_Abstract (Designator)\n+              and then not (Ekind (Designator) = E_Procedure\n+                              and then Null_Present (Specification (N)))\n+            then\n+               Error_Msg_Name_1 := Chars (Defining_Entity (N));\n+               Error_Msg_N\n+                 (\"(Ada 2005) interface subprogram % must be abstract or null\",\n+                  N);\n+            end if;\n+         end;\n+      end if;\n+\n       --  What is the following code for, it used to be\n \n       --  ???   Set_Suppress_Elaboration_Checks\n@@ -1755,6 +2358,11 @@ package body Sem_Ch6 is\n       then\n          Set_Has_Completion (Designator);\n          Set_Is_Inlined (Designator);\n+\n+         if Is_Protected_Type (Current_Scope) then\n+            Error_Msg_N\n+              (\"protected operation cannot be a null procedure\", N);\n+         end if;\n       end if;\n    end Analyze_Subprogram_Declaration;\n \n@@ -1770,37 +2378,6 @@ package body Sem_Ch6 is\n       Designator : constant Entity_Id := Defining_Entity (N);\n       Formals    : constant List_Id   := Parameter_Specifications (N);\n \n-      function Has_Interface_Formals (T : List_Id) return Boolean;\n-      --  Ada 2005 (AI-251): Returns true if some non class-wide interface\n-      --  formal is found.\n-\n-      ---------------------------\n-      -- Has_Interface_Formals --\n-      ---------------------------\n-\n-      function Has_Interface_Formals (T : List_Id) return Boolean is\n-         Param_Spec : Node_Id;\n-         Formal     : Entity_Id;\n-\n-      begin\n-         Param_Spec := First (T);\n-\n-         while Present (Param_Spec) loop\n-            Formal := Defining_Identifier (Param_Spec);\n-\n-            if Is_Class_Wide_Type (Etype (Formal)) then\n-               null;\n-\n-            elsif Is_Interface (Etype (Formal)) then\n-               return True;\n-            end if;\n-\n-            Next (Param_Spec);\n-         end loop;\n-\n-         return False;\n-      end Has_Interface_Formals;\n-\n    --  Start of processing for Analyze_Subprogram_Specification\n \n    begin\n@@ -1860,7 +2437,12 @@ package body Sem_Ch6 is\n \n          May_Need_Actuals (Designator);\n \n+         --  Ada 2005 (AI-251): In case of primitives associated with abstract\n+         --  interface types the following error message will be reported later\n+         --  (see Analyze_Subprogram_Declaration).\n+\n          if Is_Abstract (Etype (Designator))\n+           and then not Is_Interface (Etype (Designator))\n            and then Nkind (Parent (N))\n                       /= N_Abstract_Subprogram_Declaration\n            and then (Nkind (Parent (N)))\n@@ -1874,20 +2456,6 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      if Ada_Version >= Ada_05\n-        and then Comes_From_Source (N)\n-        and then Nkind (Parent (N)) /= N_Abstract_Subprogram_Declaration\n-        and then (Nkind (N) /= N_Procedure_Specification\n-                    or else\n-                  not Null_Present (N))\n-        and then Has_Interface_Formals (Formals)\n-      then\n-         Error_Msg_Name_1 := Chars (Defining_Unit_Name\n-                                    (Specification (Parent (N))));\n-         Error_Msg_N\n-           (\"(Ada 2005) interface subprogram % must be abstract or null\", N);\n-      end if;\n-\n       return Designator;\n    end Analyze_Subprogram_Specification;\n \n@@ -2014,7 +2582,6 @@ package body Sem_Ch6 is\n \n       begin\n          S := First (Stats);\n-\n          while Present (S) loop\n             Stat_Count := Stat_Count + 1;\n \n@@ -2095,9 +2662,10 @@ package body Sem_Ch6 is\n       -------------------------------\n \n       function Has_Pending_Instantiation return Boolean is\n-         S : Entity_Id := Current_Scope;\n+         S : Entity_Id;\n \n       begin\n+         S := Current_Scope;\n          while Present (S) loop\n             if Is_Compilation_Unit (S)\n               or else Is_Child_Unit (S)\n@@ -2388,7 +2956,7 @@ package body Sem_Ch6 is\n          --  Remove last character (question mark) to make this into an error,\n          --  because the Inline_Always pragma cannot be obeyed.\n \n-         Error_Msg_NE (Msg (1 .. Msg'Length - 1), N, Subp);\n+         Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n \n       elsif Ineffective_Inline_Warnings then\n          Error_Msg_NE (Msg, N, Subp);\n@@ -2409,11 +2977,6 @@ package body Sem_Ch6 is\n       Get_Inst                 : Boolean := False;\n       Skip_Controlling_Formals : Boolean := False)\n    is\n-      Old_Type   : constant Entity_Id := Etype (Old_Id);\n-      New_Type   : constant Entity_Id := Etype (New_Id);\n-      Old_Formal : Entity_Id;\n-      New_Formal : Entity_Id;\n-\n       procedure Conformance_Error (Msg : String; N : Node_Id := New_Id);\n       --  Post error message for conformance error on given node. Two messages\n       --  are output. The first points to the previous declaration with a\n@@ -2463,6 +3026,16 @@ package body Sem_Ch6 is\n          end if;\n       end Conformance_Error;\n \n+      --  Local Variables\n+\n+      Old_Type           : constant Entity_Id := Etype (Old_Id);\n+      New_Type           : constant Entity_Id := Etype (New_Id);\n+      Old_Formal         : Entity_Id;\n+      New_Formal         : Entity_Id;\n+      Access_Types_Match : Boolean;\n+      Old_Formal_Base    : Entity_Id;\n+      New_Formal_Base    : Entity_Id;\n+\n    --  Start of processing for Check_Conformance\n \n    begin\n@@ -2583,6 +3156,49 @@ package body Sem_Ch6 is\n             end if;\n          end if;\n \n+         --  Ada 2005 (AI-423): Possible access [sub]type and itype match. This\n+         --  case occurs whenever a subprogram is being renamed and one of its\n+         --  parameters imposes a null exclusion. For example:\n+\n+         --     type T is null record;\n+         --     type Acc_T is access T;\n+         --     subtype Acc_T_Sub is Acc_T;\n+\n+         --     procedure P     (Obj : not null Acc_T_Sub);  --  itype\n+         --     procedure Ren_P (Obj :          Acc_T_Sub)   --  subtype\n+         --       renames P;\n+\n+         Old_Formal_Base := Etype (Old_Formal);\n+         New_Formal_Base := Etype (New_Formal);\n+\n+         if Get_Inst then\n+            Old_Formal_Base := Get_Instance_Of (Old_Formal_Base);\n+            New_Formal_Base := Get_Instance_Of (New_Formal_Base);\n+         end if;\n+\n+         Access_Types_Match := Ada_Version >= Ada_05\n+\n+            --  Ensure that this rule is only applied when New_Id is a\n+            --  renaming of Old_Id\n+\n+           and then Nkind (Parent (Parent (New_Id)))\n+                      = N_Subprogram_Renaming_Declaration\n+           and then Nkind (Name (Parent (Parent (New_Id)))) in N_Has_Entity\n+           and then Present (Entity (Name (Parent (Parent (New_Id)))))\n+           and then Entity (Name (Parent (Parent (New_Id)))) = Old_Id\n+\n+            --  Now handle the allowed access-type case\n+\n+           and then Is_Access_Type (Old_Formal_Base)\n+           and then Is_Access_Type (New_Formal_Base)\n+           and then Directly_Designated_Type (Old_Formal_Base) =\n+                      Directly_Designated_Type (New_Formal_Base)\n+           and then ((Is_Itype (Old_Formal_Base)\n+                       and then Can_Never_Be_Null (Old_Formal_Base))\n+                    or else\n+                     (Is_Itype (New_Formal_Base)\n+                       and then Can_Never_Be_Null (New_Formal_Base)));\n+\n          --  Types must always match. In the visible part of an instance,\n          --  usual overloading rules for dispatching operations apply, and\n          --  we check base types (not the actual subtypes).\n@@ -2591,15 +3207,22 @@ package body Sem_Ch6 is\n            and then Is_Dispatching_Operation (New_Id)\n          then\n             if not Conforming_Types\n-              (Base_Type (Etype (Old_Formal)),\n-                 Base_Type (Etype (New_Formal)), Ctype, Get_Inst)\n+                     (T1       => Base_Type (Etype (Old_Formal)),\n+                      T2       => Base_Type (Etype (New_Formal)),\n+                      Ctype    => Ctype,\n+                      Get_Inst => Get_Inst)\n+               and then not Access_Types_Match\n             then\n                Conformance_Error (\"type of & does not match!\", New_Formal);\n                return;\n             end if;\n \n          elsif not Conforming_Types\n-           (Etype (Old_Formal), Etype (New_Formal), Ctype, Get_Inst)\n+                     (T1       => Etype (Old_Formal),\n+                      T2       => Etype (New_Formal),\n+                      Ctype    => Ctype,\n+                      Get_Inst => Get_Inst)\n+           and then not Access_Types_Match\n          then\n             Conformance_Error (\"type of & does not match!\", New_Formal);\n             return;\n@@ -2761,6 +3384,136 @@ package body Sem_Ch6 is\n       end if;\n    end Check_Conformance;\n \n+   -----------------------\n+   -- Check_Conventions --\n+   -----------------------\n+\n+   procedure Check_Conventions (Typ : Entity_Id) is\n+      procedure Check_Convention\n+        (Op          : Entity_Id;\n+         Search_From : Elmt_Id);\n+      --  Verify that the convention of inherited dispatching operation\n+      --  Op is consistent among all subprograms it overrides. In order\n+      --  to minimize the search, Search_From is utilized to designate\n+      --  a specific point in the list rather than iterating over the\n+      --  whole list once more.\n+\n+      ----------------------\n+      -- Check_Convention --\n+      ----------------------\n+\n+      procedure Check_Convention\n+        (Op          : Entity_Id;\n+         Search_From : Elmt_Id)\n+      is\n+         procedure Error_Msg_Operation (Op : Entity_Id);\n+         --  Emit a continuation to an error message depicting the kind,\n+         --  name, convention and source location of subprogram Op.\n+\n+         -------------------------\n+         -- Error_Msg_Operation --\n+         -------------------------\n+\n+         procedure Error_Msg_Operation (Op : Entity_Id) is\n+         begin\n+            Error_Msg_Name_1 := Chars (Op);\n+\n+            --  Error messages of primitive subprograms do not contain a\n+            --  convention attribute since the convention may have been\n+            --  first inherited from a parent subprogram, then changed by\n+            --  a pragma.\n+\n+            if Comes_From_Source (Op) then\n+               Error_Msg_Sloc := Sloc (Op);\n+               Error_Msg_N\n+                (\"\\ primitive % defined #\", Typ);\n+\n+            else\n+               Error_Msg_Name_2 := Get_Convention_Name (Convention (Op));\n+\n+               if Present (Abstract_Interface_Alias (Op)) then\n+                  Error_Msg_Sloc := Sloc (Abstract_Interface_Alias (Op));\n+                  Error_Msg_N (\"\\\\overridden operation % with \" &\n+                               \"convention % defined #\", Typ);\n+\n+               else pragma Assert (Present (Alias (Op)));\n+                  Error_Msg_Sloc := Sloc (Alias (Op));\n+                  Error_Msg_N (\"\\\\inherited operation % with \" &\n+                               \"convention % defined #\", Typ);\n+               end if;\n+            end if;\n+         end Error_Msg_Operation;\n+\n+         --  Local variables\n+\n+         Prim_Op      : Entity_Id;\n+         Prim_Op_Elmt : Elmt_Id;\n+\n+      --  Start of processing for Check_Convention\n+\n+      begin\n+         Prim_Op_Elmt := Next_Elmt (Search_From);\n+         while Present (Prim_Op_Elmt) loop\n+            Prim_Op := Node (Prim_Op_Elmt);\n+\n+            --  A small optimization, skip the predefined dispatching\n+            --  operations since they always have the same convention.\n+            --  Also do not consider abstract primitives since those\n+            --  are left by an erroneous overriding.\n+\n+            if not Is_Predefined_Dispatching_Operation (Prim_Op)\n+              and then not Is_Abstract (Prim_Op)\n+              and then Chars (Prim_Op) = Chars (Op)\n+              and then Type_Conformant (Prim_Op, Op)\n+              and then Convention (Prim_Op) /= Convention (Op)\n+            then\n+               Error_Msg_N\n+                 (\"inconsistent conventions in primitive operations\", Typ);\n+\n+               Error_Msg_Operation (Op);\n+               Error_Msg_Operation (Prim_Op);\n+\n+               --  Avoid cascading errors\n+\n+               return;\n+            end if;\n+\n+            Next_Elmt (Prim_Op_Elmt);\n+         end loop;\n+      end Check_Convention;\n+\n+      --  Local variables\n+\n+      Prim_Op      : Entity_Id;\n+      Prim_Op_Elmt : Elmt_Id;\n+\n+   --  Start of processing for Check_Conventions\n+\n+   begin\n+      --  The algorithm checks every overriding dispatching operation\n+      --  against all the corresponding overridden dispatching operations,\n+      --  detecting differences in coventions.\n+\n+      Prim_Op_Elmt := First_Elmt (Primitive_Operations (Typ));\n+      while Present (Prim_Op_Elmt) loop\n+         Prim_Op := Node (Prim_Op_Elmt);\n+\n+         --  A small optimization, skip the predefined dispatching operations\n+         --  since they always have the same convention. Also avoid processing\n+         --  of abstract primitives left from an erroneous overriding.\n+\n+         if not Is_Predefined_Dispatching_Operation (Prim_Op)\n+           and then not Is_Abstract (Prim_Op)\n+         then\n+            Check_Convention\n+              (Op          => Prim_Op,\n+               Search_From => Prim_Op_Elmt);\n+         end if;\n+\n+         Next_Elmt (Prim_Op_Elmt);\n+      end loop;\n+   end Check_Conventions;\n+\n    ------------------------------\n    -- Check_Delayed_Subprogram --\n    ------------------------------\n@@ -2829,7 +3582,7 @@ package body Sem_Ch6 is\n             Utyp : constant Entity_Id := Underlying_Type (Typ);\n \n          begin\n-            if Is_Return_By_Reference_Type (Typ) then\n+            if Is_Inherently_Limited_Type (Typ) then\n                Set_Returns_By_Ref (Designator);\n \n             elsif Present (Utyp) and then Controlled_Type (Utyp) then\n@@ -3026,42 +3779,58 @@ package body Sem_Ch6 is\n    --------------------------------\n \n    procedure Check_Overriding_Indicator\n-     (Subp          : Entity_Id;\n-      Does_Override : Boolean)\n+     (Subp            : Entity_Id;\n+      Overridden_Subp : Entity_Id := Empty)\n    is\n       Decl : Node_Id;\n       Spec : Node_Id;\n \n    begin\n-      if Ekind (Subp) = E_Enumeration_Literal then\n-\n-         --  No overriding indicator for literals\n+      --  No overriding indicator for literals\n \n+      if Ekind (Subp) = E_Enumeration_Literal then\n          return;\n \n+      elsif Ekind (Subp) = E_Entry then\n+         Decl := Parent (Subp);\n+\n       else\n          Decl := Unit_Declaration_Node (Subp);\n       end if;\n \n-      if Nkind (Decl) = N_Subprogram_Declaration\n-        or else Nkind (Decl) = N_Subprogram_Body\n-        or else Nkind (Decl) = N_Subprogram_Renaming_Declaration\n+      if Nkind (Decl) = N_Subprogram_Body\n         or else Nkind (Decl) = N_Subprogram_Body_Stub\n+        or else Nkind (Decl) = N_Subprogram_Declaration\n+        or else Nkind (Decl) = N_Subprogram_Renaming_Declaration\n       then\n          Spec := Specification (Decl);\n+\n+      elsif Nkind (Decl) = N_Entry_Declaration then\n+         Spec := Decl;\n+\n       else\n          return;\n       end if;\n \n-      if not Does_Override then\n-         if Must_Override (Spec) then\n-            Error_Msg_NE (\"subprogram& is not overriding\", Spec, Subp);\n-         end if;\n+      if Present (Overridden_Subp) then\n+         if Must_Not_Override (Spec) then\n+            Error_Msg_Sloc := Sloc (Overridden_Subp);\n \n+            if Ekind (Subp) = E_Entry then\n+               Error_Msg_NE (\"entry & overrides inherited operation #\",\n+                             Spec, Subp);\n+            else\n+               Error_Msg_NE (\"subprogram & overrides inherited operation #\",\n+                             Spec, Subp);\n+            end if;\n+         end if;\n       else\n-         if Must_Not_Override (Spec) then\n-            Error_Msg_NE\n-              (\"subprogram& overrides inherited operation\", Spec, Subp);\n+         if Must_Override (Spec) then\n+            if Ekind (Subp) = E_Entry then\n+               Error_Msg_NE (\"entry & is not overriding\", Spec, Subp);\n+            else\n+               Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n+            end if;\n          end if;\n       end if;\n    end Check_Overriding_Indicator;\n@@ -3564,7 +4333,7 @@ package body Sem_Ch6 is\n          end if;\n       end Base_Types_Match;\n \n-      --  Start of processing for Conforming_Types\n+   --  Start of processing for Conforming_Types\n \n    begin\n       --  The context is an instance association for a formal\n@@ -3746,23 +4515,36 @@ package body Sem_Ch6 is\n \n    procedure Create_Extra_Formals (E : Entity_Id) is\n       Formal      : Entity_Id;\n+      First_Extra : Entity_Id := Empty;\n       Last_Extra  : Entity_Id;\n       Formal_Type : Entity_Id;\n       P_Formal    : Entity_Id := Empty;\n \n-      function Add_Extra_Formal (Typ : Entity_Id) return Entity_Id;\n-      --  Add an extra formal, associated with the current Formal. The extra\n-      --  formal is added to the list of extra formals, and also returned as\n-      --  the result. These formals are always of mode IN.\n+      function Add_Extra_Formal\n+        (Assoc_Entity : Entity_Id;\n+         Typ          : Entity_Id;\n+         Scope        : Entity_Id;\n+         Suffix       : String) return Entity_Id;\n+      --  Add an extra formal to the current list of formals and extra formals.\n+      --  The extra formal is added to the end of the list of extra formals,\n+      --  and also returned as the result. These formals are always of mode IN.\n+      --  The new formal has the type Typ, is declared in Scope, and its name\n+      --  is given by a concatenation of the name of Assoc_Entity and Suffix.\n \n       ----------------------\n       -- Add_Extra_Formal --\n       ----------------------\n \n-      function Add_Extra_Formal (Typ : Entity_Id) return Entity_Id is\n+      function Add_Extra_Formal\n+        (Assoc_Entity : Entity_Id;\n+         Typ          : Entity_Id;\n+         Scope        : Entity_Id;\n+         Suffix       : String) return Entity_Id\n+      is\n          EF : constant Entity_Id :=\n-                Make_Defining_Identifier (Sloc (Formal),\n-                  Chars => New_External_Name (Chars (Formal), 'F'));\n+                Make_Defining_Identifier (Sloc (Assoc_Entity),\n+                  Chars  => New_External_Name (Chars (Assoc_Entity),\n+                  Suffix => Suffix));\n \n       begin\n          --  We never generate extra formals if expansion is not active\n@@ -3783,12 +4565,21 @@ package body Sem_Ch6 is\n          Set_Ekind           (EF, E_In_Parameter);\n          Set_Actual_Subtype  (EF, Typ);\n          Set_Etype           (EF, Typ);\n-         Set_Scope           (EF, Scope (Formal));\n+         Set_Scope           (EF, Scope);\n          Set_Mechanism       (EF, Default_Mechanism);\n          Set_Formal_Validity (EF);\n \n-         Set_Extra_Formal (Last_Extra, EF);\n+         if No (First_Extra) then\n+            First_Extra := EF;\n+            Set_Extra_Formals (Scope, First_Extra);\n+         end if;\n+\n+         if Present (Last_Extra) then\n+            Set_Extra_Formal (Last_Extra, EF);\n+         end if;\n+\n          Last_Extra := EF;\n+\n          return EF;\n       end Add_Extra_Formal;\n \n@@ -3857,7 +4648,9 @@ package body Sem_Ch6 is\n                   or else Present (Extra_Formal (Formal)))\n             then\n                Set_Extra_Constrained\n-                 (Formal, Add_Extra_Formal (Standard_Boolean));\n+                 (Formal,\n+                  Add_Extra_Formal\n+                    (Formal, Standard_Boolean, Scope (Formal), \"F\"));\n             end if;\n          end if;\n \n@@ -3888,7 +4681,9 @@ package body Sem_Ch6 is\n               and then Nkind (Parent (Parent (Parent (E)))) /= N_Protected_Body\n             then\n                Set_Extra_Accessibility\n-                 (Formal, Add_Extra_Formal (Standard_Natural));\n+                 (Formal,\n+                  Add_Extra_Formal\n+                    (Formal, Standard_Natural, Scope (Formal), \"F\"));\n             end if;\n          end if;\n \n@@ -3903,6 +4698,54 @@ package body Sem_Ch6 is\n \n          Next_Formal (Formal);\n       end loop;\n+\n+      --  Ada 2005 (AI-318-02): In the case of build-in-place functions, add\n+      --  an extra formal that will be passed the address of the return object\n+      --  within the caller. This is added as the last extra formal, but\n+      --  eventually will be accompanied by other implicit formals related to\n+      --  build-in-place functions (such as allocate/deallocate subprograms,\n+      --  finalization list, constrained flag, task master, task activation\n+      --  list, etc.).\n+\n+      if Expander_Active\n+        and then Ada_Version >= Ada_05\n+        and then Is_Build_In_Place_Function (E)\n+      then\n+         declare\n+            Formal_Type        : constant Entity_Id :=\n+                                   Create_Itype\n+                                     (E_Anonymous_Access_Type,\n+                                      E, Scope_Id => Scope (E));\n+            Result_Subt        : constant Entity_Id := Etype (E);\n+            Result_Addr_Formal : Entity_Id;\n+\n+         begin\n+            Set_Directly_Designated_Type (Formal_Type, Result_Subt);\n+            Set_Etype (Formal_Type, Formal_Type);\n+            Init_Size_Align (Formal_Type);\n+            Set_Depends_On_Private\n+              (Formal_Type, Has_Private_Component (Formal_Type));\n+            Set_Is_Public (Formal_Type, Is_Public (Scope (Formal_Type)));\n+            Set_Is_Access_Constant (Formal_Type, False);\n+            Set_Can_Never_Be_Null (Formal_Type);\n+\n+            --  Ada 2005 (AI-50217): Propagate the attribute that indicates\n+            --  the designated type comes from the limited view (for back-end\n+            --  purposes).\n+\n+            Set_From_With_Type (Formal_Type, From_With_Type (Result_Subt));\n+\n+            Layout_Type (Formal_Type);\n+\n+            Result_Addr_Formal := Add_Extra_Formal (E, Formal_Type, E, \"RA\");\n+\n+            --  For some reason the following is not effective and the\n+            --  dereference of the formal within the function still gets\n+            --  a check. ???\n+\n+            Set_Can_Never_Be_Null (Result_Addr_Formal);\n+         end;\n+      end if;\n    end Create_Extra_Formals;\n \n    -----------------------------\n@@ -4334,7 +5177,7 @@ package body Sem_Ch6 is\n                    and then FCE (Left_Opnd  (E1), Left_Opnd  (E2))\n                    and then FCE (Right_Opnd (E1), Right_Opnd (E2));\n \n-            when N_And_Then | N_Or_Else | N_In | N_Not_In =>\n+            when N_And_Then | N_Or_Else | N_Membership_Test =>\n                return\n                  FCE (Left_Opnd  (E1), Left_Opnd  (E2))\n                    and then\n@@ -4902,17 +5745,25 @@ package body Sem_Ch6 is\n      (S            : Entity_Id;\n       Derived_Type : Entity_Id := Empty)\n    is\n-      Does_Override : Boolean := False;\n+      Overridden_Subp : Entity_Id := Empty;\n       --  Set if the current scope has an operation that is type-conformant\n       --  with S, and becomes hidden by S.\n \n       E : Entity_Id;\n       --  Entity that S overrides\n \n       Prev_Vis : Entity_Id := Empty;\n-      --  Needs comment ???\n-\n-      Is_Alias_Interface : Boolean := False;\n+      --  Predecessor of E in Homonym chain\n+\n+      procedure Check_Synchronized_Overriding\n+        (Def_Id          : Entity_Id;\n+         First_Hom       : Entity_Id;\n+         Overridden_Subp : out Entity_Id);\n+      --  First determine if Def_Id is an entry or a subprogram either defined\n+      --  in the scope of a task or protected type, or is a primitive of such\n+      --  a type. Check whether Def_Id overrides a subprogram of an interface\n+      --  implemented by the synchronized type, return the overridden entity\n+      --  or Empty.\n \n       function Is_Private_Declaration (E : Entity_Id) return Boolean;\n       --  Check that E is declared in the private part of the current package,\n@@ -4925,6 +5776,67 @@ package body Sem_Ch6 is\n       --  If the subprogram being analyzed is a primitive operation of\n       --  the type of one of its formals, set the corresponding flag.\n \n+      -----------------------------------\n+      -- Check_Synchronized_Overriding --\n+      -----------------------------------\n+\n+      procedure Check_Synchronized_Overriding\n+        (Def_Id          : Entity_Id;\n+         First_Hom       : Entity_Id;\n+         Overridden_Subp : out Entity_Id)\n+      is\n+         Ifaces_List : Elist_Id;\n+         In_Scope    : Boolean;\n+         Typ         : Entity_Id;\n+\n+      begin\n+         Overridden_Subp := Empty;\n+\n+         --  Def_Id must be an entry or a subprogram\n+\n+         if Ekind (Def_Id) /= E_Entry\n+           and then Ekind (Def_Id) /= E_Function\n+           and then Ekind (Def_Id) /= E_Procedure\n+         then\n+            return;\n+         end if;\n+\n+         --  Def_Id must be declared withing the scope of a protected or\n+         --  task type or be a primitive operation of such a type.\n+\n+         if Present (Scope (Def_Id))\n+           and then Is_Concurrent_Type (Scope (Def_Id))\n+           and then not Is_Generic_Actual_Type (Scope (Def_Id))\n+         then\n+            Typ := Scope (Def_Id);\n+            In_Scope := True;\n+\n+         elsif Present (First_Formal (Def_Id))\n+           and then Is_Concurrent_Type (Etype (First_Formal (Def_Id)))\n+           and then not Is_Generic_Actual_Type (Etype (First_Formal (Def_Id)))\n+         then\n+            Typ := Etype (First_Formal (Def_Id));\n+            In_Scope := False;\n+\n+         else\n+            return;\n+         end if;\n+\n+         --  Gather all limited, protected and task interfaces that Typ\n+         --  implements. Do not collect the interfaces in case of full type\n+         --  declarations because they don't have interface lists.\n+\n+         if Nkind (Parent (Typ)) /= N_Full_Type_Declaration then\n+            Collect_Synchronized_Interfaces (Typ, Ifaces_List);\n+\n+            if not Is_Empty_Elmt_List (Ifaces_List) then\n+               Overridden_Subp :=\n+                 Overrides_Synchronized_Primitive\n+                   (Def_Id, First_Hom, Ifaces_List, In_Scope);\n+            end if;\n+         end if;\n+      end Check_Synchronized_Overriding;\n+\n       ----------------------------\n       -- Is_Private_Declaration --\n       ----------------------------\n@@ -5103,6 +6015,10 @@ package body Sem_Ch6 is\n \n                B_Typ := Base_Type (F_Typ);\n \n+               if Ekind (B_Typ) = E_Access_Subtype then\n+                  B_Typ := Base_Type (B_Typ);\n+               end if;\n+\n                if Scope (B_Typ) = Current_Scope then\n                   Set_Has_Primitive_Operations (B_Typ);\n                   Check_Private_Overriding (B_Typ);\n@@ -5129,13 +6045,12 @@ package body Sem_Ch6 is\n          Check_Dispatching_Operation (S, Empty);\n          Maybe_Primitive_Operation;\n \n-         --  Ada 2005 (AI-397): Subprograms in the context of protected\n-         --  types have their overriding indicators checked in Sem_Ch9.\n+         --  If subprogram has an explicit declaration, check whether it\n+         --  has an overriding indicator.\n \n-         if Ekind (S) not in Subprogram_Kind\n-           or else Ekind (Scope (S)) /= E_Protected_Type\n-         then\n-            Check_Overriding_Indicator (S, False);\n+         if Comes_From_Source (S) then\n+            Check_Synchronized_Overriding (S, Homonym (S), Overridden_Subp);\n+            Check_Overriding_Indicator (S, Overridden_Subp);\n          end if;\n \n       --  If there is a homonym that is not overloadable, then we have an\n@@ -5161,7 +6076,7 @@ package body Sem_Ch6 is\n             Enter_Overloaded_Entity (S);\n             Set_Homonym (S, Homonym (E));\n             Check_Dispatching_Operation (S, Empty);\n-            Check_Overriding_Indicator (S, False);\n+            Check_Overriding_Indicator (S, Empty);\n \n          --  If the subprogram is implicit it is hidden by the previous\n          --  declaration. However if it is dispatching, it must appear in the\n@@ -5195,11 +6110,21 @@ package body Sem_Ch6 is\n       --  E exists and is overloadable\n \n       else\n-         Is_Alias_Interface :=\n-            Present (Alias (S))\n-            and then Is_Dispatching_Operation (Alias (S))\n-            and then Present (DTC_Entity (Alias (S)))\n-            and then Is_Interface (Scope (DTC_Entity (Alias (S))));\n+         --  Ada 2005 (AI-251): Derivation of abstract interface primitives\n+         --  need no check against the homonym chain. They are directly added\n+         --  to the list of primitive operations of Derived_Type.\n+\n+         if Ada_Version >= Ada_05\n+           and then Present (Derived_Type)\n+           and then Is_Dispatching_Operation (Alias (S))\n+           and then Present (Find_Dispatching_Type (Alias (S)))\n+           and then Is_Interface (Find_Dispatching_Type (Alias (S)))\n+           and then not Is_Predefined_Dispatching_Operation (Alias (S))\n+         then\n+            goto Add_New_Entity;\n+         end if;\n+\n+         Check_Synchronized_Overriding (S, E, Overridden_Subp);\n \n          --  Loop through E and its homonyms to determine if any of them is\n          --  the candidate for overriding by S.\n@@ -5213,29 +6138,16 @@ package body Sem_Ch6 is\n \n             --  Check if we have type conformance\n \n-            --  Ada 2005 (AI-251): In case of overriding an interface\n-            --  subprogram it is not an error that the old and new entities\n-            --  have the same profile, and hence we skip this code.\n-\n-            elsif not Is_Alias_Interface\n-              and then Type_Conformant (E, S)\n+            elsif Type_Conformant (E, S) then\n \n-               --  Ada 2005 (AI-251): Do not consider here entities that cover\n-               --  abstract interface primitives. They will be handled after\n-               --  the overriden entity is found (see comments bellow inside\n-               --  this subprogram).\n-\n-              and then not (Is_Subprogram (E)\n-                              and then Present (Abstract_Interface_Alias (E)))\n-            then\n                --  If the old and new entities have the same profile and one\n                --  is not the body of the other, then this is an error, unless\n                --  one of them is implicitly declared.\n \n                --  There are some cases when both can be implicit, for example\n                --  when both a literal and a function that overrides it are\n                --  inherited in a derivation, or when an inhertited operation\n-               --  of a tagged full type overrides the ineherited operation of\n+               --  of a tagged full type overrides the inherited operation of\n                --  a private extension. Ada 83 had a special rule for the the\n                --  literal case. In Ada95, the later implicit operation hides\n                --  the former, and the literal is always the former. In the\n@@ -5272,7 +6184,7 @@ package body Sem_Ch6 is\n                   Set_Is_Overriding_Operation (E);\n \n                   if Comes_From_Source (E) then\n-                     Check_Overriding_Indicator (E, True);\n+                     Check_Overriding_Indicator (E, S);\n \n                      --  Indicate that E overrides the operation from which\n                      --  S is inherited.\n@@ -5327,7 +6239,7 @@ package body Sem_Ch6 is\n                   --  replaced in the list of primitive operations of its type\n                   --  (see Override_Dispatching_Operation).\n \n-                  Does_Override := True;\n+                  Overridden_Subp := E;\n \n                   declare\n                      Prev : Entity_Id;\n@@ -5436,7 +6348,7 @@ package body Sem_Ch6 is\n \n                      Enter_Overloaded_Entity (S);\n                      Set_Is_Overriding_Operation (S);\n-                     Check_Overriding_Indicator (S, True);\n+                     Check_Overriding_Indicator (S, E);\n \n                      --  Indicate that S overrides the operation from which\n                      --  E is inherited.\n@@ -5456,68 +6368,8 @@ package body Sem_Ch6 is\n                         --  AI-117).\n \n                         Set_Convention (S, Convention (E));\n-\n-                        --  AI-251: For an entity overriding an interface\n-                        --  primitive check if the entity also covers other\n-                        --  abstract subprograms in the same scope. This is\n-                        --  required to handle the general case, that is,\n-                        --  1) overriding other interface primitives, and\n-                        --  2) overriding abstract subprograms inherited from\n-                        --  some abstract ancestor type.\n-\n-                        if Has_Homonym (E)\n-                          and then Present (Alias (E))\n-                          and then Ekind (Alias (E)) /= E_Operator\n-                          and then Present (DTC_Entity (Alias (E)))\n-                          and then Is_Interface (Scope (DTC_Entity\n-                                                        (Alias (E))))\n-                        then\n-                           declare\n-                              E1 : Entity_Id;\n-\n-                           begin\n-                              E1 := Homonym (E);\n-                              while Present (E1) loop\n-                                 if (Is_Overloadable (E1)\n-                                       or else Ekind (E1) = E_Subprogram_Type)\n-                                   and then Present (Alias (E1))\n-                                   and then Ekind (Alias (E1)) /= E_Operator\n-                                   and then Present (DTC_Entity (Alias (E1)))\n-                                   and then Is_Abstract\n-                                              (Scope (DTC_Entity (Alias (E1))))\n-                                   and then Type_Conformant (E1, S)\n-                                 then\n-                                    Check_Dispatching_Operation (S, E1);\n-                                 end if;\n-\n-                                 E1 := Homonym (E1);\n-                              end loop;\n-                           end;\n-                        end if;\n-\n                         Check_Dispatching_Operation (S, E);\n \n-                        --  AI-251: Handle the case in which the entity\n-                        --  overrides a primitive operation that covered\n-                        --  several abstract interface primitives.\n-\n-                        declare\n-                           E1 : Entity_Id;\n-                        begin\n-                           E1 := Current_Entity_In_Scope (S);\n-                           while Present (E1) loop\n-                              if Is_Subprogram (E1)\n-                                and then Present\n-                                           (Abstract_Interface_Alias (E1))\n-                                and then Alias (E1) = E\n-                              then\n-                                 Set_Alias (E1, S);\n-                              end if;\n-\n-                              E1 := Homonym (E1);\n-                           end loop;\n-                        end;\n-\n                      else\n                         Check_Dispatching_Operation (S, Empty);\n                      end if;\n@@ -5570,8 +6422,8 @@ package body Sem_Ch6 is\n \n                if May_Hide_Profile then\n                   declare\n-                     F1    : Entity_Id;\n-                     F2    : Entity_Id;\n+                     F1 : Entity_Id;\n+                     F2 : Entity_Id;\n                   begin\n                      F1 := First_Formal (S);\n                      F2 := First_Formal (E);\n@@ -5607,15 +6459,16 @@ package body Sem_Ch6 is\n                end if;\n             end if;\n \n-            Prev_Vis := E;\n             E := Homonym (E);\n          end loop;\n \n+         <<Add_New_Entity>>\n+\n          --  On exit, we know that S is a new entity\n \n          Enter_Overloaded_Entity (S);\n          Maybe_Primitive_Operation;\n-         Check_Overriding_Indicator (S, Does_Override);\n+         Check_Overriding_Indicator (S, Overridden_Subp);\n \n          --  If S is a derived operation for an untagged type then by\n          --  definition it's not a dispatching operation (even if the parent\n@@ -5701,10 +6554,10 @@ package body Sem_Ch6 is\n \n             Formal_Type := Entity (Ptype);\n \n-            if Ekind (Formal_Type) = E_Incomplete_Type\n-              or else (Is_Class_Wide_Type (Formal_Type)\n-                        and then Ekind (Root_Type (Formal_Type)) =\n-                                                         E_Incomplete_Type)\n+            if Is_Incomplete_Type (Formal_Type)\n+              or else\n+               (Is_Class_Wide_Type (Formal_Type)\n+                  and then Is_Incomplete_Type (Root_Type (Formal_Type)))\n             then\n                --  Ada 2005 (AI-326): Tagged incomplete types allowed\n \n@@ -5728,22 +6581,26 @@ package body Sem_Ch6 is\n             --  type of the formal with the internal subtype.\n \n             if Ada_Version >= Ada_05\n-              and then Is_Access_Type (Formal_Type)\n               and then Null_Exclusion_Present (Param_Spec)\n             then\n-               if Can_Never_Be_Null (Formal_Type)\n-                 and then Comes_From_Source (Related_Nod)\n-               then\n-                  Error_Msg_N\n-                    (\"null exclusion must apply to a type that does not \"\n-                       & \"exclude null ('R'M 3.10 (14)\", Related_Nod);\n-               end if;\n+               if not Is_Access_Type (Formal_Type) then\n+                  Error_Msg_N (\"null-exclusion must be applied to an \" &\n+                               \"access type\", Param_Spec);\n+               else\n+                  if Can_Never_Be_Null (Formal_Type)\n+                    and then Comes_From_Source (Related_Nod)\n+                  then\n+                     Error_Msg_N\n+                       (\"null-exclusion cannot be applied to \" &\n+                        \"a null excluding type\", Param_Spec);\n+                  end if;\n \n-               Formal_Type :=\n-                 Create_Null_Excluding_Itype\n-                   (T           => Formal_Type,\n-                    Related_Nod => Related_Nod,\n-                    Scope_Id    => Scope (Current_Scope));\n+                  Formal_Type :=\n+                    Create_Null_Excluding_Itype\n+                      (T           => Formal_Type,\n+                       Related_Nod => Related_Nod,\n+                       Scope_Id    => Scope (Current_Scope));\n+               end if;\n             end if;\n \n          --  An access formal type"}, {"sha": "52b657080bc5d5d9f1d451c0201e8288c31bd56b", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4867fab9418c5b8ab6917e6accd3a9822e96c6/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4867fab9418c5b8ab6917e6accd3a9822e96c6/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=ec4867fab9418c5b8ab6917e6accd3a9822e96c6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@ with Types; use Types;\n package Sem_Ch6 is\n \n    procedure Analyze_Abstract_Subprogram_Declaration (N : Node_Id);\n+   procedure Analyze_Extended_Return_Statement       (N : Node_Id);\n    procedure Analyze_Function_Call                   (N : Node_Id);\n    procedure Analyze_Operator_Symbol                 (N : Node_Id);\n    procedure Analyze_Parameter_Association           (N : Node_Id);\n@@ -48,6 +49,11 @@ package Sem_Ch6 is\n    --  If Subp is not Always_Inlined, then a warning is issued if the flag\n    --  Ineffective_Inline_Warnings is set, and if not, the call has no effect.\n \n+   procedure Check_Conventions (Typ : Entity_Id);\n+   --  Ada 2005 (AI-430): Check that the conventions of all inherited and\n+   --  overridden dispatching operations of type Typ are consistent with\n+   --  their respective counterparts.\n+\n    procedure Check_Delayed_Subprogram (Designator : Entity_Id);\n    --  Designator can be a E_Subrpgram_Type, E_Procedure or E_Function. If a\n    --  type in its profile depends on a private type without a full"}]}