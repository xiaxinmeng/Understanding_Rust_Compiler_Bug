{"sha": "a3895f55f7b6278ed4ce31883d75ed3094da96af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM4OTVmNTVmN2I2Mjc4ZWQ0Y2UzMTg4M2Q3NWVkMzA5NGRhOTZhZg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2006-12-12T13:07:39Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2006-12-12T13:07:39Z"}, "message": "tree-vect-analyze.c (vect_analyze_data_ref_access): Add another check for stores with gaps.\n\n\t* tree-vect-analyze.c (vect_analyze_data_ref_access): Add another check\n\tfor stores with gaps.\n\t* tree-vect-transform.c (vect_permute_store_chain): Create\n\tinterleave_high or interleave_low according to the endianess.\n\nFrom-SVN: r119779", "tree": {"sha": "a7c9004d84030f2e840f713009d443402d46a395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7c9004d84030f2e840f713009d443402d46a395"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3895f55f7b6278ed4ce31883d75ed3094da96af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3895f55f7b6278ed4ce31883d75ed3094da96af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3895f55f7b6278ed4ce31883d75ed3094da96af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3895f55f7b6278ed4ce31883d75ed3094da96af/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2c104d8b62382883eb3a704f56b7394f2c1e8e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c104d8b62382883eb3a704f56b7394f2c1e8e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c104d8b62382883eb3a704f56b7394f2c1e8e6"}], "stats": {"total": 259, "additions": 249, "deletions": 10}, "files": [{"sha": "23721c40105877683cb14065ffa5d5700132cadd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3895f55f7b6278ed4ce31883d75ed3094da96af", "patch": "@@ -1,3 +1,10 @@\n+2006-12-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vect-analyze.c (vect_analyze_data_ref_access): Add another check\n+\tfor stores with gaps.\n+\t* tree-vect-transform.c (vect_permute_store_chain): Create\n+\tinterleave_high or interleave_low according to the endianess.\n+\n 2006-12-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/30147"}, {"sha": "724bd05c827786593e6ec8a0e770090e6b773c84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3895f55f7b6278ed4ce31883d75ed3094da96af", "patch": "@@ -1,3 +1,11 @@\n+2006-12-12  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-strided-store-u32-i2.c: New test.\n+\t* gcc.dg/vect/vect-strided-store-a-u8-i2.c: New test.\n+\t* gcc.dg/vect/vect-strided-store-u16-i4.c: New test.\n+\t* gcc.dg/vect/vect-strided-u8-i8-gap4.c: Add a case of stores with\n+\tgaps.\n+\n 2006-12-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/30147"}, {"sha": "e7125b1458d20e1dd7c99f572f5df31bba45f93c", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-store-a-u8-i2.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-a-u8-i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-a-u8-i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-a-u8-i2.c?ref=a3895f55f7b6278ed4ce31883d75ed3094da96af", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+} s;\n+\n+int\n+main1 ()\n+{\n+  s arr[N];\n+  s *ptr = arr;\n+  s res[N];\n+  int i;\n+  unsigned char a[N], b[N];\n+\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i * 2;\n+      if (a[i] == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].a = a[i] + 3;\n+      res[i].b = a[i] + b[i];\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != a[i] + 3\n+          || res[i].b != a[i] + b[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "629ab79b7c31ed3d741161a7258f0fee63b5b003", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-store-u16-i4.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-u16-i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-u16-i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-u16-i4.c?ref=a3895f55f7b6278ed4ce31883d75ed3094da96af", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+   unsigned short c;\n+   unsigned short d;\n+} s;\n+\n+unsigned short a[N];\n+unsigned short b[N];\n+unsigned short c[N];\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+  unsigned short x, y, z, w;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = a[i];\n+      res[i].a = b[i];\n+      res[i].d = c[i];\n+      res[i].b = a[i] + b [i];\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].c != a[i]\n+          || res[i].a != b[i]\n+          || res[i].d != c[i]\n+          || res[i].b != a[i] + b[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i * 2;\n+      c[i] = 17;\n+      if (a[i] == 178)\n+         abort();\n+    }\n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "ec810985b154a10233d235d88f413dd49582f7ee", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-store-u32-i2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-u32-i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-u32-i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-store-u32-i2.c?ref=a3895f55f7b6278ed4ce31883d75ed3094da96af", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+int\n+main1 (void)\n+{\n+  int i;\n+  int a[N*2];\n+  int b[N] = {0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30};\n+  int c[N] = {1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31};\n+\n+  /* Strided access pattern.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      a[i*2] = b[i] + c[i];\n+      a[i*2+1] = b[i] * c[i];\n+    }\n+\n+  /* Check results.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (a[i*2] != b[i] + c[i]\n+          || a[i*2+1] != b[i] * c[i])\n+        abort();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  return main1 ();\n+}\n+\n+/* Needs interleaving support.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { xfail { vect_interleave } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "75691467e9ae79982f8d8ad89513e8e315b8e9f5", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4.c?ref=a3895f55f7b6278ed4ce31883d75ed3094da96af", "patch": "@@ -49,8 +49,26 @@ main1 (s *arr)\n           || res[i].e != arr[i].b + arr[i].e\n           || res[i].h != arr[i].c\n           || res[i].g != arr[i].b + arr[i].c)\n-          abort();\n+          abort ();\n    }\n+\n+  ptr = arr;\n+  /* Not vectorizable: gap in store. */\n+  for (i = 0; i < N; i++)\n+    { \n+      res[i].a = ptr->b;\n+      res[i].b = ptr->c;\n+      ptr++; \n+    }\n+  \n+  /* Check results.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != arr[i].b \n+\t  || res[i].b != arr[i].c)\n+          abort ();\n+    }\n+\n }\n \n "}, {"sha": "c8b2bf858d6e1fc7512eccf521fe41bb4c8d5c27", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=a3895f55f7b6278ed4ce31883d75ed3094da96af", "patch": "@@ -1804,7 +1804,8 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n       /* COUNT is the number of accesses found, we multiply it by the size of \n \t the type to get COUNT_IN_BYTES.  */\n       count_in_bytes = type_size * count;\n-      /* Check the size of the interleaving is not greater than STEP.  */\n+\n+      /* Check that the size of the interleaving is not greater than STEP.  */\n       if (dr_step < count_in_bytes) \n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1815,6 +1816,15 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t  return false;\n \t}\n \n+      /* Check that the size of the interleaving is equal to STEP for stores, \n+         i.e., that there are no gaps.  */ \n+      if (!DR_IS_READ (dr) && dr_step != count_in_bytes) \n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"interleaved store with gaps\");\n+\t  return false;\n+\t}\n+\n       /* Check that STEP is a multiple of type size.  */\n       if ((dr_step % type_size) != 0)\n \t{"}, {"sha": "f83d92a39ff269bce7a1ea4a0a4aeb34d610a44d", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3895f55f7b6278ed4ce31883d75ed3094da96af/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=a3895f55f7b6278ed4ce31883d75ed3094da96af", "patch": "@@ -2592,23 +2592,41 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t  vect1 = VEC_index (tree, dr_chain, j);\n \t  vect2 = VEC_index (tree, dr_chain, j+length/2);\n \n-\t  /* high = interleave_high (vect1, vect2);  */\n+\t  /* Create interleaving stmt:\n+\t     in the case of big endian: \n+                                high = interleave_high (vect1, vect2) \n+             and in the case of little endian: \n+                                high = interleave_low (vect1, vect2).  */\n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_high\");\n \t  add_referenced_var (perm_dest);\n-\t  perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n-\t\t\t      build2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, vect1, \n-\t\t\t\t      vect2));\n+          if (BYTES_BIG_ENDIAN)\n+\t    perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n+\t        \t\tbuild2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, \n+                                        vect1, vect2)); \n+\t  else\n+            perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n+                                build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, \n+                                        vect1, vect2));\n \t  high = make_ssa_name (perm_dest, perm_stmt);\n \t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = high;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n \t  VEC_replace (tree, *result_chain, 2*j, high);\n \n-\t  /* low = interleave_low (vect1, vect2);  */\n+\t  /* Create interleaving stmt:\n+             in the case of big endian:\n+                               low  = interleave_low (vect1, vect2) \n+             and in the case of little endian:\n+                               low  = interleave_high (vect1, vect2).  */     \n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_low\");\n \t  add_referenced_var (perm_dest);\n-\t  perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n-\t\t\t      build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, vect1, \n-\t\t\t\t      vect2));\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n+\t               \t        build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, \n+ \t\t\t\t\tvect1, vect2));\n+\t  else\n+            perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n+                                build2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, \n+                                        vect1, vect2));\n \t  low = make_ssa_name (perm_dest, perm_stmt);\n \t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = low;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);"}]}