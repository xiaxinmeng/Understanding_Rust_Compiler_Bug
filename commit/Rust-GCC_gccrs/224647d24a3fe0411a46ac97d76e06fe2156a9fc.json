{"sha": "224647d24a3fe0411a46ac97d76e06fe2156a9fc", "node_id": "C_kwDOANBUbNoAKDIyNDY0N2QyNGEzZmUwNDExYTQ2YWM5N2Q3NmUwNmZlMjE1NmE5ZmM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-05-06T11:22:46Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-05-06T15:34:13Z"}, "message": "Ensure the coercion sites are applied correctly on unions\n\nWhen we construct a union, we were wrongly compiling the constructor\nwithout taking into account the associated union index. This means we ended\nup trying to coerce the wrong field which was always zero here which\nresulted in a silent failure by returning error mark node.\n\nThe offending test case was: gcc/testsuite/execute/torture/slice1.rs", "tree": {"sha": "dcc8637223ee6d471fe84e39b4336b4e419fd84f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcc8637223ee6d471fe84e39b4336b4e419fd84f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/224647d24a3fe0411a46ac97d76e06fe2156a9fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224647d24a3fe0411a46ac97d76e06fe2156a9fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224647d24a3fe0411a46ac97d76e06fe2156a9fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224647d24a3fe0411a46ac97d76e06fe2156a9fc/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ea940e4dcabbf99fbb44c125a0af7cf82e48146", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ea940e4dcabbf99fbb44c125a0af7cf82e48146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ea940e4dcabbf99fbb44c125a0af7cf82e48146"}], "stats": {"total": 48, "additions": 41, "deletions": 7}, "files": [{"sha": "79d9e577dd2ac9cf55e710c53a382fd83875ecf3", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224647d24a3fe0411a46ac97d76e06fe2156a9fc/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224647d24a3fe0411a46ac97d76e06fe2156a9fc/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=224647d24a3fe0411a46ac97d76e06fe2156a9fc", "patch": "@@ -419,18 +419,19 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n     // compile it\n     tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n-    // this assumes all fields are in order from type resolution and if a base\n-    // struct was specified those fields are filed via accesors\n     std::vector<tree> arguments;\n-    for (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n+    if (adt->is_union ())\n       {\n+\trust_assert (struct_expr.get_fields ().size () == 1);\n+\n \t// assignments are coercion sites so lets convert the rvalue if\n \t// necessary\n-\tauto respective_field = variant->get_field_at_index (i);\n+\tauto respective_field\n+\t  = variant->get_field_at_index (union_disriminator);\n \tauto expected = respective_field->get_field_type ();\n \n \t// process arguments\n-\tauto &argument = struct_expr.get_fields ().at (i);\n+\tauto &argument = struct_expr.get_fields ().at (0);\n \tauto lvalue_locus\n \t  = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n \tauto rvalue_locus = argument->get_locus ();\n@@ -440,8 +441,6 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \tbool ok = ctx->get_tyctx ()->lookup_type (\n \t  argument->get_mappings ().get_hirid (), &actual);\n \n-\t// coerce it if required/possible see\n-\t// compile/torture/struct_base_init_1.rs\n \tif (ok)\n \t  {\n \t    rvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n@@ -451,6 +450,41 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \t// add it to the list\n \targuments.push_back (rvalue);\n       }\n+    else\n+      {\n+\t// this assumes all fields are in order from type resolution and if a\n+\t// base struct was specified those fields are filed via accesors\n+\tfor (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n+\t  {\n+\t    // assignments are coercion sites so lets convert the rvalue if\n+\t    // necessary\n+\t    auto respective_field = variant->get_field_at_index (i);\n+\t    auto expected = respective_field->get_field_type ();\n+\n+\t    // process arguments\n+\t    auto &argument = struct_expr.get_fields ().at (i);\n+\t    auto lvalue_locus\n+\t      = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+\t    auto rvalue_locus = argument->get_locus ();\n+\t    auto rvalue\n+\t      = CompileStructExprField::Compile (argument.get (), ctx);\n+\n+\t    TyTy::BaseType *actual = nullptr;\n+\t    bool ok = ctx->get_tyctx ()->lookup_type (\n+\t      argument->get_mappings ().get_hirid (), &actual);\n+\n+\t    // coerce it if required/possible see\n+\t    // compile/torture/struct_base_init_1.rs\n+\t    if (ok)\n+\t      {\n+\t\trvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n+\t\t\t\t\trvalue_locus);\n+\t      }\n+\n+\t    // add it to the list\n+\t    arguments.push_back (rvalue);\n+\t  }\n+      }\n \n     // the constructor depends on whether this is actually an enum or not if\n     // its an enum we need to setup the discriminator"}]}