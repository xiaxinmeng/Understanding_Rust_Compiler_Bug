{"sha": "2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZhOTQ0M2VlOTI1MTYwMDJkM2UzYTU4ZWZmNGMxYzViMDMwZGZkZA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-06-06T10:27:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:27:41Z"}, "message": "exp_prag.adb (Expand_Pragma_Import_Or_Interface): Remove properly a default initialization on an imported object...\n\n2007-04-20  Ed Schonberg  <schonberg@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_prag.adb (Expand_Pragma_Import_Or_Interface): Remove properly a\n\tdefault initialization on an imported object, when there is no\n\tinitialization call generated for it.\n\t(Expand_Pragma_Assert): Add handling of No_Exception_Propagation\n\trestriction\n\n\t* snames.h, snames.ads, snames.adb, par-prag.adb: New pragma\n\tStatic_Elaboration_Desired.\n\tRemove pragma Thread_Body.\n\tImplement a new pragma No_Body\n\tRemoves the Explicit_Overriding pragma\n\tRemove Optional_Overriding pragma\n\t(Prag): Deal with Universal_Aliasing.\n\t(Name_CIL, Name_CIL_Constructor, Convention_CIL,\n\tPragma_CIL_Constructor): New names.\n\n\t* sem_cat.adb (Validate_Object_Declaration): An initialization that\n\tuses the equivalent aggregate of a type must be treated as an implicit\n\tinitialization.\n\t(Get_Categorization): Check a unit for pragma Preelaborate only if it\n\thas none of the other categories.\n\t(Process_Import_Or_Interface_Pragma): Report an error for an attempt\n\tto apply Import to an object renaming declaration.\n\n\t* sem_prag.adb (Process_Import_Or_Interface): Warn that a type imported\n\tfrom a C++ class should be declared as limited and that it will be\n\tconsidererd limited.\n\t(Analyze_Pragma): Warn that a type specified with pragma CPP_Class\n\tshould be declared as limited and that it will be considererd limited.\n\t(Ada_2005_Pragma): New procedure, used to deal with Ada 2005 pragmas\n\t(Analyze_Pragma, case Export): Diagnose export of enumeration literal\n\t(Analyze_Pragma): Deal with Universal_Aliasing.\n\t(Sig_Flags): Likewise.\n\t(Set_Encoded_Interface_Name): Suppress encoding when compiling for AAMP.\n\t(Overflow_Checks_Unsuppressed): New flag.\n\t(Process_Suppress_Unsuppress): Set Overflow_Checks_Unsuppressed.\n\t(Analyze_Pragma [case Pack]): Ignore pragma Pack and post warning in\n\tcase of JVM or .NET targets, and compiling user code.\n\tAdd debugging convenience routine rv\n\nFrom-SVN: r125408", "tree": {"sha": "5d2107f02e060dc7b88a186a48e40cf696cf91db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d2107f02e060dc7b88a186a48e40cf696cf91db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d8b9c9990b3e3cc13303e3dd0057ff87994120b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8b9c9990b3e3cc13303e3dd0057ff87994120b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8b9c9990b3e3cc13303e3dd0057ff87994120b"}], "stats": {"total": 2144, "additions": 1173, "deletions": 971}, "files": [{"sha": "710ff7d5adfbd858eb377da7b8e4a781d3831e45", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 70, "deletions": 27, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,6 +26,7 @@\n \n with Atree;    use Atree;\n with Casing;   use Casing;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n@@ -36,6 +37,8 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Eval; use Sem_Eval;\n@@ -239,7 +242,7 @@ package body Exp_Prag is\n \n       --  Since assertions are on, we rewrite the pragma with its\n       --  corresponding if statement, and then analyze the statement\n-      --  The expansion transforms:\n+      --  The normal case expansion transforms:\n \n       --    pragma Assert (condition [,message]);\n \n@@ -252,30 +255,70 @@ package body Exp_Prag is\n       --  where Str is the message if one is present, or the default of\n       --  file:line if no message is given.\n \n-      --  First, we need to prepare the character literal\n+      --  An alternative expansion is used when the No_Exception_Propagation\n+      --  restriction is active and there is a local Assert_Failure handler.\n+      --  This is not a common combination of circumstances, but it occurs in\n+      --  the context of Aunit and the zero footprint profile. In this case we\n+      --  generate:\n \n-      if Present (Arg2 (N)) then\n-         Msg := Strval (Expr_Value_S (Arg2 (N)));\n-      else\n-         Build_Location_String (Loc);\n-         Msg := String_From_Name_Buffer;\n-      end if;\n+      --    if not condition then\n+      --       raise Assert_Failure;\n+      --    end if;\n \n-      --  Now generate the if statement. Note that we consider this to be\n-      --  an explicit conditional in the source, not an implicit if, so we\n+      --  This will then be transformed into a goto, and the local handler will\n+      --  be able to handle the assert error (which would not be the case if a\n+      --  call is made to the Raise_Assert_Failure procedure).\n+\n+      --  Note that the reason we do not always generate a direct raise is that\n+      --  the form in which the procedure is called allows for more efficient\n+      --  breakpointing of assertion errors.\n+\n+      --  Generate the appropriate if statement. Note that we consider this to\n+      --  be an explicit conditional in the source, not an implicit if, so we\n       --  do not call Make_Implicit_If_Statement.\n \n-      Rewrite (N,\n-        Make_If_Statement (Loc,\n-          Condition =>\n-            Make_Op_Not (Loc,\n-              Right_Opnd => Cond),\n-          Then_Statements => New_List (\n-            Make_Procedure_Call_Statement (Loc,\n-              Name =>\n-                New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n-              Parameter_Associations => New_List (\n-                Make_String_Literal (Loc, Msg))))));\n+      --  Case where we generate a direct raise\n+\n+      if (Debug_Flag_Dot_G\n+          or else Restriction_Active (No_Exception_Propagation))\n+        and then Present (Find_Local_Handler (RTE (RE_Assert_Failure), N))\n+      then\n+         Rewrite (N,\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd => Cond),\n+             Then_Statements => New_List (\n+               Make_Raise_Statement (Loc,\n+                 Name =>\n+                   New_Reference_To (RTE (RE_Assert_Failure), Loc)))));\n+\n+      --  Case where we call the procedure\n+\n+      else\n+         --  First, we need to prepare the string literal\n+\n+         if Present (Arg2 (N)) then\n+            Msg := Strval (Expr_Value_S (Arg2 (N)));\n+         else\n+            Build_Location_String (Loc);\n+            Msg := String_From_Name_Buffer;\n+         end if;\n+\n+         --  Now rewrite as an if statement\n+\n+         Rewrite (N,\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd => Cond),\n+             Then_Statements => New_List (\n+               Make_Procedure_Call_Statement (Loc,\n+                 Name =>\n+                   New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n+                 Parameter_Associations => New_List (\n+                   Make_String_Literal (Loc, Msg))))));\n+      end if;\n \n       Analyze (N);\n \n@@ -284,9 +327,8 @@ package body Exp_Prag is\n       if Nkind (N) = N_Procedure_Call_Statement\n         and then Is_RTE (Entity (Name (N)), RE_Raise_Assert_Failure)\n       then\n-         --  If original condition was a Standard.False, we assume\n-         --  that this is indeed intented to raise assert error\n-         --  and no warning is required.\n+         --  If original condition was a Standard.False, we assume that this is\n+         --  indeed intented to raise assert error and no warning is required.\n \n          if Is_Entity_Name (Original_Node (Cond))\n            and then Entity (Original_Node (Cond)) = Standard_False\n@@ -389,7 +431,8 @@ package body Exp_Prag is\n       if Ekind (Def_Id) = E_Variable then\n          Typ  := Etype (Def_Id);\n \n-         --  Loop to ???\n+         --  Iterate from declaration of object to import pragma, to find\n+         --  generated initialization call for object, if any.\n \n          Init_Call := Next (Parent (Def_Id));\n          while Present (Init_Call) and then Init_Call /= N loop\n@@ -411,7 +454,7 @@ package body Exp_Prag is\n          --  have explicit initialization, so the expression must have\n          --  been generated by the compiler.\n \n-         if No (Init_Call)\n+         if Init_Call = N\n            and then Present (Expression (Parent (Def_Id)))\n          then\n             Set_Expression (Parent (Def_Id), Empty);"}, {"sha": "6e791b565d42ed589b4c62eafe8c9078cf0d6d87", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -518,7 +518,7 @@ begin\n             Expr  : Node_Id;\n             Index : Nat;\n \n-            function Get_Fname (Arg : Node_Id) return Name_Id;\n+            function Get_Fname (Arg : Node_Id) return File_Name_Type;\n             --  Process file name from unit name form of pragma\n \n             function Get_String_Argument (Arg : Node_Id) return String_Ptr;\n@@ -534,7 +534,7 @@ begin\n             -- Get_Fname --\n             ---------------\n \n-            function Get_Fname (Arg : Node_Id) return Name_Id is\n+            function Get_Fname (Arg : Node_Id) return File_Name_Type is\n             begin\n                String_To_Name_Buffer (Strval (Expression (Arg)));\n \n@@ -803,7 +803,7 @@ begin\n       --  turn off semantic checking anyway if any parse errors are found.\n \n       when Pragma_Source_Reference => Source_Reference : declare\n-         Fname : Name_Id;\n+         Fname : File_Name_Type;\n \n       begin\n          if Arg_Count /= 1 then\n@@ -833,7 +833,7 @@ begin\n                   Pragma_Sloc);\n                raise Error_Resync;\n             else\n-               Fname := No_Name;\n+               Fname := No_File;\n             end if;\n \n          --  File name present\n@@ -1054,6 +1054,7 @@ begin\n            Pragma_Atomic                        |\n            Pragma_Atomic_Components             |\n            Pragma_Attach_Handler                |\n+           Pragma_CIL_Constructor               |\n            Pragma_Compile_Time_Error            |\n            Pragma_Compile_Time_Warning          |\n            Pragma_Convention_Identifier         |\n@@ -1077,7 +1078,6 @@ begin\n            Pragma_Elaborate_All                 |\n            Pragma_Elaborate_Body                |\n            Pragma_Elaboration_Checks            |\n-           Pragma_Explicit_Overriding           |\n            Pragma_Export                        |\n            Pragma_Export_Exception              |\n            Pragma_Export_Function               |\n@@ -1123,13 +1123,13 @@ begin\n            Pragma_Main                          |\n            Pragma_Main_Storage                  |\n            Pragma_Memory_Size                   |\n+           Pragma_No_Body                       |\n            Pragma_No_Return                     |\n            Pragma_Obsolescent                   |\n            Pragma_No_Run_Time                   |\n            Pragma_No_Strict_Aliasing            |\n            Pragma_Normalize_Scalars             |\n            Pragma_Optimize                      |\n-           Pragma_Optional_Overriding           |\n            Pragma_Pack                          |\n            Pragma_Passive                       |\n            Pragma_Preelaborable_Initialization  |\n@@ -1157,6 +1157,7 @@ begin\n            Pragma_Shared_Passive                |\n            Pragma_Storage_Size                  |\n            Pragma_Storage_Unit                  |\n+           Pragma_Static_Elaboration_Desired    |\n            Pragma_Stream_Convert                |\n            Pragma_Subtitle                      |\n            Pragma_Suppress                      |\n@@ -1169,11 +1170,11 @@ begin\n            Pragma_Task_Info                     |\n            Pragma_Task_Name                     |\n            Pragma_Task_Storage                  |\n-           Pragma_Thread_Body                   |\n            Pragma_Time_Slice                    |\n            Pragma_Title                         |\n            Pragma_Unchecked_Union               |\n            Pragma_Unimplemented_Unit            |\n+           Pragma_Universal_Aliasing            |\n            Pragma_Universal_Data                |\n            Pragma_Unreferenced                  |\n            Pragma_Unreferenced_Objects          |"}, {"sha": "409090c312a88dcb512a160cd9053f3889c4114a", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Fname;    use Fname;\n with Lib;      use Lib;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Sem;      use Sem;\n@@ -120,9 +121,13 @@ package body Sem_Cat is\n    is\n       N : constant Node_Id := Info_Node;\n \n-      --  Here we define an enumeration type to represent categorization\n-      --  types, ordered so that a unit with a given categorization can\n-      --  only WITH units with lower or equal categorization type.\n+      --  Here we define an enumeration type to represent categorization types,\n+      --  ordered so that a unit with a given categorization can only WITH\n+      --  units with lower or equal categorization type.\n+\n+      --  Note that we take advantage of E.2(14) to define a category\n+      --  Preelaborated and treat pragma Preelaborate as a categorization\n+      --  pragma that defines that category.\n \n       type Categorization is\n         (Pure,\n@@ -132,25 +137,26 @@ package body Sem_Cat is\n          Preelaborated,\n          Normal);\n \n-      Unit_Category : Categorization;\n-      With_Category : Categorization;\n-\n       function Get_Categorization (E : Entity_Id) return Categorization;\n       --  Check categorization flags from entity, and return in the form\n-      --  of a corresponding enumeration value.\n+      --  of the lowest value of the Categorization type that applies to E.\n \n       ------------------------\n       -- Get_Categorization --\n       ------------------------\n \n       function Get_Categorization (E : Entity_Id) return Categorization is\n       begin\n-         if Is_Preelaborated (E) then\n-            return Preelaborated;\n+         --  Get the lowest categorization that corresponds to E. Note that\n+         --  nothing prevents several (different) categorization pragmas\n+         --  to apply to the same library unit, in which case the unit has\n+         --  all associated categories, so we need to be careful here to\n+         --  check pragmas in proper Categorization order in order to\n+         --  return the lowest appplicable value.\n \n-            --  Ignore Pure specification if set by pragma Pure_Function\n+         --  Ignore Pure specification if set by pragma Pure_Function\n \n-         elsif Is_Pure (E)\n+         if Is_Pure (E)\n            and then not\n              (Has_Pragma_Pure_Function (E) and not Has_Pragma_Pure (E))\n          then\n@@ -165,11 +171,17 @@ package body Sem_Cat is\n          elsif Is_Remote_Call_Interface (E) then\n             return Remote_Call_Interface;\n \n+         elsif Is_Preelaborated (E) then\n+            return Preelaborated;\n+\n          else\n             return Normal;\n          end if;\n       end Get_Categorization;\n \n+      Unit_Category : Categorization;\n+      With_Category : Categorization;\n+\n    --  Start of processing for Check_Categorization_Dependencies\n \n    begin\n@@ -1049,8 +1061,20 @@ package body Sem_Cat is\n          --  Check for default initialized variable case. Note that in\n          --  accordance with (RM B.1(24)) imported objects are not\n          --  subject to default initialization.\n+         --  If the initialization does not come from source and is an\n+         --  aggregate, it is a static initialization that replaces an\n+         --  implicit call, and must be treated as such.\n+\n+         if Present (E)\n+           and then\n+            (Comes_From_Source (E) or else Nkind (E) /= N_Aggregate)\n+         then\n+            null;\n \n-         if No (E) and then not Is_Imported (Id) then\n+         elsif Is_Imported (Id) then\n+            null;\n+\n+         else\n             declare\n                Ent : Entity_Id := T;\n \n@@ -1129,23 +1153,30 @@ package body Sem_Cat is\n                           (\"private object not allowed in preelaborated unit\",\n                            N);\n \n-                        --  If we are in Ada 2005 mode, add a message if pragma\n+                        --  Add a message if it would help to provide a pragma\n                         --  Preelaborable_Initialization on the type of the\n-                        --  object would help.\n+                        --  object (which would make it legal in Ada 2005).\n \n                         --  If the type has no full view (generic type, or\n                         --  previous error), the warning does not apply.\n \n-                        if Ada_Version >= Ada_05\n-                          and then Is_Private_Type (Ent)\n+                        if Is_Private_Type (Ent)\n                           and then Present (Full_View (Ent))\n                           and then\n                             Has_Preelaborable_Initialization (Full_View (Ent))\n                         then\n                            Error_Msg_Sloc := Sloc (Ent);\n-                           Error_Msg_NE\n-                             (\"\\would be legal if pragma Preelaborable_\" &\n-                              \"Initialization given for & #\", N, Ent);\n+\n+                           if Ada_Version >= Ada_05 then\n+                              Error_Msg_NE\n+                                (\"\\would be legal if pragma Preelaborable_\" &\n+                                 \"Initialization given for & #\", N, Ent);\n+                           else\n+                              Error_Msg_NE\n+                                (\"\\would be legal in Ada 2005 if pragma \" &\n+                                 \"Preelaborable_Initialization given for & #\",\n+                                 N, Ent);\n+                           end if;\n                         end if;\n                      end if;\n                   end if;"}, {"sha": "5f4b95d2ae63f0351feb901dfe03a1f3738d7fe2", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 244, "deletions": 141, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,7 +37,6 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Dist; use Exp_Dist;\n-with Hostparm; use Hostparm;\n with Lib;      use Lib;\n with Lib.Writ; use Lib.Writ;\n with Lib.Xref; use Lib.Xref;\n@@ -174,6 +173,12 @@ package body Sem_Prag is\n    --  (the original one, following the renaming chain) is returned.\n    --  Otherwise the entity is returned unchanged. Should be in Einfo???\n \n+   procedure rv;\n+   --  This is a dummy function called by the processing for pragma Reviewable.\n+   --  It is there for assisting front end debugging. By placing a Reviewable\n+   --  pragma in the source program, a breakpoint on rv catches this place in\n+   --  the source, allowing convenient stepping to the point of interest.\n+\n    procedure Set_Unit_Name (N : Node_Id; With_Item : Node_Id);\n    --  Place semantic information on the argument of an Elaborate or\n    --  Elaborate_All pragma. Entity name for unit and its parents is\n@@ -253,6 +258,11 @@ package body Sem_Prag is\n       type Args_List is array (Natural range <>) of Node_Id;\n       --  Types used for arguments to Check_Arg_Order and Gather_Associations\n \n+      procedure Ada_2005_Pragma;\n+      --  Called for pragmas defined in Ada 2005, that are not in Ada 95. In\n+      --  Ada 95 mode, these are implementation defined pragmas, so should be\n+      --  caught by the No_Implementation_Pragmas restriction\n+\n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n       --  83 mode (used for language pragmas that are not a standard part of\n@@ -482,8 +492,8 @@ package body Sem_Prag is\n       --  returned, otherwise Arg is returned unchanged.\n \n       procedure GNAT_Pragma;\n-      --  Called for all GNAT defined pragmas to note the use of the feature,\n-      --  and also check the relevant restriction (No_Implementation_Pragmas).\n+      --  Called for all GNAT defined pragmas to check the relevant restriction\n+      --  (No_Implementation_Pragmas).\n \n       function Is_Before_First_Decl\n         (Pragma_Node : Node_Id;\n@@ -633,6 +643,17 @@ package body Sem_Prag is\n       --  node, which is used for error messages on any constructs\n       --  that violate the profile.\n \n+      ---------------------\n+      -- Ada_2005_Pragma --\n+      ---------------------\n+\n+      procedure Ada_2005_Pragma is\n+      begin\n+         if Ada_Version <= Ada_95 then\n+            Check_Restriction (No_Implementation_Pragmas, N);\n+         end if;\n+      end Ada_2005_Pragma;\n+\n       --------------------------\n       -- Check_Ada_83_Warning --\n       --------------------------\n@@ -1417,8 +1438,8 @@ package body Sem_Prag is\n                      Pragma_Misplaced;\n \n                   elsif (Nkind (Parent_Node) = N_Generic_Package_Declaration\n-                          or else Nkind (Parent_Node)\n-                            = N_Generic_Subprogram_Declaration)\n+                           or else Nkind (Parent_Node) =\n+                                             N_Generic_Subprogram_Declaration)\n                     and then Plist = Generic_Formal_Declarations (Parent_Node)\n                   then\n                      Pragma_Misplaced;\n@@ -2198,6 +2219,10 @@ package body Sem_Prag is\n             Error_Pragma_Arg (\"entity name required\", Arg2);\n          end if;\n \n+         if Ekind (Entity (Id)) = E_Enumeration_Literal then\n+            Error_Pragma (\"enumeration literal not allowed for pragma%\");\n+         end if;\n+\n          E := Entity (Id);\n \n          --  Go to renamed subprogram if present, since convention applies\n@@ -2207,8 +2232,8 @@ package body Sem_Prag is\n          if Is_Subprogram (E)\n            and then Present (Alias (E))\n          then\n-            if Nkind (Parent (Declaration_Node (E)))\n-              = N_Subprogram_Renaming_Declaration\n+            if Nkind (Parent (Declaration_Node (E))) =\n+                                       N_Subprogram_Renaming_Declaration\n             then\n                E := Alias (E);\n \n@@ -3078,14 +3103,20 @@ package body Sem_Prag is\n               or else\n             Ekind (Def_Id) = E_Constant\n          then\n+            --  We do not permit Import to apply to a renaming declaration\n+\n+            if Present (Renamed_Object (Def_Id)) then\n+               Error_Pragma_Arg\n+                 (\"pragma% not allowed for object renaming\", Arg2);\n+\n             --  User initialization is not allowed for imported object, but\n             --  the object declaration may contain a default initialization,\n             --  that will be discarded. Note that an explicit initialization\n             --  only counts if it comes from source, otherwise it is simply\n             --  the code generator making an implicit initialization explicit.\n \n-            if Present (Expression (Parent (Def_Id)))\n-               and then Comes_From_Source (Expression (Parent (Def_Id)))\n+            elsif Present (Expression (Parent (Def_Id)))\n+              and then Comes_From_Source (Expression (Parent (Def_Id)))\n             then\n                Error_Msg_Sloc := Sloc (Def_Id);\n                Error_Pragma_Arg\n@@ -3235,12 +3266,14 @@ package body Sem_Prag is\n                end if;\n             end loop;\n \n-         --  When the convention is Java, we also allow Import to be given\n-         --  for packages, exceptions, and record components.\n+         --  When the convention is Java or CIL, we also allow Import to be\n+         --  given for packages, generic packages, exceptions, and record\n+         --  components.\n \n-         elsif C = Convention_Java\n+         elsif (C = Convention_Java or else C = Convention_CIL)\n            and then\n              (Ekind (Def_Id) = E_Package\n+                or else Ekind (Def_Id) = E_Generic_Package\n                 or else Ekind (Def_Id) = E_Exception\n                 or else Nkind (Parent (Def_Id)) = N_Component_Declaration)\n          then\n@@ -3256,7 +3289,24 @@ package body Sem_Prag is\n             if not Is_Tagged_Type (Def_Id) then\n                Error_Msg_Sloc := Sloc (Def_Id);\n                Error_Pragma_Arg (\"imported 'C'P'P type must be tagged\", Arg2);\n+\n             else\n+               --  Types treated as CPP classes are treated as limited, but we\n+               --  don't require them to be declared this way. A warning is\n+               --  issued to encourage the user to declare them as limited.\n+               --  This is not an error, for compatibility reasons, because\n+               --  these types have been supported this way for some time.\n+\n+               if not Is_Limited_Type (Def_Id) then\n+                  Error_Msg_N\n+                    (\"imported 'C'P'P type should be \" &\n+                       \"explicitly declared limited?\",\n+                     Get_Pragma_Arg (Arg2));\n+                  Error_Msg_N\n+                    (\"\\type will be considered limited\",\n+                     Get_Pragma_Arg (Arg2));\n+               end if;\n+\n                Set_Is_CPP_Class (Def_Id);\n                Set_Is_Limited_Record (Def_Id);\n             end if;\n@@ -3338,8 +3388,8 @@ package body Sem_Prag is\n                --  trivially possible.\n \n                elsif\n-                 Nkind (Unit_Declaration_Node (Corresponding_Body (Decl)))\n-                   = N_Subprogram_Renaming_Declaration\n+                 Nkind (Unit_Declaration_Node (Corresponding_Body (Decl))) =\n+                                             N_Subprogram_Renaming_Declaration\n                then\n                   return False;\n \n@@ -3569,9 +3619,11 @@ package body Sem_Prag is\n                C := Get_String_Char (S, J);\n \n                if Warn_On_Export_Import\n-                 and then (not In_Character_Range (C)\n-                             or else Get_Character (C) = ' '\n-                             or else Get_Character (C) = ',')\n+                 and then\n+                   (not In_Character_Range (C)\n+                     or else (Get_Character (C) = ' '\n+                               and then VM_Target /= CLI_Target)\n+                     or else Get_Character (C) = ',')\n                then\n                   Error_Msg_N\n                     (\"?interface name contains illegal character\", SN);\n@@ -3584,6 +3636,18 @@ package body Sem_Prag is\n       begin\n          if No (Link_Arg) then\n             if No (Ext_Arg) then\n+               if VM_Target = CLI_Target\n+                 and then Ekind (Subprogram_Def) = E_Package\n+                 and then Nkind (Parent (Subprogram_Def)) =\n+                                                 N_Package_Specification\n+                 and then Present (Generic_Parent (Parent (Subprogram_Def)))\n+               then\n+                  Set_Interface_Name\n+                     (Subprogram_Def,\n+                      Interface_Name\n+                        (Generic_Parent (Parent (Subprogram_Def))));\n+               end if;\n+\n                return;\n \n             elsif Chars (Ext_Arg) = Name_Link_Name then\n@@ -3669,7 +3733,11 @@ package body Sem_Prag is\n \n          else\n             Start_String;\n-            Store_String_Char (Get_Char_Code ('*'));\n+\n+            if VM_Target = No_VM then\n+               Store_String_Char (Get_Char_Code ('*'));\n+            end if;\n+\n             String_Val := Strval (Expr_Value_S (Link_Nam));\n \n             for J in 1 .. String_Length (String_Val) loop\n@@ -3952,6 +4020,12 @@ package body Sem_Prag is\n             C := Get_Check_Id (Chars (Expression (Arg1)));\n          end if;\n \n+         if not Suppress_Case\n+           and then (C = All_Checks or else C = Overflow_Check)\n+         then\n+            Opt.Overflow_Checks_Unsuppressed := True;\n+         end if;\n+\n          if Arg_Count = 1 then\n \n             --  Make an entry in the local scope suppress table. This is the\n@@ -4665,6 +4739,7 @@ package body Sem_Prag is\n             Expr : Node_Id;\n \n          begin\n+            Ada_2005_Pragma;\n             Check_At_Least_N_Arguments (1);\n             Check_At_Most_N_Arguments (2);\n             Check_Arg_Order ((Name_Check, Name_Message));\n@@ -4737,6 +4812,7 @@ package body Sem_Prag is\n          --  pragma Assertion_Policy (Check | Ignore)\n \n          when Pragma_Assertion_Policy =>\n+            Ada_2005_Pragma;\n             Check_Arg_Count (1);\n             Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Ignore);\n             Assertions_Enabled := Chars (Expression (Arg1)) = Name_Check;\n@@ -5413,6 +5489,22 @@ package body Sem_Prag is\n                Error_Pragma_Arg (\"pragma% applicable to tagged types \", Arg1);\n             end if;\n \n+            --  Types treated as CPP classes are treated as limited, but we\n+            --  don't require them to be declared this way. A warning is issued\n+            --  to encourage the user to declare them as limited. This is not\n+            --  an error, for compatibility reasons, because these types have\n+            --  been supported this way for some time.\n+\n+            if not Is_Limited_Type (Typ) then\n+               Error_Msg_N\n+                 (\"imported 'C'P'P type should be \" &\n+                    \"explicitly declared limited?\",\n+                  Get_Pragma_Arg (Arg1));\n+               Error_Msg_N\n+                 (\"\\type will be considered limited\",\n+                  Get_Pragma_Arg (Arg1));\n+            end if;\n+\n             Set_Is_CPP_Class      (Typ);\n             Set_Is_Limited_Record (Typ);\n             Set_Convention        (Typ, Convention_CPP);\n@@ -5558,7 +5650,7 @@ package body Sem_Prag is\n          --  pragma Detect_Blocking;\n \n          when Pragma_Detect_Blocking =>\n-            GNAT_Pragma;\n+            Ada_2005_Pragma;\n             Check_Arg_Count (0);\n             Check_Valid_Configuration_Pragma;\n             Detect_Blocking := True;\n@@ -5591,7 +5683,8 @@ package body Sem_Prag is\n \n                   --  If there is no parameter, then from now on this pragma\n                   --  applies to any enumeration, exception or tagged type\n-                  --  defined in the current declarative part.\n+                  --  defined in the current declarative part, and recursively\n+                  --  to any nested scope.\n \n                   Set_Discard_Names (Current_Scope);\n                   return;\n@@ -5936,15 +6029,6 @@ package body Sem_Prag is\n                Source_Location);\n          end Eliminate;\n \n-         -------------------------\n-         -- Explicit_Overriding --\n-         -------------------------\n-\n-         when Pragma_Explicit_Overriding =>\n-            Check_Valid_Configuration_Pragma;\n-            Check_Arg_Count (0);\n-            Explicit_Overriding := True;\n-\n          ------------\n          -- Export --\n          ------------\n@@ -7337,7 +7421,7 @@ package body Sem_Prag is\n                   Error_Msg_Sloc :=\n                     Interrupt_States.Table (IST_Num).Pragma_Loc;\n                   Error_Pragma_Arg\n-                    (\"state conflicts with that given at #\", Arg2);\n+                    (\"state conflicts with that given #\", Arg2);\n                   exit;\n                end if;\n \n@@ -7351,10 +7435,12 @@ package body Sem_Prag is\n \n          --  pragma Java_Constructor ([Entity =>] LOCAL_NAME);\n \n-         when Pragma_Java_Constructor => Java_Constructor : declare\n-            Id     : Entity_Id;\n-            Def_Id : Entity_Id;\n-            Hom_Id : Entity_Id;\n+         when Pragma_CIL_Constructor | Pragma_Java_Constructor =>\n+         Java_Constructor : declare\n+            Id         : Entity_Id;\n+            Def_Id     : Entity_Id;\n+            Hom_Id     : Entity_Id;\n+            Convention : Convention_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -7371,33 +7457,50 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            case Prag_Id is\n+               when Pragma_CIL_Constructor  => Convention := Convention_CIL;\n+               when Pragma_Java_Constructor => Convention := Convention_Java;\n+               when others                  => null;\n+            end case;\n+\n             Hom_Id := Entity (Id);\n \n             --  Loop through homonyms\n \n             loop\n                Def_Id := Get_Base_Subprogram (Hom_Id);\n \n-               --  The constructor is required to be a function returning\n-               --  an access type whose designated type has convention Java.\n+               --  The constructor is required to be a function returning an\n+               --  access type whose designated type has convention Java/CIL.\n \n                if Ekind (Def_Id) = E_Function\n-                 and then Ekind (Etype (Def_Id)) in Access_Kind\n                  and then\n-                   (Atree.Convention\n-                      (Designated_Type (Etype (Def_Id))) = Convention_Java\n-                   or else\n-                     Atree.Convention\n-                      (Root_Type (Designated_Type (Etype (Def_Id))))\n-                        = Convention_Java)\n+                   (Is_Value_Type (Etype (Def_Id))\n+                     or else\n+                       (Ekind (Etype (Def_Id)) in Access_Kind\n+                         and then\n+                          (Atree.Convention\n+                             (Designated_Type (Etype (Def_Id))) = Convention\n+                            or else\n+                              Atree.Convention\n+                               (Root_Type (Designated_Type (Etype (Def_Id)))) =\n+                                                                 Convention)))\n                then\n                   Set_Is_Constructor (Def_Id);\n-                  Set_Convention     (Def_Id, Convention_Java);\n+                  Set_Convention     (Def_Id, Convention);\n+                  Set_Is_Imported    (Def_Id);\n \n                else\n-                  Error_Pragma_Arg\n-                    (\"pragma% requires function returning a 'Java access type\",\n-                      Arg1);\n+                  if Convention = Convention_Java then\n+                     Error_Pragma_Arg\n+                       (\"pragma% requires function returning a \" &\n+                        \"'Java access type\", Arg1);\n+                  else\n+                     pragma Assert (Convention = Convention_CIL);\n+                     Error_Pragma_Arg\n+                       (\"pragma% requires function returning a \" &\n+                        \"'CIL access type\", Arg1);\n+                  end if;\n                end if;\n \n                Hom_Id := Homonym (Hom_Id);\n@@ -7985,6 +8088,22 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Arg_Is_Integer_Literal (Arg1);\n \n+         -------------\n+         -- No_Body --\n+         -------------\n+\n+         --  pragma No_Body;\n+\n+         --  The only correct use of this pragma is on its own in a file, in\n+         --  which case it is specially processed (see Gnat1drv.Check_Bad_Body\n+         --  and Frontend, which use Sinput.L.Source_File_Is_Pragma_No_Body to\n+         --  check for a file containing nothing but a No_Body pragma). If we\n+         --  attempt to process it during normal semantics processing, it means\n+         --  it was misplaced.\n+\n+         when Pragma_No_Body =>\n+            Error_Pragma (\"misplaced pragma %\");\n+\n          ---------------\n          -- No_Return --\n          ---------------\n@@ -8337,18 +8456,6 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Arg_Is_One_Of (Arg1, Name_Time, Name_Space, Name_Off);\n \n-         -------------------------\n-         -- Optional_Overriding --\n-         -------------------------\n-\n-         --  These pragmas are treated as part of the previous subprogram\n-         --  declaration, and analyzed immediately after it (see sem_ch6,\n-         --  Check_Overriding_Operation). If the pragma has not been analyzed\n-         --  yet, it appears in the wrong place.\n-\n-         when Pragma_Optional_Overriding =>\n-            Error_Msg_N (\"pragma must appear immediately after subprogram\", N);\n-\n          ----------\n          -- Pack --\n          ----------\n@@ -8423,7 +8530,13 @@ package body Sem_Prag is\n \n                else\n                   if not Rep_Item_Too_Late (Typ, N) then\n-                     Set_Is_Packed            (Base_Type (Typ));\n+                     if VM_Target = No_VM then\n+                        Set_Is_Packed (Base_Type (Typ));\n+                     elsif not GNAT_Mode then\n+                        Error_Pragma\n+                          (\"?pragma% ignored in this configuration\");\n+                     end if;\n+\n                      Set_Has_Pragma_Pack      (Base_Type (Typ));\n                      Set_Has_Non_Standard_Rep (Base_Type (Typ));\n                   end if;\n@@ -8433,8 +8546,13 @@ package body Sem_Prag is\n \n             else pragma Assert (Is_Record_Type (Typ));\n                if not Rep_Item_Too_Late (Typ, N) then\n+                  if VM_Target = No_VM then\n+                     Set_Is_Packed (Base_Type (Typ));\n+                  elsif not GNAT_Mode then\n+                     Error_Pragma (\"?pragma% ignored in this configuration\");\n+                  end if;\n+\n                   Set_Has_Pragma_Pack      (Base_Type (Typ));\n-                  Set_Is_Packed            (Base_Type (Typ));\n                   Set_Has_Non_Standard_Rep (Base_Type (Typ));\n                end if;\n             end if;\n@@ -8483,6 +8601,7 @@ package body Sem_Prag is\n             Ent : Entity_Id;\n \n          begin\n+            Ada_2005_Pragma;\n             Check_Arg_Count (1);\n             Check_No_Identifiers;\n             Check_Arg_Is_Identifier (Arg1);\n@@ -8770,6 +8889,7 @@ package body Sem_Prag is\n             Upper_Val   : Uint;\n \n          begin\n+            Ada_2005_Pragma;\n             Check_Arg_Count (3);\n             Check_No_Identifiers;\n             Check_Arg_Is_Task_Dispatching_Policy (Arg1);\n@@ -8888,6 +9008,7 @@ package body Sem_Prag is\n          --  profile_IDENTIFIER => Protected | Ravenscar\n \n          when Pragma_Profile =>\n+            Ada_2005_Pragma;\n             Check_Arg_Count (1);\n             Check_Valid_Configuration_Pragma;\n             Check_No_Identifiers;\n@@ -9388,6 +9509,7 @@ package body Sem_Prag is\n          when Pragma_Reviewable =>\n             Check_Ada_83_Warning;\n             Check_Arg_Count (0);\n+            rv;\n \n          -------------------\n          -- Share_Generic --\n@@ -9537,6 +9659,25 @@ package body Sem_Prag is\n          when Pragma_Source_Reference =>\n             GNAT_Pragma;\n \n+         --------------------------------\n+         -- Static_Elaboration_Desired --\n+         --------------------------------\n+\n+         --  Syntax ???\n+\n+         when Pragma_Static_Elaboration_Desired =>\n+\n+            --  GNAT_Pragma???\n+            --  Check number of arguments ???\n+\n+            if Is_Compilation_Unit (Current_Scope)\n+              and then Ekind (Current_Scope) = E_Package\n+            then\n+               Set_Static_Elaboration_Desired (Current_Scope, True);\n+            else\n+               Error_Pragma (\"pragma% must apply to a library-level package\");\n+            end if;\n+\n          ------------------\n          -- Storage_Size --\n          ------------------\n@@ -10078,80 +10219,6 @@ package body Sem_Prag is\n             end if;\n          end Task_Storage;\n \n-         -----------------\n-         -- Thread_Body --\n-         -----------------\n-\n-         --  pragma Thread_Body\n-         --    (  [Entity =>]               LOCAL_NAME\n-         --     [,[Secondary_Stack_Size =>] static_integer_EXPRESSION]);\n-\n-         when Pragma_Thread_Body => Thread_Body : declare\n-            Id : Node_Id;\n-            SS : Node_Id;\n-            E  : Entity_Id;\n-\n-         begin\n-            GNAT_Pragma;\n-            Check_Arg_Order ((Name_Entity, Name_Secondary_Stack_Size));\n-            Check_At_Least_N_Arguments (1);\n-            Check_At_Most_N_Arguments (2);\n-            Check_Optional_Identifier (Arg1, Name_Entity);\n-            Check_Arg_Is_Local_Name (Arg1);\n-\n-            Id := Expression (Arg1);\n-\n-            if not Is_Entity_Name (Id)\n-              or else not Is_Subprogram (Entity (Id))\n-            then\n-               Error_Pragma_Arg (\"subprogram name required\", Arg1);\n-            end if;\n-\n-            E := Entity (Id);\n-\n-            --  Go to renamed subprogram if present, since Thread_Body applies\n-            --  to the actual renamed entity, not to the renaming entity.\n-\n-            if Present (Alias (E))\n-              and then Nkind (Parent (Declaration_Node (E))) =\n-                         N_Subprogram_Renaming_Declaration\n-            then\n-               E := Alias (E);\n-            end if;\n-\n-            --  Various error checks\n-\n-            if Nkind (Parent (Declaration_Node (E))) = N_Subprogram_Body then\n-               Error_Pragma\n-                 (\"pragma% requires separate spec and must come before body\");\n-\n-            elsif Rep_Item_Too_Early (E, N)\n-              or else Rep_Item_Too_Late (E, N)\n-            then\n-               raise Pragma_Exit;\n-\n-            elsif Is_Thread_Body (E) then\n-               Error_Pragma_Arg\n-                 (\"only one thread body pragma allowed\", Arg1);\n-\n-            elsif Present (Homonym (E))\n-              and then Scope (Homonym (E)) = Current_Scope\n-            then\n-               Error_Pragma_Arg\n-                 (\"thread body subprogram must not be overloaded\", Arg1);\n-            end if;\n-\n-            Set_Is_Thread_Body (E);\n-\n-            --  Deal with secondary stack argument\n-\n-            if Arg_Count = 2 then\n-               Check_Optional_Identifier (Arg2, Name_Secondary_Stack_Size);\n-               SS := Expression (Arg2);\n-               Analyze_And_Resolve (SS, Any_Integer);\n-            end if;\n-         end Thread_Body;\n-\n          ----------------\n          -- Time_Slice --\n          ----------------\n@@ -10373,6 +10440,31 @@ package body Sem_Prag is\n             end if;\n          end Unimplemented_Unit;\n \n+         ------------------------\n+         -- Universal_Aliasing --\n+         ------------------------\n+\n+         --  pragma Universal_Aliasing [([Entity =>] type_LOCAL_NAME)];\n+\n+         when Pragma_Universal_Aliasing => Universal_Alias : declare\n+            E_Id : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_Arg_Count (1);\n+            Check_Optional_Identifier (Arg2, Name_Entity);\n+            Check_Arg_Is_Local_Name (Arg1);\n+            E_Id := Entity (Expression (Arg1));\n+\n+            if E_Id = Any_Type then\n+               return;\n+            elsif No (E_Id) or else not Is_Type (E_Id) then\n+               Error_Pragma_Arg (\"pragma% requires type\", Arg1);\n+            end if;\n+\n+            Set_Universal_Aliasing (Implementation_Base_Type (E_Id));\n+         end Universal_Alias;\n+\n          --------------------\n          -- Universal_Data --\n          --------------------\n@@ -11012,6 +11104,7 @@ package body Sem_Prag is\n       Pragma_Atomic                        =>  0,\n       Pragma_Atomic_Components             =>  0,\n       Pragma_Attach_Handler                => -1,\n+      Pragma_CIL_Constructor               => -1,\n       Pragma_CPP_Class                     =>  0,\n       Pragma_CPP_Constructor               =>  0,\n       Pragma_CPP_Virtual                   =>  0,\n@@ -11036,7 +11129,6 @@ package body Sem_Prag is\n       Pragma_Elaborate_Body                => -1,\n       Pragma_Elaboration_Checks            => -1,\n       Pragma_Eliminate                     => -1,\n-      Pragma_Explicit_Overriding           => -1,\n       Pragma_Export                        => -1,\n       Pragma_Export_Exception              => -1,\n       Pragma_Export_Function               => -1,\n@@ -11085,12 +11177,12 @@ package body Sem_Prag is\n       Pragma_Main_Storage                  => -1,\n       Pragma_Memory_Size                   => -1,\n       Pragma_No_Return                     =>  0,\n+      Pragma_No_Body                       =>  0,\n       Pragma_No_Run_Time                   => -1,\n       Pragma_No_Strict_Aliasing            => -1,\n       Pragma_Normalize_Scalars             => -1,\n       Pragma_Obsolescent                   =>  0,\n       Pragma_Optimize                      => -1,\n-      Pragma_Optional_Overriding           => -1,\n       Pragma_Pack                          =>  0,\n       Pragma_Page                          => -1,\n       Pragma_Passive                       => -1,\n@@ -11124,6 +11216,7 @@ package body Sem_Prag is\n       Pragma_Source_Reference              => -1,\n       Pragma_Storage_Size                  => -1,\n       Pragma_Storage_Unit                  => -1,\n+      Pragma_Static_Elaboration_Desired    => -1,\n       Pragma_Stream_Convert                => -1,\n       Pragma_Style_Checks                  => -1,\n       Pragma_Subtitle                      => -1,\n@@ -11137,11 +11230,11 @@ package body Sem_Prag is\n       Pragma_Task_Info                     => -1,\n       Pragma_Task_Name                     => -1,\n       Pragma_Task_Storage                  =>  0,\n-      Pragma_Thread_Body                   => +2,\n       Pragma_Time_Slice                    => -1,\n       Pragma_Title                         => -1,\n       Pragma_Unchecked_Union               =>  0,\n       Pragma_Unimplemented_Unit            => -1,\n+      Pragma_Universal_Aliasing            => -1,\n       Pragma_Universal_Data                => -1,\n       Pragma_Unreferenced                  => -1,\n       Pragma_Unreferenced_Objects          => -1,\n@@ -11297,6 +11390,15 @@ package body Sem_Prag is\n       end;\n    end Process_Compilation_Unit_Pragmas;\n \n+   --------\n+   -- rv --\n+   --------\n+\n+   procedure rv is\n+   begin\n+      null;\n+   end rv;\n+\n    --------------------------------\n    -- Set_Encoded_Interface_Name --\n    --------------------------------\n@@ -11337,11 +11439,12 @@ package body Sem_Prag is\n       --  If first character is asterisk, this is a link name, and we\n       --  leave it completely unmodified. We also ignore null strings\n       --  (the latter case happens only in error cases) and no encoding\n-      --  should occur for Java interface names.\n+      --  should occur for Java or AAMP interface names.\n \n       if Len = 0\n         or else Get_String_Char (Str, 1) = Get_Char_Code ('*')\n-        or else Java_VM\n+        or else VM_Target /= No_VM\n+        or else AAMP_On_Target\n       then\n          Set_Interface_Name (E, S);\n "}, {"sha": "1afe327aa9a2c7e2f9d0c7182ba9d2d580dd73cb", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Namet; use Namet;\n with Opt;   use Opt;\n with Table;\n \n@@ -118,9 +117,11 @@ package body Snames is\n      \"put#\" &\n      \"put_line#\" &\n      \"to#\" &\n+     \"exception_traces#\" &\n      \"finalization#\" &\n      \"finalization_root#\" &\n      \"interfaces#\" &\n+     \"most_recent_exception#\" &\n      \"standard#\" &\n      \"system#\" &\n      \"text_io#\" &\n@@ -187,7 +188,6 @@ package body Snames is\n      \"discard_names#\" &\n      \"elaboration_checks#\" &\n      \"eliminate#\" &\n-     \"explicit_overriding#\" &\n      \"extend_system#\" &\n      \"extensions_allowed#\" &\n      \"external_name_casing#\" &\n@@ -232,6 +232,7 @@ package body Snames is\n      \"atomic#\" &\n      \"atomic_components#\" &\n      \"attach_handler#\" &\n+     \"cil_constructor#\" &\n      \"comment#\" &\n      \"common_object#\" &\n      \"complete_representation#\" &\n@@ -283,10 +284,10 @@ package body Snames is\n      \"main#\" &\n      \"main_storage#\" &\n      \"memory_size#\" &\n+     \"no_body#\" &\n      \"no_return#\" &\n      \"obsolescent#\" &\n      \"optimize#\" &\n-     \"optional_overriding#\" &\n      \"pack#\" &\n      \"page#\" &\n      \"passive#\" &\n@@ -303,6 +304,7 @@ package body Snames is\n      \"shared#\" &\n      \"shared_passive#\" &\n      \"source_reference#\" &\n+     \"static_elaboration_desired#\" &\n      \"stream_convert#\" &\n      \"subtitle#\" &\n      \"suppress_all#\" &\n@@ -312,11 +314,11 @@ package body Snames is\n      \"task_info#\" &\n      \"task_name#\" &\n      \"task_storage#\" &\n-     \"thread_body#\" &\n      \"time_slice#\" &\n      \"title#\" &\n      \"unchecked_union#\" &\n      \"unimplemented_unit#\" &\n+     \"universal_aliasing#\" &\n      \"unreferenced#\" &\n      \"unreferenced_objects#\" &\n      \"unreserve_all_interrupts#\" &\n@@ -325,6 +327,7 @@ package body Snames is\n      \"weak_external#\" &\n      \"ada#\" &\n      \"assembler#\" &\n+     \"cil#\" &\n      \"cobol#\" &\n      \"cpp#\" &\n      \"fortran#\" &\n@@ -670,13 +673,13 @@ package body Snames is\n      \"archive_suffix#\" &\n      \"binder#\" &\n      \"binder_driver#\" &\n+     \"binder_prefix#\" &\n      \"body_suffix#\" &\n      \"builder#\" &\n      \"builder_switches#\" &\n      \"compiler#\" &\n      \"compiler_driver#\" &\n      \"compiler_kind#\" &\n-     \"compiler_minimum_options#\" &\n      \"compiler_pic_option#\" &\n      \"compute_dependency#\" &\n      \"config_body_file_name#\" &\n@@ -690,6 +693,7 @@ package body Snames is\n      \"default_global_compiler_switches#\" &\n      \"default_language#\" &\n      \"default_linker#\" &\n+     \"default_minimum_linker_options#\" &\n      \"default_switches#\" &\n      \"dependency_file_kind#\" &\n      \"dependency_option#\" &\n@@ -724,6 +728,7 @@ package body Snames is\n      \"library_name#\" &\n      \"library_major_minor_id_supported#\" &\n      \"library_options#\" &\n+     \"library_partial_linker#\" &\n      \"library_reference_symbol_file#\" &\n      \"library_src_dir#\" &\n      \"library_support#\" &\n@@ -743,6 +748,8 @@ package body Snames is\n      \"mapping_body_suffix#\" &\n      \"metrics#\" &\n      \"minimum_binder_options#\" &\n+     \"minimum_compiler_options#\" &\n+     \"minimum_linker_options#\" &\n      \"naming#\" &\n      \"objects_path#\" &\n      \"objects_path_file#\" &\n@@ -767,6 +774,7 @@ package body Snames is\n      \"stack#\" &\n      \"switches#\" &\n      \"symbolic_link_supported#\" &\n+     \"toolchain_description#\" &\n      \"toolchain_version#\" &\n      \"unaligned_valid#\" &\n      \"interface#\" &\n@@ -864,6 +872,7 @@ package body Snames is\n          when Name_Ada        => return Convention_Ada;\n          when Name_Assembler  => return Convention_Assembler;\n          when Name_C          => return Convention_C;\n+         when Name_CIL        => return Convention_CIL;\n          when Name_COBOL      => return Convention_COBOL;\n          when Name_CPP        => return Convention_CPP;\n          when Name_Fortran    => return Convention_Fortran;\n@@ -896,6 +905,7 @@ package body Snames is\n          when Convention_Ada       => return Name_Ada;\n          when Convention_Assembler => return Name_Assembler;\n          when Convention_C         => return Name_C;\n+         when Convention_CIL       => return Name_CIL;\n          when Convention_COBOL     => return Name_COBOL;\n          when Convention_CPP       => return Name_CPP;\n          when Convention_Entry     => return Name_Entry;"}, {"sha": "7795368b56c33ac3584ed547d3766ce56c9fe682", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 704, "deletions": 692, "changes": 1396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=2fa9443ee92516002d3e3a58eff4c1c5b030dfdd"}, {"sha": "b84d771c9160cf693242b79e3dc2711f2e6620b1", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa9443ee92516002d3e3a58eff4c1c5b030dfdd/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=2fa9443ee92516002d3e3a58eff4c1c5b030dfdd", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -192,12 +192,13 @@ extern unsigned char Get_Attribute_Id (int);\n #define  Convention_Protected                     3\n #define  Convention_Assembler                     4\n #define  Convention_C                             5\n-#define  Convention_COBOL                         6\n-#define  Convention_CPP                           7\n-#define  Convention_Fortran                       8\n-#define  Convention_Java                          9\n-#define  Convention_Stdcall                       10\n-#define  Convention_Stubbed                       11\n+#define  Convention_CIL                           6\n+#define  Convention_COBOL                         7\n+#define  Convention_CPP                           8\n+#define  Convention_Fortran                       9\n+#define  Convention_Java                          10\n+#define  Convention_Stdcall                       11\n+#define  Convention_Stubbed                       12\n \n /* Define the function to check if a Name_Id value is a valid pragma */\n \n@@ -229,51 +230,51 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Discard_Names                 12\n #define  Pragma_Elaboration_Checks            13\n #define  Pragma_Eliminate                     14\n-#define  Pragma_Explicit_Overriding           15\n-#define  Pragma_Extend_System                 16\n-#define  Pragma_Extensions_Allowed            17\n-#define  Pragma_External_Name_Casing          18\n-#define  Pragma_Float_Representation          19\n-#define  Pragma_Initialize_Scalars            20\n-#define  Pragma_Interrupt_State               21\n-#define  Pragma_License                       22\n-#define  Pragma_Locking_Policy                23\n-#define  Pragma_Long_Float                    24\n-#define  Pragma_No_Run_Time                   25\n-#define  Pragma_No_Strict_Aliasing            26\n-#define  Pragma_Normalize_Scalars             27\n-#define  Pragma_Polling                       28\n-#define  Pragma_Persistent_BSS                29\n-#define  Pragma_Priority_Specific_Dispatching 30\n-#define  Pragma_Profile                       31\n-#define  Pragma_Profile_Warnings              32\n-#define  Pragma_Propagate_Exceptions          33\n-#define  Pragma_Queuing_Policy                34\n-#define  Pragma_Ravenscar                     35\n-#define  Pragma_Restricted_Run_Time           36\n-#define  Pragma_Restrictions                  37\n-#define  Pragma_Restriction_Warnings          38\n-#define  Pragma_Reviewable                    39\n-#define  Pragma_Source_File_Name              40\n-#define  Pragma_Source_File_Name_Project      41\n-#define  Pragma_Style_Checks                  42\n-#define  Pragma_Suppress                      43\n-#define  Pragma_Suppress_Exception_Locations  44\n-#define  Pragma_Task_Dispatching_Policy       45\n-#define  Pragma_Universal_Data                46\n-#define  Pragma_Unsuppress                    47\n-#define  Pragma_Use_VADS_Size                 48\n-#define  Pragma_Validity_Checks               49\n-#define  Pragma_Warnings                      50\n-#define  Pragma_Wide_Character_Encoding       51\n-#define  Pragma_Abort_Defer                   52\n-#define  Pragma_All_Calls_Remote              53\n-#define  Pragma_Annotate                      54\n-#define  Pragma_Assert                        55\n-#define  Pragma_Asynchronous                  56\n-#define  Pragma_Atomic                        57\n-#define  Pragma_Atomic_Components             58\n-#define  Pragma_Attach_Handler                59\n+#define  Pragma_Extend_System                 15\n+#define  Pragma_Extensions_Allowed            16\n+#define  Pragma_External_Name_Casing          17\n+#define  Pragma_Float_Representation          18\n+#define  Pragma_Initialize_Scalars            19\n+#define  Pragma_Interrupt_State               20\n+#define  Pragma_License                       21\n+#define  Pragma_Locking_Policy                22\n+#define  Pragma_Long_Float                    23\n+#define  Pragma_No_Run_Time                   24\n+#define  Pragma_No_Strict_Aliasing            25\n+#define  Pragma_Normalize_Scalars             26\n+#define  Pragma_Polling                       27\n+#define  Pragma_Persistent_BSS                28\n+#define  Pragma_Priority_Specific_Dispatching 29\n+#define  Pragma_Profile                       30\n+#define  Pragma_Profile_Warnings              31\n+#define  Pragma_Propagate_Exceptions          32\n+#define  Pragma_Queuing_Policy                33\n+#define  Pragma_Ravenscar                     34\n+#define  Pragma_Restricted_Run_Time           35\n+#define  Pragma_Restrictions                  36\n+#define  Pragma_Restriction_Warnings          37\n+#define  Pragma_Reviewable                    38\n+#define  Pragma_Source_File_Name              39\n+#define  Pragma_Source_File_Name_Project      40\n+#define  Pragma_Style_Checks                  41\n+#define  Pragma_Suppress                      42\n+#define  Pragma_Suppress_Exception_Locations  43\n+#define  Pragma_Task_Dispatching_Policy       44\n+#define  Pragma_Universal_Data                45\n+#define  Pragma_Unsuppress                    46\n+#define  Pragma_Use_VADS_Size                 47\n+#define  Pragma_Validity_Checks               48\n+#define  Pragma_Warnings                      49\n+#define  Pragma_Wide_Character_Encoding       50\n+#define  Pragma_Abort_Defer                   51\n+#define  Pragma_All_Calls_Remote              52\n+#define  Pragma_Annotate                      53\n+#define  Pragma_Assert                        54\n+#define  Pragma_Asynchronous                  55\n+#define  Pragma_Atomic                        56\n+#define  Pragma_Atomic_Components             57\n+#define  Pragma_Attach_Handler                58\n+#define  Pragma_CIL_Constructor               59\n #define  Pragma_Comment                       60\n #define  Pragma_Common_Object                 61\n #define  Pragma_Complete_Representation       62\n@@ -325,10 +326,10 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Main                          108\n #define  Pragma_Main_Storage                  109\n #define  Pragma_Memory_Size                   110\n-#define  Pragma_No_Return                     111\n-#define  Pragma_Obsolescent                   112\n-#define  Pragma_Optimize                      113\n-#define  Pragma_Optional_Overriding           114\n+#define  Pragma_No_Body                       111\n+#define  Pragma_No_Return                     112\n+#define  Pragma_Obsolescent                   113\n+#define  Pragma_Optimize                      114\n #define  Pragma_Pack                          115\n #define  Pragma_Page                          116\n #define  Pragma_Passive                       117\n@@ -345,30 +346,31 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Shared                        128\n #define  Pragma_Shared_Passive                129\n #define  Pragma_Source_Reference              130\n-#define  Pragma_Stream_Convert                131\n-#define  Pragma_Subtitle                      132\n-#define  Pragma_Suppress_All                  133\n-#define  Pragma_Suppress_Debug_Info           134\n-#define  Pragma_Suppress_Initialization       135\n-#define  Pragma_System_Name                   136\n-#define  Pragma_Task_Info                     137\n-#define  Pragma_Task_Name                     138\n-#define  Pragma_Task_Storage                  139\n-#define  Pragma_Thread_Body                   140\n+#define  Pragma_Static_Elaboration_Desired    131\n+#define  Pragma_Stream_Convert                132\n+#define  Pragma_Subtitle                      133\n+#define  Pragma_Suppress_All                  134\n+#define  Pragma_Suppress_Debug_Info           135\n+#define  Pragma_Suppress_Initialization       136\n+#define  Pragma_System_Name                   137\n+#define  Pragma_Task_Info                     138\n+#define  Pragma_Task_Name                     139\n+#define  Pragma_Task_Storage                  140\n #define  Pragma_Time_Slice                    141\n #define  Pragma_Title                         142\n #define  Pragma_Unchecked_Union               143\n #define  Pragma_Unimplemented_Unit            144\n-#define  Pragma_Unreferenced                  145\n-#define  Pragma_Unreferenced_Objects          146\n-#define  Pragma_Unreserve_All_Interrupts      147\n-#define  Pragma_Volatile                      148\n-#define  Pragma_Volatile_Components           149\n-#define  Pragma_Weak_External                 150\n-#define  Pragma_AST_Entry                     151\n-#define  Pragma_Interface                     152\n-#define  Pragma_Priority                      153\n-#define  Pragma_Storage_Size                  154\n-#define  Pragma_Storage_Unit                  155\n+#define  Pragma_Universal_Aliasing            145\n+#define  Pragma_Unreferenced                  146\n+#define  Pragma_Unreferenced_Objects          147\n+#define  Pragma_Unreserve_All_Interrupts      148\n+#define  Pragma_Volatile                      149\n+#define  Pragma_Volatile_Components           150\n+#define  Pragma_Weak_External                 151\n+#define  Pragma_AST_Entry                     152\n+#define  Pragma_Interface                     153\n+#define  Pragma_Priority                      154\n+#define  Pragma_Storage_Size                  155\n+#define  Pragma_Storage_Unit                  156\n \n /* End of snames.h (C version of Snames package spec) */"}]}