{"sha": "b0c83d59f44bf677c8d74acae228acf32719acb3", "node_id": "C_kwDOANBUbNoAKGIwYzgzZDU5ZjQ0YmY2NzdjOGQ3NGFjYWUyMjhhY2YzMjcxOWFjYjM", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-10T10:13:09Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-10T16:45:01Z"}, "message": "path solver: Adjustments for use outside of the backward threader.\n\nHere are some enhancements to make it easier for other clients to use\nthe path solver.\n\nFirst, I've made the imports to the solver optional since we can\ncalculate them ourselves.  However, I've left the ability to set them,\nsince the backward threader adds a few SSA names in addition to the\ndefault ones.  As a follow-up I may move all the import set up code\nfrom the threader to the solver, as the extra imports tend to improve\nthe behavior slightly.\n\nSecond, Richi suggested an entry point where you just feed the solver\nan edge, which will be quite convenient for a subsequent patch adding\na client in the header copying pass.  The required some shuffling,\nsince we'll be adding the blocks on the fly.  There's now a vector\ncopy, but the impact will be minimal, since these are just 5-6 entries\nat the most.\n\nTested on ppc64le Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-path.cc (path_range_query::path_range_query): Do\n\tnot init m_path.\n\t(path_range_query::dump): Change m_path uses to non-pointer.\n\t(path_range_query::defined_outside_path):  Same.\n\t(path_range_query::set_path): Same.\n\t(path_range_query::add_copies_to_imports): Same.\n\t(path_range_query::range_of_stmt): Same.\n\t(path_range_query::compute_outgoing_relations): Same.\n\t(path_range_query::compute_ranges): Imports are now optional.\n\tImplement overload that takes an edge.\n\t* gimple-range-path.h (class path_range_query): Make imports\n\toptional for compute_ranges.  Add compute_ranges(edge) overload.\n\tMake m_path an auto_vec instead of a pointer and adjust\n\taccordingly.", "tree": {"sha": "ba62e54ec581868f3d16113a1a4ceddf5dd5230b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba62e54ec581868f3d16113a1a4ceddf5dd5230b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0c83d59f44bf677c8d74acae228acf32719acb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c83d59f44bf677c8d74acae228acf32719acb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c83d59f44bf677c8d74acae228acf32719acb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c83d59f44bf677c8d74acae228acf32719acb3/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86ffc845b2d0bff59832dcf3cf6518f1358e30ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ffc845b2d0bff59832dcf3cf6518f1358e30ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ffc845b2d0bff59832dcf3cf6518f1358e30ac"}], "stats": {"total": 58, "additions": 39, "deletions": 19}, "files": [{"sha": "6da01c7067f533ecaa1836d707fbc32bc07ce3bc", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c83d59f44bf677c8d74acae228acf32719acb3/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c83d59f44bf677c8d74acae228acf32719acb3/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=b0c83d59f44bf677c8d74acae228acf32719acb3", "patch": "@@ -41,7 +41,6 @@ path_range_query::path_range_query (gimple_ranger &ranger, bool resolve)\n {\n   m_cache = new ssa_global_cache;\n   m_has_cache_entry = BITMAP_ALLOC (NULL);\n-  m_path = NULL;\n   m_resolve = resolve;\n   m_oracle = new path_oracle (ranger.oracle ());\n }\n@@ -92,13 +91,13 @@ path_range_query::dump (FILE *dump_file)\n {\n   push_dump_file save (dump_file, dump_flags & ~TDF_DETAILS);\n \n-  if (m_path->is_empty ())\n+  if (m_path.is_empty ())\n     return;\n \n   unsigned i;\n   bitmap_iterator bi;\n \n-  dump_ranger (dump_file, *m_path);\n+  dump_ranger (dump_file, m_path);\n \n   fprintf (dump_file, \"Imports:\\n\");\n   EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n@@ -125,7 +124,7 @@ path_range_query::defined_outside_path (tree name)\n   gimple *def = SSA_NAME_DEF_STMT (name);\n   basic_block bb = gimple_bb (def);\n \n-  return !bb || !m_path->contains (bb);\n+  return !bb || !m_path.contains (bb);\n }\n \n // Return the range of NAME on entry to the path.\n@@ -230,8 +229,8 @@ void\n path_range_query::set_path (const vec<basic_block> &path)\n {\n   gcc_checking_assert (path.length () > 1);\n-  m_path = &path;\n-  m_pos = m_path->length () - 1;\n+  m_path = path.copy ();\n+  m_pos = m_path.length () - 1;\n   bitmap_clear (m_has_cache_entry);\n }\n \n@@ -486,7 +485,7 @@ path_range_query::add_copies_to_imports ()\n \t      tree arg = gimple_phi_arg (phi, i)->def;\n \n \t      if (TREE_CODE (arg) == SSA_NAME\n-\t\t  && m_path->contains (e->src)\n+\t\t  && m_path.contains (e->src)\n \t\t  && bitmap_set_bit (m_imports, SSA_NAME_VERSION (arg)))\n \t\tworklist.safe_push (arg);\n \t    }\n@@ -497,7 +496,8 @@ path_range_query::add_copies_to_imports ()\n // Compute the ranges for IMPORTS along PATH.\n //\n // IMPORTS are the set of SSA names, any of which could potentially\n-// change the value of the final conditional in PATH.\n+// change the value of the final conditional in PATH.  Default to the\n+// imports of the last block in the path if none is given.\n \n void\n path_range_query::compute_ranges (const vec<basic_block> &path,\n@@ -507,9 +507,16 @@ path_range_query::compute_ranges (const vec<basic_block> &path,\n     fprintf (dump_file, \"\\n==============================================\\n\");\n \n   set_path (path);\n-  bitmap_copy (m_imports, imports);\n   m_undefined_path = false;\n \n+  if (imports)\n+    bitmap_copy (m_imports, imports);\n+  else\n+    {\n+      bitmap imports = m_ranger.gori ().imports (exit_bb ());\n+      bitmap_copy (m_imports, imports);\n+    }\n+\n   if (m_resolve)\n     {\n       add_copies_to_imports ();\n@@ -561,6 +568,18 @@ path_range_query::compute_ranges (const vec<basic_block> &path,\n     }\n }\n \n+// Convenience function to compute ranges along a path consisting of\n+// E->SRC and E->DEST.\n+\n+void\n+path_range_query::compute_ranges (edge e)\n+{\n+  auto_vec<basic_block> bbs (2);\n+  bbs.quick_push (e->dest);\n+  bbs.quick_push (e->src);\n+  compute_ranges (bbs);\n+}\n+\n // A folding aid used to register and query relations along a path.\n // When queried, it returns relations as they would appear on exit to\n // the path.\n@@ -643,7 +662,7 @@ path_range_query::range_of_stmt (irange &r, gimple *stmt, tree)\n   if (m_resolve)\n     {\n       fold_using_range f;\n-      jt_fur_source src (stmt, this, &m_ranger.gori (), *m_path);\n+      jt_fur_source src (stmt, this, &m_ranger.gori (), m_path);\n       if (!f.fold_stmt (r, stmt, src))\n \tr.set_varying (type);\n     }\n@@ -734,7 +753,7 @@ path_range_query::compute_outgoing_relations (basic_block bb, basic_block next)\n       else\n \tgcc_unreachable ();\n \n-      jt_fur_source src (NULL, this, &m_ranger.gori (), *m_path);\n+      jt_fur_source src (NULL, this, &m_ranger.gori (), m_path);\n       src.register_outgoing_edges (cond, r, e0, e1);\n     }\n }"}, {"sha": "b73549f01a5e93c0160587a09e80e80db127c439", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c83d59f44bf677c8d74acae228acf32719acb3/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c83d59f44bf677c8d74acae228acf32719acb3/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=b0c83d59f44bf677c8d74acae228acf32719acb3", "patch": "@@ -34,7 +34,8 @@ class path_range_query : public range_query\n public:\n   path_range_query (class gimple_ranger &ranger, bool resolve);\n   virtual ~path_range_query ();\n-  void compute_ranges (const vec<basic_block> &, const bitmap_head *imports);\n+  void compute_ranges (const vec<basic_block> &, const bitmap_head *imports = NULL);\n+  void compute_ranges (edge e);\n   bool range_of_expr (irange &r, tree name, gimple * = NULL) override;\n   bool range_of_stmt (irange &r, gimple *, tree name = NULL) override;\n   bool unreachable_path_p ();\n@@ -66,12 +67,12 @@ class path_range_query : public range_query\n \n   // Path navigation.\n   void set_path (const vec<basic_block> &);\n-  basic_block entry_bb () { return (*m_path)[m_path->length () - 1]; }\n-  basic_block exit_bb ()  { return (*m_path)[0]; }\n-  basic_block curr_bb ()  { return (*m_path)[m_pos]; }\n-  basic_block prev_bb ()  { return (*m_path)[m_pos + 1]; }\n-  basic_block next_bb ()  { return (*m_path)[m_pos - 1]; }\n-  bool at_entry ()\t  { return m_pos == m_path->length () - 1; }\n+  basic_block entry_bb () { return m_path[m_path.length () - 1]; }\n+  basic_block exit_bb ()  { return m_path[0]; }\n+  basic_block curr_bb ()  { return m_path[m_pos]; }\n+  basic_block prev_bb ()  { return m_path[m_pos + 1]; }\n+  basic_block next_bb ()  { return m_path[m_pos - 1]; }\n+  bool at_entry ()\t  { return m_pos == m_path.length () - 1; }\n   bool at_exit ()\t  { return m_pos == 0; }\n   void move_next ()\t  { --m_pos; }\n \n@@ -82,7 +83,7 @@ class path_range_query : public range_query\n   bitmap m_has_cache_entry;\n \n   // Path being analyzed.\n-  const vec<basic_block> *m_path;\n+  auto_vec<basic_block> m_path;\n \n   auto_bitmap m_imports;\n   gimple_ranger &m_ranger;"}]}