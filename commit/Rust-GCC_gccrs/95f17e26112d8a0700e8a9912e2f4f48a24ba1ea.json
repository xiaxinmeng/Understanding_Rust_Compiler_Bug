{"sha": "95f17e26112d8a0700e8a9912e2f4f48a24ba1ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVmMTdlMjYxMTJkOGEwNzAwZThhOTkxMmUyZjRmNDhhMjRiYTFlYQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2020-08-19T18:43:55Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2020-08-19T18:43:55Z"}, "message": "rs6000: Enable more sibcalls when TOC is not preserved\n\nA function compiled with the PC-relative addressing model does not\nrequire r2 to contain a TOC pointer, and does not guarantee that r2\nwill be preserved for its caller.  Such a function can make sibcalls\nwithout restriction based on TOC preservation rules.  However, a\ncaller that does preserve r2 cannot make a sibcall to a callee that\ndoes not.\n\n2020-08-19  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-logue.c (rs6000_decl_ok_for_sibcall):\n\tSibcalls are always legal when the caller doesn't preserve r2.\n\ngcc/testsuite/\n\t* gcc.target/powerpc/pcrel-sibcall-1.c: Adjust.", "tree": {"sha": "9dffad1e20d30777b80466f59b169c066ced05ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dffad1e20d30777b80466f59b169c066ced05ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95f17e26112d8a0700e8a9912e2f4f48a24ba1ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f17e26112d8a0700e8a9912e2f4f48a24ba1ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95f17e26112d8a0700e8a9912e2f4f48a24ba1ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f17e26112d8a0700e8a9912e2f4f48a24ba1ea/comments", "author": null, "committer": null, "parents": [{"sha": "5abc821556e141c9b7003877d09d9dd9e9f98ae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5abc821556e141c9b7003877d09d9dd9e9f98ae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5abc821556e141c9b7003877d09d9dd9e9f98ae7"}], "stats": {"total": 49, "additions": 28, "deletions": 21}, "files": [{"sha": "5a2cb7fdf2c1278890d87838322dfedbdb95c54c", "filename": "gcc/config/rs6000/rs6000-logue.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f17e26112d8a0700e8a9912e2f4f48a24ba1ea/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f17e26112d8a0700e8a9912e2f4f48a24ba1ea/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c?ref=95f17e26112d8a0700e8a9912e2f4f48a24ba1ea", "patch": "@@ -1080,28 +1080,28 @@ rs6000_decl_ok_for_sibcall (tree decl)\n \n   if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     {\n-      /* Under the AIX or ELFv2 ABIs we can't allow calls to non-local\n-\t functions, because the callee may have a different TOC pointer to\n-\t the caller and there's no way to ensure we restore the TOC when\n+      /* A function compiled using the PC-relative addressing model does not\n+\t use a TOC pointer; nor is it guaranteed to preserve the value of\n+\t r2 for its caller's TOC.  Such a function may make sibcalls to any\n+\t function, whether local or external, without restriction based on\n+\t TOC-save/restore rules.  */\n+      if (rs6000_pcrel_p (cfun))\n+\treturn true;\n+\n+      /* Otherwise, under the AIX or ELFv2 ABIs we can't allow sibcalls\n+\t to non-local functions, because the callee may not preserve the\n+\t TOC pointer, and there's no way to ensure we restore the TOC when\n \t we return.  */\n       if (!decl || DECL_EXTERNAL (decl) || DECL_WEAK (decl)\n \t  || !(*targetm.binds_local_p) (decl))\n \treturn false;\n \n-      /* Similarly, if the caller preserves the TOC pointer and the callee\n-\t doesn't (or vice versa), proper TOC setup or restoration will be\n-\t missed.  For example, suppose A, B, and C are in the same binary\n-\t and A -> B -> C.  A and B preserve the TOC pointer but C does not,\n-\t and B -> C is eligible as a sibcall.  A will call B through its\n-\t local entry point, so A will not restore its TOC itself.  B calls\n-\t C with a sibcall, so it will not restore the TOC.  C does not\n-\t preserve the TOC, so it may clobber r2 with impunity.  Returning\n-\t from C will result in a corrupted TOC for A.  */\n-      else if (rs6000_fndecl_pcrel_p (decl) != rs6000_pcrel_p (cfun))\n+      /* A local sibcall from a function that preserves the TOC pointer\n+\t to a function that does not is invalid for the same reason.  */\n+      if (rs6000_fndecl_pcrel_p (decl))\n \treturn false;\n \n-      else\n-\treturn true;\n+      return true;\n     }\n \n   /*  With the secure-plt SYSV ABI we can't make non-local calls when"}, {"sha": "9197788f98f015aa1a57c0c6b9e3cc874f447da8", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-sibcall-1.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f17e26112d8a0700e8a9912e2f4f48a24ba1ea/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-sibcall-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f17e26112d8a0700e8a9912e2f4f48a24ba1ea/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-sibcall-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-sibcall-1.c?ref=95f17e26112d8a0700e8a9912e2f4f48a24ba1ea", "patch": "@@ -3,10 +3,9 @@\n /* { dg-require-effective-target powerpc_elfv2 } */\n /* { dg-require-effective-target power10_ok } */\n \n-/* Test that potential sibcalls are not generated when the caller preserves the\n-   TOC and the callee doesn't, or vice versa.  At present, -mcpu=power10 does\n-   not enable pc-relative mode.  Enable it here explicitly until it is turned\n-   on by default.  */\n+/* Test that potential sibcalls are generated when the caller does not\n+   preserve the TOC, even for external calls; and that sibcalls are not\n+   generated when the caller preserves the TOC but the callee does not.  */\n \n #pragma GCC target (\"cpu=power10,pcrel\")\n int x (void) __attribute__((noinline));\n@@ -39,12 +38,20 @@ int xx (void)\n   return 1;\n }\n \n+extern int yy (void);\n+\n #pragma GCC target (\"cpu=power10,pcrel\")\n-int notoc_call (void)\n+int notoc_sibcall (void)\n {\n   return xx ();\n }\n \n+int extern_sibcall (void)\n+{\n+  return yy ();\n+}\n+\n /* { dg-final { scan-assembler {\\mb x@notoc\\M} } } */\n /* { dg-final { scan-assembler {\\mbl y\\M} } } */\n-/* { dg-final { scan-assembler {\\mbl xx@notoc\\M} } } */\n+/* { dg-final { scan-assembler {\\mb xx@notoc\\M} } } */\n+/* { dg-final { scan-assembler {\\mb yy@notoc\\M} } } */"}]}