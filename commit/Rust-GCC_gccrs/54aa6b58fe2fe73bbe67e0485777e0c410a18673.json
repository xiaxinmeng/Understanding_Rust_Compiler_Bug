{"sha": "54aa6b58fe2fe73bbe67e0485777e0c410a18673", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRhYTZiNThmZTJmZTczYmJlNjdlMDQ4NTc3N2UwYzQxMGExODY3Mw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-11-22T17:14:17Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-11-22T17:14:17Z"}, "message": "PR middle-end/83859 - attributes to associate pointer arguments and sizes\n\ngcc/ChangeLog:\n\n\tPR middle-end/83859\n\t* attribs.h (struct attr_access): New.\n\t* attribs.c (decl_attributes): Add an informational note.\n\t* builtins.c (check_access): Make extern.  Consistently set no-warning\n\tafter issuing a warning.  Handle calls through function pointers.  Set\n\tno-warning.\n\t* builtins.h (check_access): Declare.\n\t* calls.c (rdwr_access_hash): New type.\n\t(rdwr_map): Same.\n\t(init_attr_rdwr_indices): New function.\n\t(maybe_warn_rdwr_sizes): Same.\n\t(initialize_argument_information): Call init_attr_rdwr_indices.\n\tCall maybe_warn_rdwr_sizes.\n\t(get_size_range): Avoid null argument.\n\t* doc/extend.texi (attribute access): Document new attribute.\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/83859\n\t* c-attribs.c (handle_access_attribute): New function.\n\t(c_common_attribute_table): Add new attribute.\n\t(get_argument_type): New function.\n\t(append_access_attrs): New function.\n\t(get_nonnull_operand): Rename...\n\t(get_attribute_operand): ...to this.\n\t* c-common.c (get_nonnull_operand): Rename...\n\t(get_attribute_operand): ...to this.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/83859\n\t* c-c++-common/attr-nonstring-8.c: Adjust text of expected warning.\n\t* gcc.dg/Wstringop-overflow-23.c: New test.\n\t* gcc.dg/Wstringop-overflow-24.c: New test.\n\t* gcc.dg/attr-access-read-only.c: New test.\n\t* gcc.dg/attr-access-read-write.c: New test.\n\t* gcc.dg/attr-access-read-write-2.c: New test.\n\t* gcc.dg/attr-access-write-only.c: New test.\n\nFrom-SVN: r278624", "tree": {"sha": "11281ae8b5d5a5f2a57ffc60d7d8cfe951a953d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11281ae8b5d5a5f2a57ffc60d7d8cfe951a953d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54aa6b58fe2fe73bbe67e0485777e0c410a18673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54aa6b58fe2fe73bbe67e0485777e0c410a18673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54aa6b58fe2fe73bbe67e0485777e0c410a18673", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54aa6b58fe2fe73bbe67e0485777e0c410a18673/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9"}], "stats": {"total": 1824, "additions": 1748, "deletions": 76}, "files": [{"sha": "0b3b47714eac85b13712b47aa9d43d6405706360", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -1,3 +1,21 @@\n+2019-11-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/83859\n+\t* attribs.h (struct attr_access): New.\n+\t* attribs.c (decl_attributes): Add an informational note.\n+\t* builtins.c (check_access): Make extern.  Consistently set no-warning\n+\tafter issuing a warning.  Handle calls through function pointers.  Set\n+\tno-warning.\n+\t* builtins.h (check_access): Declare.\n+\t* calls.c (rdwr_access_hash): New type.\n+\t(rdwr_map): Same.\n+\t(init_attr_rdwr_indices): New function.\n+\t(maybe_warn_rdwr_sizes): Same.\n+\t(initialize_argument_information): Call init_attr_rdwr_indices.\n+\tCall maybe_warn_rdwr_sizes.\n+\t(get_size_range): Avoid null argument.\n+\t* doc/extend.texi (attribute access): Document new attribute.\n+\n 2019-11-22  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/gcn/gcn.c (OMP_LDS_SIZE): Define."}, {"sha": "de34918919b891d6e4400b087b38a44272c09e92", "filename": "gcc/attribs.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -573,13 +573,23 @@ decl_attributes (tree *node, tree attributes, int flags,\n \t    }\n \t  continue;\n \t}\n-      else if (list_length (args) < spec->min_length\n-\t       || (spec->max_length >= 0\n-\t\t   && list_length (args) > spec->max_length))\n+      else\n \t{\n-\t  error (\"wrong number of arguments specified for %qE attribute\",\n-\t\t name);\n-\t  continue;\n+\t  int nargs = list_length (args);\n+\t  if (nargs < spec->min_length\n+\t      || (spec->max_length >= 0\n+\t\t  && nargs > spec->max_length))\n+\t    {\n+\t      error (\"wrong number of arguments specified for %qE attribute\",\n+\t\t     name);\n+\t      if (spec->max_length < 0)\n+\t\tinform (input_location, \"expected %i or more, found %i\",\n+\t\t\tspec->min_length, nargs);\n+\t      else\n+\t\tinform (input_location, \"expected between %i and %i, found %i\",\n+\t\t\tspec->min_length, spec->max_length, nargs);\n+\t      continue;\n+\t    }\n \t}\n       gcc_assert (is_attribute_p (spec->name, name));\n "}, {"sha": "9bc1600dfe3e456ed77e2532cccaea49564dca66", "filename": "gcc/attribs.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -218,4 +218,24 @@ lookup_attribute_by_prefix (const char *attr_name, tree list)\n     }\n }\n \n+/* Description of a function argument declared with attribute access.\n+   Used as an \"iterator\" over all such arguments in a function declaration\n+   or call.  */\n+\n+struct attr_access\n+{\n+  /* The attribute pointer argument.  */\n+  tree ptr;\n+  /* The size of the pointed-to object or NULL when not specified.  */\n+  tree size;\n+\n+  /* The zero-based number of each of the formal function arguments.  */\n+  unsigned ptrarg;\n+  unsigned sizarg;\n+\n+  /* The access mode.  */\n+  enum access_mode { read_only, write_only, read_write };\n+  access_mode mode;\n+};\n+\n #endif // GCC_ATTRIBS_H"}, {"sha": "8296d84617166223b92e02e79130600b969ebd3b", "filename": "gcc/builtins.c", "status": "modified", "additions": 154, "deletions": 61, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -3340,7 +3340,7 @@ determine_block_size (tree len, rtx len_rtx,\n    If the call is successfully verified as safe return true, otherwise\n    return false.  */\n \n-static bool\n+bool\n check_access (tree exp, tree, tree, tree dstwrite,\n \t      tree maxread, tree srcstr, tree dstsize)\n {\n@@ -3436,16 +3436,26 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \n       bool warned;\n       if (range[0] == range[1])\n-\twarned = warning_at (loc, opt,\n-\t\t\t     \"%K%qD specified size %E \"\n-\t\t\t     \"exceeds maximum object size %E\",\n-\t\t\t     exp, func, range[0], maxobjsize);\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD specified size %E \"\n+\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\texp, func, range[0], maxobjsize)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kspecified size %E \"\n+\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\texp, range[0], maxobjsize));\n       else\n-\twarned = warning_at (loc, opt,\n-\t\t\t     \"%K%qD specified size between %E and %E \"\n-\t\t\t     \"exceeds maximum object size %E\",\n-\t\t\t     exp, func,\n-\t\t\t     range[0], range[1], maxobjsize);\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD specified size between %E and %E \"\n+\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\texp, func,\n+\t\t\t\trange[0], range[1], maxobjsize)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kspecified size between %E and %E \"\n+\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\texp, range[0], range[1], maxobjsize));\n       if (warned)\n \tTREE_NO_WARNING (exp) = true;\n \n@@ -3474,37 +3484,69 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t  location_t loc = tree_nonartificial_location (exp);\n \t  loc = expansion_point_location_if_in_system_header (loc);\n \n+\t  bool warned = false;\n \t  if (dstwrite == slen && at_least_one)\n \t    {\n \t      /* This is a call to strcpy with a destination of 0 size\n \t\t and a source of unknown length.  The call will write\n \t\t at least one byte past the end of the destination.  */\n-\t      warning_at (loc, opt,\n-\t\t\t  \"%K%qD writing %E or more bytes into a region \"\n-\t\t\t  \"of size %E overflows the destination\",\n-\t\t\t  exp, func, range[0], dstsize);\n+\t      warned = (func\n+\t\t\t? warning_at (loc, opt,\n+\t\t\t\t      \"%K%qD writing %E or more bytes into \"\n+\t\t\t\t      \"a region of size %E overflows \"\n+\t\t\t\t      \"the destination\",\n+\t\t\t\t      exp, func, range[0], dstsize)\n+\t\t\t: warning_at (loc, opt,\n+\t\t\t\t      \"%Kwriting %E or more bytes into \"\n+\t\t\t\t      \"a region of size %E overflows \"\n+\t\t\t\t      \"the destination\",\n+\t\t\t\t      exp, range[0], dstsize));\n \t    }\n \t  else if (tree_int_cst_equal (range[0], range[1]))\n-\t    warning_n (loc, opt, tree_to_uhwi (range[0]),\n-\t\t       \"%K%qD writing %E byte into a region \"\n-\t\t       \"of size %E overflows the destination\",\n-\t\t       \"%K%qD writing %E bytes into a region \"\n-\t\t       \"of size %E overflows the destination\",\n-\t\t       exp, func, range[0], dstsize);\n+\t    warned = (func\n+\t\t      ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t\t   \"%K%qD writing %E byte into a region \"\n+\t\t\t\t   \"of size %E overflows the destination\",\n+\t\t\t\t   \"%K%qD writing %E bytes into a region \"\n+\t\t\t\t   \"of size %E overflows the destination\",\n+\t\t\t\t   exp, func, range[0], dstsize)\n+\t\t      : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t\t   \"%Kwriting %E byte into a region \"\n+\t\t\t\t   \"of size %E overflows the destination\",\n+\t\t\t\t   \"%Kwriting %E bytes into a region \"\n+\t\t\t\t   \"of size %E overflows the destination\",\n+\t\t\t\t   exp, range[0], dstsize));\n \t  else if (tree_int_cst_sign_bit (range[1]))\n \t    {\n \t      /* Avoid printing the upper bound if it's invalid.  */\n-\t      warning_at (loc, opt,\n-\t\t\t  \"%K%qD writing %E or more bytes into a region \"\n-\t\t\t  \"of size %E overflows the destination\",\n-\t\t\t  exp, func, range[0], dstsize);\n+\t      warned = (func\n+\t\t\t? warning_at (loc, opt,\n+\t\t\t\t      \"%K%qD writing %E or more bytes into \"\n+\t\t\t\t      \"a region of size %E overflows \"\n+\t\t\t\t      \"the destination\",\n+\t\t\t\t      exp, func, range[0], dstsize)\n+\t\t\t: warning_at (loc, opt,\n+\t\t\t\t      \"%Kwriting %E or more bytes into \"\n+\t\t\t\t      \"a region of size %E overflows \"\n+\t\t\t\t      \"the destination\",\n+\t\t\t\t      exp, range[0], dstsize));\n \t    }\n \t  else\n-\t    warning_at (loc, opt,\n-\t\t\t\"%K%qD writing between %E and %E bytes into \"\n-\t\t\t\"a region of size %E overflows the destination\",\n-\t\t\texp, func, range[0], range[1],\n-\t\t\tdstsize);\n+\t    warned = (func\n+\t\t      ? warning_at (loc, opt,\n+\t\t\t\t    \"%K%qD writing between %E and %E bytes \"\n+\t\t\t\t    \"into a region of size %E overflows \"\n+\t\t\t\t    \"the destination\",\n+\t\t\t\t    exp, func, range[0], range[1],\n+\t\t\t\t    dstsize)\n+\t\t      : warning_at (loc, opt,\n+\t\t\t\t    \"%Kwriting between %E and %E bytes \"\n+\t\t\t\t    \"into a region of size %E overflows \"\n+\t\t\t\t    \"the destination\",\n+\t\t\t\t    exp, range[0], range[1],\n+\t\t\t\t    dstsize));\n+\t  if (warned)\n+\t    TREE_NO_WARNING (exp) = true;\n \n \t  /* Return error when an overflow has been detected.  */\n \t  return false;\n@@ -3527,21 +3569,36 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t      if (TREE_NO_WARNING (exp))\n \t\treturn false;\n \n+\t      bool warned = false;\n+\n \t      /* Warn about crazy big sizes first since that's more\n \t\t likely to be meaningful than saying that the bound\n \t\t is greater than the object size if both are big.  */\n \t      if (range[0] == range[1])\n-\t\twarning_at (loc, opt,\n-\t\t\t    \"%K%qD specified bound %E \"\n-\t\t\t    \"exceeds maximum object size %E\",\n-\t\t\t    exp, func,\n-\t\t\t    range[0], maxobjsize);\n+\t\twarned = (func\n+\t\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\t\"%K%qD specified bound %E \"\n+\t\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\t\texp, func, range[0], maxobjsize)\n+\t\t\t  : warning_at (loc, opt,\n+\t\t\t\t\t\"%Kspecified bound %E \"\n+\t\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\t\texp, range[0], maxobjsize));\n \t      else\n-\t\twarning_at (loc, opt,\n-\t\t\t    \"%K%qD specified bound between %E and %E \"\n-\t\t\t    \"exceeds maximum object size %E\",\n-\t\t\t    exp, func,\n-\t\t\t    range[0], range[1], maxobjsize);\n+\t\twarned = (func\n+\t\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\t\"%K%qD specified bound between \"\n+\t\t\t\t\t\"%E and %E exceeds maximum object \"\n+\t\t\t\t\t\"size %E\",\n+\t\t\t\t\texp, func,\n+\t\t\t\t\trange[0], range[1], maxobjsize)\n+\t\t\t  : warning_at (loc, opt,\n+\t\t\t\t\t\"%Kspecified bound between \"\n+\t\t\t\t\t\"%E and %E exceeds maximum object \"\n+\t\t\t\t\t\"size %E\",\n+\t\t\t\t\texp, range[0], range[1], maxobjsize));\n+\t      if (warned)\n+\t\tTREE_NO_WARNING (exp) = true;\n \n \t      return false;\n \t    }\n@@ -3551,18 +3608,34 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t      if (TREE_NO_WARNING (exp))\n \t\treturn false;\n \n+\t      bool warned = false;\n+\n \t      if (tree_int_cst_equal (range[0], range[1]))\n-\t\twarning_at (loc, opt,\n-\t\t\t    \"%K%qD specified bound %E \"\n-\t\t\t    \"exceeds destination size %E\",\n-\t\t\t    exp, func,\n-\t\t\t    range[0], dstsize);\n+\t\twarned = (func\n+\t\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\t\"%K%qD specified bound %E \"\n+\t\t\t\t\t\"exceeds destination size %E\",\n+\t\t\t\t\texp, func,\n+\t\t\t\t\trange[0], dstsize)\n+\t\t\t  : warning_at (loc, opt,\n+\t\t\t\t\t\"%Kspecified bound %E \"\n+\t\t\t\t\t\"exceeds destination size %E\",\n+\t\t\t\t\texp, range[0], dstsize));\n \t      else\n-\t\twarning_at (loc, opt,\n-\t\t\t    \"%K%qD specified bound between %E and %E \"\n-\t\t\t    \"exceeds destination size %E\",\n-\t\t\t    exp, func,\n-\t\t\t    range[0], range[1], dstsize);\n+\t\twarned = (func\n+\t\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\t\"%K%qD specified bound between %E \"\n+\t\t\t\t\t\"and %E exceeds destination size %E\",\n+\t\t\t\t\texp, func,\n+\t\t\t\t\trange[0], range[1], dstsize)\n+\t\t\t  : warning_at (loc, opt,\n+\t\t\t\t\t\"%Kspecified bound between %E \"\n+\t\t\t\t\t\"and %E exceeds destination size %E\",\n+\t\t\t\t\texp,\n+\t\t\t\t\trange[0], range[1], dstsize));\n+\t      if (warned)\n+\t\tTREE_NO_WARNING (exp) = true;\n+\n \t      return false;\n \t    }\n \t}\n@@ -3577,26 +3650,46 @@ check_access (tree exp, tree, tree, tree dstwrite,\n       if (TREE_NO_WARNING (exp))\n \treturn false;\n \n+      bool warned = false;\n       location_t loc = tree_nonartificial_location (exp);\n+      loc = expansion_point_location_if_in_system_header (loc);\n \n       if (tree_int_cst_equal (range[0], range[1]))\n-\twarning_n (loc, opt, tree_to_uhwi (range[0]),\n-\t\t   \"%K%qD reading %E byte from a region of size %E\",\n-\t\t   \"%K%qD reading %E bytes from a region of size %E\",\n-\t\t    exp, func, range[0], slen);\n+\twarned = (func\n+\t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t       \"%K%qD reading %E byte from a region of size %E\",\n+\t\t\t       \"%K%qD reading %E bytes from a region of size %E\",\n+\t\t\t       exp, func, range[0], slen)\n+\t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t       \"%Kreading %E byte from a region of size %E\",\n+\t\t\t       \"%Kreading %E bytes from a region of size %E\",\n+\t\t\t       exp, range[0], slen));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n-\t  warning_at (loc, opt,\n-\t\t      \"%K%qD reading %E or more bytes from a region \"\n-\t\t      \"of size %E\",\n-\t\t      exp, func, range[0], slen);\n+\t  warned = (func\n+\t\t    ? warning_at (loc, opt,\n+\t\t\t\t  \"%K%qD reading %E or more bytes from a region \"\n+\t\t\t\t  \"of size %E\",\n+\t\t\t\t  exp, func, range[0], slen)\n+\t\t    : warning_at (loc, opt,\n+\t\t\t\t  \"%Kreading %E or more bytes from a region \"\n+\t\t\t\t  \"of size %E\",\n+\t\t\t\t  exp, range[0], slen));\n \t}\n       else\n-\twarning_at (loc, opt,\n-\t\t    \"%K%qD reading between %E and %E bytes from a region \"\n-\t\t    \"of size %E\",\n-\t\t    exp, func, range[0], range[1], slen);\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD reading between %E and %E bytes from \"\n+\t\t\t\t\"a region of size %E\",\n+\t\t\t\texp, func, range[0], range[1], slen)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kreading between %E and %E bytes from \"\n+\t\t\t\t\"a region of size %E\",\n+\t\t\t\texp, range[0], range[1], slen));\n+      if (warned)\n+\tTREE_NO_WARNING (exp) = true;\n+\n       return false;\n     }\n "}, {"sha": "aa83a46a684903ebaee19548a0eb5d6570578880", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -151,5 +151,7 @@ bool check_nul_terminated_array (tree, tree, tree = NULL_TREE);\n extern void warn_string_no_nul (location_t, const char *, tree, tree);\n extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);\n extern bool builtin_with_linkage_p (tree);\n+extern bool check_access (tree, tree, tree, tree, tree, tree, tree);\n+\n \n #endif /* GCC_BUILTINS_H */"}, {"sha": "9c93f7f777aafa48c2cc505dd47a07239b4a68b4", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -1,3 +1,15 @@\n+2019-11-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/83859\n+\t* c-attribs.c (handle_access_attribute): New function.\n+\t(c_common_attribute_table): Add new attribute.\n+\t(get_argument_type): New function.\n+\t(append_access_attrs): New function.\n+\t(get_nonnull_operand): Rename...\n+\t(get_attribute_operand): ...to this.\n+\t* c-common.c (get_nonnull_operand): Rename...\n+\t(get_attribute_operand): ...to this.\n+\n 2019-11-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-attribs.c (handle_fallthrough_attribute): Use pedwarn instead"}, {"sha": "e307160a4534590712e7193c6bfba68e096a08cb", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 387, "deletions": 1, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -123,6 +123,8 @@ static tree handle_nothrow_attribute (tree *, tree, tree, int, bool *);\n static tree handle_cleanup_attribute (tree *, tree, tree, int, bool *);\n static tree handle_warn_unused_result_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n+static tree handle_access_attribute (tree *, tree, tree, int, bool *);\n+\n static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);\n static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n@@ -477,6 +479,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_copy_attribute, NULL },\n   { \"noinit\",\t\t      0, 0, true,  false, false, false,\n \t\t\t      handle_noinit_attribute, attr_noinit_exclusions },\n+  { \"access\",\t\t      1, 3, false, true, true, false,\n+\t\t\t      handle_access_attribute, NULL },\n   { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -508,7 +512,8 @@ attribute_takes_identifier_p (const_tree attr_id)\n     return true;\n   else if (!strcmp (\"mode\", spec->name)\n \t   || !strcmp (\"format\", spec->name)\n-\t   || !strcmp (\"cleanup\", spec->name))\n+\t   || !strcmp (\"cleanup\", spec->name)\n+\t   || !strcmp (\"access\", spec->name))\n     return true;\n   else\n     return targetm.attribute_takes_identifier_p (attr_id);\n@@ -3795,6 +3800,387 @@ handle_nonstring_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   return NULL_TREE;\n }\n \n+/* Given a function type FUNCTYPE, returns the type of the parameter\n+   ARGNO or null if ARGNO exceeds the number of parameters.  On failure\n+   set *NARGS to the number of function parameters.  */\n+\n+static tree\n+get_argument_type (tree functype, unsigned argno, unsigned *nargs)\n+{\n+  function_args_iterator iter;\n+  function_args_iter_init (&iter, functype);\n+\n+  unsigned count = 0;\n+\n+  for ( ; iter.next; ++count, function_args_iter_next (&iter))\n+    {\n+      if (count + 1 == argno)\n+\t{\n+\t  tree argtype = function_args_iter_cond (&iter);\n+\t  if (VOID_TYPE_P (argtype))\n+\t    break;\n+\t  return argtype;\n+\t}\n+    }\n+\n+  *nargs = count;\n+  return NULL_TREE;\n+}\n+\n+/* Appends ATTRSTR to the access string in ATTRS if one is there\n+   or creates a new one and returns the concatenated access string.  */\n+\n+static tree\n+append_access_attrs (tree t, tree attrs, const char *attrstr,\n+\t\t     char code, HOST_WIDE_INT idxs[2])\n+{\n+  char attrspec[80];\n+  int n1 = sprintf (attrspec, \"%c%u\", code, (unsigned) idxs[0] - 1);\n+  int n2 = 0;\n+  if (idxs[1])\n+    n2 = sprintf (attrspec + n1 + 1, \"%u\", (unsigned) idxs[1] - 1);\n+\n+  size_t newlen = n1 + n2;\n+  char *newspec = attrspec;\n+\n+  if (tree acs = lookup_attribute (\"access\", attrs))\n+    {\n+      acs = TREE_VALUE (acs);\n+      gcc_assert (TREE_CODE (acs) == STRING_CST);\n+\n+      /* Check to make sure ATTRSPEC doesn't conflict with another\n+\t access attribute specified in ATTRS by searching the access\n+\t string in ATTRS for the position string formatted above into\n+\t ATTRSPEC, and if it's found, that the two match.  */\n+\n+      const char *posstr = attrspec + 1;\n+      const char *str = TREE_STRING_POINTER (acs);\n+      const char *pos = str;\n+      for ( ; ; pos += n1)\n+\t{\n+\t  pos = strstr (pos, posstr);\n+\t  if (!pos)\n+\t    break;\n+\n+\t  if (ISDIGIT (pos[-1]) || ISDIGIT (pos[n1 -1]))\n+\t    continue;\n+\n+\t  /* Found a matching positional argument.  */\n+\t  if (*attrspec != pos[-1])\n+\t    {\n+\t      /* Mismatch in access mode.  */\n+\t      if (warning (OPT_Wattributes,\n+\t\t\t   \"attribute %qs mismatch with mode %qs\",\n+\t\t\t   attrstr,\n+\t\t\t   (pos[-1] == 'r'\n+\t\t\t    ? \"read_only\"\n+\t\t\t    : (pos[-1] == 'w' ? \"write_only\" : \"read_write\")))\n+\t\t  && DECL_P (t))\n+\t\tinform (DECL_SOURCE_LOCATION (t),\n+\t\t\t\"previous declaration here\");\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  if ((n2 && pos[n1 - 1] != ','))\n+\t    {\n+\t      /* Mismatch in the presence of the size argument.  */\n+\t      if (warning (OPT_Wattributes,\n+\t\t\t   \"attribute %qs positional argument 2 conflicts \"\n+\t\t\t   \"with previous designation\",\n+\t\t\t   attrstr)\n+\t\t  && DECL_P (t))\n+\t\tinform (DECL_SOURCE_LOCATION (t),\n+\t\t\t\"previous declaration here\");\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  if (!n2 && pos[n1 - 1] == ',')\n+\t    {\n+\t      /* Mismatch in the presence of the size argument.  */\n+\t      if (warning (OPT_Wattributes,\n+\t\t\t   \"attribute %qs missing positional argument 2 \"\n+\t\t\t   \"provided in previous designation\",\n+\t\t\t   attrstr)\n+\t\t  && DECL_P (t))\n+\t\tinform (DECL_SOURCE_LOCATION (t),\n+\t\t\t\"previous declaration here\");\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  if (n2 && strncmp (attrstr + n1 + 1, pos + n1, n2))\n+\t    {\n+\t      /* Mismatch in the value of the size argument.  */\n+\t      if (warning (OPT_Wattributes,\n+\t\t\t   \"attribute %qs mismatch positional argument \"\n+\t\t\t   \"values %i and %i\",\n+\t\t\t   attrstr, atoi (attrstr + n1 + 1), atoi (pos + n1))\n+\t\t  && DECL_P (t))\n+\t\tinform (DECL_SOURCE_LOCATION (t),\n+\t\t\t\"previous declaration here\");\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  /* Avoid adding the same attribute specification.  */\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* Connect the two substrings formatted above into a single one.  */\n+      if (idxs[1])\n+\tattrspec[n1] = ',';\n+\n+      size_t len = strlen (str);\n+      newspec = (char *) xmalloc (newlen + len + 1);\n+      strcpy (newspec, str);\n+      strcpy (newspec + len, attrspec);\n+      newlen += len;\n+    }\n+  else if (idxs[1])\n+    /* Connect the two substrings formatted above into a single one.  */\n+    attrspec[n1] = ',';\n+\n+  return build_string (newlen + 1, newspec);\n+}\n+\n+/* Handle the access attribute (read_only, write_only, and read_write).  */\n+\n+static tree\n+handle_access_attribute (tree *node, tree name, tree args,\n+\t\t\t int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree type = *node;\n+  tree attrs = TYPE_ATTRIBUTES (type);\n+\n+  *no_add_attrs = true;\n+\n+  /* Verify a full prototype is provided so that the argument types\n+     can be validated.  Avoid diagnosing type-generic built-ins since\n+     those have no prototype.  */\n+  if (!args\n+      && !prototype_p (type)\n+      && (!attrs || !lookup_attribute (\"type generic\", attrs)))\n+    {\n+      error (\"attribute %qE without arguments on a non-prototype\", name);\n+      return NULL_TREE;\n+    }\n+\n+  /* Set to true when the access mode has the form of a function call\n+     as in 'attribute (read_only (1, 2))'.  That's an easy mistake to\n+     make and so worth a special diagnostic.  */\n+  bool funcall = false;\n+  tree access_mode = TREE_VALUE (args);\n+  if (TREE_CODE (access_mode) == CALL_EXPR)\n+    {\n+      access_mode = CALL_EXPR_FN (access_mode);\n+      if (TREE_CODE (access_mode) != ADDR_EXPR)\n+\t{\n+\t  error (\"attribute %qE invalid mode\", name);\n+\t  return NULL_TREE;\n+\t}\n+      access_mode = TREE_OPERAND (access_mode, 0);\n+      access_mode = DECL_NAME (access_mode);\n+      funcall = true;\n+    }\n+\n+  const char* const access_str = IDENTIFIER_POINTER (access_mode);\n+  const char *ps = access_str;\n+  if (ps[0] == '_' && ps[1] == '_')\n+    {\n+      size_t len = strlen (ps);\n+      if (ps[len - 1] == '_' && ps[len - 2] == '_')\n+\tps += 2;\n+    }\n+\n+  const bool read_only = strncmp (ps, \"read_only\", 9) == 0;\n+  const bool write_only = strncmp (ps, \"write_only\", 9) == 0;\n+  if (!read_only && !write_only && strncmp (ps, \"read_write\", 9))\n+    {\n+      error (\"attribute %qE invalid mode %qs; expected one of \"\n+\t     \"%qs, %qs, or %qs\", name, access_str,\n+\t     \"read_only\", \"read_write\", \"write_only\");\n+      return NULL_TREE;\n+    }\n+\n+  if (funcall)\n+    {\n+      error (\"attribute %qE unexpected %<(%> after mode %qs; expected \"\n+\t     \"a positional argument or %<)%>\",\n+\t     name, access_str);\n+      return NULL_TREE;\n+    }\n+\n+  args = TREE_CHAIN (args);\n+  if (!args)\n+    {\n+      /* The first positional argument is required.  It may be worth\n+\t dropping the requirement at some point and having read_only\n+\t apply to all const-qualified pointers and read_write or\n+\t write_only to the rest.  */\n+      error (\"attribute %<%E(%s)%> missing an argument\",\n+\t     name, access_str);\n+      return NULL_TREE;\n+    }\n+\n+  /* One or more positional arguments have been specified.  Validate\n+     them.  */\n+  tree idxnodes[2] = { NULL_TREE, NULL_TREE };\n+  tree argtypes[2] = { NULL_TREE, NULL_TREE };\n+  /* 1-based attribute positional arguments or zero if not specified.\n+     Invalid negative or excessive values are also stored but used\n+     only in diagnostics.  */\n+  HOST_WIDE_INT idxs[2] = { 0, 0 };\n+\n+  /* Number of function formal arguments (used in diagnostics).  */\n+  unsigned nfuncargs = 0;\n+  /* Number of (optional) attribute positional arguments.  */\n+  unsigned nattrargs = 0;\n+\n+  for (unsigned i = 0; i != 2; ++i, args = TREE_CHAIN (args), ++nattrargs)\n+    {\n+      if (!args)\n+\tbreak;\n+\n+      idxnodes[i] = TREE_VALUE (args);\n+\n+      if (TREE_CODE (idxnodes[i]) != IDENTIFIER_NODE\n+\t  && TREE_CODE (idxnodes[i]) != FUNCTION_DECL)\n+\tidxnodes[i] = default_conversion (idxnodes[i]);\n+\n+      if (tree_fits_shwi_p (idxnodes[i]))\n+\t{\n+\t  idxs[i] = tree_to_shwi (idxnodes[i]);\n+\t  argtypes[i] = get_argument_type (type, idxs[i], &nfuncargs);\n+\t}\n+    }\n+\n+  if ((nattrargs == 1 && !idxs[0])\n+      || (nattrargs == 2 && (!idxs[0] || !idxs[1])))\n+    {\n+      if (idxnodes[1])\n+\terror (\"attribute %<%E(%s, %E, %E)%> invalid positional argument %i\",\n+\t       name, access_str, idxnodes[0], idxnodes[1], idxs[0] ? 2 : 1);\n+      else\n+\terror (\"attribute %<%E(%s, %E)%> invalid positional argument %i\",\n+\t       name, access_str, idxnodes[0], idxs[0] ? 2 : 1);\n+      return NULL_TREE;\n+    }\n+\n+  /* Format the attribute specification to include in diagnostics.  */\n+  char attrstr[80];\n+  if (idxnodes[1])\n+    snprintf (attrstr, sizeof attrstr, \"%s(%s, %lli, %lli)\",\n+\t      IDENTIFIER_POINTER (name), access_str,\n+\t      (long long) idxs[0], (long long) idxs[1]);\n+  else if (idxnodes[0])\n+    snprintf (attrstr, sizeof attrstr, \"%s(%s, %lli)\",\n+\t      IDENTIFIER_POINTER (name), access_str,\n+\t      (long long) idxs[0]);\n+  else\n+    snprintf (attrstr, sizeof attrstr, \"%s(%s)\",\n+\t      IDENTIFIER_POINTER (name), access_str);\n+\n+  /* Verify the positional argument values are in range.  */\n+  if (!argtypes[0] || (idxnodes[1] && !argtypes[1]))\n+    {\n+      if (idxnodes[0])\n+\t{\n+\t  if (idxs[0] < 0 || idxs[1] < 0)\n+\t    error (\"attribute %qs positional argument %i invalid value %wi\",\n+\t\t   attrstr, idxs[0] < 0 ? 1 : 2,\n+\t\t   idxs[0] < 0 ? idxs[0] : idxs[1]);\n+\t  else\n+\t    error (\"attribute %qs positional argument %i value %wi exceeds \"\n+\t\t   \"number of function arguments %u\",\n+\t\t   attrstr, idxs[0] ? 1 : 2,\n+\t\t   idxs[0] ? idxs[0] : idxs[1],\n+\t\t   nfuncargs);\n+\t}\n+      else\n+\terror (\"attribute %qs invalid positional argument\", attrstr);\n+\n+      return NULL_TREE;\n+    }\n+\n+  if (!POINTER_TYPE_P (argtypes[0]))\n+    {\n+      /* The first argument must have a pointer or reference type.  */\n+      error (\"attribute %qs positional argument 1 references \"\n+\t     \"non-pointer argument type %qT\",\n+\t     attrstr, argtypes[0]);\n+      return NULL_TREE;\n+    }\n+\n+  {\n+    /* Pointers to functions are not allowed.  */\n+    tree ptrtype = TREE_TYPE (argtypes[0]);\n+    if (FUNC_OR_METHOD_TYPE_P (ptrtype))\n+      {\n+\terror (\"attribute %qs positional argument 1 references \"\n+\t       \"argument of function type %qT\",\n+\t       attrstr, ptrtype);\n+\treturn NULL_TREE;\n+      }\n+  }\n+\n+  if (!read_only)\n+    {\n+      /* A read_write and write_only modes must reference non-const\n+\t arguments.  */\n+      if (TYPE_READONLY (TREE_TYPE (argtypes[0])))\n+\t{\n+\t  error (\"attribute %qs positional argument 1 references \"\n+\t\t \"%qs-qualified argument type %qT\",\n+\t\t attrstr, \"const\", argtypes[0]);\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  else if (!TYPE_READONLY (TREE_TYPE (argtypes[0])))\n+    {\n+      /* A read_only mode should ideally reference const-qualified\n+\t arguments but it's not diagnosed error if one doesn't.\n+\t This makes it possible to annotate legacy, const-incorrect\n+\t APIs.  It might be worth a diagnostic along the lines of\n+\t -Wsuggest-const.  */\n+      ;\n+    }\n+\n+  if (argtypes[1] && !INTEGRAL_TYPE_P (argtypes[1]))\n+    {\n+      error (\"attribute %qs positional argument 2 references \"\n+\t     \"non-integer argument type %qT\",\n+\t     attrstr, argtypes[1]);\n+      return NULL_TREE;\n+    }\n+\n+  /* Verify that the new attribute doesn't conflict with any existing\n+     attributes specified on previous declarations of the same type\n+     and if not, concatenate the two.  */\n+  const char code = read_only ? 'r' : write_only ? 'w' : 'x';\n+  tree new_attrs = append_access_attrs (node[0], attrs, attrstr, code, idxs);\n+  if (!new_attrs)\n+    return NULL_TREE;\n+\n+  /* Replace any existing access attribute specification with\n+     the concatenation above.  */\n+  attrs = remove_attribute (IDENTIFIER_POINTER (name), attrs);\n+  new_attrs = tree_cons (name, new_attrs, attrs);\n+\n+  if (node[1])\n+    {\n+      /* Repeat for the previously declared type.  */\n+      attrs = TYPE_ATTRIBUTES (TREE_TYPE (node[1]));\n+      tree new_attrs = append_access_attrs (node[1], attrs, attrstr, code, idxs);\n+      if (!new_attrs)\n+\treturn NULL_TREE;\n+\n+      attrs = remove_attribute (IDENTIFIER_POINTER (name), attrs);\n+      new_attrs = tree_cons (name, new_attrs, attrs);\n+      TYPE_ATTRIBUTES (TREE_TYPE (node[1])) = new_attrs;\n+    }\n+\n+  TYPE_ATTRIBUTES (*node) = new_attrs;\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"nothrow\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "3e70b6d72f63352602a6219998c427ec9b4c7df1", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -5483,7 +5483,7 @@ nonnull_check_p (tree args, unsigned HOST_WIDE_INT param_num)\n \n   for (; args; args = TREE_CHAIN (args))\n     {\n-      bool found = get_nonnull_operand (TREE_VALUE (args), &arg_num);\n+      bool found = get_attribute_operand (TREE_VALUE (args), &arg_num);\n \n       gcc_assert (found);\n \n@@ -5518,11 +5518,11 @@ check_nonnull_arg (void *ctx, tree param, unsigned HOST_WIDE_INT param_num)\n     }\n }\n \n-/* Helper for nonnull attribute handling; fetch the operand number\n-   from the attribute argument list.  */\n+/* Helper for attribute handling; fetch the operand number from\n+   the attribute argument list.  */\n \n bool\n-get_nonnull_operand (tree arg_num_expr, unsigned HOST_WIDE_INT *valp)\n+get_attribute_operand (tree arg_num_expr, unsigned HOST_WIDE_INT *valp)\n {\n   /* Verify the arg number is a small constant.  */\n   if (tree_fits_uhwi_p (arg_num_expr))"}, {"sha": "bed4d0c8764e68942c102a5a8d9636cd65ade502", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -880,7 +880,7 @@ extern bool pointer_to_zero_sized_aggr_p (tree);\n extern bool bool_promoted_to_int_p (tree);\n extern tree fold_for_warn (tree);\n extern tree c_common_get_narrower (tree, int *);\n-extern bool get_nonnull_operand (tree, unsigned HOST_WIDE_INT *);\n+extern bool get_attribute_operand (tree, unsigned HOST_WIDE_INT *);\n \n #define c_sizeof(LOC, T)  c_sizeof_or_alignof_type (LOC, T, true, false, 1)\n #define c_alignof(LOC, T) c_sizeof_or_alignof_type (LOC, T, false, false, 1)"}, {"sha": "15627abbd0da419b9a1eb2ab173d0fe76bb3504e", "filename": "gcc/calls.c", "status": "modified", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -52,6 +52,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-strlen.h\"\n #include \"intl.h\"\n #include \"stringpool.h\"\n+#include \"hash-map.h\"\n+#include \"hash-traits.h\"\n #include \"attribs.h\"\n #include \"builtins.h\"\n #include \"gimple-fold.h\"\n@@ -1258,6 +1260,9 @@ alloc_max_size (void)\n bool\n get_size_range (tree exp, tree range[2], bool allow_zero /* = false */)\n {\n+  if (!exp)\n+    return false;\n+\n   if (tree_fits_uhwi_p (exp))\n     {\n       /* EXP is a constant.  */\n@@ -1870,6 +1875,309 @@ maybe_complain_about_tail_call (tree call_expr, const char *reason)\n   error_at (EXPR_LOCATION (call_expr), \"cannot tail-call: %s\", reason);\n }\n \n+/* Used to define rdwr_map below.  */\n+struct rdwr_access_hash: int_hash<int, -1> { };\n+\n+/* A mapping between argument number corresponding to attribute access\n+   mode (read_only, write_only, or read_write) and operands.  */\n+typedef hash_map<rdwr_access_hash, attr_access> rdwr_map;\n+\n+/* Initialize a mapping for a call to function FNDECL declared with\n+   attribute access.  Each attribute poisitional operand inserts one\n+   entry into the mapping with the operand number as the key.  */\n+\n+static void\n+init_attr_rdwr_indices (rdwr_map *rwm, tree fntype)\n+{\n+  if (!fntype)\n+    return;\n+\n+  tree access = TYPE_ATTRIBUTES (fntype);\n+  /* If the function's type has no attributes there's nothing to do.  */\n+  if (!access)\n+    return;\n+\n+  access = lookup_attribute (\"access\", access);\n+  if (!access)\n+    return;\n+\n+  tree mode = TREE_VALUE (access);\n+  gcc_assert (TREE_CODE (mode) == STRING_CST);\n+  const char *modestr = TREE_STRING_POINTER (mode);\n+  for (const char *m = modestr; *m; )\n+    {\n+      attr_access acc = { };\n+\n+      switch (*m)\n+\t{\n+\tcase 'r': acc.mode = acc.read_only; break;\n+\tcase 'w': acc.mode = acc.write_only; break;\n+\tdefault: acc.mode = acc.read_write; break;\n+\t}\n+\n+      char *end;\n+      acc.ptrarg = strtoul (++m, &end, 10);\n+      m = end;\n+      if (*m == ',')\n+\t{\n+\t  acc.sizarg = strtoul (++m, &end, 10);\n+\t  m = end;\n+\t}\n+      else\n+\tacc.sizarg = UINT_MAX;\n+\n+      acc.ptr = NULL_TREE;\n+      acc.size = NULL_TREE;\n+\n+      /* Unconditionally add an entry for the required pointer\n+\t operand of the attribute, and one for the optional size\n+\t operand when it's specified.  */\n+      rwm->put (acc.ptrarg, acc);\n+      if (acc.sizarg != UINT_MAX)\n+\trwm->put (acc.sizarg, acc);\n+    }\n+}\n+\n+/* Returns the type of the argument ARGNO to function with type FNTYPE\n+   or null when the typoe cannot be determined or no such argument exists.  */\n+\n+static tree\n+fntype_argno_type (tree fntype, unsigned argno)\n+{\n+  if (!prototype_p (fntype))\n+    return NULL_TREE;\n+\n+  tree argtype;\n+  function_args_iterator it;\n+  FOREACH_FUNCTION_ARGS (fntype, argtype, it)\n+    if (argno-- == 0)\n+      return argtype;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Helper to append the \"rdwr\" attribute specification described\n+   by ACCESS to the array ATTRSTR with size STRSIZE.  Used in\n+   diagnostics.  */\n+\n+static inline void\n+append_attrname (const std::pair<int, attr_access> &access,\n+\t\t char *attrstr, size_t strsize)\n+{\n+  /* Append the relevant attribute to the string.  This (deliberately)\n+     appends the attribute pointer operand even when none was specified.  */\n+  size_t len = strlen (attrstr);\n+\n+  const char *atname\n+    = (access.second.mode == attr_access::read_only\n+       ? \"read_only\"\n+       : (access.second.mode == attr_access::write_only\n+\t  ? \"write_only\" : \"read_write\"));\n+\n+  const char *sep = len ? \", \" : \"\";\n+\n+  if (access.second.sizarg == UINT_MAX)\n+    snprintf (attrstr + len, strsize - len,\n+\t      \"%s%s (%i)\", sep, atname,\n+\t      access.second.ptrarg + 1);\n+  else\n+    snprintf (attrstr + len, strsize - len,\n+\t      \"%s%s (%i, %i)\", sep, atname,\n+\t      access.second.ptrarg + 1, access.second.sizarg + 1);\n+}\n+\n+/* Iterate over attribute access read-only, read-write, and write-only\n+   arguments and diagnose past-the-end accesses and related problems\n+   in the function call EXP.  */\n+\n+static void\n+maybe_warn_rdwr_sizes (rdwr_map *rwm, tree exp)\n+{\n+  tree fndecl = NULL_TREE;\n+  tree fntype = NULL_TREE;\n+  if (tree fnaddr = CALL_EXPR_FN (exp))\n+    {\n+      if (TREE_CODE (fnaddr) == ADDR_EXPR)\n+\t{\n+\t  fndecl = TREE_OPERAND (fnaddr, 0);\n+\t  fntype = TREE_TYPE (fndecl);\n+\t}\n+      else\n+\tfntype = TREE_TYPE (TREE_TYPE (fnaddr));\n+    }\n+\n+  if (!fntype)\n+    return;\n+\n+  /* A string describing the attributes that the warnings issued by this\n+     function apply to.  Used to print one informational note per function\n+     call, rather than one per warning.  That reduces clutter.  */\n+  char attrstr[80];\n+  attrstr[0] = 0;\n+\n+  for (rdwr_map::iterator it = rwm->begin (); it != rwm->end (); ++it)\n+    {\n+      std::pair<int, attr_access> access = *it;\n+\n+      /* Get the function call arguments corresponding to the attribute's\n+\t positional arguments.  When both arguments have been specified\n+\t there will be two entries in *RWM, one for each.  They are\n+\t cross-referenced by their respective argument numbers in\n+\t ACCESS.PTRARG and ACCESS.SIZARG.  */\n+      const int ptridx = access.second.ptrarg;\n+      const int sizidx = access.second.sizarg;\n+\n+      gcc_assert (ptridx != -1);\n+      gcc_assert (access.first == ptridx || access.first == sizidx);\n+\n+      /* The pointer is set to null for the entry corresponding to\n+\t the size argument.  Skip it.  It's handled when the entry\n+\t corresponding to the pointer argument comes up.  */\n+      if (!access.second.ptr)\n+\tcontinue;\n+\n+      tree argtype = fntype_argno_type (fntype, ptridx);\n+      argtype = TREE_TYPE (argtype);\n+\n+      tree size;\n+      if (sizidx == -1)\n+\t{\n+\t  /* If only the pointer attribute operand was specified\n+\t     and not size, set SIZE to the size of one element of\n+\t     the pointed to type to detect smaller objects (null\n+\t     pointers are diagnosed in this case only if\n+\t     the pointer is also declared with attribute nonnull.  */\n+\t  size = size_one_node;\n+\t}\n+      else\n+\tsize = rwm->get (sizidx)->size;\n+\n+      tree ptr = access.second.ptr;\n+      tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n+      if (get_size_range (size, sizrng, true)\n+\t  && tree_int_cst_sgn (sizrng[0]) < 0\n+\t  && tree_int_cst_sgn (sizrng[1]) < 0)\n+\t{\n+\t  /* Warn about negative sizes.  */\n+\t  bool warned = false;\n+\t  location_t loc = EXPR_LOCATION (exp);\n+\t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n+\t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t\t \"%Kargument %i value %E is negative\",\n+\t\t\t\t exp, sizidx + 1, size);\n+\t  else\n+\t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t\t \"%Kargument %i range [%E, %E] is negative\",\n+\t\t\t\t exp, sizidx + 1, sizrng[0], sizrng[1]);\n+\t  if (warned)\n+\t    {\n+\t      append_attrname (access, attrstr, sizeof attrstr);\n+\t      /* Avoid warning again for the same attribute.  */\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (tree_int_cst_sgn (sizrng[0]) >= 0)\n+\t{\n+\t  if (COMPLETE_TYPE_P (argtype))\n+\t    {\n+\t      /* Multiple SIZE by the size of the type the pointer\n+\t\t argument points to.  If it's incomplete the size\n+\t\t is used as is.  */\n+\t      size = NULL_TREE;\n+\t      if (tree argsize = TYPE_SIZE_UNIT (argtype))\n+\t\tif (TREE_CODE (argsize) == INTEGER_CST)\n+\t\t  {\n+\t\t    const int prec = TYPE_PRECISION (sizetype);\n+\t\t    wide_int minsize = wi::to_wide (sizrng[0], prec);\n+\t\t    minsize *= wi::to_wide (argsize, prec);\n+\t\t    size = wide_int_to_tree (sizetype, minsize);\n+\t\t  }\n+\t    }\n+\t}\n+      else\n+\tsize = NULL_TREE;\n+\n+      if (sizidx >= 0\n+\t  && integer_zerop (ptr)\n+\t  && tree_int_cst_sgn (sizrng[0]) > 0)\n+\t{\n+\t  /* Warn about null pointers with positive sizes.  This is\n+\t     different from also declaring the pointer argument with\n+\t     attribute nonnull when the function accepts null pointers\n+\t     only when the corresponding size is zero.  */\n+\t  bool warned = false;\n+\t  location_t loc = EXPR_LOCATION (exp);\n+\t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n+\t    warned = warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t \"%Kargument %i is null but the corresponding \"\n+\t\t\t\t \"size argument %i value is %E\",\n+\t\t\t\t exp, ptridx + 1, sizidx + 1, size);\n+\t  else\n+\t    warned = warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t \"%Kargument %i is null but the corresponding \"\n+\t\t\t\t \"size argument %i range is [%E, %E]\",\n+\t\t\t\t exp, ptridx + 1, sizidx + 1,\n+\t\t\t\t sizrng[0], sizrng[1]);\n+\t  if (warned)\n+\t    {\n+\t      append_attrname (access, attrstr, sizeof attrstr);\n+\t      /* Avoid warning again for the same attribute.  */\n+\t      continue;\n+\t    }\n+\t}\n+\n+      tree objsize = compute_objsize (ptr, 0);\n+\n+      tree srcsize;\n+      if (access.second.mode == attr_access::write_only)\n+\t{\n+\t  /* For a write-only argument there is no source.  */\n+\t  srcsize = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  /* For read-only and read-write attributes also set the source\n+\t     size.  */\n+\t  srcsize = objsize;\n+\t  if (access.second.mode == attr_access::read_only)\n+\t    {\n+\t      /* For a read-only attribute there is no destination so\n+\t\t clear OBJSIZE.  This emits \"reading N bytes\" kind of\n+\t\t diagnostics instead of the \"writing N bytes\" kind.  */\n+\t      objsize = NULL_TREE;\n+\t    }\n+\t}\n+\n+      /* Clear the no-warning bit in case it was set in a prior\n+\t iteration so that accesses via different arguments are\n+\t diagnosed.  */\n+      TREE_NO_WARNING (exp) = false;\n+      check_access (exp, NULL_TREE, NULL_TREE, size, /*maxread=*/ NULL_TREE,\n+\t\t    srcsize, objsize);\n+\n+      if (TREE_NO_WARNING (exp))\n+\t/* If check_access issued a warning above, append the relevant\n+\t   attribute to the string.  */\n+\tappend_attrname (access, attrstr, sizeof attrstr);\n+    }\n+\n+  if (!*attrstr)\n+    return;\n+\n+  if (fndecl)\n+    inform (DECL_SOURCE_LOCATION (fndecl),\n+\t    \"in a call to function %qD declared with attribute %qs\",\n+\t    fndecl, attrstr);\n+  else\n+    inform (EXPR_LOCATION (fndecl),\n+\t    \"in a call with type %qT and attribute %qs\",\n+\t    fntype, attrstr);\n+\n+  /* Set the bit in case if was cleared and not set above.  */\n+  TREE_NO_WARNING (exp) = true;\n+}\n+\n /* Fill in ARGS_SIZE and ARGS array based on the parameters found in\n    CALL_EXPR EXP.\n \n@@ -1986,6 +2294,11 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n   /* Array for up to the two attribute alloc_size arguments.  */\n   tree alloc_args[] = { NULL_TREE, NULL_TREE };\n \n+  /* Map of attribute read_only, write_only, or read_write specifications\n+     for function arguments.  */\n+  rdwr_map rdwr_idx;\n+  init_attr_rdwr_indices (&rdwr_idx, fntype);\n+\n   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n   for (argpos = 0; argpos < num_actuals; i--, argpos++)\n     {\n@@ -2226,6 +2539,22 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \talloc_args[0] = args[i].tree_value;\n       else if (argpos == alloc_idx[1])\n \talloc_args[1] = args[i].tree_value;\n+\n+      /* Save the actual argument that corresponds to the access attribute\n+\t operand for later processing.  */\n+      if (attr_access *access = rdwr_idx.get (argpos))\n+\t{\n+\t  if (POINTER_TYPE_P (type))\n+\t    {\n+\t      access->ptr = args[i].tree_value;\n+\t      gcc_assert (access->size == NULL_TREE);\n+\t    }\n+\t  else\n+\t    {\n+\t      access->size = args[i].tree_value;\n+\t      gcc_assert (access->ptr == NULL_TREE);\n+\t    }\n+\t}\n     }\n \n   if (alloc_args[0])\n@@ -2238,6 +2567,9 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n   /* Detect passing non-string arguments to functions expecting\n      nul-terminated strings.  */\n   maybe_warn_nonstring_arg (fndecl, exp);\n+\n+  /* Check read_only, write_only, and read_write arguments.  */\n+  maybe_warn_rdwr_sizes (&rdwr_idx, exp);\n }\n \n /* Update ARGS_SIZE to contain the total size for the argument block."}, {"sha": "3a63d48f857aa2bc93241d8c943c77546b474d21", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -2484,6 +2484,77 @@ The following attributes are supported on most targets.\n @table @code\n @c Keep this table alphabetized by attribute name.  Treat _ as space.\n \n+@item access\n+@itemx access (@var{access-mode}, @var{ref-index})\n+@itemx access (@var{access-mode}, @var{ref-index}, @var{size-index})\n+\n+The @code{access} attribute enables the detection of invalid or unsafe\n+accesses by functions to which they apply to or their callers, as well\n+as wite-only accesses to objects that are never read from.  Such accesses\n+may be diagnosed by warnings such as @option{-Wstringop-overflow},\n+@option{-Wunnitialized}, @option{-Wunused}, and others.\n+\n+The @code{access} attribute specifies that a function to whose by-reference\n+arguments the attribute applies accesses the referenced object according to\n+@var{access-mode}.  The @var{access-mode} argument is required and must be\n+one of three names: @code{read_only}, @code{read_write}, or @code{write_only}.\n+The remaining two are positional arguments.\n+\n+The required @var{ref-index} positional argument  denotes a function\n+argument of pointer (or in C++, refeference) type that is subject to\n+the access.  The same pointer argument can be referenced by at most one\n+distinct @code{access} attribute.\n+\n+The optional @var{size-index} positional argument denotes a function\n+argument of integer type that specifies the maximum size of the access.\n+The size is the number of elements of the type refefenced by @var{ref-index},\n+or the number of bytes when the pointer type is @code{void*}.  When no\n+@var{size-index} argument is specified, the pointer argument must be either\n+null or point to a space that is suitably aligned and large for at least one\n+object of the referenced type (this implies that a past-the-end pointer is\n+not a valid argument).  The actual size of the access may be less but it\n+must not be more.\n+\n+The @code{read_only} access mode specifies that the pointer to which it\n+applies is used to read the referenced object but not write to it.  Unless\n+the argument specifying the size of the access denoted by @var{size-index}\n+is zero, the referenced object must be initialized.  The mode implies\n+a stronger guarantee than the @code{const} qualifier which, when cast away\n+from a pointer, does not prevent a function from modifying the pointed-to\n+object.  Examples of the use of the @code{read_only} access mode is\n+the argument to the @code{puts} function, or the second and third arguments\n+to the @code{memcpy} function.\n+\n+@smallexample\n+__attribute__ ((access (read_only))) int puts (const char*);\n+__attribute__ ((access (read_only, 1, 2))) void* memcpy (void*, const void*, size_t);\n+@end smallexample\n+\n+The @code{read_write} access mode applies to arguments of pointer types\n+without the @code{const} qualifier.  It specifies that the pointer to which\n+it applies is used to both read and write the referenced object.  Unless\n+the argument specifying the size of the access denoted by @var{size-index}\n+is zero, the object refrenced by the pointer must be initialized.  An example\n+of the use of the @code{read_write} access mode is the first argument to\n+the @code{strcat} function.\n+\n+@smallexample\n+__attribute__ ((access (read_write, 1), access (read_only, 2))) char* strcat (char*, const char*);\n+@end smallexample\n+\n+The @code{write_only} access mode applies to arguments of pointer types\n+without the @code{const} qualifier.  It specifies that the pointer to which\n+it applies is used to write to the referenced object but not read from it.\n+The object refrenced by the pointer need not be initialized.  An example\n+of the use of the @code{write_only} access mode is the first argument to\n+the @code{strcpy} function, or the first two arguments to the @code{fgets}\n+function.\n+\n+@smallexample\n+__attribute__ ((access (write_only, 1), access (read_only, 2))) char* strcpy (char*, const char*);\n+__attribute__ ((access (write_only, 1, 2), access (read_write, 3))) int fgets (char*, int, FILE*);\n+@end smallexample\n+\n @item alias (\"@var{target}\")\n @cindex @code{alias} function attribute\n The @code{alias} attribute causes the declaration to be emitted as an\n@@ -3849,7 +3920,6 @@ performing a link with relocatable output (ie: @code{ld -r}) on them.\n At present, a declaration to which @code{weakref} is attached can\n only be @code{static}.\n \n-\n @end table\n \n @c This is the end of the target-independent attribute table"}, {"sha": "b9d86958376859d5bde803ac06a26edc7837b61e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -1,3 +1,14 @@\n+2019-11-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/83859\n+\t* c-c++-common/attr-nonstring-8.c: Adjust text of expected warning.\n+\t* gcc.dg/Wstringop-overflow-23.c: New test.\n+\t* gcc.dg/Wstringop-overflow-24.c: New test.\n+\t* gcc.dg/attr-access-read-only.c: New test.\n+\t* gcc.dg/attr-access-read-write.c: New test.\n+\t* gcc.dg/attr-access-read-write-2.c: New test.\n+\t* gcc.dg/attr-access-write-only.c: New test.\n+\n 2019-11-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/88226"}, {"sha": "fbae8bae5f73debc1de0d597ff67b60af3bbd3ef", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-8.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -57,8 +57,8 @@ void test_strncat_nonstring_cst (char *d)\n   T (strncat (nd3, ns3, 1));\n   T (strncat (nd3, ns3, 2));\n   T (strncat (nd3, ns3, 3));     /* { dg-warning \"specified bound 3 equals destination size\" } */\n-  T (strncat (nd3, ns3, 4));     /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound 4\" } */\n-  /* { dg-warning \"specified bound 4 exceeds destination size 3\" \"\" { target *-*-* } .-1 } */\n+  /* Either of the two warnings below is fine.  */\n+  T (strncat (nd3, ns3, 4));     /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound 4|specified bound 4 exceeds destination size 3\" } */\n \n   T (strncat (d, pns, sizeof pns));   /* { dg-warning \"argument to .sizeof. in .\\[^\\n\\r\\]*strncat\\[^\\n\\r\\]*. call is the same expression as the source\" } */\n }"}, {"sha": "f7094342861e3b7d44c52e549694641a4b957d67", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-23.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -0,0 +1,176 @@\n+/* PR middle-end/83859 - attribute to establish relation between parameters\n+   for buffer and its size\n+   Test to verify that with optimization enabled, -Wstringop-overflow\n+   warnings are issued for calls to user-defined functions with attribute\n+   access and with non-constant out-of-bounds arguments.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n+\n+#define RDONLY(...)  __attribute__ ((access (read_only, __VA_ARGS__)))\n+#define WRONLY(...)  __attribute__ ((access (write_only, __VA_ARGS__)))\n+#define RDWR(...)  __attribute__ ((access (read_write, __VA_ARGS__)))\n+\n+typedef __INT32_TYPE__ int32_t;\n+\n+/* Exercise null pointer detection.  */\n+\n+RDONLY (2, 1) void\n+rd2_1 (int, const void*);       // { dg-message \"in a call to function 'rd2_1' declared with attribute 'read_only \\\\\\(2, 1\\\\\\)\" }\n+\n+void test_rd2_1 (void)\n+{\n+  {\n+    void *null = 0;\n+    void *p = &null;\n+\n+    rd2_1 (0, null);\n+    rd2_1 (1, p);\n+  }\n+\n+  {\n+    void *null = 0;\n+    rd2_1 (1, null);            // { dg-warning \"argument 2 is null but the corresponding size argument 1 value is 1\" }\n+  }\n+\n+  {\n+    void *null = 0;\n+    rd2_1 (SR (1, 2), null);    // { dg-warning \"argument 2 is null but the corresponding size argument 1 range is \\\\\\[1, 2]\" }\n+  }\n+}\n+\n+WRONLY (3, 1) void\n+wr3_1 (int, int, void*);        // { dg-message \"in a call to function 'wr3_1' declared with attribute 'write_only \\\\\\(3, 1\\\\\\)\" }\n+\n+void test_wr3_1 (void)\n+{\n+  {\n+    void *null = 0;\n+    void *p = &null;\n+\n+    wr3_1 (SR (0, 1), 0, null);\n+    wr3_1 (SR (1, 1), 0, p);\n+  }\n+\n+  void *null = 0;\n+\n+  wr3_1 (SR (1, 2), 1, null);   // { dg-warning \"argument 3 is null but the corresponding size argument 1 range is \\\\\\[1, 2]\" }\n+}\n+\n+\n+WRONLY (2, 1) void\n+wr2_1 (int, void*);\n+\n+void test_wrd2_1 (int n)\n+{\n+  wr2_1 (0, 0);\n+  wr2_1 (SR (-1, 1), 0);\n+  wr2_1 (SR (0, 1), 0);\n+  wr2_1 (SR (1, 2), 0);         // { dg-warning \"argument 2 is null but the corresponding size argument 1 range is \\\\\\[1, 2]\" }\n+\n+  /* This should probably be diagnosed but to avoid false positives\n+     caused by jump threading and such it would have to be done\n+     earlier than it is now.  */\n+  wr2_1 (n, 0);                 // { dg-warning \"argument 2 is null\" \"unimplemented\" { xfail *-*-* } }\n+}\n+\n+\n+/* Exercise pointer to an incomplete type other than void.  */\n+\n+struct Incomplete;\n+extern struct Incomplete inc;\n+\n+extern char ax[];\n+\n+WRONLY (1, 2) void\n+wr1_2_inc (struct Incomplete*, unsigned);\n+\n+void test_wr1_2_inc (struct Incomplete *pinc, unsigned n)\n+{\n+  wr1_2_inc (0, 0);\n+  wr1_2_inc (0, 1);         // { dg-warning \"argument 1 is null but the corresponding size argument 2 value is 1\" }\n+\n+  wr1_2_inc (pinc, 1);\n+  wr1_2_inc (&inc, 1);\n+\n+  wr1_2_inc (pinc, 123);\n+  wr1_2_inc (&inc, 456);\n+\n+  char a3[3];\n+  pinc = (struct Incomplete*)a3;\n+  wr1_2_inc (pinc, SR (3, 4));\n+  wr1_2_inc (pinc, SR (4, 5));\n+  // { dg-warning \"'wr1_2_inc' writing between 4 and 5 bytes into a region of size 3\" \"small buffer cast to incomplete\" { target *-*-* } .-1 }\n+\n+  pinc = (struct Incomplete*)ax;\n+  wr1_2_inc (pinc, SR (123, 456));\n+\n+  char vla[n];\n+  pinc = (struct Incomplete*)vla;\n+  wr1_2_inc (pinc, SR (345, 456));\n+}\n+\n+\n+RDONLY (1, 3) WRONLY (2, 4) void\n+rd1_3_wr2_4 (const void*, void*, int, int);\n+\n+void test_rd1_3_wr2_4 (const void *s, void *d, int n1, int n2)\n+{\n+  rd1_3_wr2_4 (s, d, 1, 2);\n+  rd1_3_wr2_4 (s, d, 123, 456);\n+  rd1_3_wr2_4 (s, d, INT_MAX, INT_MAX);\n+  rd1_3_wr2_4 (s, d, -1, 2);    // { dg-warning \"argument 3 value -1 is negative\" }\n+\n+  const int ir_min_m1 = SR (INT_MIN, -1);\n+  rd1_3_wr2_4 (s, d, ir_min_m1, 2);   // { dg-warning \"argument 3 range \\\\\\[-\\[0-9\\]+, -1] is negative\" }\n+\n+  rd1_3_wr2_4 (s, d, SR (-1, 0), 2);\n+  rd1_3_wr2_4 (s, d, SR (INT_MIN, INT_MAX), 2);\n+\n+  rd1_3_wr2_4 (s, d, n1, n2);\n+\n+\n+  const char s11[11] = \"0123456789\";\n+\n+  rd1_3_wr2_4 (s11, d, 11, n2);\n+  rd1_3_wr2_4 (s11, d, 12, n2);   // { dg-warning \"'rd1_3_wr2_4' reading 12 bytes from a region of size 11\" }\n+\n+  rd1_3_wr2_4 (s11, d, SR (0, 11), n2);\n+  rd1_3_wr2_4 (s11, d, SR (0, 12), n2);\n+  rd1_3_wr2_4 (s11, d, SR (11, 12), n2);\n+  rd1_3_wr2_4 (s11, d, SR (11, INT_MAX), n2);\n+  rd1_3_wr2_4 (s11, d, SR (12, 13), n2);  // { dg-warning \"'rd1_3_wr2_4' reading between 12 and 13 bytes from a region of size 11\" }\n+\n+  char d4[4];\n+  rd1_3_wr2_4 (s, d4, n1, 4);\n+  rd1_3_wr2_4 (s, d4, n1, 5);     // { dg-warning \"'rd1_3_wr2_4' writing 5 bytes into a region of size 4\" }\n+\n+  rd1_3_wr2_4 (s11, d4, SR (12, 13), SR (5, 6));\n+  // { dg-warning \"'rd1_3_wr2_4' reading between 12 and 13 bytes from a region of size 11\" \"read\" { target *-*-* } .-1 }\n+  // { dg-warning \"'rd1_3_wr2_4' writing between 5 and 6 bytes into a region of size 4\" \"read\" { target *-*-* } .-2 }\n+}\n+\n+\n+/* Verify that function pointers are handled.  */\n+\n+RDONLY (1) void (*pfrd1)(const void*, const void*);\n+\n+void test_pfrd1 (void)\n+{\n+  pfrd1 (\"\" + SR (0, 9), \"\" + SR (1, 9));\n+  pfrd1 (\"\" + SR (1, 2), \"\");   // { dg-warning \"reading 1 byte from a region of size 0\" }\n+}\n+\n+\n+WRONLY (4, 3) void (*pfwr4_3)(int, const char*, int, int*);\n+\n+void test_pfwr4_3 (void)\n+{\n+  int32_t i;\n+  pfwr4_3 (3, \"\", 0, &i + SR (0, 9));\n+  pfwr4_3 (5, \"\", 1, &i + SR (1, 2));   // { dg-warning \"writing 4 bytes into a region of size 0\" }\n+}"}, {"sha": "8a490d7b7efd93b97ec7297ed093c93e3a4085d3", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-24.c", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-24.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -0,0 +1,204 @@\n+/* PR middle-end/83859 - attribute to establish relation between parameters\n+   for buffer and its size\n+   Test to verify that -Wstringop-overflow warnings are issued even with\n+   no optimization for calls to user-defined functions with attribute\n+   access and with constant out-of-bounds arguments.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall\" } */\n+\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n+\n+#define rdonly       __attribute__ ((access (read_only)))\n+#define RDONLY(...)  __attribute__ ((access (read_only, __VA_ARGS__)))\n+#define WRONLY(...)  __attribute__ ((access (write_only, __VA_ARGS__)))\n+#define RDWR(...)    __attribute__ ((access (read_write, __VA_ARGS__)))\n+\n+typedef __INT32_TYPE__ int32_t;\n+\n+extern const char s1[1], s2[2], s3[3];\n+extern char d1[1], d2[2], d3[3];\n+\n+/* Exercise that null pointers are allowed in functions declared with\n+   the attribute without a size operand.  */\n+\n+RDONLY (1) void\n+rd1_int (const int*);       // { dg-message \"in a call to function 'rd1_int' declared with attribute 'read_only \\\\\\(1\\\\\\)'\" }\n+\n+void test_rd1_int (void)\n+{\n+  rd1_int (0);\n+\n+  int32_t i = 0;\n+  rd1_int (&i);\n+\n+  rd1_int ((int32_t*)s1);   // { dg-warning \"reading 4 bytes from a region of size 1\" }\n+}\n+\n+/* Exercise null pointer detection in functions declared with\n+   the attribute and with non-zero size.  */\n+\n+RDONLY (2, 1) void\n+rd2_1 (int, const void*);   // { dg-message \"in a call to function 'rd2_1' declared with attribute 'read_only \\\\\\(2, 1\\\\\\)\" }\n+\n+void test_rd2_1 (void)\n+{\n+  rd2_1 (0, 0);\n+  rd2_1 (1, \"\");\n+  rd2_1 (1, 0);             // { dg-warning \"argument 2 is null but the corresponding size argument 1 value is 1\" }\n+}\n+\n+WRONLY (3, 1) void\n+wr3_1 (int, int, void*);    // { dg-message \"in a call to function 'wr3_1' declared with attribute 'write_only \\\\\\(3, 1\\\\\\)\" }\n+\n+void test_wr3_1 (void)\n+{\n+  wr3_1 (0, 0, 0);\n+  wr3_1 (1, 0, d1);\n+  wr3_1 (2, 1, 0);          // { dg-warning \"argument 3 is null but the corresponding size argument 1 value is 2\" }\n+}\n+\n+\n+/* Exercise pointer to an incomplete type other than void.  */\n+\n+struct Incomplete;\n+extern struct Incomplete inc;\n+\n+RDONLY (1) void\n+rd_inc (const struct Incomplete*);\n+\n+void test_rd_inc (const struct Incomplete *pinc)\n+{\n+  rd_inc (0);\n+\n+  rd_inc (pinc);\n+  rd_inc ((const struct Incomplete*)s1);\n+\n+  rd_inc ((const struct Incomplete*)&s1[1]);\n+  // { dg-warning \"'rd_inc' reading 1 byte from a region of size 0\" \"past-the-end pointer\" { target *-*-* } .-1 }\n+}\n+\n+RDONLY (1, 2) void\n+rd1_2_inc (const struct Incomplete*, unsigned);\n+\n+void test_rd1_2_inc (const struct Incomplete *pinc)\n+{\n+  rd1_2_inc (0, 0);\n+  rd1_2_inc (0, 1);         // { dg-warning \"argument 1 is null but the corresponding size argument 2 value is 1\" }\n+\n+  rd1_2_inc (pinc, 1);\n+  rd1_2_inc (&inc, 1);\n+\n+  rd1_2_inc (pinc, 123);\n+  rd1_2_inc (&inc, 456);\n+\n+  rd1_2_inc ((const struct Incomplete*)s3, 4);\n+  // { dg-warning \"'rd1_2_inc' reading 4 bytes from a region of size 3\" \"small buffer cast to incomplete\" { target *-*-* } .-1 }\n+}\n+\n+\n+/* Verify the handling of two attributes sharing the same size operand .  */\n+\n+RDONLY (1, 3) WRONLY (2, 3) void\n+rd1_3_wr2_3 (const void*, void*, int);\n+\n+void test_rd1_3_wr2_3 (void)\n+{\n+  rd1_3_wr2_3 (s1, d1, 0);\n+  rd1_3_wr2_3 (s1, d1, 1);\n+\n+  rd1_3_wr2_3 (s1, d1, 2);\n+  // { dg-warning \"'rd1_3_wr2_3' reading 2 bytes from a region of size 1\" \"read\" { target *-*-* } .-1 }\n+  // { dg-warning \"'rd1_3_wr2_3' writing 2 bytes into a region of size 1\" \"write\" { target *-*-* } .-2 }\n+\n+  rd1_3_wr2_3 (s1, d2, 2);\n+  // { dg-warning \"'rd1_3_wr2_3' reading 2 bytes from a region of size 1\" \"read\" { target *-*-* } .-1 }\n+\n+  rd1_3_wr2_3 (s2, d1, 2);\n+  // { dg-warning \"'rd1_3_wr2_3' writing 2 bytes into a region of size 1\" \"write\" { target *-*-* } .-1 }\n+}\n+\n+\n+/* Verify the handling of multiple attributes of the same kind with\n+   out-of-order operands.  */\n+\n+RDONLY (1, 6) RDONLY (2, 5) RDONLY (3, 4) void\n+rd1_6_2_5_3_4 (const void *s1, const void *s2, const void *s3,\n+\t       int         n3, int         n2, int         n1);\n+\n+void test_rd1_6_2_5_3_4 (void)\n+{\n+  rd1_6_2_5_3_4 (s1, s2, s3, 4, 2, 1);   // { dg-warning \"reading 4 bytes from a region of size 3\" }\n+  rd1_6_2_5_3_4 (s1, s2, s3, 3, 5, 1);   // { dg-warning \"reading 5 bytes from a region of size 2\" }\n+  rd1_6_2_5_3_4 (s1, s2, s3, 3, 2, 6);   // { dg-warning \"reading 6 bytes from a region of size 1\" }\n+}\n+\n+\n+/* Verify the handling of multiple attributes of different kinds with\n+   out-of-order operands.  */\n+\n+RDONLY (1, 6) WRONLY (2, 5) RDONLY (3, 4) void\n+rd1_6_wr2_5_rd3_4 (const void *s1, void *d2, const void *s3,\n+\t\t   int         n3, int   n2, int         n1);\n+\n+void test_rd1_6_wr2_5_rd3_4 (void)\n+{\n+  rd1_6_wr2_5_rd3_4 (s1, d2, s3, 7, 2, 1);   // { dg-warning \"reading 7 bytes from a region of size 3\" }\n+  rd1_6_wr2_5_rd3_4 (s1, d2, s3, 3, 8, 1);   // { dg-warning \"writing 8 bytes into a region of size 2\" }\n+  rd1_6_wr2_5_rd3_4 (s1, d2, s3, 3, 2, 9);   // { dg-warning \"reading 9 bytes from a region of size 1\" }\n+}\n+\n+\n+RDONLY (6, 1) WRONLY (5, 2) RDWR (4, 3) void\n+rd6_1_wr5_2_rd4_3 (int   n1, int   n2, int         n3,\n+\t\t   void *d3, void *d2, const void *s1);\n+\n+void test_rd6_1_wr5_2_rd4_3 (void)\n+{\n+  rd6_1_wr5_2_rd4_3 (7, 2, 1, d1, d2, s3);   // { dg-warning \"reading 7 bytes from a region of size 3\" }\n+  rd6_1_wr5_2_rd4_3 (3, 8, 1, d1, d2, s3);   // { dg-warning \"writing 8 bytes into a region of size 2\" }\n+  rd6_1_wr5_2_rd4_3 (3, 2, 9, d1, d2, s3);   // { dg-warning \"writing 9 bytes into a region of size 1\" }\n+}\n+\n+\n+RDONLY (1, 3) WRONLY (2, 4) void\n+rd1_3_wr2_4 (const void*, void*, int, int);\n+\n+void test_rd1_3_wr2_4 (const void *s, void *d, int n1, int n2)\n+{\n+  rd1_3_wr2_4 (s, d, 1, 2);\n+  rd1_3_wr2_4 (s, d, 123, 456);\n+  rd1_3_wr2_4 (s, d, INT_MAX, INT_MAX);\n+  rd1_3_wr2_4 (s, d, -1, 2);    // { dg-warning \"argument 3 value -1 is negative\" }\n+\n+  const char s11[11] = \"0123456789\";\n+\n+  rd1_3_wr2_4 (s11, d, 11, n2);\n+  rd1_3_wr2_4 (s11, d, 12, n2);   // { dg-warning \"'rd1_3_wr2_4' reading 12 bytes from a region of size 11\" }\n+}\n+\n+\n+/* Verify that function pointers are handled.  */\n+\n+RDONLY (1) void (*pfrd1)(const void*, const void*);\n+\n+void test_pfrd1 (void)\n+{\n+  pfrd1 (0, 0);\n+  pfrd1 (\"\", \"\");\n+\n+  pfrd1 (\"\", \"\" + 1);\n+  pfrd1 (\"\" + 1, \"\");   // { dg-warning \"reading 1 byte from a region of size 0\" }\n+}\n+\n+\n+WRONLY (4, 3) void (*pfwr4_3)(int, const char*, int, int*);\n+\n+void test_pfwr4_3 (void)\n+{\n+  pfwr4_3 (0, 0, 0, 0);\n+\n+  int32_t i;\n+  pfwr4_3 (3, \"\", 0, &i + 1);\n+  pfwr4_3 (5, \"\", 1, &i + 1);   // { dg-warning \"writing 4 bytes into a region of size 0\" }\n+}"}, {"sha": "9acd769621e6c06ef7d3ef588ebbbd9a191c3b04", "filename": "gcc/testsuite/gcc.dg/attr-access-read-only.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-only.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-only.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-only.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -0,0 +1,96 @@\n+/* PR middle-end/83859 - attribute to establish relation between parameters\n+   for buffer and its size\n+   Test to verify the handling of attribute access (read_only) syntax.\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" } */\n+\n+int  __attribute__ ((access))\n+access_v (void);       // { dg-error \"wrong number of arguments specified for 'access' attribute\" }\n+\n+int  __attribute__ ((access ()))\n+access___v (void);     // { dg-error \"wrong number of arguments specified for 'access' attribute\" }\n+\n+int  __attribute__ ((access (rdonly)))\n+rdonly_spelling (void);   // { dg-error \"attribute .access. invalid mode 'rdonly'; expected one of 'read_only', 'read_write', or 'write_only'\" }\n+\n+int  __attribute__ ((access (read_only)))\n+rdonly_v_all (void);   // { dg-error \"attribute .access\\\\(read_only\\\\). missing an argument\" }\n+\n+int  __attribute__ ((access (read_only ())))\n+rdonly___v_all (void);   // { dg-error \"attribute 'access' unexpected '\\\\(' after mode 'read_only'; expected a positional argument or '\\\\)'\" }\n+// { dg-warning \"implicit declaration of function 'read_only'\" \"\" { target *-*-* } .-2 }\n+\n+\n+int rdonly (void);\n+\n+int  __attribute__ ((access (rdonly ())))\n+rdonly___v_all (void);   // { dg-error \"attribute 'access' invalid mode 'rdonly'\" }\n+\n+\n+int  __attribute__ ((access (read_only)))\n+rdonly_i_all (int);   // { dg-error \"attribute .access\\\\(read_only\\\\). missing an argument\" }\n+\n+#define rdonly       __attribute__ ((access (read_only)))\n+#define RDONLY(...)  __attribute__ ((access (read_only, __VA_ARGS__)))\n+\n+int RDONLY (1)\n+rdonly_pcv_1 (const void*);\n+int RDONLY (2)\n+rdonly_i_pcv_2 (int, const void*);\n+int RDONLY (3)\n+rdonly_i_i_pcv_3 (int, int, const void*);\n+\n+int RDONLY (0 + 1)\n+rdonly_pcv_0p1 (const void*);\n+\n+int RDONLY (2 - 1)\n+rdonly_pcv_2m1 (const void*);\n+\n+int RDONLY (1, 1)\n+rdonly_pv_pi_1_1 (const void*, const int*);      // { dg-error \"attribute 'access\\\\(read_only, 1, 1\\\\)' positional argument 2 references non-integer argument type 'const void \\\\*'\" }\n+\n+int RDONLY (1, 2)\n+rdonly_pcv_pc_1_2 (const void*, char*);   // { dg-error \"attribute .access\\\\(read_only, 1, 2\\\\)' positional argument 2 references non-integer argument type 'char \\\\*'\" }\n+\n+int RDONLY (2, 1)\n+rdonly_pcd_pcv_2_1 (const double*, const void*);   // { dg-error \"attribute .access\\\\(read_only, 2, 1\\\\)' positional argument 2 references non-integer argument type 'const double \\\\*'\" }\n+\n+int RDONLY (2, 2)\n+rdonly_pi_pcv_2_2 (int*, const void*);   // { dg-error \"positional argument 2 references non-integer argument type 'const void \\\\*'\" }\n+\n+int RDONLY (4)\n+rdonly_i_i_i_4 (int, int, int);   // { dg-error \"attribute 'access\\\\(read_only, 4\\\\)' positional argument 1 value 4 exceeds number of function arguments 3\" }\n+\n+int RDONLY (1)\n+rdonly_i_1 (int);   // { dg-error \"attribute 'access\\\\(read_only, 1\\\\)' positional argument 1 references non-pointer argument type 'int'\" }\n+\n+// It's okay if the pointer argument is non-const, although a separate\n+// warning encouraging one might be worthwhile.  Maybe something like\n+// -Wsuggest-const.\n+int RDONLY (2)\n+rdonly_i_pc (int, char*);\n+\n+int RDONLY (-1)\n+rdonly_pcv_m1 (const void*);   // { dg-error \"attribute 'access\\\\(read_only, -1\\\\)' positional argument 1 invalid value -1\" }\n+\n+int RDONLY (1, -12345)\n+rdonly_pcv_i_1_m12345 (const void*, int*);   // { dg-error \"attribute 'access\\\\(read_only, 1, -12345\\\\)' positional argument 2 invalid value -12345\" }\n+\n+int RDONLY (\"blah\")\n+rdonly_pcv_str (const void*);   // { dg-error \"attribute 'access\\\\(read_only, \\\"blah\\\"\\\\)' invalid positional argument 1\" }\n+\n+int RDONLY (1, \"foobar\")\n+rdonly_pcv_i_1_str (const void*, int);   // { dg-error \"attribute 'access\\\\(read_only, 1, \\\"foobar\\\"\\\\)' invalid positional argument 2\" }\n+\n+// Verify that attributes whose operands reference function pointers\n+// are rejected.\n+typedef int F (int, int);\n+RDONLY (1) void rdwr_pf_1 (F*);   // { dg-error \"attribute 'access\\\\(read_only, 1\\\\)' positional argument 1 references argument of function type 'F' \\\\{aka 'int\\\\(int,  *int\\\\)'\\\\}\" }\n+\n+// Verify pointers to functions.\n+void RDONLY(2) (*prdonly_pcv2)(int, const void*);\n+void RDONLY(3, 1) (*prdonly_pcv2_1)(int, void*, const void*);\n+\n+// Verify types.\n+typedef RDONLY (2) void rdonly_p2_t (const int*, const char*, const void*);\n+typedef RDONLY (2) void rdonly_p2_1 (int, const int*);"}, {"sha": "c2ac6c344a533ba3f2e7883fd5ff0efae3738c64", "filename": "gcc/testsuite/gcc.dg/attr-access-read-write-2.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write-2.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -0,0 +1,61 @@\n+/* PR middle-end/83859 - attribute to establish relation between parameters\n+   for buffer and its size\n+   Test to verify the handling of attribute read_only combining multiple\n+   declarations of the same function.\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" } */\n+\n+#define RW(...)    __attribute__ ((access (read_write, __VA_ARGS__)))\n+#define WO(...)  __attribute__ ((access (write_only, __VA_ARGS__)))\n+\n+int rdwr1_rdwr1 (void*, void*);\n+int RW (1) RW (1) rdwr1_rdwr1 (void*, void*);\n+int RW (2) RW (2) rdwr1_rdwr1 (void*, void*);\n+int RW (1) RW (2) rdwr1_rdwr1 (void*, void*);\n+int RW (2) RW (1) rdwr1_rdwr1 (void*, void*);\n+\n+int frdwr1_wr1 (void*, void*);\n+int RW (1) WO (1) frdwr1_wr1 (void*, void*);    // { dg-warning \"attribute 'access\\\\(write_only, 1\\\\)' mismatch with mode 'read_write'\" }\n+\n+int RW (1) grdwr1_wr1 (void*, void*);           // { dg-message \"previous declaration here\" }\n+\n+int WO (1) grdwr1_wr1 (void*, void*);         // { dg-warning \"attribute 'access\\\\(write_only, 1\\\\)' mismatch with mode 'read_write'\" }\n+\n+\n+int RW (1) RW (1, 2) frdwr1_rdwr1_1 (void*, int);   // { dg-warning \"attribute 'access\\\\(read_write, 1, 2\\\\)' positional argument 2 conflicts with previous designation\" }\n+\n+int RW (1, 2) RW (1) frdwr1_1_rdwr1 (void*, int);   // { dg-warning \"attribute 'access\\\\(read_write, 1\\\\)' missing positional argument 2 provided in previous designation\" }\n+\n+int RW (1)    grdwr1_rdwr1_1 (void*, int);   // { dg-message \"previous declaration here\" }\n+int RW (1, 2) grdwr1_rdwr1_1 (void*, int);   // { dg-warning \"attribute 'access\\\\(read_write, 1, 2\\\\)' positional argument 2 conflicts with previous designation\" }\n+\n+\n+typedef int *P;\n+\n+int RW(1) WO(3) RW(5) WO(7) RW(9) WO(11) RW(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+\n+int RW(1) WO(3) RW(5) WO(7) RW(9) WO(11) RW(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+\n+int WO(1) WO(3) RW(5) WO(7) RW(9) WO(11) RW(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+// { dg-warning \"attribute 'access\\\\(write_only, 1\\\\)' mismatch with mode 'read_write'\" \"1\" { target *-*-* } .-1 }\n+\n+int RW(1) RW(3) RW(5) WO(7) RW(9) WO(11) RW(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+// { dg-warning \"attribute 'access\\\\(read_write, 3\\\\)' mismatch with mode 'write_only'\" \"3\" { target *-*-* } .-1 }\n+\n+int RW(1) WO(3) WO(5) WO(7) RW(9) WO(11) RW(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+// { dg-warning \"attribute 'access\\\\(write_only, 5\\\\)' mismatch with mode 'read_write'\" \"5\" { target *-*-* } .-1 }\n+\n+int RW(1) WO(3) RW(5) RW(7) RW(9) WO(11) RW(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+// { dg-warning \"attribute 'access\\\\(read_write, 7\\\\)' mismatch with mode 'write_only'\" \"7\" { target *-*-* } .-1 }\n+\n+int RW(1) WO(3) RW(5) WO(7) WO(9) WO(11) RW(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+// { dg-warning \"attribute 'access\\\\(write_only, 9\\\\)' mismatch with mode 'read_write'\" \"9\" { target *-*-* } .-1 }\n+\n+int RW(1) WO(3) RW(5) WO(7) RW(9) RW(11) RW(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+// { dg-warning \"attribute 'access\\\\(read_write, 11\\\\)' mismatch with mode 'write_only'\" \"11\" { target *-*-* } .-1 }\n+\n+int RW(1) WO(3) RW(5) WO(7) RW(9) WO(11) WO(13) WO(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+// { dg-warning \"attribute 'access\\\\(write_only, 13\\\\)' mismatch with mode 'read_write'\" \"13\" { target *-*-* } .-1 }\n+\n+int RW(1) WO(3) RW(5) WO(7) RW(9) WO(11) RW(13) RW(15) frw1_w3_rw5_w7_rw9_wr11_rw13_w15 (P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, int);\n+// { dg-warning \"attribute 'access\\\\(read_write, 15\\\\)' mismatch with mode 'write_only'\" \"15\" { target *-*-* } .-1 }"}, {"sha": "c97e54bbd609c8467fbee44cb9f274e8887bba8b", "filename": "gcc/testsuite/gcc.dg/attr-access-read-write.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -0,0 +1,92 @@\n+/* PR middle-end/83859 - attribute to establish relation between parameters\n+   for buffer and its size\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" } */\n+\n+int  __attribute__ ((access))\n+access_v (void);       /* { dg-error \"wrong number of arguments specified for 'access' attribute\" } */\n+\n+int  __attribute__ ((access ()))\n+access___v (void);     /* { dg-error \"wrong number of arguments specified for 'access' attribute\" } */\n+\n+int  __attribute__ ((access (rdwr)))\n+rdwr_spelling (void);   /* { dg-error \"attribute .access. invalid mode 'rdwr'; expected one of 'read_only', 'read_write', or 'write_only'\" } */\n+\n+int  __attribute__ ((access (read_write)))\n+rdwr_v_all (void);   /* { dg-error \"attribute .access\\\\(read_write\\\\). missing an argument\" } */\n+\n+int  __attribute__ ((access (read_write ())))\n+rdwr___v_all (void);   /* { dg-error \"attribute 'access' unexpected '\\\\(' after mode 'read_write'; expected a positional argument or '\\\\)'\" } */\n+/* { dg-warning \"implicit declaration of function 'read_write'\" \"\" { target *-*-* } .-2 } */\n+\n+\n+int rdwr (void);\n+\n+int  __attribute__ ((access (rdwr ())))\n+rdwr___v_all (void);   /* { dg-error \"attribute 'access' invalid mode 'rdwr'\" } */\n+\n+\n+#define RDWR(...)  __attribute__ ((access (read_write, __VA_ARGS__)))\n+\n+int RDWR (1)\n+rdwr_pcv_1 (void*);\n+\n+int RDWR (2)\n+rdwr_i_pcv_2 (int, void*);\n+int RDWR (3)\n+rdwr_i_i_pcv_3 (int, int, void*);\n+\n+int RDWR (0 + 1)\n+rdwr_pcv_0p1 (void*);\n+\n+int RDWR (2 - 1)\n+rdwr_pcv_2m1 (void*);\n+\n+int RDWR (1)\n+rdwr_pcv_pi_1_1 (const void*, int*);    /* { dg-error \"attribute 'access\\\\(read_write, 1\\\\)' positional argument 1 references 'const'-qualified argument type 'const void \\\\*'\" } */\n+\n+int RDWR (1, 1)\n+rdwr_pv_pi_1_1 (void*, int*);      /* { dg-error \"attribute 'access\\\\(read_write, 1, 1\\\\)' positional argument 2 references non-integer argument type 'void \\\\*'\" } */\n+\n+int RDWR (1, 2)\n+rdwr_pcv_pc_1_2 (void*, char*);   /* { dg-error \"attribute .access\\\\(read_write, 1, 2\\\\)' positional argument 2 references non-integer argument type 'char \\\\*'\" } */\n+\n+int RDWR (2, 1)\n+rdwr_pcd_pcv_2_1 (double*, void*);   /* { dg-error \"attribute .access\\\\(read_write, 2, 1\\\\)' positional argument 2 references non-integer argument type 'double \\\\*'\" } */\n+\n+int RDWR (2, 2)\n+rdwr_pi_pcv_2_2 (int*, void*);   /* { dg-error \"positional argument 2 references non-integer argument type 'void \\\\*'\" } */\n+\n+int RDWR (4)\n+rdwr_i_i_i_4 (int, int, int);   /* { dg-error \"attribute 'access\\\\(read_write, 4\\\\)' positional argument 1 value 4 exceeds number of function arguments 3\" } */\n+\n+int RDWR (1)\n+rdwr_i_1 (int);   /* { dg-error \"attribute 'access\\\\(read_write, 1\\\\)' positional argument 1 references non-pointer argument type 'int'\" } */\n+\n+int RDWR (2)\n+rdwr_i_pc (int, const char*);   /* { dg-error \"attribute 'access\\\\(read_write, 2\\\\)' positional argument 1 references 'const'-qualified argument type 'const char \\\\*'\" } */\n+\n+int RDWR (-1)\n+rdwr_pcv_m1 (void*);   /* { dg-error \"attribute 'access\\\\(read_write, -1\\\\)' positional argument 1 invalid value -1\" } */\n+\n+int RDWR (1, -12345)\n+rdwr_pcv_i_1_m12345 (void*, int*);   /* { dg-error \"attribute 'access\\\\(read_write, 1, -12345\\\\)' positional argument 2 invalid value -12345\" } */\n+\n+int RDWR (\"blah\")\n+rdwr_pcv_str (void*);   /* { dg-error \"attribute 'access\\\\(read_write, \\\"blah\\\"\\\\)' invalid positional argument 1\" } */\n+\n+int RDWR (1, \"foobar\")\n+rdwr_pcv_i_1_str (void*, int);   /* { dg-error \"attribute 'access\\\\(read_write, 1, \\\"foobar\\\"\\\\)' invalid positional argument 2\" } */\n+\n+/* Verify that attributes whose operands reference function pointers\n+   are rejected.  */\n+typedef int F (int, int);\n+RDWR (1) void rdwr_pf_1 (F*);   /* { dg-error \"attribute 'access\\\\(read_write, 1\\\\)' positional argument 1 references argument of function type 'F' \\\\{aka 'int\\\\(int,  *int\\\\)'\\\\}\" } */\n+\n+/* Verify pointers to functions.  */\n+void RDWR(2) (*prdwr_pv2)(int, void*);\n+void RDWR(3, 1) (*prdwr_pv2_1)(int, void*, void*);\n+\n+/* Verify types.  */\n+typedef RDWR (2) void rdwr_p2_t (int*, char*, void*);\n+typedef RDWR (2) void rdwr_p2_1 (int, int*);"}, {"sha": "008f5a36ff43e1f5e7210c8b8889b054874a8961", "filename": "gcc/testsuite/gcc.dg/attr-access-write-only.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-write-only.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54aa6b58fe2fe73bbe67e0485777e0c410a18673/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-write-only.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-write-only.c?ref=54aa6b58fe2fe73bbe67e0485777e0c410a18673", "patch": "@@ -0,0 +1,89 @@\n+/* PR middle-end/83859 - attribute to establish relation between parameters\n+   for buffer and its size\n+   Test to verify the handling of attribute access (write_only) syntax.\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" } */\n+\n+int  __attribute__ ((access))\n+access_v (void);       // { dg-error \"wrong number of arguments specified for 'access' attribute\" }\n+\n+int  __attribute__ ((access ()))\n+access___v (void);     // { dg-error \"wrong number of arguments specified for 'access' attribute\" }\n+\n+int  __attribute__ ((access (wronly)))\n+wronly_spelling (void);   // { dg-error \"attribute .access. invalid mode 'wronly'; expected one of 'read_only', 'read_write', or 'write_only'\" }\n+\n+int  __attribute__ ((access (read_only)))\n+wronly_v_all (void);   // { dg-error \"attribute .access\\\\(read_only\\\\). missing an argument\" }\n+\n+int  __attribute__ ((access (read_only ())))\n+wronly___v_all (void);   // { dg-error \"attribute 'access' unexpected '\\\\(' after mode 'read_only'; expected a positional argument or '\\\\)'\" }\n+// { dg-warning \"implicit declaration of function 'read_only'\" \"\" { target *-*-* } .-2 }\n+\n+\n+int wronly (void);\n+\n+int  __attribute__ ((access (wronly ())))\n+wronly___v_all (void);   // { dg-error \"attribute 'access' invalid mode 'wronly'\" }\n+\n+#define WRONLY(...)  __attribute__ ((access (write_only, __VA_ARGS__)))\n+\n+int WRONLY (1)\n+wronly_pcv_1 (void*);\n+int WRONLY (2)\n+wronly_i_pcv_2 (int, void*);\n+int WRONLY (3)\n+wronly_i_i_pcv_3 (int, int, void*);\n+\n+int WRONLY (0 + 1)\n+wronly_pcv_0p1 (void*);\n+\n+int WRONLY (2 - 1)\n+wronly_pcv_2m1 (void*);\n+\n+int WRONLY (1, 1)\n+wronly_pv_pi_1_1 (void*, const int*);      // { dg-error \"attribute 'access\\\\(write_only, 1, 1\\\\)' positional argument 2 references non-integer argument type 'void \\\\*'\" }\n+\n+int WRONLY (1, 2)\n+wronly_pcv_pc_1_2 (void*, char*);   // { dg-error \"attribute .access\\\\(write_only, 1, 2\\\\)' positional argument 2 references non-integer argument type 'char \\\\*'\" }\n+\n+int WRONLY (2, 1)\n+wronly_pcd_pcv_2_1 (const double*, void*);   // { dg-error \"attribute .access\\\\(write_only, 2, 1\\\\)' positional argument 2 references non-integer argument type 'const double \\\\*'\" }\n+\n+int WRONLY (2, 2)\n+wronly_pi_pcv_2_2 (int*, void*);   // { dg-error \"positional argument 2 references non-integer argument type 'void \\\\*'\" }\n+\n+int WRONLY (4)\n+wronly_i_i_i_4 (int, int, int);   // { dg-error \"attribute 'access\\\\(write_only, 4\\\\)' positional argument 1 value 4 exceeds number of function arguments 3\" }\n+\n+int WRONLY (1)\n+wronly_i_1 (int);   // { dg-error \"attribute 'access\\\\(write_only, 1\\\\)' positional argument 1 references non-pointer argument type 'int'\" }\n+\n+int WRONLY (2)\n+wronly_i_pc (int, const char*);   // { dg-error \"attribute 'access\\\\(write_only, 2\\\\)' positional argument 1 references 'const'-qualified argument type 'const char \\\\*'\" }\n+\n+int WRONLY (-1)\n+wronly_pcv_m1 (void*);   // { dg-error \"attribute 'access\\\\(write_only, -1\\\\)' positional argument 1 invalid value -1\" }\n+\n+int WRONLY (1, -12345)\n+wronly_pcv_i_1_m12345 (void*, int*);   // { dg-error \"attribute 'access\\\\(write_only, 1, -12345\\\\)' positional argument 2 invalid value -12345\" }\n+\n+int WRONLY (\"blah\")\n+wronly_pcv_str (void*);   // { dg-error \"attribute 'access\\\\(write_only, \\\"blah\\\"\\\\)' invalid positional argument 1\" }\n+\n+int WRONLY (1, \"foobar\")\n+wronly_pcv_i_1_str (void*, int);   // { dg-error \"attribute 'access\\\\(write_only, 1, \\\"foobar\\\"\\\\)' invalid positional argument 2\" }\n+\n+// Verify that attributes whose operands reference function pointers\n+// are rejected.\n+typedef int F (int, int);\n+WRONLY (1) void wronly_pf_1 (F*);   // { dg-error \"attribute 'access\\\\(write_only, 1\\\\)' positional argument 1 references argument of function type 'F' \\\\{aka 'int\\\\(int,  *int\\\\)'\\\\}\" }\n+\n+// Verify pointers to functions.\n+void WRONLY(2) (*pwronly_pcv2)(int, void*);\n+void WRONLY(3, 1) (*pwronly_pcv2_1)(int, void*, void*);\n+void WRONLY(1, 2) (*pwronly_i_pcv_1_2)(int, void*);   // { dg-error \"attribute 'access\\\\(write_only, 1, 2\\\\)' positional argument 1 references non-pointer argument type 'int'\" }\n+\n+// Verify types.\n+typedef WRONLY (2) void wronly_p2_t (const int*, char*, const void*);\n+typedef WRONLY (2) void wronly_p2_1 (int, int*);"}]}