{"sha": "a271b387e6375d5612a2bd8669e0da1ac731e9c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI3MWIzODdlNjM3NWQ1NjEyYTJiZDg2NjllMGRhMWFjNzMxZTljMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-10-27T19:59:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-10-27T19:59:41Z"}, "message": "re PR rtl-optimization/67609 (Generates wrong code for SSE2 _mm_load_pd)\n\nPR rtl-opt/67609\n\n\t* config/i386/i386.c (ix86_cannot_change_mode_class): Disallow\n\tnarrowing subregs on SSE and MMX registers.\n\t* doc/tm.texi.in (CANNOT_CHANGE_MODE_CLASS): Clarify when subregs that\n\tappear to be sub-words of multi-register pseudos must be rejected.\n\t* doc/tm.texi: Regenerate.\ntestsuite/\n\t* gcc.target/i386/pr67609-2.c: New test.\n\nFrom-SVN: r229458", "tree": {"sha": "eec2e90ceb0a5636cb3bfde359439074db6769a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec2e90ceb0a5636cb3bfde359439074db6769a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a271b387e6375d5612a2bd8669e0da1ac731e9c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a271b387e6375d5612a2bd8669e0da1ac731e9c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a271b387e6375d5612a2bd8669e0da1ac731e9c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a271b387e6375d5612a2bd8669e0da1ac731e9c3/comments", "author": null, "committer": null, "parents": [{"sha": "7263fa9ff190a311c6fefc4aafb374437d1020ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7263fa9ff190a311c6fefc4aafb374437d1020ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7263fa9ff190a311c6fefc4aafb374437d1020ae"}], "stats": {"total": 96, "additions": 84, "deletions": 12}, "files": [{"sha": "369a5821fd1a1cbe969b0deb9b0644131cd7d39e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a271b387e6375d5612a2bd8669e0da1ac731e9c3", "patch": "@@ -1,3 +1,12 @@\n+2015-10-27  Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl-opt/67609\n+\t* config/i386/i386.c (ix86_cannot_change_mode_class): Disallow\n+\tnarrowing subregs on SSE and MMX registers.\n+\t* doc/tm.texi.in (CANNOT_CHANGE_MODE_CLASS): Clarify when subregs that\n+\tappear to be sub-words of multi-register pseudos must be rejected.\n+\t* doc/tm.texi: Regenerate.\n+\n 2015-10-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/68102"}, {"sha": "82fd05412ac62228a546ba0bf0d24ed33adc5b66", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a271b387e6375d5612a2bd8669e0da1ac731e9c3", "patch": "@@ -43031,15 +43031,22 @@ ix86_cannot_change_mode_class (machine_mode from, machine_mode to,\n   if (MAYBE_FLOAT_CLASS_P (regclass))\n     return true;\n \n+  /* Vector registers do not support QI or HImode loads.  If we don't\n+     disallow a change to these modes, reload will assume it's ok to\n+     drop the subreg from (subreg:SI (reg:HI 100) 0).  This affects\n+     the vec_dupv4hi pattern.\n+\n+     Further, we cannot allow word_mode subregs of full vector modes.\n+     Otherwise the middle-end will assume it's ok to store to\n+     (subreg:DI (reg:TI 100) 0) in order to modify only the low 64 bits\n+     of the 128-bit register.  However, after reload the subreg will\n+     be dropped leaving a plain DImode store.  This is indistinguishable\n+     from a \"normal\" DImode move, and so we're justified to use movsd,\n+     which modifies the entire 128-bit register.\n+\n+     Combining these two conditions, disallow all narrowing mode changes.  */\n   if (MAYBE_SSE_CLASS_P (regclass) || MAYBE_MMX_CLASS_P (regclass))\n-    {\n-      /* Vector registers do not support QI or HImode loads.  If we don't\n-\t disallow a change to these modes, reload will assume it's ok to\n-\t drop the subreg from (subreg:SI (reg:HI 100) 0).  This affects\n-\t the vec_dupv4hi pattern.  */\n-      if (GET_MODE_SIZE (from) < 4)\n-\treturn true;\n-    }\n+    return GET_MODE_SIZE (to) < GET_MODE_SIZE (from);\n \n   return false;\n }"}, {"sha": "606ddb672f8dd6a8d2fcc70aa894f97b39956c1b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a271b387e6375d5612a2bd8669e0da1ac731e9c3", "patch": "@@ -2823,8 +2823,8 @@ in the reload pass.\n If defined, a C expression that returns nonzero for a @var{class} for which\n a change from mode @var{from} to mode @var{to} is invalid.\n \n-For the example, loading 32-bit integer or floating-point objects into\n-floating-point registers on the Alpha extends them to 64 bits.\n+For example, loading 32-bit integer or floating-point objects into\n+floating-point registers on Alpha extends them to 64 bits.\n Therefore loading a 64-bit object and then storing it as a 32-bit object\n does not store the low-order 32 bits, as would be the case for a normal\n register.  Therefore, @file{alpha.h} defines @code{CANNOT_CHANGE_MODE_CLASS}\n@@ -2835,6 +2835,17 @@ as below:\n   (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \\\n    ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)\n @end smallexample\n+\n+Even if storing from a register in mode @var{to} would be valid,\n+if both @var{from} and @code{raw_reg_mode} for @var{class} are wider\n+than @code{word_mode}, then we must prevent @var{to} narrowing the\n+mode.  This happens when the middle-end assumes that it can load\n+or store pieces of an @var{N}-word pseudo, and that the pseudo will\n+eventually be allocated to @var{N} @code{word_mode} hard registers.\n+Failure to prevent this kind of mode change will result in the\n+entire @code{raw_reg_mode} being modified instead of the partial\n+value that the middle-end intended.\n+\n @end defmac\n \n @deftypefn {Target Hook} reg_class_t TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS (int, @var{reg_class_t})"}, {"sha": "93620ebd325cd343b38296212127e0e534790f06", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=a271b387e6375d5612a2bd8669e0da1ac731e9c3", "patch": "@@ -2461,8 +2461,8 @@ in the reload pass.\n If defined, a C expression that returns nonzero for a @var{class} for which\n a change from mode @var{from} to mode @var{to} is invalid.\n \n-For the example, loading 32-bit integer or floating-point objects into\n-floating-point registers on the Alpha extends them to 64 bits.\n+For example, loading 32-bit integer or floating-point objects into\n+floating-point registers on Alpha extends them to 64 bits.\n Therefore loading a 64-bit object and then storing it as a 32-bit object\n does not store the low-order 32 bits, as would be the case for a normal\n register.  Therefore, @file{alpha.h} defines @code{CANNOT_CHANGE_MODE_CLASS}\n@@ -2473,6 +2473,17 @@ as below:\n   (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \\\n    ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)\n @end smallexample\n+\n+Even if storing from a register in mode @var{to} would be valid,\n+if both @var{from} and @code{raw_reg_mode} for @var{class} are wider\n+than @code{word_mode}, then we must prevent @var{to} narrowing the\n+mode.  This happens when the middle-end assumes that it can load\n+or store pieces of an @var{N}-word pseudo, and that the pseudo will\n+eventually be allocated to @var{N} @code{word_mode} hard registers.\n+Failure to prevent this kind of mode change will result in the\n+entire @code{raw_reg_mode} being modified instead of the partial\n+value that the middle-end intended.\n+\n @end defmac\n \n @hook TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS"}, {"sha": "9aa791e4b2122cf480fcda25d0f00ae006151aa2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a271b387e6375d5612a2bd8669e0da1ac731e9c3", "patch": "@@ -1,3 +1,8 @@\n+2015-10-27  Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl-opt/67609\n+\t* gcc.target/i386/pr67609-2.c: New test.\n+\n 2015-10-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/68102"}, {"sha": "fece43771226594286531130690c381ecd2ec945", "filename": "gcc/testsuite/gcc.target/i386/pr67609-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67609-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a271b387e6375d5612a2bd8669e0da1ac731e9c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67609-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67609-2.c?ref=a271b387e6375d5612a2bd8669e0da1ac731e9c3", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -msse2\" } */\n+/* { dg-require-effective-target sse2 } */\n+\n+#include <stdlib.h>\n+#include <emmintrin.h>\n+\n+__m128d reg = { 2.0, 4.0 };\n+\n+void\n+__attribute__((noinline))\n+set_lower (double b)\n+{\n+  double v[2];\n+  _mm_store_pd(v, reg);\n+  v[0] = b;\n+  reg = _mm_load_pd(v);\n+}\n+\n+int\n+main ()\n+{\n+  set_lower (6.0);\n+\n+  if (reg[1] != 4.0)\n+    abort ();\n+\n+  return 0;\n+}"}]}