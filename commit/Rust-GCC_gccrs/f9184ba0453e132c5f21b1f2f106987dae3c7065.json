{"sha": "f9184ba0453e132c5f21b1f2f106987dae3c7065", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkxODRiYTA0NTNlMTMyYzVmMjFiMWYyZjEwNjk4N2RhZTNjNzA2NQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2015-12-08T11:17:18Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2015-12-08T11:17:18Z"}, "message": "[testsuite][ARM target attributes] Fix effective_target tests.\n\n2015-12-08  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\t* lib/target-supports.exp\n\t(check_effective_target_arm_vfp_ok_nocache): New.\n\t(check_effective_target_arm_vfp_ok): Call the new\n\tcheck_effective_target_arm_vfp_ok_nocache function.\n\t(check_effective_target_arm_fp_ok_nocache): New.\n\t(check_effective_target_arm_fp_ok): New.\n\t(add_options_for_arm_fp): New.\n\t(check_effective_target_arm_crypto_ok_nocache): Require\n\ttarget_arm_v8_neon_ok instead of arm32.\n\t(check_effective_target_arm_crypto_pragma_ok_nocache): New.\n\t(check_effective_target_arm_crypto_pragma_ok): New.\n\t(add_options_for_arm_vfp): New.\n\t* gcc.target/arm/attr-crypto.c: Use arm_crypto_pragma_ok effective\n\ttarget. Do not force -mfloat-abi=softfp, use arm_vfp effective\n\ttarget instead.\n\t* gcc.target/arm/attr-neon-builtin-fail.c: Do not force\n\t-mfloat-abi=softfp, use arm_fp effective target instead.\n\t* gcc.target/arm/attr-neon-fp16.c: Likewise. Remove arm_neon_ok\n\tdependency.\n\t* gcc.target/arm/attr-neon2.c: Do not force -mfloat-abi=softfp,\n\tuse arm_vfp effective target instead.\n\t* gcc.target/arm/attr-neon3.c: Likewise.\n\nFrom-SVN: r231403", "tree": {"sha": "5b4f44ef46ba9dfc6eee92cdcfec143a72b1e183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b4f44ef46ba9dfc6eee92cdcfec143a72b1e183"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9184ba0453e132c5f21b1f2f106987dae3c7065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9184ba0453e132c5f21b1f2f106987dae3c7065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9184ba0453e132c5f21b1f2f106987dae3c7065", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9184ba0453e132c5f21b1f2f106987dae3c7065/comments", "author": null, "committer": null, "parents": [{"sha": "409c286f84dbb7c50ee411df67339cc63796369c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/409c286f84dbb7c50ee411df67339cc63796369c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/409c286f84dbb7c50ee411df67339cc63796369c"}], "stats": {"total": 181, "additions": 161, "deletions": 20}, "files": [{"sha": "e7aa6ea2cdc16779a1eb93f4473b8bbbb655cfbb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f9184ba0453e132c5f21b1f2f106987dae3c7065", "patch": "@@ -1,3 +1,28 @@\n+2015-12-08  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_arm_vfp_ok_nocache): New.\n+\t(check_effective_target_arm_vfp_ok): Call the new\n+\tcheck_effective_target_arm_vfp_ok_nocache function.\n+\t(check_effective_target_arm_fp_ok_nocache): New.\n+\t(check_effective_target_arm_fp_ok): New.\n+\t(add_options_for_arm_fp): New.\n+\t(check_effective_target_arm_crypto_ok_nocache): Require\n+\ttarget_arm_v8_neon_ok instead of arm32.\n+\t(check_effective_target_arm_crypto_pragma_ok_nocache): New.\n+\t(check_effective_target_arm_crypto_pragma_ok): New.\n+\t(add_options_for_arm_vfp): New.\n+\t* gcc.target/arm/attr-crypto.c: Use arm_crypto_pragma_ok effective\n+\ttarget. Do not force -mfloat-abi=softfp, use arm_vfp effective\n+\ttarget instead.\n+\t* gcc.target/arm/attr-neon-builtin-fail.c: Do not force\n+\t-mfloat-abi=softfp, use arm_fp effective target instead.\n+\t* gcc.target/arm/attr-neon-fp16.c: Likewise. Remove arm_neon_ok\n+\tdependency.\n+\t* gcc.target/arm/attr-neon2.c: Do not force -mfloat-abi=softfp,\n+\tuse arm_vfp effective target instead.\n+\t* gcc.target/arm/attr-neon3.c: Likewise.\n+\n 2015-12-08  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* gfortran.dg/pr68627.f: Limit target to x86."}, {"sha": "b703fbcfdc1d788c9a346c45a92a6c0397b2eedb", "filename": "gcc/testsuite/gcc.target/arm/attr-crypto.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-crypto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-crypto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-crypto.c?ref=f9184ba0453e132c5f21b1f2f106987dae3c7065", "patch": "@@ -1,6 +1,10 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target arm_crypto_ok } */\n-/* { dg-options \"-O2 -mfloat-abi=softfp\" } */\n+/* Make sure we can force fpu=vfp before switching using the\n+   pragma.  */\n+/* { dg-require-effective-target arm_vfp_ok } */\n+/* { dg-require-effective-target arm_crypto_pragma_ok } */\n+/* { dg-options \"-O2 -march=armv8-a\" } */\n+/* { dg-add-options arm_vfp } */\n \n #pragma GCC target (\"fpu=crypto-neon-fp-armv8\")\n "}, {"sha": "05dc579f25d0169b918ee775d8df36fae4f9de47", "filename": "gcc/testsuite/gcc.target/arm/attr-neon-builtin-fail.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-builtin-fail.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-builtin-fail.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-builtin-fail.c?ref=f9184ba0453e132c5f21b1f2f106987dae3c7065", "patch": "@@ -1,7 +1,9 @@\n /* Check that calling a neon builtin from a function compiled with vfp fails.  */\n /* { dg-do compile } */\n+/* { dg-require-effective-target arm_fp_ok } */\n /* { dg-require-effective-target arm_neon_ok } */\n-/* { dg-options \"-O2 -mfloat-abi=softfp\" } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-add-options arm_fp } */\n \n #include <arm_neon.h>\n \n@@ -12,6 +14,5 @@ foo (uint8x16_t *p)\n   *p = vmovq_n_u8 (3); /* { dg-message \"called from here\" } */\n }\n \n-/* { dg-error \"inlining failed in call to always_inline\" \"\" { target *-*-* } 0 }\n- */\n+/* { dg-error \"inlining failed in call to always_inline\" \"\" { target *-*-* } 0 } */\n "}, {"sha": "984992f2ab06969969f5e7699d7af7fed356705a", "filename": "gcc/testsuite/gcc.target/arm/attr-neon-fp16.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-fp16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-fp16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-fp16.c?ref=f9184ba0453e132c5f21b1f2f106987dae3c7065", "patch": "@@ -1,6 +1,7 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target arm_neon_ok } */\n-/* { dg-options \"-mfp16-format=ieee -mfloat-abi=softfp\" } */\n+/* { dg-require-effective-target arm_fp_ok } */\n+/* { dg-options \"-mfp16-format=ieee\" } */\n+/* { dg-add-options arm_fp } */\n \n #include \"arm_neon.h\"\n "}, {"sha": "79133e5237afaaf598fbbf6aa05b3ae6f981e83a", "filename": "gcc/testsuite/gcc.target/arm/attr-neon2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c?ref=f9184ba0453e132c5f21b1f2f106987dae3c7065", "patch": "@@ -1,6 +1,8 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target arm_neon_ok } */\n-/* { dg-options \"-O2 -mfloat-abi=softfp -mfpu=vfp\" } */\n+/* { dg-require-effective-target arm_vfp_ok } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-add-options arm_vfp } */\n \n #pragma GCC target (\"fpu=neon\")\n #include <arm_neon.h>"}, {"sha": "0d31fb525594770cf76aca5c5ee9846c8d5c572a", "filename": "gcc/testsuite/gcc.target/arm/attr-neon3.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon3.c?ref=f9184ba0453e132c5f21b1f2f106987dae3c7065", "patch": "@@ -1,6 +1,8 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target arm_crypto_ok } */\n-/* { dg-options \"-O2 -mfloat-abi=softfp -mfpu=vfp\" } */\n+/* { dg-require-effective-target arm_vfp_ok } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-add-options arm_vfp } */\n \n #include <arm_neon.h>\n "}, {"sha": "4f2a5bb1675e7fd5290f74c666463ac616dfdf1e", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 117, "deletions": 11, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9184ba0453e132c5f21b1f2f106987dae3c7065/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=f9184ba0453e132c5f21b1f2f106987dae3c7065", "patch": "@@ -2664,17 +2664,34 @@ proc check_effective_target_arm_vect_no_misalign { } {\n \n \n # Return 1 if this is an ARM target supporting -mfpu=vfp\n-# -mfloat-abi=softfp.  Some multilibs may be incompatible with these\n-# options.\n+# -mfloat-abi=softfp or equivalent options.  Some multilibs may be\n+# incompatible with these options.  Also set et_arm_vfp_flags to the\n+# best options to add.\n \n-proc check_effective_target_arm_vfp_ok { } {\n+proc check_effective_target_arm_vfp_ok_nocache { } {\n+    global et_arm_vfp_flags\n+    set et_arm_vfp_flags \"\"\n     if { [check_effective_target_arm32] } {\n-\treturn [check_no_compiler_messages arm_vfp_ok object {\n-\t    int dummy;\n-\t} \"-mfpu=vfp -mfloat-abi=softfp\"]\n-    } else {\n-\treturn 0\n+\tforeach flags {\"-mfpu=vfp\" \"-mfpu=vfp -mfloat-abi=softfp\" \"-mfpu=vfp -mfloat-abi=hard\"} {\n+\t    if { [check_no_compiler_messages_nocache arm_vfp_ok object {\n+\t\t#ifndef __ARM_FP\n+\t\t#error __ARM_FP not defined\n+\t\t#endif\n+\t\t#ifdef __ARM_NEON_FP\n+\t\t#error __ARM_NEON_FP defined\n+\t\t#endif\n+\t    } \"$flags\" ] } {\n+\t\tset et_arm_vfp_flags $flags\n+\t\treturn 1\n+\t    }\n+\t}\n     }\n+    return 0\n+}\n+\n+proc check_effective_target_arm_vfp_ok { } {\n+    return [check_cached_effective_target arm_vfp_ok \\\n+\t\tcheck_effective_target_arm_vfp_ok_nocache]\n }\n \n # Return 1 if this is an ARM target supporting -mfpu=vfp3\n@@ -2721,6 +2738,47 @@ proc check_effective_target_arm_hard_vfp_ok { } {\n     }\n }\n \n+# Return 1 if this is an ARM target defining __ARM_FP. We may need\n+# -mfloat-abi=softfp or equivalent options.  Some multilibs may be\n+# incompatible with these options.  Also set et_arm_fp_flags to the\n+# best options to add.\n+\n+proc check_effective_target_arm_fp_ok_nocache { } {\n+    global et_arm_fp_flags\n+    set et_arm_fp_flags \"\"\n+    if { [check_effective_target_arm32] } {\n+\tforeach flags {\"\" \"-mfloat-abi=softfp\" \"-mfloat-abi=hard\"} {\n+\t    if { [check_no_compiler_messages_nocache arm_fp_ok object {\n+\t\t#ifndef __ARM_FP\n+\t\t#error __ARM_FP not defined\n+\t\t#endif\n+\t    } \"$flags\"] } {\n+\t\tset et_arm_fp_flags $flags\n+\t\treturn 1\n+\t    }\n+\t}\n+    }\n+\n+    return 0\n+}\n+\n+proc check_effective_target_arm_fp_ok { } {\n+    return [check_cached_effective_target arm_fp_ok \\\n+\t\tcheck_effective_target_arm_fp_ok_nocache]\n+}\n+\n+# Add the options needed to define __ARM_FP.  We need either\n+# -mfloat-abi=softfp or -mfloat-abi=hard, but if one is already\n+# specified by the multilib, use it.\n+\n+proc add_options_for_arm_fp { flags } {\n+    if { ! [check_effective_target_arm_fp_ok] } {\n+\treturn \"$flags\"\n+    }\n+    global et_arm_fp_flags\n+    return \"$flags $et_arm_fp_flags\"\n+}\n+\n # Return 1 if this is an ARM target that supports DSP multiply with\n # current multilib flags.\n \n@@ -2753,7 +2811,7 @@ proc check_effective_target_arm_unaligned { } {\n proc check_effective_target_arm_crypto_ok_nocache { } {\n     global et_arm_crypto_flags\n     set et_arm_crypto_flags \"\"\n-    if { [check_effective_target_arm32] } {\n+    if { [check_effective_target_arm_v8_neon_ok] } {\n \tforeach flags {\"\" \"-mfloat-abi=softfp\" \"-mfpu=crypto-neon-fp-armv8\" \"-mfpu=crypto-neon-fp-armv8 -mfloat-abi=softfp\"} {\n \t    if { [check_no_compiler_messages_nocache arm_crypto_ok object {\n \t\t#include \"arm_neon.h\"\n@@ -2779,6 +2837,54 @@ proc check_effective_target_arm_crypto_ok { } {\n \t\tcheck_effective_target_arm_crypto_ok_nocache]\n }\n \n+# Return 1 if this is an ARM target supporting pragma target\n+# -mfpu=crypto-neon-fp-armv8 -mfloat-abi=softfp or equivalent options.\n+# Some multilibs may be incompatible with these options.  Also set\n+# et_arm_crypto_pragma_flags to the best options to add.\n+\n+proc check_effective_target_arm_crypto_pragma_ok_nocache { } {\n+    global et_arm_crypto_pragma_flags\n+    set et_arm_crypto_pragma_flags \"\"\n+    if { [check_effective_target_arm_v8_neon_ok] } {\n+\tforeach flags {\"\" \"-mfloat-abi=softfp\" \"-mfpu=crypto-neon-fp-armv8\" \"-mfpu=crypto-neon-fp-armv8 -mfloat-abi=softfp\"} {\n+\t    if { [check_no_compiler_messages_nocache arm_crypto_pragmaok object {\n+\t\t#pragma GCC target (\"fpu=crypto-neon-fp-armv8\")\n+\t\t#include \"arm_neon.h\"\n+\t\tuint8x16_t\n+\t\tfoo (uint8x16_t a, uint8x16_t b)\n+\t\t{\n+\t          return vaeseq_u8 (a, b);\n+\t\t}\n+\t    } \"[add_options_for_arm_v8_neon \"\"] $flags\"] } {\n+\t\tset et_arm_crypto_pragma_flags \"[add_options_for_arm_v8_neon \"\"] $flags\"\n+\t\treturn 1\n+\t    }\n+\t}\n+    }\n+\n+    return 0\n+}\n+\n+# Return 1 if this is an ARM target supporting pragma target\n+# -mfpu=crypto-neon-fp-armv8.\n+\n+proc check_effective_target_arm_crypto_pragma_ok { } {\n+    return [check_cached_effective_target arm_crypto_pragma_ok \\\n+\t\tcheck_effective_target_arm_crypto_pragma_ok_nocache]\n+}\n+\n+# Add the options needed for VFP.  We need either -mfloat-abi=softfp\n+# or -mfloat-abi=hard, but if one is already specified by the\n+# multilib, use it.\n+\n+proc add_options_for_arm_vfp { flags } {\n+    if { ! [check_effective_target_arm_vfp_ok] } {\n+\treturn \"$flags\"\n+    }\n+    global et_arm_vfp_flags\n+    return \"$flags $et_arm_vfp_flags\"\n+}\n+\n # Add options for crypto extensions.\n proc add_options_for_arm_crypto { flags } {\n     if { ! [check_effective_target_arm_crypto_ok] } {\n@@ -2907,8 +3013,8 @@ proc check_effective_target_arm_crc_ok { } {\n \n # Return 1 if this is an ARM target supporting -mfpu=neon-fp16\n # -mfloat-abi=softfp or equivalent options.  Some multilibs may be\n-# incompatible with these options.  Also set et_arm_neon_flags to the\n-# best options to add.\n+# incompatible with these options.  Also set et_arm_neon_fp16_flags to\n+# the best options to add.\n \n proc check_effective_target_arm_neon_fp16_ok_nocache { } {\n     global et_arm_neon_fp16_flags"}]}