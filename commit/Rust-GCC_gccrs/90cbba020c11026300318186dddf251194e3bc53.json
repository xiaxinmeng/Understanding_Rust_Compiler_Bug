{"sha": "90cbba020c11026300318186dddf251194e3bc53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjYmJhMDIwYzExMDI2MzAwMzE4MTg2ZGRkZjI1MTE5NGUzYmM1Mw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2008-09-10T13:28:34Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2008-09-10T13:28:34Z"}, "message": "bfin.c (workaround_speculation): Correct algorithm to not lose track of the number of NOPs needed.\n\n\t* config/bfin/bfin.c (workaround_speculation): Correct algorithm to\n\tnot lose track of the number of NOPs needed.  Number of NOPs needed\n\tfor sync vs. loads workaround was switched; corrected.  Run second\n\tpass for all workarounds.  No NOPs needed after call insns.  Change\n\tsecond pass to use find_next_insn_start and find_load helpers in order\n\tto properly detect parallel insns.\n\t* config/bfin/bfin.md (cbranch_with_nops): Increase length.\n\nFrom-SVN: r140230", "tree": {"sha": "a5adf4180e38242aff75f589555de75322e1c292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5adf4180e38242aff75f589555de75322e1c292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90cbba020c11026300318186dddf251194e3bc53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90cbba020c11026300318186dddf251194e3bc53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90cbba020c11026300318186dddf251194e3bc53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90cbba020c11026300318186dddf251194e3bc53/comments", "author": null, "committer": null, "parents": [{"sha": "06c7153ff1c52ab47808fc00b72b98894ec858b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c7153ff1c52ab47808fc00b72b98894ec858b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c7153ff1c52ab47808fc00b72b98894ec858b8"}], "stats": {"total": 90, "additions": 60, "deletions": 30}, "files": [{"sha": "4d68e2248de3f3e08f2f57cc2f21b4b6a64ea563", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbba020c11026300318186dddf251194e3bc53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbba020c11026300318186dddf251194e3bc53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90cbba020c11026300318186dddf251194e3bc53", "patch": "@@ -1,3 +1,13 @@\n+2008-09-10  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.c (workaround_speculation): Correct algorithm to\n+\tnot lose track of the number of NOPs needed.  Number of NOPs needed\n+\tfor sync vs. loads workaround was switched; corrected.  Run second\n+\tpass for all workarounds.  No NOPs needed after call insns.  Change\n+\tsecond pass to use find_next_insn_start and find_load helpers in order\n+\tto properly detect parallel insns.\n+\t* config/bfin/bfin.md (cbranch_with_nops): Increase length.\n+\n 2008-09-10  Jan Hubicka  <jh@suse.cz>\n \n \t* value-prof.c (gimple_ic): Fix tuplification bug."}, {"sha": "9af7fab73fe83de9d5b4d1027bac567167369c3a", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbba020c11026300318186dddf251194e3bc53/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbba020c11026300318186dddf251194e3bc53/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=90cbba020c11026300318186dddf251194e3bc53", "patch": "@@ -4799,6 +4799,7 @@ workaround_speculation (void)\n   rtx insn, next;\n   rtx last_condjump = NULL_RTX;\n   int cycles_since_jump = INT_MAX;\n+  int delay_added = 0;\n \n   if (! ENABLE_WA_SPECULATIVE_LOADS && ! ENABLE_WA_SPECULATIVE_SYNCS)\n     return;\n@@ -4808,6 +4809,7 @@ workaround_speculation (void)\n   for (insn = get_insns (); insn; insn = next)\n     {\n       rtx pat;\n+      int delay_needed = 0;\n \n       next = find_next_insn_start (insn);\n       \n@@ -4826,6 +4828,7 @@ workaround_speculation (void)\n \t      && ! cbranch_predicted_taken_p (insn))\n \t    {\n \t      last_condjump = insn;\n+\t      delay_added = 0;\n \t      cycles_since_jump = 0;\n \t    }\n \t  else\n@@ -4835,49 +4838,56 @@ workaround_speculation (void)\n \t{\n \t  rtx load_insn = find_load (insn);\n \t  enum attr_type type = type_for_anomaly (insn);\n-\t  int delay_needed = 0;\n+\n \t  if (cycles_since_jump < INT_MAX)\n \t    cycles_since_jump++;\n \n \t  if (load_insn && ENABLE_WA_SPECULATIVE_LOADS)\n \t    {\n \t      if (trapping_loads_p (load_insn))\n-\t\tdelay_needed = 3;\n+\t\tdelay_needed = 4;\n \t    }\n \t  else if (type == TYPE_SYNC && ENABLE_WA_SPECULATIVE_SYNCS)\n-\t    delay_needed = 4;\n+\t    delay_needed = 3;\n+\t}\n \n-\t  if (delay_needed > cycles_since_jump)\n-\t    {\n-\t      rtx pat;\n-\t      int num_clobbers;\n-\t      rtx *op = recog_data.operand;\n+      if (delay_needed > cycles_since_jump\n+\t  && (delay_needed - cycles_since_jump) > delay_added)\n+\t{\n+\t  rtx pat1;\n+\t  int num_clobbers;\n+\t  rtx *op = recog_data.operand;\n \n-\t      delay_needed -= cycles_since_jump;\n+\t  delay_needed -= cycles_since_jump;\n \n-\t      extract_insn (last_condjump);\n-\t      if (optimize_size)\n-\t\t{\n-\t\t  pat = gen_cbranch_predicted_taken (op[0], op[1], op[2],\n-\t\t\t\t\t\t     op[3]);\n-\t\t  cycles_since_jump = INT_MAX;\n-\t\t}\n-\t      else\n-\t\t/* Do not adjust cycles_since_jump in this case, so that\n-\t\t   we'll increase the number of NOPs for a subsequent insn\n-\t\t   if necessary.  */\n-\t\tpat = gen_cbranch_with_nops (op[0], op[1], op[2], op[3],\n-\t\t\t\t\t     GEN_INT (delay_needed));\n-\t      PATTERN (last_condjump) = pat;\n-\t      INSN_CODE (last_condjump) = recog (pat, insn, &num_clobbers);\n+\t  extract_insn (last_condjump);\n+\t  if (optimize_size)\n+\t    {\n+\t      pat1 = gen_cbranch_predicted_taken (op[0], op[1], op[2],\n+\t\t\t\t\t\t op[3]);\n+\t      cycles_since_jump = INT_MAX;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Do not adjust cycles_since_jump in this case, so that\n+\t\t we'll increase the number of NOPs for a subsequent insn\n+\t\t if necessary.  */\n+\t      pat1 = gen_cbranch_with_nops (op[0], op[1], op[2], op[3],\n+\t\t\t\t\t    GEN_INT (delay_needed));\n+\t      delay_added = delay_needed;\n \t    }\n+\t  PATTERN (last_condjump) = pat1;\n+\t  INSN_CODE (last_condjump) = recog (pat1, insn, &num_clobbers);\n+\t}\n+      if (CALL_P (insn))\n+\t{\n+\t  cycles_since_jump = INT_MAX;\n+\t  delay_added = 0;\n \t}\n     }\n+\n   /* Second pass: for predicted-true branches, see if anything at the\n      branch destination needs extra nops.  */\n-  if (! ENABLE_WA_SPECULATIVE_SYNCS)\n-    return;\n-\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       int cycles_since_jump;\n@@ -4888,11 +4898,15 @@ workaround_speculation (void)\n \t{\n \t  rtx target = JUMP_LABEL (insn);\n \t  rtx label = target;\n+\t  rtx next_tgt;\n+\n \t  cycles_since_jump = 0;\n-\t  for (; target && cycles_since_jump < 3; target = NEXT_INSN (target))\n+\t  for (; target && cycles_since_jump < 3; target = next_tgt)\n \t    {\n \t      rtx pat;\n \n+\t      next_tgt = find_next_insn_start (target);\n+\n \t      if (NOTE_P (target) || BARRIER_P (target) || LABEL_P (target))\n \t\tcontinue;\n \n@@ -4904,12 +4918,18 @@ workaround_speculation (void)\n \n \t      if (INSN_P (target))\n \t\t{\n+\t\t  rtx load_insn = find_load (target);\n \t\t  enum attr_type type = type_for_anomaly (target);\n \t\t  int delay_needed = 0;\n \t\t  if (cycles_since_jump < INT_MAX)\n \t\t    cycles_since_jump++;\n \n-\t\t  if (type == TYPE_SYNC && ENABLE_WA_SPECULATIVE_SYNCS)\n+\t\t  if (load_insn && ENABLE_WA_SPECULATIVE_LOADS)\n+\t\t    {\n+\t\t      if (trapping_loads_p (load_insn))\n+\t\t\tdelay_needed = 2;\n+\t\t    }\n+\t\t  else if (type == TYPE_SYNC && ENABLE_WA_SPECULATIVE_SYNCS)\n \t\t    delay_needed = 2;\n \n \t\t  if (delay_needed > cycles_since_jump)"}, {"sha": "bd2d208a334170632870152eb813ace0ccd14855", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbba020c11026300318186dddf251194e3bc53/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbba020c11026300318186dddf251194e3bc53/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=90cbba020c11026300318186dddf251194e3bc53", "patch": "@@ -2588,7 +2588,7 @@\n   return \"\";\n }\n   [(set_attr \"type\" \"brcc\")\n-   (set_attr \"length\" \"6\")])\n+   (set_attr \"length\" \"8\")])\n \n ;; setcc insns.  */\n (define_expand \"seq\""}]}