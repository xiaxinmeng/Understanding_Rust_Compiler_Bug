{"sha": "a2027aad1b81c6b56d198a26b56e9f179a82cd6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwMjdhYWQxYjgxYzZiNTZkMTk4YTI2YjU2ZTlmMTc5YTgyY2Q2Yg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2012-09-22T23:02:06Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2012-09-22T23:02:06Z"}, "message": "predicates.md (altivec_register_operand, [...]): If op is a SUBREG, consider its SUBREG_REG instead.\n\ngcc/\n\t* config/rs6000/predicates.md (altivec_register_operand,\n\tvsx_register_operand, vfloat_operand, vint_operand,\n\tvlogical_operand, gpc_reg_operand, cc_reg_operand,\n\tcc_reg_not_cr0_operand, cc_reg_not_micro_cr0_operand):\n\tIf op is a SUBREG, consider its SUBREG_REG instead.\n\nFrom-SVN: r191645", "tree": {"sha": "f2a23ab1341f2eaac8258e8b64131bec579e1d5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2a23ab1341f2eaac8258e8b64131bec579e1d5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2027aad1b81c6b56d198a26b56e9f179a82cd6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2027aad1b81c6b56d198a26b56e9f179a82cd6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2027aad1b81c6b56d198a26b56e9f179a82cd6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2027aad1b81c6b56d198a26b56e9f179a82cd6b/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "699bae64e5f2db1e1d67259a7ab1d54765d6475e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/699bae64e5f2db1e1d67259a7ab1d54765d6475e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/699bae64e5f2db1e1d67259a7ab1d54765d6475e"}], "stats": {"total": 174, "additions": 132, "deletions": 42}, "files": [{"sha": "e650f9061c3e22e7dce441d2f50ebe1d00712786", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2027aad1b81c6b56d198a26b56e9f179a82cd6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2027aad1b81c6b56d198a26b56e9f179a82cd6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2027aad1b81c6b56d198a26b56e9f179a82cd6b", "patch": "@@ -1,3 +1,11 @@\n+2012-09-22  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/predicates.md (altivec_register_operand,\n+\tvsx_register_operand, vfloat_operand, vint_operand,\n+\tvlogical_operand, gpc_reg_operand, cc_reg_operand,\n+\tcc_reg_not_cr0_operand, cc_reg_not_micro_cr0_operand):\n+\tIf op is a SUBREG, consider its SUBREG_REG instead.\n+\n 2012-09-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* optabs.c (prepare_cmp_insn): Expand comparison of the result"}, {"sha": "12b75275a32b745d1bd3f814cd18228fd8d7e7e0", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 124, "deletions": 42, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2027aad1b81c6b56d198a26b56e9f179a82cd6b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2027aad1b81c6b56d198a26b56e9f179a82cd6b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=a2027aad1b81c6b56d198a26b56e9f179a82cd6b", "patch": "@@ -30,44 +30,89 @@\n   (and (match_code \"reg\")\n        (match_test \"REGNO (op) == CTR_REGNO\n \t\t    || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n-  \n+\n ;; Return 1 if op is an Altivec register.\n (define_predicate \"altivec_register_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"GET_CODE (op) != REG\n-\t\t     || ALTIVEC_REGNO_P (REGNO (op))\n-\t\t     || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER)\n+    return 1;\n+\n+  return ALTIVEC_REGNO_P (REGNO (op));\n+})\n \n ;; Return 1 if op is a VSX register.\n (define_predicate \"vsx_register_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"GET_CODE (op) != REG\n-\t\t     || VSX_REGNO_P (REGNO (op))\n-\t\t     || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER)\n+    return 1;\n+\n+  return VSX_REGNO_P (REGNO (op));\n+})\n \n ;; Return 1 if op is a vector register that operates on floating point vectors\n ;; (either altivec or VSX).\n (define_predicate \"vfloat_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"GET_CODE (op) != REG\n-\t\t     || VFLOAT_REGNO_P (REGNO (op))\n-\t\t     || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER)\n+    return 1;\n+\n+  return VFLOAT_REGNO_P (REGNO (op));\n+})\n \n ;; Return 1 if op is a vector register that operates on integer vectors\n ;; (only altivec, VSX doesn't support integer vectors)\n (define_predicate \"vint_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"GET_CODE (op) != REG\n-\t\t     || VINT_REGNO_P (REGNO (op))\n-\t\t     || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER)\n+    return 1;\n+\n+  return VINT_REGNO_P (REGNO (op));\n+})\n \n ;; Return 1 if op is a vector register to do logical operations on (and, or,\n ;; xor, etc.)\n (define_predicate \"vlogical_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"GET_CODE (op) != REG\n-\t\t     || VLOGICAL_REGNO_P (REGNO (op))\n-\t\t     || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER)\n+    return 1;\n+\n+  return VLOGICAL_REGNO_P (REGNO (op));\n+})\n \n ;; Return 1 if op is the carry register.\n (define_predicate \"ca_operand\"\n@@ -123,36 +168,73 @@\n \n ;; Return 1 if op is a register that is not special.\n (define_predicate \"gpc_reg_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"(GET_CODE (op) != REG\n-\t\t      || (REGNO (op) >= ARG_POINTER_REGNUM\n-\t\t\t  && !CA_REGNO_P (REGNO (op)))\n-\t\t      || INT_REGNO_P (REGNO (op))\n-\t\t      || FP_REGNO_P (REGNO (op)))\n-\t\t     && !((TARGET_E500_DOUBLE || TARGET_SPE)\n-\t\t\t  && invalid_e500_subreg (op, mode))\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if ((TARGET_E500_DOUBLE || TARGET_SPE) && invalid_e500_subreg (op, mode))\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) >= ARG_POINTER_REGNUM && !CA_REGNO_P (REGNO (op)))\n+    return 1;\n+\n+  return INT_REGNO_P (REGNO (op)) || FP_REGNO_P (REGNO (op));\n+})\n \n ;; Return 1 if op is a register that is a condition register field.\n (define_predicate \"cc_reg_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"GET_CODE (op) != REG\n-\t\t     || REGNO (op) > LAST_VIRTUAL_REGISTER\n-\t\t     || CR_REGNO_P (REGNO (op))\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER)\n+    return 1;\n+\n+  return CR_REGNO_P (REGNO (op));\n+})\n \n ;; Return 1 if op is a register that is a condition register field not cr0.\n (define_predicate \"cc_reg_not_cr0_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"GET_CODE (op) != REG\n-\t\t     || REGNO (op) > LAST_VIRTUAL_REGISTER\n-\t\t     || CR_REGNO_NOT_CR0_P (REGNO (op))\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER)\n+    return 1;\n+\n+  return CR_REGNO_NOT_CR0_P (REGNO (op));\n+})\n \n ;; Return 1 if op is a register that is a condition register field and if generating microcode, not cr0.\n (define_predicate \"cc_reg_not_micro_cr0_operand\"\n-   (and (match_operand 0 \"register_operand\")\n-\t(match_test \"GET_CODE (op) != REG\n-\t\t     || REGNO (op) > LAST_VIRTUAL_REGISTER\n-\t\t     || (rs6000_gen_cell_microcode && CR_REGNO_NOT_CR0_P (REGNO (op)))\n-\t\t     || (!rs6000_gen_cell_microcode && CR_REGNO_P (REGNO (op)))\")))\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER)\n+    return 1;\n+\n+  if (rs6000_gen_cell_microcode)\n+    return CR_REGNO_NOT_CR0_P (REGNO (op));\n+  else\n+    return CR_REGNO_P (REGNO (op));\n+})\n \n ;; Return 1 if op is a constant integer valid for D field\n ;; or non-special register register."}]}