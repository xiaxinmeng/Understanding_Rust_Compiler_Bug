{"sha": "5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5ZTVjNmZiNmMxNDBiZDgwYTI5ODZmMWQ1MzdhMjUwYTYyZWE1OQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-05-18T15:03:26Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-05-18T15:03:26Z"}, "message": "java-except.h (struct eh_range): Removed unused `next' member.\n\n\t* java-except.h (struct eh_range): Removed unused `next' member.\n\t* verify.c (verify_jvm_instructions): Call check_nested_ranges\n\tafter adding all exception handlers.  Sort exception ranges in\n\torder of start PC.\n\t(struct pc_index): New structure.\n\t(start_pc_cmp): New function.\n\t* except.c (add_handler): Return `void'.  Don't call link_handler;\n\tinstead construct an ordinary linked list and do range\n\tcoalescing.\n\t(check_nested_ranges): New function.\n\t(link_handler): Changed interface to allow merging of eh_ranges.\n\tSplit overlapping ranges.  Return `void'.\n\nFrom-SVN: r26995", "tree": {"sha": "009368cd560c748736b8a935a20c33d9fefb97c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/009368cd560c748736b8a935a20c33d9fefb97c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/comments", "author": null, "committer": null, "parents": [{"sha": "c64f913e0035db3d4a4137405b768d2f50c30eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64f913e0035db3d4a4137405b768d2f50c30eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c64f913e0035db3d4a4137405b768d2f50c30eea"}], "stats": {"total": 247, "additions": 191, "deletions": 56}, "files": [{"sha": "23eadc91d85092992a1f5683a7788b4b184e03f3", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "patch": "@@ -1,3 +1,18 @@\n+1999-05-14  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java-except.h (struct eh_range): Removed unused `next' member.\n+\t* verify.c (verify_jvm_instructions): Call check_nested_ranges\n+\tafter adding all exception handlers.  Sort exception ranges in\n+\torder of start PC.\n+\t(struct pc_index): New structure.\n+\t(start_pc_cmp): New function.\n+\t* except.c (add_handler): Return `void'.  Don't call link_handler;\n+\tinstead construct an ordinary linked list and do range\n+\tcoalescing.\n+\t(check_nested_ranges): New function.\n+\t(link_handler): Changed interface to allow merging of eh_ranges.\n+\tSplit overlapping ranges.  Return `void'.\n+\n Mon May 17 19:20:24 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (constructor_block_end:): New rule, tagged <node>."}, {"sha": "0e6eb398f8f023d49ce55fdcfa911fe93e525ee5", "filename": "gcc/java/except.c", "status": "modified", "additions": 125, "deletions": 33, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "patch": "@@ -108,51 +108,102 @@ find_handler (pc)\n   return find_handler_in_range (pc, h, cache_next_child);\n }\n \n-#if 0\n-first_child;\n-next_sibling;\n-outer;\n-#endif\n+/* Recursive helper routine for check_nested_ranges. */\n \n-/* Recursive helper routine for add_handler. */\n-\n-static int\n-link_handler (start_pc, end_pc, handler, type, outer)\n-     int start_pc, end_pc;\n-     tree handler;\n-     tree type;\n-     struct eh_range *outer;\n+static void\n+link_handler (range, outer)\n+     struct eh_range *range, *outer;\n {\n   struct eh_range **ptr;\n-  if (start_pc < outer->start_pc || end_pc > outer->end_pc)\n-    return 0;  /* invalid or non-nested exception range */\n-  if (start_pc == outer->start_pc && end_pc == outer->end_pc)\n+\n+  if (range->start_pc == outer->start_pc && range->end_pc == outer->end_pc)\n+    {\n+      outer->handlers = chainon (range->handlers, outer->handlers);\n+      return;\n+    }\n+\n+  /* If the new range completely encloses the `outer' range, then insert it\n+     between the outer range and its parent.  */\n+  if (range->start_pc <= outer->start_pc && range->end_pc >= outer->end_pc)\n+    {\n+      range->outer = outer->outer;\n+      range->next_sibling = NULL;\n+      range->first_child = outer;\n+      outer->outer->first_child = range;\n+      outer->outer = range;\n+      return;\n+    }\n+\n+  /* Handle overlapping ranges by splitting the new range.  */\n+  if (range->start_pc < outer->start_pc || range->end_pc > outer->end_pc)\n     {\n-      outer->handlers = tree_cons (type, handler, outer->handlers);\n-      return 1;\n+      struct eh_range *h\n+\t= (struct eh_range *) oballoc (sizeof (struct eh_range));\n+      if (range->start_pc < outer->start_pc)\n+\t{\n+\t  h->start_pc = range->start_pc;\n+\t  h->end_pc = outer->start_pc;\n+\t  range->start_pc = outer->start_pc;\n+\t}\n+      else\n+\t{\n+\t  h->start_pc = outer->end_pc;\n+\t  h->end_pc = range->end_pc;\n+\t  range->end_pc = outer->end_pc;\n+\t}\n+      h->first_child = NULL;\n+      h->outer = NULL;\n+      h->handlers = build_tree_list (TREE_PURPOSE (range->handlers),\n+\t\t\t\t     TREE_VALUE (range->handlers));\n+      h->next_sibling = NULL;\n+      /* Restart both from the top to avoid having to make this\n+\t function smart about reentrancy.  */\n+      link_handler (h, &whole_range);\n+      link_handler (range, &whole_range);\n+      return;\n     }\n+\n   ptr = &outer->first_child;\n   for (;; ptr = &(*ptr)->next_sibling)\n     {\n-      if (*ptr == NULL || end_pc <= (*ptr)->start_pc)\n+      if (*ptr == NULL || range->end_pc <= (*ptr)->start_pc)\n \t{\n-\t  struct eh_range *h = (struct eh_range *)\n-\t    oballoc (sizeof (struct eh_range));\n-\t  h->start_pc = start_pc;\n-\t  h->end_pc = end_pc;\n-\t  h->next_sibling = *ptr;\n-\t  h->first_child = NULL;\n-\t  h->outer = outer;\n-\t  h->handlers = build_tree_list (type, handler);\n-\t  *ptr = h;\n-\t  return 1;\n+\t  range->next_sibling = *ptr;\n+\t  range->first_child = NULL;\n+\t  range->outer = outer;\n+\t  *ptr = range;\n+\t  return;\n+\t}\n+      else if (range->start_pc < (*ptr)->end_pc)\n+\t{\n+\t  link_handler (range, *ptr);\n+\t  return;\n \t}\n-      else if (start_pc < (*ptr)->end_pc)\n-\treturn link_handler (start_pc, end_pc, handler, type, *ptr);\n       /* end_pc > (*ptr)->start_pc && start_pc >= (*ptr)->end_pc. */\n     }\n }\n \n+/* The first pass of exception range processing (calling add_handler)\n+   constructs a linked list of exception ranges.  We turn this into\n+   the data structure expected by the rest of the code, and also\n+   ensure that exception ranges are properly nested.  */\n+\n+void\n+handle_nested_ranges ()\n+{\n+  struct eh_range *ptr, *next;\n+\n+  ptr = whole_range.first_child;\n+  whole_range.first_child = NULL;\n+  for (; ptr; ptr = next)\n+    {\n+      next = ptr->next_sibling;\n+      ptr->next_sibling = NULL;\n+      link_handler (ptr, &whole_range);\n+    }\n+}\n+\n+\n /* Called to re-initialize the exception machinery for a new method. */\n \n void\n@@ -174,13 +225,54 @@ java_set_exception_lang_code ()\n   set_exception_version_code (1);\n }\n \n-int\n+/* Add an exception range.  If we already have an exception range\n+   which has the same handler and label, and the new range overlaps\n+   that one, then we simply extend the existing range.  Some bytecode\n+   obfuscators generate seemingly nonoverlapping exception ranges\n+   which, when coalesced, do in fact nest correctly.\n+   \n+   This constructs an ordinary linked list which check_nested_ranges()\n+   later turns into the data structure we actually want.\n+   \n+   We expect the input to come in order of increasing START_PC.  This\n+   function doesn't attempt to detect the case where two previously\n+   added disjoint ranges could be coalesced by a new range; that is\n+   what the sorting counteracts.  */\n+\n+void\n add_handler (start_pc, end_pc, handler, type)\n      int start_pc, end_pc;\n      tree handler;\n      tree type;\n {\n-  return link_handler (start_pc, end_pc, handler, type, &whole_range);\n+  struct eh_range *ptr, *prev = NULL, *h;\n+\n+  for (ptr = whole_range.first_child; ptr; ptr = ptr->next_sibling)\n+    {\n+      if (start_pc >= ptr->start_pc\n+\t  && start_pc <= ptr->end_pc\n+\t  && TREE_PURPOSE (ptr->handlers) == type\n+\t  && TREE_VALUE (ptr->handlers) == handler)\n+\t{\n+\t  /* Already found an overlapping range, so coalesce.  */\n+\t  ptr->end_pc = MAX (ptr->end_pc, end_pc);\n+\t  return;\n+\t}\n+      prev = ptr;\n+    }\n+\n+  h = (struct eh_range *) oballoc (sizeof (struct eh_range));\n+  h->start_pc = start_pc;\n+  h->end_pc = end_pc;\n+  h->first_child = NULL;\n+  h->outer = NULL;\n+  h->handlers = build_tree_list (type, handler);\n+  h->next_sibling = NULL;\n+\n+  if (prev == NULL)\n+    whole_range.first_child = h;\n+  else\n+    prev->next_sibling = h;\n }\n \n "}, {"sha": "07b3feb30463e2e39742cb6ec90b81998d902f3a", "filename": "gcc/java/java-except.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/gcc%2Fjava%2Fjava-except.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/gcc%2Fjava%2Fjava-except.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-except.h?ref=5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "patch": "@@ -47,11 +47,6 @@ struct eh_range\n \n     /* The next child of outer, in address order. */\n     struct eh_range *next_sibling;\n-\n-#if 0\n-    /* Next handler, sorted by ascending start_pc then descending end_pc. */\n-    tree next;\n-#endif\n   };\n \n /* A dummy range that represents the entire method. */\n@@ -69,6 +64,8 @@ extern void maybe_start_try PROTO ((int));\n \n extern void maybe_end_try PROTO ((int));\n \n-extern int add_handler PROTO ((int, int, tree, tree));\n+extern void add_handler PROTO ((int, int, tree, tree));\n+\n+extern void handle_nested_ranges PROTO ((void));\n \n extern void expand_resume_after_catch PROTO ((void));"}, {"sha": "ef0f85e12e52518a31a8845f472c3bbcd72b030f", "filename": "gcc/java/verify.c", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9e5c6fb6c140bd80a2986f1d537a250a62ea59/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=5a9e5c6fb6c140bd80a2986f1d537a250a62ea59", "patch": "@@ -300,6 +300,24 @@ type_stack_dup (size, offset)\n     }\n }\n \n+/* This keeps track of a start PC and corresponding initial index.  */\n+struct pc_index\n+{\n+  int start_pc;\n+  int index;\n+};\n+\n+/* A helper that is used when sorting exception ranges.  */\n+static int\n+start_pc_cmp (xp, yp)\n+     const GENERIC_PTR xp;\n+     const GENERIC_PTR yp;\n+{\n+  struct pc_index *x = (struct pc_index *) xp;\n+  struct pc_index *y = (struct pc_index *) yp;\n+  return x->start_pc - y->start_pc;\n+}\n+\n /* This causes the next iteration to ignore the next instruction\n    and look for some other unhandled instruction. */\n #define INVALIDATE_PC (prevpc = -1, oldpc = PC, PC = INVALID_PC)\n@@ -341,6 +359,8 @@ verify_jvm_instructions (jcf, byte_ops, length)\n   struct eh_range *prev_eh_ranges = NULL_EH_RANGE;\n   struct eh_range *eh_ranges;\n   tree return_type = TREE_TYPE (TREE_TYPE (current_function_decl));\n+  struct pc_index *starts;\n+  int eh_count;\n \n   jint int_value = -1;\n \n@@ -349,17 +369,28 @@ verify_jvm_instructions (jcf, byte_ops, length)\n   /* Handle the exception table. */\n   method_init_exceptions ();\n   JCF_SEEK (jcf, DECL_CODE_OFFSET (current_function_decl) + length);\n-  i = JCF_readu2 (jcf);\n+  eh_count = JCF_readu2 (jcf);\n \n-  /* We read the exception backwards. */\n-  p = jcf->read_ptr + 8 * i;\n-  while (--i >= 0)\n+  /* We read the exception handlers in order of increasing start PC.\n+     To do this we first read and sort the start PCs.  */\n+  starts = (struct pc_index *) xmalloc (eh_count * sizeof (struct pc_index));\n+  for (i = 0; i < eh_count; ++i)\n     {\n-      int start_pc = GET_u2 (p-8);\n-      int end_pc = GET_u2 (p-6);\n-      int handler_pc = GET_u2 (p-4);\n-      int catch_type = GET_u2 (p-2);\n-      p -= 8;\n+      starts[i].start_pc = GET_u2 (jcf->read_ptr + 8 * i);\n+      starts[i].index = i;\n+    }\n+  qsort (starts, eh_count, sizeof (struct pc_index), start_pc_cmp);\n+\n+  for (i = 0; i < eh_count; ++i)\n+    {\n+      int start_pc, end_pc, handler_pc, catch_type;\n+\n+      p = jcf->read_ptr + 8 * starts[i].index;\n+\n+      start_pc = GET_u2 (p);\n+      end_pc = GET_u2 (p+2);\n+      handler_pc = GET_u2 (p+4);\n+      catch_type = GET_u2 (p+6);\n \n       if (start_pc < 0 || start_pc >= length\n \t  || end_pc < 0 || end_pc > length || start_pc >= end_pc\n@@ -370,21 +401,21 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  || ! (instruction_bits [handler_pc] & BCODE_INSTRUCTION_START))\n \t{\n \t  error (\"bad pc in exception_table\");\n+\t  free (starts);\n \t  return 0;\n \t}\n \n-      if (! add_handler (start_pc, end_pc,\n-\t\t\t lookup_label (handler_pc),\n-\t\t\t catch_type == 0 ? NULL_TREE\n-\t\t\t : get_class_constant (jcf, catch_type)))\n-\t{\n-\t  error (\"overlapping exception ranges are not supported\");\n-\t  return 0;\n-\t}\n+      add_handler (start_pc, end_pc,\n+\t\t   lookup_label (handler_pc),\n+\t\t   catch_type == 0 ? NULL_TREE\n+\t\t   : get_class_constant (jcf, catch_type));\n \n       instruction_bits [handler_pc] |= BCODE_EXCEPTION_TARGET;\n     }\n \n+  free (starts);\n+  handle_nested_ranges ();\n+\n   for (PC = 0;;)\n     {\n       int index;"}]}