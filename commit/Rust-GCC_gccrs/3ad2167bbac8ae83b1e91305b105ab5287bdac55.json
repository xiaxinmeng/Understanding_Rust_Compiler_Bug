{"sha": "3ad2167bbac8ae83b1e91305b105ab5287bdac55", "node_id": "C_kwDOANBUbNoAKDNhZDIxNjdiYmFjOGFlODNiMWU5MTMwNWIxMDVhYjUyODdiZGFjNTU", "commit": {"author": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-06-15T22:06:53Z"}, "committer": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-11-05T14:23:20Z"}, "message": "c++: libcpp: Support raw strings with newlines in directives [PR55971]\n\nIt's not currently possible to use a C++11 raw string containing a newline as\npart of the definition of a macro, or in any other preprocessing directive,\nsuch as:\n\n #define X R\"(two\nlines)\"\n\n #error R\"(this error has\ntwo lines)\"\n\nAdd support for that by relaxing the conditions under which\n_cpp_get_fresh_line() refuses to get a new line. For the case of lexing a raw\nstring, it's OK to do so as long as there is another line within the current\nbuffer. The code in cpp_get_fresh_line() was refactored into a new function\nget_fresh_line_impl(), so that the new logic is applied only when processing a\nraw string and not any other times.\n\nlibcpp/ChangeLog:\n\n\tPR preprocessor/55971\n\t* lex.cc (get_fresh_line_impl): New function refactoring the code\n\tfrom...\n\t(_cpp_get_fresh_line): ...here.\n\t(lex_raw_string): Use the new version of get_fresh_line_impl() to\n\tsupport raw strings containing new lines when processing a directive.\n\ngcc/testsuite/ChangeLog:\n\n\tPR preprocessor/55971\n\t* c-c++-common/raw-string-directive-1.c: New test.\n\t* c-c++-common/raw-string-directive-2.c: New test.\n\ngcc/c-family/ChangeLog:\n\n\tPR preprocessor/55971\n\t* c-ppoutput.cc (adjust_for_newlines): Update comment.", "tree": {"sha": "d6dbb86c53a6eded2fb209819e466b6ef1200ddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6dbb86c53a6eded2fb209819e466b6ef1200ddc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ad2167bbac8ae83b1e91305b105ab5287bdac55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad2167bbac8ae83b1e91305b105ab5287bdac55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad2167bbac8ae83b1e91305b105ab5287bdac55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad2167bbac8ae83b1e91305b105ab5287bdac55/comments", "author": null, "committer": null, "parents": [{"sha": "b83f01d0057578ebc1785f858fbfd46cdc210560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b83f01d0057578ebc1785f858fbfd46cdc210560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b83f01d0057578ebc1785f858fbfd46cdc210560"}], "stats": {"total": 158, "additions": 148, "deletions": 10}, "files": [{"sha": "6e054358e9e7deb9c640aac7011dd56a506f528b", "filename": "gcc/c-family/c-ppoutput.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad2167bbac8ae83b1e91305b105ab5287bdac55/gcc%2Fc-family%2Fc-ppoutput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad2167bbac8ae83b1e91305b105ab5287bdac55/gcc%2Fc-family%2Fc-ppoutput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ppoutput.cc?ref=3ad2167bbac8ae83b1e91305b105ab5287bdac55", "patch": "@@ -433,7 +433,15 @@ scan_translation_unit_directives_only (cpp_reader *pfile)\n     lang_hooks.preprocess_token (pfile, NULL, streamer.filter);\n }\n \n-/* Adjust print.src_line for newlines embedded in output.  */\n+/* Adjust print.src_line for newlines embedded in output.  For example, if a raw\n+   string literal contains newlines, then we need to increment our notion of the\n+   current line to keep in sync and avoid outputting a line marker\n+   unnecessarily.  If a raw string literal containing newlines is the result of\n+   macro expansion, then we have the opposite problem, where the token takes up\n+   more lines in the output than it did in the input, and hence a line marker is\n+   needed to restore the correct state for subsequent lines.  In this case,\n+   incrementing print.src_line still does the job, because it will cause us to\n+   emit the line marker the next time a token is streamed.  */\n static void\n account_for_newlines (const unsigned char *str, size_t len)\n {"}, {"sha": "d6525e107bc29822f0517f28557421dfdeff8bdb", "filename": "gcc/testsuite/c-c++-common/raw-string-directive-1.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad2167bbac8ae83b1e91305b105ab5287bdac55/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-directive-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad2167bbac8ae83b1e91305b105ab5287bdac55/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-directive-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-directive-1.c?ref=3ad2167bbac8ae83b1e91305b105ab5287bdac55", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" { target c } } */\n+/* { dg-options \"-std=c++11\" { target c++ } } */\n+\n+/* Test that multi-line raw strings are lexed OK for all preprocessing\n+   directives where one could appear. Test raw-string-directive-2.c\n+   checks that #define is also processed properly.  */\n+\n+/* Note that in cases where we cause GCC to produce a multi-line error\n+   message, we construct the string so that the second line looks enough\n+   like an error message for DejaGNU to process it as such, so that we\n+   can use dg-warning or dg-error directives to check for it.  */\n+\n+#warning R\"delim(line1 /* { dg-warning \"line1\" } */\n+file:15:1: warning: line2)delim\" /* { dg-warning \"line2\" } */\n+\n+#error R\"delim(line3 /* { dg-error \"line3\" } */\n+file:18:1: error: line4)delim\" /* { dg-error \"line4\" } */\n+\n+#define X1 R\"(line 5\n+line 6\n+line 7\n+line 8\n+/*\n+//\n+line 9)\" R\"delim(\n+line10)delim\"\n+\n+#define X2(a) X1 #a R\"(line 11\n+/*\n+line12\n+)\"\n+\n+#if R\"(line 13 /* { dg-error \"line13\" } */\n+file:35:1: error: line14)\" /* { dg-error \"line14\\\\)\\\"\\\" is not valid\" } */\n+#endif R\"(line 15 /* { dg-warning \"extra tokens at end of #endif\" } */\n+\\\n+line16)\" \"\"\n+\n+#ifdef XYZ R\"(line17 /* { dg-warning \"extra tokens at end of #ifdef\" } */\n+\\\n+\\\n+line18)\"\n+#endif\n+\n+#if 1\n+#else R\"(line23 /* { dg-warning \"extra tokens at end of #else\" } */\n+\\\n+\n+line24)\"\n+#endif\n+\n+#if 0\n+#elif R\"(line 25 /* { dg-error \"line25\" } */\n+file:55:1: error: line26)\" /* { dg-error \"line26\\\\)\\\"\\\" is not valid\" } */\n+#endif\n+\n+#line 60 R\"(file:60:1: warning: this file has a space\n+in it!)\"\n+#warning \"line27\" /* { dg-warning \"line27\" } */\n+/* { dg-warning \"this file has a space\" \"#line check\" { target *-*-* } 60 } */\n+#line 63 \"file\"\n+\n+#undef X1 R\"(line28 /* { dg-warning \"extra tokens at end of #undef\" } */\n+line29\n+\\\n+)\"\n+\n+#ident R\"(line30\n+line31)\" R\"(line 32 /* { dg-warning \"extra tokens at end of #ident\" } */\n+line 33)\"\n+\n+#pragma GCC diagnostic ignored R\"(-Woption /* { dg-warning \"-Wpragmas\" } */\n+-with-a-newline)\""}, {"sha": "6fc673ccd82be83c6fd34b879ff32ac59e0bbdc9", "filename": "gcc/testsuite/c-c++-common/raw-string-directive-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad2167bbac8ae83b1e91305b105ab5287bdac55/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-directive-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad2167bbac8ae83b1e91305b105ab5287bdac55/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-directive-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-directive-2.c?ref=3ad2167bbac8ae83b1e91305b105ab5287bdac55", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" { target c } } */\n+/* { dg-options \"-std=c++11\" { target c++ } } */\n+\n+#define S1 R\"(three\n+line\n+string)\"\n+\n+#define S2 R\"(pasted\n+two line)\" \" string\"\n+\n+#define X(a, b) a b R\"(\n+one more)\"\n+\n+const char *s1 = S1;\n+const char *s2 = S2;\n+const char *s3 = X(S1, R\"(\n+with this line plus)\");\n+\n+int main ()\n+{\n+  const char s1_correct[] = \"three\\nline\\nstring\";\n+  if (__builtin_memcmp (s1, s1_correct, sizeof s1_correct))\n+    __builtin_abort ();\n+\n+  const char s2_correct[] = \"pasted\\ntwo line string\";\n+  if (__builtin_memcmp (s2, s2_correct, sizeof s2_correct))\n+    __builtin_abort ();\n+\n+  const char s3_correct[] = \"three\\nline\\nstring\\nwith this line plus\\none more\";\n+  if (__builtin_memcmp (s3, s3_correct, sizeof s3_correct))\n+    __builtin_abort ();\n+}"}, {"sha": "b1107920c947eb07981c2dba583c859dba54b57a", "filename": "libcpp/lex.cc", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad2167bbac8ae83b1e91305b105ab5287bdac55/libcpp%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad2167bbac8ae83b1e91305b105ab5287bdac55/libcpp%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.cc?ref=3ad2167bbac8ae83b1e91305b105ab5287bdac55", "patch": "@@ -1076,6 +1076,9 @@ _cpp_clean_line (cpp_reader *pfile)\n   buffer->next_line = s + 1;\n }\n \n+template <bool lexing_raw_string>\n+static bool get_fresh_line_impl (cpp_reader *pfile);\n+\n /* Return true if the trigraph indicated by NOTE should be warned\n    about in a comment.  */\n static bool\n@@ -2695,9 +2698,8 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \t{\n \t  pos--;\n \t  pfile->buffer->cur = pos;\n-\t  if (pfile->state.in_directive\n-\t      || (pfile->state.parsing_args\n-\t\t  && pfile->buffer->next_line >= pfile->buffer->rlimit))\n+\t  if ((pfile->state.in_directive || pfile->state.parsing_args)\n+\t      && pfile->buffer->next_line >= pfile->buffer->rlimit)\n \t    {\n \t      cpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc, 0,\n \t\t\t\t   \"unterminated raw string\");\n@@ -2712,7 +2714,7 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \t    CPP_INCREMENT_LINE (pfile, 0);\n \t  pfile->buffer->need_line = true;\n \n-\t  if (!_cpp_get_fresh_line (pfile))\n+\t  if (!get_fresh_line_impl<true> (pfile))\n \t    {\n \t      /* We ran out of file and failed to get a line.  */\n \t      location_t src_loc = token->src_loc;\n@@ -2724,8 +2726,15 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \t\t_cpp_release_buff (pfile, accum.first);\n \t      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,\n \t\t\t\t   \"unterminated raw string\");\n-\t      /* Now pop the buffer that _cpp_get_fresh_line did not.  */\n+\n+\t      /* Now pop the buffer that get_fresh_line_impl() did not.  Popping\n+\t\t is not safe if processing a directive, however this cannot\n+\t\t happen as we already checked above that a line would be\n+\t\t available, and get_fresh_line_impl() can't fail in this\n+\t\t case.  */\n+\t      gcc_assert (!pfile->state.in_directive);\n \t      _cpp_pop_buffer (pfile);\n+\n \t      return;\n \t    }\n \n@@ -3659,11 +3668,14 @@ _cpp_lex_token (cpp_reader *pfile)\n }\n \n /* Returns true if a fresh line has been loaded.  */\n-bool\n-_cpp_get_fresh_line (cpp_reader *pfile)\n+template <bool lexing_raw_string>\n+static bool\n+get_fresh_line_impl (cpp_reader *pfile)\n {\n-  /* We can't get a new line until we leave the current directive.  */\n-  if (pfile->state.in_directive)\n+  /* We can't get a new line until we leave the current directive, unless we\n+     are lexing a raw string, in which case it will be OK as long as we don't\n+     pop the current buffer.  */\n+  if (!lexing_raw_string && pfile->state.in_directive)\n     return false;\n \n   for (;;)\n@@ -3679,6 +3691,10 @@ _cpp_get_fresh_line (cpp_reader *pfile)\n \t  return true;\n \t}\n \n+      /* We can't change buffers until we leave the current directive.  */\n+      if (lexing_raw_string && pfile->state.in_directive)\n+\treturn false;\n+\n       /* First, get out of parsing arguments state.  */\n       if (pfile->state.parsing_args)\n \treturn false;\n@@ -3706,6 +3722,13 @@ _cpp_get_fresh_line (cpp_reader *pfile)\n     }\n }\n \n+bool\n+_cpp_get_fresh_line (cpp_reader *pfile)\n+{\n+  return get_fresh_line_impl<false> (pfile);\n+}\n+\n+\n #define IF_NEXT_IS(CHAR, THEN_TYPE, ELSE_TYPE)\t\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\"}]}