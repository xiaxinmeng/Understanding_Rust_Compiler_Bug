{"sha": "56731d645e826bc7524c85bef3d32d75772f72cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY3MzFkNjQ1ZTgyNmJjNzUyNGM4NWJlZjNkMzJkNzU3NzJmNzJjYg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-05-17T11:16:00Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-05-17T11:16:00Z"}, "message": "function.c (try_fit_stack_local, [...]): New static functions.\n\n\t* function.c (try_fit_stack_local, add_frame_space): New static\n\tfunctions.\n\t(assign_stack_local_1): Use them.  Look for opportunities to use\n\tspace previously wasted on alignment.\n\t* function.h (struct frame_space): New.\n\t(struct rtl_data): Add FRAME_SPACE_LIST member.\n\t* reload1.c (something_was_spilled): New static variable.\n\t(alter_reg): Set it.\n\t(reload): Test it in addition to testing if the frame size changed.\n\nFrom-SVN: r159480", "tree": {"sha": "134ce3aa4098037a175571e45c5fbc2d2a49bbd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/134ce3aa4098037a175571e45c5fbc2d2a49bbd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56731d645e826bc7524c85bef3d32d75772f72cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56731d645e826bc7524c85bef3d32d75772f72cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56731d645e826bc7524c85bef3d32d75772f72cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56731d645e826bc7524c85bef3d32d75772f72cb/comments", "author": null, "committer": null, "parents": [{"sha": "1041dabaa27fa33389263dcb1aacd7aae5a73396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1041dabaa27fa33389263dcb1aacd7aae5a73396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1041dabaa27fa33389263dcb1aacd7aae5a73396"}], "stats": {"total": 186, "additions": 150, "deletions": 36}, "files": [{"sha": "e53fc44d79c66325648f81882edf821b997f3a5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56731d645e826bc7524c85bef3d32d75772f72cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56731d645e826bc7524c85bef3d32d75772f72cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56731d645e826bc7524c85bef3d32d75772f72cb", "patch": "@@ -1,3 +1,15 @@\n+2010-05-17  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* function.c (try_fit_stack_local, add_frame_space): New static\n+\tfunctions.\n+\t(assign_stack_local_1): Use them.  Look for opportunities to use\n+\tspace previously wasted on alignment.\n+\t* function.h (struct frame_space): New.\n+\t(struct rtl_data): Add FRAME_SPACE_LIST member.\n+\t* reload1.c (something_was_spilled): New static variable.\n+\t(alter_reg): Set it.\n+\t(reload): Test it in addition to testing if the frame size changed.\n+\n 2010-05-17  Christian Borntraeger  <borntraeger@de.ibm.com>\n \n         * config/s390/s390.c: Define sane prefetch settings and activate"}, {"sha": "5d0e7e5c9543de5e06a947a5205dfe5dd03c908b", "filename": "gcc/function.c", "status": "modified", "additions": 117, "deletions": 34, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56731d645e826bc7524c85bef3d32d75772f72cb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56731d645e826bc7524c85bef3d32d75772f72cb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=56731d645e826bc7524c85bef3d32d75772f72cb", "patch": "@@ -278,6 +278,75 @@ get_stack_local_alignment (tree type, enum machine_mode mode)\n   return STACK_SLOT_ALIGNMENT (type, mode, alignment);\n }\n \n+/* Determine whether it is possible to fit a stack slot of size SIZE and\n+   alignment ALIGNMENT into an area in the stack frame that starts at\n+   frame offset START and has a length of LENGTH.  If so, store the frame\n+   offset to be used for the stack slot in *POFFSET and return true;\n+   return false otherwise.  This function will extend the frame size when\n+   given a start/length pair that lies at the end of the frame.  */\n+\n+static bool\n+try_fit_stack_local (HOST_WIDE_INT start, HOST_WIDE_INT length,\n+\t\t     HOST_WIDE_INT size, unsigned int alignment,\n+\t\t     HOST_WIDE_INT *poffset)\n+{\n+  HOST_WIDE_INT this_frame_offset;\n+  int frame_off, frame_alignment, frame_phase;\n+\n+  /* Calculate how many bytes the start of local variables is off from\n+     stack alignment.  */\n+  frame_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+  frame_off = STARTING_FRAME_OFFSET % frame_alignment;\n+  frame_phase = frame_off ? frame_alignment - frame_off : 0;\n+\n+  /* Round the frame offset to the specified alignment.  */\n+\n+  /*  We must be careful here, since FRAME_OFFSET might be negative and\n+      division with a negative dividend isn't as well defined as we might\n+      like.  So we instead assume that ALIGNMENT is a power of two and\n+      use logical operations which are unambiguous.  */\n+  if (FRAME_GROWS_DOWNWARD)\n+    this_frame_offset\n+      = (FLOOR_ROUND (start + length - size - frame_phase,\n+\t\t      (unsigned HOST_WIDE_INT) alignment)\n+\t + frame_phase);\n+  else\n+    this_frame_offset\n+      = (CEIL_ROUND (start - frame_phase,\n+\t\t     (unsigned HOST_WIDE_INT) alignment)\n+\t + frame_phase);\n+\n+  /* See if it fits.  If this space is at the edge of the frame,\n+     consider extending the frame to make it fit.  Our caller relies on\n+     this when allocating a new slot.  */\n+  if (frame_offset == start && this_frame_offset < frame_offset)\n+    frame_offset = this_frame_offset;\n+  else if (this_frame_offset < start)\n+    return false;\n+  else if (start + length == frame_offset\n+\t   && this_frame_offset + size > start + length)\n+    frame_offset = this_frame_offset + size;\n+  else if (this_frame_offset + size > start + length)\n+    return false;\n+\n+  *poffset = this_frame_offset;\n+  return true;\n+}\n+\n+/* Create a new frame_space structure describing free space in the stack\n+   frame beginning at START and ending at END, and chain it into the\n+   function's frame_space_list.  */\n+\n+static void\n+add_frame_space (HOST_WIDE_INT start, HOST_WIDE_INT end)\n+{\n+  struct frame_space *space = GGC_NEW (struct frame_space);\n+  space->next = crtl->frame_space_list;\n+  crtl->frame_space_list = space;\n+  space->start = start;\n+  space->length = end - start;\n+}\n+\n /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it\n    with machine mode MODE.\n \n@@ -298,8 +367,8 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n {\n   rtx x, addr;\n   int bigend_correction = 0;\n+  HOST_WIDE_INT slot_offset, old_frame_offset;\n   unsigned int alignment, alignment_in_bits;\n-  int frame_off, frame_alignment, frame_phase;\n \n   if (align == 0)\n     {\n@@ -318,9 +387,6 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n \n   alignment_in_bits = alignment * BITS_PER_UNIT;\n \n-  if (FRAME_GROWS_DOWNWARD)\n-    frame_offset -= size;\n-\n   /* Ignore alignment if it exceeds MAX_SUPPORTED_STACK_ALIGNMENT.  */\n   if (alignment_in_bits > MAX_SUPPORTED_STACK_ALIGNMENT)\n     {\n@@ -363,35 +429,55 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n   if (crtl->max_used_stack_slot_alignment < alignment_in_bits)\n     crtl->max_used_stack_slot_alignment = alignment_in_bits;\n \n-  /* Calculate how many bytes the start of local variables is off from\n-     stack alignment.  */\n-  frame_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n-  frame_off = STARTING_FRAME_OFFSET % frame_alignment;\n-  frame_phase = frame_off ? frame_alignment - frame_off : 0;\n+  if (mode != BLKmode || size != 0)\n+    {\n+      struct frame_space **psp;\n \n-  /* Round the frame offset to the specified alignment.  The default is\n-     to always honor requests to align the stack but a port may choose to\n-     do its own stack alignment by defining STACK_ALIGNMENT_NEEDED.  */\n-  if (STACK_ALIGNMENT_NEEDED\n-      || mode != BLKmode\n-      || size != 0)\n+      for (psp = &crtl->frame_space_list; *psp; psp = &(*psp)->next)\n+\t{\n+\t  struct frame_space *space = *psp;\n+\t  if (!try_fit_stack_local (space->start, space->length, size,\n+\t\t\t\t    alignment, &slot_offset))\n+\t    continue;\n+\t  *psp = space->next;\n+\t  if (slot_offset > space->start)\n+\t    add_frame_space (space->start, slot_offset);\n+\t  if (slot_offset + size < space->start + space->length)\n+\t    add_frame_space (slot_offset + size,\n+\t\t\t     space->start + space->length);\n+\t  goto found_space;\n+\t}\n+    }\n+  else if (!STACK_ALIGNMENT_NEEDED)\n     {\n-      /*  We must be careful here, since FRAME_OFFSET might be negative and\n-\t  division with a negative dividend isn't as well defined as we might\n-\t  like.  So we instead assume that ALIGNMENT is a power of two and\n-\t  use logical operations which are unambiguous.  */\n-      if (FRAME_GROWS_DOWNWARD)\n-\tframe_offset\n-\t  = (FLOOR_ROUND (frame_offset - frame_phase,\n-\t\t\t  (unsigned HOST_WIDE_INT) alignment)\n-\t     + frame_phase);\n-      else\n-\tframe_offset\n-\t  = (CEIL_ROUND (frame_offset - frame_phase,\n-\t\t\t (unsigned HOST_WIDE_INT) alignment)\n-\t     + frame_phase);\n+      slot_offset = frame_offset;\n+      goto found_space;\n+    }\n+\n+  old_frame_offset = frame_offset;\n+\n+  if (FRAME_GROWS_DOWNWARD)\n+    {\n+      frame_offset -= size;\n+      try_fit_stack_local (frame_offset, size, size, alignment, &slot_offset);\n+\n+      if (slot_offset > frame_offset)\n+\tadd_frame_space (frame_offset, slot_offset);\n+      if (slot_offset + size < old_frame_offset)\n+\tadd_frame_space (slot_offset + size, old_frame_offset);\n+    }\n+  else\n+    {\n+      frame_offset += size;\n+      try_fit_stack_local (old_frame_offset, size, size, alignment, &slot_offset);\n+\n+      if (slot_offset > old_frame_offset)\n+\tadd_frame_space (old_frame_offset, slot_offset);\n+      if (slot_offset + size < frame_offset)\n+\tadd_frame_space (slot_offset + size, frame_offset);\n     }\n \n+ found_space:\n   /* On a big-endian machine, if we are allocating more space than we will use,\n      use the least significant bytes of those that are allocated.  */\n   if (BYTES_BIG_ENDIAN && mode != BLKmode && GET_MODE_SIZE (mode) < size)\n@@ -402,17 +488,14 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n   if (virtuals_instantiated)\n     addr = plus_constant (frame_pointer_rtx,\n \t\t\t  trunc_int_for_mode\n-\t\t\t  (frame_offset + bigend_correction\n+\t\t\t  (slot_offset + bigend_correction\n \t\t\t   + STARTING_FRAME_OFFSET, Pmode));\n   else\n     addr = plus_constant (virtual_stack_vars_rtx,\n \t\t\t  trunc_int_for_mode\n-\t\t\t  (frame_offset + bigend_correction,\n+\t\t\t  (slot_offset + bigend_correction,\n \t\t\t   Pmode));\n \n-  if (!FRAME_GROWS_DOWNWARD)\n-    frame_offset += size;\n-\n   x = gen_rtx_MEM (mode, addr);\n   set_mem_align (x, alignment_in_bits);\n   MEM_NOTRAP_P (x) = 1;"}, {"sha": "d008e8586efdf13dcbefe128e26612df1b53dff7", "filename": "gcc/function.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56731d645e826bc7524c85bef3d32d75772f72cb/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56731d645e826bc7524c85bef3d32d75772f72cb/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=56731d645e826bc7524c85bef3d32d75772f72cb", "patch": "@@ -231,6 +231,17 @@ struct GTY(()) function_subsections {\n   const char *unlikely_text_section_name;\n };\n \n+/* Describe an empty area of space in the stack frame.  These can be chained\n+   into a list; this is used to keep track of space wasted for alignment\n+   reasons.  */\n+struct GTY(()) frame_space\n+{\n+  struct frame_space *next;\n+\n+  HOST_WIDE_INT start;\n+  HOST_WIDE_INT length;\n+};\n+\n /* Datastructures maintained for currently processed function in RTL form.  */\n struct GTY(()) rtl_data {\n   struct expr_status expr;\n@@ -278,6 +289,9 @@ struct GTY(()) rtl_data {\n      Made for the sake of unshare_all_rtl.  */\n   rtx x_stack_slot_list;\n \n+  /* List of empty areas in the stack frame.  */\n+  struct frame_space *frame_space_list;\n+\n   /* Place after which to insert the tail_recursion_label if we need one.  */\n   rtx x_stack_check_probe_note;\n "}, {"sha": "4321b08546b7f2dd2b44a2767a916072be43ac7f", "filename": "gcc/reload1.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56731d645e826bc7524c85bef3d32d75772f72cb/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56731d645e826bc7524c85bef3d32d75772f72cb/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=56731d645e826bc7524c85bef3d32d75772f72cb", "patch": "@@ -702,6 +702,8 @@ has_nonexceptional_receiver (void)\n static int something_needs_elimination;\n /* Set during calculate_needs if an insn needs an operand changed.  */\n static int something_needs_operands_changed;\n+/* Set by alter_regs if we spilled a register to the stack.  */\n+static bool something_was_spilled;\n \n /* Nonzero means we couldn't get enough spill regs.  */\n static int failure;\n@@ -981,6 +983,7 @@ reload (rtx first, int global)\n       HOST_WIDE_INT starting_frame_size;\n \n       starting_frame_size = get_frame_size ();\n+      something_was_spilled = false;\n \n       set_initial_elim_offsets ();\n       set_initial_label_offsets ();\n@@ -1046,7 +1049,7 @@ reload (rtx first, int global)\n \tsetup_save_areas ();\n \n       /* If we allocated another stack slot, redo elimination bookkeeping.  */\n-      if (starting_frame_size != get_frame_size ())\n+      if (something_was_spilled || starting_frame_size != get_frame_size ())\n \tcontinue;\n       if (starting_frame_size && crtl->stack_alignment_needed)\n \t{\n@@ -1084,7 +1087,7 @@ reload (rtx first, int global)\n \n       /* If we allocated any new memory locations, make another pass\n \t since it might have changed elimination offsets.  */\n-      if (starting_frame_size != get_frame_size ())\n+      if (something_was_spilled || starting_frame_size != get_frame_size ())\n \tsomething_changed = 1;\n \n       /* Even if the frame size remained the same, we might still have\n@@ -2223,6 +2226,8 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n       unsigned int min_align = reg_max_ref_width[i] * BITS_PER_UNIT;\n       int adjust = 0;\n \n+      something_was_spilled = true;\n+\n       if (ira_conflicts_p)\n \t{\n \t  /* Mark the spill for IRA.  */"}]}