{"sha": "e256dfce35cac1ab31628bd03f1881e145cb137e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI1NmRmY2UzNWNhYzFhYjMxNjI4YmQwM2YxODgxZTE0NWNiMTM3ZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-10-19T12:59:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-10-19T12:59:21Z"}, "message": "re PR tree-optimization/50768 (ICE: in execute_todo, at passes.c:1731 with -O2 -ftracer)\n\n2011-10-19  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/50768\n\t* gimple-fold.c (gimplify_and_update_call_from_tree): Rewrite.\n\n\t* gcc.dg/torture/pr50768.c: New testcase.\n\nFrom-SVN: r180187", "tree": {"sha": "acce1ffdbedc8c39bba1f601eab5477b701394fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acce1ffdbedc8c39bba1f601eab5477b701394fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e256dfce35cac1ab31628bd03f1881e145cb137e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e256dfce35cac1ab31628bd03f1881e145cb137e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e256dfce35cac1ab31628bd03f1881e145cb137e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e256dfce35cac1ab31628bd03f1881e145cb137e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "854b5fd7b52ae803fd48eb942095a75fa6f910a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/854b5fd7b52ae803fd48eb942095a75fa6f910a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/854b5fd7b52ae803fd48eb942095a75fa6f910a8"}], "stats": {"total": 156, "additions": 79, "deletions": 77}, "files": [{"sha": "ba3f7073b3a3a4235f9d5a641984b8aab186f61b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e256dfce35cac1ab31628bd03f1881e145cb137e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e256dfce35cac1ab31628bd03f1881e145cb137e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e256dfce35cac1ab31628bd03f1881e145cb137e", "patch": "@@ -1,3 +1,8 @@\n+2011-10-19  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/50768\n+\t* gimple-fold.c (gimplify_and_update_call_from_tree): Rewrite.\n+\n 2011-10-19  Andrey Belevantsev  <abel@ispras.ru>\n \n \tPR rtl-optimization/50340"}, {"sha": "aa67d248c53da1bb6d3948f702a971457ba623cc", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 52, "deletions": 77, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e256dfce35cac1ab31628bd03f1881e145cb137e/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e256dfce35cac1ab31628bd03f1881e145cb137e/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e256dfce35cac1ab31628bd03f1881e145cb137e", "patch": "@@ -534,25 +534,22 @@ void\n gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n {\n   tree lhs;\n-  tree tmp = NULL_TREE;  /* Silence warning.  */\n   gimple stmt, new_stmt;\n   gimple_stmt_iterator i;\n   gimple_seq stmts = gimple_seq_alloc();\n   struct gimplify_ctx gctx;\n-  gimple last = NULL;\n-  gimple laststore = NULL;\n+  gimple last;\n+  gimple laststore;\n   tree reaching_vuse;\n \n   stmt = gsi_stmt (*si_p);\n \n   gcc_assert (is_gimple_call (stmt));\n \n-  lhs = gimple_call_lhs (stmt);\n-  reaching_vuse = gimple_vuse (stmt);\n-\n   push_gimplify_context (&gctx);\n   gctx.into_ssa = gimple_in_ssa_p (cfun);\n \n+  lhs = gimple_call_lhs (stmt);\n   if (lhs == NULL_TREE)\n     {\n       gimplify_and_add (expr, &stmts);\n@@ -571,105 +568,83 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \t}\n     }\n   else\n-    tmp = get_initialized_tmp_var (expr, &stmts, NULL);\n+    {\n+      tree tmp = get_initialized_tmp_var (expr, &stmts, NULL);\n+      new_stmt = gimple_build_assign (lhs, tmp);\n+      i = gsi_last (stmts);\n+      gsi_insert_after_without_update (&i, new_stmt,\n+\t\t\t\t       GSI_CONTINUE_LINKING);\n+    }\n \n   pop_gimplify_context (NULL);\n \n   if (gimple_has_location (stmt))\n     annotate_all_with_location (stmts, gimple_location (stmt));\n \n-  /* The replacement can expose previously unreferenced variables.  */\n+  /* First iterate over the replacement statements backward, assigning\n+     virtual operands to their defining statements.  */\n+  laststore = NULL;\n+  for (i = gsi_last (stmts); !gsi_end_p (i); gsi_prev (&i))\n+    {\n+      new_stmt = gsi_stmt (i);\n+      if (gimple_assign_single_p (new_stmt)\n+\t  && !is_gimple_reg (gimple_assign_lhs (new_stmt)))\n+\t{\n+\t  tree vdef;\n+\t  if (!laststore)\n+\t    vdef = gimple_vdef (stmt);\n+\t  else\n+\t    vdef = make_ssa_name (gimple_vop (cfun), new_stmt);\n+\t  gimple_set_vdef (new_stmt, vdef);\n+\t  if (TREE_CODE (vdef) == SSA_NAME)\n+\t    SSA_NAME_DEF_STMT (vdef) = new_stmt;\n+\t  laststore = new_stmt;\n+\t}\n+    }\n+\n+  /* Second iterate over the statements forward, assigning virtual\n+     operands to their uses.  */\n+  last = NULL;\n+  reaching_vuse = gimple_vuse (stmt);\n   for (i = gsi_start (stmts); !gsi_end_p (i); gsi_next (&i))\n     {\n+      /* Do not insert the last stmt in this loop but remember it\n+         for replacing the original statement.  */\n       if (last)\n \t{\n \t  gsi_insert_before (si_p, last, GSI_NEW_STMT);\n \t  gsi_next (si_p);\n \t}\n       new_stmt = gsi_stmt (i);\n+      /* The replacement can expose previously unreferenced variables.  */\n       if (gimple_in_ssa_p (cfun))\n \tfind_new_referenced_vars (new_stmt);\n       /* If the new statement possibly has a VUSE, update it with exact SSA\n \t name we know will reach this one.  */\n       if (gimple_has_mem_ops (new_stmt))\n-\t{\n-\t  /* If we've also seen a previous store create a new VDEF for\n-\t     the latter one, and make that the new reaching VUSE.  */\n-\t  if (laststore)\n-\t    {\n-\t      reaching_vuse = make_ssa_name (gimple_vop (cfun), laststore);\n-\t      gimple_set_vdef (laststore, reaching_vuse);\n-\t      update_stmt (laststore);\n-\t      laststore = NULL;\n-\t    }\n-\t  gimple_set_vuse (new_stmt, reaching_vuse);\n-\t  gimple_set_modified (new_stmt, true);\n-\t}\n-      if (gimple_assign_single_p (new_stmt)\n-\t  && !is_gimple_reg (gimple_assign_lhs (new_stmt)))\n-\t{\n-\t  laststore = new_stmt;\n-\t}\n+\tgimple_set_vuse (new_stmt, reaching_vuse);\n+      gimple_set_modified (new_stmt, true);\n+      if (gimple_vdef (new_stmt))\n+\treaching_vuse = gimple_vdef (new_stmt);\n       last = new_stmt;\n     }\n \n-  if (lhs == NULL_TREE)\n+  /* If the new sequence does not do a store release the virtual\n+     definition of the original statement.  */\n+  if (reaching_vuse\n+      && reaching_vuse == gimple_vuse (stmt))\n     {\n-      /* If we replace a call without LHS that has a VDEF and our new\n-         sequence ends with a store we must make that store have the same\n-\t vdef in order not to break the sequencing.  This can happen\n-\t for instance when folding memcpy calls into assignments.  */\n-      if (gimple_vdef (stmt) && laststore)\n-\t{\n-\t  gimple_set_vdef (laststore, gimple_vdef (stmt));\n-\t  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)\n-\t    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = laststore;\n-\t  update_stmt (laststore);\n-\t}\n-      else if (gimple_in_ssa_p (cfun))\n+      tree vdef = gimple_vdef (stmt);\n+      if (vdef\n+\t  && TREE_CODE (vdef) == SSA_NAME)\n \t{\n \t  unlink_stmt_vdef (stmt);\n-\t  release_defs (stmt);\n-\t}\n-      new_stmt = last;\n-    }\n-  else\n-    {\n-      if (last)\n-\t{\n-\t  gsi_insert_before (si_p, last, GSI_NEW_STMT);\n-\t  gsi_next (si_p);\n-\t}\n-      if (laststore && is_gimple_reg (lhs))\n-\t{\n-\t  gimple_set_vdef (laststore, gimple_vdef (stmt));\n-\t  update_stmt (laststore);\n-\t  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)\n-\t    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = laststore;\n-\t  laststore = NULL;\n-\t}\n-      else if (laststore)\n-\t{\n-\t  reaching_vuse = make_ssa_name (gimple_vop (cfun), laststore);\n-\t  gimple_set_vdef (laststore, reaching_vuse);\n-\t  update_stmt (laststore);\n-\t  laststore = NULL;\n-\t}\n-      new_stmt = gimple_build_assign (lhs, tmp);\n-      if (!is_gimple_reg (tmp))\n-\tgimple_set_vuse (new_stmt, reaching_vuse);\n-      if (!is_gimple_reg (lhs))\n-\t{\n-\t  gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n-\t  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)\n-\t    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = new_stmt;\n+\t  release_ssa_name (vdef);\n \t}\n-      else if (reaching_vuse == gimple_vuse (stmt))\n-\tunlink_stmt_vdef (stmt);\n     }\n \n-  gimple_set_location (new_stmt, gimple_location (stmt));\n-  gsi_replace (si_p, new_stmt, false);\n+  /* Finally replace rhe original statement with the last.  */\n+  gsi_replace (si_p, last, false);\n }\n \n /* Return the string length, maximum string length or maximum value of"}, {"sha": "1bed60070d50710d0b6a359ac7631baae922e8b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e256dfce35cac1ab31628bd03f1881e145cb137e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e256dfce35cac1ab31628bd03f1881e145cb137e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e256dfce35cac1ab31628bd03f1881e145cb137e", "patch": "@@ -1,3 +1,8 @@\n+2011-10-19  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/50768\n+\t* gcc.dg/torture/pr50768.c: New testcase.\n+\n 2011-10-19  Alexander Monakov  <amonakov@ispras.ru>\n \n \tPR rtl-optimization/50340"}, {"sha": "351b2f9661812e092870fca9f2e706fb97d7a0c8", "filename": "gcc/testsuite/gcc.dg/torture/pr50768.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e256dfce35cac1ab31628bd03f1881e145cb137e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50768.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e256dfce35cac1ab31628bd03f1881e145cb137e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50768.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50768.c?ref=e256dfce35cac1ab31628bd03f1881e145cb137e", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-ftracer\" } */\n+\n+char data[8];\n+int l1;\n+\n+void\n+test1 (void)\n+{\n+  char buf[8];\n+  __builtin___mempcpy_chk (buf, data, l1 ? sizeof (buf) : 4,\n+\t\t\t   __builtin_object_size (buf, 0));\n+  if (__builtin___memmove_chk\n+      (buf, data, l1 ? sizeof (buf) : 4,\n+       __builtin_object_size (buf, 0)) != buf)\n+    __builtin_abort ();\n+}"}]}