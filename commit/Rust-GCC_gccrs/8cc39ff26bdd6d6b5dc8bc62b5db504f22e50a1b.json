{"sha": "8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNjMzlmZjI2YmRkNmQ2YjVkYzhiYzYyYjVkYjUwNGYyMmU1MGExYg==", "commit": {"author": {"name": "Vasiliy Fofanov", "email": "fofanov@adacore.com", "date": "2007-06-06T10:30:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:30:04Z"}, "message": "gmem.c: Add support for timestamps on memory operations.\n\n2007-04-20  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* gmem.c: Add support for timestamps on memory operations.\n\n\t* memtrack.adb, gnatmem.adb: Add support for timestamps on memory\n\toperations (not used currently, just foundation for future\n\tenhancements). Add possibility to perform full dump of gmem.out file.\n\t(Print_Back_Traces): Declare accesses to root arrays constants since\n\tthey aren't modified.\n\t(Print_Back_Traces): allocate root arrays on the heap rather than stack.\n\nFrom-SVN: r125419", "tree": {"sha": "dc2de52c5511689fb3b3a03be8ed6fcae9c92368", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc2de52c5511689fb3b3a03be8ed6fcae9c92368"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b/comments", "author": {"login": "t-14", "id": 18482303, "node_id": "MDQ6VXNlcjE4NDgyMzAz", "avatar_url": "https://avatars.githubusercontent.com/u/18482303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-14", "html_url": "https://github.com/t-14", "followers_url": "https://api.github.com/users/t-14/followers", "following_url": "https://api.github.com/users/t-14/following{/other_user}", "gists_url": "https://api.github.com/users/t-14/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-14/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-14/subscriptions", "organizations_url": "https://api.github.com/users/t-14/orgs", "repos_url": "https://api.github.com/users/t-14/repos", "events_url": "https://api.github.com/users/t-14/events{/privacy}", "received_events_url": "https://api.github.com/users/t-14/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fd79385825a2ff47101383be84d72bd6792a197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd79385825a2ff47101383be84d72bd6792a197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fd79385825a2ff47101383be84d72bd6792a197"}], "stats": {"total": 301, "additions": 227, "deletions": 74}, "files": [{"sha": "508d18d7cd6c7a2930dd7d4d241d3bcf06e08111", "filename": "gcc/ada/gmem.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b/gcc%2Fada%2Fgmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b/gcc%2Fada%2Fgmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgmem.c?ref=8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *         Copyright (C) 2000-2006, Free Software Foundation, Inc.          *\n+ *         Copyright (C) 2000-2007, Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -31,7 +31,7 @@\n  ****************************************************************************/\n \n /*  This unit reads the allocation tracking log produced by augmented\n-    __gnat_malloc and __gnat_free procedures (see file a-raise.c) and\n+    __gnat_malloc and __gnat_free procedures (see file memtrack.adb) and\n     provides GNATMEM tool with gdb-compliant output. The output is\n     processed by GNATMEM to detect dynamic memory allocation errors.\n \n@@ -43,9 +43,11 @@\n       GNU/Linux x86\n       Solaris (sparc and x86) (*)\n       Windows 98/95/NT (x86)\n+      Alpha OpenVMS\n \n     (*) on these targets, the compilation must be done with -funwind-tables to\n     be able to build the stack backtrace.\n+\n */\n \n #include <stdio.h>\n@@ -65,6 +67,7 @@ struct struct_storage_elmt {\n   char   Elmt;\n   void * Address;\n   size_t Size;\n+  long long Timestamp;\n };\n \n static void\n@@ -108,14 +111,15 @@ gmem_read_backtrace (void)\n   cur_tb_pos = 0;\n }\n \n-/* initialize gmem feature from the dumpname file. It returns 1 if the\n-   dumpname has been generated by GMEM (instrumented malloc/free) and 0 if not\n-   (i.e. probably a GDB generated file).\n+/* initialize gmem feature from the dumpname file. It returns t0 timestamp\n+   if the dumpname has been generated by GMEM (instrumented malloc/free)\n+   and 0 if not.\n */\n \n-int __gnat_gmem_initialize (char *dumpname)\n+long long __gnat_gmem_initialize (char *dumpname)\n {\n   char header [10];\n+  long long t0;\n \n   gmemfile = fopen (dumpname, \"rb\");\n   fread (header, 10, 1, gmemfile);\n@@ -127,7 +131,9 @@ int __gnat_gmem_initialize (char *dumpname)\n       return 0;\n     }\n \n-  return 1;\n+  fread (&t0, sizeof (long long), 1, gmemfile);\n+\n+  return t0;\n }\n \n /* initialize addr2line library */\n@@ -163,10 +169,12 @@ __gnat_gmem_read_next (struct struct_storage_elmt *buf)\n             buf->Elmt = LOG_ALLOC;\n             fread (&(buf->Address), sizeof (void *), 1, gmemfile);\n             fread (&(buf->Size), sizeof (size_t), 1, gmemfile);\n+            fread (&(buf->Timestamp), sizeof (long long), 1, gmemfile);\n             break;\n           case 'D' :\n             buf->Elmt = LOG_DEALL;\n             fread (&(buf->Address), sizeof (void *), 1, gmemfile);\n+            fread (&(buf->Timestamp), sizeof (long long), 1, gmemfile);\n             break;\n           default:\n             puts (\"GNATMEM dump file corrupt\");"}, {"sha": "b5c092f30daa6938f4c564ea72bd2ef7ec19c90d", "filename": "gcc/ada/gnatmem.adb", "status": "modified", "additions": 165, "deletions": 56, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b/gcc%2Fada%2Fgnatmem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b/gcc%2Fada%2Fgnatmem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatmem.adb?ref=8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1997-2005, AdaCore                     --\n+--                     Copyright (C) 1997-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,24 +53,25 @@\n --   execution generating memory allocation where data is collected (such as\n --   number of allocations, amount of memory allocated, high water mark, etc.)\n \n-with Gnatvsn; use Gnatvsn;\n-\n-with Ada.Text_IO;             use Ada.Text_IO;\n with Ada.Float_Text_IO;\n with Ada.Integer_Text_IO;\n+with Ada.Text_IO;             use Ada.Text_IO;\n+\n+with System;                  use System;\n+with System.Storage_Elements; use System.Storage_Elements;\n \n with GNAT.Command_Line;       use GNAT.Command_Line;\n with GNAT.Heap_Sort_G;\n with GNAT.OS_Lib;             use GNAT.OS_Lib;\n with GNAT.HTable;             use GNAT.HTable;\n \n-with System;                  use System;\n-with System.Storage_Elements; use System.Storage_Elements;\n-\n+with Gnatvsn; use Gnatvsn;\n with Memroot; use Memroot;\n \n procedure Gnatmem is\n \n+   package Int_IO renames Ada.Integer_Text_IO;\n+\n    ------------------------\n    -- Other Declarations --\n    ------------------------\n@@ -80,13 +81,24 @@ procedure Gnatmem is\n       --  *  = End of log file\n       --  A  = found a ALLOC mark in the log\n       --  D  = found a DEALL mark in the log\n+\n       Address : Integer_Address;\n       Size    : Storage_Count;\n+      Timestamp : Duration;\n    end record;\n-   --  This needs a comment ???\n+   --  This type is used to read heap operations from the log file.\n+   --  Elmt contains the type of the operation, which can be either\n+   --  allocation, deallocation, or a special mark indicating the\n+   --  end of the log file. Address is used to store address on the\n+   --  heap where a chunk was allocated/deallocated, size is only\n+   --  for A event and contains size of the allocation, and Timestamp\n+   --  is the clock value at the moment of allocation\n+\n+   Log_Name : String_Access;\n+   --  Holds the name of the heap operations log file\n \n-   Log_Name, Program_Name : String_Access;\n-   --  These need comments, and should be on separate lines ???\n+   Program_Name : String_Access;\n+   --  Holds the name of the user executable\n \n    function Read_Next return Storage_Elmt;\n    --  Reads next dynamic storage operation from the log file\n@@ -133,18 +145,37 @@ procedure Gnatmem is\n \n    BT_Depth   : Integer := 1;\n \n-   --  The following need comments ???\n+   --  Some global statistics\n+\n+   Global_Alloc_Size : Storage_Count := 0;\n+   --  Total number of bytes allocated during the lifetime of a program\n+\n+   Global_High_Water_Mark : Storage_Count := 0;\n+   --  Largest amount of storage ever in use during the lifetime\n \n-   Global_Alloc_Size      : Storage_Count  := 0;\n-   Global_High_Water_Mark : Storage_Count  := 0;\n-   Global_Nb_Alloc        : Integer        := 0;\n-   Global_Nb_Dealloc      : Integer        := 0;\n-   Nb_Root                : Integer        := 0;\n-   Nb_Wrong_Deall         : Integer        := 0;\n-   Minimum_NB_Leaks       : Integer        := 1;\n+   Global_Nb_Alloc : Integer := 0;\n+   --  Total number of allocations\n \n-   Tmp_Alloc   : Allocation;\n-   Quiet_Mode  : Boolean := False;\n+   Global_Nb_Dealloc : Integer := 0;\n+   --  Total number of deallocations\n+\n+   Nb_Root : Integer := 0;\n+   --  Total number of allocation roots\n+\n+   Nb_Wrong_Deall : Integer := 0;\n+   --  Total number of wrong deallocations (i.e. without matching alloc)\n+\n+   Minimum_Nb_Leaks : Integer := 1;\n+   --  How many unfreed allocs should be in a root for it to count as leak\n+\n+   T0 : Duration := 0.0;\n+   --  The moment at which memory allocation routines initialized (should\n+   --  be pretty close to the moment the program started since there are\n+   --  always some allocations at RTL elaboration\n+\n+   Tmp_Alloc     : Allocation;\n+   Dump_Log_Mode : Boolean := False;\n+   Quiet_Mode    : Boolean := False;\n \n    ------------------------------\n    -- Allocation Roots Sorting --\n@@ -160,16 +191,25 @@ procedure Gnatmem is\n    -- GMEM functionality binding --\n    --------------------------------\n \n+   ---------------------\n+   -- Gmem_Initialize --\n+   ---------------------\n+\n    function Gmem_Initialize (Dumpname : String) return Boolean is\n-      function Initialize (Dumpname : System.Address) return Boolean;\n+      function Initialize (Dumpname : System.Address) return Duration;\n       pragma Import (C, Initialize, \"__gnat_gmem_initialize\");\n \n       S : aliased String := Dumpname & ASCII.NUL;\n \n    begin\n-      return Initialize (S'Address);\n+      T0 := Initialize (S'Address);\n+      return T0 > 0.0;\n    end Gmem_Initialize;\n \n+   -------------------------\n+   -- Gmem_A2l_Initialize --\n+   -------------------------\n+\n    procedure Gmem_A2l_Initialize (Exename : String) is\n       procedure A2l_Initialize (Exename : System.Address);\n       pragma Import (C, A2l_Initialize, \"__gnat_gmem_a2l_initialize\");\n@@ -180,6 +220,10 @@ procedure Gnatmem is\n       A2l_Initialize (S'Address);\n    end Gmem_A2l_Initialize;\n \n+   ---------------\n+   -- Read_Next --\n+   ---------------\n+\n    function Read_Next return Storage_Elmt is\n       procedure Read_Next (buf : System.Address);\n       pragma Import (C, Read_Next, \"__gnat_gmem_read_next\");\n@@ -205,9 +249,9 @@ procedure Gnatmem is\n    ---------------\n \n    function Mem_Image (X : Storage_Count) return String is\n-      Ks    : constant Storage_Count := X / 1024;\n-      Megs  : constant Storage_Count := Ks / 1024;\n-      Buff  : String (1 .. 7);\n+      Ks   : constant Storage_Count := X / 1024;\n+      Megs : constant Storage_Count := Ks / 1024;\n+      Buff : String (1 .. 7);\n \n    begin\n       if Megs /= 0 then\n@@ -233,7 +277,7 @@ procedure Gnatmem is\n       New_Line;\n       Put (\"GNATMEM \");\n       Put_Line (Gnat_Version_String);\n-      Put_Line (\"Copyright 1997-2005, Free Software Foundation, Inc.\");\n+      Put_Line (\"Copyright 1997-2007, Free Software Foundation, Inc.\");\n       New_Line;\n \n       Put_Line (\"Usage: gnatmem switches [depth] exename\");\n@@ -263,7 +307,7 @@ procedure Gnatmem is\n       --  Parse the options first\n \n       loop\n-         case Getopt (\"b: m: i: q s:\") is\n+         case Getopt (\"b: dd m: i: q s:\") is\n             when ASCII.Nul => exit;\n \n             when 'b' =>\n@@ -274,9 +318,12 @@ procedure Gnatmem is\n                      Usage;\n                end;\n \n+            when 'd' =>\n+               Dump_Log_Mode := True;\n+\n             when 'm' =>\n                begin\n-                  Minimum_NB_Leaks := Natural'Value (Parameter);\n+                  Minimum_Nb_Leaks := Natural'Value (Parameter);\n                exception\n                   when Constraint_Error =>\n                      Usage;\n@@ -291,7 +338,6 @@ procedure Gnatmem is\n             when 's' =>\n                declare\n                   S : constant String (Sort_Order'Range) := Parameter;\n-\n                begin\n                   for J in Sort_Order'Range loop\n                      if S (J) = 'n' or else\n@@ -399,13 +445,36 @@ procedure Gnatmem is\n          Usage;\n    end Process_Arguments;\n \n+   --  Local variables\n+\n    Cur_Elmt : Storage_Elmt;\n+   Buff     : String (1 .. 16);\n \n --  Start of processing for Gnatmem\n \n begin\n    Process_Arguments;\n \n+   if Dump_Log_Mode then\n+      Put_Line (\"Full dump of dynamic memory operations history\");\n+      Put_Line (\"----------------------------------------------\");\n+\n+      declare\n+         function CTime (Clock : Address) return Address;\n+         pragma Import (C, CTime, \"ctime\");\n+\n+         Int_T0     : Integer := Integer (T0);\n+         CTime_Addr : constant Address := CTime (Int_T0'Address);\n+\n+         Buffer : String (1 .. 30);\n+         for Buffer'Address use CTime_Addr;\n+\n+      begin\n+         Put_Line (\"Log started at T0 =\" & Duration'Image (T0) & \" (\"\n+                   & Buffer (1 .. 24) & \")\");\n+      end;\n+   end if;\n+\n    --  Main loop analysing the data generated by the instrumented routines.\n    --  For each allocation, the backtrace is kept and stored in a htable\n    --  whose entry is the address. For each deallocation, we look for the\n@@ -420,10 +489,11 @@ begin\n \n          when 'A' =>\n \n-            --  Update global counters if the allocated size is meaningful\n+            --  Read the corresponding back trace\n+\n+            Tmp_Alloc.Root := Read_BT (BT_Depth);\n \n             if Quiet_Mode then\n-               Tmp_Alloc.Root := Read_BT (BT_Depth);\n \n                if Nb_Alloc (Tmp_Alloc.Root) = 0 then\n                   Nb_Root := Nb_Root + 1;\n@@ -434,17 +504,15 @@ begin\n \n             elsif Cur_Elmt.Size > 0 then\n \n+               --  Update global counters if the allocated size is meaningful\n+\n                Global_Alloc_Size := Global_Alloc_Size + Cur_Elmt.Size;\n                Global_Nb_Alloc   := Global_Nb_Alloc + 1;\n \n                if Global_High_Water_Mark < Global_Alloc_Size then\n                   Global_High_Water_Mark := Global_Alloc_Size;\n                end if;\n \n-               --  Read the corresponding back trace\n-\n-               Tmp_Alloc.Root := Read_BT (BT_Depth);\n-\n                --  Update the number of allocation root if this is a new one\n \n                if Nb_Alloc (Tmp_Alloc.Root) = 0 then\n@@ -470,10 +538,6 @@ begin\n                Tmp_Alloc.Size := Cur_Elmt.Size;\n                Address_HTable.Set (Cur_Elmt.Address, Tmp_Alloc);\n \n-            --  non meaningful output, just consumes the backtrace\n-\n-            else\n-               Tmp_Alloc.Root := Read_BT (BT_Depth);\n             end if;\n \n          when 'D' =>\n@@ -485,7 +549,7 @@ begin\n             if Tmp_Alloc.Root = No_Root_Id then\n \n                --  There was no prior allocation at this address, something is\n-               --  very wrong. Mark this allocation root as problematic\n+               --  very wrong. Mark this allocation root as problematic.\n \n                Tmp_Alloc.Root := Read_BT (BT_Depth);\n \n@@ -512,21 +576,45 @@ begin\n \n                Set_Nb_Alloc (Tmp_Alloc.Root, Nb_Alloc (Tmp_Alloc.Root) - 1);\n \n-               --  update the number of allocation root if this one disappear\n+               --  Update the number of allocation root if this one disappears\n \n                if Nb_Alloc (Tmp_Alloc.Root) = 0\n-                 and then Minimum_NB_Leaks > 0 then\n+                 and then Minimum_Nb_Leaks > 0 then\n                   Nb_Root := Nb_Root - 1;\n                end if;\n \n-               --  De-associate the deallocated address\n+               --  Deassociate the deallocated address\n \n                Address_HTable.Remove (Cur_Elmt.Address);\n             end if;\n \n          when others =>\n             raise Program_Error;\n       end case;\n+\n+      if Dump_Log_Mode then\n+         case Cur_Elmt.Elmt is\n+            when 'A' =>\n+               Put (\"ALLOC\");\n+               Int_IO.Put (Buff (1 .. 16), Integer (Cur_Elmt.Address), 16);\n+               Put (Buff);\n+               Int_IO.Put (Buff (1 .. 8), Integer (Cur_Elmt.Size));\n+               Put (Buff (1 .. 8) & \" bytes at moment T0 +\");\n+               Put_Line (Duration'Image (Cur_Elmt.Timestamp - T0));\n+\n+            when 'D' =>\n+               Put (\"DEALL\");\n+               Int_IO.Put (Buff (1 .. 16), Integer (Cur_Elmt.Address), 16);\n+               Put (Buff);\n+               Put_Line (\" at moment T0 +\"\n+                         & Duration'Image (Cur_Elmt.Timestamp - T0));\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+         Print_BT (Tmp_Alloc.Root);\n+      end if;\n+\n    end loop Main;\n \n    --  Print out general information about overall allocation\n@@ -551,33 +639,51 @@ begin\n    end if;\n \n    --  Print out the back traces corresponding to potential leaks in order\n-   --  greatest number of non-deallocated allocations\n+   --  greatest number of non-deallocated allocations.\n \n    Print_Back_Traces : declare\n       type Root_Array is array (Natural range <>) of Root_Id;\n-      Leaks   : Root_Array (0 .. Nb_Root);\n+      type Access_Root_Array is access Root_Array;\n+\n+      Leaks        : constant Access_Root_Array :=\n+                       new Root_Array (0 .. Nb_Root);\n       Leak_Index   : Natural := 0;\n \n-      Bogus_Dealls : Root_Array (1 .. Nb_Wrong_Deall);\n+      Bogus_Dealls : constant Access_Root_Array :=\n+                       new Root_Array (1 .. Nb_Wrong_Deall);\n       Deall_Index  : Natural := 0;\n       Nb_Alloc_J   : Natural := 0;\n \n       procedure Move (From : Natural; To : Natural);\n-      function  Lt (Op1, Op2 : Natural) return Boolean;\n-      package   Root_Sort is new GNAT.Heap_Sort_G (Move, Lt);\n+      function Lt (Op1, Op2 : Natural) return Boolean;\n+      package Root_Sort is new GNAT.Heap_Sort_G (Move, Lt);\n+\n+      ----------\n+      -- Move --\n+      ----------\n \n       procedure Move (From : Natural; To : Natural) is\n       begin\n          Leaks (To) := Leaks (From);\n       end Move;\n \n+      --------\n+      -- Lt --\n+      --------\n+\n       function Lt (Op1, Op2 : Natural) return Boolean is\n+\n          function Apply_Sort_Criterion (S : Character) return Integer;\n          --  Applies a specific sort criterion; returns -1, 0 or 1 if Op1 is\n-         --  smaller than, equal, or greater than Op2 according to criterion\n+         --  smaller than, equal, or greater than Op2 according to criterion.\n+\n+         --------------------------\n+         -- Apply_Sort_Criterion --\n+         --------------------------\n \n          function Apply_Sort_Criterion (S : Character) return Integer is\n             LOp1, LOp2 : Integer;\n+\n          begin\n             case S is\n                when 'n' =>\n@@ -603,11 +709,14 @@ begin\n             else\n                return 0;\n             end if;\n+\n          exception\n             when Constraint_Error =>\n                return 0;\n          end Apply_Sort_Criterion;\n \n+         --  Local Variables\n+\n          Result : Integer;\n \n       --  Start of processing for Lt\n@@ -627,12 +736,11 @@ begin\n    --  Start of processing for Print_Back_Traces\n \n    begin\n-      --  Transfer all the relevant Roots in the Leaks and a\n-      --  Bogus_Deall arrays\n+      --  Transfer all the relevant Roots in the Leaks and a Bogus_Deall arrays\n \n       Tmp_Alloc.Root := Get_First;\n       while Tmp_Alloc.Root /= No_Root_Id loop\n-         if Nb_Alloc (Tmp_Alloc.Root) = 0 and then Minimum_NB_Leaks > 0 then\n+         if Nb_Alloc (Tmp_Alloc.Root) = 0 and then Minimum_Nb_Leaks > 0 then\n             null;\n \n          elsif Nb_Alloc (Tmp_Alloc.Root) < 0  then\n@@ -663,15 +771,16 @@ begin\n \n       --  Print out all allocation Leaks\n \n-      if Nb_Root > 0 then\n+      if Leak_Index > 0 then\n \n          --  Sort the Leaks so that potentially important leaks appear first\n \n-         Root_Sort.Sort (Nb_Root);\n+         Root_Sort.Sort (Leak_Index);\n \n-         for J in  1 .. Leaks'Last loop\n+         for J in  1 .. Leak_Index loop\n             Nb_Alloc_J := Nb_Alloc (Leaks (J));\n-            if Nb_Alloc_J >= Minimum_NB_Leaks then\n+\n+            if Nb_Alloc_J >= Minimum_Nb_Leaks then\n                if Quiet_Mode then\n                   if Nb_Alloc_J = 1 then\n                      Put_Line (\" 1 leak at :\");"}, {"sha": "ad5c900a8abc65015d68392549a6e3b0a46c67f3", "filename": "gcc/ada/memtrack.adb", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b/gcc%2Fada%2Fmemtrack.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b/gcc%2Fada%2Fmemtrack.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemtrack.adb?ref=8cc39ff26bdd6d6b5dc8bc62b5db504f22e50a1b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,6 +64,12 @@\n --    Irix\n --    Solaris\n --    Tru64\n+--    Alpha OpenVMS\n+\n+--  NOTE FOR FUTURE PLATFORMS SUPPORT: It is assumed that type Duration is\n+--  64 bit. If the need arises to support architectures where this assumption\n+--  is incorrect, it will require changing the way timestamps of allocation\n+--  events are recorded.\n \n pragma Source_File_Name (System.Memory, Body_File_Name => \"memtrack.adb\");\n \n@@ -72,6 +78,7 @@ with System.Soft_Links;\n with System.Traceback;\n with System.Traceback_Entries;\n with GNAT.IO;\n+with System.OS_Primitives;\n \n package body System.Memory is\n \n@@ -140,6 +147,9 @@ package body System.Memory is\n    Gmemfile : File_Ptr;\n    --  Global C file pointer to the allocation log\n \n+   Needs_Init : Boolean := True;\n+   --  Reset after first call to Gmem_Initialize\n+\n    procedure Gmem_Initialize;\n    --  Initialization routine; opens the file and writes a header string. This\n    --  header string is used as a magic-tag to know if the .out file is to be\n@@ -157,6 +167,7 @@ package body System.Memory is\n    function Alloc (Size : size_t) return System.Address is\n       Result      : aliased System.Address;\n       Actual_Size : aliased size_t := Size;\n+      Timestamp   : aliased Duration;\n \n    begin\n       if Size = size_t'Last then\n@@ -184,13 +195,19 @@ package body System.Memory is\n \n          First_Call := False;\n \n-         Gmem_Initialize;\n+         if Needs_Init then\n+            Gmem_Initialize;\n+         end if;\n+\n+         Timestamp := System.OS_Primitives.Clock;\n          Call_Chain (Tracebk'Address, Max_Call_Stack, Num_Calls,\n                      Skip_Frames => 2);\n          fputc (Character'Pos ('A'), Gmemfile);\n          fwrite (Result'Address, Address_Size, 1, Gmemfile);\n          fwrite (Actual_Size'Address, size_t'Max_Size_In_Storage_Elements, 1,\n                  Gmemfile);\n+         fwrite (Timestamp'Address, Duration'Max_Size_In_Storage_Elements, 1,\n+                 Gmemfile);\n          fwrite (Num_Calls'Address, Integer'Max_Size_In_Storage_Elements, 1,\n                  Gmemfile);\n \n@@ -219,9 +236,6 @@ package body System.Memory is\n    -- Finalize --\n    --------------\n \n-   Needs_Init : Boolean := True;\n-   --  Reset after first call to Gmem_Initialize\n-\n    procedure Finalize is\n    begin\n       if not Needs_Init then\n@@ -234,7 +248,8 @@ package body System.Memory is\n    ----------\n \n    procedure Free (Ptr : System.Address) is\n-      Addr : aliased constant System.Address := Ptr;\n+      Addr      : aliased constant System.Address := Ptr;\n+      Timestamp : aliased Duration;\n \n    begin\n       Lock_Task.all;\n@@ -247,11 +262,17 @@ package body System.Memory is\n \n          First_Call := False;\n \n-         Gmem_Initialize;\n+         if Needs_Init then\n+            Gmem_Initialize;\n+         end if;\n+\n          Call_Chain (Tracebk'Address, Max_Call_Stack, Num_Calls,\n                      Skip_Frames => 2);\n+         Timestamp := System.OS_Primitives.Clock;\n          fputc (Character'Pos ('D'), Gmemfile);\n          fwrite (Addr'Address, Address_Size, 1, Gmemfile);\n+         fwrite (Timestamp'Address, Duration'Max_Size_In_Storage_Elements, 1,\n+                 Gmemfile);\n          fwrite (Num_Calls'Address, Integer'Max_Size_In_Storage_Elements, 1,\n                  Gmemfile);\n \n@@ -276,9 +297,13 @@ package body System.Memory is\n    ---------------------\n \n    procedure Gmem_Initialize is\n+      Timestamp : aliased Duration;\n+\n    begin\n       if Needs_Init then\n          Needs_Init := False;\n+         System.OS_Primitives.Initialize;\n+         Timestamp := System.OS_Primitives.Clock;\n          Gmemfile := fopen (Gmemfname, \"wb\" & ASCII.NUL);\n \n          if Gmemfile = System.Null_Address then\n@@ -287,6 +312,8 @@ package body System.Memory is\n          end if;\n \n          fwrite (\"GMEM DUMP\" & ASCII.LF, 10, 1, Gmemfile);\n+         fwrite (Timestamp'Address, Duration'Max_Size_In_Storage_Elements, 1,\n+                 Gmemfile);\n       end if;\n    end Gmem_Initialize;\n \n@@ -295,10 +322,12 @@ package body System.Memory is\n    -------------\n \n    function Realloc\n-     (Ptr : System.Address; Size : size_t) return System.Address\n+     (Ptr  : System.Address;\n+      Size : size_t) return System.Address\n    is\n-      Addr : aliased constant System.Address := Ptr;\n-      Result : aliased System.Address;\n+      Addr      : aliased constant System.Address := Ptr;\n+      Result    : aliased System.Address;\n+      Timestamp : aliased Duration;\n \n    begin\n       --  For the purposes of allocations logging, we treat realloc as a free\n@@ -317,11 +346,16 @@ package body System.Memory is\n \n          --  We first log deallocation call\n \n-         Gmem_Initialize;\n+         if Needs_Init then\n+            Gmem_Initialize;\n+         end if;\n          Call_Chain (Tracebk'Address, Max_Call_Stack, Num_Calls,\n                      Skip_Frames => 2);\n+         Timestamp := System.OS_Primitives.Clock;\n          fputc (Character'Pos ('D'), Gmemfile);\n          fwrite (Addr'Address, Address_Size, 1, Gmemfile);\n+         fwrite (Timestamp'Address, Duration'Max_Size_In_Storage_Elements, 1,\n+                 Gmemfile);\n          fwrite (Num_Calls'Address, Integer'Max_Size_In_Storage_Elements, 1,\n                  Gmemfile);\n \n@@ -343,6 +377,8 @@ package body System.Memory is\n          fwrite (Result'Address, Address_Size, 1, Gmemfile);\n          fwrite (Size'Address, size_t'Max_Size_In_Storage_Elements, 1,\n                  Gmemfile);\n+         fwrite (Timestamp'Address, Duration'Max_Size_In_Storage_Elements, 1,\n+                 Gmemfile);\n          fwrite (Num_Calls'Address, Integer'Max_Size_In_Storage_Elements, 1,\n                  Gmemfile);\n "}]}