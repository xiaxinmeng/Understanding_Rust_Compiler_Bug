{"sha": "a668c6adec09839b44d2ae6c1046a2e100e10936", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY2OGM2YWRlYzA5ODM5YjQ0ZDJhZTZjMTA0NmEyZTEwMGUxMDkzNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-12-01T05:58:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-12-01T05:58:23Z"}, "message": "re PR c++/9849 (Missing keyword 'template' produces ICE with no diagnostic on 3.3 (and unreadable diagnostic on 3.4))\n\n\tPR c++/9849\n\t* g++.dg/template/error4.C: New test.\n\t* g++.dg/template/nested3.C: Adjust error markers.\n\n\tPR c++/9849\n\t* parser.c (cp_lexer_prev_token): New function.\n\t(cp_parser_skip_to_closing_parenthesis): Add consume_paren\n\tparameter.\n\t(cp_parser_nested_name_specifier_opt): Add is_declaration\n\tparameter.\n\t(cp_parser_nested_name_specifier): Likewise.\n\t(cp_parser_class_or_namespace_name): Likewise.\n\t(cp_parser_class_name): Likewise.\n\t(cp_parser_template_id): Likewise.\n\t(cp_parser_template_name): Likewise.\n\t(cp_parser_id_expression): Adjust calls to\n\tcp_parser_nested_name_specifier_op, cp_parser_template_id,\n\tcp_parser_class_name.\n\t(cp_parser_unqualified_id): Likewise.\n\t(cp_parser_postfix_expression): Likewise.\n\t(cp_parser_pseudo_destructor_name): Likewise.\n\t(cp_parser_cast_expression): Likewise.\n\t(cp_parser_mem_initializer_id): Likewise.\n\t(cp_parser_simple_type_specifier): Likewise.\n\t(cp_parser_type_name): Likewise.\n\t(cp_parser_elaborated_type_specifier): Likewise.\n\t(cp_parser_qualified_namespace_specifier): Likewise.\n\t(cp_parser_using_declaration): Likewise.\n\t(cp_parser_using_directive): Likewise.\n\t(cp_parser_ptr_operator): Likewise.\n\t(cp_parser_declarator_id): Likewise.\n\t(cp_parser_class_head): Likewise.\n\t(cp_parser_base_specifier): Likewise.\n\t(cp_parser_constructor_declarator_p): Likewise.\n\t(cp_parser_direct_declarator): Fix typo in comment.\n\t(cp_parser_parenthesized_expression_list): Adjust call to\n\tcp_parser_skip_to_closing_parenthesis.\n\t(cp_parser_selection_statement): Likewise.\n\nFrom-SVN: r74087", "tree": {"sha": "c0e649f54f30f187a3ba3a98aa574f4a173e21b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0e649f54f30f187a3ba3a98aa574f4a173e21b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a668c6adec09839b44d2ae6c1046a2e100e10936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a668c6adec09839b44d2ae6c1046a2e100e10936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a668c6adec09839b44d2ae6c1046a2e100e10936", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a668c6adec09839b44d2ae6c1046a2e100e10936/comments", "author": null, "committer": null, "parents": [{"sha": "8786882bd0bb9c3fd89b67342544bd9deae5ec55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8786882bd0bb9c3fd89b67342544bd9deae5ec55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8786882bd0bb9c3fd89b67342544bd9deae5ec55"}], "stats": {"total": 362, "additions": 273, "deletions": 89}, "files": [{"sha": "9686a3650b02d9ca32771f7f5fc4b32d295f6b12", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a668c6adec09839b44d2ae6c1046a2e100e10936", "patch": "@@ -1,3 +1,40 @@\n+2003-11-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9849\n+\t* parser.c (cp_lexer_prev_token): New function.\n+\t(cp_parser_skip_to_closing_parenthesis): Add consume_paren\n+\tparameter.\n+\t(cp_parser_nested_name_specifier_opt): Add is_declaration\n+\tparameter.\n+\t(cp_parser_nested_name_specifier): Likewise.\n+\t(cp_parser_class_or_namespace_name): Likewise.\n+\t(cp_parser_class_name): Likewise.\n+\t(cp_parser_template_id): Likewise.\n+\t(cp_parser_template_name): Likewise.\n+\t(cp_parser_id_expression): Adjust calls to\n+\tcp_parser_nested_name_specifier_op, cp_parser_template_id,\n+\tcp_parser_class_name.\n+\t(cp_parser_unqualified_id): Likewise.\n+\t(cp_parser_postfix_expression): Likewise.\n+\t(cp_parser_pseudo_destructor_name): Likewise.\n+\t(cp_parser_cast_expression): Likewise.\n+\t(cp_parser_mem_initializer_id): Likewise.\n+\t(cp_parser_simple_type_specifier): Likewise.\n+\t(cp_parser_type_name): Likewise.\n+\t(cp_parser_elaborated_type_specifier): Likewise.\n+\t(cp_parser_qualified_namespace_specifier): Likewise.\n+\t(cp_parser_using_declaration): Likewise.\n+\t(cp_parser_using_directive): Likewise.\n+\t(cp_parser_ptr_operator): Likewise.\n+\t(cp_parser_declarator_id): Likewise.\n+\t(cp_parser_class_head): Likewise.\n+\t(cp_parser_base_specifier): Likewise.\n+\t(cp_parser_constructor_declarator_p): Likewise.\n+\t(cp_parser_direct_declarator): Fix typo in comment.\n+\t(cp_parser_parenthesized_expression_list): Adjust call to\n+\tcp_parser_skip_to_closing_parenthesis.\n+\t(cp_parser_selection_statement): Likewise.\n+\n 2003-11-23  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/12924"}, {"sha": "f2f1c5bbcd7eea5799294e23c67230517d1309c0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 218, "deletions": 85, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a668c6adec09839b44d2ae6c1046a2e100e10936", "patch": "@@ -219,6 +219,8 @@ static int cp_lexer_saving_tokens\n   (const cp_lexer *);\n static cp_token *cp_lexer_next_token\n   (cp_lexer *, cp_token *);\n+static cp_token *cp_lexer_prev_token\n+  (cp_lexer *, cp_token *);\n static ptrdiff_t cp_lexer_token_difference \n   (cp_lexer *, cp_token *, cp_token *);\n static cp_token *cp_lexer_read_token\n@@ -419,6 +421,17 @@ cp_lexer_next_token (cp_lexer* lexer, cp_token* token)\n   return token;\n }\n \n+/* TOKEN points into the circular token buffer.  Return a pointer to\n+   the previous token in the buffer.  */\n+\n+static inline cp_token *\n+cp_lexer_prev_token (cp_lexer* lexer, cp_token* token)\n+{\n+  if (token == lexer->buffer)\n+    token = lexer->buffer_end;\n+  return token - 1;\n+}\n+\n /* nonzero if we are presently saving tokens.  */\n \n static int\n@@ -1309,11 +1322,11 @@ static tree cp_parser_id_expression\n static tree cp_parser_unqualified_id\n   (cp_parser *, bool, bool, bool);\n static tree cp_parser_nested_name_specifier_opt\n-  (cp_parser *, bool, bool, bool);\n+  (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_nested_name_specifier\n-  (cp_parser *, bool, bool, bool);\n-static tree cp_parser_class_or_namespace_name\n   (cp_parser *, bool, bool, bool, bool);\n+static tree cp_parser_class_or_namespace_name\n+  (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_postfix_expression\n   (cp_parser *, bool);\n static tree cp_parser_parenthesized_expression_list\n@@ -1495,7 +1508,7 @@ static bool cp_parser_ctor_initializer_opt_and_function_body\n /* Classes [gram.class] */\n \n static tree cp_parser_class_name\n-  (cp_parser *, bool, bool, bool, bool, bool);\n+  (cp_parser *, bool, bool, bool, bool, bool, bool);\n static tree cp_parser_class_specifier\n   (cp_parser *);\n static tree cp_parser_class_head\n@@ -1553,9 +1566,9 @@ static tree cp_parser_template_parameter\n static tree cp_parser_type_parameter\n   (cp_parser *);\n static tree cp_parser_template_id\n-  (cp_parser *, bool, bool);\n+  (cp_parser *, bool, bool, bool);\n static tree cp_parser_template_name\n-  (cp_parser *, bool, bool);\n+  (cp_parser *, bool, bool, bool, bool *);\n static tree cp_parser_template_argument_list\n   (cp_parser *);\n static tree cp_parser_template_argument\n@@ -1694,7 +1707,7 @@ static tree cp_parser_non_constant_expression\n static bool cp_parser_diagnose_invalid_type_name\n   (cp_parser *);\n static int cp_parser_skip_to_closing_parenthesis\n-  (cp_parser *, bool, bool);\n+  (cp_parser *, bool, bool, bool);\n static void cp_parser_skip_to_end_of_statement\n   (cp_parser *);\n static void cp_parser_consume_semicolon_at_end_of_statement\n@@ -1890,7 +1903,9 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser)\n \n static int\n cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n-\t\t\t\t       bool recovering, bool or_comma)\n+\t\t\t\t       bool recovering, \n+\t\t\t\t       bool or_comma,\n+\t\t\t\t       bool consume_paren)\n {\n   unsigned paren_depth = 0;\n   unsigned brace_depth = 0;\n@@ -1907,37 +1922,38 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n       if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n \treturn 0;\n \n-      if (recovering)\n+      token = cp_lexer_peek_token (parser->lexer);\n+      \n+      /* This matches the processing in skip_to_end_of_statement */\n+      if (token->type == CPP_SEMICOLON && !brace_depth)\n+\treturn 0;\n+      if (token->type == CPP_OPEN_BRACE)\n+\t++brace_depth;\n+      if (token->type == CPP_CLOSE_BRACE)\n \t{\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\n-\t  /* This matches the processing in skip_to_end_of_statement */\n-\t  if (token->type == CPP_SEMICOLON && !brace_depth)\n+\t  if (!brace_depth--)\n \t    return 0;\n-\t  if (token->type == CPP_OPEN_BRACE)\n-\t    ++brace_depth;\n-\t  if (token->type == CPP_CLOSE_BRACE)\n-\t    {\n-\t      if (!brace_depth--)\n-\t\treturn 0;\n-\t    }\n-\t  if (or_comma && token->type == CPP_COMMA\n-\t      && !brace_depth && !paren_depth)\n-\t    return -1;\n \t}\n+      if (recovering && or_comma && token->type == CPP_COMMA\n+\t  && !brace_depth && !paren_depth)\n+\treturn -1;\n       \n-      /* Consume the token.  */\n-      token = cp_lexer_consume_token (parser->lexer);\n-\n       if (!brace_depth)\n \t{\n \t  /* If it is an `(', we have entered another level of nesting.  */\n \t  if (token->type == CPP_OPEN_PAREN)\n \t    ++paren_depth;\n \t  /* If it is a `)', then we might be done.  */\n \t  else if (token->type == CPP_CLOSE_PAREN && !paren_depth--)\n-\t    return 1;\n+\t    {\n+\t      if (consume_paren)\n+\t\tcp_lexer_consume_token (parser->lexer);\n+\t      return 1;\n+\t    }\n \t}\n+      \n+      /* Consume the token.  */\n+      cp_lexer_consume_token (parser->lexer);\n     }\n }\n \n@@ -2543,7 +2559,8 @@ cp_parser_id_expression (cp_parser *parser,\n     = (cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t    /*typename_keyword_p=*/false,\n \t\t\t\t\t    check_dependency_p,\n-\t\t\t\t\t    /*type_p=*/false)\n+\t\t\t\t\t    /*type_p=*/false,\n+\t\t\t\t\t    /*is_declarator=*/false)\n        != NULL_TREE);\n   /* If there is a nested-name-specifier, then we are looking at\n      the first qualified-id production.  */\n@@ -2596,7 +2613,8 @@ cp_parser_id_expression (cp_parser *parser,\n       /* Try a template-id.  */\n       id = cp_parser_template_id (parser, \n \t\t\t\t  /*template_keyword_p=*/false,\n-\t\t\t\t  /*check_dependency_p=*/true);\n+\t\t\t\t  /*check_dependency_p=*/true,\n+\t\t\t\t  declarator_p);\n       /* If that worked, we're done.  */\n       if (cp_parser_parse_definitely (parser))\n \treturn id;\n@@ -2670,7 +2688,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \tcp_parser_parse_tentatively (parser);\n \t/* Try a template-id.  */\n \tid = cp_parser_template_id (parser, template_keyword_p,\n-\t\t\t\t    check_dependency_p);\n+\t\t\t\t    check_dependency_p,\n+\t\t\t\t    declarator_p);\n \t/* If it worked, we're done.  */\n \tif (cp_parser_parse_definitely (parser))\n \t  return id;\n@@ -2680,7 +2699,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \n     case CPP_TEMPLATE_ID:\n       return cp_parser_template_id (parser, template_keyword_p,\n-\t\t\t\t    check_dependency_p);\n+\t\t\t\t    check_dependency_p,\n+\t\t\t\t    declarator_p);\n \n     case CPP_COMPL:\n       {\n@@ -2752,7 +2772,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t\t      /*type_p=*/false,\n \t\t\t\t\t      /*check_dependency=*/false,\n-\t\t\t\t\t      /*class_head_p=*/false);\n+\t\t\t\t\t      /*class_head_p=*/false,\n+\t\t\t\t\t      declarator_p);\n \t    if (cp_parser_parse_definitely (parser))\n \t      return build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n \t  }\n@@ -2769,7 +2790,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t      /*type_p=*/false,\n \t\t\t\t      /*check_dependency=*/false,\n-\t\t\t\t      /*class_head_p=*/false);\n+\t\t\t\t      /*class_head_p=*/false,\n+\t\t\t\t      declarator_p);\n \t    if (cp_parser_parse_definitely (parser))\n \t      return build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n \t  }\n@@ -2786,7 +2808,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t      /*type_p=*/false,\n \t\t\t\t      /*check_dependency=*/false,\n-\t\t\t\t      /*class_head_p=*/false);\n+\t\t\t\t      /*class_head_p=*/false,\n+\t\t\t\t      declarator_p);\n \t    if (cp_parser_parse_definitely (parser))\n \t      return build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n \t  }\n@@ -2800,7 +2823,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t  /*template_keyword_p=*/false,\n \t\t\t\t  /*type_p=*/false,\n \t\t\t\t  /*check_dependency=*/false,\n-\t\t\t\t  /*class_head_p=*/false);\n+\t\t\t\t  /*class_head_p=*/false,\n+\t\t\t\t  declarator_p);\n \t/* If an error occurred, assume that the name of the\n \t   destructor is the same as the name of the qualifying\n \t   class.  That allows us to keep parsing after running\n@@ -2832,7 +2856,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t  cp_parser_parse_tentatively (parser);\n \t  /* Try a template-id.  */\n \t  id = cp_parser_template_id (parser, template_keyword_p,\n-\t\t\t\t      /*check_dependency_p=*/true);\n+\t\t\t\t      /*check_dependency_p=*/true,\n+\t\t\t\t      declarator_p);\n \t  /* If that worked, we're done.  */\n \t  if (cp_parser_parse_definitely (parser))\n \t    return id;\n@@ -2869,13 +2894,17 @@ cp_parser_unqualified_id (cp_parser* parser,\n    Sets PARSER->SCOPE to the class (TYPE) or namespace\n    (NAMESPACE_DECL) specified by the nested-name-specifier, or leaves\n    it unchanged if there is no nested-name-specifier.  Returns the new\n-   scope iff there is a nested-name-specifier, or NULL_TREE otherwise.  */\n+   scope iff there is a nested-name-specifier, or NULL_TREE otherwise.  \n+\n+   If IS_DECLARATION is TRUE, the nested-name-specifier is known to be\n+   part of a declaration and/or decl-specifier.  */\n \n static tree\n cp_parser_nested_name_specifier_opt (cp_parser *parser, \n \t\t\t\t     bool typename_keyword_p, \n \t\t\t\t     bool check_dependency_p,\n-\t\t\t\t     bool type_p)\n+\t\t\t\t     bool type_p,\n+\t\t\t\t     bool is_declaration)\n {\n   bool success = false;\n   tree access_check = NULL_TREE;\n@@ -2974,7 +3003,8 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\t\t\t     typename_keyword_p,\n \t\t\t\t\t     template_keyword_p,\n \t\t\t\t\t     check_dependency_p,\n-\t\t\t\t\t     type_p);\n+\t\t\t\t\t     type_p,\n+\t\t\t\t\t     is_declaration);\n       /* Look for the `::' token.  */\n       cp_parser_require (parser, CPP_SCOPE, \"`::'\");\n \n@@ -3101,15 +3131,17 @@ static tree\n cp_parser_nested_name_specifier (cp_parser *parser, \n \t\t\t\t bool typename_keyword_p, \n \t\t\t\t bool check_dependency_p,\n-\t\t\t\t bool type_p)\n+\t\t\t\t bool type_p,\n+\t\t\t\t bool is_declaration)\n {\n   tree scope;\n \n   /* Look for the nested-name-specifier.  */\n   scope = cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t       typename_keyword_p,\n \t\t\t\t\t       check_dependency_p,\n-\t\t\t\t\t       type_p);\n+\t\t\t\t\t       type_p,\n+\t\t\t\t\t       is_declaration);\n   /* If it was not present, issue an error message.  */\n   if (!scope)\n     {\n@@ -3143,7 +3175,8 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n \t\t\t\t   bool typename_keyword_p,\n \t\t\t\t   bool template_keyword_p,\n \t\t\t\t   bool check_dependency_p,\n-\t\t\t\t   bool type_p)\n+\t\t\t\t   bool type_p,\n+\t\t\t\t   bool is_declaration)\n {\n   tree saved_scope;\n   tree saved_qualifying_scope;\n@@ -3167,7 +3200,8 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n \t\t\t\ttemplate_keyword_p,\n \t\t\t\ttype_p,\n \t\t\t\tcheck_dependency_p,\n-\t\t\t\t/*class_head_p=*/false);\n+\t\t\t\t/*class_head_p=*/false,\n+\t\t\t\tis_declaration);\n   /* If that didn't work, try for a namespace-name.  */\n   if (!only_class_p && !cp_parser_parse_definitely (parser))\n     {\n@@ -3372,15 +3406,17 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \tcp_parser_nested_name_specifier (parser,\n \t\t\t\t\t /*typename_keyword_p=*/true,\n \t\t\t\t\t /*check_dependency_p=*/true,\n-\t\t\t\t\t /*type_p=*/true);\n+\t\t\t\t\t /*type_p=*/true,\n+\t\t\t\t\t /*is_declaration=*/true);\n \t/* Look for the optional `template' keyword.  */\n \ttemplate_p = cp_parser_optional_template_keyword (parser);\n \t/* We don't know whether we're looking at a template-id or an\n \t   identifier.  */\n \tcp_parser_parse_tentatively (parser);\n \t/* Try a template-id.  */\n \tid = cp_parser_template_id (parser, template_p,\n-\t\t\t\t    /*check_dependency_p=*/true);\n+\t\t\t\t    /*check_dependency_p=*/true,\n+\t\t\t\t    /*is_declaration=*/true);\n \t/* If that didn't work, try an identifier.  */\n \tif (!cp_parser_parse_definitely (parser))\n \t  id = cp_parser_identifier (parser);\n@@ -3872,7 +3908,8 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n     skip_comma:;\n       /* We try and resync to an unnested comma, as that will give the\n \t user better diagnostics.  */\n-      ending = cp_parser_skip_to_closing_parenthesis (parser, true, true);\n+      ending = cp_parser_skip_to_closing_parenthesis (parser, true, true,\n+\t\t\t\t\t\t      /*consume_paren=*/true);\n       if (ending < 0)\n \tgoto get_comma;\n       if (!ending)\n@@ -3913,7 +3950,8 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n     = (cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t    /*typename_keyword_p=*/false,\n \t\t\t\t\t    /*check_dependency_p=*/true,\n-\t\t\t\t\t    /*type_p=*/false) \n+\t\t\t\t\t    /*type_p=*/false,\n+\t\t\t\t\t    /*is_declaration=*/true) \n        != NULL_TREE);\n   /* Now, if we saw a nested-name-specifier, we might be doing the\n      second production.  */\n@@ -3925,7 +3963,8 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n       /* Parse the template-id.  */\n       cp_parser_template_id (parser, \n \t\t\t     /*template_keyword_p=*/true,\n-\t\t\t     /*check_dependency_p=*/false);\n+\t\t\t     /*check_dependency_p=*/false,\n+\t\t\t     /*is_declaration=*/true);\n       /* Look for the `::' token.  */\n       cp_parser_require (parser, CPP_SCOPE, \"`::'\");\n     }\n@@ -4503,7 +4542,8 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n \t If we find the closing `)', and the next token is a `{', then\n \t we are looking at a compound-literal.  */\n       compound_literal_p \n-\t= (cp_parser_skip_to_closing_parenthesis (parser, false, false)\n+\t= (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n+\t\t\t\t\t\t  /*consume_paren=*/true)\n \t   && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE));\n       /* Roll back the tokens we skipped.  */\n       cp_lexer_rollback_tokens (parser->lexer);\n@@ -5430,7 +5470,8 @@ cp_parser_selection_statement (cp_parser* parser)\n \tcondition = cp_parser_condition (parser);\n \t/* Look for the `)'.  */\n \tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n-\t  cp_parser_skip_to_closing_parenthesis (parser, true, false);\n+\t  cp_parser_skip_to_closing_parenthesis (parser, true, false,\n+\t\t\t\t\t\t /*consume_paren=*/true);\n \n \tif (keyword == RID_IF)\n \t  {\n@@ -6924,7 +6965,8 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n     = (cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t    /*typename_keyword_p=*/true,\n \t\t\t\t\t    /*check_dependency_p=*/true,\n-\t\t\t\t\t    /*type_p=*/true)\n+\t\t\t\t\t    /*type_p=*/true,\n+\t\t\t\t\t    /*is_declaration=*/true)\n        != NULL_TREE);\n   /* If there is a `::' operator or a nested-name-specifier, then we\n      are definitely looking for a class-name.  */\n@@ -6934,7 +6976,8 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n \t\t\t\t /*template_keyword_p=*/false,\n \t\t\t\t /*type_p=*/false,\n \t\t\t\t /*check_dependency_p=*/true,\n-\t\t\t\t /*class_head_p=*/false);\n+\t\t\t\t /*class_head_p=*/false,\n+\t\t\t\t /*is_declaration=*/true);\n   /* Otherwise, we could also be looking for an ordinary identifier.  */\n   cp_parser_parse_tentatively (parser);\n   /* Try a class-name.  */\n@@ -6943,7 +6986,8 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n \t\t\t     /*template_keyword_p=*/false,\n \t\t\t     /*type_p=*/false,\n \t\t\t     /*check_dependency_p=*/true,\n-\t\t\t     /*class_head_p=*/false);\n+\t\t\t     /*class_head_p=*/false,\n+\t\t\t     /*is_declaration=*/true);\n   /* If we found one, we're done.  */\n   if (cp_parser_parse_definitely (parser))\n     return id;\n@@ -7507,14 +7551,16 @@ cp_parser_type_parameter (cp_parser* parser)\n static tree\n cp_parser_template_id (cp_parser *parser, \n \t\t       bool template_keyword_p, \n-\t\t       bool check_dependency_p)\n+\t\t       bool check_dependency_p,\n+\t\t       bool is_declaration)\n {\n   tree template;\n   tree arguments;\n   tree template_id;\n   ptrdiff_t start_of_id;\n   tree access_check = NULL_TREE;\n   cp_token *next_token;\n+  bool is_identifier;\n \n   /* If the next token corresponds to a template-id, there is no need\n      to reparse it.  */\n@@ -7559,12 +7605,15 @@ cp_parser_template_id (cp_parser *parser,\n   push_deferring_access_checks (dk_deferred);\n \n   /* Parse the template-name.  */\n+  is_identifier = false;\n   template = cp_parser_template_name (parser, template_keyword_p,\n-\t\t\t\t      check_dependency_p);\n-  if (template == error_mark_node)\n+\t\t\t\t      check_dependency_p,\n+\t\t\t\t      is_declaration,\n+\t\t\t\t      &is_identifier);\n+  if (template == error_mark_node || is_identifier)\n     {\n       pop_deferring_access_checks ();\n-      return error_mark_node;\n+      return template;\n     }\n \n   /* Look for the `<' that starts the template-argument-list.  */\n@@ -7661,7 +7710,9 @@ cp_parser_template_id (cp_parser *parser,\n static tree\n cp_parser_template_name (cp_parser* parser, \n                          bool template_keyword_p, \n-                         bool check_dependency_p)\n+                         bool check_dependency_p,\n+\t\t\t bool is_declaration,\n+\t\t\t bool *is_identifier)\n {\n   tree identifier;\n   tree decl;\n@@ -7699,9 +7750,70 @@ cp_parser_template_name (cp_parser* parser,\n \n      correctly.  We would treat `S' as a template -- if it were `S<T>'\n      -- but we do not if there is no `<'.  */\n-  if (template_keyword_p && processing_template_decl\n+\n+  if (processing_template_decl\n       && cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n-    return identifier;\n+    {\n+      /* In a declaration, in a dependent context, we pretend that the\n+\t \"template\" keyword was present in order to improve error\n+\t recovery.  For example, given:\n+\t \n+\t   template <typename T> void f(T::X<int>);\n+\t \n+\t we want to treat \"X<int>\" as a template-id.  */\n+      if (is_declaration \n+\t  && !template_keyword_p \n+\t  && parser->scope && TYPE_P (parser->scope)\n+\t  && dependent_type_p (parser->scope))\n+\t{\n+\t  ptrdiff_t start;\n+\t  cp_token* token;\n+\t  /* Explain what went wrong.  */\n+\t  error (\"non-template `%D' used as template\", identifier);\n+\t  error (\"(use `%T::template %D' to indicate that it is a template)\",\n+\t\t parser->scope, identifier);\n+\t  /* If parsing tentatively, find the location of the \"<\"\n+\t     token.  */\n+\t  if (cp_parser_parsing_tentatively (parser)\n+\t      && !cp_parser_committed_to_tentative_parse (parser))\n+\t    {\n+\t      cp_parser_simulate_error (parser);\n+\t      token = cp_lexer_peek_token (parser->lexer);\n+\t      token = cp_lexer_prev_token (parser->lexer, token);\n+\t      start = cp_lexer_token_difference (parser->lexer,\n+\t\t\t\t\t\t parser->lexer->first_token,\n+\t\t\t\t\t\t token);\n+\t    }\n+\t  else\n+\t    start = -1;\n+\t  /* Parse the template arguments so that we can issue error\n+\t     messages about them.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_enclosed_template_argument_list (parser);\n+\t  /* Skip tokens until we find a good place from which to\n+\t     continue parsing.  */\n+\t  cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t /*recovering=*/true,\n+\t\t\t\t\t\t /*or_comma=*/true,\n+\t\t\t\t\t\t /*consume_paren=*/false);\n+\t  /* If parsing tentatively, permanently remove the\n+\t     template argument list.  That will prevent duplicate\n+\t     error messages from being issued about the missing\n+\t     \"template\" keyword.  */\n+\t  if (start >= 0)\n+\t    {\n+\t      token = cp_lexer_advance_token (parser->lexer,\n+\t\t\t\t\t      parser->lexer->first_token,\n+\t\t\t\t\t      start);\n+\t      cp_lexer_purge_tokens_after (parser->lexer, token);\n+\t    }\n+\t  if (is_identifier)\n+\t    *is_identifier = true;\n+\t  return identifier;\n+\t}\n+      if (template_keyword_p)\n+\treturn identifier;\n+    }\n \n   /* Look up the name.  */\n   decl = cp_parser_lookup_name (parser, identifier,\n@@ -8364,7 +8476,8 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n       cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t   /*typename_keyword_p=*/false,\n \t\t\t\t\t   /*check_dependency_p=*/true,\n-\t\t\t\t\t   /*type_p=*/false);\n+\t\t\t\t\t   /*type_p=*/false,\n+\t\t\t\t\t   /*is_declaration=*/false);\n       /* If we have seen a nested-name-specifier, and the next token\n \t is `template', then we are using the template-id production.  */\n       if (parser->scope \n@@ -8373,7 +8486,8 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n \t  /* Look for the template-id.  */\n \t  type = cp_parser_template_id (parser, \n \t\t\t\t\t/*template_keyword_p=*/true,\n-\t\t\t\t\t/*check_dependency_p=*/true);\n+\t\t\t\t\t/*check_dependency_p=*/true,\n+\t\t\t\t\t/*is_declaration=*/false);\n \t  /* If the template-id did not name a type, we are out of\n \t     luck.  */\n \t  if (TREE_CODE (type) != TYPE_DECL)\n@@ -8403,9 +8517,9 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n       return error_mark_node;\n     }\n \n-  /* There is no valid C++ program where a non-template type can never\n-     be followed by a \"<\".  That usually indicates that the user\n-     thought that the type was a template.  */\n+  /* There is no valid C++ program where a non-template type is\n+     followed by a \"<\".  That usually indicates that the user thought\n+     that the type was a template.  */\n   if (type && cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n     {\n       error (\"`%T' is not a template\", TREE_TYPE (type));\n@@ -8450,7 +8564,8 @@ cp_parser_type_name (cp_parser* parser)\n \t\t\t\t    /*template_keyword_p=*/false,\n \t\t\t\t    /*type_p=*/false,\n \t\t\t\t    /*check_dependency_p=*/true,\n-\t\t\t\t    /*class_head_p=*/false);\n+\t\t\t\t    /*class_head_p=*/false,\n+\t\t\t\t    /*is_declaration=*/false);\n   /* If it's not a class-name, keep looking.  */\n   if (!cp_parser_parse_definitely (parser))\n     {\n@@ -8544,7 +8659,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       if (cp_parser_nested_name_specifier (parser,\n \t\t\t\t\t   /*typename_keyword_p=*/true,\n \t\t\t\t\t   /*check_dependency_p=*/true,\n-\t\t\t\t\t   /*type_p=*/true) \n+\t\t\t\t\t   /*type_p=*/true,\n+\t\t\t\t\t   is_declaration) \n \t  == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -8555,7 +8671,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n     cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t /*typename_keyword_p=*/true,\n \t\t\t\t\t /*check_dependency_p=*/true,\n-\t\t\t\t\t /*type_p=*/true);\n+\t\t\t\t\t /*type_p=*/true,\n+\t\t\t\t\t is_declaration);\n   /* For everything but enumeration types, consider a template-id.  */\n   if (tag_type != enum_type)\n     {\n@@ -8570,7 +8687,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \tcp_parser_parse_tentatively (parser);\n       /* Parse the template-id.  */\n       decl = cp_parser_template_id (parser, template_p,\n-\t\t\t\t    /*check_dependency_p=*/true);\n+\t\t\t\t    /*check_dependency_p=*/true,\n+\t\t\t\t    is_declaration);\n       /* If we didn't find a template-id, look for an ordinary\n          identifier.  */\n       if (!template_p && !cp_parser_parse_definitely (parser))\n@@ -8998,7 +9116,8 @@ cp_parser_qualified_namespace_specifier (cp_parser* parser)\n   cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t       /*typename_keyword_p=*/false,\n \t\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t\t       /*type_p=*/false);\n+\t\t\t\t       /*type_p=*/false,\n+\t\t\t\t       /*is_declaration=*/true);\n \n   return cp_parser_namespace_name (parser);\n }\n@@ -9044,14 +9163,16 @@ cp_parser_using_declaration (cp_parser* parser)\n   if (typename_p || !global_scope_p)\n     cp_parser_nested_name_specifier (parser, typename_p, \n \t\t\t\t     /*check_dependency_p=*/true,\n-\t\t\t\t     /*type_p=*/false);\n+\t\t\t\t     /*type_p=*/false,\n+\t\t\t\t     /*is_declaration=*/true);\n   /* Otherwise, we could be in either of the two productions.  In that\n      case, treat the nested-name-specifier as optional.  */\n   else\n     cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t /*typename_keyword_p=*/false,\n \t\t\t\t\t /*check_dependency_p=*/true,\n-\t\t\t\t\t /*type_p=*/false);\n+\t\t\t\t\t /*type_p=*/false,\n+\t\t\t\t\t /*is_declaration=*/true);\n \n   /* Parse the unqualified-id.  */\n   identifier = cp_parser_unqualified_id (parser, \n@@ -9125,7 +9246,8 @@ cp_parser_using_directive (cp_parser* parser)\n   cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t       /*typename_keyword_p=*/false,\n \t\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t\t       /*type_p=*/false);\n+\t\t\t\t       /*type_p=*/false,\n+\t\t\t\t       /*is_declaration=*/true);\n   /* Get the namespace being used.  */\n   namespace_decl = cp_parser_namespace_name (parser);\n   /* And any specified attributes.  */\n@@ -9257,7 +9379,8 @@ cp_parser_asm_definition (cp_parser* parser)\n     }\n   /* Look for the closing `)'.  */\n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n-    cp_parser_skip_to_closing_parenthesis (parser, true, false);\n+    cp_parser_skip_to_closing_parenthesis (parser, true, false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n   cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n \n   /* Create the ASM_STMT.  */\n@@ -9891,7 +10014,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t}\n       else if (first && dcl_kind != CP_PARSER_DECLARATOR_ABSTRACT)\n \t{\n-\t  /* Parse a declarator_id */\n+\t  /* Parse a declarator-id */\n \t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n \t    cp_parser_parse_tentatively (parser);\n \t  declarator = cp_parser_declarator_id (parser);\n@@ -10078,7 +10201,8 @@ cp_parser_ptr_operator (cp_parser* parser,\n       cp_parser_nested_name_specifier (parser,\n \t\t\t\t       /*typename_keyword_p=*/false,\n \t\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t\t       /*type_p=*/false);\n+\t\t\t\t       /*type_p=*/false,\n+\t\t\t\t       /*is_declaration=*/false);\n       /* If we found it, and the next token is a `*', then we are\n \t indeed looking at a pointer-to-member operator.  */\n       if (!cp_parser_error_occurred (parser)\n@@ -11123,7 +11247,8 @@ cp_parser_class_name (cp_parser *parser,\n \t\t      bool template_keyword_p, \n \t\t      bool type_p,\n \t\t      bool check_dependency_p,\n-\t\t      bool class_head_p)\n+\t\t      bool class_head_p,\n+\t\t      bool is_declaration)\n {\n   tree decl;\n   tree scope;\n@@ -11188,7 +11313,8 @@ cp_parser_class_name (cp_parser *parser,\n     {\n       /* Try a template-id.  */\n       decl = cp_parser_template_id (parser, template_keyword_p,\n-\t\t\t\t    check_dependency_p);\n+\t\t\t\t    check_dependency_p,\n+\t\t\t\t    is_declaration);\n       if (decl == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -11448,7 +11574,8 @@ cp_parser_class_head (cp_parser* parser,\n     = cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t   /*typename_keyword_p=*/false,\n \t\t\t\t\t   /*check_dependency_p=*/false,\n-\t\t\t\t\t   /*type_p=*/false);\n+\t\t\t\t\t   /*type_p=*/false,\n+\t\t\t\t\t   /*is_declaration=*/false);\n   /* If there was a nested-name-specifier, then there *must* be an\n      identifier.  */\n   if (nested_name_specifier)\n@@ -11476,7 +11603,8 @@ cp_parser_class_head (cp_parser* parser,\n \t\t\t\t   /*template_keyword_p=*/false,\n \t\t\t\t   /*type_p=*/true,\n \t\t\t\t   /*check_dependency_p=*/false,\n-\t\t\t\t   /*class_head_p=*/true);\n+\t\t\t\t   /*class_head_p=*/true,\n+\t\t\t\t   /*is_declaration=*/false);\n       /* If that didn't work, ignore the nested-name-specifier.  */\n       if (!cp_parser_parse_definitely (parser))\n \t{\n@@ -11517,7 +11645,8 @@ cp_parser_class_head (cp_parser* parser,\n       /* Check for a template-id.  */\n       id = cp_parser_template_id (parser, \n \t\t\t\t  /*template_keyword_p=*/false,\n-\t\t\t\t  /*check_dependency_p=*/true);\n+\t\t\t\t  /*check_dependency_p=*/true,\n+\t\t\t\t  /*is_declaration=*/true);\n       /* If that didn't work, it could still be an identifier.  */\n       if (!cp_parser_parse_definitely (parser))\n \t{\n@@ -12338,7 +12467,8 @@ cp_parser_base_specifier (cp_parser* parser)\n   cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t       /*typename_keyword_p=*/true,\n \t\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t\t       /*type_p=*/true);\n+\t\t\t\t       /*type_p=*/true,\n+\t\t\t\t       /*is_declaration=*/true);\n   /* If the base class is given by a qualified name, assume that names\n      we see are type names or templates, as appropriate.  */\n   class_scope_p = (parser->scope && TYPE_P (parser->scope));\n@@ -12350,7 +12480,8 @@ cp_parser_base_specifier (cp_parser* parser)\n \t\t\t       template_p,\n \t\t\t       /*type_p=*/true,\n \t\t\t       /*check_dependency_p=*/true,\n-\t\t\t       /*class_head_p=*/false);\n+\t\t\t       /*class_head_p=*/false,\n+\t\t\t       /*is_declaration=*/true);\n \n   if (type == error_mark_node)\n     return error_mark_node;\n@@ -13441,7 +13572,8 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n     = (cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t    /*typename_keyword_p=*/false,\n \t\t\t\t\t    /*check_dependency_p=*/false,\n-\t\t\t\t\t    /*type_p=*/false)\n+\t\t\t\t\t    /*type_p=*/false,\n+\t\t\t\t\t    /*is_declaration=*/false)\n        != NULL_TREE);\n   /* Outside of a class-specifier, there must be a\n      nested-name-specifier.  */\n@@ -13469,7 +13601,8 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t\t\t\t\t/*template_keyword_p=*/false,\n \t\t\t\t\t/*type_p=*/false,\n \t\t\t\t\t/*check_dependency_p=*/false,\n-\t\t\t\t\t/*class_head_p=*/false);\n+\t\t\t\t\t/*class_head_p=*/false,\n+\t\t\t\t\t/*is_declaration=*/false);\n       /* If there was no class-name, then this is not a constructor.  */\n       constructor_p = !cp_parser_error_occurred (parser);\n     }"}, {"sha": "10d1d8e67d9b2261fe4c8259fd562a447b720a6d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a668c6adec09839b44d2ae6c1046a2e100e10936", "patch": "@@ -1,3 +1,9 @@\n+2003-11-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9849\n+\t* g++.dg/template/error4.C: New test.\n+\t* g++.dg/template/nested3.C: Adjust error markers.\n+\n 2003-11-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/cpp/assert4.c: Check more #system assertions."}, {"sha": "a3196ee8e778620b6c57932b2d87007d91d3496f", "filename": "gcc/testsuite/g++.dg/template/error4.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror4.C?ref=a668c6adec09839b44d2ae6c1046a2e100e10936", "patch": "@@ -0,0 +1,8 @@\n+template<class T> struct C1\n+{\n+  template<class U> struct C2\n+  { class Type { }; };\n+};\n+\n+template<class T, class U>\n+void foo(typename C1<T>::C2<U>::Type *) { } // { dg-error \"template\" }"}, {"sha": "0094783166a6845efc714684ec681e6b740fdc58", "filename": "gcc/testsuite/g++.dg/template/nested3.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnested3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668c6adec09839b44d2ae6c1046a2e100e10936/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnested3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnested3.C?ref=a668c6adec09839b44d2ae6c1046a2e100e10936", "patch": "@@ -5,13 +5,13 @@ class A {\n     int _k;\n   };\n   T1 _t1;\n-  T2 _t2;\n+  T2 _t2; // { dg-error \"instantiated\" }\n };\n \n template <class U>\n-class B {\n+class B { // { dg-error \"\" }\n   class SubB1 {\n-    B _i;\n+    B _i; // { dg-error \"\" }\n   };\n \n   class SubB2 {\n@@ -22,7 +22,7 @@ class B {\n \n \n int main() {\n-  B<char> objB;\n+  B<char> objB; // { dg-error \"instantiated\" }\n \n   return 0;\n }"}]}