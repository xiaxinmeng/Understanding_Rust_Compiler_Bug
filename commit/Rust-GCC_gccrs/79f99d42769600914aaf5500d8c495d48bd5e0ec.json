{"sha": "79f99d42769600914aaf5500d8c495d48bd5e0ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlmOTlkNDI3Njk2MDA5MTRhYWY1NTAwZDhjNDk1ZDQ4YmQ1ZTBlYw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2006-12-18T16:21:08Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2006-12-18T16:21:08Z"}, "message": "Add memory reuse to virtual operands in the operand scanner.\n\n\n2006-12-18  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* tree-ssa-operands.h (struct vdef_optype_d): Rename to voptype_d.\n\t(struct vuse_optype_d): Delete.\n\t(SSA_OPERAND_MEMORY_SIZE): Delete.\n\t(struct ssa_operand_memory_d): Change mem array to size one.\n\t(NUM_VOP_FREE_BUCKETS): Define.\n\t(free_vuses, free_vdefs): Replace with vop_free_buckets array.\n\t(vdef_ops, vuse_ops, struct ssa_operand_iterator_d): Use voptype_d type.\n\t* tree-pretty-print.c (dump_vops): Use voptype_d type.\n\t* tree-ssa-operands.c (vop_free_bucket_size): New.  Number of operands\n\twhich fit into a chunk of memory from a specific bucket.\n\t(vop_free_bucket_index): New.  Find correct size memory bucket.\n\t(init_vop_buckets): New.  Initialize VOP free memory buckets.\n\t(add_vop_to_freelist): New.  Add a VOP to the correct free list.\n\t(ssa_operand_mem_size): New.  Current size of an operand memory chunk.\n\t(init_ssa_operands): Initialize operand memory and free lists.\n\t(fini_ssa_operands): Remove references to free_vuses and free_vdefs.\n\t(ssa_operand_alloc): Use graduated size memory allocation.\n\t(APPEND_OP_AFTER, MOVE_HEAD_AFTER, MOVE_HEAD_TO_FREELIST, \n\tINITIALIZE_USE): Remove.\n\t(alloc_vop): New.  Allocate a virtual operand.\n\t(alloc_vdef, alloc_vuse): Delete.\n\t(add_def_op, add_use_op): Directly setup pointers.\n\t(add_vop): New.  Add a virtual operand.\n\t(add_vuse_op, add_vdef_op): Call add_vop.\n\t(realloc_vop): New.  Reallocate a virtual operand.\n\t(realloc_vdef, realloc_vuse): Call realloc_vop.\n\t(finalize_ssa_def_ops): Delete.  Move content to finalize_ssa_defs.\n\t(finalize_ssa_defs): Optimize for common case, remove code based on\n\tsorted pointers which was a waste of time.\n\t(finalize_ssa_use_ops): Delete.  Move content to finalize_ssa_uses.\n\t(finalize_ssa_uses): Update last pointer.\n\t(finalize_ssa_vdef_ops): Delete.  Move content to finalize_ssa_vdefs.\n\t(finalize_ssa_vdefs, finalize_ssa_vuse_ops): Use voptype_d and\n\tdirectly manipulate pointers.\n\t(copy_virtual_operands): Use voptype_d, and no need to update pointers.\n\nFrom-SVN: r120009", "tree": {"sha": "84b63c6bdefa887d08218dba3084880c6484eaaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84b63c6bdefa887d08218dba3084880c6484eaaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79f99d42769600914aaf5500d8c495d48bd5e0ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f99d42769600914aaf5500d8c495d48bd5e0ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f99d42769600914aaf5500d8c495d48bd5e0ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f99d42769600914aaf5500d8c495d48bd5e0ec/comments", "author": null, "committer": null, "parents": [{"sha": "85bf4c61f4de13ab1e6019c4c3883336f5054cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85bf4c61f4de13ab1e6019c4c3883336f5054cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85bf4c61f4de13ab1e6019c4c3883336f5054cdd"}], "stats": {"total": 662, "additions": 345, "deletions": 317}, "files": [{"sha": "e9a397ea476f49098ffa8282aa0972f603fa9a5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f99d42769600914aaf5500d8c495d48bd5e0ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f99d42769600914aaf5500d8c495d48bd5e0ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79f99d42769600914aaf5500d8c495d48bd5e0ec", "patch": "@@ -1,3 +1,41 @@\n+2006-12-18  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-ssa-operands.h (struct vdef_optype_d): Rename to voptype_d.\n+\t(struct vuse_optype_d): Delete.\n+\t(SSA_OPERAND_MEMORY_SIZE): Delete.\n+\t(struct ssa_operand_memory_d): Change mem array to size one.\n+\t(NUM_VOP_FREE_BUCKETS): Define.\n+\t(free_vuses, free_vdefs): Replace with vop_free_buckets array.\n+\t(vdef_ops, vuse_ops, struct ssa_operand_iterator_d): Use voptype_d type.\n+\t* tree-pretty-print.c (dump_vops): Use voptype_d type.\n+\t* tree-ssa-operands.c (vop_free_bucket_size): New.  Number of operands\n+\twhich fit into a chunk of memory from a specific bucket.\n+\t(vop_free_bucket_index): New.  Find correct size memory bucket.\n+\t(init_vop_buckets): New.  Initialize VOP free memory buckets.\n+\t(add_vop_to_freelist): New.  Add a VOP to the correct free list.\n+\t(ssa_operand_mem_size): New.  Current size of an operand memory chunk.\n+\t(init_ssa_operands): Initialize operand memory and free lists.\n+\t(fini_ssa_operands): Remove references to free_vuses and free_vdefs.\n+\t(ssa_operand_alloc): Use graduated size memory allocation.\n+\t(APPEND_OP_AFTER, MOVE_HEAD_AFTER, MOVE_HEAD_TO_FREELIST, \n+\tINITIALIZE_USE): Remove.\n+\t(alloc_vop): New.  Allocate a virtual operand.\n+\t(alloc_vdef, alloc_vuse): Delete.\n+\t(add_def_op, add_use_op): Directly setup pointers.\n+\t(add_vop): New.  Add a virtual operand.\n+\t(add_vuse_op, add_vdef_op): Call add_vop.\n+\t(realloc_vop): New.  Reallocate a virtual operand.\n+\t(realloc_vdef, realloc_vuse): Call realloc_vop.\n+\t(finalize_ssa_def_ops): Delete.  Move content to finalize_ssa_defs.\n+\t(finalize_ssa_defs): Optimize for common case, remove code based on\n+\tsorted pointers which was a waste of time.\n+\t(finalize_ssa_use_ops): Delete.  Move content to finalize_ssa_uses.\n+\t(finalize_ssa_uses): Update last pointer.\n+\t(finalize_ssa_vdef_ops): Delete.  Move content to finalize_ssa_vdefs.\n+\t(finalize_ssa_vdefs, finalize_ssa_vuse_ops): Use voptype_d and\n+\tdirectly manipulate pointers.\n+\t(copy_virtual_operands): Use voptype_d, and no need to update pointers.\n+\n 2006-12-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/rs6000/rs6000.md (*movdf_hardfloat32): Use %X format to"}, {"sha": "e4f85c132752b345b9979b2a63ee9ab82fee0416", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f99d42769600914aaf5500d8c495d48bd5e0ec/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f99d42769600914aaf5500d8c495d48bd5e0ec/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=79f99d42769600914aaf5500d8c495d48bd5e0ec", "patch": "@@ -2692,8 +2692,8 @@ newline_and_indent (pretty_printer *buffer, int spc)\n static void\n dump_vops (pretty_printer *buffer, tree stmt, int spc, int flags)\n {\n-  struct vdef_optype_d *vdefs;\n-  struct vuse_optype_d *vuses;\n+  struct voptype_d *vdefs;\n+  struct voptype_d *vuses;\n   int i, n;\n \n   if (!ssa_operands_active () || !stmt_references_memory_p (stmt))"}, {"sha": "a577727243ef424c730daedead6160ced12d05c1", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 285, "deletions": 290, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f99d42769600914aaf5500d8c495d48bd5e0ec/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f99d42769600914aaf5500d8c495d48bd5e0ec/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=79f99d42769600914aaf5500d8c495d48bd5e0ec", "patch": "@@ -265,6 +265,95 @@ ssa_operands_active (void)\n }\n \n \n+/* VOPs are of variable sized, so the free list maps \"free buckets\" to the \n+   following table:  \n+    bucket   # operands\n+    ------   ----------\n+\t0\t1\n+\t1\t2\n+\t  ...\n+\t15\t16\n+\t16\t17-24\n+\t17\t25-32\n+\t18\t31-40\n+\t  ...\n+\t29\t121-128\n+   Any VOPs larger than this are simply added to the largest bucket when they\n+   are freed.  */\n+\n+\n+/* Return the number of operands used in bucket BUCKET.  */\n+\n+static inline int\n+vop_free_bucket_size (int bucket)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (bucket >= 0 && bucket < NUM_VOP_FREE_BUCKETS);\n+#endif\n+  if (bucket < 16)\n+    return bucket + 1;\n+  return (bucket - 13) * 8;\n+}\n+\n+\n+/* For a vop of NUM operands, return the bucket NUM belongs to.  If NUM is \n+   beyond the end of the bucket table, return -1.  */\n+\n+static inline int \n+vop_free_bucket_index (int num)\n+{\n+  gcc_assert (num > 0);\n+\n+  /* Sizes 1 through 16 use buckets 0-15.  */\n+  if (num <= 16)\n+    return num - 1;\n+  /* Buckets 16 - 45  represent 17 through 256 in 8 unit chunks.  */\n+  if (num < 256)\n+    return 14 + (num - 1) / 8;\n+  return -1;\n+}\n+\n+\n+/* Initialize the VOP free buckets.  */\n+\n+static inline void\n+init_vop_buckets (void)\n+{\n+  int x;\n+\n+  for (x = 0; x < NUM_VOP_FREE_BUCKETS; x++)\n+    gimple_ssa_operands (cfun)->vop_free_buckets[x] = NULL;\n+}\n+\n+\n+/* Add PTR to the appropriate VOP bucket.  */\n+\n+static inline void\n+add_vop_to_freelist (voptype_p ptr)\n+{\n+  int bucket = vop_free_bucket_index (VUSE_VECT_NUM_ELEM (ptr->usev));\n+\n+  /* Too large, use the largest bucket so its not a complete throw away.  */\n+  if (bucket == -1)\n+    bucket = NUM_VOP_FREE_BUCKETS - 1;\n+\n+  ptr->next = gimple_ssa_operands (cfun)->vop_free_buckets[bucket];\n+  gimple_ssa_operands (cfun)->vop_free_buckets[bucket] = ptr;\n+}\n+ \n+\n+/* These are the sizes of the operand memory  buffer which gets allocated each \n+   time more operands space is required.  The final value is the amount that is\n+   allocated every time after that.  */\n+  \n+#define OP_SIZE_INIT\t0\n+#define OP_SIZE_1\t30\n+#define OP_SIZE_2\t110\n+#define OP_SIZE_3\t511\n+\n+/* Current size of the operand memory buffer.  */\n+static unsigned int ssa_operand_mem_size;\n+\n /* Initialize the operand cache routines.  */\n \n void\n@@ -283,9 +372,11 @@ init_ssa_operands (void)\n \n   gcc_assert (gimple_ssa_operands (cfun)->operand_memory == NULL);\n   gcc_assert (gimple_ssa_operands (cfun)->mpt_table == NULL);\n-  gimple_ssa_operands (cfun)->operand_memory_index = SSA_OPERAND_MEMORY_SIZE;\n+  gimple_ssa_operands (cfun)->operand_memory_index = ssa_operand_mem_size;\n   gimple_ssa_operands (cfun)->ops_active = true;\n   memset (&clobber_stats, 0, sizeof (clobber_stats));\n+  init_vop_buckets ();\n+  ssa_operand_mem_size = OP_SIZE_INIT;\n }\n \n \n@@ -315,8 +406,6 @@ fini_ssa_operands (void)\n \n   gimple_ssa_operands (cfun)->free_defs = NULL;\n   gimple_ssa_operands (cfun)->free_uses = NULL;\n-  gimple_ssa_operands (cfun)->free_vuses = NULL;\n-  gimple_ssa_operands (cfun)->free_vdefs = NULL;\n \n   while ((ptr = gimple_ssa_operands (cfun)->operand_memory) != NULL)\n     {\n@@ -362,13 +451,32 @@ ssa_operand_alloc (unsigned size)\n {\n   char *ptr;\n \n-  gcc_assert (size <= SSA_OPERAND_MEMORY_SIZE);\n-\n   if (gimple_ssa_operands (cfun)->operand_memory_index + size\n-      >= SSA_OPERAND_MEMORY_SIZE)\n+      >= ssa_operand_mem_size)\n     {\n       struct ssa_operand_memory_d *ptr;\n-      ptr = GGC_NEW (struct ssa_operand_memory_d);\n+\n+      if (ssa_operand_mem_size == OP_SIZE_INIT)\n+\tssa_operand_mem_size = OP_SIZE_1 * sizeof (struct voptype_d);\n+      else\n+\tif (ssa_operand_mem_size == OP_SIZE_1 * sizeof (struct voptype_d))\n+\t  ssa_operand_mem_size = OP_SIZE_2 * sizeof (struct voptype_d);\n+\telse\n+\t  ssa_operand_mem_size = OP_SIZE_3 * sizeof (struct voptype_d);\n+\n+      /* Go right to the maximum size if the request is too large.  */\n+      if (size > ssa_operand_mem_size)\n+        ssa_operand_mem_size = OP_SIZE_3 * sizeof (struct voptype_d);\n+\n+      /* Fail if there is not enough space.  If thre are this many operands\n+\t required, first make sure there isn't a different probem causing this\n+\t many operands.  If the decision is that this is OK, then we can \n+\t specially allocate a buffer just for this request.  */\n+      gcc_assert (size <= ssa_operand_mem_size);\n+\n+      ptr = (struct ssa_operand_memory_d *) \n+\t      ggc_alloc (sizeof (struct ssa_operand_memory_d) \n+\t\t\t + ssa_operand_mem_size - 1);\n       ptr->next = gimple_ssa_operands (cfun)->operand_memory;\n       gimple_ssa_operands (cfun)->operand_memory = ptr;\n       gimple_ssa_operands (cfun)->operand_memory_index = 0;\n@@ -380,6 +488,8 @@ ssa_operand_alloc (unsigned size)\n }\n \n \n+/* Allocate a DEF operand.  */\n+\n static inline struct def_optype_d *\n alloc_def (void)\n {\n@@ -392,11 +502,13 @@ alloc_def (void)\n     }\n   else\n     ret = (struct def_optype_d *)\n-\t\t      ssa_operand_alloc (sizeof (struct def_optype_d));\n+\t  ssa_operand_alloc (sizeof (struct def_optype_d));\n   return ret;\n }\n \n \n+/* Allocate a USE operand.  */\n+\n static inline struct use_optype_d *\n alloc_use (void)\n {\n@@ -408,50 +520,40 @@ alloc_use (void)\n \t= gimple_ssa_operands (cfun)->free_uses->next;\n     }\n   else\n-    ret = (struct use_optype_d *)ssa_operand_alloc (sizeof (struct use_optype_d));\n+    ret = (struct use_optype_d *)\n+          ssa_operand_alloc (sizeof (struct use_optype_d));\n   return ret;\n }\n \n \n+/* Allocate a vop with NUM elements.  */\n \n-\n-static inline struct vdef_optype_d *\n-alloc_vdef (int num)\n+static inline struct voptype_d *\n+alloc_vop (int num)\n {\n-  struct vdef_optype_d *ret;\n-  /* Eliminate free list for the moment.  */\n-#if 0\n-  if (free_vdefs)\n+  struct voptype_d *ret = NULL;\n+  int alloc_size = 0;\n+\n+  int bucket = vop_free_bucket_index (num);\n+  if (bucket != -1)\n     {\n-      ret = free_vdefs;\n-      free_vdefs = free_vdefs->next;\n+      /* If there is a free operand, use it.  */\n+      if (gimple_ssa_operands (cfun)->vop_free_buckets[bucket] != NULL)\n+\t{\n+\t  ret = gimple_ssa_operands (cfun)->vop_free_buckets[bucket];\n+\t  gimple_ssa_operands (cfun)->vop_free_buckets[bucket] = \n+\t\t  gimple_ssa_operands (cfun)->vop_free_buckets[bucket]->next;\n+\t}\n+      else\n+        alloc_size = vop_free_bucket_size(bucket);\n     }\n   else\n-#endif\n-    ret = (struct vdef_optype_d *)ssa_operand_alloc (\n-\tsizeof (struct vdef_optype_d) + (num - 1) * sizeof (vuse_element_t));\n-  VUSE_VECT_NUM_ELEM (ret->usev) = num;\n-  return ret;\n-}\n-\n-\n+    alloc_size = num;\n \n+  if (alloc_size > 0)\n+    ret = (struct voptype_d *)ssa_operand_alloc (\n+\tsizeof (struct voptype_d) + (alloc_size - 1) * sizeof (vuse_element_t));\n \n-static inline struct vuse_optype_d *\n-alloc_vuse (int num)\n-{\n-  struct vuse_optype_d *ret;\n-/* No free list for the moment.  */\n-#if 0    \n-  if (free_vuses)\n-    {\n-      ret = free_vuses;\n-      free_vuses = free_vuses->next;\n-    }\n-  else\n-#endif\n-    ret = (struct vuse_optype_d *)ssa_operand_alloc (\n-\tsizeof (struct vuse_optype_d) + (num - 1) * sizeof (vuse_element_t));\n   VUSE_VECT_NUM_ELEM (ret->usev) = num;\n   return ret;\n }\n@@ -472,138 +574,111 @@ set_virtual_use_link (use_operand_p ptr, tree stmt)\n     link_imm_use (ptr, *(ptr->use));\n }\n \n-/* Appends ELT after TO, and moves the TO pointer to ELT.  */\n-\n-#define APPEND_OP_AFTER(ELT, TO)\t\\\n-  do\t\t\t\t\t\\\n-    {\t\t\t\t\t\\\n-      (TO)->next = (ELT);\t\t\\\n-      (TO) = (ELT);\t\t\t\\\n-    } while (0)\n-\n-/* Appends head of list FROM after TO, and move both pointers\n-   to their successors.  */\n-\n-#define MOVE_HEAD_AFTER(FROM, TO)\t\\\n-  do\t\t\t\t\t\\\n-    {\t\t\t\t\t\\\n-      APPEND_OP_AFTER (FROM, TO);\t\\\n-      (FROM) = (FROM)->next;\t\t\\\n-    } while (0)\n-\n-/* Moves OP to appropriate freelist.  OP is set to its successor.  */\n-\n-#define MOVE_HEAD_TO_FREELIST(OP, TYPE)\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      TYPE##_optype_p next = (OP)->next;\t\t\\\n-      (OP)->next\t\t\t\t\t\\\n-\t = gimple_ssa_operands (cfun)->free_##TYPE##s;\t\\\n-      gimple_ssa_operands (cfun)->free_##TYPE##s = (OP);\\\n-      (OP) = next;\t\t\t\t\t\\\n-    } while (0)\n-\n-/* Initializes immediate use at USE_PTR to value VAL, and links it to the list\n-   of immediate uses.  STMT is the current statement.  */\n-\n-#define INITIALIZE_USE(USE_PTR, VAL, STMT)\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      (USE_PTR)->use = (VAL);\t\t\t\t\\\n-      link_imm_use_stmt ((USE_PTR), *(VAL), (STMT));\t\\\n-    } while (0)\n-\n-/* Adds OP to the list of defs after LAST, and moves\n-   LAST to the new element.  */\n+\n+/* Adds OP to the list of defs after LAST.  */\n \n static inline def_optype_p \n-add_def_op (tree *op, def_optype_p *last)\n+add_def_op (tree *op, def_optype_p last)\n {\n   def_optype_p new;\n \n   new = alloc_def ();\n   DEF_OP_PTR (new) = op;\n-  APPEND_OP_AFTER (new, *last);  \n+  last->next = new;\n+  new->next = NULL;\n   return new;\n }\n \n-/* Adds OP to the list of uses of statement STMT after LAST, and moves\n-   LAST to the new element.  */\n+\n+/* Adds OP to the list of uses of statement STMT after LAST.  */\n \n static inline use_optype_p\n-add_use_op (tree stmt, tree *op, use_optype_p *last)\n+add_use_op (tree stmt, tree *op, use_optype_p last)\n {\n   use_optype_p new;\n \n   new = alloc_use ();\n-  INITIALIZE_USE (USE_OP_PTR (new), op, stmt);\n-  APPEND_OP_AFTER (new, *last);  \n+  USE_OP_PTR (new)->use = op;\n+  link_imm_use_stmt (USE_OP_PTR (new), *op, stmt);\n+  last->next = new;\n+  new->next = NULL;\n   return new;\n }\n \n-/* Adds OP to the list of vuses of statement STMT after LAST, and moves\n-   LAST to the new element.  */\n \n-static inline vuse_optype_p\n-add_vuse_op (tree stmt, tree op, int num, vuse_optype_p *last)\n+/* Return a virtual op pointer with NUM elements which are all initialized to OP\n+   and are linked into the immeidate uses for STMT.  The new vop is appended\n+   after PREV.  */\n+\n+static inline voptype_p\n+add_vop (tree stmt, tree op, int num, voptype_p prev)\n {\n-  vuse_optype_p new;\n+  voptype_p new;\n   int x;\n \n-  new = alloc_vuse (num);\n+  new = alloc_vop (num);\n   for (x = 0; x < num; x++)\n     {\n+      VUSE_OP_PTR (new, x)->prev = NULL;\n       SET_VUSE_OP (new, x, op);\n-      INITIALIZE_USE (VUSE_OP_PTR (new, x), &new->usev.uses[x].use_var, stmt);\n+      VUSE_OP_PTR (new, x)->use = &new->usev.uses[x].use_var;\n+      link_imm_use_stmt (VUSE_OP_PTR (new, x), new->usev.uses[x].use_var, stmt);\n     }\n \n-  APPEND_OP_AFTER (new, *last);  \n+  if (prev)\n+    prev->next = new;\n+  new->next = NULL;\n   return new;\n }\n \n \n-/* Adds OP to the list of vdefs of statement STMT after LAST, and moves\n+/* Adds OP to the list of vuses of statement STMT after LAST, and moves\n    LAST to the new element.  */\n \n-static inline vdef_optype_p\n-add_vdef_op (tree stmt, tree op, int num, vdef_optype_p *last)\n+static inline voptype_p\n+add_vuse_op (tree stmt, tree op, int num, voptype_p last)\n {\n-  int x;\n-  vdef_optype_p new;\n+  voptype_p new = add_vop (stmt, op, num, last);\n+  VDEF_RESULT (new) = NULL_TREE;\n+  return new;\n+}\n \n-  new = alloc_vdef (num);\n-  VDEF_RESULT (new) = op;\n-  for (x = 0; x < num; x++)\n-    {\n-      SET_VDEF_OP (new, x, op);\n-      INITIALIZE_USE (VDEF_OP_PTR (new, x), &new->usev.uses[x].use_var, stmt);\n-    }\n \n-  APPEND_OP_AFTER (new, *last);  \n+/* Adds OP to the list of vdefs of statement STMT after LAST, and moves\n+   LAST to the new element.  */\n+\n+static inline voptype_p\n+add_vdef_op (tree stmt, tree op, int num, voptype_p last)\n+{\n+  voptype_p new = add_vop (stmt, op, num, last);\n+  VDEF_RESULT (new) = op;\n   return new;\n }\n+  \n \n+/* Reallocate the virtual operand PTR so that it has NUM_ELEM use slots.  ROOT\n+   is the head of the operand list it belongs to.  */\n \n-struct vdef_optype_d *\n-realloc_vdef (struct vdef_optype_d *ptr, int num_elem)\n+static inline struct voptype_d *\n+realloc_vop (struct voptype_d *ptr, int num_elem, struct voptype_d **root)\n {\n   int x, lim;\n-  tree val, stmt;\n-  struct vdef_optype_d *ret, *tmp;\n+  tree stmt, val;\n+  struct voptype_d *ret, *tmp;\n \n   if (VUSE_VECT_NUM_ELEM (ptr->usev) == num_elem)\n     return ptr; \n-  \n-  val = VDEF_RESULT (ptr);\n+\n+  val = VUSE_OP (ptr, 0);\n   if (TREE_CODE (val) == SSA_NAME)\n     val = SSA_NAME_VAR (val);\n \n-  stmt = USE_STMT (VDEF_OP_PTR (ptr, 0));\n+  stmt = USE_STMT (VUSE_OP_PTR (ptr, 0));\n \n   /* Delink all the existing uses.  */\n   for (x = 0; x < VUSE_VECT_NUM_ELEM (ptr->usev); x++)\n     {\n-      use_operand_p use_p = VDEF_OP_PTR (ptr, x);\n+      use_operand_p use_p = VUSE_OP_PTR (ptr, x);\n       delink_imm_use (use_p);\n     }\n \n@@ -615,23 +690,22 @@ realloc_vdef (struct vdef_optype_d *ptr, int num_elem)\n     }\n \n   /* It is growing.  Allocate a new one and replace the old one.  */\n-  tmp = ptr;\n-  ret = add_vdef_op (stmt, val, num_elem, &ptr);\n-  ret->next = NULL;\n-  ptr = tmp;\n+  ret = add_vuse_op (stmt, val, num_elem, ptr);\n \n+  /* Clear PTR and add its memory to the free list.  */\n   lim = VUSE_VECT_NUM_ELEM (ptr->usev);\n   memset (ptr, 0,\n-          sizeof (struct vdef_optype_d) + sizeof (vuse_element_t) * (lim- 1));\n+          sizeof (struct voptype_d) + sizeof (vuse_element_t) * (lim- 1));\n+  add_vop_to_freelist (ptr);\n \n   /* Now simply remove the old one.  */\n-  if (VDEF_OPS (stmt) == ptr)\n+  if (*root == ptr)\n     {\n-      VDEF_OPS (stmt) = ret;\n+      *root = ret;\n       return ret;\n     }\n   else\n-    for (tmp = VDEF_OPS (stmt); \n+    for (tmp = *root; \n \t tmp != NULL && tmp->next != ptr; \n \t tmp = tmp->next)\n       {\n@@ -642,115 +716,63 @@ realloc_vdef (struct vdef_optype_d *ptr, int num_elem)\n   /* The pointer passed in isn't in STMT's VDEF lists.  */\n   gcc_unreachable ();\n }\n+ \n \n+/* Reallocate the PTR vdef so that it has NUM_ELEM use slots.  */\n \n-struct vuse_optype_d *\n-realloc_vuse (struct vuse_optype_d *ptr, int num_elem)\n+struct voptype_d *\n+realloc_vdef (struct voptype_d *ptr, int num_elem)\n {\n-  int x, lim;\n   tree val, stmt;\n-  struct vuse_optype_d *ret, *tmp;\n+  struct voptype_d *ret;\n \n-  if (VUSE_VECT_NUM_ELEM (ptr->usev) == num_elem)\n-    return ptr; \n+  val = VDEF_RESULT (ptr);\n+  stmt = USE_STMT (VDEF_OP_PTR (ptr, 0));\n+  ret = realloc_vop (ptr, num_elem, &(VDEF_OPS (stmt)));\n+  VDEF_RESULT (ret) = val;\n+  return ret;\n+}\n   \n-  val = VUSE_OP (ptr, 0);\n-  if (TREE_CODE (val) == SSA_NAME)\n-    val = SSA_NAME_VAR (val);\n \n-  stmt = USE_STMT (VUSE_OP_PTR (ptr, 0));\n+/* Reallocate the PTR vuse so that it has NUM_ELEM use slots.  */\n \n-  /* Delink all the existing uses.  */\n-  for (x = 0; x < VUSE_VECT_NUM_ELEM (ptr->usev); x++)\n-    {\n-      use_operand_p use_p = VUSE_OP_PTR (ptr, x);\n-      delink_imm_use (use_p);\n-    }\n-\n-  /* If we want less space, simply use this one, and shrink the size.  */\n-  if (VUSE_VECT_NUM_ELEM (ptr->usev) > num_elem)\n-    {\n-      VUSE_VECT_NUM_ELEM (ptr->usev) = num_elem;\n-      return ptr;\n-    }\n-\n-  /* It is growing.  Allocate a new one and replace the old one.  */\n-  tmp = ptr;\n-  ret = add_vuse_op (stmt, val, num_elem, &ptr);\n-  ret->next = NULL;\n-  ptr = tmp;\n-\n-  lim = VUSE_VECT_NUM_ELEM (ptr->usev);\n-  memset (ptr, 0, \n-\t  sizeof (struct vuse_optype_d) + sizeof (vuse_element_t) * (lim - 1));\n-\n-  /* Now simply link it in, find the node which points to this one.  */\n-  if (VUSE_OPS (stmt) == ptr)\n-    {\n-      VUSE_OPS (stmt) = ret;\n-      return ret;\n-    }\n-  else\n-    for (tmp = VUSE_OPS (stmt); \n-\t tmp != NULL && tmp->next != ptr; \n-\t tmp = tmp->next)\n-      {\n-\ttmp->next = ret;\n-\treturn ret;\n-      }\n+struct voptype_d *\n+realloc_vuse (struct voptype_d *ptr, int num_elem)\n+{\n+  tree stmt;\n+  struct voptype_d *ret;\n \n-  /* The pointer passed in isn't in STMT's VUSE lists.  */\n-  gcc_unreachable ();\n+  stmt = USE_STMT (VUSE_OP_PTR (ptr, 0));\n+  ret = realloc_vop (ptr, num_elem, &(VUSE_OPS (stmt)));\n+  return ret;\n }\n \n+\n /* Takes elements from build_defs and turns them into def operands of STMT.\n-   TODO -- Given that def operands list is not necessarily sorted, merging\n-\t   the operands this way does not make much sense.\n-\t-- Make build_defs VEC of tree *.  */\n+   TODO -- Make build_defs VEC of tree *.  */\n \n static inline void\n-finalize_ssa_def_ops (tree stmt)\n+finalize_ssa_defs (tree stmt)\n {\n   unsigned new_i;\n   struct def_optype_d new_list;\n   def_optype_p old_ops, last;\n-  tree *old_base;\n+  unsigned int num = VEC_length (tree, build_defs);\n+\n+  /* There should only be a single real definition per assignment.  */\n+  gcc_assert ((stmt && TREE_CODE (stmt) != GIMPLE_MODIFY_STMT) || num <= 1);\n \n   new_list.next = NULL;\n   last = &new_list;\n \n   old_ops = DEF_OPS (stmt);\n \n   new_i = 0;\n-  while (old_ops && new_i < VEC_length (tree, build_defs))\n-    {\n-      tree *new_base = (tree *) VEC_index (tree, build_defs, new_i);\n-      old_base = DEF_OP_PTR (old_ops);\n-\n-      if (old_base == new_base)\n-        {\n-\t  /* if variables are the same, reuse this node.  */\n-\t  MOVE_HEAD_AFTER (old_ops, last);\n-\t  new_i++;\n-\t}\n-      else if (old_base < new_base)\n-\t{\n-\t  /* if old is less than new, old goes to the free list.  */\n-\t  MOVE_HEAD_TO_FREELIST (old_ops, def);\n-\t}\n-      else\n-\t{\n-\t  /* This is a new operand.  */\n-\t  add_def_op (new_base, &last);\n-\t  new_i++;\n-\t}\n-    }\n-\n-  /* If there is anything remaining in the build_defs list, simply emit it.  */\n-  for ( ; new_i < VEC_length (tree, build_defs); new_i++)\n-    add_def_op ((tree *) VEC_index (tree, build_defs, new_i), &last);\n \n-  last->next = NULL;\n+  /* Check for the common case of 1 def that hasn't changed.  */\n+  if (old_ops && old_ops->next == NULL && num == 1\n+      && (tree *) VEC_index (tree, build_defs, 0) == DEF_OP_PTR (old_ops))\n+    return;\n \n   /* If there is anything in the old list, free it.  */\n   if (old_ops)\n@@ -759,6 +781,10 @@ finalize_ssa_def_ops (tree stmt)\n       gimple_ssa_operands (cfun)->free_defs = old_ops;\n     }\n \n+  /* If there is anything remaining in the build_defs list, simply emit it.  */\n+  for ( ; new_i < num; new_i++)\n+    last = add_def_op ((tree *) VEC_index (tree, build_defs, new_i), last);\n+\n   /* Now set the stmt's operands.  */\n   DEF_OPS (stmt) = new_list.next;\n \n@@ -769,36 +795,36 @@ finalize_ssa_def_ops (tree stmt)\n     for (ptr = DEF_OPS (stmt); ptr; ptr = ptr->next)\n       x++;\n \n-    gcc_assert (x == VEC_length (tree, build_defs));\n+    gcc_assert (x == num);\n   }\n #endif\n }\n \n-/* This routine will create stmt operands for STMT from the def build list.  */\n-\n-static void\n-finalize_ssa_defs (tree stmt)\n-{\n-  unsigned int num = VEC_length (tree, build_defs);\n-\n-  /* There should only be a single real definition per assignment.  */\n-  gcc_assert ((stmt && TREE_CODE (stmt) != GIMPLE_MODIFY_STMT) || num <= 1);\n-\n-  /* If there is an old list, often the new list is identical, or close, so\n-     find the elements at the beginning that are the same as the vector.  */\n-  finalize_ssa_def_ops (stmt);\n-}\n \n /* Takes elements from build_uses and turns them into use operands of STMT.\n    TODO -- Make build_uses VEC of tree *.  */\n \n static inline void\n-finalize_ssa_use_ops (tree stmt)\n+finalize_ssa_uses (tree stmt)\n {\n   unsigned new_i;\n   struct use_optype_d new_list;\n   use_optype_p old_ops, ptr, last;\n \n+#ifdef ENABLE_CHECKING\n+  {\n+    unsigned x;\n+    unsigned num = VEC_length (tree, build_uses);\n+\n+    /* If the pointer to the operand is the statement itself, something is\n+       wrong.  It means that we are pointing to a local variable (the \n+       initial call to update_stmt_operands does not pass a pointer to a \n+       statement).  */\n+    for (x = 0; x < num; x++)\n+      gcc_assert (*((tree *)VEC_index (tree, build_uses, x)) != stmt);\n+  }\n+#endif\n+\n   new_list.next = NULL;\n   last = &new_list;\n \n@@ -815,9 +841,9 @@ finalize_ssa_use_ops (tree stmt)\n \n   /* Now create nodes for all the new nodes.  */\n   for (new_i = 0; new_i < VEC_length (tree, build_uses); new_i++)\n-    add_use_op (stmt, (tree *) VEC_index (tree, build_uses, new_i), &last);\n-\n-  last->next = NULL;\n+    last = add_use_op (stmt, \n+\t\t       (tree *) VEC_index (tree, build_uses, new_i), \n+\t\t       last);\n \n   /* Now set the stmt's operands.  */\n   USE_OPS (stmt) = new_list.next;\n@@ -833,38 +859,17 @@ finalize_ssa_use_ops (tree stmt)\n #endif\n }\n \n-/* Return a new use operand vector for STMT, comparing to OLD_OPS_P.  */\n-                                                                              \n-static void\n-finalize_ssa_uses (tree stmt)\n-{\n-#ifdef ENABLE_CHECKING\n-  {\n-    unsigned x;\n-    unsigned num = VEC_length (tree, build_uses);\n-\n-    /* If the pointer to the operand is the statement itself, something is\n-       wrong.  It means that we are pointing to a local variable (the \n-       initial call to update_stmt_operands does not pass a pointer to a \n-       statement).  */\n-    for (x = 0; x < num; x++)\n-      gcc_assert (*((tree *)VEC_index (tree, build_uses, x)) != stmt);\n-  }\n-#endif\n-  finalize_ssa_use_ops (stmt);\n-}\n-\n \n /* Takes elements from BUILD_VDEFS and turns them into vdef operands of\n    STMT.  FIXME, for now VDEF operators should have a single operand\n    in their RHS.  */\n \n static inline void\n-finalize_ssa_vdef_ops (tree stmt)\n+finalize_ssa_vdefs (tree stmt)\n {\n   unsigned new_i;\n-  struct vdef_optype_d new_list;\n-  vdef_optype_p old_ops, ptr, last;\n+  struct voptype_d new_list;\n+  voptype_p old_ops, ptr, last;\n   stmt_ann_t ann = stmt_ann (stmt);\n \n   /* Set the symbols referenced by STMT.  */\n@@ -906,37 +911,43 @@ finalize_ssa_vdef_ops (tree stmt)\n       if (old_uid == new_uid)\n         {\n \t  /* If the symbols are the same, reuse the existing operand.  */\n-\t  MOVE_HEAD_AFTER (old_ops, last);\n+\t  last->next = old_ops;\n+\t  last = old_ops;\n+\t  old_ops = old_ops->next;\n+\t  last->next = NULL;\n \t  set_virtual_use_link (VDEF_OP_PTR (last, 0), stmt);\n \t  new_i++;\n \t}\n       else if (old_uid < new_uid)\n \t{\n \t  /* If old is less than new, old goes to the free list.  */\n+\t  voptype_p next;\n \t  delink_imm_use (VDEF_OP_PTR (old_ops, 0));\n-\t  MOVE_HEAD_TO_FREELIST (old_ops, vdef);\n+\t  next = old_ops->next;\n+\t  add_vop_to_freelist (old_ops);\n+\t  old_ops = next;\n \t}\n       else\n \t{\n \t  /* This is a new operand.  */\n-\t  add_vdef_op (stmt, op, 1, &last);\n+\t  last = add_vdef_op (stmt, op, 1, last);\n \t  new_i++;\n \t}\n     }\n \n   /* If there is anything remaining in BUILD_VDEFS, simply emit it.  */\n   for ( ; new_i < VEC_length (tree, build_vdefs); new_i++)\n-    add_vdef_op (stmt, VEC_index (tree, build_vdefs, new_i), 1, &last);\n-\n-  last->next = NULL;\n+    last = add_vdef_op (stmt, VEC_index (tree, build_vdefs, new_i), 1, last);\n \n   /* If there is anything in the old list, free it.  */\n   if (old_ops)\n     {\n-      for (ptr = old_ops; ptr; ptr = ptr->next)\n-\tdelink_imm_use (VDEF_OP_PTR (ptr, 0));\n-      old_ops->next = gimple_ssa_operands (cfun)->free_vdefs;\n-      gimple_ssa_operands (cfun)->free_vdefs = old_ops;\n+      for (ptr = old_ops; ptr; ptr = last)\n+        {\n+\t  last = ptr->next;\n+\t  delink_imm_use (VDEF_OP_PTR (ptr, 0));\n+\t  add_vop_to_freelist (ptr);\n+\t}\n     }\n \n   /* Now set STMT's operands.  */\n@@ -954,14 +965,6 @@ finalize_ssa_vdef_ops (tree stmt)\n }\n \n \n-static void\n-finalize_ssa_vdefs (tree stmt)\n-{\n-  finalize_ssa_vdef_ops (stmt);\n-}\n-\n-\n-\n /* Takes elements from BUILD_VUSES and turns them into VUSE operands of\n    STMT.  */\n \n@@ -970,8 +973,7 @@ finalize_ssa_vuse_ops (tree stmt)\n {\n   unsigned new_i;\n   int old_i;\n-  struct vuse_optype_d new_list;\n-  vuse_optype_p old_ops, last;\n+  voptype_p old_ops, last;\n   VEC(tree,heap) *new_ops;\n   stmt_ann_t ann;\n \n@@ -1042,9 +1044,7 @@ finalize_ssa_vuse_ops (tree stmt)\n     {\n       for (old_i = 0; old_i < VUSE_NUM (old_ops); old_i++)\n \tdelink_imm_use (VUSE_OP_PTR (old_ops, old_i));\n-      old_ops->next = gimple_ssa_operands (cfun)->free_vuses;\n-      gimple_ssa_operands (cfun)->free_vuses = old_ops;\n-\n+      add_vop_to_freelist (old_ops);\n       VUSE_OPS (stmt) = NULL;\n     }\n \n@@ -1054,15 +1054,12 @@ finalize_ssa_vuse_ops (tree stmt)\n       tree op;\n       unsigned i;\n \n-      new_list.next = NULL;\n-      last = &new_list;\n-      add_vuse_op (stmt, NULL, VEC_length (tree, new_ops), &last);\n-      last->next = NULL;\n+      last = add_vuse_op (stmt, NULL, VEC_length (tree, new_ops), NULL);\n \n       for (i = 0; VEC_iterate (tree, new_ops, i, op); i++)\n \tSET_USE (VUSE_OP_PTR (last, (int) i), op);\n \n-      VUSE_OPS (stmt) = new_list.next;\n+      VUSE_OPS (stmt) = last;\n     }\n \n #ifdef ENABLE_CHECKING\n@@ -2391,10 +2388,10 @@ void\n copy_virtual_operands (tree dest, tree src)\n {\n   int i, n;\n-  vuse_optype_p src_vuses, dest_vuses;\n-  vdef_optype_p src_vdefs, dest_vdefs;\n-  struct vuse_optype_d vuse;\n-  struct vdef_optype_d vdef;\n+  voptype_p src_vuses, dest_vuses;\n+  voptype_p src_vdefs, dest_vdefs;\n+  struct voptype_d vuse;\n+  struct voptype_d vdef;\n   stmt_ann_t dest_ann;\n \n   VDEF_OPS (dest) = NULL;\n@@ -2421,8 +2418,7 @@ copy_virtual_operands (tree dest, tree src)\n   for (src_vuses = VUSE_OPS (src); src_vuses; src_vuses = src_vuses->next)\n     {\n       n = VUSE_NUM (src_vuses);\n-      dest_vuses = add_vuse_op (dest, NULL_TREE, n, &dest_vuses);\n-      dest_vuses->next = NULL;\n+      dest_vuses = add_vuse_op (dest, NULL_TREE, n, dest_vuses);\n       for (i = 0; i < n; i++)\n \tSET_USE (VUSE_OP_PTR (dest_vuses, i), VUSE_OP (src_vuses, i));\n \n@@ -2435,8 +2431,7 @@ copy_virtual_operands (tree dest, tree src)\n   for (src_vdefs = VDEF_OPS (src); src_vdefs; src_vdefs = src_vdefs->next)\n     {\n       n = VUSE_NUM (src_vdefs);\n-      dest_vdefs = add_vdef_op (dest, NULL_TREE, n, &dest_vdefs);\n-      dest_vdefs->next = NULL;\n+      dest_vdefs = add_vdef_op (dest, NULL_TREE, n, dest_vdefs);\n       VDEF_RESULT (dest_vdefs) = VDEF_RESULT (src_vdefs);\n       for (i = 0; i < n; i++)\n \tSET_USE (VUSE_OP_PTR (dest_vdefs, i), VUSE_OP (src_vdefs, i));"}, {"sha": "10fd1459996950fec60d8632c2cc17a5f8064fe5", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f99d42769600914aaf5500d8c495d48bd5e0ec/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f99d42769600914aaf5500d8c495d48bd5e0ec/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=79f99d42769600914aaf5500d8c495d48bd5e0ec", "patch": "@@ -98,32 +98,28 @@ typedef struct vuse_vec_d *vuse_vec_p;\n \n #define VUSE_ELEMENT_VAR(V,X)\t(VUSE_VECT_ELEMENT ((V),(X)).use_var)\n \n-/* This represents the VDEFS for a stmt.  */\n-struct vdef_optype_d\n+/* This represents the virtual ops of a stmt.  */\n+struct voptype_d\n {\n-  struct vdef_optype_d *next;\n+  struct voptype_d *next;\n   tree def_var;\n   vuse_vec_t usev;\n };\n-typedef struct vdef_optype_d *vdef_optype_p;\n+typedef struct voptype_d *voptype_p;\n \n-/* This represents the VUSEs for a stmt.  */\n-struct vuse_optype_d\n-{\n-  struct vuse_optype_d *next;\n-  vuse_vec_t usev;\n-};\n-typedef struct vuse_optype_d *vuse_optype_p;\n-                                                                              \n-\n-#define SSA_OPERAND_MEMORY_SIZE\t\t(511 * sizeof (struct vuse_optype_d))\n-                                                                              \n+/* This structure represents a variable sized buffer which is allocated by the\n+   operand memory manager.  Operands are subalocated out of this block.  The\n+   MEM array varies in size.  */\n+   \n struct ssa_operand_memory_d GTY((chain_next(\"%h.next\")))\n {\n   struct ssa_operand_memory_d *next;\n-  char mem[SSA_OPERAND_MEMORY_SIZE];\n+  char mem[1];\n };\n \n+/* Number of different size free buckets for virtual operands.  */\n+#define NUM_VOP_FREE_BUCKETS\t\t29\n+\n /* Per-function operand caches.  */\n struct ssa_operands GTY(()) {\n    struct ssa_operand_memory_d *operand_memory;\n@@ -133,8 +129,7 @@ struct ssa_operands GTY(()) {\n \n    struct def_optype_d * GTY ((skip (\"\"))) free_defs;\n    struct use_optype_d * GTY ((skip (\"\"))) free_uses;\n-   struct vuse_optype_d * GTY ((skip (\"\"))) free_vuses;\n-   struct vdef_optype_d * GTY ((skip (\"\"))) free_vdefs;\n+   struct voptype_d * GTY ((skip (\"\"))) vop_free_buckets[NUM_VOP_FREE_BUCKETS];\n    VEC(tree,heap) * GTY ((skip (\"\"))) mpt_table;\n };\n \n@@ -146,8 +141,8 @@ struct stmt_operands_d\n   struct use_optype_d * use_ops;\n                                                                               \n   /* Virtual operands (VDEF, VUSE).  */\n-  struct vdef_optype_d * vdef_ops;\n-  struct vuse_optype_d * vuse_ops;\n+  struct voptype_d * vdef_ops;\n+  struct voptype_d * vuse_ops;\n \n   /* Sets of memory symbols loaded and stored.  */\n   bitmap stores;\n@@ -206,8 +201,8 @@ typedef struct stmt_operands_d *stmt_operands_p;\n #define PHI_ARG_INDEX_FROM_USE(USE)   phi_arg_index_from_use (USE)\n \n \n-extern struct vdef_optype_d *realloc_vdef (struct vdef_optype_d *, int);\n-extern struct vuse_optype_d *realloc_vuse (struct vuse_optype_d *, int);\n+extern struct voptype_d *realloc_vdef (struct voptype_d *, int);\n+extern struct voptype_d *realloc_vuse (struct voptype_d *, int);\n \n extern void init_ssa_operands (void);\n extern void fini_ssa_operands (void);\n@@ -249,9 +244,9 @@ typedef struct ssa_operand_iterator_d\n {\n   def_optype_p defs;\n   use_optype_p uses;\n-  vuse_optype_p vuses;\n-  vdef_optype_p vdefs;\n-  vdef_optype_p mayuses;\n+  voptype_p vuses;\n+  voptype_p vdefs;\n+  voptype_p mayuses;\n   enum ssa_op_iter_type iter_type;\n   int phi_i;\n   int num_phi;"}]}