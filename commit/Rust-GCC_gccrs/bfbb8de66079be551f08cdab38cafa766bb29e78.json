{"sha": "bfbb8de66079be551f08cdab38cafa766bb29e78", "node_id": "C_kwDOANBUbNoAKGJmYmI4ZGU2NjA3OWJlNTUxZjA4Y2RhYjM4Y2FmYTc2NmJiMjllNzg", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2021-11-29T18:12:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-06T17:11:31Z"}, "message": "[Ada] Crash in class-wide pre/postconditions\n\ngcc/ada/\n\n\t* contracts.adb (Restore_Original_Selected_Component): New\n\tsubprogram that traverses a preanalyzed expression searching for\n\tdispatching calls to functions whose original node was a\n\tselected component, and replacing them with their original node.\n\tThis functionality is required because the preanalyis of\n\tdispatching calls using the Object.Operation notation transforms\n\tsuch calls, and we need the original condition to properly\n\tinherit and extend the condition expression on tagged type\n\tderivations.  This functionality was previously provided by the\n\troutine Install_Original_Selected_Component (as part of\n\tinheriting conditions); now it is performed as part of the\n\tpreanalysis of the condition, thus avoiding repeatedly\n\tinstalling and restoring such nodes.\n\t(Install_Original_Selected_Component): Removed.\n\t(Restore_Dispatching_Calls): Removed.", "tree": {"sha": "7919ecc7cf1cd2ee947d2667ec2777fa684901c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7919ecc7cf1cd2ee947d2667ec2777fa684901c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfbb8de66079be551f08cdab38cafa766bb29e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfbb8de66079be551f08cdab38cafa766bb29e78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfbb8de66079be551f08cdab38cafa766bb29e78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfbb8de66079be551f08cdab38cafa766bb29e78/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a3652640b612c1e7619dfa10c096f3adc750b41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3652640b612c1e7619dfa10c096f3adc750b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3652640b612c1e7619dfa10c096f3adc750b41"}], "stats": {"total": 164, "additions": 58, "deletions": 106}, "files": [{"sha": "1902fbb8863fd644ef99b9b2ec67854263dcf46b", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 58, "deletions": 106, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfbb8de66079be551f08cdab38cafa766bb29e78/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfbb8de66079be551f08cdab38cafa766bb29e78/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=bfbb8de66079be551f08cdab38cafa766bb29e78", "patch": "@@ -4254,6 +4254,11 @@ package body Contracts is\n          procedure Remove_Formals (Id : Entity_Id);\n          --  Remove formals from homonym chains and make them not visible\n \n+         procedure Restore_Original_Selected_Component;\n+         --  Traverse Expr searching for dispatching calls to functions whose\n+         --  original node was a selected component, and replace them with\n+         --  their original node.\n+\n          ----------------------------\n          -- Clear_Unset_References --\n          ----------------------------\n@@ -4313,6 +4318,46 @@ package body Contracts is\n             end loop;\n          end Remove_Formals;\n \n+         -----------------------------------------\n+         -- Restore_Original_Selected_Component --\n+         -----------------------------------------\n+\n+         procedure Restore_Original_Selected_Component is\n+\n+            function Restore_Node (N : Node_Id) return Traverse_Result;\n+            --  Process a single node\n+\n+            ------------------\n+            -- Restore_Node --\n+            ------------------\n+\n+            function Restore_Node (N : Node_Id) return Traverse_Result is\n+            begin\n+               if Nkind (N) = N_Function_Call\n+                 and then Nkind (Original_Node (N)) = N_Selected_Component\n+                 and then Is_Dispatching_Operation (Entity (Name (N)))\n+               then\n+                  Rewrite (N, Original_Node (N));\n+                  Set_Original_Node (N, N);\n+\n+                  --  Restore decoration of its child nodes; required to ensure\n+                  --  proper copies of this subtree (if required) by subsequent\n+                  --  calls to New_Copy_Tree (since otherwise these child nodes\n+                  --  are not duplicated).\n+\n+                  Set_Parent (Prefix (N), N);\n+                  Set_Parent (Selector_Name (N), N);\n+               end if;\n+\n+               return OK;\n+            end Restore_Node;\n+\n+            procedure Restore_Nodes is new Traverse_Proc (Restore_Node);\n+\n+         begin\n+            Restore_Nodes (Expr);\n+         end Restore_Original_Selected_Component;\n+\n       --  Start of processing for Preanalyze_Condition\n \n       begin\n@@ -4329,6 +4374,16 @@ package body Contracts is\n          Remove_Formals (Subp);\n          Pop_Scope;\n \n+         --  If this preanalyzed condition has occurrences of dispatching calls\n+         --  using the Object.Operation notation, during preanalysis such calls\n+         --  are rewritten as dispatching function calls; if at later stages\n+         --  this condition is inherited we must have restored the original\n+         --  selected-component node to ensure that the preanalysis of the\n+         --  inherited condition rewrites these dispatching calls in the\n+         --  correct context to avoid reporting spurious errors.\n+\n+         Restore_Original_Selected_Component;\n+\n          --  Traverse Expr and clear the Controlling_Argument of calls to\n          --  nonabstract functions. Required since the preanalyzed condition\n          --  is not yet installed on its definite context and will be cloned\n@@ -4373,103 +4428,9 @@ package body Contracts is\n            (Par_Subp : Entity_Id;\n             Subp     : Entity_Id) return Node_Id\n          is\n-            Installed_Calls : constant Elist_Id := New_Elmt_List;\n-\n-            procedure Install_Original_Selected_Component (Expr : Node_Id);\n-            --  Traverse the given expression searching for dispatching calls\n-            --  to functions whose original nodes was a selected component,\n-            --  and replacing them temporarily by a copy of their original\n-            --  node. Modified calls are stored in the list Installed_Calls\n-            --  (to undo this work later).\n-\n-            procedure Restore_Dispatching_Calls (Expr : Node_Id);\n-            --  Undo the work done by Install_Original_Selected_Component.\n-\n-            -----------------------------------------\n-            -- Install_Original_Selected_Component --\n-            -----------------------------------------\n-\n-            procedure Install_Original_Selected_Component (Expr : Node_Id) is\n-               function Install_Node (N : Node_Id) return Traverse_Result;\n-               --  Process a single node\n-\n-               ------------------\n-               -- Install_Node --\n-               ------------------\n-\n-               function Install_Node (N : Node_Id) return Traverse_Result is\n-                  New_N    : Node_Id;\n-                  Orig_Nod : Node_Id;\n-\n-               begin\n-                  if Nkind (N) = N_Function_Call\n-                    and then Nkind (Original_Node (N)) = N_Selected_Component\n-                    and then Is_Dispatching_Operation (Entity (Name (N)))\n-                  then\n-                     Orig_Nod := Original_Node (N);\n-\n-                     --  Temporarily use the original node field to keep the\n-                     --  reference to this node (to undo this work later!).\n-\n-                     New_N := New_Copy (N);\n-                     Set_Original_Node (New_N, Orig_Nod);\n-                     Append_Elmt (New_N, Installed_Calls);\n-\n-                     Rewrite (N, Orig_Nod);\n-                     Set_Original_Node (N, New_N);\n-                  end if;\n-\n-                  return OK;\n-               end Install_Node;\n-\n-               procedure Install_Nodes is new Traverse_Proc (Install_Node);\n-\n-            begin\n-               Install_Nodes (Expr);\n-            end Install_Original_Selected_Component;\n-\n-            -------------------------------\n-            -- Restore_Dispatching_Calls --\n-            -------------------------------\n-\n-            procedure Restore_Dispatching_Calls (Expr : Node_Id) is\n-               function Restore_Node (N : Node_Id) return Traverse_Result;\n-               --  Process a single node\n-\n-               ------------------\n-               -- Restore_Node --\n-               ------------------\n-\n-               function Restore_Node (N : Node_Id) return Traverse_Result is\n-                  Orig_Sel_N : Node_Id;\n-\n-               begin\n-                  if Nkind (N) = N_Selected_Component\n-                    and then Nkind (Original_Node (N)) = N_Function_Call\n-                    and then Contains (Installed_Calls, Original_Node (N))\n-                  then\n-                     Orig_Sel_N := Original_Node (Original_Node (N));\n-                     pragma Assert (Nkind (Orig_Sel_N) = N_Selected_Component);\n-                     Rewrite (N, Original_Node (N));\n-                     Set_Original_Node (N, Orig_Sel_N);\n-                  end if;\n-\n-                  return OK;\n-               end Restore_Node;\n-\n-               procedure Restore_Nodes is new Traverse_Proc (Restore_Node);\n-\n-            begin\n-               Restore_Nodes (Expr);\n-            end Restore_Dispatching_Calls;\n-\n-            --  Local variables\n-\n             Assoc_List     : constant Elist_Id := New_Elmt_List;\n             Par_Formal_Id  : Entity_Id := First_Formal (Par_Subp);\n             Subp_Formal_Id : Entity_Id := First_Formal (Subp);\n-            New_Expr       : Node_Id;\n-            Class_Cond     : Node_Id;\n \n          --  Start of processing for Inherit_Condition\n \n@@ -4482,18 +4443,9 @@ package body Contracts is\n                Next_Formal (Subp_Formal_Id);\n             end loop;\n \n-            --  In order to properly preanalyze an inherited preanalyzed\n-            --  condition that has occurrences of the Object.Operation\n-            --  notation we must restore the original node; otherwise we\n-            --  would report spurious errors.\n-\n-            Class_Cond := Class_Condition (Kind, Par_Subp);\n-\n-            Install_Original_Selected_Component (Class_Cond);\n-            New_Expr := New_Copy_Tree (Class_Cond);\n-            Restore_Dispatching_Calls (Class_Cond);\n-\n-            return New_Copy_Tree (New_Expr, Map => Assoc_List);\n+            return New_Copy_Tree\n+                     (Source => Class_Condition (Kind, Par_Subp),\n+                      Map    => Assoc_List);\n          end Inherit_Condition;\n \n          ----------------------"}]}