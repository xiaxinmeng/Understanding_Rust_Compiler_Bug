{"sha": "81ad38a60d9d5f1b612b3aae3721ded0e35deb74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFhZDM4YTYwZDlkNWYxYjYxMmIzYWFlMzcyMWRlZDBlMzVkZWI3NA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-01-09T15:42:07Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-01-09T15:42:07Z"}, "message": "m32r.c (m32r_expand_block_move): Call gen_movestrsi_internal with two more arguments.\n\n\t* config/m32r/m32r.c (m32r_expand_block_move): Call\n\tgen_movestrsi_internal with two more arguments.\n\t(m32r_output_block_move): Adjust operand numbers.\n\tProperly update the source and destination pointers.\n\t* config/m32r/m32r.md (movstrsi_internal): Use 'r' instead of\n\t'r+'.  Change the set detinations to match_operand.\n\nFrom-SVN: r75585", "tree": {"sha": "6a61eef2978a77abfea9ddf4b214f0ae88c1643d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a61eef2978a77abfea9ddf4b214f0ae88c1643d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81ad38a60d9d5f1b612b3aae3721ded0e35deb74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ad38a60d9d5f1b612b3aae3721ded0e35deb74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ad38a60d9d5f1b612b3aae3721ded0e35deb74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ad38a60d9d5f1b612b3aae3721ded0e35deb74/comments", "author": null, "committer": null, "parents": [{"sha": "b816f339f40ce7d9b5d9aa404de8642598ffc205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b816f339f40ce7d9b5d9aa404de8642598ffc205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b816f339f40ce7d9b5d9aa404de8642598ffc205"}], "stats": {"total": 97, "additions": 72, "deletions": 25}, "files": [{"sha": "55f1f8a8c61575a15cdd51149b58b100a089f4fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ad38a60d9d5f1b612b3aae3721ded0e35deb74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ad38a60d9d5f1b612b3aae3721ded0e35deb74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81ad38a60d9d5f1b612b3aae3721ded0e35deb74", "patch": "@@ -1,3 +1,12 @@\n+2004-01-09  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/m32r/m32r.c (m32r_expand_block_move): Call\n+\tgen_movestrsi_internal with two more arguments.\n+\t(m32r_output_block_move): Adjust operand numbers.\n+\tProperly update the source and destination pointers.\n+\t* config/m32r/m32r.md (movstrsi_internal): Use 'r' instead of\n+\t'r+'.  Change the set detinations to match_operand.\n+\n 2004-01-09  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* final.c (FIRST_INSN_ADDRESS): Remove."}, {"sha": "f1c5c35383d6cf02663556c75a4f51bebecb629b", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ad38a60d9d5f1b612b3aae3721ded0e35deb74/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ad38a60d9d5f1b612b3aae3721ded0e35deb74/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=81ad38a60d9d5f1b612b3aae3721ded0e35deb74", "patch": "@@ -2809,6 +2809,8 @@ m32r_expand_block_move (rtx operands[])\n       rtx final_src = NULL_RTX;\n       rtx at_a_time = GEN_INT (MAX_MOVE_BYTES);\n       rtx rounded_total = GEN_INT (bytes);\n+      rtx new_dst_reg = gen_reg_rtx (SImode);\n+      rtx new_src_reg = gen_reg_rtx (SImode);\n \n       /* If we are going to have to perform this loop more than\n \t once, then generate a label and compute the address the\n@@ -2834,7 +2836,10 @@ m32r_expand_block_move (rtx operands[])\n \t to the word after the end of the source block, and dst_reg to point\n \t to the last word of the destination block, provided that the block\n \t is MAX_MOVE_BYTES long.  */\n-      emit_insn (gen_movstrsi_internal (dst_reg, src_reg, at_a_time));\n+      emit_insn (gen_movstrsi_internal (dst_reg, src_reg, at_a_time,\n+\t\t\t\t\tnew_dst_reg, new_src_reg));\n+      emit_move_insn (dst_reg, new_dst_reg);\n+      emit_move_insn (src_reg, new_src_reg);\n       emit_insn (gen_addsi3 (dst_reg, dst_reg, GEN_INT (4)));\n       \n       if (bytes > MAX_MOVE_BYTES)\n@@ -2845,7 +2850,9 @@ m32r_expand_block_move (rtx operands[])\n     }\n \n   if (leftover)\n-    emit_insn (gen_movstrsi_internal (dst_reg, src_reg, GEN_INT (leftover)));\n+    emit_insn (gen_movstrsi_internal (dst_reg, src_reg, GEN_INT (leftover),\n+\t\t\t\t      gen_reg_rtx (SImode),\n+\t\t\t\t      gen_reg_rtx (SImode)));\n }\n \n \f\n@@ -2881,17 +2888,17 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t{\n \t  if (first_time)\n \t    {\n-\t      output_asm_insn (\"ld\\t%3, %p1\", operands);\n-\t      output_asm_insn (\"ld\\t%4, %p1\", operands);\n-\t      output_asm_insn (\"st\\t%3, @%0\", operands);\n-\t      output_asm_insn (\"st\\t%4, %s0\", operands);\n+\t      output_asm_insn (\"ld\\t%5, %p1\", operands);\n+\t      output_asm_insn (\"ld\\t%6, %p1\", operands);\n+\t      output_asm_insn (\"st\\t%5, @%0\", operands);\n+\t      output_asm_insn (\"st\\t%6, %s0\", operands);\n \t    }\n \t  else\n \t    {\n-\t      output_asm_insn (\"ld\\t%3, %p1\", operands);\n-\t      output_asm_insn (\"ld\\t%4, %p1\", operands);\n-\t      output_asm_insn (\"st\\t%3, %s0\", operands);\n-\t      output_asm_insn (\"st\\t%4, %s0\", operands);\n+\t      output_asm_insn (\"ld\\t%5, %p1\", operands);\n+\t      output_asm_insn (\"ld\\t%6, %p1\", operands);\n+\t      output_asm_insn (\"st\\t%5, %s0\", operands);\n+\t      output_asm_insn (\"st\\t%6, %s0\", operands);\n \t    }\n \n \t  bytes -= 8;\n@@ -2901,15 +2908,15 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t  if (bytes > 4)\n \t    got_extra = 1;\n \t  \n-\t  output_asm_insn (\"ld\\t%3, %p1\", operands);\n+\t  output_asm_insn (\"ld\\t%5, %p1\", operands);\n \t  \n \t  if (got_extra)\n-\t    output_asm_insn (\"ld\\t%4, %p1\", operands);\n+\t    output_asm_insn (\"ld\\t%6, %p1\", operands);\n \t\t\n \t  if (first_time)\n-\t    output_asm_insn (\"st\\t%3, @%0\", operands);\n+\t    output_asm_insn (\"st\\t%5, @%0\", operands);\n \t  else\n-\t    output_asm_insn (\"st\\t%3, %s0\", operands);\n+\t    output_asm_insn (\"st\\t%5, %s0\", operands);\n \n \t  bytes -= 4;\n \t}\n@@ -2921,20 +2928,25 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t     valid memory [since we don't get called if things aren't properly\n \t     aligned].  */\n \t  int dst_offset = first_time ? 0 : 4;\n+\t  /* The amount of increment we have to make to the\n+\t     destination pointer.  */\n+\t  int dst_inc_amount = dst_offset + bytes - 4;\n+\t  /* The same for the source pointer.  */\n+\t  int src_inc_amount = bytes;\n \t  int last_shift;\n \t  rtx my_operands[3];\n \n \t  /* If got_extra is true then we have already loaded\n \t     the next word as part of loading and storing the previous word.  */\n \t  if (! got_extra)\n-\t    output_asm_insn (\"ld\\t%4, @%1\", operands);\n+\t    output_asm_insn (\"ld\\t%6, @%1\", operands);\n \n \t  if (bytes >= 2)\n \t    {\n \t      bytes -= 2;\n \n-\t      output_asm_insn (\"sra3\\t%3, %4, #16\", operands);\n-\t      my_operands[0] = operands[3];\n+\t      output_asm_insn (\"sra3\\t%5, %6, #16\", operands);\n+\t      my_operands[0] = operands[5];\n \t      my_operands[1] = GEN_INT (dst_offset);\n \t      my_operands[2] = operands[0];\n \t      output_asm_insn (\"sth\\t%0, @(%1,%2)\", my_operands);\n@@ -2955,14 +2967,36 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \n \t  if (bytes > 0)\n \t    {\n-\t      my_operands[0] = operands[4];\n+\t      my_operands[0] = operands[6];\n \t      my_operands[1] = GEN_INT (last_shift);\n \t      output_asm_insn (\"srai\\t%0, #%1\", my_operands);\n-\t      my_operands[0] = operands[4];\n+\t      my_operands[0] = operands[6];\n \t      my_operands[1] = GEN_INT (dst_offset);\n \t      my_operands[2] = operands[0];\n \t      output_asm_insn (\"stb\\t%0, @(%1,%2)\", my_operands);\n \t    }\n+\n+\t  /* Update the destination pointer if needed.  We have to do\n+\t     this so that the patterns matches what we output in this\n+\t     function.  */\n+\t  if (dst_inc_amount\n+\t      && !find_reg_note (insn, REG_UNUSED, operands[0]))\n+\t    {\n+\t      my_operands[0] = operands[0];\n+\t      my_operands[1] = GEN_INT (dst_inc_amount);\n+\t      output_asm_insn (\"addi\\t%0, #%1\", my_operands);\n+\t    }\n+\t  \n+\t  /* Update the source pointer if needed.  We have to do this\n+\t     so that the patterns matches what we output in this\n+\t     function.  */\n+\t  if (src_inc_amount\n+\t      && !find_reg_note (insn, REG_UNUSED, operands[1]))\n+\t    {\n+\t      my_operands[0] = operands[1];\n+\t      my_operands[1] = GEN_INT (src_inc_amount);\n+\t      output_asm_insn (\"addi\\t%0, #%1\", my_operands);\n+\t    }\n \t  \n \t  bytes = 0;\n \t}"}, {"sha": "5a43ff74995157c15264e23725c80e15e06268c1", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ad38a60d9d5f1b612b3aae3721ded0e35deb74/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ad38a60d9d5f1b612b3aae3721ded0e35deb74/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=81ad38a60d9d5f1b612b3aae3721ded0e35deb74", "patch": "@@ -2675,13 +2675,17 @@\n ;; Insn generated by block moves\n \n (define_insn \"movstrsi_internal\"\n-  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+r\"))\t;; destination\n-\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+r\")))\t;; source\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\t;; destination\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\t;; source\n    (use (match_operand:SI 2 \"m32r_block_immediate_operand\" \"J\"));; # bytes to move\n-   (set (match_dup 0) (plus:SI (match_dup 0) (minus:SI (match_dup 2) (const_int 4))))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (match_dup 2)))\n-   (clobber (match_scratch:SI 3 \"=&r\"))\t\t\t\t;; temp 1\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\t\t\t;; temp 2\n+   (set (match_operand:SI 3 \"register_operand\" \"=0\")\n+\t(plus:SI (match_dup 0)\n+\t\t (minus (match_dup 2) (const_int 4))))\n+   (set (match_operand:SI 4 \"register_operand\" \"=1\")\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 2)))\n+   (clobber (match_scratch:SI 5 \"=&r\"))  ;; temp1\n+   (clobber (match_scratch:SI 6 \"=&r\"))] ;; temp2\n   \"\"\n   \"* m32r_output_block_move (insn, operands); return \\\"\\\"; \"\n   [(set_attr \"type\"\t\"store8\")"}]}