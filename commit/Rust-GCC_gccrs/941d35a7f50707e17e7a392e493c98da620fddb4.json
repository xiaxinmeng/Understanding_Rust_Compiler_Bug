{"sha": "941d35a7f50707e17e7a392e493c98da620fddb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxZDM1YTdmNTA3MDdlMTdlN2EzOTJlNDkzYzk4ZGE2MjBmZGRiNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-24T03:56:14Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-24T03:56:14Z"}, "message": "Initial revision\n\nFrom-SVN: r134", "tree": {"sha": "3154354e063158045cc418614374521daf3431aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3154354e063158045cc418614374521daf3431aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/941d35a7f50707e17e7a392e493c98da620fddb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941d35a7f50707e17e7a392e493c98da620fddb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/941d35a7f50707e17e7a392e493c98da620fddb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941d35a7f50707e17e7a392e493c98da620fddb4/comments", "author": null, "committer": null, "parents": [{"sha": "f451fe61fcc580b320fcdcdd054bab0bb1cd2dc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f451fe61fcc580b320fcdcdd054bab0bb1cd2dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f451fe61fcc580b320fcdcdd054bab0bb1cd2dc3"}], "stats": {"total": 1093, "additions": 1093, "deletions": 0}, "files": [{"sha": "a93eab79ee5021775d05c9e6a567bb495e79aaa4", "filename": "gcc/config/m68k/3b1.h", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941d35a7f50707e17e7a392e493c98da620fddb4/gcc%2Fconfig%2Fm68k%2F3b1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941d35a7f50707e17e7a392e493c98da620fddb4/gcc%2Fconfig%2Fm68k%2F3b1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2F3b1.h?ref=941d35a7f50707e17e7a392e493c98da620fddb4", "patch": "@@ -0,0 +1,480 @@\n+/* Definitions of target machine for GNU compiler.\n+   AT&T UNIX PC version (pc7300, 3b1)\n+\n+   Written by Alex Crain\n+   bug reports to alex@umbc3.umd.edu\n+\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define SGS_SWAP_W\t\t/* Use swap.w rather than just plain swap */\n+#define SGS_SWITCH_TABLES\t/* Different switch table handling */\n+\n+#include \"hp320.h\"\n+\n+/* See m68k.h.  0 means 680[01]0 with no 68881.  */\n+\n+#undef TARGET_DEFAULT\n+#define\tTARGET_DEFAULT 0\n+\n+/* -m68020 requires special flags to the assembler.  */\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{m68020:-68020}%{!m68020:-68010} %{m68881:-68881}\"\n+\n+/* we use /lib/libp/lib*  when profiling */\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!shlib:%{p:-L/lib/libp} %{pg:-L/lib/libp} -lc}\"\n+\n+/* shared libraries need to use crt0s.o  */\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n+   %{shlib:crt0s.o%s shlib.ifile%s} \"\n+\n+/* cpp has to support a #sccs directive for the /usr/include files */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Make output for SDB.  */\n+\n+#define SDB_DEBUGGING_INFO\n+\n+/* The .file command should always begin the output.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) \\\n+output_file_directive ((FILE), main_input_filename)\n+\n+/* Don't try to define `gcc_compiled.' since the assembler might not\n+   accept symbols with periods and GDB doesn't run on this machine anyway.  */\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+/* Define __HAVE_68881__ in preprocessor if -m68881 is specified.\n+   This will control the use of inline 68881 insns in certain macros.  */\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{m68881:-D__HAVE_68881__}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+/* ihnp4!lmayk!lgm@eddie.mit.edu says mc68000 and m68k should not be here.  */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dmc68k -Dunix -Dunixpc\"\n+\n+#undef REGISTER_NAMES\n+#define REGISTER_NAMES \\\n+{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n+ \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%fp\", \"%sp\",\t\\\n+ \"%f0\", \"%f1\", \"%f2\", \"%f3\", \"%f4\", \"%f5\", \"%f6\", \"%f7\"}\n+\n+/* Specify how to pad function arguments.\n+   Value should be `upward', `downward' or `none'.\n+   Same as the default, except no padding for large or variable-size args.  */\n+\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n+  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n+    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n+       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n+    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n+   ? downward : none)\n+\n+/* Override part of the obstack macros.  */\n+\n+#define __PTR_TO_INT(P) ((int)(P))\n+#define __INT_TO_PTR(P) ((char *)(P))\n+\n+/* Override parts of m68k.h to fit the SGS-3b1 assembler.  */\n+\n+#undef TARGET_VERSION\n+#undef ASM_FORMAT_PRIVATE_NAME\n+#undef ASM_OUTPUT_DOUBLE\n+#undef ASM_OUTPUT_FLOAT\n+#undef ASM_OUTPUT_ALIGN\n+#undef ASM_OUTPUT_SOURCE_FILENAME\n+#undef ASM_OUTPUT_SOURCE_LINE\n+#undef PRINT_OPERAND_ADDRESS\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#undef FUNCTION_PROFILER\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#undef ASM_OUTPUT_OPCODE\n+#undef ASM_OUTPUT_LOCAL\n+#undef ASM_OUTPUT_LABELREF\n+#undef ASM_OUTPUT_ASCII\n+\n+#define TARGET_VERSION fprintf (stderr, \" (68k, SGS/AT&T unixpc syntax)\");\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n+  sprintf ((OUTPUT), \"%s_%%%d\", (NAME), (LABELNO)))\n+\n+/* The unixpc doesn't know about double's and float's */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+do { union { double d; long l[2]; } tem;\t\t\\\n+     tem.d = (VALUE);\t\t\t\t\t\\\n+     fprintf(FILE, \"\\tlong 0x%x,0x%x\\n\", tem.l[0], tem.l[1]); \\\n+   } while (0)\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+do { union { float f; long l;} tem;\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\\\n+     fprintf (FILE, \"\\tlong 0x%x\\n\", tem.l);\t\\\n+   } while (0)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) == 1)\t\t\t\\\n+    fprintf (FILE, \"\\teven\\n\");\t\\\n+  else if ((LOG) != 0)\t\t\t\\\n+    abort ();\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\tspace %d\\n\", (SIZE))\n+\n+/* Can't use ASM_OUTPUT_SKIP in text section; it doesn't leave 0s.  */\n+\n+#define ASM_NO_SKIP_IN_TEXT 1\n+\n+/* The beginnings of sdb support... */\n+\n+#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n+  fprintf (FILE, \"\\tfile\\t\\\"%s\\\"\\n\", FILENAME)\n+\n+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\t\\\n+  fprintf (FILE, \"\\tln\\t%d\\n\",\t\t\t\\\n+\t   (sdb_begin_function_line\t\t\\\n+\t    ? last_linenum - sdb_begin_function_line : 1))\n+\n+/* Yet another null terminated string format. */\n+\n+#define ASM_OUTPUT_ASCII(FILE,PTR,LEN) \\\n+  { register int sp = 0, lp = 0; \\\n+    fprintf ((FILE), \"\\tbyte\\t\"); \\\n+  loop: \\\n+    if ((PTR)[sp] > ' ' && ! ((PTR)[sp] & 0x80) && (PTR)[sp] != '\\\\') \\\n+      { lp += 3; \\\n+\tfprintf ((FILE), \"'%c\", (PTR)[sp]); } \\\n+    else \\\n+      { lp += 5; \\\n+\tfprintf ((FILE), \"0x%x\", (PTR)[sp]); } \\\n+    if (++sp < (LEN)) \\\n+      {\tif (lp > 60) \\\n+\t  { lp = 0; \\\n+\t    fprintf ((FILE), \"\\n%s \", ASCII_DATA_ASM_OP); }\t\\\n+\telse \\\n+\t  putc (',', (FILE)); \\\n+\tgoto loop; } \\\n+    putc ('\\n', (FILE)); }\n+\n+/* Note that in the case of the movhi which fetches an element of\n+   an ADDR_DIFF_VEC the offset output is too large by 2.\n+   This is because the 3b1 assembler refuses to subtract 2.\n+   ASM_OUTPUT_CASE_LABEL, below, compensates for this.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset;\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PRE_DEC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case POST_INC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n+      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n+\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n+\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n+/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+  */\t\t\t\t\t\t\t\t\t\\\n+      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n+      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n+\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { int scale = 1;\t\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n+\t    fprintf (FILE, \"LD%%%d(%%pc,%s.w\",\t\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"LD%%%d(%%pc,%s.l\",\t\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  fprintf (FILE, \")\");\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { fprintf (FILE, \"LD%%%d(%%pc,%s.l\",\t\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   reg_names[REGNO (breg)]);\t\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n+\t{ int scale = 1;\t\t\t\t\t\t\\\n+\t  if (breg == 0)\t\t\t\t\t\t\\\n+\t    abort ();\t\t\t\t\t\t\t\\\n+\t  if (addr != 0)\t\t\t\t\t\t\\\n+\t    output_addr_const (FILE, addr);\t\t\t\t\\\n+\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n+\t  if (ireg != 0)\t\t\t\t\t        \\\n+\t    putc (',', FILE);\t\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n+\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n+\t  else if (ireg != 0)\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n+\t{ fprintf (FILE, \"LD%%%d(%%pc,%s.w)\",\t\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n+\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n+\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n+\tfprintf (FILE, \"%d\", INTVAL (addr));\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        output_addr_const (FILE, addr);\t\t\t\t\t\\\n+    }}\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n+  sprintf ((LABEL), \"%s%%%d\", (PREFIX), (NUM))\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+    fprintf (FILE, \"%s%%%d:\\n\", PREFIX, NUM)\n+\n+/* Must put address in  %a0 , not  %d0 . -- LGM, 7/15/88 */\n+#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n+    fprintf (FILE, \"\\tmov.l &LP%%%d,%%a0\\n\\tjsr mcount\\n\", (LABEL_NO))\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\\\n+    fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n+    fprintf (FILE, \"\\tshort L%%%d-L%%%d\\n\", (VALUE), (REL))\n+\n+/* ihnp4!lmayk!lgm says that `short 0' triggers assembler bug;\n+   `short L%nn-L%nn' supposedly works.  */\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n+  if (! RTX_INTEGRATED_P (TABLE))\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\",\t\t\t\t\\\n+\t     XVECLEN (PATTERN (TABLE), 1), (PREFIX), (NUM));\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\\tshort %s%%%d-%s%%%d\\n\",\t\\\n+\t     XVECLEN (PATTERN (TABLE), 1) + 1, (PREFIX), (NUM),\t\t\\\n+\t     (PREFIX), (NUM), (PREFIX), (NUM))\n+\n+/* At end of a switch table, define LD%n iff the symbol LI%n was defined.  */\n+#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\\\n+  if (RTX_INTEGRATED_P (TABLE))\t\t\t\t\\\n+    fprintf (FILE, \"\\tset LD%%%d,L%%%d-LI%%%d\\n\", (NUM), (NUM), (NUM))\n+\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n+{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n+    { ++(PTR);\t\t\t\t\t\t\\\n+      while (*(PTR) != ' ')\t\t\t\t\\\n+\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n+      fprintf ((FILE), \".w\"); }\t\t\t\t\\\n+  else if ((PTR)[0] == 'f')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (!strncmp ((PTR), \"fmove\", 5))\t\t\t\\\n+\t{ fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\\\n+      else if (!strncmp ((PTR), \"fbne\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"fbneq\"); (PTR) += 4; }\t\\\n+    }\t\t\t\t\t\t\t\\\n+/* MOVE, MOVEA, MOVEQ, MOVEC ==> MOV\t*/\t\t\\\n+  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n+    { fprintf ((FILE), \"mov\"); (PTR) += 4;\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'a' ||\t\\\n+\t   (PTR)[0] == 'c') (PTR)++; }\t\t\t\\\n+/* SUB, SUBQ, SUBA, SUBI ==> SUB */\t\t\t\\\n+  else if ((PTR)[0] == 's' && (PTR)[1] == 'u' \t\t\\\n+\t   && (PTR)[2] == 'b')\t\t\t\t\\\n+    { fprintf ((FILE), \"sub\"); (PTR) += 3;\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'i' || \t\\\n+\t   (PTR)[0] == 'a') (PTR)++; }\t\t\t\\\n+/* CMP, CMPA, CMPI, CMPM ==> CMP\t*/\t\t\\\n+  else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n+\t   && (PTR)[2] == 'p')\t\t\t\t\\\n+    { fprintf ((FILE), \"cmp\"); (PTR) += 3;\t\t\\\n+       if ((PTR)[0] == 'a' || (PTR)[0] == 'i' || \t\\\n+\t   (PTR)[0] == 'm') (PTR)++; }\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\tlcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\f\n+/* Override usual definitions of SDB output macros.\n+   These definitions differ only in the absence of the period\n+   at the beginning of the name of the directive\n+   and in the use of `~' as the symbol for the current location.  */\n+\n+#define PUT_SDB_SCL(a) fprintf(asm_out_file, \"\\tscl\\t%d;\", (a))\n+#define PUT_SDB_INT_VAL(a) fprintf (asm_out_file, \"\\tval\\t%d;\", (a))\n+#define PUT_SDB_VAL(a)\t\t\t\t\\\n+( fputs (\"\\tval\\t\", asm_out_file),\t\t\\\n+  output_addr_const (asm_out_file, (a)),\t\\\n+  fputc (';', asm_out_file))\n+\n+#define PUT_SDB_DEF(a)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\tdef\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, a); \t\\\n+     fprintf (asm_out_file, \";\"); } while (0)\n+\n+#define PUT_SDB_PLAIN_DEF(a) fprintf(asm_out_file,\"\\tdef\\t~%s;\",a)\n+#define PUT_SDB_ENDEF fputs(\"\\tendef\\n\", asm_out_file)\n+#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\ttype\\t0%o;\", a)\n+#define PUT_SDB_SIZE(a) fprintf(asm_out_file, \"\\tsize\\t%d;\", a)\n+#define PUT_SDB_START_DIM fprintf(asm_out_file, \"\\tdim\\t\")\n+\n+#define PUT_SDB_TAG(a)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, a);\t\\\n+     fprintf (asm_out_file, \";\"); } while (0)\n+\n+#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~bb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~eb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~bf;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~ef;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_EPILOGUE_END(NAME)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t%s;\\tval\\t~;\\tscl\\t-1;\\tendef\\n\",\t\\\n+\t   (NAME))\n+\n+#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n+  sprintf ((BUFFER), \"~%dfake\", (NUMBER));\n+\n+/* Define subroutines to call to handle multiply, divide, and remainder.\n+   Use the subroutines that the 3b1's library provides.\n+   The `*' prevents an underscore from being prepended by the compiler.  */\n+\n+#define DIVSI3_LIBCALL \"*ldiv\"\n+#define UDIVSI3_LIBCALL \"*uldiv\"\n+#define MODSI3_LIBCALL \"*lrem\"\n+#define UMODSI3_LIBCALL \"*ulrem\"\n+#define MULSI3_LIBCALL \"*lmul\"\n+#define UMULSI3_LIBCALL \"*ulmul\""}, {"sha": "dbf19b37802c896e433117fc42e7bdf0c694ee3c", "filename": "gcc/config/m68k/tower-as.h", "status": "added", "additions": 613, "deletions": 0, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941d35a7f50707e17e7a392e493c98da620fddb4/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941d35a7f50707e17e7a392e493c98da620fddb4/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ftower-as.h?ref=941d35a7f50707e17e7a392e493c98da620fddb4", "patch": "@@ -0,0 +1,613 @@\n+/* Definitions of target machine for GNU compiler.\n+   Copyright (C) 1990 Free Software Foundation, Inc.\n+\n+   Written by Robert Andersson, International Systems, Oslo, Norway.\n+   Send bug reports, questions and improvements to ra@intsys.no.\n+\n+   For NCR Tower 32/4x0 and 32/6x0 running System V Release 3.\n+   This file outputs assembler source suitable for the native Tower as\n+   and with sdb debugging symbols.  See tower.h for more comments.\n+\n+   This file was based on m68k.h, hp320.h and 3b1.h\n+   as of the 1.37.1 version.\n+\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"tower.h\"\n+\n+\n+/* Define __HAVE_68881 in preprocessor only if -m68881 is specified.\n+   This will control the use of inline 68881 insns in certain macros.\n+   Also, define special define used to identify the Tower assembler.  */\n+\n+#define CPP_SPEC \"-D__TOWER_ASM__ %{m68881:-D__HAVE_68881__}\"\n+\n+/* The startfiles and libraries depend on the -p and -m68881 options.\n+   The Tower does not support the -pg option.  */\n+\n+#define STARTFILE_SPEC                                         \\\n+\"%{p:%{m68881:/usr/lib/fp/mcrt1.o}%{!m68881:/lib/mcrt1.o}}     \\\n+ %{!p:%{m68881:/usr/lib/fp/crt1.o}%{!m68881:/lib/crt1.o}}\"\n+\n+/* These four macros control how m68k.md is expanded.  */\n+\n+#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n+#define SGS\t\t\t/* Uses SGS assembler */\n+#define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n+#define SGS_NO_LI\t\t/* Suppress jump table label usage */\n+\n+/* Turn on SDB debugging info.  */\n+\n+#define SDB_DEBUGGING_INFO\n+\n+/* This is only useful if gdb is changed, but doesn't harm anyway.  */\n+\n+#define ASM_IDENTIFY_GCC(FILE) \\\n+  fprintf (FILE, \"gcc2_compiled%%:\\n\")\n+\n+/* All the ASM_OUTPUT macros need to conform to the Tower as syntax.  */\n+\n+#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n+  fprintf (FILE, \"\\tfile\\t\\\"%s\\\"\\n\", FILENAME)\n+\n+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\t\\\n+  fprintf (FILE, \"\\tln\\t%d\\n\",\t\t\t\\\n+\t   (sdb_begin_function_line\t\t\\\n+\t    ? last_linenum - sdb_begin_function_line : 1))\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"\\tident\\t\\\"%s\\\" \\n\", NAME)\n+\n+#define ASM_OUTPUT_ASCII(FILE,PTR,LEN) \\\n+  { register int sp = 0, lp = 0; \\\n+    fprintf ((FILE), \"\\tbyte\\t\"); \\\n+  loop: \\\n+    if ((PTR)[sp] > ' ' && ! ((PTR)[sp] & 0x80) && (PTR)[sp] != '\\\\') \\\n+      { lp += 3; \\\n+\tfprintf ((FILE), \"'%c\", (PTR)[sp]); } \\\n+    else \\\n+      { lp += 5; \\\n+\tfprintf ((FILE), \"0x%x\", (PTR)[sp]); } \\\n+    if (++sp < (LEN)) \\\n+      {\tif (lp > 60) \\\n+\t  { lp = 0; \\\n+\t    fprintf ((FILE), \"\\n\\tbyte\\t\"); }\t\\\n+\telse \\\n+\t  putc (',', (FILE)); \\\n+\tgoto loop; } \\\n+    putc ('\\n', (FILE)); }\n+\n+/* Translate Motorola opcodes such as `jbeq'\n+   into SGS/Tower opcodes such as `beq.w'.\n+   Change `move' to `mov'.\n+   Change `cmpm' to `cmp'.\n+   Change `divsl' to `tdivs'.\n+   Change `divul' to `tdivu'.\n+   Change `ftst' to `ftest'.\n+   Change `fmove' to `fmov'.  */\n+\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n+{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n+    { ++(PTR);\t\t\t\t\t\t\\\n+      while (*(PTR) != ' ')\t\t\t\t\\\n+\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n+      fprintf ((FILE), \".w\"); }\t\t\t\t\\\n+  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n+    { fprintf ((FILE), \"mov\"); (PTR) += 4; }\t\t\\\n+  else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n+\t   && (PTR)[2] == 'p' && (PTR)[3] == 'm')\t\\\n+    { fprintf ((FILE), \"cmp\"); (PTR) += 4; }\t\t\\\n+  else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 's'\t\\\n+\t   && (PTR)[4] == 'l')\t\t\t\t\\\n+    { fprintf ((FILE), \"tdivs\"); (PTR) += 5; }\t\t\\\n+  else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'u'\t\\\n+\t   && (PTR)[4] == 'l')\t\t\t\t\\\n+    { fprintf ((FILE), \"tdivu\"); (PTR) += 5; }\t\t\\\n+  else if ((PTR)[0] == 'f' && (PTR)[1] == 't'\t\t\\\n+\t   && (PTR)[2] == 's' && (PTR)[3] == 't')\t\\\n+    { fprintf ((FILE), \"ftest\"); (PTR) += 4; }\t\t\\\n+  else if ((PTR)[0] == 'f' && (PTR)[1] == 'm'\t\t\\\n+\t   && (PTR)[2] == 'o' && (PTR)[3] == 'v' \t\\\n+\t   && (PTR)[4] == 'e')\t\t\t\t\\\n+    { fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\t\\\n+}\n+\n+\n+\f\n+/* Override parts of m68k.h to fit the Tower assembler.\n+   This section needs to track changes done to m68k.h in the future.  */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (68k, Motorola/SGS/Tower32 syntax)\");\n+\n+#undef BLOCK_PROFILER\n+#undef FUNCTION_BLOCK_PROFILER\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n+    fprintf (FILE, \"\\tmov.l &LP%%%d,%%a0\\n\\tjsr mcount%%\\n\", (LABEL_NO))\n+\n+/* The prologue is identical to the one in m68k.h except that the\n+   assembler syntax is different.  */\n+\n+#undef FUNCTION_PROLOGUE\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask = 0;\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    { if (TARGET_68020 || fsize < 0x8000)\t\t\t\\\n+        fprintf (FILE, \"\\tlink %%a6,&%d\\n\", -fsize);\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tlink %%a6,&0\\n\\tsub.l &%d,%%sp\\n\", fsize); }  \\\n+  for (regno = 24; regno < 56; regno++)                         \\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])       \\\n+      fprintf(FILE, \"\\tfpmoved %s,-(%%sp)\\n\",                   \\\n+\t      reg_names[regno]);                                \\\n+  for (regno = 16; regno < 24; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (regno - 16);\t\t\t\t\\\n+  if ((mask & 0xff) != 0)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tfmovm &0x%x,-(%%sp)\\n\", mask & 0xff);     \\\n+  mask = 0;\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (15 - regno);\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\t\t\t\\\n+  if (exact_log2 (mask) >= 0)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[15 - exact_log2 (mask)]); \\\n+  else if (mask) fprintf (FILE, \"\\tmovm.l &0x%x,-(%%sp)\\n\", mask); }\n+\n+/* The epilogue is identical to the one in m68k.h except that:\n+   a) The assembler syntax is different.\n+   b) Pointers are returned both in %d0 and %a0.\n+   c) FUNCTION_EXTRA_EPILOGUE is not needed.  */\n+\n+#undef FUNCTION_EPILOGUE\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask, fmask;\t\t\t\t\t\\\n+  register int nregs;\t\t\t\t\t\t\\\n+  int offset, foffset, fpoffset;   \t                        \\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n+  int big = 0;\t\t\t\t\t\t\t\\\n+  nregs = 0;  fmask = 0; fpoffset = 0;  \t\t\t\\\n+  for (regno = 24 ; regno < 56 ; regno++)\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      nregs++;\t\t\t\t\t\t\t\\\n+  fpoffset = nregs*8;\t\t\t\t\t\t\\\n+  nregs = 0;\t\t\t\t\t\t\t\\\n+  for (regno = 16; regno < 24; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; fmask |= 1 << (23 - regno); }\t\t\t\\\n+  foffset = fpoffset + nregs * 12;\t\t\t\t\\\n+  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n+  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n+  offset = foffset + nregs * 4;\t\t\t\t\t\\\n+  if (offset + fsize >= 0x8000 \t\t\t\t\t\\\n+      && frame_pointer_needed \t\t\t\t\t\\\n+      && (mask || fmask || fpoffset)) \t\t\t\t\\\n+    { fprintf (FILE, \"\\tmov.l &%d,%%a0\\n\", -fsize);\t\t\\\n+      fsize = 0, big = 1; }\t\t\t\t\t\\\n+  if (exact_log2 (mask) >= 0) {\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l -%d(%%a6,%%a0.l),%s\\n\",\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]);\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\",\t\t\t\\\n+\t       reg_names[exact_log2 (mask)]);\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmov.l -%d(%%a6),%s\\n\",\t\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]); }\t\\\n+  else if (mask) {\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l -%d(%%a6,%%a0.l),&0x%x\\n\",\t\\\n+\t       offset + fsize, mask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l (%%sp)+,&0x%x\\n\", mask);\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovm.l -%d(%%a6),&0x%x\\n\",\t\t\\\n+\t       offset + fsize, mask); }\t\t\t\t\\\n+  if (fmask) {\t\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovm -%d(%%a6,%%a0.l),&0x%x\\n\",\t\\\n+\t       foffset + fsize, fmask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovm (%%sp)+,&0x%x\\n\", fmask);\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovm -%d(%%a6),&0x%x\\n\",\t\t\\\n+\t       foffset + fsize, fmask); }\t\t\t\\\n+  if (fpoffset != 0)\t\t\t\t\t\t\\\n+    for (regno = 55; regno >= 24; regno--)\t\t\t\\\n+      if (regs_ever_live[regno] && ! call_used_regs[regno]) {\t\\\n+\tif (big)\t\t\t\t\t\t\\\n+\t  fprintf(FILE, \"\\tfpmoved -%d(%%a6,%%a0.l),%s\\n\",\t\\\n+\t\t  fpoffset + fsize, reg_names[regno]);\t\t\\\n+\telse if (! frame_pointer_needed)\t\t\t\\\n+\t  fprintf(FILE, \"\\tfpmoved (%%sp)+,%s\\n\",\t\t\\\n+\t\t  reg_names[regno]);\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  fprintf(FILE, \"\\tfpmoved -%d(%%a6),%s\\n\",\t\t\\\n+\t\t  fpoffset + fsize, reg_names[regno]);\t\t\\\n+\tfpoffset -= 8;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  if (current_function_returns_pointer)                         \\\n+    fprintf (FILE, \"\\tmov.l %%d0,%%a0\\n\");                      \\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tunlk %%a6\\n\");\t\t\t\t\\\n+  if (current_function_pops_args)\t\t\t\t\\\n+    fprintf (FILE, \"\\trtd &%d\\n\", current_function_pops_args);\t\\\n+  else fprintf (FILE, \"\\trts\\n\"); }\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#undef ASM_OUTPUT_REG_PUSH\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#undef ASM_OUTPUT_REG_POP\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\", reg_names[REGNO])\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) \\\n+( fprintf (FILE, \"#NO_APP\\n\"), \\\n+  output_file_directive ((FILE), main_input_filename))\n+\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP \"\\ttext\"\n+\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP \"\\tdata\"\n+\n+/* This says how to output an assembler line to define a global common symbol.\n+   We use SIZE rather than ROUNDED, as this is what the native cc does.  */\n+\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\tcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d\\n\", ((SIZE) == 0) ? (ROUNDED) : (SIZE)))\n+\n+/* This says how to output an assembler line to define a local common symbol.\n+   We use SIZE rather than ROUNDED, as this is what the native cc does.  */\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\tlcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d\\n\", ((SIZE) == 0) ? (ROUNDED) : (SIZE)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#undef ASM_FORMAT_PRIVATE_NAME\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 11),\t\\\n+  sprintf ((OUTPUT), \"%s%%%%%d\", (NAME), (LABELNO)))\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#undef ASM_GLOBALIZE_LABEL\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+do { fputs (\"\\tglobal \", FILE);         \\\n+     assemble_name (FILE, NAME);        \\\n+     fputs (\"\\n\", FILE);                \\\n+   } while (0)\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n+  sprintf ((LABEL), \"%s%%%d\", (PREFIX), (NUM))\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf ((FILE), \"%s%%%d:\\n\", (PREFIX), (NUM))\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n+  fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\",\t\t\t\t\\\n+           XVECLEN (PATTERN (TABLE), 1), (PREFIX), (NUM));\t\t\\\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+do { union { double d; long l[2]; } tem;\t\t\\\n+     tem.d = (VALUE);\t\t\t\t\t\\\n+     fprintf(FILE, \"\\tlong 0x%x,0x%x\\n\", tem.l[0], tem.l[1]); \\\n+   } while (0)\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+do { union { float f; long l;} tem;\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\\\n+     fprintf (FILE, \"\\tlong 0x%x\\n\", tem.l);\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#undef ASM_OUTPUT_INT\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tlong \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#undef ASM_OUTPUT_SHORT\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tshort \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#undef ASM_OUTPUT_CHAR\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tbyte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#undef ASM_OUTPUT_BYTE\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tbyte 0x%x\\n\", (VALUE))\n+\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\tshort L%%%d-L%%%d\\n\", (VALUE), (REL))\n+\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) == 1)\t\t\t\\\n+    fprintf (FILE, \"\\teven\\n\");\t        \\\n+  else if ((LOG) != 0)\t\t\t\\\n+    abort ();\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\tspace %d\\n\", (SIZE))\n+\n+#undef PRINT_OPERAND\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (CODE == '.') fprintf (FILE, \".\");\t\t\t\t\t\\\n+  else if (CODE == '#') fprintf (FILE, \"&\");\t\t\t\t\\\n+  else if (CODE == '-') fprintf (FILE, \"-(%%sp)\");\t\t\t\\\n+  else if (CODE == '+') fprintf (FILE, \"(%%sp)+\");\t\t\t\\\n+  else if (CODE == '@') fprintf (FILE, \"(%%sp)\");\t\t\t\\\n+  else if (CODE == '!') fprintf (FILE, \"%%cc\");\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      union { float f; int i; } u1;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      u1.f = u.d;\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"&0x%x\", u1.i); }\t\t\t\t        \\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n+      fprintf (FILE, \"&0x%x%08x\", CONST_DOUBLE_LOW (X), CONST_DOUBLE_HIGH (X));\\\n+  else { putc ('&', FILE); output_addr_const (FILE, X); }}\n+\n+/* Note that this contains a kludge that knows that the only reason\n+   we have an address (plus (label_ref...) (reg...))\n+   is in the insn before a tablejump, and we know that the table is\n+   exactly 10 bytes away.  */\n+\n+#undef PRINT_OPERAND_ADDRESS\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset;\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PRE_DEC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case POST_INC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n+      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n+\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n+\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n+/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+  */\t\t\t\t\t\t\t\t\t\\\n+      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n+      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n+\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { int scale = 1;\t\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n+\t    fprintf (FILE, \"10(%%pc,%s.w\",\t\t\t\t\\\n+\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"10(%%pc,%s.l\",\t\t\t\t\\\n+\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n+\t{ int scale = 1;\t\t\t\t\t\t\\\n+\t  if (breg == 0)\t\t\t\t\t\t\\\n+\t    abort ();\t\t\t\t\t\t\t\\\n+\t  if (addr != 0)\t\t\t\t\t\t\\\n+\t    output_addr_const (FILE, addr);\t\t\t\t\\\n+\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n+\t  if (ireg != 0)\t\t\t\t\t\t\\\n+\t    putc (',', FILE);\t\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n+\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n+\t  else if (ireg != 0)\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n+\t{ fprintf (FILE, \"10(%%pc,%s.w)\",\t\t\t\t\\\n+\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+        output_addr_const (FILE, addr);\t\t\t\t\t\\\n+    }}\n+\n+\n+\f\n+/* Override usual definitions of SDB output macros.\n+   These definitions differ only in the absence of the period\n+   at the beginning of the name of the directive\n+   and in the use of `~' as the symbol for the current location.  */\n+\n+#define PUT_SDB_SCL(a) fprintf(asm_out_file, \"\\tscl\\t%d;\", (a))\n+#define PUT_SDB_INT_VAL(a) fprintf (asm_out_file, \"\\tval\\t%d;\", (a))\n+#define PUT_SDB_VAL(a)\t\t\t\t\\\n+( fputs (\"\\tval\\t\", asm_out_file),\t\t\\\n+  output_addr_const (asm_out_file, (a)),\t\\\n+  fputc (';', asm_out_file))\n+\n+#define PUT_SDB_DEF(a)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\tdef\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, a); \t\\\n+     fprintf (asm_out_file, \";\"); } while (0)\n+\n+#define PUT_SDB_PLAIN_DEF(a) fprintf(asm_out_file,\"\\tdef\\t~%s;\",a)\n+#define PUT_SDB_ENDEF fputs(\"\\tendef\\n\", asm_out_file)\n+#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\ttype\\t0%o;\", a)\n+#define PUT_SDB_SIZE(a) fprintf(asm_out_file, \"\\tsize\\t%d;\", a)\n+#define PUT_SDB_DIM(a) fprintf(asm_out_file, \"\\tdim\\t%d;\", a)\n+\n+#define PUT_SDB_TAG(a)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, a);\t\\\n+     fprintf (asm_out_file, \";\"); } while (0)\n+\n+#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~bb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~eb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~bf;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t~ef;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n+\t   (LINE))\n+\n+#define PUT_SDB_EPILOGUE_END(NAME)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\tdef\\t%s;\\tval\\t~;\\tscl\\t-1;\\tendef\\n\",\t\\\n+\t   (NAME))\n+\n+#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n+  sprintf ((BUFFER), \"~%dfake\", (NUMBER));"}]}