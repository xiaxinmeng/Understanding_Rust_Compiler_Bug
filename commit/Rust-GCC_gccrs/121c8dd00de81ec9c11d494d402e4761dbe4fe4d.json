{"sha": "121c8dd00de81ec9c11d494d402e4761dbe4fe4d", "node_id": "C_kwDOANBUbNoAKDEyMWM4ZGQwMGRlODFlYzljMTFkNDk0ZDQwMmU0NzYxZGJlNGZlNGQ", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-19T13:38:53Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:24Z"}, "message": "gccrs const folding port: continue porting potential_constant_expression_1()\n\nFollowing functions are ported in this changeset:\n - resolve_nondeduced_context\n - instantiate_non_dependent_or_null\n - resolve_nondeduced_context_or_error\n - really_overloaded_fn\n - invalid_nonstatic_memfn_p\n - strip_top_quals\n - cxx_incomplete_type_inform\n - cxx_incomplete_type_diagnostic\n - cxx_incomplete_type_error\n\nFollowing structs, classes and enums are ported in this changeset:\n - stmt_tree_s\n - c_language_function\n - omp_declare_target_attr\n - cxx_binding\n - cxx_saved_binding\n - saved_scope\n - named_label_hash\n - language_function\n - ref_operator\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "d03c693e0307cbd689b769fab049f423cd6b956e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d03c693e0307cbd689b769fab049f423cd6b956e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/121c8dd00de81ec9c11d494d402e4761dbe4fe4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121c8dd00de81ec9c11d494d402e4761dbe4fe4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/121c8dd00de81ec9c11d494d402e4761dbe4fe4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121c8dd00de81ec9c11d494d402e4761dbe4fe4d/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a00b61e6bfc4a79af55236db0e602e09cd8fda72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a00b61e6bfc4a79af55236db0e602e09cd8fda72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a00b61e6bfc4a79af55236db0e602e09cd8fda72"}], "stats": {"total": 646, "additions": 628, "deletions": 18}, "files": [{"sha": "e1ab7f1607491f32cef174bbcdaa6da16f47f522", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121c8dd00de81ec9c11d494d402e4761dbe4fe4d/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121c8dd00de81ec9c11d494d402e4761dbe4fe4d/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=121c8dd00de81ec9c11d494d402e4761dbe4fe4d", "patch": "@@ -28,12 +28,17 @@\n #include \"timevar.h\"\n #include \"convert.h\"\n #include \"gimple-expr.h\"\n+#include \"gimplify.h\"\n+#include \"function.h\"\n+#include \"gcc-rich-location.h\"\n \n // forked from gcc/c-family/c-common.cc c_global_trees\n tree c_global_trees[CTI_MAX];\n // forked from gcc/cp/decl.cc cp_global_trees\n tree cp_global_trees[CPTI_MAX];\n \n+struct saved_scope *scope_chain;\n+\n namespace Rust {\n \n void\n@@ -3721,4 +3726,247 @@ resolve_nondeduced_context (tree orig_expr, tsubst_flags_t complain)\n \n   return orig_expr;\n }\n+\n+// forked from gcc/cp/pt.cc instantiate_non_dependent_or_null\n+\n+/* Like instantiate_non_dependent_expr, but return NULL_TREE rather than\n+   an uninstantiated expression.  */\n+\n+tree\n+instantiate_non_dependent_or_null (tree expr)\n+{\n+  if (expr == NULL_TREE)\n+    return NULL_TREE;\n+\n+  return expr;\n+}\n+\n+// forked from gcc/cp/pt.cc resolve_nondeduced_context_or_error\n+\n+/* As above, but error out if the expression remains overloaded.  */\n+\n+tree\n+resolve_nondeduced_context_or_error (tree exp, tsubst_flags_t complain)\n+{\n+  exp = resolve_nondeduced_context (exp, complain);\n+  if (type_unknown_p (exp))\n+    {\n+      if (complain & tf_error)\n+\tcxx_incomplete_type_error (exp, TREE_TYPE (exp));\n+      return error_mark_node;\n+    }\n+  return exp;\n+}\n+\n+// forked from gcc/cp/tree.cc really_overloaded_fn\n+\n+/* Returns true iff X is an expression for an overloaded function\n+   whose type cannot be known without performing overload\n+   resolution.  */\n+\n+bool\n+really_overloaded_fn (tree x)\n+{\n+  return is_overloaded_fn (x) == 2;\n+}\n+\n+// forked from gcc/cp/typeck..cc invalid_nonstatic_memfn_p\n+\n+/* EXPR is being used in a context that is not a function call.\n+   Enforce:\n+\n+     [expr.ref]\n+\n+     The expression can be used only as the left-hand operand of a\n+     member function call.\n+\n+     [expr.mptr.operator]\n+\n+     If the result of .* or ->* is a function, then that result can be\n+     used only as the operand for the function call operator ().\n+\n+   by issuing an error message if appropriate.  Returns true iff EXPR\n+   violates these rules.  */\n+\n+bool\n+invalid_nonstatic_memfn_p (location_t loc, tree expr, tsubst_flags_t complain)\n+{\n+  if (expr == NULL_TREE)\n+    return false;\n+  /* Don't enforce this in MS mode.  */\n+  if (flag_ms_extensions)\n+    return false;\n+  if (is_overloaded_fn (expr) && !really_overloaded_fn (expr))\n+    expr = get_first_fn (expr);\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (expr))\n+    {\n+      if (complain & tf_error)\n+\t{\n+\t  if (DECL_P (expr))\n+\t    {\n+\t      error_at (loc, \"invalid use of non-static member function %qD\",\n+\t\t\texpr);\n+\t      inform (DECL_SOURCE_LOCATION (expr), \"declared here\");\n+\t    }\n+\t  else\n+\t    error_at (loc,\n+\t\t      \"invalid use of non-static member function of \"\n+\t\t      \"type %qT\",\n+\t\t      TREE_TYPE (expr));\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n+// forked from gcc/cp/call.cc strip_top_quals\n+\n+tree\n+strip_top_quals (tree t)\n+{\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return t;\n+  return rs_build_qualified_type (t, 0);\n+}\n+\n+// forked from gcc/cp/typeck2.cc cxx_incomplete_type_inform\n+\n+/* Print an inform about the declaration of the incomplete type TYPE.  */\n+\n+void\n+cxx_incomplete_type_inform (const_tree type)\n+{\n+  if (!TYPE_MAIN_DECL (type))\n+    return;\n+\n+  location_t loc = DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type));\n+  tree ptype = strip_top_quals (CONST_CAST_TREE (type));\n+\n+  if (current_class_type && TYPE_BEING_DEFINED (current_class_type)\n+      && same_type_p (ptype, current_class_type))\n+    inform (loc,\n+\t    \"definition of %q#T is not complete until \"\n+\t    \"the closing brace\",\n+\t    ptype);\n+  else\n+    inform (loc, \"forward declaration of %q#T\", ptype);\n+}\n+\n+// forked from gcc/cp/typeck2.cc cxx_incomplete_type_diagnostic\n+\n+/* Print an error message for invalid use of an incomplete type.\n+   VALUE is the expression that was used (or 0 if that isn't known)\n+   and TYPE is the type that was invalid.  DIAG_KIND indicates the\n+   type of diagnostic (see diagnostic.def).  */\n+\n+void\n+cxx_incomplete_type_diagnostic (location_t loc, const_tree value,\n+\t\t\t\tconst_tree type, diagnostic_t diag_kind)\n+{\n+  bool is_decl = false, complained = false;\n+\n+  gcc_assert (diag_kind == DK_WARNING || diag_kind == DK_PEDWARN\n+\t      || diag_kind == DK_ERROR);\n+\n+  /* Avoid duplicate error message.  */\n+  if (TREE_CODE (type) == ERROR_MARK)\n+    return;\n+\n+  if (value)\n+    {\n+      STRIP_ANY_LOCATION_WRAPPER (value);\n+\n+      if (VAR_P (value) || TREE_CODE (value) == PARM_DECL\n+\t  || TREE_CODE (value) == FIELD_DECL)\n+\t{\n+\t  complained = emit_diagnostic (diag_kind, DECL_SOURCE_LOCATION (value),\n+\t\t\t\t\t0, \"%qD has incomplete type\", value);\n+\t  is_decl = true;\n+\t}\n+    }\n+retry:\n+  /* We must print an error message.  Be clever about what it says.  */\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      if (!is_decl)\n+\tcomplained\n+\t  = emit_diagnostic (diag_kind, loc, 0,\n+\t\t\t     \"invalid use of incomplete type %q#T\", type);\n+      if (complained)\n+\tcxx_incomplete_type_inform (type);\n+      break;\n+\n+    case VOID_TYPE:\n+      emit_diagnostic (diag_kind, loc, 0, \"invalid use of %qT\", type);\n+      break;\n+\n+    case ARRAY_TYPE:\n+      if (TYPE_DOMAIN (type))\n+\t{\n+\t  type = TREE_TYPE (type);\n+\t  goto retry;\n+\t}\n+      emit_diagnostic (diag_kind, loc, 0,\n+\t\t       \"invalid use of array with unspecified bounds\");\n+      break;\n+\n+    case OFFSET_TYPE:\n+      bad_member : {\n+\ttree member = TREE_OPERAND (value, 1);\n+\tif (is_overloaded_fn (member))\n+\t  member = get_first_fn (member);\n+\n+\tif (DECL_FUNCTION_MEMBER_P (member) && !flag_ms_extensions)\n+\t  {\n+\t    gcc_rich_location richloc (loc);\n+\t    /* If \"member\" has no arguments (other than \"this\"), then\n+\t       add a fix-it hint.  */\n+\t    if (type_num_arguments (TREE_TYPE (member)) == 1)\n+\t      richloc.add_fixit_insert_after (\"()\");\n+\t    emit_diagnostic (diag_kind, &richloc, 0,\n+\t\t\t     \"invalid use of member function %qD \"\n+\t\t\t     \"(did you forget the %<()%> ?)\",\n+\t\t\t     member);\n+\t  }\n+\telse\n+\t  emit_diagnostic (diag_kind, loc, 0,\n+\t\t\t   \"invalid use of member %qD \"\n+\t\t\t   \"(did you forget the %<&%> ?)\",\n+\t\t\t   member);\n+      }\n+      break;\n+\n+    case LANG_TYPE:\n+      if (type == init_list_type_node)\n+\t{\n+\t  emit_diagnostic (diag_kind, loc, 0,\n+\t\t\t   \"invalid use of brace-enclosed initializer list\");\n+\t  break;\n+\t}\n+      gcc_assert (type == unknown_type_node);\n+      if (value && TREE_CODE (value) == COMPONENT_REF)\n+\tgoto bad_member;\n+      else if (value && TREE_CODE (value) == ADDR_EXPR)\n+\temit_diagnostic (diag_kind, loc, 0,\n+\t\t\t \"address of overloaded function with no contextual \"\n+\t\t\t \"type information\");\n+      else if (value && TREE_CODE (value) == OVERLOAD)\n+\temit_diagnostic (\n+\t  diag_kind, loc, 0,\n+\t  \"overloaded function with no contextual type information\");\n+      else\n+\temit_diagnostic (\n+\t  diag_kind, loc, 0,\n+\t  \"insufficient contextual information to determine type\");\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n } // namespace Rust"}, {"sha": "fc83dc2cb8f131702e3f2c3b6f4ab22dcdd5d6b6", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 380, "deletions": 18, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121c8dd00de81ec9c11d494d402e4761dbe4fe4d/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121c8dd00de81ec9c11d494d402e4761dbe4fe4d/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=121c8dd00de81ec9c11d494d402e4761dbe4fe4d", "patch": "@@ -1098,6 +1098,148 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n /* Returns true if NODE is a pointer or a pointer-to-member.  */\n #define TYPE_PTR_OR_PTRMEM_P(NODE) (TYPE_PTR_P (NODE) || TYPE_PTRMEM_P (NODE))\n \n+/* Nonzero if NODE is an artificial VAR_DECL for a C++17 structured binding\n+   declaration or one of VAR_DECLs for the user identifiers in it.  */\n+#define DECL_DECOMPOSITION_P(NODE)                                             \\\n+  (VAR_P (NODE) && DECL_LANG_SPECIFIC (NODE)                                   \\\n+     ? DECL_LANG_SPECIFIC (NODE)->u.base.selector == lds_decomp                \\\n+     : false)\n+\n+/* The underlying artificial VAR_DECL for structured binding.  */\n+#define DECL_DECOMP_BASE(NODE) (LANG_DECL_DECOMP_CHECK (NODE)->base)\n+\n+/* Nonzero if either DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P or\n+   DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P is true of NODE.  */\n+#define DECL_MAYBE_IN_CHARGE_CDTOR_P(NODE)                                     \\\n+  (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (NODE)                                   \\\n+   || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (NODE))\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor, but not the\n+   specialized in-charge constructor, in-charge deleting constructor,\n+   or the base destructor.  */\n+#define DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P(NODE)                                \\\n+  (DECL_NAME (NODE) == dtor_identifier)\n+\n+/* Nonzero if NODE (a _DECL) is a cloned constructor or\n+   destructor.  */\n+#define DECL_CLONED_FUNCTION_P(NODE)                                           \\\n+  (DECL_NAME (NODE) && IDENTIFIER_CDTOR_P (DECL_NAME (NODE))                   \\\n+   && !DECL_MAYBE_IN_CHARGE_CDTOR_P (NODE))\n+\n+/* If DECL_CLONED_FUNCTION_P holds, this is the function that was\n+   cloned.  */\n+#define DECL_CLONED_FUNCTION(NODE)                                             \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))->u.fn.u5.cloned_function)\n+\n+/* Nonzero if NODE (a _DECL) is a cloned constructor or\n+   destructor.  */\n+#define DECL_CLONED_FUNCTION_P(NODE)                                           \\\n+  (DECL_NAME (NODE) && IDENTIFIER_CDTOR_P (DECL_NAME (NODE))                   \\\n+   && !DECL_MAYBE_IN_CHARGE_CDTOR_P (NODE))\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a constructor, but not either the\n+   specialized in-charge constructor or the specialized not-in-charge\n+   constructor.  */\n+#define DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P(NODE)                               \\\n+  (DECL_NAME (NODE) == ctor_identifier)\n+\n+/* The current C++-specific per-function global variables.  */\n+\n+#define cp_function_chain (cfun->language)\n+\n+/* In a constructor destructor, the point at which all derived class\n+   destroying/construction has been done.  I.e., just before a\n+   constructor returns, or before any base class destroying will be done\n+   in a destructor.  */\n+\n+#define cdtor_label cp_function_chain->x_cdtor_label\n+\n+/* When we're processing a member function, current_class_ptr is the\n+   PARM_DECL for the `this' pointer.  The current_class_ref is an\n+   expression for `*this'.  */\n+\n+#define current_class_ptr                                                      \\\n+  (*(cfun && cp_function_chain ? &cp_function_chain->x_current_class_ptr       \\\n+\t\t\t       : &scope_chain->x_current_class_ptr))\n+#define current_class_ref                                                      \\\n+  (*(cfun && cp_function_chain ? &cp_function_chain->x_current_class_ref       \\\n+\t\t\t       : &scope_chain->x_current_class_ref))\n+\n+/* The EH_SPEC_BLOCK for the exception-specifiers for the current\n+   function, if any.  */\n+\n+#define current_eh_spec_block cp_function_chain->x_eh_spec_block\n+\n+/* The `__in_chrg' parameter for the current function.  Only used for\n+   constructors and destructors.  */\n+\n+#define current_in_charge_parm cp_function_chain->x_in_charge_parm\n+\n+/* The `__vtt_parm' parameter for the current function.  Only used for\n+   constructors and destructors.  */\n+\n+#define current_vtt_parm cp_function_chain->x_vtt_parm\n+\n+/* A boolean flag to control whether we need to clean up the return value if a\n+   local destructor throws.  Only used in functions that return by value a\n+   class with a destructor.  Which 'tors don't, so we can use the same\n+   field as current_vtt_parm.  */\n+\n+#define current_retval_sentinel current_vtt_parm\n+\n+/* Set to 0 at beginning of a function definition, set to 1 if\n+   a return statement that specifies a return value is seen.  */\n+\n+#define current_function_returns_value cp_function_chain->returns_value\n+\n+/* Set to 0 at beginning of a function definition, set to 1 if\n+   a return statement with no argument is seen.  */\n+\n+#define current_function_returns_null cp_function_chain->returns_null\n+\n+/* Set to 0 at beginning of a function definition, set to 1 if\n+   a call to a noreturn function is seen.  */\n+\n+#define current_function_returns_abnormally                                    \\\n+  cp_function_chain->returns_abnormally\n+\n+/* Set to 0 at beginning of a function definition, set to 1 if we see an\n+   obvious infinite loop.  This can have false positives and false\n+   negatives, so it should only be used as a heuristic.  */\n+\n+#define current_function_infinite_loop cp_function_chain->infinite_loop\n+\n+/* Nonzero if we are processing a base initializer.  Zero elsewhere.  */\n+#define in_base_initializer cp_function_chain->x_in_base_initializer\n+\n+#define in_function_try_handler cp_function_chain->x_in_function_try_handler\n+\n+/* Expression always returned from function, or error_mark_node\n+   otherwise, for use by the automatic named return value optimization.  */\n+\n+#define current_function_return_value (cp_function_chain->x_return_value)\n+\n+#define current_class_type scope_chain->class_type\n+\n+/* Nonzero means that this type is being defined.  I.e., the left brace\n+   starting the definition of this type has been seen.  */\n+#define TYPE_BEING_DEFINED(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->being_defined)\n+\n+/* Nonzero for FUNCTION_DECL means that this decl is a static\n+   member function.  */\n+#define DECL_STATIC_FUNCTION_P(NODE)                                           \\\n+  (LANG_DECL_FN_CHECK (NODE)->static_function)\n+\n+/* Nonzero for FUNCTION_DECL means that this decl is a non-static\n+   member function.  */\n+#define DECL_NONSTATIC_MEMBER_FUNCTION_P(NODE)                                 \\\n+  (TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE)\n+\n+/* Nonzero for FUNCTION_DECL means that this decl is a member function\n+   (static or non-static).  */\n+#define DECL_FUNCTION_MEMBER_P(NODE)                                           \\\n+  (DECL_NONSTATIC_MEMBER_FUNCTION_P (NODE) || DECL_STATIC_FUNCTION_P (NODE))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -1362,6 +1504,213 @@ struct GTY (()) lang_decl_base\n    || TREE_CODE (NODE) == TEMPLATE_DECL || TREE_CODE (NODE) == USING_DECL      \\\n    || TREE_CODE (NODE) == CONCEPT_DECL)\n \n+// forked from gcc/c-family-common.h stmt_tree_s\n+\n+/* Information about a statement tree.  */\n+\n+struct GTY (()) stmt_tree_s\n+{\n+  /* A stack of statement lists being collected.  */\n+  vec<tree, va_gc> *x_cur_stmt_list;\n+\n+  /* In C++, Nonzero if we should treat statements as full\n+     expressions.  In particular, this variable is non-zero if at the\n+     end of a statement we should destroy any temporaries created\n+     during that statement.  Similarly, if, at the end of a block, we\n+     should destroy any local variables in this block.  Normally, this\n+     variable is nonzero, since those are the normal semantics of\n+     C++.\n+\n+     This flag has no effect in C.  */\n+  int stmts_are_full_exprs_p;\n+};\n+\n+// forked from gcc/c-family-common.h stmt_tree_s\n+\n+typedef struct stmt_tree_s *stmt_tree;\n+\n+// forked from gcc/c-family-common.h c_language_function\n+\n+/* Global state pertinent to the current function.  Some C dialects\n+   extend this structure with additional fields.  */\n+\n+struct GTY (()) c_language_function\n+{\n+  /* While we are parsing the function, this contains information\n+     about the statement-tree that we are building.  */\n+  struct stmt_tree_s x_stmt_tree;\n+\n+  /* Vector of locally defined typedefs, for\n+     -Wunused-local-typedefs.  */\n+  vec<tree, va_gc> *local_typedefs;\n+};\n+\n+// forked from gcc/cp/cp-tree.h omp_declare_target_attr\n+\n+struct GTY (()) omp_declare_target_attr\n+{\n+  bool attr_syntax;\n+};\n+\n+// forked from gcc/cp/name-lookup.h cxx_binding\n+\n+/* Datatype that represents binding established by a declaration between\n+   a name and a C++ entity.  */\n+struct GTY (()) cxx_binding\n+{\n+  /* Link to chain together various bindings for this name.  */\n+  cxx_binding *previous;\n+  /* The non-type entity this name is bound to.  */\n+  tree value;\n+  /* The type entity this name is bound to.  */\n+  tree type;\n+\n+  bool value_is_inherited : 1;\n+  bool is_local : 1;\n+  bool type_is_hidden : 1;\n+};\n+\n+// forked from gcc/cp/name-lookup.h cxx_saved_binding\n+\n+/* Datatype used to temporarily save C++ bindings (for implicit\n+   instantiations purposes and like).  Implemented in decl.cc.  */\n+struct GTY (()) cxx_saved_binding\n+{\n+  /* The name of the current binding.  */\n+  tree identifier;\n+  /* The binding we're saving.  */\n+  cxx_binding *binding;\n+  tree real_type_value;\n+};\n+\n+// forked from gcc/cp/cp-tree.h saved_scope\n+\n+/* Global state.  */\n+\n+struct GTY (()) saved_scope\n+{\n+  vec<cxx_saved_binding, va_gc> *old_bindings;\n+  tree old_namespace;\n+  vec<tree, va_gc> *decl_ns_list;\n+  tree class_name;\n+  tree class_type;\n+  tree access_specifier;\n+  tree function_decl;\n+  vec<tree, va_gc> *lang_base;\n+  tree lang_name;\n+  tree template_parms;\n+  tree x_saved_tree;\n+\n+  /* Only used for uses of this in trailing return type.  */\n+  tree x_current_class_ptr;\n+  tree x_current_class_ref;\n+\n+  int x_processing_template_decl;\n+  int x_processing_specialization;\n+  int x_processing_constraint;\n+  int suppress_location_wrappers;\n+  BOOL_BITFIELD x_processing_explicit_instantiation : 1;\n+  BOOL_BITFIELD need_pop_function_context : 1;\n+\n+  /* Nonzero if we are parsing the discarded statement of a constexpr\n+     if-statement.  */\n+  BOOL_BITFIELD discarded_stmt : 1;\n+  /* Nonzero if we are parsing or instantiating the compound-statement\n+     of consteval if statement.  Also set while processing an immediate\n+     invocation.  */\n+  BOOL_BITFIELD consteval_if_p : 1;\n+\n+  int unevaluated_operand;\n+  int inhibit_evaluation_warnings;\n+  int noexcept_operand;\n+  int ref_temp_count;\n+\n+  struct stmt_tree_s x_stmt_tree;\n+\n+  hash_map<tree, tree> *GTY ((skip)) x_local_specializations;\n+  vec<omp_declare_target_attr, va_gc> *omp_declare_target_attribute;\n+\n+  struct saved_scope *prev;\n+};\n+\n+extern GTY (()) struct saved_scope *scope_chain;\n+\n+// forked from gcc/cp/cp-tree.h named_label_hash\n+\n+struct named_label_entry; /* Defined in decl.cc.  */\n+\n+struct named_label_hash : ggc_remove<named_label_entry *>\n+{\n+  typedef named_label_entry *value_type;\n+  typedef tree compare_type; /* An identifier.  */\n+\n+  inline static hashval_t hash (value_type);\n+  inline static bool equal (const value_type, compare_type);\n+\n+  static const bool empty_zero_p = true;\n+  inline static void mark_empty (value_type &p) { p = NULL; }\n+  inline static bool is_empty (value_type p) { return !p; }\n+\n+  /* Nothing is deletable.  Everything is insertable.  */\n+  inline static bool is_deleted (value_type) { return false; }\n+  inline static void mark_deleted (value_type) { gcc_unreachable (); }\n+};\n+\n+// forked from gcc/cp/cp-tree.h\n+\n+/* Global state pertinent to the current function.  */\n+\n+struct GTY (()) language_function\n+{\n+  struct c_language_function base;\n+\n+  tree x_cdtor_label;\n+  tree x_current_class_ptr;\n+  tree x_current_class_ref;\n+  tree x_eh_spec_block;\n+  tree x_in_charge_parm;\n+  tree x_vtt_parm;\n+  tree x_return_value;\n+\n+  BOOL_BITFIELD returns_value : 1;\n+  BOOL_BITFIELD returns_null : 1;\n+  BOOL_BITFIELD returns_abnormally : 1;\n+  BOOL_BITFIELD infinite_loop : 1;\n+  BOOL_BITFIELD x_in_function_try_handler : 1;\n+  BOOL_BITFIELD x_in_base_initializer : 1;\n+\n+  /* True if this function can throw an exception.  */\n+  BOOL_BITFIELD can_throw : 1;\n+\n+  BOOL_BITFIELD invalid_constexpr : 1;\n+  BOOL_BITFIELD throwing_cleanup : 1;\n+\n+  hash_table<named_label_hash> *x_named_labels;\n+\n+  /* Tracking possibly infinite loops.  This is a vec<tree> only because\n+     vec<bool> doesn't work with gtype.  */\n+  vec<tree, va_gc> *infinite_loops;\n+};\n+\n+// forked from gcc/c-family/c-common.h ref_operator\n+\n+/* The various name of operator that appears in error messages. */\n+enum ref_operator\n+{\n+  /* NULL */\n+  RO_NULL,\n+  /* array indexing */\n+  RO_ARRAY_INDEXING,\n+  /* unary * */\n+  RO_UNARY_STAR,\n+  /* -> */\n+  RO_ARROW,\n+  /* implicit conversion */\n+  RO_IMPLICIT_CONVERSION,\n+  /* ->* */\n+  RO_ARROW_STAR\n+};\n+\n // forked from gcc/cp/cp-tree.h lang_decl_min\n \n /* DECL_LANG_SPECIFIC for the above codes.  */\n@@ -1530,24 +1879,6 @@ struct c_fileinfo\n   short interface_unknown;\n };\n \n-// forked from gcc/cp/name-lookup.h\n-\n-/* Datatype that represents binding established by a declaration between\n-   a name and a C++ entity.  */\n-struct GTY (()) cxx_binding\n-{\n-  /* Link to chain together various bindings for this name.  */\n-  cxx_binding *previous;\n-  /* The non-type entity this name is bound to.  */\n-  tree value;\n-  /* The type entity this name is bound to.  */\n-  tree type;\n-\n-  bool value_is_inherited : 1;\n-  bool is_local : 1;\n-  bool type_is_hidden : 1;\n-};\n-\n // forked from gcc/c-family/c-common.h c_common_identifier\n \n /* Identifier part common to the C front ends.  Inherits from\n@@ -2194,6 +2525,23 @@ extern bool reject_gcc_builtin (const_tree, location_t = UNKNOWN_LOCATION);\n \n extern tree resolve_nondeduced_context (tree, tsubst_flags_t);\n \n+extern void cxx_incomplete_type_diagnostic (location_t, const_tree, const_tree,\n+\t\t\t\t\t    diagnostic_t);\n+\n+extern void cxx_incomplete_type_error (location_t, const_tree, const_tree);\n+\n+extern bool invalid_nonstatic_memfn_p (location_t, tree, tsubst_flags_t);\n+\n+extern bool really_overloaded_fn (tree) ATTRIBUTE_PURE;\n+\n+extern tree resolve_nondeduced_context_or_error (tree, tsubst_flags_t);\n+\n+extern tree instantiate_non_dependent_or_null (tree);\n+\n+extern void cxx_incomplete_type_inform (const_tree);\n+\n+extern tree strip_top_quals (tree);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum\n@@ -2362,6 +2710,20 @@ null_node_p (const_tree expr)\n   return expr == null_node;\n }\n \n+inline void\n+cxx_incomplete_type_diagnostic (const_tree value, const_tree type,\n+\t\t\t\tdiagnostic_t diag_kind)\n+{\n+  cxx_incomplete_type_diagnostic (rs_expr_loc_or_input_loc (value), value, type,\n+\t\t\t\t  diag_kind);\n+}\n+\n+inline void\n+cxx_incomplete_type_error (const_tree value, const_tree type)\n+{\n+  cxx_incomplete_type_diagnostic (value, type, DK_ERROR);\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}