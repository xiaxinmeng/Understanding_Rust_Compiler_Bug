{"sha": "a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdlN2JmOGZjM2I0YmNmZTU3YmQwYmI1YjIyNjBkZDY3OGU5YjA2Mw==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@linaro.org", "date": "2012-09-17T17:07:29Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-09-17T17:07:29Z"}, "message": "arm.c (output_move_neon): Update comment.\n\n2012-09-17  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n\t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n\n\t* config/arm/arm.c (output_move_neon): Update comment.\n\tUse vld1.64/vst1.64 instead of vldm/vstm where possible.\n\t(neon_vector_mem_operand): Support double-word modes.\n\t* config/arm/neon.md (*neon_mov VD): Call output_move_neon\n\tinstead of output_move_vfp.  Change constraint from Uv to Un.\n\nCo-Authored-By: Ulrich Weigand <ulrich.weigand@linaro.org>\n\nFrom-SVN: r191399", "tree": {"sha": "174a968c96d901ce5cbc6343557266ec626bef94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/174a968c96d901ce5cbc6343557266ec626bef94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063/comments", "author": null, "committer": null, "parents": [{"sha": "eff02e4f8421170b613b80e266b5b1893c588ea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff02e4f8421170b613b80e266b5b1893c588ea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff02e4f8421170b613b80e266b5b1893c588ea6"}], "stats": {"total": 85, "additions": 62, "deletions": 23}, "files": [{"sha": "81d4e2ebc31eb5c581d4b38695f5c669da56506e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "patch": "@@ -1,3 +1,12 @@\n+2012-09-17  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n+\t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* config/arm/arm.c (output_move_neon): Update comment.\n+\tUse vld1.64/vst1.64 instead of vldm/vstm where possible.\n+\t(neon_vector_mem_operand): Support double-word modes.\n+\t* config/arm/neon.md (*neon_mov VD): Call output_move_neon\n+\tinstead of output_move_vfp.  Change constraint from Uv to Un.\n+\n 2012-09-17  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/54598"}, {"sha": "b84a04098ea29bd46e036b7419504fea8b2b47ff", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 50, "deletions": 15, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "patch": "@@ -9629,7 +9629,11 @@ neon_vector_mem_operand (rtx op, int type)\n       && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n       && CONST_INT_P (XEXP (ind, 1))\n       && INTVAL (XEXP (ind, 1)) > -1024\n-      && INTVAL (XEXP (ind, 1)) < 1016\n+      /* For quad modes, we restrict the constant offset to be slightly less\n+\t than what the instruction format permits.  We have no such constraint\n+\t on double mode offsets.  (This must match arm_legitimate_index_p.)  */\n+      && (INTVAL (XEXP (ind, 1))\n+\t  < (VALID_NEON_QREG_MODE (GET_MODE (op))? 1016 : 1024))\n       && (INTVAL (XEXP (ind, 1)) & 3) == 0)\n     return TRUE;\n \n@@ -14573,15 +14577,16 @@ output_move_vfp (rtx *operands)\n   return \"\";\n }\n \n-/* Output a Neon quad-word load or store, or a load or store for\n-   larger structure modes.\n+/* Output a Neon double-word or quad-word load or store, or a load\n+   or store for larger structure modes.\n \n    WARNING: The ordering of elements is weird in big-endian mode,\n-   because we use VSTM, as required by the EABI.  GCC RTL defines\n-   element ordering based on in-memory order.  This can be differ\n-   from the architectural ordering of elements within a NEON register.\n-   The intrinsics defined in arm_neon.h use the NEON register element\n-   ordering, not the GCC RTL element ordering.\n+   because the EABI requires that vectors stored in memory appear\n+   as though they were stored by a VSTM, as required by the EABI.\n+   GCC RTL defines element ordering based on in-memory order.\n+   This can be different from the architectural ordering of elements\n+   within a NEON register. The intrinsics defined in arm_neon.h use the\n+   NEON register element ordering, not the GCC RTL element ordering.\n \n    For example, the in-memory ordering of a big-endian a quadword\n    vector with 16-bit elements when stored from register pair {d0,d1}\n@@ -14595,13 +14600,28 @@ output_move_vfp (rtx *operands)\n      dN -> (rN+1, rN), dN+1 -> (rN+3, rN+2)\n \n    So that STM/LDM can be used on vectors in ARM registers, and the\n-   same memory layout will result as if VSTM/VLDM were used.  */\n+   same memory layout will result as if VSTM/VLDM were used.\n+\n+   Instead of VSTM/VLDM we prefer to use VST1.64/VLD1.64 where\n+   possible, which allows use of appropriate alignment tags.\n+   Note that the choice of \"64\" is independent of the actual vector\n+   element size; this size simply ensures that the behavior is\n+   equivalent to VSTM/VLDM in both little-endian and big-endian mode.\n+\n+   Due to limitations of those instructions, use of VST1.64/VLD1.64\n+   is not possible if:\n+    - the address contains PRE_DEC, or\n+    - the mode refers to more than 4 double-word registers\n+\n+   In those cases, it would be possible to replace VSTM/VLDM by a\n+   sequence of instructions; this is not currently implemented since\n+   this is not certain to actually improve performance.  */\n \n const char *\n output_move_neon (rtx *operands)\n {\n   rtx reg, mem, addr, ops[2];\n-  int regno, load = REG_P (operands[0]);\n+  int regno, nregs, load = REG_P (operands[0]);\n   const char *templ;\n   char buff[50];\n   enum machine_mode mode;\n@@ -14613,6 +14633,7 @@ output_move_neon (rtx *operands)\n \n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n+  nregs = HARD_REGNO_NREGS (regno, mode) / 2;\n   gcc_assert (VFP_REGNO_OK_FOR_DOUBLE (regno)\n \t      || NEON_REGNO_OK_FOR_QUAD (regno));\n   gcc_assert (VALID_NEON_DREG_MODE (mode)\n@@ -14629,13 +14650,23 @@ output_move_neon (rtx *operands)\n   switch (GET_CODE (addr))\n     {\n     case POST_INC:\n-      templ = \"v%smia%%?\\t%%0!, %%h1\";\n-      ops[0] = XEXP (addr, 0);\n+      /* We have to use vldm / vstm for too-large modes.  */\n+      if (nregs > 4)\n+\t{\n+\t  templ = \"v%smia%%?\\t%%0!, %%h1\";\n+\t  ops[0] = XEXP (addr, 0);\n+\t}\n+      else\n+\t{\n+\t  templ = \"v%s1.64\\t%%h1, %%A0\";\n+\t  ops[0] = mem;\n+\t}\n       ops[1] = reg;\n       break;\n \n     case PRE_DEC:\n-      /* FIXME: We should be using vld1/vst1 here in BE mode?  */\n+      /* We have to use vldm / vstm in this case, since there is no\n+\t pre-decrement form of the vld1 / vst1 instructions.  */\n       templ = \"v%smdb%%?\\t%%0!, %%h1\";\n       ops[0] = XEXP (addr, 0);\n       ops[1] = reg;\n@@ -14648,7 +14679,6 @@ output_move_neon (rtx *operands)\n     case LABEL_REF:\n     case PLUS:\n       {\n-\tint nregs = HARD_REGNO_NREGS (REGNO (reg), mode) / 2;\n \tint i;\n \tint overlap = -1;\n \tfor (i = 0; i < nregs; i++)\n@@ -14679,7 +14709,12 @@ output_move_neon (rtx *operands)\n       }\n \n     default:\n-      templ = \"v%smia%%?\\t%%m0, %%h1\";\n+      /* We have to use vldm / vstm for too-large modes.  */\n+      if (nregs > 4)\n+\ttempl = \"v%smia%%?\\t%%m0, %%h1\";\n+      else\n+\ttempl = \"v%s1.64\\t%%h1, %%A0\";\n+\n       ops[0] = mem;\n       ops[1] = reg;\n     }"}, {"sha": "bad95f5ad3c7550c99a188599e9b0fb33273c4ec", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "patch": "@@ -156,9 +156,9 @@\n \n (define_insn \"*neon_mov<mode>\"\n   [(set (match_operand:VDX 0 \"nonimmediate_operand\"\n-\t  \"=w,Uv,w, w,  ?r,?w,?r,?r, ?Us\")\n+\t  \"=w,Un,w, w,  ?r,?w,?r,?r, ?Us\")\n \t(match_operand:VDX 1 \"general_operand\"\n-\t  \" w,w, Dn,Uvi, w, r, r, Usi,r\"))]\n+\t  \" w,w, Dn,Uni, w, r, r, Usi,r\"))]\n   \"TARGET_NEON\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n@@ -181,15 +181,10 @@\n       return templ;\n     }\n \n-  /* FIXME: If the memory layout is changed in big-endian mode, output_move_vfp\n-     below must be changed to output_move_neon (which will use the\n-     element/structure loads/stores), and the constraint changed to 'Um' instead\n-     of 'Uv'.  */\n-\n   switch (which_alternative)\n     {\n     case 0: return \"vmov\\t%P0, %P1  @ <mode>\";\n-    case 1: case 3: return output_move_vfp (operands);\n+    case 1: case 3: return output_move_neon (operands);\n     case 2: gcc_unreachable ();\n     case 4: return \"vmov\\t%Q0, %R0, %P1  @ <mode>\";\n     case 5: return \"vmov\\t%P0, %Q1, %R1  @ <mode>\";"}]}