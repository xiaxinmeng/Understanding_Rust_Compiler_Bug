{"sha": "b2539e1e8d60e0df830ab3d75dd6b5590f5c7080", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1MzllMWU4ZDYwZTBkZjgzMGFiM2Q3NWRkNmI1NTkwZjVjNzA4MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-09T05:07:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-09T05:07:18Z"}, "message": "re PR lto/61886 (LTO breaks fread with _FORTIFY_SOURCE=2)\n\n\n\tPR ipa/61886\n\t* symtab.c (symtab_node::equal_address_to): New parameter\n\tMEMORY_ACCESSED.\n\t* cgraph.h (symtab_node::equal_address_to): Update prototype.\n\nFrom-SVN: r231440", "tree": {"sha": "605cb507b2dcec62d39dca832e936a5a93ff6a1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/605cb507b2dcec62d39dca832e936a5a93ff6a1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080/comments", "author": null, "committer": null, "parents": [{"sha": "eb457a8c59cfeb602d66f1ba379b6ec3e9475d90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb457a8c59cfeb602d66f1ba379b6ec3e9475d90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb457a8c59cfeb602d66f1ba379b6ec3e9475d90"}], "stats": {"total": 49, "additions": 39, "deletions": 10}, "files": [{"sha": "5153e2089c7319c88be746ec2eb902451e3ed2ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2539e1e8d60e0df830ab3d75dd6b5590f5c7080", "patch": "@@ -1,3 +1,10 @@\n+2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\t* symtab.c (symtab_node::equal_address_to): New parameter\n+\tMEMORY_ACCESSED.\n+\t* cgraph.h (symtab_node::equal_address_to): Update prototype.\n+\n 2015-12-08  DJ Delorie  <dj@redhat.com>\n \n \t* config/rx/rx.opt (-mjsr): Add."}, {"sha": "0a093913be6447c0f81ff96f3cd17d0b2fc96921", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b2539e1e8d60e0df830ab3d75dd6b5590f5c7080", "patch": "@@ -355,8 +355,13 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n   /* Return 0 if symbol is known to have different address than S2,\n      Return 1 if symbol is known to have same address as S2,\n-     return 2 otherwise.   */\n-  int equal_address_to (symtab_node *s2);\n+     return 2 otherwise. \n+\n+     If MEMORY_ACCESSED is true, assume that both memory pointer to THIS\n+     and S2 is going to be accessed.  This eliminates the situations when\n+     either THIS or S2 is NULL and is seful for comparing bases when deciding\n+     about memory aliasing.  */\n+  int equal_address_to (symtab_node *s2, bool memory_accessed = false);\n \n   /* Return true if symbol's address may possibly be compared to other\n      symbol's address.  */"}, {"sha": "581decea5d65f3d6b7ced860efb69e2a50f62bdf", "filename": "gcc/symtab.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2539e1e8d60e0df830ab3d75dd6b5590f5c7080/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=b2539e1e8d60e0df830ab3d75dd6b5590f5c7080", "patch": "@@ -1878,16 +1878,31 @@ symtab_node::nonzero_address ()\n \n /* Return 0 if symbol is known to have different address than S2,\n    Return 1 if symbol is known to have same address as S2,\n-   return 2 otherwise.   */\n+   return 2 otherwise.  \n+\n+   If MEMORY_ACCESSED is true, assume that both memory pointer to THIS\n+   and S2 is going to be accessed.  This eliminates the situations when\n+   either THIS or S2 is NULL and is seful for comparing bases when deciding\n+   about memory aliasing.  */\n int\n-symtab_node::equal_address_to (symtab_node *s2)\n+symtab_node::equal_address_to (symtab_node *s2, bool memory_accessed)\n {\n   enum availability avail1, avail2;\n \n   /* A Shortcut: equivalent symbols are always equivalent.  */\n   if (this == s2)\n     return 1;\n \n+  /* Unwind transparent aliases first; those are always equal to their\n+     target.  */\n+  if (this->transparent_alias && this->analyzed)\n+    return this->get_alias_target ()->equal_address_to (s2);\n+  while (s2->transparent_alias && s2->analyzed)\n+    s2 = s2->get_alias_target();\n+\n+  if (this == s2)\n+    return 1;\n+\n   /* For non-interposable aliases, lookup and compare their actual definitions.\n      Also check if the symbol needs to bind to given definition.  */\n   symtab_node *rs1 = ultimate_alias_target (&avail1);\n@@ -1924,8 +1939,9 @@ symtab_node::equal_address_to (symtab_node *s2)\n       return 1;\n     }\n \n-  /* If both symbols may resolve to NULL, we can not really prove them different.  */\n-  if (!nonzero_address () && !s2->nonzero_address ())\n+  /* If both symbols may resolve to NULL, we can not really prove them\n+     different.  */\n+  if (!memory_accessed && !nonzero_address () && !s2->nonzero_address ())\n     return 2;\n \n   /* Except for NULL, functions and variables never overlap.  */\n@@ -1956,11 +1972,12 @@ symtab_node::equal_address_to (symtab_node *s2)\n     }\n \n   /* TODO: Alias oracle basically assume that addresses of global variables\n-     are different unless they are declared as alias of one to another.\n-     We probably should be consistent and use this fact here, too, and update\n-     alias oracle to use this predicate.  */\n+     are different unless they are declared as alias of one to another while\n+     the code folding comparsions doesn't.\n+     We probably should be consistent and use this fact here, too, but for\n+     the moment return false only when we are called from the alias oracle.  */\n \n-  return 2;\n+  return memory_accessed && rs1 != rs2 ? 0 : 2;\n }\n \n /* Worker for call_for_symbol_and_aliases.  */"}]}