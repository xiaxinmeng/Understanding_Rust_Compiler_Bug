{"sha": "da6603c626fdc18f3206ad6f9df72b987575639a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE2NjAzYzYyNmZkYzE4ZjMyMDZhZDZmOWRmNzJiOTg3NTc1NjM5YQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:41:48Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:41:48Z"}, "message": "Change use to type-based pool allocator in dse.c.\n\n\t* dse.c (get_group_info):Use new type-based pool allocator.\n\t(dse_step0) Likewise.\n\t(free_store_info) Likewise.\n\t(delete_dead_store_insn) Likewise.\n\t(free_read_records) Likewise.\n\t(record_store) Likewise.\n\t(replace_read) Likewise.\n\t(check_mem_read_rtx) Likewise.\n\t(scan_insn) Likewise.\n\t(dse_step1) Likewise.\n\t(dse_step7) Likewise.\n\nFrom-SVN: r223955", "tree": {"sha": "89920ad1698939f1909312c8d0dae519455b4d88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89920ad1698939f1909312c8d0dae519455b4d88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da6603c626fdc18f3206ad6f9df72b987575639a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da6603c626fdc18f3206ad6f9df72b987575639a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da6603c626fdc18f3206ad6f9df72b987575639a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da6603c626fdc18f3206ad6f9df72b987575639a/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e956943eb103777c2b54ed46ec567f9f43595fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e956943eb103777c2b54ed46ec567f9f43595fd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e956943eb103777c2b54ed46ec567f9f43595fd5"}], "stats": {"total": 215, "additions": 143, "deletions": 72}, "files": [{"sha": "1865398de2188d804dbfe9847654c7965175dc66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6603c626fdc18f3206ad6f9df72b987575639a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6603c626fdc18f3206ad6f9df72b987575639a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da6603c626fdc18f3206ad6f9df72b987575639a", "patch": "@@ -1,3 +1,17 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* dse.c (get_group_info):Use new type-based pool allocator.\n+\t(dse_step0) Likewise.\n+\t(free_store_info) Likewise.\n+\t(delete_dead_store_insn) Likewise.\n+\t(free_read_records) Likewise.\n+\t(record_store) Likewise.\n+\t(replace_read) Likewise.\n+\t(check_mem_read_rtx) Likewise.\n+\t(scan_insn) Likewise.\n+\t(dse_step1) Likewise.\n+\t(dse_step7) Likewise.\n+\n 2015-06-01  Martin Liska  <mliska@suse.cz>\n \n \t* df-scan.c (struct df_scan_problem_data):Use new type-based pool allocator."}, {"sha": "fae63af5ce6ceece1ad7ece11fd21de2e0a74ed8", "filename": "gcc/dse.c", "status": "modified", "additions": 129, "deletions": 72, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6603c626fdc18f3206ad6f9df72b987575639a/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6603c626fdc18f3206ad6f9df72b987575639a/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=da6603c626fdc18f3206ad6f9df72b987575639a", "patch": "@@ -249,7 +249,7 @@ static struct obstack dse_obstack;\n /* Scratch bitmap for cselib's cselib_expand_value_rtx.  */\n static bitmap scratch = NULL;\n \n-struct insn_info;\n+struct insn_info_type;\n \n /* This structure holds information about a candidate store.  */\n struct store_info\n@@ -316,7 +316,7 @@ struct store_info\n   /* Set if this store stores the same constant value as REDUNDANT_REASON\n      insn stored.  These aren't eliminated early, because doing that\n      might prevent the earlier larger store to be eliminated.  */\n-  struct insn_info *redundant_reason;\n+  struct insn_info_type *redundant_reason;\n };\n \n /* Return a bitmask with the first N low bits set.  */\n@@ -329,12 +329,15 @@ lowpart_bitmask (int n)\n }\n \n typedef struct store_info *store_info_t;\n-static alloc_pool cse_store_info_pool;\n-static alloc_pool rtx_store_info_pool;\n+static pool_allocator<store_info> cse_store_info_pool (\"cse_store_info_pool\",\n+\t\t\t\t\t\t       100);\n+\n+static pool_allocator<store_info> rtx_store_info_pool (\"rtx_store_info_pool\",\n+\t\t\t\t\t\t       100);\n \n /* This structure holds information about a load.  These are only\n    built for rtx bases.  */\n-struct read_info\n+struct read_info_type\n {\n   /* The id of the mem group of the base address.  */\n   int group_id;\n@@ -351,15 +354,30 @@ struct read_info\n   rtx mem;\n \n   /* The next read_info for this insn.  */\n-  struct read_info *next;\n+  struct read_info_type *next;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((read_info_type *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<read_info_type> pool;\n };\n-typedef struct read_info *read_info_t;\n-static alloc_pool read_info_pool;\n+typedef struct read_info_type *read_info_t;\n \n+pool_allocator<read_info_type> read_info_type::pool (\"read_info_pool\", 100);\n \n /* One of these records is created for each insn.  */\n \n-struct insn_info\n+struct insn_info_type\n {\n   /* Set true if the insn contains a store but the insn itself cannot\n      be deleted.  This is set if the insn is a parallel and there is\n@@ -433,27 +451,41 @@ struct insn_info\n   regset fixed_regs_live;\n \n   /* The prev insn in the basic block.  */\n-  struct insn_info * prev_insn;\n+  struct insn_info_type * prev_insn;\n \n   /* The linked list of insns that are in consideration for removal in\n      the forwards pass through the basic block.  This pointer may be\n      trash as it is not cleared when a wild read occurs.  The only\n      time it is guaranteed to be correct is when the traversal starts\n      at active_local_stores.  */\n-  struct insn_info * next_local_store;\n+  struct insn_info_type * next_local_store;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((insn_info_type *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<insn_info_type> pool;\n };\n+typedef struct insn_info_type *insn_info_t;\n \n-typedef struct insn_info *insn_info_t;\n-static alloc_pool insn_info_pool;\n+pool_allocator<insn_info_type> insn_info_type::pool (\"insn_info_pool\", 100);\n \n /* The linked list of stores that are under consideration in this\n    basic block.  */\n static insn_info_t active_local_stores;\n static int active_local_stores_len;\n \n-struct dse_bb_info\n+struct dse_bb_info_type\n {\n-\n   /* Pointer to the insn info for the last insn in the block.  These\n      are linked so this is how all of the insns are reached.  During\n      scanning this is the current insn being scanned.  */\n@@ -507,10 +539,25 @@ struct dse_bb_info\n      to assure that shift and/or add sequences that are inserted do not\n      accidentally clobber live hard regs.  */\n   bitmap regs_live;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((dse_bb_info_type *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<dse_bb_info_type> pool;\n };\n \n-typedef struct dse_bb_info *bb_info_t;\n-static alloc_pool bb_info_pool;\n+typedef struct dse_bb_info_type *bb_info_t;\n+pool_allocator<dse_bb_info_type> dse_bb_info_type::pool (\"bb_info_pool\", 100);\n \n /* Table to hold all bb_infos.  */\n static bb_info_t *bb_table;\n@@ -578,10 +625,26 @@ struct group_info\n      care about.  */\n   int *offset_map_n, *offset_map_p;\n   int offset_map_size_n, offset_map_size_p;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((group_info *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<group_info> pool;\n };\n typedef struct group_info *group_info_t;\n typedef const struct group_info *const_group_info_t;\n-static alloc_pool rtx_group_info_pool;\n+\n+pool_allocator<group_info> group_info::pool (\"rtx_group_info_pool\", 100);\n \n /* Index into the rtx_group_vec.  */\n static int rtx_group_next_id;\n@@ -602,10 +665,27 @@ struct deferred_change\n   rtx reg;\n \n   struct deferred_change *next;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((deferred_change *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<deferred_change> pool;\n };\n \n typedef struct deferred_change *deferred_change_t;\n-static alloc_pool deferred_change_pool;\n+\n+pool_allocator<deferred_change> deferred_change::pool\n+  (\"deferred_change_pool\", 10);\n \n static deferred_change_t deferred_change_list = NULL;\n \n@@ -712,8 +792,7 @@ get_group_info (rtx base)\n     {\n       if (!clear_alias_group)\n \t{\n-\t  clear_alias_group = gi =\n-\t    (group_info_t) pool_alloc (rtx_group_info_pool);\n+\t  clear_alias_group = gi = new group_info;\n \t  memset (gi, 0, sizeof (struct group_info));\n \t  gi->id = rtx_group_next_id++;\n \t  gi->store1_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n@@ -735,7 +814,7 @@ get_group_info (rtx base)\n \n   if (gi == NULL)\n     {\n-      *slot = gi = (group_info_t) pool_alloc (rtx_group_info_pool);\n+      *slot = gi = new group_info;\n       gi->rtx_base = base;\n       gi->id = rtx_group_next_id++;\n       gi->base_mem = gen_rtx_MEM (BLKmode, base);\n@@ -776,24 +855,6 @@ dse_step0 (void)\n   scratch = BITMAP_ALLOC (&reg_obstack);\n   kill_on_calls = BITMAP_ALLOC (&dse_bitmap_obstack);\n \n-  rtx_store_info_pool\n-    = create_alloc_pool (\"rtx_store_info_pool\",\n-\t\t\t sizeof (struct store_info), 100);\n-  read_info_pool\n-    = create_alloc_pool (\"read_info_pool\",\n-\t\t\t sizeof (struct read_info), 100);\n-  insn_info_pool\n-    = create_alloc_pool (\"insn_info_pool\",\n-\t\t\t sizeof (struct insn_info), 100);\n-  bb_info_pool\n-    = create_alloc_pool (\"bb_info_pool\",\n-\t\t\t sizeof (struct dse_bb_info), 100);\n-  rtx_group_info_pool\n-    = create_alloc_pool (\"rtx_group_info_pool\",\n-\t\t\t sizeof (struct group_info), 100);\n-  deferred_change_pool\n-    = create_alloc_pool (\"deferred_change_pool\",\n-\t\t\t sizeof (struct deferred_change), 10);\n \n   rtx_group_table = new hash_table<invariant_group_base_hasher> (11);\n \n@@ -829,9 +890,9 @@ free_store_info (insn_info_t insn_info)\n       if (store_info->is_large)\n \tBITMAP_FREE (store_info->positions_needed.large.bmap);\n       if (store_info->cse_base)\n-\tpool_free (cse_store_info_pool, store_info);\n+\tcse_store_info_pool.remove (store_info);\n       else\n-\tpool_free (rtx_store_info_pool, store_info);\n+\trtx_store_info_pool.remove (store_info);\n       store_info = next;\n     }\n \n@@ -948,7 +1009,7 @@ check_for_inc_dec_1 (insn_info_t insn_info)\n bool\n check_for_inc_dec (rtx_insn *insn)\n {\n-  struct insn_info insn_info;\n+  insn_info_type insn_info;\n   rtx note;\n \n   insn_info.insn = insn;\n@@ -989,7 +1050,7 @@ delete_dead_store_insn (insn_info_t insn_info)\n   while (read_info)\n     {\n       read_info_t next = read_info->next;\n-      pool_free (read_info_pool, read_info);\n+      delete read_info;\n       read_info = next;\n     }\n   insn_info->read_rec = NULL;\n@@ -1113,7 +1174,7 @@ free_read_records (bb_info_t bb_info)\n       read_info_t next = (*ptr)->next;\n       if ((*ptr)->alias_set == 0)\n         {\n-          pool_free (read_info_pool, *ptr);\n+\t  delete *ptr;\n           *ptr = next;\n         }\n       else\n@@ -1167,7 +1228,7 @@ const_or_frame_p (rtx x)\n \treturn true;\n       return false;\n     }\n-  \n+\n   return false;\n }\n \n@@ -1488,7 +1549,7 @@ record_store (rtx body, bb_info_t bb_info)\n       if (clear_alias_group->offset_map_size_p < spill_alias_set)\n \tclear_alias_group->offset_map_size_p = spill_alias_set;\n \n-      store_info = (store_info_t) pool_alloc (rtx_store_info_pool);\n+      store_info = rtx_store_info_pool.allocate ();\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \" processing spill store %d(%s)\\n\",\n@@ -1503,7 +1564,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t= rtx_group_vec[group_id];\n       tree expr = MEM_EXPR (mem);\n \n-      store_info = (store_info_t) pool_alloc (rtx_store_info_pool);\n+      store_info = rtx_store_info_pool.allocate ();\n       set_usage_bits (group, offset, width, expr);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1516,7 +1577,7 @@ record_store (rtx body, bb_info_t bb_info)\n \tinsn_info->stack_pointer_based = true;\n       insn_info->contains_cselib_groups = true;\n \n-      store_info = (store_info_t) pool_alloc (cse_store_info_pool);\n+      store_info = cse_store_info_pool.allocate ();\n       group_id = -1;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2060,8 +2121,7 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \n   if (validate_change (read_insn->insn, loc, read_reg, 0))\n     {\n-      deferred_change_t deferred_change =\n-\t(deferred_change_t) pool_alloc (deferred_change_pool);\n+      deferred_change_t change = new deferred_change;\n \n       /* Insert this right before the store insn where it will be safe\n \t from later insns that might change it before the read.  */\n@@ -2091,15 +2151,15 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \t block we can put them back.  */\n \n       *loc = read_info->mem;\n-      deferred_change->next = deferred_change_list;\n-      deferred_change_list = deferred_change;\n-      deferred_change->loc = loc;\n-      deferred_change->reg = read_reg;\n+      change->next = deferred_change_list;\n+      deferred_change_list = change;\n+      change->loc = loc;\n+      change->reg = read_reg;\n \n       /* Get rid of the read_info, from the point of view of the\n \t rest of dse, play like this read never happened.  */\n       read_insn->read_rec = read_info->next;\n-      pool_free (read_info_pool, read_info);\n+      delete read_info;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \" -- replaced the loaded MEM with \");\n@@ -2165,7 +2225,7 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n   else\n     width = GET_MODE_SIZE (GET_MODE (mem));\n \n-  read_info = (read_info_t) pool_alloc (read_info_pool);\n+  read_info = new read_info_type;\n   read_info->group_id = group_id;\n   read_info->mem = mem;\n   read_info->alias_set = spill_alias_set;\n@@ -2481,9 +2541,9 @@ static void\n scan_insn (bb_info_t bb_info, rtx_insn *insn)\n {\n   rtx body;\n-  insn_info_t insn_info = (insn_info_t) pool_alloc (insn_info_pool);\n+  insn_info_type *insn_info = new insn_info_type;\n   int mems_found = 0;\n-  memset (insn_info, 0, sizeof (struct insn_info));\n+  memset (insn_info, 0, sizeof (struct insn_info_type));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n**scanning insn=%d\\n\",\n@@ -2740,9 +2800,9 @@ dse_step1 (void)\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n       insn_info_t ptr;\n-      bb_info_t bb_info = (bb_info_t) pool_alloc (bb_info_pool);\n+      bb_info_t bb_info = new dse_bb_info_type;\n \n-      memset (bb_info, 0, sizeof (struct dse_bb_info));\n+      memset (bb_info, 0, sizeof (dse_bb_info_type));\n       bitmap_set_bit (all_blocks, bb->index);\n       bb_info->regs_live = regs_live;\n \n@@ -2756,9 +2816,6 @@ dse_step1 (void)\n \t{\n \t  rtx_insn *insn;\n \n-\t  cse_store_info_pool\n-\t    = create_alloc_pool (\"cse_store_info_pool\",\n-\t\t\t\t sizeof (struct store_info), 100);\n \t  active_local_stores = NULL;\n \t  active_local_stores_len = 0;\n \t  cselib_clear_table ();\n@@ -2820,7 +2877,7 @@ dse_step1 (void)\n \t      /* There is no reason to validate this change.  That was\n \t\t done earlier.  */\n \t      *deferred_change_list->loc = deferred_change_list->reg;\n-\t      pool_free (deferred_change_pool, deferred_change_list);\n+\t      delete deferred_change_list;\n \t      deferred_change_list = next;\n \t    }\n \n@@ -2866,7 +2923,7 @@ dse_step1 (void)\n \t      ptr = ptr->prev_insn;\n \t    }\n \n-\t  free_alloc_pool (cse_store_info_pool);\n+\t  cse_store_info_pool.release ();\n \t}\n       bb_info->regs_live = NULL;\n     }\n@@ -3704,12 +3761,12 @@ dse_step7 (void)\n   BITMAP_FREE (all_blocks);\n   BITMAP_FREE (scratch);\n \n-  free_alloc_pool (rtx_store_info_pool);\n-  free_alloc_pool (read_info_pool);\n-  free_alloc_pool (insn_info_pool);\n-  free_alloc_pool (bb_info_pool);\n-  free_alloc_pool (rtx_group_info_pool);\n-  free_alloc_pool (deferred_change_pool);\n+  rtx_store_info_pool.release ();\n+  read_info_type::pool.release ();\n+  insn_info_type::pool.release ();\n+  dse_bb_info_type::pool.release ();\n+  group_info::pool.release ();\n+  deferred_change::pool.release ();\n }\n \n "}]}