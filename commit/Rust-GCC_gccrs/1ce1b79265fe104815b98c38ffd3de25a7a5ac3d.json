{"sha": "1ce1b79265fe104815b98c38ffd3de25a7a5ac3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNlMWI3OTI2NWZlMTA0ODE1Yjk4YzM4ZmZkM2RlMjVhN2E1YWMzZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-11-10T19:17:13Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-11-10T19:17:13Z"}, "message": "gcov.c (struct function_info): Make src an index, not a pointer.\n\n\t* gcov.c (struct function_info): Make src an index, not a pointer.\n\t(struct source_info): Remove index and next source fields.\n\t(fn_end): New static var.\n\t(sources_index): Remove.\n\t(sources): Now a pointer to an array, not a list.\n\t(n_sources, a_sources): New.\n\t(process_file): Adjust for changes to read_graph_file. Insert\n\tfunctions into source lists and check line numbers here.\n\t(generate_results): Only allocate lines for sources with\n\tcontents.  Adjust for source array.\n\t(release_structures): Likewise.\n\t(find_source): Return source index, adjust for source array.\n\t(read_graph_file): Return function list.  Don't insert into source\n\tlists here.\n\t(read_count_file): Take list of functions.\n\t(solve_flow_graph): Reverse the arc lists here.\n\t(add_line_counts): Adjust for source array.\n\nFrom-SVN: r181265", "tree": {"sha": "8ae542337d47fb9600022dcd2667a0cf55213e7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ae542337d47fb9600022dcd2667a0cf55213e7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ce1b79265fe104815b98c38ffd3de25a7a5ac3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce1b79265fe104815b98c38ffd3de25a7a5ac3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce1b79265fe104815b98c38ffd3de25a7a5ac3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce1b79265fe104815b98c38ffd3de25a7a5ac3d/comments", "author": null, "committer": null, "parents": [{"sha": "ea17de23b70df0b90005582a692705f23d062bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea17de23b70df0b90005582a692705f23d062bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea17de23b70df0b90005582a692705f23d062bec"}], "stats": {"total": 333, "additions": 169, "deletions": 164}, "files": [{"sha": "92cb2022a8c46aeba38717f83bc5144a04274b7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce1b79265fe104815b98c38ffd3de25a7a5ac3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce1b79265fe104815b98c38ffd3de25a7a5ac3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ce1b79265fe104815b98c38ffd3de25a7a5ac3d", "patch": "@@ -1,3 +1,23 @@\n+2011-11-10  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcov.c (struct function_info): Make src an index, not a pointer.\n+\t(struct source_info): Remove index and next source fields.\n+\t(fn_end): New static var.\n+\t(sources_index): Remove.\n+\t(sources): Now a pointer to an array, not a list.\n+\t(n_sources, a_sources): New.\n+\t(process_file): Adjust for changes to read_graph_file. Insert\n+\tfunctions into source lists and check line numbers here.\n+\t(generate_results): Only allocate lines for sources with\n+\tcontents.  Adjust for source array.\n+\t(release_structures): Likewise.\n+\t(find_source): Return source index, adjust for source array.\n+\t(read_graph_file): Return function list.  Don't insert into source\n+\tlists here.\n+\t(read_count_file): Take list of functions.\n+\t(solve_flow_graph): Reverse the arc lists here.\n+\t(add_line_counts): Adjust for source array.\n+\n 2011-11-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/51077\n@@ -7,8 +27,8 @@\n 2011-11-10  Andrew MacLeod  <amacleod@redhat.com>\n \n \tPR rtl-optimization/51040\n-\t* optabs.c (expand_atomic_fetch_op): Patchup code for NAND should be AND\n-\tfollowed by NOT.\n+\t* optabs.c (expand_atomic_fetch_op): Patchup code for NAND should\n+\tbe AND followed by NOT.\n \t* builtins.c (expand_builtin_atomic_fetch_op): Patchup code for NAND\n \tshould be AND followed by NOT.\n \t* testsuite/gcc.dg/atomic-noinline[-aux].c: Test no-inline NAND and"}, {"sha": "3929eba51c3dba21534ac900f24a5fe698471e7e", "filename": "gcc/gcov.c", "status": "modified", "additions": 147, "deletions": 162, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce1b79265fe104815b98c38ffd3de25a7a5ac3d/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce1b79265fe104815b98c38ffd3de25a7a5ac3d/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=1ce1b79265fe104815b98c38ffd3de25a7a5ac3d", "patch": "@@ -181,9 +181,9 @@ typedef struct function_info\n   gcov_type *counts;\n   unsigned num_counts;\n \n-  /* First line number.  */\n+  /* First line number & file.  */\n   unsigned line;\n-  struct source_info *src;\n+  unsigned src;\n \n   /* Next function in same source file.  */\n   struct function_info *line_next;\n@@ -233,7 +233,6 @@ typedef struct source_info\n {\n   /* Name of source file.  */\n   char *name;\n-  unsigned index;\n   time_t file_time;\n \n   /* Array of line information.  */\n@@ -245,23 +244,16 @@ typedef struct source_info\n   /* Functions in this source file.  These are in ascending line\n      number order.  */\n   function_t *functions;\n-\n-  /* Next source file.  */\n-  struct source_info *next;\n } source_t;\n \n /* Holds a list of function basic block graphs.  */\n \n static function_t *functions;\n+static function_t **fn_end = &functions;\n \n-/* This points to the head of the sourcefile structure list.  New elements\n-   are always prepended.  */\n-\n-static source_t *sources;\n-\n-/* Next index for a source file.  */\n-\n-static unsigned source_index;\n+static source_t *sources;   /* Array of source files  */\n+static unsigned n_sources;  /* Number of sources */\n+static unsigned a_sources;  /* Allocated sources */\n \n /* This holds data summary information.  */\n \n@@ -349,9 +341,9 @@ static void print_version (void) ATTRIBUTE_NORETURN;\n static void process_file (const char *);\n static void generate_results (const char *);\n static void create_file_names (const char *);\n-static source_t *find_source (const char *);\n-static int read_graph_file (void);\n-static int read_count_file (void);\n+static unsigned find_source (const char *);\n+static function_t *read_graph_file (void);\n+static int read_count_file (function_t *);\n static void solve_flow_graph (function_t *);\n static void add_branch_counts (coverage_t *, const arc_t *);\n static void add_line_counts (coverage_t *, function_t *);\n@@ -537,57 +529,85 @@ process_args (int argc, char **argv)\n static void\n process_file (const char *file_name)\n {\n-  function_t *fn;\n-  function_t **fn_p;\n-  function_t *old_functions;\n-\n-  /* Save and clear the list of current functions.  They will be appended\n-     later.  */\n-  old_functions = functions;\n-  functions = NULL;\n+  function_t *fns;\n \n   create_file_names (file_name);\n-  if (read_graph_file ())\n+  fns = read_graph_file ();\n+  if (!fns)\n     return;\n-\n-  if (!functions)\n+  \n+  read_count_file (fns);\n+  while (fns)\n     {\n-      fnotice (stderr, \"%s:no functions found\\n\", bbg_file_name);\n-      return;\n-    }\n-\n-  if (read_count_file ())\n-    return;\n+      function_t *fn = fns;\n \n-  fn_p = &functions;\n-  while ((fn = *fn_p) != NULL)\n-    {\n+      fns = fn->next;\n+      fn->next = NULL;\n       if (fn->counts)\n \t{\n+\t  unsigned src = fn->src;\n+\t  unsigned line = fn->line;\n+\t  unsigned block_no;\n+\t  function_t *probe, **prev;\n+\t  \n+\t  /* Now insert it into the source file's list of\n+\t     functions. Normally functions will be encountered in\n+\t     ascending order, so a simple scan is quick.  Note we're\n+\t     building this list in reverse order.  */\n+\t  for (prev = &sources[src].functions;\n+\t       (probe = *prev); prev = &probe->line_next)\n+\t    if (probe->line <= line)\n+\t      break;\n+\t  fn->line_next = probe;\n+\t  *prev = fn;\n+\n+\t  /* Mark last line in files touched by function.  */\n+\t  for (block_no = 0; block_no != fn->num_blocks; block_no++)\n+\t    {\n+\t      unsigned *enc = fn->blocks[block_no].u.line.encoding;\n+\t      unsigned num = fn->blocks[block_no].u.line.num;\n+\n+\t      for (; num--; enc++)\n+\t\tif (!*enc)\n+\t\t  {\n+\t\t    if (enc[1] != src)\n+\t\t      {\n+\t\t\tif (line >= sources[src].num_lines)\n+\t\t\t  sources[src].num_lines = line + 1;\n+\t\t\tline = 0;\n+\t\t\tsrc = enc[1];\n+\t\t      }\n+\t\t    enc++;\n+\t\t    num--;\n+\t\t  }\n+\t\telse if (*enc > line)\n+\t\t  line = *enc;\n+\t    }\n+\t  if (line >= sources[src].num_lines)\n+\t    sources[src].num_lines = line + 1;\n+\t  \n \t  solve_flow_graph (fn);\n-\t  fn_p = &fn->next;\n+\t  *fn_end = fn;\n+\t  fn_end = &fn->next;\n \t}\n       else\n-\t{\n-\t  /* The function was not in the executable -- some other\n-\t     instance must have been selected.  */\n-\t  function_t *next = fn->next;\n-\t  release_function (fn);\n-\t  *fn_p = next;\n-\t}\n+\t/* The function was not in the executable -- some other\n+\t   instance must have been selected.  */\n+\trelease_function (fn);\n     }\n-\n-  *fn_p = old_functions;\n }\n \n static void\n generate_results (const char *file_name)\n {\n+  unsigned ix;\n   source_t *src;\n   function_t *fn;\n \n-  for (src = sources; src; src = src->next)\n-    src->lines = XCNEWVEC (line_t, src->num_lines);\n+  for (ix = n_sources, src = sources; ix--; src++)\n+    if (src->num_lines)\n+      src->lines = XCNEWVEC (line_t, src->num_lines);\n+\n   for (fn = functions; fn; fn = fn->next)\n     {\n       coverage_t coverage;\n@@ -602,7 +622,7 @@ generate_results (const char *file_name)\n \t}\n     }\n \n-  for (src = sources; src; src = src->next)\n+  for (ix = n_sources, src = sources; ix--; src++)\n     {\n       accumulate_line_counts (src);\n       function_summary (&src->coverage, \"File\");\n@@ -657,15 +677,13 @@ release_function (function_t *fn)\n static void\n release_structures (void)\n {\n+  unsigned ix;\n   function_t *fn;\n-  source_t *src;\n \n-  while ((src = sources))\n+  for (ix = n_sources; ix--;)\n     {\n-      sources = src->next;\n-\n-      free (src->name);\n-      free (src->lines);\n+      free (sources[ix].name);\n+      free (sources[ix].lines);\n     }\n \n   while ((fn = functions))\n@@ -746,28 +764,40 @@ create_file_names (const char *file_name)\n /* Find or create a source file structure for FILE_NAME. Copies\n    FILE_NAME on creation */\n \n-static source_t *\n+static unsigned\n find_source (const char *file_name)\n {\n-  source_t *src;\n+  unsigned ix;\n+  source_t *src = 0;\n   struct stat status;\n \n   if (!file_name)\n     file_name = \"<unknown>\";\n \n-  for (src = sources; src; src = src->next)\n-    if (!filename_cmp (file_name, src->name))\n-      break;\n+  for (ix = n_sources; ix--;)\n+    if (!filename_cmp (file_name, sources[ix].name))\n+      {\n+\tsrc = &sources[ix];\n+\tbreak;\n+      }\n \n   if (!src)\n     {\n-      src = XCNEW (source_t);\n+      if (n_sources == a_sources)\n+\t{\n+\t  if (!a_sources)\n+\t    a_sources = 10;\n+\t  a_sources *= 2;\n+\t  src = XNEWVEC (source_t, a_sources);\n+\t  memcpy (src, sources, n_sources * sizeof (*sources));\n+\t  free (sources);\n+\t  sources = src;\n+\t}\n+      ix = n_sources;\n+      src = &sources[ix];\n       src->name = xstrdup (file_name);\n       src->coverage.name = src->name;\n-      src->index = source_index++;\n-      src->next = sources;\n-      sources = src;\n-\n+      n_sources++;\n       if (!stat (file_name, &status))\n \tsrc->file_time = status.st_mtime;\n     }\n@@ -787,33 +817,34 @@ find_source (const char *file_name)\n       src->file_time = 0;\n     }\n \n-  return src;\n+  return ix;\n }\n \n-/* Read the graph file. Return nonzero on fatal error.  */\n+/* Read the graph file.  Return list of functions read -- in reverse order.  */\n \n-static int\n+static function_t *\n read_graph_file (void)\n {\n   unsigned version;\n   unsigned current_tag = 0;\n-  struct function_info *fn = NULL;\n-  function_t *old_functions_head = functions;\n-  source_t *src = NULL;\n+  function_t *fn = NULL;\n+  function_t *fns = NULL;\n+  function_t **fns_end = &fns;\n+  unsigned src_idx = 0;\n   unsigned ix;\n   unsigned tag;\n \n   if (!gcov_open (bbg_file_name, 1))\n     {\n       fnotice (stderr, \"%s:cannot open graph file\\n\", bbg_file_name);\n-      return 1;\n+      return fns;\n     }\n   bbg_file_time = gcov_time ();\n   if (!gcov_magic (gcov_read_unsigned (), GCOV_NOTE_MAGIC))\n     {\n       fnotice (stderr, \"%s:not a gcov graph file\\n\", bbg_file_name);\n       gcov_close ();\n-      return 1;\n+      return fns;\n     }\n \n   version = gcov_read_unsigned ();\n@@ -839,42 +870,27 @@ read_graph_file (void)\n \t  char *function_name;\n \t  unsigned ident, lineno;\n \t  unsigned lineno_checksum, cfg_checksum;\n-\t  source_t *src;\n-\t  function_t *probe, *prev;\n \n \t  ident = gcov_read_unsigned ();\n \t  lineno_checksum = gcov_read_unsigned ();\n \t  cfg_checksum = gcov_read_unsigned ();\n \t  function_name = xstrdup (gcov_read_string ());\n-\t  src = find_source (gcov_read_string ());\n+\t  src_idx = find_source (gcov_read_string ());\n \t  lineno = gcov_read_unsigned ();\n \n \t  fn = XCNEW (function_t);\n \t  fn->name = function_name;\n \t  fn->ident = ident;\n \t  fn->lineno_checksum = lineno_checksum;\n \t  fn->cfg_checksum = cfg_checksum;\n-\t  fn->src = src;\n+\t  fn->src = src_idx;\n \t  fn->line = lineno;\n \n-\t  fn->next = functions;\n-\t  functions = fn;\n+\t  fn->line_next = NULL;\n+\t  fn->next = NULL;\n+\t  *fns_end = fn;\n+\t  fns_end = &fn->next;\n \t  current_tag = tag;\n-\n-\t  if (lineno >= src->num_lines)\n-\t    src->num_lines = lineno + 1;\n-\t  /* Now insert it into the source file's list of\n-\t     functions. Normally functions will be encountered in\n-\t     ascending order, so a simple scan is quick.  */\n-\t  for (probe = src->functions, prev = NULL;\n-\t       probe && probe->line > lineno;\n-\t       prev = probe, probe = probe->line_next)\n-\t    continue;\n-\t  fn->line_next = probe;\n-\t  if (prev)\n-\t    prev->line_next = fn;\n-\t  else\n-\t    src->functions = fn;\n \t}\n       else if (fn && tag == GCOV_TAG_BLOCKS)\n \t{\n@@ -966,22 +982,19 @@ read_graph_file (void)\n \t\t  if (!ix)\n \t\t    {\n \t\t      line_nos[ix++] = 0;\n-\t\t      line_nos[ix++] = src->index;\n+\t\t      line_nos[ix++] = src_idx;\n \t\t    }\n \t\t  line_nos[ix++] = lineno;\n-\t\t  if (lineno >= src->num_lines)\n-\t\t    src->num_lines = lineno + 1;\n \t\t}\n \t      else\n \t\t{\n \t\t  const char *file_name = gcov_read_string ();\n \n \t\t  if (!file_name)\n \t\t    break;\n-\t\t  src = find_source (file_name);\n-\n+\t\t  src_idx = find_source (file_name);\n \t\t  line_nos[ix++] = 0;\n-\t\t  line_nos[ix++] = src->index;\n+\t\t  line_nos[ix++] = src_idx;\n \t\t}\n \t    }\n \n@@ -998,72 +1011,22 @@ read_graph_file (void)\n \t{\n \tcorrupt:;\n \t  fnotice (stderr, \"%s:corrupted\\n\", bbg_file_name);\n-\t  gcov_close ();\n-\t  return 1;\n+\t  break;\n \t}\n     }\n   gcov_close ();\n \n-  /* We built everything backwards, so nreverse them all.  */\n-\n-  /* Reverse sources. Not strictly necessary, but we'll then process\n-     them in the 'expected' order.  */\n-  {\n-    source_t *src, *src_p, *src_n;\n-\n-    for (src_p = NULL, src = sources; src; src_p = src, src = src_n)\n-      {\n-\tsrc_n = src->next;\n-\tsrc->next = src_p;\n-      }\n-    sources =  src_p;\n-  }\n-\n-  /* Reverse functions.  */\n-  {\n-    function_t *fn, *fn_p, *fn_n;\n-\n-    for (fn_p = old_functions_head, fn = functions;\n-\t fn != old_functions_head;\n-\t fn_p = fn, fn = fn_n)\n-      {\n-\tunsigned ix;\n-\n-\tfn_n = fn->next;\n-\tfn->next = fn_p;\n+  if (!fns)\n+    fnotice (stderr, \"%s:no functions found\\n\", bbg_file_name);\n \n-\t/* Reverse the arcs.  */\n-\tfor (ix = fn->num_blocks; ix--;)\n-\t  {\n-\t    arc_t *arc, *arc_p, *arc_n;\n-\n-\t    for (arc_p = NULL, arc = fn->blocks[ix].succ; arc;\n-\t\t arc_p = arc, arc = arc_n)\n-\t      {\n-\t\tarc_n = arc->succ_next;\n-\t\tarc->succ_next = arc_p;\n-\t      }\n-\t    fn->blocks[ix].succ = arc_p;\n-\n-\t    for (arc_p = NULL, arc = fn->blocks[ix].pred; arc;\n-\t\t arc_p = arc, arc = arc_n)\n-\t      {\n-\t\tarc_n = arc->pred_next;\n-\t\tarc->pred_next = arc_p;\n-\t      }\n-\t    fn->blocks[ix].pred = arc_p;\n-\t  }\n-      }\n-    functions = fn_p;\n-  }\n-  return 0;\n+  return fns;\n }\n \n /* Reads profiles from the count file and attach to each\n    function. Return nonzero if fatal error.  */\n \n static int\n-read_count_file (void)\n+read_count_file (function_t *fns)\n {\n   unsigned ix;\n   unsigned version;\n@@ -1125,7 +1088,7 @@ read_count_file (void)\n \t  /* Try to find the function in the list.  To speed up the\n \t     search, first start from the last function found.  */\n \t  ident = gcov_read_unsigned ();\n-\t  fn_n = functions;\n+\t  fn_n = fns;\n \t  for (fn = fn ? fn->next : NULL; ; fn = fn->next)\n \t    {\n \t      if (fn)\n@@ -1190,6 +1153,28 @@ solve_flow_graph (function_t *fn)\n   block_t *valid_blocks = NULL;    /* valid, but unpropagated blocks.  */\n   block_t *invalid_blocks = NULL;  /* invalid, but inferable blocks.  */\n \n+  /* The arcs were built in reverse order.  Fix that now.  */\n+  for (ix = fn->num_blocks; ix--;)\n+    {\n+      arc_t *arc_p, *arc_n;\n+\n+      for (arc_p = NULL, arc = fn->blocks[ix].succ; arc;\n+\t   arc_p = arc, arc = arc_n)\n+\t{\n+\t  arc_n = arc->succ_next;\n+\t  arc->succ_next = arc_p;\n+\t}\n+      fn->blocks[ix].succ = arc_p;\n+\n+      for (arc_p = NULL, arc = fn->blocks[ix].pred; arc;\n+\t   arc_p = arc, arc = arc_n)\n+\t{\n+\t  arc_n = arc->pred_next;\n+\t  arc->pred_next = arc_p;\n+\t}\n+      fn->blocks[ix].pred = arc_p;\n+    }\n+\n   if (fn->num_blocks < 2)\n     fnotice (stderr, \"%s:'%s' lacks entry and/or exit blocks\\n\",\n \t     bbg_file_name, fn->name);\n@@ -1643,10 +1628,7 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n \t   jx != block->u.line.num; jx++, encoding++)\n \tif (!*encoding)\n \t  {\n-\t    unsigned src_n = *++encoding;\n-\n-\t    for (src = sources; src->index != src_n; src = src->next)\n-\t      continue;\n+\t    src = &sources[*++encoding];\n \t    jx++;\n \t  }\n \telse\n@@ -1671,7 +1653,10 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n \t/* Entry or exit block */;\n       else if (flag_all_blocks)\n \t{\n-\t  line_t *block_line = line ? line : &fn->src->lines[fn->line];\n+\t  line_t *block_line = line;\n+\n+\t  if (!block_line)\n+\t    block_line = &sources[fn->src].lines[fn->line];\n \n \t  block->chain = block_line->u.blocks;\n \t  block_line->u.blocks = block;"}]}