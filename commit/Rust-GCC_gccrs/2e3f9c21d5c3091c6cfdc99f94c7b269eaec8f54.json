{"sha": "2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUzZjljMjFkNWMzMDkxYzZjZmRjOTlmOTRjN2IyNjllYWVjOGY1NA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2008-06-06T19:32:43Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2008-06-06T19:32:43Z"}, "message": "using.xml: Outline exception topics.\n\n2008-06-06  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* doc/xml/manual/using.xml: Outline exception topics.\n\n\t* include/ext/pb_ds/detail/binary_heap_/insert_fn_imps.hpp: Format.\n\t* include/ext/pb_ds/detail/left_child_next_sibling_heap_/\n\tpolicy_access_fn_imps.hpp: Same.\n\t* include/ext/pb_ds/priority_queue.hpp: Same.\n\t* include/ext/throw_allocator.h: Same.\n\n\t* include/ext/pb_ds/tag_and_trait.hpp (string_tag): New tag.\n\t(sequence_tag): New tag. Doxygen markup fixes.\n\n\t* testsuite/lib/libstdc++.exp: Remove twister_ran_gen.cc source file.\n\n\t* testsuite/performance/ext/pb_ds/text_find_timing.cc: Fix\n\tcomment typo, include paths, format.\n\t* testsuite/performance/ext/pb_ds/tree_text_insert_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/\n\thash_random_int_erase_mem_usage.cc: Same.\n\t* testsuite/performance/ext/pb_ds/\n\trandom_int_subscript_find_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/\n\tpriority_queue_text_push_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/tree_split_join_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/random_int_find_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/multimap_text_insert_mem_usage.hpp\n\t* testsuite/performance/ext/pb_ds/multimap_text_find_timing.hpp\n\t* testsuite/performance/ext/pb_ds/\n\tpriority_queue_random_int_push_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/priority_queue_text_modify_timing.hpp\n\t* testsuite/performance/ext/pb_ds/tree_order_statistics_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/\n\tpriority_queue_text_push_pop_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/\n\tpriority_queue_text_join_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/\n\tpriority_queue_random_int_push_pop_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/\n\trandom_int_subscript_insert_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/tree_text_lor_find_timing.cc: Same.\n\t* testsuite/performance/ext/pb_ds/multimap_text_insert_timing.hpp\n\t* testsuite/performance/ext/pb_ds/\n\tpriority_queue_text_pop_mem_usage.cc: Same.\n\t* testsuite/performance/ext/pb_ds/\n\thash_zlob_random_int_find_timing.cc: Same.\n\t* testsuite/ext/pb_ds/regression/hash_data_map_rand.cc: Same.\n\t* testsuite/ext/pb_ds/regression/trie_data_map_rand.cc: Same.\n\t* testsuite/ext/pb_ds/regression/list_update_no_data_map_rand.cc: Same.\n\t* testsuite/ext/pb_ds/regression/tree_no_data_map_rand.cc: Same.\n\t* testsuite/ext/pb_ds/regression/list_update_data_map_rand.cc: Same.\n\t* testsuite/ext/pb_ds/regression/hash_no_data_map_rand.cc: Same.\n\t* testsuite/ext/pb_ds/regression/priority_queue_rand.cc: Same.\n\t* testsuite/ext/pb_ds/regression/tree_data_map_rand.cc: Same.\n\t* testsuite/ext/pb_ds/regression/trie_no_data_map_rand.cc: Same.\n\t* testsuite/util/regression/trait/priority_queue/trait.hpp: Same.\n\t* testsuite/util/regression/trait/erase_if_fn.hpp: Same.\n\t* testsuite/util/regression/trait/assoc/native_type_trait.hpp: Same.\n\t* testsuite/util/regression/trait/assoc/node_update_trait.hpp: Same.\n\t* testsuite/util/regression/trait/assoc/get_set_load_trait.hpp: Same.\n\t* testsuite/util/regression/trait/assoc/get_set_loads_trait.hpp: Same.\n\t* testsuite/util/regression/trait/assoc/trait.hpp: Same.\n\t* testsuite/util/regression/trait/assoc/resize_trait.hpp: Same.\n\t* testsuite/util/regression/trait/assoc/type_trait.hpp: Same.\n\t* testsuite/util/regression/trait/assoc/to_string.hpp: Same.\n\t* testsuite/util/regression/basic_type.hpp: Same.\n\t* testsuite/util/common_type/priority_queue/string_form.hpp: Same.\n\t* testsuite/util/common_type/priority_queue/detail/\n\tds_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/detail/\n\tresize_policy_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/detail/\n\ttrigger_policy_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/detail/\n\tcomb_hash_fn_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/detail/ds_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/detail/\n\tsize_policy_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/detail/\n\tprobe_fn_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/detail/\n\tlist_update_policy_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/detail/\n\tstore_hash_string_form.hpp: Same.\n\t* testsuite/util/common_type/assoc/native_set.hpp: Same.\n\t* testsuite/util/io/prog_bar.cc: Same.\n\n\t* testsuite/util/regression/rand/io: Remove.\n\t* testsuite/util/regression/rand/io/priority_queue: Same.\n\t* testsuite/util/regression/rand/io/assoc: Same.\n\t* testsuite/util/regression/rand/io/priority_queue/\n\txml_formatter.hpp: Consolidate this...\n\t* testsuite/util/regression/rand/io/assoc/xml_formatter.hpp: ...this\n\t* testsuite/util/regression/rand/io/xml_formatter.hpp: ... and this\n\t* testsuite/util/regression/rand/xml_formatter.hpp: ...here.\n\n\t* testsuite/util/regression/rand/priority_queue/\n\tcontainer_rand_regression_test.hpp:To ...\n\tcontainer_rand_regression_test.h: ... this.\n\t* testsuite/util/regression/rand/priority_queue/detail/*.hpp:To ...\n\t* testsuite/util/regression/rand/priority_queue/\n\tcontainer_rand_regression_test.tcc: ... this.\n\tPB_DS_THROW_IF_FAIL: Change to _GLIBCXX_THROW_IF, adjust predicate.\n\tPB_DS_SET_DESTRUCT_PRINT: Fold inline.\n\tPB_DS_CANCEL_DESTRUCT_PRINT: Fold inline.\n\t* testsuite/util/regression/rand/priority_queue/\n\trand_regression_test.hpp: Adjust includes.\n\n\t* testsuite/util/regression/rand/assoc/\n\tcontainer_rand_regression_test.hpp: To ...\n\t* testsuite/util/regression/rand/assoc/\n\tcontainer_rand_regression_test.h: ... this.\n\t* testsuite/util/regression/rand/assoc/detail/*.hpp:To ...\n\t* testsuite/util/regression/rand/assoc/\n\tcontainer_rand_regression_test.tcc: ...this.\n\t* testsuite/util/regression/rand/assoc/rand_regression_test.hpp: Adjust\n\tincludes.\n\n\t* testsuite/util/regression/priority_queue: Remove.\n\t* testsuite/util/regression/assoc: Remove.\n\t* testsuite/util/regression/priority_queue/\n\tcommon_type.hpp: Consolidate this...\n\t* testsuite/util/regression/assoc/common_type.hpp: ... and this\n\t* testsuite/util/regression/common_type.hpp: ...here.\n\n\t* testsuite/util/rng: Remove.\n\t* testsuite/util/rng/twister_rand_gen.cc: Consolidate...\n\t* testsuite/util/rng/twister_rand_gen.hpp: ... and this\n\t* testsuite/util/testsuite_rng.h: ...here.\n\n\t* testsuite/util/native_type/priority_queue: Remove.\n\t* testsuite/util/native_type/priority_queue/\n\tnative_priority_queue.hpp: To...\n\t* testsuite/util/native_type/native_priority_queue.hpp: ...here.\n\n\t* testsuite/util/native_type/assoc: Remove.\n\t* testsuite/util/native_type/assoc/native_multimap.hpp: To...\n\t* testsuite/util/native_type/assoc/native_tree_tag.hpp: To...\n\t* testsuite/util/native_type/assoc/native_hash_multimap.hpp: To...\n\t* testsuite/util/native_type/assoc/native_set.hpp: To...\n\t* testsuite/util/native_type/assoc/native_map.hpp: To...\n\t* testsuite/util/native_type/assoc/native_hash_set.hpp: To...\n\t* testsuite/util/native_type/assoc/native_hash_tag.hpp: To...\n\t* testsuite/util/native_type/assoc/native_hash_map.hpp: To...\n\t* testsuite/util/native_type/native_multimap.hpp: ...here.\n\t* testsuite/util/native_type/native_tree_tag.hpp: ...here.\n\t* testsuite/util/native_type/native_hash_multimap.hpp: ...here.\n\t* testsuite/util/native_type/native_set.hpp: ...here.\n\t* testsuite/util/native_type/native_map.hpp: ...here.\n\t* testsuite/util/native_type/native_hash_set.hpp: ...here.\n\t* testsuite/util/native_type/native_hash_tag.hpp: ...here.\n\t* testsuite/util/native_type/native_hash_map.hpp: ...here.\n\n\t* testsuite/util/common_type/priority_queue/common_type.hpp:\n\tMake include guard distinct.\n\nFrom-SVN: r136497", "tree": {"sha": "c613dcf3fb3a3c8ab813dc257a992c37ad32aa74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c613dcf3fb3a3c8ab813dc257a992c37ad32aa74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/comments", "author": null, "committer": null, "parents": [{"sha": "bffc9d793fd01df2420a39b2544860f9bae16848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffc9d793fd01df2420a39b2544860f9bae16848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bffc9d793fd01df2420a39b2544860f9bae16848"}], "stats": {"total": 9516, "additions": 3941, "deletions": 5575}, "files": [{"sha": "0e30cfd343a48de600e4be40121b70b797e18ce4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 177, "deletions": 19, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -1,3 +1,161 @@\n+2008-06-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* doc/xml/manual/using.xml: Outline exception topics.\n+\n+\t* include/ext/pb_ds/detail/binary_heap_/insert_fn_imps.hpp: Format.\n+\t* include/ext/pb_ds/detail/left_child_next_sibling_heap_/\n+\tpolicy_access_fn_imps.hpp: Same.\n+\t* include/ext/pb_ds/priority_queue.hpp: Same.\n+\t* include/ext/throw_allocator.h: Same.\n+\n+\t* include/ext/pb_ds/tag_and_trait.hpp (string_tag): New tag.\n+\t(sequence_tag): New tag. Doxygen markup fixes.\n+\n+\t* testsuite/lib/libstdc++.exp: Remove twister_ran_gen.cc source file.\n+\n+\t* testsuite/performance/ext/pb_ds/text_find_timing.cc: Fix\n+\tcomment typo, include paths, format.\n+\t* testsuite/performance/ext/pb_ds/tree_text_insert_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/\n+\thash_random_int_erase_mem_usage.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/\n+\trandom_int_subscript_find_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/\n+\tpriority_queue_text_push_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/tree_split_join_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/random_int_find_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/multimap_text_insert_mem_usage.hpp\n+\t* testsuite/performance/ext/pb_ds/multimap_text_find_timing.hpp\n+\t* testsuite/performance/ext/pb_ds/\n+\tpriority_queue_random_int_push_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/priority_queue_text_modify_timing.hpp\n+\t* testsuite/performance/ext/pb_ds/tree_order_statistics_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/\n+\tpriority_queue_text_push_pop_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/\n+\tpriority_queue_text_join_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/\n+\tpriority_queue_random_int_push_pop_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/\n+\trandom_int_subscript_insert_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/tree_text_lor_find_timing.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/multimap_text_insert_timing.hpp\n+\t* testsuite/performance/ext/pb_ds/\n+\tpriority_queue_text_pop_mem_usage.cc: Same.\n+\t* testsuite/performance/ext/pb_ds/\n+\thash_zlob_random_int_find_timing.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/hash_data_map_rand.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/trie_data_map_rand.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/list_update_no_data_map_rand.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/tree_no_data_map_rand.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/list_update_data_map_rand.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/hash_no_data_map_rand.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/priority_queue_rand.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/tree_data_map_rand.cc: Same.\n+\t* testsuite/ext/pb_ds/regression/trie_no_data_map_rand.cc: Same.\n+\t* testsuite/util/regression/trait/priority_queue/trait.hpp: Same.\n+\t* testsuite/util/regression/trait/erase_if_fn.hpp: Same.\n+\t* testsuite/util/regression/trait/assoc/native_type_trait.hpp: Same.\n+\t* testsuite/util/regression/trait/assoc/node_update_trait.hpp: Same.\n+\t* testsuite/util/regression/trait/assoc/get_set_load_trait.hpp: Same.\n+\t* testsuite/util/regression/trait/assoc/get_set_loads_trait.hpp: Same.\n+\t* testsuite/util/regression/trait/assoc/trait.hpp: Same.\n+\t* testsuite/util/regression/trait/assoc/resize_trait.hpp: Same.\n+\t* testsuite/util/regression/trait/assoc/type_trait.hpp: Same.\n+\t* testsuite/util/regression/trait/assoc/to_string.hpp: Same.\n+\t* testsuite/util/regression/basic_type.hpp: Same.\n+\t* testsuite/util/common_type/priority_queue/string_form.hpp: Same.\n+\t* testsuite/util/common_type/priority_queue/detail/\n+\tds_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/detail/\n+\tresize_policy_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/detail/\n+\ttrigger_policy_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/detail/\n+\tcomb_hash_fn_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/detail/ds_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/detail/\n+\tsize_policy_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/detail/\n+\tprobe_fn_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/detail/\n+\tlist_update_policy_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/detail/\n+\tstore_hash_string_form.hpp: Same.\n+\t* testsuite/util/common_type/assoc/native_set.hpp: Same.\n+\t* testsuite/util/io/prog_bar.cc: Same.\n+\n+\t* testsuite/util/regression/rand/io: Remove.\n+\t* testsuite/util/regression/rand/io/priority_queue: Same.\n+\t* testsuite/util/regression/rand/io/assoc: Same.\n+\t* testsuite/util/regression/rand/io/priority_queue/\n+\txml_formatter.hpp: Consolidate this...\n+\t* testsuite/util/regression/rand/io/assoc/xml_formatter.hpp: ...this\n+\t* testsuite/util/regression/rand/io/xml_formatter.hpp: ... and this\n+\t* testsuite/util/regression/rand/xml_formatter.hpp: ...here.\n+\n+\t* testsuite/util/regression/rand/priority_queue/\n+\tcontainer_rand_regression_test.hpp:To ...\n+\tcontainer_rand_regression_test.h: ... this.\n+\t* testsuite/util/regression/rand/priority_queue/detail/*.hpp:To ...\n+\t* testsuite/util/regression/rand/priority_queue/\n+\tcontainer_rand_regression_test.tcc: ... this.\n+\tPB_DS_THROW_IF_FAIL: Change to _GLIBCXX_THROW_IF, adjust predicate.\n+\tPB_DS_SET_DESTRUCT_PRINT: Fold inline.\n+\tPB_DS_CANCEL_DESTRUCT_PRINT: Fold inline.\n+\t* testsuite/util/regression/rand/priority_queue/\n+\trand_regression_test.hpp: Adjust includes.\n+\n+\t* testsuite/util/regression/rand/assoc/\n+\tcontainer_rand_regression_test.hpp: To ...\n+\t* testsuite/util/regression/rand/assoc/\n+\tcontainer_rand_regression_test.h: ... this.\n+\t* testsuite/util/regression/rand/assoc/detail/*.hpp:To ...\n+\t* testsuite/util/regression/rand/assoc/\n+\tcontainer_rand_regression_test.tcc: ...this.\n+\t* testsuite/util/regression/rand/assoc/rand_regression_test.hpp: Adjust\n+\tincludes.\n+\n+\t* testsuite/util/regression/priority_queue: Remove.\n+\t* testsuite/util/regression/assoc: Remove.\n+\t* testsuite/util/regression/priority_queue/\n+\tcommon_type.hpp: Consolidate this...\n+\t* testsuite/util/regression/assoc/common_type.hpp: ... and this\n+\t* testsuite/util/regression/common_type.hpp: ...here.\n+\n+\t* testsuite/util/rng: Remove.\n+\t* testsuite/util/rng/twister_rand_gen.cc: Consolidate...\n+\t* testsuite/util/rng/twister_rand_gen.hpp: ... and this\n+\t* testsuite/util/testsuite_rng.h: ...here.\n+\n+\t* testsuite/util/native_type/priority_queue: Remove.\n+\t* testsuite/util/native_type/priority_queue/\n+\tnative_priority_queue.hpp: To...\n+\t* testsuite/util/native_type/native_priority_queue.hpp: ...here.\n+\n+\t* testsuite/util/native_type/assoc: Remove.\n+\t* testsuite/util/native_type/assoc/native_multimap.hpp: To...\n+\t* testsuite/util/native_type/assoc/native_tree_tag.hpp: To...\n+\t* testsuite/util/native_type/assoc/native_hash_multimap.hpp: To...\n+\t* testsuite/util/native_type/assoc/native_set.hpp: To...\n+\t* testsuite/util/native_type/assoc/native_map.hpp: To...\n+\t* testsuite/util/native_type/assoc/native_hash_set.hpp: To...\n+\t* testsuite/util/native_type/assoc/native_hash_tag.hpp: To...\n+\t* testsuite/util/native_type/assoc/native_hash_map.hpp: To...\n+\t* testsuite/util/native_type/native_multimap.hpp: ...here.\n+\t* testsuite/util/native_type/native_tree_tag.hpp: ...here.\n+\t* testsuite/util/native_type/native_hash_multimap.hpp: ...here.\n+\t* testsuite/util/native_type/native_set.hpp: ...here.\n+\t* testsuite/util/native_type/native_map.hpp: ...here.\n+\t* testsuite/util/native_type/native_hash_set.hpp: ...here.\n+\t* testsuite/util/native_type/native_hash_tag.hpp: ...here.\n+\t* testsuite/util/native_type/native_hash_map.hpp: ...here.\n+\n+\t* testsuite/util/common_type/priority_queue/common_type.hpp:\n+\tMake include guard distinct.\n+\t* testsuite/util/common_type/assoc/common_type.hpp: Same.\n+\n 2008-06-06  Joseph Myers  <joseph@codesourcery.com>\n \n \t* configure.ac: Do not check for gconv.h.\n@@ -18,16 +176,16 @@\n \n 2008-06-05  Johannes Singler  <singler@ira.uka.de>\n \n-        * include/parallel/random_shuffle.h:\n-        (parallel_random_shuffle_drs) Get the actual number of\n-        threads after entering the parallel region. Indentation.\n-        * include/parallel/algo.h: (random_shuffle(begin, end))\n-        Add namespace qualification to avoid ambiguity.\n+\t* include/parallel/random_shuffle.h:\n+\t(parallel_random_shuffle_drs) Get the actual number of\n+\tthreads after entering the parallel region. Indentation.\n+\t* include/parallel/algo.h: (random_shuffle(begin, end))\n+\tAdd namespace qualification to avoid ambiguity.\n \n 2008-06-04  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/ext/pb_ds/assoc_container.hpp: Change allocator typedef\n-\tto allocator_type, as per existing conventions.\t\n+\tto allocator_type, as per existing conventions.\n \t* include/ext/pb_ds/detail/binomial_heap_base_/\n \tbinomial_heap_base_.hpp: Same.\n \t* include/ext/pb_ds/detail/cc_hash_table_map_/cc_ht_map_.hpp: Same.\n@@ -74,15 +232,15 @@\n \ttrie_supports_prefix_search.hpp: Same.\n \t* testsuite/util/common_type/assoc/detail/\n \ttrie_supports_order_statistics.hpp: Same.\n-\t\n+\n 2008-06-02  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* testsuite/27_io/basic_filebuf/sputbackc/char/9425.cc: Use\n \tdg-require-fileio.\n \t* testsuite/27_io/basic_filebuf/sputbackc/char/1-out.cc: Likewise.\n \t* testsuite/27_io/basic_filebuf/sputbackc/char/2-out.cc: Likewise.\n- \n+\n 2008-06-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/bits/vector.tcc (vector<>::_M_insert_aux): In C++0x mode,\n@@ -173,7 +331,7 @@\n \n 2008-05-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n-\t* include/std/tuple: Replace int -> size_t throughout per DR 775. \n+\t* include/std/tuple: Replace int -> size_t throughout per DR 775.\n \t* include/tr1_impl/array: Likewise.\n \t* include/tr1_impl/utility: Likewise.\n \t* doc/xml/manual/intro.xml: Add an entry for DR 775.\n@@ -190,7 +348,7 @@\n 2008-05-22  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/tr1_impl/hashtable_policy.h (_Map_base<,,\n-\tstd::_Select1st<_Pair>, true,>::at): Add per DR 761. \n+\tstd::_Select1st<_Pair>, true,>::at): Add per DR 761.\n \t* testsuite/23_containers/unordered_map/dr761.cc: New.\n \t* doc/xml/manual/intro.xml: Add an entry for DR 761.\n \n@@ -240,7 +398,7 @@\n \t* testsuite/20_util/is_integral/requirements/typedefs.cc: Likewise.\n \t* testsuite/20_util/is_integral/requirements/\n \texplicit_instantiation.cc: Likewise.\n-\t* testsuite/18_support/numeric_limits/char16_32_t.cc: Likewise.\t\n+\t* testsuite/18_support/numeric_limits/char16_32_t.cc: Likewise.\n \t* config/abi/pre/gnu.ver: Export new numeric_limits symbols at\n \tGLIBCXX_3.4.11.\n \t* configure: Regenerate.\n@@ -255,7 +413,7 @@\n \t* include/std/ostream: Adjust error_code inserter.\n \t* acinclude.m4 (GLIBCXX_CHECK_SYSTEM_ERROR): Remove sys_nerr test.\n \t* config/abi/pre/gnu.ver: Add new exports.\n-\t\n+\n \t* testsuite/util/testsuite_error.h: Consolidate error testing\n \tutilities here.\n \t* testsuite/19_diagnostics/error_code/cons/1.cc: Use\n@@ -266,7 +424,7 @@\n \t* testsuite/19_diagnostics/error_category/cons/default.cc: Same.\n \t* testsuite/19_diagnostics/error_category/operators/equal.cc: Same.\n \t* testsuite/19_diagnostics/error_category/operators/not_equal.cc: Same.\n-\t* testsuite/19_diagnostics/system_error/cons_virtual_derivation.cc: \n+\t* testsuite/19_diagnostics/system_error/cons_virtual_derivation.cc:\n \tSame.\n \t* testsuite/19_diagnostics/system_error/cons-1.cc: Same.\n \t* testsuite/19_diagnostics/system_error/what-1.cc: Same.\n@@ -282,9 +440,9 @@\n \n 2008-05-15  Johannes Singler  <singler@ira.uka.de>\n \n-        * xml/manual/parallel_mode.xml:\n-        General revision and documentation of new compile-time \n-        options for sorting.\n+\t* xml/manual/parallel_mode.xml:\n+\tGeneral revision and documentation of new compile-time\n+\toptions for sorting.\n \n 2008-05-14  Benjamin Kosnik  <bkoz@redhat.com>\n \n@@ -313,7 +471,7 @@\n \t* testsuite/29_atomics/atomic_flag/test_and_set/implicit.c: Same.\n \n \t* doc/doxygen/user.cfg.in: Remove thread include.\n-\t\n+\n 2008-05-13  David Daney  <ddaney@avtrex.com>\n \n \t* config/cpu/mips/atomicity.h: Remove file.\n@@ -344,7 +502,7 @@\n        * include/parallel/quicksort.h:\n        (parallel_sort_qs_conquer) Explicitly request number of threads\n        in the parallel clause.\n-       (parallel_sort_qs) Remove setting the number of threads globally. \n+       (parallel_sort_qs) Remove setting the number of threads globally.\n \n 2008-05-06  Benjamin Kosnik  <bkoz@redhat.com>\n \n@@ -355,7 +513,7 @@\n \t* testsuite/30_threads/mutex/cons/copy_neg.cc: Same.\n \t* testsuite/30_threads/recursive_mutex/cons/assign_neg.cc: Same.\n \t* testsuite/30_threads/recursive_mutex/cons/copy_neg.cc: Same.\n-\t\n+\n 2008-05-06  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/std/condition_variable: New."}, {"sha": "861058d7447ba760b7838558a2639fa70617f7a0", "filename": "libstdc++-v3/doc/xml/manual/using.xml", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -1013,9 +1013,22 @@ gcc version 4.1.2 20070925 (Red Hat 4.1.2-33)\n     </sect2>\n   </sect1>\n \n-  <sect1 id=\"manual.intro.using.exception_safety\" xreflabel=\"Exception Safety\">\n-    <title>Exception Safety</title>\n+  <sect1 id=\"manual.intro.using.exception\" xreflabel=\"Exceptions\">\n+    <title>Exceptions</title>\n     <para></para>\n+\n+  <sect2 id=\"intro.using.exception.propagating\" xreflabel=\"Propagating Exceptions\">\n+    <title>Propagating Exceptions aka Exception Neutrality</title>\n+  </sect2>\n+\n+  <sect2 id=\"intro.using.exception.safety\" xreflabel=\"Exception Safety\">\n+    <title>Exception Safety</title>\n+  </sect2>\n+\n+  <sect2 id=\"intro.using.exception.no\" xreflabel=\"no-exceptions\">\n+    <title>Support for <literal>-fno-exceptions</literal></title>\n+  </sect2>\n+\n   </sect1>  \n \n <!-- Section 0x : Debug -->"}, {"sha": "a32bd723415b0f9b4ec6f1afa8d6913a70f84435", "filename": "libstdc++-v3/include/ext/pb_ds/detail/binary_heap_/insert_fn_imps.hpp", "status": "modified", "additions": 15, "deletions": 46, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fbinary_heap_%2Finsert_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fbinary_heap_%2Finsert_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fbinary_heap_%2Finsert_fn_imps.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,14 +50,11 @@ PB_DS_CLASS_C_DEC::\n push(const_reference r_val)\n {\n   _GLIBCXX_DEBUG_ONLY(assert_valid();)\n-\n-    insert_value(r_val, s_no_throw_copies_ind);\n-\n-  std::push_heap(m_a_entries, m_a_entries + m_size, static_cast<entry_cmp& >(*this));\n-\n+  insert_value(r_val, s_no_throw_copies_ind);\n+  std::push_heap(m_a_entries, m_a_entries + m_size, \n+\t\t static_cast<entry_cmp&>(*this));\n   _GLIBCXX_DEBUG_ONLY(assert_valid();)\n-\n-    return point_iterator(m_a_entries);\n+  return point_iterator(m_a_entries);\n }\n \n PB_DS_CLASS_T_DEC\n@@ -76,15 +73,10 @@ PB_DS_CLASS_C_DEC::\n insert_value(const_reference r_val, false_type)\n {\n   resize_for_insert_if_needed();\n-\n   pointer p_new = s_value_allocator.allocate(1);\n-\n   cond_dealtor_t cond(p_new);\n-\n   new (p_new) value_type(r_val);\n-\n   cond.set_no_action();\n-\n   m_a_entries[m_size++] = p_new;\n }\n \n@@ -94,7 +86,6 @@ PB_DS_CLASS_C_DEC::\n insert_entry(entry e)\n {\n   resize_for_insert_if_needed();\n-\n   m_a_entries[m_size++] = e;\n }\n \n@@ -106,23 +97,15 @@ resize_for_insert_if_needed()\n   if (!resize_policy::resize_needed_for_grow(m_size))\n     {\n       _GLIBCXX_DEBUG_ASSERT(m_size < m_actual_size);\n-\n       return;\n     }\n \n-  const size_type new_actual_size =\n-    resize_policy::get_new_size_for_grow();\n-\n+  const size_type new_actual_size = resize_policy::get_new_size_for_grow();\n   entry_pointer a_new_entries = s_entry_allocator.allocate(new_actual_size);\n-\n   resize_policy::notify_grow_resize();\n-\n   std::copy(m_a_entries, m_a_entries + m_size, a_new_entries);\n-\n   s_entry_allocator.deallocate(m_a_entries, m_actual_size);\n-\n   m_actual_size = new_actual_size;\n-\n   m_a_entries = a_new_entries;\n }\n \n@@ -132,69 +115,55 @@ PB_DS_CLASS_C_DEC::\n modify(point_iterator it, const_reference r_new_val)\n {\n   _GLIBCXX_DEBUG_ONLY(assert_valid();)\n-\n-    swap_value_imp(it.m_p_e, r_new_val, s_no_throw_copies_ind);\n-\n+  swap_value_imp(it.m_p_e, r_new_val, s_no_throw_copies_ind);\n   fix(it.m_p_e);\n-\n   _GLIBCXX_DEBUG_ONLY(assert_valid();)\n-    }\n+}\n \n PB_DS_CLASS_T_DEC\n void\n PB_DS_CLASS_C_DEC::\n fix(entry_pointer p_e)\n {\n   size_type i = p_e - m_a_entries;\n-\n-  if (i > 0&&  entry_cmp::operator()(m_a_entries[parent(i)], m_a_entries[i]))\n+  if (i > 0 && entry_cmp::operator()(m_a_entries[parent(i)], m_a_entries[i]))\n     {\n       size_type parent_i = parent(i);\n-\n-      while (i > 0&&  entry_cmp::operator()(m_a_entries[parent_i], m_a_entries[i]))\n+      while (i > 0 \n+\t     && entry_cmp::operator()(m_a_entries[parent_i], m_a_entries[i]))\n         {\n \t  std::swap(m_a_entries[i], m_a_entries[parent_i]);\n-\n \t  i = parent_i;\n-\n \t  parent_i = parent(i);\n         }\n \n       _GLIBCXX_DEBUG_ONLY(assert_valid();)\n-\n-        return;\n+      return;\n     }\n \n   while (i < m_size)\n     {\n       const size_type left_child_i = left_child(i);\n       const size_type right_child_i = right_child(i);\n-\n       _GLIBCXX_DEBUG_ASSERT(right_child_i > left_child_i);\n-\n-      const bool smaller_than_left_child =\n-\tleft_child_i < m_size&& \n+      const bool smaller_than_left_child = left_child_i < m_size && \n \tentry_cmp::operator()(m_a_entries[i], m_a_entries[left_child_i]);\n \n-      const bool smaller_than_right_child =\n-\tright_child_i < m_size&& \n+      const bool smaller_than_right_child = right_child_i < m_size && \n \tentry_cmp::operator()(m_a_entries[i], m_a_entries[right_child_i]);\n \n-      const bool swap_with_r_child = smaller_than_right_child&& (!smaller_than_left_child ||\n-\t\t\t\t\t\t\t\t entry_cmp::operator()(m_a_entries[left_child_i], m_a_entries[right_child_i]));\n+      const bool swap_with_r_child = smaller_than_right_child && (!smaller_than_left_child || entry_cmp::operator()(m_a_entries[left_child_i], m_a_entries[right_child_i]));\n \n-      const bool swap_with_l_child = !swap_with_r_child&&  smaller_than_left_child;\n+      const bool swap_with_l_child = !swap_with_r_child && smaller_than_left_child;\n \n       if (swap_with_l_child)\n         {\n \t  std::swap(m_a_entries[i], m_a_entries[left_child_i]);\n-\n \t  i = left_child_i;\n         }\n       else if (swap_with_r_child)\n         {\n \t  std::swap(m_a_entries[i], m_a_entries[right_child_i]);\n-\n \t  i = right_child_i;\n         }\n       else"}, {"sha": "e17c53c539d381180b5b7f6b769a456e2390bee6", "filename": "libstdc++-v3/include/ext/pb_ds/detail/left_child_next_sibling_heap_/policy_access_fn_imps.hpp", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fleft_child_next_sibling_heap_%2Fpolicy_access_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fleft_child_next_sibling_heap_%2Fpolicy_access_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fleft_child_next_sibling_heap_%2Fpolicy_access_fn_imps.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,15 +48,11 @@ PB_DS_CLASS_T_DEC\n Cmp_Fn& \n PB_DS_CLASS_C_DEC::\n get_cmp_fn()\n-{\n-  return (*this);\n-}\n+{ return *this; }\n \n PB_DS_CLASS_T_DEC\n const Cmp_Fn& \n PB_DS_CLASS_C_DEC::\n get_cmp_fn() const\n-{\n-  return (*this);\n-}\n+{ return *this; }\n "}, {"sha": "3b31874dc4fcb25f0e8653a80dec8b0ec24891b8", "filename": "libstdc++-v3/include/ext/pb_ds/priority_queue.hpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fpriority_queue.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fpriority_queue.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fpriority_queue.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -59,7 +59,7 @@ namespace __gnu_pbds\n \t   typename Tag = pairing_heap_tag,\n \t   typename Allocator = std::allocator<char> >\n   class priority_queue \n-    : public detail::priority_queue_base_dispatch<Value_Type,Cmp_Fn,Tag,Allocator>::type\n+  : public detail::priority_queue_base_dispatch<Value_Type,Cmp_Fn,Tag,Allocator>::type\n   {\n   private:\n     typedef typename detail::priority_queue_base_dispatch<Value_Type,Cmp_Fn,Tag,Allocator>::type base_type;\n@@ -114,7 +114,7 @@ namespace __gnu_pbds\n     priority_queue& \n     operator=(const priority_queue& other)\n     {\n-      if (this !=& other)\n+      if (this != &other)\n \t{\n \t  priority_queue tmp(other);\n \t  swap(tmp);"}, {"sha": "5b5a2f3437743e16f9aa311c93e881b1cc1d5f9d", "filename": "libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Ftag_and_trait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Ftag_and_trait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Ftag_and_trait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -89,70 +89,77 @@ namespace __gnu_pbds\n   { };\n \n \n-  // A mapped-policy indicating that an associative container is a set.\n+  /// A mapped-policy indicating that an associative container is a set.\n   // XXX should this be a trait of the form is_set<T> ??\n   struct null_mapped_type { };\n \n \n-  // Base data structure tag.\n+  /// Base data structure tag.\n   struct container_tag\n   { };\n \n-  // Basic associative-container.\n+  /// Basic string container, inclusive of strings, ropes, etc.\n+  struct string_tag : public container_tag { };\n+\n+  /// Basic sequence.\n+  struct sequence_tag : public container_tag { };\n+\n+  /// Basic associative-container.\n   struct associative_container_tag : public container_tag { };\n \n-  // Basic hash.\n+  /// Basic hash.\n   struct basic_hash_tag : public associative_container_tag { };\n \n-  // Collision-chaining hash.\n+  /// Collision-chaining hash.\n   struct cc_hash_tag : public basic_hash_tag { };\n \n-  // General-probing hash.\n+  /// General-probing hash.\n   struct gp_hash_tag : public basic_hash_tag { };\n \n-  // Basic tree.\n+  /// Basic tree.\n   struct basic_tree_tag : public associative_container_tag { };\n \n-  // tree.\n+  /// tree.\n   struct tree_tag : public basic_tree_tag { };\n \n-  // Red-black tree.\n+  /// Red-black tree.\n   struct rb_tree_tag : public tree_tag { };\n \n-  // Splay tree.\n+  /// Splay tree.\n   struct splay_tree_tag : public tree_tag { };\n \n-  // Ordered-vector tree.\n+  /// Ordered-vector tree.\n   struct ov_tree_tag : public tree_tag { };\n \n-  // trie.\n+  /// trie.\n   struct trie_tag : public basic_tree_tag { };\n \n-  // PATRICIA trie.\n+  /// PATRICIA trie.\n   struct pat_trie_tag : public trie_tag { };\n \n-  // List-update.\n+  /// List-update.\n   struct list_update_tag : public associative_container_tag { };\n \n-  // Basic priority-queue.\n+  /// Basic priority-queue.\n   struct priority_queue_tag : public container_tag { };\n \n-  // Pairing-heap.\n+  /// Pairing-heap.\n   struct pairing_heap_tag : public priority_queue_tag { };\n \n-  // Binomial-heap.\n+  /// Binomial-heap.\n   struct binomial_heap_tag : public priority_queue_tag { };\n \n-  // Redundant-counter binomial-heap.\n+  /// Redundant-counter binomial-heap.\n   struct rc_binomial_heap_tag : public priority_queue_tag { };\n \n-  // Binary-heap (array-based).\n+  /// Binary-heap (array-based).\n   struct binary_heap_tag : public priority_queue_tag { };\n \n-  // Thin heap.\n+  /// Thin heap.\n   struct thin_heap_tag : public priority_queue_tag { };\n \n \n+  /// Base traits type for containers.\n   template<typename Tag>\n   struct container_traits_base;\n \n@@ -337,7 +344,8 @@ namespace __gnu_pbds\n       };\n   };\n \n-  \n+\n+  /// container_traits\n   // See Matt Austern for the name, S. Meyers MEFC++ #2, others.\n   template<typename Cntnr>\n   struct container_traits "}, {"sha": "36dc3c0f0da1cd9c45ccc6df39e82446f770263c", "filename": "libstdc++-v3/include/ext/throw_allocator.h", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -65,19 +65,18 @@\n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n   class twister_rand_gen\n-  {\n+  {    \n+  private:\n+    std::tr1::mt19937 _M_generator;\n+\n   public:\n-    twister_rand_gen(unsigned int seed = \n-\t\t     static_cast<unsigned int>(std::time(0)));\n+    twister_rand_gen(unsigned int s = static_cast<unsigned int>(std::time(0)));\n     \n     void\n     init(unsigned int);\n     \n     double\n     get_prob();\n-    \n-  private:\n-    std::tr1::mt19937 _M_generator;\n   };\n \n   /// Thown by throw_allocator.\n@@ -116,8 +115,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n     struct group_throw_prob_adjustor\n     {\n-      group_throw_prob_adjustor(size_t size) \n-      : _M_throw_prob_orig(_S_throw_prob)\n+      group_throw_prob_adjustor(size_t size) : _M_throw_prob_orig(_S_throw_prob)\n       {\n \t_S_throw_prob =\n \t  1 - std::pow(double(1 - _S_throw_prob), double(0.5 / (size + 1)));\n@@ -297,14 +295,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   twister_rand_gen::\n   get_prob()\n   {\n-    const double eng_min = _M_generator.min();\n-    const double eng_range =\n-      static_cast<const double>(_M_generator.max() - eng_min);\n-\n-    const double eng_res =\n-      static_cast<const double>(_M_generator() - eng_min);\n-\n-    const double ret = eng_res / eng_range;\n+    const double min = _M_generator.min();\n+    const double res = static_cast<const double>(_M_generator() - min);\n+    const double range = static_cast<const double>(_M_generator.max() - min);\n+    const double ret = res / range;\n     _GLIBCXX_DEBUG_ASSERT(ret >= 0 && ret <= 1);\n     return ret;\n   }\n@@ -397,7 +391,9 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     while (it != _S_map.end())\n       {\n \tif (it->second.first == label)\n-\t  print_to_string(found, *it);\n+\t  {\n+\t    print_to_string(found, *it);\n+\t  }\n \t++it;\n       }\n "}, {"sha": "ab3b624e26dc394f6e8921a6b2976db12f763d81", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/hash_data_map_rand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fhash_data_map_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fhash_data_map_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fhash_data_map_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/assoc/rand_regression_test.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n // This can take long on simulators, timing out the test.\n // { dg-options \"-DPB_DS_REGRESSION -DITERATIONS=5\" { target simulator } }"}, {"sha": "167d4c1bf8f939386652b040fb95c9575afcedf2", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/hash_no_data_map_rand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fhash_no_data_map_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fhash_no_data_map_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fhash_no_data_map_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/assoc/rand_regression_test.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n // This can take long on simulators, timing out the test.\n // { dg-options \"-DPB_DS_REGRESSION -DITERATIONS=5\" { target simulator } }"}, {"sha": "221c0c84bb533501de04768555cd924797d111eb", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/list_update_data_map_rand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Flist_update_data_map_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Flist_update_data_map_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Flist_update_data_map_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/assoc/rand_regression_test.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n int\n main(int argc, char* a_p_argv[])"}, {"sha": "262575fd1dce592b594ca85d500e320ddb50e435", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/list_update_no_data_map_rand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Flist_update_no_data_map_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Flist_update_no_data_map_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Flist_update_no_data_map_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/assoc/rand_regression_test.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n int\n main(int argc, char* a_p_argv[])"}, {"sha": "1d253a9c0036f288ad93b30d229d07c37809da9f", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/priority_queue_rand.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fpriority_queue_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fpriority_queue_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Fpriority_queue_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/priority_queue/rand_regression_test.hpp>\n-#include <regression/priority_queue/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n // This can take long on simulators, timing out the test.\n // { dg-options \"-DPB_DS_REGRESSION -DITERATIONS=5\" { target simulator } }\n@@ -63,7 +63,7 @@ main(int argc, char* a_p_argv[])\n {\n   using namespace __gnu_pbds::test;\n   return rand_regression_test(ITERATIONS, KEYS,\n-\t\t\t      \"tree_no_data_map_rand_regression_test\", \n+\t\t\t      \"pq_no_data_map_rand_regression_test\", \n \t\t\t      pq_tl_t());\n }\n "}, {"sha": "3bcdebf0eb6815146b0e638dcc3834b65c6bbea9", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/tree_data_map_rand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftree_data_map_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftree_data_map_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftree_data_map_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/assoc/rand_regression_test.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n // This can take long on simulators, timing out the test.\n // { dg-options \"-DPB_DS_REGRESSION -DITERATIONS=5\" { target simulator } }"}, {"sha": "acb69119c9dec09d73a503c37fdcdfdd0272f0cb", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/tree_no_data_map_rand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftree_no_data_map_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftree_no_data_map_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftree_no_data_map_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/assoc/rand_regression_test.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n // This can take long on simulators, timing out the test.\n // { dg-options \"-DPB_DS_REGRESSION -DITERATIONS=5\" { target simulator } }"}, {"sha": "64335b09ea6a3e063e0dd7c617e8c7bdcb78105d", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/trie_data_map_rand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftrie_data_map_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftrie_data_map_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftrie_data_map_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/assoc/rand_regression_test.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n // This can take long on simulators, timing out the test.\n // { dg-options \"-DPB_DS_REGRESSION -DITERATIONS=5\" { target simulator } }"}, {"sha": "93b2bdda2b075785b234baf58fc993c0ea036558", "filename": "libstdc++-v3/testsuite/ext/pb_ds/regression/trie_no_data_map_rand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftrie_no_data_map_rand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftrie_no_data_map_rand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpb_ds%2Fregression%2Ftrie_no_data_map_rand.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n // { dg-require-time \"\" }\n \n #include <regression/rand/assoc/rand_regression_test.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n // This can take long on simulators, timing out the test.\n // { dg-options \"-DPB_DS_REGRESSION -DITERATIONS=5\" { target simulator } }"}, {"sha": "d6b372b80ef14f1ad70a34e2130726223fea90f4", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -513,7 +513,7 @@ proc v3-build_support { } {\n     # Build the support objects.\n     set source_files [list testsuite_abi.cc testsuite_allocator.cc \\\n \t\t\t  testsuite_character.cc testsuite_hooks.cc \\\n-\t       \t rng/twister_rand_gen.cc io/verified_cmd_line_input.cc \\\n+\t       \t          io/verified_cmd_line_input.cc \\\n \t\t\t  io/prog_bar.cc performance/time/elapsed_timer.cc ]\n     foreach f $source_files {\n \tset obj [file rootname $f].o"}, {"sha": "042072103c54fa0e257b54c3970501de57f08a20", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/hash_random_int_erase_mem_usage.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fhash_random_int_erase_mem_usage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fhash_random_int_erase_mem_usage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fhash_random_int_erase_mem_usage.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n #include <testsuite_allocator.h>\n #include <performance/io/xml_formatter.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/mem_usage/erase_test.hpp>\n #include <iostream>"}, {"sha": "ee25ce9be24c786915b024ea8d192b10a46a52c0", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/hash_zlob_random_int_find_timing.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fhash_zlob_random_int_find_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fhash_zlob_random_int_find_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fhash_zlob_random_int_find_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -46,9 +46,9 @@\n \n #include <ext/typelist.h>\n #include <performance/io/xml_formatter.hpp>\n-#include <native_type/assoc/native_hash_set.hpp>\n+#include <native_type/native_hash_set.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/find_test.hpp>\n #include <iostream>"}, {"sha": "ad068a557327fca2480a309259664c51157b7b88", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/multimap_text_find_timing.hpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_find_timing.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_find_timing.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_find_timing.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -47,10 +47,10 @@\n #include <ext/typelist.h>\n #include <io/text_populate.hpp>\n #include <performance/io/xml_formatter.hpp>\n-#include <native_type/assoc/native_hash_multimap.hpp>\n-#include <native_type/assoc/native_multimap.hpp>\n+#include <native_type/native_hash_multimap.hpp>\n+#include <native_type/native_multimap.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/multimap_find_test.hpp>\n #include <performance/assoc/multimap_common_type.hpp>"}, {"sha": "8f6fc7e87cfa5771155c23ccf5fd1def63bcd836", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/multimap_text_insert_mem_usage.hpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_insert_mem_usage.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_insert_mem_usage.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_insert_mem_usage.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,10 +50,10 @@\n #include <testsuite_allocator.h>\n #include <io/text_populate.hpp>\n #include <performance/io/xml_formatter.hpp>\n-#include <native_type/assoc/native_hash_multimap.hpp>\n-#include <native_type/assoc/native_multimap.hpp>\n+#include <native_type/native_hash_multimap.hpp>\n+#include <native_type/native_multimap.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/mem_usage/multimap_insert_test.hpp>\n #include <performance/assoc/multimap_common_type.hpp>"}, {"sha": "8e98606040e80dd116f568537312914ef17b0bda", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/multimap_text_insert_timing.hpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_insert_timing.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_insert_timing.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fmultimap_text_insert_timing.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -47,10 +47,10 @@\n #include <ext/typelist.h>\n #include <io/text_populate.hpp>\n #include <performance/io/xml_formatter.hpp>\n-#include <native_type/assoc/native_hash_multimap.hpp>\n-#include <native_type/assoc/native_multimap.hpp>\n+#include <native_type/native_hash_multimap.hpp>\n+#include <native_type/native_multimap.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/multimap_insert_test.hpp>\n #include <performance/assoc/multimap_common_type.hpp>"}, {"sha": "a6e9338bdbc4f142b858400c75d453327b78731c", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/priority_queue_random_int_push_pop_timing.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_random_int_push_pop_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_random_int_push_pop_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_random_int_push_pop_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -49,8 +49,8 @@\n #include <io/verified_cmd_line_input.hpp>\n #include <common_type/priority_queue/common_type.hpp>\n #include <performance/priority_queue/timing/push_pop_test.hpp>\n-#include <native_type/priority_queue/native_priority_queue.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <native_type/native_priority_queue.hpp>\n+#include <testsuite_rng.h>\n #include <iostream>\n #include <vector>\n "}, {"sha": "0022510ab09710c2a277e60ba9b9fbf7049146c3", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/priority_queue_random_int_push_timing.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_random_int_push_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_random_int_push_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_random_int_push_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -49,8 +49,8 @@\n #include <io/verified_cmd_line_input.hpp>\n #include <common_type/priority_queue/common_type.hpp>\n #include <performance/priority_queue/timing/push_test.hpp>\n-#include <native_type/priority_queue/native_priority_queue.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <native_type/native_priority_queue.hpp>\n+#include <testsuite_rng.h>\n #include <iostream>\n #include <vector>\n "}, {"sha": "6b8904c2174f402f1a81714b2e6f1421290f2ae3", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/priority_queue_text_join_timing.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_join_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_join_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_join_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <common_type/priority_queue/common_type.hpp>\n #include <performance/priority_queue/timing/join_test.hpp>\n #include <io/text_populate.hpp>\n-#include <native_type/priority_queue/native_priority_queue.hpp>\n+#include <native_type/native_priority_queue.hpp>\n #include <iostream>\n #include <vector>\n "}, {"sha": "bcec33c1850776fb8daa4064008c9dace9d3d99c", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/priority_queue_text_modify_timing.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_modify_timing.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_modify_timing.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_modify_timing.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <common_type/priority_queue/common_type.hpp>\n #include <performance/priority_queue/timing/modify_test.hpp>\n #include <io/text_populate.hpp>\n-#include <native_type/priority_queue/native_priority_queue.hpp>\n+#include <native_type/native_priority_queue.hpp>\n #include <iostream>\n #include <vector>\n "}, {"sha": "f4655feed45e89a9d53a9cc49081adb2fccaf600", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/priority_queue_text_pop_mem_usage.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_pop_mem_usage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_pop_mem_usage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_pop_mem_usage.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -53,7 +53,7 @@\n #include <common_type/priority_queue/common_type.hpp>\n #include <performance/priority_queue/mem_usage/pop_test.hpp>\n #include <io/text_populate.hpp>\n-#include <native_type/priority_queue/native_priority_queue.hpp>\n+#include <native_type/native_priority_queue.hpp>\n \n void\n usage();"}, {"sha": "6a222eca1f067a92c15db3fd41d4828663920050", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/priority_queue_text_push_pop_timing.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_push_pop_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_push_pop_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_push_pop_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <common_type/priority_queue/common_type.hpp>\n #include <performance/priority_queue/timing/push_pop_test.hpp>\n #include <io/text_populate.hpp>\n-#include <native_type/priority_queue/native_priority_queue.hpp>\n+#include <native_type/native_priority_queue.hpp>\n #include <iostream>\n #include <vector>\n "}, {"sha": "9967c7db0b8bc73b743bbf5124442d2233b72cfd", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/priority_queue_text_push_timing.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_push_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_push_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Fpriority_queue_text_push_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <common_type/priority_queue/common_type.hpp>\n #include <performance/priority_queue/timing/push_test.hpp>\n #include <io/text_populate.hpp>\n-#include <native_type/priority_queue/native_priority_queue.hpp>\n+#include <native_type/native_priority_queue.hpp>\n #include <iostream>\n #include <vector>\n "}, {"sha": "8e06155a1cad04d1e941f6341ae96f83669eb00c", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/random_int_find_timing.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_find_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_find_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_find_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -46,10 +46,10 @@\n \n #include <ext/typelist.h>\n #include <performance/io/xml_formatter.hpp>\n-#include <native_type/assoc/native_hash_map.hpp>\n-#include <native_type/assoc/native_map.hpp>\n+#include <native_type/native_hash_map.hpp>\n+#include <native_type/native_map.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/find_test.hpp>\n #include <iostream>"}, {"sha": "461ce4ddeec9d6fa5545b17c9db0c89c8cd11e67", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/random_int_subscript_find_timing.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_subscript_find_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_subscript_find_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_subscript_find_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -46,10 +46,10 @@\n \n #include <ext/typelist.h>\n #include <performance/io/xml_formatter.hpp>\n-#include <native_type/assoc/native_hash_map.hpp>\n-#include <native_type/assoc/native_map.hpp>\n+#include <native_type/native_hash_map.hpp>\n+#include <native_type/native_map.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/subscript_find_test.hpp>\n #include <iostream>"}, {"sha": "a30e3c557532b28d8be92c5b31aebf2e7aba0b86", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/random_int_subscript_insert_timing.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_subscript_insert_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_subscript_insert_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Frandom_int_subscript_insert_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -46,10 +46,10 @@\n \n #include <ext/typelist.h>\n #include <performance/io/xml_formatter.hpp>\n-#include <native_type/assoc/native_hash_map.hpp>\n-#include <native_type/assoc/native_map.hpp>\n+#include <native_type/native_hash_map.hpp>\n+#include <native_type/native_map.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/subscript_insert_test.hpp>\n #include <iostream>"}, {"sha": "e769984eecd0b0050ec8551cc7e8cc3089608a5c", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/text_find_timing.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftext_find_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftext_find_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftext_find_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -51,8 +51,8 @@\n #include <performance/assoc/timing/find_test.hpp>\n #include <io/text_populate.hpp>\n #include <hash_fn/string_hash_fn.hpp>\n-#include <native_type/assoc/native_hash_map.hpp>\n-#include <native_type/assoc/native_map.hpp>\n+#include <native_type/native_hash_map.hpp>\n+#include <native_type/native_map.hpp>\n #include <iostream>\n #include <vector>\n "}, {"sha": "da1dda878d76c835633c76e0dbaf53c9693b8ddb", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/tree_order_statistics_timing.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_order_statistics_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_order_statistics_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_order_statistics_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -49,7 +49,7 @@\n #include <ext/typelist.h>\n #include <performance/io/xml_formatter.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/tree_order_statistics_test.hpp>\n "}, {"sha": "72101cfdcd0d1547251ffa936619bcb9e3e4ae66", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/tree_split_join_timing.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_split_join_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_split_join_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_split_join_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -47,7 +47,7 @@\n #include <ext/typelist.h>\n #include <performance/io/xml_formatter.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/tree_split_join_test.hpp>\n #include <iostream>"}, {"sha": "b5d74f013e525c7b9d8e1b7042ef7c9279600a42", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/tree_text_insert_timing.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_text_insert_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_text_insert_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_text_insert_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -51,8 +51,8 @@\n #include <performance/assoc/timing/insert_test.hpp>\n #include <io/text_populate.hpp>\n #include <hash_fn/string_hash_fn.hpp>\n-#include <native_type/assoc/native_hash_map.hpp>\n-#include <native_type/assoc/native_map.hpp>\n+#include <native_type/native_hash_map.hpp>\n+#include <native_type/native_map.hpp>\n #include <iostream>\n #include <vector>\n "}, {"sha": "eb4cbba5f592ceeb821f5d5acc1dea048da635bf", "filename": "libstdc++-v3/testsuite/performance/ext/pb_ds/tree_text_lor_find_timing.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_text_lor_find_timing.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_text_lor_find_timing.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fext%2Fpb_ds%2Ftree_text_lor_find_timing.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <common_type/assoc/common_type.hpp>\n #include <performance/assoc/timing/find_test.hpp>\n #include <io/text_populate.hpp>\n-#include <native_type/assoc/native_map.hpp>\n+#include <native_type/native_map.hpp>\n #include <iostream>\n #include <vector>\n "}, {"sha": "d2f7fa0b89cfb9883eac0e6030e70f99a8437f68", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/common_type.hpp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fcommon_type.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fcommon_type.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fcommon_type.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -44,8 +44,8 @@\n  * Contains common types.\n  */\n \n-#ifndef PB_DS_COMMON_TYPES_HPP\n-#define PB_DS_COMMON_TYPES_HPP\n+#ifndef PB_DS_COMMON_TYPES_ASSOC_HPP\n+#define PB_DS_COMMON_TYPES_ASSOC_HPP\n \n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <common_type/assoc/template_policy.hpp>\n@@ -812,7 +812,6 @@ namespace __gnu_pbds\n     };\n \n   } // namespace test\n-\n } // namespace __gnu_pbds\n \n-#endif // #ifndef PB_DS_COMMON_TYPES_HPP\n+#endif // #ifndef PB_DS_COMMON_TYPES_ASSOC_HPP"}, {"sha": "248ab3cab530b63fb5f91a295530e89f1c622ea7", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/detail/comb_hash_fn_string_form.hpp", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fcomb_hash_fn_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fcomb_hash_fn_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fcomb_hash_fn_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -52,70 +52,56 @@\n #include <io/xml.hpp>\n \n namespace __gnu_pbds\n+{\n+namespace test\n+{\n+namespace detail\n {\n \n-  namespace test\n+  template<typename Comb_Hash_Fn>\n+  struct comb_hash_fn_string_form\n+  {\n+    static std::string\n+    name()\n+    { return (Comb_Hash_Fn::name()); }\n+\n+    static std::string\n+    desc()\n+    { return (Comb_Hash_Fn::desc()); }\n+  };\n+\n+  template<typename Size_Type>\n+  struct comb_hash_fn_string_form<\n+    direct_mask_range_hashing_t_<\n+      Size_Type> >\n   {\n+    static std::string\n+    name()\n+    { return (\"mask_\"); }\n \n-    namespace detail\n+    static std::string\n+    desc()\n     {\n+      return make_xml_tag(\"Comb_Hash_Fn\", \"value\", \"direct_mask_range_hashing\");\n+    }\n+  };\n \n-      template<typename Comb_Hash_Fn>\n-      struct comb_hash_fn_string_form\n-      {\n-\tstatic std::string\n-        name()\n-\t{\n-\t  return (Comb_Hash_Fn::name());\n-\t}\n-\n-\tstatic std::string\n-        desc()\n-\t{\n-\t  return (Comb_Hash_Fn::desc());\n-\t}\n-      };\n-\n-      template<typename Size_Type>\n-      struct comb_hash_fn_string_form<\n-\tdirect_mask_range_hashing_t_<\n-        Size_Type> >\n-      {\n-\tstatic std::string\n-        name()\n-\t{\n-\t  return (\"mask_\");\n-\t}\n-\n-\tstatic std::string\n-        desc()\n-\t{\n-\t  return (make_xml_tag(            \"Comb_Hash_Fn\", \"value\", \"direct_mask_range_hashing\"));\n-\t}\n-      };\n-\n-      template<typename Size_Type>\n-      struct comb_hash_fn_string_form<\n-\tdirect_mod_range_hashing_t_<\n-        Size_Type> >\n-      {\n-\tstatic std::string\n-        name()\n-\t{\n-\t  return (\"mod_\");\n-\t}\n-\n-\tstatic std::string\n-        desc()\n-\t{\n-\t  return (make_xml_tag(            \"Comb_Hash_Fn\", \"value\", \"direct_mod_range_hashing\"));\n-\t}\n-      };\n-\n-    } // namespace detail\n-\n-  } // namespace test\n+  template<typename Size_Type>\n+  struct comb_hash_fn_string_form<direct_mod_range_hashing_t_<Size_Type> >\n+  {\n+    static std::string\n+    name()\n+    { return (\"mod_\"); }\n+\n+    static std::string\n+    desc()\n+    {\n+      return make_xml_tag(\"Comb_Hash_Fn\", \"value\", \"direct_mod_range_hashing\");\n+    }\n+  };\n \n+} // namespace detail\n+} // namespace test\n } // namespace __gnu_pbds\n \n #endif // #ifndef PB_DS_COMB_HASH_FN_STRING_FORM_HPP"}, {"sha": "485f413ccb5bc853ff285162bc3c76e32b934eda", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/detail/ds_string_form.hpp", "status": "modified", "additions": 35, "deletions": 74, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fds_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fds_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fds_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -61,20 +61,15 @@\n \n namespace __gnu_pbds\n {\n-\n   namespace test\n   {\n-\n     namespace detail\n     {\n-\n       template<typename Cntnr, class Tag>\n       struct ds_string_form;\n \n       template<typename Cntnr>\n-      struct ds_string_form<\n-\tCntnr,\n-\t__gnu_pbds::cc_hash_tag>\n+      struct ds_string_form<Cntnr, __gnu_pbds::cc_hash_tag>\n       {\n \tstatic std::string\n         name()\n@@ -97,14 +92,12 @@ namespace __gnu_pbds\n \t  const std::string store_hash_desc =\n             store_hash_string_form<Cntnr::store_hash>::desc();\n \n-\t  return (make_xml_tag(            \"type\", \"value\", \"cc_hash_table\", comb_hash_fn_desc +            resize_policy_desc +            store_hash_desc));\n+\t  return (make_xml_tag(\"type\", \"value\", \"cc_hash_table\", comb_hash_fn_desc + resize_policy_desc + store_hash_desc));\n \t}\n       };\n \n       template<typename Cntnr>\n-      struct ds_string_form<\n-\tCntnr,\n-\t__gnu_pbds::gp_hash_tag>\n+      struct ds_string_form<Cntnr, __gnu_pbds::gp_hash_tag>\n       {\n \tstatic std::string\n         name()\n@@ -130,8 +123,9 @@ namespace __gnu_pbds\n \n \t  const std::string store_hash_desc =\n             store_hash_string_form<Cntnr::store_hash>::desc();\n-\n-\t  return (make_xml_tag(            \"type\", \"value\", \"gp_hash_table\", comb_probe_fn_desc +            probe_fn_desc +            resize_policy_desc +            store_hash_desc));\n+\t  \n+\t  return make_xml_tag(\"type\", \"value\", \"gp_hash_table\", \n+\t\t\t      comb_probe_fn_desc + probe_fn_desc + resize_policy_desc + store_hash_desc);\n \t}\n       };\n \n@@ -143,99 +137,77 @@ namespace __gnu_pbds\n \t{\n \t  if (tree_supports_order_statistics<Cntnr>::value)\n             return (container_category_str + \"ost_\");\n-\n-\t  return (container_category_str);\n+\t  return container_category_str;\n \t}\n \n \tstatic std::string\n         desc(const std::string container_category_str)\n \t{\n \t  const std::string category_str =\n-            make_xml_tag(                \"Tag\",  \"value\",  container_category_str);\n+            make_xml_tag(\"Tag\",  \"value\",  container_category_str);\n \n \t  const std::string node_update_str =\n-            make_xml_tag(\n-\t\t\t \"Node_Update\",\n-\t\t\t \"value\",(tree_supports_order_statistics<Cntnr>::value?\n-\t\t\t\t  \"tree_order_statistics_node_update\" : \"null_tree_node_update\"));\n+            make_xml_tag(\"Node_Update\",\n+\t\t\t \"value\",(tree_supports_order_statistics<Cntnr>::value ?\n+\t \"tree_order_statistics_node_update\" : \"null_tree_node_update\"));\n \n-\t  return (make_xml_tag(            \"type\", \"value\", \"tree\", category_str + node_update_str));\n+\t  return make_xml_tag(\"type\", \"value\", \"tree\", category_str + node_update_str);\n \t}\n       };\n \n       template<typename Cntnr>\n-      struct ds_string_form<\n-        Cntnr,\n-        __gnu_pbds::rb_tree_tag> : private tree_ds_string_form<\n-        Cntnr>\n+      struct ds_string_form<Cntnr, __gnu_pbds::rb_tree_tag> \n+      : private tree_ds_string_form<Cntnr>\n       {\n       private:\n \ttypedef tree_ds_string_form< Cntnr> base_type;\n \n       public:\n \tstatic std::string\n         name()\n-\t{\n-\t  return (base_type::name(\"rb_tree_\"));\n-\t}\n+\t{ return base_type::name(\"rb_tree_\"); }\n \n \tstatic std::string\n         desc()\n-\t{\n-\t  return (base_type::desc(\"rb_tree_tag\"));\n-\t}\n+\t{ return base_type::desc(\"rb_tree_tag\"); }\n       };\n \n       template<typename Cntnr>\n-      struct ds_string_form<\n-        Cntnr,\n-        __gnu_pbds::splay_tree_tag> : private tree_ds_string_form<\n-        Cntnr>\n+      struct ds_string_form<Cntnr, __gnu_pbds::splay_tree_tag> \n+      : private tree_ds_string_form<Cntnr>\n       {\n       private:\n \ttypedef tree_ds_string_form< Cntnr> base_type;\n \n       public:\n \tstatic std::string\n         name()\n-\t{\n-\t  return (base_type::name(\"splay_tree_\"));\n-\t}\n+\t{ return base_type::name(\"splay_tree_\"); }\n \n \tstatic std::string\n         desc()\n-\t{\n-\t  return (base_type::desc(\"splay_tree_tag\"));\n-\t}\n+\t{ return base_type::desc(\"splay_tree_tag\"); }\n       };\n \n       template<typename Cntnr>\n-      struct ds_string_form<\n-        Cntnr,\n-        __gnu_pbds::ov_tree_tag> : private tree_ds_string_form<\n-        Cntnr>\n+      struct ds_string_form<Cntnr, __gnu_pbds::ov_tree_tag> \n+      : private tree_ds_string_form<Cntnr>\n       {\n       private:\n \ttypedef tree_ds_string_form< Cntnr> base_type;\n \n       public:\n \tstatic std::string\n         name()\n-\t{\n-\t  return (base_type::name(\"ov_tree_\"));\n-\t}\n+\t{ return (base_type::name(\"ov_tree_\")); }\n \n \tstatic std::string\n         desc()\n-\t{\n-\t  return (base_type::desc(\"ov_tree_tag\"));\n-\t}\n+\t{ return (base_type::desc(\"ov_tree_tag\")); }\n       };\n \n       template<typename Cntnr>\n-      struct ds_string_form<\n-\tCntnr,\n-\t__gnu_pbds::list_update_tag>\n+      struct ds_string_form<Cntnr, __gnu_pbds::list_update_tag>\n       {\n \tstatic std::string\n         name()\n@@ -247,18 +219,13 @@ namespace __gnu_pbds\n \tstatic std::string\n         desc()\n \t{\n-\t  return (make_xml_tag(\n-\t\t\t       \"type\",\n-\t\t\t       \"value\",\n-\t\t\t       \"list_update\",\n-\t\t\t       lu_policy_string_form<typename Cntnr::update_policy>::desc()));\n+\t  return make_xml_tag(\"type\", \"value\", \"list_update\",\n+\t\t\t       lu_policy_string_form<typename Cntnr::update_policy>::desc());\n \t}\n       };\n \n       template<typename Cntnr>\n-      struct ds_string_form<\n-\tCntnr,\n-\t__gnu_pbds::pat_trie_tag>\n+      struct ds_string_form<Cntnr, __gnu_pbds::pat_trie_tag>\n       {\n \tstatic std::string\n         name()\n@@ -275,22 +242,16 @@ namespace __gnu_pbds\n \tstatic std::string\n         desc()\n \t{\n-\t  const std::string category_str =\n-            make_xml_tag(                \"Tag\",  \"value\",  \"pat_trie_tag\");\n-\n-\t  std::string node_update_desc;\n-\n+\t  std::string category_s = make_xml_tag(\"Tag\", \"value\", \"pat_trie_tag\");\n+\t  const char* s;\n \t  if (trie_supports_order_statistics<Cntnr>::value)\n-            node_update_desc =\n-\t      make_xml_tag(                    \"Node_Update\",  \"value\",  \"trie_order_statistics_node_update\");\n+            s = \"trie_order_statistics_node_update\";\n \t  else if (trie_supports_prefix_search<Cntnr>::value)\n-            node_update_desc =\n-\t      make_xml_tag(                    \"Node_Update\",  \"value\",  \"trie_prefix_search_node_update\");\n+\t    s = \"trie_prefix_search_node_update\";\n \t  else\n-            node_update_desc =\n-\t      make_xml_tag(                    \"Node_Update\",  \"value\",  \"null_trie_node_update\");\n-\n-\t  return (make_xml_tag(            \"type\", \"value\", \"trie\", category_str + node_update_desc));\n+            s = \"null_trie_node_update\";\n+\t  std::string node_s = make_xml_tag(\"Node_Update\", \"value\", s);\n+\t  return make_xml_tag(\"type\", \"value\", \"trie\", category_s + node_s);\n \t}\n       };\n "}, {"sha": "e5c9067038cc8dd5950b6d17ec29dd925f8c1f7f", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/detail/list_update_policy_string_form.hpp", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Flist_update_policy_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Flist_update_policy_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Flist_update_policy_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -64,42 +64,36 @@ namespace __gnu_pbds\n       struct lu_policy_string_form;\n \n       template<>\n-      struct lu_policy_string_form<\n-\tmove_to_front_lu_policy_t_>\n+      struct lu_policy_string_form<move_to_front_lu_policy_t_>\n       {\n \tstatic std::string\n         name()\n-\t{\n-\t  return (\"mtf_\");\n-\t}\n+\t{ return (\"mtf_\"); }\n \n \tstatic std::string\n         desc()\n \t{\n-\t  return (make_xml_tag(            \"Update_Policy\", \"value\", \"move_to_front_lu_policy\"));\n+\t  return make_xml_tag(\"Update_Policy\", \"value\", \n+\t\t\t      \"move_to_front_lu_policy\");\n \t}\n       };\n \n       template<typename Allocator, typename Allocator::size_type Max_Count>\n-      struct lu_policy_string_form<\n-\tcounter_lu_policy_t_<\n-        Allocator,\n-        Max_Count> >\n+      struct lu_policy_string_form<counter_lu_policy_t_<Allocator, Max_Count> >\n       {\n \tstatic std::string\n         name()\n \t{\n \t  std::ostringstream ret;\n-\n \t  ret << \"cnt_\" << Max_Count << \"_\";\n-\n \t  return (ret.str());\n \t}\n \n \tstatic std::string\n         desc()\n \t{\n-\t  return (make_xml_tag(            \"Update_Policy\", \"value\", \"counter_lu_policy\", \"Max_Count\", Max_Count));\n+\t  return (make_xml_tag(\"Update_Policy\", \"value\", \"counter_lu_policy\", \n+\t\t\t       \"Max_Count\", Max_Count));\n \t}\n       };\n "}, {"sha": "6e335dcf7e5c9226721ae3030fee05ee217e87e6", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/detail/probe_fn_string_form.hpp", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fprobe_fn_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fprobe_fn_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fprobe_fn_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -64,58 +64,39 @@ namespace __gnu_pbds\n       struct probe_fn_string_form;\n \n       template<typename Key, class Allocator>\n-      struct probe_fn_string_form<\n-\tlinear_probe_fn_t_<\n-        Key,\n-        Allocator> >\n+      struct probe_fn_string_form<linear_probe_fn_t_<Key, Allocator> >\n       {\n \tstatic std::string\n         name()\n-\t{\n-\t  return (\"linp_\");\n-\t}\n+\t{ return (\"linp_\"); }\n \n \tstatic std::string\n         desc()\n-\t{\n-\t  return (make_xml_tag(            \"Probe_Fn\", \"value\", \"linear_probe_fn\"));\n-\t}\n+\t{ return make_xml_tag(\"Probe_Fn\", \"value\", \"linear_probe_fn\"); }\n       };\n \n       template<typename Key, class Allocator>\n-      struct probe_fn_string_form<\n-\tquadratic_probe_fn_t_<\n-        Key,\n-        Allocator> >\n+      struct probe_fn_string_form<quadratic_probe_fn_t_<Key, Allocator> >\n       {\n \tstatic std::string\n         name()\n-\t{\n-\t  return (\"quadp_\");\n-\t}\n+\t{ return (\"quadp_\"); }\n \n \tstatic std::string\n         desc()\n-\t{\n-\t  return (make_xml_tag(            \"Probe_Fn\", \"value\", \"quadratic_probe_fn\"));\n-\t}\n+\t{ return make_xml_tag(\"Probe_Fn\", \"value\", \"quadratic_probe_fn\"); }\n       };\n \n       template<>\n-      struct probe_fn_string_form<\n-\t__gnu_pbds::null_probe_fn>\n+      struct probe_fn_string_form<__gnu_pbds::null_probe_fn>\n       {\n \tstatic std::string\n         name()\n-\t{\n-\t  return (\"\");\n-\t}\n+\t{ return (\"\"); }\n \n \tstatic std::string\n         desc()\n-\t{\n-\t  return (make_xml_tag(            \"Probe_Fn\", \"value\", \"null_probe_fn\"));\n-\t}\n+\t{ return make_xml_tag(\"Probe_Fn\", \"value\", \"null_probe_fn\"); }\n       };\n \n     } // namespace detail"}, {"sha": "f6dc0107bccb1bea11a40e0e32605e9c0c9eb12d", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/detail/resize_policy_string_form.hpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fresize_policy_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fresize_policy_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fresize_policy_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -71,10 +71,7 @@ namespace __gnu_pbds\n \t       typename Size_Type>\n       struct resize_policy_string_form<\n \t__gnu_pbds::hash_standard_resize_policy<\n-        Size_Policy,\n-        Trigger_Policy,\n-        External_Size_Access,\n-        Size_Type> >\n+        Size_Policy, Trigger_Policy, External_Size_Access, Size_Type> >\n       {\n \tstatic std::string\n         name()\n@@ -92,7 +89,7 @@ namespace __gnu_pbds\n \t  const std::string trigger_policy_string_form_desc =\n             trigger_policy_string_form<Trigger_Policy>::desc();\n \n-\t  return (make_xml_tag(            \"Resize_Policy\", \"value\", \"hash_standard_resize_policy\", size_policy_string_form_desc + trigger_policy_string_form_desc));\n+\t  return (make_xml_tag(\"Resize_Policy\", \"value\", \"hash_standard_resize_policy\", size_policy_string_form_desc + trigger_policy_string_form_desc));\n \t}\n       };\n "}, {"sha": "3b8dffa419da510a9e9b7345f9203e428d7f93ed", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/detail/size_policy_string_form.hpp", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fsize_policy_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fsize_policy_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fsize_policy_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -67,19 +67,16 @@ namespace __gnu_pbds\n \n       template<typename Allocator>\n       struct size_policy_string_form<\n-\t__gnu_pbds::test::hash_exponential_size_policy_t_<\n-        Allocator> >\n+\t__gnu_pbds::test::hash_exponential_size_policy_t_<Allocator> >\n       {\n \tstatic std::string\n         name()\n-\t{\n-\t  return (\"exp_\");\n-\t}\n+\t{ return (\"exp_\"); }\n \n \tstatic std::string\n         desc()\n \t{\n-\t  return (make_xml_tag(            \"Size_Policy\", \"value\", \"hash_exponential_size_policy\"));\n+\t  return (make_xml_tag(\"Size_Policy\", \"value\", \"hash_exponential_size_policy\"));\n \t}\n       };\n \n@@ -89,14 +86,12 @@ namespace __gnu_pbds\n       {\n \tstatic std::string\n         name()\n-\t{\n-\t  return (\"prime_\");\n-\t}\n+\t{ return (\"prime_\"); }\n \n \tstatic std::string\n         desc()\n \t{\n-\t  return (make_xml_tag(            \"Size_Policy\", \"value\", \"hash_prime_size_policy\"));\n+\t  return (make_xml_tag(\"Size_Policy\", \"value\", \"hash_prime_size_policy\"));\n \t}\n       };\n "}, {"sha": "218362eed4110c3d1cb1bba3770b5a5ed5fcabec", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/detail/store_hash_string_form.hpp", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fstore_hash_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fstore_hash_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Fstore_hash_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -65,38 +65,27 @@ namespace __gnu_pbds\n       {\n \tstatic std::string\n         name()\n-\t{\n-\t  return (\"sth_\");\n-\t}\n+\t{ return (\"sth_\"); }\n \n \tstatic std::string\n         desc()\n-\t{\n-\t  return (make_xml_tag(            \"Store_Hash\", \"value\", \"true\"));\n-\t}\n+\t{ return (make_xml_tag(\"Store_Hash\", \"value\", \"true\")); }\n       };\n \n       template<>\n-      struct store_hash_string_form<\n-        false>\n+      struct store_hash_string_form<false>\n       {\n \tstatic std::string\n \tname()\n-        {\n-\t  return (\"nsth_\");\n-\t}\n+        { return (\"nsth_\"); }\n \n \tstatic std::string\n         desc()\n-        {\n-\t  return (make_xml_tag(                \"Store_Hash\",  \"value\",  \"false\"));\n-        }\n+        { return (make_xml_tag(\"Store_Hash\",  \"value\",  \"false\")); }\n       };\n \n     } // namespace detail\n-\n   } // namespace test\n-\n } // namespace __gnu_pbds\n \n #endif // #ifndef PB_DS_STORE_HASH_STRING_FORM_HPP"}, {"sha": "abb4f4105e76b6284b184bfc921ed21be8041005", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/detail/trigger_policy_string_form.hpp", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Ftrigger_policy_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Ftrigger_policy_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fdetail%2Ftrigger_policy_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -94,15 +94,14 @@ namespace __gnu_pbds\n         desc()\n \t{\n \t  const std::string ext_access_desc =\n-            make_xml_tag(\n-\t\t\t \"External_Access\",\n+            make_xml_tag(\"External_Access\",\n \t\t\t \"value\",(External_Access? \"true\" : \"false\"));\n \n \t  const std::string loads_desc =\n-            make_xml_tag(                \"alpha_min\",  \"nom\", Min_Load_Nom,  \"denom\", Min_Load_Denom) +\n-            make_xml_tag(                \"alpha_max\",  \"nom\", Max_Load_Nom,  \"denom\", Max_Load_Denom);\n+            make_xml_tag(\"alpha_min\", \"nom\", Min_Load_Nom, \"denom\", Min_Load_Denom) +\n+            make_xml_tag(\"alpha_max\", \"nom\", Max_Load_Nom, \"denom\", Max_Load_Denom);\n \n-\t  return (make_xml_tag(            \"Trigger_Policy\", \"value\", \"hash_load_check_resize_trigger\", ext_access_desc + loads_desc));\n+\t  return (make_xml_tag(\"Trigger_Policy\", \"value\", \"hash_load_check_resize_trigger\", ext_access_desc + loads_desc));\n \t}\n       };\n \n@@ -132,14 +131,13 @@ namespace __gnu_pbds\n         desc()\n \t{\n \t  const std::string ext_access_desc =\n-            make_xml_tag(\n-\t\t\t \"External_Access\",\n+            make_xml_tag(\"External_Access\",\n \t\t\t \"value\",(External_Access? \"true\" : \"false\"));\n \n \t  const std::string load_desc =\n-            make_xml_tag(                \"alpha\",  \"nom\", Load_Nom,  \"denom\", Load_Denom);\n+            make_xml_tag(\"alpha\",  \"nom\", Load_Nom,  \"denom\", Load_Denom);\n \n-\t  return (make_xml_tag(            \"Trigger_Policy\", \"value\", \"cc_hash_max_collision_check_resize_trigger\", ext_access_desc + load_desc));\n+\t  return (make_xml_tag(\"Trigger_Policy\", \"value\", \"cc_hash_max_collision_check_resize_trigger\", ext_access_desc + load_desc));\n \t}\n       };\n "}, {"sha": "9b533a5903ccde0c00610bd5513ff2126f3f906e", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/native_set.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fnative_set.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fnative_set.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fnative_set.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,7 +48,7 @@\n #define PB_DS_NATIVE_SET_HPP\n \n #include <ext/pb_ds/detail/standard_policies.hpp>\n-#include <native_type/assoc/native_tree_tag.hpp>\n+#include <native_type/native_tree_tag.hpp>\n #include <io/xml.hpp>\n #include <string>\n "}, {"sha": "624faf38070bc64eaf19e9f2bd713019fc4f74ab", "filename": "libstdc++-v3/testsuite/util/common_type/assoc/string_form.hpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fstring_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fstring_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fassoc%2Fstring_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -51,11 +51,11 @@\n #include <sstream>\n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/tag_and_trait.hpp>\n-#include <native_type/assoc/native_hash_map.hpp>\n-#include <native_type/assoc/native_hash_set.hpp>\n-#include <native_type/assoc/native_multimap.hpp>\n-#include <native_type/assoc/native_hash_multimap.hpp>\n-#include <native_type/assoc/native_set.hpp>\n+#include <native_type/native_hash_map.hpp>\n+#include <native_type/native_hash_set.hpp>\n+#include <native_type/native_multimap.hpp>\n+#include <native_type/native_hash_multimap.hpp>\n+#include <native_type/native_set.hpp>\n #include <common_type/assoc/template_policy.hpp>\n #include <common_type/assoc/detail/ds_string_form.hpp>\n #include <regression/basic_type.hpp>"}, {"sha": "4c3217d2b1672ad6a6fe4da63bd6ff4db7cc4328", "filename": "libstdc++-v3/testsuite/util/common_type/priority_queue/common_type.hpp", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fcommon_type.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fcommon_type.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fcommon_type.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -44,8 +44,8 @@\n  * Contains common types.\n  */\n \n-#ifndef PB_DS_COMMON_TYPES_HPP\n-#define PB_DS_COMMON_TYPES_HPP\n+#ifndef PB_DS_COMMON_TYPES_PQ_HPP\n+#define PB_DS_COMMON_TYPES_PQ_HPP\n \n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/priority_queue.hpp>\n@@ -60,8 +60,6 @@ namespace __gnu_pbds\n     struct pq_common_types\n     {\n     private:\n-      //    typedef typename Allocator::size_type size_type;\n-\n       typedef __gnu_pbds::priority_queue<Value_Type, Cmp_Fn, __gnu_pbds::pairing_heap_tag, Allocator> pairing_heap_t;\n \n       typedef __gnu_pbds::priority_queue<Value_Type, Cmp_Fn, __gnu_pbds::binomial_heap_tag, Allocator> binomial_heap_t;\n@@ -84,4 +82,4 @@ namespace __gnu_pbds\n   } // namespace test\n } // namespace __gnu_pbds\n \n-#endif // #ifndef PB_DS_COMMON_TYPES_HPP\n+#endif // #ifndef PB_DS_COMMON_TYPES_PQ_HPP"}, {"sha": "d4846ba3a2e45165436fe5b9fa92b7d8a4229e50", "filename": "libstdc++-v3/testsuite/util/common_type/priority_queue/detail/ds_string_form.hpp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fdetail%2Fds_string_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fdetail%2Fds_string_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fdetail%2Fds_string_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -120,6 +120,18 @@ namespace __gnu_pbds\n \t{ return make_xml_tag(\"type\", \"value\", \"binary_heap\"); }\n       };\n \n+      template<typename Cntnr>\n+      struct ds_string_form<Cntnr, __gnu_pbds::sequence_tag>\n+      {\n+\tstatic std::string\n+        name()\n+\t{ return \"sequence\"; }\n+\n+\tstatic std::string\n+        desc()\n+\t{ return make_xml_tag(\"type\", \"value\", \"sequence\"); }\n+      };\n+\n     } // namespace detail\n   } // namespace test\n } // namespace __gnu_pbds"}, {"sha": "aca597f4c5e9e892ce85b756722485578d49dfe5", "filename": "libstdc++-v3/testsuite/util/common_type/priority_queue/string_form.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fstring_form.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fstring_form.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fcommon_type%2Fpriority_queue%2Fstring_form.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <string>\n #include <sstream>\n #include <ext/pb_ds/detail/type_utils.hpp>\n-#include <native_type/priority_queue/native_priority_queue.hpp>\n+#include <native_type/native_priority_queue.hpp>\n #include <common_type/priority_queue/detail/ds_string_form.hpp>\n #include <io/xml.hpp>\n "}, {"sha": "572d8a7f1526fa7bea6eca27cda38c7b5f55149b", "filename": "libstdc++-v3/testsuite/util/io/prog_bar.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fio%2Fprog_bar.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fio%2Fprog_bar.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fio%2Fprog_bar.cc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -48,10 +48,8 @@\n \n namespace __gnu_pbds\n {\n-\n   namespace test\n   {\n-\n     prog_bar::\n     prog_bar(size_t max, std::ostream& r_os, bool display/*= true*/) :\n       m_cur(0),\n@@ -78,11 +76,10 @@ namespace __gnu_pbds\n       if (m_display == false)\n         return;\n \n-      while (m_cur*  num_disp >= m_max*  m_cur_disp&&  m_cur_disp < num_disp)\n+      while (m_cur * num_disp >= m_max * m_cur_disp && m_cur_disp < num_disp)\n \t{\n \t  m_r_os << '*';\n \t  m_r_os.flush();\n-\n \t  ++m_cur_disp;\n \t}\n     }"}, {"sha": "dacf3f718912ef1db04faa753026d7f18590d24a", "filename": "libstdc++-v3/testsuite/util/native_type/native_hash_map.hpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_map.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_map.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_map.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <string>\n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/detail/standard_policies.hpp>\n-#include <native_type/assoc/native_hash_tag.hpp>\n+#include <native_type/native_hash_tag.hpp>\n #include <io/xml.hpp>\n #include <tr1/unordered_map>\n ", "previous_filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_hash_map.hpp"}, {"sha": "0226f8359ffed30c5f1c93924ca16df845051179", "filename": "libstdc++-v3/testsuite/util/native_type/native_hash_multimap.hpp", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_multimap.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_multimap.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_multimap.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -51,7 +51,7 @@\n #include <tr1/unordered_map>\n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/detail/standard_policies.hpp>\n-#include <native_type/assoc/native_hash_tag.hpp>\n+#include <native_type/native_hash_tag.hpp>\n #include <io/xml.hpp>\n \n namespace __gnu_pbds\n@@ -76,12 +76,12 @@ namespace __gnu_pbds\n \n     public:\n       typedef native_hash_tag \t\t\tcontainer_category;\n-      typedef Allocator \t\t\tallocator_type;\n+      typedef Allocator \t\t\tallocator;\n       typedef typename base_type::iterator \titerator;\n       typedef typename base_type::const_iterator const_iterator;\n \n       typedef\n-      typename allocator_type::template rebind<pair_type>::other::const_reference\n+      typename allocator::template rebind<pair_type>::other::const_reference\n       const_reference;\n \n       native_hash_multimap() : base_type(Init_Size)", "previous_filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_hash_multimap.hpp"}, {"sha": "032fe1ff386f94a04ac74bec2746bb7517656e63", "filename": "libstdc++-v3/testsuite/util/native_type/native_hash_set.hpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_set.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_set.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_set.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <string>\n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/detail/standard_policies.hpp>\n-#include <native_type/assoc/native_hash_tag.hpp>\n+#include <native_type/native_hash_tag.hpp>\n #include <io/xml.hpp>\n #include <tr1/unordered_set>\n ", "previous_filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_hash_set.hpp"}, {"sha": "ad8fec10f2c1b0adc127638ad9db98e6618c7c6f", "filename": "libstdc++-v3/testsuite/util/native_type/native_hash_tag.hpp", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_tag.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_tag.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_hash_tag.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "previous_filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_hash_tag.hpp"}, {"sha": "d2ae83314a71ae719a748a021bac12236b6c5cd6", "filename": "libstdc++-v3/testsuite/util/native_type/native_map.hpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_map.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_map.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_map.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -51,7 +51,7 @@\n #include <string>\n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/detail/standard_policies.hpp>\n-#include <native_type/assoc/native_tree_tag.hpp>\n+#include <native_type/native_tree_tag.hpp>\n #include <io/xml.hpp>\n \n namespace __gnu_pbds", "previous_filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_map.hpp"}, {"sha": "c06a2adfc428ceffe27c5a66c287560a4bbfb5e8", "filename": "libstdc++-v3/testsuite/util/native_type/native_multimap.hpp", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_multimap.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_multimap.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_multimap.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <map>\n #include <string>\n #include <ext/pb_ds/detail/type_utils.hpp>\n-#include <native_type/assoc/native_tree_tag.hpp>\n+#include <native_type/native_tree_tag.hpp>\n \n namespace __gnu_pbds\n {\n@@ -70,7 +70,7 @@ namespace __gnu_pbds\n     public:\n       typedef native_tree_tag container_category;\n \n-      typedef Allocator allocator_type;\n+      typedef Allocator allocator;\n \n       typedef\n       typename Allocator::template rebind<", "previous_filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_multimap.hpp"}, {"sha": "81525c0bfc99fdb448253ee080ea807884305011", "filename": "libstdc++-v3/testsuite/util/native_type/native_priority_queue.hpp", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_priority_queue.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_priority_queue.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_priority_queue.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "previous_filename": "libstdc++-v3/testsuite/util/native_type/priority_queue/native_priority_queue.hpp"}, {"sha": "c7e8cfebeb30a041f1cee9d2fa1a24e8eff466f5", "filename": "libstdc++-v3/testsuite/util/native_type/native_set.hpp", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_set.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_set.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_set.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -50,7 +50,7 @@\n #include <string>\n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/detail/standard_policies.hpp>\n-#include <native_type/assoc/native_tree_tag.hpp>\n+#include <native_type/native_tree_tag.hpp>\n #include <io/xml.hpp>\n \n namespace __gnu_pbds", "previous_filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_set.hpp"}, {"sha": "de2a019b273a9e623580a34d3742bc0deccbc9b4", "filename": "libstdc++-v3/testsuite/util/native_type/native_tree_tag.hpp", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_tree_tag.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_tree_tag.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fnative_tree_tag.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "previous_filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_tree_tag.hpp"}, {"sha": "61b094a69512dddcc421f841da57dc14864bb703", "filename": "libstdc++-v3/testsuite/util/regression/basic_type.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fbasic_type.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fbasic_type.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fbasic_type.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file basic_type.hpp\n- * Containsert a type used for regression tests' key and data.\n+ * Contains a type used for regression tests' key and data.\n  */\n \n #ifndef PB_DS_BASIC_TYPE_HPP"}, {"sha": "1bfaa30a690aef0776a5dcf0cbf5860b0f7bf407", "filename": "libstdc++-v3/testsuite/util/regression/common_type.hpp", "status": "renamed", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fcommon_type.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fcommon_type.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fcommon_type.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -47,8 +47,10 @@\n #ifndef PB_DS_RAND_REGRESSION_TEST_COMMON_TYPE_HPP\n #define PB_DS_RAND_REGRESSION_TEST_COMMON_TYPE_HPP\n \n+#include <vector>\n #include <regression/basic_type.hpp>\n #include <common_type/assoc/common_type.hpp>\n+#include <common_type/priority_queue/common_type.hpp>\n \n namespace __gnu_pbds\n {\n@@ -119,7 +121,64 @@ namespace test\n \n   typedef tl_t min_tl_t;\n   };\n+ \n+  // Sequence types.\n+  typedef pq_common_types<basic_type, std::less<basic_type>, alloc_type> pq_types;\n+ \n+  typedef pq_types::regression_tl pq_tl_t;\n+  typedef pq_tl_t min_pq_tl_t;\n+\n+  template<typename _Tp, typename _Alloc>\n+  struct vector_adaptor : public std::vector<_Tp, _Alloc>\n+  {\n+  private:\n+    typedef std::vector<_Tp, _Alloc> base_type;\n+\n+  public:\n+    typedef typename base_type::value_type\t\tvalue_type;\n+    typedef typename base_type::pointer \t\tpointer; \n+    typedef typename base_type::const_pointer \t\tconst_pointer; \n+    typedef typename base_type::reference \t\treference; \n+    typedef typename base_type::const_reference \tconst_reference; \n+    typedef typename base_type::iterator \t\titerator; \n+    typedef typename base_type::const_iterator \t\tconst_iterator; \n+    typedef typename base_type::reverse_iterator\treverse_iterator; \n+    typedef typename base_type::const_reverse_iterator \tconst_reverse_iterator; \n+    typedef typename base_type::size_type \t\tsize_type;\n+    typedef typename base_type::difference_type \tdifference_type;\n+    typedef typename base_type::allocator_type \t\tallocator_type;\n+\n+    typedef __gnu_pbds::sequence_tag \t\t\tcontainer_category;\n+    typedef std::less<_Tp> \t\t   \t\tcmp_fn;\n+\n+    const cmp_fn& \n+    get_cmp_fn() const\n+    { return _M_cmp; }\n+\n+    vector_adaptor() { }\n+    vector_adaptor(iterator) { }\n+    vector_adaptor(iterator, iterator) { }\n+    vector_adaptor(iterator, iterator, const cmp_fn&) { }\n+    vector_adaptor(const cmp_fn& other) { }\n+\n+    using base_type::push_back;\n+    using base_type::pop_back;\n+\n+    // erase_if\n+\n+    cmp_fn _M_cmp;\n+\n+  };\n+ \n+  namespace detail\n+  {\n+\n+  };\n+\n+  typedef vector_adaptor<basic_type, alloc_type>\tvector_type;\n+  typedef __gnu_cxx::typelist::create1<vector_type>::type vector_tl_t;\n \n+  // Associative types.\n   typedef tree_types<null_mapped_type>::tl_t \t\ttree_set_tl_t;\n   typedef tree_types<null_mapped_type>::min_tl_t\tmin_tree_set_tl_t;\n   typedef tree_types<basic_type>::tl_t \t\t\ttree_map_tl_t;", "previous_filename": "libstdc++-v3/testsuite/util/regression/assoc/common_type.hpp"}, {"sha": "7740a913852bdd5dca452f5c0b01f20e215dc2c5", "filename": "libstdc++-v3/testsuite/util/regression/priority_queue/common_type.hpp", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fpriority_queue%2Fcommon_type.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fpriority_queue%2Fcommon_type.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Fpriority_queue%2Fcommon_type.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,65 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file common_type.hpp\n- * Contains types used for regression tests.\n- */\n-\n-#ifndef PB_DS_RAND_REGRESSION_TEST_COMMON_TYPE_HPP\n-#define PB_DS_RAND_REGRESSION_TEST_COMMON_TYPE_HPP\n-\n-#include <regression/basic_type.hpp>\n-#include <common_type/priority_queue/common_type.hpp>\n-\n-namespace __gnu_pbds\n-{\n-namespace test\n-{\n-  typedef __gnu_cxx::throw_allocator<basic_type> alloc_type;\n-\n-  typedef pq_common_types<basic_type, std::less<basic_type>, alloc_type>::regression_tl pq_tl_t;\n-\n-  typedef pq_tl_t min_pq_tl_t;\n-} // namespace test\n-} // namespace __gnu_pbds\n-\n-#endif"}, {"sha": "c9f6186ce4617f5b23a95540b3e4fe26da8d70e4", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/container_rand_regression_test.h", "status": "renamed", "additions": 56, "deletions": 71, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.h?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -40,78 +40,30 @@\n // warranty.\n \n /**\n- * @file container_rand_regression_test.hpp\n+ * @file container_rand_regression_test.h\n  * Contains a random regression test for a specific container type.\n  */\n \n-#ifndef PB_DS_CONTAINER_RAND_REGRESSION_TEST_HPP\n-#define PB_DS_CONTAINER_RAND_REGRESSION_TEST_HPP\n+#ifndef PB_DS_CONTAINER_RAND_REGRESSION_TEST_H\n+#define PB_DS_CONTAINER_RAND_REGRESSION_TEST_H\n \n #include <algorithm>\n #include <string>\n #include <sstream>\n #include <utility>\n #include <ext/pb_ds/assoc_container.hpp>\n #include <io/prog_bar.hpp>\n-#include <rng/twister_rand_gen.hpp>\n+#include <testsuite_rng.h>\n #include <regression/trait/assoc/trait.hpp>\n #include <common_type/assoc/string_form.hpp>\n-#include <regression/rand/io/assoc/xml_formatter.hpp>\n+#include <regression/rand/xml_formatter.hpp>\n \n namespace __gnu_pbds\n {\n namespace test\n {\n namespace detail\n {\n-\n-#ifdef PB_DS_REGRESSION_TRACE\n-#define PB_DS_TRACE(X) std::cerr << X << std::endl\n-#else \n-#define PB_DS_TRACE(X)\n-#endif\n-\n-#define PB_DS_CLASS_T_DEC \\\n-  template<typename Cntnr>\n-\n-#define PB_DS_CLASS_C_DEC \\\n-  container_rand_regression_test<Cntnr>\n-\n-#define PB_DS_COND_COMPARE(L, R) \\\n-  if (m_g.get_prob() < m_mp)\t\t\t\\\n-    cmp(L, R, __FUNCTION__);\n-\n-#define PB_DS_RUN_MTHD(MTHD) \\\n-  {\t\t\t\t\t\t\\\n-    bool done = false;\t\t\t\t\\\n-\t\t\t\t\t\t\\\n-    while (!done)\t\t\t\t\\\n-      done = MTHD();\t\t\t\t\\\n-  }\n-\n-#define PB_DS_THROW_IF_FAILED_(PRED, MORE, P_C, P_NC, F, L) \\\n-  if (!(PRED))\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      std::cerr << \"Failure at \" << F << \": \" << L << std::endl;\t\\\n-      std::cerr << MORE << std::endl;\t\t\t\t\t\\\n-      std::cerr << \"container:\" << std::endl;\t\t\t\t\\\n-      print_container(*(P_C));\t\t\t\t\t\t\\\n-      std::cerr << std::endl;\t\t\t\t\t\t\\\n-      std::cerr << \"native container:\" << std::endl;\t\t\t\\\n-      print_container(*(P_NC));\t\t\t\t\t\t\\\n-      std::cerr << std::endl;\t\t\t\t\t\t\\\n-      throw std::logic_error(\"fucked!\");\t\t\t\t\\\n-    }\n-\n-#define PB_DS_THROW_IF_FAILED(PRED, MORE, P_C, P_NC)\t\t\t\\\n-  PB_DS_THROW_IF_FAILED_(PRED, MORE, P_C, P_NC, __FILE__, __LINE__)\n-\n-#define PB_DS_SET_DESTRUCT_PRINT \\\n-  destructor_printer dest_print___(__FUNCTION__);\n-\n-#define PB_DS_CANCEL_DESTRUCT_PRINT \\\n-  dest_print___.cancel_print();\n-\n   // Rand test specialized for a specific container.\n   template<typename Cntnr>\n   class container_rand_regression_test\n@@ -129,15 +81,15 @@ namespace detail\n \n   private:\n     typedef Cntnr \t\t\t\t\tcntnr;\n-    typedef typename cntnr::allocator_type \t\t\tallocator_type;\n+    typedef typename cntnr::allocator_type \t\tallocator_type;\n     typedef typename cntnr::size_type \t\t\tsize_type;\n     typedef regression_test_traits<Cntnr> \t\ttest_traits;\n     typedef typename test_traits::key_type \t\tkey_type;\n     typedef typename test_traits::const_key_reference\tconst_key_reference;\n     typedef typename test_traits::value_type \t\tvalue_type;\n     typedef typename test_traits::native_type \t\tnative_type;\n     typedef twister_rand_gen \t\t\t\tgen;\n-    typedef __gnu_pbds::container_traits<Cntnr> \t\tcontainer_traits;\n+    typedef __gnu_pbds::container_traits<Cntnr> \tcontainer_traits;\n     typedef __gnu_cxx::throw_allocator<char> \t\talloc_t;\n \n     enum op\n@@ -467,21 +419,54 @@ namespace detail\n     size_t \t\t\tm_i;\n   };\n \n-#include <regression/rand/assoc/detail/constructor_destructor_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/cmp_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/operator_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/insert_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/subscript_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/clear_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/erase_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/defs_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/policy_access_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/split_join_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/it_conversion_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/resize_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/get_set_load_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/get_set_loads_fn_imps.hpp>\n-#include <regression/rand/assoc/detail/diagnostic_fn_imps.hpp>\n+#ifdef PB_DS_REGRESSION_TRACE\n+#define PB_DS_TRACE(X) std::cerr << X << std::endl\n+#else \n+#define PB_DS_TRACE(X)\n+#endif\n+\n+#define PB_DS_CLASS_T_DEC \\\n+  template<typename Cntnr>\n+\n+#define PB_DS_CLASS_C_DEC \\\n+  container_rand_regression_test<Cntnr>\n+\n+#define PB_DS_COND_COMPARE(L, R) \\\n+  if (m_g.get_prob() < m_mp)\t\t\t\\\n+    cmp(L, R, __FUNCTION__);\n+\n+#define PB_DS_RUN_MTHD(MTHD) \\\n+  {\t\t\t\t\t\t\\\n+    bool done = false;\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+    while (!done)\t\t\t\t\\\n+      done = MTHD();\t\t\t\t\\\n+  }\n+\n+#define PB_DS_THROW_IF_FAILED_(PRED, MORE, P_C, P_NC, F, L) \\\n+  if (!(PRED))\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      std::cerr << \"Failure at \" << F << \": \" << L << std::endl;\t\\\n+      std::cerr << MORE << std::endl;\t\t\t\t\t\\\n+      std::cerr << \"container:\" << std::endl;\t\t\t\t\\\n+      print_container(*(P_C));\t\t\t\t\t\t\\\n+      std::cerr << std::endl;\t\t\t\t\t\t\\\n+      std::cerr << \"native container:\" << std::endl;\t\t\t\\\n+      print_container(*(P_NC));\t\t\t\t\t\t\\\n+      std::cerr << std::endl;\t\t\t\t\t\t\\\n+      throw std::logic_error(\"fucked!\");\t\t\t\t\\\n+    }\n+\n+#define PB_DS_THROW_IF_FAILED(PRED, MORE, P_C, P_NC)\t\t\t\\\n+  PB_DS_THROW_IF_FAILED_(PRED, MORE, P_C, P_NC, __FILE__, __LINE__)\n+\n+#define PB_DS_SET_DESTRUCT_PRINT \\\n+  destructor_printer dest_print___(__FUNCTION__);\n+\n+#define PB_DS_CANCEL_DESTRUCT_PRINT \\\n+  dest_print___.cancel_print();\n+\n+#include <regression/rand/assoc/container_rand_regression_test.tcc>\n \n #undef PB_DS_COND_COMPARE\n #undef PB_DS_RUN_MTHD", "previous_filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/container_rand_regression_test.hpp"}, {"sha": "6d676a9f3fe7ca346b1c8e4b1dc15ae7d4fdde73", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/container_rand_regression_test.tcc", "status": "added", "additions": 2143, "deletions": 0, "changes": 2143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -0,0 +1,2143 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n+\n+// Permission to use, copy, modify, sell, and distribute this software\n+// is hereby granted without fee, provided that the above copyright\n+// notice appears in all copies, and that both that copyright notice\n+// and this permission notice appear in supporting documentation. None\n+// of the above authors, nor IBM Haifa Research Laboratories, make any\n+// representation about the suitability of this software for any\n+// purpose. It is provided \"as is\" without express or implied\n+// warranty.\n+\n+/**\n+ * @file container_rand_regression_test.tcc\n+ * Contains a random regression test for a specific container type.\n+ */\n+\n+#ifndef PB_DS_CONTAINER_RAND_REGRESSION_TEST_TCC\n+#define PB_DS_CONTAINER_RAND_REGRESSION_TEST_TCC\n+\n+// Constructors/Destructors.\n+PB_DS_CLASS_T_DEC\n+PB_DS_CLASS_C_DEC::\n+container_rand_regression_test(unsigned long seed, size_t n, size_t m, \n+\t\t\t       double tp, double ip, double ep, double cp, \n+\t\t\t       double mp, bool disp) \n+: m_seed((seed == 0) ? twister_rand_gen::get_time_determined_seed() : seed),\n+  m_n(n), m_m(m), m_tp(tp), m_ip(ip), m_ep(ep), m_cp(cp), m_mp(mp),\n+  m_disp(disp), m_p_c(NULL)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+PB_DS_CLASS_C_DEC::\n+~container_rand_regression_test()\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+default_constructor()\n+{\n+  PB_DS_TRACE(\"default_constructor\");\n+  bool done = true;\n+  m_alloc.set_throw_prob(m_tp);\n+\n+  try\n+    {\n+      m_p_c = new Cntnr;\n+    }\n+  catch(__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+    }\n+\n+  if (m_p_c != NULL)\n+    PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+swap()\n+{\n+  PB_DS_TRACE(\"swap\");\n+  m_alloc.set_throw_prob(0);\n+  Cntnr* p_c = new Cntnr;\n+  m_alloc.set_throw_prob(1);\n+  p_c->swap(*m_p_c);\n+  std::swap(p_c, m_p_c);\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+copy_constructor()\n+{\n+  PB_DS_TRACE(\"copy_constructor\");\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      p_c = new Cntnr(*m_p_c);\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+assignment_operator()\n+{\n+  PB_DS_TRACE(\"assignment operator\");\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      p_c = new Cntnr();\n+      * p_c =* m_p_c;\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+it_constructor()\n+{\n+  PB_DS_TRACE(\"it_constructor\");\n+  return it_constructor_imp(typename Cntnr::container_category());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+it_constructor_imp(__gnu_pbds::cc_hash_tag)\n+{\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      switch(get_next_sub_op(8))\n+        {\n+        case 0:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 1:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 2:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n+\t\t\t  m_p_c->get_comb_hash_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 3:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n+\t\t\t  m_p_c->get_comb_hash_fn(),\n+\t\t\t  m_p_c->get_resize_policy());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 4:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end());\n+\t  break;\n+        case 5:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn());\n+\t  break;\n+        case 6:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n+\t\t\t  m_p_c->get_eq_fn());\n+\t  break;\n+        case 7:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n+\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_hash_fn());\n+\t  break;\n+        case 8:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n+\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_hash_fn(),\n+\t\t\t  m_p_c->get_resize_policy());\n+\t  break;\n+        default:\n+\t  PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+        };\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch (__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+it_constructor_imp(__gnu_pbds::gp_hash_tag)\n+{\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      switch(get_next_sub_op(11))\n+        {\n+        case 0:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 1:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 2:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n+\t\t\t  m_p_c->get_comb_probe_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 3:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n+\t\t\t  m_p_c->get_comb_probe_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 4:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n+\t\t\t  m_p_c->get_comb_probe_fn(), m_p_c->get_probe_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 5:\n+\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n+\t\t\t  m_p_c->get_comb_probe_fn(), m_p_c->get_probe_fn(),\n+\t\t\t  m_p_c->get_resize_policy());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 6:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn());\n+\t  break;\n+        case 7:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n+\t\t\t  m_p_c->get_eq_fn());\n+\t  break;\n+        case 8:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n+\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_probe_fn());\n+\t  break;\n+        case 9:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n+\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_probe_fn());\n+\t  break;\n+        case 10:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n+\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_probe_fn(),\n+\t\t\t  m_p_c->get_probe_fn());\n+\t  break;\n+        case 11:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n+\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_probe_fn(),\n+\t\t\t  m_p_c->get_probe_fn(), m_p_c->get_resize_policy());\n+\t  break;\n+        default:\n+\t  PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+        };\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch (__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+it_constructor_imp(__gnu_pbds::tree_tag)\n+{\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      switch(get_next_sub_op(2))\n+        {\n+        case 0:\n+\t  p_c = new Cntnr(m_p_c->get_cmp_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 1:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_cmp_fn());\n+\t  break;\n+        default:\n+\t  PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+        };\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch (__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+it_constructor_imp(__gnu_pbds::list_update_tag)\n+{\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      p_c = new Cntnr(m_p_c->begin(), m_p_c->end());\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch (__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+it_constructor_imp(__gnu_pbds::pat_trie_tag)\n+{\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      switch(get_next_sub_op(2))\n+        {\n+        case 0:\n+\t  p_c = new Cntnr(m_p_c->get_e_access_traits());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 1:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), \n+\t\t\t  m_p_c->get_e_access_traits());\n+\t  break;\n+        default:\n+\t  PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+        };\n+\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch (__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+// Cmp.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+cmp(const Cntnr& r_c, const native_type& r_native_c, \n+    const std::string& r_call_fn)\n+{\n+  m_alloc.set_throw_prob(1);\n+  const size_t size = r_c.size();\n+  const size_t native_size = r_native_c.size();\n+  PB_DS_THROW_IF_FAILED(size == native_size,\n+\t\t\tsize << \" \" << native_size, &r_c, &r_native_c);\n+\n+  const bool empty = r_c.empty();\n+  const bool native_empty = r_native_c.empty();\n+  PB_DS_THROW_IF_FAILED(empty == native_empty,\n+\t\t\tempty << \" \" << native_empty, &r_c, &r_native_c);\n+\n+  try\n+    {\n+      basic_cmp_(r_c, r_native_c);\n+      cmp_(r_c, r_native_c);\n+    }\n+  catch(...)\n+    {\n+      PB_DS_THROW_IF_FAILED(false, \"call-fn: \" + r_call_fn, &r_c, &r_native_c);\n+    }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+basic_cmp_(const Cntnr& r_c, const native_type& r_native_c)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+  if (static_cast<size_t>(std::distance(r_c.begin(), r_c.end())) != r_c.size())\n+    PB_DS_THROW_IF_FAILED(false,\n+\t\t\t  static_cast<unsigned long>(std::distance(r_c.begin(), r_c.end())) << \" \" << static_cast<unsigned long>(r_c.size()), &r_c, &r_native_c);\n+  \n+  typename native_type::const_iterator it = r_native_c.begin();\n+  while (it != r_native_c.end())\n+    {\n+      typename native_type::key_type native_key = test_traits::extract_native_key(*it);\n+\n+      m_alloc.set_throw_prob(0);\n+      const key_type k = native_key;\n+      m_alloc.set_throw_prob(1);\n+      typename cntnr::const_point_iterator found_it = r_c.find(k);\n+      PB_DS_THROW_IF_FAILED(found_it != r_c.end(),\n+\t\t\t    test_traits::native_val_to_string(*it),\n+\t\t\t    &r_c, &r_native_c);\n+\n+      if (!test_traits::cmp(*found_it, * it))\n+\tPB_DS_THROW_IF_FAILED(false, \"\", &r_c, &r_native_c);\n+\n+      ++it;\n+    }\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+cmp_(const Cntnr& r_c, const native_type& r_native_c)\n+{\n+  enum\n+    {\n+      order_preserving = container_traits::order_preserving,\n+      back_order_preserving = container_traits::order_preserving \n+      && \n+      !__gnu_pbds::detail::is_same<\n+      typename std::iterator_traits<\n+      typename cntnr::const_iterator>::iterator_category,\n+      std::forward_iterator_tag>::value,\n+      reverse_iteration = container_traits::reverse_iteration,\n+      order_statistics = test_traits::order_statistics,\n+      prefix_search = test_traits::prefix_search,\n+      has_mapped = !__gnu_pbds::detail::is_same<\n+      typename Cntnr::mapped_type,\n+      __gnu_pbds::null_mapped_type>::value\n+    };\n+\n+  order_preserving_cmp_imp(r_c, r_native_c,\n+\t\t\t   __gnu_pbds::detail::integral_constant<int,order_preserving>());\n+\n+  back_order_preserving_cmp_imp(r_c, r_native_c,\n+\t\t\t\t__gnu_pbds::detail::integral_constant<int,back_order_preserving>());\n+\n+  order_statistics_cmp_imp(r_c, r_native_c,\n+\t\t\t   __gnu_pbds::detail::integral_constant<int,order_statistics>());\n+\n+  prefix_search_cmp_imp(r_c, r_native_c,\n+\t\t\t__gnu_pbds::detail::integral_constant<int,prefix_search>());\n+\n+  reverse_iteration_cmp_imp(r_c, r_native_c,\n+\t\t\t    __gnu_pbds::detail::integral_constant<int,reverse_iteration>());\n+\n+  lower_bound_cmp_imp(r_c, r_native_c,\n+\t\t      __gnu_pbds::detail::integral_constant<int,order_preserving>());\n+\n+  upper_bound_cmp_imp(r_c, r_native_c,\n+\t\t      __gnu_pbds::detail::integral_constant<int,order_preserving>());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+order_preserving_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+order_preserving_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+    typename cntnr::const_iterator b = r_c.begin();\n+  typename cntnr::const_iterator e = r_c.end();\n+\n+  typename native_type::const_iterator native_b = r_native_c.begin();\n+  typename native_type::const_iterator native_e = r_native_c.end();\n+\n+  try\n+    {\n+      it_cmp_imp(b, e, native_b, native_e);\n+    }\n+  catch(...)\n+    {\n+      PB_DS_THROW_IF_FAILED(false, \"\", &r_c, &r_native_c)\n+    }\n+\n+  try\n+    {\n+      back_it_cmp_imp(b, e, native_b, native_e);\n+    }\n+  catch(...)\n+    {\n+      PB_DS_THROW_IF_FAILED(false, \"\", &r_c, &r_native_c)\n+    }\n+\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+back_order_preserving_cmp_imp(const Cntnr&, const native_type&, \n+\t\t\t\t    __gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+back_order_preserving_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, \n+\t\t\t      __gnu_pbds::detail::true_type)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+  typename cntnr::const_iterator b = r_c.begin();\n+  typename cntnr::const_iterator e = r_c.end();\n+  typename native_type::const_iterator native_b = r_native_c.begin();\n+  typename native_type::const_iterator native_e = r_native_c.end();\n+  it_cmp_imp(b, e, native_b, native_e);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+reverse_iteration_cmp_imp(const Cntnr&, const native_type&, \n+\t\t\t  __gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+reverse_iteration_cmp_imp(const Cntnr& r_c, const native_type&r_native_c, __gnu_pbds::detail::true_type)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+    typename cntnr::const_reverse_iterator b = r_c.rbegin();\n+  typename cntnr::const_reverse_iterator e = r_c.rend();\n+\n+  typename native_type::const_reverse_iterator native_b = r_native_c.rbegin();\n+  typename native_type::const_reverse_iterator native_e = r_native_c.rend();\n+\n+  try\n+    {\n+      it_cmp_imp(b, e, native_b, native_e);\n+    }\n+  catch(...)\n+    {\n+      PB_DS_THROW_IF_FAILED(false, \"\", &r_c, &r_native_c)\n+    }\n+\n+  try\n+    {\n+      back_it_cmp_imp(b, e, native_b, native_e);\n+    }\n+  catch(...)\n+    {\n+      PB_DS_THROW_IF_FAILED(false, \"\", &r_c, &r_native_c)\n+    }\n+\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+order_statistics_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+order_statistics_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n+{\n+  {\n+    m_alloc.set_throw_prob(0);\n+    const key_type k = test_traits::generate_key(m_g, m_m);\n+    m_alloc.set_throw_prob(1);\n+    const size_type order = r_c.order_of_key(k);\n+    const size_type native_order = std::distance(r_native_c.begin(),\n+\t\t\t\t\t\t r_native_c.lower_bound(test_traits::native_key(k)));\n+\n+    PB_DS_THROW_IF_FAILED(order == native_order,\n+\t\t\t  test_traits::key_to_string(k) << \" \" <<\n+\t\t\t  static_cast<unsigned long>(order) << \" \" <<\n+\t\t\t  static_cast<unsigned long>(native_order),\n+\t\t\t  &r_c,\n+\t\t\t  &r_native_c);\n+  }\n+\n+  const size_type rand_ord =\n+    static_cast<size_t>(m_g.get_unsigned_long(0,\n+\t\t\t\t\t      2 * static_cast<unsigned long>(m_m)));\n+\n+  typename cntnr::const_iterator it = r_c.find_by_order(rand_ord);\n+  typename native_type::const_iterator native_it = r_native_c.begin();\n+  std::advance(native_it, std::min(rand_ord, r_native_c.size()));\n+  if (it == r_c.end()&&  native_it != r_native_c.end())\n+    PB_DS_THROW_IF_FAILED(false,\n+\t\t\t  static_cast<unsigned long>(rand_ord),\n+\t\t\t  m_p_c,\n+\t\t\t  &m_native_c);\n+\n+  if (it != r_c.end()&&  native_it == r_native_c.end())\n+    PB_DS_THROW_IF_FAILED(false,\n+\t\t\t  static_cast<unsigned long>(rand_ord),\n+\t\t\t  m_p_c,\n+\t\t\t  &m_native_c);\n+\n+  if (it != r_c.end()&&     native_it != r_native_c.end())\n+    PB_DS_THROW_IF_FAILED(test_traits::cmp(*it, * native_it),\n+\t\t\t  static_cast<unsigned long>(rand_ord),\n+\t\t\t  m_p_c,\n+\t\t\t  &m_native_c);\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+prefix_search_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+prefix_search_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+  m_alloc.set_throw_prob(0);\n+  const key_type k = test_traits::generate_key(m_g, m_m);\n+  m_alloc.set_throw_prob(1);\n+  try\n+    {\n+      typedef\n+\tstd::pair<typename Cntnr::const_iterator, typename Cntnr::const_iterator>\n+\tpref_ret_t;\n+\n+      const pref_ret_t pref_ret = r_c.prefix_range(k);\n+\n+      typename native_type::const_iterator native_start_it = r_native_c.begin();\n+\n+      while (native_start_it != r_native_c.end() && \n+\t     !test_traits::prefix_match(k,\n+\t\t\t\t\ttest_traits::extract_native_key(*native_start_it)))\n+\t++native_start_it;\n+\n+      typename native_type::const_iterator native_end_it =\n+\tnative_start_it;\n+\n+      do\n+        {\n+\t  if (native_end_it != r_native_c.end())\n+\t    ++native_end_it;\n+        }\n+      while (native_end_it != r_native_c.end() && \n+\t     test_traits::prefix_match(k,\n+\t\t\t\t       test_traits::extract_native_key(*native_end_it)));\n+\n+      it_cmp_imp(pref_ret.first, pref_ret.second, native_start_it, native_end_it);\n+    }\n+  catch(...)\n+    {\n+      PB_DS_THROW_IF_FAILED(false, \"prefix key \" << k, &r_c, &r_native_c);\n+    }\n+\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+PB_DS_CLASS_T_DEC\n+template<typename Const_It, class Const_Native_It>\n+void\n+PB_DS_CLASS_C_DEC::\n+it_cmp_imp(Const_It b, Const_It e, Const_Native_It native_b, \n+\t   Const_Native_It native_e)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+  if (std::distance(b, e) != std::distance(native_b, native_e))\n+    {\n+      const size_t dist = std::distance(b, e);\n+      const size_t native_dist = std::distance(native_b, native_e);\n+      PB_DS_THROW_IF_FAILED(false,\n+\t\t\t    static_cast<unsigned long>(dist) << \" \"\n+\t\t\t    << static_cast<unsigned long>(native_dist),\n+\t\t\t    m_p_c, &m_native_c);\n+    }\n+  \n+  while (b != e)\n+    {\n+      PB_DS_THROW_IF_FAILED(native_b != native_e, \"\", m_p_c, &m_native_c);\n+\n+      if (!test_traits::cmp(*b, * native_b))\n+\tPB_DS_THROW_IF_FAILED(false,\n+\t\t\t      test_traits::val_to_string(*b) << \" \" <<\n+\t\t\t      test_traits::val_to_string(*native_b),\n+\t\t\t      m_p_c, &m_native_c);\n+\n+      ++b;\n+      ++native_b;\n+    }\n+\n+  PB_DS_THROW_IF_FAILED(native_b == native_e, \"\", m_p_c, &m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+PB_DS_CLASS_T_DEC\n+template<typename Const_It, class Const_Native_It>\n+void\n+PB_DS_CLASS_C_DEC::\n+back_it_cmp_imp(Const_It b, Const_It e, Const_Native_It native_b, \n+\t\tConst_Native_It native_e)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+  while (b != e)\n+  {\n+    PB_DS_THROW_IF_FAILED(native_b != native_e,\n+\t\t\t  test_traits::val_to_string(*native_e),\n+\t\t\t  m_p_c, &m_native_c);\n+\n+    --e;\n+    --native_e;\n+\n+    PB_DS_THROW_IF_FAILED(test_traits::cmp(*e, * native_e),\n+\t\t\t  test_traits::val_to_string(*e) <<\n+\t\t\t  test_traits::val_to_string(*native_e),\n+\t\t\t  m_p_c, &m_native_c);\n+  }\n+\n+  PB_DS_THROW_IF_FAILED(native_b == native_e,\n+\t\t\ttest_traits::val_to_string(*native_e),\n+\t\t\tm_p_c, &m_native_c);\n+\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+lower_bound_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+lower_bound_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+  m_alloc.set_throw_prob(0);\n+  const key_type k = test_traits::generate_key(m_g, m_m);\n+  m_alloc.set_throw_prob(1);\n+  typename cntnr::const_iterator it = r_c.lower_bound(k);\n+  typename native_type::key_type native_k = test_traits::native_key(k);\n+  typename native_type::const_iterator native_it = r_native_c.lower_bound(native_k);\n+\n+  if (it != r_c.end() && native_it == r_native_c.end())\n+    PB_DS_THROW_IF_FAILED(\"\",\n+\t\t\t  \"it: \" + test_traits::val_to_string(*it) + \"\\n\\n\",\n+\t\t\t  &r_c, &r_native_c);\n+\n+  if (it == r_c.end() && native_it != r_native_c.end())\n+    PB_DS_THROW_IF_FAILED(\"\",\n+\t\t\t  \"native_it: \" + test_traits::val_to_string(*native_it) + \"\\n\\n\",\n+\t\t\t  &r_c, &r_native_c);\n+\n+  if (it != r_c.end() && !test_traits::cmp(*it, * native_it))\n+    PB_DS_THROW_IF_FAILED(false,\n+\t\t\t  \"key: \" + test_traits::key_to_string(k) + \"\\n\\n\" +\n+\t\t\t  \"it: \" + test_traits::val_to_string(*it) + \"\\n\\n\" +\n+\t\t\t  \"native_it: \" + test_traits::val_to_string(*native_it) + \"\\n\\n\",\n+\t\t\t  &r_c, &r_native_c);\n+\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+upper_bound_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+upper_bound_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n+{\n+  PB_DS_SET_DESTRUCT_PRINT\n+  m_alloc.set_throw_prob(0);\n+  const key_type k = test_traits::generate_key(m_g, m_m);\n+  m_alloc.set_throw_prob(1);\n+  typename cntnr::const_iterator it =  r_c.upper_bound(k);\n+  typename native_type::key_type native_k = test_traits::native_key(k);\n+  typename native_type::const_iterator native_it = r_native_c.upper_bound(native_k);\n+\n+  if (it == r_c.end() && native_it != r_native_c.end())\n+    PB_DS_THROW_IF_FAILED(false,\n+\t\t\t  \"key: \" + test_traits::key_to_string(k) + \"\\n\\n\" +\n+\t\t\t  \"native_it: \" + test_traits::val_to_string(*native_it) + \"\\n\\n\",\n+\t\t\t  &r_c, &r_native_c);\n+\n+  if (it != r_c.end() && native_it == r_native_c.end())\n+    PB_DS_THROW_IF_FAILED(false,\n+\t\t\t  \"key: \" + test_traits::key_to_string(k) + \"\\n\\n\" +\n+\t\t\t  \"it: \" + test_traits::val_to_string(*it) + \"\\n\\n\",\n+\t\t\t  &r_c, &r_native_c);\n+\n+  if (it != r_c.end() && !test_traits::cmp(*it, * native_it))\n+    PB_DS_THROW_IF_FAILED(false,\n+\t\t\t  \"key: \" + test_traits::key_to_string(k) + \"\\n\\n\" +\n+\t\t\t  \"it: \" + test_traits::val_to_string(*it) + \"\\n\\n\" +\n+\t\t\t  \"native_it: \" + test_traits::val_to_string(*native_it) + \"\\n\\n\",\n+\t\t\t  &r_c, &r_native_c);\n+\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+// Operators.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+operator()()\n+{\n+  typedef xml_result_set_regression_formatter formatter_type;\n+  formatter_type* p_fmt = NULL;\n+\n+  if (m_disp)\n+    p_fmt = new formatter_type(string_form<Cntnr>::name(),\n+\t\t\t       string_form<Cntnr>::desc());\n+\n+  m_g.init(m_seed);\n+\n+  // Track allocation from this point only.\n+  const size_t memory_label = 775;\n+  m_alloc.init(m_seed);\n+  m_alloc.set_label(memory_label);  \n+\n+  prog_bar pb(m_n, std::cout, m_disp);\n+  m_i = 0;\n+\n+  try\n+    {\n+      for (m_i = 0; m_i < m_n; ++m_i)\n+        {\n+\t  PB_DS_TRACE(\"Op #\" << static_cast<unsigned long>(m_i));\n+\t  allocator_type::set_label(m_i);\n+\t  switch (m_i)\n+            {\n+            case 0:\n+\t      PB_DS_RUN_MTHD(default_constructor);\n+\t      break;\n+            case 1:\n+\t      defs();\n+\t      break;\n+            case 2:\n+\t      policy_access();\n+\t      break;\n+            case 3:\n+\t      it_copy();\n+\t      break;\n+            case 4:\n+\t      it_assign();\n+\t      break;\n+            case 5:\n+\t      rev_it_copy();\n+\t      break;\n+            case 6:\n+\t      rev_it_assign();\n+\t      break;\n+            default:\n+\t      switch(get_next_op())\n+                {\n+                case insert_op:\n+\t\t  switch(get_next_sub_op(2))\n+                    {\n+                    case 0:\n+\t\t      PB_DS_RUN_MTHD(insert)\n+                        break;\n+                    case 1:\n+\t\t      PB_DS_RUN_MTHD(subscript)\n+                        break;\n+                    default:\n+\t\t      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+                    }\n+\t\t  break;\n+                case erase_op:\n+\t\t  switch(get_next_sub_op(4))\n+                    {\n+                    case 0:\n+\t\t      PB_DS_RUN_MTHD(erase)\n+                        break;\n+                    case 1:\n+\t\t      PB_DS_RUN_MTHD(erase_if)\n+                        break;\n+                    case 2:\n+\t\t      PB_DS_RUN_MTHD(erase_it)\n+                        break;\n+                    case 3:\n+\t\t      PB_DS_RUN_MTHD(erase_rev_it)\n+                        break;\n+                    default:\n+\t\t      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+                    }\n+\t\t  break;\n+                case clear_op:\n+\t\t  PB_DS_RUN_MTHD(clear)\n+                    break;\n+                case other_op:\n+\t\t  switch(get_next_sub_op(8))\n+                    {\n+                    case 0:\n+\t\t      swap();\n+\t\t      break;\n+                    case 1:\n+\t\t      PB_DS_RUN_MTHD(copy_constructor)\n+                        break;\n+                    case 2:\n+\t\t      PB_DS_RUN_MTHD(it_constructor)\n+                        break;\n+                    case 3:\n+\t\t      PB_DS_RUN_MTHD(assignment_operator)\n+                        break;\n+                    case 4:\n+\t\t      PB_DS_RUN_MTHD(split_join)\n+                        break;\n+                    case 5:\n+\t\t      resize();\n+\t\t      break;\n+                    case 6:\n+\t\t      get_set_load();\n+\t\t      break;\n+                    case 7:\n+\t\t      get_set_loads();\n+\t\t      break;\n+                    default:\n+\t\t      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+                    }\n+\t\t  break;\n+                default:\n+\t\t  PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+                };\n+            }\n+\n+\t  pb.inc();\n+        }\n+    }\n+  catch (...)\n+    {\n+      std::cerr << \"Failed at index \" << static_cast<unsigned long>(m_i) \n+\t\t<< std::endl;\n+      delete m_p_c;\n+      throw;\n+    }\n+\n+  // Clean up, then check for allocation by special label, set above.\n+  delete m_p_c;\n+\n+  try \n+    { m_alloc.check_allocated(memory_label); }\n+  catch (...)\n+    {\n+      std::cerr << \"detected leaks!\" << std::endl;\n+      std::cerr << m_alloc << std::endl;\n+      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+    }\n+\n+  // Reset throw probability.\n+  m_alloc.set_throw_prob(0);\n+\n+  if (m_disp)\n+    {\n+      std::cout << std::endl;\n+      delete p_fmt;\n+    }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+typename PB_DS_CLASS_C_DEC::op\n+PB_DS_CLASS_C_DEC::\n+get_next_op()\n+{\n+  const double prob = m_g.get_prob();\n+  if (prob < m_ip)\n+    return insert_op;\n+\n+  if (prob < m_ip + m_ep)\n+    return erase_op;\n+\n+  if (prob < m_ip + m_ep + m_cp)\n+    return clear_op;\n+\n+  PB_DS_THROW_IF_FAILED(prob <= 1, prob, m_p_c, &m_native_c);\n+  return other_op;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+size_t\n+PB_DS_CLASS_C_DEC::\n+get_next_sub_op(size_t max)\n+{\n+  const double p = m_g.get_prob();\n+  const double delta = 1 / static_cast<double>(max);\n+  size_t i = 0;\n+  while (true)\n+    if (p <= (i + 1) * delta)\n+      {\n+\tPB_DS_THROW_IF_FAILED(i < max, i << \" \" << max, m_p_c, &m_native_c);\n+\treturn i;\n+      }\n+    else\n+      ++i;\n+}\n+\n+// Insert.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+insert()\n+{\n+  PB_DS_TRACE(\"insert\");\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+  try\n+    {\n+      m_alloc.set_throw_prob(0);\n+      value_type v = test_traits::generate_value(m_g, m_m);\n+      m_alloc.set_throw_prob(m_tp);\n+      const_key_reference r_k = test_traits::extract_key(v);\n+      typename cntnr::const_point_iterator found_it = m_p_c->find(r_k);\n+      const bool existed = (found_it != m_p_c->end());\n+      const std::pair<typename cntnr::point_iterator, bool> ins_ret = m_p_c->insert(v);\n+      \n+      if (ins_ret.second)\n+\t{\n+\t  PB_DS_THROW_IF_FAILED(!existed, \"\", m_p_c, &m_native_c);\n+\t}\n+      else\n+\t{\n+\t  PB_DS_THROW_IF_FAILED(existed, \"\", m_p_c, &m_native_c);\n+\t  PB_DS_THROW_IF_FAILED(found_it == ins_ret.first, \"\", m_p_c, &m_native_c);\n+\t}\n+      m_native_c.insert(test_traits::native_value(v));\n+    }\n+  catch(__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+    }\n+  catch(__gnu_pbds::insert_error&)\n+    {\n+      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n+    }\n+  \n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+// Subscript.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+subscript()\n+{\n+  PB_DS_TRACE(\"subscript\");\n+\n+  enum\n+    {\n+      no_data = __gnu_pbds::detail::is_same<\n+      typename Cntnr::const_key_reference,\n+      typename Cntnr::const_reference>::value\n+    };\n+\n+  return (subscript_imp(__gnu_pbds::detail::integral_constant<int,no_data>()));\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+subscript_imp(__gnu_pbds::detail::false_type)\n+{\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+  try\n+    {\n+      m_alloc.set_throw_prob(0);\n+      value_type v = test_traits::generate_value(m_g, m_m);\n+\n+      m_alloc.set_throw_prob(m_tp);\n+      (*m_p_c)[v.first] = v.second;\n+\n+      m_native_c[test_traits::native_value(v).first] =\n+\ttest_traits::native_value(v).second;\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+    }\n+  \n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+subscript_imp(__gnu_pbds::detail::true_type)\n+{\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+  try\n+    {\n+      m_alloc.set_throw_prob(0);\n+      value_type v = test_traits::generate_value(m_g, m_m);\n+      m_alloc.set_throw_prob(m_tp);\n+      (*m_p_c)[v] = __gnu_pbds::null_mapped_type();\n+      m_native_c.insert(test_traits::native_value(v));\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+    }\n+  \n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+// Clear.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+clear()\n+{\n+  m_p_c->clear();\n+  m_native_c.clear();\n+  return true;\n+}\n+\n+\n+// Erase.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase()\n+{\n+  PB_DS_TRACE(\"erase\");\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+  m_alloc.set_throw_prob(0);\n+  const key_type k = test_traits::generate_key(m_g, m_m);\n+  m_alloc.set_throw_prob(m_tp);\n+\n+  try\n+    {\n+      const bool cntnd = m_p_c->find(k) != m_p_c->end();\n+      PB_DS_THROW_IF_FAILED(cntnd ==(m_native_c.find(test_traits::native_key(k)) != m_native_c.end()), test_traits::key_to_string(k), m_p_c, &m_native_c);\n+\n+      const bool ersd = m_p_c->erase(k);\n+      const bool native_ersd = m_native_c.erase(test_traits::native_key(k)) != 0;\n+\n+      PB_DS_THROW_IF_FAILED(ersd == native_ersd, ersd << \" \" << native_ersd, \n+\t\t\t    m_p_c, &m_native_c);\n+\n+      PB_DS_THROW_IF_FAILED(m_p_c->find(k) == m_p_c->end(), \"\", \n+\t\t\t    m_p_c, &m_native_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+\n+      PB_DS_THROW_IF_FAILED(            container_traits::erase_can_throw, container_traits::erase_can_throw, m_p_c, &m_native_c);\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_if()\n+{\n+  PB_DS_TRACE(\"erase_if\");\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+  try\n+    {\n+      typedef\n+\ttypename std::iterator_traits<typename cntnr::iterator>::reference\n+\tit_const_reference;\n+      \n+      typedef\n+\ttypename test_traits::template erase_if_fn<value_type>\n+\terase_if_fn_t;\n+      \n+      m_alloc.set_throw_prob(m_tp);\n+      \n+      const size_t ersd = m_p_c->erase_if(erase_if_fn_t());      \n+      const size_t native_ersd = test_traits::erase_if(m_native_c);      \n+      PB_DS_THROW_IF_FAILED(ersd == native_ersd,\n+\t\t\t    ersd << \" \" << native_ersd, m_p_c, &m_native_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+      PB_DS_THROW_IF_FAILED(container_traits::erase_can_throw, \n+\t\t\t    container_traits::erase_can_throw, \n+\t\t\t    m_p_c, &m_native_c);\n+    }\n+  \n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_it()\n+{\n+  enum\n+    {\n+      erase_iterators = container_traits::order_preserving\n+    };\n+\n+  return (erase_it_imp(__gnu_pbds::detail::integral_constant<int,erase_iterators>()));\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_it_imp(__gnu_pbds::detail::false_type)\n+{\n+  return true;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_it_imp(__gnu_pbds::detail::true_type)\n+{\n+  PB_DS_TRACE(\"erase_it\");\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+  try\n+    {\n+      m_alloc.set_throw_prob(0);\n+      const key_type k = test_traits::generate_key(m_g, m_m);\n+      m_alloc.set_throw_prob(m_tp);\n+\n+      typename cntnr::iterator found_it = m_p_c->find(k);\n+\n+      typename native_type::iterator native_it = m_native_c.find(test_traits::native_key(k));\n+\n+      const bool found = found_it != m_p_c->end();\n+      const bool native_found = native_it != m_native_c.end();\n+      \n+      PB_DS_THROW_IF_FAILED(\n+\t\t\t    found == native_found,\n+\t\t\t    found << \" \" <<    native_found,\n+\t\t\t    m_p_c,\n+\t\t\t    &m_native_c);\n+      \n+      typename cntnr::const_iterator next_it = found_it;\n+      if (next_it != m_p_c->end())\n+\t++next_it;\n+      \n+      typename cntnr::iterator next_ers_it = m_p_c->erase(found_it);\n+      \n+      if (native_it != m_native_c.end())\n+\tm_native_c.erase(native_it);\n+      \n+      bool range_guarantee = __gnu_pbds::detail::is_same<\n+      typename container_traits::invalidation_guarantee,\n+\t__gnu_pbds::range_invalidation_guarantee>::value ;\n+\n+      if (range_guarantee)\n+\tPB_DS_THROW_IF_FAILED(next_ers_it == next_it, \"\", m_p_c, &m_native_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+      PB_DS_THROW_IF_FAILED(container_traits::erase_can_throw, container_traits::erase_can_throw, m_p_c, &m_native_c);\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_rev_it()\n+{\n+  enum\n+    {\n+      erase_iterators = container_traits::order_preserving \n+      \t                && container_traits::reverse_iteration\n+    };\n+\n+  return (erase_rev_it_imp(__gnu_pbds::detail::integral_constant<int,erase_iterators>()));\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_rev_it_imp(__gnu_pbds::detail::false_type)\n+{\n+  return true;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_rev_it_imp(__gnu_pbds::detail::true_type)\n+{\n+  PB_DS_TRACE(\"erase_rev_it\");\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+  try\n+    {\n+      m_alloc.set_throw_prob(0);      \n+      const key_type k = test_traits::generate_key(m_g, m_m);      \n+      m_alloc.set_throw_prob(m_tp);\n+      \n+      typename cntnr::iterator found_it = m_p_c->find(k);\n+      typename native_type::iterator native_it = m_native_c.find(test_traits::native_key(k));\n+      \n+      typename cntnr::const_reverse_iterator next_it = found_it;\n+      if (next_it != m_p_c->end())\n+\t++next_it;\n+      \n+      typename cntnr::reverse_iterator next_ers_it =\n+\tm_p_c->erase((typename cntnr::reverse_iterator)found_it);\n+      \n+      PB_DS_THROW_IF_FAILED(next_ers_it == next_it, \"\", m_p_c, &m_native_c);\n+\n+      if (native_it != m_native_c.end())\n+\tm_native_c.erase(native_it);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;      \n+      PB_DS_THROW_IF_FAILED(container_traits::erase_can_throw, \n+\t\t\t    container_traits::erase_can_throw, \n+\t\t\t    m_p_c, &m_native_c);\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+// Defs.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+defs()\n+{\n+  // General container types.\n+  typedef typename Cntnr::size_type test_size_type;\n+  typedef typename Cntnr::difference_type difference_type;\n+\n+  key_defs();\n+  mapped_defs();\n+  value_defs();\n+  iterator_defs();\n+  node_iterator_defs(__gnu_pbds::detail::integral_constant<int,\n+\t\t     container_traits::order_preserving>());\n+  policy_defs();\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+key_defs()\n+{\n+  typedef typename Cntnr::key_type test_key_type;\n+  typedef typename Cntnr::key_reference test_key_reference;\n+  typedef typename Cntnr::const_key_reference test_const_key_reference;\n+  typedef typename Cntnr::key_pointer test_key_pointer;\n+  typedef typename Cntnr::const_key_pointer test_const_key_pointer;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+mapped_defs()\n+{\n+  typedef typename Cntnr::mapped_type test_mapped_type;\n+  typedef typename Cntnr::mapped_reference test_mapped_reference;\n+  typedef typename Cntnr::const_mapped_reference test_const_mapped_reference;\n+  typedef typename Cntnr::mapped_pointer test_mapped_pointer;\n+  typedef typename Cntnr::const_mapped_pointer test_const_mapped_pointer;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+value_defs()\n+{\n+  typedef typename Cntnr::value_type test_value_type;\n+  typedef typename Cntnr::reference test_reference;\n+  typedef typename Cntnr::const_reference test_const_reference;\n+  typedef typename Cntnr::pointer test_pointer;\n+  typedef typename Cntnr::const_pointer test_const_pointer;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+ds_defs()\n+{\n+  typedef __gnu_pbds::container_traits< Cntnr> test_container_traits;\n+\n+  typedef typename test_container_traits::container_category test_container_category;\n+\n+  typedef\n+    typename test_container_traits::invalidation_guarantee\n+    test_invalidation_guarantee;\n+\n+  enum\n+    {\n+      test_order_preserving = test_container_traits::order_preserving\n+    };\n+\n+  enum\n+    {\n+      test_erase_can_throw = test_container_traits::erase_can_throw\n+    };\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+iterator_defs()\n+{\n+  typedef typename Cntnr::point_iterator test_point_iterator;\n+  typedef typename Cntnr::const_point_iterator const_test_point_iterator;\n+  typedef typename Cntnr::iterator test_iterator;\n+  typedef typename Cntnr::const_iterator const_test_iterator;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+node_iterator_defs(__gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+node_iterator_defs(__gnu_pbds::detail::true_type)\n+{\n+  typedef typename Cntnr::node_iterator test_node_iterator;\n+  typedef typename Cntnr::const_node_iterator test_const_node_iterator;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_defs()\n+{\n+  typedef typename Cntnr::allocator_type test_allocator;\n+  policy_defs(typename Cntnr::container_category());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_defs(__gnu_pbds::basic_hash_tag)\n+{\n+  typedef typename Cntnr::hash_fn test_hash_fn;\n+  typedef typename Cntnr::eq_fn test_eq_fn;\n+  typedef typename Cntnr::resize_policy test_resize_policy;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_defs(__gnu_pbds::cc_hash_tag)\n+{\n+  policy_defs(__gnu_pbds::basic_hash_tag());\n+  typedef typename Cntnr::comb_hash_fn test_comb_hash_fn;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_defs(__gnu_pbds::gp_hash_tag)\n+{\n+  policy_defs(__gnu_pbds::basic_hash_tag());\n+  typedef typename Cntnr::comb_probe_fn test_comb_probe_fn;\n+  typedef typename Cntnr::probe_fn test_probe_fn;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_defs(__gnu_pbds::tree_tag)\n+{\n+  typedef typename Cntnr::cmp_fn test_cmp_fn;\n+  typedef typename Cntnr::node_update test_node_update;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_defs(__gnu_pbds::list_update_tag)\n+{\n+  typedef typename Cntnr::eq_fn test_eq_fn;\n+  typedef typename Cntnr::update_policy test_update_policy;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_defs(__gnu_pbds::pat_trie_tag)\n+{\n+  typedef typename Cntnr::e_access_traits e_access_traits;\n+}\n+\n+\n+// Policy Access.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_access()\n+{\n+  policy_access(typename Cntnr::container_category());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_access(__gnu_pbds::basic_hash_tag)\n+{\n+  {\n+    typename Cntnr::hash_fn& r_t = m_p_c->get_hash_fn();\n+    assert(&r_t != NULL);\n+  }\n+  {\n+    const typename Cntnr::hash_fn& r_t =((const Cntnr& )*m_p_c).get_hash_fn();\n+    assert(&r_t != NULL);\n+  }\n+\n+  {\n+    typename Cntnr::eq_fn& r_t = m_p_c->get_eq_fn();\n+    assert(&r_t != NULL);\n+  }\n+  {\n+    const typename Cntnr::eq_fn& r_t =((const Cntnr& )*m_p_c).get_eq_fn();\n+    assert(&r_t != NULL);\n+  }\n+\n+  {\n+    typename Cntnr::resize_policy& r_t = m_p_c->get_resize_policy();\n+    assert(&r_t != NULL);\n+  }\n+  {\n+    const typename Cntnr::resize_policy& r_t =((const Cntnr& )*m_p_c).get_resize_policy();\n+\n+    assert(&r_t != NULL);\n+  }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_access(__gnu_pbds::cc_hash_tag)\n+{\n+  policy_access(__gnu_pbds::basic_hash_tag());\n+\n+  {\n+    typename Cntnr::comb_hash_fn& r_t = m_p_c->get_comb_hash_fn();\n+    assert(&r_t != NULL);\n+  }\n+  {\n+    const typename Cntnr::comb_hash_fn& r_t =((const Cntnr& )*m_p_c).get_comb_hash_fn();\n+\n+    assert(&r_t != NULL);\n+  }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_access(__gnu_pbds::gp_hash_tag)\n+{\n+  policy_access(__gnu_pbds::basic_hash_tag());\n+\n+  {\n+    typename Cntnr::comb_probe_fn& r_t = m_p_c->get_comb_probe_fn();\n+    assert(&r_t != NULL);\n+  }\n+  {\n+    const typename Cntnr::comb_probe_fn& r_t =((const Cntnr& )*m_p_c).get_comb_probe_fn();\n+\n+    assert(&r_t != NULL);\n+  }\n+\n+  {\n+    typename Cntnr::probe_fn& r_t = m_p_c->get_probe_fn();\n+    assert(&r_t != NULL);\n+  }\n+  {\n+    const typename Cntnr::probe_fn& r_t =((const Cntnr& )*m_p_c).get_probe_fn();\n+    assert(&r_t != NULL);\n+  }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_access(__gnu_pbds::tree_tag)\n+{\n+  {\n+    typename Cntnr::cmp_fn& r_t = m_p_c->get_cmp_fn();\n+    assert(&r_t != NULL);\n+  }\n+\n+  {\n+    const typename Cntnr::cmp_fn& r_t =((const Cntnr& )*m_p_c).get_cmp_fn();\n+    assert(&r_t != NULL);\n+  }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_access(__gnu_pbds::list_update_tag)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_access(__gnu_pbds::pat_trie_tag)\n+{\n+  typename Cntnr::e_access_traits& r_t = m_p_c->get_e_access_traits();\n+  assert(&r_t != NULL);\n+}\n+\n+\n+// Split/Join.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+split_join()\n+{\n+  enum\n+    {\n+      split_join = container_traits::order_preserving\n+    };\n+\n+  return (split_join_imp(__gnu_pbds::detail::integral_constant<int,split_join>()));\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+split_join_imp(__gnu_pbds::detail::false_type)\n+{\n+  return true;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+split_join_imp(__gnu_pbds::detail::true_type)\n+{\n+  PB_DS_TRACE(\"split_join\");\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+\n+  try\n+    {\n+      m_alloc.set_throw_prob(0);\n+      Cntnr lhs(*m_p_c);\n+      Cntnr rhs;\n+      native_type native_lhs(m_native_c);\n+      native_type native_rhs;\n+      const key_type k = test_traits::generate_key(m_g, m_m);\n+      \n+      m_alloc.set_throw_prob(m_tp);\n+      lhs.split(k, rhs);\n+      \n+      typename native_type::const_iterator it =\n+\tnative_lhs.upper_bound(test_traits::native_key(k));\n+      \n+      while (!native_lhs.empty()&&  it != native_lhs.end())\n+\t{\n+\t  native_rhs.insert(*it);\n+\t  typename native_type::const_iterator next_it = it;\n+\t  ++next_it;\n+\t  native_lhs.erase(test_traits::extract_native_key(*it));\n+\t  it = next_it;\n+\t}\n+      \n+      PB_DS_COND_COMPARE(lhs, native_lhs);\n+      PB_DS_COND_COMPARE(rhs, native_rhs);\n+      \n+      m_alloc.set_throw_prob(m_tp);\n+      \n+      if (m_g.get_prob() < 0.5)\n+\tlhs.swap(rhs);\n+      \n+      lhs.join(rhs);\n+      PB_DS_THROW_IF_FAILED(rhs.size() == 0, rhs.size(), m_p_c, &m_native_c);\n+      PB_DS_THROW_IF_FAILED(rhs.empty(), rhs.size(), m_p_c, &m_native_c);\n+      m_p_c->swap(lhs);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+      PB_DS_THROW_IF_FAILED(container_traits::split_join_can_throw, \n+\t\t\t    container_traits::split_join_can_throw, \n+\t\t\t    m_p_c, &m_native_c);\n+    }\n+  \n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+// Iterator conversions.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+it_copy()\n+{\n+  {\n+    typename cntnr::iterator it = m_p_c->end();\n+    typename cntnr::const_iterator const_it(it);\n+    PB_DS_THROW_IF_FAILED(const_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_it != it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::const_point_iterator const_find_it(it);\n+    PB_DS_THROW_IF_FAILED(const_find_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_find_it != it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::point_iterator find_it(it);\n+    PB_DS_THROW_IF_FAILED(find_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(find_it != it), \"\", m_p_c, &m_native_c);\n+  }\n+\n+  {\n+    typename cntnr::const_iterator const_it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it(const_it);\n+    PB_DS_THROW_IF_FAILED(const_find_it == const_it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_find_it != const_it), \"\", m_p_c, &m_native_c);\n+  }\n+\n+  {\n+    typename cntnr::point_iterator find_it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it(find_it);\n+    PB_DS_THROW_IF_FAILED(find_it == const_find_it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(find_it != const_find_it), \"\", m_p_c, &m_native_c);\n+  }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+it_assign()\n+{\n+  {\n+    typename cntnr::iterator it = m_p_c->end();\n+    typename cntnr::const_iterator const_it;\n+    const_it = it;\n+    PB_DS_THROW_IF_FAILED(const_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_it != it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::const_point_iterator const_find_it;\n+    const_find_it = it;\n+    PB_DS_THROW_IF_FAILED(const_find_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_find_it != it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::point_iterator find_it;\n+    find_it = it;\n+    PB_DS_THROW_IF_FAILED(find_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(find_it != it), \"\", m_p_c, &m_native_c);\n+  }\n+\n+  {\n+    typename cntnr::const_iterator const_it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it;\n+    const_find_it = const_it;\n+    PB_DS_THROW_IF_FAILED(const_find_it == const_it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_find_it != const_it), \"\", m_p_c, &m_native_c);\n+  }\n+\n+  {\n+    typename cntnr::point_iterator find_it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it;\n+    const_find_it = find_it;\n+    PB_DS_THROW_IF_FAILED(find_it == const_find_it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(find_it != const_find_it), \"\", m_p_c, &m_native_c);\n+  }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+rev_it_copy()\n+{\n+  enum\n+    {\n+      reverse_iteration = container_traits::reverse_iteration\n+    };\n+\n+  rev_it_copy_imp(__gnu_pbds::detail::integral_constant<int,reverse_iteration>());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+rev_it_assign()\n+{\n+  enum\n+    {\n+      reverse_iteration = container_traits::reverse_iteration\n+    };\n+\n+  rev_it_assign_imp(__gnu_pbds::detail::integral_constant<int,reverse_iteration>());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+rev_it_copy_imp(__gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+rev_it_copy_imp(__gnu_pbds::detail::true_type)\n+{\n+  {\n+    typename cntnr::iterator it = m_p_c->end();\n+    typename cntnr::const_reverse_iterator const_it(it);\n+    PB_DS_THROW_IF_FAILED(const_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_it != it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::const_point_iterator const_find_it(it);\n+    PB_DS_THROW_IF_FAILED(const_find_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_find_it != it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::point_iterator find_it(it);\n+    PB_DS_THROW_IF_FAILED(find_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(find_it != it), \"\", m_p_c, &m_native_c);\n+  }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+rev_it_assign_imp(__gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+rev_it_assign_imp(__gnu_pbds::detail::true_type)\n+{\n+  {\n+    typename cntnr::iterator it = m_p_c->end();\n+    typename cntnr::const_reverse_iterator const_it;\n+    const_it = it;\n+    PB_DS_THROW_IF_FAILED(const_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_it != it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::const_point_iterator const_find_it;\n+    const_find_it = it;\n+    PB_DS_THROW_IF_FAILED(const_find_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(const_find_it != it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::point_iterator find_it;\n+    find_it = it;\n+    PB_DS_THROW_IF_FAILED(find_it == it, \"\", m_p_c, &m_native_c);\n+    PB_DS_THROW_IF_FAILED(!(find_it != it), \"\", m_p_c, &m_native_c);\n+  }\n+}\n+\n+// Resize.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+resize()\n+{\n+  typedef __gnu_pbds::detail::integral_constant<int, test_traits::resize> resize_ind;\n+\n+  return resize_imp(resize_ind());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+resize_imp(__gnu_pbds::detail::false_type)\n+{\n+  return true;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+resize_imp(__gnu_pbds::detail::true_type)\n+{\n+  PB_DS_TRACE(\"resize\");\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+  const size_t old_size = m_p_c->get_actual_size();\n+\n+  try\n+    {\n+      enum\n+        {\n+\t  min_new_size = 200,\n+\t  max_new_size = 2000\n+        };\n+\n+      m_alloc.set_throw_prob(m_tp);\n+      typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+      const size_t new_size = m_g.get_unsigned_long(min_new_size, max_new_size);\n+      m_p_c->resize(new_size);\n+      const size_t actual_new_size = m_p_c->get_actual_size();\n+      PB_DS_THROW_IF_FAILED(actual_new_size >= new_size,\n+\t\t\t    actual_new_size << \" \" << new_size,\n+\t\t\t    m_p_c, &m_native_c);\n+    }\n+  catch(...)\n+    {\n+      PB_DS_THROW_IF_FAILED(m_p_c->get_actual_size() == old_size,\n+\t\t\t    m_p_c->get_actual_size() << \" \" << old_size,\n+\t\t\t    m_p_c, &m_native_c);\n+\n+      done = false;\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+\n+// Get/Set load.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+get_set_load()\n+{\n+  typedef\n+    __gnu_pbds::detail::integral_constant<int, test_traits::get_set_load>\n+    get_set_load_ind;\n+\n+  get_set_load_imp(get_set_load_ind());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+get_set_load_imp(__gnu_pbds::detail::false_type)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+get_set_load_imp(__gnu_pbds::detail::true_type)\n+{\n+  PB_DS_TRACE(\"get_set_load\");\n+  PB_DS_SET_DESTRUCT_PRINT\n+  m_p_c->get_load();\n+  m_alloc.set_throw_prob(1);\n+  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  const float min_load = static_cast<float>(0.05);\n+  const float max_load = static_cast<float>(0.9);\n+\n+  const float new_load = static_cast<float>(m_g.get_prob() * (max_load - min_load) + min_load);\n+\n+  m_p_c->set_load(new_load);\n+  PB_DS_THROW_IF_FAILED(m_p_c->get_load() == new_load, \"\", m_p_c, &m_native_c);\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+}\n+\n+\n+// Get/Set loads.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+get_set_loads()\n+{\n+  typedef\n+    __gnu_pbds::detail::integral_constant<int, test_traits::get_set_loads>\n+    get_set_loads_ind;\n+\n+  return get_set_loads_imp(get_set_loads_ind());\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+get_set_loads_imp(__gnu_pbds::detail::false_type)\n+{\n+  return true;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+get_set_loads_imp(__gnu_pbds::detail::true_type)\n+{\n+  PB_DS_TRACE(\"get_set_loads\");\n+  bool done = true;\n+  PB_DS_SET_DESTRUCT_PRINT\n+  const std::pair<float, float> old_loads = m_p_c->get_loads();\n+\n+  try\n+    {\n+      m_alloc.set_throw_prob(m_tp);\n+\n+      typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+\n+      const float min_min_load = static_cast<float>(0.05);\n+      const float max_min_load = static_cast<float>(0.2);\n+\n+      const float new_min_load =\n+\tstatic_cast<float>(m_g.get_prob()*  (max_min_load - min_min_load) +\n+\t\t\t   min_min_load);\n+\n+      const float new_max_load = static_cast<float>(new_min_load*  2.5);\n+      PB_DS_THROW_IF_FAILED(new_max_load < 1, new_max_load, m_p_c, &m_native_c);\n+      m_p_c->set_loads(std::make_pair(new_min_load, new_max_load));\n+    }\n+  catch(...)\n+    {\n+      PB_DS_THROW_IF_FAILED(old_loads == m_p_c->get_loads(),\n+\t\t\t    old_loads.first << \" \" << old_loads.second << \" \" <<\n+\t\t\t    m_p_c->get_loads().first << \" \" <<\n+\t\t\t    m_p_c->get_loads().second,\n+\t\t\t    m_p_c, &m_native_c);\n+\n+      done = false;\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  PB_DS_CANCEL_DESTRUCT_PRINT\n+  return done;\n+}\n+\n+// Diagnostics.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+print_container(const native_type& r_cnt, std::ostream& r_os) const\n+{\n+  m_alloc.set_throw_prob(0);\n+  typename native_type::const_iterator it = r_cnt.begin();\n+  while (it != r_cnt.end())\n+    {\n+      r_os << test_traits::val_to_string(*it) + \"\\n\";\n+      ++it;\n+    }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+print_container(const cntnr& r_cnt, std::ostream& r_os) const\n+{\n+  m_alloc.set_throw_prob(0);\n+  typename cntnr::const_iterator it = r_cnt.begin();\n+  while (it != r_cnt.end())\n+    {\n+      r_os << test_traits::val_to_string(*it) + \"\\n\";\n+      ++it;\n+    }\n+}\n+\n+#endif"}, {"sha": "bbc8cbe75c90d1435489ae646eeb3f6a1d3153dd", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/clear_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fclear_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fclear_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fclear_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,58 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file clear_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-clear()\n-{\n-  m_p_c->clear();\n-\n-  m_native_c.clear();\n-\n-  return (true);\n-}\n-"}, {"sha": "3b19a75269675ae9bb43bc6703bec3e4501eb50e", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/cmp_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 601, "changes": 601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fcmp_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fcmp_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fcmp_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,601 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file cmp_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-cmp(const Cntnr& r_c, const native_type& r_native_c, const std::string& r_call_fn)\n-{\n-  m_alloc.set_throw_prob(1);\n-\n-  const size_t size = r_c.size();\n-  const size_t native_size = r_native_c.size();\n-\n-  PB_DS_THROW_IF_FAILED(\n-\t\t\tsize == native_size,\n-\t\t\tstatic_cast<unsigned long>(size) << \" \" <<\n-\t\t\tstatic_cast<unsigned long>(native_size),\n-\t\t\t& r_c,\n-\t\t\t& r_native_c);\n-\n-  const bool empty = r_c.empty();\n-  const bool native_empty = r_native_c.empty();\n-\n-  PB_DS_THROW_IF_FAILED(\n-\t\t\tempty == native_empty,\n-\t\t\tempty << \" \" << native_empty,\n-\t\t\t& r_c,\n-\t\t\t& r_native_c);\n-\n-  try\n-    {\n-      basic_cmp_(r_c, r_native_c);\n-\n-      cmp_(r_c, r_native_c);\n-    }\n-  catch(...)\n-    {\n-      PB_DS_THROW_IF_FAILED(            false, \"call-fn: \" + r_call_fn, & r_c, & r_native_c);\n-    }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-basic_cmp_(const Cntnr& r_c, const native_type& r_native_c)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    if (static_cast<size_t>(std::distance(r_c.begin(), r_c.end())) !=\n-\tr_c.size())\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    false,\n-\t\t\t    static_cast<unsigned long>(\n-\t\t\t\t\t\t       std::distance(r_c.begin(), r_c.end())) <<\n-\t\t\t    \" \" << static_cast<unsigned long>(r_c.size()),\n-\t\t\t    & r_c,\n-\t\t\t    & r_native_c);\n-\n-  typename native_type::const_iterator it = r_native_c.begin();\n-\n-  while (it != r_native_c.end())\n-    {\n-      typename native_type::key_type native_key =\n-\ttest_traits::extract_native_key(*it);\n-\n-      m_alloc.set_throw_prob(0);\n-\n-      const key_type k = native_key;\n-\n-      m_alloc.set_throw_prob(1);\n-\n-      typename cntnr::const_point_iterator found_it = r_c.find(k);\n-\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    found_it != r_c.end(),\n-\t\t\t    test_traits::native_val_to_string(*it),\n-\t\t\t    & r_c,\n-\t\t\t    & r_native_c);\n-\n-      if (!test_traits::cmp(*found_it, * it))\n-\tPB_DS_THROW_IF_FAILED(                false,  \"\", & r_c, & r_native_c);\n-\n-      ++it;\n-    }\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-cmp_(const Cntnr& r_c, const native_type& r_native_c)\n-{\n-  enum\n-    {\n-      order_preserving =\n-      container_traits::order_preserving,\n-      back_order_preserving =\n-      container_traits::order_preserving&& \n-      !__gnu_pbds::detail::is_same<\n-      typename std::iterator_traits<\n-      typename cntnr::const_iterator>::iterator_category,\n-      std::forward_iterator_tag>::value,\n-      reverse_iteration = container_traits::reverse_iteration,\n-      order_statistics = test_traits::order_statistics,\n-      prefix_search = test_traits::prefix_search,\n-      has_mapped = !__gnu_pbds::detail::is_same<\n-      typename Cntnr::mapped_type,\n-      __gnu_pbds::null_mapped_type>::value\n-    };\n-\n-  order_preserving_cmp_imp(r_c, r_native_c,\n-\t\t\t   __gnu_pbds::detail::integral_constant<int,order_preserving>());\n-\n-  back_order_preserving_cmp_imp(r_c, r_native_c,\n-\t\t\t\t__gnu_pbds::detail::integral_constant<int,back_order_preserving>());\n-\n-  order_statistics_cmp_imp(r_c, r_native_c,\n-\t\t\t   __gnu_pbds::detail::integral_constant<int,order_statistics>());\n-\n-  prefix_search_cmp_imp(r_c, r_native_c,\n-\t\t\t__gnu_pbds::detail::integral_constant<int,prefix_search>());\n-\n-  reverse_iteration_cmp_imp(r_c, r_native_c,\n-\t\t\t    __gnu_pbds::detail::integral_constant<int,reverse_iteration>());\n-\n-  lower_bound_cmp_imp(r_c, r_native_c,\n-\t\t      __gnu_pbds::detail::integral_constant<int,order_preserving>());\n-\n-  upper_bound_cmp_imp(r_c, r_native_c,\n-\t\t      __gnu_pbds::detail::integral_constant<int,order_preserving>());\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-order_preserving_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-order_preserving_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    typename cntnr::const_iterator b = r_c.begin();\n-  typename cntnr::const_iterator e = r_c.end();\n-\n-  typename native_type::const_iterator native_b = r_native_c.begin();\n-  typename native_type::const_iterator native_e = r_native_c.end();\n-\n-  try\n-    {\n-      it_cmp_imp(b, e, native_b, native_e);\n-    }\n-  catch(...)\n-    {\n-      PB_DS_THROW_IF_FAILED(            false, \"\", & r_c, & r_native_c)\n-\t}\n-\n-  try\n-    {\n-      back_it_cmp_imp(b, e, native_b, native_e);\n-    }\n-  catch(...)\n-    {\n-      PB_DS_THROW_IF_FAILED(            false, \"\", & r_c, & r_native_c)\n-\t}\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-back_order_preserving_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-back_order_preserving_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    typename cntnr::const_iterator b = r_c.begin();\n-  typename cntnr::const_iterator e = r_c.end();\n-\n-  typename native_type::const_iterator native_b = r_native_c.begin();\n-  typename native_type::const_iterator native_e = r_native_c.end();\n-\n-  it_cmp_imp(b, e, native_b, native_e);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-reverse_iteration_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-reverse_iteration_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    typename cntnr::const_reverse_iterator b = r_c.rbegin();\n-  typename cntnr::const_reverse_iterator e = r_c.rend();\n-\n-  typename native_type::const_reverse_iterator native_b = r_native_c.rbegin();\n-  typename native_type::const_reverse_iterator native_e = r_native_c.rend();\n-\n-  try\n-    {\n-      it_cmp_imp(b, e, native_b, native_e);\n-    }\n-  catch(...)\n-    {\n-      PB_DS_THROW_IF_FAILED(            false, \"\", & r_c, & r_native_c)\n-\t}\n-\n-  try\n-    {\n-      back_it_cmp_imp(b, e, native_b, native_e);\n-    }\n-  catch(...)\n-    {\n-      PB_DS_THROW_IF_FAILED(            false, \"\", & r_c, & r_native_c)\n-\t}\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-order_statistics_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-order_statistics_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n-{\n-  {\n-    m_alloc.set_throw_prob(0);\n-\n-    const key_type k =\n-      test_traits::generate_key(m_g, m_m);\n-\n-    m_alloc.set_throw_prob(1);\n-\n-    const size_type order = r_c.order_of_key(k);\n-\n-    const size_type native_order = std::distance(\n-\t\t\t\t\t\t r_native_c.begin(),\n-\t\t\t\t\t\t r_native_c.lower_bound(test_traits::native_key(k)));\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  order == native_order,\n-\t\t\t  test_traits::key_to_string(k) << \" \" <<\n-\t\t\t  static_cast<unsigned long>(order) << \" \" <<\n-\t\t\t  static_cast<unsigned long>(native_order),\n-\t\t\t  & r_c,\n-\t\t\t  & r_native_c);\n-  }\n-\n-  const size_type rand_ord =\n-    static_cast<size_t>(m_g.get_unsigned_long(\n-\t\t\t\t\t      0,\n-\t\t\t\t\t      2*  static_cast<unsigned long>(m_m)));\n-\n-  typename cntnr::const_iterator it =\n-    r_c.find_by_order(rand_ord);\n-\n-  typename native_type::const_iterator native_it =\n-    r_native_c.begin();\n-\n-  std::advance(native_it, std::min(rand_ord, r_native_c.size()));\n-\n-  if (it == r_c.end()&&  native_it != r_native_c.end())\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  false,\n-\t\t\t  static_cast<unsigned long>(rand_ord),\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-  if (it != r_c.end()&&  native_it == r_native_c.end())\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  false,\n-\t\t\t  static_cast<unsigned long>(rand_ord),\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-  if (it != r_c.end()&&     native_it != r_native_c.end())\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  test_traits::cmp(*it, * native_it),\n-\t\t\t  static_cast<unsigned long>(rand_ord),\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-prefix_search_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-prefix_search_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    m_alloc.set_throw_prob(0);\n-\n-  const key_type k =\n-    test_traits::generate_key(m_g, m_m);\n-\n-  m_alloc.set_throw_prob(1);\n-\n-  try\n-    {\n-      typedef\n-\tstd::pair<\n-\ttypename Cntnr::const_iterator,\n-\ttypename Cntnr::const_iterator>\n-\tpref_ret_t;\n-\n-      const pref_ret_t pref_ret = r_c.prefix_range(k);\n-\n-      typename native_type::const_iterator native_start_it =\n-\tr_native_c.begin();\n-\n-      while (native_start_it != r_native_c.end()&& \n-\t     !test_traits::prefix_match(\n-\t\t\t\t\tk,\n-\t\t\t\t\ttest_traits::extract_native_key(*native_start_it)))\n-\t++native_start_it;\n-\n-      typename native_type::const_iterator native_end_it =\n-\tnative_start_it;\n-\n-      do\n-        {\n-\t  if (native_end_it != r_native_c.end())\n-\t    ++native_end_it;\n-        }\n-      while (native_end_it != r_native_c.end()&& \n-\t     test_traits::prefix_match(\n-\t\t\t\t       k,\n-\t\t\t\t       test_traits::extract_native_key(*native_end_it)));\n-\n-      it_cmp_imp(            pref_ret.first, pref_ret.second, native_start_it, native_end_it);\n-    }\n-  catch(...)\n-    {\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    false,\n-\t\t\t    \"prefix key \" << k,\n-\t\t\t    & r_c,\n-\t\t\t    & r_native_c);\n-    }\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-\n-PB_DS_CLASS_T_DEC\n-template<typename Const_It, class Const_Native_It>\n-void\n-PB_DS_CLASS_C_DEC::\n-it_cmp_imp(Const_It b, Const_It e, Const_Native_It native_b, Const_Native_It native_e)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    if (std::distance(b, e) != std::distance(native_b, native_e))\n-      {\n-        const size_t dist = std::distance(b, e);\n-\n-        const size_t native_dist = std::distance(native_b, native_e);\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      false,\n-\t\t\t      static_cast<unsigned long>(dist) << \" \"\n-\t\t\t      << static_cast<unsigned long>(native_dist),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-      }\n-\n-  while (b != e)\n-    {\n-      PB_DS_THROW_IF_FAILED(            native_b != native_e, \"\", m_p_c, & m_native_c);\n-\n-      if (!test_traits::cmp(*b, * native_b))\n-\tPB_DS_THROW_IF_FAILED(\n-\t\t\t      false,\n-\t\t\t      test_traits::val_to_string(*b) << \" \" <<\n-\t\t\t      test_traits::val_to_string(*native_b),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-\n-      ++b;\n-      ++native_b;\n-    }\n-\n-  PB_DS_THROW_IF_FAILED(        native_b == native_e, \"\", m_p_c,    & m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-\n-PB_DS_CLASS_T_DEC\n-template<typename Const_It, class Const_Native_It>\n-void\n-PB_DS_CLASS_C_DEC::\n-back_it_cmp_imp(Const_It b, Const_It e, Const_Native_It native_b, Const_Native_It native_e)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    while (b != e)\n-      {\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      native_b != native_e,\n-\t\t\t      test_traits::val_to_string(*native_e),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-\n-        --e;\n-        --native_e;\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      test_traits::cmp(*e, * native_e),\n-\t\t\t      test_traits::val_to_string(*e) <<\n-\t\t\t      test_traits::val_to_string(*native_e),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-      }\n-\n-  PB_DS_THROW_IF_FAILED(\n-\t\t\tnative_b == native_e,\n-\t\t\ttest_traits::val_to_string(*native_e),\n-\t\t\tm_p_c,\n-\t\t\t& m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-lower_bound_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-lower_bound_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    m_alloc.set_throw_prob(0);\n-\n-  const key_type k =\n-    test_traits::generate_key(m_g, m_m);\n-\n-  m_alloc.set_throw_prob(1);\n-\n-  typename cntnr::const_iterator it =    r_c.lower_bound(k);\n-\n-  typename native_type::key_type native_k = test_traits::native_key(k);\n-\n-  typename native_type::const_iterator native_it =\n-    r_native_c.lower_bound(native_k);\n-\n-  if (it != r_c.end()&&  native_it == r_native_c.end())\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  \"\",\n-\t\t\t  \"it: \" + test_traits::val_to_string(*it) + \"\\n\\n\",\n-\t\t\t  & r_c,\n-\t\t\t  & r_native_c);\n-\n-  if (it == r_c.end()&&  native_it != r_native_c.end())\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  \"\",\n-\t\t\t  \"native_it: \" + test_traits::val_to_string(*native_it) + \"\\n\\n\",\n-\t\t\t  & r_c,\n-\t\t\t  & r_native_c);\n-\n-  if (it != r_c.end()&&  !test_traits::cmp(*it, * native_it))\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  false,\n-\t\t\t  \"key: \" + test_traits::key_to_string(k) + \"\\n\\n\" +\n-\t\t\t  \"it: \" + test_traits::val_to_string(*it) + \"\\n\\n\" +\n-\t\t\t  \"native_it: \" + test_traits::val_to_string(*native_it) + \"\\n\\n\",\n-\t\t\t  & r_c,\n-\t\t\t  & r_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-upper_bound_cmp_imp(const Cntnr& /*r_c*/, const native_type& /*r_native_c*/, __gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-upper_bound_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    m_alloc.set_throw_prob(0);\n-\n-  const key_type k =\n-    test_traits::generate_key(m_g, m_m);\n-\n-  m_alloc.set_throw_prob(1);\n-\n-  typename cntnr::const_iterator it =    r_c.upper_bound(k);\n-\n-  typename native_type::key_type native_k = test_traits::native_key(k);\n-\n-  typename native_type::const_iterator native_it =\n-    r_native_c.upper_bound(native_k);\n-\n-  if (it == r_c.end()&&  native_it != r_native_c.end())\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  false,\n-\t\t\t  \"key: \" + test_traits::key_to_string(k) + \"\\n\\n\" +\n-\t\t\t  \"native_it: \" + test_traits::val_to_string(*native_it) + \"\\n\\n\",\n-\t\t\t  & r_c,\n-\t\t\t  & r_native_c);\n-\n-  if (it != r_c.end()&&  native_it == r_native_c.end())\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  false,\n-\t\t\t  \"key: \" + test_traits::key_to_string(k) + \"\\n\\n\" +\n-\t\t\t  \"it: \" + test_traits::val_to_string(*it) + \"\\n\\n\",\n-\t\t\t  & r_c,\n-\t\t\t  & r_native_c);\n-\n-  if (it != r_c.end()&&  !test_traits::cmp(*it, * native_it))\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  false,\n-\t\t\t  \"key: \" + test_traits::key_to_string(k) + \"\\n\\n\" +\n-\t\t\t  \"it: \" + test_traits::val_to_string(*it) + \"\\n\\n\" +\n-\t\t\t  \"native_it: \" + test_traits::val_to_string(*native_it) + \"\\n\\n\",\n-\t\t\t  & r_c,\n-\t\t\t  & r_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }"}, {"sha": "c6b02b61a170cbed7556f487ad5734241b05852b", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/constructor_destructor_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 410, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fconstructor_destructor_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fconstructor_destructor_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fconstructor_destructor_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,410 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file constructor_destructor_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-PB_DS_CLASS_C_DEC::\n-container_rand_regression_test(unsigned long seed, size_t n, size_t m, \n-\t\t\t       double tp, double ip, double ep, double cp, \n-\t\t\t       double mp, bool disp) \n-: m_seed((seed == 0) ? twister_rand_gen::get_time_determined_seed() : seed),\n-  m_n(n), m_m(m), m_tp(tp), m_ip(ip), m_ep(ep), m_cp(cp), m_mp(mp),\n-  m_disp(disp), m_p_c(NULL)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-PB_DS_CLASS_C_DEC::\n-~container_rand_regression_test()\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-default_constructor()\n-{\n-  PB_DS_TRACE(\"default_constructor\");\n-  bool done = true;\n-  m_alloc.set_throw_prob(m_tp);\n-\n-  try\n-    {\n-      m_p_c = new Cntnr;\n-    }\n-  catch(__gnu_cxx::forced_exception_error&)\n-    {\n-      done = false;\n-    }\n-\n-  if (m_p_c != NULL)\n-    PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  return done;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-swap()\n-{\n-  PB_DS_TRACE(\"swap\");\n-  m_alloc.set_throw_prob(0);\n-  Cntnr* p_c = new Cntnr;\n-  m_alloc.set_throw_prob(1);\n-  p_c->swap(*m_p_c);\n-  std::swap(p_c, m_p_c);\n-  delete p_c;\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-copy_constructor()\n-{\n-  PB_DS_TRACE(\"copy_constructor\");\n-  bool done = true;\n-  Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n-\n-  try\n-    {\n-      p_c = new Cntnr(*m_p_c);\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch(__gnu_cxx::forced_exception_error& )\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  return done;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-assignment_operator()\n-{\n-  PB_DS_TRACE(\"assignment operator\");\n-  bool done = true;\n-  Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n-\n-  try\n-    {\n-      p_c = new Cntnr();\n-      * p_c =* m_p_c;\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch(__gnu_cxx::forced_exception_error& )\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  return done;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-it_constructor()\n-{\n-  PB_DS_TRACE(\"it_constructor\");\n-  return it_constructor_imp(typename Cntnr::container_category());\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-it_constructor_imp(__gnu_pbds::cc_hash_tag)\n-{\n-  bool done = true;\n-  Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n-\n-  try\n-    {\n-      switch(get_next_sub_op(8))\n-        {\n-        case 0:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 1:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 2:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n-\t\t\t  m_p_c->get_comb_hash_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 3:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n-\t\t\t  m_p_c->get_comb_hash_fn(),\n-\t\t\t  m_p_c->get_resize_policy());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 4:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end());\n-\t  break;\n-        case 5:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn());\n-\t  break;\n-        case 6:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n-\t\t\t  m_p_c->get_eq_fn());\n-\t  break;\n-        case 7:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n-\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_hash_fn());\n-\t  break;\n-        case 8:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n-\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_hash_fn(),\n-\t\t\t  m_p_c->get_resize_policy());\n-\t  break;\n-        default:\n-\t  PB_DS_THROW_IF_FAILED(false, \"\",  m_p_c, & m_native_c);\n-        };\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch (__gnu_cxx::forced_exception_error&)\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  return done;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-it_constructor_imp(__gnu_pbds::gp_hash_tag)\n-{\n-  bool done = true;\n-  Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n-\n-  try\n-    {\n-      switch(get_next_sub_op(11))\n-        {\n-        case 0:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 1:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 2:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n-\t\t\t  m_p_c->get_comb_probe_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 3:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n-\t\t\t  m_p_c->get_comb_probe_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 4:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n-\t\t\t  m_p_c->get_comb_probe_fn(), m_p_c->get_probe_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 5:\n-\t  p_c = new Cntnr(m_p_c->get_hash_fn(), m_p_c->get_eq_fn(),\n-\t\t\t  m_p_c->get_comb_probe_fn(), m_p_c->get_probe_fn(),\n-\t\t\t  m_p_c->get_resize_policy());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 6:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn());\n-\t  break;\n-        case 7:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n-\t\t\t  m_p_c->get_eq_fn());\n-\t  break;\n-        case 8:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n-\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_probe_fn());\n-\t  break;\n-        case 9:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n-\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_probe_fn());\n-\t  break;\n-        case 10:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n-\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_probe_fn(),\n-\t\t\t  m_p_c->get_probe_fn());\n-\t  break;\n-        case 11:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_hash_fn(),\n-\t\t\t  m_p_c->get_eq_fn(), m_p_c->get_comb_probe_fn(),\n-\t\t\t  m_p_c->get_probe_fn(), m_p_c->get_resize_policy());\n-\t  break;\n-        default:\n-\t  PB_DS_THROW_IF_FAILED(false, \"\",  m_p_c, & m_native_c);\n-        };\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch (__gnu_cxx::forced_exception_error&)\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  return done;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-it_constructor_imp(__gnu_pbds::tree_tag)\n-{\n-  bool done = true;\n-  Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n-\n-  try\n-    {\n-      switch(get_next_sub_op(2))\n-        {\n-        case 0:\n-\t  p_c = new Cntnr(m_p_c->get_cmp_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 1:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_cmp_fn());\n-\t  break;\n-        default:\n-\t  PB_DS_THROW_IF_FAILED(false, \"\",  m_p_c, &m_native_c);\n-        };\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch (__gnu_cxx::forced_exception_error&)\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  return done;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-it_constructor_imp(__gnu_pbds::list_update_tag)\n-{\n-  bool done = true;\n-  Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n-\n-  try\n-    {\n-      p_c = new Cntnr(m_p_c->begin(), m_p_c->end());\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch (__gnu_cxx::forced_exception_error&)\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  return done;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-it_constructor_imp(__gnu_pbds::pat_trie_tag)\n-{\n-  bool done = true;\n-  Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n-\n-  try\n-    {\n-      switch(get_next_sub_op(2))\n-        {\n-        case 0:\n-\t  p_c = new Cntnr(m_p_c->get_e_access_traits());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 1:\n-\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), \n-\t\t\t  m_p_c->get_e_access_traits());\n-\t  break;\n-        default:\n-\t  PB_DS_THROW_IF_FAILED(false, \"\",  m_p_c, & m_native_c);\n-        };\n-\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch (__gnu_cxx::forced_exception_error&)\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  return done;\n-}\n-"}, {"sha": "f3e01d97fac8684b303e3241b8f79de7e2057fb8", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/defs_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fdefs_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fdefs_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fdefs_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,248 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file defs_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-defs()\n-{\n-  // General container types.\n-\n-  typedef typename Cntnr::size_type test_size_type;\n-\n-  typedef typename Cntnr::difference_type difference_type;\n-\n-  key_defs();\n-\n-  mapped_defs();\n-\n-  value_defs();\n-\n-  iterator_defs();\n-\n-  node_iterator_defs(__gnu_pbds::detail::integral_constant<int,\n-\t\t     container_traits::order_preserving>());\n-\n-  policy_defs();\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-key_defs()\n-{\n-  typedef typename Cntnr::key_type test_key_type;\n-\n-  typedef typename Cntnr::key_reference test_key_reference;\n-\n-  typedef typename Cntnr::const_key_reference test_const_key_reference;\n-\n-  typedef typename Cntnr::key_pointer test_key_pointer;\n-\n-  typedef typename Cntnr::const_key_pointer test_const_key_pointer;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-mapped_defs()\n-{\n-  typedef typename Cntnr::mapped_type test_mapped_type;\n-\n-  typedef typename Cntnr::mapped_reference test_mapped_reference;\n-\n-  typedef\n-    typename Cntnr::const_mapped_reference\n-    test_const_mapped_reference;\n-\n-  typedef typename Cntnr::mapped_pointer test_mapped_pointer;\n-\n-  typedef typename Cntnr::const_mapped_pointer test_const_mapped_pointer;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-value_defs()\n-{\n-  typedef typename Cntnr::value_type test_value_type;\n-\n-  typedef typename Cntnr::reference test_reference;\n-\n-  typedef typename Cntnr::const_reference test_const_reference;\n-\n-  typedef typename Cntnr::pointer test_pointer;\n-\n-  typedef typename Cntnr::const_pointer test_const_pointer;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-ds_defs()\n-{\n-  typedef __gnu_pbds::container_traits< Cntnr> test_container_traits;\n-\n-  typedef typename test_container_traits::container_category test_container_category;\n-\n-  typedef\n-    typename test_container_traits::invalidation_guarantee\n-    test_invalidation_guarantee;\n-\n-  enum\n-    {\n-      test_order_preserving =\n-      test_container_traits::order_preserving\n-    };\n-\n-  enum\n-    {\n-      test_erase_can_throw =\n-      test_container_traits::erase_can_throw\n-    };\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-iterator_defs()\n-{\n-  typedef typename Cntnr::point_iterator test_point_iterator;\n-\n-  typedef typename Cntnr::const_point_iterator const_test_point_iterator;\n-\n-  typedef typename Cntnr::iterator test_iterator;\n-\n-  typedef typename Cntnr::const_iterator const_test_iterator;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-node_iterator_defs(__gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-node_iterator_defs(__gnu_pbds::detail::true_type)\n-{\n-  typedef typename Cntnr::node_iterator test_node_iterator;\n-\n-  typedef typename Cntnr::const_node_iterator test_const_node_iterator;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_defs()\n-{\n-  typedef typename Cntnr::allocator_type test_allocator;\n-\n-  policy_defs(typename Cntnr::container_category());\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_defs(__gnu_pbds::basic_hash_tag)\n-{\n-  typedef typename Cntnr::hash_fn test_hash_fn;\n-\n-  typedef typename Cntnr::eq_fn test_eq_fn;\n-\n-  typedef typename Cntnr::resize_policy test_resize_policy;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_defs(__gnu_pbds::cc_hash_tag)\n-{\n-  policy_defs(__gnu_pbds::basic_hash_tag());\n-\n-  typedef typename Cntnr::comb_hash_fn test_comb_hash_fn;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_defs(__gnu_pbds::gp_hash_tag)\n-{\n-  policy_defs(__gnu_pbds::basic_hash_tag());\n-\n-  typedef typename Cntnr::comb_probe_fn test_comb_probe_fn;\n-\n-  typedef typename Cntnr::probe_fn test_probe_fn;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_defs(__gnu_pbds::tree_tag)\n-{\n-  typedef typename Cntnr::cmp_fn test_cmp_fn;\n-\n-  typedef typename Cntnr::node_update test_node_update;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_defs(__gnu_pbds::list_update_tag)\n-{\n-  typedef typename Cntnr::eq_fn test_eq_fn;\n-\n-  typedef typename Cntnr::update_policy test_update_policy;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_defs(__gnu_pbds::pat_trie_tag)\n-{\n-  typedef typename Cntnr::e_access_traits e_access_traits;\n-}"}, {"sha": "0a16482d3a1387e30e85c2255b84cac543d19a6d", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/diagnostic_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fdiagnostic_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fdiagnostic_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fdiagnostic_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,79 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file diagnostic_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-print_container(const native_type& r_cnt, std::ostream& r_os /*= std::cerr*/) const\n-{\n-  m_alloc.set_throw_prob(0);\n-\n-  typename native_type::const_iterator it = r_cnt.begin();\n-\n-  while (it != r_cnt.end())\n-    {\n-      r_os << test_traits::val_to_string(*it) + \"\\n\";\n-\n-      ++it;\n-    }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-print_container(const cntnr& r_cnt, std::ostream& r_os /*= std::cerr*/) const\n-{\n-  m_alloc.set_throw_prob(0);\n-\n-  typename cntnr::const_iterator it = r_cnt.begin();\n-\n-  while (it != r_cnt.end())\n-    {\n-      r_os << test_traits::val_to_string(*it) + \"\\n\";\n-\n-      ++it;\n-    }\n-}"}, {"sha": "0bd39f33bb3d531535e4cbebc7b226e291bde60a", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/erase_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Ferase_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Ferase_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Ferase_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,319 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file erase_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase()\n-{\n-  PB_DS_TRACE(\"erase\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    m_alloc.set_throw_prob(0);\n-\n-  const key_type k =\n-    test_traits::generate_key(m_g, m_m);\n-\n-  m_alloc.set_throw_prob(m_tp);\n-\n-  try\n-    {\n-      const bool cntnd = m_p_c->find(k) != m_p_c->end();\n-\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    cntnd ==(m_native_c.find(test_traits::native_key(k)) != m_native_c.end()),\n-\t\t\t    test_traits::key_to_string(k),\n-\t\t\t    m_p_c,\n-\t\t\t    & m_native_c);\n-\n-      const bool ersd = m_p_c->erase(k);\n-\n-      const bool native_ersd =\n-\tm_native_c.erase(test_traits::native_key(k)) != 0;\n-\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    ersd == native_ersd,\n-\t\t\t    ersd << \" \" << native_ersd,\n-\t\t\t    m_p_c,\n-\t\t\t    & m_native_c);\n-\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    m_p_c->find(k) == m_p_c->end(),\n-\t\t\t    \"\",\n-\t\t\t    m_p_c,\n-\t\t\t    & m_native_c);\n-    }\n-  catch(__gnu_cxx::forced_exception_error& )\n-    {\n-      done = false;\n-\n-      PB_DS_THROW_IF_FAILED(            container_traits::erase_can_throw, container_traits::erase_can_throw, m_p_c, & m_native_c);\n-    }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_if()\n-{\n-  PB_DS_TRACE(\"erase_if\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        typedef\n-\t  typename std::iterator_traits<\n-\t  typename cntnr::iterator>::reference\n-\t  it_const_reference;\n-\n-        typedef\n-\t  typename test_traits::template erase_if_fn<\n-\t  value_type>\n-\t  erase_if_fn_t;\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        const size_t ersd =\n-\t  m_p_c->erase_if(erase_if_fn_t());\n-\n-        const size_t native_ersd =\n-\t  test_traits::erase_if(m_native_c);\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      ersd == native_ersd,\n-\t\t\t      static_cast<unsigned long>(ersd) << \" \" <<\n-\t\t\t      static_cast<unsigned long>(native_ersd),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-\n-        PB_DS_THROW_IF_FAILED(            container_traits::erase_can_throw, container_traits::erase_can_throw, m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_it()\n-{\n-  enum\n-    {\n-      erase_iterators =\n-      container_traits::order_preserving\n-    };\n-\n-  return (erase_it_imp(__gnu_pbds::detail::integral_constant<int,erase_iterators>()));\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_it_imp(__gnu_pbds::detail::false_type)\n-{\n-  return (true);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_it_imp(__gnu_pbds::detail::true_type)\n-{\n-  PB_DS_TRACE(\"erase_it\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-\n-        const key_type k =\n-\t  test_traits::generate_key(m_g, m_m);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        typename cntnr::iterator found_it = m_p_c->find(k);\n-\n-        typename native_type::iterator native_it = m_native_c.find(\n-\t\t\t\t\t\t\t\t   test_traits::native_key(k));\n-\n-        const bool found = found_it != m_p_c->end();\n-        const bool native_found = native_it != m_native_c.end();\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      found == native_found,\n-\t\t\t      found << \" \" <<    native_found,\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-\n-        typename cntnr::const_iterator next_it = found_it;\n-        if (next_it != m_p_c->end())\n-\t  ++next_it;\n-\n-        typename cntnr::iterator next_ers_it =\n-\t  m_p_c->erase(found_it);\n-\n-        if (native_it != m_native_c.end())\n-\t  m_native_c.erase(native_it);\n-\n-        bool range_guarantee =\n-\t  __gnu_pbds::detail::is_same<\n-\t  typename container_traits::invalidation_guarantee,\n-\t  __gnu_pbds::range_invalidation_guarantee>::value ;\n-\n-        if (range_guarantee)\n-\t  PB_DS_THROW_IF_FAILED(                next_ers_it == next_it,  \"\",  m_p_c, & m_native_c);\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-\n-        PB_DS_THROW_IF_FAILED(            container_traits::erase_can_throw, container_traits::erase_can_throw, m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_rev_it()\n-{\n-  enum\n-    {\n-      erase_iterators =\n-      container_traits::order_preserving&& \n-      container_traits::reverse_iteration\n-    };\n-\n-  return (erase_rev_it_imp(__gnu_pbds::detail::integral_constant<int,erase_iterators>()));\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_rev_it_imp(__gnu_pbds::detail::false_type)\n-{\n-  return (true);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_rev_it_imp(__gnu_pbds::detail::true_type)\n-{\n-  PB_DS_TRACE(\"erase_rev_it\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-\n-        const key_type k =\n-\t  test_traits::generate_key(m_g, m_m);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        typename cntnr::iterator found_it = m_p_c->find(k);\n-\n-        typename native_type::iterator native_it = m_native_c.find(\n-\t\t\t\t\t\t\t\t   test_traits::native_key(k));\n-\n-        typename cntnr::const_reverse_iterator next_it = found_it;\n-        if (next_it != m_p_c->end())\n-\t  ++next_it;\n-\n-        typename cntnr::reverse_iterator next_ers_it =\n-\t  m_p_c->erase((typename cntnr::reverse_iterator)found_it);\n-\n-        PB_DS_THROW_IF_FAILED(            next_ers_it == next_it, \"\", m_p_c, & m_native_c);\n-\n-        if (native_it != m_native_c.end())\n-\t  m_native_c.erase(native_it);\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-\n-        PB_DS_THROW_IF_FAILED(            container_traits::erase_can_throw, container_traits::erase_can_throw, m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-"}, {"sha": "adc87271c251807615952ad2f04e68d529335f8c", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/get_set_load_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fget_set_load_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fget_set_load_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fget_set_load_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,102 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file get_set_load_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-get_set_load()\n-{\n-  typedef\n-    __gnu_pbds::detail::integral_constant<int,\n-    test_traits::get_set_load>\n-    get_set_load_ind;\n-\n-  get_set_load_imp(get_set_load_ind());\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-get_set_load_imp(__gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-get_set_load_imp(__gnu_pbds::detail::true_type)\n-{\n-  PB_DS_TRACE(\"get_set_load\");\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    m_p_c->get_load();\n-\n-  m_alloc.set_throw_prob(1);\n-\n-  typename alloc_t::group_throw_prob_adjustor adjust(\n-\t\t\t\t\t\t     m_p_c->size());\n-\n-  const float min_load = static_cast<float>(0.05);\n-  const float max_load = static_cast<float>(0.9);\n-\n-  const float new_load =\n-    static_cast<float>(\n-\t\t       m_g.get_prob()*  (max_load - min_load) +\n-\t\t       min_load);\n-\n-  m_p_c->set_load(new_load);\n-\n-  PB_DS_THROW_IF_FAILED(\n-\t\t\tm_p_c->get_load() == new_load,\n-\t\t\t\"\",\n-\t\t\tm_p_c,\n-\t\t\t& m_native_c);\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-"}, {"sha": "10ea2aed9417aebac41e922d2aa0a21f7c815838", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/get_set_loads_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fget_set_loads_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fget_set_loads_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fget_set_loads_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,122 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file get_set_loads_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-get_set_loads()\n-{\n-  typedef\n-    __gnu_pbds::detail::integral_constant<int,\n-    test_traits::get_set_loads>\n-    get_set_loads_ind;\n-\n-  return (get_set_loads_imp(get_set_loads_ind()));\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-get_set_loads_imp(__gnu_pbds::detail::false_type)\n-{\n-  return (true);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-get_set_loads_imp(__gnu_pbds::detail::true_type)\n-{\n-  PB_DS_TRACE(\"get_set_loads\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    const std::pair<float, float> old_loads =\n-    m_p_c->get_loads();\n-\n-  try\n-    {\n-      m_alloc.set_throw_prob(m_tp);\n-\n-      typename alloc_t::group_throw_prob_adjustor adjust(\n-\t\t\t\t\t\t\t m_p_c->size());\n-\n-      const float min_min_load = static_cast<float>(0.05);\n-      const float max_min_load = static_cast<float>(0.2);\n-\n-      const float new_min_load =\n-\tstatic_cast<float>(\n-\t\t\t   m_g.get_prob()*  (max_min_load - min_min_load) +\n-\t\t\t   min_min_load);\n-\n-      const float new_max_load = static_cast<float>(new_min_load*  2.5);\n-\n-      PB_DS_THROW_IF_FAILED(            new_max_load < 1, new_max_load, m_p_c, & m_native_c);\n-\n-      m_p_c->set_loads(\n-\t\t       std::make_pair(                new_min_load,  new_max_load));\n-    }\n-  catch(...)\n-    {\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    old_loads == m_p_c->get_loads(),\n-\t\t\t    old_loads.first << \" \" << old_loads.second << \" \" <<\n-\t\t\t    m_p_c->get_loads().first << \" \" <<\n-\t\t\t    m_p_c->get_loads().second,\n-\t\t\t    m_p_c,\n-\t\t\t    & m_native_c);\n-\n-      done = false;\n-    }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}"}, {"sha": "e5bf3be35b05842dad367d06cc6a480de1f570ef", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/insert_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Finsert_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Finsert_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Finsert_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,89 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file insert_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-insert()\n-{\n-  PB_DS_TRACE(\"insert\");\n-  bool done = true;\n-  PB_DS_SET_DESTRUCT_PRINT\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-        value_type v = test_traits::generate_value(m_g, m_m);\n-        m_alloc.set_throw_prob(m_tp);\n-        const_key_reference r_k = test_traits::extract_key(v);\n-        typename cntnr::const_point_iterator found_it = m_p_c->find(r_k);\n-        const bool existed = (found_it != m_p_c->end());\n-        const std::pair<typename cntnr::point_iterator, bool> ins_ret = m_p_c->insert(v);\n-\n-        if (ins_ret.second)\n-\t  {\n-            PB_DS_THROW_IF_FAILED(!existed, \"\", m_p_c, &m_native_c);\n-\t  }\n-        else\n-\t  {\n-            PB_DS_THROW_IF_FAILED(existed, \"\", m_p_c, &m_native_c);\n-            PB_DS_THROW_IF_FAILED(found_it == ins_ret.first, \"\", m_p_c, &m_native_c);\n-\t  }\n-        m_native_c.insert(test_traits::native_value(v));\n-      }\n-    catch(__gnu_cxx::forced_exception_error&)\n-      {\n-        done = false;\n-      }\n-    catch(__gnu_pbds::insert_error&)\n-      {\n-        PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    return (done);\n-}\n-"}, {"sha": "2a3c6396e8a42eec18c59cce237af3aa36d957b7", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/it_conversion_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 307, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fit_conversion_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fit_conversion_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fit_conversion_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,307 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file it_conversion_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-it_copy()\n-{\n-  {\n-    typename cntnr::iterator it = m_p_c->end();\n-\n-    typename cntnr::const_iterator const_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            const_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::const_point_iterator const_find_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::point_iterator find_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-\n-  {\n-    typename cntnr::const_iterator const_it = m_p_c->end();\n-\n-    typename cntnr::const_point_iterator const_find_it(const_it);\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == const_it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != const_it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-\n-  {\n-    typename cntnr::point_iterator find_it = m_p_c->end();\n-\n-    typename cntnr::const_point_iterator const_find_it(find_it);\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == const_find_it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != const_find_it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-it_assign()\n-{\n-  {\n-    typename cntnr::iterator it = m_p_c->end();\n-\n-    typename cntnr::const_iterator const_it;\n-    const_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            const_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::const_point_iterator const_find_it;\n-    const_find_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::point_iterator find_it;\n-    find_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-\n-  {\n-    typename cntnr::const_iterator const_it = m_p_c->end();\n-\n-    typename cntnr::const_point_iterator const_find_it;\n-    const_find_it = const_it;\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == const_it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != const_it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-\n-  {\n-    typename cntnr::point_iterator find_it = m_p_c->end();\n-\n-    typename cntnr::const_point_iterator const_find_it;\n-    const_find_it = find_it;\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == const_find_it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != const_find_it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-rev_it_copy()\n-{\n-  enum\n-    {\n-      reverse_iteration = container_traits::reverse_iteration\n-    };\n-\n-  rev_it_copy_imp(__gnu_pbds::detail::integral_constant<int,reverse_iteration>());\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-rev_it_assign()\n-{\n-  enum\n-    {\n-      reverse_iteration = container_traits::reverse_iteration\n-    };\n-\n-  rev_it_assign_imp(__gnu_pbds::detail::integral_constant<int,reverse_iteration>());\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-rev_it_copy_imp(__gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-rev_it_copy_imp(__gnu_pbds::detail::true_type)\n-{\n-  {\n-    typename cntnr::iterator it = m_p_c->end();\n-\n-    typename cntnr::const_reverse_iterator const_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            const_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::const_point_iterator const_find_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::point_iterator find_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-rev_it_assign_imp(__gnu_pbds::detail::false_type)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-rev_it_assign_imp(__gnu_pbds::detail::true_type)\n-{\n-  {\n-    typename cntnr::iterator it = m_p_c->end();\n-\n-    typename cntnr::const_reverse_iterator const_it;\n-    const_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            const_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::const_point_iterator const_find_it;\n-    const_find_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::point_iterator find_it;\n-    find_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-}"}, {"sha": "8c11f765766d605c0384bbb0a696cd5c9be1f200", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/operator_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Foperator_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Foperator_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Foperator_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,246 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file operator_fn_imps.hpp\n- * Contains a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-operator()()\n-{\n-  typedef xml_result_set_regression_formatter formatter_type;\n-  formatter_type* p_fmt = NULL;\n-\n-  if (m_disp)\n-    p_fmt = new formatter_type(string_form<Cntnr>::name(),\n-\t\t\t       string_form<Cntnr>::desc());\n-\n-  m_g.init(m_seed);\n-\n-  // Track allocation from this point only.\n-  const size_t memory_label = 775;\n-  m_alloc.init(m_seed);\n-  m_alloc.set_label(memory_label);  \n-\n-  prog_bar pb(m_n, std::cout, m_disp);\n-  m_i = 0;\n-\n-  try\n-    {\n-      for (m_i = 0; m_i < m_n; ++m_i)\n-        {\n-\t  PB_DS_TRACE(\"Op #\" << static_cast<unsigned long>(m_i));\n-\t  allocator_type::set_label(m_i);\n-\t  switch (m_i)\n-            {\n-            case 0:\n-\t      PB_DS_RUN_MTHD(default_constructor);\n-\t      break;\n-            case 1:\n-\t      defs();\n-\t      break;\n-            case 2:\n-\t      policy_access();\n-\t      break;\n-            case 3:\n-\t      it_copy();\n-\t      break;\n-            case 4:\n-\t      it_assign();\n-\t      break;\n-            case 5:\n-\t      rev_it_copy();\n-\t      break;\n-            case 6:\n-\t      rev_it_assign();\n-\t      break;\n-            default:\n-\t      switch(get_next_op())\n-                {\n-                case insert_op:\n-\t\t  switch(get_next_sub_op(2))\n-                    {\n-                    case 0:\n-\t\t      PB_DS_RUN_MTHD(insert)\n-                        break;\n-                    case 1:\n-\t\t      PB_DS_RUN_MTHD(subscript)\n-                        break;\n-                    default:\n-\t\t      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-                    }\n-\t\t  break;\n-                case erase_op:\n-\t\t  switch(get_next_sub_op(4))\n-                    {\n-                    case 0:\n-\t\t      PB_DS_RUN_MTHD(erase)\n-                        break;\n-                    case 1:\n-\t\t      PB_DS_RUN_MTHD(erase_if)\n-                        break;\n-                    case 2:\n-\t\t      PB_DS_RUN_MTHD(erase_it)\n-                        break;\n-                    case 3:\n-\t\t      PB_DS_RUN_MTHD(erase_rev_it)\n-                        break;\n-                    default:\n-\t\t      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-                    }\n-\t\t  break;\n-                case clear_op:\n-\t\t  PB_DS_RUN_MTHD(clear)\n-                    break;\n-                case other_op:\n-\t\t  switch(get_next_sub_op(8))\n-                    {\n-                    case 0:\n-\t\t      swap();\n-\t\t      break;\n-                    case 1:\n-\t\t      PB_DS_RUN_MTHD(copy_constructor)\n-                        break;\n-                    case 2:\n-\t\t      PB_DS_RUN_MTHD(it_constructor)\n-                        break;\n-                    case 3:\n-\t\t      PB_DS_RUN_MTHD(assignment_operator)\n-                        break;\n-                    case 4:\n-\t\t      PB_DS_RUN_MTHD(split_join)\n-                        break;\n-                    case 5:\n-\t\t      resize();\n-\t\t      break;\n-                    case 6:\n-\t\t      get_set_load();\n-\t\t      break;\n-                    case 7:\n-\t\t      get_set_loads();\n-\t\t      break;\n-                    default:\n-\t\t      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-                    }\n-\t\t  break;\n-                default:\n-\t\t  PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-                };\n-            }\n-\n-\t  pb.inc();\n-        }\n-    }\n-  catch (...)\n-    {\n-      std::cerr << \"Failed at index \" << static_cast<unsigned long>(m_i) \n-\t\t<< std::endl;\n-      delete m_p_c;\n-      throw;\n-    }\n-\n-  // Clean up, then check for allocation by special label, set above.\n-  delete m_p_c;\n-\n-  try \n-    { m_alloc.check_allocated(memory_label); }\n-  catch (...)\n-    {\n-      std::cerr << \"detected leaks!\" << std::endl;\n-      std::cerr << m_alloc << std::endl;\n-      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-    }\n-\n-  // Reset throw probability.\n-  m_alloc.set_throw_prob(0);\n-\n-  if (m_disp)\n-    {\n-      std::cout << std::endl;\n-      delete p_fmt;\n-    }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-typename PB_DS_CLASS_C_DEC::op\n-PB_DS_CLASS_C_DEC::\n-get_next_op()\n-{\n-  const double prob = m_g.get_prob();\n-\n-  if (prob < m_ip)\n-    return insert_op;\n-\n-  if (prob < m_ip + m_ep)\n-    return erase_op;\n-\n-  if (prob < m_ip + m_ep + m_cp)\n-    return clear_op;\n-\n-  PB_DS_THROW_IF_FAILED(prob <= 1, prob, m_p_c, &m_native_c);\n-\n-  return other_op;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-size_t\n-PB_DS_CLASS_C_DEC::\n-get_next_sub_op(size_t max)\n-{\n-  const double p = m_g.get_prob();\n-  const double delta = 1 / static_cast<double>(max);\n-  size_t i = 0;\n-  while (true)\n-    if (p <= (i + 1) * delta)\n-      {\n-\tPB_DS_THROW_IF_FAILED(i < max,\n-\t\t\t      static_cast<unsigned long>(i) << \" \" <<\n-\t\t\t      static_cast<unsigned long>(max),\n-\t\t\t      m_p_c, &m_native_c);\n-\n-\treturn i;\n-      }\n-    else\n-      ++i;\n-}"}, {"sha": "9b4f0927f6f0049bd22be3323befdef3a2624655", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/policy_access_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fpolicy_access_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fpolicy_access_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fpolicy_access_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,184 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file policy_access_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_access()\n-{\n-  policy_access(typename Cntnr::container_category());\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_access(__gnu_pbds::basic_hash_tag)\n-{\n-  {\n-    typename Cntnr::hash_fn& r_t =\n-      m_p_c->get_hash_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-  {\n-    const typename Cntnr::hash_fn& r_t =((const Cntnr& )*m_p_c).get_hash_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-\n-  {\n-    typename Cntnr::eq_fn& r_t =\n-      m_p_c->get_eq_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-  {\n-    const typename Cntnr::eq_fn& r_t =((const Cntnr& )*m_p_c).get_eq_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-\n-  {\n-    typename Cntnr::resize_policy& r_t =\n-      m_p_c->get_resize_policy();\n-\n-    assert(&r_t != NULL);\n-  }\n-  {\n-    const typename Cntnr::resize_policy& r_t =((const Cntnr& )*m_p_c).get_resize_policy();\n-\n-    assert(&r_t != NULL);\n-  }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_access(__gnu_pbds::cc_hash_tag)\n-{\n-  policy_access(__gnu_pbds::basic_hash_tag());\n-\n-  {\n-    typename Cntnr::comb_hash_fn& r_t =\n-      m_p_c->get_comb_hash_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-  {\n-    const typename Cntnr::comb_hash_fn& r_t =((const Cntnr& )*m_p_c).get_comb_hash_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_access(__gnu_pbds::gp_hash_tag)\n-{\n-  policy_access(__gnu_pbds::basic_hash_tag());\n-\n-  {\n-    typename Cntnr::comb_probe_fn& r_t =\n-      m_p_c->get_comb_probe_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-  {\n-    const typename Cntnr::comb_probe_fn& r_t =((const Cntnr& )*m_p_c).get_comb_probe_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-\n-  {\n-    typename Cntnr::probe_fn& r_t =\n-      m_p_c->get_probe_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-  {\n-    const typename Cntnr::probe_fn& r_t =((const Cntnr& )*m_p_c).get_probe_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_access(__gnu_pbds::tree_tag)\n-{\n-  {\n-    typename Cntnr::cmp_fn& r_t =\n-      m_p_c->get_cmp_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-\n-  {\n-    const typename Cntnr::cmp_fn& r_t =((const Cntnr& )*m_p_c).get_cmp_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_access(__gnu_pbds::list_update_tag)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_access(__gnu_pbds::pat_trie_tag)\n-{\n-  typename Cntnr::e_access_traits& r_t =\n-    m_p_c->get_e_access_traits();\n-\n-  assert(&r_t != NULL);\n-}\n-"}, {"sha": "77bfcb84c39cbccebed88e747cec1611eede46b0", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/resize_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fresize_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fresize_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fresize_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,125 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file resize_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-resize()\n-{\n-  typedef __gnu_pbds::detail::integral_constant<int, test_traits::resize> resize_ind;\n-\n-  return (resize_imp(resize_ind()));\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-resize_imp(__gnu_pbds::detail::false_type)\n-{\n-  return (true);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-resize_imp(__gnu_pbds::detail::true_type)\n-{\n-  PB_DS_TRACE(\"resize\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    const size_t old_size =\n-    m_p_c->get_actual_size();\n-\n-  try\n-    {\n-      m_alloc.set_throw_prob(m_tp);\n-\n-      typename alloc_t::group_throw_prob_adjustor\n-\tadjust(m_p_c->size());\n-\n-      enum\n-        {\n-\t  min_new_size = 200,\n-\t  max_new_size = 2000\n-        };\n-\n-      const size_t new_size =\n-\tm_g.get_unsigned_long(min_new_size, max_new_size);\n-\n-      m_p_c->resize(new_size);\n-\n-      const size_t actual_new_size =\n-\tm_p_c->get_actual_size();\n-\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    actual_new_size >= new_size,\n-\t\t\t    static_cast<unsigned long>(actual_new_size) << \" \" <<\n-\t\t\t    static_cast<unsigned long>(new_size),\n-\t\t\t    m_p_c,\n-\t\t\t    & m_native_c);\n-    }\n-  catch(...)\n-    {\n-      PB_DS_THROW_IF_FAILED(\n-\t\t\t    m_p_c->get_actual_size() == old_size,\n-\t\t\t    static_cast<unsigned long>(m_p_c->get_actual_size()) <<\n-\t\t\t    \" \" << static_cast<unsigned long>(old_size),\n-\t\t\t    m_p_c,\n-\t\t\t    & m_native_c);\n-\n-      done = false;\n-    }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-"}, {"sha": "8026d7cc2003310f9a2fb18bcb319b51ae6f815c", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/split_join_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fsplit_join_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fsplit_join_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fsplit_join_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,149 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file split_join_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-split_join()\n-{\n-  enum\n-    {\n-      split_join = container_traits::order_preserving\n-    };\n-\n-  return (split_join_imp(__gnu_pbds::detail::integral_constant<int,split_join>()));\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-split_join_imp(__gnu_pbds::detail::false_type)\n-{\n-  return (true);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-split_join_imp(__gnu_pbds::detail::true_type)\n-{\n-  PB_DS_TRACE(\"split_join\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-\n-        Cntnr lhs(*m_p_c);\n-\n-        Cntnr rhs;\n-\n-        native_type native_lhs(m_native_c);\n-\n-        native_type native_rhs;\n-\n-        const key_type k =\n-\t  test_traits::generate_key(m_g, m_m);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        lhs.split(k, rhs);\n-\n-        typename native_type::const_iterator it =\n-\t  native_lhs.upper_bound(test_traits::native_key(k));\n-\n-        while (!native_lhs.empty()&&  it != native_lhs.end())\n-\t  {\n-            native_rhs.insert(*it);\n-\n-            typename native_type::const_iterator next_it = it;\n-            ++next_it;\n-\n-            native_lhs.erase(test_traits::extract_native_key(*it));\n-\n-            it = next_it;\n-\t  }\n-\n-        PB_DS_COND_COMPARE(lhs, native_lhs);\n-        PB_DS_COND_COMPARE(rhs, native_rhs);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        if (m_g.get_prob() < 0.5)\n-\t  lhs.swap(rhs);\n-\n-        lhs.join(rhs);\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      rhs.size() == 0,\n-\t\t\t      static_cast<unsigned long>(rhs.size()),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      rhs.empty(),\n-\t\t\t      static_cast<unsigned long>(rhs.size()),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-\n-        m_p_c->swap(lhs);\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-\n-        PB_DS_THROW_IF_FAILED(            container_traits::split_join_can_throw, container_traits::split_join_can_throw, m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}"}, {"sha": "e627595d728f6db5cbcba42453c2583852d4f1aa", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/detail/subscript_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fsubscript_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fsubscript_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fdetail%2Fsubscript_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,127 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file subscript_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-subscript()\n-{\n-  PB_DS_TRACE(\"subscript\");\n-\n-  enum\n-    {\n-      no_data = __gnu_pbds::detail::is_same<\n-      typename Cntnr::const_key_reference,\n-      typename Cntnr::const_reference>::value\n-    };\n-\n-  return (subscript_imp(__gnu_pbds::detail::integral_constant<int,no_data>()));\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-subscript_imp(__gnu_pbds::detail::false_type)\n-{\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-\n-        value_type v = test_traits::generate_value(m_g, m_m);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\t(*m_p_c)[v.first] = v.second;\n-\n-        m_native_c[test_traits::native_value(v).first] =\n-\t  test_traits::native_value(v).second;\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-subscript_imp(__gnu_pbds::detail::true_type)\n-{\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-\n-        value_type v = test_traits::generate_value(m_g, m_m);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\t(*m_p_c)[v] = __gnu_pbds::null_mapped_type();\n-\n-        m_native_c.insert(test_traits::native_value(v));\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}"}, {"sha": "882d62b65696d65005f455183a49423771f80a73", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/rand_regression_test.hpp", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Frand_regression_test.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Frand_regression_test.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Frand_regression_test.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -49,11 +49,11 @@\n \n #include <iostream>\n #include <vector>\n-#include <regression/rand/assoc/container_rand_regression_test.hpp>\n+#include <regression/rand/assoc/container_rand_regression_test.h>\n #include <io/verified_cmd_line_input.hpp>\n #include <common_type/assoc/common_type.hpp>\n #include <regression/basic_type.hpp>\n-#include <regression/assoc/common_type.hpp>\n+#include <regression/common_type.hpp>\n \n namespace __gnu_pbds\n {\n@@ -111,7 +111,7 @@ namespace detail\n     // Sane defaults.\n     size_t n = iter;\n     size_t m = keys;\n-    size_t sd = 0; // 0 = time-determined arbitrary\n+    size_t sd = twister_rand_gen::get_time_determined_seed();\n     double tp = 0.2;\n     double ip = 0.6;\n     double ep = 0.2; \n@@ -133,12 +133,10 @@ namespace detail\n \treturn -2;\n       };\n \n+    // XXX RAII, constructor takes bool for display\n     xml_test_rand_regression_formatter* p_fmt = NULL;\n-    if (sd == 0)\n-      sd = twister_rand_gen::get_time_determined_seed();\n     if (disp)\n-      p_fmt = new xml_test_rand_regression_formatter(sd, n, m, tp, ip, \n-\t\t\t\t\t\t     ep, cp, mp);\n+      p_fmt = new xml_test_rand_regression_formatter(sd, n, m, tp, ip, ep, cp, mp);\n \n     try\n       {\n@@ -174,12 +172,12 @@ namespace detail\n     cerr << \"*  Performs the same operation on an cntnr object\" << endl;\n     cerr << \"*  Possibly compares the container to the cntnr object\" << endl;\n     cerr << \"*  Checks that exceptions (thrown by an allocator) \"\n-      \"do not violate exception guarantees\";\n+      \t    \"do not violate exception guarantees\";\n \n     cerr << endl << endl;\n \n-    cerr << \"sd = seed for random-number generator; 0 = \"\n-      \"time determined value\" << endl;\n+    cerr << \"sd = seed for random-number generator; \"\n+            \"0 = time determined value\" << endl;\n     cerr << \"n = number of iterations\" << endl;\n     cerr << \"m = number of distinct values\" << endl;\n     cerr << \"tp = probability that an exception will be actively thrown\" << endl;"}, {"sha": "db9ed28efb8bafea736193eec6a2c3a584c37eb7", "filename": "libstdc++-v3/testsuite/util/regression/rand/io/assoc/xml_formatter.hpp", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fio%2Fassoc%2Fxml_formatter.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fio%2Fassoc%2Fxml_formatter.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fio%2Fassoc%2Fxml_formatter.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,81 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file xml_formatter.hpp\n- * Contains an XML formatter for regression tests.\n- */\n-\n-#ifndef PB_DS_XML_TEST_REGRESSION_FORMATTER_HPP\n-#define PB_DS_XML_TEST_REGRESSION_FORMATTER_HPP\n-\n-#include <regression/rand/io/xml_formatter.hpp>\n-\n-namespace __gnu_pbds\n-{\n-\n-  namespace test\n-  {\n-\n-    class xml_test_rand_regression_formatter : public xml_test_formatter\n-    {\n-    public:\n-      xml_test_rand_regression_formatter(size_t sd, size_t n, size_t m, double tp, double ip, double ep, double cp, double mp);\n-    };\n-\n-    xml_test_rand_regression_formatter::\n-    xml_test_rand_regression_formatter(size_t sd, size_t n, size_t m, double tp, double ip, double ep, double cp, double mp)\n-    {\n-      std::cout << make_xml_tag(\"sd\", \"value\", sd);\n-      std::cout << make_xml_tag(\"n\", \"value\", n);\n-      std::cout << make_xml_tag(\"m\", \"value\", m);\n-      std::cout << make_xml_tag(\"tp\", \"value\", tp);\n-      std::cout << make_xml_tag(\"ip\", \"value\", ip);\n-      std::cout << make_xml_tag(\"ep\", \"value\", ep);\n-      std::cout << make_xml_tag(\"cp\", \"value\", cp);\n-      std::cout << make_xml_tag(\"mp\", \"value\", mp);\n-    }\n-\n-  } // namespace test\n-\n-} // namespace __gnu_pbds\n-\n-#endif // #ifndef PB_DS_XML_TEST_REGRESSION_FORMATTER_HPP"}, {"sha": "af6f5d242b9d5dba2c187b0b5879e5c6ec3ac662", "filename": "libstdc++-v3/testsuite/util/regression/rand/io/priority_queue/xml_formatter.hpp", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fio%2Fpriority_queue%2Fxml_formatter.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fio%2Fpriority_queue%2Fxml_formatter.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fio%2Fpriority_queue%2Fxml_formatter.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,82 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file xml_formatter.hpp\n- * Contains an XML formatter for regression tests.\n- */\n-\n-#ifndef PB_DS_XML_TEST_REGRESSION_FORMATTER_HPP\n-#define PB_DS_XML_TEST_REGRESSION_FORMATTER_HPP\n-\n-#include <regression/rand/io/xml_formatter.hpp>\n-\n-namespace __gnu_pbds\n-{\n-\n-  namespace test\n-  {\n-\n-    class xml_test_rand_regression_formatter : public xml_test_formatter\n-    {\n-    public:\n-      xml_test_rand_regression_formatter(size_t sd, size_t n, size_t m, double tp, double ip, double dp, double ep, double cp, double mp);\n-    };\n-\n-    xml_test_rand_regression_formatter::\n-    xml_test_rand_regression_formatter(size_t sd, size_t n, size_t m, double tp, double ip, double dp, double ep, double cp, double mp)\n-    {\n-      std::cout << make_xml_tag(\"sd\", \"value\", sd);\n-      std::cout << make_xml_tag(\"n\", \"value\", n);\n-      std::cout << make_xml_tag(\"m\", \"value\", m);\n-      std::cout << make_xml_tag(\"tp\", \"value\", tp);\n-      std::cout << make_xml_tag(\"ip\", \"value\", ip);\n-      std::cout << make_xml_tag(\"dp\", \"value\", dp);\n-      std::cout << make_xml_tag(\"ep\", \"value\", ep);\n-      std::cout << make_xml_tag(\"cp\", \"value\", cp);\n-      std::cout << make_xml_tag(\"mp\", \"value\", mp);\n-    }\n-\n-  } // namespace test\n-\n-} // namespace __gnu_pbds\n-\n-#endif // #ifndef PB_DS_XML_TEST_REGRESSION_FORMATTER_HPP"}, {"sha": "fe22c0c6efa4096e3e5f652937fde04a5630eade", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/container_rand_regression_test.h", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.h?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -0,0 +1,275 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n+\n+// Permission to use, copy, modify, sell, and distribute this software\n+// is hereby granted without fee, provided that the above copyright\n+// notice appears in all copies, and that both that copyright notice\n+// and this permission notice appear in supporting documentation. None\n+// of the above authors, nor IBM Haifa Research Laboratories, make any\n+// representation about the suitability of this software for any\n+// purpose. It is provided \"as is\" without express or implied\n+// warranty.\n+\n+/**\n+ * @file container_rand_regression_test.h\n+ * Contains a random regression test for a specific container type.\n+ */\n+\n+#ifndef PB_DS_CONTAINER_RAND_REGRESSION_TEST_H\n+#define PB_DS_CONTAINER_RAND_REGRESSION_TEST_H\n+\n+#include <algorithm>\n+#include <string>\n+#include <sstream>\n+#include <utility>\n+#include <cassert>\n+#include <regression/basic_type.hpp>\n+#include <ext/pb_ds/priority_queue.hpp>\n+#include <io/prog_bar.hpp>\n+#include <testsuite_rng.h>\n+#include <common_type/priority_queue/string_form.hpp>\n+#include <regression/rand/xml_formatter.hpp>\n+#include <regression/trait/priority_queue/trait.hpp>\n+\n+namespace __gnu_pbds\n+{\n+namespace test\n+{\n+namespace detail\n+{\n+  // Rand test specialized for a specific container.\n+  template<typename Cntnr>\n+    class container_rand_regression_test\n+    {\n+    private:\n+      typedef Cntnr \t\t\t\t\t\tcntnr;\n+      typedef typename cntnr::allocator_type \t\t\tallocator_type;\n+      typedef typename cntnr::size_type \t\t\tsize_type;\n+      typedef twister_rand_gen \t\t\t\t\tgen;\n+      typedef basic_type \t\t\t\t\tvalue_type;\n+      typedef native_priority_queue<std::string, true>\t\tnative_type;\n+      typedef regression_test_traits<cntnr> \t\t\ttest_traits;\n+\n+      enum op\n+\t{\n+\t  insert_op,\n+\t  modify_op,\n+\t  erase_op,\n+\t  clear_op,\n+\t  other_op\n+\t};\n+\n+      op\n+      get_next_op();\n+\n+      size_t\n+      get_next_sub_op(size_t max);\n+\n+      static void\n+      defs();\n+\n+      static void\n+      value_defs();\n+\n+      static void\n+      ds_defs();\n+\n+      static void\n+      iterator_defs();\n+\n+      static void\n+      policy_defs();\n+\n+      void\n+      policy_access();\n+\n+      void\n+      it_copy();\n+\n+      void\n+      it_assign();\n+\n+      bool\n+      default_constructor();\n+\n+      void\n+      swap();\n+\n+      bool\n+      copy_constructor();\n+\n+      bool\n+      assignment_operator();\n+\n+      bool\n+      it_constructor();\n+\n+      bool\n+      push();\n+\n+      bool\n+      modify();\n+\n+      bool\n+      pop();\n+\n+      bool\n+      erase_if();\n+\n+      bool\n+      erase_it();\n+\n+      bool\n+      clear();\n+\n+      bool\n+      split_join();\n+\n+      void\n+      cmp(const Cntnr& r_container, const native_type& r_native_c, \n+\t  const std::string& r_call_fn);\n+\n+      void\n+      print_container(const native_type& r_cnt, \n+\t\t      std::ostream& r_os = std::cerr) const;\n+\n+      void\n+      print_container(const cntnr& r_cnt, \n+\t\t      std::ostream& r_os = std::cerr) const;\n+\n+      struct destructor_printer\n+      {\n+\tdestructor_printer(const std::string& r_msg) \n+\t: m_msg(r_msg), m_print(true) { }\n+\n+\tvoid\n+\tcancel()\n+\t{ m_print = false; }\n+\n+\t~destructor_printer()\n+\t{\n+\t  if (m_print)\n+\t    {\n+\t      std::cerr << std::endl << \"Uncaught exception: \" << std::endl \n+\t\t\t<< m_msg << std::endl;\n+\t    }\n+\t}\n+\n+\tconst std::string \tm_msg;\n+\tbool \t\t\tm_print;\n+      };\n+\n+      const unsigned long \tm_seed;\n+      const size_t \t\tm_n;\n+      const size_t \t\tm_m;\n+      const double \t\tm_tp;\n+      const double \t\tm_ip;\n+      const double \t\tm_dp;\n+      const double \t\tm_ep;\n+      const double \t\tm_cp;\n+      const double \t\tm_mp;\n+      const bool \t\tm_disp;\n+      twister_rand_gen \t\tm_g;\n+      Cntnr* \t\t\tm_p_c;\n+      native_type \t\tm_native_c;\n+      allocator_type \t\tm_alloc;\n+      size_t \t\t\tm_i;\n+\n+    public:\n+      container_rand_regression_test(unsigned long seed, size_t n, size_t m, \n+\t\t\t\t     double tp, double ip, double dp, \n+\t\t\t\t     double ep, double cp, double mp, \n+\t\t\t\t     bool disp);\n+\n+      virtual\n+      ~container_rand_regression_test();\n+      \n+      void\n+      operator()();\n+  };\n+\n+\n+#ifdef PB_DS_REGRESSION_TRACE\n+# define PB_DS_TRACE(X) std::cerr << X << std::endl\n+#else \n+# define PB_DS_TRACE(X)\n+#endif\n+\n+#define PB_DS_CLASS_T_DEC\t\t\t\\\n+      template<typename Cntnr>\n+\n+#define PB_DS_CLASS_C_DEC\t\t\t\t\\\n+      container_rand_regression_test<Cntnr>\n+\n+#define PB_DS_COND_COMPARE(L, R)\t\t\\\n+      if (m_g.get_prob() < m_mp)\t\t\\\n+        cmp(L, R, __FUNCTION__);\n+\n+#define PB_DS_RUN_MTHD(MTHD)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+        bool done = false;\t\t\t\\\n+        while (!done)\t\t\t\t\\\n+\t  done = MTHD();\t\t\t\\\n+      }\n+\n+#define _GLIBCXX_THROW_IF_(PRED, MORE, P_C, P_NC, F, L)\t\t\t\\\n+      if (PRED)\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  std::cerr << \"Failure at \" << F << \": \" << L << std::endl;\t\\\n+\t  std::cerr << MORE << std::endl;\t\t\t\t\\\n+\t  std::cerr << \"container:\" << std::endl;\t\t\t\\\n+\t  print_container(*(P_C));\t\t\t\t\t\\\n+\t  std::cerr << std::endl;\t\t\t\t\t\\\n+\t  std::cerr << \"native container:\" << std::endl;\t\t\\\n+\t  print_container(*(P_NC));\t\t\t\t\t\\\n+\t  std::cerr << std::endl;\t\t\t\t\t\\\n+\t  throw std::logic_error(\"pbds throw if failed\");\t\t\\\n+\t}\n+\n+#define _GLIBCXX_THROW_IF(PRED, MORE, P_C, P_NC)\t\t\t\\\n+      _GLIBCXX_THROW_IF_(PRED, MORE, P_C, P_NC, __FILE__, __LINE__)\n+\n+#include <regression/rand/priority_queue/container_rand_regression_test.tcc>\n+\n+#undef PB_DS_COND_COMPARE\n+#undef PB_DS_RUN_MTHD\n+#undef PB_DS_CLASS_T_DEC\n+#undef PB_DS_CLASS_C_DEC\n+#undef _GLIBCXX_THROW_IF_\n+#undef _GLIBCXX_THROW_IF\n+#undef PB_DS_TRACE\n+\n+} // namespace detail\n+} // namespace test\n+} // namespace __gnu_pbds\n+\n+#endif"}, {"sha": "ceaa75badaede92e5a626677880b44c1b24f6c47", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/container_rand_regression_test.tcc", "status": "added", "additions": 848, "deletions": 0, "changes": 848, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -0,0 +1,848 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n+\n+// Permission to use, copy, modify, sell, and distribute this software\n+// is hereby granted without fee, provided that the above copyright\n+// notice appears in all copies, and that both that copyright notice\n+// and this permission notice appear in supporting documentation. None\n+// of the above authors, nor IBM Haifa Research Laboratories, make any\n+// representation about the suitability of this software for any\n+// purpose. It is provided \"as is\" without express or implied\n+// warranty.\n+\n+/**\n+ * @file container_rand_regression_test.tcc\n+ * Contains a random regression test for a specific container type.\n+ */\n+\n+#ifndef PB_DS_CONTAINER_RAND_REGRESSION_TEST_TCC\n+#define PB_DS_CONTAINER_RAND_REGRESSION_TEST_TCC\n+\n+  // Constructor, copy constructor, assignment and destructor.\n+PB_DS_CLASS_T_DEC\n+PB_DS_CLASS_C_DEC::\n+container_rand_regression_test(unsigned long seed, size_t n, size_t m, \n+\t\t\t       double tp, double ip, double dp, double ep, \n+\t\t\t       double cp, double mp, bool disp) \n+: m_seed(seed == 0 ? twister_rand_gen::get_time_determined_seed(): seed),\n+  m_n(n), m_m(m), m_tp(tp), m_ip(ip), m_dp(dp), m_ep(ep), m_cp(cp),\n+  m_mp(mp), m_disp(disp), m_p_c(NULL)\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+PB_DS_CLASS_C_DEC::\n+~container_rand_regression_test()\n+{ }\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+default_constructor()\n+{\n+  PB_DS_TRACE(\"default_constructor\");\n+  bool done = true;\n+  m_alloc.set_throw_prob(m_tp);\n+\n+  try\n+    {\n+      m_p_c = new Cntnr;\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+    }\n+\n+  if (m_p_c != NULL)\n+    PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+swap()\n+{\n+  PB_DS_TRACE(\"swap\");\n+  m_alloc.set_throw_prob(0);\n+  Cntnr* p_c = new Cntnr;\n+  m_alloc.set_throw_prob(1);\n+  p_c->swap(*m_p_c);\n+  std::swap(p_c, m_p_c);\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+copy_constructor()\n+{\n+  PB_DS_TRACE(\"copy_constructor\");\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+\n+  typedef typename allocator_type::group_throw_prob_adjustor adjustor;\n+  adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      p_c = new Cntnr(*m_p_c);\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+assignment_operator()\n+{\n+  PB_DS_TRACE(\"assignment operator\");\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+\n+  typedef typename allocator_type::group_throw_prob_adjustor adjustor;\n+  adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      p_c = new Cntnr();\n+      *p_c = *m_p_c;\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+it_constructor()\n+{\n+  bool done = true;\n+  Cntnr* p_c = NULL;\n+  m_alloc.set_throw_prob(m_tp);\n+  typedef typename allocator_type::group_throw_prob_adjustor adjustor;\n+  adjustor adjust(m_p_c->size());\n+\n+  try\n+    {\n+      switch(get_next_sub_op(3))\n+        {\n+        case 0:\n+\t  p_c = new Cntnr(m_p_c->get_cmp_fn());\n+\t  m_native_c.clear();\n+\t  break;\n+        case 1:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end());\n+\t  break;\n+        case 2:\n+\t  p_c = new Cntnr(m_p_c->begin(), m_p_c->end(), m_p_c->get_cmp_fn());\n+\t  break;\n+        default:\n+\t  _GLIBCXX_THROW_IF(true, \"\", m_p_c, &m_native_c);\n+        };\n+\n+      std::swap(p_c, m_p_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error& )\n+    {\n+      done = false;\n+    }\n+\n+  delete p_c;\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  return done;\n+}\n+\n+\n+  // Compare.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+cmp(const Cntnr& c, const native_type& native, const std::string& callfn)\n+{\n+  destructor_printer notify(__FUNCTION__);\n+\n+  try\n+    {\n+      m_alloc.set_throw_prob(1);\n+      \n+      const size_t size = c.size();\n+      const size_t native_size = native.size();\n+      _GLIBCXX_THROW_IF(size != native_size, size << \" \" << native_size,\n+\t\t\t&c, &native);\n+      \n+      const bool empty = c.empty();\n+      const bool native_empty = native.empty();\n+      _GLIBCXX_THROW_IF(empty != native_empty, empty << \" \" << native_empty, \n+\t\t\t&c, &native);\n+      \n+      const size_t it_size = std::distance(c.begin(), c.end());\n+      _GLIBCXX_THROW_IF(it_size != size, it_size << \" \" << size, &c, &native);\n+      \n+      if (!c.empty())\n+\t{\n+\t  const std::string native_top = native.top();\n+\t  const std::string top = test_traits::native_value(c.top());\n+\t  const bool top_smaller = std::less<std::string>()(top, native_top);\n+\t  const bool top_larger = std::less<std::string>()(native_top, top);\n+\t  \n+\t  if (top_smaller || top_larger)\n+\t    _GLIBCXX_THROW_IF(true, top << \" \" << native_top, &c, &native);\n+\t}\n+    }\n+  catch(...)\n+    {\n+      _GLIBCXX_THROW_IF(true, \"call-fn: \" + callfn, &c, &native);\n+    }\n+  \n+  notify.cancel();\n+}\n+\n+  // Operators.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+operator()()\n+{\n+  typedef xml_result_set_regression_formatter formatter_type;\n+  formatter_type* p_fmt = NULL;\n+  if (m_disp)\n+    p_fmt = new formatter_type(string_form<Cntnr>::name(),\n+\t\t\t       string_form<Cntnr>::desc());\n+\n+  m_g.init(m_seed);\n+  m_alloc.init(m_seed);\n+\n+  // The __throw_allocator::_S_label defaults to 0, so to make things\n+  // easier and more precise when debugging, start at 1.\n+  const size_t starting_label(1);\n+\n+  try\n+    {\n+      prog_bar pb(m_n, std::cout, m_disp);\n+\n+      for (m_i = starting_label; m_i <= m_n; ++m_i)\n+        {\n+\t  PB_DS_TRACE(\"Op #\" << m_i);\n+\n+\t  // Track allocation from this point only.\n+\t  allocator_type::set_label(m_i);\n+\t  switch(m_i)\n+            {\n+            case 1:\n+\t      PB_DS_RUN_MTHD(default_constructor);\n+\t      break;\n+            case 2:\n+\t      defs();\n+\t      break;\n+            case 3:\n+\t      policy_access();\n+\t      break;\n+            case 4:\n+\t      it_copy();\n+\t      break;\n+            case 5:\n+\t      it_assign();\n+\t      break;\n+            default:\n+\t      switch(get_next_op())\n+                {\n+                case insert_op:\n+\t\t  PB_DS_RUN_MTHD(push)\n+                    break;\n+                case modify_op:\n+\t\t  PB_DS_RUN_MTHD(modify)\n+                    break;\n+                case erase_op:\n+\t\t  switch(get_next_sub_op(3))\n+                    {\n+                    case 0:\n+\t\t      PB_DS_RUN_MTHD(pop)\n+                        break;\n+                    case 1:\n+\t\t      PB_DS_RUN_MTHD(erase_if)\n+                        break;\n+                    case 2:\n+\t\t      PB_DS_RUN_MTHD(erase_it)\n+                        break;\n+                    default:\n+\t\t      _GLIBCXX_THROW_IF(true, \"\", m_p_c, &m_native_c);\n+                    }\n+\t\t  break;\n+                case clear_op:\n+\t\t  PB_DS_RUN_MTHD(clear)\n+                    break;\n+                case other_op:\n+\t\t  switch(get_next_sub_op(5))\n+                    {\n+                    case 0:\n+\t\t      swap();\n+\t\t      break;\n+                    case 1:\n+\t\t      PB_DS_RUN_MTHD(copy_constructor)\n+                        break;\n+                    case 2:\n+\t\t      PB_DS_RUN_MTHD(it_constructor)\n+                        break;\n+                    case 3:\n+\t\t      PB_DS_RUN_MTHD(assignment_operator)\n+                        break;\n+                    case 4:\n+\t\t      PB_DS_RUN_MTHD(split_join)\n+                        break;\n+                    default:\n+\t\t      _GLIBCXX_THROW_IF(true, \"\", m_p_c, &m_native_c);\n+                    }\n+\t\t  break;\n+                default:\n+\t\t  _GLIBCXX_THROW_IF(true, \"\", m_p_c,  &m_native_c);\n+                };\n+            }\n+\t  pb.inc();\n+        }\n+    }\n+  catch (...)\n+    {\n+      std::cerr << \"Failed at index \" << m_i << std::endl;\n+      delete m_p_c;\n+      throw;\n+    }\n+\n+  // Clean up, then check for allocation by special label, set above.\n+  allocator_type::set_label(0);\n+  delete m_p_c;\n+\n+  try \n+    { \n+      for (size_t n = starting_label; n <= m_n; ++n)\n+\tm_alloc.check_allocated(n); \n+    }\n+  catch (std::logic_error& obj)\n+    {\n+      // On fail, check_allocated should throw std::logic_error.\n+      std::cerr << obj.what() << std::endl;\n+      std::cerr << typeid(Cntnr).name() << std::endl;\n+      throw;\n+    }\n+\n+  // Reset throw probability.\n+  m_alloc.set_throw_prob(0);\n+\n+  if (m_disp)\n+    {\n+      std::cout << std::endl;\n+      delete p_fmt;\n+    }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+typename PB_DS_CLASS_C_DEC::op\n+PB_DS_CLASS_C_DEC::\n+get_next_op()\n+{\n+  const double prob = m_g.get_prob();\n+\n+  if (prob < m_ip)\n+    return insert_op;\n+\n+  if (prob < m_ip + m_dp)\n+    return modify_op;\n+\n+  if (prob < m_ip + m_dp + m_ep)\n+    return erase_op;\n+\n+  if (prob < m_ip + m_dp + m_ep + m_cp)\n+    return clear_op;\n+\n+  _GLIBCXX_THROW_IF(prob > 1, prob, m_p_c, &m_native_c);\n+  return other_op;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+size_t\n+PB_DS_CLASS_C_DEC::\n+get_next_sub_op(size_t max)\n+{\n+  const double p = m_g.get_prob();\n+  const double delta = 1 / static_cast<double>(max);\n+  size_t i = 0;\n+  while (true)\n+    if (p <= (i + 1) * delta)\n+      {\n+\t_GLIBCXX_THROW_IF(i >= max, i << \" \" << max, m_p_c, &m_native_c);\n+\treturn i;\n+      }\n+    else\n+      ++i;\n+}\n+\n+  // Insert.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+push()\n+{\n+  PB_DS_TRACE(\"push\");\n+  bool done = true;\n+  destructor_printer notify(__FUNCTION__);\n+\n+    try\n+      {\n+        m_alloc.set_throw_prob(0);\n+        value_type v = test_traits::generate_value(m_g, m_m);\n+        m_alloc.set_throw_prob(m_tp);\n+        const typename cntnr::size_type sz = m_p_c->size();\n+        m_p_c->push(v);\n+        _GLIBCXX_THROW_IF(sz != m_p_c->size() - 1, sz, m_p_c, &m_native_c);\n+        m_native_c.push(test_traits::native_value(v));\n+      }\n+    catch(__gnu_cxx::forced_exception_error& )\n+      {\n+        done = false;\n+      }\n+    catch(...)\n+      {\n+        _GLIBCXX_THROW_IF(true, \"\", m_p_c, &m_native_c);\n+      }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  notify.cancel();\n+  return done;\n+}\n+\n+\n+  // Modify.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+modify()\n+{\n+  PB_DS_TRACE(\"modify\");\n+  destructor_printer notify(__FUNCTION__);\n+\n+  bool done = true;\n+  try\n+    {\n+      m_alloc.set_throw_prob(0);\n+      value_type v = test_traits::generate_value(m_g, m_m);\n+\n+      m_alloc.set_throw_prob(m_tp);\n+      typename cntnr::iterator it = m_p_c->begin();\n+      std::advance(it, m_g.get_unsigned_long(0, m_p_c->size()));\n+      if (it != m_p_c->end())\n+\t{\n+\t  typedef typename test_traits::native_value_type native_value_type;\n+\t  native_value_type native_v = test_traits::native_value(*it);\n+\t  native_value_type new_native_v = test_traits::native_value(v);\n+\t  m_p_c->modify(it, v);\n+\t  m_native_c.modify(native_v, new_native_v);\n+\t}\n+    }\n+  catch(__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+      _GLIBCXX_THROW_IF(true, \"\", m_p_c, &m_native_c);\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  notify.cancel();\n+  return done;\n+}\n+\n+  // Clear.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+clear()\n+{\n+  PB_DS_TRACE(\"clear\");\n+  m_p_c->clear();\n+  m_native_c.clear();\n+  return true;\n+}\n+\n+  // Erase.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+pop()\n+{\n+  PB_DS_TRACE(\"pop\");\n+  destructor_printer notify(__FUNCTION__);\n+\n+  bool done = true;\n+  try\n+    {\n+      m_alloc.set_throw_prob(1);\n+      if (!m_p_c->empty())\n+        {\n+\t  m_p_c->pop();\n+\t  m_native_c.pop();\n+        }\n+    }\n+  catch(__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;\n+      _GLIBCXX_THROW_IF(true, \"\", m_p_c, &m_native_c);\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  notify.cancel();\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_if()\n+{\n+  PB_DS_TRACE(\"erase_if\");\n+  destructor_printer notify(__FUNCTION__);\n+\n+  bool done = true;\n+  try\n+    {\n+      typedef\n+\ttypename std::iterator_traits<typename cntnr::iterator>::reference\n+\tit_const_reference;\n+      \n+      m_alloc.set_throw_prob(1);\n+      \n+      typedef\n+\ttypename test_traits::template erase_if_fn<value_type>\n+\terase_if_fn_t;\n+      \n+      const size_t ersd = m_p_c->erase_if(erase_if_fn_t());\n+      \n+      typedef\n+\ttypename test_traits::template erase_if_fn<std::string>\n+\tnative_erase_if_fn_t;\n+      \n+      const size_t native_ersd = m_native_c.erase_if(native_erase_if_fn_t());\n+\n+      _GLIBCXX_THROW_IF(ersd != native_ersd, ersd << \" \" << native_ersd,\n+\t\t\tm_p_c, &m_native_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;      \n+      _GLIBCXX_THROW_IF(true, \"\", m_p_c, &m_native_c);\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  notify.cancel();\n+  return done;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+erase_it()\n+{\n+  PB_DS_TRACE(\"erase_it\");\n+  destructor_printer notify(__FUNCTION__);\n+\n+  bool done = true;\n+  try\n+    {\n+      m_alloc.set_throw_prob(1);      \n+      typename cntnr::iterator it = m_p_c->begin();      \n+      std::advance(it, m_g.get_unsigned_long(0, m_p_c->size()));\n+      \n+      if (it != m_p_c->end())\n+\t{\n+\t  m_native_c.erase(*it);\t \n+\t  m_p_c->erase(it);\n+\t}\n+    }\n+  catch(__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;      \n+      _GLIBCXX_THROW_IF(true, \"\", m_p_c, &m_native_c);\n+    }\n+\n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  notify.cancel();\n+  return done;\n+}\n+\n+  // Defs.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+defs()\n+{\n+  // General container types.\n+  typedef typename Cntnr::size_type test_size_type;\n+  typedef typename Cntnr::difference_type difference_type;\n+  value_defs();\n+  iterator_defs();\n+  policy_defs();\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+value_defs()\n+{\n+  typedef typename Cntnr::value_type test_value_type;\n+  typedef typename Cntnr::reference test_reference;\n+  typedef typename Cntnr::const_reference test_const_reference;\n+  typedef typename Cntnr::pointer test_pointer;\n+  typedef typename Cntnr::const_pointer test_const_pointer;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+ds_defs()\n+{\n+  typedef typename Cntnr::container_category test_container_category;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+iterator_defs()\n+{\n+  typedef typename Cntnr::point_iterator test_point_iterator;\n+  typedef typename Cntnr::const_point_iterator const_test_point_iterator;\n+  typedef typename Cntnr::iterator test_iterator;\n+  typedef typename Cntnr::const_iterator const_test_iterator;\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_defs()\n+{\n+  typedef typename Cntnr::allocator_type test_allocator;\n+  typedef typename Cntnr::cmp_fn test_cmp_fn;\n+}\n+\n+\n+// Policy access.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+policy_access()\n+{\n+  PB_DS_TRACE(\"policy_access\");\n+\n+  {\n+    typename Cntnr::cmp_fn& r_t = m_p_c->get_cmp_fn();\n+    assert(&r_t != NULL);\n+  }\n+\n+  {\n+    const typename Cntnr::cmp_fn& r_t =((const Cntnr& )*m_p_c).get_cmp_fn();\n+    assert(&r_t != NULL);\n+  }\n+}\n+\n+// Split join.\n+PB_DS_CLASS_T_DEC\n+bool\n+PB_DS_CLASS_C_DEC::\n+split_join()\n+{\n+  PB_DS_TRACE(\"split_join\");\n+  destructor_printer notify(__FUNCTION__);\n+\n+  bool done = true;\n+  try\n+    {\n+      m_alloc.set_throw_prob(0);\n+      Cntnr lhs(*m_p_c);\n+      Cntnr rhs;\n+      native_type native_lhs(m_native_c);\n+      m_alloc.set_throw_prob(m_tp);\n+      \n+      typedef typename test_traits::template erase_if_fn<value_type> split_fn_t;\n+      lhs.split(split_fn_t(), rhs);\n+      \n+      typedef typename test_traits::template erase_if_fn<std::string>\n+\tnative_split_fn_t;\n+      \n+      native_type native_rhs;      \n+      native_lhs.split(native_split_fn_t(), native_rhs);      \n+      PB_DS_COND_COMPARE(lhs, native_lhs);\n+      PB_DS_COND_COMPARE(rhs, native_rhs);\n+      \n+      m_alloc.set_throw_prob(m_tp);\n+      \n+      if (m_g.get_prob() < 0.5)\n+\tlhs.swap(rhs);      \n+      lhs.join(rhs);\n+      \n+      _GLIBCXX_THROW_IF(rhs.size() != 0, rhs.size(), m_p_c, &m_native_c);\n+      _GLIBCXX_THROW_IF(!rhs.empty(), rhs.size(), m_p_c, &m_native_c);\n+    }\n+  catch(__gnu_cxx::forced_exception_error&)\n+    {\n+      done = false;      \n+      const bool b = __gnu_pbds::container_traits<cntnr>::split_join_can_throw;\n+      _GLIBCXX_THROW_IF(!b, b, m_p_c, &m_native_c);\n+    }\n+  \n+  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n+  notify.cancel();\n+  return done;\n+}\n+\n+// Iterator conversions.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+it_copy()\n+{\n+  PB_DS_TRACE(\"it_copy\");\n+\n+  {\n+    typename cntnr::iterator it = m_p_c->end();\n+    typename cntnr::const_iterator const_it(it);\n+    _GLIBCXX_THROW_IF(const_it != it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(const_it == it), \"\", m_p_c, &m_native_c);\n+  }\n+\n+  {\n+    typename cntnr::const_iterator const_it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it(const_it);\n+    _GLIBCXX_THROW_IF(const_find_it != const_it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(const_find_it == const_it), \"\", m_p_c, &m_native_c);\n+  }\n+\n+  {\n+    typename cntnr::iterator it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it1(it);\n+    _GLIBCXX_THROW_IF(const_find_it1 != it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(const_find_it1 == it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::point_iterator find_it1(it);\n+    _GLIBCXX_THROW_IF(find_it1 != it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(find_it1 == it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::point_iterator find_it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it(find_it);\n+    _GLIBCXX_THROW_IF(find_it != const_find_it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(find_it == const_find_it), \"\", m_p_c, &m_native_c);\n+  }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+it_assign()\n+{\n+  PB_DS_TRACE(\"it_assign\");\n+\n+  {\n+    typename cntnr::iterator it = m_p_c->end();\n+    typename cntnr::const_iterator const_it;\n+    const_it = it;\n+    _GLIBCXX_THROW_IF(const_it != it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(const_it == it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::const_point_iterator const_find_it;\n+    const_find_it = it;\n+    _GLIBCXX_THROW_IF(const_find_it != it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(const_find_it == it), \"\", m_p_c, &m_native_c);\n+\n+    typename cntnr::point_iterator find_it;\n+    find_it = it;\n+    _GLIBCXX_THROW_IF(find_it != it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(find_it == it), \"\", m_p_c, &m_native_c);\n+  }\n+\n+  {\n+    typename cntnr::const_iterator const_it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it;\n+    const_find_it = const_it;\n+    _GLIBCXX_THROW_IF(const_find_it != const_it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(const_find_it == const_it), \"\", m_p_c, &m_native_c);\n+  }\n+\n+  {\n+    typename cntnr::point_iterator find_it = m_p_c->end();\n+    typename cntnr::const_point_iterator const_find_it;\n+    const_find_it = find_it;\n+    _GLIBCXX_THROW_IF(find_it != const_find_it, \"\", m_p_c, &m_native_c);\n+    _GLIBCXX_THROW_IF(!(find_it == const_find_it), \"\", m_p_c, &m_native_c);\n+  }\n+}\n+\n+\n+// Diagnostics.\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+print_container(const native_type& cnt, std::ostream& os) const\n+{\n+  m_alloc.set_throw_prob(0);\n+  native_type cpy(cnt);\n+  while (!cpy.empty())\n+    {\n+      os << cpy.top() << std::endl;\n+      cpy.pop();\n+    }\n+}\n+\n+PB_DS_CLASS_T_DEC\n+void\n+PB_DS_CLASS_C_DEC::\n+print_container(const cntnr& cnt, std::ostream& os) const\n+{\n+  typedef typename cntnr::const_iterator const_iterator;\n+  m_alloc.set_throw_prob(0);\n+  for (const_iterator it = cnt.begin(); it != cnt.end(); ++it)\n+    os << *it << std::endl;\n+}\n+\n+#endif"}, {"sha": "009b56faaf60e479d505f5545cabce8af9dcb081", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/clear_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fclear_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fclear_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fclear_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,60 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file clear_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-clear()\n-{\n-  PB_DS_TRACE(\"clear\");\n-\n-  m_p_c->clear();\n-\n-  m_native_c.clear();\n-\n-  return (true);\n-}\n-"}, {"sha": "3707b7db99727561826435fc12bc8f4df6b4b87a", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/cmp_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fcmp_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fcmp_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fcmp_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,108 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file cmp_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-cmp(const Cntnr& r_c, const native_type& r_native_c, const std::string& r_call_fn)\n-{\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(1);\n-\n-        const size_t size = r_c.size();\n-        const size_t native_size = r_native_c.size();\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      size == native_size,\n-\t\t\t      static_cast<unsigned long>(size) << \" \" <<\n-\t\t\t      static_cast<unsigned long>(native_size),\n-\t\t\t      & r_c,\n-\t\t\t      & r_native_c);\n-\n-        const bool empty = r_c.empty();\n-        const bool native_empty = r_native_c.empty();\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      empty == native_empty,\n-\t\t\t      empty << \" \" << native_empty,\n-\t\t\t      & r_c,\n-\t\t\t      & r_native_c);\n-\n-        const size_t it_size = std::distance(r_c.begin(), r_c.end());\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      it_size == size,\n-\t\t\t      it_size << \" \" << size,\n-\t\t\t      & r_c,\n-\t\t\t      & r_native_c);\n-\n-        if (!r_c.empty())\n-\t  {\n-            const std::string native_top = r_native_c.top();\n-            const std::string top = test_traits::native_value(r_c.top());\n-\n-            const bool top_smaller = std::less<std::string>()(top, native_top);\n-            const bool top_larger = std::less<std::string>()(native_top, top);\n-\n-            if (top_smaller || top_larger)\n-\t      PB_DS_THROW_IF_FAILED(\n-\t\t\t\t    false,\n-\t\t\t\t    top << \" \" << native_top,\n-\t\t\t\t    & r_c,\n-\t\t\t\t    & r_native_c);\n-\t  }\n-      }\n-    catch(...)\n-      {\n-        PB_DS_THROW_IF_FAILED(            false, \"call-fn: \" + r_call_fn, & r_c, & r_native_c);\n-      }\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-    }\n-"}, {"sha": "87282825f9c2c14ae1f52865da101c587989121a", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/constructor_destructor_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fconstructor_destructor_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fconstructor_destructor_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fconstructor_destructor_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,235 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file constructor_destructor_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-PB_DS_CLASS_C_DEC::\n-container_rand_regression_test(unsigned long seed, size_t n, size_t m, double tp, double ip, double dp, double ep, double cp, double mp, bool disp) :\n-  m_seed((seed == 0)?\n-\t twister_rand_gen::get_time_determined_seed():\n-\t seed),\n-  m_n(n),\n-  m_m(m),\n-  m_tp(tp),\n-  m_ip(ip),\n-  m_dp(dp),\n-  m_ep(ep),\n-  m_cp(cp),\n-  m_mp(mp),\n-  m_disp(disp),\n-  m_p_c(NULL)\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-PB_DS_CLASS_C_DEC::\n-~container_rand_regression_test()\n-{ }\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-default_constructor()\n-{\n-  PB_DS_TRACE(\"default_constructor\");\n-\n-  bool done = true;\n-\n-  m_alloc.set_throw_prob(m_tp);\n-\n-  try\n-    {\n-      m_p_c = new Cntnr;\n-    }\n-  catch(__gnu_cxx::forced_exception_error& )\n-    {\n-      done = false;\n-    }\n-\n-  if (m_p_c != NULL)\n-    PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-swap()\n-{\n-  PB_DS_TRACE(\"swap\");\n-\n-  m_alloc.set_throw_prob(0);\n-\n-  Cntnr* p_c = new Cntnr;\n-\n-  m_alloc.set_throw_prob(1);\n-\n-  p_c->swap(*m_p_c);\n-\n-  std::swap(p_c, m_p_c);\n-\n-  delete p_c;\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-copy_constructor()\n-{\n-  PB_DS_TRACE(\"copy_constructor\");\n-\n-  bool done = true;\n-\n-  Cntnr* p_c = NULL;\n-\n-  m_alloc.set_throw_prob(m_tp);\n-\n-  typename alloc_t::group_throw_prob_adjustor\n-    adjust(m_p_c->size());\n-\n-  try\n-    {\n-      p_c = new Cntnr(*m_p_c);\n-\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch(__gnu_cxx::forced_exception_error& )\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-assignment_operator()\n-{\n-  PB_DS_TRACE(\"assignment operator\");\n-\n-  bool done = true;\n-\n-  Cntnr* p_c = NULL;\n-\n-  m_alloc.set_throw_prob(m_tp);\n-\n-  typename alloc_t::group_throw_prob_adjustor\n-    adjust(m_p_c->size());\n-\n-  try\n-    {\n-      p_c = new Cntnr();\n-\n-      * p_c =* m_p_c;\n-\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch(__gnu_cxx::forced_exception_error& )\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-it_constructor()\n-{\n-  bool done = true;\n-\n-  Cntnr* p_c = NULL;\n-\n-  m_alloc.set_throw_prob(m_tp);\n-\n-  typename alloc_t::group_throw_prob_adjustor\n-    adjust(m_p_c->size());\n-\n-  try\n-    {\n-      switch(get_next_sub_op(3))\n-        {\n-        case 0:\n-\t  p_c = new Cntnr(m_p_c->get_cmp_fn());\n-\t  m_native_c.clear();\n-\t  break;\n-        case 1:\n-\t  p_c = new Cntnr(m_p_c->begin(),\n-\t\t\t  m_p_c->end());\n-\t  break;\n-        case 2:\n-\t  p_c = new Cntnr(m_p_c->begin(),\n-\t\t\t  m_p_c->end(),\n-\t\t\t  m_p_c->get_cmp_fn());\n-\t  break;\n-        default:\n-\t  PB_DS_THROW_IF_FAILED(                    false,  \"\",  m_p_c, & m_native_c);\n-        };\n-\n-      std::swap(p_c, m_p_c);\n-    }\n-  catch(__gnu_cxx::forced_exception_error& )\n-    {\n-      done = false;\n-    }\n-\n-  delete p_c;\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  return (done);\n-}"}, {"sha": "ae406937337c6e89b9ee395eabbe33fc2d0c5ad4", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/defs_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fdefs_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fdefs_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fdefs_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,98 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file defs_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-defs()\n-{\n-  // General container types.\n-  typedef typename Cntnr::size_type test_size_type;\n-  typedef typename Cntnr::difference_type difference_type;\n-  value_defs();\n-  iterator_defs();\n-  policy_defs();\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-value_defs()\n-{\n-  typedef typename Cntnr::value_type test_value_type;\n-  typedef typename Cntnr::reference test_reference;\n-  typedef typename Cntnr::const_reference test_const_reference;\n-  typedef typename Cntnr::pointer test_pointer;\n-  typedef typename Cntnr::const_pointer test_const_pointer;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-ds_defs()\n-{\n-  typedef typename Cntnr::container_category test_container_category;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-iterator_defs()\n-{\n-  typedef typename Cntnr::point_iterator test_point_iterator;\n-  typedef typename Cntnr::const_point_iterator const_test_point_iterator;\n-  typedef typename Cntnr::iterator test_iterator;\n-  typedef typename Cntnr::const_iterator const_test_iterator;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_defs()\n-{\n-  typedef typename Cntnr::allocator_type test_allocator;\n-  typedef typename Cntnr::cmp_fn test_cmp_fn;\n-}"}, {"sha": "caeba090e2565c33f31deb77279d8a410f9ae9dd", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/diagnostic_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fdiagnostic_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fdiagnostic_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fdiagnostic_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,73 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file diagnostic_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-print_container(const native_type& r_cnt, std::ostream& r_os /*= std::cerr*/) const\n-{\n-  m_alloc.set_throw_prob(0);\n-\n-  native_type cpy(r_cnt);\n-\n-  while (!cpy.empty())\n-    {\n-      r_os << cpy.top() << std::endl;\n-\n-      cpy.pop();\n-    }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-print_container(const cntnr& r_cnt, std::ostream& r_os /*= std::cerr*/) const\n-{\n-  m_alloc.set_throw_prob(0);\n-\n-  for (typename cntnr::const_iterator it = r_cnt.begin(); it != r_cnt.end(); ++it)\n-    r_os <<* it << std::endl;\n-}"}, {"sha": "82b126a883a4042637b91778da759a91bc8cd2f7", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/erase_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Ferase_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Ferase_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Ferase_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,178 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file erase_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-pop()\n-{\n-  PB_DS_TRACE(\"pop\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    m_alloc.set_throw_prob(1);\n-\n-  try\n-    {\n-      if (!m_p_c->empty())\n-        {\n-\t  m_p_c->pop();\n-\n-\t  m_native_c.pop();\n-        }\n-    }\n-  catch(__gnu_cxx::forced_exception_error& )\n-    {\n-      done = false;\n-\n-      PB_DS_THROW_IF_FAILED(            false, \"\", m_p_c, & m_native_c);\n-    }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_if()\n-{\n-  PB_DS_TRACE(\"erase_if\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        typedef\n-\t  typename std::iterator_traits<\n-\t  typename cntnr::iterator>::reference\n-\t  it_const_reference;\n-\n-        m_alloc.set_throw_prob(1);\n-\n-        typedef\n-\t  typename test_traits::template erase_if_fn<\n-\t  value_type>\n-\t  erase_if_fn_t;\n-\n-        const size_t ersd =\n-\t  m_p_c->erase_if(erase_if_fn_t());\n-\n-        typedef\n-\t  typename test_traits::template erase_if_fn<\n-\t  std::string>\n-\t  native_erase_if_fn_t;\n-\n-        const size_t native_ersd =\n-\t  m_native_c.erase_if(native_erase_if_fn_t());\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      ersd == native_ersd,\n-\t\t\t      static_cast<unsigned long>(ersd) << \" \" <<\n-\t\t\t      static_cast<unsigned long>(native_ersd),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-\n-        PB_DS_THROW_IF_FAILED(            false, \"\", m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-erase_it()\n-{\n-  PB_DS_TRACE(\"erase_it\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(1);\n-\n-        typename cntnr::iterator it = m_p_c->begin();\n-\n-        std::advance(it, m_g.get_unsigned_long(0, m_p_c->size()));\n-\n-        if (it != m_p_c->end())\n-\t  {\n-            m_native_c.erase(*it);\n-\n-            m_p_c->erase(it);\n-\t  }\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-\n-        PB_DS_THROW_IF_FAILED(            false, \"\", m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}"}, {"sha": "24dc6499d8131d9c689f87921e0c0bf074ef631a", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/insert_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Finsert_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Finsert_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Finsert_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,93 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file insert_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-push()\n-{\n-  PB_DS_TRACE(\"push\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-\n-        value_type v = test_traits::generate_value(m_g, m_m);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        const typename cntnr::size_type sz = m_p_c->size();\n-\n-        typename cntnr::point_iterator ins_ret = m_p_c->push(v);\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      sz == m_p_c->size() - 1,\n-\t\t\t      sz,\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-\n-        m_native_c.push(test_traits::native_value(v));\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-      }\n-    catch(...)\n-      {\n-        PB_DS_THROW_IF_FAILED(            false, \"\", m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-"}, {"sha": "c59e13688351e97a091c1f45ee4f835fef1c514b", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/it_conversion_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fit_conversion_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fit_conversion_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fit_conversion_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,190 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file it_conversion_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-it_copy()\n-{\n-  PB_DS_TRACE(\"it_copy\");\n-\n-  {\n-    typename cntnr::iterator it = m_p_c->end();\n-\n-    typename cntnr::const_iterator const_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            const_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::const_point_iterator const_find_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::point_iterator find_it(it);\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-\n-  {\n-    typename cntnr::const_iterator const_it = m_p_c->end();\n-\n-    typename cntnr::const_point_iterator const_find_it(const_it);\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == const_it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != const_it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-\n-  {\n-    typename cntnr::point_iterator find_it = m_p_c->end();\n-\n-    typename cntnr::const_point_iterator const_find_it(find_it);\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == const_find_it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != const_find_it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-it_assign()\n-{\n-  PB_DS_TRACE(\"it_assign\");\n-\n-  {\n-    typename cntnr::iterator it = m_p_c->end();\n-\n-    typename cntnr::const_iterator const_it;\n-    const_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            const_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::const_point_iterator const_find_it;\n-    const_find_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-\n-    typename cntnr::point_iterator find_it;\n-    find_it = it;\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-\n-  {\n-    typename cntnr::const_iterator const_it = m_p_c->end();\n-\n-    typename cntnr::const_point_iterator const_find_it;\n-    const_find_it = const_it;\n-\n-    PB_DS_THROW_IF_FAILED(            const_find_it == const_it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(const_find_it != const_it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-\n-  {\n-    typename cntnr::point_iterator find_it = m_p_c->end();\n-\n-    typename cntnr::const_point_iterator const_find_it;\n-    const_find_it = find_it;\n-\n-    PB_DS_THROW_IF_FAILED(            find_it == const_find_it, \"\", m_p_c, & m_native_c);\n-\n-    PB_DS_THROW_IF_FAILED(\n-\t\t\t  !(find_it != const_find_it),\n-\t\t\t  \"\",\n-\t\t\t  m_p_c,\n-\t\t\t  & m_native_c);\n-  }\n-}"}, {"sha": "5e99e09628f3f830ea066a7caad70df7478e73c0", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/modify_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fmodify_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fmodify_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fmodify_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,96 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file modify_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-modify()\n-{\n-  PB_DS_TRACE(\"modify\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-\n-        value_type v = test_traits::generate_value(m_g, m_m);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        typename cntnr::iterator it = m_p_c->begin();\n-\n-        std::advance(it, m_g.get_unsigned_long(0, m_p_c->size()));\n-\n-        if (it != m_p_c->end())\n-\t  {\n-            typename test_traits::native_value_type native_v =\n-\t      test_traits::native_value(*it);\n-\n-            typename test_traits::native_value_type new_native_v =\n-\t      test_traits::native_value(v);\n-\n-            m_p_c->modify(it, v);\n-\n-            m_native_c.modify(native_v, new_native_v);\n-\t  }\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-\n-        PB_DS_THROW_IF_FAILED(            false, \"\", m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}\n-"}, {"sha": "6186991984373493b6e079c062933046cd6ce9c0", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/operator_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Foperator_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Foperator_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Foperator_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,222 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file operator_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-operator()()\n-{\n-  typedef xml_result_set_regression_formatter formatter_type;\n-  formatter_type* p_fmt = NULL;\n-\n-  if (m_disp)\n-    p_fmt = new formatter_type(string_form<Cntnr>::name(),\n-\t\t\t       string_form<Cntnr>::desc());\n-\n-  m_g.init(m_seed);\n-\n-  // Track allocation from this point only.\n-  const size_t memory_label = 775;\n-  m_alloc.init(m_seed);\n-  m_alloc.set_label(memory_label);  \n-\n-  prog_bar pb(m_n, std::cout, m_disp);\n-  m_i = 0;\n-\n-  try\n-    {\n-      for (m_i = 0; m_i < m_n; ++m_i)\n-        {\n-\t  PB_DS_TRACE(\"Op #\" << static_cast<unsigned long>(m_i));\n-\t  allocator_type::set_label(m_i);\n-\t  switch(m_i)\n-            {\n-            case 0:\n-\t      PB_DS_RUN_MTHD(default_constructor);\n-\t      break;\n-            case 1:\n-\t      defs();\n-\t      break;\n-            case 2:\n-\t      policy_access();\n-\t      break;\n-            case 3:\n-\t      it_copy();\n-\t      break;\n-            case 4:\n-\t      it_assign();\n-\t      break;\n-            default:\n-\t      switch(get_next_op())\n-                {\n-                case insert_op:\n-\t\t  PB_DS_RUN_MTHD(push)\n-                    break;\n-                case modify_op:\n-\t\t  PB_DS_RUN_MTHD(modify)\n-                    break;\n-                case erase_op:\n-\t\t  switch(get_next_sub_op(3))\n-                    {\n-                    case 0:\n-\t\t      PB_DS_RUN_MTHD(pop)\n-                        break;\n-                    case 1:\n-\t\t      PB_DS_RUN_MTHD(erase_if)\n-                        break;\n-                    case 2:\n-\t\t      PB_DS_RUN_MTHD(erase_it)\n-                        break;\n-                    default:\n-\t\t      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-                    }\n-\t\t  break;\n-                case clear_op:\n-\t\t  PB_DS_RUN_MTHD(clear)\n-                    break;\n-                case other_op:\n-\t\t  switch(get_next_sub_op(5))\n-                    {\n-                    case 0:\n-\t\t      swap();\n-\t\t      break;\n-                    case 1:\n-\t\t      PB_DS_RUN_MTHD(copy_constructor)\n-                        break;\n-                    case 2:\n-\t\t      PB_DS_RUN_MTHD(it_constructor)\n-                        break;\n-                    case 3:\n-\t\t      PB_DS_RUN_MTHD(assignment_operator)\n-                        break;\n-                    case 4:\n-\t\t      PB_DS_RUN_MTHD(split_join)\n-                        break;\n-                    default:\n-\t\t      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-                    }\n-\t\t  break;\n-                default:\n-\t\t  PB_DS_THROW_IF_FAILED(false, \"\", m_p_c,  &m_native_c);\n-                };\n-            }\n-\t  pb.inc();\n-        }\n-    }\n-  catch (...)\n-    {\n-      std::cerr << \"Failed at index \" << static_cast<unsigned long>(m_i) \n-\t\t<< std::endl;\n-      delete m_p_c;\n-      throw;\n-    }\n-\n-  // Clean up, then check for allocation by special label, set above.\n-  delete m_p_c;\n-\n-  try \n-    { m_alloc.check_allocated(memory_label); }\n-  catch (...)\n-    {\n-      std::cerr << \"detected leaks!\" << std::endl;\n-      std::cerr << m_alloc << std::endl;\n-      PB_DS_THROW_IF_FAILED(false, \"\", m_p_c, &m_native_c);\n-    }\n-\n-  // Reset throw probability.\n-  m_alloc.set_throw_prob(0);\n-\n-  if (m_disp)\n-    {\n-      std::cout << std::endl;\n-      delete p_fmt;\n-    }\n-}\n-\n-PB_DS_CLASS_T_DEC\n-typename PB_DS_CLASS_C_DEC::op\n-PB_DS_CLASS_C_DEC::\n-get_next_op()\n-{\n-  const double prob = m_g.get_prob();\n-\n-  if (prob < m_ip)\n-    return (insert_op);\n-\n-  if (prob < m_ip + m_dp)\n-    return (modify_op);\n-\n-  if (prob < m_ip + m_dp + m_ep)\n-    return (erase_op);\n-\n-  if (prob < m_ip + m_dp + m_ep + m_cp)\n-    return (clear_op);\n-\n-  PB_DS_THROW_IF_FAILED(prob <= 1, prob, m_p_c, &m_native_c);\n-  return other_op;\n-}\n-\n-PB_DS_CLASS_T_DEC\n-size_t\n-PB_DS_CLASS_C_DEC::\n-get_next_sub_op(size_t max)\n-{\n-  const double p = m_g.get_prob();\n-  const double delta = 1 / static_cast<double>(max);\n-  size_t i = 0;\n-  while (true)\n-    if (p <= (i + 1)*  delta)\n-      {\n-\tPB_DS_THROW_IF_FAILED(i < max,\n-\t\t\t      static_cast<unsigned long>(i) << \" \" <<\n-\t\t\t      static_cast<unsigned long>(max),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-\treturn i;\n-      }\n-    else\n-      ++i;\n-}"}, {"sha": "40f37926c8e27c8201cf16c56f48049a63a8172a", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/policy_access_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fpolicy_access_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fpolicy_access_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fpolicy_access_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,66 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file policy_access_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-void\n-PB_DS_CLASS_C_DEC::\n-policy_access()\n-{\n-  PB_DS_TRACE(\"policy_access\");\n-\n-  {\n-    typename Cntnr::cmp_fn& r_t =\n-      m_p_c->get_cmp_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-\n-  {\n-    const typename Cntnr::cmp_fn& r_t =((const Cntnr& )*m_p_c).get_cmp_fn();\n-\n-    assert(&r_t != NULL);\n-  }\n-}"}, {"sha": "b25394fa34d4733ed480ce86e1f43a6232ef6cfc", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/detail/split_join_fn_imps.hpp", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fsplit_join_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fsplit_join_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fdetail%2Fsplit_join_fn_imps.hpp?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,120 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with this library; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-// MA 02111-1307, USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file split_join_fn_imps.hpp\n- * Containsert a random regression test for a specific container type.\n- */\n-\n-PB_DS_CLASS_T_DEC\n-bool\n-PB_DS_CLASS_C_DEC::\n-split_join()\n-{\n-  PB_DS_TRACE(\"split_join\");\n-\n-  bool done = true;\n-\n-  PB_DS_SET_DESTRUCT_PRINT\n-\n-    try\n-      {\n-        m_alloc.set_throw_prob(0);\n-\n-        Cntnr lhs(*m_p_c);\n-\n-        Cntnr rhs;\n-\n-        native_type native_lhs(m_native_c);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        typedef\n-\t  typename test_traits::template erase_if_fn<\n-\t  value_type>\n-\t  split_fn_t;\n-\n-        lhs.split(split_fn_t(), rhs);\n-\n-        typedef\n-\t  typename test_traits::template erase_if_fn<\n-\t  std::string>\n-\t  native_split_fn_t;\n-\n-        native_type native_rhs;\n-\n-        native_lhs.split(native_split_fn_t(), native_rhs);\n-\n-        PB_DS_COND_COMPARE(lhs, native_lhs);\n-        PB_DS_COND_COMPARE(rhs, native_rhs);\n-\n-        m_alloc.set_throw_prob(m_tp);\n-\n-        if (m_g.get_prob() < 0.5)\n-\t  lhs.swap(rhs);\n-\n-        lhs.join(rhs);\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      rhs.size() == 0,\n-\t\t\t      static_cast<unsigned long>(rhs.size()),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-\n-        PB_DS_THROW_IF_FAILED(\n-\t\t\t      rhs.empty(),\n-\t\t\t      static_cast<unsigned long>(rhs.size()),\n-\t\t\t      m_p_c,\n-\t\t\t      & m_native_c);\n-      }\n-    catch(__gnu_cxx::forced_exception_error& )\n-      {\n-        done = false;\n-\n-        PB_DS_THROW_IF_FAILED(            __gnu_pbds::container_traits<cntnr>::split_join_can_throw, __gnu_pbds::container_traits<cntnr>::split_join_can_throw, m_p_c, & m_native_c);\n-      }\n-\n-  PB_DS_COND_COMPARE(*m_p_c, m_native_c);\n-\n-  PB_DS_CANCEL_DESTRUCT_PRINT\n-\n-    return (done);\n-}"}, {"sha": "c74b1a06714f61f3ea725de0a8785adb66744702", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/rand_regression_test.hpp", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Frand_regression_test.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Frand_regression_test.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Frand_regression_test.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -49,11 +49,9 @@\n \n #include <iostream>\n #include <vector>\n-#include <regression/rand/priority_queue/container_rand_regression_test.hpp>\n #include <io/verified_cmd_line_input.hpp>\n-#include <common_type/priority_queue/common_type.hpp>\n-#include <regression/basic_type.hpp>\n-#include <regression/priority_queue/common_type.hpp>\n+#include <regression/common_type.hpp>\n+#include <regression/rand/priority_queue/container_rand_regression_test.h>\n \n namespace __gnu_pbds\n {"}, {"sha": "2e43eb35ddaec39e2fe9bf1b58964f8bd78d78f7", "filename": "libstdc++-v3/testsuite/util/regression/rand/xml_formatter.hpp", "status": "renamed", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fxml_formatter.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fxml_formatter.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fxml_formatter.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -53,35 +53,58 @@\n \n namespace __gnu_pbds\n {\n-\n   namespace test\n   {\n-\n-    class xml_result_set_regression_formatter : public xml_result_set_formatter\n+    // Test formatters.\n+    struct xml_test_rand_regression_formatter : public xml_test_formatter\n     {\n-    public:\n-      xml_result_set_regression_formatter(const std::string& r_container_name, const std::string& r_container_desc);\n-\n-      ~xml_result_set_regression_formatter();\n+      // Associative.\n+      xml_test_rand_regression_formatter(size_t sd, size_t n, size_t m, \n+\t\t\t\t\t double tp, double ip, double ep, \n+\t\t\t\t\t double cp, double mp)\n+      {\n+\tstd::cout << make_xml_tag(\"sd\", \"value\", sd);\n+\tstd::cout << make_xml_tag(\"n\", \"value\", n);\n+\tstd::cout << make_xml_tag(\"m\", \"value\", m);\n+\tstd::cout << make_xml_tag(\"tp\", \"value\", tp);\n+\tstd::cout << make_xml_tag(\"ip\", \"value\", ip);\n+\tstd::cout << make_xml_tag(\"ep\", \"value\", ep);\n+\tstd::cout << make_xml_tag(\"cp\", \"value\", cp);\n+\tstd::cout << make_xml_tag(\"mp\", \"value\", mp);\n+      }\n+\n+      // Priority Queue.\n+      xml_test_rand_regression_formatter(size_t sd, size_t n, size_t m, \n+\t\t\t\t\t double tp, double ip, double dp, \n+\t\t\t\t\t double ep, double cp, double mp)\n+      {\n+\tstd::cout << make_xml_tag(\"sd\", \"value\", sd);\n+\tstd::cout << make_xml_tag(\"n\", \"value\", n);\n+\tstd::cout << make_xml_tag(\"m\", \"value\", m);\n+\tstd::cout << make_xml_tag(\"tp\", \"value\", tp);\n+\tstd::cout << make_xml_tag(\"ip\", \"value\", ip);\n+\tstd::cout << make_xml_tag(\"dp\", \"value\", dp);\n+\tstd::cout << make_xml_tag(\"ep\", \"value\", ep);\n+\tstd::cout << make_xml_tag(\"cp\", \"value\", cp);\n+\tstd::cout << make_xml_tag(\"mp\", \"value\", mp);\n+      }\n     };\n \n-    xml_result_set_regression_formatter::\n-    xml_result_set_regression_formatter(const std::string& r_container_name, const std::string& r_container_desc) :\n-      xml_result_set_formatter(r_container_name, r_container_desc)\n+    // Result formatter.\n+    struct xml_result_set_regression_formatter : public xml_result_set_formatter\n     {\n-\n-      std::cout << detail::make_xml_name_start_tag(\"progress\");\n-      std::cout << detail::make_xml_name_start_tag_end_delimiter();\n-    }\n-\n-    xml_result_set_regression_formatter::\n-    ~xml_result_set_regression_formatter()\n-    {\n-      std::cout << detail::make_xml_name_end_tag(\"progress\");\n-    }\n-\n+      xml_result_set_regression_formatter(const std::string& r_container_name, \n+\t\t\t\t\t  const std::string& r_container_desc)\n+      : xml_result_set_formatter(r_container_name, r_container_desc)\n+      {\t\n+\tstd::cout << detail::make_xml_name_start_tag(\"progress\");\n+\tstd::cout << detail::make_xml_name_start_tag_end_delimiter();\n+      }\n+\n+      ~xml_result_set_regression_formatter()\n+      { std::cout << detail::make_xml_name_end_tag(\"progress\"); }      \n+    };\n   } // namespace test\n-\n } // namespace __gnu_pbds\n \n #endif // #ifndef PB_DS_COMMON_XML_TEST_REGRESSION_FORMATTER_HPP", "previous_filename": "libstdc++-v3/testsuite/util/regression/rand/io/xml_formatter.hpp"}, {"sha": "9e8e0f37bb7bbd79493a0331a4fc10a59f63ff40", "filename": "libstdc++-v3/testsuite/util/regression/trait/assoc/get_set_load_trait.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fget_set_load_trait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fget_set_load_trait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fget_set_load_trait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file get_set_load_trait.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n "}, {"sha": "d2fd190eea1dfc801c604fb2d54d693d9e144234", "filename": "libstdc++-v3/testsuite/util/regression/trait/assoc/get_set_loads_trait.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fget_set_loads_trait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fget_set_loads_trait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fget_set_loads_trait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file get_set_loads_trait.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n "}, {"sha": "f97609781a090745048b361bd0e7f4a2fe2a151b", "filename": "libstdc++-v3/testsuite/util/regression/trait/assoc/native_type_trait.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fnative_type_trait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fnative_type_trait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fnative_type_trait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file native_type_trait.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n "}, {"sha": "b54a9350e79f9af3b43e44ae4237c0e09d579838", "filename": "libstdc++-v3/testsuite/util/regression/trait/assoc/node_update_trait.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fnode_update_trait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fnode_update_trait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fnode_update_trait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file node_update_trait.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n "}, {"sha": "4c7d0268bb64e0eb022e6bf68629e866cb63acf2", "filename": "libstdc++-v3/testsuite/util/regression/trait/assoc/resize_trait.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fresize_trait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fresize_trait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fresize_trait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file resize_trait.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n "}, {"sha": "772fa172abc289dd8cec391791651f54172d9fed", "filename": "libstdc++-v3/testsuite/util/regression/trait/assoc/to_string.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fto_string.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fto_string.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Fto_string.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file to_string.hpp\n- * Containsert classes for transforming stuff to strings.\n+ * Contains classes for transforming stuff to strings.\n  */\n \n #ifndef PB_DS_REGRESSION_TEST_TO_STRING_HPP"}, {"sha": "1ce2a9e59e52bf9676292b084bf93e926ef694c5", "filename": "libstdc++-v3/testsuite/util/regression/trait/assoc/trait.hpp", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Ftrait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Ftrait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Ftrait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,21 +41,21 @@\n \n /**\n  * @file trait.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n \n #ifndef PB_DS_REGRESSION_TEST_TRAIT_HPP\n #define PB_DS_REGRESSION_TEST_TRAIT_HPP\n \n+#include <regression/trait/erase_if_fn.hpp>\n #include <regression/trait/assoc/to_string.hpp>\n #include <regression/trait/assoc/type_trait.hpp>\n #include <regression/trait/assoc/native_type_trait.hpp>\n #include <regression/trait/assoc/resize_trait.hpp>\n #include <regression/trait/assoc/get_set_loads_trait.hpp>\n #include <regression/trait/assoc/get_set_load_trait.hpp>\n #include <regression/trait/assoc/node_update_trait.hpp>\n-#include <regression/trait/erase_if_fn.hpp>\n \n namespace __gnu_pbds\n {\n@@ -104,14 +104,16 @@ namespace detail\n     typedef PB_DS_TYPE_TRAITS_C_DEC type_traits_base;\n \n   public:\n-    typedef typename Cntnr::key_type key_type;\n-    typedef typename Cntnr::const_key_reference const_key_reference;\n     typedef typename Cntnr::value_type value_type;\n     typedef typename Cntnr::const_reference const_reference;\n     typedef typename PB_DS_NATIVE_TYPE_TRAITS_C_DEC::type native_type;\n-    typedef typename native_type::key_type native_key_type;\n     typedef typename native_type::value_type native_value_type;\n \n+    // Only associative containers.\n+    typedef typename Cntnr::key_type key_type;\n+    typedef typename Cntnr::const_key_reference const_key_reference;\n+    typedef typename native_type::key_type native_key_type;\n+\n     enum\n       {\n \tresize = PB_DS_RESIZE_TRAITS_C_DEC::value,\n@@ -128,8 +130,7 @@ namespace detail\n     static size_t\n     erase_if(native_type& r_native_c)\n     {\n-      typedef regression_test_erase_if_fn<typename native_type::value_type> erase_if_fn;\n-\n+      typedef regression_test_erase_if_fn<native_value_type> erase_if_fn;\n       typename native_type::iterator it = r_native_c.begin();\n       size_t num_ersd = 0;\n       while (it != r_native_c.end())\n@@ -193,13 +194,9 @@ namespace detail\n     static bool\n     prefix_match(const_key_reference r_key, const std::string& r_native_key)\n     {\n-      const size_t native_substr_len = std::min(r_key.length(), \n-\t\t\t\t\t\tr_native_key.length());\n-\n-      const std::string native_substr = r_native_key.substr(0, \n-\t\t\t\t\t\t\t    native_substr_len);\n-\n-      return native_substr == (const std::string&) r_key;\n+      const size_t len = std::min(r_key.length(), r_native_key.length());\n+      const std::string substr = r_native_key.substr(0, len);\n+      return substr == static_cast<const std::string&>(r_key);\n     }\n   };\n "}, {"sha": "2764e434f75f95a7a466b9ade15ed1babd395d58", "filename": "libstdc++-v3/testsuite/util/regression/trait/assoc/type_trait.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Ftype_trait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Ftype_trait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fassoc%2Ftype_trait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file type_trait.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n "}, {"sha": "994259c4d4c62de6f4ef39a50ccf14d02b81b4bf", "filename": "libstdc++-v3/testsuite/util/regression/trait/erase_if_fn.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Ferase_if_fn.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Ferase_if_fn.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Ferase_if_fn.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file erase_if_fn.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n "}, {"sha": "34bf706d987d69951eeadad5cde407abaa462fd6", "filename": "libstdc++-v3/testsuite/util/regression/trait/priority_queue/trait.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fpriority_queue%2Ftrait.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fpriority_queue%2Ftrait.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Ftrait%2Fpriority_queue%2Ftrait.hpp?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -41,7 +41,7 @@\n \n /**\n  * @file trait.hpp\n- * Containsert traits for a random regression test\n+ * Contains traits for a random regression test\n  *    for a specific container type.\n  */\n "}, {"sha": "a0c74586a4165f6ae0f49f87e048a194986e3d28", "filename": "libstdc++-v3/testsuite/util/rng/twister_rand_gen.cc", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Frng%2Ftwister_rand_gen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffc9d793fd01df2420a39b2544860f9bae16848/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Frng%2Ftwister_rand_gen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Frng%2Ftwister_rand_gen.cc?ref=bffc9d793fd01df2420a39b2544860f9bae16848", "patch": "@@ -1,95 +0,0 @@\n-// -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n-// of the GNU General Public License as published by the Free Software\n-// Foundation; either version 2, or (at your option) any later\n-// version.\n-\n-// This library is distributed in the hope that it will be useful, but\n-// WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free\n-// software library without restriction.  Specifically, if other files\n-// instantiate templates or use macros or inline functions from this\n-// file, or you compile this file and link it with other files to\n-// produce an executable, this file does not by itself cause the\n-// resulting executable to be covered by the GNU General Public\n-// License.  This exception does not however invalidate any other\n-// reasons why the executable file might be covered by the GNU General\n-// Public License.\n-\n-// Copyright (C) 2004 Ami Tavory and Vladimir Dreizin, IBM-HRL.\n-\n-// Permission to use, copy, modify, sell, and distribute this software\n-// is hereby granted without fee, provided that the above copyright\n-// notice appears in all copies, and that both that copyright notice\n-// and this permission notice appear in supporting documentation. None\n-// of the above authors, nor IBM Haifa Research Laboratories, make any\n-// representation about the suitability of this software for any\n-// purpose. It is provided \"as is\" without express or implied\n-// warranty.\n-\n-/**\n- * @file twister_rand_gen.cc\n- */\n-\n-#include <ctime>\n-#include <debug/debug.h>\n-#include <util/rng/twister_rand_gen.hpp>\n-\n-namespace __gnu_pbds\n-{\n-  namespace test\n-  {\n-    twister_rand_gen::\n-    twister_rand_gen(unsigned int seed)\n-    : m_base_generator(seed)\n-    {\n-      // Do nothing.\n-    }\n-\n-    void\n-    twister_rand_gen::\n-    init(unsigned int seed)\n-    { m_base_generator.seed(seed); }\n-\n-    unsigned long\n-    twister_rand_gen::\n-    get_unsigned_long(unsigned long min, unsigned long max)\n-    {\n-      _GLIBCXX_DEBUG_ASSERT(max >= min);\n-      const double prob = get_prob();\n-      const unsigned long rand_word = \n-\t(unsigned long)((max - min + 1) * prob) + min;\n-\n-      _GLIBCXX_DEBUG_ASSERT(rand_word <= max);\n-      return rand_word;\n-    }\n-\n-    double\n-    twister_rand_gen::\n-    get_prob()\n-    {\n-      const double eng_min = m_base_generator.min();\n-      const double eng_range =\n-\tstatic_cast<const double>(m_base_generator.max() - eng_min);\n-\n-      const double eng_res =\n-\tstatic_cast<const double>(m_base_generator() - eng_min);\n-\n-      const double ret = eng_res / eng_range;\n-      _GLIBCXX_DEBUG_ASSERT(ret >= 0 && ret <= 1);\n-      return ret;\n-    }\n-  } // namespace test\n-} // namespace __gnu_pbds"}, {"sha": "4cc076f13e208a4ca7575bee4c06d269329aea15", "filename": "libstdc++-v3/testsuite/util/testsuite_rng.h", "status": "renamed", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rng.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rng.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rng.h?ref=2e3f9c21d5c3091c6cfdc99f94c7b269eaec8f54", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -40,14 +40,15 @@\n // warranty.\n \n /**\n- * @file twister_rand_gen.hpp\n+ * @file testsuite_rng.h\n  */\n \n-#ifndef PB_DS_TWISTER_RAND_GEN_HPP\n-#define PB_DS_TWISTER_RAND_GEN_HPP\n+#ifndef _GLIBCXX_TESTSUITE_RNG_H\n+#define _GLIBCXX_TESTSUITE_RNG_H\n \n #include <ctime>\n-#include <limits.h>\n+#include <climits>\n+#include <debug/debug.h>\n #include <tr1/random>\n \n namespace __gnu_pbds\n@@ -58,29 +59,49 @@ namespace __gnu_pbds\n     {\n     public:\n       twister_rand_gen(unsigned int seed = \n-\t\t       static_cast<unsigned int>(std::time(0)));\n+\t\t       static_cast<unsigned int>(std::time(0)))\n+      : m_base_generator(seed)\n+      {\n+\t// Do nothing.\n+      }\n \n       void\n-      init(unsigned int seed);\n+      init(unsigned int seed)\n+      { m_base_generator.seed(seed); }\n \n       static unsigned int\n       get_time_determined_seed()\n       { return(static_cast<unsigned int>(std::time(0))); }\n \n       unsigned long\n       get_unsigned_long(unsigned long min = 0, \n-\t\t\tunsigned long max = UINT_MAX - 1);\n+\t\t\tunsigned long max = UINT_MAX - 1)\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(max >= min);\n+\tconst double prob = get_prob();\n+\tconst unsigned long r = (unsigned long)((max - min + 1) * prob) + min;\n+\t_GLIBCXX_DEBUG_ASSERT(r <= max);\n+\treturn r;\n+      }\n \n       double\n-      get_prob();\n+      get_prob()\n+      {\n+\tconst double min = m_base_generator.min();\n+\tconst double max = m_base_generator.max();\n+\tconst double range = static_cast<const double>(max - min);\n+\tconst double res = static_cast<const double>(m_base_generator() - min);\n+\tconst double ret = res / range;\n+\t_GLIBCXX_DEBUG_ASSERT(ret >= 0 && ret <= 1);\n+\treturn ret;\n+      }\n \n     private:\n       typedef std::tr1::mt19937 base_generator_t;\n \n-    private:\n       base_generator_t m_base_generator;\n     };\n   } // namespace test\n } // namespace __gnu_pbds\n \n-#endif // #ifndef PB_DS_TWISTER_RAND_GEN_HPP\n+#endif // #ifndef _GLIBCXX_TESTSUITE_RNG_H", "previous_filename": "libstdc++-v3/testsuite/util/rng/twister_rand_gen.hpp"}]}