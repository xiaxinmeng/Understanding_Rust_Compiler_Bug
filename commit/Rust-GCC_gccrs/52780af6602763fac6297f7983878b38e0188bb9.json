{"sha": "52780af6602763fac6297f7983878b38e0188bb9", "node_id": "C_kwDOANBUbNoAKDUyNzgwYWY2NjAyNzYzZmFjNjI5N2Y3OTgzODc4YjM4ZTAxODhiYjk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-13T22:01:59Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-14T12:32:40Z"}, "message": "Redesign constant folding from the typechecking pass to the backend\n\nIn Rust the ArrayType has a constant capacity constraint, this means it\nallows for bounds checking at compile time as no variable length arrays are\nallowed. In order to typecheck this case we had a constant folding pass as\npart of the typechecking system which generated gcc tree's for the IR\nand enforced the constant checking along the way.\n\nAlso after doing some testing GCC with optimizations turned on is capable\nof constant folding/propogating the compilation unit fully. Which meant we\nneed a method of doing with regardless of optimization level to be able\nto be on par with what the Rust language expects we need a full proof\nmethod. Turns out the CPP front-end already does this via its constexpr\nmechanism to ensure that these _do_ fold correclty. Another major reason\nto do this change is that the original const fold pass was a striped down\ncopy of what the backend is _already_ doing which is creating a duplication\nof the code generation pass. With this all unified into the code generation\npass all we need to do is port over gcc/cp/constexpr.c to enforce the const\nrules fully but at the GCC tree level not at the typed HIR level.\n\nNow that we have unified the pass when we hit a const function we can\nsimply emit a normal GCC function and outside of const expressions GCC\nwill simply emit a normal CallExpr and depending on optimization level\nfully optimize this. If we are in a ConstDecl we will follow the\nrust-constexpr.cc and fold the values or error_mark_node with an apropriate\nerror. By reusing the CPP constexpr code we _know_ it works so reusing it\nas much as possible is a good idea in general for this front-end.\n\nAddresses #799", "tree": {"sha": "41a8d89d018f527b3f20159da1279f67aac71f40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41a8d89d018f527b3f20159da1279f67aac71f40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52780af6602763fac6297f7983878b38e0188bb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52780af6602763fac6297f7983878b38e0188bb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52780af6602763fac6297f7983878b38e0188bb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52780af6602763fac6297f7983878b38e0188bb9/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c2a74f557ec98896c9f71ba666bd969c4735d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c2a74f557ec98896c9f71ba666bd969c4735d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c2a74f557ec98896c9f71ba666bd969c4735d2"}], "stats": {"total": 2075, "additions": 1013, "deletions": 1062}, "files": [{"sha": "dcb2d2cafcecc2af41c86169cb894ac318f4f151", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -85,7 +85,6 @@ GRS_OBJS = \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n-    rust/rust-hir-const-fold.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n     rust/rust-hir-address-taken.o \\\n@@ -98,6 +97,7 @@ GRS_OBJS = \\\n     rust/rust-base62.o \\\n     rust/rust-compile-expr.o \\\n     rust/rust-compile-type.o \\\n+    rust/rust-constexpr.o \\\n     $(END)\n # removed object files from here\n \n@@ -107,7 +107,7 @@ RUST_ALL_OBJS = $(GRS_OBJS) $(RUST_TARGET_OBJS)\n rust_OBJS = $(RUST_ALL_OBJS) rust/rustspec.o\n \n # The compiler itself is called rust1 (formerly grs1)\n-rust1$(exeext): $(RUST_ALL_OBJS) attribs.o  $(BACKEND) $(LIBDEPS)\n+rust1$(exeext): $(RUST_ALL_OBJS) attribs.o $(BACKEND) $(LIBDEPS)\n \t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n \t      $(RUST_ALL_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n "}, {"sha": "2169ea5d56c14a221c7609237149e133c30ec219", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -44,8 +44,9 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n   bool compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n \t\t\t\t std::vector<Bvariable *> &locals);\n \n-  tree coercion_site (tree compiled_ref, TyTy::BaseType *actual,\n-\t\t      TyTy::BaseType *expected, Location locus);\n+  tree coercion_site (tree rvalue, TyTy::BaseType *actual,\n+\t\t      TyTy::BaseType *expected, Location lvalue_locus,\n+\t\t      Location rvalue_locus);\n \n   tree coerce_to_dyn_object (tree compiled_ref, const TyTy::BaseType *actual,\n \t\t\t     const TyTy::BaseType *expected,\n@@ -57,6 +58,9 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n     std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n       &receiver_bounds,\n     const TyTy::BaseType *receiver, const TyTy::BaseType *root, Location locus);\n+\n+  bool verify_array_capacities (tree ltype, tree rtype, Location ltype_locus,\n+\t\t\t\tLocation rtype_locus);\n };\n \n } // namespace Compile"}, {"sha": "9be9801dea75068a2b6359f4b86ed6f9282686f5", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -27,7 +27,6 @@\n #include \"rust-compile-tyty.h\"\n #include \"rust-ast-full.h\"\n #include \"rust-hir-full.h\"\n-#include \"rust-hir-const-fold-ctx.h\"\n #include \"rust-mangle.h\"\n \n namespace Rust {\n@@ -45,8 +44,7 @@ class Context\n   Context (::Backend *backend)\n     : backend (backend), resolver (Resolver::Resolver::get ()),\n       tyctx (Resolver::TypeCheckContext::get ()),\n-      mappings (Analysis::Mappings::get ()),\n-      const_ctx (ConstFold::Context::get ()), mangler (Mangler ())\n+      mappings (Analysis::Mappings::get ()), mangler (Mangler ())\n   {\n     // insert the builtins\n     auto builtins = resolver->get_builtin_types ();\n@@ -110,7 +108,6 @@ class Context\n   Resolver::Resolver *get_resolver () { return resolver; }\n   Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n   Analysis::Mappings *get_mappings () { return mappings; }\n-  ConstFold::Context *get_const_ctx () { return const_ctx; }\n \n   void push_block (tree scope)\n   {\n@@ -315,7 +312,6 @@ class Context\n   Resolver::Resolver *resolver;\n   Resolver::TypeCheckContext *tyctx;\n   Analysis::Mappings *mappings;\n-  ConstFold::Context *const_ctx;\n   std::set<HirId> builtin_range;\n   Mangler mangler;\n "}, {"sha": "33237e5f5a977cc7575e1dfc3280d9a1a859bde1", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 232, "deletions": 3, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -25,10 +25,12 @@\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n #include \"rust-compile-pattern.h\"\n+#include \"rust-constexpr.h\"\n \n #include \"fold-const.h\"\n #include \"realmpfr.h\"\n #include \"convert.h\"\n+#include \"print-tree.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -381,7 +383,11 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t  rust_assert (ok);\n \n \t  // coerce it if required\n-\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\t  Location lvalue_locus\n+\t    = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+\t  Location rvalue_locus = argument->get_locus ();\n+\t  rvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n+\t\t\t\t  rvalue_locus);\n \n \t  // add it to the list\n \t  arguments.push_back (rvalue);\n@@ -477,7 +483,11 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       rust_assert (ok);\n \n       // coerce it if required\n-      rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+      Location lvalue_locus\n+\t= ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+      Location rvalue_locus = argument->get_locus ();\n+      rvalue\n+\t= coercion_site (rvalue, actual, expected, lvalue_locus, rvalue_locus);\n \n       // add it to the list\n       args.push_back (rvalue);\n@@ -604,7 +614,11 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       rust_assert (ok);\n \n       // coerce it if required\n-      rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+      Location lvalue_locus\n+\t= ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+      Location rvalue_locus = argument->get_locus ();\n+      rvalue\n+\t= coercion_site (rvalue, actual, expected, lvalue_locus, rvalue_locus);\n \n       // add it to the list\n       args.push_back (rvalue);\n@@ -1093,5 +1107,220 @@ CompileExpr::type_cast_expression (tree type_to_cast_to, tree expr_tree,\n \t\t\t   expr_tree);\n }\n \n+void\n+CompileExpr::visit (HIR::ArrayExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this array expr\");\n+      return;\n+    }\n+\n+  tree array_type = TyTyResolveCompile::compile (ctx, tyty);\n+  if (TREE_CODE (array_type) != ARRAY_TYPE)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  rust_assert (tyty->get_kind () == TyTy::TypeKind::ARRAY);\n+  const TyTy::ArrayType &array_tyty\n+    = static_cast<const TyTy::ArrayType &> (*tyty);\n+\n+  HIR::ArrayElems &elements = *expr.get_internal_elements ();\n+  switch (elements.get_array_expr_type ())\n+    {\n+      case HIR::ArrayElems::ArrayExprType::VALUES: {\n+\tHIR::ArrayElemsValues &elems\n+\t  = static_cast<HIR::ArrayElemsValues &> (elements);\n+\ttranslated\n+\t  = array_value_expr (expr.get_locus (), array_tyty, array_type, elems);\n+      }\n+      return;\n+\n+    case HIR::ArrayElems::ArrayExprType::COPIED:\n+      HIR::ArrayElemsCopied &elems\n+\t= static_cast<HIR::ArrayElemsCopied &> (elements);\n+      translated\n+\t= array_copied_expr (expr.get_locus (), array_tyty, array_type, elems);\n+    }\n+}\n+\n+tree\n+CompileExpr::array_value_expr (Location expr_locus,\n+\t\t\t       const TyTy::ArrayType &array_tyty,\n+\t\t\t       tree array_type, HIR::ArrayElemsValues &elems)\n+{\n+  std::vector<unsigned long> indexes;\n+  std::vector<tree> constructor;\n+  size_t i = 0;\n+  for (auto &elem : elems.get_values ())\n+    {\n+      tree translated_expr = CompileExpr::Compile (elem.get (), ctx);\n+      constructor.push_back (translated_expr);\n+      indexes.push_back (i++);\n+    }\n+\n+  return ctx->get_backend ()->array_constructor_expression (array_type, indexes,\n+\t\t\t\t\t\t\t    constructor,\n+\t\t\t\t\t\t\t    expr_locus);\n+}\n+\n+tree\n+CompileExpr::array_copied_expr (Location expr_locus,\n+\t\t\t\tconst TyTy::ArrayType &array_tyty,\n+\t\t\t\ttree array_type, HIR::ArrayElemsCopied &elems)\n+{\n+  //  see gcc/cp/typeck2.c:1369-1401\n+  gcc_assert (TREE_CODE (array_type) == ARRAY_TYPE);\n+  tree domain = TYPE_DOMAIN (array_type);\n+  if (!domain)\n+    return error_mark_node;\n+\n+  if (!TREE_CONSTANT (TYPE_MAX_VALUE (domain)))\n+    {\n+      rust_error_at (expr_locus, \"non const capacity domain %qT\", array_type);\n+      return error_mark_node;\n+    }\n+\n+  tree capacity_expr = CompileExpr::Compile (elems.get_num_copies_expr (), ctx);\n+  if (!TREE_CONSTANT (capacity_expr))\n+    {\n+      rust_error_at (expr_locus, \"non const num copies %qT\", array_type);\n+      return error_mark_node;\n+    }\n+\n+  // get the compiled value\n+  tree translated_expr = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n+\n+  tree max_domain = TYPE_MAX_VALUE (domain);\n+  tree min_domain = TYPE_MIN_VALUE (domain);\n+\n+  auto max = wi::to_offset (max_domain);\n+  auto min = wi::to_offset (min_domain);\n+  auto precision = TYPE_PRECISION (TREE_TYPE (domain));\n+  auto sign = TYPE_SIGN (TREE_TYPE (domain));\n+  unsigned HOST_WIDE_INT len\n+    = wi::ext (max - min + 1, precision, sign).to_uhwi ();\n+\n+  // create the constructor\n+  size_t idx = 0;\n+  std::vector<unsigned long> indexes;\n+  std::vector<tree> constructor;\n+  for (unsigned HOST_WIDE_INT i = 0; i < len; i++)\n+    {\n+      constructor.push_back (translated_expr);\n+      indexes.push_back (idx++);\n+    }\n+\n+  return ctx->get_backend ()->array_constructor_expression (array_type, indexes,\n+\t\t\t\t\t\t\t    constructor,\n+\t\t\t\t\t\t\t    expr_locus);\n+}\n+\n+// tree\n+// CompileExpr::array_copied_expr (Location expr_locus, tree array_type,\n+// \t\t\t\tHIR::ArrayElemsCopied &elems)\n+// {\n+//   // create tmp for the result\n+//   fncontext fnctx = ctx->peek_fn ();\n+//   Location start_location = expr_locus;\n+//   Location end_location = expr_locus;\n+//   tree fndecl = fnctx.fndecl;\n+//   tree enclosing_scope = ctx->peek_enclosing_scope ();\n+\n+//   bool is_address_taken = false;\n+//   tree result_var_stmt = nullptr;\n+//   Bvariable *result\n+//     = ctx->get_backend ()->temporary_variable (fnctx.fndecl,\n+//     enclosing_scope,\n+// \t\t\t\t\t       array_type, NULL,\n+// \t\t\t\t\t       is_address_taken, expr_locus,\n+// \t\t\t\t\t       &result_var_stmt);\n+//   ctx->add_statement (result_var_stmt);\n+\n+//   // get the compiled value\n+//   tree translated_expr = CompileExpr::Compile (elems.get_elem_to_copy (),\n+//   ctx);\n+\n+//   // lets assign each index in the array\n+//   TyTy::BaseType *capacity_tyty = nullptr;\n+//   HirId capacity_ty_id\n+//     = elems.get_num_copies_expr ()->get_mappings ().get_hirid ();\n+//   bool ok = ctx->get_tyctx ()->lookup_type (capacity_ty_id,\n+//   &capacity_tyty); rust_assert (ok); tree capacity_type =\n+//   TyTyResolveCompile::compile (ctx, capacity_tyty); tree capacity_expr =\n+//   CompileExpr::Compile (elems.get_num_copies_expr (), ctx);\n+\n+//   // create a loop for this with assignments to array_index exprs\n+//   tree index_type = capacity_type;\n+//   Bvariable *idx\n+//     = ctx->get_backend ()->temporary_variable (fnctx.fndecl,\n+//     enclosing_scope,\n+// \t\t\t\t\t       index_type, NULL,\n+// \t\t\t\t\t       is_address_taken, expr_locus,\n+// \t\t\t\t\t       &result_var_stmt);\n+//   ctx->add_statement (result_var_stmt);\n+\n+//   // set index to zero\n+//   tree index_lvalue = error_mark_node;\n+//   tree zero = build_int_cst (index_type, 0);\n+//   tree index_assignment\n+//     = ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n+//     index_lvalue,\n+// \t\t\t\t\t\t zero, expr_locus);\n+//   ctx->add_statement (index_assignment);\n+\n+//   // BEGIN loop block\n+//   tree loop_body = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+// \t\t\t\t\t       start_location, end_location);\n+//   ctx->push_block (loop_body);\n+\n+//   // loop predicate\n+//   tree loop_predicate\n+//     = fold_build2_loc (expr_locus.gcc_location (), GE_EXPR,\n+//     boolean_type_node,\n+// \t\t       ctx->get_backend ()->var_expression (idx, expr_locus),\n+// \t\t       capacity_expr);\n+//   tree exit_expr = fold_build1_loc (expr_locus.gcc_location (), EXIT_EXPR,\n+// \t\t\t\t    void_type_node, loop_predicate);\n+//   tree break_stmt\n+//     = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n+//   ctx->add_statement (break_stmt);\n+\n+//   // increment index\n+//   tree increment\n+//     = fold_build2_loc (expr_locus.gcc_location (), POSTINCREMENT_EXPR,\n+// \t\t       index_type,\n+// \t\t       ctx->get_backend ()->var_expression (idx, expr_locus),\n+// \t\t       build_int_cst (index_type, 1));\n+\n+//   // create index_assess\n+//   tree index_access = ctx->get_backend ()->array_index_expression (\n+//     ctx->get_backend ()->var_expression (result, expr_locus), increment,\n+//     expr_locus);\n+\n+//   // create assignment to index_access\n+//   tree array_assignment\n+//     = ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n+//     index_access,\n+// \t\t\t\t\t\t translated_expr, expr_locus);\n+//   ctx->add_statement (array_assignment);\n+\n+//   // END loop block\n+//   ctx->pop_block ();\n+\n+//   tree loop_expr = ctx->get_backend ()->loop_expression (loop_body,\n+//   expr_locus); tree loop_stmt\n+//     = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n+//   ctx->add_statement (loop_stmt);\n+\n+//   // result is the tmp\n+//   return ctx->get_backend ()->var_expression (result, expr_locus);\n+// }\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "b5047d0bb690798957704e20eb43251a9fac48db", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 21, "deletions": 60, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -290,7 +290,9 @@ class CompileExpr : public HIRCompileBase\n       expr.get_rhs ()->get_mappings ().get_hirid (), &actual);\n     rust_assert (ok);\n \n-    rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+    rvalue\n+      = coercion_site (rvalue, actual, expected, expr.get_lhs ()->get_locus (),\n+\t\t       expr.get_rhs ()->get_locus ());\n \n     tree assignment\n       = ctx->get_backend ()->assignment_statement (fn.fndecl, lvalue, rvalue,\n@@ -332,56 +334,7 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t     expr.get_locus ());\n   }\n \n-  void visit (HIR::ArrayExpr &expr) override\n-  {\n-    TyTy::BaseType *tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &tyty))\n-      {\n-\trust_fatal_error (expr.get_locus (),\n-\t\t\t  \"did not resolve type for this array expr\");\n-\treturn;\n-      }\n-\n-    rust_assert (tyty->get_kind () == TyTy::TypeKind::ARRAY);\n-    TyTy::ArrayType *array_tyty = static_cast<TyTy::ArrayType *> (tyty);\n-    capacity_expr = array_tyty->get_capacity ();\n-\n-    tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n-    rust_assert (array_type != nullptr);\n-\n-    expr.get_internal_elements ()->accept_vis (*this);\n-    std::vector<unsigned long> indexes;\n-    for (size_t i = 0; i < constructor.size (); i++)\n-      indexes.push_back (i);\n-\n-    translated\n-      = ctx->get_backend ()->array_constructor_expression (array_type, indexes,\n-\t\t\t\t\t\t\t   constructor,\n-\t\t\t\t\t\t\t   expr.get_locus ());\n-  }\n-\n-  void visit (HIR::ArrayElemsValues &elems) override\n-  {\n-    for (auto &elem : elems.get_values ())\n-      {\n-\ttree translated_expr = CompileExpr::Compile (elem.get (), ctx);\n-\tconstructor.push_back (translated_expr);\n-      }\n-  }\n-\n-  void visit (HIR::ArrayElemsCopied &elems) override\n-  {\n-    tree translated_expr\n-      = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n-\n-    size_t capacity;\n-    bool ok = ctx->get_backend ()->const_size_cast (capacity_expr, &capacity);\n-    rust_assert (ok);\n-\n-    for (size_t i = 0; i < capacity; ++i)\n-      constructor.push_back (translated_expr);\n-  }\n+  void visit (HIR::ArrayExpr &expr) override;\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr) override;\n \n@@ -605,14 +558,18 @@ class CompileExpr : public HIRCompileBase\n     std::vector<tree> arguments;\n     for (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n       {\n-\tauto &argument = struct_expr.get_fields ().at (i);\n-\tauto rvalue = CompileStructExprField::Compile (argument.get (), ctx);\n-\n \t// assignments are coercion sites so lets convert the rvalue if\n \t// necessary\n \tauto respective_field = variant->get_field_at_index (i);\n \tauto expected = respective_field->get_field_type ();\n \n+\t// process arguments\n+\tauto &argument = struct_expr.get_fields ().at (i);\n+\tauto lvalue_locus\n+\t  = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+\tauto rvalue_locus = argument->get_locus ();\n+\tauto rvalue = CompileStructExprField::Compile (argument.get (), ctx);\n+\n \tTyTy::BaseType *actual = nullptr;\n \tbool ok = ctx->get_tyctx ()->lookup_type (\n \t  argument->get_mappings ().get_hirid (), &actual);\n@@ -621,8 +578,8 @@ class CompileExpr : public HIRCompileBase\n \t// compile/torture/struct_base_init_1.rs\n \tif (ok)\n \t  {\n-\t    rvalue = coercion_site (rvalue, actual, expected,\n-\t\t\t\t    argument->get_locus ());\n+\t    rvalue = coercion_site (rvalue, actual, expected, lvalue_locus,\n+\t\t\t\t    rvalue_locus);\n \t  }\n \n \t// add it to the list\n@@ -998,15 +955,19 @@ class CompileExpr : public HIRCompileBase\n \n   tree type_cast_expression (tree type_to_cast_to, tree expr, Location locus);\n \n+  tree array_value_expr (Location expr_locus, const TyTy::ArrayType &array_tyty,\n+\t\t\t tree array_type, HIR::ArrayElemsValues &elems);\n+\n+  tree array_copied_expr (Location expr_locus,\n+\t\t\t  const TyTy::ArrayType &array_tyty, tree array_type,\n+\t\t\t  HIR::ArrayElemsCopied &elems);\n+\n private:\n   CompileExpr (Context *ctx)\n-    : HIRCompileBase (ctx), translated (error_mark_node),\n-      capacity_expr (nullptr)\n+    : HIRCompileBase (ctx), translated (error_mark_node)\n   {}\n \n   tree translated;\n-  tree capacity_expr;\n-  std::vector<tree> constructor;\n };\n \n } // namespace Compile"}, {"sha": "61749507ae95271a0ebe600886fd94a422c2c7f4", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -27,6 +27,7 @@\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-fnparam.h\"\n #include \"rust-compile-extern.h\"\n+#include \"rust-constexpr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -97,7 +98,10 @@ class CompileItem : public HIRCompileBase\n     rust_assert (ok);\n \n     tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n+\n     tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree folded_expr = ConstCtx::fold (value);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -107,7 +111,8 @@ class CompileItem : public HIRCompileBase\n \n     std::string ident = canonical_path->get ();\n     tree const_expr\n-      = ctx->get_backend ()->named_constant_expression (type, ident, value,\n+      = ctx->get_backend ()->named_constant_expression (const_type, ident,\n+\t\t\t\t\t\t\tfolded_expr,\n \t\t\t\t\t\t\tconstant.get_locus ());\n \n     ctx->push_const (const_expr);\n@@ -183,6 +188,10 @@ class CompileItem : public HIRCompileBase\n     if (is_main_fn || function.has_visibility ())\n       flags |= Backend::function_is_visible;\n \n+    // is it a const function?\n+    if (function.get_qualifiers ().is_const ())\n+      flags |= Backend::function_read_only;\n+\n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     bool ok = ctx->get_mappings ()->lookup_canonical_path (\n       function.get_mappings ().get_crate_num (),"}, {"sha": "ffda6526e3c8117ca3a409f332cc2d67cb9cbd41", "filename": "gcc/rust/backend/rust-compile-pattern.cc", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -17,6 +17,8 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-pattern.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-constexpr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -46,20 +48,33 @@ CompilePatternCaseLabelExpr::visit (HIR::PathInExpression &pattern)\n   ok = adt->lookup_variant_by_id (variant_id, &variant);\n   rust_assert (ok);\n \n-  mpz_t disciminantl;\n-  if (variant->get_variant_type () == TyTy::VariantDef::VariantType::NUM)\n+  tree case_low = error_mark_node;\n+  if (variant->is_specified_discriminant_node ())\n     {\n-      mpz_init_set_ui (disciminantl, variant->get_discriminant ());\n+      auto discrim_node = variant->get_discriminant_node ();\n+      auto &discrim_expr = discrim_node->get_discriminant_expression ();\n+\n+      tree discrim_expr_node = CompileExpr::Compile (discrim_expr.get (), ctx);\n+      tree folded_discrim_expr = ConstCtx::fold (discrim_expr_node);\n+      case_low = folded_discrim_expr;\n     }\n   else\n     {\n-      HirId variant_id = variant->get_id ();\n-      mpz_init_set_ui (disciminantl, variant_id);\n-    }\n+      mpz_t disciminantl;\n+      if (variant->get_variant_type () == TyTy::VariantDef::VariantType::NUM)\n+\t{\n+\t  mpz_init_set_ui (disciminantl, variant->get_discriminant ());\n+\t}\n+      else\n+\t{\n+\t  HirId variant_id = variant->get_id ();\n+\t  mpz_init_set_ui (disciminantl, variant_id);\n+\t}\n \n-  tree t = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n-  tree case_low\n-    = double_int_to_tree (t, mpz_get_double_int (t, disciminantl, true));\n+      tree t = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n+      case_low\n+\t= double_int_to_tree (t, mpz_get_double_int (t, disciminantl, true));\n+    }\n \n   case_label_expr\n     = build_case_label (case_low, NULL_TREE, associated_case_label);"}, {"sha": "c1d0778ff5e5689a45efb12fbfdf494df2abfeee", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -95,11 +95,24 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       tree compiled_adt_type = TyTyResolveCompile::compile (ctx, adt);\n \n       // make the ctor for the union\n-      mpz_t val;\n-      mpz_init_set_ui (val, variant->get_discriminant ());\n-      tree t = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n-      tree qualifier\n-\t= double_int_to_tree (t, mpz_get_double_int (t, val, true));\n+      tree qualifier = error_mark_node;\n+      if (variant->is_specified_discriminant_node ())\n+\t{\n+\t  auto discrim_node = variant->get_discriminant_node ();\n+\t  auto &discrim_expr = discrim_node->get_discriminant_expression ();\n+\n+\t  tree discrim_expr_node\n+\t    = CompileExpr::Compile (discrim_expr.get (), ctx);\n+\t  tree folded_discrim_expr = ConstCtx::fold (discrim_expr_node);\n+\t  qualifier = folded_discrim_expr;\n+\t}\n+      else\n+\t{\n+\t  mpz_t val;\n+\t  mpz_init_set_ui (val, variant->get_discriminant ());\n+\t  tree t = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n+\t  qualifier = double_int_to_tree (t, mpz_get_double_int (t, val, true));\n+\t}\n \n       return ctx->get_backend ()->constructor_expression (compiled_adt_type,\n \t\t\t\t\t\t\t  true, {qualifier},"}, {"sha": "3e73ccecd60e82c0753fb820e520f211109a7262", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -112,8 +112,10 @@ class CompileStmt : public HIRCompileBase\n       stmt.get_init_expr ()->get_mappings ().get_hirid (), &actual);\n     rust_assert (ok);\n \n+    Location lvalue_locus = stmt.get_pattern ()->get_locus ();\n+    Location rvalue_locus = stmt.get_init_expr ()->get_locus ();\n     TyTy::BaseType *expected = ty;\n-    init = coercion_site (init, actual, expected, stmt.get_locus ());\n+    init = coercion_site (init, actual, expected, lvalue_locus, rvalue_locus);\n \n     auto fnctx = ctx->peek_fn ();\n     if (ty->is_unit ())"}, {"sha": "d7a8ae56758471da7d1ee7b3138d06a1d6c79a38", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -17,8 +17,11 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-type.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-constexpr.h\"\n \n #include \"tree.h\"\n+#include \"print-tree.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -63,13 +66,15 @@ TyTyResolveCompile::get_implicit_enumeral_node_type (Context *ctx)\n void\n TyTyResolveCompile::visit (const TyTy::ErrorType &)\n {\n-  gcc_unreachable ();\n+  translated = error_mark_node;\n }\n+\n void\n TyTyResolveCompile::visit (const TyTy::InferType &)\n {\n-  gcc_unreachable ();\n+  translated = error_mark_node;\n }\n+\n void\n TyTyResolveCompile::visit (const TyTy::ClosureType &)\n {\n@@ -332,8 +337,11 @@ TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n {\n   tree element_type\n     = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n+  tree capacity_expr = CompileExpr::Compile (&type.get_capacity_expr (), ctx);\n+  tree folded_capacity_expr = ConstCtx::fold (capacity_expr);\n+\n   translated\n-    = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n+    = ctx->get_backend ()->array_type (element_type, folded_capacity_expr);\n }\n \n void"}, {"sha": "4d9c7805234acf378a8b88de5cb7c56a8cb7d2a3", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -63,13 +63,14 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n private:\n   TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n-    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr),\n-      recursion_count (0)\n+    : ctx (ctx), trait_object_mode (trait_object_mode),\n+      translated (error_mark_node), recursion_count (0)\n   {}\n \n   Context *ctx;\n   bool trait_object_mode;\n   tree translated;\n+\n   size_t recursion_count;\n \n   static const size_t kDefaultRecusionLimit = 5;"}, {"sha": "b12860d8ae4b524db5aa9e0e8a91dd1ed1981c78", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -288,21 +288,33 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n }\n \n tree\n-HIRCompileBase::coercion_site (tree compiled_ref, TyTy::BaseType *actual,\n-\t\t\t       TyTy::BaseType *expected, Location locus)\n+HIRCompileBase::coercion_site (tree rvalue, TyTy::BaseType *actual,\n+\t\t\t       TyTy::BaseType *expected, Location lvalue_locus,\n+\t\t\t       Location rvalue_locus)\n {\n   auto root_actual_kind = actual->get_root ()->get_kind ();\n   auto root_expected_kind = expected->get_root ()->get_kind ();\n \n-  if (root_expected_kind == TyTy::TypeKind::DYNAMIC\n-      && root_actual_kind != TyTy::TypeKind::DYNAMIC)\n+  if (root_expected_kind == TyTy::TypeKind::ARRAY\n+      && root_actual_kind == TyTy::TypeKind::ARRAY)\n+    {\n+      tree tree_rval_type\n+\t= TyTyResolveCompile::compile (ctx, actual->get_root ());\n+      tree tree_lval_type\n+\t= TyTyResolveCompile::compile (ctx, expected->get_root ());\n+      if (!verify_array_capacities (tree_lval_type, tree_rval_type,\n+\t\t\t\t    lvalue_locus, rvalue_locus))\n+\treturn error_mark_node;\n+    }\n+  else if (root_expected_kind == TyTy::TypeKind::DYNAMIC\n+\t   && root_actual_kind != TyTy::TypeKind::DYNAMIC)\n     {\n       const TyTy::DynamicObjectType *dyn\n \t= static_cast<const TyTy::DynamicObjectType *> (expected->get_root ());\n-      return coerce_to_dyn_object (compiled_ref, actual, expected, dyn, locus);\n+      return coerce_to_dyn_object (rvalue, actual, expected, dyn, rvalue_locus);\n     }\n \n-  return compiled_ref;\n+  return rvalue;\n }\n \n tree\n@@ -530,5 +542,57 @@ HIRCompileBase::compute_address_for_trait_item (\n \t\t\t\t    true, locus);\n }\n \n+bool\n+HIRCompileBase::verify_array_capacities (tree ltype, tree rtype,\n+\t\t\t\t\t Location lvalue_locus,\n+\t\t\t\t\t Location rvalue_locus)\n+{\n+  rust_assert (ltype != NULL_TREE);\n+  rust_assert (rtype != NULL_TREE);\n+\n+  // lets just return ok as other errors have already occurred\n+  if (ltype == error_mark_node || rtype == error_mark_node)\n+    return true;\n+\n+  tree ltype_domain = TYPE_DOMAIN (ltype);\n+  if (!ltype_domain)\n+    return false;\n+\n+  if (!TREE_CONSTANT (TYPE_MAX_VALUE (ltype_domain)))\n+    return false;\n+\n+  auto ltype_length\n+    = wi::ext (wi::to_offset (TYPE_MAX_VALUE (ltype_domain))\n+\t\t - wi::to_offset (TYPE_MIN_VALUE (ltype_domain)) + 1,\n+\t       TYPE_PRECISION (TREE_TYPE (ltype_domain)),\n+\t       TYPE_SIGN (TREE_TYPE (ltype_domain)))\n+\t.to_uhwi ();\n+\n+  tree rtype_domain = TYPE_DOMAIN (rtype);\n+  if (!rtype_domain)\n+    return false;\n+\n+  if (!TREE_CONSTANT (TYPE_MAX_VALUE (rtype_domain)))\n+    return false;\n+\n+  auto rtype_length\n+    = wi::ext (wi::to_offset (TYPE_MAX_VALUE (rtype_domain))\n+\t\t - wi::to_offset (TYPE_MIN_VALUE (rtype_domain)) + 1,\n+\t       TYPE_PRECISION (TREE_TYPE (rtype_domain)),\n+\t       TYPE_SIGN (TREE_TYPE (rtype_domain)))\n+\t.to_uhwi ();\n+\n+  if (ltype_length != rtype_length)\n+    {\n+      rust_error_at (rvalue_locus,\n+\t\t     \"expected an array with a fixed size of %lu \"\n+\t\t     \"elements, found one with %lu elements\",\n+\t\t     ltype_length, rtype_length);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "293f1108d8416388c16ef0efe24ff2b71bd00a2b", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -0,0 +1,428 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-constexpr.h\"\n+#include \"rust-location.h\"\n+#include \"rust-diagnostics.h\"\n+\n+#include \"fold-const.h\"\n+#include \"realmpfr.h\"\n+#include \"convert.h\"\n+#include \"print-tree.h\"\n+#include \"gimplify.h\"\n+#include \"tree-iterator.h\"\n+\n+/* Returns true if NODE is a pointer.  */\n+#define TYPE_PTR_P(NODE) (TREE_CODE (NODE) == POINTER_TYPE)\n+\n+/* Returns true if NODE is a reference.  */\n+#define TYPE_REF_P(NODE) (TREE_CODE (NODE) == REFERENCE_TYPE)\n+\n+/* Returns true if NODE is a pointer or a reference.  */\n+#define INDIRECT_TYPE_P(NODE) (TYPE_PTR_P (NODE) || TYPE_REF_P (NODE))\n+\n+/* [basic.fundamental]\n+\n+   Types  bool, char, wchar_t, and the signed and unsigned integer types\n+   are collectively called integral types.\n+\n+   Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n+   types as well, which is incorrect in C++.  Keep these checks in\n+   ascending code order.  */\n+#define RS_INTEGRAL_TYPE_P(TYPE)                                               \\\n+  (TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == INTEGER_TYPE)\n+\n+/* [basic.fundamental]\n+\n+   Integral and floating types are collectively called arithmetic\n+   types.\n+\n+   As a GNU extension, we also accept complex types.\n+\n+   Keep these checks in ascending code order.  */\n+#define ARITHMETIC_TYPE_P(TYPE)                                                \\\n+  (RS_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == REAL_TYPE                  \\\n+   || TREE_CODE (TYPE) == COMPLEX_TYPE)\n+\n+/* True iff TYPE is cv decltype(nullptr).  */\n+#define NULLPTR_TYPE_P(TYPE) (TREE_CODE (TYPE) == NULLPTR_TYPE)\n+\n+/* [basic.types]\n+\n+   Arithmetic types, enumeration types, pointer types,\n+   pointer-to-member types, and std::nullptr_t are collectively called\n+   scalar types.\n+\n+   Keep these checks in ascending code order.  */\n+#define SCALAR_TYPE_P(TYPE)                                                    \\\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE || ARITHMETIC_TYPE_P (TYPE)               \\\n+   || TYPE_PTR_P (TYPE) || NULLPTR_TYPE_P (TYPE))\n+\n+namespace Rust {\n+namespace Compile {\n+\n+static tree\n+constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p,\n+\t\t  bool unshare_p);\n+tree\n+decl_constant_value (tree decl, bool unshare_p);\n+\n+static void\n+non_const_var_error (location_t loc, tree r);\n+\n+static tree\n+get_function_named_in_call (tree t);\n+\n+ConstCtx::ConstCtx () : constexpr_ops_count (0) {}\n+\n+tree\n+ConstCtx::fold (tree expr)\n+{\n+  tree folded = ConstCtx ().constexpr_expression (expr);\n+  rust_assert (folded != NULL_TREE);\n+  return folded;\n+}\n+\n+tree\n+ConstCtx::constexpr_expression (tree t)\n+{\n+  location_t loc = EXPR_LOCATION (t);\n+  if (CONSTANT_CLASS_P (t))\n+    {\n+      if (TREE_OVERFLOW (t))\n+\t{\n+\t  rust_error_at (Location (loc), \"overflow in constant expression\");\n+\t  return t;\n+\t}\n+\n+      if (TREE_CODE (t) == INTEGER_CST && TYPE_PTR_P (TREE_TYPE (t))\n+\t  && !integer_zerop (t))\n+\t{\n+\t  // FIXME check does this actually work to print out tree types\n+\t  rust_error_at (Location (loc),\n+\t\t\t \"value %qE of type %qT is not a constant expression\",\n+\t\t\t t, TREE_TYPE (t));\n+\t  return t;\n+\t}\n+\n+      return t;\n+    }\n+\n+  // Avoid excessively long constexpr evaluations\n+  if (++constexpr_ops_count >= constexpr_ops_limit)\n+    {\n+      rust_error_at (\n+\tLocation (loc),\n+\t\"%<constexpr%> evaluation operation count exceeds limit of \"\n+\t\"%wd (use %<-fconstexpr-ops-limit=%> to increase the limit)\",\n+\tconstexpr_ops_limit);\n+\n+      return t;\n+    }\n+\n+  tree r = t;\n+  tree_code tcode = TREE_CODE (t);\n+  switch (tcode)\n+    {\n+      case CONST_DECL: {\n+\tr = decl_constant_value (t, /*unshare_p=*/false);\n+\tif (TREE_CODE (r) == TARGET_EXPR\n+\t    && TREE_CODE (TARGET_EXPR_INITIAL (r)) == CONSTRUCTOR)\n+\t  r = TARGET_EXPR_INITIAL (r);\n+\tif (DECL_P (r))\n+\t  {\n+\t    non_const_var_error (loc, r);\n+\t    return r;\n+\t  }\n+      }\n+      break;\n+\n+    case POINTER_PLUS_EXPR:\n+    case POINTER_DIFF_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case SPACESHIP_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+    case RANGE_EXPR:\n+    case COMPLEX_EXPR:\n+      r = eval_binary_expression (t);\n+      break;\n+\n+    case CALL_EXPR:\n+      r = eval_call_expression (t);\n+      break;\n+\n+    case RETURN_EXPR:\n+      rust_assert (TREE_OPERAND (t, 0) != NULL_TREE);\n+      r = constexpr_expression (TREE_OPERAND (t, 0));\n+      break;\n+\n+    case MODIFY_EXPR:\n+      r = eval_store_expression (t);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return r;\n+}\n+\n+tree\n+ConstCtx::eval_store_expression (tree t)\n+{\n+  tree init = TREE_OPERAND (t, 1);\n+  if (TREE_CLOBBER_P (init))\n+    /* Just ignore clobbers.  */\n+    return void_node;\n+\n+  /* First we figure out where we're storing to.  */\n+  tree target = TREE_OPERAND (t, 0);\n+\n+  tree type = TREE_TYPE (target);\n+  bool preeval = SCALAR_TYPE_P (type) || TREE_CODE (t) == MODIFY_EXPR;\n+  if (preeval)\n+    {\n+      /* Evaluate the value to be stored without knowing what object it will be\n+\t stored in, so that any side-effects happen first.  */\n+      init = ConstCtx::fold (init);\n+    }\n+\n+  bool evaluated = false;\n+  tree object = NULL_TREE;\n+  for (tree probe = target; object == NULL_TREE;)\n+    {\n+      switch (TREE_CODE (probe))\n+\t{\n+\tdefault:\n+\t  if (evaluated)\n+\t    object = probe;\n+\t  else\n+\t    {\n+\t      probe = constexpr_expression (probe);\n+\t      evaluated = true;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+\n+  return init;\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+ Like cxx_eval_unary_expression, except for binary expressions.  */\n+\n+tree\n+ConstCtx::eval_binary_expression (tree t)\n+{\n+  tree orig_lhs = TREE_OPERAND (t, 0);\n+  tree orig_rhs = TREE_OPERAND (t, 1);\n+  tree lhs, rhs;\n+\n+  lhs = constexpr_expression (orig_lhs);\n+  rhs = constexpr_expression (orig_rhs);\n+\n+  location_t loc = EXPR_LOCATION (t);\n+  enum tree_code code = TREE_CODE (t);\n+  tree type = TREE_TYPE (t);\n+\n+  return fold_binary_loc (loc, code, type, lhs, rhs);\n+}\n+\n+// Subroutine of cxx_eval_constant_expression.\n+// Evaluate the call expression tree T in the context of OLD_CALL expression\n+// evaluation.\n+tree\n+ConstCtx::eval_call_expression (tree t)\n+{\n+  tree fun = get_function_named_in_call (t);\n+  return constexpr_fn_retval (DECL_SAVED_TREE (fun));\n+}\n+\n+// Subroutine of check_constexpr_fundef.  BODY is the body of a function\n+// declared to be constexpr, or a sub-statement thereof.  Returns the\n+// return value if suitable, error_mark_node for a statement not allowed in\n+// a constexpr function, or NULL_TREE if no return value was found.\n+tree\n+ConstCtx::constexpr_fn_retval (tree body)\n+{\n+  switch (TREE_CODE (body))\n+    {\n+      case STATEMENT_LIST: {\n+\ttree expr = NULL_TREE;\n+\tfor (tree stmt : tsi_range (body))\n+\t  {\n+\t    tree s = constexpr_fn_retval (stmt);\n+\t    if (s == error_mark_node)\n+\t      return error_mark_node;\n+\t    else if (s == NULL_TREE)\n+\t      /* Keep iterating.  */;\n+\t    else if (expr)\n+\t      /* Multiple return statements.  */\n+\t      return error_mark_node;\n+\t    else\n+\t      expr = s;\n+\t  }\n+\treturn expr;\n+      }\n+\n+    case RETURN_EXPR:\n+      return constexpr_expression (body);\n+\n+      case DECL_EXPR: {\n+\ttree decl = DECL_EXPR_DECL (body);\n+\tif (TREE_CODE (decl) == USING_DECL\n+\t    /* Accept __func__, __FUNCTION__, and __PRETTY_FUNCTION__.  */\n+\t    || DECL_ARTIFICIAL (decl))\n+\t  return NULL_TREE;\n+\treturn error_mark_node;\n+      }\n+\n+    case CLEANUP_POINT_EXPR:\n+      return constexpr_fn_retval (TREE_OPERAND (body, 0));\n+\n+      case BIND_EXPR: {\n+\ttree b = BIND_EXPR_BODY (body);\n+\treturn constexpr_fn_retval (b);\n+      }\n+      break;\n+\n+    default:\n+      return error_mark_node;\n+    }\n+  return error_mark_node;\n+}\n+\n+// Taken from cp/constexpr.c\n+//\n+// If DECL is a scalar enumeration constant or variable with a\n+// constant initializer, return the initializer (or, its initializers,\n+// recursively); otherwise, return DECL.  If STRICT_P, the\n+// initializer is only returned if DECL is a\n+// constant-expression.  If RETURN_AGGREGATE_CST_OK_P, it is ok to\n+// return an aggregate constant.  If UNSHARE_P, return an unshared\n+// copy of the initializer.\n+static tree\n+constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p,\n+\t\t  bool unshare_p)\n+{\n+  while (TREE_CODE (decl) == CONST_DECL)\n+    {\n+      tree init;\n+      /* If DECL is a static data member in a template\n+\t specialization, we must instantiate it here.  The\n+\t initializer for the static data member is not processed\n+\t until needed; we need it now.  */\n+\n+      init = DECL_INITIAL (decl);\n+      if (init == error_mark_node)\n+\t{\n+\t  if (TREE_CODE (decl) == CONST_DECL)\n+\t    /* Treat the error as a constant to avoid cascading errors on\n+\t       excessively recursive template instantiation (c++/9335).  */\n+\t    return init;\n+\t  else\n+\t    return decl;\n+\t}\n+\n+      decl = init;\n+    }\n+  return unshare_p ? unshare_expr (decl) : decl;\n+}\n+\n+// A more relaxed version of decl_really_constant_value, used by the\n+// common C/C++ code.\n+tree\n+decl_constant_value (tree decl, bool unshare_p)\n+{\n+  return constant_value_1 (decl, /*strict_p=*/false,\n+\t\t\t   /*return_aggregate_cst_ok_p=*/true,\n+\t\t\t   /*unshare_p=*/unshare_p);\n+}\n+\n+static void\n+non_const_var_error (location_t loc, tree r)\n+{\n+  error_at (loc,\n+\t    \"the value of %qD is not usable in a constant \"\n+\t    \"expression\",\n+\t    r);\n+  /* Avoid error cascade.  */\n+  if (DECL_INITIAL (r) == error_mark_node)\n+    return;\n+\n+  // more in cp/constexpr.c\n+}\n+\n+static tree\n+get_callee (tree call)\n+{\n+  if (call == NULL_TREE)\n+    return call;\n+  else if (TREE_CODE (call) == CALL_EXPR)\n+    return CALL_EXPR_FN (call);\n+\n+  return NULL_TREE;\n+}\n+\n+// We have an expression tree T that represents a call, either CALL_EXPR\n+// or AGGR_INIT_EXPR. If the call is lexically to a named function,\n+// return the _DECL for that function.\n+static tree\n+get_function_named_in_call (tree t)\n+{\n+  tree fun = get_callee (t);\n+  if (fun && TREE_CODE (fun) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (fun, 0)) == FUNCTION_DECL)\n+    fun = TREE_OPERAND (fun, 0);\n+  return fun;\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "40d9159ccd1f143bce75ac113076d2b927db705f", "filename": "gcc/rust/backend/rust-constexpr.h", "status": "renamed", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-constexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Fbackend%2Frust-constexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -1,5 +1,3 @@\n-// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n-\n // This file is part of GCC.\n \n // GCC is free software; you can redistribute it and/or modify it under\n@@ -16,38 +14,33 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#ifndef RUST_HIR_CONST_FOLD_CTX_H\n-#define RUST_HIR_CONST_FOLD_CTX_H\n+#ifndef RUST_CONSTEXPR\n+#define RUST_CONSTEXPR\n \n-#include \"rust-backend.h\"\n-#include \"rust-hir-map.h\"\n+#include \"rust-system.h\"\n+#include \"tree.h\"\n \n namespace Rust {\n-namespace ConstFold {\n+namespace Compile {\n \n-class Context\n+class ConstCtx\n {\n public:\n-  ~Context () {}\n-\n-  static void init (::Backend *backend);\n-\n-  static Context *get ();\n-\n-  ::Backend *get_backend () { return backend; }\n-\n-  bool lookup_const (HirId id, tree *expr);\n+  static tree fold (tree);\n \n-  void insert_const (HirId, tree expr);\n+  tree constexpr_expression (tree);\n+  tree eval_binary_expression (tree);\n+  tree eval_call_expression (tree);\n+  tree constexpr_fn_retval (tree);\n+  tree eval_store_expression (tree);\n \n private:\n-  Context (::Backend *backend);\n+  ConstCtx ();\n \n-  ::Backend *backend;\n-  std::map<HirId, tree> ctx;\n+  HOST_WIDE_INT constexpr_ops_count;\n };\n \n-} // namespace ConstFold\n+} // namespace Compile\n } // namespace Rust\n \n-#endif // RUST_HIR_CONST_FOLD_CTX_H\n+#endif // RUST_CONSTEXPR", "previous_filename": "gcc/rust/typecheck/rust-hir-const-fold-ctx.h"}, {"sha": "98aaae92accbb60b8f77915f95fcae941ccda1e3", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -74,11 +74,6 @@ class Backend\n   virtual void debug (tree) = 0;\n   virtual void debug (Bvariable *) = 0;\n \n-  // const folder helpers\n-  virtual bool const_size_cast (tree, size_t *) = 0;\n-  virtual std::string const_size_val_to_string (tree) = 0;\n-  virtual bool const_values_equal (tree, tree) = 0;\n-\n   static Rust::ABI get_abi_from_string (const std::string &abi, Location locus)\n   {\n     if (abi.compare (\"rust\") == 0)"}, {"sha": "1fdba7a2b5e11acc8897879b236dd1c816e5f615", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -137,45 +137,6 @@ class Gcc_backend : public Backend\n \n   tree char_type () { return char_type_node; }\n \n-  bool const_size_cast (tree expr, size_t *result)\n-  {\n-    rust_assert (TREE_CONSTANT (expr));\n-\n-    unsigned char buf[sizeof (size_t) + 1];\n-    memset (buf, 0, sizeof (buf));\n-\n-    int ret = native_encode_expr (expr, buf, sizeof (buf), 0);\n-    if (ret <= 0)\n-      return false;\n-\n-    size_t *tmp = (size_t *) buf;\n-    *result = *tmp;\n-    return true;\n-  }\n-\n-  std::string const_size_val_to_string (tree expr)\n-  {\n-    rust_assert (TREE_CONSTANT (expr));\n-\n-    unsigned char buf[sizeof (size_t) + 1];\n-    memset (buf, 0, sizeof (buf));\n-\n-    int ret = native_encode_expr (expr, buf, sizeof (buf), 0);\n-    rust_assert (ret > 0);\n-\n-    size_t *ptr = (size_t *) buf;\n-    return std::to_string (*ptr);\n-  }\n-\n-  bool const_values_equal (tree a, tree b)\n-  {\n-    return operand_equal_p (a, b, OEP_ONLY_CONST | OEP_PURE_SAME);\n-    // printf (\"comparing!\\n\");\n-    // debug_tree (a->get_tree ());\n-    // debug_tree (b->get_tree ());\n-    // printf (\"ok = %s\\n\", ok ? \"true\" : \"false\");\n-  }\n-\n   tree wchar_type ()\n   {\n     tree wchar = make_unsigned_type (32);\n@@ -1672,6 +1633,9 @@ Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n   /* Construct a new tree and build an expression from it. */\n   auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n \t\t\t\t   tree_type, left_tree, right_tree);\n+  TREE_CONSTANT (new_tree)\n+    = TREE_CONSTANT (left_tree) && TREE_CONSTANT (right_tree);\n+\n   if (floating_point && extended_type != NULL_TREE)\n     new_tree = convert (original_type, new_tree);\n   return new_tree;"}, {"sha": "dccaffebff701d8b68f42b6aaa0c352c43b953a0", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -52,7 +52,6 @@\n #include \"rust-lint-scan-deadcode.h\"\n #include \"rust-tycheck-dump.h\"\n #include \"rust-ast-resolve-unused.h\"\n-#include \"rust-hir-const-fold.h\"\n #include \"rust-compile.h\"\n \n extern Linemap *\n@@ -330,9 +329,6 @@ Session::init ()\n \n   // set the default crate name\n   options.set_crate_name (kDefaultCrateName);\n-\n-  // the constant folder uses gcc\n-  ConstFold::Context::init (backend);\n }\n \n /* Initialise default options. Actually called before handle_option, unlike init"}, {"sha": "2ab44503cf19e57cb33dd45a4356d4720920e75d", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06c2a74f557ec98896c9f71ba666bd969c4735d2/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06c2a74f557ec98896c9f71ba666bd969c4735d2/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=06c2a74f557ec98896c9f71ba666bd969c4735d2", "patch": "@@ -1,54 +0,0 @@\n-// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_HIR_CONST_FOLD_BASE_H\n-#define RUST_HIR_CONST_FOLD_BASE_H\n-\n-#include \"rust-diagnostics.h\"\n-#include \"rust-hir-visitor.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-hir-type-check.h\"\n-#include \"rust-name-resolver.h\"\n-#include \"rust-hir-const-fold-ctx.h\"\n-\n-namespace Rust {\n-namespace ConstFold {\n-\n-// base class to allow derivatives to overload as needed\n-class ConstFoldBase : public HIR::HIRFullVisitorBase\n-{\n-public:\n-  virtual ~ConstFoldBase () {}\n-\n-protected:\n-  ConstFoldBase ()\n-    : mappings (Analysis::Mappings::get ()),\n-      resolver (Resolver::Resolver::get ()),\n-      tyctx (Resolver::TypeCheckContext::get ()), ctx (Context::get ())\n-  {}\n-\n-  Analysis::Mappings *mappings;\n-  Resolver::Resolver *resolver;\n-  Resolver::TypeCheckContext *tyctx;\n-  Context *ctx;\n-};\n-\n-} // namespace ConstFold\n-} // namespace Rust\n-\n-#endif // RUST_HIR_CONST_FOLD_BASE_H"}, {"sha": "1545c1a6efd6a622772a8cec6047618e7ed95d39", "filename": "gcc/rust/typecheck/rust-hir-const-fold.cc", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06c2a74f557ec98896c9f71ba666bd969c4735d2/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06c2a74f557ec98896c9f71ba666bd969c4735d2/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc?ref=06c2a74f557ec98896c9f71ba666bd969c4735d2", "patch": "@@ -1,138 +0,0 @@\n-// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include \"rust-hir-const-fold-ctx.h\"\n-#include \"rust-hir-const-fold.h\"\n-\n-namespace Rust {\n-namespace ConstFold {\n-\n-static Context *context = nullptr;\n-\n-Context::Context (::Backend *backend) : backend (backend) {}\n-\n-void\n-Context::init (::Backend *backend)\n-{\n-  rust_assert (context == nullptr);\n-  context = new Context (backend);\n-}\n-\n-Context *\n-Context::get ()\n-{\n-  rust_assert (context != nullptr);\n-  return context;\n-}\n-\n-bool\n-Context::lookup_const (HirId id, tree *expr)\n-{\n-  auto it = ctx.find (id);\n-  if (it == ctx.end ())\n-    return false;\n-\n-  *expr = it->second;\n-  return true;\n-}\n-\n-void\n-Context::insert_const (HirId id, tree expr)\n-{\n-  rust_assert (ctx.find (id) == ctx.end ());\n-  ctx[id] = expr;\n-}\n-\n-// rust-hir-const-fold.h\n-\n-void\n-ConstFoldItem::visit (HIR::ConstantItem &item)\n-{\n-  auto folded_expr = ConstFoldExpr::fold (item.get_expr ());\n-\n-  folded = folded_expr;\n-}\n-\n-void\n-ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n-{\n-  unsigned long index = 0;\n-  std::vector<unsigned long> indices;\n-  std::vector<tree> values;\n-\n-  TyTy::BaseType *tyty = nullptr;\n-  if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n-    {\n-      rust_fatal_error (expr.get_locus (),\n-\t\t\t\"did not resolve type for array elems values\");\n-      return;\n-    }\n-\n-  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n-\n-  for (auto &value : elems.get_values ())\n-    {\n-      indices.push_back (index++);\n-      values.push_back (ConstFoldExpr::fold (value.get ()));\n-    }\n-\n-  folded\n-    = ctx->get_backend ()->array_constructor_expression (type, indices, values,\n-\t\t\t\t\t\t\t expr.get_locus ());\n-}\n-\n-void\n-ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n-{\n-  std::vector<unsigned long> indices;\n-  std::vector<tree> values;\n-\n-  TyTy::BaseType *tyty = nullptr;\n-  if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n-    {\n-      rust_fatal_error (expr.get_locus (),\n-\t\t\t\"did not resolve type for array elems\");\n-      return;\n-    }\n-\n-  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n-  tree elem = ConstFoldExpr::fold (elems.get_elem_to_copy ());\n-\n-  // num copies expr was already folded in rust-hir-type-check-expr; lookup the\n-  // earlier result\n-  tree num_copies_expr = ctx->get_backend ()->error_expression ();\n-  ctx->lookup_const (elems.get_num_copies_expr ()->get_mappings ().get_hirid (),\n-\t\t     &num_copies_expr);\n-\n-  size_t copies;\n-  bool ok = ctx->get_backend ()->const_size_cast (num_copies_expr, &copies);\n-  rust_assert (ok);\n-\n-  for (size_t i = 0; i < copies; i++)\n-    {\n-      indices.push_back (i);\n-      values.push_back (elem);\n-    }\n-\n-  folded\n-    = ctx->get_backend ()->array_constructor_expression (type, indices, values,\n-\t\t\t\t\t\t\t expr.get_locus ());\n-}\n-\n-} // namespace ConstFold\n-} // namespace Rust"}, {"sha": "190781658624edb40832315861764e36b7b3571b", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "removed", "additions": 0, "deletions": 499, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06c2a74f557ec98896c9f71ba666bd969c4735d2/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06c2a74f557ec98896c9f71ba666bd969c4735d2/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=06c2a74f557ec98896c9f71ba666bd969c4735d2", "patch": "@@ -1,499 +0,0 @@\n-// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_HIR_CONST_FOLD_H\n-#define RUST_HIR_CONST_FOLD_H\n-\n-#include \"rust-hir-const-fold-base.h\"\n-#include \"rust-tyty-visitor.h\"\n-\n-namespace Rust {\n-namespace ConstFold {\n-\n-class ConstFoldType : public TyTy::TyVisitor\n-{\n-public:\n-  static tree fold (TyTy::BaseType *type, ::Backend *backend)\n-  {\n-    ConstFoldType folder (backend);\n-    type->accept_vis (folder);\n-    return folder.translated;\n-  };\n-\n-  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ADTType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ArrayType &type) override\n-  {\n-    tree element_ty = ConstFoldType::fold (type.get_element_type (), backend);\n-    translated = backend->array_type (element_ty, type.get_capacity ());\n-  }\n-\n-  void visit (TyTy::ReferenceType &type) override\n-  {\n-    tree base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n-    if (type.is_mutable ())\n-      {\n-\ttranslated = backend->reference_type (base_compiled_type);\n-      }\n-    else\n-      {\n-\tauto base = backend->immutable_type (base_compiled_type);\n-\ttranslated = backend->reference_type (base);\n-      }\n-  }\n-\n-  void visit (TyTy::PointerType &type) override\n-  {\n-    tree base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n-    if (type.is_mutable ())\n-      {\n-\ttranslated = backend->pointer_type (base_compiled_type);\n-      }\n-    else\n-      {\n-\tauto base = backend->immutable_type (base_compiled_type);\n-\ttranslated = backend->pointer_type (base);\n-      }\n-  }\n-\n-  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::FnType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::TupleType &type) override\n-  {\n-    if (type.num_fields () == 0)\n-      translated = backend->unit_type ();\n-    else\n-      gcc_unreachable ();\n-  }\n-\n-  void visit (TyTy::BoolType &) override\n-  {\n-    translated = backend->named_type (\"bool\", backend->bool_type (),\n-\t\t\t\t      Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::IntType &type) override\n-  {\n-    switch (type.get_int_kind ())\n-      {\n-      case TyTy::IntType::I8:\n-\ttranslated\n-\t  = backend->named_type (\"i8\", backend->integer_type (false, 8),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::IntType::I16:\n-\ttranslated\n-\t  = backend->named_type (\"i16\", backend->integer_type (false, 16),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::IntType::I32:\n-\ttranslated\n-\t  = backend->named_type (\"i32\", backend->integer_type (false, 32),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::IntType::I64:\n-\ttranslated\n-\t  = backend->named_type (\"i64\", backend->integer_type (false, 64),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::IntType::I128:\n-\ttranslated\n-\t  = backend->named_type (\"i128\", backend->integer_type (false, 128),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-      }\n-    gcc_unreachable ();\n-  }\n-\n-  void visit (TyTy::UintType &type) override\n-  {\n-    switch (type.get_uint_kind ())\n-      {\n-      case TyTy::UintType::U8:\n-\ttranslated = backend->named_type (\"u8\", backend->integer_type (true, 8),\n-\t\t\t\t\t  Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::UintType::U16:\n-\ttranslated\n-\t  = backend->named_type (\"u16\", backend->integer_type (true, 16),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::UintType::U32:\n-\ttranslated\n-\t  = backend->named_type (\"u32\", backend->integer_type (true, 32),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::UintType::U64:\n-\ttranslated\n-\t  = backend->named_type (\"u64\", backend->integer_type (true, 64),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::UintType::U128:\n-\ttranslated\n-\t  = backend->named_type (\"u128\", backend->integer_type (true, 128),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-      }\n-    gcc_unreachable ();\n-  }\n-\n-  void visit (TyTy::FloatType &type) override\n-  {\n-    switch (type.get_float_kind ())\n-      {\n-      case TyTy::FloatType::F32:\n-\ttranslated = backend->named_type (\"f32\", backend->float_type (32),\n-\t\t\t\t\t  Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::FloatType::F64:\n-\ttranslated = backend->named_type (\"f64\", backend->float_type (64),\n-\t\t\t\t\t  Linemap::predeclared_location ());\n-\treturn;\n-      }\n-\n-    gcc_unreachable ();\n-  }\n-\n-  void visit (TyTy::USizeType &) override\n-  {\n-    translated = backend->named_type (\n-      \"usize\", backend->integer_type (true, backend->get_pointer_size ()),\n-      Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::ISizeType &) override\n-  {\n-    translated = backend->named_type (\n-      \"isize\", backend->integer_type (false, backend->get_pointer_size ()),\n-      Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::CharType &) override\n-  {\n-    translated = backend->named_type (\"char\", backend->wchar_type (),\n-\t\t\t\t      Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::StrType &) override\n-  {\n-    tree raw_str = backend->raw_str_type ();\n-    translated\n-      = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ClosureType &) override { gcc_unreachable (); }\n-\n-private:\n-  ConstFoldType (::Backend *backend)\n-    : backend (backend), translated (backend->error_type ())\n-  {}\n-\n-  ::Backend *backend;\n-  ::tree translated;\n-};\n-\n-class ConstFoldItem : public ConstFoldBase\n-{\n-  using ConstFoldBase::visit;\n-\n-public:\n-  static tree fold (HIR::Item &item)\n-  {\n-    ConstFoldItem folder;\n-    item.accept_vis (folder);\n-    if (folder.ctx->get_backend ()->is_error_expression (folder.folded))\n-      {\n-\trust_error_at (item.get_locus (), \"non const value\");\n-\treturn nullptr;\n-      }\n-\n-    folder.ctx->insert_const (item.get_mappings ().get_hirid (), folder.folded);\n-    return folder.folded;\n-  };\n-\n-  void visit (HIR::ConstantItem &item) override;\n-\n-private:\n-  ConstFoldItem ()\n-    : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n-  {}\n-\n-  tree folded;\n-};\n-\n-class ConstFoldArrayElems : public ConstFoldBase\n-{\n-  using ConstFoldBase::visit;\n-\n-public:\n-  static tree fold (HIR::ArrayExpr &expr)\n-  {\n-    ConstFoldArrayElems folder (expr);\n-    HIR::ArrayElems *elems = expr.get_internal_elements ();\n-    elems->accept_vis (folder);\n-    return folder.folded;\n-  }\n-\n-  void visit (HIR::ArrayElemsValues &elems) override;\n-  void visit (HIR::ArrayElemsCopied &elems) override;\n-\n-private:\n-  ConstFoldArrayElems (HIR::ArrayExpr &expr)\n-    : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ()),\n-      expr (expr)\n-  {}\n-\n-  tree folded;\n-  HIR::ArrayExpr &expr;\n-};\n-\n-class ConstFoldExpr : public ConstFoldBase\n-{\n-  using ConstFoldBase::visit;\n-\n-public:\n-  static tree fold (HIR::Expr *expr)\n-  {\n-    ConstFoldExpr folder;\n-    expr->accept_vis (folder);\n-    if (folder.ctx->get_backend ()->is_error_expression (folder.folded))\n-      {\n-\trust_error_at (expr->get_locus (), \"non const value\");\n-\treturn folder.ctx->get_backend ()->error_expression ();\n-      }\n-\n-    folder.ctx->insert_const (expr->get_mappings ().get_hirid (),\n-\t\t\t      folder.folded);\n-    return folder.folded;\n-  };\n-\n-  void visit (HIR::IdentifierExpr &expr) override\n-  {\n-    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n-\n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-      {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tResolver::Definition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return;\n-\t  }\n-\tref_node_id = def.parent;\n-      }\n-\n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       ref_node_id, &ref))\n-      {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-\treturn;\n-      }\n-\n-    // lookup constant\n-    ctx->lookup_const (ref, &folded);\n-  }\n-\n-  void visit (HIR::LiteralExpr &expr) override\n-  {\n-    auto literal_value = expr.get_literal ();\n-    switch (expr.get_lit_type ())\n-      {\n-\tcase HIR::Literal::INT: {\n-\t  mpz_t ival;\n-\t  if (mpz_init_set_str (ival, literal_value.as_string ().c_str (), 10)\n-\t      != 0)\n-\t    {\n-\t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n-\t      return;\n-\t    }\n-\n-\t  TyTy::BaseType *tyty = nullptr;\n-\t  if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n-\t    {\n-\t      rust_fatal_error (expr.get_locus (),\n-\t\t\t\t\"did not resolve type for this literal expr\");\n-\t      return;\n-\t    }\n-\n-\t  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n-\t  folded\n-\t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n-\t}\n-\treturn;\n-\n-\tcase HIR::Literal::BOOL: {\n-\t  bool bval = literal_value.as_string ().compare (\"true\") == 0;\n-\t  folded = ctx->get_backend ()->boolean_constant_expression (bval);\n-\t}\n-\treturn;\n-\n-\tcase HIR::Literal::FLOAT: {\n-\t  mpfr_t fval;\n-\t  if (mpfr_init_set_str (fval, literal_value.as_string ().c_str (), 10,\n-\t\t\t\t MPFR_RNDN)\n-\t      != 0)\n-\t    {\n-\t      rust_fatal_error (expr.get_locus (),\n-\t\t\t\t\"bad floating-point number in literal\");\n-\t      return;\n-\t    }\n-\n-\t  TyTy::BaseType *tyty = nullptr;\n-\t  if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n-\t    {\n-\t      rust_fatal_error (expr.get_locus (),\n-\t\t\t\t\"did not resolve type for this literal expr\");\n-\t      return;\n-\t    }\n-\n-\t  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n-\t  folded = ctx->get_backend ()->float_constant_expression (type, fval);\n-\t}\n-\treturn;\n-\n-\t/* handle other literals */\n-\n-      default:\n-\tgcc_unreachable ();\n-\treturn;\n-      }\n-\n-    gcc_unreachable ();\n-  }\n-\n-  void visit (HIR::ArrayExpr &expr) override\n-  {\n-    folded = ConstFoldArrayElems::fold (expr);\n-  }\n-\n-  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    auto lhs = ConstFoldExpr::fold (expr.get_lhs ());\n-    auto rhs = ConstFoldExpr::fold (expr.get_rhs ());\n-\n-    auto op = expr.get_expr_type ();\n-    auto location = expr.get_locus ();\n-\n-    folded\n-      = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n-\t\t\t\t\t\t\t       location);\n-  }\n-\n-  void visit (HIR::NegationExpr &expr) override\n-  {\n-    auto negated_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n-\n-    auto op = expr.get_expr_type ();\n-    auto location = expr.get_locus ();\n-\n-    folded\n-      = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n-  }\n-\n-  void visit (HIR::ArrayIndexExpr &expr) override\n-  {\n-    tree array = ConstFoldExpr::fold (expr.get_array_expr ());\n-    tree index = ConstFoldExpr::fold (expr.get_index_expr ());\n-\n-    folded = ctx->get_backend ()->array_index_expression (array, index,\n-\t\t\t\t\t\t\t  expr.get_locus ());\n-  }\n-\n-  void visit (HIR::BorrowExpr &expr) override\n-  {\n-    tree main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n-\n-    folded\n-      = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n-  }\n-\n-  void visit (HIR::DereferenceExpr &expr) override\n-  {\n-    tree main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n-\n-    TyTy::BaseType *tyty = nullptr;\n-    if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n-      {\n-\trust_fatal_error (expr.get_locus (),\n-\t\t\t  \"did not resolve type for this TupleExpr\");\n-\treturn;\n-      }\n-\n-    tree expected_type = ConstFoldType::fold (tyty, ctx->get_backend ());\n-    bool known_valid = true;\n-    folded = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n-\t\t\t\t\t\t       known_valid,\n-\t\t\t\t\t\t       expr.get_locus ());\n-  }\n-\n-  void visit (HIR::GroupedExpr &expr) override\n-  {\n-    folded = ConstFoldExpr::fold (expr.get_expr_in_parens ().get ());\n-  }\n-\n-private:\n-  ConstFoldExpr ()\n-    : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n-  {}\n-\n-  tree folded;\n-};\n-\n-} // namespace ConstFold\n-} // namespace Rust\n-\n-#endif // RUST_HIR_CONST_FOLD_H"}, {"sha": "f770bed1eaf0505580ec7befaf4e9c99f3edc72f", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.h", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -63,28 +63,16 @@ class TypeCheckEnumItem : public TypeCheckBase\n     if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n-    TyTy::USizeType *expected_ty\n-      = new TyTy::USizeType (discriminant->get_mappings ().get_hirid ());\n+    TyTy::ISizeType *expected_ty\n+      = new TyTy::ISizeType (discriminant->get_mappings ().get_hirid ());\n     context->insert_type (discriminant->get_mappings (), expected_ty);\n \n     auto unified = expected_ty->unify (capacity_type);\n     if (unified->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n-    auto backend = rust_get_backend ();\n-    auto folded_discriminant\n-      = ConstFold::ConstFoldExpr::fold (discriminant.get ());\n-    if (backend->is_error_expression (folded_discriminant))\n-      return;\n-\n-    size_t specified_discriminant;\n-    bool ok\n-      = backend->const_size_cast (folded_discriminant, &specified_discriminant);\n-    rust_assert (ok);\n-\n-    variant\n-      = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n-\t\t\t      item.get_identifier (), specified_discriminant);\n+    variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t    item.get_identifier (), &item);\n   }\n \n   void visit (HIR::EnumItemTuple &item) override"}, {"sha": "1ac49463062556578a0174d6865bb9854deef775", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 70, "deletions": 79, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -27,7 +27,6 @@\n #include \"rust-hir-type-check-struct-field.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n-#include \"rust-hir-const-fold.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n@@ -728,25 +727,26 @@ class TypeCheckExpr : public TypeCheckBase\n \t     It is a constant, but for fold it to get a tree.  */\n \t  std::string capacity_str\n \t    = std::to_string (expr.get_literal ().as_string ().size ());\n-\t  HIR::LiteralExpr literal_capacity (capacity_mapping, capacity_str,\n-\t\t\t\t\t     HIR::Literal::LitType::INT,\n-\t\t\t\t\t     PrimitiveCoreType::CORETYPE_USIZE,\n-\t\t\t\t\t     expr.get_locus ());\n+\t  HIR::LiteralExpr *literal_capacity\n+\t    = new HIR::LiteralExpr (capacity_mapping, capacity_str,\n+\t\t\t\t    HIR::Literal::LitType::INT,\n+\t\t\t\t    PrimitiveCoreType::CORETYPE_USIZE,\n+\t\t\t\t    expr.get_locus ());\n \n \t  // mark the type for this implicit node\n-\t  context->insert_type (capacity_mapping,\n-\t\t\t\tnew TyTy::USizeType (\n-\t\t\t\t  capacity_mapping.get_hirid ()));\n-\n-\t  tree capacity = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n+\t  TyTy::BaseType *expected_ty = nullptr;\n+\t  ok = context->lookup_builtin (\"usize\", &expected_ty);\n+\t  rust_assert (ok);\n+\t  context->insert_type (capacity_mapping, expected_ty);\n \n \t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n \t\t\t\t\t       mappings->get_next_hir_id (\n \t\t\t\t\t\t crate_num),\n \t\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n \n \t  TyTy::ArrayType *array\n-\t    = new TyTy::ArrayType (array_mapping.get_hirid (), capacity,\n+\t    = new TyTy::ArrayType (array_mapping.get_hirid (),\n+\t\t\t\t   *literal_capacity,\n \t\t\t\t   TyTy::TyVar (u8->get_ref ()));\n \t  context->insert_type (array_mapping, array);\n \n@@ -979,77 +979,75 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::ArrayExpr &expr) override\n   {\n-    HIR::ArrayElems *elements = expr.get_internal_elements ();\n-    root_array_expr_locus = expr.get_locus ();\n-\n-    elements->accept_vis (*this);\n-    if (infered_array_elems == nullptr)\n-      return;\n-    if (folded_array_capacity == nullptr)\n-      return;\n+    HIR::ArrayElems &elements = *expr.get_internal_elements ();\n \n-    infered\n-      = new TyTy::ArrayType (expr.get_mappings ().get_hirid (),\n-\t\t\t     folded_array_capacity,\n-\t\t\t     TyTy::TyVar (infered_array_elems->get_ref ()));\n-  }\n-\n-  void visit (HIR::ArrayElemsValues &elems) override\n-  {\n-    std::vector<TyTy::BaseType *> types;\n-\n-    for (auto &elem : elems.get_values ())\n+    HIR::Expr *capacity_expr = nullptr;\n+    TyTy::BaseType *element_type = nullptr;\n+    switch (elements.get_array_expr_type ())\n       {\n-\ttypes.push_back (TypeCheckExpr::Resolve (elem.get (), false));\n-      }\n+\tcase HIR::ArrayElems::ArrayExprType::COPIED: {\n+\t  HIR::ArrayElemsCopied &elems\n+\t    = static_cast<HIR::ArrayElemsCopied &> (elements);\n+\t  element_type\n+\t    = TypeCheckExpr::Resolve (elems.get_elem_to_copy (), false);\n \n-    infered_array_elems\n-      = TyTy::TyVar::get_implicit_infer_var (root_array_expr_locus).get_tyty ();\n+\t  auto capacity_type\n+\t    = TypeCheckExpr::Resolve (elems.get_num_copies_expr (), false);\n \n-    for (auto &type : types)\n-      {\n-\tinfered_array_elems = infered_array_elems->unify (type);\n-      }\n-    for (auto &elem : types)\n-      {\n-\tinfered_array_elems->append_reference (elem->get_ref ());\n-      }\n+\t  TyTy::BaseType *expected_ty = nullptr;\n+\t  bool ok = context->lookup_builtin (\"usize\", &expected_ty);\n+\t  rust_assert (ok);\n+\t  context->insert_type (elems.get_num_copies_expr ()->get_mappings (),\n+\t\t\t\texpected_ty);\n \n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-    std::string capacity_str = std::to_string (elems.get_num_elements ());\n-    HIR::LiteralExpr implicit_literal_capacity (\n-      mapping, capacity_str, HIR::Literal::LitType::INT,\n-      PrimitiveCoreType::CORETYPE_USIZE, Location ());\n+\t  auto unified = expected_ty->unify (capacity_type);\n+\t  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return;\n \n-    // mark the type for this implicit node\n-    context->insert_type (mapping, new TyTy::USizeType (mapping.get_hirid ()));\n+\t  capacity_expr = elems.get_num_copies_expr ();\n+\t}\n+\tbreak;\n \n-    folded_array_capacity\n-      = ConstFold::ConstFoldExpr::fold (&implicit_literal_capacity);\n-  }\n+\tcase HIR::ArrayElems::ArrayExprType::VALUES: {\n+\t  HIR::ArrayElemsValues &elems\n+\t    = static_cast<HIR::ArrayElemsValues &> (elements);\n \n-  void visit (HIR::ArrayElemsCopied &elems) override\n-  {\n-    auto capacity_type\n-      = TypeCheckExpr::Resolve (elems.get_num_copies_expr (), false);\n+\t  std::vector<TyTy::BaseType *> types;\n+\t  for (auto &elem : elems.get_values ())\n+\t    {\n+\t      types.push_back (TypeCheckExpr::Resolve (elem.get (), false));\n+\t    }\n \n-    TyTy::USizeType *expected_ty = new TyTy::USizeType (\n-      elems.get_num_copies_expr ()->get_mappings ().get_hirid ());\n-    context->insert_type (elems.get_num_copies_expr ()->get_mappings (),\n-\t\t\t  expected_ty);\n+\t  element_type = TyTy::TyVar::get_implicit_infer_var (expr.get_locus ())\n+\t\t\t   .get_tyty ();\n+\t  for (auto &type : types)\n+\t    {\n+\t      element_type = element_type->unify (type);\n+\t    }\n \n-    auto unified = expected_ty->unify (capacity_type);\n-    if (unified->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n+\t  auto crate_num = mappings->get_current_crate ();\n+\t  Analysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\t  std::string capacity_str = std::to_string (elems.get_num_elements ());\n+\t  capacity_expr\n+\t    = new HIR::LiteralExpr (mapping, capacity_str,\n+\t\t\t\t    HIR::Literal::LitType::INT,\n+\t\t\t\t    PrimitiveCoreType::CORETYPE_USIZE,\n+\t\t\t\t    Location ());\n \n-    folded_array_capacity\n-      = ConstFold::ConstFoldExpr::fold (elems.get_num_copies_expr ());\n+\t  // mark the type for this implicit node\n+\t  TyTy::BaseType *expected_ty = nullptr;\n+\t  bool ok = context->lookup_builtin (\"usize\", &expected_ty);\n+\t  rust_assert (ok);\n+\t  context->insert_type (mapping, expected_ty);\n+\t}\n+\tbreak;\n+      }\n \n-    infered_array_elems\n-      = TypeCheckExpr::Resolve (elems.get_elem_to_copy (), false);\n+    infered\n+      = new TyTy::ArrayType (expr.get_mappings ().get_hirid (), *capacity_expr,\n+\t\t\t     TyTy::TyVar (element_type->get_ref ()));\n   }\n \n   // empty struct\n@@ -1547,8 +1545,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n private:\n   TypeCheckExpr (bool inside_loop)\n-    : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),\n-      folded_array_capacity (nullptr), inside_loop (inside_loop)\n+    : TypeCheckBase (), infered (nullptr), inside_loop (inside_loop)\n   {}\n \n   // Beware: currently returns Tyty::ErrorType or nullptr in case of error.\n@@ -1617,14 +1614,8 @@ class TypeCheckExpr : public TypeCheckBase\n   /* The return value of TypeCheckExpr::Resolve */\n   TyTy::BaseType *infered;\n \n-  /* The return value of visit(ArrayElemsValues&) and visit(ArrayElemsCopied&)\n-     Stores the type of array elements, if `expr` is ArrayExpr. */\n-  TyTy::BaseType *infered_array_elems;\n-  tree folded_array_capacity;\n-  Location root_array_expr_locus;\n-\n   bool inside_loop;\n-}; // namespace Resolver\n+};\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "25b592c50e7151046b58c100a3ad2aa94fe99f00", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -170,9 +170,6 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       = TypeCheckExpr::Resolve (constant.get_expr (), false);\n \n     context->insert_type (constant.get_mappings (), type->unify (expr_type));\n-\n-    // notify the constant folder of this\n-    ConstFold::ConstFoldItem::fold (constant);\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "22b6f3ff3c9164e5158296f2d6a996e48b6001b5", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -64,9 +64,6 @@ class TypeCheckStmt : public TypeCheckBase\n \n     infered = type->unify (expr_type);\n     context->insert_type (constant.get_mappings (), infered);\n-\n-    // notify the constant folder of this\n-    ConstFold::ConstFoldItem::fold (constant);\n   }\n \n   void visit (HIR::LetStmt &stmt) override\n@@ -98,7 +95,7 @@ class TypeCheckStmt : public TypeCheckBase\n \tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n \t  return;\n \n-\tcontext->insert_type (stmt.get_mappings (), unified_ty);\n+\tcontext->insert_type (stmt.get_mappings (), specified_ty);\n       }\n     else\n       {"}, {"sha": "3733e429ba52756b5ca7343ddf54e6be3798f193", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -315,9 +315,6 @@ class TypeCheckTopLevel : public TypeCheckBase\n       = TypeCheckExpr::Resolve (constant.get_expr (), false);\n \n     context->insert_type (constant.get_mappings (), type->unify (expr_type));\n-\n-    // notify the constant folder of this\n-    ConstFold::ConstFoldItem::fold (constant);\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "93f46e6add134eaec3c03b836746a34f607ea219", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-check-expr.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -575,5 +576,27 @@ TypeCheckType::visit (HIR::TraitObjectType &type)\n \t\t\t\t\t    std::move (specified_bounds));\n }\n \n+void\n+TypeCheckType::visit (HIR::ArrayType &type)\n+{\n+  auto capacity_type = TypeCheckExpr::Resolve (type.get_size_expr (), false);\n+  if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::BaseType *expected_ty = nullptr;\n+  bool ok = context->lookup_builtin (\"usize\", &expected_ty);\n+  rust_assert (ok);\n+  context->insert_type (type.get_size_expr ()->get_mappings (), expected_ty);\n+\n+  auto unified = expected_ty->unify (capacity_type);\n+  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_element_type ());\n+  translated = new TyTy::ArrayType (type.get_mappings ().get_hirid (),\n+\t\t\t\t    *type.get_size_expr (),\n+\t\t\t\t    TyTy::TyVar (base->get_ref ()));\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "ccde21aa3dd89a1da85ac0d24256d25c3781af4b", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -23,7 +23,6 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n #include \"rust-hir-inherent-impl-overlap.h\"\n-#include \"rust-hir-const-fold.h\"\n \n extern bool\n saw_errors (void);\n@@ -135,28 +134,6 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n }\n \n-void\n-TypeCheckType::visit (HIR::ArrayType &type)\n-{\n-  auto capacity_type = TypeCheckExpr::Resolve (type.get_size_expr (), false);\n-  if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n-    return;\n-\n-  TyTy::USizeType *expected_ty\n-    = new TyTy::USizeType (type.get_size_expr ()->get_mappings ().get_hirid ());\n-  context->insert_type (type.get_size_expr ()->get_mappings (), expected_ty);\n-\n-  auto unified = expected_ty->unify (capacity_type);\n-  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n-    return;\n-\n-  auto capacity = ConstFold::ConstFoldExpr::fold (type.get_size_expr ());\n-\n-  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_element_type ());\n-  translated = new TyTy::ArrayType (type.get_mappings ().get_hirid (), capacity,\n-\t\t\t\t    TyTy::TyVar (base->get_ref ()));\n-}\n-\n // rust-hir-trait-ref.h\n \n TraitItemReference::TraitItemReference ("}, {"sha": "6036a750e373460c5735c74723e46f3c32698547", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -806,19 +806,9 @@ class ArrayCastRules : public BaseCastRules\n \treturn;\n       }\n \n-    auto backend = rust_get_backend ();\n-\n-    // need to check the base types and capacity\n-    if (!backend->const_values_equal (type.get_capacity (),\n-\t\t\t\t      base->get_capacity ()))\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t       type.get_capacity (), TyVar (base_resolved->get_ref ()));\n+    resolved = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_capacity_expr (),\n+\t\t\t      TyVar (base_resolved->get_ref ()));\n   }\n \n private:"}, {"sha": "634753034a73cca3e4f50b91ac9d2dfa83ce778e", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -851,13 +851,6 @@ class ArrayCmp : public BaseCmp\n \n   void visit (const ArrayType &type) override\n   {\n-    // need to check the base types and capacity\n-    if (type.get_capacity () != base->get_capacity ())\n-      {\n-\tBaseCmp::visit (type);\n-\treturn;\n-      }\n-\n     // check base type\n     const BaseType *base_element = base->get_element_type ();\n     const BaseType *other_element = type.get_element_type ();"}, {"sha": "25f68109e1bf0f812e9ad0eb4ca493c957c49cf6", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -824,19 +824,9 @@ class ArrayCoercionRules : public BaseCoercionRules\n \treturn;\n       }\n \n-    auto backend = rust_get_backend ();\n-\n-    // need to check the base types and capacity\n-    if (!backend->const_values_equal (type.get_capacity (),\n-\t\t\t\t      base->get_capacity ()))\n-      {\n-\tBaseCoercionRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t       type.get_capacity (), TyVar (base_resolved->get_ref ()));\n+    resolved = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_capacity_expr (),\n+\t\t\t      TyVar (base_resolved->get_ref ()));\n   }\n \n private:"}, {"sha": "450a93f28a144d924358c1d65ecd53a32bbf63bf", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -841,19 +841,9 @@ class ArrayRules : public BaseRules\n \treturn;\n       }\n \n-    auto backend = rust_get_backend ();\n-\n-    // need to check the base types and capacity\n-    if (!backend->const_values_equal (type.get_capacity (),\n-\t\t\t\t      base->get_capacity ()))\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t       type.get_capacity (), TyVar (base_resolved->get_ref ()));\n+    resolved = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_capacity_expr (),\n+\t\t\t      TyVar (base_resolved->get_ref ()));\n   }\n \n private:"}, {"sha": "679187b16fdee316bbea1adcbf580ae0d8d8c224", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -1335,14 +1335,7 @@ ArrayType::accept_vis (TyConstVisitor &vis) const\n std::string\n ArrayType::as_string () const\n {\n-  return \"[\" + get_element_type ()->as_string () + \":\" + capacity_string ()\n-\t + \"]\";\n-}\n-\n-std::string\n-ArrayType::capacity_string () const\n-{\n-  return rust_get_backend ()->const_size_val_to_string (get_capacity ());\n+  return \"[\" + get_element_type ()->as_string () + \":\" + \"CAPACITY\" + \"]\";\n }\n \n BaseType *\n@@ -1381,8 +1374,6 @@ ArrayType::is_equal (const BaseType &other) const\n     return false;\n \n   auto other2 = static_cast<const ArrayType &> (other);\n-  if (get_capacity () != other2.get_capacity ())\n-    return false;\n \n   auto this_element_type = get_element_type ();\n   auto other_element_type = other2.get_element_type ();\n@@ -1399,8 +1390,8 @@ ArrayType::get_element_type () const\n BaseType *\n ArrayType::clone () const\n {\n-  return new ArrayType (get_ref (), get_ty_ref (), get_capacity (),\n-\t\t\telement_type, get_combined_refs ());\n+  return new ArrayType (get_ref (), get_ty_ref (), capacity_expr, element_type,\n+\t\t\tget_combined_refs ());\n }\n \n void"}, {"sha": "bdf85a97d391741c1a630f62426f02786e0ac279", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -19,12 +19,12 @@\n #ifndef RUST_TYTY\n #define RUST_TYTY\n \n-#include \"rust-backend.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-diagnostics.h\"\n #include \"rust-abi.h\"\n #include \"rust-common.h\"\n+#include \"tree.h\"\n \n namespace Rust {\n \n@@ -1034,15 +1034,25 @@ class VariantDef\n   }\n \n   VariantDef (HirId id, std::string identifier, int discriminant)\n-    : id (id), identifier (identifier), discriminant (discriminant)\n+    : id (id), identifier (identifier), discriminant (discriminant),\n+      discriminant_node (nullptr)\n+  {\n+    type = VariantType::NUM;\n+    fields = {};\n+  }\n+\n+  VariantDef (HirId id, std::string identifier,\n+\t      HIR::EnumItemDiscriminant *discriminant)\n+    : id (id), identifier (identifier), discriminant_node (discriminant)\n   {\n     type = VariantType::NUM;\n     fields = {};\n   }\n \n   VariantDef (HirId id, std::string identifier, VariantType type,\n \t      std::vector<StructFieldType *> fields)\n-    : id (id), identifier (identifier), type (type), fields (fields)\n+    : id (id), identifier (identifier), type (type), fields (fields),\n+      discriminant_node (nullptr)\n   {\n     discriminant = 0;\n     rust_assert (type == VariantType::TUPLE || type == VariantType::STRUCT);\n@@ -1073,7 +1083,12 @@ class VariantDef\n   bool is_dataless_variant () const { return type == VariantType::NUM; }\n \n   std::string get_identifier () const { return identifier; }\n-  int get_discriminant () const { return discriminant; }\n+\n+  int get_discriminant () const\n+  {\n+    rust_assert (!is_specified_discriminant_node ());\n+    return discriminant;\n+  }\n \n   size_t num_fields () const { return fields.size (); }\n   StructFieldType *get_field_at_index (size_t index)\n@@ -1109,6 +1124,17 @@ class VariantDef\n     return false;\n   }\n \n+  bool is_specified_discriminant_node () const\n+  {\n+    return discriminant_node != nullptr;\n+  }\n+\n+  HIR::EnumItemDiscriminant *get_discriminant_node () const\n+  {\n+    rust_assert (is_specified_discriminant_node ());\n+    return discriminant_node;\n+  }\n+\n   std::string as_string () const\n   {\n     if (type == VariantType::NUM)\n@@ -1166,6 +1192,7 @@ class VariantDef\n   VariantType type;\n   int discriminant; /* Either discriminant or fields are valid.  */\n   std::vector<StructFieldType *> fields;\n+  HIR::EnumItemDiscriminant *discriminant_node;\n };\n \n class ADTType : public BaseType, public SubstitutionRef\n@@ -1595,16 +1622,16 @@ class ClosureType : public BaseType, public SubstitutionRef\n class ArrayType : public BaseType\n {\n public:\n-  ArrayType (HirId ref, tree capacity, TyVar base,\n+  ArrayType (HirId ref, HIR::Expr &capacity_expr, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ARRAY, refs), capacity (capacity),\n-      element_type (base)\n+    : BaseType (ref, ref, TypeKind::ARRAY, refs), element_type (base),\n+      capacity_expr (capacity_expr)\n   {}\n \n-  ArrayType (HirId ref, HirId ty_ref, tree capacity, TyVar base,\n+  ArrayType (HirId ref, HirId ty_ref, HIR::Expr &capacity_expr, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ARRAY, refs), capacity (capacity),\n-      element_type (base)\n+    : BaseType (ref, ty_ref, TypeKind::ARRAY, refs), element_type (base),\n+      capacity_expr (capacity_expr)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1622,9 +1649,6 @@ class ArrayType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  tree get_capacity () const { return capacity; }\n-  std::string capacity_string () const;\n-\n   BaseType *get_element_type () const;\n \n   BaseType *clone () const final override;\n@@ -1634,9 +1658,11 @@ class ArrayType : public BaseType\n     return get_element_type ()->is_concrete ();\n   }\n \n+  HIR::Expr &get_capacity_expr () const { return capacity_expr; }\n+\n private:\n-  tree capacity;\n   TyVar element_type;\n+  HIR::Expr &capacity_expr;\n };\n \n class BoolType : public BaseType"}, {"sha": "c96f4f7d820895a2dd73683039ddf632ad36e980", "filename": "gcc/testsuite/rust/compile/arrays2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Ftestsuite%2Frust%2Fcompile%2Farrays2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Ftestsuite%2Frust%2Fcompile%2Farrays2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Farrays2.rs?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -1,4 +1,5 @@\n+// { dg-additional-options \"-w\" }\n fn main() {\n     let array: [i32; 5] = [1, 2, 3];\n-    // { dg-error \"expected ..i32:5.. got ..i32:3..\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"expected an array with a fixed size of 5 elements, found one with 3 elements\" \"\" { target *-*-* } .-1 }\n }"}, {"sha": "3cd6c0c77b5126056d35b411485705d7317ab4d8", "filename": "gcc/testsuite/rust/execute/torture/const_fold1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fconst_fold1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52780af6602763fac6297f7983878b38e0188bb9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fconst_fold1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fconst_fold1.rs?ref=52780af6602763fac6297f7983878b38e0188bb9", "patch": "@@ -0,0 +1,13 @@\n+// { dg-additional-options \"-w\" }\n+const fn const_fn() -> usize {\n+    4\n+}\n+\n+const FN_TEST: usize = const_fn();\n+\n+const TEST: usize = 2 + FN_TEST;\n+\n+fn main() -> i32 {\n+    let a: [_; 12] = [5; TEST * 2];\n+    a[6] - 5\n+}"}]}