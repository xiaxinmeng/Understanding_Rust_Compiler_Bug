{"sha": "1b1f249dbccd98900bf1f49e9454bae306d47ea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIxZjI0OWRiY2NkOTg5MDBiZjFmNDllOTQ1NGJhZTMwNmQ0N2VhMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2003-02-06T23:08:12Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-02-06T23:08:12Z"}, "message": "genautomata.c (VLA_PTR_CREATE, [...]): Use temporay variables starting with underscore.\n\n2003-02-06  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* genautomata.c (VLA_PTR_CREATE, VLA_PTR_EXPAND, VLA_PTR_ADD,\n\tVLA_HWINT_CREATE, VLA_HWINT_EXPAND, VLA_HWINT_ADD): Use temporay\n\tvariables starting with underscore.\n\t(struct unit_usage): New structure.\n\t(unit_usages, cycle_alt_unit_usages): New global variables.\n\t(check_unit_distribution_in_reserv): Remove it.\n\t(store_alt_unit_usage): New function.\n\t(check_regexp_units_distribution): Rewrite it.\n\nFrom-SVN: r62500", "tree": {"sha": "c0d573c3b277646ffebc124269c12b1627837c94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d573c3b277646ffebc124269c12b1627837c94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b1f249dbccd98900bf1f49e9454bae306d47ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1f249dbccd98900bf1f49e9454bae306d47ea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b1f249dbccd98900bf1f49e9454bae306d47ea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1f249dbccd98900bf1f49e9454bae306d47ea1/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "256803d96e0d170715b56684074f13c86675a66e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/256803d96e0d170715b56684074f13c86675a66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/256803d96e0d170715b56684074f13c86675a66e"}], "stats": {"total": 252, "additions": 146, "deletions": 106}, "files": [{"sha": "9a288d5292d1279a6c207952d8971b2f77a04f43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1f249dbccd98900bf1f49e9454bae306d47ea1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1f249dbccd98900bf1f49e9454bae306d47ea1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b1f249dbccd98900bf1f49e9454bae306d47ea1", "patch": "@@ -1,3 +1,14 @@\n+2003-02-06  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (VLA_PTR_CREATE, VLA_PTR_EXPAND, VLA_PTR_ADD,\n+\tVLA_HWINT_CREATE, VLA_HWINT_EXPAND, VLA_HWINT_ADD): Use temporay\n+\tvariables starting with underscore.\n+\t(struct unit_usage): New structure.\n+\t(unit_usages, cycle_alt_unit_usages): New global variables.\n+\t(check_unit_distribution_in_reserv): Remove it.\n+\t(store_alt_unit_usage): New function.\n+\t(check_regexp_units_distribution): Rewrite it.\n+\n 2003-02-06  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config.gcc (hppa*-*-linux*): Set MASK_NO_SPACE_REGS in"}, {"sha": "06c5d968e83a3e53eb31001cb2cf05e0e6d42318", "filename": "gcc/genautomata.c", "status": "modified", "additions": 135, "deletions": 106, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b1f249dbccd98900bf1f49e9454bae306d47ea1/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b1f249dbccd98900bf1f49e9454bae306d47ea1/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=1b1f249dbccd98900bf1f49e9454bae306d47ea1", "patch": "@@ -367,8 +367,7 @@ static regexp_t regexp_transform_func\n static regexp_t transform_regexp            PARAMS ((regexp_t));\n static void transform_insn_regexps          PARAMS ((void));\n \n-static void check_unit_distribution_in_reserv PARAMS ((const char *, regexp_t,\n-\t\t\t\t\t\t       regexp_t, int));\n+static void store_alt_unit_usage PARAMS ((regexp_t, regexp_t, int, int));\n static void check_regexp_units_distribution   PARAMS ((const char *, regexp_t));\n static void check_unit_distributions_to_automata PARAMS ((void));\n \n@@ -546,14 +545,14 @@ static struct obstack irp;\n    allocator when varray is used only.  */\n \n /* Start work with vla.  */\n-#define VLA_PTR_CREATE(vla, allocated_length, name)                   \t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {                                                                \t\\\n-      vla_ptr_t *const vla_ptr = &(vla);                                \\\n-                                                                      \t\\\n-      VARRAY_GENERIC_PTR_INIT (vla_ptr->varray, allocated_length, name);\\\n-      vla_ptr->length = 0;                                              \\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define VLA_PTR_CREATE(vla, allocated_length, name)                   \t \\\n+  do\t\t\t\t\t\t\t\t\t \\\n+    {                                                                \t \\\n+      vla_ptr_t *const _vla_ptr = &(vla);                                \\\n+                                                                      \t \\\n+      VARRAY_GENERIC_PTR_INIT (_vla_ptr->varray, allocated_length, name);\\\n+      _vla_ptr->length = 0;                                              \\\n+    }\t\t\t\t\t\t\t\t\t \\\n   while (0)\n \n /* Finish work with the vla.  */\n@@ -576,23 +575,23 @@ static struct obstack irp;\n    undefined.  */\n #define VLA_PTR_EXPAND(vla, n)                                        \\\n   do {                                                                \\\n-    vla_ptr_t *const expand_vla_ptr = &(vla);                         \\\n-    const size_t new_length = (n) + expand_vla_ptr->length;           \\\n+    vla_ptr_t *const _expand_vla_ptr = &(vla);                        \\\n+    const size_t _new_length = (n) + _expand_vla_ptr->length;         \\\n                                                                       \\\n-    if (VARRAY_SIZE (expand_vla_ptr->varray) < new_length)            \\\n-      VARRAY_GROW (expand_vla_ptr->varray,                            \\\n-                   (new_length - expand_vla_ptr->length < 128         \\\n-                    ? expand_vla_ptr->length + 128 : new_length));    \\\n-    expand_vla_ptr->length = new_length;                              \\\n+    if (VARRAY_SIZE (_expand_vla_ptr->varray) < _new_length)          \\\n+      VARRAY_GROW (_expand_vla_ptr->varray,                           \\\n+                   (_new_length - _expand_vla_ptr->length < 128       \\\n+                    ? _expand_vla_ptr->length + 128 : _new_length));  \\\n+    _expand_vla_ptr->length = _new_length;                            \\\n   } while (0)\n \n /* Add element to the end of the vla.  */\n-#define VLA_PTR_ADD(vla, ptr)                                         \\\n-  do {                                                                \\\n-    vla_ptr_t *const vla_ptr = &(vla);                                \\\n-                                                                      \\\n-    VLA_PTR_EXPAND (*vla_ptr, 1);                                     \\\n-    VARRAY_GENERIC_PTR (vla_ptr->varray, vla_ptr->length - 1) = (ptr);\\\n+#define VLA_PTR_ADD(vla, ptr)                                           \\\n+  do {                                                                  \\\n+    vla_ptr_t *const _vla_ptr = &(vla);                                 \\\n+                                                                        \\\n+    VLA_PTR_EXPAND (*_vla_ptr, 1);                                      \\\n+    VARRAY_GENERIC_PTR (_vla_ptr->varray, _vla_ptr->length - 1) = (ptr);\\\n   } while (0)\n \n /* Length of the vla in elements.  */\n@@ -607,10 +606,10 @@ static struct obstack irp;\n \n #define VLA_HWINT_CREATE(vla, allocated_length, name)                 \\\n   do {                                                                \\\n-    vla_hwint_t *const vla_ptr = &(vla);                              \\\n+    vla_hwint_t *const _vla_ptr = &(vla);                             \\\n                                                                       \\\n-    VARRAY_WIDE_INT_INIT (vla_ptr->varray, allocated_length, name);   \\\n-    vla_ptr->length = 0;                                              \\\n+    VARRAY_WIDE_INT_INIT (_vla_ptr->varray, allocated_length, name);  \\\n+    _vla_ptr->length = 0;                                             \\\n   } while (0)\n \n #define VLA_HWINT_DELETE(vla) VARRAY_FREE ((vla).varray)\n@@ -621,22 +620,22 @@ static struct obstack irp;\n \n #define VLA_HWINT_EXPAND(vla, n)                                      \\\n   do {                                                                \\\n-    vla_hwint_t *const expand_vla_ptr = &(vla);                       \\\n-    const size_t new_length = (n) + expand_vla_ptr->length;           \\\n+    vla_hwint_t *const _expand_vla_ptr = &(vla);                      \\\n+    const size_t _new_length = (n) + _expand_vla_ptr->length;         \\\n                                                                       \\\n-    if (VARRAY_SIZE (expand_vla_ptr->varray) < new_length)            \\\n-      VARRAY_GROW (expand_vla_ptr->varray,                            \\\n-                   (new_length - expand_vla_ptr->length < 128         \\\n-                    ? expand_vla_ptr->length + 128 : new_length));    \\\n-    expand_vla_ptr->length = new_length;                              \\\n+    if (VARRAY_SIZE (_expand_vla_ptr->varray) < _new_length)          \\\n+      VARRAY_GROW (_expand_vla_ptr->varray,                           \\\n+                   (_new_length - _expand_vla_ptr->length < 128       \\\n+                    ? _expand_vla_ptr->length + 128 : _new_length));  \\\n+    _expand_vla_ptr->length = _new_length;                            \\\n   } while (0)\n \n #define VLA_HWINT_ADD(vla, ptr)                                       \\\n   do {                                                                \\\n-    vla_hwint_t *const vla_ptr = &(vla);                              \\\n+    vla_hwint_t *const _vla_ptr = &(vla);                             \\\n                                                                       \\\n-    VLA_HWINT_EXPAND (*vla_ptr, 1);                                   \\\n-    VARRAY_WIDE_INT (vla_ptr->varray, vla_ptr->length - 1) = (ptr);   \\\n+    VLA_HWINT_EXPAND (*_vla_ptr, 1);                                  \\\n+    VARRAY_WIDE_INT (_vla_ptr->varray, _vla_ptr->length - 1) = (ptr); \\\n   } while (0)\n \n #define VLA_HWINT_LENGTH(vla) ((vla).length)\n@@ -763,6 +762,9 @@ struct unit_decl\n   /* The following is used only when `query_p' has nonzero value.\n      This is query number for the unit.  */\n   int query_num;\n+  /* The following is the last cycle on which the unit was checked for\n+     correct distributions of units to automata in a regexp.  */\n+  int last_distribution_check_cycle;\n \n   /* The following fields are defined by automaton generator.  */\n \n@@ -5442,78 +5444,61 @@ transform_insn_regexps ()\n    about units to automata distribution has been output.  */\n static int annotation_message_reported_p;\n \n-/* The function processes all alternative reservations on CYCLE in\n-   given REGEXP of insn reservation with INSN_RESERV_NAME to check the\n-   UNIT (or another unit from the same automaton) is not reserved on\n-   the all alternatives.  If it is true, the function outputs message\n-   about the rule violation.  */\n+/* The following structure describes usage of a unit in a reservation.  */\n+struct unit_usage\n+{\n+  unit_decl_t unit_decl;\n+  /* The following forms a list of units used on the same cycle in the\n+     same alternative.  */\n+  struct unit_usage *next;\n+};\n+\n+/* Obstack for unit_usage structures.  */\n+static struct obstack unit_usages;\n+\n+/* VLA for representation of array of pointers to unit usage\n+   structures.  There is an element for each combination of\n+   (alternative number, cycle).  Unit usages on given cycle in\n+   alternative with given number are referred through element with\n+   index equals to the cycle * number of all alternatives in the regexp\n+   + the alternative number.  */\n+static vla_ptr_t cycle_alt_unit_usages;\n+\n+/* The following function creates the structure unit_usage for UNIT on\n+   CYCLE in REGEXP alternative with ALT_NUM.  The structure is made\n+   accessed through cycle_alt_unit_usages.  */\n static void\n-check_unit_distribution_in_reserv (insn_reserv_name, unit, regexp, cycle)\n-     const char *insn_reserv_name;\n-     regexp_t unit;\n+store_alt_unit_usage (regexp, unit, cycle, alt_num)\n      regexp_t regexp;\n+     regexp_t unit;\n      int cycle;\n+     int alt_num;\n {\n-  int i, k;\n-  regexp_t seq, allof;\n+  size_t i, length, old_length;\n   unit_decl_t unit_decl;\n+  struct unit_usage *unit_usage_ptr;\n+  int index;\n \n-  if (regexp == NULL || regexp->mode != rm_oneof)\n+  if (regexp == NULL || regexp->mode != rm_oneof\n+      || alt_num >= REGEXP_ONEOF (regexp)->regexps_num)\n     abort ();\n   unit_decl = REGEXP_UNIT (unit)->unit_decl;\n-  for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n-    {\n-      seq = REGEXP_ONEOF (regexp)->regexps [i];\n-      if (seq->mode == rm_sequence)\n-\t{\n-\t  if (cycle >= REGEXP_SEQUENCE (seq)->regexps_num)\n-\t    continue;\n-\t  allof = REGEXP_SEQUENCE (seq)->regexps [cycle];\n-\t  if (allof->mode == rm_allof)\n-\t    {\n-\t      for (k = 0; k < REGEXP_ALLOF (allof)->regexps_num; k++)\n-\t\tif (REGEXP_ALLOF (allof)->regexps [k]->mode == rm_unit\n-\t\t    && (REGEXP_UNIT (REGEXP_ALLOF (allof)->regexps [k])\n-\t\t\t->unit_decl->automaton_decl\n-\t\t\t== unit_decl->automaton_decl))\n-\t\t  break;\n-\t      if (k >= REGEXP_ALLOF (allof)->regexps_num)\n-\t\tbreak;\n-\t    }\n-\t  else if (allof->mode == rm_unit\n-\t\t   && (REGEXP_UNIT (allof)->unit_decl->automaton_decl\n-\t\t       != unit_decl->automaton_decl))\n-\t    break;\n-\t}\n-      else if (cycle != 0)\n-\tcontinue;\n-      else if (seq->mode == rm_allof)\n-\t{\n-\t  for (k = 0; k < REGEXP_ALLOF (seq)->regexps_num; k++)\n-\t    if (REGEXP_ALLOF (seq)->regexps [k]->mode == rm_unit\n-\t\t&& (REGEXP_UNIT (REGEXP_ALLOF (seq)->regexps [k])\n-\t\t    ->unit_decl->automaton_decl == unit_decl->automaton_decl))\n-\t      break;\n-\t  if (k >= REGEXP_ALLOF (seq)->regexps_num)\n-\t    break;\n-\t}\n-      else if (seq->mode == rm_unit\n-\t       && (REGEXP_UNIT (seq)->unit_decl->automaton_decl\n-\t\t   != unit_decl->automaton_decl))\n-\tbreak;\n-    }\n-  if (i >= 0)\n+  old_length = VLA_PTR_LENGTH (cycle_alt_unit_usages);\n+  length = (cycle + 1) * REGEXP_ONEOF (regexp)->regexps_num;\n+  if (old_length < length)\n     {\n-      if (!annotation_message_reported_p)\n-\t{\n-\t  fprintf (stderr, \"\\n\");\n-\t  error (\"The following units do not satisfy units-automata distribution rule\");\n-\t  error (\"  (A unit of given unit automaton should be on each reserv. altern.)\");\n-\t  annotation_message_reported_p = TRUE;\n-\t}\n-      error (\"Unit %s, reserv. %s, cycle %d\",\n-\t     unit_decl->name, insn_reserv_name, cycle);\n+      VLA_PTR_EXPAND (cycle_alt_unit_usages, length - old_length);\n+      for (i = old_length; i < length; i++)\n+\tVLA_PTR (cycle_alt_unit_usages, i) = NULL;\n     }\n+  obstack_blank (&unit_usages, sizeof (struct unit_usage));\n+  unit_usage_ptr = (struct unit_usage *) obstack_base (&unit_usages);\n+  obstack_finish (&unit_usages);\n+  unit_usage_ptr->unit_decl = unit_decl;\n+  index = cycle * REGEXP_ONEOF (regexp)->regexps_num + alt_num;\n+  unit_usage_ptr->next = VLA_PTR (cycle_alt_unit_usages, index);\n+  VLA_PTR (cycle_alt_unit_usages, index) = unit_usage_ptr;\n+  unit_decl->last_distribution_check_cycle = -1; /* undefined */\n }\n \n /* The function processes given REGEXP to find units with the wrong\n@@ -5523,11 +5508,15 @@ check_regexp_units_distribution (insn_reserv_name, regexp)\n      const char *insn_reserv_name;\n      regexp_t regexp;\n {\n-  int i, j, k;\n+  int i, j, k, cycle;\n   regexp_t seq, allof, unit;\n+  struct unit_usage *unit_usage_ptr, *other_unit_usage_ptr;\n \n   if (regexp == NULL || regexp->mode != rm_oneof)\n     return;\n+  /* Store all unit usages in the regexp:  */\n+  obstack_init (&unit_usages);\n+  VLA_PTR_CREATE (cycle_alt_unit_usages, 100, \"unit usages on cycles\");\n   for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n     {\n       seq = REGEXP_ONEOF (regexp)->regexps [i];\n@@ -5540,14 +5529,12 @@ check_regexp_units_distribution (insn_reserv_name, regexp)\n \t\t{\n \t\t  unit = REGEXP_ALLOF (allof)->regexps [k];\n \t\t  if (unit->mode == rm_unit)\n-\t\t    check_unit_distribution_in_reserv (insn_reserv_name, unit,\n-\t\t\t\t\t\t       regexp, j);\n+\t\t    store_alt_unit_usage (regexp, unit, j, i);\n \t\t  else if (unit->mode != rm_nothing)\n \t\t    abort ();\n \t\t}\n \t    else if (allof->mode == rm_unit)\n-\t      check_unit_distribution_in_reserv (insn_reserv_name, allof,\n-\t\t\t\t\t\t regexp, j);\n+\t      store_alt_unit_usage (regexp, allof, j, i);\n \t    else if (allof->mode != rm_nothing)\n \t      abort ();\n \t  }\n@@ -5556,16 +5543,58 @@ check_regexp_units_distribution (insn_reserv_name, regexp)\n \t  {\n \t    unit = REGEXP_ALLOF (seq)->regexps [k];\n \t    if (unit->mode == rm_unit)\n-\t      check_unit_distribution_in_reserv (insn_reserv_name, unit,\n-\t\t\t\t\t\t regexp, 0);\n+\t      store_alt_unit_usage (regexp, unit, 0, i);\n \t    else if (unit->mode != rm_nothing)\n \t      abort ();\n \t  }\n       else if (seq->mode == rm_unit)\n-\tcheck_unit_distribution_in_reserv (insn_reserv_name, seq, regexp, 0);\n+\tstore_alt_unit_usage (regexp, seq, 0, i);\n       else if (seq->mode != rm_nothing)\n \tabort ();\n     }\n+  /* Check distribution:  */\n+  for (i = 0; i < (int) VLA_PTR_LENGTH (cycle_alt_unit_usages); i++)\n+    {\n+      cycle = i / REGEXP_ONEOF (regexp)->regexps_num;\n+      for (unit_usage_ptr = VLA_PTR (cycle_alt_unit_usages, i);\n+\t   unit_usage_ptr != NULL;\n+\t   unit_usage_ptr = unit_usage_ptr->next)\n+\tif (cycle != unit_usage_ptr->unit_decl->last_distribution_check_cycle)\n+\t  {\n+\t    unit_usage_ptr->unit_decl->last_distribution_check_cycle = cycle;\n+\t    for (k = cycle * REGEXP_ONEOF (regexp)->regexps_num;\n+\t\t k < (int) VLA_PTR_LENGTH (cycle_alt_unit_usages)\n+\t\t   && k == cycle * REGEXP_ONEOF (regexp)->regexps_num;\n+\t\t k++)\n+\t      {\n+\t\tfor (other_unit_usage_ptr = VLA_PTR (cycle_alt_unit_usages, k);\n+\t\t     other_unit_usage_ptr != NULL;\n+\t\t     other_unit_usage_ptr = other_unit_usage_ptr->next)\n+\t\t  if (unit_usage_ptr->unit_decl->automaton_decl\n+\t\t      == other_unit_usage_ptr->unit_decl->automaton_decl)\n+\t\t    break;\n+\t\tif (other_unit_usage_ptr == NULL\n+\t\t    && VLA_PTR (cycle_alt_unit_usages, k) != NULL)\n+\t\t  break;\n+\t      }\n+\t    if (k < (int) VLA_PTR_LENGTH (cycle_alt_unit_usages)\n+\t\t&& k == cycle * REGEXP_ONEOF (regexp)->regexps_num)\n+\t      {\n+\t\tif (!annotation_message_reported_p)\n+\t\t  {\n+\t\t    fprintf (stderr, \"\\n\");\n+\t\t    error (\"The following units do not satisfy units-automata distribution rule\");\n+\t\t    error (\" (A unit of given unit automaton should be on each reserv. altern.)\");\n+\t\t    annotation_message_reported_p = TRUE;\n+\t\t  }\n+\t\terror (\"Unit %s, reserv. %s, cycle %d\",\n+\t\t       unit_usage_ptr->unit_decl->name, insn_reserv_name,\n+\t\t       cycle);\n+\t      }\n+\t  }\n+    }\n+  VLA_PTR_DELETE (cycle_alt_unit_usages);\n+  obstack_free (&unit_usages, NULL);\n }\n \n /* The function finds units which violates units to automata"}]}