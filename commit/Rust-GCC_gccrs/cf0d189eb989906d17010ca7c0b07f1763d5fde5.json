{"sha": "cf0d189eb989906d17010ca7c0b07f1763d5fde5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YwZDE4OWViOTg5OTA2ZDE3MDEwY2E3YzBiMDdmMTc2M2Q1ZmRlNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:53:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:53:56Z"}, "message": "Make calls.c use function_arg_info internally\n\nThis patch makes the two main calls.c argument-processing\nroutines track the state of the argument in a function_arg_info\ninstead of using separate mode variables.\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* calls.c (emit_library_call_value_1): Merge arg and orig_arg\n\tinto a single function_arg_info, updating its fields when we\n\tapply pass-by-reference and promotion semantics.  Use the\n\tfunction_arg_info to track the mode rather than keeping it in\n\ta separate local variable.\n\t(initialize_argument_information): Likewise.  Base the final\n\targ_to_skip on this new function_arg_info rather than creating\n\ta new one from scratch.\n\nFrom-SVN: r274706", "tree": {"sha": "69bb9a54638a17fd4c8ba6658acedc1064c7fab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69bb9a54638a17fd4c8ba6658acedc1064c7fab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf0d189eb989906d17010ca7c0b07f1763d5fde5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf0d189eb989906d17010ca7c0b07f1763d5fde5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf0d189eb989906d17010ca7c0b07f1763d5fde5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf0d189eb989906d17010ca7c0b07f1763d5fde5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "634afa05a8cbff010480088811fe1f39eca70c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634afa05a8cbff010480088811fe1f39eca70c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/634afa05a8cbff010480088811fe1f39eca70c1d"}], "stats": {"total": 71, "additions": 42, "deletions": 29}, "files": [{"sha": "2a6d8910bfbaecae6ec168a43866f51aa6b52818", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf0d189eb989906d17010ca7c0b07f1763d5fde5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf0d189eb989906d17010ca7c0b07f1763d5fde5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf0d189eb989906d17010ca7c0b07f1763d5fde5", "patch": "@@ -1,3 +1,14 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* calls.c (emit_library_call_value_1): Merge arg and orig_arg\n+\tinto a single function_arg_info, updating its fields when we\n+\tapply pass-by-reference and promotion semantics.  Use the\n+\tfunction_arg_info to track the mode rather than keeping it in\n+\ta separate local variable.\n+\t(initialize_argument_information): Likewise.  Base the final\n+\targ_to_skip on this new function_arg_info rather than creating\n+\ta new one from scratch.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* function.c (assign_parm_data_one): Replace passed_type,"}, {"sha": "454e5130391e9dbceffe44f0d82f9336f68ed5fa", "filename": "gcc/calls.c", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf0d189eb989906d17010ca7c0b07f1763d5fde5/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf0d189eb989906d17010ca7c0b07f1763d5fde5/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=cf0d189eb989906d17010ca7c0b07f1763d5fde5", "patch": "@@ -1982,7 +1982,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n     {\n       tree type = TREE_TYPE (args[i].tree_value);\n       int unsignedp;\n-      machine_mode mode;\n \n       /* Replace erroneous argument with constant zero.  */\n       if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n@@ -2010,13 +2009,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t with those made by function.c.  */\n \n       /* See if this argument should be passed by invisible reference.  */\n-      function_arg_info orig_arg (type, argpos < n_named_args);\n-      if (pass_by_reference (args_so_far_pnt, orig_arg))\n+      function_arg_info arg (type, argpos < n_named_args);\n+      if (pass_by_reference (args_so_far_pnt, arg))\n \t{\n \t  bool callee_copies;\n \t  tree base = NULL_TREE;\n \n-\t  callee_copies = reference_callee_copied (args_so_far_pnt, orig_arg);\n+\t  callee_copies = reference_callee_copied (args_so_far_pnt, arg);\n \n \t  /* If we're compiling a thunk, pass through invisible references\n \t     instead of making a copy.  */\n@@ -2129,15 +2128,16 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t}\n \n       unsignedp = TYPE_UNSIGNED (type);\n-      mode = promote_function_mode (type, TYPE_MODE (type), &unsignedp,\n-\t\t\t\t    fndecl ? TREE_TYPE (fndecl) : fntype, 0);\n+      arg.type = type;\n+      arg.mode\n+\t= promote_function_mode (type, TYPE_MODE (type), &unsignedp,\n+\t\t\t\t fndecl ? TREE_TYPE (fndecl) : fntype, 0);\n \n       args[i].unsignedp = unsignedp;\n-      args[i].mode = mode;\n+      args[i].mode = arg.mode;\n \n       targetm.calls.warn_parameter_passing_abi (args_so_far, type);\n \n-      function_arg_info arg (type, mode, argpos < n_named_args);\n       args[i].reg = targetm.calls.function_arg (args_so_far, arg);\n \n       if (args[i].reg && CONST_INT_P (args[i].reg))\n@@ -2177,7 +2177,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       if (args[i].reg == 0 || args[i].partial != 0\n \t       || reg_parm_stack_space > 0\n \t       || args[i].pass_on_stack)\n-\tlocate_and_pad_parm (mode, type,\n+\tlocate_and_pad_parm (arg.mode, type,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n \t\t\t     1,\n #else\n@@ -2191,7 +2191,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t/* The argument is passed entirely in registers.  See at which\n \t   end it should be padded.  */\n \targs[i].locate.where_pad =\n-\t  BLOCK_REG_PADDING (mode, type,\n+\t  BLOCK_REG_PADDING (arg.mode, type,\n \t\t\t     int_size_in_bytes (type) <= UNITS_PER_WORD);\n #endif\n \n@@ -2208,9 +2208,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t promoted_mode used for function_arg above.  However, the\n \t corresponding handling of incoming arguments in function.c\n \t does pass the promoted mode.  */\n-      function_arg_info arg_to_skip (type, TYPE_MODE (type),\n-\t\t\t\t     argpos < n_named_args);\n-      targetm.calls.function_arg_advance (args_so_far, arg_to_skip);\n+      arg.mode = TYPE_MODE (type);\n+      targetm.calls.function_arg_advance (args_so_far, arg);\n \n       /* Store argument values for functions decorated with attribute\n \t alloc_size.  */\n@@ -4906,24 +4905,25 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   for (unsigned int i = 0; count < nargs; i++, count++)\n     {\n       rtx val = args[i].first;\n-      machine_mode mode = args[i].second;\n+      function_arg_info arg (args[i].second, /*named=*/true);\n       int unsigned_p = 0;\n \n       /* We cannot convert the arg value to the mode the library wants here;\n \t must do it earlier where we know the signedness of the arg.  */\n-      gcc_assert (mode != BLKmode\n-\t\t  && (GET_MODE (val) == mode || GET_MODE (val) == VOIDmode));\n+      gcc_assert (arg.mode != BLKmode\n+\t\t  && (GET_MODE (val) == arg.mode\n+\t\t      || GET_MODE (val) == VOIDmode));\n \n       /* Make sure it is a reasonable operand for a move or push insn.  */\n       if (!REG_P (val) && !MEM_P (val)\n-\t  && !(CONSTANT_P (val) && targetm.legitimate_constant_p (mode, val)))\n+\t  && !(CONSTANT_P (val)\n+\t       && targetm.legitimate_constant_p (arg.mode, val)))\n \tval = force_operand (val, NULL_RTX);\n \n-      function_arg_info orig_arg (mode, /*named=*/true);\n-      if (pass_by_reference (&args_so_far_v, orig_arg))\n+      if (pass_by_reference (&args_so_far_v, arg))\n \t{\n \t  rtx slot;\n-\t  int must_copy = !reference_callee_copied (&args_so_far_v, orig_arg);\n+\t  int must_copy = !reference_callee_copied (&args_so_far_v, arg);\n \n \t  /* If this was a CONST function, it is now PURE since it now\n \t     reads memory.  */\n@@ -4942,7 +4942,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t    }\n \t  else\n \t    {\n-\t      slot = assign_temp (lang_hooks.types.type_for_mode (mode, 0),\n+\t      slot = assign_temp (lang_hooks.types.type_for_mode (arg.mode, 0),\n \t\t\t\t  1, 1);\n \t      emit_move_insn (slot, val);\n \t    }\n@@ -4956,14 +4956,15 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t\t\t\t\t\t      slot),\n \t\t\t\t\t     call_fusage);\n \n-\t  mode = Pmode;\n+\t  arg.mode = Pmode;\n \t  val = force_operand (XEXP (slot, 0), NULL_RTX);\n \t}\n \n-      mode = promote_function_mode (NULL_TREE, mode, &unsigned_p, NULL_TREE, 0);\n-      function_arg_info arg (mode, /*named=*/true);\n-      argvec[count].mode = mode;\n-      argvec[count].value = convert_modes (mode, GET_MODE (val), val, unsigned_p);\n+      arg.mode = promote_function_mode (NULL_TREE, arg.mode, &unsigned_p,\n+\t\t\t\t\tNULL_TREE, 0);\n+      argvec[count].mode = arg.mode;\n+      argvec[count].value = convert_modes (arg.mode, GET_MODE (val), val,\n+\t\t\t\t\t   unsigned_p);\n       argvec[count].reg = targetm.calls.function_arg (args_so_far, arg);\n \n       argvec[count].partial\n@@ -4973,7 +4974,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  || argvec[count].partial != 0\n \t  || reg_parm_stack_space > 0)\n \t{\n-\t  locate_and_pad_parm (mode, NULL_TREE,\n+\t  locate_and_pad_parm (arg.mode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n \t\t\t       1,\n #else\n@@ -4989,8 +4990,9 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t/* The argument is passed entirely in registers.  See at which\n \t   end it should be padded.  */\n \targvec[count].locate.where_pad =\n-\t  BLOCK_REG_PADDING (mode, NULL_TREE,\n-\t\t\t     known_le (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n+\t  BLOCK_REG_PADDING (arg.mode, NULL_TREE,\n+\t\t\t     known_le (GET_MODE_SIZE (arg.mode),\n+\t\t\t\t       UNITS_PER_WORD));\n #endif\n \n       targetm.calls.function_arg_advance (args_so_far, arg);"}]}