{"sha": "f43329a5ae7245add8191783724d9bb99006f3b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQzMzI5YTVhZTcyNDVhZGQ4MTkxNzgzNzI0ZDliYjk5MDA2ZjNiMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-11T19:50:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-11T19:50:21Z"}, "message": "profile.c (BB_TO_GCOV_INDEX): move more to the front.\n\n\t* profile.c (BB_TO_GCOV_INDEX): move more to the front.\n\t(output_location): Break out from ....\n\t(branch_prob): ... here; handle gcov output on trees.\n\t* toplev.c (process_options): No longer be sorry about coverage for\n\ttrees.\n\nFrom-SVN: r87364", "tree": {"sha": "e110d172852c144f573e4bd063d5b6e81bde2518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e110d172852c144f573e4bd063d5b6e81bde2518"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f43329a5ae7245add8191783724d9bb99006f3b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43329a5ae7245add8191783724d9bb99006f3b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f43329a5ae7245add8191783724d9bb99006f3b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43329a5ae7245add8191783724d9bb99006f3b3/comments", "author": null, "committer": null, "parents": [{"sha": "05cf561db41aa56f53e0c77b4489987f25fe2efa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05cf561db41aa56f53e0c77b4489987f25fe2efa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05cf561db41aa56f53e0c77b4489987f25fe2efa"}], "stats": {"total": 210, "additions": 151, "deletions": 59}, "files": [{"sha": "7429882c3c19134a6e4072d3c0e0fa68a796673d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43329a5ae7245add8191783724d9bb99006f3b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43329a5ae7245add8191783724d9bb99006f3b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f43329a5ae7245add8191783724d9bb99006f3b3", "patch": "@@ -1,3 +1,11 @@\n+2004-09-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* profile.c (BB_TO_GCOV_INDEX): move more to the front.\n+\t(output_location): Break out from ....\n+\t(branch_prob): ... here; handle gcov output on trees.\n+\t* toplev.c (process_options): No longer be sorry about coverage for\n+\ttrees.\n+\n 2004-09-11  Steven Bosscher  <stevenb@suse.de>\n \n \tPR c++/17412"}, {"sha": "7b0a667b1fe8dd3ebda0284167248612b9ab344f", "filename": "gcc/profile.c", "status": "modified", "additions": 143, "deletions": 57, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43329a5ae7245add8191783724d9bb99006f3b3/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43329a5ae7245add8191783724d9bb99006f3b3/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=f43329a5ae7245add8191783724d9bb99006f3b3", "patch": "@@ -684,6 +684,53 @@ compute_value_histograms (histogram_values values)\n       free (histogram_counts[t]);\n }\n \n+#define BB_TO_GCOV_INDEX(bb)  ((bb)->index + 1)\n+/* When passed NULL as file_name, initialize.\n+   When passed something else, output the neccesary commands to change\n+   line to LINE and offset to FILE_NAME.  */\n+static void\n+output_location (char const *file_name, int line,\n+\t\t gcov_position_t *offset, basic_block bb)\n+{\n+  static char const *prev_file_name;\n+  static int prev_line;\n+  bool name_differs, line_differs;\n+\n+  if (!file_name)\n+    {\n+      prev_file_name = NULL;\n+      prev_line = -1;\n+      return;\n+    }\n+\n+  name_differs = !prev_file_name || strcmp (file_name, prev_file_name);\n+  line_differs = prev_line != line;\n+\n+  if (name_differs || line_differs)\n+    {\n+      if (!*offset)\n+\t{\n+\t  *offset = gcov_write_tag (GCOV_TAG_LINES);\n+\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n+\t  name_differs = line_differs=true;\n+\t}\n+\n+      /* If this is a new source file, then output the\n+\t file's name to the .bb file.  */\n+      if (name_differs)\n+\t{\n+\t  prev_file_name = file_name;\n+\t  gcov_write_unsigned (0);\n+\t  gcov_write_string (prev_file_name);\n+\t}\n+      if (line_differs)\n+\t{\n+\t  gcov_write_unsigned (line);\n+\t  prev_line = line;\n+\t}\n+     }\n+}\n+\n /* Instrument and/or analyze program behavior based on program flow graph.\n    In either case, this function builds a flow graph for the function being\n    compiled.  The flow graph is stored in BB_GRAPH.\n@@ -850,7 +897,6 @@ branch_prob (void)\n       */\n   ENTRY_BLOCK_PTR->index = -1;\n   EXIT_BLOCK_PTR->index = last_basic_block;\n-#define BB_TO_GCOV_INDEX(bb)  ((bb)->index + 1)\n \n   /* Arcs */\n   if (coverage_begin_output ())\n@@ -877,6 +923,12 @@ branch_prob (void)\n \t\t    flag_bits |= GCOV_ARC_FAKE;\n \t\t  if (e->flags & EDGE_FALLTHRU)\n \t\t    flag_bits |= GCOV_ARC_FALLTHROUGH;\n+\t\t  /* On trees we don't have fallthru flags, but we can\n+\t\t     recompute them from CFG shape.  */\n+\t\t  if (ir_type ()\n+\t\t      && e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)\n+\t\t      && e->src->next_bb == e->dest)\n+\t\t    flag_bits |= GCOV_ARC_FALLTHROUGH;\n \n \t\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (e->dest));\n \t\t  gcov_write_unsigned (flag_bits);\n@@ -888,78 +940,112 @@ branch_prob (void)\n     }\n \n   /* Line numbers.  */\n-  /* FIXME:  make this work for trees.  (Line numbers are in location_t\n-     objects, but aren't always attached to the obvious tree...) */\n-  if (coverage_begin_output () && !ir_type ())\n+  if (coverage_begin_output ())\n     {\n-      char const *prev_file_name = NULL;\n-      gcov_position_t offset;\n+      /* Initialize the output.  */\n+      output_location (NULL, 0, NULL, NULL);\n \n-      FOR_EACH_BB (bb)\n+      if (!ir_type ())\n \t{\n-\t  rtx insn = BB_HEAD (bb);\n-\t  int ignore_next_note = 0;\n-\n-\t  offset = 0;\n-\n-\t  /* We are looking for line number notes.  Search backward\n-\t     before basic block to find correct ones.  */\n-\t  insn = prev_nonnote_insn (insn);\n-\t  if (!insn)\n-\t    insn = get_insns ();\n-\t  else\n-\t    insn = NEXT_INSN (insn);\n+\t  gcov_position_t offset;\n \n-\t  while (insn != BB_END (bb))\n+\t  FOR_EACH_BB (bb)\n \t    {\n-\t      if (NOTE_P (insn))\n-\t\t{\n-\t\t  /* Must ignore the line number notes that\n-\t\t     immediately follow the end of an inline function\n-\t\t     to avoid counting it twice.  There is a note\n-\t\t     before the call, and one after the call.  */\n-\t\t  if (NOTE_LINE_NUMBER (insn)\n-\t\t      == NOTE_INSN_REPEATED_LINE_NUMBER)\n-\t\t    ignore_next_note = 1;\n-\t\t  else if (NOTE_LINE_NUMBER (insn) <= 0)\n-\t\t    /*NOP*/;\n-\t\t  else if (ignore_next_note)\n-\t\t    ignore_next_note = 0;\n-\t\t  else\n-\t\t    {\n-\t\t      expanded_location s;\n+\t      rtx insn = BB_HEAD (bb);\n+\t      int ignore_next_note = 0;\n \n-\t\t      if (!offset)\n-\t\t\t{\n-\t\t\t  offset = gcov_write_tag (GCOV_TAG_LINES);\n-\t\t\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n-\t\t\t}\n+\t      offset = 0;\n \n-\t\t      NOTE_EXPANDED_LOCATION (s, insn);\n+\t      /* We are looking for line number notes.  Search backward\n+\t\t before basic block to find correct ones.  */\n+\t      insn = prev_nonnote_insn (insn);\n+\t      if (!insn)\n+\t\tinsn = get_insns ();\n+\t      else\n+\t\tinsn = NEXT_INSN (insn);\n \n-\t\t      /* If this is a new source file, then output the\n-\t\t\t file's name to the .bb file.  */\n-\t\t      if (!prev_file_name\n-\t\t\t  || strcmp (s.file, prev_file_name))\n+\t      while (insn != BB_END (bb))\n+\t\t{\n+\t\t  if (NOTE_P (insn))\n+\t\t    {\n+\t\t      /* Must ignore the line number notes that\n+\t\t\t immediately follow the end of an inline function\n+\t\t\t to avoid counting it twice.  There is a note\n+\t\t\t before the call, and one after the call.  */\n+\t\t      if (NOTE_LINE_NUMBER (insn)\n+\t\t\t  == NOTE_INSN_REPEATED_LINE_NUMBER)\n+\t\t\tignore_next_note = 1;\n+\t\t      else if (NOTE_LINE_NUMBER (insn) <= 0)\n+\t\t\t/*NOP*/;\n+\t\t      else if (ignore_next_note)\n+\t\t\tignore_next_note = 0;\n+\t\t      else\n \t\t\t{\n-\t\t\t  prev_file_name = s.file;\n-\t\t\t  gcov_write_unsigned (0);\n-\t\t\t  gcov_write_string (prev_file_name);\n+\t\t          expanded_location s;\n+\t\t          NOTE_EXPANDED_LOCATION (s, insn);\n+\t\t\t  output_location (s.file, NOTE_LINE_NUMBER (insn), &offset, bb);\n \t\t\t}\n-\t\t      gcov_write_unsigned (s.line);\n \t\t    }\n+\t\t  insn = NEXT_INSN (insn);\n+\t\t}\n+\n+\t      if (offset)\n+\t\t{\n+\t\t  /* A file of NULL indicates the end of run.  */\n+\t\t  gcov_write_unsigned (0);\n+\t\t  gcov_write_string (NULL);\n+\t\t  gcov_write_length (offset);\n \t\t}\n-\t      insn = NEXT_INSN (insn);\n \t    }\n+\t}\n+      else\n+\t{\n+\t  gcov_position_t offset;\n+\t  location_t *curr_location = NULL;\n \n-\t  if (offset)\n+\t  FOR_EACH_BB (bb)\n \t    {\n-\t      /* A file of NULL indicates the end of run.  */\n-\t      gcov_write_unsigned (0);\n-\t      gcov_write_string (NULL);\n-\t      gcov_write_length (offset);\n+\t      block_stmt_iterator bsi;\n+\n+\t      offset = 0;\n+\n+\t      if (bb == ENTRY_BLOCK_PTR->next_bb)\n+\t\t{\n+\t\t  curr_location = &DECL_SOURCE_LOCATION (current_function_decl);\n+\t\t  output_location (curr_location->file, curr_location->line,\n+\t\t\t\t   &offset, bb);\n+\t\t}\n+\n+\t      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t\t{\n+\t\t  tree stmt = bsi_stmt (bsi);\n+#ifdef USE_MAPPED_LOCATION\n+\t\t  curr_location = EXPR_LOCATION (stmt);\n+#else\n+\t\t  curr_location = EXPR_LOCUS (stmt);\n+#endif\n+\t\t  if (curr_location)\n+\t\t    output_location (curr_location->file, curr_location->line,\n+\t\t\t\t     &offset, bb);\n+\t\t}\n+\n+\t      /* Notice GOTO expressions we elliminated while constructing the\n+\t         CFG.  */\n+\t      if (bb->succ && !bb->succ->succ_next && bb->succ->goto_locus)\n+\t        {\n+\t\t  curr_location = bb->succ->goto_locus;\n+\t          output_location (curr_location->file, curr_location->line, &offset, bb);\n+\t        }\n+\n+\t      if (offset)\n+\t\t{\n+\t\t  /* A file of NULL indicates the end of run.  */\n+\t\t  gcov_write_unsigned (0);\n+\t\t  gcov_write_string (NULL);\n+\t\t  gcov_write_length (offset);\n+\t\t}\n \t    }\n-\t}\n+\t }\n     }\n \n   ENTRY_BLOCK_PTR->index = ENTRY_BLOCK;"}, {"sha": "f63e80ba48e885f3be495c7240b60366b494ff40", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43329a5ae7245add8191783724d9bb99006f3b3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43329a5ae7245add8191783724d9bb99006f3b3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f43329a5ae7245add8191783724d9bb99006f3b3", "patch": "@@ -1752,8 +1752,6 @@ process_options (void)\n     warning (\"this target machine does not have delayed branches\");\n #endif\n \n-  if (flag_tree_based_profiling && flag_test_coverage)\n-    sorry (\"test-coverage not yet implemented in trees.\");\n   if (flag_tree_based_profiling && flag_profile_values)\n     sorry (\"value-based profiling not yet implemented in trees.\");\n "}]}