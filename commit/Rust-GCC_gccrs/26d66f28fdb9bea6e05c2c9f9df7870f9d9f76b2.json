{"sha": "26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZkNjZmMjhmZGI5YmVhNmUwNWMyYzlmOWRmNzg3MGY5ZDlmNzZiMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-08-08T12:49:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-08-08T12:49:39Z"}, "message": "re PR tree-optimization/81723 (fortran build doesn't terminate on 64bit targets)\n\n2017-08-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/81723\n\t* tree-vect-slp.c (struct bst_traits): New hash traits.\n\t(bst_fail): New global.\n\t(vect_build_slp_tree_2): New worker, split out from ...\n\t(vect_build_slp_tree): ... this now wrapping it with using\n\tbst_fail set to cache SLP tree build fails.  Properly handle\n\tmax_tree_size.\n\t(vect_analyze_slp_instance): Allocate and free bst_fail.\n\n\t* gfortran.dg/pr81723.f: New testcase.\n\nFrom-SVN: r250953", "tree": {"sha": "44c9ca13f1ec9e28922d7e114717cf35d2f576bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44c9ca13f1ec9e28922d7e114717cf35d2f576bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "82c0d3ebe651bb12c087855c0e621cf070e97ed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c0d3ebe651bb12c087855c0e621cf070e97ed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c0d3ebe651bb12c087855c0e621cf070e97ed3"}], "stats": {"total": 159, "additions": 153, "deletions": 6}, "files": [{"sha": "c88e6668c9ef602af09f7c15687358a2b7782e0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2", "patch": "@@ -1,3 +1,14 @@\n+2017-08-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/81723\n+\t* tree-vect-slp.c (struct bst_traits): New hash traits.\n+\t(bst_fail): New global.\n+\t(vect_build_slp_tree_2): New worker, split out from ...\n+\t(vect_build_slp_tree): ... this now wrapping it with using\n+\tbst_fail set to cache SLP tree build fails.  Properly handle\n+\tmax_tree_size.\n+\t(vect_analyze_slp_instance): Allocate and free bst_fail.\n+\n 2017-08-08  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-opt/81696"}, {"sha": "a3f5d46ed7d9d7942e2ed50d099714210285bac9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2", "patch": "@@ -1,3 +1,8 @@\n+2017-08-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/81723\n+\t* gfortran.dg/pr81723.f: New testcase.\n+\n 2017-08-08  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/bfp/scalar-extract-exp-2.c: Adjust diagnostic"}, {"sha": "977c1b69bbfce3ee7fd49699120999372041c779", "filename": "gcc/testsuite/gfortran.dg/pr81723.f", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81723.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81723.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr81723.f?ref=26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -fno-automatic\" }\n+\n+      FUNCTION WWERF(Z)\n+\n+      IMPLICIT DOUBLE PRECISION (A-H,O-Z)\n+      COMPLEX*16 WWERF\n+      COMPLEX*16 Z,ZH,R(37),S,T,V,W\n+\n+      PARAMETER (Z1 = 1, HF = Z1/2, Z10 = 10)\n+      PARAMETER (C1 = 74/Z10, C2 = 83/Z10, C3 = Z10/32, C4 = 16/Z10)\n+      PARAMETER (C = 1.12837 91670 95512 57D0, P = (2*C4)**33)\n+\n+      DOUBLE PRECISION GREAL,GIMAG,XARG,YARG\n+      COMPLEX*16 ZARG,GCONJG,GCMPLX\n+      GREAL( ZARG)=DREAL( ZARG)\n+      GIMAG( ZARG)=DIMAG( ZARG)\n+      GCONJG(ZARG)=DCONJG(ZARG)\n+      GCMPLX(XARG,YARG)=DCMPLX(XARG,YARG)\n+\n+      X=Z\n+      Y=GIMAG(Z)\n+      XA=ABS(X)\n+      YA=ABS(Y)\n+      IF(YA .LT. C1 .AND. XA .LT. C2) THEN\n+       ZH=GCMPLX(YA+C4,XA)\n+       R(37)=0\n+       DO 1 N = 36,1,-1\n+       T=ZH+N*GCONJG(R(N+1))\n+    1  R(N)=HF*T/(GREAL(T)**2+GIMAG(T)**2)\n+       XL=P\n+       S=0\n+       DO 2 N = 33,1,-1\n+       XL=C3*XL\n+    2  S=R(N)*(S+XL)\n+       V=C*S\n+      ELSE\n+       ZH=GCMPLX(YA,XA)\n+       R(1)=0\n+       DO 3 N = 9,1,-1\n+       T=ZH+N*GCONJG(R(1))\n+    3  R(1)=HF*T/(GREAL(T)**2+GIMAG(T)**2)\n+       V=C*R(1)\n+      END IF\n+      IF(YA .EQ. 0) V=GCMPLX(EXP(-XA**2),GIMAG(V))\n+      IF(Y .LT. 0) THEN\n+       V=2*EXP(-GCMPLX(XA,YA)**2)-V\n+       IF(X .GT. 0) V=GCONJG(V)\n+      ELSE\n+       IF(X .LT. 0) V=GCONJG(V)\n+      END IF\n+\n+      WWERF=V\n+\n+      RETURN\n+      END"}, {"sha": "04ecaab7fc35c98d1c5cc787dd8bb457b39eb2ef", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=26d66f28fdb9bea6e05c2c9f9df7870f9d9f76b2", "patch": "@@ -908,12 +908,49 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   return true;\n }\n \n-/* Recursively build an SLP tree starting from NODE.\n-   Fail (and return a value not equal to zero) if def-stmts are not\n-   isomorphic, require data permutation or are of unsupported types of\n-   operation.  Otherwise, return 0.\n-   The value returned is the depth in the SLP tree where a mismatch\n-   was found.  */\n+/* Traits for the hash_set to record failed SLP builds for a stmt set.\n+   Note we never remove apart from at destruction time so we do not\n+   need a special value for deleted that differs from empty.  */\n+struct bst_traits\n+{\n+  typedef vec <gimple *> value_type;\n+  typedef vec <gimple *> compare_type;\n+  static inline hashval_t hash (value_type);\n+  static inline bool equal (value_type existing, value_type candidate);\n+  static inline bool is_empty (value_type x) { return !x.exists (); }\n+  static inline bool is_deleted (value_type x) { return !x.exists (); }\n+  static inline void mark_empty (value_type &x) { x.release (); }\n+  static inline void mark_deleted (value_type &x) { x.release (); }\n+  static inline void remove (value_type &x) { x.release (); }\n+};\n+inline hashval_t\n+bst_traits::hash (value_type x)\n+{\n+  inchash::hash h;\n+  for (unsigned i = 0; i < x.length (); ++i)\n+    h.add_int (gimple_uid (x[i]));\n+  return h.end ();\n+}\n+inline bool\n+bst_traits::equal (value_type existing, value_type candidate)\n+{\n+  if (existing.length () != candidate.length ())\n+    return false;\n+  for (unsigned i = 0; i < existing.length (); ++i)\n+    if (existing[i] != candidate[i])\n+      return false;\n+  return true;\n+}\n+\n+static hash_set <vec <gimple *>, bst_traits> *bst_fail;\n+\n+static slp_tree\n+vect_build_slp_tree_2 (vec_info *vinfo,\n+\t\t       vec<gimple *> stmts, unsigned int group_size,\n+\t\t       unsigned int *max_nunits,\n+\t\t       vec<slp_tree> *loads,\n+\t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n+\t\t       unsigned max_tree_size);\n \n static slp_tree\n vect_build_slp_tree (vec_info *vinfo,\n@@ -922,6 +959,39 @@ vect_build_slp_tree (vec_info *vinfo,\n                      vec<slp_tree> *loads,\n \t\t     bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t     unsigned max_tree_size)\n+{\n+  if (bst_fail->contains (stmts))\n+    return NULL;\n+  slp_tree res = vect_build_slp_tree_2 (vinfo, stmts, group_size, max_nunits,\n+\t\t\t\t\tloads, matches, npermutes, tree_size,\n+\t\t\t\t\tmax_tree_size);\n+  /* When SLP build fails for stmts record this, otherwise SLP build\n+     can be exponential in time when we allow to construct parts from\n+     scalars, see PR81723.  */\n+  if (! res)\n+    {\n+      vec <gimple *> x;\n+      x.create (stmts.length ());\n+      x.splice (stmts);\n+      bst_fail->add (x);\n+    }\n+  return res;\n+}\n+\n+/* Recursively build an SLP tree starting from NODE.\n+   Fail (and return a value not equal to zero) if def-stmts are not\n+   isomorphic, require data permutation or are of unsupported types of\n+   operation.  Otherwise, return 0.\n+   The value returned is the depth in the SLP tree where a mismatch\n+   was found.  */\n+\n+static slp_tree\n+vect_build_slp_tree_2 (vec_info *vinfo,\n+\t\t       vec<gimple *> stmts, unsigned int group_size,\n+\t\t       unsigned int *max_nunits,\n+\t\t       vec<slp_tree> *loads,\n+\t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n+\t\t       unsigned max_tree_size)\n {\n   unsigned nops, i, this_tree_size = 0, this_max_nunits = *max_nunits;\n   gimple *stmt;\n@@ -1014,6 +1084,9 @@ vect_build_slp_tree (vec_info *vinfo,\n \n   stmt = stmts[0];\n \n+  if (tree_size)\n+    max_tree_size -= *tree_size;\n+\n   /* Create SLP_TREE nodes for the definition node/s.  */\n   FOR_EACH_VEC_ELT (oprnds_info, i, oprnd_info)\n     {\n@@ -1933,9 +2006,11 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   /* Build the tree for the SLP instance.  */\n   bool *matches = XALLOCAVEC (bool, group_size);\n   unsigned npermutes = 0;\n+  bst_fail = new hash_set <vec <gimple *>, bst_traits> ();\n   node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n \t\t\t\t   &max_nunits, &loads, matches, &npermutes,\n \t\t\t      NULL, max_tree_size);\n+  delete bst_fail;\n   if (node != NULL)\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */"}]}