{"sha": "8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE0OThmOTljYWJhN2YzNjZlMDdmYmY1MjdkN2VkN2ZjYmUwMzhiMw==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2017-09-16T14:50:07Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2017-09-16T14:50:07Z"}, "message": "Refine formatting and comments.\n\ngcc/\n\t* config/nds32/nds32.c: Refine formatting and comments.\n\t* config/nds32/nds32.h: Likewise.\n\t* config/nds32/nds32.md: Likewise.\n\t* config/nds32/nds32-cost.c: Likewise.\n\t* config/nds32/nds32-isr.c: Likewise.\n\t* config/nds32/nds32-md-auxiliary.c: Likewise.\n\t* config/nds32/nds32-multiple.md: Likewise.\n\t* config/nds32/nds32-predicates.c: Likewise.\n\nFrom-SVN: r252874", "tree": {"sha": "f03a4e5ec59c36401d00be167e7954382482dd13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f03a4e5ec59c36401d00be167e7954382482dd13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ebc6a85e3e8dc9a3e02301a6f9e2216781af565a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc6a85e3e8dc9a3e02301a6f9e2216781af565a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebc6a85e3e8dc9a3e02301a6f9e2216781af565a"}], "stats": {"total": 782, "additions": 396, "deletions": 386}, "files": [{"sha": "173ed96dbc3d9e72f6acc551f2675f5d23cdf9bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -1,3 +1,14 @@\n+2017-09-16  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32.c: Refine formatting and comments.\n+\t* config/nds32/nds32.h: Likewise.\n+\t* config/nds32/nds32.md: Likewise.\n+\t* config/nds32/nds32-cost.c: Likewise.\n+\t* config/nds32/nds32-isr.c: Likewise.\n+\t* config/nds32/nds32-md-auxiliary.c: Likewise.\n+\t* config/nds32/nds32-multiple.md: Likewise.\n+\t* config/nds32/nds32-predicates.c: Likewise.\n+\n 2017-09-15  Andrew Sutton  <andrew.n.sutton@gmail.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "c507517ee8d2962c184103cf1c672beea541603f", "filename": "gcc/config/nds32/nds32-cost.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -99,7 +99,7 @@ nds32_rtx_costs_impl (rtx x,\n     {\n     case SET:\n       /* For 'SET' rtx, we need to return false\n-         so that it can recursively calculate costs.  */\n+\t so that it can recursively calculate costs.  */\n       return false;\n \n     case USE:\n@@ -109,7 +109,7 @@ nds32_rtx_costs_impl (rtx x,\n \n     case CONST_INT:\n       /* All instructions involving constant operation\n-         need to be considered for cost evaluation.  */\n+\t need to be considered for cost evaluation.  */\n       if (outer_code == SET)\n \t{\n \t  /* (set X imm5s), use movi55, 2-byte cost.\n@@ -202,17 +202,17 @@ nds32_address_cost_impl (rtx address,\n     case POST_INC:\n     case POST_DEC:\n       /* We encourage that rtx contains\n-         POST_MODIFY/POST_INC/POST_DEC behavior.  */\n+\t POST_MODIFY/POST_INC/POST_DEC behavior.  */\n       return 0;\n \n     case SYMBOL_REF:\n       /* We can have gp-relative load/store for symbol_ref.\n-         Have it 4-byte cost.  */\n+\t Have it 4-byte cost.  */\n       return COSTS_N_INSNS (1);\n \n     case CONST:\n       /* It is supposed to be the pattern (const (plus symbol_ref const_int)).\n-         Have it 4-byte cost.  */\n+\t Have it 4-byte cost.  */\n       return COSTS_N_INSNS (1);\n \n     case REG:\n@@ -221,14 +221,14 @@ nds32_address_cost_impl (rtx address,\n \n     case PLUS:\n       /* We do not need to check if the address is a legitimate address,\n-         because this hook is never called with an invalid address.\n-         But we better check the range of\n-         const_int value for cost, if it exists.  */\n+\t because this hook is never called with an invalid address.\n+\t But we better check the range of\n+\t const_int value for cost, if it exists.  */\n       plus0 = XEXP (address, 0);\n       plus1 = XEXP (address, 1);\n \n       if (REG_P (plus0) && CONST_INT_P (plus1))\n-        {\n+\t{\n \t  /* If it is possible to be lwi333/swi333 form,\n \t     make it 2-byte cost.  */\n \t  if (satisfies_constraint_Iu05 (plus1))"}, {"sha": "933072c2863f4bda8f5f50b9a9b6b36b9d0e2ee6", "filename": "gcc/config/nds32/nds32-isr.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-isr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-isr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-isr.c?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -171,20 +171,20 @@ nds32_emit_isr_vector_section (int vector_id)\n   if (nds32_isr_vector_size == 4)\n     {\n       /* This block is for 4-byte vector size.\n-         Hardware $VID support is necessary and only one instruction\n-         is needed in vector section.  */\n+\t Hardware $VID support is necessary and only one instruction\n+\t is needed in vector section.  */\n       fprintf (asm_out_file, \"\\tj\\t%s ! jump to first level handler\\n\",\n \t\t\t     first_level_handler_name);\n     }\n   else\n     {\n       /* This block is for 16-byte vector size.\n-         There is NO hardware $VID so that we need several instructions\n-         such as pushing GPRs and preparing software vid at vector section.\n-         For pushing GPRs, there are four variations for\n-         16-byte vector content and we have to handle each combination.\n-         For preparing software vid, note that the vid need to\n-         be substracted vector_number_offset.  */\n+\t There is NO hardware $VID so that we need several instructions\n+\t such as pushing GPRs and preparing software vid at vector section.\n+\t For pushing GPRs, there are four variations for\n+\t 16-byte vector content and we have to handle each combination.\n+\t For preparing software vid, note that the vid need to\n+\t be substracted vector_number_offset.  */\n       if (TARGET_REDUCED_REGS)\n \t{\n \t  if (nds32_isr_vectors[vector_id].save_reg == NDS32_SAVE_ALL)\n@@ -449,12 +449,12 @@ nds32_construct_isr_vectors_information (tree func_attrs,\n       nds32_isr_vectors[0].category = NDS32_ISR_RESET;\n \n       /* Prepare id_list and identify id value so that\n-         we can set total number of vectors.  */\n+\t we can set total number of vectors.  */\n       id_list = TREE_VALUE (reset);\n       id = TREE_VALUE (id_list);\n \n       /* The total vectors = interrupt + exception numbers + reset.\n-         There are 8 exception and 1 reset in nds32 architecture.  */\n+\t There are 8 exception and 1 reset in nds32 architecture.  */\n       nds32_isr_vectors[0].total_n_vectors = TREE_INT_CST_LOW (id) + 8 + 1;\n       strcpy (nds32_isr_vectors[0].func_name, func_name);\n "}, {"sha": "5888438ffd43fa03fa745d536858d862230a90be", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -453,33 +453,33 @@ nds32_output_32bit_load_s (rtx *operands, int byte)\n     {\n     case REG:\n       /* (mem (reg X))\n-         => access location by using register,\n-         use \"lbsi / lhsi\" */\n+\t => access location by using register,\n+\t use \"lbsi / lhsi\" */\n       snprintf (pattern, sizeof (pattern), \"l%csi\\t%%0, %%1\", size);\n       break;\n \n     case SYMBOL_REF:\n     case CONST:\n       /* (mem (symbol_ref X))\n-         (mem (const (...)))\n-         => access global variables,\n-         use \"lbsi.gp / lhsi.gp\" */\n+\t (mem (const (...)))\n+\t => access global variables,\n+\t use \"lbsi.gp / lhsi.gp\" */\n       operands[1] = XEXP (operands[1], 0);\n       snprintf (pattern, sizeof (pattern), \"l%csi.gp\\t%%0, [ + %%1]\", size);\n       break;\n \n     case POST_INC:\n       /* (mem (post_inc reg))\n-         => access location by using register which will be post increment,\n-         use \"lbsi.bi / lhsi.bi\" */\n+\t => access location by using register which will be post increment,\n+\t use \"lbsi.bi / lhsi.bi\" */\n       snprintf (pattern, sizeof (pattern),\n \t\t\"l%csi.bi\\t%%0, %%1, %d\", size, byte);\n       break;\n \n     case POST_DEC:\n       /* (mem (post_dec reg))\n-         => access location by using register which will be post decrement,\n-         use \"lbsi.bi / lhsi.bi\" */\n+\t => access location by using register which will be post decrement,\n+\t use \"lbsi.bi / lhsi.bi\" */\n       snprintf (pattern, sizeof (pattern),\n \t\t\"l%csi.bi\\t%%0, %%1, -%d\", size, byte);\n       break;\n@@ -585,8 +585,8 @@ nds32_output_stack_push (rtx par_rtx)\n       && (cfun->machine->va_args_size == 0))\n     {\n       /* For stack v3push:\n-           operands[0]: Re\n-           operands[1]: imm8u */\n+\t   operands[0]: Re\n+\t   operands[1]: imm8u */\n \n       /* This variable is to check if 'push25 Re,imm8u' is available.  */\n       int sp_adjust;\n@@ -595,7 +595,7 @@ nds32_output_stack_push (rtx par_rtx)\n       operands[0] = gen_rtx_REG (SImode, re_callee_saved);\n \n       /* Check if we can generate 'push25 Re,imm8u',\n-         otherwise, generate 'push25 Re,0'.  */\n+\t otherwise, generate 'push25 Re,0'.  */\n       sp_adjust = cfun->machine->local_size\n \t\t  + cfun->machine->out_args_size\n \t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n@@ -611,12 +611,12 @@ nds32_output_stack_push (rtx par_rtx)\n   else\n     {\n       /* For normal stack push multiple:\n-         operands[0]: Rb\n-         operands[1]: Re\n-         operands[2]: En4 */\n+\t operands[0]: Rb\n+\t operands[1]: Re\n+\t operands[2]: En4 */\n \n       /* This variable is used to check if we only need to generate En4 field.\n-         As long as Rb==Re=SP_REGNUM, we set this variable to 1.  */\n+\t As long as Rb==Re=SP_REGNUM, we set this variable to 1.  */\n       int push_en4_only_p = 0;\n \n       /* Set operands[0] and operands[1].  */\n@@ -678,8 +678,8 @@ nds32_output_stack_pop (rtx par_rtx ATTRIBUTE_UNUSED)\n       && (cfun->machine->va_args_size == 0))\n     {\n       /* For stack v3pop:\n-           operands[0]: Re\n-           operands[1]: imm8u */\n+\t   operands[0]: Re\n+\t   operands[1]: imm8u */\n \n       /* This variable is to check if 'pop25 Re,imm8u' is available.  */\n       int sp_adjust;\n@@ -688,12 +688,12 @@ nds32_output_stack_pop (rtx par_rtx ATTRIBUTE_UNUSED)\n       operands[0] = gen_rtx_REG (SImode, re_callee_saved);\n \n       /* Check if we can generate 'pop25 Re,imm8u',\n-         otherwise, generate 'pop25 Re,0'.\n-         We have to consider alloca issue as well.\n-         If the function does call alloca(), the stack pointer is not fixed.\n-         In that case, we cannot use 'pop25 Re,imm8u' directly.\n-         We have to caculate stack pointer from frame pointer\n-         and then use 'pop25 Re,0'.  */\n+\t otherwise, generate 'pop25 Re,0'.\n+\t We have to consider alloca issue as well.\n+\t If the function does call alloca(), the stack pointer is not fixed.\n+\t In that case, we cannot use 'pop25 Re,imm8u' directly.\n+\t We have to caculate stack pointer from frame pointer\n+\t and then use 'pop25 Re,0'.  */\n       sp_adjust = cfun->machine->local_size\n \t\t  + cfun->machine->out_args_size\n \t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n@@ -710,12 +710,12 @@ nds32_output_stack_pop (rtx par_rtx ATTRIBUTE_UNUSED)\n   else\n     {\n       /* For normal stack pop multiple:\n-         operands[0]: Rb\n-         operands[1]: Re\n-         operands[2]: En4 */\n+\t operands[0]: Rb\n+\t operands[1]: Re\n+\t operands[2]: En4 */\n \n       /* This variable is used to check if we only need to generate En4 field.\n-         As long as Rb==Re=SP_REGNUM, we set this variable to 1.  */\n+\t As long as Rb==Re=SP_REGNUM, we set this variable to 1.  */\n       int pop_en4_only_p = 0;\n \n       /* Set operands[0] and operands[1].  */"}, {"sha": "e72038e5b5b57c0ae75f793c4be6b2344a3aac35", "filename": "gcc/config/nds32/nds32-multiple.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -49,9 +49,9 @@\n      otherwise we have to FAIL this rtx generation:\n        1. The number of consecutive registers must be integer.\n        2. Maximum 4 or 8 registers for lmw.bi instruction\n-          (based on this nds32-multiple.md design).\n+\t  (based on this nds32-multiple.md design).\n        3. Minimum 2 registers for lmw.bi instruction\n-          (based on this nds32-multiple.md design).\n+\t  (based on this nds32-multiple.md design).\n        4. operands[0] must be register for sure.\n        5. operands[1] must be memory for sure.\n        6. Do not cross $r15 register because it is not allocatable.  */\n@@ -231,9 +231,9 @@\n      otherwise we have to FAIL this rtx generation:\n        1. The number of consecutive registers must be integer.\n        2. Maximum 4 or 8 registers for smw.bi instruction\n-          (based on this nds32-multiple.md design).\n+\t  (based on this nds32-multiple.md design).\n        3. Minimum 2 registers for smw.bi instruction\n-          (based on this nds32-multiple.md design).\n+\t  (based on this nds32-multiple.md design).\n        4. operands[0] must be memory for sure.\n        5. operands[1] must be register for sure.\n        6. Do not cross $r15 register because it is not allocatable.  */"}, {"sha": "cc8ae55f1175abb0547d9720ff5a5036efd10706", "filename": "gcc/config/nds32/nds32-predicates.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -175,47 +175,47 @@ nds32_valid_stack_push_pop_p (rtx op, bool push_p)\n     {\n       elt = XVECEXP (op, 0, index);\n       if (GET_CODE (elt) != SET)\n-        return false;\n+\treturn false;\n     }\n \n   /* For push operation, the parallel rtx looks like:\n      (parallel [(set (mem (plus (reg:SI SP_REGNUM) (const_int -32)))\n-                     (reg:SI Rb))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -28)))\n-                     (reg:SI Rb+1))\n-                ...\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -16)))\n-                     (reg:SI Re))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -12)))\n-                     (reg:SI FP_REGNUM))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -8)))\n-                     (reg:SI GP_REGNUM))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -4)))\n-                     (reg:SI LP_REGNUM))\n-                (set (reg:SI SP_REGNUM)\n-                     (plus (reg:SI SP_REGNUM) (const_int -32)))])\n+\t\t     (reg:SI Rb))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -28)))\n+\t\t     (reg:SI Rb+1))\n+\t\t...\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -16)))\n+\t\t     (reg:SI Re))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -12)))\n+\t\t     (reg:SI FP_REGNUM))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -8)))\n+\t\t     (reg:SI GP_REGNUM))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -4)))\n+\t\t     (reg:SI LP_REGNUM))\n+\t\t(set (reg:SI SP_REGNUM)\n+\t\t     (plus (reg:SI SP_REGNUM) (const_int -32)))])\n \n      For pop operation, the parallel rtx looks like:\n      (parallel [(set (reg:SI Rb)\n-                     (mem (reg:SI SP_REGNUM)))\n-                (set (reg:SI Rb+1)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 4))))\n-                ...\n-                (set (reg:SI Re)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 16))))\n-                (set (reg:SI FP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 20))))\n-                (set (reg:SI GP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 24))))\n-                (set (reg:SI LP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 28))))\n-                (set (reg:SI SP_REGNUM)\n-                     (plus (reg:SI SP_REGNUM) (const_int 32)))]) */\n+\t\t     (mem (reg:SI SP_REGNUM)))\n+\t\t(set (reg:SI Rb+1)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 4))))\n+\t\t...\n+\t\t(set (reg:SI Re)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 16))))\n+\t\t(set (reg:SI FP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 20))))\n+\t\t(set (reg:SI GP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 24))))\n+\t\t(set (reg:SI LP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 28))))\n+\t\t(set (reg:SI SP_REGNUM)\n+\t\t     (plus (reg:SI SP_REGNUM) (const_int 32)))]) */\n \n   /* 1. Consecutive registers push/pop operations.\n-        We need to calculate how many registers should be consecutive.\n-        The $sp adjustment rtx, $fp push rtx, $gp push rtx,\n-        and $lp push rtx are excluded.  */\n+\tWe need to calculate how many registers should be consecutive.\n+\tThe $sp adjustment rtx, $fp push rtx, $gp push rtx,\n+\tand $lp push rtx are excluded.  */\n \n   /* Detect whether we have $fp, $gp, or $lp in the parallel rtx.  */\n   save_fp = reg_mentioned_p (gen_rtx_REG (SImode, FP_REGNUM), op);\n@@ -239,19 +239,19 @@ nds32_valid_stack_push_pop_p (rtx op, bool push_p)\n       first_regno = REGNO (elt_reg);\n \n       /* The 'push' operation is a kind of store operation.\n-         The 'pop' operation is a kind of load operation.\n-         Pass corresponding false/true as second argument (bool load_p).\n-         The par_index is supposed to start with index 0.  */\n+\t The 'pop' operation is a kind of load operation.\n+\t Pass corresponding false/true as second argument (bool load_p).\n+\t The par_index is supposed to start with index 0.  */\n       if (!nds32_consecutive_registers_load_store_p (op,\n \t\t\t\t\t\t     !push_p ? true : false,\n \t\t\t\t\t\t     0,\n \t\t\t\t\t\t     first_regno,\n \t\t\t\t\t\t     rest_count))\n-        return false;\n+\treturn false;\n     }\n \n   /* 2. Valid $fp/$gp/$lp push/pop operations.\n-        Remember to set start index for checking them.  */\n+\tRemember to set start index for checking them.  */\n \n   /* The rest_count is the start index for checking $fp/$gp/$lp.  */\n   index = rest_count;\n@@ -270,9 +270,9 @@ nds32_valid_stack_push_pop_p (rtx op, bool push_p)\n       index++;\n \n       if (GET_CODE (elt_mem) != MEM\n-          || GET_CODE (elt_reg) != REG\n-          || REGNO (elt_reg) != FP_REGNUM)\n-        return false;\n+\t  || GET_CODE (elt_reg) != REG\n+\t  || REGNO (elt_reg) != FP_REGNUM)\n+\treturn false;\n     }\n   if (save_gp)\n     {\n@@ -282,9 +282,9 @@ nds32_valid_stack_push_pop_p (rtx op, bool push_p)\n       index++;\n \n       if (GET_CODE (elt_mem) != MEM\n-          || GET_CODE (elt_reg) != REG\n-          || REGNO (elt_reg) != GP_REGNUM)\n-        return false;\n+\t  || GET_CODE (elt_reg) != REG\n+\t  || REGNO (elt_reg) != GP_REGNUM)\n+\treturn false;\n     }\n   if (save_lp)\n     {\n@@ -294,16 +294,16 @@ nds32_valid_stack_push_pop_p (rtx op, bool push_p)\n       index++;\n \n       if (GET_CODE (elt_mem) != MEM\n-          || GET_CODE (elt_reg) != REG\n-          || REGNO (elt_reg) != LP_REGNUM)\n-        return false;\n+\t  || GET_CODE (elt_reg) != REG\n+\t  || REGNO (elt_reg) != LP_REGNUM)\n+\treturn false;\n     }\n \n   /* 3. The last element must be stack adjustment rtx.\n-        Its form of rtx should be:\n-          (set (reg:SI SP_REGNUM)\n-               (plus (reg:SI SP_REGNUM) (const_int X)))\n-        The X could be positive or negative value.  */\n+\tIts form of rtx should be:\n+\t  (set (reg:SI SP_REGNUM)\n+\t       (plus (reg:SI SP_REGNUM) (const_int X)))\n+\tThe X could be positive or negative value.  */\n \n   /* Pick up the last element.  */\n   elt = XVECEXP (op, 0, total_count - 1);"}, {"sha": "65095ffaff1adec084b6beb9ef0a394c4103010d", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 244, "deletions": 245, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -83,7 +83,7 @@ static const char * const nds32_intrinsic_register_names[] =\n static const struct attribute_spec nds32_attribute_table[] =\n {\n   /* Syntax: { name, min_len, max_len, decl_required, type_required,\n-               function_type_required, handler, affects_type_identity } */\n+\t       function_type_required, handler, affects_type_identity } */\n \n   /* The interrupt vid: [0-63]+ (actual vector number starts from 9 to 72).  */\n   { \"interrupt\",    1, 64, false, false, false, NULL, false },\n@@ -152,11 +152,11 @@ nds32_compute_stack_frame (void)\n   if (cfun->machine->va_args_size != 0)\n     {\n       cfun->machine->va_args_first_regno\n-        = NDS32_GPR_ARG_FIRST_REGNUM\n-          + NDS32_MAX_GPR_REGS_FOR_ARGS\n-          - (crtl->args.pretend_args_size / UNITS_PER_WORD);\n+\t= NDS32_GPR_ARG_FIRST_REGNUM\n+\t  + NDS32_MAX_GPR_REGS_FOR_ARGS\n+\t  - (crtl->args.pretend_args_size / UNITS_PER_WORD);\n       cfun->machine->va_args_last_regno\n-        = NDS32_GPR_ARG_FIRST_REGNUM + NDS32_MAX_GPR_REGS_FOR_ARGS - 1;\n+\t= NDS32_GPR_ARG_FIRST_REGNUM + NDS32_MAX_GPR_REGS_FOR_ARGS - 1;\n     }\n   else\n     {\n@@ -223,13 +223,13 @@ nds32_compute_stack_frame (void)\n      Or, if all the following conditions succeed,\n      we can set this function 'naked_p' as well:\n        condition 1: first_regno == last_regno == SP_REGNUM,\n-                    which means we do not have to save\n-                    any callee-saved registers.\n+\t\t    which means we do not have to save\n+\t\t    any callee-saved registers.\n        condition 2: Both $lp and $fp are NOT live in this function,\n-                    which means we do not need to save them and there\n-                    is no outgoing size.\n+\t\t    which means we do not need to save them and there\n+\t\t    is no outgoing size.\n        condition 3: There is no local_size, which means\n-                    we do not need to adjust $sp.  */\n+\t\t    we do not need to adjust $sp.  */\n   if (lookup_attribute (\"naked\", DECL_ATTRIBUTES (current_function_decl))\n       || (cfun->machine->callee_saved_first_gpr_regno == SP_REGNUM\n \t  && cfun->machine->callee_saved_last_gpr_regno == SP_REGNUM\n@@ -238,21 +238,21 @@ nds32_compute_stack_frame (void)\n \t  && cfun->machine->local_size == 0))\n     {\n       /* Set this function 'naked_p' and other functions can check this flag.\n-         Note that in nds32 port, the 'naked_p = 1' JUST means there is no\n-         callee-saved, local size, and outgoing size.\n-         The varargs space and ret instruction may still present in\n-         the prologue/epilogue expanding.  */\n+\t Note that in nds32 port, the 'naked_p = 1' JUST means there is no\n+\t callee-saved, local size, and outgoing size.\n+\t The varargs space and ret instruction may still present in\n+\t the prologue/epilogue expanding.  */\n       cfun->machine->naked_p = 1;\n \n       /* No need to save $fp, $gp, and $lp.\n-         We should set these value to be zero\n-         so that nds32_initial_elimination_offset() can work properly.  */\n+\t We should set these value to be zero\n+\t so that nds32_initial_elimination_offset() can work properly.  */\n       cfun->machine->fp_size = 0;\n       cfun->machine->gp_size = 0;\n       cfun->machine->lp_size = 0;\n \n       /* If stack usage computation is required,\n-         we need to provide the static stack size.  */\n+\t we need to provide the static stack size.  */\n       if (flag_stack_usage_info)\n \tcurrent_function_static_stack_size = 0;\n \n@@ -272,11 +272,11 @@ nds32_compute_stack_frame (void)\n       && (cfun->machine->va_args_size == 0))\n     {\n       /* Recompute:\n-           cfun->machine->fp_size\n-           cfun->machine->gp_size\n-           cfun->machine->lp_size\n-           cfun->machine->callee_saved_regs_first_regno\n-           cfun->machine->callee_saved_regs_last_regno */\n+\t   cfun->machine->fp_size\n+\t   cfun->machine->gp_size\n+\t   cfun->machine->lp_size\n+\t   cfun->machine->callee_saved_first_gpr_regno\n+\t   cfun->machine->callee_saved_last_gpr_regno */\n \n       /* For v3push instructions, $fp, $gp, and $lp are always saved.  */\n       cfun->machine->fp_size = 4;\n@@ -319,11 +319,11 @@ nds32_compute_stack_frame (void)\n \t}\n     }\n \n-  /* We have correctly set callee_saved_regs_first_regno\n-     and callee_saved_regs_last_regno.\n-     Initially, the callee_saved_regs_size is supposed to be 0.\n-     As long as callee_saved_regs_last_regno is not SP_REGNUM,\n-     we can update callee_saved_regs_size with new size.  */\n+  /* We have correctly set callee_saved_first_gpr_regno\n+     and callee_saved_last_gpr_regno.\n+     Initially, the callee_saved_gpr_regs_size is supposed to be 0.\n+     As long as callee_saved_last_gpr_regno is not SP_REGNUM,\n+     we can update callee_saved_gpr_regs_size with new size.  */\n   if (cfun->machine->callee_saved_last_gpr_regno != SP_REGNUM)\n     {\n       /* Compute pushed size of callee-saved registers.  */\n@@ -334,9 +334,9 @@ nds32_compute_stack_frame (void)\n     }\n \n   /* Important: We need to make sure that\n-                (fp_size + gp_size + lp_size + callee_saved_regs_size)\n-                is 8-byte alignment.\n-                If it is not, calculate the padding bytes.  */\n+\t\t(fp_size + gp_size + lp_size + callee_saved_gpr_regs_size)\n+\t\tis 8-byte alignment.\n+\t\tIf it is not, calculate the padding bytes.  */\n   block_size = cfun->machine->fp_size\n \t       + cfun->machine->gp_size\n \t       + cfun->machine->lp_size\n@@ -384,20 +384,20 @@ nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n      necessary information for data analysis,\n      so we create a parallel rtx like this:\n      (parallel [(set (mem (plus (reg:SI SP_REGNUM) (const_int -32)))\n-                     (reg:SI Rb))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -28)))\n-                     (reg:SI Rb+1))\n-                ...\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -16)))\n-                     (reg:SI Re))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -12)))\n-                     (reg:SI FP_REGNUM))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -8)))\n-                     (reg:SI GP_REGNUM))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -4)))\n-                     (reg:SI LP_REGNUM))\n-                (set (reg:SI SP_REGNUM)\n-                     (plus (reg:SI SP_REGNUM) (const_int -32)))]) */\n+\t\t     (reg:SI Rb))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -28)))\n+\t\t     (reg:SI Rb+1))\n+\t\t...\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -16)))\n+\t\t     (reg:SI Re))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -12)))\n+\t\t     (reg:SI FP_REGNUM))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -8)))\n+\t\t     (reg:SI GP_REGNUM))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -4)))\n+\t\t     (reg:SI LP_REGNUM))\n+\t\t(set (reg:SI SP_REGNUM)\n+\t\t     (plus (reg:SI SP_REGNUM) (const_int -32)))]) */\n \n   /* Determine whether we need to save $fp, $gp, or $lp.  */\n   save_fp = INTVAL (En4) & 0x8;\n@@ -431,7 +431,7 @@ nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4, bool vaarg_p)\n   for (regno = REGNO (Rb); regno <= (int) REGNO (Re); regno++)\n     {\n       /* Rb and Re may be SP_REGNUM.\n-         We need to break this loop immediately.  */\n+\t We need to break this loop immediately.  */\n       if (regno == SP_REGNUM)\n \tbreak;\n \n@@ -537,20 +537,20 @@ nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n      necessary information for data analysis,\n      so we create a parallel rtx like this:\n      (parallel [(set (reg:SI Rb)\n-                     (mem (reg:SI SP_REGNUM)))\n-                (set (reg:SI Rb+1)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 4))))\n-                ...\n-                (set (reg:SI Re)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 16))))\n-                (set (reg:SI FP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 20))))\n-                (set (reg:SI GP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 24))))\n-                (set (reg:SI LP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 28))))\n-                (set (reg:SI SP_REGNUM)\n-                     (plus (reg:SI SP_REGNUM) (const_int 32)))]) */\n+\t\t     (mem (reg:SI SP_REGNUM)))\n+\t\t(set (reg:SI Rb+1)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 4))))\n+\t\t...\n+\t\t(set (reg:SI Re)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 16))))\n+\t\t(set (reg:SI FP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 20))))\n+\t\t(set (reg:SI GP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 24))))\n+\t\t(set (reg:SI LP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 28))))\n+\t\t(set (reg:SI SP_REGNUM)\n+\t\t     (plus (reg:SI SP_REGNUM) (const_int 32)))]) */\n \n   /* Determine whether we need to restore $fp, $gp, or $lp.  */\n   save_fp = INTVAL (En4) & 0x8;\n@@ -584,7 +584,7 @@ nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n   for (regno = REGNO (Rb); regno <= (int) REGNO (Re); regno++)\n     {\n       /* Rb and Re may be SP_REGNUM.\n-         We need to break this loop immediately.  */\n+\t We need to break this loop immediately.  */\n       if (regno == SP_REGNUM)\n \tbreak;\n \n@@ -693,20 +693,20 @@ nds32_emit_stack_v3push (rtx Rb,\n      necessary information for data analysis,\n      so we create a parallel rtx like this:\n      (parallel [(set (mem (plus (reg:SI SP_REGNUM) (const_int -32)))\n-                     (reg:SI Rb))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -28)))\n-                     (reg:SI Rb+1))\n-                ...\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -16)))\n-                     (reg:SI Re))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -12)))\n-                     (reg:SI FP_REGNUM))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -8)))\n-                     (reg:SI GP_REGNUM))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -4)))\n-                     (reg:SI LP_REGNUM))\n-                (set (reg:SI SP_REGNUM)\n-                     (plus (reg:SI SP_REGNUM) (const_int -32-imm8u)))]) */\n+\t\t     (reg:SI Rb))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -28)))\n+\t\t     (reg:SI Rb+1))\n+\t\t...\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -16)))\n+\t\t     (reg:SI Re))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -12)))\n+\t\t     (reg:SI FP_REGNUM))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -8)))\n+\t\t     (reg:SI GP_REGNUM))\n+\t\t(set (mem (plus (reg:SI SP_REGNUM) (const_int -4)))\n+\t\t     (reg:SI LP_REGNUM))\n+\t\t(set (reg:SI SP_REGNUM)\n+\t\t     (plus (reg:SI SP_REGNUM) (const_int -32-imm8u)))]) */\n \n   /* Calculate the number of registers that will be pushed.\n      Since $fp, $gp, and $lp is always pushed with v3push instruction,\n@@ -818,20 +818,20 @@ nds32_emit_stack_v3pop (rtx Rb,\n      necessary information for data analysis,\n      so we create a parallel rtx like this:\n      (parallel [(set (reg:SI Rb)\n-                     (mem (reg:SI SP_REGNUM)))\n-                (set (reg:SI Rb+1)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 4))))\n-                ...\n-                (set (reg:SI Re)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 16))))\n-                (set (reg:SI FP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 20))))\n-                (set (reg:SI GP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 24))))\n-                (set (reg:SI LP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 28))))\n-                (set (reg:SI SP_REGNUM)\n-                     (plus (reg:SI SP_REGNUM) (const_int 32+imm8u)))]) */\n+\t\t     (mem (reg:SI SP_REGNUM)))\n+\t\t(set (reg:SI Rb+1)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 4))))\n+\t\t...\n+\t\t(set (reg:SI Re)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 16))))\n+\t\t(set (reg:SI FP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 20))))\n+\t\t(set (reg:SI GP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 24))))\n+\t\t(set (reg:SI LP_REGNUM)\n+\t\t     (mem (plus (reg:SI SP_REGNUM) (const_int 28))))\n+\t\t(set (reg:SI SP_REGNUM)\n+\t\t     (plus (reg:SI SP_REGNUM) (const_int 32+imm8u)))]) */\n \n   /* Calculate the number of registers that will be poped.\n      Since $fp, $gp, and $lp is always poped with v3pop instruction,\n@@ -950,14 +950,14 @@ nds32_force_addi_stack_int (int full_value)\n   if (!satisfies_constraint_Is15 (GEN_INT (full_value)))\n     {\n       /* The value is not able to fit in single addi instruction.\n-         Create more instructions of moving value into a register\n-         and then add stack pointer with it.  */\n+\t Create more instructions of moving value into a register\n+\t and then add stack pointer with it.  */\n \n       /* $r15 is going to be temporary register to hold the value.  */\n       tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n \n       /* Create one more instruction to move value\n-         into the temporary register.  */\n+\t into the temporary register.  */\n       emit_move_insn (tmp_reg, GEN_INT (full_value));\n \n       /* Create new 'add' rtx.  */\n@@ -1038,7 +1038,7 @@ nds32_naked_function_p (tree func)\n \n    STRICT : true\n      => We are in reload pass or after reload pass.\n-        The register number should be strictly limited in general registers.\n+\tThe register number should be strictly limited in general registers.\n \n    STRICT : false\n      => Before reload pass, we are free to use any register number.  */\n@@ -1061,7 +1061,7 @@ nds32_address_register_rtx_p (rtx x, bool strict)\n /* Function that check if 'INDEX' is valid to be a index rtx for address.\n \n    OUTER_MODE : Machine mode of outer address rtx.\n-        INDEX : Check if this rtx is valid to be a index for address.\n+\tINDEX : Check if this rtx is valid to be a index for address.\n        STRICT : If it is true, we are in reload pass or after reload pass.  */\n static bool\n nds32_legitimate_index_p (machine_mode outer_mode,\n@@ -1077,7 +1077,7 @@ nds32_legitimate_index_p (machine_mode outer_mode,\n     case REG:\n       regno = REGNO (index);\n       /* If we are in reload pass or after reload pass,\n-         we need to limit it to general register.  */\n+\t we need to limit it to general register.  */\n       if (strict)\n \treturn REGNO_OK_FOR_INDEX_P (regno);\n       else\n@@ -1225,8 +1225,8 @@ nds32_register_priority (int hard_regno)\n        2. return address\n        3. callee-saved registers\n        4. <padding bytes> (we will calculte in nds32_compute_stack_frame()\n-                           and save it at\n-                           cfun->machine->callee_saved_area_padding_bytes)\n+\t\t\t   and save it at\n+\t\t\t   cfun->machine->callee_saved_area_padding_bytes)\n \n      [Block B]\n        1. local variables\n@@ -1244,29 +1244,29 @@ nds32_register_priority (int hard_regno)\n    By applying the basic frame/stack/argument pointers concept,\n    the layout of a stack frame shoule be like this:\n \n-                            |    |\n+\t\t\t    |    |\n        old stack pointer ->  ----\n-                            |    | \\\n-                            |    |   saved arguments for\n-                            |    |   vararg functions\n-                            |    | /\n+\t\t\t    |    | \\\n+\t\t\t    |    |   saved arguments for\n+\t\t\t    |    |   vararg functions\n+\t\t\t    |    | /\n       hard frame pointer ->   --\n       & argument pointer    |    | \\\n-                            |    |   previous hardware frame pointer\n-                            |    |   return address\n-                            |    |   callee-saved registers\n-                            |    | /\n-           frame pointer ->   --\n-                            |    | \\\n-                            |    |   local variables\n-                            |    |   and incoming arguments\n-                            |    | /\n-                              --\n-                            |    | \\\n-                            |    |   outgoing\n-                            |    |   arguments\n-                            |    | /\n-           stack pointer ->  ----\n+\t\t\t    |    |   previous hardware frame pointer\n+\t\t\t    |    |   return address\n+\t\t\t    |    |   callee-saved registers\n+\t\t\t    |    | /\n+\t   frame pointer ->   --\n+\t\t\t    |    | \\\n+\t\t\t    |    |   local variables\n+\t\t\t    |    |   and incoming arguments\n+\t\t\t    |    | /\n+\t\t\t      --\n+\t\t\t    |    | \\\n+\t\t\t    |    |   outgoing\n+\t\t\t    |    |   arguments\n+\t\t\t    |    | /\n+\t   stack pointer ->  ----\n \n   $SFP and $AP are used to represent frame pointer and arguments pointer,\n   which will be both eliminated as hard frame pointer.  */\n@@ -1309,7 +1309,7 @@ nds32_function_arg (cumulative_args_t ca, machine_mode mode,\n   if (!named)\n     {\n       /* If we are under hard float abi, we have arguments passed on the\n-         stack and all situation can be handled by GCC itself.  */\n+\t stack and all situation can be handled by GCC itself.  */\n       if (TARGET_HARD_FLOAT)\n \treturn NULL_RTX;\n \n@@ -1323,7 +1323,7 @@ nds32_function_arg (cumulative_args_t ca, machine_mode mode,\n \t}\n \n       /* No register available, return NULL_RTX.\n-         The compiler will use stack to pass argument instead.  */\n+\t The compiler will use stack to pass argument instead.  */\n       return NULL_RTX;\n     }\n \n@@ -1338,8 +1338,8 @@ nds32_function_arg (cumulative_args_t ca, machine_mode mode,\n   else\n     {\n       /* For !TARGET_HARD_FLOAT calling convention, we always use GPR to pass\n-         argument.  Since we allow to pass argument partially in registers,\n-         we can just return it if there are still registers available.  */\n+\t argument.  Since we allow to pass argument partially in registers,\n+\t we can just return it if there are still registers available.  */\n       if (NDS32_ARG_PARTIAL_IN_GPR_REG_P (cum->gpr_offset, mode, type))\n \t{\n \t  /* Pick up the next available register number.  */\n@@ -1403,7 +1403,7 @@ nds32_arg_partial_bytes (cumulative_args_t ca, machine_mode mode,\n   remaining_reg_count\n     = NDS32_MAX_GPR_REGS_FOR_ARGS\n       - (NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type)\n-         - NDS32_GPR_ARG_FIRST_REGNUM);\n+\t - NDS32_GPR_ARG_FIRST_REGNUM);\n \n   /* Note that we have to return the nubmer of bytes, not registers count.  */\n   if (needed_reg_count > remaining_reg_count)\n@@ -1445,9 +1445,9 @@ nds32_function_arg_advance (cumulative_args_t ca, machine_mode mode,\n   else\n     {\n       /* If this nameless argument is NOT under TARGET_HARD_FLOAT,\n-         we can advance next register as well so that caller is\n-         able to pass arguments in registers and callee must be\n-         in charge of pushing all of them into stack.  */\n+\t we can advance next register as well so that caller is\n+\t able to pass arguments in registers and callee must be\n+\t in charge of pushing all of them into stack.  */\n       if (!TARGET_HARD_FLOAT)\n \t{\n \t  cum->gpr_offset\n@@ -1672,8 +1672,8 @@ nds32_asm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n static bool\n nds32_warn_func_return (tree decl)\n {\n-/* Naked functions are implemented entirely in assembly, including the\n-   return sequence, so suppress warnings about this.  */\n+  /* Naked functions are implemented entirely in assembly, including the\n+     return sequence, so suppress warnings about this.  */\n   return !nds32_naked_function_p (decl);\n }\n \n@@ -1796,7 +1796,7 @@ nds32_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n     sorry (\"a nested function is not supported for reduced registers\");\n \n   /* STEP 1: Copy trampoline code template into stack,\n-             fill up essential data into stack.  */\n+\t     fill up essential data into stack.  */\n \n   /* Extract nested function address rtx.  */\n   fnaddr = XEXP (DECL_RTL (fndecl), 0);\n@@ -1832,8 +1832,8 @@ nds32_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n       && (tramp_align_in_bytes % nds32_cache_block_size) == 0)\n     {\n       /* Under this condition, the starting address of trampoline\n-         must be aligned to the starting address of each cache block\n-         and we do not have to worry about cross-boundary issue.  */\n+\t must be aligned to the starting address of each cache block\n+\t and we do not have to worry about cross-boundary issue.  */\n       for (i = 0;\n \t   i < (TRAMPOLINE_SIZE + nds32_cache_block_size - 1)\n \t       / nds32_cache_block_size;\n@@ -1848,10 +1848,10 @@ nds32_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   else if (TRAMPOLINE_SIZE > nds32_cache_block_size)\n     {\n       /* The starting address of trampoline code\n-         may not be aligned to the cache block,\n-         so the trampoline code may be across two cache block.\n-         We need to sync the last element, which is 4-byte size,\n-         of trampoline template.  */\n+\t may not be aligned to the cache block,\n+\t so the trampoline code may be across two cache block.\n+\t We need to sync the last element, which is 4-byte size,\n+\t of trampoline template.  */\n       for (i = 0;\n \t   i < (TRAMPOLINE_SIZE + nds32_cache_block_size - 1)\n \t       / nds32_cache_block_size;\n@@ -1872,16 +1872,16 @@ nds32_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   else\n     {\n       /* This is the simplest case.\n-         Because TRAMPOLINE_SIZE is less than or\n-         equal to nds32_cache_block_size,\n-         we can just sync start address and\n-         the last element of trampoline code.  */\n+\t Because TRAMPOLINE_SIZE is less than or\n+\t equal to nds32_cache_block_size,\n+\t we can just sync start address and\n+\t the last element of trampoline code.  */\n \n       /* Sync starting address of tampoline code.  */\n       emit_move_insn (tmp_reg, sync_cache_addr);\n       emit_insn (isync_insn);\n       /* Sync the last element, which is 4-byte size,\n-         of trampoline template.  */\n+\t of trampoline template.  */\n       emit_move_insn (tmp_reg,\n \t\t      plus_constant (Pmode, sync_cache_addr,\n \t\t\t\t     TRAMPOLINE_SIZE - 4));\n@@ -1901,7 +1901,7 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   /* For (mem:DI addr) or (mem:DF addr) case,\n      we only allow 'addr' to be [reg], [symbol_ref],\n-                                [const], or [reg + const_int] pattern.  */\n+\t\t\t\t[const], or [reg + const_int] pattern.  */\n   if (mode == DImode || mode == DFmode)\n     {\n       /* Allow [Reg + const_int] addressing mode.  */\n@@ -1911,7 +1911,6 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \t      && nds32_legitimate_index_p (mode, XEXP (x, 1), strict)\n \t      && CONST_INT_P (XEXP (x, 1)))\n \t    return true;\n-\n \t  else if (nds32_address_register_rtx_p (XEXP (x, 1), strict)\n \t\t   && nds32_legitimate_index_p (mode, XEXP (x, 0), strict)\n \t\t   && CONST_INT_P (XEXP (x, 0)))\n@@ -1935,15 +1934,15 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n     case SYMBOL_REF:\n       /* (mem (symbol_ref A)) => [symbol_ref] */\n       /* If -mcmodel=large, the 'symbol_ref' is not a valid address\n-         during or after LRA/reload phase.  */\n+\t during or after LRA/reload phase.  */\n       if (TARGET_CMODEL_LARGE\n \t  && (reload_completed\n \t      || reload_in_progress\n \t      || lra_in_progress))\n \treturn false;\n       /* If -mcmodel=medium and the symbol references to rodata section,\n-         the 'symbol_ref' is not a valid address during or after\n-         LRA/reload phase.  */\n+\t the 'symbol_ref' is not a valid address during or after\n+\t LRA/reload phase.  */\n       if (TARGET_CMODEL_MEDIUM\n \t  && NDS32_SYMBOL_REF_RODATA_P (x)\n \t  && (reload_completed\n@@ -1955,7 +1954,7 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \n     case CONST:\n       /* (mem (const (...)))\n-         => [ + const_addr ], where const_addr = symbol_ref + const_int */\n+\t => [ + const_addr ], where const_addr = symbol_ref + const_int */\n       if (GET_CODE (XEXP (x, 0)) == PLUS)\n \t{\n \t  rtx plus_op = XEXP (x, 0);\n@@ -1966,17 +1965,17 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \t  if (GET_CODE (op0) == SYMBOL_REF && CONST_INT_P (op1))\n \t    {\n \t      /* Now we see the [ + const_addr ] pattern, but we need\n-\t         some further checking.  */\n+\t\t some further checking.  */\n \t      /* If -mcmodel=large, the 'const_addr' is not a valid address\n-\t         during or after LRA/reload phase.  */\n+\t\t during or after LRA/reload phase.  */\n \t      if (TARGET_CMODEL_LARGE\n \t\t  && (reload_completed\n \t\t      || reload_in_progress\n \t\t      || lra_in_progress))\n \t\treturn false;\n \t      /* If -mcmodel=medium and the symbol references to rodata section,\n-\t         the 'const_addr' is not a valid address during or after\n-\t         LRA/reload phase.  */\n+\t\t the 'const_addr' is not a valid address during or after\n+\t\t LRA/reload phase.  */\n \t      if (TARGET_CMODEL_MEDIUM\n \t\t  && NDS32_SYMBOL_REF_RODATA_P (op0)\n \t\t  && (reload_completed\n@@ -1994,9 +1993,9 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \n     case POST_MODIFY:\n       /* (mem (post_modify (reg) (plus (reg) (reg))))\n-         => [Ra], Rb */\n+\t => [Ra], Rb */\n       /* (mem (post_modify (reg) (plus (reg) (const_int))))\n-         => [Ra], const_int */\n+\t => [Ra], const_int */\n       if (GET_CODE (XEXP (x, 0)) == REG\n \t  && GET_CODE (XEXP (x, 1)) == PLUS)\n \t{\n@@ -2019,19 +2018,19 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n       /* (mem (post_inc reg)) => [Ra], 1/2/4 */\n       /* (mem (post_dec reg)) => [Ra], -1/-2/-4 */\n       /* The 1/2/4 or -1/-2/-4 have been displayed in nds32.md.\n-         We only need to deal with register Ra.  */\n+\t We only need to deal with register Ra.  */\n       if (nds32_address_register_rtx_p (XEXP (x, 0), strict))\n \treturn true;\n       else\n \treturn false;\n \n     case PLUS:\n       /* (mem (plus reg const_int))\n-         => [Ra + imm] */\n+\t => [Ra + imm] */\n       /* (mem (plus reg reg))\n-         => [Ra + Rb] */\n+\t => [Ra + Rb] */\n       /* (mem (plus (mult reg const_int) reg))\n-         => [Ra + Rb << sv] */\n+\t => [Ra + Rb << sv] */\n       if (nds32_address_register_rtx_p (XEXP (x, 0), strict)\n \t  && nds32_legitimate_index_p (mode, XEXP (x, 1), strict))\n \treturn true;\n@@ -2258,11 +2257,11 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n       op_value = INTVAL (x);\n \n       /* According to the Andes architecture,\n-         the system/user register index range is 0 ~ 1023.\n-         In order to avoid conflict between user-specified-integer value\n-         and enum-specified-register value,\n-         the 'enum nds32_intrinsic_registers' value\n-         in nds32_intrinsic.h starts from 1024.  */\n+\t the system/user register index range is 0 ~ 1023.\n+\t In order to avoid conflict between user-specified-integer value\n+\t and enum-specified-register value,\n+\t the 'enum nds32_intrinsic_registers' value\n+\t in nds32_intrinsic.h starts from 1024.  */\n       if (op_value < 1024 && op_value >= 0)\n \t{\n \t  /* If user gives integer value directly (0~1023),\n@@ -2302,7 +2301,7 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n \n     case REG:\n       /* Forbid using static chain register ($r16)\n-         on reduced-set registers configuration.  */\n+\t on reduced-set registers configuration.  */\n       if (TARGET_REDUCED_REGS\n \t  && REGNO (x) == STATIC_CHAIN_REGNUM)\n \tsorry (\"a nested function is not supported for reduced registers\");\n@@ -2323,8 +2322,8 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n \n     default:\n       /* Generally, output_addr_const () is able to handle most cases.\n-         We want to see what CODE could appear,\n-         so we use gcc_unreachable() to stop it.  */\n+\t We want to see what CODE could appear,\n+\t so we use gcc_unreachable() to stop it.  */\n       debug_rtx (x);\n       gcc_unreachable ();\n       break;\n@@ -2349,7 +2348,7 @@ nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n \n     case REG:\n       /* Forbid using static chain register ($r16)\n-         on reduced-set registers configuration.  */\n+\t on reduced-set registers configuration.  */\n       if (TARGET_REDUCED_REGS\n \t  && REGNO (x) == STATIC_CHAIN_REGNUM)\n \tsorry (\"a nested function is not supported for reduced registers\");\n@@ -2363,13 +2362,13 @@ nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n       op1 = XEXP (x, 1);\n \n       /* Checking op0, forbid using static chain register ($r16)\n-         on reduced-set registers configuration.  */\n+\t on reduced-set registers configuration.  */\n       if (TARGET_REDUCED_REGS\n \t  && REG_P (op0)\n \t  && REGNO (op0) == STATIC_CHAIN_REGNUM)\n \tsorry (\"a nested function is not supported for reduced registers\");\n       /* Checking op1, forbid using static chain register ($r16)\n-         on reduced-set registers configuration.  */\n+\t on reduced-set registers configuration.  */\n       if (TARGET_REDUCED_REGS\n \t  && REG_P (op1)\n \t  && REGNO (op1) == STATIC_CHAIN_REGNUM)\n@@ -2392,8 +2391,8 @@ nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n \t  /* [Ra + Rb << sv]\n \t     From observation, the pattern looks like:\n \t     (plus:SI (mult:SI (reg:SI 58)\n-\t                       (const_int 4 [0x4]))\n-\t              (reg/f:SI 57)) */\n+\t\t\t       (const_int 4 [0x4]))\n+\t\t      (reg/f:SI 57)) */\n \t  int sv;\n \n \t  /* We need to set sv to output shift value.  */\n@@ -2422,20 +2421,20 @@ nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n \n     case POST_MODIFY:\n       /* (post_modify (regA) (plus (regA) (regB)))\n-         (post_modify (regA) (plus (regA) (const_int)))\n-         We would like to extract\n-         regA and regB (or const_int) from plus rtx.  */\n+\t (post_modify (regA) (plus (regA) (const_int)))\n+\t We would like to extract\n+\t regA and regB (or const_int) from plus rtx.  */\n       op0 = XEXP (XEXP (x, 1), 0);\n       op1 = XEXP (XEXP (x, 1), 1);\n \n       /* Checking op0, forbid using static chain register ($r16)\n-         on reduced-set registers configuration.  */\n+\t on reduced-set registers configuration.  */\n       if (TARGET_REDUCED_REGS\n \t  && REG_P (op0)\n \t  && REGNO (op0) == STATIC_CHAIN_REGNUM)\n \tsorry (\"a nested function is not supported for reduced registers\");\n       /* Checking op1, forbid using static chain register ($r16)\n-         on reduced-set registers configuration.  */\n+\t on reduced-set registers configuration.  */\n       if (TARGET_REDUCED_REGS\n \t  && REG_P (op1)\n \t  && REGNO (op1) == STATIC_CHAIN_REGNUM)\n@@ -2467,7 +2466,7 @@ nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n       op0 = XEXP (x, 0);\n \n       /* Checking op0, forbid using static chain register ($r16)\n-         on reduced-set registers configuration.  */\n+\t on reduced-set registers configuration.  */\n       if (TARGET_REDUCED_REGS\n \t  && REG_P (op0)\n \t  && REGNO (op0) == STATIC_CHAIN_REGNUM)\n@@ -2491,8 +2490,8 @@ nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n \n     default :\n       /* Generally, output_addr_const () is able to handle most cases.\n-         We want to see what CODE could appear,\n-         so we use gcc_unreachable() to stop it.  */\n+\t We want to see what CODE could appear,\n+\t so we use gcc_unreachable() to stop it.  */\n       debug_rtx (x);\n       gcc_unreachable ();\n       break;\n@@ -2544,10 +2543,10 @@ nds32_insert_attributes (tree decl, tree *attributes)\n       nds32_check_isr_attrs_conflict (decl, func_attrs);\n \n       /* Now we are starting to check valid id value\n-         for interrupt/exception/reset.\n-         Note that we ONLY check its validity here.\n-         To construct isr vector information, it is still performed\n-         by nds32_construct_isr_vectors_information().  */\n+\t for interrupt/exception/reset.\n+\t Note that we ONLY check its validity here.\n+\t To construct isr vector information, it is still performed\n+\t by nds32_construct_isr_vectors_information().  */\n       intr  = lookup_attribute (\"interrupt\", func_attrs);\n       excp  = lookup_attribute (\"exception\", func_attrs);\n       reset = lookup_attribute (\"reset\", func_attrs);\n@@ -2689,7 +2688,7 @@ nds32_option_override (void)\n       int r;\n \n       /* Prevent register allocator from\n-         choosing it as doing register allocation.  */\n+\t choosing it as doing register allocation.  */\n       for (r = 11; r <= 14; r++)\n \tfixed_regs[r] = call_used_regs[r] = 1;\n       for (r = 16; r <= 27; r++)\n@@ -2834,12 +2833,12 @@ nds32_initial_elimination_offset (unsigned int from_reg, unsigned int to_reg)\n   nds32_compute_stack_frame ();\n \n   /* Remember to consider\n-     cfun->machine->callee_saved_area_padding_bytes\n+     cfun->machine->callee_saved_area_gpr_padding_bytes\n      when calculating offset.  */\n   if (from_reg == ARG_POINTER_REGNUM && to_reg == STACK_POINTER_REGNUM)\n     {\n       offset = (cfun->machine->fp_size\n-\t        + cfun->machine->gp_size\n+\t\t+ cfun->machine->gp_size\n \t\t+ cfun->machine->lp_size\n \t\t+ cfun->machine->callee_saved_gpr_regs_size\n \t\t+ cfun->machine->callee_saved_area_gpr_padding_bytes\n@@ -2969,11 +2968,11 @@ nds32_expand_prologue (void)\n   if (frame_pointer_needed)\n     {\n       /* adjust $fp = $sp + ($fp size) + ($gp size) + ($lp size)\n-                          + (4 * callee-saved-registers)\n-         Note: No need to adjust\n-               cfun->machine->callee_saved_area_padding_bytes,\n-               because, at this point, stack pointer is just\n-               at the position after push instruction.  */\n+\t\t\t  + (4 * callee-saved-registers)\n+\t Note: No need to adjust\n+\t       cfun->machine->callee_saved_area_gpr_padding_bytes,\n+\t       because, at this point, stack pointer is just\n+\t       at the position after push instruction.  */\n       fp_adjust = cfun->machine->fp_size\n \t\t  + cfun->machine->gp_size\n \t\t  + cfun->machine->lp_size\n@@ -2989,7 +2988,7 @@ nds32_expand_prologue (void)\n     }\n \n   /* Adjust $sp = $sp - local_size - out_args_size\n-                      - callee_saved_area_padding_bytes.  */\n+                      - callee_saved_area_gpr_padding_bytes.  */\n   sp_adjust = cfun->machine->local_size\n \t      + cfun->machine->out_args_size\n \t      + cfun->machine->callee_saved_area_gpr_padding_bytes;\n@@ -3042,8 +3041,8 @@ nds32_expand_epilogue (bool sibcall_p)\n   if (cfun->machine->naked_p)\n     {\n       /* If this is a variadic function, we do not have to restore argument\n-         registers but need to adjust stack pointer back to previous stack\n-         frame location before return.  */\n+\t registers but need to adjust stack pointer back to previous stack\n+\t frame location before return.  */\n       if (cfun->machine->va_args_size != 0)\n \t{\n \t  /* Generate sp adjustment instruction.\n@@ -3063,7 +3062,7 @@ nds32_expand_epilogue (bool sibcall_p)\n \t}\n \n       /* Generate return instruction by using 'return_internal' pattern.\n-         Make sure this instruction is after gen_blockage().  */\n+\t Make sure this instruction is after gen_blockage().  */\n       if (!sibcall_p)\n \temit_jump_insn (gen_return_internal ());\n       return;\n@@ -3072,11 +3071,11 @@ nds32_expand_epilogue (bool sibcall_p)\n   if (frame_pointer_needed)\n     {\n       /* adjust $sp = $fp - ($fp size) - ($gp size) - ($lp size)\n-                          - (4 * callee-saved-registers)\n-         Note: No need to adjust\n-               cfun->machine->callee_saved_area_padding_bytes,\n-               because we want to adjust stack pointer\n-               to the position for pop instruction.  */\n+\t\t\t  - (4 * callee-saved-registers)\n+\t Note: No need to adjust\n+\t       cfun->machine->callee_saved_area_gpr_padding_bytes,\n+\t       because we want to adjust stack pointer\n+\t       to the position for pop instruction.  */\n       sp_adjust = cfun->machine->fp_size\n \t\t  + cfun->machine->gp_size\n \t\t  + cfun->machine->lp_size\n@@ -3093,20 +3092,20 @@ nds32_expand_epilogue (bool sibcall_p)\n   else\n     {\n       /* If frame pointer is NOT needed,\n-         we cannot calculate the sp adjustment from frame pointer.\n-         Instead, we calculate the adjustment by local_size,\n-         out_args_size, and callee_saved_area_padding_bytes.\n-         Notice that such sp adjustment value may be out of range,\n-         so we have to deal with it as well.  */\n+\t we cannot calculate the sp adjustment from frame pointer.\n+\t Instead, we calculate the adjustment by local_size,\n+\t out_args_size, and callee_saved_area_padding_bytes.\n+\t Notice that such sp adjustment value may be out of range,\n+\t so we have to deal with it as well.  */\n \n       /* Adjust $sp = $sp + local_size + out_args_size\n-                          + callee_saved_area_padding_bytes.  */\n+\t\t\t  + callee_saved_area_padding_bytes.  */\n       sp_adjust = cfun->machine->local_size\n \t\t  + cfun->machine->out_args_size\n \t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n       /* sp_adjust value may be out of range of the addi instruction,\n-         create alternative add behavior with TA_REGNUM if necessary,\n-         using POSITIVE value to tell that we are increasing address.  */\n+\t create alternative add behavior with TA_REGNUM if necessary,\n+\t using POSITIVE value to tell that we are increasing address.  */\n       sp_adjust = nds32_force_addi_stack_int (sp_adjust);\n       if (sp_adjust)\n \t{\n@@ -3154,7 +3153,7 @@ nds32_expand_epilogue (bool sibcall_p)\n   if (cfun->machine->va_args_size != 0)\n     {\n       /* Generate sp adjustment instruction.\n-         We  need to consider padding bytes here.  */\n+\t We need to consider padding bytes here.  */\n       sp_adjust = cfun->machine->va_args_size\n \t\t  + cfun->machine->va_args_area_padding_bytes;\n       sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n@@ -3164,8 +3163,8 @@ nds32_expand_epilogue (bool sibcall_p)\n       sp_adjust_insn = emit_insn (sp_adjust_insn);\n \n       /* The insn rtx 'sp_adjust_insn' will change frame layout.\n-         We need to use RTX_FRAME_RELATED_P so that GCC is able to\n-         generate CFI (Call Frame Information) stuff.  */\n+\t We need to use RTX_FRAME_RELATED_P so that GCC is able to\n+\t generate CFI (Call Frame Information) stuff.  */\n       RTX_FRAME_RELATED_P (sp_adjust_insn) = 1;\n     }\n \n@@ -3209,25 +3208,25 @@ nds32_expand_prologue_v3push (void)\n       /* We can use 'push25 Re,imm8u'.  */\n \n       /* nds32_emit_stack_v3push(last_regno, sp_adjust),\n-         the pattern 'stack_v3push' is implemented in nds32.md.\n+\t the pattern 'stack_v3push' is implemented in nds32.md.\n          The (const_int 14) means v3push always push { $fp $gp $lp }.  */\n       nds32_emit_stack_v3push (Rb, Re,\n \t\t\t       GEN_INT (14), GEN_INT (sp_adjust));\n \n       /* Check frame_pointer_needed to see\n-         if we shall emit fp adjustment instruction.  */\n+\t if we shall emit fp adjustment instruction.  */\n       if (frame_pointer_needed)\n \t{\n \t  /* adjust $fp = $sp   + 4         ($fp size)\n-\t                        + 4         ($gp size)\n-\t                        + 4         ($lp size)\n-\t                        + (4 * n)   (callee-saved registers)\n-\t                        + sp_adjust ('push25 Re,imm8u')\n+\t\t\t\t+ 4         ($gp size)\n+\t\t\t\t+ 4         ($lp size)\n+\t\t\t\t+ (4 * n)   (callee-saved registers)\n+\t\t\t\t+ sp_adjust ('push25 Re,imm8u')\n \t     Note: Since we use 'push25 Re,imm8u',\n-\t           the position of stack pointer is further\n-\t           changed after push instruction.\n-\t           Hence, we need to take sp_adjust value\n-\t           into consideration.  */\n+\t\t   the position of stack pointer is further\n+\t\t   changed after push instruction.\n+\t\t   Hence, we need to take sp_adjust value\n+\t\t   into consideration.  */\n \t  fp_adjust = cfun->machine->fp_size\n \t\t      + cfun->machine->gp_size\n \t\t      + cfun->machine->lp_size\n@@ -3243,26 +3242,26 @@ nds32_expand_prologue_v3push (void)\n   else\n     {\n       /* We have to use 'push25 Re,0' and\n-         expand one more instruction to adjust $sp later.  */\n+\t expand one more instruction to adjust $sp later.  */\n \n       /* nds32_emit_stack_v3push(last_regno, sp_adjust),\n-         the pattern 'stack_v3push' is implemented in nds32.md.\n-         The (const_int 14) means v3push always push { $fp $gp $lp }.  */\n+\t the pattern 'stack_v3push' is implemented in nds32.md.\n+\t The (const_int 14) means v3push always push { $fp $gp $lp }.  */\n       nds32_emit_stack_v3push (Rb, Re,\n \t\t\t       GEN_INT (14), GEN_INT (0));\n \n       /* Check frame_pointer_needed to see\n-         if we shall emit fp adjustment instruction.  */\n+\t if we shall emit fp adjustment instruction.  */\n       if (frame_pointer_needed)\n \t{\n \t  /* adjust $fp = $sp + 4        ($fp size)\n-\t                      + 4        ($gp size)\n-\t                      + 4        ($lp size)\n-\t                      + (4 * n)  (callee-saved registers)\n+\t\t\t      + 4        ($gp size)\n+\t\t\t      + 4        ($lp size)\n+\t\t\t      + (4 * n)  (callee-saved registers)\n \t     Note: Since we use 'push25 Re,0',\n-\t           the stack pointer is just at the position\n-\t           after push instruction.\n-\t           No need to take sp_adjust into consideration.  */\n+\t\t   the stack pointer is just at the position\n+\t\t   after push instruction.\n+\t\t   No need to take sp_adjust into consideration.  */\n \t  fp_adjust = cfun->machine->fp_size\n \t\t      + cfun->machine->gp_size\n \t\t      + cfun->machine->lp_size\n@@ -3275,10 +3274,10 @@ nds32_expand_prologue_v3push (void)\n \t}\n \n       /* Because we use 'push25 Re,0',\n-         we need to expand one more instruction to adjust $sp.\n-         However, sp_adjust value may be out of range of the addi instruction,\n-         create alternative add behavior with TA_REGNUM if necessary,\n-         using NEGATIVE value to tell that we are decreasing address.  */\n+\t we need to expand one more instruction to adjust $sp.\n+\t However, sp_adjust value may be out of range of the addi instruction,\n+\t create alternative add behavior with TA_REGNUM if necessary,\n+\t using NEGATIVE value to tell that we are decreasing address.  */\n       sp_adjust = nds32_force_addi_stack_int ( (-1) * sp_adjust);\n       if (sp_adjust)\n \t{\n@@ -3324,7 +3323,7 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n   if (cfun->machine->naked_p)\n     {\n       /* Generate return instruction by using 'return_internal' pattern.\n-         Make sure this instruction is after gen_blockage().  */\n+\t Make sure this instruction is after gen_blockage().  */\n       if (!sibcall_p)\n \temit_jump_insn (gen_return_internal ());\n       return;\n@@ -3354,26 +3353,26 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n       /* We can use 'pop25 Re,imm8u'.  */\n \n       /* nds32_emit_stack_v3pop(last_regno, sp_adjust),\n-         the pattern 'stack_v3pop' is implementad in nds32.md.\n+\t the pattern 'stack_v3pop' is implementad in nds32.md.\n          The (const_int 14) means v3pop always pop { $fp $gp $lp }.  */\n       nds32_emit_stack_v3pop (Rb, Re,\n \t\t\t      GEN_INT (14), GEN_INT (sp_adjust));\n     }\n   else\n     {\n       /* We have to use 'pop25 Re,0', and prior to it,\n-         we must expand one more instruction to adjust $sp.  */\n+\t we must expand one more instruction to adjust $sp.  */\n \n       if (frame_pointer_needed)\n \t{\n \t  /* adjust $sp = $fp - 4        ($fp size)\n-\t                      - 4        ($gp size)\n-\t                      - 4        ($lp size)\n-\t                      - (4 * n)  (callee-saved registers)\n+\t\t\t      - 4        ($gp size)\n+\t\t\t      - 4        ($lp size)\n+\t\t\t      - (4 * n)  (callee-saved registers)\n \t     Note: No need to adjust\n-\t           cfun->machine->callee_saved_area_padding_bytes,\n-\t           because we want to adjust stack pointer\n-\t           to the position for pop instruction.  */\n+\t\t   cfun->machine->callee_saved_area_gpr_padding_bytes,\n+\t\t   because we want to adjust stack pointer\n+\t\t   to the position for pop instruction.  */\n \t  sp_adjust = cfun->machine->fp_size\n \t\t      + cfun->machine->gp_size\n \t\t      + cfun->machine->lp_size\n@@ -3394,7 +3393,7 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n \t     so we have to deal with it as well.  */\n \n \t  /* Adjust $sp = $sp + local_size + out_args_size\n-\t\t\t      + callee_saved_area_padding_bytes.  */\n+\t\t\t      + callee_saved_area_gpr_padding_bytes.  */\n \t  sp_adjust = cfun->machine->local_size\n \t\t      + cfun->machine->out_args_size\n \t\t      + cfun->machine->callee_saved_area_gpr_padding_bytes;\n@@ -3405,7 +3404,7 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n \t  if (sp_adjust)\n \t    {\n \t      /* Generate sp adjustment instruction\n-\t         if and only if sp_adjust != 0.  */\n+\t\t if and only if sp_adjust != 0.  */\n \t      sp_adjust_insn = gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t\t   stack_pointer_rtx,\n \t\t\t\t\t   GEN_INT (sp_adjust));\n@@ -3415,7 +3414,7 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n \t}\n \n       /* nds32_emit_stack_v3pop(last_regno, sp_adjust),\n-         the pattern 'stack_v3pop' is implementad in nds32.md.  */\n+\t the pattern 'stack_v3pop' is implementad in nds32.md.  */\n       /* The (const_int 14) means v3pop always pop { $fp $gp $lp }.  */\n       nds32_emit_stack_v3pop (Rb, Re,\n \t\t\t      GEN_INT (14), GEN_INT (0));\n@@ -3438,9 +3437,9 @@ nds32_can_use_return_insn (void)\n \n   /* If no stack was created, two conditions must be satisfied:\n      1. This is a naked function.\n-        So there is no callee-saved, local size, or outgoing size.\n+\tSo there is no callee-saved, local size, or outgoing size.\n      2. This is NOT a variadic function.\n-        So there is no pushing arguement registers into the stack.  */\n+\tSo there is no pushing arguement registers into the stack.  */\n   return (cfun->machine->naked_p && (cfun->machine->va_args_size == 0));\n }\n "}, {"sha": "d33237c004cd5a516de17284de2b88a85551ed87", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -159,18 +159,18 @@ enum nds32_16bit_address_type\n /* This macro is used to return the register number for passing argument.\n    We need to obey the following rules:\n      1. If it is required MORE THAN one register,\n-        we need to further check if it really needs to be\n-        aligned on double words.\n-          a) If double word alignment is necessary,\n-             the register number must be even value.\n-          b) Otherwise, the register number can be odd or even value.\n+\twe need to further check if it really needs to be\n+\taligned on double words.\n+\t  a) If double word alignment is necessary,\n+\t     the register number must be even value.\n+\t  b) Otherwise, the register number can be odd or even value.\n      2. If it is required ONLY one register,\n-        the register number can be odd or even value.  */\n-#define NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG(reg_offset, mode, type)  \\\n-  ((NDS32_NEED_N_REGS_FOR_ARG (mode, type) > 1)                     \\\n-   ? ((NDS32_MODE_TYPE_ALIGN (mode, type) > PARM_BOUNDARY)          \\\n-      ? (((reg_offset) + NDS32_GPR_ARG_FIRST_REGNUM + 1) & ~1)      \\\n-      : ((reg_offset) + NDS32_GPR_ARG_FIRST_REGNUM))                \\\n+\tthe register number can be odd or even value.  */\n+#define NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG(reg_offset, mode, type) \\\n+  ((NDS32_NEED_N_REGS_FOR_ARG (mode, type) > 1)                    \\\n+   ? ((NDS32_MODE_TYPE_ALIGN (mode, type) > PARM_BOUNDARY)         \\\n+      ? (((reg_offset) + NDS32_GPR_ARG_FIRST_REGNUM + 1) & ~1)     \\\n+      : ((reg_offset) + NDS32_GPR_ARG_FIRST_REGNUM))               \\\n    : ((reg_offset) + NDS32_GPR_ARG_FIRST_REGNUM))\n \n /* This macro is to check if there are still available registers\n@@ -761,13 +761,13 @@ enum reg_class\n    The trampoline code for nds32 target must contains following parts:\n \n      1. instructions (4 * 4 = 16 bytes):\n-          get $pc first\n-          load chain_value to static chain register via $pc\n-          load nested function address to $r15 via $pc\n-          jump to desired nested function via $r15\n+\t  get $pc first\n+\t  load chain_value to static chain register via $pc\n+\t  load nested function address to $r15 via $pc\n+\t  jump to desired nested function via $r15\n      2. data (4 * 2 = 8 bytes):\n-          chain_value\n-          nested function address\n+\t  chain_value\n+\t  nested function address\n \n    Please check nds32.c implementation for more information.  */\n #define TRAMPOLINE_SIZE 24\n@@ -906,10 +906,10 @@ enum reg_class\n   do                                                   \\\n     {                                                  \\\n       /* Because our jump table is in text section,    \\\n-         we need to make sure 2-byte alignment after   \\\n-         the jump table for instructions fetch.  */    \\\n+\t we need to make sure 2-byte alignment after   \\\n+\t the jump table for instructions fetch.  */    \\\n       if (GET_MODE (PATTERN (table)) == QImode)        \\\n-        ASM_OUTPUT_ALIGN (stream, 1);                  \\\n+\tASM_OUTPUT_ALIGN (stream, 1);                  \\\n       asm_fprintf (stream, \"\\t! Jump Table End\\n\");    \\\n     }  while (0)\n "}, {"sha": "8d1f649024f8c7c4e0d9d5c58573327519645b13", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a498f99caba7f366e07fbf527d7ed7fcbe038b3/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=8a498f99caba7f366e07fbf527d7ed7fcbe038b3", "patch": "@@ -269,12 +269,12 @@\n     {\n     case 0:\n       /* addi Rt4,Rt4,-x  ==>  subi45 Rt4,x\n-         where 0 <= x <= 31 */\n+\t where 0 <= x <= 31 */\n       operands[2] = gen_int_mode (-INTVAL (operands[2]), SImode);\n       return \"subi45\\t%0, %2\";\n     case 1:\n       /* addi Rt3,Ra3,-x  ==>  subi333 Rt3,Ra3,x\n-         where 0 <= x <= 7 */\n+\t where 0 <= x <= 7 */\n       operands[2] = gen_int_mode (-INTVAL (operands[2]), SImode);\n       return \"subi333\\t%0, %1, %2\";\n     case 2:\n@@ -320,7 +320,7 @@\n ;; and needs to ensure it is exact_log2 value.\n (define_insn \"*add_slli\"\n   [(set (match_operand:SI 0 \"register_operand\"                    \"=r\")\n-        (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\"  \" r\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\"  \" r\")\n \t\t\t  (match_operand:SI 2 \"immediate_operand\" \" i\"))\n \t\t (match_operand:SI 3 \"register_operand\"           \" r\")))]\n   \"TARGET_ISA_V3\n@@ -415,29 +415,29 @@\n \n (define_insn \"*maddr32_0\"\n   [(set (match_operand:SI 0 \"register_operand\"                   \"=r\")\n-        (plus:SI (match_operand:SI 3 \"register_operand\"          \" 0\")\n-                 (mult:SI (match_operand:SI 1 \"register_operand\" \" r\")\n-                          (match_operand:SI 2 \"register_operand\" \" r\"))))]\n+\t(plus:SI (match_operand:SI 3 \"register_operand\"          \" 0\")\n+\t\t (mult:SI (match_operand:SI 1 \"register_operand\" \" r\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \" r\"))))]\n   \"\"\n   \"maddr32\\t%0, %1, %2\"\n   [(set_attr \"type\"   \"alu\")\n    (set_attr \"length\"   \"4\")])\n \n (define_insn \"*maddr32_1\"\n   [(set (match_operand:SI 0 \"register_operand\"                   \"=r\")\n-        (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \" r\")\n-                          (match_operand:SI 2 \"register_operand\" \" r\"))\n-                 (match_operand:SI 3 \"register_operand\"          \" 0\")))]\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \" r\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \" r\"))\n+\t\t (match_operand:SI 3 \"register_operand\"          \" 0\")))]\n   \"\"\n   \"maddr32\\t%0, %1, %2\"\n   [(set_attr \"type\"   \"alu\")\n    (set_attr \"length\"   \"4\")])\n \n (define_insn \"*msubr32\"\n   [(set (match_operand:SI 0 \"register_operand\"                    \"=r\")\n-        (minus:SI (match_operand:SI 3 \"register_operand\"          \" 0\")\n-                  (mult:SI (match_operand:SI 1 \"register_operand\" \" r\")\n-                           (match_operand:SI 2 \"register_operand\" \" r\"))))]\n+\t(minus:SI (match_operand:SI 3 \"register_operand\"          \" 0\")\n+\t\t  (mult:SI (match_operand:SI 1 \"register_operand\" \" r\")\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \" r\"))))]\n   \"\"\n   \"msubr32\\t%0, %1, %2\"\n   [(set_attr \"type\"   \"alu\")\n@@ -448,21 +448,21 @@\n \n (define_insn \"divmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\"         \"=r\")\n-        (div:SI (match_operand:SI 1 \"register_operand\" \" r\")\n-                (match_operand:SI 2 \"register_operand\" \" r\")))\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \" r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \" r\")))\n    (set (match_operand:SI 3 \"register_operand\"         \"=r\")\n-        (mod:SI (match_dup 1) (match_dup 2)))]\n+\t(mod:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"divsr\\t%0, %3, %1, %2\"\n   [(set_attr \"type\"   \"alu\")\n    (set_attr \"length\"   \"4\")])\n \n (define_insn \"udivmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\"          \"=r\")\n-        (udiv:SI (match_operand:SI 1 \"register_operand\" \" r\")\n-                (match_operand:SI 2 \"register_operand\"  \" r\")))\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \" r\")\n+\t\t (match_operand:SI 2 \"register_operand\"  \" r\")))\n    (set (match_operand:SI 3 \"register_operand\"          \"=r\")\n-        (umod:SI (match_dup 1) (match_dup 2)))]\n+\t(umod:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"divr\\t%0, %3, %1, %2\"\n   [(set_attr \"type\"   \"alu\")\n@@ -2275,8 +2275,8 @@ create_template:\n       add_tmp = gen_int_mode (-INTVAL (operands[1]), SImode);\n \n       /* If the integer value is not in the range of imm15s,\n-         we need to force register first because our addsi3 pattern\n-         only accept nds32_rimm15s_operand predicate.  */\n+\t we need to force register first because our addsi3 pattern\n+\t only accept nds32_rimm15s_operand predicate.  */\n       add_tmp = force_reg (SImode, add_tmp);\n \n       emit_insn (gen_addsi3 (reg, operands[0], add_tmp));"}]}