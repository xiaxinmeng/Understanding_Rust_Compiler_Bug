{"sha": "d5db54a12c1fec54208876b4137ab09851fe6565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVkYjU0YTEyYzFmZWM1NDIwODg3NmI0MTM3YWIwOTg1MWZlNjU2NQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2002-11-01T14:41:57Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2002-11-01T14:41:57Z"}, "message": "re PR target/7856 ([arm] invalid offset in constant pool reference)\n\nPR target/7856\n* arm.c (use_return_insn): Don't use a return insn if there are\nsaved integer regs, but LR is not one of them.\n\nFrom-SVN: r58716", "tree": {"sha": "7fe50bc1681bc3ac3462d5638af232702f27e312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fe50bc1681bc3ac3462d5638af232702f27e312"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5db54a12c1fec54208876b4137ab09851fe6565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5db54a12c1fec54208876b4137ab09851fe6565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5db54a12c1fec54208876b4137ab09851fe6565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5db54a12c1fec54208876b4137ab09851fe6565/comments", "author": null, "committer": null, "parents": [{"sha": "9dcb1ec8139c2ebd15357e6efe37d19f4ff80267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dcb1ec8139c2ebd15357e6efe37d19f4ff80267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dcb1ec8139c2ebd15357e6efe37d19f4ff80267"}], "stats": {"total": 35, "additions": 25, "deletions": 10}, "files": [{"sha": "d904fc4eacc6633d028456957909291dc21e4c39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5db54a12c1fec54208876b4137ab09851fe6565/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5db54a12c1fec54208876b4137ab09851fe6565/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5db54a12c1fec54208876b4137ab09851fe6565", "patch": "@@ -1,3 +1,9 @@\n+2002-11-01  Richard Earnshaw  (rearnsha@arm.com)\n+\n+\tPR target/7856\n+\t* arm.c (use_return_insn): Don't use a return insn if there are\n+\tsaved integer regs, but LR is not one of them.\n+\n Fri Nov  1 10:33:15 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* expr.c (emit_move_insn):  Use SCALAR_FLOAT_MODE_P"}, {"sha": "5c0eea7cd9d8fe43ccde95d7a031623afeeeafcf", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5db54a12c1fec54208876b4137ab09851fe6565/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5db54a12c1fec54208876b4137ab09851fe6565/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d5db54a12c1fec54208876b4137ab09851fe6565", "patch": "@@ -909,6 +909,7 @@ use_return_insn (iscond)\n {\n   int regno;\n   unsigned int func_type;\n+  unsigned long saved_int_regs;\n \n   /* Never use a return instruction before reload has run.  */\n   if (!reload_completed)\n@@ -931,23 +932,31 @@ use_return_insn (iscond)\n \t  && !frame_pointer_needed))\n     return 0;\n \n+  saved_int_regs = arm_compute_save_reg_mask ();\n+\n   /* Can't be done if interworking with Thumb, and any registers have been\n-     stacked.  Similarly, on StrongARM, conditional returns are expensive\n-     if they aren't taken and registers have been stacked.  */\n-  if (iscond && arm_is_strong && frame_pointer_needed)\n+     stacked.  */\n+  if (TARGET_INTERWORK && saved_int_regs != 0)\n     return 0;\n-  \n-  if ((iscond && arm_is_strong)\n-      || TARGET_INTERWORK)\n+\n+  /* On StrongARM, conditional returns are expensive if they aren't\n+     taken and multiple registers have been stacked.  */\n+  if (iscond && arm_is_strong)\n     {\n-      for (regno = 0; regno <= LAST_ARM_REGNUM; regno++)\n-\tif (regs_ever_live[regno] && !call_used_regs[regno])\n-\t  return 0;\n+      /* Conditional return when just the LR is stored is a simple \n+\t conditional-load instruction, that's not expensive.  */\n+      if (saved_int_regs != 0 && saved_int_regs != (1 << LR_REGNUM))\n+\treturn 0;\n \n       if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n \treturn 0;\n     }\n-      \n+\n+  /* If there are saved registers but the LR isn't saved, then we need\n+     two instructions for the return.  */\n+  if (saved_int_regs && !(saved_int_regs & (1 << LR_REGNUM)))\n+    return 0;\n+\n   /* Can't be done if any of the FPU regs are pushed,\n      since this also requires an insn.  */\n   if (TARGET_HARD_FLOAT)"}]}