{"sha": "280c1e0d2363f8c7ad25d623123421e9b42f4722", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwYzFlMGQyMzYzZjhjN2FkMjVkNjIzMTIzNDIxZTliNDJmNDcyMg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-06-30T00:31:21Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-06-30T00:31:21Z"}, "message": "builtin-attrs.def (gcc_diag, [...]): New format attributes.\n\ngcc:\n\t* builtin-attrs.def (gcc_diag, gcc_cdiag, gcc_cxxdiag): New\n\tformat attributes.\n\t* c-format.c (enum format_type): Add gcc_diag_format_type,\n\tgcc_cdiag_format_type, and gcc_cxxdiag_format_type.\n\t(gcc_diag_length_specs, gcc_cdiag_length_specs,\n\tgcc_cxxdiag_length_specs, gcc_diag_flag_pairs,\n\tgcc_cdiag_flag_pairs, gcc_cxxdiag_flag_pairs, gcc_diag_flag_specs,\n\tgcc_cdiag_flag_specs, gcc_cxxdiag_flag_specs, gcc_diag_char_table,\n\tgcc_cdiag_char_table, gcc_cxxdiag_char_table): New.\n\t(format_types_orig): Add new data.\n\t(find_char_info_specifier_index, init_dynamic_diag_info): New\n\tfunctions.\n\t(handle_format_attribute): Update to handle new format attributes.\n\ntestsuite:\n\t* gcc.dg/format/gcc_diag-1.c: New test.\n\nFrom-SVN: r68689", "tree": {"sha": "8a17e7fe4aba72658d0e9aef9464d1878f0b087b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a17e7fe4aba72658d0e9aef9464d1878f0b087b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/280c1e0d2363f8c7ad25d623123421e9b42f4722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280c1e0d2363f8c7ad25d623123421e9b42f4722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/280c1e0d2363f8c7ad25d623123421e9b42f4722", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280c1e0d2363f8c7ad25d623123421e9b42f4722/comments", "author": null, "committer": null, "parents": [{"sha": "54bbcbd99db9ba3520ceef2912aca9c895e89bf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54bbcbd99db9ba3520ceef2912aca9c895e89bf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54bbcbd99db9ba3520ceef2912aca9c895e89bf3"}], "stats": {"total": 486, "additions": 482, "deletions": 4}, "files": [{"sha": "77013cc00dec754a1887af207d9e3b5376b2355a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=280c1e0d2363f8c7ad25d623123421e9b42f4722", "patch": "@@ -1,3 +1,19 @@\n+2003-06-29  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtin-attrs.def (gcc_diag, gcc_cdiag, gcc_cxxdiag): New\n+\tformat attributes.\n+\t* c-format.c (enum format_type): Add gcc_diag_format_type,\n+\tgcc_cdiag_format_type, and gcc_cxxdiag_format_type.\n+\t(gcc_diag_length_specs, gcc_cdiag_length_specs,\n+\tgcc_cxxdiag_length_specs, gcc_diag_flag_pairs,\n+\tgcc_cdiag_flag_pairs, gcc_cxxdiag_flag_pairs, gcc_diag_flag_specs,\n+\tgcc_cdiag_flag_specs, gcc_cxxdiag_flag_specs, gcc_diag_char_table,\n+\tgcc_cdiag_char_table, gcc_cxxdiag_char_table): New.\n+\t(format_types_orig): Add new data.\n+\t(find_char_info_specifier_index, init_dynamic_diag_info): New\n+\tfunctions.\n+\t(handle_format_attribute): Update to handle new format attributes.\n+\n 2003-06-29  Aaron W. LaFramboise  <awlaframboise@aol.com>\n \n \t* config/i386/mingw32.h (__GTHREAD_HIDE_WIN32API): Define to 1."}, {"sha": "7156fcef994394b54f5c140e04599d338f2e4da2", "filename": "gcc/builtin-attrs.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2Fbuiltin-attrs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2Fbuiltin-attrs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-attrs.def?ref=280c1e0d2363f8c7ad25d623123421e9b42f4722", "patch": "@@ -85,6 +85,9 @@ DEF_ATTR_IDENT (ATTR_NORETURN, \"noreturn\")\n DEF_ATTR_IDENT (ATTR_NOTHROW, \"nothrow\")\n DEF_ATTR_IDENT (ATTR_PRINTF, \"printf\")\n DEF_ATTR_IDENT (ATTR_ASM_FPRINTF, \"asm_fprintf\")\n+DEF_ATTR_IDENT (ATTR_GCC_DIAG, \"gcc_diag\")\n+DEF_ATTR_IDENT (ATTR_GCC_CDIAG, \"gcc_cdiag\")\n+DEF_ATTR_IDENT (ATTR_GCC_CXXDIAG, \"gcc_cxxdiag\")\n DEF_ATTR_IDENT (ATTR_PURE, \"pure\")\n DEF_ATTR_IDENT (ATTR_SCANF, \"scanf\")\n DEF_ATTR_IDENT (ATTR_STRFMON, \"strfmon\")"}, {"sha": "b971d3258aad40ecfce4dc173ba34d538f5cd996", "filename": "gcc/c-format.c", "status": "modified", "additions": 274, "deletions": 4, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=280c1e0d2363f8c7ad25d623123421e9b42f4722", "patch": "@@ -56,6 +56,8 @@ set_Wformat (int setting)\n /* This must be in the same order as format_types, with format_type_error\n    last.  */\n enum format_type { printf_format_type, asm_fprintf_format_type,\n+\t\t   gcc_diag_format_type, gcc_cdiag_format_type,\n+\t\t   gcc_cxxdiag_format_type,\n \t\t   scanf_format_type, strftime_format_type,\n \t\t   strfmon_format_type, format_type_error };\n \n@@ -523,6 +525,18 @@ static const format_length_info asm_fprintf_length_specs[] =\n   { NULL, 0, 0, NULL, 0, 0 }\n };\n \n+/* Length specifiers valid for GCC diagnostics.  */\n+static const format_length_info gcc_diag_length_specs[] =\n+{\n+  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C89 },\n+  { \"w\", FMT_LEN_none, STD_C89, NULL, 0, 0 },\n+  { NULL, 0, 0, NULL, 0, 0 }\n+};\n+\n+/* The custom diagnostics all accept the same length specifiers.  */\n+#define gcc_cdiag_length_specs gcc_diag_length_specs\n+#define gcc_cxxdiag_length_specs gcc_diag_length_specs\n+\n /* This differs from printf_length_specs only in that \"Z\" is not accepted.  */\n static const format_length_info scanf_length_specs[] =\n {\n@@ -591,6 +605,32 @@ static const format_flag_pair asm_fprintf_flag_pairs[] =\n   { 0, 0, 0, 0 }\n };\n \n+static const format_flag_pair gcc_diag_flag_pairs[] =\n+{\n+  { 0, 0, 0, 0 }\n+};\n+\n+#define gcc_cdiag_flag_pairs gcc_diag_flag_pairs\n+#define gcc_cxxdiag_flag_pairs gcc_diag_flag_pairs\n+\n+static const format_flag_spec gcc_diag_flag_specs[] =\n+{\n+  { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n+  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, 0, NULL, NULL, 0 }\n+};\n+\n+#define gcc_cdiag_flag_specs gcc_diag_flag_specs\n+\n+static const format_flag_spec gcc_cxxdiag_flag_specs[] =\n+{\n+  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n+  { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n+  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, 0, NULL, NULL, 0 }\n+};\n+\n static const format_flag_spec scanf_flag_specs[] =\n {\n   { '*',  0, 0, N_(\"assignment suppression\"), N_(\"the assignment suppression scanf feature\"), STD_C89 },\n@@ -755,6 +795,72 @@ static const format_char_info asm_fprintf_char_table[] =\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n };\n \n+static const format_char_info gcc_diag_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"p\",  \"cR\" },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"c\"  },\n+\n+  /* Custom conversion specifiers.  */\n+\n+  /* %H will require \"location_t\" at runtime.  */\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+};\n+\n+static const format_char_info gcc_cdiag_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"p\",  \"cR\" },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"c\"  },\n+\n+  /* Custom conversion specifiers.  */\n+\n+  /* %H will require \"location_t\" at runtime.  */\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+\n+  /* These will require a \"tree\" at runtime.  */\n+  { \"DFT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+};\n+\n+static const format_char_info gcc_cxxdiag_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"p\",  \"cR\" },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"c\"  },\n+\n+  /* Custom conversion specifiers.  */\n+\n+  /* %H will require \"location_t\" at runtime.  */\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+\n+  /* These will require a \"tree\" at runtime.  */\n+  { \"ADEFTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"+#\",   \"\"   },\n+\n+  /* These accept either an `int' or an `enum tree_code' (which is handled as an `int'.)  */\n+  { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+};\n+\n static const format_char_info scan_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n@@ -824,6 +930,24 @@ static const format_kind_info format_types_orig[] =\n     'w', 0, 'p', 0, 'L',\n     NULL, NULL\n   },\n+  { \"gcc_diag\",   gcc_diag_length_specs,  gcc_diag_char_table, \"\", NULL, \n+    gcc_diag_flag_specs, gcc_diag_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT,\n+    0, 0, 'p', 0, 'L',\n+    NULL, &integer_type_node\n+  },\n+  { \"gcc_cdiag\",   gcc_cdiag_length_specs,  gcc_cdiag_char_table, \"\", NULL, \n+    gcc_cdiag_flag_specs, gcc_cdiag_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT,\n+    0, 0, 'p', 0, 'L',\n+    NULL, &integer_type_node\n+  },\n+  { \"gcc_cxxdiag\",   gcc_cxxdiag_length_specs,  gcc_cxxdiag_char_table, \"+#\", NULL, \n+    gcc_cxxdiag_flag_specs, gcc_cxxdiag_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT,\n+    0, 0, 'p', 0, 'L',\n+    NULL, &integer_type_node\n+  },\n   { \"scanf\",    scanf_length_specs,   scan_char_table,  \"*'I\", NULL, \n     scanf_flag_specs, scanf_flag_pairs,\n     FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD|FMT_FLAG_DOLLAR_GAP_POINTER_OK,\n@@ -2330,6 +2454,26 @@ check_format_types (int *status, format_wanted_type *types)\n     }\n }\n \n+/* Given a format_char_info array FCI, and a character C, this function\n+   returns the index into the conversion_specs where that specifier's\n+   data is located.  If the character isn't found it aborts.  */\n+static unsigned int\n+find_char_info_specifier_index (const format_char_info *fci, int c)\n+{\n+  unsigned int i = 0;\n+  \n+  while (fci->format_chars)\n+    {\n+      if (strchr (fci->format_chars, c))\n+\treturn i;\n+      i++; fci++;\n+    }\n+  \n+  /* We shouldn't be looking for a non-existent specifier.  */\n+  abort ();\n+  \n+}\n+\n /* Given a format_length_info array FLI, and a character C, this\n    function returns the index into the conversion_specs where that\n    modifier's data is located.  If the character isn't found it\n@@ -2391,6 +2535,118 @@ init_dynamic_asm_fprintf_info (void)\n     }\n }\n \n+/* Determine the types of \"tree\" and \"location_t\" in the code being\n+   compiled for use in GCC's diagnostic custom format attributes.  You\n+   must have set dynamic_format_types before calling this function.  */\n+static void\n+init_dynamic_diag_info (void)\n+{\n+  static tree t, loc, hwi;\n+      \n+  if (!loc || !t || !hwi)\n+    {\n+      static format_char_info *diag_fci, *cdiag_fci, *cxxdiag_fci;\n+      static format_length_info *diag_ls;\n+      unsigned int i;\n+\n+      /* For the GCC-diagnostics custom format specifiers to work, one\n+\t must have declared `tree' and/or `location_t' prior to using\n+\t those attributes.  If we haven't seen these declarations then\n+\t you shouldn't use the specifiers requiring these types.\n+\t However we don't force a hard ICE because we may see only one\n+\t or the other type.  */\n+      if ((loc = maybe_get_identifier (\"location_t\")))\n+\tloc = TREE_TYPE (identifier_global_value (loc));\n+\n+      /* We need to grab the underlying `union tree_node' so peek into\n+\t an extra type level.  */\n+      if ((t = maybe_get_identifier (\"tree\")))\n+\tt = TREE_TYPE (TREE_TYPE (identifier_global_value (t)));\n+    \n+      /* Find the underlying type for HOST_WIDE_INT.  For the %w\n+\t length modifier to work, one must have issued: \"typedef\n+\t HOST_WIDE_INT __gcc_host_wide_int__;\" in one's source code\n+\t prior to using that modifier.  */\n+      if ((hwi = maybe_get_identifier (\"__gcc_host_wide_int__\")))\n+\thwi = DECL_ORIGINAL_TYPE (identifier_global_value (hwi));\n+      \n+      /* Assign the new data for use.  */\n+\n+      /* All the GCC diag formats use the same length specs.  */\n+      if (! diag_ls)\n+\tdynamic_format_types[gcc_diag_format_type].length_char_specs =\n+\t  dynamic_format_types[gcc_cdiag_format_type].length_char_specs =\n+\t  dynamic_format_types[gcc_cxxdiag_format_type].length_char_specs =\n+\t  diag_ls = xmemdup (gcc_diag_length_specs,\n+\t\t\t     sizeof (gcc_diag_length_specs),\n+\t\t\t     sizeof (gcc_diag_length_specs)); \n+      if (hwi)\n+        {\n+\t  /* HOST_WIDE_INT must be one of 'long' or 'long long'.  */\n+\t  i = find_length_info_modifier_index (diag_ls, 'w');\n+\t  if (hwi == long_integer_type_node)\n+\t    diag_ls[i].index = FMT_LEN_l;\n+\t  else if (hwi == long_long_integer_type_node)\n+\t    diag_ls[i].index = FMT_LEN_ll;\n+\t  else\n+\t    abort ();\n+\t}\n+\n+      /* Handle the __gcc_diag__ format specifics.  */\n+      if (! diag_fci)\n+\tdynamic_format_types[gcc_diag_format_type].conversion_specs =\n+\t  diag_fci = xmemdup (gcc_diag_char_table,\n+\t\t\t      sizeof(gcc_diag_char_table),\n+\t\t\t      sizeof(gcc_diag_char_table));\n+      if (loc)\n+        {\n+\t  i = find_char_info_specifier_index (diag_fci, 'H');\n+\t  diag_fci[i].types[0].type = &loc;\n+\t  diag_fci[i].pointer_count = 1;\n+\t}\n+\n+      /* Handle the __gcc_cdiag__ format specifics.  */\n+      if (! cdiag_fci)\n+\tdynamic_format_types[gcc_cdiag_format_type].conversion_specs =\n+\t  cdiag_fci = xmemdup (gcc_cdiag_char_table,\n+\t\t\t       sizeof(gcc_cdiag_char_table),\n+\t\t\t       sizeof(gcc_cdiag_char_table));\n+      if (loc)\n+        {\n+\t  i = find_char_info_specifier_index (cdiag_fci, 'H');\n+\t  cdiag_fci[i].types[0].type = &loc;\n+\t  cdiag_fci[i].pointer_count = 1;\n+\t}\n+      if (t)\n+        {\n+\t  /* All specifiers taking a tree share the same struct. */\n+\t  i = find_char_info_specifier_index (cdiag_fci, 'D');\n+\t  cdiag_fci[i].types[0].type = &t;\n+\t  cdiag_fci[i].pointer_count = 1;\n+\t}\n+\n+      /* Handle the __gcc_cxxdiag__ format specifics.  */\n+      if (! cxxdiag_fci)\n+\tdynamic_format_types[gcc_cxxdiag_format_type].conversion_specs =\n+\t  cxxdiag_fci = xmemdup (gcc_cxxdiag_char_table,\n+\t\t\t\t sizeof(gcc_cxxdiag_char_table),\n+\t\t\t\t sizeof(gcc_cxxdiag_char_table));\n+      if (loc)\n+        {\n+\t  i = find_char_info_specifier_index (cxxdiag_fci, 'H');\n+\t  cxxdiag_fci[i].types[0].type = &loc;\n+\t  cxxdiag_fci[i].pointer_count = 1;\n+\t}\n+      if (t)\n+        {\n+\t  /* All specifiers taking a tree share the same struct. */\n+\t  i = find_char_info_specifier_index (cxxdiag_fci, 'D');\n+\t  cxxdiag_fci[i].types[0].type = &t;\n+\t  cxxdiag_fci[i].pointer_count = 1;\n+\t}\n+    }\n+}\n+\n /* Handle a \"format\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n@@ -2440,9 +2696,12 @@ handle_format_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n       return NULL_TREE;\n     }\n \n-  /* If this is format type __asm_fprintf__, we have to initialize\n-     GCC's notion of HOST_WIDE_INT for checking %wd.  */\n-  if (info.format_type == asm_fprintf_format_type)\n+  /* If this is a custom GCC-internal format type, we have to\n+     initialize certain bits a runtime.  */\n+  if (info.format_type == asm_fprintf_format_type\n+      || info.format_type == gcc_diag_format_type\n+      || info.format_type == gcc_cdiag_format_type\n+      || info.format_type == gcc_cxxdiag_format_type)\n     {\n       /* Our first time through, we have to make sure that our\n          format_type data is allocated dynamically and is modifiable.  */\n@@ -2451,7 +2710,18 @@ handle_format_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n \t  xmemdup (format_types_orig, sizeof (format_types_orig),\n \t\t   sizeof (format_types_orig));\n \n-      init_dynamic_asm_fprintf_info();\n+      /* If this is format __asm_fprintf__, we have to initialize\n+         GCC's notion of HOST_WIDE_INT for checking %wd.  */\n+      if (info.format_type == asm_fprintf_format_type)\n+\tinit_dynamic_asm_fprintf_info();\n+      /* If this is one of the diagnostic attributes, then we have to\n+         intialize `location_t' and `tree' at runtime.  */\n+      else if (info.format_type == gcc_diag_format_type\n+\t       || info.format_type == gcc_cdiag_format_type\n+\t       || info.format_type == gcc_cxxdiag_format_type)\n+\tinit_dynamic_diag_info();\n+      else\n+\tabort();\n     }\n \n   return NULL_TREE;"}, {"sha": "26f239f93584cae8cf30e2c9789e1e1caaf82dad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=280c1e0d2363f8c7ad25d623123421e9b42f4722", "patch": "@@ -1,3 +1,7 @@\n+2003-06-29  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/format/gcc_diag-1.c: New test.\n+\n 2003-06-28  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* gcc.c-torture/execute/multi-ix.c: Fix off-by-one bugs."}, {"sha": "7cf18c1b15f6f4cbc24ec3a6a052b6ff6ceb9c21", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-1.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280c1e0d2363f8c7ad25d623123421e9b42f4722/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c?ref=280c1e0d2363f8c7ad25d623123421e9b42f4722", "patch": "@@ -0,0 +1,185 @@\n+/* Test for GCC diagnositc formats.  */\n+/* Origin: Kaveh Ghazi <ghazi@caip.rutgers.edu> */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wformat\" } */\n+\n+#include \"format.h\"\n+\n+#define ATTRIBUTE_DIAG(F) __attribute__ ((__format__ (F, 1, 2))) __attribute__ ((__nonnull__));\n+\n+/* Magic identifiers must be set before the attribute is used.  */\n+\n+typedef long long __gcc_host_wide_int__;\n+\n+typedef struct location_s\n+{\n+  const char *file;\n+  int line;\n+} location_t;\n+\n+union tree_node;\n+typedef union tree_node *tree;\n+\n+extern int diag (const char *, ...) ATTRIBUTE_DIAG(__gcc_diag__);\n+extern int cdiag (const char *, ...) ATTRIBUTE_DIAG(__gcc_cdiag__);\n+extern int cxxdiag (const char *, ...) ATTRIBUTE_DIAG(__gcc_cxxdiag__);\n+\n+void\n+foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n+     int *n, short int *hn, long int l, unsigned long int ul,\n+     long int *ln, long double ld, wint_t lc, wchar_t *ls, llong ll,\n+     ullong ull, unsigned int *un, const int *cn, signed char *ss,\n+     unsigned char *us, const signed char *css, unsigned int u1,\n+     unsigned int u2, location_t *loc, tree t1, union tree_node *t2,\n+     tree *t3, tree t4[])\n+{\n+  /* Acceptable C90 specifiers, flags and modifiers.  */\n+  diag (\"%%\");\n+  cdiag (\"%%\");\n+  cxxdiag (\"%%\");\n+  diag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n+  cdiag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n+  cxxdiag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n+  diag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n+  cdiag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n+  cxxdiag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n+  diag (\"%lld%lli%llo%llu%llx\", ll, ll, ull, ull, ull);\n+  cdiag (\"%lld%lli%llo%llu%llx\", ll, ll, ull, ull, ull);\n+  cxxdiag (\"%lld%lli%llo%llu%llx\", ll, ll, ull, ull, ull);\n+  diag (\"%wd%wi%wo%wu%wx\", ll, ll, ull, ull, ull);\n+  cdiag (\"%wd%wi%wo%wu%wx\", ll, ll, ull, ull, ull);\n+  cxxdiag (\"%wd%wi%wo%wu%wx\", ll, ll, ull, ull, ull);\n+  diag (\"%.*s\", i, s);\n+  cdiag (\"%.*s\", i, s);\n+  cxxdiag (\"%.*s\", i, s);\n+\n+  /* Extensions provided in the diagnostic framework.  */\n+  diag (\"%m\");\n+  cdiag (\"%m\");\n+  cxxdiag (\"%m\");\n+  diag (\"%H\", loc);\n+  cdiag (\"%H\", loc);\n+  cxxdiag (\"%H\", loc);\n+\n+  cdiag (\"%D%F%T\", t1, t1, t1);\n+  cdiag (\"%D%D%D%D\", t1, t2, *t3, t4[5]);\n+  cxxdiag (\"%A%D%E%F%T%V\", t1, t1, t1, t1, t1, t1);\n+  cxxdiag (\"%D%D%D%D\", t1, t2, *t3, t4[5]);\n+  cxxdiag (\"%#A%#D%#E%#F%#T%#V\", t1, t1, t1, t1, t1, t1);\n+  cxxdiag (\"%+A%+D%+E%+F%+T%+V\", t1, t1, t1, t1, t1, t1);\n+  cxxdiag (\"%+#A%+#D%+#E%+#F%+#T%+#V\", t1, t1, t1, t1, t1, t1);\n+  cxxdiag (\"%C%L%O%P%Q\", i, i, i, i, i);\n+\n+  /* Bad stuff with extensions.  */\n+  diag (\"%m\", i); /* { dg-warning \"format\" \"extra arg\" } */\n+  cdiag (\"%m\", i); /* { dg-warning \"format\" \"extra arg\" } */\n+  cxxdiag (\"%m\", i); /* { dg-warning \"format\" \"extra arg\" } */\n+  diag (\"%#m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cdiag (\"%#m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cxxdiag (\"%#m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  diag (\"%+m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cdiag (\"%+m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cxxdiag (\"%+m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  diag (\"%H\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  cdiag (\"%H\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  cxxdiag (\"%H\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  diag (\"%H\", i); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cdiag (\"%H\", i); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cxxdiag (\"%H\", i); /* { dg-warning \"format\" \"wrong arg\" } */\n+  diag (\"%H\", p); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cdiag (\"%H\", p); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cxxdiag (\"%H\", p); /* { dg-warning \"format\" \"wrong arg\" } */\n+  diag (\"%#H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cdiag (\"%#H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cxxdiag (\"%#H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  diag (\"%+H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cdiag (\"%+H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cxxdiag (\"%+H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  diag (\"%D\", t1); /* { dg-warning \"format\" \"bogus tree\" } */\n+  cdiag (\"%A\", t1); /* { dg-warning \"format\" \"bogus tree\" } */\n+  cdiag (\"%#D\", t1); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cdiag (\"%+D\", t1); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cxxdiag (\"%C\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  cxxdiag (\"%C\", l); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cxxdiag (\"%C\", i, i); /* { dg-warning \"format\" \"extra arg\" } */\n+  cxxdiag (\"%#C\", i); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cxxdiag (\"%+C\", i); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  cdiag (\"%D\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  cxxdiag (\"%D\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  cdiag (\"%D\", i); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cxxdiag (\"%D\", i); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cdiag (\"%D\", t1, t1); /* { dg-warning \"format\" \"extra arg\" } */\n+  cxxdiag (\"%D\", t1, t1); /* { dg-warning \"format\" \"extra arg\" } */\n+\n+  /* Standard specifiers not accepted in the diagnostic framework.  */\n+  diag (\"%X\\n\", u); /* { dg-warning \"format\" \"HEX\" } */\n+  diag (\"%f\\n\", d); /* { dg-warning \"format\" \"float\" } */\n+  diag (\"%e\\n\", d); /* { dg-warning \"format\" \"float\" } */\n+  diag (\"%E\\n\", d); /* { dg-warning \"format\" \"float\" } */\n+  diag (\"%g\\n\", d); /* { dg-warning \"format\" \"float\" } */\n+  diag (\"%G\\n\", d); /* { dg-warning \"format\" \"float\" } */\n+  diag (\"%n\\n\", n); /* { dg-warning \"format\" \"counter\" } */\n+  diag (\"%hd\\n\", i); /* { dg-warning \"format\" \"conversion\" } */\n+\n+  /* Various tests of bad argument types.  */\n+  diag (\"%-d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%-d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%-d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"% d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"% d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"% d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%#o\", u); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%#o\", u); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%#o\", u); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%0d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%0d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%0d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%08d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%08d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%08d\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%+d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%+d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%+d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%3d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%3d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%3d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%-3d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%-3d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%-3d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%.7d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%.7d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%.7d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%+9.4d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%+9.4d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%+9.4d\\n\", i); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%.3ld\\n\", l); /* { dg-warning \"format\" \"bad flag\" } */\n+  cdiag (\"%.3ld\\n\", l); /* { dg-warning \"format\" \"bad flag\" } */\n+  cxxdiag (\"%.3ld\\n\", l); /* { dg-warning \"format\" \"bad flag\" } */\n+  diag (\"%d %lu\\n\", i, ul);\n+  diag (\"%d\", l); /* { dg-warning \"format\" \"bad argument types\" } */\n+  diag (\"%wd\", l); /* { dg-warning \"format\" \"bad argument types\" } */\n+  diag (\"%d\", ll); /* { dg-warning \"format\" \"bad argument types\" } */\n+  diag (\"%*s\", i, s); /* { dg-warning \"format\" \"bad * argument types\" } */\n+  diag (\"%*.*s\", i, i, s); /* { dg-warning \"format\" \"bad * argument types\" } */\n+  diag (\"%*d\\n\", i1, i); /* { dg-warning \"format\" \"bad * argument types\" } */\n+  diag (\"%.*d\\n\", i2, i); /* { dg-warning \"format\" \"bad * argument types\" } */\n+  diag (\"%*.*ld\\n\", i1, i2, l); /* { dg-warning \"format\" \"bad * argument types\" } */\n+  diag (\"%ld\", i); /* { dg-warning \"format\" \"bad argument types\" } */\n+  diag (\"%s\", n); /* { dg-warning \"format\" \"bad argument types\" } */\n+\n+  /* Wrong number of arguments.  */\n+  diag (\"%d%d\", i); /* { dg-warning \"arguments\" \"wrong number of args\" } */\n+  diag (\"%d\", i, i); /* { dg-warning \"arguments\" \"wrong number of args\" } */\n+  /* Miscellaneous bogus constructions.  */\n+  diag (\"\"); /* { dg-warning \"zero-length\" \"warning for empty format\" } */\n+  diag (\"\\0\"); /* { dg-warning \"embedded\" \"warning for embedded NUL\" } */\n+  diag (\"%d\\0\", i); /* { dg-warning \"embedded\" \"warning for embedded NUL\" } */\n+  diag (\"%d\\0%d\", i, i); /* { dg-warning \"embedded|too many\" \"warning for embedded NUL\" } */\n+  diag (NULL); /* { dg-warning \"null\" \"null format string warning\" } */\n+  diag (\"%\"); /* { dg-warning \"trailing\" \"trailing % warning\" } */\n+  diag ((const char *)L\"foo\"); /* { dg-warning \"wide\" \"wide string\" } */\n+  diag (\"%s\", (char *)0); /* { dg-warning \"null\" \"%s with NULL\" } */\n+\n+  /* Make sure we still get warnings for regular printf.  */\n+  printf (\"%d\\n\", ll); /* { dg-warning \"format\" \"bad argument types\" } */\n+}"}]}