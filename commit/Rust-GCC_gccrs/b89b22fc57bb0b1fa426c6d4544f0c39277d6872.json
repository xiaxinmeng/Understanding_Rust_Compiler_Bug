{"sha": "b89b22fc57bb0b1fa426c6d4544f0c39277d6872", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg5YjIyZmM1N2JiMGIxZmE0MjZjNmQ0NTQ0ZjBjMzkyNzdkNjg3Mg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2013-07-08T09:18:50Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2013-07-08T09:18:50Z"}, "message": "s390.c: Rename cfun_set_fpr_bit to cfun_set_fpr_save and cfun_fpr_bit_p to cfun_fpr_save_p.\n\n2013-07-08  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* config/s390/s390.c: Rename cfun_set_fpr_bit to cfun_set_fpr_save\n\tand cfun_fpr_bit_p to cfun_fpr_save_p.\n\t(s390_frame_area, s390_register_info, s390_frame_info)\n\t(s390_emit_prologue, s390_emit_epilogue)\n\t(s390_conditional_register_usage): Use the *_REGNUM macros for FPR\n\tregister numbers.\n\t* config/s390/s390.h: Define *_REGNUM macros for floating point\n\tregister numbers.\n\nFrom-SVN: r200780", "tree": {"sha": "b266b8e8319960a0a1e2d39cd88737ed6f229849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b266b8e8319960a0a1e2d39cd88737ed6f229849"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b89b22fc57bb0b1fa426c6d4544f0c39277d6872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89b22fc57bb0b1fa426c6d4544f0c39277d6872", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89b22fc57bb0b1fa426c6d4544f0c39277d6872", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89b22fc57bb0b1fa426c6d4544f0c39277d6872/comments", "author": null, "committer": null, "parents": [{"sha": "07f398aa89a0cf285ebf8647342224907656371c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07f398aa89a0cf285ebf8647342224907656371c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07f398aa89a0cf285ebf8647342224907656371c"}], "stats": {"total": 134, "additions": 88, "deletions": 46}, "files": [{"sha": "3df6374835f653516b66c1e5526bc524185e1140", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89b22fc57bb0b1fa426c6d4544f0c39277d6872/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89b22fc57bb0b1fa426c6d4544f0c39277d6872/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b89b22fc57bb0b1fa426c6d4544f0c39277d6872", "patch": "@@ -1,3 +1,14 @@\n+2013-07-08  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* config/s390/s390.c: Rename cfun_set_fpr_bit to cfun_set_fpr_save\n+\tand cfun_fpr_bit_p to cfun_fpr_save_p.\n+\t(s390_frame_area, s390_register_info, s390_frame_info)\n+\t(s390_emit_prologue, s390_emit_epilogue)\n+\t(s390_conditional_register_usage): Use the *_REGNUM macros for FPR\n+\tregister numbers.\n+\t* config/s390/s390.h: Define *_REGNUM macros for floating point\n+\tregister numbers.\n+\n 2013-07-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* Makefile.in (tree-ssa-reassoc.o): Add dependency on $(PARAMS_H)."}, {"sha": "c8b1df86cb5133af824c17ebc46b2972dd0e5f75", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89b22fc57bb0b1fa426c6d4544f0c39277d6872/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89b22fc57bb0b1fa426c6d4544f0c39277d6872/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b89b22fc57bb0b1fa426c6d4544f0c39277d6872", "patch": "@@ -379,10 +379,10 @@ struct GTY(()) machine_function\n #define cfun_save_high_fprs_p (!!cfun_frame_layout.high_fprs)\n #define cfun_gprs_save_area_size ((cfun_frame_layout.last_save_gpr_slot -           \\\n   cfun_frame_layout.first_save_gpr_slot + 1) * UNITS_PER_LONG)\n-#define cfun_set_fpr_bit(BITNUM) (cfun->machine->frame_layout.fpr_bitmap |=    \\\n-  (1 << (BITNUM)))\n-#define cfun_fpr_bit_p(BITNUM) (!!(cfun->machine->frame_layout.fpr_bitmap &    \\\n-  (1 << (BITNUM))))\n+#define cfun_set_fpr_save(REGNO) (cfun->machine->frame_layout.fpr_bitmap |=    \\\n+  (1 << (REGNO - F0_REGNUM)))\n+#define cfun_fpr_save_p(REGNO) (!!(cfun->machine->frame_layout.fpr_bitmap &    \\\n+  (1 << (REGNO - F0_REGNUM))))\n \n /* Number of GPRs and FPRs used for argument passing.  */\n #define GP_ARG_NUM_REG 5\n@@ -7451,7 +7451,6 @@ static void\n s390_frame_area (int *area_bottom, int *area_top)\n {\n   int b, t;\n-  int i;\n \n   b = INT_MAX;\n   t = INT_MIN;\n@@ -7472,13 +7471,18 @@ s390_frame_area (int *area_bottom, int *area_top)\n     }\n \n   if (!TARGET_64BIT)\n-    for (i = 2; i < 4; i++)\n-      if (cfun_fpr_bit_p (i))\n+    {\n+      if (cfun_fpr_save_p (F4_REGNUM))\n \t{\n-\t  b = MIN (b, cfun_frame_layout.f4_offset + (i - 2) * 8);\n-\t  t = MAX (t, cfun_frame_layout.f4_offset + (i - 1) * 8);\n+\t  b = MIN (b, cfun_frame_layout.f4_offset);\n+\t  t = MAX (t, cfun_frame_layout.f4_offset + 8);\n \t}\n-\n+      if (cfun_fpr_save_p (F6_REGNUM))\n+\t{\n+\t  b = MIN (b, cfun_frame_layout.f4_offset + 8);\n+\t  t = MAX (t, cfun_frame_layout.f4_offset + 16);\n+\t}\n+    }\n   *area_bottom = b;\n   *area_top = t;\n }\n@@ -7505,7 +7509,7 @@ s390_register_info (int clobbered_regs[])\n       cfun_frame_layout.fpr_bitmap = 0;\n       cfun_frame_layout.high_fprs = 0;\n       if (TARGET_64BIT)\n-\tfor (i = 24; i < 32; i++)\n+\tfor (i = F8_REGNUM; i <= F15_REGNUM; i++)\n \t  /* During reload we have to use the df_regs_ever_live infos\n \t     since reload is marking FPRs used as spill slots there as\n \t     live before actually making the code changes.  Without\n@@ -7517,7 +7521,7 @@ s390_register_info (int clobbered_regs[])\n \t\t       || crtl->saves_all_registers)))\n \t      && !global_regs[i])\n \t    {\n-\t      cfun_set_fpr_bit (i - 16);\n+\t      cfun_set_fpr_save (i);\n \t      cfun_frame_layout.high_fprs++;\n \t    }\n     }\n@@ -7644,14 +7648,17 @@ s390_register_info (int clobbered_regs[])\n \t    min_fpr = 0;\n \n \t  for (i = min_fpr; i < max_fpr; i++)\n-\t    cfun_set_fpr_bit (i);\n+\t    cfun_set_fpr_save (i + F0_REGNUM);\n \t}\n     }\n \n   if (!TARGET_64BIT)\n-    for (i = 2; i < 4; i++)\n-      if (df_regs_ever_live_p (i + 16) && !global_regs[i + 16])\n-\tcfun_set_fpr_bit (i);\n+    {\n+      if (df_regs_ever_live_p (F4_REGNUM) && !global_regs[F4_REGNUM])\n+\tcfun_set_fpr_save (F4_REGNUM);\n+      if (df_regs_ever_live_p (F6_REGNUM) && !global_regs[F6_REGNUM])\n+\tcfun_set_fpr_save (F6_REGNUM);\n+    }\n }\n \n /* Fill cfun->machine with info about frame of current function.  */\n@@ -7687,11 +7694,13 @@ s390_frame_info (void)\n \t{\n \t  cfun_frame_layout.f4_offset\n \t    = (cfun_frame_layout.gprs_offset\n-\t       - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n+\t       - 8 * (cfun_fpr_save_p (F4_REGNUM)\n+\t\t      + cfun_fpr_save_p (F6_REGNUM)));\n \n \t  cfun_frame_layout.f0_offset\n \t    = (cfun_frame_layout.f4_offset\n-\t       - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n+\t       - 8 * (cfun_fpr_save_p (F0_REGNUM)\n+\t\t      + cfun_fpr_save_p (F2_REGNUM)));\n \t}\n       else\n \t{\n@@ -7700,22 +7709,26 @@ s390_frame_info (void)\n \t  cfun_frame_layout.f0_offset\n \t    = ((cfun_frame_layout.gprs_offset\n \t\t& ~(STACK_BOUNDARY / BITS_PER_UNIT - 1))\n-\t       - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n+\t       - 8 * (cfun_fpr_save_p (F0_REGNUM)\n+\t\t      + cfun_fpr_save_p (F2_REGNUM)));\n \n \t  cfun_frame_layout.f4_offset\n \t    = (cfun_frame_layout.f0_offset\n-\t       - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n+\t       - 8 * (cfun_fpr_save_p (F4_REGNUM)\n+\t\t      + cfun_fpr_save_p (F6_REGNUM)));\n \t}\n     }\n   else /* no backchain */\n     {\n       cfun_frame_layout.f4_offset\n \t= (STACK_POINTER_OFFSET\n-\t   - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n+\t   - 8 * (cfun_fpr_save_p (F4_REGNUM)\n+\t\t  + cfun_fpr_save_p (F6_REGNUM)));\n \n       cfun_frame_layout.f0_offset\n \t= (cfun_frame_layout.f4_offset\n-\t   - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n+\t   - 8 * (cfun_fpr_save_p (F0_REGNUM)\n+\t\t  + cfun_fpr_save_p (F2_REGNUM)));\n \n       cfun_frame_layout.gprs_offset\n \t= cfun_frame_layout.f0_offset - cfun_gprs_save_area_size;\n@@ -7747,8 +7760,8 @@ s390_frame_info (void)\n \n       cfun_frame_layout.frame_size += cfun_frame_layout.high_fprs * 8;\n \n-      for (i = 0; i < 8; i++)\n-\tif (cfun_fpr_bit_p (i))\n+      for (i = F0_REGNUM; i <= F7_REGNUM; i++)\n+\tif (cfun_fpr_save_p (i))\n \t  cfun_frame_layout.frame_size += 8;\n \n       cfun_frame_layout.frame_size += cfun_gprs_save_area_size;\n@@ -8453,11 +8466,11 @@ s390_emit_prologue (void)\n   offset = cfun_frame_layout.f0_offset;\n \n   /* Save f0 and f2.  */\n-  for (i = 0; i < 2; i++)\n+  for (i = F0_REGNUM; i <= F0_REGNUM + 1; i++)\n     {\n-      if (cfun_fpr_bit_p (i))\n+      if (cfun_fpr_save_p (i))\n \t{\n-\t  save_fpr (stack_pointer_rtx, offset, i + 16);\n+\t  save_fpr (stack_pointer_rtx, offset, i);\n \t  offset += 8;\n \t}\n       else if (!TARGET_PACKED_STACK)\n@@ -8466,16 +8479,16 @@ s390_emit_prologue (void)\n \n   /* Save f4 and f6.  */\n   offset = cfun_frame_layout.f4_offset;\n-  for (i = 2; i < 4; i++)\n+  for (i = F4_REGNUM; i <= F4_REGNUM + 1; i++)\n     {\n-      if (cfun_fpr_bit_p (i))\n+      if (cfun_fpr_save_p (i))\n \t{\n-\t  insn = save_fpr (stack_pointer_rtx, offset, i + 16);\n+\t  insn = save_fpr (stack_pointer_rtx, offset, i);\n \t  offset += 8;\n \n \t  /* If f4 and f6 are call clobbered they are saved due to stdargs and\n \t     therefore are not frame related.  */\n-\t  if (!call_really_used_regs[i + 16])\n+\t  if (!call_really_used_regs[i])\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else if (!TARGET_PACKED_STACK)\n@@ -8489,20 +8502,20 @@ s390_emit_prologue (void)\n       offset = (cfun_frame_layout.f8_offset\n \t\t+ (cfun_frame_layout.high_fprs - 1) * 8);\n \n-      for (i = 15; i > 7 && offset >= 0; i--)\n-\tif (cfun_fpr_bit_p (i))\n+      for (i = F15_REGNUM; i >= F8_REGNUM && offset >= 0; i--)\n+\tif (cfun_fpr_save_p (i))\n \t  {\n-\t    insn = save_fpr (stack_pointer_rtx, offset, i + 16);\n+\t    insn = save_fpr (stack_pointer_rtx, offset, i);\n \n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \t    offset -= 8;\n \t  }\n       if (offset >= cfun_frame_layout.f8_offset)\n-\tnext_fpr = i + 16;\n+\tnext_fpr = i;\n     }\n \n   if (!TARGET_PACKED_STACK)\n-    next_fpr = cfun_save_high_fprs_p ? 31 : 0;\n+    next_fpr = cfun_save_high_fprs_p ? F15_REGNUM : 0;\n \n   if (flag_stack_usage_info)\n     current_function_static_stack_size = cfun_frame_layout.frame_size;\n@@ -8647,8 +8660,8 @@ s390_emit_prologue (void)\n \n       offset = 0;\n \n-      for (i = 24; i <= next_fpr; i++)\n-\tif (cfun_fpr_bit_p (i - 16))\n+      for (i = F8_REGNUM; i <= next_fpr; i++)\n+\tif (cfun_fpr_save_p (i))\n \t  {\n \t    rtx addr = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t      cfun_frame_layout.frame_size\n@@ -8777,9 +8790,9 @@ s390_emit_epilogue (bool sibcall)\n       if (cfun_save_high_fprs_p)\n \t{\n \t  next_offset = cfun_frame_layout.f8_offset;\n-\t  for (i = 24; i < 32; i++)\n+\t  for (i = F8_REGNUM; i <= F15_REGNUM; i++)\n \t    {\n-\t      if (cfun_fpr_bit_p (i - 16))\n+\t      if (cfun_fpr_save_p (i))\n \t\t{\n \t\t  restore_fpr (frame_pointer,\n \t\t\t       offset + next_offset, i);\n@@ -8795,9 +8808,10 @@ s390_emit_epilogue (bool sibcall)\n   else\n     {\n       next_offset = cfun_frame_layout.f4_offset;\n-      for (i = 18; i < 20; i++)\n+      /* f4, f6 */\n+      for (i = F4_REGNUM; i <= F4_REGNUM + 1; i++)\n \t{\n-\t  if (cfun_fpr_bit_p (i - 16))\n+\t  if (cfun_fpr_save_p (i))\n \t    {\n \t      restore_fpr (frame_pointer,\n \t\t\t   offset + next_offset, i);\n@@ -10504,18 +10518,18 @@ s390_conditional_register_usage (void)\n     }\n   if (TARGET_64BIT)\n     {\n-      for (i = 24; i < 32; i++)\n+      for (i = F8_REGNUM; i <= F15_REGNUM; i++)\n \tcall_used_regs[i] = call_really_used_regs[i] = 0;\n     }\n   else\n     {\n-      for (i = 18; i < 20; i++)\n-\tcall_used_regs[i] = call_really_used_regs[i] = 0;\n+      call_used_regs[F4_REGNUM] = call_really_used_regs[F4_REGNUM] = 0;\n+      call_used_regs[F6_REGNUM] = call_really_used_regs[F6_REGNUM] = 0;\n     }\n \n   if (TARGET_SOFT_FLOAT)\n     {\n-      for (i = 16; i < 32; i++)\n+      for (i = F0_REGNUM; i <= F15_REGNUM; i++)\n \tcall_used_regs[i] = fixed_regs[i] = 1;\n     }\n }"}, {"sha": "21c55f164bbeef9e0cefddc8a74b5e8eac7a51b2", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89b22fc57bb0b1fa426c6d4544f0c39277d6872/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89b22fc57bb0b1fa426c6d4544f0c39277d6872/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=b89b22fc57bb0b1fa426c6d4544f0c39277d6872", "patch": "@@ -477,6 +477,23 @@ enum reg_class\n   { 0xffffffff, 0x0000003f },\t/* ALL_REGS */\t\t\\\n }\n \n+#define F0_REGNUM  16\n+#define F1_REGNUM  20\n+#define F2_REGNUM  17\n+#define F3_REGNUM  21\n+#define F4_REGNUM  18\n+#define F5_REGNUM  22\n+#define F6_REGNUM  19\n+#define F7_REGNUM  23\n+#define F8_REGNUM  24\n+#define F9_REGNUM  25\n+#define F10_REGNUM 26\n+#define F11_REGNUM 27\n+#define F12_REGNUM 28\n+#define F13_REGNUM 29\n+#define F14_REGNUM 30\n+#define F15_REGNUM 31\n+\n /* In some case register allocation order is not enough for IRA to\n    generate a good code.  The following macro (if defined) increases\n    cost of REGNO for a pseudo approximately by pseudo usage frequency"}]}