{"sha": "a198145843f0b16e59069cb2da55c47a0a9bc2b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE5ODE0NTg0M2YwYjE2ZTU5MDY5Y2IyZGE1NWM0N2EwYTliYzJiOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-24T20:30:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-24T20:30:21Z"}, "message": "ipa-utils.h (polymorphic_call_context): Add metdhos dump, debug and clear_outer_type.\n\n\n\t* ipa-utils.h (polymorphic_call_context): Add\n\tmetdhos dump, debug and clear_outer_type.\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Simplify.\n\t(ipa_polymorphic_call_context::clear_outer_type): New method.\n\t* ipa-prop.c (ipa_analyze_call_uses): Do not overwrite offset.\n\t* ipa-devirt.c (types_odr_comparable): New function.\n\t(types_must_be_same_for_odr): New function.\n\t(odr_subtypes_equivalent_p): Simplify.\n\t(possible_placement_new): Break out from ...\n\t(ipa_polymorphic_call_context::restrict_to_inner_type): ... here;\n\tbe more cuatious about returning false in cases the context may be\n\tvalid in derived type or via placement new.\n\t(contains_type_p): Clear maybe_derived_type\n\t(ipa_polymorphic_call_context::dump): New method.\n\t(ipa_polymorphic_call_context::debug): New method.\n\t(ipa_polymorphic_call_context::set_by_decl): Cleanup comment.\n\t(ipa_polymorphic_call_context::set_by_invariant): Simplify.\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Simplify.\n\t(possible_polymorphic_call_targets): Trust context.restrict_to_inner_class\n\tto suceed on all valid cases; remove confused sanity check.\n\t(dump_possible_polymorphic_call_targets): Simplify.\n\nFrom-SVN: r215569", "tree": {"sha": "fb085630166aa196f47f51404bc1b7f3f2c51098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb085630166aa196f47f51404bc1b7f3f2c51098"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a198145843f0b16e59069cb2da55c47a0a9bc2b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a198145843f0b16e59069cb2da55c47a0a9bc2b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a198145843f0b16e59069cb2da55c47a0a9bc2b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a198145843f0b16e59069cb2da55c47a0a9bc2b9/comments", "author": null, "committer": null, "parents": [{"sha": "c6195f588b1b8980b07d53394edaaa2cd6807588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6195f588b1b8980b07d53394edaaa2cd6807588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6195f588b1b8980b07d53394edaaa2cd6807588"}], "stats": {"total": 438, "additions": 314, "deletions": 124}, "files": [{"sha": "666f1a61cdc57ce690e56e1b56f902fa4fbbbf84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a198145843f0b16e59069cb2da55c47a0a9bc2b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a198145843f0b16e59069cb2da55c47a0a9bc2b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a198145843f0b16e59069cb2da55c47a0a9bc2b9", "patch": "@@ -1,3 +1,27 @@\n+2014-09-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.h (polymorphic_call_context): Add\n+\tmetdhos dump, debug and clear_outer_type.\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Simplify.\n+\t(ipa_polymorphic_call_context::clear_outer_type): New method.\n+\t* ipa-prop.c (ipa_analyze_call_uses): Do not overwrite offset.\n+\t* ipa-devirt.c (types_odr_comparable): New function.\n+\t(types_must_be_same_for_odr): New function.\n+\t(odr_subtypes_equivalent_p): Simplify.\n+\t(possible_placement_new): Break out from ...\n+\t(ipa_polymorphic_call_context::restrict_to_inner_type): ... here;\n+\tbe more cuatious about returning false in cases the context may be\n+\tvalid in derived type or via placement new.\n+\t(contains_type_p): Clear maybe_derived_type\n+\t(ipa_polymorphic_call_context::dump): New method.\n+\t(ipa_polymorphic_call_context::debug): New method.\n+\t(ipa_polymorphic_call_context::set_by_decl): Cleanup comment.\n+\t(ipa_polymorphic_call_context::set_by_invariant): Simplify.\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Simplify.\n+\t(possible_polymorphic_call_targets): Trust context.restrict_to_inner_class\n+\tto suceed on all valid cases; remove confused sanity check.\n+\t(dump_possible_polymorphic_call_targets): Simplify.\n+\n 2014-09-24  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* cgraph.h, dbxout.c, dwarfout2.c, gimple-fold.c,"}, {"sha": "afa263f1e7f156a600276de8626b186eb99c1c2a", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 268, "deletions": 116, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a198145843f0b16e59069cb2da55c47a0a9bc2b9/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a198145843f0b16e59069cb2da55c47a0a9bc2b9/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=a198145843f0b16e59069cb2da55c47a0a9bc2b9", "patch": "@@ -452,6 +452,34 @@ types_same_for_odr (const_tree type1, const_tree type2)\n \t  == DECL_ASSEMBLER_NAME (TYPE_NAME (type2)));\n }\n \n+/* Return true if we can decide on ODR equivalency.\n+\n+   In non-LTO it is always decide, in LTO however it depends in the type has\n+   ODR info attached.  */\n+\n+static bool\n+types_odr_comparable (tree t1, tree t2)\n+{\n+  return (!in_lto_p\n+\t  || main_odr_variant (t1) == main_odr_variant (t2)\n+\t  || (odr_type_p (t1) && odr_type_p (t2))\n+\t  || (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE\n+\t      && TYPE_BINFO (t1) && TYPE_BINFO (t2)\n+\t      && polymorphic_type_binfo_p (TYPE_BINFO (t1))\n+\t      && polymorphic_type_binfo_p (TYPE_BINFO (t2))));\n+}\n+\n+/* Return true if T1 and T2 are ODR equivalent.  If ODR equivalency is not\n+   known, be conservative and return false.  */\n+\n+static bool\n+types_must_be_same_for_odr (tree t1, tree t2)\n+{\n+  if (types_odr_comparable (t1, t2))\n+    return types_same_for_odr (t1, t2);\n+  else\n+    return main_odr_variant (t1) == main_odr_variant (t2);\n+}\n \n /* Compare types T1 and T2 and return true if they are\n    equivalent.  */\n@@ -528,11 +556,7 @@ odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<type_pair,pair_traits> *vi\n   /* For ODR types be sure to compare their names.\n      To support -wno-odr-type-merging we allow one type to be non-ODR\n      and other ODR even though it is a violation.  */\n-  if ((odr_type_p (t1) && odr_type_p (t2))\n-      || (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE\n-          && TYPE_BINFO (t1) && TYPE_BINFO (t2)\n-          && polymorphic_type_binfo_p (TYPE_BINFO (t1))\n-          && polymorphic_type_binfo_p (TYPE_BINFO (t2))))\n+  if (types_odr_comparable (t1, t2))\n     {\n       if (!types_same_for_odr (t1, t2))\n         return false;\n@@ -1325,8 +1349,8 @@ get_odr_type (tree type, bool insert)\n   type = main_odr_variant (type);\n \n   hash = hash_type_name (type);\n-  slot\n-     = odr_hash->find_slot_with_hash (type, hash, insert ? INSERT : NO_INSERT);\n+  slot = odr_hash->find_slot_with_hash (type, hash,\n+\t\t\t\t\tinsert ? INSERT : NO_INSERT);\n   if (!slot)\n     return NULL;\n \n@@ -1979,12 +2003,37 @@ contains_polymorphic_type_p (const_tree type)\n   return false;\n }\n \n+/* Return true if it seems valid to use placement new to build EXPECTED_TYPE\n+   at possition CUR_OFFSET within TYPE.  \n+\n+   POD can be changed to an instance of a polymorphic type by\n+   placement new.  Here we play safe and assume that any\n+   non-polymorphic type is POD.  */\n+bool\n+possible_placement_new (tree type, tree expected_type,\n+\t\t\tHOST_WIDE_INT cur_offset)\n+{\n+  return ((TREE_CODE (type) != RECORD_TYPE\n+\t   || !TYPE_BINFO (type)\n+\t   || cur_offset >= BITS_PER_WORD\n+\t   || !polymorphic_type_binfo_p (TYPE_BINFO (type)))\n+\t  && (!TYPE_SIZE (type)\n+\t      || !tree_fits_shwi_p (TYPE_SIZE (type))\n+\t      || (cur_offset\n+\t\t  + (expected_type ? tree_to_uhwi (TYPE_SIZE (expected_type))\n+\t\t     : 1)\n+\t\t  <= tree_to_uhwi (TYPE_SIZE (type)))));\n+}\n+\n /* THIS->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n    is contained at THIS->OFFSET.  Walk the memory representation of\n    THIS->OUTER_TYPE and find the outermost class type that match\n    EXPECTED_TYPE or contain EXPECTED_TYPE as a base.  Update THIS\n    to represent it.\n \n+   If EXPECTED_TYPE is NULL, just find outermost polymorphic type with\n+   virtual table present at possition OFFSET.\n+\n    For example when THIS represents type\n    class A\n      {\n@@ -2005,88 +2054,136 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n   tree type = outer_type;\n   HOST_WIDE_INT cur_offset = offset;\n   bool speculative = false;\n-  bool speculation_valid = false;\n-  bool valid = false;\n \n+ /* Update OUTER_TYPE to match EXPECTED_TYPE if it is not set.  */\n  if (!outer_type)\n    {\n-     type = outer_type = expected_type;\n-     offset = cur_offset = 0;\n+     clear_outer_type (expected_type);\n+     type = expected_type;\n+     cur_offset = 0;\n    }\n-\n- if (speculative_outer_type == outer_type\n-     && (!maybe_derived_type\n-\t || speculative_maybe_derived_type))\n+ /* See if OFFSET points inside OUTER_TYPE.  If it does not, we know\n+    that the context is either invalid, or the instance type must be\n+    derived from OUTER_TYPE.\n+\n+    Because the instance type may contain field whose type is of OUTER_TYPE,\n+    we can not derive any effective information about it.\n+\n+    TODO: In the case we know all derrived types, we can definitely do better\n+    here.  */\n+  else if (TYPE_SIZE (outer_type)\n+\t   && tree_fits_shwi_p (TYPE_SIZE (outer_type))\n+\t   && tree_to_shwi (TYPE_SIZE (outer_type)) >= 0\n+\t   && tree_to_shwi (TYPE_SIZE (outer_type)) <= offset)\n    {\n-      speculative_outer_type = NULL;\n-      speculative_offset = 0;\n-      speculative_maybe_derived_type = false;\n+     clear_outer_type (expected_type);\n+     type = expected_type;\n+     cur_offset = 0;\n+\n+     /* If derived type is not allowed, we know that the context is invalid.  */\n+     if (!maybe_derived_type)\n+       {\n+\t clear_speculation ();\n+\t invalid = true;\n+\t return false;\n+       }\n    }\n \n-  /* See if speculative type seem to be derrived from outer_type.\n-     Then speculation is valid only if it really is a derivate and derived types\n-     are allowed.  \n-\n-     The test does not really look for derivate, but also accepts the case where\n-     outer_type is a field of speculative_outer_type.  In this case eiter\n-     MAYBE_DERIVED_TYPE is false and we have full non-speculative information or\n-     the loop bellow will correctly update SPECULATIVE_OUTER_TYPE\n-     and SPECULATIVE_MAYBE_DERIVED_TYPE.  */\n-  if (speculative_outer_type\n-      && speculative_offset >= offset\n-      && contains_type_p (speculative_outer_type,\n-\t\t\t  offset - speculative_offset,\n-\t\t\t  outer_type))\n-    speculation_valid = maybe_derived_type;\n+  if (speculative_outer_type)\n+    {\n+      /* Short cirucit the busy work bellow and give up on case when speculation\n+\t is obviously the same as outer_type.  */\n+      if ((!maybe_derived_type\n+\t   || speculative_maybe_derived_type)\n+\t  && types_must_be_same_for_odr (speculative_outer_type, outer_type))\n+\tclear_speculation ();\n+\n+      /* See if SPECULATIVE_OUTER_TYPE is contained in or derived from OUTER_TYPE.\n+\t In this case speculation is valid only if derived types are allowed. \n+\n+\t The test does not really look for derivate, but also accepts the case where\n+\t outer_type is a field of speculative_outer_type.  In this case eiter\n+\t MAYBE_DERIVED_TYPE is false and we have full non-speculative information or\n+\t the loop bellow will correctly update SPECULATIVE_OUTER_TYPE\n+\t and SPECULATIVE_MAYBE_DERIVED_TYPE.  */\n+      else if (speculative_offset < offset\n+\t       || !contains_type_p (speculative_outer_type,\n+\t\t\t\t    speculative_offset - offset,\n+\t\t\t\t    outer_type)\n+\t       || !maybe_derived_type)\n+\tclear_speculation ();\n+    }\n   else\n+    /* Regularize things little bit and clear all the fields when no useful\n+       speculatin is known.  */\n     clear_speculation ();\n-\t\t\t       \n+\n+  if (!type)\n+    goto no_useful_type_info;\n+\n   /* Find the sub-object the constant actually refers to and mark whether it is\n      an artificial one (as opposed to a user-defined one).\n \n      This loop is performed twice; first time for outer_type and second time\n-     for speculative_outer_type.  The second iteration has SPECULATIVE set.  */\n+     for speculative_outer_type.  The second run has SPECULATIVE set.  */\n   while (true)\n     {\n       HOST_WIDE_INT pos, size;\n       tree fld;\n+      bool size_unknown;\n+\n+      /* If we do not know size of TYPE, we need to be more conservative\n+         about accepting cases where we can not find EXPECTED_TYPE.\n+\t Generally the types that do matter here are of constant size.\n+\t Size_unknown case should be very rare.  */\n+      if (TYPE_SIZE (type)\n+\t  && tree_fits_shwi_p (TYPE_SIZE (type))\n+\t  && tree_to_shwi (TYPE_SIZE (type)) >= 0)\n+\tsize_unknown = false;\n+      else\n+\tsize_unknown = true;\n \n       /* On a match, just return what we found.  */\n-      if (TREE_CODE (type) == TREE_CODE (expected_type)\n-\t  && (!in_lto_p\n-\t      || (TREE_CODE (type) == RECORD_TYPE\n-\t\t  && TYPE_BINFO (type)\n-\t\t  && polymorphic_type_binfo_p (TYPE_BINFO (type))))\n-\t  && types_same_for_odr (type, expected_type))\n+      if ((types_odr_comparable (type, expected_type)\n+\t   && types_same_for_odr (type, expected_type))\n+\t  || (!expected_type\n+\t      && TREE_CODE (type) == RECORD_TYPE\n+\t      && TYPE_BINFO (type)\n+\t      && polymorphic_type_binfo_p (TYPE_BINFO (type))))\n \t{\n \t  if (speculative)\n \t    {\n-\t      gcc_assert (speculation_valid);\n-\t      gcc_assert (valid);\n-\n \t      /* If we did not match the offset, just give up on speculation.  */\n \t      if (cur_offset != 0\n-\t\t  || (types_same_for_odr (speculative_outer_type,\n-\t\t\t\t\t  outer_type)\n+\t\t  /* Also check if speculation did not end up being same as\n+\t\t     non-speculation.  */\n+\t\t  || (types_must_be_same_for_odr (speculative_outer_type,\n+\t\t\t\t\t\t  outer_type)\n \t\t      && (maybe_derived_type\n \t\t\t  == speculative_maybe_derived_type)))\n \t\tclear_speculation ();\n \t      return true;\n \t    }\n \t  else\n \t    {\n+\t      /* If type is known to be final, do not worry about derived\n+\t\t types.  Testing it here may help us to avoid speculation.  */\n+\t      if (type_all_derivations_known_p (outer_type)\n+\t\t  && (TYPE_FINAL_P (outer_type)\n+\t\t      || (odr_hash\n+\t\t\t  && !get_odr_type (outer_type, true)->derived_types.length())))\n+\t\tmaybe_derived_type = false;\n+\n \t      /* Type can not contain itself on an non-zero offset.  In that case\n-\t\t just give up.  */\n+\t\t just give up.  Still accept the case where size is now known.\n+\t\t Either the second copy may appear past the end of type or within\n+\t\t the non-POD buffer located inside the variably sized type\n+\t\t itself.  */\n \t      if (cur_offset != 0)\n-\t\t{\n-\t\t  valid = false;\n-\t\t  goto give_up;\n-\t\t}\n-\t      valid = true;\n-\t      /* If speculation is not valid or we determined type precisely,\n-\t\t we are done.  */\n-\t      if (!speculation_valid\n-\t\t  || !maybe_derived_type)\n+\t\tgoto no_useful_type_info;\n+\t      /* If we determined type precisely or we have no clue on\n+ \t\t speuclation, we are done.  */\n+\t      if (!maybe_derived_type || !speculative_outer_type)\n \t\t{\n \t\t  clear_speculation ();\n \t          return true;\n@@ -2117,7 +2214,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t    }\n \n \t  if (!fld)\n-\t    goto give_up;\n+\t    goto no_useful_type_info;\n \n \t  type = TYPE_MAIN_VARIANT (TREE_TYPE (fld));\n \t  cur_offset -= pos;\n@@ -2149,8 +2246,20 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t      || !tree_fits_shwi_p (TYPE_SIZE (subtype))\n \t      || tree_to_shwi (TYPE_SIZE (subtype)) <= 0\n \t      || !contains_polymorphic_type_p (subtype))\n-\t    goto give_up;\n-\t  cur_offset = cur_offset % tree_to_shwi (TYPE_SIZE (subtype));\n+\t    goto no_useful_type_info;\n+\n+\t  HOST_WIDE_INT new_offset = cur_offset % tree_to_shwi (TYPE_SIZE (subtype));\n+\n+\t  /* We may see buffer for placement new.  In this case the expected type\n+\t     can be bigger than the subtype.  */\n+\t  if (TYPE_SIZE (subtype)\n+\t      && (cur_offset\n+\t\t  + (expected_type ? tree_to_uhwi (TYPE_SIZE (expected_type))\n+\t\t     : 0)\n+\t\t  > tree_to_uhwi (TYPE_SIZE (type))))\n+\t    goto no_useful_type_info;\n+\n+\t  cur_offset = new_offset;\n \t  type = subtype;\n \t  if (!speculative)\n \t    {\n@@ -2167,31 +2276,48 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t}\n       /* Give up on anything else.  */\n       else\n-\tgoto give_up;\n+\t{\n+no_useful_type_info:\n+\t  /* We found no way to embedd EXPECTED_TYPE in TYPE.\n+\t     We still permit two special cases - placement new and\n+\t     the case of variadic types containing themselves.  */\n+\t  if (!speculative\n+\t      && (size_unknown || !type\n+\t\t  || possible_placement_new (type, expected_type, cur_offset)))\n+\t    {\n+\t      /* In these weird cases we want to accept the context.\n+\t\t In non-speculative run we have no useful outer_type info\n+\t\t (TODO: we may eventually want to record upper bound on the\n+\t\t  type size that can be used to prune the walk),\n+\t\t but we still want to consider speculation that may\n+\t\t give useful info.  */\n+\t      if (!speculative)\n+\t\t{\n+\t\t  clear_outer_type (expected_type);\n+\t\t  if (speculative_outer_type)\n+\t\t    {\n+\t\t      speculative = true;\n+\t\t      type = speculative_outer_type;\n+\t\t      cur_offset = speculative_offset;\n+\t\t    }\n+\t\t  else\n+\t\t    return true;\n+\t\t}\n+\t      else\n+\t\tclear_speculation ();\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      clear_speculation ();\n+\t      if (speculative)\n+\t\treturn true;\n+\t      clear_outer_type (expected_type);\n+\t      invalid = true; \n+\t      return false;\n+\t    }\n+\t}\n     }\n-\n-  /* If we failed to find subtype we look for, give up and fall back to the\n-     most generic query.  */\n-give_up:\n-  clear_speculation ();\n-  if (valid)\n-    return true;\n-  outer_type = expected_type;\n-  offset = 0;\n-  maybe_derived_type = true;\n-  maybe_in_construction = true;\n-  /* POD can be changed to an instance of a polymorphic type by\n-     placement new.  Here we play safe and assume that any\n-     non-polymorphic type is POD.  */\n-  if ((TREE_CODE (type) != RECORD_TYPE\n-       || !TYPE_BINFO (type)\n-       || !polymorphic_type_binfo_p (TYPE_BINFO (type)))\n-      && (!TYPE_SIZE (type)\n-\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n-\t  || (cur_offset + tree_to_uhwi (TYPE_SIZE (expected_type)) <=\n-\t      tree_to_uhwi (TYPE_SIZE (type)))))\n-    return true;\n-  return false;\n }\n \n /* Return true if OUTER_TYPE contains OTR_TYPE at OFFSET.  */\n@@ -2203,6 +2329,7 @@ contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n   ipa_polymorphic_call_context context;\n   context.offset = offset;\n   context.outer_type = TYPE_MAIN_VARIANT (outer_type);\n+  context.maybe_derived_type = false;\n   return context.restrict_to_inner_class (otr_type);\n }\n \n@@ -2399,6 +2526,50 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n   return false;\n }\n \n+/* Dump human readable context to F.  */\n+\n+void\n+ipa_polymorphic_call_context::dump (FILE *f) const\n+{\n+  fprintf (f, \"    \");\n+  if (invalid)\n+    fprintf (f, \"Call is known to be undefined\\n\");\n+  else\n+    {\n+      if (!outer_type && !offset && !speculative_outer_type)\n+\tfprintf (f, \"Empty context\\n\");\n+      if (outer_type || offset)\n+\t{\n+\t  fprintf (f, \"Outer type:\");\n+\t  print_generic_expr (f, outer_type, TDF_SLIM);\n+\t  if (maybe_derived_type)\n+\t    fprintf (f, \" (or a derived type)\");\n+\t  if (maybe_in_construction)\n+\t    fprintf (f, \" (maybe in construction)\");\n+\t  fprintf (f, \" offset \"HOST_WIDE_INT_PRINT_DEC,\n+\t\t   offset);\n+\t}\n+      if (speculative_outer_type)\n+\t{\n+\t  fprintf (f, \" speculative outer type:\");\n+\t  print_generic_expr (f, speculative_outer_type, TDF_SLIM);\n+\t  if (speculative_maybe_derived_type)\n+\t    fprintf (f, \" (or a derived type)\");\n+\t  fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC,\n+\t\t   speculative_offset);\n+\t}\n+    }\n+  fprintf(f, \"\\n\");\n+}\n+\n+/* Print context to stderr.  */\n+\n+void\n+ipa_polymorphic_call_context::debug () const\n+{\n+  dump (stderr);\n+}\n+\n /* Proudce polymorphic call context for call method of instance\n    that is located within BASE (that is assumed to be a decl) at offset OFF. */\n \n@@ -2412,8 +2583,9 @@ ipa_polymorphic_call_context::set_by_decl (tree base, HOST_WIDE_INT off)\n   clear_speculation ();\n   /* Make very conservative assumption that all objects\n      may be in construction. \n-     TODO: ipa-prop already contains code to tell better. \n-     merge it later.  */\n+ \n+     It is up to caller to revisit this via\n+     get_dynamic_type or decl_maybe_in_construction_p.  */\n   maybe_in_construction = true;\n   maybe_derived_type = false;\n }\n@@ -2433,9 +2605,7 @@ ipa_polymorphic_call_context::set_by_invariant (tree cst,\n \n   invalid = false;\n   off = 0;\n-  outer_type = NULL;\n-  maybe_in_construction = true;\n-  maybe_derived_type = true;\n+  clear_outer_type (otr_type);\n \n   if (TREE_CODE (cst) != ADDR_EXPR)\n     return false;\n@@ -2448,10 +2618,7 @@ ipa_polymorphic_call_context::set_by_invariant (tree cst,\n   /* Only type inconsistent programs can have otr_type that is\n      not part of outer type.  */\n   if (otr_type && !contains_type_p (TREE_TYPE (base), off, otr_type))\n-    {\n-      invalid = true;\n-      return false;\n-    }\n+    return false;\n \n   set_by_decl (base, off);\n   return true;\n@@ -2512,10 +2679,7 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \n   /* Set up basic info in case we find nothing interesting in the analysis.  */\n   clear_speculation ();\n-  outer_type = TYPE_MAIN_VARIANT (otr_type);\n-  offset = 0;\n-  maybe_derived_type = true;\n-  maybe_in_construction = true;\n+  clear_outer_type (otr_type);\n   invalid = false;\n \n   /* Walk SSA for outer object.  */\n@@ -3489,18 +3653,21 @@ possible_polymorphic_call_targets (tree otr_type,\n   gcc_assert (!context.outer_type\n \t      || TYPE_MAIN_VARIANT (context.outer_type) == context.outer_type);\n \n-  /* Lookup the outer class type we want to walk.  */\n+  /* Lookup the outer class type we want to walk.\n+     If we fail to do so, the context is invalid.  */\n   if ((context.outer_type || context.speculative_outer_type)\n       && !context.restrict_to_inner_class (otr_type))\n     {\n+      fprintf (stderr, \"Invalid\\n\");\n       if (completep)\n-\t*completep = false;\n+\t*completep = true;\n       if (cache_token)\n \t*cache_token = NULL;\n       if (speculative_targetsp)\n \t*speculative_targetsp = 0;\n       return nodes;\n     }\n+  gcc_assert (!context.invalid);\n \n   /* Check that restrict_to_inner_class kept the main variant.  */\n   gcc_assert (!context.outer_type\n@@ -3652,10 +3819,7 @@ possible_polymorphic_call_targets (tree otr_type,\n   if (type_possibly_instantiated_p (outer_type->type))\n     maybe_record_node (nodes, target, &inserted, can_refer, &complete);\n   else\n-    {\n-      skipped = true;\n-      gcc_assert (in_lto_p || context.maybe_derived_type);\n-    }\n+    skipped = true;\n \n   if (binfo)\n     matched_vtables.add (BINFO_VTABLE (binfo));\n@@ -3789,20 +3953,8 @@ dump_possible_polymorphic_call_targets (FILE *f,\n   fprintf (f, \"  Targets of polymorphic call of type %i:\", type->id);\n   print_generic_expr (f, type->type, TDF_SLIM);\n   fprintf (f, \" token %i\\n\", (int)otr_token);\n-  if (ctx.outer_type || ctx.offset)\n-    {\n-      fprintf (f, \"    Contained in type:\");\n-      print_generic_expr (f, ctx.outer_type, TDF_SLIM);\n-      fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n-\t       ctx.offset);\n-    }\n-  if (ctx.speculative_outer_type)\n-    {\n-      fprintf (f, \"    Speculatively contained in type:\");\n-      print_generic_expr (f, ctx.speculative_outer_type, TDF_SLIM);\n-      fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n-\t       ctx.speculative_offset);\n-    }\n+\n+  ctx.dump (f);\n \n   fprintf (f, \"    %s%s%s%s\\n      \",\n \t   final ? \"This is a complete list.\" :"}, {"sha": "b65a1e21493ac261da4a76972f6ae9cf3db0cdcc", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a198145843f0b16e59069cb2da55c47a0a9bc2b9/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a198145843f0b16e59069cb2da55c47a0a9bc2b9/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=a198145843f0b16e59069cb2da55c47a0a9bc2b9", "patch": "@@ -2357,7 +2357,8 @@ ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n \n       if (context.get_dynamic_type (instance,\n \t\t\t\t    OBJ_TYPE_REF_OBJECT (target),\n-\t\t\t\t    otr_type, call))\n+\t\t\t\t    otr_type, call)\n+\t  && context.offset == cs->indirect_info->offset)\n \t{\n \t  gcc_assert (TREE_CODE (otr_type) == RECORD_TYPE);\n \t  cs->indirect_info->polymorphic = true;"}, {"sha": "409e4853858e69f5631f681ffd30a4535b120566", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a198145843f0b16e59069cb2da55c47a0a9bc2b9/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a198145843f0b16e59069cb2da55c47a0a9bc2b9/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=a198145843f0b16e59069cb2da55c47a0a9bc2b9", "patch": "@@ -83,9 +83,14 @@ class ipa_polymorphic_call_context {\n      containing EXPECTED_TYPE as base class.  */\n   bool restrict_to_inner_class (tree expected_type);\n \n+  /* Dump human readable context to F.  */\n+  void dump (FILE *f) const;\n+  void DEBUG_FUNCTION debug () const;\n+\n private:\n   void set_by_decl (tree, HOST_WIDE_INT);\n   bool set_by_invariant (tree, tree, HOST_WIDE_INT);\n+  void clear_outer_type (tree otr_type = NULL);\n };\n \n /* Build polymorphic call context for indirect call E.  */\n@@ -110,13 +115,8 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (cgraph_edge *e)\n inline\n ipa_polymorphic_call_context::ipa_polymorphic_call_context ()\n {\n-  offset = 0;\n-  speculative_offset = 0;\n-  outer_type = NULL;\n-  speculative_outer_type = NULL;\n-  maybe_in_construction = true;\n-  maybe_derived_type = true;\n-  speculative_maybe_derived_type = false;\n+  clear_speculation ();\n+  clear_outer_type ();\n   invalid = false;\n }\n \n@@ -130,6 +130,19 @@ ipa_polymorphic_call_context::clear_speculation ()\n   speculative_maybe_derived_type = false;\n }\n \n+/* Produce context specifying all derrived types of OTR_TYPE.\n+   If OTR_TYPE is NULL or type of the OBJ_TYPE_REF, the context is set\n+   to dummy \"I know nothing\" setting.  */\n+\n+inline void\n+ipa_polymorphic_call_context::clear_outer_type (tree otr_type)\n+{\n+  outer_type = otr_type ? TYPE_MAIN_VARIANT (otr_type) : NULL;\n+  offset = 0;\n+  maybe_derived_type = true;\n+  maybe_in_construction = true;\n+}\n+\n /* In ipa-utils.c  */\n void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);\n int ipa_reduced_postorder (struct cgraph_node **, bool, bool,"}]}