{"sha": "d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNiZmU0ZGVjYzJiYmJjZTA1ODVkZjc4MTRjNzkyMzQ4OGNiMWNiNQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-06-26T00:18:25Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-06-26T00:18:25Z"}, "message": "driver-i386.c (detect_caches_amd, [...]): Fix -Wc++-compat and/or -Wcast-qual warnings.\n\n\t* config/i386/driver-i386.c (detect_caches_amd,\n\tdetect_caches_intel, host_detect_local_cpu): Fix -Wc++-compat\n\tand/or -Wcast-qual warnings.\n\t*ggc-common.c (ggc_mark_roots, gt_pch_note_object,\n\tgt_pch_note_reorder, relocate_ptrs, write_pch_globals,\n\tgt_pch_save): Likewise.\n\t* ggc-page.c (push_depth, push_by_depth, alloc_anon, alloc_page,\n\tgt_ggc_m_S, clear_marks, ggc_pch_read): Likewise.\n\t* global.c (compute_regsets): Likewise.\n\t* graph.c (print_rtl_graph_with_bb, clean_graph_dump_file,\n\tfinish_graph_dump_file): Likewise.\n\t* haifa-sched.c (schedule_block, extend_h_i_d, extend_ready,\n\tunlink_bb_notes): Likewise.\n\t* integrate.c (get_hard_reg_initial_val): Likewise.\n\t* ipa-prop.c (ipa_push_func_to_list): Likewise.\n\t* ipa-struct-reorg.c (gen_var_name, gen_cluster_name): Likewise.\n\t* local-alloc.c (update_equiv_regs): Likewise.\n\t* loop-invariant.c (check_invariant_table_size,\n\thash_invariant_expr, eq_invariant_expr, find_or_insert_inv):\n\tLikewise.\n\t* loop-iv.c (check_iv_ref_table_size, analyzed_for_bivness_p,\n\taltered_reg_used, mark_altered): Likewise.\n\t* loop-unroll.c (si_info_eq, ve_info_eq, allocate_basic_variable,\n\tinsert_var_expansion_initialization,\n\tcombine_var_copies_in_loop_exit, apply_opt_in_copies,\n\trelease_var_copies): Likewise.\n\t* matrix-reorg.c (mat_acc_phi_hash, mat_acc_phi_eq, mtt_info_eq,\n\tanalyze_matrix_decl, add_allocation_site, analyze_transpose,\n\tanalyze_accesses_for_phi_node, check_var_notmodified_p,\n\tcheck_allocation_function, find_sites_in_func,\n\trecord_all_accesses_in_func, transform_access_sites,\n\ttransform_allocation_sites): Likewise.\n\t* omp-low.c (new_omp_region, create_omp_child_function_name,\n\tcheck_omp_nesting_restrictions, check_combined_parallel,\n\tlower_omp_2, diagnose_sb_1, diagnose_sb_2): Likewise.\n\t* optabs.c (no_conflict_move_test, gen_libfunc, gen_fp_libfunc,\n\tgen_intv_fp_libfunc, gen_interclass_conv_libfunc,\n\tgen_intraclass_conv_libfunc, set_optab_libfunc, set_conv_libfunc):\n\tLikewise.\n\t* opts-common.c (prune_options): Likewise.\n\t* opts.c (add_input_filename, print_filtered_help,\n\tget_option_state): Likewise.\n\t* params.c (add_params): Likewise.\n\t* passes.c (set_pass_for_id, next_pass_1,\n\tdo_per_function_toporder, pass_fini_dump_file): Likewise.\n\t* postreload.c (reload_cse_simplify_operands): Likewise.\n\t* predict.c (tree_predicted_by_p, tree_predict_edge,\n\tclear_bb_predictions, combine_predictions_for_bb): Likewise.\n\nFrom-SVN: r137134", "tree": {"sha": "8bec70e2b9f614f364abd830f6241a61d7d1d986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bec70e2b9f614f364abd830f6241a61d7d1d986"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/comments", "author": null, "committer": null, "parents": [{"sha": "04298b116a9a550e575224a07537e89461701016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04298b116a9a550e575224a07537e89461701016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04298b116a9a550e575224a07537e89461701016"}], "stats": {"total": 326, "additions": 195, "deletions": 131}, "files": [{"sha": "e080d76345dbe37db0a0e44640be08f8391e7f5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -1,3 +1,54 @@\n+2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* config/i386/driver-i386.c (detect_caches_amd,\n+\tdetect_caches_intel, host_detect_local_cpu): Fix -Wc++-compat\n+\tand/or -Wcast-qual warnings.\n+\t*ggc-common.c (ggc_mark_roots, gt_pch_note_object,\n+\tgt_pch_note_reorder, relocate_ptrs, write_pch_globals,\n+\tgt_pch_save): Likewise.\n+\t* ggc-page.c (push_depth, push_by_depth, alloc_anon, alloc_page,\n+\tgt_ggc_m_S, clear_marks, ggc_pch_read): Likewise.\n+\t* global.c (compute_regsets): Likewise.\n+\t* graph.c (print_rtl_graph_with_bb, clean_graph_dump_file,\n+\tfinish_graph_dump_file): Likewise.\n+\t* haifa-sched.c (schedule_block, extend_h_i_d, extend_ready,\n+\tunlink_bb_notes): Likewise.\n+\t* integrate.c (get_hard_reg_initial_val): Likewise.\n+\t* ipa-prop.c (ipa_push_func_to_list): Likewise.\n+\t* ipa-struct-reorg.c (gen_var_name, gen_cluster_name): Likewise.\n+\t* local-alloc.c (update_equiv_regs): Likewise.\n+\t* loop-invariant.c (check_invariant_table_size,\n+\thash_invariant_expr, eq_invariant_expr, find_or_insert_inv):\n+\tLikewise.\n+\t* loop-iv.c (check_iv_ref_table_size, analyzed_for_bivness_p,\n+\taltered_reg_used, mark_altered): Likewise.\n+\t* loop-unroll.c (si_info_eq, ve_info_eq, allocate_basic_variable,\n+\tinsert_var_expansion_initialization,\n+\tcombine_var_copies_in_loop_exit, apply_opt_in_copies,\n+\trelease_var_copies): Likewise.\n+\t* matrix-reorg.c (mat_acc_phi_hash, mat_acc_phi_eq, mtt_info_eq,\n+\tanalyze_matrix_decl, add_allocation_site, analyze_transpose,\n+\tanalyze_accesses_for_phi_node, check_var_notmodified_p,\n+\tcheck_allocation_function, find_sites_in_func,\n+\trecord_all_accesses_in_func, transform_access_sites,\n+\ttransform_allocation_sites): Likewise.\n+\t* omp-low.c (new_omp_region, create_omp_child_function_name,\n+\tcheck_omp_nesting_restrictions, check_combined_parallel,\n+\tlower_omp_2, diagnose_sb_1, diagnose_sb_2): Likewise.\n+\t* optabs.c (no_conflict_move_test, gen_libfunc, gen_fp_libfunc,\n+\tgen_intv_fp_libfunc, gen_interclass_conv_libfunc,\n+\tgen_intraclass_conv_libfunc, set_optab_libfunc, set_conv_libfunc):\n+\tLikewise.\n+\t* opts-common.c (prune_options): Likewise.\n+\t* opts.c (add_input_filename, print_filtered_help,\n+\tget_option_state): Likewise.\n+\t* params.c (add_params): Likewise.\n+\t* passes.c (set_pass_for_id, next_pass_1,\n+\tdo_per_function_toporder, pass_fini_dump_file): Likewise.\n+\t* postreload.c (reload_cse_simplify_operands): Likewise.\n+\t* predict.c (tree_predicted_by_p, tree_predict_edge,\n+\tclear_bb_predictions, combine_predictions_for_bb): Likewise.\n+\n 2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* ra.h (add_neighbor): Fix -Wc++-compat and/or -Wcast-qual"}, {"sha": "44845cd8c2e4182165bfe72214b76746a5fb97d6", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -70,15 +70,15 @@ decode_l2_cache (unsigned *l2_size, unsigned *l2_line, unsigned *l2_assoc)\n \n /* Returns the description of caches for an AMD processor.  */\n \n-static char *\n+static const char *\n detect_caches_amd (unsigned max_ext_level)\n {\n   unsigned eax, ebx, ecx, edx;\n   unsigned l1_sizekb, l1_line, l1_assoc;\n   unsigned l2_sizekb, l2_line, l2_assoc;\n \n   if (max_ext_level < 0x80000005)\n-    return (char *) \"\";\n+    return \"\";\n \n   __cpuid (0x80000005, eax, ebx, ecx, edx);\n \n@@ -282,15 +282,15 @@ decode_caches_intel (unsigned reg, unsigned *l1_sizekb, unsigned *l1_line,\n \n /* Returns the description of caches for an intel processor.  */\n \n-static char *\n+static const char *\n detect_caches_intel (unsigned max_level, unsigned max_ext_level)\n {\n   unsigned eax, ebx, ecx, edx;\n   unsigned l1_sizekb = 0, l1_line = 0, assoc = 0;\n   unsigned l2_sizekb = 0, l2_line = 0, l2_assoc = 0;\n \n   if (max_level < 2)\n-    return (char *) \"\";\n+    return \"\";\n \n   __cpuid (2, eax, ebx, ecx, edx);\n \n@@ -304,7 +304,7 @@ detect_caches_intel (unsigned max_level, unsigned max_ext_level)\n       &l2_sizekb, &l2_line, &l2_assoc);\n \n   if (!l1_sizekb)\n-    return (char *) \"\";\n+    return \"\";\n \n   /* Newer Intel CPUs are equipped with AMD style L2 cache info */\n   if (max_ext_level >= 0x80000006)\n@@ -393,13 +393,13 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n \n   if (!arch)\n     {\n-      if (vendor == *(unsigned int*) \"Auth\")\n+      if (vendor == *(const unsigned int*) \"Auth\")\n \tcache = detect_caches_amd (ext_level);\n-      else if (vendor == *(unsigned int*) \"Genu\")\n+      else if (vendor == *(const unsigned int*) \"Genu\")\n \tcache = detect_caches_intel (max_level, ext_level);\n     }\n \n-  if (vendor == *(unsigned int*) \"Auth\")\n+  if (vendor == *(const unsigned int*) \"Auth\")\n     {\n       processor = PROCESSOR_PENTIUM;\n \n@@ -412,7 +412,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       if (has_sse4a)\n \tprocessor = PROCESSOR_AMDFAM10;\n     }\n-  else if (vendor == *(unsigned int*) \"Geod\")\n+  else if (vendor == *(const unsigned int*) \"Geod\")\n     processor = PROCESSOR_GEODE;\n   else\n     {"}, {"sha": "a01fa3f0b011e0d18b417923c80661f28fe5ac32", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -116,7 +116,8 @@ ggc_mark_roots (void)\n       if (*cti->base)\n \t{\n \t  ggc_set_mark (*cti->base);\n-\t  htab_traverse_noresize (*cti->base, ggc_htab_delete, (void *) cti);\n+\t  htab_traverse_noresize (*cti->base, ggc_htab_delete,\n+\t\t\t\t  CONST_CAST (void *, (const void *)cti));\n \t  ggc_set_mark ((*cti->base)->entries);\n \t}\n \n@@ -264,12 +265,12 @@ gt_pch_note_object (void *obj, void *note_ptr_cookie,\n       return 0;\n     }\n \n-  *slot = xcalloc (sizeof (struct ptr_data), 1);\n+  *slot = XCNEW (struct ptr_data);\n   (*slot)->obj = obj;\n   (*slot)->note_ptr_fn = note_ptr_fn;\n   (*slot)->note_ptr_cookie = note_ptr_cookie;\n   if (note_ptr_fn == gt_pch_p_S)\n-    (*slot)->size = strlen (obj) + 1;\n+    (*slot)->size = strlen ((const char *)obj) + 1;\n   else\n     (*slot)->size = ggc_get_size (obj);\n   (*slot)->type = type;\n@@ -287,7 +288,8 @@ gt_pch_note_reorder (void *obj, void *note_ptr_cookie,\n   if (obj == NULL || obj == (void *) 1)\n     return;\n \n-  data = htab_find_with_hash (saving_htab, obj, POINTER_HASH (obj));\n+  data = (struct ptr_data *)\n+    htab_find_with_hash (saving_htab, obj, POINTER_HASH (obj));\n   gcc_assert (data && data->note_ptr_cookie == note_ptr_cookie);\n \n   data->reorder_fn = reorder_fn;\n@@ -370,7 +372,8 @@ relocate_ptrs (void *ptr_p, void *state_p)\n   if (*ptr == NULL || *ptr == (void *)1)\n     return;\n \n-  result = htab_find_with_hash (saving_htab, *ptr, POINTER_HASH (*ptr));\n+  result = (struct ptr_data *)\n+    htab_find_with_hash (saving_htab, *ptr, POINTER_HASH (*ptr));\n   gcc_assert (result);\n   *ptr = result->new_addr;\n }\n@@ -398,8 +401,8 @@ write_pch_globals (const struct ggc_root_tab * const *tab,\n \t    }\n \t  else\n \t    {\n-\t      new_ptr = htab_find_with_hash (saving_htab, ptr,\n-\t\t\t\t\t     POINTER_HASH (ptr));\n+\t      new_ptr = (struct ptr_data *)\n+\t\thtab_find_with_hash (saving_htab, ptr, POINTER_HASH (ptr));\n \t      if (fwrite (&new_ptr->new_addr, sizeof (void *), 1, state->f)\n \t\t  != 1)\n \t\tfatal_error (\"can't write PCH file: %m\");\n@@ -502,7 +505,7 @@ gt_pch_save (FILE *f)\n       if (this_object_size < state.ptrs[i]->size)\n \t{\n \t  this_object_size = state.ptrs[i]->size;\n-\t  this_object = xrealloc (this_object, this_object_size);\n+\t  this_object = XRESIZEVAR (char, this_object, this_object_size);\n \t}\n       memcpy (this_object, state.ptrs[i]->obj, state.ptrs[i]->size);\n       if (state.ptrs[i]->reorder_fn != NULL)"}, {"sha": "14e0776a1a649004be240309fb40392cf919754e", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -503,7 +503,7 @@ push_depth (unsigned int i)\n   if (G.depth_in_use >= G.depth_max)\n     {\n       G.depth_max *= 2;\n-      G.depth = xrealloc (G.depth, G.depth_max * sizeof (unsigned int));\n+      G.depth = XRESIZEVEC (unsigned int, G.depth, G.depth_max);\n     }\n   G.depth[G.depth_in_use++] = i;\n }\n@@ -516,10 +516,9 @@ push_by_depth (page_entry *p, unsigned long *s)\n   if (G.by_depth_in_use >= G.by_depth_max)\n     {\n       G.by_depth_max *= 2;\n-      G.by_depth = xrealloc (G.by_depth,\n-\t\t\t     G.by_depth_max * sizeof (page_entry *));\n-      G.save_in_use = xrealloc (G.save_in_use,\n-\t\t\t\tG.by_depth_max * sizeof (unsigned long *));\n+      G.by_depth = XRESIZEVEC (page_entry *, G.by_depth, G.by_depth_max);\n+      G.save_in_use = XRESIZEVEC (unsigned long *, G.save_in_use,\n+\t\t\t\t  G.by_depth_max);\n     }\n   G.by_depth[G.by_depth_in_use] = p;\n   G.save_in_use[G.by_depth_in_use++] = s;\n@@ -657,12 +656,12 @@ static inline char *\n alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size)\n {\n #ifdef HAVE_MMAP_ANON\n-  char *page = mmap (pref, size, PROT_READ | PROT_WRITE,\n-\t\t     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  char *page = (char *) mmap (pref, size, PROT_READ | PROT_WRITE,\n+\t\t\t      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n #endif\n #ifdef HAVE_MMAP_DEV_ZERO\n-  char *page = mmap (pref, size, PROT_READ | PROT_WRITE,\n-\t\t     MAP_PRIVATE, G.dev_zero_fd, 0);\n+  char *page = (char *) mmap (pref, size, PROT_READ | PROT_WRITE,\n+\t\t\t      MAP_PRIVATE, G.dev_zero_fd, 0);\n #endif\n \n   if (page == (char *) MAP_FAILED)\n@@ -772,7 +771,7 @@ alloc_page (unsigned order)\n \t memory order.  */\n       for (i = GGC_QUIRE_SIZE - 1; i >= 1; i--)\n \t{\n-\t  e = xcalloc (1, page_entry_size);\n+\t  e = XCNEWVAR (struct page_entry, page_entry_size);\n \t  e->order = order;\n \t  e->bytes = G.pagesize;\n \t  e->page = page + (i << G.lg_pagesize);\n@@ -857,7 +856,7 @@ alloc_page (unsigned order)\n #endif\n \n   if (entry == NULL)\n-    entry = xcalloc (1, page_entry_size);\n+    entry = XCNEWVAR (struct page_entry, page_entry_size);\n \n   entry->bytes = entry_size;\n   entry->page = page;\n@@ -1285,7 +1284,7 @@ gt_ggc_m_S (const void *p)\n \t a STRING_CST.  */\n       gcc_assert (offset == offsetof (struct tree_string, str));\n       p = ((const char *) p) - offset;\n-      gt_ggc_mx_lang_tree_node ((void *) p);\n+      gt_ggc_mx_lang_tree_node (CONST_CAST (void *, p));\n       return;\n     }\n \n@@ -1666,7 +1665,7 @@ clear_marks (void)\n \t  if (p->context_depth < G.context_depth)\n \t    {\n \t      if (! save_in_use_p (p))\n-\t\tsave_in_use_p (p) = xmalloc (bitmap_size);\n+\t\tsave_in_use_p (p) = XNEWVAR (unsigned long, bitmap_size);\n \t      memcpy (save_in_use_p (p), p->in_use_p, bitmap_size);\n \t    }\n \n@@ -2272,7 +2271,7 @@ ggc_pch_read (FILE *f, void *addr)\n {\n   struct ggc_pch_ondisk d;\n   unsigned i;\n-  char *offs = addr;\n+  char *offs = (char *) addr;\n   unsigned long count_old_page_tables;\n   unsigned long count_new_page_tables;\n \n@@ -2318,9 +2317,9 @@ ggc_pch_read (FILE *f, void *addr)\n \n       bytes = ROUND_UP (d.totals[i] * OBJECT_SIZE (i), G.pagesize);\n       num_objs = bytes / OBJECT_SIZE (i);\n-      entry = xcalloc (1, (sizeof (struct page_entry)\n-\t\t\t   - sizeof (long)\n-\t\t\t   + BITMAP_SIZE (num_objs + 1)));\n+      entry = XCNEWVAR (struct page_entry, (sizeof (struct page_entry)\n+\t\t\t\t\t    - sizeof (long)\n+\t\t\t\t\t    + BITMAP_SIZE (num_objs + 1)));\n       entry->bytes = bytes;\n       entry->page = offs;\n       entry->context_depth = 0;"}, {"sha": "8ccad6b093a3d4634508d5df2545b5327628666f", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -216,7 +216,7 @@ compute_regsets (HARD_REG_SET *elim_set,\n /* Like regs_ever_live, but 1 if a reg is set or clobbered from an asm.\n    Unlike regs_ever_live, elements of this array corresponding to\n    eliminable regs like the frame pointer are set if an asm sets them.  */\n-  char *regs_asm_clobbered = alloca (FIRST_PSEUDO_REGISTER * sizeof (char));\n+  char *regs_asm_clobbered = XALLOCAVEC (char, FIRST_PSEUDO_REGISTER);\n \n #ifdef ELIMINABLE_REGS\n   static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;"}, {"sha": "e59adbc367740d973b5f02728242cac36a98dad9", "filename": "gcc/graph.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -226,7 +226,7 @@ print_rtl_graph_with_bb (const char *base, rtx rtx_first)\n   rtx tmp_rtx;\n   size_t namelen = strlen (base);\n   size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = alloca (namelen + extlen);\n+  char *buf = XALLOCAVEC (char, namelen + extlen);\n   FILE *fp;\n \n   if (basic_block_info == NULL)\n@@ -389,7 +389,7 @@ clean_graph_dump_file (const char *base)\n {\n   size_t namelen = strlen (base);\n   size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = alloca (namelen + extlen);\n+  char *buf = XALLOCAVEC (char, namelen + extlen);\n   FILE *fp;\n \n   memcpy (buf, base, namelen);\n@@ -413,7 +413,7 @@ finish_graph_dump_file (const char *base)\n {\n   size_t namelen = strlen (base);\n   size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = alloca (namelen + extlen);\n+  char *buf = XALLOCAVEC (char, namelen + extlen);\n   FILE *fp;\n \n   memcpy (buf, base, namelen);"}, {"sha": "8d5b38bbf3246cba4defbb1b6781b7913908867d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -2179,7 +2179,7 @@ schedule_block (basic_block *target_bb, int rgn_n_insns1)\n   q_ptr = 0;\n   q_size = 0;\n \n-  insn_queue = alloca ((max_insn_queue_index + 1) * sizeof (rtx));\n+  insn_queue = XALLOCAVEC (rtx, max_insn_queue_index + 1);\n   memset (insn_queue, 0, (max_insn_queue_index + 1) * sizeof (rtx));\n \n   /* Start just before the beginning of time.  */\n@@ -3158,7 +3158,8 @@ extend_h_i_d (void)\n      pseudos which do not cross calls.  */\n   int new_max_uid = get_max_uid () + 1;  \n \n-  h_i_d = xrecalloc (h_i_d, new_max_uid, old_max_uid, sizeof (*h_i_d));\n+  h_i_d = (struct haifa_insn_data *)\n+    xrecalloc (h_i_d, new_max_uid, old_max_uid, sizeof (*h_i_d));\n   old_max_uid = new_max_uid;\n \n   if (targetm.sched.h_i_d_extended)\n@@ -3175,8 +3176,8 @@ extend_ready (int n_new_insns)\n   readyp->veclen = rgn_n_insns + n_new_insns + 1 + issue_rate;\n   readyp->vec = XRESIZEVEC (rtx, readyp->vec, readyp->veclen);\n  \n-  ready_try = xrecalloc (ready_try, rgn_n_insns + n_new_insns + 1,\n-\t\t\t rgn_n_insns + 1, sizeof (char));\n+  ready_try = (char *) xrecalloc (ready_try, rgn_n_insns + n_new_insns + 1,\n+\t\t\t\t  rgn_n_insns + 1, sizeof (char));\n \n   rgn_n_insns += n_new_insns;\n \n@@ -4098,7 +4099,7 @@ unlink_bb_notes (basic_block first, basic_block last)\n   if (first == last)\n     return;\n \n-  bb_header = xmalloc (last_basic_block * sizeof (*bb_header));\n+  bb_header = XNEWVEC (rtx, last_basic_block);\n \n   /* Make a sentinel.  */\n   if (last->next_bb != EXIT_BLOCK_PTR)"}, {"sha": "d29aab6627e00519670c3f7044cd65e620b58897", "filename": "gcc/integrate.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -237,19 +237,18 @@ get_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n   ivs = crtl->hard_reg_initial_vals;\n   if (ivs == 0)\n     {\n-      ivs = ggc_alloc (sizeof (initial_value_struct));\n+      ivs = GGC_NEW (initial_value_struct);\n       ivs->num_entries = 0;\n       ivs->max_entries = 5;\n-      ivs->entries = ggc_alloc (5 * sizeof (initial_value_pair));\n+      ivs->entries = GGC_NEWVEC (initial_value_pair, 5);\n       crtl->hard_reg_initial_vals = ivs;\n     }\n \n   if (ivs->num_entries >= ivs->max_entries)\n     {\n       ivs->max_entries += 5;\n-      ivs->entries = ggc_realloc (ivs->entries,\n-\t\t\t\t  ivs->max_entries\n-\t\t\t\t  * sizeof (initial_value_pair));\n+      ivs->entries = GGC_RESIZEVEC (initial_value_pair, ivs->entries,\n+\t\t\t\t    ivs->max_entries);\n     }\n \n   ivs->entries[ivs->num_entries].hard_reg = gen_rtx_REG (mode, regno);"}, {"sha": "c5b4c9a80c8e5e0b6a1c8158de30363eae4ef5c7", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -52,7 +52,7 @@ ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *mt)\n {\n   struct ipa_func_list *temp;\n \n-  temp = xcalloc (1, sizeof (struct ipa_func_list));\n+  temp = XCNEW (struct ipa_func_list);\n   temp->node = mt;\n   temp->next = *wl;\n   *wl = temp;"}, {"sha": "fffb454d8317abb8870ee93f8f69a1708727e77e", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -1954,7 +1954,7 @@ gen_var_name (tree orig_decl, unsigned HOST_WIDE_INT i)\n      appropriate new name for the new variable.  */\n \n   old_name = IDENTIFIER_POINTER (DECL_NAME (orig_decl));\n-  prefix = alloca (strlen (old_name) + 1);\n+  prefix = XALLOCAVEC (char, strlen (old_name) + 1);\n   strcpy (prefix, old_name);\n   ASM_FORMAT_PRIVATE_NAME (new_name, prefix, i);\n   return get_identifier (new_name);\n@@ -2827,7 +2827,7 @@ gen_cluster_name (tree decl, int clust_num, int str_num)\n     ASM_FORMAT_PRIVATE_NAME(tmp_name, \"struct\", str_num);\n \n   len = strlen (tmp_name ? tmp_name : orig_name) + strlen (\"_sub\");\n-  prefix = alloca (len + 1);\n+  prefix = XALLOCAVEC (char, len + 1);\n   memcpy (prefix, tmp_name ? tmp_name : orig_name, \n \t  strlen (tmp_name ? tmp_name : orig_name));\n   strcpy (prefix + strlen (tmp_name ? tmp_name : orig_name), \"_sub\");      "}, {"sha": "e1c8e47cdc8a9f325100eb4cf993567ab2fadf6f", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -806,7 +806,7 @@ update_equiv_regs (void)\n   bitmap cleared_regs;\n   \n   reg_equiv = XCNEWVEC (struct equivalence, max_regno);\n-  reg_equiv_init = ggc_alloc_cleared (max_regno * sizeof (rtx));\n+  reg_equiv_init = GGC_CNEWVEC (rtx, max_regno);\n   reg_equiv_init_size = max_regno;\n \n   init_alias_analysis ();"}, {"sha": "40e70ba18c04bec9ed7e51ef186f50728f74edc3", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -164,8 +164,7 @@ check_invariant_table_size (void)\n   if (invariant_table_size < DF_DEFS_TABLE_SIZE())\n     {\n       unsigned int new_size = DF_DEFS_TABLE_SIZE () + (DF_DEFS_TABLE_SIZE () / 4);\n-      invariant_table = xrealloc (invariant_table, \n-\t\t\t\t  sizeof (struct rtx_iv *) * new_size);\n+      invariant_table = XRESIZEVEC (struct invariant *, invariant_table, new_size);\n       memset (&invariant_table[invariant_table_size], 0, \n \t      (new_size - invariant_table_size) * sizeof (struct rtx_iv *));\n       invariant_table_size = new_size;\n@@ -417,7 +416,8 @@ invariant_expr_equal_p (rtx insn1, rtx e1, rtx insn2, rtx e2)\n static hashval_t\n hash_invariant_expr (const void *e)\n {\n-  const struct invariant_expr_entry *entry = e;\n+  const struct invariant_expr_entry *const entry =\n+    (const struct invariant_expr_entry *) e;\n \n   return entry->hash;\n }\n@@ -427,8 +427,10 @@ hash_invariant_expr (const void *e)\n static int\n eq_invariant_expr (const void *e1, const void *e2)\n {\n-  const struct invariant_expr_entry *entry1 = e1;\n-  const struct invariant_expr_entry *entry2 = e2;\n+  const struct invariant_expr_entry *const entry1 =\n+    (const struct invariant_expr_entry *) e1;\n+  const struct invariant_expr_entry *const entry2 =\n+    (const struct invariant_expr_entry *) e2;\n \n   if (entry1->mode != entry2->mode)\n     return 0;\n@@ -454,7 +456,7 @@ find_or_insert_inv (htab_t eq, rtx expr, enum machine_mode mode,\n   pentry.inv = inv;\n   pentry.mode = mode;\n   slot = htab_find_slot_with_hash (eq, &pentry, hash, INSERT);\n-  entry = *slot;\n+  entry = (struct invariant_expr_entry *) *slot;\n \n   if (entry)\n     return entry->inv;"}, {"sha": "e0635970bff707158e849dcb4f4d8ac9bb1d4137", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -173,8 +173,7 @@ check_iv_ref_table_size (void)\n   if (iv_ref_table_size < DF_DEFS_TABLE_SIZE())\n     {\n       unsigned int new_size = DF_DEFS_TABLE_SIZE () + (DF_DEFS_TABLE_SIZE () / 4);\n-      iv_ref_table = xrealloc (iv_ref_table, \n-\t\t\t       sizeof (struct rtx_iv *) * new_size);\n+      iv_ref_table = XRESIZEVEC (struct rtx_iv *, iv_ref_table, new_size);\n       memset (&iv_ref_table[iv_ref_table_size], 0, \n \t      (new_size - iv_ref_table_size) * sizeof (struct rtx_iv *));\n       iv_ref_table_size = new_size;\n@@ -819,7 +818,8 @@ record_iv (struct df_ref *def, struct rtx_iv *iv)\n static bool\n analyzed_for_bivness_p (rtx def, struct rtx_iv *iv)\n {\n-  struct biv_entry *biv = htab_find_with_hash (bivs, def, REGNO (def));\n+  struct biv_entry *biv =\n+    (struct biv_entry *) htab_find_with_hash (bivs, def, REGNO (def));\n \n   if (!biv)\n     return false;\n@@ -1304,7 +1304,7 @@ altered_reg_used (rtx *reg, void *alt)\n   if (!REG_P (*reg))\n     return 0;\n \n-  return REGNO_REG_SET_P (alt, REGNO (*reg));\n+  return REGNO_REG_SET_P ((bitmap) alt, REGNO (*reg));\n }\n \n /* Marks registers altered by EXPR in set ALT.  */\n@@ -1317,7 +1317,7 @@ mark_altered (rtx expr, const_rtx by ATTRIBUTE_UNUSED, void *alt)\n   if (!REG_P (expr))\n     return;\n \n-  SET_REGNO_REG_SET (alt, REGNO (expr));\n+  SET_REGNO_REG_SET ((bitmap) alt, REGNO (expr));\n }\n \n /* Checks whether RHS is simple enough to process.  */"}, {"sha": "b6dc266d7c64484a1e6a27c1c3500c3551c7ca26", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -1491,8 +1491,8 @@ si_info_hash (const void *ivts)\n static int\n si_info_eq (const void *ivts1, const void *ivts2)\n {\n-  const struct iv_to_split *i1 = ivts1;\n-  const struct iv_to_split *i2 = ivts2;\n+  const struct iv_to_split *const i1 = (const struct iv_to_split *) ivts1;\n+  const struct iv_to_split *const i2 = (const struct iv_to_split *) ivts2;\n \n   return i1->insn == i2->insn;\n }\n@@ -1511,8 +1511,8 @@ ve_info_hash (const void *ves)\n static int\n ve_info_eq (const void *ivts1, const void *ivts2)\n {\n-  const struct var_to_expand *i1 = ivts1;\n-  const struct var_to_expand *i2 = ivts2;\n+  const struct var_to_expand *const i1 = (const struct var_to_expand *) ivts1;\n+  const struct var_to_expand *const i2 = (const struct var_to_expand *) ivts2;\n   \n   return i1->insn == i2->insn;\n }\n@@ -1867,7 +1867,7 @@ get_ivts_expr (rtx expr, struct iv_to_split *ivts)\n static int\n allocate_basic_variable (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  struct iv_to_split *ivts = *slot;\n+  struct iv_to_split *ivts = (struct iv_to_split *) *slot;\n   rtx expr = *get_ivts_expr (single_set (ivts->insn), ivts);\n \n   ivts->base_var = gen_reg_rtx (GET_MODE (expr));\n@@ -2040,7 +2040,7 @@ expand_var_during_unrolling (struct var_to_expand *ve, rtx insn)\n static int\n insert_var_expansion_initialization (void **slot, void *place_p)\n {\n-  struct var_to_expand *ve = *slot;\n+  struct var_to_expand *ve = (struct var_to_expand *) *slot;\n   basic_block place = (basic_block)place_p;\n   rtx seq, var, zero_init, insn;\n   unsigned i;\n@@ -2088,7 +2088,7 @@ insert_var_expansion_initialization (void **slot, void *place_p)\n static int\n combine_var_copies_in_loop_exit (void **slot, void *place_p)\n {\n-  struct var_to_expand *ve = *slot;\n+  struct var_to_expand *ve = (struct var_to_expand *) *slot;\n   basic_block place = (basic_block)place_p;\n   rtx sum = ve->reg;\n   rtx expr, seq, var, insn;\n@@ -2181,7 +2181,8 @@ apply_opt_in_copies (struct opt_info *opt_info,\n           /* Apply splitting iv optimization.  */\n           if (opt_info->insns_to_split)\n             {\n-              ivts = htab_find (opt_info->insns_to_split, &ivts_templ);\n+              ivts = (struct iv_to_split *)\n+\t\thtab_find (opt_info->insns_to_split, &ivts_templ);\n               \n               if (ivts)\n                 {\n@@ -2196,7 +2197,8 @@ apply_opt_in_copies (struct opt_info *opt_info,\n           /* Apply variable expansion optimization.  */\n           if (unrolling && opt_info->insns_with_var_to_expand)\n             {\n-              ves = htab_find (opt_info->insns_with_var_to_expand, &ve_templ);\n+              ves = (struct var_to_expand *)\n+\t\thtab_find (opt_info->insns_with_var_to_expand, &ve_templ);\n               if (ves)\n                 { \n \t\t  gcc_assert (GET_CODE (PATTERN (insn))\n@@ -2246,7 +2248,8 @@ apply_opt_in_copies (struct opt_info *opt_info,\n           ivts_templ.insn = orig_insn;\n           if (opt_info->insns_to_split)\n             {\n-              ivts = htab_find (opt_info->insns_to_split, &ivts_templ);\n+              ivts = (struct iv_to_split *)\n+\t\thtab_find (opt_info->insns_to_split, &ivts_templ);\n               if (ivts)\n                 {\n                   if (!delta)\n@@ -2266,7 +2269,7 @@ apply_opt_in_copies (struct opt_info *opt_info,\n static int\n release_var_copies (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  struct var_to_expand *ve = *slot;\n+  struct var_to_expand *ve = (struct var_to_expand *) *slot;\n   \n   VEC_free (rtx, heap, ve->var_expansions);\n   "}, {"sha": "33bb0b4e8f4c83b8555b8ccc3c758678c0246ecb", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -358,7 +358,8 @@ static bool check_transpose_p;\n static hashval_t\n mat_acc_phi_hash (const void *p)\n {\n-  const struct matrix_access_phi_node *ma_phi = p;\n+  const struct matrix_access_phi_node *const ma_phi =\n+    (const struct matrix_access_phi_node *) p;\n \n   return htab_hash_pointer (ma_phi->phi);\n }\n@@ -368,8 +369,10 @@ mat_acc_phi_hash (const void *p)\n static int\n mat_acc_phi_eq (const void *p1, const void *p2)\n {\n-  const struct matrix_access_phi_node *phi1 = p1;\n-  const struct matrix_access_phi_node *phi2 = p2;\n+  const struct matrix_access_phi_node *const phi1 =\n+    (const struct matrix_access_phi_node *) p1;\n+  const struct matrix_access_phi_node *const phi2 =\n+    (const struct matrix_access_phi_node *) p2;\n \n   if (phi1->phi == phi2->phi)\n     return 1;\n@@ -397,8 +400,8 @@ mtt_info_hash (const void *mtt)\n static int\n mtt_info_eq (const void *mtt1, const void *mtt2)\n {\n-  const struct matrix_info *i1 = mtt1;\n-  const struct matrix_info *i2 = mtt2;\n+  const struct matrix_info *const i1 = (const struct matrix_info *) mtt1;\n+  const struct matrix_info *const i2 = (const struct matrix_info *) mtt2;\n \n   if (i1->decl == i2->decl)\n     return true;\n@@ -521,7 +524,7 @@ analyze_matrix_decl (tree var_decl)\n \n   /* Check to see if this pointer is already in there.  */\n   tmpmi.decl = var_decl;\n-  mi = htab_find (matrices_to_reorg, &tmpmi);\n+  mi = (struct matrix_info *) htab_find (matrices_to_reorg, &tmpmi);\n \n   if (mi)\n     return NULL;\n@@ -738,13 +741,13 @@ add_allocation_site (struct matrix_info *mi, tree stmt, int level)\n      calls like calloc and realloc.  */\n   if (!mi->malloc_for_level)\n     {\n-      mi->malloc_for_level = xcalloc (level + 1, sizeof (tree));\n+      mi->malloc_for_level = XCNEWVEC (tree, level + 1);\n       mi->max_malloced_level = level + 1;\n     }\n   else if (mi->max_malloced_level <= level)\n     {\n       mi->malloc_for_level\n-\t= xrealloc (mi->malloc_for_level, (level + 1) * sizeof (tree));\n+\t= XRESIZEVEC (tree, mi->malloc_for_level, level + 1);\n \n       /* Zero the newly allocated items.  */\n       memset (&(mi->malloc_for_level[mi->max_malloced_level + 1]),\n@@ -879,7 +882,7 @@ analyze_matrix_allocation_site (struct matrix_info *mi, tree stmt,\n static int\n analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  struct matrix_info *mi = *slot;\n+  struct matrix_info *mi = (struct matrix_info *) *slot;\n   int min_escape_l = mi->min_indirect_level_escape;\n   struct loop *loop;\n   affine_iv iv;\n@@ -1079,7 +1082,8 @@ analyze_accesses_for_phi_node (struct matrix_info *mi, tree use_stmt,\n   struct matrix_access_phi_node tmp_maphi, *maphi, **pmaphi;\n \n   tmp_maphi.phi = use_stmt;\n-  if ((maphi = htab_find (htab_mat_acc_phi_nodes, &tmp_maphi)))\n+  if ((maphi = (struct matrix_access_phi_node *)\n+       htab_find (htab_mat_acc_phi_nodes, &tmp_maphi)))\n     {\n       if (maphi->indirection_level == current_indirect_level)\n \treturn;\n@@ -1358,7 +1362,7 @@ check_var_notmodified_p (tree * tp, int *walk_subtrees, void *data)\n {\n   basic_block bb;\n   tree t = *tp;\n-  tree fn = data;\n+  tree fn = (tree) data;\n   block_stmt_iterator bsi;\n   tree stmt;\n \n@@ -1482,7 +1486,7 @@ check_allocation_function (void **slot, void *data ATTRIBUTE_UNUSED)\n   int level;\n   block_stmt_iterator bsi;\n   basic_block bb_level_0;\n-  struct matrix_info *mi = *slot;\n+  struct matrix_info *mi = (struct matrix_info *) *slot;\n   sbitmap visited;\n \n   if (!mi->malloc_for_level)\n@@ -1587,7 +1591,8 @@ find_sites_in_func (bool record)\n \t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == VAR_DECL)\n \t  {\n \t    tmpmi.decl = GIMPLE_STMT_OPERAND (stmt, 0);\n-\t    if ((mi = htab_find (matrices_to_reorg, &tmpmi)))\n+\t    if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg,\n+\t\t\t\t\t\t\t&tmpmi)))\n \t      {\n \t\tsbitmap_zero (visited_stmts_1);\n \t\tanalyze_matrix_allocation_site (mi, stmt, 0, visited_stmts_1);\n@@ -1598,7 +1603,8 @@ find_sites_in_func (bool record)\n \t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == VAR_DECL)\n \t  {\n \t    tmpmi.decl = GIMPLE_STMT_OPERAND (stmt, 1);\n-\t    if ((mi = htab_find (matrices_to_reorg, &tmpmi)))\n+\t    if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg,\n+\t\t\t\t\t\t\t&tmpmi)))\n \t      {\n \t\tsbitmap_zero (visited_stmts_1);\n \t\tanalyze_matrix_accesses (mi,\n@@ -1645,7 +1651,7 @@ record_all_accesses_in_func (void)\n          chain for this SSA_VAR and check for escapes or apply the\n          flattening.  */\n       tmpmi.decl = rhs;\n-      if ((mi = htab_find (matrices_to_reorg, &tmpmi)))\n+      if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg, &tmpmi)))\n \t{\n \t  /* This variable will track the visited PHI nodes, so we can limit\n \t     its size to the maximum number of SSA names.  */\n@@ -1714,7 +1720,7 @@ static int\n transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   block_stmt_iterator bsi;\n-  struct matrix_info *mi = *slot;\n+  struct matrix_info *mi = (struct matrix_info *) *slot;\n   int min_escape_l = mi->min_indirect_level_escape;\n   struct access_site_info *acc_info;\n   int i;\n@@ -1942,7 +1948,7 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n   int min_escape_l;\n   int id;\n \n-  mi = *slot;\n+  mi = (struct matrix_info *) *slot;\n \n   min_escape_l = mi->min_indirect_level_escape;\n \n@@ -2184,7 +2190,7 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n static int\n dump_matrix_reorg_analysis (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  struct matrix_info *mi = *slot;\n+  struct matrix_info *mi = (struct matrix_info *) *slot;\n \n   if (!dump_file)\n     return 1;"}, {"sha": "e26ebbcb9d70bcb43d1955ffd5e502ad1dfe63e5", "filename": "gcc/omp-low.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -1097,7 +1097,7 @@ debug_all_omp_regions (void)\n struct omp_region *\n new_omp_region (basic_block bb, enum tree_code type, struct omp_region *parent)\n {\n-  struct omp_region *region = xcalloc (1, sizeof (*region));\n+  struct omp_region *region = XCNEW (struct omp_region);\n \n   region->outer = parent;\n   region->entry = bb;\n@@ -1493,7 +1493,7 @@ create_omp_child_function_name (bool task_copy)\n   const char *suffix;\n \n   suffix = task_copy ? \"_omp_cpyfn\" : \"_omp_fn\";\n-  prefix = alloca (len + strlen (suffix) + 1);\n+  prefix = XALLOCAVEC (char, len + strlen (suffix) + 1);\n   memcpy (prefix, IDENTIFIER_POINTER (name), len);\n   strcpy (prefix + len, suffix);\n #ifndef NO_DOT_IN_LABEL\n@@ -1853,8 +1853,8 @@ check_omp_nesting_restrictions (tree t, omp_context *ctx)\n static tree\n scan_omp_1 (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n-  omp_context *ctx = wi->info;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  omp_context *ctx = (omp_context *) wi->info;\n   tree t = *tp;\n \n   if (EXPR_HAS_LOCATION (t))\n@@ -5800,8 +5800,8 @@ lower_omp_for (tree *stmt_p, omp_context *ctx)\n static tree\n check_combined_parallel (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n-  int *info = wi->info;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  int *info = (int *) wi->info;\n \n   *walk_subtrees = 0;\n   switch (TREE_CODE (*tp))\n@@ -6194,7 +6194,7 @@ static tree\n lower_omp_2 (tree *tp, int *walk_subtrees, void *data)\n {\n   tree t = *tp;\n-  omp_context *ctx = data;\n+  omp_context *ctx = (omp_context *) data;\n \n   /* Any variable with DECL_VALUE_EXPR needs to be regimplified.  */\n   if (TREE_CODE (t) == VAR_DECL\n@@ -6470,7 +6470,7 @@ diagnose_sb_0 (tree *stmt_p, tree branch_ctx, tree label_ctx)\n static tree\n diagnose_sb_1 (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   tree context = (tree) wi->info;\n   tree inner_context;\n   tree t = *tp;\n@@ -6532,7 +6532,7 @@ diagnose_sb_1 (tree *tp, int *walk_subtrees, void *data)\n static tree\n diagnose_sb_2 (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   tree context = (tree) wi->info;\n   splay_tree_node n;\n   tree t = *tp;"}, {"sha": "61c810e3697a3d4d566d950454928b53a82e2f0e", "filename": "gcc/optabs.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -3801,7 +3801,7 @@ struct no_conflict_data\n static void\n no_conflict_move_test (rtx dest, const_rtx set, void *p0)\n {\n-  struct no_conflict_data *p= p0;\n+  struct no_conflict_data *p= (struct no_conflict_data *) p0;\n \n   /* If this inns directly contributes to setting the target, it must stay.  */\n   if (reg_overlap_mentioned_p (p->target, dest))\n@@ -5463,7 +5463,7 @@ gen_libfunc (optab optable, const char *opname, int suffix, enum machine_mode mo\n   unsigned opname_len = strlen (opname);\n   const char *mname = GET_MODE_NAME (mode);\n   unsigned mname_len = strlen (mname);\n-  char *libfunc_name = alloca (2 + opname_len + mname_len + 1 + 1);\n+  char *libfunc_name = XALLOCAVEC (char, 2 + opname_len + mname_len + 1 + 1);\n   char *p;\n   const char *q;\n \n@@ -5511,7 +5511,7 @@ gen_fp_libfunc (optab optable, const char *opname, char suffix,\n     gen_libfunc (optable, opname, suffix, mode);\n   if (DECIMAL_FLOAT_MODE_P (mode))\n     {\n-      dec_opname = alloca (sizeof (DECIMAL_PREFIX) + strlen (opname));\n+      dec_opname = XALLOCAVEC (char, sizeof (DECIMAL_PREFIX) + strlen (opname));\n       /* For BID support, change the name to have either a bid_ or dpd_ prefix\n \t depending on the low level floating format used.  */\n       memcpy (dec_opname, DECIMAL_PREFIX, sizeof (DECIMAL_PREFIX) - 1);\n@@ -5579,7 +5579,7 @@ gen_intv_fp_libfunc (optab optable, const char *name, char suffix,\n   if (GET_MODE_CLASS (mode) == MODE_INT)\n     {\n       int len = strlen (name);\n-      char *v_name = alloca (len + 2);\n+      char *v_name = XALLOCAVEC (char, len + 2);\n       strcpy (v_name, name);\n       v_name[len] = 'v';\n       v_name[len + 1] = 0;\n@@ -5683,13 +5683,13 @@ gen_interclass_conv_libfunc (convert_optab tab,\n \n   mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));\n \n-  nondec_name = alloca (2 + opname_len + mname_len + 1 + 1);\n+  nondec_name = XALLOCAVEC (char, 2 + opname_len + mname_len + 1 + 1);\n   nondec_name[0] = '_';\n   nondec_name[1] = '_';\n   memcpy (&nondec_name[2], opname, opname_len);\n   nondec_suffix = nondec_name + opname_len + 2;\n \n-  dec_name = alloca (2 + dec_len + opname_len + mname_len + 1 + 1);\n+  dec_name = XALLOCAVEC (char, 2 + dec_len + opname_len + mname_len + 1 + 1);\n   dec_name[0] = '_';\n   dec_name[1] = '_';\n   memcpy (&dec_name[2], DECIMAL_PREFIX, dec_len);\n@@ -5808,13 +5808,13 @@ gen_intraclass_conv_libfunc (convert_optab tab, const char *opname,\n \n   mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));\n \n-  nondec_name = alloca (2 + opname_len + mname_len + 1 + 1);\n+  nondec_name = XALLOCAVEC (char, 2 + opname_len + mname_len + 1 + 1);\n   nondec_name[0] = '_';\n   nondec_name[1] = '_';\n   memcpy (&nondec_name[2], opname, opname_len);\n   nondec_suffix = nondec_name + opname_len + 2;\n \n-  dec_name = alloca (2 + dec_len + opname_len + mname_len + 1 + 1);\n+  dec_name = XALLOCAVEC (char, 2 + dec_len + opname_len + mname_len + 1 + 1);\n   dec_name[0] = '_';\n   dec_name[1] = '_';\n   memcpy (&dec_name[2], DECIMAL_PREFIX, dec_len);\n@@ -6026,7 +6026,7 @@ set_optab_libfunc (optab optable, enum machine_mode mode, const char *name)\n     val = 0;\n   slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n   if (*slot == NULL)\n-    *slot = ggc_alloc (sizeof (struct libfunc_entry));\n+    *slot = GGC_NEW (struct libfunc_entry);\n   (*slot)->optab = (size_t) (optable - &optab_table[0]);\n   (*slot)->mode1 = mode;\n   (*slot)->mode2 = VOIDmode;\n@@ -6053,7 +6053,7 @@ set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n     val = 0;\n   slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n   if (*slot == NULL)\n-    *slot = ggc_alloc (sizeof (struct libfunc_entry));\n+    *slot = GGC_NEW (struct libfunc_entry);\n   (*slot)->optab = (size_t) (optable - &convert_optab_table[0]);\n   (*slot)->mode1 = tmode;\n   (*slot)->mode2 = fmode;"}, {"sha": "af8e44c6afb4fca7d08dd3dade4122b1e40ef7bc", "filename": "gcc/opts-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -131,8 +131,8 @@ void\n prune_options (int *argcp, char ***argvp)\n {\n   int argc = *argcp;\n-  int *options = xmalloc (argc * sizeof (*options));\n-  char **argv = xmalloc (argc * sizeof (char *));\n+  int *options = XNEWVEC (int, argc);\n+  char **argv = XNEWVEC (char *, argc);\n   int i, arg_count, need_prune = 0;\n   const struct cl_option *option;\n   size_t opt_index;"}, {"sha": "226030bcde07d29a2f4187aa4b9a09835ae999da", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -651,7 +651,7 @@ static void\n add_input_filename (const char *filename)\n {\n   num_in_fnames++;\n-  in_fnames = xrealloc (in_fnames, num_in_fnames * sizeof (in_fnames[0]));\n+  in_fnames = XRESIZEVEC (const char *, in_fnames, num_in_fnames);\n   in_fnames[num_in_fnames - 1] = filename;\n }\n \n@@ -1134,7 +1134,7 @@ print_filtered_help (unsigned int include_flags,\n     }\n \n   if (!printed)\n-    printed = xcalloc (1, cl_options_count);\n+    printed = XCNEWVAR (char, cl_options_count);\n \n   for (i = 0; i < cl_options_count; i++)\n     {\n@@ -2143,7 +2143,7 @@ get_option_state (int option, struct cl_option_state *state)\n       state->data = *(const char **) cl_options[option].flag_var;\n       if (state->data == 0)\n \tstate->data = \"\";\n-      state->size = strlen (state->data) + 1;\n+      state->size = strlen ((const char *) state->data) + 1;\n       break;\n     }\n   return true;"}, {"sha": "2c653cf6157eb2e557d34522b2a4fe04b938b974", "filename": "gcc/params.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -40,8 +40,8 @@ void\n add_params (const param_info params[], size_t n)\n {\n   /* Allocate enough space for the new parameters.  */\n-  compiler_params = xrealloc (compiler_params,\n-\t\t\t      (num_compiler_params + n) * sizeof (param_info));\n+  compiler_params = XRESIZEVEC (param_info, compiler_params,\n+\t\t\t\tnum_compiler_params + n);\n   /* Copy them into the table.  */\n   memcpy (compiler_params + num_compiler_params,\n \t  params,"}, {"sha": "ba6151a4cd7f7f60934c982b933a45f861d72345", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -346,7 +346,7 @@ set_pass_for_id (int id, struct opt_pass *pass)\n   pass->static_pass_number = id;\n   if (passes_by_id_size <= id)\n     {\n-      passes_by_id = xrealloc (passes_by_id, (id + 1) * sizeof (void *));\n+      passes_by_id = XRESIZEVEC (struct opt_pass *, passes_by_id, id + 1);\n       memset (passes_by_id + passes_by_id_size, 0,\n \t      (id + 1 - passes_by_id_size) * sizeof (void *));\n       passes_by_id_size = id + 1;\n@@ -449,7 +449,7 @@ next_pass_1 (struct opt_pass **list, struct opt_pass *pass)\n     {\n       struct opt_pass *new;\n \n-      new = xmalloc (sizeof (*new));\n+      new = XNEW (struct opt_pass);\n       memcpy (new, pass, sizeof (*new));\n       new->next = NULL;\n \n@@ -884,7 +884,7 @@ do_per_function_toporder (void (*callback) (void *data), void *data)\n   else\n     {\n       gcc_assert (!order);\n-      order = ggc_alloc (sizeof (*order) * cgraph_n_nodes);\n+      order = GGC_NEWVEC (struct cgraph_node *, cgraph_n_nodes);\n       nnodes = cgraph_postorder (order);\n       for (i = nnodes - 1; i >= 0; i--)\n \t{\n@@ -1150,7 +1150,7 @@ pass_fini_dump_file (struct opt_pass *pass)\n static void\n update_properties_after_pass (void *data)\n {\n-  struct opt_pass *pass = data;\n+  struct opt_pass *pass = (struct opt_pass *) data;\n   cfun->curr_properties = (cfun->curr_properties | pass->properties_provided)\n \t\t           & ~pass->properties_destroyed;\n }"}, {"sha": "dcac71ba4d92ee56222ee738df5712587edd52cc", "filename": "gcc/postreload.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -394,9 +394,9 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n   if (! constrain_operands (1))\n     fatal_insn_not_found (insn);\n \n-  alternative_reject = alloca (recog_data.n_alternatives * sizeof (int));\n-  alternative_nregs = alloca (recog_data.n_alternatives * sizeof (int));\n-  alternative_order = alloca (recog_data.n_alternatives * sizeof (int));\n+  alternative_reject = XALLOCAVEC (int, recog_data.n_alternatives);\n+  alternative_nregs = XALLOCAVEC (int, recog_data.n_alternatives);\n+  alternative_order = XALLOCAVEC (int, recog_data.n_alternatives);\n   memset (alternative_reject, 0, recog_data.n_alternatives * sizeof (int));\n   memset (alternative_nregs, 0, recog_data.n_alternatives * sizeof (int));\n \n@@ -487,7 +487,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n       int regno;\n       const char *p;\n \n-      op_alt_regno[i] = alloca (recog_data.n_alternatives * sizeof (int));\n+      op_alt_regno[i] = XALLOCAVEC (int, recog_data.n_alternatives);\n       for (j = 0; j < recog_data.n_alternatives; j++)\n \top_alt_regno[i][j] = -1;\n "}, {"sha": "ca7f9448d01dcf40bce1c8f15de02ad031f4a709", "filename": "gcc/predict.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bfe4decc2bbbce0585df7814c7923488cb1cb5/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "patch": "@@ -211,7 +211,7 @@ tree_predicted_by_p (const_basic_block bb, enum br_predictor predictor)\n   if (!preds)\n     return false;\n   \n-  for (i = *preds; i; i = i->ep_next)\n+  for (i = (struct edge_prediction *) *preds; i; i = i->ep_next)\n     if (i->ep_predictor == predictor)\n       return true;\n   return false;\n@@ -316,7 +316,7 @@ tree_predict_edge (edge e, enum br_predictor predictor, int probability)\n       struct edge_prediction *i = XNEW (struct edge_prediction);\n       void **preds = pointer_map_insert (bb_predictions, e->src);\n \n-      i->ep_next = *preds;\n+      i->ep_next = (struct edge_prediction *) *preds;\n       *preds = i;\n       i->ep_probability = probability;\n       i->ep_predictor = predictor;\n@@ -366,7 +366,7 @@ clear_bb_predictions (basic_block bb)\n   if (!preds)\n     return;\n \n-  for (pred = *preds; pred; pred = next)\n+  for (pred = (struct edge_prediction *) *preds; pred; pred = next)\n     {\n       next = pred->ep_next;\n       free (pred);\n@@ -638,7 +638,7 @@ combine_predictions_for_bb (basic_block bb)\n     {\n       /* We implement \"first match\" heuristics and use probability guessed\n \t by predictor with smallest index.  */\n-      for (pred = *preds; pred; pred = pred->ep_next)\n+      for (pred = (struct edge_prediction *) *preds; pred; pred = pred->ep_next)\n \t{\n \t  int predictor = pred->ep_predictor;\n \t  int probability = pred->ep_probability;\n@@ -688,7 +688,7 @@ combine_predictions_for_bb (basic_block bb)\n \n   if (preds)\n     {\n-      for (pred = *preds; pred; pred = pred->ep_next)\n+      for (pred = (struct edge_prediction *) *preds; pred; pred = pred->ep_next)\n \t{\n \t  int predictor = pred->ep_predictor;\n \t  int probability = pred->ep_probability;"}]}