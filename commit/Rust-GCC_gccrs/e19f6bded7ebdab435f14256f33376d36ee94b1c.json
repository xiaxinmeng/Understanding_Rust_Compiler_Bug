{"sha": "e19f6bded7ebdab435f14256f33376d36ee94b1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE5ZjZiZGVkN2ViZGFiNDM1ZjE0MjU2ZjMzMzc2ZDM2ZWU5NGIxYw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2004-03-25T17:51:17Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2004-03-25T17:51:17Z"}, "message": "builtins.c (fold_builtin): Add new builtin optimizations for sqrt and/or cbrt.\n\n\t* builtins.c (fold_builtin): Add new builtin optimizations for\n\tsqrt and/or cbrt.\n\t* fold-const.c (fold): Likewise.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-explog-1.c: Add new cases.\n\t* gcc.dg/torture/builtin-math-1.c: Likewise.\n\t* builtin-power-1.c: New test.\n\nFrom-SVN: r79959", "tree": {"sha": "666a4a6d283551504a605f8b912b83befd89d93b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/666a4a6d283551504a605f8b912b83befd89d93b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e19f6bded7ebdab435f14256f33376d36ee94b1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19f6bded7ebdab435f14256f33376d36ee94b1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e19f6bded7ebdab435f14256f33376d36ee94b1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19f6bded7ebdab435f14256f33376d36ee94b1c/comments", "author": null, "committer": null, "parents": [{"sha": "ec507f2d8b6a00a9139d53964d2e7df902336814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec507f2d8b6a00a9139d53964d2e7df902336814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec507f2d8b6a00a9139d53964d2e7df902336814"}], "stats": {"total": 247, "additions": 238, "deletions": 9}, "files": [{"sha": "d314638bd73cfa3420a56efc84a6640bb8ef7357", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e19f6bded7ebdab435f14256f33376d36ee94b1c", "patch": "@@ -1,3 +1,9 @@\n+2004-03-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (fold_builtin): Add new builtin optimizations for\n+\tsqrt and/or cbrt.\n+\t* fold-const.c (fold): Likewise.\n+\n 2004-03-25  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_always_hint): New variable."}, {"sha": "f0ac04f89f9aa85c14bf136194199ca8ba4929a1", "filename": "gcc/builtins.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e19f6bded7ebdab435f14256f33376d36ee94b1c", "patch": "@@ -6690,6 +6690,29 @@ fold_builtin (tree exp)\n \t      return build_function_call_expr (expfn, arglist);\n \t    }\n \n+\t  /* Optimize sqrt(Nroot(x)) -> pow(x,1/(2*N)).  */\n+\t  if (flag_unsafe_math_optimizations && BUILTIN_ROOT_P (fcode))\n+\t    {\n+\t      tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n+\t      \n+\t      if (powfn)\n+\t        {\n+\t\t  tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t\t  tree tree_root;\n+\t\t  /* The inner root was either sqrt or cbrt.  */\n+\t\t  REAL_VALUE_TYPE dconstroot =\n+\t\t    BUILTIN_SQRT_P (fcode) ? dconsthalf : dconstthird;\n+\t\t  \n+\t\t  /* Adjust for the outer root.  */\n+\t\t  dconstroot.exp--;\n+\t\t  dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot);\n+\t\t  tree_root = build_real (type, dconstroot);\n+\t\t  arglist = tree_cons (NULL_TREE, arg0,\n+\t\t\t\t       build_tree_list (NULL_TREE, tree_root));\n+\t\t  return build_function_call_expr (powfn, arglist);\n+\t\t}\n+\t    }\n+\n \t  /* Optimize sqrt(pow(x,y)) = pow(x,y*0.5).  */\n \t  if (flag_unsafe_math_optimizations\n \t      && (fcode == BUILT_IN_POW\n@@ -6708,6 +6731,56 @@ fold_builtin (tree exp)\n \t}\n       break;\n \n+    case BUILT_IN_CBRT:\n+    case BUILT_IN_CBRTF:\n+    case BUILT_IN_CBRTL:\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\t{\n+\t  tree arg = TREE_VALUE (arglist);\n+\t  const enum built_in_function fcode = builtin_mathfn_code (arg);\n+\n+\t  /* Optimize cbrt of constant value.  */\n+\t  if (real_zerop (arg) || real_onep (arg) || real_minus_onep (arg))\n+\t    return arg;\n+\n+\t  /* Optimize cbrt(expN(x)) -> expN(x/3).  */\n+\t  if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n+\t    {\n+\t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n+\t      const REAL_VALUE_TYPE third_trunc =\n+\t\treal_value_truncate (TYPE_MODE (type), dconstthird);\n+\t      arg = fold (build (MULT_EXPR, type,\n+\t\t\t\t TREE_VALUE (TREE_OPERAND (arg, 1)),\n+\t\t\t\t build_real (type, third_trunc)));\n+\t      arglist = build_tree_list (NULL_TREE, arg);\n+\t      return build_function_call_expr (expfn, arglist);\n+\t    }\n+\n+\t  /* Optimize cbrt(sqrt(x)) -> pow(x,1/6).  */\n+\t  /* We don't optimize cbrt(cbrt(x)) -> pow(x,1/9) because if\n+             x is negative pow will error but cbrt won't.  */\n+\t  if (flag_unsafe_math_optimizations && BUILTIN_SQRT_P (fcode))\n+\t    {\n+\t      tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n+\n+\t      if (powfn)\n+\t        {\n+\t\t  tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t\t  tree tree_root;\n+\t\t  REAL_VALUE_TYPE dconstroot = dconstthird;\n+\n+\t\t  dconstroot.exp--;\n+\t\t  dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot);\n+\t\t  tree_root = build_real (type, dconstroot);\n+\t\t  arglist = tree_cons (NULL_TREE, arg0,\n+\t\t\t\t       build_tree_list (NULL_TREE, tree_root));\n+\t\t  return build_function_call_expr (powfn, arglist);\n+\t\t}\n+\t      \n+\t    }\n+\t}\n+      break;\n+\n     case BUILT_IN_SIN:\n     case BUILT_IN_SINF:\n     case BUILT_IN_SINL:"}, {"sha": "e8c36f029ee740eb598f598f3127a2a75709c29a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e19f6bded7ebdab435f14256f33376d36ee94b1c", "patch": "@@ -6389,23 +6389,24 @@ fold (tree expr)\n \t      enum built_in_function fcode0 = builtin_mathfn_code (arg0);\n \t      enum built_in_function fcode1 = builtin_mathfn_code (arg1);\n \n-\t      /* Optimizations of sqrt(...)*sqrt(...).  */\n-\t      if (fcode0 == fcode1 && BUILTIN_SQRT_P (fcode0))\n+\t      /* Optimizations of root(...)*root(...).  */\n+\t      if (fcode0 == fcode1 && BUILTIN_ROOT_P (fcode0))\n \t\t{\n-\t\t  tree sqrtfn, arg, arglist;\n+\t\t  tree rootfn, arg, arglist;\n \t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n \t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n \n \t\t  /* Optimize sqrt(x)*sqrt(x) as x.  */\n-\t\t  if (operand_equal_p (arg00, arg10, 0)\n+\t\t  if (BUILTIN_SQRT_P (fcode0)\n+\t\t      && operand_equal_p (arg00, arg10, 0)\n \t\t      && ! HONOR_SNANS (TYPE_MODE (type)))\n \t\t    return arg00;\n \n-\t          /* Optimize sqrt(x)*sqrt(y) as sqrt(x*y).  */\n-\t\t  sqrtfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t          /* Optimize root(x)*root(y) as root(x*y).  */\n+\t\t  rootfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n \t\t  arg = fold (build (MULT_EXPR, type, arg00, arg10));\n \t\t  arglist = build_tree_list (NULL_TREE, arg);\n-\t\t  return build_function_call_expr (sqrtfn, arglist);\n+\t\t  return build_function_call_expr (rootfn, arglist);\n \t\t}\n \n \t      /* Optimize expN(x)*expN(y) as expN(x+y).  */"}, {"sha": "afbf937c80b4305fbc7f215c97279bbc333e57e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e19f6bded7ebdab435f14256f33376d36ee94b1c", "patch": "@@ -1,3 +1,9 @@\n+2004-03-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-explog-1.c: Add new cases.\n+\t* gcc.dg/torture/builtin-math-1.c: Likewise.\n+\t* builtin-power-1.c: New test.\n+\n 2004-03-24  Andreas Schwab  <schwab@suse.de>\n \n \t* lib/prune.exp (prune_gcc_output): Ignore errata warning from"}, {"sha": "4d7de84cbb5d4d9cec3a500618fd25ca726e66ba", "filename": "gcc/testsuite/gcc.dg/torture/builtin-explog-1.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-explog-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-explog-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-explog-1.c?ref=e19f6bded7ebdab435f14256f33376d36ee94b1c", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2003  Free Software Foundation.\n+/* Copyright (C) 2003, 2004  Free Software Foundation.\n \n    Verify that built-in math function constant folding of log & exp is\n    correctly performed by the compiler.\n@@ -119,6 +119,17 @@ void test(double d1, double d2, float f1, float f2,\n   LOG_CBRT(log2);\n   LOG_CBRT(log10);\n   \n+  /* Test cbrt(expN(x)) -> expN(x/3).  */\n+#define CBRT_EXP(EXP) \\\n+ extern void link_failure_cbrt_##EXP(void); \\\n+ if (cbrt(EXP(d1)) != EXP(d1/3.0) || cbrtf(EXP##f(f1)) != EXP##f(f1/3.0F) \\\n+  || cbrtl(EXP##l(ld1)) != EXP##l(ld1/3.0L)) link_failure_cbrt_##EXP()\n+    \n+  CBRT_EXP(exp);\n+  CBRT_EXP(exp2);\n+  CBRT_EXP(exp10);\n+  CBRT_EXP(pow10);\n+  \n   /* Test logN(pow(x,y)) -> y*logN(x).  */\n #define LOG_POW(LOG, POW) \\\n  extern void link_failure_##LOG##_##POW(void); \\"}, {"sha": "99fef8d7825e2602540d1589f4f8945015a09f79", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-1.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-1.c?ref=e19f6bded7ebdab435f14256f33376d36ee94b1c", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003  Free Software Foundation.\n+/* Copyright (C) 2002, 2003, 2004  Free Software Foundation.\n \n    Verify that built-in math function constant folding of constant\n    arguments is correctly performed by the compiler.\n@@ -18,6 +18,15 @@ void test (float f, double d, long double ld)\n   if (sqrt (1.0) != 1.0)\n     link_error ();\n \n+  if (cbrt (0.0) != 0.0)\n+    link_error ();\n+\n+  if (cbrt (1.0) != 1.0)\n+    link_error ();\n+\n+  if (cbrt (-1.0) != -1.0)\n+    link_error ();\n+\n   if (exp (0.0) != 1.0)\n     link_error ();\n \n@@ -55,6 +64,15 @@ void test (float f, double d, long double ld)\n   if (sqrtf (1.0F) != 1.0F)\n     link_error ();\n \n+  if (cbrtf (0.0F) != 0.0F)\n+    link_error ();\n+\n+  if (cbrtf (1.0F) != 1.0F)\n+    link_error ();\n+\n+  if (cbrtf (-1.0F) != -1.0F)\n+    link_error ();\n+\n   if (expf (0.0F) != 1.0F)\n     link_error ();\n \n@@ -92,6 +110,15 @@ void test (float f, double d, long double ld)\n   if (sqrtl (1.0L) != 1.0L)\n     link_error ();\n \n+  if (cbrtl (0.0L) != 0.0L)\n+    link_error ();\n+\n+  if (cbrtl (1.0L) != 1.0L)\n+    link_error ();\n+\n+  if (cbrtl (-1.0L) != -1.0L)\n+    link_error ();\n+\n   if (expl (0.0L) != 1.0L)\n     link_error ();\n "}, {"sha": "45566118a818de6beba8f983358e78127fa6df64", "filename": "gcc/testsuite/gcc.dg/torture/builtin-power-1.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-power-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f6bded7ebdab435f14256f33376d36ee94b1c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-power-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-power-1.c?ref=e19f6bded7ebdab435f14256f33376d36ee94b1c", "patch": "@@ -0,0 +1,105 @@\n+/* Copyright (C) 2004  Free Software Foundation.\n+\n+   Verify that built-in folding of various math \"power\" functions is\n+   correctly performed by the compiler.\n+\n+   Written by Kaveh Ghazi, 2004-03-11.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-ffast-math\" } */\n+\n+#include \"../builtins-config.h\"\n+\n+#ifdef HAVE_C99_RUNTIME\n+#define C99CODE(CODE) CODE\n+#else\n+#define C99CODE(CODE) 0\n+#endif\n+\n+#define PROTOTYPE(FN) extern double FN(double); extern float FN##f(float); \\\n+  extern long double FN##l(long double);\n+#define PROTOTYPE2(FN) extern double FN(double, double); \\\n+  extern float FN##f(float, float); \\\n+  extern long double FN##l(long double, long double);\n+\n+PROTOTYPE(sqrt)\n+PROTOTYPE(cbrt)\n+PROTOTYPE2(pow)\n+\n+void test(double d1, double d2, double d3,\n+\t  float f1, float f2, float f3,\n+\t  long double ld1, long double ld2, long double ld3)\n+{\n+  /* Test N1root(N2root(x)) -> pow(x,1/(N1*N2)).  */\n+  /* E.g. sqrt(cbrt(x)) -> pow(x,1/6).  */\n+#define ROOT_ROOT(FN1,N1,FN2,N2) \\\n+ extern void link_failure_##FN1##_##FN2(void); \\\n+ if (FN1(FN2(d1)) != pow(d1,1.0/(N1*N2)) \\\n+     || C99CODE (FN1##f(FN2##f(f1)) != powf(f1,1.0F/(N1*N2))) \\\n+     || C99CODE (FN1##l(FN2##l(ld1)) != powl(ld1,1.0L/(N1*N2)))) \\\n+    link_failure_##FN1##_##FN2()\n+\n+  ROOT_ROOT(sqrt,2,sqrt,2);\n+  ROOT_ROOT(sqrt,2,cbrt,3);\n+  ROOT_ROOT(cbrt,3,sqrt,2);\n+  /*ROOT_ROOT(cbrt,3,cbrt,3); Intentionally not implemented.  */\n+\n+  /* Test pow(Nroot(x),y) -> pow(x,y/N).  */\n+#define POW_ROOT(FN,N) \\\n+ extern void link_failure_pow_##FN(void); \\\n+ if (pow(FN(d1), d2) != pow(d1,d2/N) \\\n+     || powf(FN##f(f1),f2) != powf(f1,f2/N) \\\n+     || powl(FN##l(ld1),ld2) != powl(ld1,ld2/N)) \\\n+    link_failure_pow_##FN()\n+\n+  POW_ROOT(sqrt,2);\n+  /*POW_ROOT(cbrt,3); Intentionally not implemented.  */\n+\n+  /* Test Nroot(pow(x,y)) -> pow(x,y/N).  */\n+#define ROOT_POW(FN,N) \\\n+ extern void link_failure_##FN##_pow(void); \\\n+ if (FN(pow(d1, d2)) != pow(d1,d2/N) \\\n+     || FN##f(powf(f1,f2)) != powf(f1,f2/N) \\\n+     || FN##l(powl(ld1,ld2)) != powl(ld1,ld2/N)) \\\n+    link_failure_##FN##_pow()\n+\n+  ROOT_POW(sqrt,2);\n+  /*ROOT_POW(cbrt,3); Intentionally not implemented.  */\n+\n+  /* Test pow(pow(x,y),z) -> pow(x,y*z).  */\n+#define POW_POW \\\n+ extern void link_failure_pow_pow(void); \\\n+ if (pow(pow(d1, d2), d3) != pow(d1,d2*d3) \\\n+     || powf(powf(f1,f2),f3) != powf(f1,f2*f3) \\\n+     || powl(powl(ld1,ld2),ld3) != powl(ld1,ld2*ld3)) \\\n+    link_failure_pow_pow()\n+\n+  POW_POW;\n+\n+  /* Test Nroot(x)*Nroot(y) -> Nroot(x*y).  */\n+#define ROOT_X_ROOT(FN) \\\n+ extern void link_failure_root_x_root(void); \\\n+ if (FN(d1)*FN(d2) != FN(d1*d2) \\\n+     || FN##f(f1)*FN##f(f2) != FN##f(f1*f2) \\\n+     || FN##l(ld1)*FN##l(ld2) != FN##l(ld1*ld2)) \\\n+    link_failure_root_x_root()\n+\n+  ROOT_X_ROOT(sqrt);\n+  ROOT_X_ROOT(cbrt);\n+  \n+  /* Test pow(x,y)*pow(x,z) -> pow(x,y+z).  */\n+#define POW_X_POW \\\n+ extern void link_failure_pow_x_pow(void); \\\n+ if (pow(d1,d2)*pow(d1,d3) != pow(d1,d2+d3) \\\n+     || powf(f1,f2)*powf(f1,f3) != powf(f1,f2+f3) \\\n+     || powl(ld1,ld2)*powl(ld1,ld3) != powl(ld1,ld2+ld3)) \\\n+    link_failure_pow_x_pow()\n+\n+  POW_X_POW;\n+  \n+}\n+\n+int main (void)\n+{\n+  return 0;\n+}"}]}