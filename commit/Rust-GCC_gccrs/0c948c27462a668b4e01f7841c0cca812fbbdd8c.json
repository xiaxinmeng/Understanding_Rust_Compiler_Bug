{"sha": "0c948c27462a668b4e01f7841c0cca812fbbdd8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM5NDhjMjc0NjJhNjY4YjRlMDFmNzg0MWMwY2NhODEyZmJiZGQ4Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-03-08T17:36:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-03-08T17:36:05Z"}, "message": "tree-vrp.c: Include \"intl.h\".\n\n./:\t* tree-vrp.c: Include \"intl.h\".\n\t(usable_range_p): New static function.\n\t(compare_values_warnv): Don't test TYPE_OVERFLOW_UNDEFINED for\n\toverflowed values, juts set *strict_overflow_p.\n\t(compare_values): Only return -2 if one of the operands is not a\n\tconstant.\n\t(compare_ranges): Call usable_range_p.\n\t(compare_range_with_value): Likewise.\n\t(vrp_evaluate_conditional_warnv): Rename from\n\tvrp_evaluate_conditional.  Make static.  Change all callers.\n\t(vrp_evaluate_conditional): New function.\n\t(simplify_div_or_mod_using_ranges): Issue warning about reliance\n\ton signed overflow.\n\t(simplify_abs_using_ranges): Likewise.\n\t(simplify_stmt_for_jump_threading): Add within_stmt parameter.\n\t* tree-ssa-dom.c (simplify_stmt_for_jump_threading): Add\n\twithin_stmt parameter.\n\t* tree-ssa-propagate.c (fold_predicate_in): Update call to\n\tvrp_evaluate_conditional.\n\t* tree-ssa-threadedge.c\n\t(record_temporary_equivalences_from_stmts_at_dest): Change\n\tsimplify parameter to take a second tree parameter.\n\t(simplify_control_stmt_condition): Likewise.\n\t(thread_across_edge): Likewise.\n\t* tree-flow.h (vrp_evaluate_conditional): Update declaration.\n\t(thread_across_edge): Likewise.\n\t* gcc/Makefile.in (tree-vrp.o): Depend upon intl.h.\ntestsuite/:\n\t* gcc.dg/no-strict-overflow-5.c: New test.\n\t* gcc.dg/no-strict-overflow-6.c: New test.\n\t* gcc.dg/Wstrict-overflow-11.c: New test.\n\t* gcc.dg/Wstrict-overflow-12.c: New test.\n\t* gcc.dg/Wstrict-overflow-13.c: New test.\n\t* gcc.dg/Wstrict-overflow-14.c: New test.\n\t* gcc.dg/Wstrict-overflow-15.c: New test.\n\nFrom-SVN: r122706", "tree": {"sha": "fa8cc8f84a345de54e6ab532ecec5b191cd7a5ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa8cc8f84a345de54e6ab532ecec5b191cd7a5ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c948c27462a668b4e01f7841c0cca812fbbdd8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c948c27462a668b4e01f7841c0cca812fbbdd8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c948c27462a668b4e01f7841c0cca812fbbdd8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c948c27462a668b4e01f7841c0cca812fbbdd8c/comments", "author": null, "committer": null, "parents": [{"sha": "3c2d980c94357e2a020597a47cee0ee1c2458be7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2d980c94357e2a020597a47cee0ee1c2458be7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2d980c94357e2a020597a47cee0ee1c2458be7"}], "stats": {"total": 337, "additions": 307, "deletions": 30}, "files": [{"sha": "5b19aa3454865445e046b8ae873c53da79cb2608", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -1,3 +1,33 @@\n+2007-03-08  Ian Lance Taylor  <iant@google.com>\n+\n+\t* tree-vrp.c: Include \"intl.h\".\n+\t(usable_range_p): New static function.\n+\t(compare_values_warnv): Don't test TYPE_OVERFLOW_UNDEFINED for\n+\toverflowed values, juts set *strict_overflow_p.\n+\t(compare_values): Only return -2 if one of the operands is not a\n+\tconstant.\n+\t(compare_ranges): Call usable_range_p.\n+\t(compare_range_with_value): Likewise.\n+\t(vrp_evaluate_conditional_warnv): Rename from\n+\tvrp_evaluate_conditional.  Make static.  Change all callers.\n+\t(vrp_evaluate_conditional): New function.\n+\t(simplify_div_or_mod_using_ranges): Issue warning about reliance\n+\ton signed overflow.\n+\t(simplify_abs_using_ranges): Likewise.\n+\t(simplify_stmt_for_jump_threading): Add within_stmt parameter.\n+\t* tree-ssa-dom.c (simplify_stmt_for_jump_threading): Add\n+\twithin_stmt parameter.\n+\t* tree-ssa-propagate.c (fold_predicate_in): Update call to\n+\tvrp_evaluate_conditional.\n+\t* tree-ssa-threadedge.c\n+\t(record_temporary_equivalences_from_stmts_at_dest): Change\n+\tsimplify parameter to take a second tree parameter.\n+\t(simplify_control_stmt_condition): Likewise.\n+\t(thread_across_edge): Likewise.\n+\t* tree-flow.h (vrp_evaluate_conditional): Update declaration.\n+\t(thread_across_edge): Likewise.\n+\t* gcc/Makefile.in (tree-vrp.o): Depend upon intl.h.\n+\n 2007-03-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (TARGET_SAHF): New define."}, {"sha": "82821cb4d44d2100728e7cf9ec7d1522659864f0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -2044,7 +2044,7 @@ tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \\\n-   $(CFGLOOP_H) $(SCEV_H) tree-chrec.h $(TIMEVAR_H) toplev.h\n+   $(CFGLOOP_H) $(SCEV_H) tree-chrec.h $(TIMEVAR_H) toplev.h intl.h\n tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "a2780b4a48478bf7e3a2b421d5177b21385719c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -1,3 +1,13 @@\n+2007-03-08  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/no-strict-overflow-5.c: New test.\n+\t* gcc.dg/no-strict-overflow-6.c: New test.\n+\t* gcc.dg/Wstrict-overflow-11.c: New test.\n+\t* gcc.dg/Wstrict-overflow-12.c: New test.\n+\t* gcc.dg/Wstrict-overflow-13.c: New test.\n+\t* gcc.dg/Wstrict-overflow-14.c: New test.\n+\t* gcc.dg/Wstrict-overflow-15.c: New test.\n+\n 2007-03-08  Richard Sandiford  <richard@codesourcery.com>\n \n \t* gcc.c-torture/execute/strcmp-1.x: New file.  XFAIL execution"}, {"sha": "c98610e48a6d7ccb5f4cafed297e34b8efb4ae94", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-11.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-11.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=1\" } */\n+\n+/* Based on strict-overflow-5.c.  */\n+\n+/* We can only unroll when using strict overflow semantics.  */\n+\n+int foo (int i)\n+{\n+  int index;\n+  int r=0;\n+ \n+  for (index = i; index <= i+4; index+=2) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+    r++;\n+ \n+  return r;\n+}"}, {"sha": "177904db74a31a71ca2f5c19db1c196f0e975481", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-12.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-12.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=2\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-6.c.  */\n+\n+/* VRP test.  This turns into an infinite loop when using strict\n+   overflow semantics.  */\n+\n+int\n+foo ()\n+{\n+  int i, bits;\n+  for (i = 1, bits = 1; i > 0; i += i) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+    ++bits;\n+  return bits;\n+}"}, {"sha": "170d13777fac3ee0d5da805a0f3707ca273ccc6d", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-13.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-13.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=2\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-6.c.  */\n+\n+/* VRP test.  This turns into an infinite loop (depending on what\n+   bigtime_test does), but at least we warn about it.  */\n+\n+extern int bigtime_test (int);\n+int\n+foo ()\n+{\n+  int j;\n+  for (j = 1; 0 < j; j *= 2) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+    if (! bigtime_test (j))\n+      return 1;\n+  return 0;\n+}"}, {"sha": "6f3c5a24fd15018f0b9fcf446fcf3d89313a555a", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-14.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-14.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=4\" } */\n+\n+/* Source: Ian Lance Taylor.  */\n+\n+int\n+foo (int j)\n+{\n+  int i;\n+  int sum = 0;\n+\n+  for (i = 1; i < j; i += i)\n+    sum += i / 16; /* { dg-warning \"assuming signed overflow does not occur\" \"\" } */\n+  return sum;\n+}"}, {"sha": "d1627d2f47b64f0b3dd815c33f2e8e34255d8d7e", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-15.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-15.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=4\" } */\n+\n+/* Source: Ian Lance Taylor.  */\n+\n+int\n+foo (int j)\n+{\n+  int i;\n+  int sum = 0;\n+\n+  for (i = 1; i < j; i += i)\n+    sum += __builtin_abs (i); /* { dg-warning \"assuming signed overflow does not occur\" \"\" } */\n+  return sum;\n+}"}, {"sha": "7f82014c76e47ea0e6f81e6e6e40d7b23f1cc1da", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-5.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Dual of strict-overflow-5.c.  */\n+\n+/* We can only unroll when using strict overflow semantics.  */\n+\n+int foo (int i)\n+{\n+  int index;\n+  int r=0;\n+ \n+  for (index = i; index <= i+4; index+=2) \n+    r++;\n+ \n+  return r;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"r = 3\" 0 \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "664aa256af5086a9d310b5aae422515b8cd045c8", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-6.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-6.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  */\n+\n+/* VRP test.  We can not simplify the conditional when not using\n+   strict overflow semantics.  We don't test this with\n+   -fstrict-overflow because it turns into an infinite loop.  That is\n+   OK but it would also be OK to not do that.  */\n+\n+int\n+foo ()\n+{\n+  int i, bits;\n+  for (i = 1, bits = 1; i > 0; i += i)\n+    ++bits;\n+  return bits;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return bits\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "bb087322e50e63f8e48a9426b88be7dc6145070f", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -776,7 +776,7 @@ bool fold_stmt_inplace (tree);\n tree widen_bitfield (tree, tree, tree);\n \n /* In tree-vrp.c  */\n-tree vrp_evaluate_conditional (tree, bool, bool *);\n+tree vrp_evaluate_conditional (tree, tree);\n void simplify_stmt_using_ranges (tree);\n \n /* In tree-ssa-dom.c  */\n@@ -910,7 +910,7 @@ bool contains_abnormal_ssa_name_p (tree);\n /* In tree-ssa-threadedge.c */\n extern bool potentially_threadable_block (basic_block);\n extern void thread_across_edge (tree, edge, bool,\n-\t\t\t\tVEC(tree, heap) **, tree (*) (tree));\n+\t\t\t\tVEC(tree, heap) **, tree (*) (tree, tree));\n \n /* In tree-ssa-loop-im.c  */\n /* The possibilities of statement movement.  */"}, {"sha": "22e0121efbdb8719e4553be213100a57641e4714", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -554,7 +554,7 @@ restore_vars_to_original_value (void)\n /* A trivial wrapper so that we can present the generic jump\n    threading code with a simple API for simplifying statements.  */\n static tree\n-simplify_stmt_for_jump_threading (tree stmt)\n+simplify_stmt_for_jump_threading (tree stmt, tree within_stmt ATTRIBUTE_UNUSED)\n {\n   return lookup_avail_expr (stmt, false);\n }"}, {"sha": "1981fa1783be6c9c352eaba1d6762a2f33b28e4d", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -1100,7 +1100,6 @@ fold_predicate_in (tree stmt)\n   tree *pred_p = NULL;\n   bool modify_stmt_p = false;\n   tree val;\n-  bool sop;\n \n   if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n       && COMPARISON_CLASS_P (GIMPLE_STMT_OPERAND (stmt, 1)))\n@@ -1113,8 +1112,7 @@ fold_predicate_in (tree stmt)\n   else\n     return false;\n \n-  sop = false;\n-  val = vrp_evaluate_conditional (*pred_p, true, &sop);\n+  val = vrp_evaluate_conditional (*pred_p, stmt);\n   if (val)\n     {\n       if (modify_stmt_p)"}, {"sha": "777685af6522dacad68350d301fc842cee20d800", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -211,7 +211,8 @@ record_temporary_equivalences_from_phis (edge e, VEC(tree, heap) **stack)\n static tree\n record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t\t\t\t\t\t  VEC(tree, heap) **stack,\n-\t\t\t\t\t\t  tree (*simplify) (tree))\n+\t\t\t\t\t\t  tree (*simplify) (tree,\n+\t\t\t\t\t\t\t\t    tree))\n {\n   block_stmt_iterator bsi;\n   tree stmt = NULL;\n@@ -315,7 +316,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t      cached_lhs = fold (pre_fold_expr);\n \t      if (TREE_CODE (cached_lhs) != SSA_NAME\n \t\t  && !is_gimple_min_invariant (cached_lhs))\n-\t        cached_lhs = (*simplify) (stmt);\n+\t        cached_lhs = (*simplify) (stmt, stmt);\n \t    }\n \n \t  /* Restore the statement's original uses/defs.  */\n@@ -353,7 +354,7 @@ static tree\n simplify_control_stmt_condition (edge e,\n \t\t\t\t tree stmt,\n \t\t\t\t tree dummy_cond,\n-\t\t\t\t tree (*simplify) (tree),\n+\t\t\t\t tree (*simplify) (tree, tree),\n \t\t\t\t bool handle_dominating_asserts)\n {\n   tree cond, cached_lhs;\n@@ -439,7 +440,7 @@ simplify_control_stmt_condition (edge e,\n       /* If we have not simplified the condition down to an invariant,\n \t then use the pass specific callback to simplify the condition.  */\n       if (! is_gimple_min_invariant (cached_lhs))\n-\tcached_lhs = (*simplify) (dummy_cond);\n+\tcached_lhs = (*simplify) (dummy_cond, stmt);\n     }\n \n   /* We can have conditionals which just test the state of a variable\n@@ -466,7 +467,7 @@ simplify_control_stmt_condition (edge e,\n       /* If we haven't simplified to an invariant yet, then use the\n \t pass specific callback to try and simplify it further.  */\n       if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n-        cached_lhs = (*simplify) (stmt);\n+        cached_lhs = (*simplify) (stmt, stmt);\n     }\n   else\n     cached_lhs = NULL;\n@@ -494,7 +495,7 @@ thread_across_edge (tree dummy_cond,\n \t\t    edge e,\n \t\t    bool handle_dominating_asserts,\n \t\t    VEC(tree, heap) **stack,\n-\t\t    tree (*simplify) (tree))\n+\t\t    tree (*simplify) (tree, tree))\n {\n   tree stmt;\n "}, {"sha": "0e0e327c50e4c3db4a8c19d6f840b95fe36f43c2", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 133, "deletions": 17, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c948c27462a668b4e01f7841c0cca812fbbdd8c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0c948c27462a668b4e01f7841c0cca812fbbdd8c", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n #include \"toplev.h\"\n+#include \"intl.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-propagate.h\"\n@@ -46,6 +47,7 @@ static sbitmap found_in_subgraph;\n static int compare_values (tree val1, tree val2);\n static int compare_values_warnv (tree val1, tree val2, bool *);\n static void vrp_meet (value_range_t *, value_range_t *);\n+static tree vrp_evaluate_conditional_warnv (tree, bool, bool *);\n \n /* Location information for ASSERT_EXPRs.  Each instance of this\n    structure describes an ASSERT_EXPR for an SSA name.  Since a single\n@@ -543,6 +545,32 @@ overflow_infinity_range_p (value_range_t *vr)\n \t      || is_overflow_infinity (vr->max)));\n }\n \n+/* Return false if we can not make a valid comparison based on VR;\n+   this will be the case if it uses an overflow infinity and overflow\n+   is not undefined (i.e., -fno-strict-overflow is in effect).\n+   Otherwise return true, and set *STRICT_OVERFLOW_P to true if VR\n+   uses an overflow infinity.  */\n+\n+static bool\n+usable_range_p (value_range_t *vr, bool *strict_overflow_p)\n+{\n+  gcc_assert (vr->type == VR_RANGE);\n+  if (is_overflow_infinity (vr->min))\n+    {\n+      *strict_overflow_p = true;\n+      if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (vr->min)))\n+\treturn false;\n+    }\n+  if (is_overflow_infinity (vr->max))\n+    {\n+      *strict_overflow_p = true;\n+      if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (vr->max)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+\n /* Like tree_expr_nonnegative_warnv_p, but this function uses value\n    ranges obtained so far.  */\n \n@@ -783,9 +811,8 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \t infinities.  */\n       if (TREE_OVERFLOW (val1) || TREE_OVERFLOW (val2))\n \t{\n-\t  if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n-\t    return -2;\n-\n+\t  if (strict_overflow_p != NULL)\n+\t    *strict_overflow_p = true;\n \t  if (is_negative_overflow_infinity (val1))\n \t    return is_negative_overflow_infinity (val2) ? 0 : -1;\n \t  else if (is_negative_overflow_infinity (val2))\n@@ -831,8 +858,8 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n     }\n }\n \n-/* Compare values like compare_values_warnv, but treat comparisons\n-   which rely on undefined overflow as incomparable.  */\n+/* Compare values like compare_values_warnv, but treat comparisons of\n+   nonconstants which rely on undefined overflow as incomparable.  */\n \n static int\n compare_values (tree val1, tree val2)\n@@ -842,7 +869,8 @@ compare_values (tree val1, tree val2)\n \n   sop = false;\n   ret = compare_values_warnv (val1, val2, &sop);\n-  if (sop)\n+  if (sop\n+      && (!is_gimple_min_invariant (val1) || !is_gimple_min_invariant (val2)))\n     ret = -2;\n   return ret;\n }\n@@ -2359,7 +2387,7 @@ static void\n extract_range_from_comparison (value_range_t *vr, tree expr)\n {\n   bool sop = false;\n-  tree val = vrp_evaluate_conditional (expr, false, &sop);\n+  tree val = vrp_evaluate_conditional_warnv (expr, false, &sop);\n \n   /* A disadvantage of using a special infinity as an overflow\n      representation is that we lose the ability to record overflow\n@@ -2604,6 +2632,10 @@ compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1,\n       return NULL_TREE;\n     }\n \n+  if (!usable_range_p (vr0, strict_overflow_p)\n+      || !usable_range_p (vr1, strict_overflow_p))\n+    return NULL_TREE;\n+\n   /* Simplify processing.  If COMP is GT_EXPR or GE_EXPR, switch the\n      operands around and change the comparison code.  */\n   if (comp == GT_EXPR || comp == GE_EXPR)\n@@ -2737,6 +2769,9 @@ compare_range_with_value (enum tree_code comp, value_range_t *vr, tree val,\n       return NULL_TREE;\n     }\n \n+  if (!usable_range_p (vr, strict_overflow_p))\n+    return NULL_TREE;\n+\n   if (comp == EQ_EXPR)\n     {\n       /* EQ_EXPR may only be computed if VR represents exactly\n@@ -4531,8 +4566,9 @@ compare_names (enum tree_code comp, tree n1, tree n2,\n    Set *STRICT_OVERFLOW_P to indicate whether we relied on an overflow\n    infinity to produce the result.  */\n \n-tree\n-vrp_evaluate_conditional (tree cond, bool use_equiv_p, bool *strict_overflow_p)\n+static tree\n+vrp_evaluate_conditional_warnv (tree cond, bool use_equiv_p,\n+\t\t\t\tbool *strict_overflow_p)\n {\n   gcc_assert (TREE_CODE (cond) == SSA_NAME\n               || TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison);\n@@ -4609,6 +4645,55 @@ vrp_evaluate_conditional (tree cond, bool use_equiv_p, bool *strict_overflow_p)\n   return NULL_TREE;\n }\n \n+/* Given COND within STMT, try to simplify it based on value range\n+   information.  Return NULL if the conditional can not be evaluated.\n+   The ranges of all the names equivalent with the operands in COND\n+   will be used when trying to compute the value.  If the result is\n+   based on undefined signed overflow, issue a warning if\n+   appropriate.  */\n+\n+tree\n+vrp_evaluate_conditional (tree cond, tree stmt)\n+{\n+  bool sop;\n+  tree ret;\n+\n+  sop = false;\n+  ret = vrp_evaluate_conditional_warnv (cond, true, &sop);\n+\n+  if (ret && sop)\n+    {\n+      enum warn_strict_overflow_code wc;\n+      const char* warnmsg;\n+\n+      if (is_gimple_min_invariant (ret))\n+\t{\n+\t  wc = WARN_STRICT_OVERFLOW_CONDITIONAL;\n+\t  warnmsg = G_(\"assuming signed overflow does not occur when \"\n+\t\t       \"simplifying conditional to constant\");\n+\t}\n+      else\n+\t{\n+\t  wc = WARN_STRICT_OVERFLOW_COMPARISON;\n+\t  warnmsg = G_(\"assuming signed overflow does not occur when \"\n+\t\t       \"simplifying conditional\");\n+\t}\n+\n+      if (issue_strict_overflow_warning (wc))\n+\t{\n+\t  location_t locus;\n+\n+\t  if (!EXPR_HAS_LOCATION (stmt))\n+\t    locus = input_location;\n+\t  else\n+\t    locus = EXPR_LOCATION (stmt);\n+\t  warning (OPT_Wstrict_overflow, \"%H%s\", &locus, warnmsg);\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n \n /* Visit conditional statement STMT.  If we can determine which edge\n    will be taken out of STMT's basic block, record it in\n@@ -4693,7 +4778,7 @@ vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n      MICO, TRAMP3D and SPEC2000) showed that doing this results in\n      4 more predicates folded in SPEC.  */\n   sop = false;\n-  val = vrp_evaluate_conditional (cond, false, &sop);\n+  val = vrp_evaluate_conditional_warnv (cond, false, &sop);\n   if (val)\n     {\n       if (!sop)\n@@ -5071,6 +5156,23 @@ simplify_div_or_mod_using_ranges (tree stmt, tree rhs, enum tree_code rhs_code)\n       bool sop = false;\n \n       val = compare_range_with_value (GT_EXPR, vr, integer_zero_node, &sop);\n+\n+      if (val\n+\t  && sop\n+\t  && integer_onep (val)\n+\t  && issue_strict_overflow_warning (WARN_STRICT_OVERFLOW_MISC))\n+\t{\n+\t  location_t locus;\n+\n+\t  if (!EXPR_HAS_LOCATION (stmt))\n+\t    locus = input_location;\n+\t  else\n+\t    locus = EXPR_LOCATION (stmt);\n+\t  warning (OPT_Wstrict_overflow,\n+\t\t   (\"%Hassuming signed overflow does not occur when \"\n+\t\t    \"simplifying / or %% to >> or &\"),\n+\t\t   &locus);\n+\t}\n     }\n \n   if (val && integer_onep (val))\n@@ -5138,6 +5240,20 @@ simplify_abs_using_ranges (tree stmt, tree rhs)\n \t{\n \t  tree t;\n \n+\t  if (sop && issue_strict_overflow_warning (WARN_STRICT_OVERFLOW_MISC))\n+\t    {\n+\t      location_t locus;\n+\n+\t      if (!EXPR_HAS_LOCATION (stmt))\n+\t\tlocus = input_location;\n+\t      else\n+\t\tlocus = EXPR_LOCATION (stmt);\n+\t      warning (OPT_Wstrict_overflow,\n+\t\t       (\"%Hassuming signed overflow does not occur when \"\n+\t\t\t\"simplifying abs (X) to X or -X\"),\n+\t\t       &locus);\n+\t    }\n+\n \t  if (integer_onep (val))\n \t    t = build1 (NEGATE_EXPR, TREE_TYPE (op), op);\n \t  else\n@@ -5330,21 +5446,21 @@ simplify_stmt_using_ranges (tree stmt)\n    restored.  */\n static VEC(tree,heap) *stack;\n \n-/* A trivial wrapper so that we can present the generic jump\n-   threading code with a simple API for simplifying statements.  */\n+/* A trivial wrapper so that we can present the generic jump threading\n+   code with a simple API for simplifying statements.  STMT is the\n+   statement we want to simplify, WITHIN_STMT provides the location\n+   for any overflow warnings.  */\n+\n static tree\n-simplify_stmt_for_jump_threading (tree stmt)\n+simplify_stmt_for_jump_threading (tree stmt, tree within_stmt)\n {\n-  bool sop;\n-\n   /* We only use VRP information to simplify conditionals.  This is\n      overly conservative, but it's unclear if doing more would be\n      worth the compile time cost.  */\n   if (TREE_CODE (stmt) != COND_EXPR)\n     return NULL;\n \n-  sop = false;\n-  return vrp_evaluate_conditional (COND_EXPR_COND (stmt), true, &sop);\n+  return vrp_evaluate_conditional (COND_EXPR_COND (stmt), within_stmt);\n }\n \n /* Blocks which have more than one predecessor and more than"}]}