{"sha": "a026b59e7711ffa23137a1255f1acc5c73589412", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAyNmI1OWU3NzExZmZhMjMxMzdhMTI1NWYxYWNjNWM3MzU4OTQxMg==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-09-23T14:38:10Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-27T09:19:33Z"}, "message": "[Ada] Fix GNATprove support for iterated_component_associations\n\ngcc/ada/\n\n\t* exp_spark.adb (Expand_SPARK_Array_Aggregate): Dedicated\n\troutine for array aggregates; mostly reuses existing code, but\n\tcalls itself recursively for multi-dimensional array aggregates.\n\t(Expand_SPARK_N_Aggregate): Call Expand_SPARK_Array_Aggregate to\n\tdo the actual expansion, starting from the first index of the\n\tarray type.", "tree": {"sha": "b5b948f5f9f12583a34c33431655d4e3c46d6fd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5b948f5f9f12583a34c33431655d4e3c46d6fd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a026b59e7711ffa23137a1255f1acc5c73589412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a026b59e7711ffa23137a1255f1acc5c73589412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a026b59e7711ffa23137a1255f1acc5c73589412", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a026b59e7711ffa23137a1255f1acc5c73589412/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb00cc7032bf1129373edd2bd99cf02fe03fd1d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb00cc7032bf1129373edd2bd99cf02fe03fd1d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb00cc7032bf1129373edd2bd99cf02fe03fd1d8"}], "stats": {"total": 172, "additions": 112, "deletions": 60}, "files": [{"sha": "75cdbe6344612c9aa7efb9aae9e0b90e22e25dec", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 112, "deletions": 60, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a026b59e7711ffa23137a1255f1acc5c73589412/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a026b59e7711ffa23137a1255f1acc5c73589412/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=a026b59e7711ffa23137a1255f1acc5c73589412", "patch": "@@ -52,6 +52,13 @@ package body Exp_SPARK is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Expand_SPARK_Array_Aggregate (N : Node_Id; Index : Node_Id);\n+   --  Perform array-aggregate-specific expansion of an array sub-aggregate N\n+   --  corresponding to the Index of the outer-most aggregate. This routine\n+   --  mimics Resolve_Array_Aggregate which only checks the aggregate for being\n+   --  well-formed, but doesn't analyze nor apply range checks to\n+   --  iterated_component_associations.\n+\n    procedure Expand_SPARK_N_Aggregate (N : Node_Id);\n    --  Perform aggregate-specific expansion\n \n@@ -153,6 +160,107 @@ package body Exp_SPARK is\n       end case;\n    end Expand_SPARK;\n \n+   ----------------------------------\n+   -- Expand_SPARK_Array_Aggregate --\n+   ----------------------------------\n+\n+   procedure Expand_SPARK_Array_Aggregate (N : Node_Id; Index : Node_Id) is\n+\n+      procedure Expand_Aggr_Expr (Expr : Node_Id);\n+      --  If Expr is a subaggregate, then process it recursively; otherwise it\n+      --  is an expression for the array components which might not have been\n+      --  analyzed and where scalar range checks could be missing.\n+\n+      ----------------------\n+      -- Expand_Aggr_Expr --\n+      ----------------------\n+\n+      procedure Expand_Aggr_Expr (Expr : Node_Id) is\n+         Nxt_Ind : constant Node_Id := Next_Index (Index);\n+      begin\n+         if Present (Nxt_Ind) then\n+            Expand_SPARK_Array_Aggregate (Expr, Index => Nxt_Ind);\n+         else\n+            declare\n+               Comp_Type : constant Entity_Id := Component_Type (Etype (N));\n+            begin\n+               Analyze_And_Resolve (Expr, Comp_Type);\n+\n+               if Is_Scalar_Type (Comp_Type) then\n+                  Apply_Scalar_Range_Check (Expr, Comp_Type);\n+               end if;\n+            end;\n+         end if;\n+      end Expand_Aggr_Expr;\n+\n+      --  Local variables\n+\n+      Assoc : Node_Id := First (Component_Associations (N));\n+\n+   --  Start of processing for Expand_SPARK_Array_Aggregate\n+\n+   begin\n+      while Present (Assoc) loop\n+         --  For iterated_component_association we must apply range check to\n+         --  discrete choices and re-analyze the expression, because frontend\n+         --  only checks its legality and then analyzes the expanded loop code.\n+\n+         if Nkind (Assoc) = N_Iterated_Component_Association then\n+            declare\n+               Choice : Node_Id;\n+            begin\n+               --  Analyze discrete choices\n+\n+               Choice := First (Discrete_Choices (Assoc));\n+\n+               while Present (Choice) loop\n+\n+                  --  The index denotes a range of elements where range checks\n+                  --  have been already applied.\n+\n+                  if Nkind (Choice) in N_Others_Choice\n+                                     | N_Range\n+                                     | N_Subtype_Indication\n+                  then\n+                     null;\n+\n+                  --  Otherwise the index denotes a single element (or a\n+                  --  subtype name which doesn't require range checks).\n+\n+                  else pragma Assert (Nkind (Choice) in N_Subexpr);\n+                     Apply_Scalar_Range_Check (Choice, Etype (Index));\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+\n+               --  Keep processing the expression with index parameter in scope\n+\n+               Push_Scope (Scope (Defining_Identifier (Assoc)));\n+               Enter_Name (Defining_Identifier (Assoc));\n+               Expand_Aggr_Expr (Expression (Assoc));\n+               End_Scope;\n+            end;\n+\n+         --  For ordinary component associations we recurse into subaggregates,\n+         --  because there could be nested iterated_component_association (and\n+         --  it is harmless to analyze and apply checks if there is none).\n+\n+         else pragma Assert (Nkind (Assoc) = N_Component_Association);\n+            declare\n+               Expr : constant Node_Id := Expression (Assoc);\n+               pragma Assert (Present (Expr) xor Box_Present (Assoc));\n+            begin\n+               if Present (Expr) then\n+                  Expand_Aggr_Expr (Expr);\n+               end if;\n+            end;\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+   end Expand_SPARK_Array_Aggregate;\n+\n    ----------------------------------\n    -- Expand_SPARK_Delta_Or_Update --\n    ----------------------------------\n@@ -372,67 +480,11 @@ package body Exp_SPARK is\n    ------------------------------\n \n    procedure Expand_SPARK_N_Aggregate (N : Node_Id) is\n-      Assoc : Node_Id := First (Component_Associations (N));\n+      Aggr_Typ : constant Entity_Id := Etype (N);\n    begin\n-      --  For compilation, frontend analyses a copy of the\n-      --  iterated_component_association's expression for legality checking;\n-      --  (then the expression is copied again when expanding association into\n-      --  assignments for the individual choices). For SPARK we analyze the\n-      --  original expression and apply range checks, if required.\n-\n-      while Present (Assoc) loop\n-         if Nkind (Assoc) = N_Iterated_Component_Association then\n-            declare\n-               Typ : constant Entity_Id := Etype (N);\n-\n-               Comp_Type : constant Entity_Id := Component_Type (Typ);\n-               Expr      : constant Node_Id := Expression (Assoc);\n-               Index_Typ : constant Entity_Id := First_Index (Typ);\n-\n-               Index : Node_Id;\n-\n-            begin\n-               --  Analyze expression with index parameter in scope\n-\n-               Push_Scope (Scope (Defining_Identifier (Assoc)));\n-               Enter_Name (Defining_Identifier (Assoc));\n-               Analyze_And_Resolve (Expr, Comp_Type);\n-\n-               if Is_Scalar_Type (Comp_Type) then\n-                  Apply_Scalar_Range_Check (Expr, Comp_Type);\n-               end if;\n-\n-               End_Scope;\n-\n-               --  Analyze discrete choices\n-\n-               Index := First (Discrete_Choices (Assoc));\n-\n-               while Present (Index) loop\n-\n-                  --  The index denotes a range of elements where range checks\n-                  --  have been already applied.\n-\n-                  if Nkind (Index) in N_Others_Choice\n-                                    | N_Range\n-                                    | N_Subtype_Indication\n-                  then\n-                     null;\n-\n-                  --  Otherwise the index denotes a single element (or a\n-                  --  subtype name which doesn't require range checks).\n-\n-                  else pragma Assert (Nkind (Index) in N_Subexpr);\n-                     Apply_Scalar_Range_Check (Index, Etype (Index_Typ));\n-                  end if;\n-\n-                  Next (Index);\n-               end loop;\n-            end;\n-         end if;\n-\n-         Next (Assoc);\n-      end loop;\n+      if Is_Array_Type (Aggr_Typ) then\n+         Expand_SPARK_Array_Aggregate (N, Index => First_Index (Aggr_Typ));\n+      end if;\n    end Expand_SPARK_N_Aggregate;\n \n    ----------------------------------------"}]}