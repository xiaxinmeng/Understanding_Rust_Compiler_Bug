{"sha": "710b73e6f775809e5aeb26ede61ce8af61edc45a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEwYjczZTZmNzc1ODA5ZTVhZWIyNmVkZTYxY2U4YWY2MWVkYzQ1YQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2003-01-29T14:25:06Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2003-01-29T14:25:06Z"}, "message": "re PR c++/8591 (g++ crashes while instantiating templates)\n\n\tPR c++/8591\n\t* parser.c (cp_parser_elaborated_type_specifier): Convert\n\tTEMPLATE_DECL to TYPE_DECL only when processing template friends.\n\t(cp_parser_maybe_treat_template_as_class): Remove redundant tests.\n\n\t* g++.dg/parse/friend2.C: New test.\n\nFrom-SVN: r62076", "tree": {"sha": "b36a2f8b18ee20da99ba21d4ba6ff7537045ee58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b36a2f8b18ee20da99ba21d4ba6ff7537045ee58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/710b73e6f775809e5aeb26ede61ce8af61edc45a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710b73e6f775809e5aeb26ede61ce8af61edc45a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710b73e6f775809e5aeb26ede61ce8af61edc45a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710b73e6f775809e5aeb26ede61ce8af61edc45a/comments", "author": null, "committer": null, "parents": [{"sha": "2f12fb2b8b6b31c2cebc7b731d424bbdd1cfe22e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f12fb2b8b6b31c2cebc7b731d424bbdd1cfe22e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f12fb2b8b6b31c2cebc7b731d424bbdd1cfe22e"}], "stats": {"total": 85, "additions": 66, "deletions": 19}, "files": [{"sha": "359fdc2b064852dfcb8b0f2a648bd5be092e41bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b73e6f775809e5aeb26ede61ce8af61edc45a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b73e6f775809e5aeb26ede61ce8af61edc45a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=710b73e6f775809e5aeb26ede61ce8af61edc45a", "patch": "@@ -1,3 +1,10 @@\n+2003-01-29  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/8591\n+\t* parser.c (cp_parser_elaborated_type_specifier): Convert\n+\tTEMPLATE_DECL to TYPE_DECL only when processing template friends.\n+\t(cp_parser_maybe_treat_template_as_class): Remove redundant tests.\n+\n 2003-01-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9437"}, {"sha": "da9a92fa126e893f402f34f924e4ff85a2b969ec", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b73e6f775809e5aeb26ede61ce8af61edc45a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b73e6f775809e5aeb26ede61ce8af61edc45a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=710b73e6f775809e5aeb26ede61ce8af61edc45a", "patch": "@@ -8660,8 +8660,31 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t\t\t\t\t/*is_type=*/true,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\t/*check_dependency=*/true);\n+\n+\t  /* If we are parsing friend declaration, DECL may be a\n+\t     TEMPLATE_DECL tree node here.  However, we need to check\n+\t     whether this TEMPLATE_DECL results in valid code.  Consider\n+\t     the following example:\n+\n+\t       namespace N {\n+\t\t template <class T> class C {};\n+\t       }\n+\t       class X {\n+\t\t template <class T> friend class N::C; // #1, valid code\n+\t       };\n+\t       template <class T> class Y {\n+\t\t friend class N::C;\t\t       // #2, invalid code\n+\t       };\n+\n+\t     For both case #1 and #2, we arrive at a TEMPLATE_DECL after\n+\t     name lookup of `N::C'.  We see that friend declaration must\n+\t     be template for the code to be valid.  Note that\n+\t     processing_template_decl does not work here since it is\n+\t     always 1 for the above two cases.  */\n+\n \t  decl = (cp_parser_maybe_treat_template_as_class \n-\t\t  (decl, /*tag_name_p=*/is_friend));\n+\t\t  (decl, /*tag_name_p=*/is_friend\n+\t\t\t && parser->num_template_parameter_lists));\n \n \t  if (TREE_CODE (decl) != TYPE_DECL)\n \t    {\n@@ -13187,18 +13210,8 @@ cp_parser_resolve_typename_type (cp_parser* parser, tree type)\n static tree\n cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)\n {\n-  /* If the DECL is a TEMPLATE_DECL for a class type, and we are in\n-     the scope of the class, then treat the TEMPLATE_DECL as a\n-     class-name.  For example, in:\n-\n-       template <class T> struct S {\n-         S s;\n-       };\n-\n-     is OK.  \n-\n-     If the TEMPLATE_DECL is being declared as part of a class-head,\n-     the same translation occurs:\n+  /* If the TEMPLATE_DECL is being declared as part of a class-head,\n+     the translation from TEMPLATE_DECL to TYPE_DECL occurs:\n \n        struct A { \n          template <typename T> struct B;\n@@ -13214,12 +13227,18 @@ cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)\n          template <typename T> friend struct N::X;\n        };\n \n-     */\n-  if (DECL_CLASS_TEMPLATE_P (decl)\n-      && (tag_name_p\n-\t  || (current_class_type\n-\t      && same_type_p (TREE_TYPE (DECL_TEMPLATE_RESULT (decl)),\n-\t\t\t      current_class_type))))\n+     However, if the DECL refers to a class type, and we are in\n+     the scope of the class, then the name lookup automatically\n+     finds the TYPE_DECL created by build_self_reference rather\n+     than a TEMPLATE_DECL.  For example, in:\n+\n+       template <class T> struct S {\n+         S s;\n+       };\n+\n+     there is no need to handle such case.  */\n+\n+  if (DECL_CLASS_TEMPLATE_P (decl) && tag_name_p)\n     return DECL_TEMPLATE_RESULT (decl);\n \n   return decl;"}, {"sha": "fc39840d455511abe68e7772e52e47d02bbe6ab0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b73e6f775809e5aeb26ede61ce8af61edc45a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b73e6f775809e5aeb26ede61ce8af61edc45a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=710b73e6f775809e5aeb26ede61ce8af61edc45a", "patch": "@@ -1,3 +1,8 @@\n+2003-01-29  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/8591\n+\t* g++.dg/parse/friend2.C: New test.\n+\n 2003-01-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9437"}, {"sha": "2e88845cceb0ede102b18be448b189fb4e6fa5b8", "filename": "gcc/testsuite/g++.dg/parse/friend2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710b73e6f775809e5aeb26ede61ce8af61edc45a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ffriend2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710b73e6f775809e5aeb26ede61ce8af61edc45a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ffriend2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ffriend2.C?ref=710b73e6f775809e5aeb26ede61ce8af61edc45a", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// Origin: <struppi@acm.org>\n+\n+// PR c++/8591\n+// Template or class detection in friend declaration\n+\n+namespace NS {\n+  template <class T1, class T2, class T3 = int, class T4 = int>\n+  struct C {};\n+}\n+\n+template <class T> class X {\n+  friend class NS::C;\t// { dg-error \"expected|friend\" }\n+};\n+\n+X<int> c;"}]}