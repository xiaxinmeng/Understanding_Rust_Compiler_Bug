{"sha": "6a5bb4705fb75fd3afdde938193c59938cc7bfde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE1YmI0NzA1ZmI3NWZkM2FmZGRlOTM4MTkzYzU5OTM4Y2M3YmZkZQ==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2020-08-03T06:01:39Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2020-11-18T06:02:49Z"}, "message": "RISC-V: Handle implied extension in canonical ordering.\n\n - ISA spec has specify the order between multi-letter extensions, implied\n   extension also need to follow store in canonical ordering, so\n   most easy way is we keep that in-order during insertion.\n\ngcc/ChangeLog:\n\n\t* common/config/riscv/riscv-common.c (single_letter_subset_rank): New.\n\t(multi_letter_subset_rank): Ditto.\n\t(subset_cmp): Ditto.\n\t(riscv_subset_list::add): Insert subext in canonical ordering.\n\t(riscv_subset_list::parse_std_ext): Move handle_implied_ext to ...\n\t(riscv_subset_list::parse): ... here.", "tree": {"sha": "16a017e5d6bfd53ea6af2b166ab78dec9d6904ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16a017e5d6bfd53ea6af2b166ab78dec9d6904ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a5bb4705fb75fd3afdde938193c59938cc7bfde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a5bb4705fb75fd3afdde938193c59938cc7bfde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a5bb4705fb75fd3afdde938193c59938cc7bfde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a5bb4705fb75fd3afdde938193c59938cc7bfde/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d87ee7f1c9cd2ffa6302cdfd0686d72e5bb7463b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d87ee7f1c9cd2ffa6302cdfd0686d72e5bb7463b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d87ee7f1c9cd2ffa6302cdfd0686d72e5bb7463b"}], "stats": {"total": 177, "additions": 172, "deletions": 5}, "files": [{"sha": "f5f7be3cfffb297485440916e919d3cf08208fa6", "filename": "gcc/common/config/riscv/riscv-common.c", "status": "modified", "additions": 172, "deletions": 5, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a5bb4705fb75fd3afdde938193c59938cc7bfde/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a5bb4705fb75fd3afdde938193c59938cc7bfde/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.c?ref=6a5bb4705fb75fd3afdde938193c59938cc7bfde", "patch": "@@ -145,13 +145,137 @@ riscv_subset_list::~riscv_subset_list ()\n     }\n }\n \n+/* Get the rank for single-letter subsets, lower value meaning higher\n+   priority.  */\n+\n+static int\n+single_letter_subset_rank (char ext)\n+{\n+  int rank;\n+\n+  switch (ext)\n+    {\n+    case 'i':\n+      return 0;\n+    case 'e':\n+      return 1;\n+    default:\n+      break;\n+    }\n+\n+  const char *all_ext = riscv_supported_std_ext ();\n+  const char *ext_pos = strchr (all_ext, ext);\n+  if (ext_pos == NULL)\n+    /* If got an unknown extension letter, then give it an alphabetical\n+       order, but after all known standard extension.  */\n+    rank = strlen (all_ext) + ext - 'a';\n+  else\n+    rank = (int)(ext_pos - all_ext) + 2 /* e and i has higher rank.  */;\n+\n+  return rank;\n+}\n+\n+/* Get the rank for multi-letter subsets, lower value meaning higher\n+   priority.  */\n+\n+static int\n+multi_letter_subset_rank (const std::string &subset)\n+{\n+  gcc_assert (subset.length () >= 2);\n+  int high_order = -1;\n+  int low_order = 0;\n+  /* The order between multi-char extensions: s -> h -> z -> x.  */\n+  char multiletter_class = subset[0];\n+  switch (multiletter_class)\n+    {\n+    case 's':\n+      high_order = 0;\n+      break;\n+    case 'h':\n+      high_order = 1;\n+      break;\n+    case 'z':\n+      gcc_assert (subset.length () > 2);\n+      high_order = 2;\n+      break;\n+    case 'x':\n+      high_order = 3;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      return -1;\n+    }\n+\n+  if (multiletter_class == 'z')\n+    /* Order for z extension on spec: If multiple \"Z\" extensions are named, they\n+       should be ordered first by category, then alphabetically within a\n+       category - for example, \"Zicsr_Zifencei_Zam\". */\n+    low_order = single_letter_subset_rank (subset[1]);\n+  else\n+    low_order = 0;\n+\n+  return (high_order << 8) + low_order;\n+}\n+\n+/* subset compare\n+\n+  Returns an integral value indicating the relationship between the subsets:\n+  Return value  indicates\n+  -1            B has higher order than A.\n+  0             A and B are same subset.\n+  1             A has higher order than B.\n+\n+*/\n+\n+static int\n+subset_cmp (const std::string &a, const std::string &b)\n+{\n+  if (a == b)\n+    return 0;\n+\n+  size_t a_len = a.length ();\n+  size_t b_len = b.length ();\n+\n+  /* Single-letter extension always get higher order than\n+     multi-letter extension.  */\n+  if (a_len == 1 && b_len != 1)\n+    return 1;\n+\n+  if (a_len != 1 && b_len == 1)\n+    return -1;\n+\n+  if (a_len == 1 && b_len == 1)\n+    {\n+      int rank_a = single_letter_subset_rank (a[0]);\n+      int rank_b = single_letter_subset_rank (b[0]);\n+\n+      if (rank_a < rank_b)\n+\treturn 1;\n+      else\n+\treturn -1;\n+    }\n+  else\n+    {\n+      int rank_a = multi_letter_subset_rank(a);\n+      int rank_b = multi_letter_subset_rank(b);\n+\n+      /* Using alphabetical/lexicographical order if they have same rank.  */\n+      if (rank_a == rank_b)\n+\t/* The return value of strcmp has opposite meaning.  */\n+\treturn -strcmp (a.c_str (), b.c_str ());\n+      else\n+\treturn (rank_a < rank_b) ? 1 : -1;\n+    }\n+}\n+\n /* Add new subset to list.  */\n \n void\n riscv_subset_list::add (const char *subset, int major_version,\n \t\t\tint minor_version, bool explicit_version_p)\n {\n   riscv_subset_t *s = new riscv_subset_t ();\n+  riscv_subset_t *itr;\n \n   if (m_head == NULL)\n     m_head = s;\n@@ -162,9 +286,45 @@ riscv_subset_list::add (const char *subset, int major_version,\n   s->explicit_version_p = explicit_version_p;\n   s->next = NULL;\n \n-  if (m_tail != NULL)\n-    m_tail->next = s;\n+  if (m_tail == NULL)\n+    {\n+      m_tail = s;\n+      return;\n+    }\n+\n+  /* e, i or g should be first subext, never come here.  */\n+  gcc_assert (subset[0] != 'e'\n+\t      && subset[0] != 'i'\n+\t      && subset[0] != 'g');\n+\n+  if (m_tail == m_head)\n+    {\n+      gcc_assert (m_head->next == NULL);\n+      m_head->next = s;\n+      m_tail = s;\n+      return;\n+    }\n+\n+  gcc_assert (m_head->next != NULL);\n+\n+  /* Subset list must in canonical order, but implied subset won't\n+     add in canonical order.  */\n+  for (itr = m_head; itr->next != NULL; itr = itr->next)\n+    {\n+      riscv_subset_t *next = itr->next;\n+      int cmp = subset_cmp (s->name, next->name);\n+      gcc_assert (cmp != 0);\n+\n+      if (cmp > 0)\n+\t{\n+\t  s->next = next;\n+\t  itr->next = s;\n+\t  return;\n+\t}\n+    }\n \n+  /* Insert at tail of the list.  */\n+  itr->next = s;\n   m_tail = s;\n }\n \n@@ -441,9 +601,6 @@ riscv_subset_list::parse_std_ext (const char *p)\n \n       subset[0] = std_ext;\n \n-      handle_implied_ext (subset, major_version,\n-\t\t\t  minor_version, explicit_version_p);\n-\n       add (subset, major_version, minor_version, explicit_version_p);\n     }\n   return p;\n@@ -553,6 +710,7 @@ riscv_subset_list *\n riscv_subset_list::parse (const char *arch, location_t loc)\n {\n   riscv_subset_list *subset_list = new riscv_subset_list (arch, loc);\n+  riscv_subset_t *itr;\n   const char *p = arch;\n   if (strncmp (p, \"rv32\", 4) == 0)\n     {\n@@ -608,6 +766,15 @@ riscv_subset_list::parse (const char *arch, location_t loc)\n       goto fail;\n     }\n \n+  for (itr = subset_list->m_head; itr != NULL; itr = itr->next)\n+    {\n+      subset_list->handle_implied_ext (\n+\titr->name.c_str (),\n+\titr->major_version,\n+\titr->minor_version,\n+\titr->explicit_version_p);\n+    }\n+\n   return subset_list;\n \n fail:"}]}