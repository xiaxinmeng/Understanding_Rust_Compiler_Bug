{"sha": "416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE2ZmYzMmVmOGY0ZjJmMWIxNjE1YzI1YWE4ODRkYTlhYWRkOGI0ZA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-06-24T17:58:46Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-06-24T17:58:46Z"}, "message": "output.h: (current_function_is_leaf...\n\n\t* output.h: (current_function_is_leaf,\n\tcurrent_function_sp_is_unchanging,\n\tcurrent_function_uses_only_leaf_regs): Remove.\n\t* function.c (current_function_is_leaf,\n\tcurrent_function_sp_is_unchanging,\n\tcurrent_function_uses_only_leaf_regs): Remove.\n\t(rest_of_handle_check_leaf_regs): Set crtl->uses_only_leaf_regs\n\tinstead of current_function_uses_only_leaf_regs.\n\t* function.h (struct rtl_data): New fields sp_is_unchanging,\n\tis_leaf, uses_only_leaf_regs.\n\t* resource.c (init_resource_info): Replace current_function_is_leaf,\n\tcurrent_function_sp_is_unchanging, and\n\tcurrent_function_uses_only_leaf_regs with new crtl fields.\n\t* sdbout.c (sdbout_symbol): Likewise.\n\t* df-core.c (rest_of_handle_df_initialize): Likewise.\n\t* ira.c (ira): Likewise.\n\t* final.c (final_start_function): Likewise.\n\t* reorg.c (fill_simple_delay_slots): Likewise.\n\t* regrename.c (check_new_reg_p): Likewise.\n\t* stack-ptr-mod.c (notice_stack_pointer_modification_1): Likewise.\n\t(notice_stack_pointer_modification): Likewise.\n\t* dbxout.c (dbxout_symbol): Likewise.\n\t(dbxout_parms): Likewise.\n\t* sel-sched.c (init_regs_for_mode): Likewise.\n\t* dwarf2out.c (dbx_reg_number): Likewise.\n\t(multiple_reg_loc_descriptor): Likewise.\n\t* config/i386/i386.c (ix86_frame_pointer_required): Likewise.\n\t(gen_pop): Likewise.\n\t(ix86_select_alt_pic_regnum): Likewise.\n\t(ix86_compute_frame_layout): Likewise.\n\t(ix86_finalize_stack_realign_flags): Likewise.\n\t(ix86_expand_epilogue): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_stack_info): Likewise.\n\t* config/h8300/h8300.c (byte_reg): Likewise.\n\t* config/c6x/c6x.c (must_reload_pic_reg_p): Likewise.\n\t(c6x_save_reg): Likewise.\n\t(c6x_compute_frame_layout): Likewise.\n\t* config/pa/pa.c (pa_compute_frame_size): Likewise.\n\t(pa_output_function_prologue): Likewise.\n\t* config/stormy16/stormy16.c (struct xstormy16_stack_layout): Likewise.\n\t* config/sparc/sparc.md (attr \"leaf_function\"): Likewise.\n\t* config/sparc/sparc.c (sparc_initial_elimination_offset): Likewise.\n\t(sparc_expand_prologue): Likewise.\n\t(sparc_flat_expand_prologue): Likewise.\n\t(sparc_asm_function_prologue): Likewise.\n\t(sparc_output_mi_thunk): Likewise.\n\t(sparc_frame_pointer_required): Likewise.\n\t* config/epiphany/epiphany.c (epiphany_compute_function_type): Likewise.\n\t(epiphany_compute_frame_size): Likewise.\n\t* config/lm32/lm32.c (lm32_compute_frame_size): Likewise.\n\t* config/cris/cris.c (cris_md_asm_clobbers): Likewise.\n\t(cris_frame_pointer_required): Likewise.\n\t* config/tilepro/tilepro.c (emit_sp_adjust): Likewise.\n\t(tilepro_current_function_is_leaf): Likewise.\n\t* config/arm/arm.c (arm_compute_save_reg0_reg12_mask): Likewise.\n\t* config/pdp11/pdp11.c (pdp11_expand_epilogue): Likewise.\n\t* config/ia64/ia64.c (find_gr_spill): Likewise.\n\t(ia64_compute_frame_size): Likewise.\n\t(ia64_can_eliminate): Likewise.\n\t(ia64_initial_elimination_offset): Likewise.\n\t* config/m68k/m68k.c (m68k_save_reg): Likewise.\n\t(m68k_expand_epilogue): Likewise.\n\t* config/rx/rx.c (rx_get_stack_layout): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_current_function_is_leaf): Likewise.\n\t* config/picochip/picochip.c (picochip_can_eliminate_link_sp_save):\n\tLikewise.\n\t(picochip_output_frame_debug): Likewise.\n\t* config/sh/sh.c (sh_media_register_for_return): Likewise.\n\t(sh_allocate_initial_value): Likewise.\n\t(sh_output_mi_thunk): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_must_save_register): Likewise.\n\t(compute_frame_size): Likewise.\n\t(microblaze_initial_elimination_offset): Likewise.\n\t(microblaze_expand_prologue): Likewise.\n\t(microblaze_expand_epilogue): Likewise.\n\t* config/frv/frv.c (frv_expand_epilogue): Likewise.\n\t(frv_frame_pointer_required): Likewise.\n\t* config/spu/spu.c (get_pic_reg): Likewise.\n\t(direct_return): Likewise.\n\t(spu_expand_prologue): Likewise.\n\t(spu_expand_epilogue): Likewise.\n\t(spu_initial_elimination_offset): Likewise.\n\t* config/mips/mips.c (mips_global_pointer): Likewise.\n\t(mips_cfun_might_clobber_call_saved_reg_p): Likewise.\n\t(mips_compute_frame_info): Likewise.\n\t* config/mep/mep.c (mep_interrupt_saved_reg): Likewise.\n\t(mep_reload_pointer): Likewise.\n\t* config/rl78/rl78.c (need_to_save): Likewise.\n\t* config/cr16/cr16.c (cr16_compute_save_regs): Likewise.\n\t* config/score/score.c (score_compute_frame_size): Likewise.\n\t(score_function_prologue): Likewise.\n\t* config/bfin/bfin.c (must_save_p): Likewise.\n\t(expand_prologue_reg_save): Likewise.\n\t(expand_epilogue_reg_restore): Likewise.\n\t(bfin_frame_pointer_required): Likewise.\n\t(n_regs_saved_by_prologue): Likewise.\n\t(add_to_reg): Likewise.\n\t(expand_interrupt_handler_prologue): Likewise.\n\t(expand_interrupt_handler_epilogue): Likewise.\n\t(bfin_expand_prologue): Likewise.\n\t* config/avr/avr.c (avr_regs_to_save): Likewise.\n\t(avr_prologue_setup_frame): Likewise.\n\t(expand_epilogue): Likewise.\n\t* config/s390/s390.c (s390_regs_ever_clobbered): Likewise.\n\t(s390_register_info): Likewise.\n\t(s390_frame_info): Likewise.\n\t(s390_init_frame_layout): Likewise.\n\t(s390_emit_prologue): Likewise.\n\nFrom-SVN: r188918", "tree": {"sha": "c8e980e836068fddf3da138b66d53052048da271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8e980e836068fddf3da138b66d53052048da271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/comments", "author": null, "committer": null, "parents": [{"sha": "e1ab7892de785b1bb9cc6a6f1d7a85b8d90dcf22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ab7892de785b1bb9cc6a6f1d7a85b8d90dcf22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ab7892de785b1bb9cc6a6f1d7a85b8d90dcf22"}], "stats": {"total": 414, "additions": 252, "deletions": 162}, "files": [{"sha": "ef1f53c175b37b45dcd7c72832e34e789cae224b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 115, "deletions": 1, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1,3 +1,117 @@\n+2012-06-24  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* output.h: (current_function_is_leaf,\n+\tcurrent_function_sp_is_unchanging,\n+\tcurrent_function_uses_only_leaf_regs): Remove.\n+\t* function.c (current_function_is_leaf,\n+\tcurrent_function_sp_is_unchanging,\n+\tcurrent_function_uses_only_leaf_regs): Remove.\n+\t(rest_of_handle_check_leaf_regs): Set crtl->uses_only_leaf_regs\n+\tinstead of current_function_uses_only_leaf_regs.\n+\t* function.h (struct rtl_data): New fields sp_is_unchanging,\n+\tis_leaf, uses_only_leaf_regs.\n+\t* resource.c (init_resource_info): Replace current_function_is_leaf,\n+\tcurrent_function_sp_is_unchanging, and\n+\tcurrent_function_uses_only_leaf_regs with new crtl fields.\n+\t* sdbout.c (sdbout_symbol): Likewise.\n+\t* df-core.c (rest_of_handle_df_initialize): Likewise.\n+\t* ira.c (ira): Likewise.\n+\t* final.c (final_start_function): Likewise.\n+\t* reorg.c (fill_simple_delay_slots): Likewise.\n+\t* regrename.c (check_new_reg_p): Likewise.\n+\t* stack-ptr-mod.c (notice_stack_pointer_modification_1): Likewise.\n+\t(notice_stack_pointer_modification): Likewise.\n+\t* dbxout.c (dbxout_symbol): Likewise.\n+\t(dbxout_parms): Likewise.\n+\t* sel-sched.c (init_regs_for_mode): Likewise.\n+\t* dwarf2out.c (dbx_reg_number): Likewise.\n+\t(multiple_reg_loc_descriptor): Likewise.\n+\t* config/i386/i386.c (ix86_frame_pointer_required): Likewise.\n+\t(gen_pop): Likewise.\n+\t(ix86_select_alt_pic_regnum): Likewise.\n+\t(ix86_compute_frame_layout): Likewise.\n+\t(ix86_finalize_stack_realign_flags): Likewise.\n+\t(ix86_expand_epilogue): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_stack_info): Likewise.\n+\t* config/h8300/h8300.c (byte_reg): Likewise.\n+\t* config/c6x/c6x.c (must_reload_pic_reg_p): Likewise.\n+\t(c6x_save_reg): Likewise.\n+\t(c6x_compute_frame_layout): Likewise.\n+\t* config/pa/pa.c (pa_compute_frame_size): Likewise.\n+\t(pa_output_function_prologue): Likewise.\n+\t* config/stormy16/stormy16.c (struct xstormy16_stack_layout): Likewise.\n+\t* config/sparc/sparc.md (attr \"leaf_function\"): Likewise.\n+\t* config/sparc/sparc.c (sparc_initial_elimination_offset): Likewise.\n+\t(sparc_expand_prologue): Likewise.\n+\t(sparc_flat_expand_prologue): Likewise.\n+\t(sparc_asm_function_prologue): Likewise.\n+\t(sparc_output_mi_thunk): Likewise.\n+\t(sparc_frame_pointer_required): Likewise.\n+\t* config/epiphany/epiphany.c (epiphany_compute_function_type):\n+\tLikewise.\n+\t(epiphany_compute_frame_size): Likewise.\n+\t* config/lm32/lm32.c (lm32_compute_frame_size): Likewise.\n+\t* config/cris/cris.c (cris_md_asm_clobbers): Likewise.\n+\t(cris_frame_pointer_required): Likewise.\n+\t* config/tilepro/tilepro.c (emit_sp_adjust): Likewise.\n+\t(tilepro_current_function_is_leaf): Likewise.\n+\t* config/arm/arm.c (arm_compute_save_reg0_reg12_mask): Likewise.\n+\t* config/pdp11/pdp11.c (pdp11_expand_epilogue): Likewise.\n+\t* config/ia64/ia64.c (find_gr_spill): Likewise.\n+\t(ia64_compute_frame_size): Likewise.\n+\t(ia64_can_eliminate): Likewise.\n+\t(ia64_initial_elimination_offset): Likewise.\n+\t* config/m68k/m68k.c (m68k_save_reg): Likewise.\n+\t(m68k_expand_epilogue): Likewise.\n+\t* config/rx/rx.c (rx_get_stack_layout): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_current_function_is_leaf): Likewise.\n+\t* config/picochip/picochip.c (picochip_can_eliminate_link_sp_save):\n+\tLikewise.\n+\t(picochip_output_frame_debug): Likewise.\n+\t* config/sh/sh.c (sh_media_register_for_return): Likewise.\n+\t(sh_allocate_initial_value): Likewise.\n+\t(sh_output_mi_thunk): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_must_save_register):\n+\tLikewise.\n+\t(compute_frame_size): Likewise.\n+\t(microblaze_initial_elimination_offset): Likewise.\n+\t(microblaze_expand_prologue): Likewise.\n+\t(microblaze_expand_epilogue): Likewise.\n+\t* config/frv/frv.c (frv_expand_epilogue): Likewise.\n+\t(frv_frame_pointer_required): Likewise.\n+\t* config/spu/spu.c (get_pic_reg): Likewise.\n+\t(direct_return): Likewise.\n+\t(spu_expand_prologue): Likewise.\n+\t(spu_expand_epilogue): Likewise.\n+\t(spu_initial_elimination_offset): Likewise.\n+\t* config/mips/mips.c (mips_global_pointer): Likewise.\n+\t(mips_cfun_might_clobber_call_saved_reg_p): Likewise.\n+\t(mips_compute_frame_info): Likewise.\n+\t* config/mep/mep.c (mep_interrupt_saved_reg): Likewise.\n+\t(mep_reload_pointer): Likewise.\n+\t* config/rl78/rl78.c (need_to_save): Likewise.\n+\t* config/cr16/cr16.c (cr16_compute_save_regs): Likewise.\n+\t* config/score/score.c (score_compute_frame_size): Likewise.\n+\t(score_function_prologue): Likewise.\n+\t* config/bfin/bfin.c (must_save_p): Likewise.\n+\t(expand_prologue_reg_save): Likewise.\n+\t(expand_epilogue_reg_restore): Likewise.\n+\t(bfin_frame_pointer_required): Likewise.\n+\t(n_regs_saved_by_prologue): Likewise.\n+\t(add_to_reg): Likewise.\n+\t(expand_interrupt_handler_prologue): Likewise.\n+\t(expand_interrupt_handler_epilogue): Likewise.\n+\t(bfin_expand_prologue): Likewise.\n+\t* config/avr/avr.c (avr_regs_to_save): Likewise.\n+\t(avr_prologue_setup_frame): Likewise.\n+\t(expand_epilogue): Likewise.\n+\t* config/s390/s390.c (s390_regs_ever_clobbered): Likewise.\n+\t(s390_register_info): Likewise.\n+\t(s390_frame_info): Likewise.\n+\t(s390_init_frame_layout): Likewise.\n+\t(s390_emit_prologue): Likewise.\n+\n+\n 2012-06-24  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* system.h: Poison ASM_BYTE_OP and ASM_OUTPUT_BYTE.\n@@ -2181,7 +2295,7 @@\n \t* doc/invoke.texi (AVR Options): Ditto.  And document related\n \tbuilt-in macros.\n \n-2012-05-31   Diego Novillo  <dnovillo@google.com>\n+2012-05-31  Diego Novillo  <dnovillo@google.com>\n \n \t* configure.ac (CXX_FOR_BUILD): Define and substitute.\n \t(BUILD_CXXFLAGS): Define and substitute."}, {"sha": "3913e11b50bbf6f8108c8f4790ceed724839227f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -15147,7 +15147,7 @@ arm_compute_save_reg0_reg12_mask (void)\n \n       for (reg = 0; reg <= max_reg; reg++)\n \tif (df_regs_ever_live_p (reg)\n-\t    || (! current_function_is_leaf && call_used_regs[reg]))\n+\t    || (! crtl->is_leaf && call_used_regs[reg]))\n \t  save_reg_mask |= (1 << reg);\n \n       /* Also save the pic base register if necessary.  */"}, {"sha": "8199d2e4f9024e2853924cce336a49d7305a7354", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -658,7 +658,7 @@ avr_regs_to_save (HARD_REG_SET *set)\n       if (fixed_regs[reg])\n         continue;\n \n-      if ((int_or_sig_p && !current_function_is_leaf && call_used_regs[reg])\n+      if ((int_or_sig_p && !crtl->is_leaf && call_used_regs[reg])\n           || (df_regs_ever_live_p (reg)\n               && (int_or_sig_p || !call_used_regs[reg])\n               /* Don't record frame pointer registers here.  They are treated\n@@ -1010,7 +1010,7 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n \n           gcc_assert (frame_pointer_needed\n                       || !isr_p\n-                      || !current_function_is_leaf);\n+                      || !crtl->is_leaf);\n           \n           fp = my_fp = (frame_pointer_needed\n                         ? frame_pointer_rtx\n@@ -1358,7 +1358,7 @@ expand_epilogue (bool sibcall_p)\n \n       gcc_assert (frame_pointer_needed\n                   || !isr_p\n-                  || !current_function_is_leaf);\n+                  || !crtl->is_leaf);\n       \n       fp = my_fp = (frame_pointer_needed\n                     ? frame_pointer_rtx"}, {"sha": "dd141ed7bb1dd4e7257165b64f22088af712b560", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -248,7 +248,7 @@ must_save_p (bool is_inthandler, unsigned regno)\n \t      || (!TARGET_FDPIC\n \t\t  && regno == PIC_OFFSET_TABLE_REGNUM\n \t\t  && (crtl->uses_pic_offset_table\n-\t\t      || (TARGET_ID_SHARED_LIBRARY && !current_function_is_leaf))));\n+\t\t      || (TARGET_ID_SHARED_LIBRARY && !crtl->is_leaf))));\n     }\n   else\n     return ((is_inthandler || !call_used_regs[regno])\n@@ -346,7 +346,7 @@ expand_prologue_reg_save (rtx spreg, int saveall, bool is_inthandler)\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n       for (dregno = REG_LT0; dregno <= REG_LB1; dregno++)\n-\tif (! current_function_is_leaf\n+\tif (! crtl->is_leaf\n \t    || cfun->machine->has_hardware_loops\n \t    || cfun->machine->has_loopreg_clobber\n \t    || (ENABLE_WA_05000257\n@@ -526,7 +526,7 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n   if (saveall || is_inthandler)\n     {\n       for (regno = REG_LB1; regno >= REG_LT0; regno--)\n-\tif (! current_function_is_leaf\n+\tif (! crtl->is_leaf\n \t    || cfun->machine->has_hardware_loops\n \t    || cfun->machine->has_loopreg_clobber\n \t    || (ENABLE_WA_05000257 && (regno == REG_LC0 || regno == REG_LC1)))\n@@ -600,7 +600,7 @@ bfin_frame_pointer_required (void)\n \n   /* We turn on -fomit-frame-pointer if -momit-leaf-frame-pointer is used,\n      so we have to override it for non-leaf functions.  */\n-  if (TARGET_OMIT_LEAF_FRAME_POINTER && ! current_function_is_leaf)\n+  if (TARGET_OMIT_LEAF_FRAME_POINTER && ! crtl->is_leaf)\n     return true;\n \n   return false;\n@@ -615,7 +615,7 @@ n_regs_saved_by_prologue (void)\n   bool is_inthandler = fkind != SUBROUTINE;\n   tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n   bool all = (lookup_attribute (\"saveall\", attrs) != NULL_TREE\n-\t      || (is_inthandler && !current_function_is_leaf));\n+\t      || (is_inthandler && !crtl->is_leaf));\n   int ndregs = all ? 8 : n_dregs_to_save (is_inthandler, false);\n   int npregs = all ? 6 : n_pregs_to_save (is_inthandler, false);\n   int n = ndregs + npregs;\n@@ -635,7 +635,7 @@ n_regs_saved_by_prologue (void)\n     {\n       /* Increment once for ASTAT.  */\n       n++;\n-      if (! current_function_is_leaf\n+      if (! crtl->is_leaf\n \t  || cfun->machine->has_hardware_loops\n \t  || cfun->machine->has_loopreg_clobber)\n \t{\n@@ -760,7 +760,7 @@ add_to_reg (rtx reg, HOST_WIDE_INT value, int frame, int epilogue_p)\n \t\t    && i == PIC_OFFSET_TABLE_REGNUM\n \t\t    && (crtl->uses_pic_offset_table\n \t\t\t|| (TARGET_ID_SHARED_LIBRARY\n-\t\t\t    && ! current_function_is_leaf))))\n+\t\t\t    && ! crtl->is_leaf))))\n \t      break;\n \t  if (i <= REG_P5)\n \t    tmpreg = gen_rtx_REG (SImode, i);\n@@ -956,7 +956,7 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind, bool all)\n \n   /* If we're calling other functions, they won't save their call-clobbered\n      registers, so we must save everything here.  */\n-  if (!current_function_is_leaf)\n+  if (!crtl->is_leaf)\n     all = true;\n   expand_prologue_reg_save (spreg, all, true);\n \n@@ -1019,7 +1019,7 @@ expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind, bool all)\n \n   /* If we're calling other functions, they won't save their call-clobbered\n      registers, so we must save (and restore) everything here.  */\n-  if (!current_function_is_leaf)\n+  if (!crtl->is_leaf)\n     all = true;\n \n   expand_epilogue_reg_restore (spreg, all, true);\n@@ -1134,7 +1134,7 @@ bfin_expand_prologue (void)\n   if (TARGET_ID_SHARED_LIBRARY\n       && !TARGET_SEP_DATA\n       && (crtl->uses_pic_offset_table\n-\t  || !current_function_is_leaf))\n+\t  || !crtl->is_leaf))\n     bfin_load_pic_reg (pic_offset_table_rtx);\n }\n "}, {"sha": "81e43ca97800d3665b6364a6a7bc561a82ea2de8", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -2537,7 +2537,7 @@ must_reload_pic_reg_p (void)\n \n   i = cgraph_local_info (current_function_decl);\n \n-  if ((crtl->uses_pic_offset_table || !current_function_is_leaf) && !i->local)\n+  if ((crtl->uses_pic_offset_table || !crtl->is_leaf) && !i->local)\n     return true;\n   return false;\n }\n@@ -2551,7 +2551,7 @@ c6x_save_reg (unsigned int regno)\n \t   && !fixed_regs[regno])\n \t  || (regno == RETURN_ADDR_REGNO\n \t      && (df_regs_ever_live_p (regno)\n-\t\t  || !current_function_is_leaf))\n+\t\t  || !crtl->is_leaf))\n \t  || (regno == PIC_OFFSET_TABLE_REGNUM && must_reload_pic_reg_p ()));\n }\n \n@@ -2642,7 +2642,7 @@ c6x_compute_frame_layout (struct c6x_frame *frame)\n     offset += frame->nregs * 4;\n \n   if (offset == 0 && size == 0 && crtl->outgoing_args_size == 0\n-      && !current_function_is_leaf)\n+      && !crtl->is_leaf)\n     /* Don't use the bottom of the caller's frame if we have no\n        allocation of our own and call other functions.  */\n     frame->padding0 = frame->padding1 = 4;"}, {"sha": "b9305701923011554ce3148797517f4dc6523774", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -354,7 +354,7 @@ cr16_compute_save_regs (void)\n       /* If this reg is used and not call-used (except RA), save it.  */\n       if (cr16_interrupt_function_p ())\n \t{\n-\t  if (!current_function_is_leaf && call_used_regs[regno])\n+\t  if (!crtl->is_leaf && call_used_regs[regno])\n \t    /* This is a volatile reg in a non-leaf interrupt routine - save \n \t       it for the sake of its sons.  */\n \t    current_frame_info.save_regs[regno] = 1;"}, {"sha": "1bc998165b1b1a4390844c17ef9a9d95c477cd9a", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -4098,7 +4098,7 @@ cris_md_asm_clobbers (tree outputs, tree inputs, tree in_clobbers)\n bool\n cris_frame_pointer_required (void)\n {\n-  return !current_function_sp_is_unchanging;\n+  return !crtl->sp_is_unchanging;\n }\n \n /* Implement TARGET_ASM_TRAMPOLINE_TEMPLATE."}, {"sha": "14c96dc4a3f8f98264922719326cf1b1fd5f1226", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -932,7 +932,7 @@ epiphany_compute_function_type (tree decl)\n    Don't consider them here.  */\n #define MUST_SAVE_REGISTER(regno, interrupt_p) \\\n   ((df_regs_ever_live_p (regno) \\\n-    || (interrupt_p && !current_function_is_leaf \\\n+    || (interrupt_p && !crtl->is_leaf \\\n \t&& call_used_regs[regno] && !fixed_regs[regno])) \\\n    && (!call_used_regs[regno] || regno == GPR_LR \\\n        || (interrupt_p && regno != GPR_SP)))\n@@ -1035,7 +1035,7 @@ epiphany_compute_frame_size (int size /* # of var. bytes allocated.  */)\n     reg_size = EPIPHANY_STACK_ALIGN (reg_size);\n   if (total_size + reg_size <= (unsigned) epiphany_stack_offset\n       && !interrupt_p\n-      && current_function_is_leaf && !frame_pointer_needed)\n+      && crtl->is_leaf && !frame_pointer_needed)\n     {\n       first_slot = -1;\n       last_slot = -1;"}, {"sha": "5e7b5d407fd9f3fc417bd577398ffb04727dfed3", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1895,7 +1895,7 @@ frv_expand_epilogue (bool emit_return)\n \n   /* Restore the stack pointer to its original value if alloca or the like\n      is used.  */\n-  if (! current_function_sp_is_unchanging)\n+  if (! crtl->sp_is_unchanging)\n     emit_insn (gen_addsi3 (sp, fp, frv_frame_offset_rtx (-fp_offset)));\n \n   /* Restore the callee-saved registers that were used in this function.  */\n@@ -2064,9 +2064,9 @@ frv_frame_pointer_required (void)\n   /* If we forgoing the usual linkage requirements, we only need\n      a frame pointer if the stack pointer might change.  */\n   if (!TARGET_LINKED_FP)\n-    return !current_function_sp_is_unchanging;\n+    return !crtl->sp_is_unchanging;\n \n-  if (! current_function_is_leaf)\n+  if (! crtl->is_leaf)\n     return true;\n \n   if (get_frame_size () != 0)\n@@ -2075,7 +2075,7 @@ frv_frame_pointer_required (void)\n   if (cfun->stdarg)\n     return true;\n \n-  if (!current_function_sp_is_unchanging)\n+  if (!crtl->sp_is_unchanging)\n     return true;\n \n   if (!TARGET_FDPIC && flag_pic && crtl->uses_pic_offset_table)"}, {"sha": "3dd071a63c4d7e6eb311f194375248348532aa1e", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -480,7 +480,7 @@ byte_reg (rtx x, int b)\n \t  handlers.  */\t\t\t\t\t\t\t\\\n        || (h8300_current_function_interrupt_function_p ()\t\t\\\n \t   && call_used_regs[regno]\t\t\t\t\t\\\n-\t   && !current_function_is_leaf)))\n+\t   && !crtl->is_leaf)))\n \n /* We use this to wrap all emitted insns in the prologue.  */\n static rtx"}, {"sha": "7bcde8a2e164bcc42f5338f9907885774a3b54a2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -8562,7 +8562,7 @@ ix86_frame_pointer_required (void)\n      turns off the frame pointer by default.  Turn it back on now if\n      we've not got a leaf function.  */\n   if (TARGET_OMIT_LEAF_FRAME_POINTER\n-      && (!current_function_is_leaf\n+      && (!crtl->is_leaf\n \t  || ix86_current_function_calls_tls_descriptor))\n     return true;\n \n@@ -8809,7 +8809,7 @@ gen_pop (rtx arg)\n static unsigned int\n ix86_select_alt_pic_regnum (void)\n {\n-  if (current_function_is_leaf\n+  if (crtl->is_leaf\n       && !crtl->profile\n       && !ix86_current_function_calls_tls_descriptor)\n     {\n@@ -8973,7 +8973,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   /* 64-bit MS ABI seem to require stack alignment to be always 16 except for\n      function prologues and leaf.  */\n   if ((TARGET_64BIT_MS_ABI && preferred_alignment < 16)\n-      && (!current_function_is_leaf || cfun->calls_alloca != 0\n+      && (!crtl->is_leaf || cfun->calls_alloca != 0\n           || ix86_current_function_calls_tls_descriptor))\n     {\n       preferred_alignment = 16;\n@@ -9078,7 +9078,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   if (stack_realign_fp\n       || offset != frame->sse_reg_save_offset\n       || size != 0\n-      || !current_function_is_leaf\n+      || !crtl->is_leaf\n       || cfun->calls_alloca\n       || ix86_current_function_calls_tls_descriptor)\n     offset = (offset + stack_alignment_needed - 1) & -stack_alignment_needed;\n@@ -9094,7 +9094,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n      expander assumes that last crtl->outgoing_args_size\n      of stack frame are unused.  */\n   if (ACCUMULATE_OUTGOING_ARGS\n-      && (!current_function_is_leaf || cfun->calls_alloca\n+      && (!crtl->is_leaf || cfun->calls_alloca\n \t  || ix86_current_function_calls_tls_descriptor))\n     {\n       offset += crtl->outgoing_args_size;\n@@ -9105,7 +9105,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \n   /* Align stack boundary.  Only needed if we're calling another function\n      or using alloca.  */\n-  if (!current_function_is_leaf || cfun->calls_alloca\n+  if (!crtl->is_leaf || cfun->calls_alloca\n       || ix86_current_function_calls_tls_descriptor)\n     offset = (offset + preferred_alignment - 1) & -preferred_alignment;\n \n@@ -9120,8 +9120,8 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n     frame->save_regs_using_mov = false;\n \n   if (ix86_using_red_zone ()\n-      && current_function_sp_is_unchanging\n-      && current_function_is_leaf\n+      && crtl->sp_is_unchanging\n+      && crtl->is_leaf\n       && !ix86_current_function_calls_tls_descriptor)\n     {\n       frame->red_zone_size = to_allocate;\n@@ -10062,7 +10062,7 @@ ix86_finalize_stack_realign_flags (void)\n     = (crtl->parm_stack_boundary > ix86_incoming_stack_boundary\n        ? crtl->parm_stack_boundary : ix86_incoming_stack_boundary);\n   unsigned int stack_realign = (incoming_stack_boundary\n-\t\t\t\t< (current_function_is_leaf\n+\t\t\t\t< (crtl->is_leaf\n \t\t\t\t   ? crtl->max_used_stack_slot_alignment\n \t\t\t\t   : crtl->stack_alignment_needed));\n \n@@ -10081,9 +10081,9 @@ ix86_finalize_stack_realign_flags (void)\n   if (stack_realign\n       && !crtl->need_drap\n       && frame_pointer_needed\n-      && current_function_is_leaf\n+      && crtl->is_leaf\n       && flag_omit_frame_pointer\n-      && current_function_sp_is_unchanging\n+      && crtl->sp_is_unchanging\n       && !ix86_current_function_calls_tls_descriptor\n       && !crtl->accesses_prior_frames\n       && !cfun->calls_alloca\n@@ -10792,7 +10792,7 @@ ix86_expand_epilogue (int style)\n   ix86_compute_frame_layout (&frame);\n \n   m->fs.sp_valid = (!frame_pointer_needed\n-\t\t    || (current_function_sp_is_unchanging\n+\t\t    || (crtl->sp_is_unchanging\n \t\t\t&& !stack_realign_fp));\n   gcc_assert (!m->fs.sp_valid\n \t      || m->fs.sp_offset == frame.stack_pointer_offset);"}, {"sha": "0e5b37363cb76da35b70dd45d39e3fa885dd85b5", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -2547,7 +2547,7 @@ find_gr_spill (enum ia64_frame_regs r, int try_locals)\n       if (regno >= LOC_REG (0) && regno < LOC_REG (80 - frame_pointer_needed)\n \t  && current_frame_info.n_local_regs < regno - LOC_REG (0) + 1)\n         current_frame_info.n_local_regs = regno - LOC_REG (0) + 1;\n-      else if (current_function_is_leaf \n+      else if (crtl->is_leaf\n                && regno >= GR_REG (1) && regno <= GR_REG (31))\n         current_frame_info.gr_used_mask |= 1 << regno;\n \n@@ -2556,7 +2556,7 @@ find_gr_spill (enum ia64_frame_regs r, int try_locals)\n \n   /* If this is a leaf function, first try an otherwise unused\n      call-clobbered register.  */\n-  if (current_function_is_leaf)\n+  if (crtl->is_leaf)\n     {\n       for (regno = GR_REG (1); regno <= GR_REG (31); regno++)\n \tif (! df_regs_ever_live_p (regno)\n@@ -2770,7 +2770,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n \t}\n     }\n \n-  if (! current_function_is_leaf)\n+  if (! crtl->is_leaf)\n     {\n       /* Emit a save of BR0 if we call other functions.  Do this even\n \t if this function doesn't return, as EH depends on this to be\n@@ -2922,7 +2922,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n   /* We always use the 16-byte scratch area provided by the caller, but\n      if we are a leaf function, there's no one to which we need to provide\n      a scratch area.  */\n-  if (current_function_is_leaf)\n+  if (crtl->is_leaf)\n     total_size = MAX (0, total_size - 16);\n \n   current_frame_info.total_size = total_size;\n@@ -2939,7 +2939,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n bool\n ia64_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n {\n-  return (to == BR_REG (0) ? current_function_is_leaf : true);\n+  return (to == BR_REG (0) ? crtl->is_leaf : true);\n }\n \n /* Compute the initial difference between the specified pair of registers.  */\n@@ -2956,15 +2956,15 @@ ia64_initial_elimination_offset (int from, int to)\n       switch (to)\n \t{\n \tcase HARD_FRAME_POINTER_REGNUM:\n-\t  if (current_function_is_leaf)\n+\t  if (crtl->is_leaf)\n \t    offset = -current_frame_info.total_size;\n \t  else\n \t    offset = -(current_frame_info.total_size\n \t\t       - crtl->outgoing_args_size - 16);\n \t  break;\n \n \tcase STACK_POINTER_REGNUM:\n-\t  if (current_function_is_leaf)\n+\t  if (crtl->is_leaf)\n \t    offset = 0;\n \t  else\n \t    offset = 16 + crtl->outgoing_args_size;"}, {"sha": "198f1e8de9959a992d21ddb95ee6cc4e771f3290", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -460,7 +460,7 @@ lm32_compute_frame_size (int size)\n \t  callee_size += UNITS_PER_WORD;\n \t}\n     }\n-  if (df_regs_ever_live_p (RA_REGNUM) || !current_function_is_leaf\n+  if (df_regs_ever_live_p (RA_REGNUM) || crtl->is_leaf!\n       || !optimize)\n     {\n       reg_save_mask |= 1 << RA_REGNUM;"}, {"sha": "8684d0ab0b8b7df1d1782ffec133fcb41f20fe99", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -882,7 +882,7 @@ m68k_save_reg (unsigned int regno, bool interrupt_handler)\n       if (df_regs_ever_live_p (regno))\n \treturn true;\n \n-      if (!current_function_is_leaf && call_used_regs[regno])\n+      if (!crtl->is_leaf && call_used_regs[regno])\n \treturn true;\n     }\n \n@@ -1142,12 +1142,11 @@ m68k_expand_epilogue (bool sibcall_p)\n   big = false;\n   restore_from_sp = false;\n \n-  /* FIXME : current_function_is_leaf below is too strong.\n+  /* FIXME : crtl->is_leaf below is too strong.\n      What we really need to know there is if there could be pending\n      stack adjustment needed at that point.  */\n   restore_from_sp = (!frame_pointer_needed\n-\t\t     || (!cfun->calls_alloca\n-\t\t\t && current_function_is_leaf));\n+\t\t     || (!cfun->calls_alloca && crtl->is_leaf));\n \n   /* fsize_with_regs is the size we need to adjust the sp when\n      popping the frame.  */"}, {"sha": "9f516209df69b979df05bbc523406cf0a0c16125", "filename": "gcc/config/mep/mep-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fmep%2Fmep-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fmep%2Fmep-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-pragma.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-pragma.h\"\n #include \"cpplib.h\"\n #include \"hard-reg-set.h\"\n-#include \"output.h\"\n+#include \"output.h\" /* for decode_reg_name */\n #include \"mep-protos.h\"\n #include \"function.h\"\n #define MAX_RECOG_OPERANDS 10"}, {"sha": "a6615edcd0b0a23811aa8214664bd8d41c48a777", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -2522,16 +2522,16 @@ mep_interrupt_saved_reg (int r)\n \t  || (r == RPB_REGNO || r == RPE_REGNO || r == RPC_REGNO || r == LP_REGNO)\n \t  || IVC2_ISAVED_REG (r)))\n     return true;\n-  if (!current_function_is_leaf)\n+  if (!crtl->is_leaf)\n     /* Function calls mean we need to save $lp.  */\n     if (r == LP_REGNO || IVC2_ISAVED_REG (r))\n       return true;\n-  if (!current_function_is_leaf || cfun->machine->doloop_tags > 0)\n+  if (!crtl->is_leaf || cfun->machine->doloop_tags > 0)\n     /* The interrupt handler might use these registers for repeat blocks,\n        or it might call a function that does so.  */\n     if (r == RPB_REGNO || r == RPE_REGNO || r == RPC_REGNO)\n       return true;\n-  if (current_function_is_leaf && call_used_regs[r] && !df_regs_ever_live_p(r))\n+  if (crtl->is_leaf && call_used_regs[r] && !df_regs_ever_live_p(r))\n     return false;\n   /* Functions we call might clobber these.  */\n   if (call_used_regs[r] && !fixed_regs[r])\n@@ -2742,7 +2742,7 @@ mep_reload_pointer (int regno, const char *symbol)\n {\n   rtx reg, sym;\n \n-  if (!df_regs_ever_live_p(regno) && current_function_is_leaf)\n+  if (!df_regs_ever_live_p(regno) && crtl->is_leaf)\n     return;\n \n   reg = gen_rtx_REG (SImode, regno);"}, {"sha": "199d1b8d46fe23fb1ae7e0c5cf732923f48b2749", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1478,7 +1478,7 @@ microblaze_must_save_register (int regno)\n   if (frame_pointer_needed && (regno == HARD_FRAME_POINTER_REGNUM))\n     return 1;\n \n-  if (!current_function_is_leaf)\n+  if (!crtl->is_leaf)\n     {\n       if (regno == MB_ABI_SUB_RETURN_ADDR_REGNUM)\n \treturn 1;\n@@ -1603,7 +1603,7 @@ compute_frame_size (HOST_WIDE_INT size)\n \n   /* No space to be allocated for link register in leaf functions with no other\n      stack requirements.  */\n-  if (total_size == 0 && current_function_is_leaf)\n+  if (total_size == 0 && crtl->is_leaf)\n     link_debug_size = 0;\n   else\n     link_debug_size = UNITS_PER_WORD;\n@@ -1664,7 +1664,7 @@ microblaze_initial_elimination_offset (int from, int to)\n \tgcc_unreachable ();\n       break;\n     case RETURN_ADDRESS_POINTER_REGNUM:\n-      if (current_function_is_leaf)\n+      if (crtl->is_leaf)\n \toffset = 0;\n       else\n \toffset = current_frame_info.gp_offset +\n@@ -2354,7 +2354,7 @@ microblaze_expand_prologue (void)\n \tRTX_FRAME_RELATED_P (insn) = 1;\n \n       /* Handle SUB_RETURN_ADDR_REGNUM specially at first.  */\n-      if (!current_function_is_leaf || interrupt_handler)\n+      if (!crtl->is_leaf || interrupt_handler)\n \t{\n \t  mem_rtx = gen_rtx_MEM (SImode,\n \t\t\t\t gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n@@ -2459,7 +2459,7 @@ microblaze_expand_epilogue (void)\n          a load-use stall cycle  :)   This is also important to handle alloca. \n          (See comments for if (frame_pointer_needed) below.  */\n \n-      if (!current_function_is_leaf || interrupt_handler)\n+      if (!crtl->is_leaf || interrupt_handler)\n \t{\n \t  mem_rtx =\n \t    gen_rtx_MEM (SImode,"}, {"sha": "7356ce541f084cd0c2babff5296f830fa08b6d68", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -9219,7 +9219,7 @@ mips_global_pointer (void)\n \n   /* If the global pointer is call-saved, try to use a call-clobbered\n      alternative.  */\n-  if (TARGET_CALL_SAVED_GP && current_function_is_leaf)\n+  if (TARGET_CALL_SAVED_GP && crtl->is_leaf)\n     for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n       if (!df_regs_ever_live_p (regno)\n \t  && call_really_used_regs[regno]\n@@ -9446,7 +9446,7 @@ mips_cfun_might_clobber_call_saved_reg_p (unsigned int regno)\n   /* If REGNO is ordinarily call-clobbered, we must assume that any\n      called function could modify it.  */\n   if (cfun->machine->interrupt_handler_p\n-      && !current_function_is_leaf\n+      && !crtl->is_leaf\n       && mips_interrupt_extra_call_saved_reg_p (regno))\n     return true;\n \n@@ -9589,7 +9589,7 @@ mips_compute_frame_info (void)\n      slot.  This area isn't needed in leaf functions, but if the\n      target-independent frame size is nonzero, we have already committed to\n      allocating these in STARTING_FRAME_OFFSET for !FRAME_GROWS_DOWNWARD.  */\n-  if ((size == 0 || FRAME_GROWS_DOWNWARD) && current_function_is_leaf)\n+  if ((size == 0 || FRAME_GROWS_DOWNWARD) && crtl->is_leaf)\n     {\n       /* The MIPS 3.0 linker does not like functions that dynamically\n \t allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it"}, {"sha": "e692e485f37ea2983bcb042997ad36e6eacaacaa", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -3673,7 +3673,7 @@ pa_compute_frame_size (HOST_WIDE_INT size, int *fregs_live)\n   /* Allocate space for the fixed frame marker.  This space must be\n      allocated for any function that makes calls or allocates\n      stack space.  */\n-  if (!current_function_is_leaf || size)\n+  if (!crtl->is_leaf || size)\n     size += TARGET_64BIT ? 48 : 32;\n \n   /* Finally, round to the preferred stack boundary.  */\n@@ -3711,7 +3711,7 @@ pa_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n      to output the assembler directives which denote the start\n      of a function.  */\n   fprintf (file, \"\\t.CALLINFO FRAME=\" HOST_WIDE_INT_PRINT_DEC, actual_fsize);\n-  if (current_function_is_leaf)\n+  if (crtl->is_leaf)\n     fputs (\",NO_CALLS\", file);\n   else\n     fputs (\",CALLS\", file);"}, {"sha": "519960e9daf01ac4e6abd47771fab10472ceda1c", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -337,7 +337,7 @@ pdp11_expand_epilogue (void)\n     }\n \n   /* If possible, restore registers via pops.  */\n-  if (!frame_pointer_needed || current_function_sp_is_unchanging)\n+  if (!frame_pointer_needed || crtl->sp_is_unchanging)\n     {\n       /* Restore registers via pops.  */\n "}, {"sha": "cef49aa8e0c295f08dae902cc35398197932e22b", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1136,7 +1136,7 @@ picochip_can_eliminate_link_sp_save (void)\n     accesses become wrong. This wouldnt happen only if we were not using the\n     stack at all. The following conditions ensures that.*/\n \n-  return (current_function_is_leaf &&\n+  return (crtl->is_leaf &&\n           !df_regs_ever_live_p(LINK_REGNUM) &&\n           !df_regs_ever_live_p(STACK_POINTER_REGNUM) &&\n           (picochip_special_save_area_byte_offset() == 0) &&\n@@ -1816,7 +1816,7 @@ picochip_output_frame_debug (FILE * file)\n {\n   int i = 0;\n \n-  if (current_function_is_leaf)\n+  if (crtl->is_leaf)\n     fprintf (file, \"\\t\\t// Leaf function\\n\");\n   else\n     fprintf (file, \"\\t\\t// Non-leaf function\\n\");"}, {"sha": "83c59b017afa3a040c4313fc3ab4a5304491e379", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -382,7 +382,7 @@ need_to_save (int regno)\n \treturn 1; /* don't know what devirt will need */\n       if (regno > 23)\n \treturn 0; /* don't need to save interrupt registers */\n-      if (current_function_is_leaf)\n+      if (crtl->is_leaf)\n \t{\n \t  return df_regs_ever_live_p (regno);\n \t}"}, {"sha": "c124c639e0daad557f1c72ce816643750effdd9b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -17670,7 +17670,7 @@ rs6000_stack_info (void)\n \t\t\t\t - info_ptr->first_altivec_reg_save);\n \n   /* Does this function call anything?  */\n-  info_ptr->calls_p = (! current_function_is_leaf\n+  info_ptr->calls_p = (! crtl->is_leaf \n \t\t       || cfun->machine->ra_needs_full_frame);\n \n   /* Determine if we need to save the condition code registers.  */"}, {"sha": "058f54fd80ffa2898e2710880f9bb468b1e7fcd4", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1382,7 +1382,7 @@ rx_get_stack_layout (unsigned int * lowest,\n \t      be used in (non-interrupt aware) routines called from this one.  */\n \t   || (call_used_regs[reg]\n \t       && is_interrupt_func (NULL_TREE)\n-\t       && ! current_function_is_leaf))\n+\t       && ! crtl->is_leaf))\n \t  && (! call_used_regs[reg]\n \t      /* Even call clobbered registered must\n \t\t be pushed inside interrupt handlers.  */"}, {"sha": "ca33d4e34981a520f8fca681322e4d18dc2b5d6a", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -7124,7 +7124,7 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n \n   /* For non-leaf functions we have to consider all call clobbered regs to be\n      clobbered.  */\n-  if (!current_function_is_leaf)\n+  if (!crtl->is_leaf)\n     {\n       for (i = 0; i < 16; i++)\n \tregs_ever_clobbered[i] = call_really_used_regs[i];\n@@ -7248,15 +7248,15 @@ s390_register_info (int clobbered_regs[])\n         && REGNO (cfun->machine->base_reg) == BASE_REGNUM);\n \n   clobbered_regs[RETURN_REGNUM]\n-    |= (!current_function_is_leaf\n+    |= (!crtl->is_leaf\n \t|| TARGET_TPF_PROFILING\n \t|| cfun->machine->split_branches_pending_p\n \t|| cfun_frame_layout.save_return_addr_p\n \t|| crtl->calls_eh_return\n \t|| cfun->stdarg);\n \n   clobbered_regs[STACK_POINTER_REGNUM]\n-    |= (!current_function_is_leaf\n+    |= (!crtl->is_leaf\n \t|| TARGET_TPF_PROFILING\n \t|| cfun_save_high_fprs_p\n \t|| get_frame_size () > 0\n@@ -7432,7 +7432,7 @@ s390_frame_info (void)\n \t= cfun_frame_layout.f0_offset - cfun_gprs_save_area_size;\n     }\n \n-  if (current_function_is_leaf\n+  if (crtl->is_leaf\n       && !TARGET_TPF_PROFILING\n       && cfun_frame_layout.frame_size == 0\n       && !cfun_save_high_fprs_p\n@@ -7507,7 +7507,7 @@ s390_init_frame_layout (void)\n \t as base register to avoid save/restore overhead.  */\n       if (!base_used)\n \tcfun->machine->base_reg = NULL_RTX;\n-      else if (current_function_is_leaf && !df_regs_ever_live_p (5))\n+      else if (crtl->is_leaf && !df_regs_ever_live_p (5))\n \tcfun->machine->base_reg = gen_rtx_REG (Pmode, 5);\n       else\n \tcfun->machine->base_reg = gen_rtx_REG (Pmode, BASE_REGNUM);\n@@ -7978,7 +7978,7 @@ s390_emit_prologue (void)\n      See below for why TPF must use the register 1.  */\n \n   if (!has_hard_reg_initial_val (Pmode, RETURN_REGNUM)\n-      && !current_function_is_leaf\n+      && !crtl->is_leaf\n       && !TARGET_TPF_PROFILING)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   else"}, {"sha": "6d81cd60901422fff4e8024e8a67d36068e0df5b", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -312,7 +312,7 @@ score_compute_frame_size (HOST_WIDE_INT size)\n   f->var_size = SCORE_STACK_ALIGN (size);\n   f->args_size = crtl->outgoing_args_size;\n   f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n-  if (f->var_size == 0 && current_function_is_leaf)\n+  if (f->var_size == 0 && crtl->is_leaf)\n     f->args_size = f->cprestore_size = 0;\n \n   if (f->args_size == 0 && cfun->calls_alloca)\n@@ -643,7 +643,7 @@ score_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n                 ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n                tsize,\n                reg_names[RA_REGNUM],\n-               current_function_is_leaf ? 1 : 0,\n+               crtl->is_leaf ? 1 : 0,\n                f->var_size,\n                f->num_gp,\n                f->args_size,"}, {"sha": "7e0c2c17515fef1e3e5dad427f60a34145b03382", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -6883,7 +6883,7 @@ sh_media_register_for_return (void)\n   int regno;\n   int tr0_used;\n \n-  if (! current_function_is_leaf)\n+  if (! crtl->is_leaf)\n     return -1;\n   if (lookup_attribute (\"interrupt_handler\",\n \t\t\tDECL_ATTRIBUTES (current_function_decl)))\n@@ -10477,7 +10477,7 @@ sh_allocate_initial_value (rtx hard_reg)\n \n   if (REGNO (hard_reg) == (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG))\n     {\n-      if (current_function_is_leaf\n+      if (crtl->is_leaf\n \t  && ! sh_pr_n_sets ()\n \t  && ! (TARGET_SHCOMPACT\n \t\t&& ((crtl->args.info.call_cookie\n@@ -11763,7 +11763,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   reload_completed = 1;\n   epilogue_completed = 1;\n-  current_function_uses_only_leaf_regs = 1;\n+  crtl->uses_only_leaf_regs = 1;\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n "}, {"sha": "6835d6914c7682cb9c7807a68c3d5d3bd50c2d1f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -470,7 +470,7 @@ struct GTY(()) machine_function\n \n   /* True if the current function is leaf and uses only leaf regs,\n      so that the SPARC leaf function optimization can be applied.\n-     Private version of current_function_uses_only_leaf_regs, see\n+     Private version of crtl->uses_only_leaf_regs, see\n      sparc_expand_prologue for the rationale.  */\n   int leaf_function_p;\n \n@@ -4558,8 +4558,7 @@ sparc_initial_elimination_offset (int to)\n   int offset;\n \n   if (to == STACK_POINTER_REGNUM)\n-    offset = sparc_compute_frame_size (get_frame_size (),\n-\t\t\t\t       current_function_is_leaf);\n+    offset = sparc_compute_frame_size (get_frame_size (), crtl->is_leaf);\n   else\n     offset = 0;\n \n@@ -4983,7 +4982,7 @@ sparc_expand_prologue (void)\n   HOST_WIDE_INT size;\n   rtx insn;\n \n-  /* Compute a snapshot of current_function_uses_only_leaf_regs.  Relying\n+  /* Compute a snapshot of crtl->uses_only_leaf_regs.  Relying\n      on the final value of the flag means deferring the prologue/epilogue\n      expansion until just before the second scheduling pass, which is too\n      late to emit multiple epilogues or return insns.\n@@ -5006,7 +5005,7 @@ sparc_expand_prologue (void)\n      example, the regrename pass has special provisions to not rename to\n      non-leaf registers in a leaf function.  */\n   sparc_leaf_function_p\n-    = optimize > 0 && current_function_is_leaf && only_leaf_regs_used ();\n+    = optimize > 0 && crtl->is_leaf && only_leaf_regs_used ();\n \n   size = sparc_compute_frame_size (get_frame_size(), sparc_leaf_function_p);\n \n@@ -5108,7 +5107,7 @@ sparc_flat_expand_prologue (void)\n   HOST_WIDE_INT size;\n   rtx insn;\n \n-  sparc_leaf_function_p = optimize > 0 && current_function_is_leaf;\n+  sparc_leaf_function_p = optimize > 0 && crtl->is_leaf;\n \n   size = sparc_compute_frame_size (get_frame_size(), sparc_leaf_function_p);\n \n@@ -5219,7 +5218,7 @@ sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   /* Check that the assumption we made in sparc_expand_prologue is valid.  */\n   if (!TARGET_FLAT)\n-    gcc_assert (sparc_leaf_function_p == current_function_uses_only_leaf_regs);\n+    gcc_assert (sparc_leaf_function_p == crtl->uses_only_leaf_regs);\n \n   sparc_output_scratch_registers (file);\n }\n@@ -10488,7 +10487,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n     {\n       /* We will emit a regular sibcall below, so we need to instruct\n \t output_sibcall that we are in a leaf function.  */\n-      sparc_leaf_function_p = current_function_uses_only_leaf_regs = 1;\n+      sparc_leaf_function_p = crtl->uses_only_leaf_regs = 1;\n \n       /* This will cause final.c to invoke leaf_renumber_regs so we\n \t must behave as if we were in a not-yet-leafified function.  */\n@@ -10498,7 +10497,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n     {\n       /* We will emit the sibcall manually below, so we will need to\n \t manually spill non-leaf registers.  */\n-      sparc_leaf_function_p = current_function_uses_only_leaf_regs = 0;\n+      sparc_leaf_function_p = crtl->uses_only_leaf_regs = 0;\n \n       /* We really are in a leaf function.  */\n       int_arg_first = SPARC_OUTGOING_INT_ARG_FIRST;\n@@ -11284,7 +11283,7 @@ sparc_frame_pointer_required (void)\n     return false;\n \n   /* Otherwise, the frame pointer is required if the function isn't leaf.  */\n-  return !(current_function_is_leaf && only_leaf_regs_used ());\n+  return !(crtl->is_leaf && only_leaf_regs_used ());\n }\n \n /* The way this is structured, we can't eliminate SFP in favor of SP"}, {"sha": "5cc6c677ccbc5aaf39c0f95aac3f1dfbbcc85a77", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -290,7 +290,7 @@\n \t\t ? CALLS_EH_RETURN_TRUE : CALLS_EH_RETURN_FALSE)\"))\n \n (define_attr \"leaf_function\" \"false,true\"\n-  (symbol_ref \"(current_function_uses_only_leaf_regs != 0\n+  (symbol_ref \"(crtl->uses_only_leaf_regs != 0\n \t\t? LEAF_FUNCTION_TRUE : LEAF_FUNCTION_FALSE)\"))\n \n (define_attr \"delayed_branch\" \"false,true\""}, {"sha": "3e0135fb5926e5c46e52210a99077a605c9d62bf", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1761,7 +1761,7 @@ get_pic_reg (void)\n      \"switch back\" to using pic_offset_table_rtx.  */\n   if (!cfun->machine->pic_reg)\n     {\n-      if (current_function_is_leaf && !df_regs_ever_live_p (LAST_ARG_REGNUM))\n+      if (crtl->is_leaf && !df_regs_ever_live_p (LAST_ARG_REGNUM))\n \tcfun->machine->pic_reg = gen_rtx_REG (SImode, LAST_ARG_REGNUM);\n       else\n \tcfun->machine->pic_reg = pic_offset_table_rtx;\n@@ -1963,7 +1963,7 @@ direct_return (void)\n \t      + get_frame_size ()\n \t      + crtl->outgoing_args_size\n \t      + crtl->args.pretend_args_size == 0)\n-\t  && current_function_is_leaf)\n+\t  && crtl->is_leaf)\n \treturn 1;\n     }\n   return 0;\n@@ -2023,13 +2023,13 @@ spu_expand_prologue (void)\n     + crtl->outgoing_args_size\n     + crtl->args.pretend_args_size;\n \n-  if (!current_function_is_leaf\n+  if (!crtl->is_leaf\n       || cfun->calls_alloca || total_size > 0)\n     total_size += STACK_POINTER_OFFSET;\n \n   /* Save this first because code after this might use the link\n      register as a scratch register. */\n-  if (!current_function_is_leaf)\n+  if (!crtl->is_leaf)\n     {\n       insn = frame_emit_store (LINK_REGISTER_REGNUM, sp_reg, 16);\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -2136,7 +2136,7 @@ spu_expand_epilogue (bool sibcall_p)\n     + crtl->outgoing_args_size\n     + crtl->args.pretend_args_size;\n \n-  if (!current_function_is_leaf\n+  if (!crtl->is_leaf\n       || cfun->calls_alloca || total_size > 0)\n     total_size += STACK_POINTER_OFFSET;\n \n@@ -2160,7 +2160,7 @@ spu_expand_epilogue (bool sibcall_p)\n \t}\n     }\n \n-  if (!current_function_is_leaf)\n+  if (!crtl->is_leaf)\n     frame_emit_load (LINK_REGISTER_REGNUM, sp_reg, 16);\n \n   if (!sibcall_p)\n@@ -4055,7 +4055,7 @@ spu_initial_elimination_offset (int from, int to)\n {\n   int saved_regs_size = spu_saved_regs_size ();\n   int sp_offset = 0;\n-  if (!current_function_is_leaf || crtl->outgoing_args_size\n+  if (!crtl->is_leaf || crtl->outgoing_args_size\n       || get_frame_size () || saved_regs_size)\n     sp_offset = STACK_POINTER_OFFSET;\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)"}, {"sha": "cd7521258fc30a964d86c090a316623d6b129b52", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -917,7 +917,7 @@ struct xstormy16_stack_layout\n   ((df_regs_ever_live_p (REGNUM) && ! call_used_regs[REGNUM])\t\t\\\n    || (IFUN && ! fixed_regs[REGNUM] && call_used_regs[REGNUM]\t\t\\\n        && (REGNUM != CARRY_REGNUM)\t\t\t\t\t\\\n-       && (df_regs_ever_live_p (REGNUM) || ! current_function_is_leaf)))\n+       && (df_regs_ever_live_p (REGNUM) || ! crtl->is_leaf)))\n \n /* Compute the stack layout.  */\n "}, {"sha": "25be30050ec68acb4e97aa4d0e73a8d4cfc1e661", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -3675,7 +3675,7 @@ emit_sp_adjust (int offset, int *next_scratch_regno, bool frame_related,\n static bool\n tilegx_current_function_is_leaf (void)\n {\n-  return current_function_is_leaf && !cfun->machine->calls_tls_get_addr;\n+  return crtl->is_leaf && !cfun->machine->calls_tls_get_addr;\n }\n \n "}, {"sha": "10bf7021a8c20667ef0c19a99e0c0a7ad96bb612", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -3377,7 +3377,7 @@ emit_sp_adjust (int offset, int *next_scratch_regno, bool frame_related,\n static bool\n tilepro_current_function_is_leaf (void)\n {\n-  return current_function_is_leaf && !cfun->machine->calls_tls_get_addr;\n+  return crtl->is_leaf && !cfun->machine->calls_tls_get_addr;\n }\n \n "}, {"sha": "e8e73bbd173b2967eb402bff43e8420214ec2187", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -2948,7 +2948,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \n       decl_rtl = eliminate_regs (decl_rtl, VOIDmode, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n-      if (current_function_uses_only_leaf_regs)\n+      if (crtl->uses_only_leaf_regs)\n \tleaf_renumber_regs_insn (decl_rtl);\n #endif\n \n@@ -3454,7 +3454,7 @@ dbxout_parms (tree parms)\n \tSET_DECL_RTL (parms,\n \t\t      eliminate_regs (DECL_RTL (parms), VOIDmode, NULL_RTX));\n #ifdef LEAF_REG_REMAP\n-\tif (current_function_uses_only_leaf_regs)\n+\tif (crtl->uses_only_leaf_regs)\n \t  {\n \t    leaf_renumber_regs_insn (DECL_INCOMING_RTL (parms));\n \t    leaf_renumber_regs_insn (DECL_RTL (parms));"}, {"sha": "0ca33037450cb08dc0762c688640a6b7fe009fc8", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -385,7 +385,6 @@ are write-only operations.\n #include \"recog.h\"\n #include \"function.h\"\n #include \"regs.h\"\n-#include \"output.h\"\n #include \"alloc-pool.h\"\n #include \"flags.h\"\n #include \"hard-reg-set.h\"\n@@ -711,7 +710,7 @@ rest_of_handle_df_initialize (void)\n \n   /* Set this to a conservative value.  Stack_ptr_mod will compute it\n      correctly later.  */\n-  current_function_sp_is_unchanging = 0;\n+  crtl->sp_is_unchanging = 0;\n \n   df_scan_add_problem ();\n   df_scan_alloc (NULL);"}, {"sha": "015422e1994b069ff332acf81f552bc6fc6fe877", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -9696,7 +9696,7 @@ dbx_reg_number (const_rtx rtl)\n   gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n \n #ifdef LEAF_REG_REMAP\n-  if (current_function_uses_only_leaf_regs)\n+  if (crtl->uses_only_leaf_regs)\n     {\n       int leaf_reg = LEAF_REG_REMAP (regno);\n       if (leaf_reg != -1)\n@@ -9802,7 +9802,7 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs,\n \n   reg = REGNO (rtl);\n #ifdef LEAF_REG_REMAP\n-  if (current_function_uses_only_leaf_regs)\n+  if (crtl->uses_only_leaf_regs)\n     {\n       int leaf_reg = LEAF_REG_REMAP (reg);\n       if (leaf_reg != -1)"}, {"sha": "5326018d0bff2739b904a34b1fab9d307d47cc75", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1653,7 +1653,7 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n     dwarf2out_begin_prologue (0, NULL);\n \n #ifdef LEAF_REG_REMAP\n-  if (current_function_uses_only_leaf_regs)\n+  if (crtl->uses_only_leaf_regs)\n     leaf_renumber_regs (first);\n #endif\n "}, {"sha": "518d52401c5ade0bf7893978723960d49410164a", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -92,22 +92,6 @@ along with GCC; see the file COPYING3.  If not see\n    alignment.  */\n #define CEIL_ROUND(VALUE,ALIGN)\t(((VALUE) + (ALIGN) - 1) & ~((ALIGN)- 1))\n \n-/* Nonzero if function being compiled doesn't contain any calls\n-   (ignoring the prologue and epilogue).  This is set prior to\n-   local register allocation and is valid for the remaining\n-   compiler passes.  */\n-int current_function_is_leaf;\n-\n-/* Nonzero if function being compiled doesn't modify the stack pointer\n-   (ignoring the prologue and epilogue).  This is only valid after\n-   pass_stack_ptr_mod has run.  */\n-int current_function_sp_is_unchanging;\n-\n-/* Nonzero if the function being compiled is a leaf function which only\n-   uses leaf registers.  This is valid after reload (specifically after\n-   sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n-int current_function_uses_only_leaf_regs;\n-\n /* Nonzero once virtual register instantiation has been done.\n    assign_stack_local uses frame_pointer_rtx when this is nonzero.\n    calls.c:emit_library_call_value_1 uses it to set up\n@@ -6768,7 +6752,7 @@ static unsigned int\n rest_of_handle_check_leaf_regs (void)\n {\n #ifdef LEAF_REGISTERS\n-  current_function_uses_only_leaf_regs\n+  crtl->uses_only_leaf_regs\n     = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n #endif\n   return 0;"}, {"sha": "58f38bd1c2bbbe5ddf2ca04d3244b1ba44be5acd", "filename": "gcc/function.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -440,6 +440,22 @@ struct GTY(()) rtl_data {\n   /* True if we performed shrink-wrapping for the current function.  */\n   bool shrink_wrapped;\n \n+  /* Nonzero if function being compiled doesn't modify the stack pointer\n+     (ignoring the prologue and epilogue).  This is only valid after\n+     pass_stack_ptr_mod has run.  */\n+  bool sp_is_unchanging;\n+\n+  /* Nonzero if function being compiled doesn't contain any calls\n+     (ignoring the prologue and epilogue).  This is set prior to\n+     local register allocation and is valid for the remaining\n+     compiler passes.  */\n+  bool is_leaf;\n+\n+  /* Nonzero if the function being compiled is a leaf function which only\n+     uses leaf registers.  This is valid after reload (specifically after\n+     sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n+  bool uses_only_leaf_regs;\n+\n   /* Like regs_ever_live, but 1 if a reg is set or clobbered from an\n      asm.  Unlike regs_ever_live, elements of this array corresponding\n      to eliminable regs (like the frame pointer) are set if an asm"}, {"sha": "43fb6084ca623c35eb8b48c32b7dc1704f8e8ccc", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -4175,7 +4175,7 @@ ira (FILE *f)\n   /* Determine if the current function is a leaf before running IRA\n      since this can impact optimizations done by the prologue and\n      epilogue thus changing register elimination offsets.  */\n-  current_function_is_leaf = leaf_function_p ();\n+  crtl->is_leaf = leaf_function_p ();\n \n   if (resize_reg_info () && flag_ira_loop_pressure)\n     ira_set_pseudo_classes (ira_dump_file);"}, {"sha": "4a811633a4415576ccadd7c28e4995d84456ad22", "filename": "gcc/output.h", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1,5 +1,5 @@\n-/* Declarations for insn-output.c.  These functions are defined in recog.c,\n-   final.c, and varasm.c.\n+/* Declarations for insn-output.c and other code to write to asm_out_file.\n+   These functions are defined in final.c, and varasm.c.\n    Copyright (C) 1987, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002,\n    2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n@@ -325,25 +325,6 @@ extern const char *first_global_object_name;\n /* The first weak object in the file.  */\n extern const char *weak_global_object_name;\n \n-/* Nonzero if function being compiled doesn't contain any calls\n-   (ignoring the prologue and epilogue).  This is set prior to\n-   local register allocation and is valid for the remaining\n-   compiler passes.  */\n-\n-extern int current_function_is_leaf;\n-\n-/* Nonzero if function being compiled doesn't modify the stack pointer\n-   (ignoring the prologue and epilogue).  This is only valid after\n-   pass_stack_ptr_mod has run.  */\n-\n-extern int current_function_sp_is_unchanging;\n-\n-/* Nonzero if the function being compiled is a leaf function which only\n-   uses leaf registers.  This is valid after reload (specifically after\n-   sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n-\n-extern int current_function_uses_only_leaf_regs;\n-\n /* Nonnull if the insn currently being emitted was a COND_EXEC pattern.  */\n extern rtx current_insn_predicate;\n "}, {"sha": "7b71eb15280fa8a1e48b0fa97b040e8a5cdcf883", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -323,7 +323,7 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n #ifdef LEAF_REGISTERS\n \t/* We can't use a non-leaf register if we're in a\n \t   leaf function.  */\n-\t|| (current_function_is_leaf\n+\t|| (crtl->is_leaf\n \t    && !LEAF_REGISTERS[new_reg + i])\n #endif\n #ifdef HARD_REGNO_RENAME_OK"}, {"sha": "f4bd8685e45ec7a92fc140b221bb1b385593327d", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -127,7 +127,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"regs.h\"\n #include \"recog.h\"\n #include \"flags.h\"\n-#include \"output.h\"\n #include \"obstack.h\"\n #include \"insn-attr.h\"\n #include \"resource.h\"\n@@ -2434,7 +2433,7 @@ fill_simple_delay_slots (int non_jumps_p)\n       SET_HARD_REG_BIT (needed.regs, HARD_FRAME_POINTER_REGNUM);\n #endif\n       if (! EXIT_IGNORE_STACK\n-\t  || current_function_sp_is_unchanging)\n+\t  || crtl->sp_is_unchanging)\n \tSET_HARD_REG_BIT (needed.regs, STACK_POINTER_REGNUM);\n     }\n   else"}, {"sha": "c47e1ab3bc03ab85934fe64c1024afa1693e03c2", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -1166,7 +1166,7 @@ init_resource_info (rtx epilogue_insn)\n   if (!(frame_pointer_needed\n \t&& EXIT_IGNORE_STACK\n \t&& epilogue_insn\n-\t&& !current_function_sp_is_unchanging))\n+\t&& !crtl->sp_is_unchanging))\n     SET_HARD_REG_BIT (end_of_function_needs.regs, STACK_POINTER_REGNUM);\n \n   if (crtl->return_rtx != 0)"}, {"sha": "59892ba4a20484dfeba9b48341defdcede3503ac", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -741,7 +741,7 @@ sdbout_symbol (tree decl, int local)\n       SET_DECL_RTL (decl,\n \t\t    eliminate_regs (DECL_RTL (decl), VOIDmode, NULL_RTX));\n #ifdef LEAF_REG_REMAP\n-      if (current_function_uses_only_leaf_regs)\n+      if (crtl->uses_only_leaf_regs)\n \tleaf_renumber_regs_insn (DECL_RTL (decl));\n #endif\n       value = DECL_RTL (decl);"}, {"sha": "1052920be9802baf60c6cd0d652346623873f52f", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"langhooks.h\"\n #include \"rtlhooks-def.h\"\n-#include \"output.h\"\n #include \"emit-rtl.h\"\n \n #ifdef INSN_SCHEDULING\n@@ -1140,7 +1139,7 @@ init_regs_for_mode (enum machine_mode mode)\n #ifdef LEAF_REGISTERS\n             /* We can't use a non-leaf register if we're in a\n                leaf function.  */\n-            || (current_function_is_leaf\n+            || (crtl->is_leaf\n                 && !LEAF_REGISTERS[cur_reg + i])\n #endif\n             )"}, {"sha": "1b339cd45fab6e71f8fd63bded85861120c6de11", "filename": "gcc/stack-ptr-mod.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fstack-ptr-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d/gcc%2Fstack-ptr-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack-ptr-mod.c?ref=416ff32ef8f4f2f1b1615c25aa884da9aadd8b4d", "patch": "@@ -46,7 +46,7 @@ notice_stack_pointer_modification_1 (rtx x, const_rtx pat ATTRIBUTE_UNUSED,\n       || (MEM_P (x)\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_AUTOINC\n \t  && XEXP (XEXP (x, 0), 0) == stack_pointer_rtx))\n-    current_function_sp_is_unchanging = 0;\n+    crtl->sp_is_unchanging = 0;\n }\n \n static void\n@@ -57,8 +57,8 @@ notice_stack_pointer_modification (void)\n \n   /* Assume that the stack pointer is unchanging if alloca hasn't\n      been used.  */\n-  current_function_sp_is_unchanging = !cfun->calls_alloca;\n-  if (current_function_sp_is_unchanging)\n+  crtl->sp_is_unchanging = !cfun->calls_alloca;\n+  if (crtl->sp_is_unchanging)\n     FOR_EACH_BB (bb)\n       FOR_BB_INSNS (bb, insn)\n         {\n@@ -68,15 +68,15 @@ notice_stack_pointer_modification (void)\n \t      note_stores (PATTERN (insn),\n \t\t\t   notice_stack_pointer_modification_1,\n \t\t\t   NULL);\n-\t      if (! current_function_sp_is_unchanging)\n+\t      if (! crtl->sp_is_unchanging)\n \t\treturn;\n \t    }\n \t}\n \n   /* The value coming into this pass was 0, and the exit block uses\n      are based on this.  If the value is now 1, we need to redo the\n      exit block uses.  */\n-  if (df && current_function_sp_is_unchanging)\n+  if (df && crtl->sp_is_unchanging)\n     df_update_exit_block_uses ();\n }\n "}]}