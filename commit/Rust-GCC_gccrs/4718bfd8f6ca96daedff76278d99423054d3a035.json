{"sha": "4718bfd8f6ca96daedff76278d99423054d3a035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcxOGJmZDhmNmNhOTZkYWVkZmY3NjI3OGQ5OTQyMzA1NGQzYTAzNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-10T07:44:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-10T07:44:42Z"}, "message": "stormy16.c (xstormy16_emit_cbranch): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/stormy16/stormy16.c (xstormy16_emit_cbranch): Use\n\tgcc_assert and gcc_unreachable as appropriate.\n\t(xstormy16_split_cbranch, xstormy16_output_cbranch_hi,\n\txstormy16_output_cbranch_si, xstormy16_split_move,\n\txstormy16_initial_elimination_offset,\n\txstormy16_encode_section_info, xstormy16_print_operand_address,\n\txstormy16_expand_call, xstormy16_expand_arith,\n\txstormy16_output_shift, xstormy16_init_builtins): Likewise.\n\nFrom-SVN: r99505", "tree": {"sha": "db2a286e2ba7a113f1e24b4202f00a8e023aade3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2a286e2ba7a113f1e24b4202f00a8e023aade3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4718bfd8f6ca96daedff76278d99423054d3a035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4718bfd8f6ca96daedff76278d99423054d3a035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4718bfd8f6ca96daedff76278d99423054d3a035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4718bfd8f6ca96daedff76278d99423054d3a035/comments", "author": null, "committer": null, "parents": [{"sha": "9d9165ef4838d286ac546d6168ffa8a4712acc2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9165ef4838d286ac546d6168ffa8a4712acc2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d9165ef4838d286ac546d6168ffa8a4712acc2c"}], "stats": {"total": 104, "additions": 49, "deletions": 55}, "files": [{"sha": "356e32837d6b0f64828abb30061c90a776919a08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4718bfd8f6ca96daedff76278d99423054d3a035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4718bfd8f6ca96daedff76278d99423054d3a035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4718bfd8f6ca96daedff76278d99423054d3a035", "patch": "@@ -1,3 +1,14 @@\n+2005-05-10  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/stormy16/stormy16.c (xstormy16_emit_cbranch): Use\n+\tgcc_assert and gcc_unreachable as appropriate.\n+\t(xstormy16_split_cbranch, xstormy16_output_cbranch_hi,\n+\txstormy16_output_cbranch_si, xstormy16_split_move,\n+\txstormy16_initial_elimination_offset,\n+\txstormy16_encode_section_info, xstormy16_print_operand_address,\n+\txstormy16_expand_call, xstormy16_expand_arith,\n+\txstormy16_output_shift, xstormy16_init_builtins): Likewise.\n+\n 2005-05-10  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-outof-ssa.c (_elim_graph): Change the type of nodes and"}, {"sha": "79d35def779b8bab236ce9b6e694f1c4c4d40edb", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 38, "deletions": 55, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4718bfd8f6ca96daedff76278d99423054d3a035/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4718bfd8f6ca96daedff76278d99423054d3a035/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=4718bfd8f6ca96daedff76278d99423054d3a035", "patch": "@@ -146,8 +146,7 @@ xstormy16_emit_cbranch (enum rtx_code code, rtx loc)\n   enum machine_mode mode;\n   \n   mode = GET_MODE (op0);\n-  if (mode != HImode && mode != SImode)\n-    abort ();\n+  gcc_assert (mode == HImode || mode == SImode);\n \n   if (mode == SImode\n       && (code == GT || code == LE || code == GTU || code == LEU))\n@@ -250,8 +249,7 @@ xstormy16_split_cbranch (enum machine_mode mode, rtx label, rtx comparison,\n   seq = get_insns ();\n   end_sequence ();\n \n-  if (! INSN_P (seq))\n-    abort ();\n+  gcc_assert (INSN_P (seq));\n \n   last_insn = seq;\n   while (NEXT_INSN (last_insn) != NULL_RTX)\n@@ -324,7 +322,7 @@ xstormy16_output_cbranch_hi (rtx op, const char *label, int reversed, rtx insn)\n     case LEU:  ccode = \"ls\";  break;\n       \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (need_longbranch)\n@@ -374,7 +372,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n \n       /* The missing codes above should never be generated.  */\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   switch (code)\n@@ -383,8 +381,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n       {\n \tint regnum;\n \t\n-\tif (GET_CODE (XEXP (op, 0)) != REG)\n-\t  abort ();\n+\tgcc_assert (GET_CODE (XEXP (op, 0)) == REG);\n       \n \tregnum = REGNO (XEXP (op, 0));\n \tsprintf (prevop, \"or %s,%s\", reg_names[regnum], reg_names[regnum+1]);\n@@ -396,7 +393,7 @@ xstormy16_output_cbranch_si (rtx op, const char *label, int reversed, rtx insn)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (need_longbranch)\n@@ -799,21 +796,16 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n   rtx auto_inc_reg_rtx = NULL_RTX;\n   \n   /* Check initial conditions.  */\n-  if (! reload_completed\n-      || mode == QImode || mode == HImode\n-      || ! nonimmediate_operand (dest, mode)\n-      || ! general_operand (src, mode))\n-    abort ();\n+  gcc_assert (reload_completed\n+\t      && mode != QImode && mode != HImode\n+\t      && nonimmediate_operand (dest, mode)\n+\t      && general_operand (src, mode));\n \n   /* This case is not supported below, and shouldn't be generated.  */\n-  if (GET_CODE (dest) == MEM\n-      && GET_CODE (src) == MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (dest) != MEM || GET_CODE (src) != MEM);\n \n   /* This case is very very bad after reload, so trap it now.  */\n-  if (GET_CODE (dest) == SUBREG\n-      || GET_CODE (src) == SUBREG)\n-    abort ();\n+  gcc_assert (GET_CODE (dest) != SUBREG && GET_CODE (src) != SUBREG);\n \n   /* The general idea is to copy by words, offsetting the source and\n      destination.  Normally the least-significant word will be copied\n@@ -870,12 +862,12 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n \t   && reg_overlap_mentioned_p (dest, src))\n     {\n       int regno;\n-      if (GET_CODE (dest) != REG)\n-\tabort ();\n+      \n+      gcc_assert (GET_CODE (dest) == REG);\n       regno = REGNO (dest);\n       \n-      if (! refers_to_regno_p (regno, regno + num_words, mem_operand, 0))\n-\tabort ();\n+      gcc_assert (refers_to_regno_p (regno, regno + num_words,\n+\t\t\t\t     mem_operand, 0));\n       \n       if (refers_to_regno_p (regno, regno + 1, mem_operand, 0))\n \tdirection = -1;\n@@ -887,7 +879,7 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n \t   (set (reg:DI r0) (mem:DI (reg:HI r1)))\n \t   which we'd need to support by doing the set of the second word\n \t   last.  */\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   end = direction < 0 ? -1 : num_words;\n@@ -910,9 +902,8 @@ xstormy16_split_move (enum machine_mode mode, rtx dest, rtx src)\n \tMEM_VOLATILE_P (w_dest) = 1;\n       \n       /* The simplify_subreg calls must always be able to simplify.  */\n-      if (GET_CODE (w_src) == SUBREG\n-\t  || GET_CODE (w_dest) == SUBREG)\n-\tabort ();\n+      gcc_assert (GET_CODE (w_src) != SUBREG\n+\t\t  && GET_CODE (w_dest) != SUBREG);\n       \n       insn = emit_insn (gen_rtx_SET (VOIDmode, w_dest, w_src));\n       if (auto_inc_reg_rtx)\n@@ -1075,7 +1066,7 @@ xstormy16_initial_elimination_offset (int from, int to)\n   else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     result = -(layout.sp_minus_fp + layout.fp_minus_ap);\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   return result;\n }\n@@ -1656,25 +1647,22 @@ xstormy16_encode_section_info (tree decl,\n \n       rtl = r;\n       rtlname = XEXP (rtl, 0);\n-      if (GET_CODE (rtlname) == SYMBOL_REF)\n-\toldname = XSTR (rtlname, 0);\n-      else if (GET_CODE (rtlname) == MEM\n-\t       && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-\toldname = XSTR (XEXP (rtlname, 0), 0);\n-      else\n-\tabort ();\n+      if (GET_CODE (rtlname) == MEM)\n+\trtlname = XEXP (rtlname, 0);\n+      gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+      oldname = XSTR (rtlname, 0);\n \n       if (DECL_INITIAL (decl))\n \t{\n \t  newsection = \".data_below100\";\n-\t  DECL_SECTION_NAME (decl) = build_string (strlen (newsection), newsection);\n+\t  DECL_SECTION_NAME (decl) = build_string (strlen (newsection),\n+\t\t\t\t\t\t   newsection);\n \t}\n \n       newname = alloca (strlen (oldname) + 4);\n       sprintf (newname, \"@b.%s\", oldname);\n       idp = get_identifier (newname);\n-      XEXP (rtl, 0) =\n-\tgen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+      XEXP (rtl, 0) = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n     }\n }\n \n@@ -1769,8 +1757,7 @@ xstormy16_print_operand_address (FILE *file, rtx address)\n \n   if (GET_CODE (address) == PLUS)\n     {\n-      if (GET_CODE (XEXP (address, 1)) != CONST_INT)\n-\tabort ();\n+      gcc_assert (GET_CODE (XEXP (address, 1)) == CONST_INT);\n       offset = INTVAL (XEXP (address, 1));\n       address = XEXP (address, 0);\n     }\n@@ -1782,8 +1769,7 @@ xstormy16_print_operand_address (FILE *file, rtx address)\n   if (pre_dec || post_inc)\n     address = XEXP (address, 0);\n   \n-  if (GET_CODE (address) != REG)\n-    abort ();\n+  gcc_assert (GET_CODE (address) == REG);\n \n   fputc ('(', file);\n   if (pre_dec)\n@@ -1997,8 +1983,7 @@ xstormy16_expand_call (rtx retval, rtx dest, rtx counter)\n   rtx call, temp;\n   enum machine_mode mode;\n \n-  if (GET_CODE (dest) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (dest) == MEM);\n   dest = XEXP (dest, 0);\n \n   if (! CONSTANT_P (dest)\n@@ -2120,7 +2105,7 @@ xstormy16_expand_arith (enum machine_mode mode, enum rtx_code code,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       \n       firstloop = 0;\n@@ -2147,10 +2132,8 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n   const char *r0, *r1, *rt;\n   static char r[64];\n \n-  if (GET_CODE (size_r) != CONST_INT\n-      || GET_CODE (x) != REG\n-      || mode != SImode)\n-    abort ();\n+  gcc_assert (GET_CODE (size_r) == CONST_INT\n+\t      && GET_CODE (x) == REG && mode == SImode);\n   size = INTVAL (size_r) & (GET_MODE_BITSIZE (mode) - 1);\n \n   if (size == 0)\n@@ -2174,7 +2157,7 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n \t  sprintf (r, \"shr %s,#1 | rrc %s,#1\", r1, r0);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return r;\n     }\n@@ -2194,7 +2177,7 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n \t  sprintf (r, \"mov %s,%s | mov %s,#0\", r0, r1, r1);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return r;\n     }\n@@ -2215,7 +2198,7 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n \t\t   r0, r1, r1, r0, (int) size - 16);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return r;\n     }\n@@ -2244,7 +2227,7 @@ xstormy16_output_shift (enum machine_mode mode, enum rtx_code code,\n \t       r0, rt);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return r;\n }\n@@ -2366,7 +2349,7 @@ xstormy16_init_builtins (void)\n \t    case 'S': arg = short_unsigned_type_node; break;\n \t    case 'l': arg = long_integer_type_node; break;\n \t    case 'L': arg = long_unsigned_type_node; break;\n-\t    default: abort();\n+\t    default: gcc_unreachable ();\n \t    }\n \t  if (a == 0)\n \t    ret_type = arg;"}]}