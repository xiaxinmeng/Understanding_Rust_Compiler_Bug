{"sha": "ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UzZGEwZDBkNTRjZTNlNDY5ODI4Njk4YmExYWM1ZjI1MTQ2YjZmOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-11-28T10:51:19Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-11-28T10:51:19Z"}, "message": "stor-layout.c (layout_type): Do not clear TREE_OVERFLOW on overflowed zeroes, except in one specific case.\n\n\t* stor-layout.c (layout_type) <ARRAY_TYPE>: Do not clear TREE_OVERFLOW\n\ton overflowed zeroes, except in one specific case.\nada/\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Use\n\tvalid_constant_size_p to detect too large objects.\n\t<E_Subprogram_Type>: Likewise for too large return types.\n\t(allocatable_size_p): Call valid_constant_size_p in the fixed case.\n\t(annotate_value) <INTEGER_CST>: Simplify.\n\t<BIT_AND_EXPR>: Deal with negative values here.\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Use\n\tvalid_constant_size_p to detect too large objects on the LHS.\n\t* gcc-interface/misc.c (default_pass_by_ref): Likewise for large types.\n\tAnd use TYPE_SIZE_UNIT throughout.\n\t(must_pass_by_ref): Likewise.\n\t* gcc-interface/utils.c (max_size) <tcc_unary>: Split from common case.\n\t<tcc_binary>: Likewise.  Call size_binop instead of fold_build2.\n\t<tcc_expression>: Simplify.\n\t* gcc-interface/utils2.c (build_allocator): Use valid_constant_size_p\n\tto detect too large allocations.\n\nFrom-SVN: r193886", "tree": {"sha": "66a07373943672c9d9ef3f8e395acb3f21fe89cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66a07373943672c9d9ef3f8e395acb3f21fe89cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/comments", "author": null, "committer": null, "parents": [{"sha": "fb1fbef2735bce7c62511daf6f64343d9d97e299", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb1fbef2735bce7c62511daf6f64343d9d97e299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb1fbef2735bce7c62511daf6f64343d9d97e299"}], "stats": {"total": 250, "additions": 172, "deletions": 78}, "files": [{"sha": "4890147487c2fc4a5f344d82a743785d8ac963f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -1,3 +1,8 @@\n+2012-11-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* stor-layout.c (layout_type) <ARRAY_TYPE>: Do not clear TREE_OVERFLOW\n+\ton overflowed zeroes, except in one specific case.\n+\n 2012-11-28  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR middle-end/55266"}, {"sha": "0e7d3c8ee8ef78c62663b6e2541a5ad69a8c6b35", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -1,3 +1,22 @@\n+2012-11-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Use\n+\tvalid_constant_size_p to detect too large objects.\n+\t<E_Subprogram_Type>: Likewise for too large return types.\n+\t(allocatable_size_p): Call valid_constant_size_p in the fixed case.\n+\t(annotate_value) <INTEGER_CST>: Simplify.\n+\t<BIT_AND_EXPR>: Deal with negative values here.\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Use\n+\tvalid_constant_size_p to detect too large objects on the LHS.\n+\t* gcc-interface/misc.c (default_pass_by_ref): Likewise for large types.\n+\tAnd use TYPE_SIZE_UNIT throughout.\n+\t(must_pass_by_ref): Likewise.\n+\t* gcc-interface/utils.c (max_size) <tcc_unary>: Split from common case.\n+\t<tcc_binary>: Likewise.  Call size_binop instead of fold_build2.\n+\t<tcc_expression>: Simplify.\n+\t* gcc-interface/utils2.c (build_allocator): Use valid_constant_size_p\n+\tto detect too large allocations.\n+\n 2012-11-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Length>: Look through"}, {"sha": "094d7e0ec21fe214c3f10eb98aa2270ca068d4de", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -1337,7 +1337,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  }\n \n \t\tif (TREE_CODE (TYPE_SIZE_UNIT (gnu_alloc_type)) == INTEGER_CST\n-\t\t    && TREE_OVERFLOW (TYPE_SIZE_UNIT (gnu_alloc_type)))\n+\t\t    && !valid_constant_size_p (TYPE_SIZE_UNIT (gnu_alloc_type)))\n \t\t  post_error (\"?`Storage_Error` will be raised at run time!\",\n \t\t\t      gnat_entity);\n \n@@ -4240,8 +4240,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       a function that returns that type.  This usage doesn't make\n \t       sense anyway, so give an error here.  */\n \t    if (TYPE_SIZE_UNIT (gnu_return_type)\n-\t\t&& TREE_CONSTANT (TYPE_SIZE_UNIT (gnu_return_type))\n-\t\t&& TREE_OVERFLOW (TYPE_SIZE_UNIT (gnu_return_type)))\n+\t\t&& TREE_CODE (TYPE_SIZE_UNIT (gnu_return_type)) == INTEGER_CST\n+\t\t&& !valid_constant_size_p (TYPE_SIZE_UNIT (gnu_return_type)))\n \t      {\n \t\tpost_error (\"cannot return type whose size overflows\",\n \t\t\t    gnat_entity);\n@@ -5989,10 +5989,9 @@ elaborate_entity (Entity_Id gnat_entity)\n static bool\n allocatable_size_p (tree gnu_size, bool static_p)\n {\n-  /* We can allocate a fixed size if it hasn't overflowed and can be handled\n-     (efficiently) on the host.  */\n+  /* We can allocate a fixed size if it is a valid for the middle-end.  */\n   if (TREE_CODE (gnu_size) == INTEGER_CST)\n-    return !TREE_OVERFLOW (gnu_size) && host_integerp (gnu_size, 1);\n+    return valid_constant_size_p (gnu_size);\n \n   /* We can allocate a variable size if this isn't a static allocation.  */\n   else\n@@ -7254,7 +7253,7 @@ static Uint\n annotate_value (tree gnu_size)\n {\n   TCode tcode;\n-  Node_Ref_Or_Val ops[3], ret;\n+  Node_Ref_Or_Val ops[3], ret, pre_op1 = No_Uint;\n   struct tree_int_map in;\n   int i;\n \n@@ -7283,24 +7282,7 @@ annotate_value (tree gnu_size)\n   switch (TREE_CODE (gnu_size))\n     {\n     case INTEGER_CST:\n-      if (TREE_OVERFLOW (gnu_size))\n-\treturn No_Uint;\n-\n-      /* This may come from a conversion from some smaller type, so ensure\n-\t this is in bitsizetype.  */\n-      gnu_size = convert (bitsizetype, gnu_size);\n-\n-      /* For a negative value, build NEGATE_EXPR of the opposite.  Such values\n-\t appear in expressions containing aligning patterns.  Note that, since\n-\t sizetype is sign-extended but nonetheless unsigned, we don't directly\n-\t use tree_int_cst_sgn.  */\n-      if (TREE_INT_CST_HIGH (gnu_size) < 0)\n-\t{\n-\t  tree op_size = fold_build1 (NEGATE_EXPR, bitsizetype, gnu_size);\n-\t  return annotate_value (build1 (NEGATE_EXPR, bitsizetype, op_size));\n-\t}\n-\n-      return UI_From_gnu (gnu_size);\n+      return TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);\n \n     case COMPONENT_REF:\n       /* The only case we handle here is a simple discriminant reference.  */\n@@ -7339,14 +7321,31 @@ annotate_value (tree gnu_size)\n     case TRUTH_OR_EXPR:\t\ttcode = Truth_Or_Expr; break;\n     case TRUTH_XOR_EXPR:\ttcode = Truth_Xor_Expr; break;\n     case TRUTH_NOT_EXPR:\ttcode = Truth_Not_Expr; break;\n-    case BIT_AND_EXPR:\t\ttcode = Bit_And_Expr; break;\n     case LT_EXPR:\t\ttcode = Lt_Expr; break;\n     case LE_EXPR:\t\ttcode = Le_Expr; break;\n     case GT_EXPR:\t\ttcode = Gt_Expr; break;\n     case GE_EXPR:\t\ttcode = Ge_Expr; break;\n     case EQ_EXPR:\t\ttcode = Eq_Expr; break;\n     case NE_EXPR:\t\ttcode = Ne_Expr; break;\n \n+    case BIT_AND_EXPR:\n+      tcode = Bit_And_Expr;\n+      /* For negative values, build NEGATE_EXPR of the opposite.  Such values\n+\t appear in expressions containing aligning patterns.  Note that, since\n+\t sizetype is unsigned, we have to jump through some hoops.   */\n+      if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST)\n+\t{\n+\t  tree op1 = TREE_OPERAND (gnu_size, 1);\n+\t  double_int signed_op1\n+\t    = tree_to_double_int (op1).sext (TYPE_PRECISION (sizetype));\n+\t  if (signed_op1.is_negative ())\n+\t    {\n+\t      op1 = double_int_to_tree (sizetype, -signed_op1);\n+\t      pre_op1 = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));\n+\t    }\n+\t}\n+      break;\n+\n     case CALL_EXPR:\n       {\n \ttree t = maybe_inline_call_in_expr (gnu_size);\n@@ -7367,7 +7366,10 @@ annotate_value (tree gnu_size)\n \n   for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)\n     {\n-      ops[i] = annotate_value (TREE_OPERAND (gnu_size, i));\n+      if (i == 1 && pre_op1 != No_Uint)\n+\tops[i] = pre_op1;\n+      else\n+\tops[i] = annotate_value (TREE_OPERAND (gnu_size, i));\n       if (ops[i] == No_Uint)\n \treturn No_Uint;\n     }"}, {"sha": "3d3f16110ce0075bc5e1b1e25343a1fc66f4954f", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -604,8 +604,8 @@ gnat_get_subrange_bounds (const_tree gnu_type, tree *lowval, tree *highval)\n bool\n default_pass_by_ref (tree gnu_type)\n {\n-  /* We pass aggregates by reference if they are sufficiently large.  The\n-     choice of constant here is somewhat arbitrary.  We also pass by\n+  /* We pass aggregates by reference if they are sufficiently large for\n+     their alignment.  The ratio is somewhat arbitrary.  We also pass by\n      reference if the target machine would either pass or return by\n      reference.  Strictly speaking, we need only check the return if this\n      is an In Out parameter, but it's probably best to err on the side of\n@@ -618,9 +618,9 @@ default_pass_by_ref (tree gnu_type)\n     return true;\n \n   if (AGGREGATE_TYPE_P (gnu_type)\n-      && (!host_integerp (TYPE_SIZE (gnu_type), 1)\n-\t  || 0 < compare_tree_int (TYPE_SIZE (gnu_type),\n-\t\t\t\t   8 * TYPE_ALIGN (gnu_type))))\n+      && (!valid_constant_size_p (TYPE_SIZE_UNIT (gnu_type))\n+\t  || 0 < compare_tree_int (TYPE_SIZE_UNIT (gnu_type),\n+\t\t\t\t   TYPE_ALIGN (gnu_type))))\n     return true;\n \n   return false;\n@@ -639,8 +639,8 @@ must_pass_by_ref (tree gnu_type)\n      not have such objects.  */\n   return (TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n \t  || TYPE_IS_BY_REFERENCE_P (gnu_type)\n-\t  || (TYPE_SIZE (gnu_type)\n-\t      && TREE_CODE (TYPE_SIZE (gnu_type)) != INTEGER_CST));\n+\t  || (TYPE_SIZE_UNIT (gnu_type)\n+\t      && TREE_CODE (TYPE_SIZE_UNIT (gnu_type)) != INTEGER_CST));\n }\n \n /* This function is called by the front-end to enumerate all the supported"}, {"sha": "291d00f1c275193dd1190d768e20f96afcbdeb6a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -6115,7 +6115,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* If the type has a size that overflows, convert this into raise of\n \t Storage_Error: execution shouldn't have gotten here anyway.  */\n       if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))) == INTEGER_CST\n-\t   && TREE_OVERFLOW (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))))\n+\t   && !valid_constant_size_p (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))))\n \tgnu_result = build_call_raise (SE_Object_Too_Large, gnat_node,\n \t\t\t\t       N_Raise_Storage_Error);\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call)"}, {"sha": "716ea9e3270e59108663bd2d74e8fbc46a8a1f8c", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -3024,59 +3024,67 @@ max_size (tree exp, bool max_p)\n       return max_p ? size_one_node : size_zero_node;\n \n     case tcc_unary:\n+      if (code == NON_LVALUE_EXPR)\n+\treturn max_size (TREE_OPERAND (exp, 0), max_p);\n+ \n+      return fold_build1 (code, type,\n+\t\t\t  max_size (TREE_OPERAND (exp, 0),\n+\t\t\t\t    code == NEGATE_EXPR ? !max_p : max_p));\n+\n     case tcc_binary:\n+      {\n+\ttree lhs = max_size (TREE_OPERAND (exp, 0), max_p);\n+\ttree rhs = max_size (TREE_OPERAND (exp, 1),\n+\t\t\t     code == MINUS_EXPR ? !max_p : max_p);\n+\n+\t/* Special-case wanting the maximum value of a MIN_EXPR.\n+\t   In that case, if one side overflows, return the other.  */\n+\tif (max_p && code == MIN_EXPR)\n+\t  {\n+\t    if (TREE_CODE (rhs) == INTEGER_CST && TREE_OVERFLOW (rhs))\n+\t      return lhs;\n+\n+\t    if (TREE_CODE (lhs) == INTEGER_CST && TREE_OVERFLOW (lhs))\n+\t      return rhs;\n+\t  }\n+\n+\t/* Likewise, handle a MINUS_EXPR or PLUS_EXPR with the LHS\n+\t   overflowing and the RHS a variable.  */\n+\tif ((code == MINUS_EXPR || code == PLUS_EXPR)\n+\t    && TREE_CODE (lhs) == INTEGER_CST\n+\t    && TREE_OVERFLOW (lhs)\n+\t    && !TREE_CONSTANT (rhs))\n+\t  return lhs;\n+\n+\treturn size_binop (code, lhs, rhs);\n+      }\n+\n     case tcc_expression:\n       switch (TREE_CODE_LENGTH (code))\n \t{\n \tcase 1:\n \t  if (code == SAVE_EXPR)\n \t    return exp;\n-\t  else if (code == NON_LVALUE_EXPR)\n-\t    return max_size (TREE_OPERAND (exp, 0), max_p);\n-\t  else\n-\t    return\n-\t      fold_build1 (code, type,\n-\t\t\t   max_size (TREE_OPERAND (exp, 0),\n-\t\t\t\t     code == NEGATE_EXPR ? !max_p : max_p));\n+\n+\t  return fold_build1 (code, type,\n+\t\t\t      max_size (TREE_OPERAND (exp, 0), max_p));\n \n \tcase 2:\n \t  if (code == COMPOUND_EXPR)\n \t    return max_size (TREE_OPERAND (exp, 1), max_p);\n \n-\t  {\n-\t    tree lhs = max_size (TREE_OPERAND (exp, 0), max_p);\n-\t    tree rhs = max_size (TREE_OPERAND (exp, 1),\n-\t\t\t\t code == MINUS_EXPR ? !max_p : max_p);\n-\n-\t    /* Special-case wanting the maximum value of a MIN_EXPR.\n-\t       In that case, if one side overflows, return the other.\n-\t       sizetype is signed, but we know sizes are non-negative.\n-\t       Likewise, handle a MINUS_EXPR or PLUS_EXPR with the LHS\n-\t       overflowing and the RHS a variable.  */\n-\t    if (max_p\n-\t\t&& code == MIN_EXPR\n-\t\t&& TREE_CODE (rhs) == INTEGER_CST\n-\t\t&& TREE_OVERFLOW (rhs))\n-\t      return lhs;\n-\t    else if (max_p\n-\t\t     && code == MIN_EXPR\n-\t\t     && TREE_CODE (lhs) == INTEGER_CST\n-\t\t     && TREE_OVERFLOW (lhs))\n-\t      return rhs;\n-\t    else if ((code == MINUS_EXPR || code == PLUS_EXPR)\n-\t\t     && TREE_CODE (lhs) == INTEGER_CST\n-\t\t     && TREE_OVERFLOW (lhs)\n-\t\t     && !TREE_CONSTANT (rhs))\n-\t      return lhs;\n-\t    else\n-\t      return fold_build2 (code, type, lhs, rhs);\n-\t  }\n+\t  return fold_build2 (code, type,\n+\t\t\t      max_size (TREE_OPERAND (exp, 0), max_p),\n+\t\t\t      max_size (TREE_OPERAND (exp, 1), max_p));\n \n \tcase 3:\n \t  if (code == COND_EXPR)\n \t    return fold_build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n \t\t\t\tmax_size (TREE_OPERAND (exp, 1), max_p),\n \t\t\t\tmax_size (TREE_OPERAND (exp, 2), max_p));\n+\n+\tdefault:\n+\t  break;\n \t}\n \n       /* Other tree classes cannot happen.  */"}, {"sha": "71dd8e5651395b0d56da8069243f7e96e90c54ac", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -2286,7 +2286,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t\t\t\t\t     init);\n \n       /* If the size overflows, pass -1 so Storage_Error will be raised.  */\n-      if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n+      if (TREE_CODE (size) == INTEGER_CST && !valid_constant_size_p (size))\n \tsize = size_int (-1);\n \n       storage = build_call_alloc_dealloc (NULL_TREE, size, storage_type,\n@@ -2345,7 +2345,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n     }\n \n   /* If the size overflows, pass -1 so Storage_Error will be raised.  */\n-  if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n+  if (TREE_CODE (size) == INTEGER_CST && !valid_constant_size_p (size))\n     size = size_int (-1);\n \n   storage = convert (result_type,"}, {"sha": "d0c093f936492547e51dcc69d0674f7b074c1f2a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -2233,12 +2233,12 @@ layout_type (tree type)\n \t\t\t\t\t      size_binop (MINUS_EXPR, ub, lb)));\n \t      }\n \n-\t    /* If we arrived at a length of zero ignore any overflow\n-\t       that occurred as part of the calculation.  There exists\n-\t       an association of the plus one where that overflow would\n-\t       not happen.  */\n+\t    /* ??? We have no way to distinguish a null-sized array from an\n+\t       array spanning the whole sizetype range, so we arbitrarily\n+\t       decide that [0, -1] is the only valid representation.  */\n \t    if (integer_zerop (length)\n-\t\t&& TREE_OVERFLOW (length))\n+\t        && TREE_OVERFLOW (length)\n+\t\t&& integer_zerop (lb))\n \t      length = size_zero_node;\n \n \t    TYPE_SIZE (type) = size_binop (MULT_EXPR, element_size,"}, {"sha": "d01a700d9ab46e68d23ca9425c4489834e9078ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -1,3 +1,11 @@\n+2012-11-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/object_overflow.adb: Rename to...\n+\t* gnat.dg/object_overflow1.adb: ...this.\n+\t* gnat.dg/object_overflow2.adb: New test.\n+\t* gnat.dg/object_overflow3.adb: Likewise.\n+\t* gnat.dg/object_overflow4.adb: Likewise.\n+\n 2012-11-28  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/55497"}, {"sha": "ba7f657e71027b78c7e04f577982dafd49da873a", "filename": "gcc/testsuite/gnat.dg/object_overflow1.adb", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow1.adb?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -1,6 +1,6 @@\n -- { dg-do compile }\n \n-procedure Object_Overflow is\n+procedure Object_Overflow1 is\n \n   procedure Proc (x : Boolean) is begin null; end;\n ", "previous_filename": "gcc/testsuite/gnat.dg/object_overflow.adb"}, {"sha": "9601c563b2a418e69fed54cab1d197ecfbf47aee", "filename": "gcc/testsuite/gnat.dg/object_overflow2.adb", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow2.adb?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -0,0 +1,13 @@\n+-- { dg-do compile }\n+\n+procedure Object_Overflow2 is\n+\n+  procedure Proc (x : Boolean) is begin null; end;\n+\n+  type Arr is array(0 .. Long_Integer'Last) of Boolean;\n+  Obj : Arr; -- { dg-warning \"Storage_Error\" }\n+\n+begin\n+  Obj(1) := True;\n+  Proc (Obj(1));\n+end;"}, {"sha": "5e27b4f0d81da0e6093de3d81cce4e6156d820e4", "filename": "gcc/testsuite/gnat.dg/object_overflow3.adb", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow3.adb?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -0,0 +1,19 @@\n+-- { dg-do compile }\n+\n+procedure Object_Overflow3 is\n+\n+  procedure Proc (x : Boolean) is begin null; end;\n+\n+  type Arr is array(0 .. Long_Integer'Last) of Boolean;\n+\n+  type Rec is record\n+    A : Arr;\n+    B : Arr;\n+  end record;\n+\n+  Obj : Rec; -- { dg-warning \"Storage_Error\" }\n+\n+begin\n+  Obj.A(1) := True;\n+  Proc (Obj.A(1));\n+end;"}, {"sha": "643989d348cd2d7a5398bd4bf8f4fbcd15cbb3ef", "filename": "gcc/testsuite/gnat.dg/object_overflow4.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce3da0d0d54ce3e469828698ba1ac5f25146b6f9/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fobject_overflow4.adb?ref=ce3da0d0d54ce3e469828698ba1ac5f25146b6f9", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do compile }\n+\n+procedure Object_Overflow4 is\n+\n+  procedure Proc (x : Integer) is begin null; end;\n+\n+  type Index is new Long_Integer range 0 .. Long_Integer'Last;\n+\n+  type Arr is array(Index range <>) of Integer;\n+\n+  type Rec (Size: Index := 6) is record -- { dg-warning \"Storage_Error\" }\n+    A: Arr (0..Size);\n+  end record;\n+\n+  Obj : Rec; -- { dg-warning \"Storage_Error\" }\n+\n+begin\n+  Obj.A(1) := 0;\n+  Proc (Obj.A(1));\n+end;"}]}