{"sha": "26731a9e43668e28553e494a9f5f3cf946a83012", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY3MzFhOWU0MzY2OGUyODU1M2U0OTRhOWY1ZjNjZjk0NmE4MzAxMg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-11T22:45:37Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-11T22:45:37Z"}, "message": "Initial revision\n\nFrom-SVN: r7726", "tree": {"sha": "257c40b873eb4076d5ea931f741216521ea71a37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/257c40b873eb4076d5ea931f741216521ea71a37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26731a9e43668e28553e494a9f5f3cf946a83012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26731a9e43668e28553e494a9f5f3cf946a83012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26731a9e43668e28553e494a9f5f3cf946a83012", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26731a9e43668e28553e494a9f5f3cf946a83012/comments", "author": null, "committer": null, "parents": [{"sha": "159c2aedc68ef2d82cb9adcd668bf883b519a14f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159c2aedc68ef2d82cb9adcd668bf883b519a14f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/159c2aedc68ef2d82cb9adcd668bf883b519a14f"}], "stats": {"total": 672, "additions": 672, "deletions": 0}, "files": [{"sha": "370ba75ed048cd4e7bd3285a5a8a0f74f2e49fac", "filename": "gcc/config/h8300/lib1funcs.asm", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26731a9e43668e28553e494a9f5f3cf946a83012/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26731a9e43668e28553e494a9f5f3cf946a83012/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Flib1funcs.asm?ref=26731a9e43668e28553e494a9f5f3cf946a83012", "patch": "@@ -0,0 +1,672 @@\n+;; libgcc1 routines for the Hitachi h8/300 cpu.\n+;; Contributed by Steve Chamberlain.\n+;; sac@cygnus.com\n+;; This file is in the public domain.\n+\n+/* Assembler register definitions.  */\n+\n+#define A0 r0\n+#define A0L r0l\n+#define A0H r0h\n+\n+#define A1 r1\n+#define A1L r1l\n+#define A1H r1h\n+\n+#define A2 r2\n+#define A2L r2l\n+#define A2H r2h\n+\n+#define A3 r3\n+#define A3L r3l\n+#define A3H r3h\n+\n+#define S0 r4\n+#define S0L r4l\n+#define S0H r4h\n+\n+#define S1 r5\n+#define S1L r5l\n+#define S1H r5h\n+\n+#define S2 r6\n+#define S2L r6l\n+#define S2H r6h\n+\n+#ifdef __H8300__\n+#define MOVP\tmov.w\t/* pointers are 16 bits */\n+#define ADDP\tadd.w\n+#define CMPP\tcmp.w\n+#define PUSHP\tpush\n+#define POPP\tpop\n+\n+#define A0P\tr0\n+#define A1P\tr1\n+#define A2P\tr2\n+#define A3P\tr3\n+#define S0P\tr4\n+#define S1P\tr5\n+#define S2P\tr6\n+#endif\n+\n+#ifdef __H8300H__\n+#define MOVP\tmov.l\t/* pointers are 32 bits */\n+#define ADDP\tadd.l\n+#define CMPP\tcmp.l\n+#define PUSHP\tpush.l\n+#define POPP\tpop.l\n+\n+#define A0P\ter0\n+#define A1P\ter1\n+#define A2P\ter2\n+#define A3P\ter3\n+#define S0P\ter4\n+#define S1P\ter5\n+#define S2P\ter6\n+\n+#define A0E\te0\n+#define A1E\te1\n+#define A2E\te2\n+#define A3E\te3\n+#endif\n+\n+#ifdef L_cmpsi2\n+#ifdef __H8300__\n+\t.section .text\n+\t.align 2\n+\t.global ___cmpsi2\n+___cmpsi2:\n+\tcmp.w\tA2,A0\n+\tbne\t.L2\n+\tcmp.w\tA3,A1\n+\tbne\t.L2\n+\tmov.w\t#1,A0\n+\trts\n+.L2:\n+\tcmp.w\tA0,A2\n+\tbgt\t.L4\n+\tbne\t.L3\n+\tcmp.w\tA1,A3\n+\tbls\t.L3\n+.L4:\n+\tsub.w\tA0,A0\n+\trts\n+.L3:\n+\tmov.w\t#2,A0\n+.L5:\n+\trts\n+\t.end\n+#endif\n+#endif /* L_cmpsi2 */\n+\n+#ifdef L_ucmpsi2\n+#ifdef __H8300__\n+\t.section .text\n+\t.align 2\n+\t.global ___ucmpsi2\n+___ucmpsi2:\n+\tcmp.w\tA2,A0\n+\tbne\t.L2\n+\tcmp.w\tA3,A1\n+\tbne\t.L2\n+\tmov.w\t#1,A0\n+\trts\n+.L2:\n+\tcmp.w\tA0,A2\n+\tbhi\t.L4\n+\tbne\t.L3\n+\tcmp.w\tA1,A3\n+\tbls\t.L3\n+.L4:\n+\tsub.w\tA0,A0\n+\trts\n+.L3:\n+\tmov.w\t#2,A0\n+.L5:\n+\trts\n+\t.end\n+#endif\n+#endif /* L_ucmpsi2 */\n+\n+#ifdef L_divhi3\n+\n+;; HImode divides for the H8/300.\n+;; We bunch all of this into one object file since there are several\n+;; \"supporting routines\".\n+\n+; general purpose normalize routine\n+; \n+; divisor in A0\n+; dividend in A1\n+; turns both into +ve numbers, and leaves what the answer sign\n+; should be in A2L\n+\n+#ifdef __H8300__\n+\t.section .text\n+\t.align 2\n+divnorm:\n+\tmov.b\t#0x0,A2L\n+\tor\tA0H,A0H\t\t; is divisor > 0\n+\tbge\t_lab1\t\t\t\n+\tnot\tA0H\t\t; no - then make it +ve\n+\tnot\tA0L\n+\tadds\t#1,A0\t\t\t\n+\txor\t#0x1,A2L\t; and remember that in A2L\n+_lab1:\tor\tA1H,A1H\t; look at dividend\n+\tbge\t_lab2\t\t\n+\tnot\tA1H\t\t; it is -ve, make it positive\n+\tnot\tA1L\n+\tadds\t#1,A1\n+\txor\t#0x1,A2L; and toggle sign of result\n+_lab2:\trts\n+\n+; A0=A0/A1 signed\n+\n+\t.global\t___divhi3\n+___divhi3:\n+\tbsr\tdivnorm\n+\tbsr\t___udivhi3\n+negans:\tor\tA2L,A2L\t; should answer be negative ?\n+\tbeq\t_lab4\n+\tnot\tA0H\t; yes, so make it so\n+\tnot\tA0L\n+\tadds\t#1,A0\n+_lab4:\trts\t\n+\n+; A0=A0%A1 signed\n+\n+\t.global\t___modhi3\n+___modhi3:\n+\tbsr\tdivnorm\n+\tbsr\t___udivhi3\n+\tmov\tA3,A0\n+\tbra\tnegans\n+\n+; A0=A0%A1 unsigned\n+\n+\t.global\t___umodhi3\n+___umodhi3:\n+\tbsr\t___udivhi3\n+\tmov\tA3,A0\n+\trts\n+\n+; A0=A0/A1 unsigned\n+; A3=A0%A1 unsigned\n+; A2H trashed\n+; D high 8 bits of denom\n+; d low 8 bits of denom\n+; N high 8 bits of num\n+; n low 8 bits of num\n+; M high 8 bits of mod\n+; m low 8 bits of mod\n+; Q high 8 bits of quot\n+; q low 8 bits of quot\n+; P preserve\n+\n+; The h8 only has a 16/8 bit divide, so we look at the incoming and\n+; see how to partition up the expression.\n+\n+\t.global\t___udivhi3\n+___udivhi3:\n+\t\t\t\t; A0 A1 A2 A3 \n+\t\t\t\t; Nn Dd       P\n+\tsub.w\tA3,A3\t\t; Nn Dd xP 00 \n+\tor\tA1H,A1H\t\t \n+\tbne\tdivlongway\n+\tor\tA0H,A0H\t\t\n+\tbeq\t_lab6\t\t\n+\n+; we know that D == 0 and N is != 0\n+\tmov.b\tA0H,A3L\t\t; Nn Dd xP 0N\n+\tdivxu\tA1L,A3\t\t;          MQ\n+\tmov.b\tA3L,A0H\t \t; Q\n+; dealt with N, do n\n+_lab6:\tmov.b\tA0L,A3L\t\t;           n\n+\tdivxu\tA1L,A3\t\t;          mq\n+\tmov.b\tA3L,A0L\t\t; Qq\n+\tmov.b\tA3H,A3L         ;           m\n+\tmov.b\t#0x0,A3H\t; Qq       0m\n+\trts\t\n+\n+; D != 0 - which means the denominator is\n+;          loop around to get the result.\n+\n+divlongway:\n+\tmov.b\tA0H,A3L\t\t; Nn Dd xP 0N\n+\tmov.b\t#0x0,A0H\t; high byte of answer has to be zero\n+\tmov.b\t#0x8,A2H\t;       8\n+div8:\tadd.b\tA0L,A0L\t\t; n*=2\n+\trotxl\tA3L\t\t; Make remainder bigger\n+\trotxl\tA3H\t\t\n+\tsub.w\tA1,A3\t\t; Q-=N\n+\tbhs\tsetbit\t\t; set a bit ?\n+\tadd.w\tA1,A3\t\t;  no : too far , Q+=N\n+\n+\tdec\tA2H\t\t\n+\tbne\tdiv8\t\t; next bit\t\n+\trts\t\n+\n+setbit:\tinc\tA0L\t\t; do insert bit\n+\tdec\tA2H\t\t\n+\tbne\tdiv8\t\t; next bit\t\n+\trts\t\n+\n+#endif /* __H8300__ */\n+#endif /* L_divhi3 */\n+\n+#ifdef L_divsi3\n+\n+;; 4 byte integer divides for the H8/300.\n+;;\n+;; We have one routine which does all the work and lots of \n+;; little ones which prepare the args and massage the sign.\n+;; We bunch all of this into one object file since there are several\n+;; \"supporting routines\".\n+\n+#ifdef __H8300H__\n+\t.h8300h\n+#endif\n+\n+\t.section .text\n+\t.align 2\n+\n+; Put abs SIs into r0/r1 and r2/r3, and leave a 1 in r6l with sign of rest.\n+; This function is here to keep branch displacements small.\n+\n+#ifdef __H8300__\n+\n+divnorm:\n+\tmov.b\t#0,S2L\t\t; keep the sign in S2\n+\tmov.b\tA0H,A0H\t\t; is the numerator -ve\n+\tbge\tpostive\n+\n+\t; negate arg\n+\tnot\tA0H\n+\tnot\tA1H\n+\tnot\tA0L\n+\tnot\tA1L\n+\n+\tadd\t#1,A1L\n+\taddx\t#0,A1H\n+\taddx\t#0,A0H\n+\taddx\t#0,A0L\n+\n+\tmov.b\t#1,S2L\t\t; the sign will be -ve\n+postive:\n+\tmov.b\tA2H,A2H\t\t; is the denominator -ve\n+\tbge\tpostive2\n+\tnot\tA2L\t\t\n+\tnot\tA2H\n+\tnot\tA3L\n+\tnot\tA3H\n+\tadd.b\t#1,A3L\t\n+\taddx\t#0,A3H\n+\taddx\t#0,A2L\n+\taddx\t#0,A2H\n+\txor\t#1,S2L\t\t; toggle result sign\n+postive2:\n+\trts\n+\n+#else /* __H8300H__ */\n+\n+divnorm:\n+\tmov.b\t#0,S2L\t\t; keep the sign in S2\n+\tmov.l\tA0P,A0P\t\t; is the numerator -ve\n+\tbge\tpostive\n+\n+\tneg.l\tA0P\t\t; negate arg\n+\tmov.b\t#1,S2L\t\t; the sign will be -ve\n+\n+postive:\n+\tmov.l\tA1P,A1P\t\t; is the denominator -ve\n+\tbge\tpostive2\n+\n+\tneg.l\tA1P\t\t; negate arg\n+\txor.b\t#1,S2L\t\t; toggle result sign\n+\n+postive2:\n+\trts\n+\n+#endif\n+\n+; numerator in A0/A1\n+; denominator in A2/A3\n+\t.global\t___modsi3\n+___modsi3:\n+\tPUSHP\tS2P\t\t\n+\tPUSHP\tS0P\n+\tPUSHP\tS1P\n+\n+\tbsr\tdivnorm\n+\tbsr\tdivmodsi4\n+#ifdef __H8300__\n+\tmov\tS0,A0\n+\tmov\tS1,A1\n+#else\n+\tmov.l\tS0P,A0P\n+#endif\n+\tbra\texitdiv\n+\n+\t.global\t___udivsi3\n+___udivsi3:\n+\tPUSHP\tS2P\n+\tPUSHP\tS0P\n+\tPUSHP\tS1P\n+\tmov.b\t#0,S2L\t; keep sign low\n+\tbsr\tdivmodsi4\n+\tbra\texitdiv\n+\n+\t.global\t___umodsi3\n+___umodsi3:\n+\tPUSHP\tS2P\n+\tPUSHP\tS0P\n+\tPUSHP\tS1P\n+\tmov.b\t#0,S2L\t; keep sign low\n+\tbsr\tdivmodsi4\n+#ifdef __H8300__\n+\tmov\tS0,A0\n+\tmov\tS1,A1\n+#else\n+\tmov.l\tS0P,A0P\n+#endif\n+\tbra\texitdiv\n+\t\n+\t.global\t___divsi3\n+___divsi3:\n+\tPUSHP\tS2P\n+\tPUSHP\tS0P\n+\tPUSHP\tS1P\n+\tjsr\tdivnorm\n+\tjsr\tdivmodsi4\n+\n+\t; examine what the sign should be\n+exitdiv:\n+\tPOPP\tS1P\n+\tPOPP\tS0P\n+\n+\tor\tS2L,S2L\n+\tbeq\treti\n+\t\n+\t; should be -ve\n+#ifdef __H8300__\n+\tnot\tA0H\n+\tnot\tA1H\n+\tnot\tA0L\n+\tnot\tA1L\n+\n+\tadd\t#1,A1L\n+\taddx\t#0,A1H\n+\taddx\t#0,A0H\n+\taddx\t#0,A0L\n+#else /* __H8300H__ */\n+\tneg.l\tA0P\n+#endif\n+\n+reti:\n+\tPOPP\tS2P\n+\trts\t\n+\n+\t; takes A0/A1 numerator (A0P for 300h)\n+\t; A2/A3 denominator (A1P for 300h)\n+\t; returns A0/A1 quotient (A0P for 300h)\n+\t; S0/S1 remainder (S0P for 300h)\n+\t; trashes S2\n+\n+#ifdef __H8300__\n+\n+divmodsi4:\n+        sub.w\tS0,S0\t\t; zero play area\n+        mov.w\tS0,S1\n+        mov.b\tA2H,S2H\n+        or\tA2L,S2H\n+        or\tA3H,S2H\n+        bne\tDenHighZero\n+        mov.b\tA0H,A0H\n+        bne\tNumByte0Zero\n+        mov.b\tA0L,A0L\n+        bne\tNumByte1Zero\n+        mov.b\tA1H,A1H\n+        bne\tNumByte2Zero\n+        bra\tNumByte3Zero\n+NumByte0Zero:\n+\tmov.b\tA0H,S1L\n+        divxu\tA3L,S1\n+        mov.b\tS1L,A0H\n+NumByte1Zero:\n+\tmov.b\tA0L,S1L\n+        divxu\tA3L,S1\n+        mov.b\tS1L,A0L\n+NumByte2Zero:\n+\tmov.b\tA1H,S1L\n+        divxu\tA3L,S1\n+        mov.b\tS1L,A1H\n+NumByte3Zero:\n+\tmov.b\tA1L,S1L\n+        divxu\tA3L,S1\n+        mov.b\tS1L,A1L\n+\n+        mov.b\tS1H,S1L\n+        mov.b\t#0x0,S1H\n+        rts\t\n+\n+; have to do the divide by shift and test\n+DenHighZero:\n+\tmov.b\tA0H,S1L\n+        mov.b\tA0L,A0H\n+        mov.b\tA1H,A0L\n+        mov.b\tA1L,A1H\n+\n+        mov.b\t#0,A1L\n+        mov.b\t#24,S2H\t; only do 24 iterations\n+\n+nextbit:\n+\tadd.w\tA1,A1\t; double the answer guess\n+        rotxl\tA0L\n+        rotxl\tA0H\n+\n+        rotxl\tS1L\t; double remainder\n+        rotxl\tS1H\n+        rotxl\tS0L\n+        rotxl\tS0H\n+        sub.w\tA3,S1\t; does it all fit\n+        subx\tA2L,S0L\n+        subx\tA2H,S0H\n+        bhs\tsetone\t \n+\n+        add.w\tA3,S1\t; no, restore mistake\n+        addx\tA2L,S0L\n+        addx\tA2H,S0H\n+\n+        dec\tS2H\n+        bne\tnextbit\n+        rts\t\n+\t\n+setone:\n+\tinc\tA1L\n+        dec\tS2H\n+        bne\tnextbit\n+        rts\t\n+\n+#else /* __H8300H__ */\n+\n+divmodsi4:\n+\tsub.l\tS0P,S0P\t\t; zero play area\n+\tmov.w\tA1E,A1E\t\t; denominator top word 0?\n+\tbne\tDenHighZero\n+\n+\t; do it the easy way, see page 107 in manual\n+\tmov.w\tA0E,A2\n+\textu.l\tA2P\n+\tdivxu.w\tA1,A2P\n+\tmov.w\tA2E,A0E\n+\tdivxu.w\tA1,A0P\n+\tmov.w\tA0E,S0\n+\tmov.w\tA2,A0E\n+\textu.l\tS0P\n+\trts\n+\n+DenHighZero:\n+\tmov.w\tA0E,A2\n+\tmov.b\tA2H,S0L\n+\tmov.b\tA2L,A2H\n+\tmov.b\tA0H,A2L\n+\tmov.w\tA2,A0E\n+\tmov.b\tA0L,A0H\n+\tmov.b\t#0,A0L\n+\tmov.b\t#24,S2H\t\t; only do 24 iterations\n+\n+nextbit:\n+\tshll.l\tA0P\t\t; double the answer guess\n+\trotxl.l\tS0P\t\t; double remainder\n+\tsub.l\tA1P,S0P\t\t; does it all fit?\n+\tbhs\tsetone\n+\n+\tadd.l\tA1P,S0P\t\t; no, restore mistake\n+\tdec\tS2H\n+\tbne\tnextbit\n+\trts\n+\n+setone:\n+\tinc\tA0L\n+\tdec\tS2H\n+\tbne\tnextbit\n+\trts\n+\n+#endif\n+#endif /* L_divsi3 */\n+\n+#ifdef L_mulhi3\n+\n+;; HImode multiply.\n+; The h8 only has an 8*8->16 multiply.\n+; The answer is the same as:\n+; \n+; product = (srca.l * srcb.l) + ((srca.h * srcb.l) + (srcb.h * srca.l)) * 256\n+; (we can ignore A1.h * A0.h cause that will all off the top)\n+; A0 in\n+; A1 in \n+; A0 answer\n+\n+#ifdef __H8300__\n+\t.section .text\n+\t.align 2\n+\t.global\t___mulhi3\n+___mulhi3:\n+\tmov.b\tA1L,A2L\t\t; A2l gets srcb.l\n+\tmulxu\tA0L,A2\t\t; A2 gets first sub product \n+\n+\tmov.b\tA0H,A3L\t\t; prepare for\n+\tmulxu\tA1L,A3\t\t; second sub product\n+\n+\tadd.b\tA3L,A2H\t\t; sum first two terms\n+\n+\tmov.b\tA1H,A3L\t\t; third sub product\n+\tmulxu\tA0L,A3\t\t\n+\n+\tadd.b\tA3L,A2H\t\t; almost there\n+\tmov.w\tA2,A0\t\t; that is\n+\trts\n+\n+#endif\n+#endif /* L_mulhi3 */\n+\n+#ifdef L_mulsi3\n+\n+;; SImode multiply.\n+;; \n+;; I think that shift and add may be sufficient for this.  Using the\n+;; supplied 8x8->16 would need 10 ops of 14 cycles each + overhead.  This way\n+;; the inner loop uses maybe 20 cycles + overhead, but terminates\n+;; quickly on small args.\n+;;\n+;; A0/A1 src_a\n+;; A2/A3 src_b\n+;;\n+;;  while (a) \n+;;    {\n+;;      if (a & 1)\n+;;        r += b;\n+;;      a >>= 1;\n+;;      b <<= 1;\n+;;    }\n+\n+\t.section .text\n+\t.align 2\n+\n+#ifdef __H8300__\n+\n+\t.global\t___mulsi3\n+___mulsi3:\n+\tPUSHP\tS0P\n+\tPUSHP\tS1P\n+\tPUSHP\tS2P\n+\t\n+\tsub.w\tS0,S0\n+\tsub.w\tS1,S1\n+\t\n+\t; while (a)\n+_top:\tmov.w\tA0,A0\n+\tbne\t_more\n+\tmov.w\tA1,A1\n+\tbeq\t_done\n+_more:\t; if (a & 1)\n+\tbld\t#0,A1L\n+\tbcc\t_nobit\n+\t; r += b\n+\tadd.w\tA3,S1\n+\taddx\tA2L,S0L\n+\taddx\tA2H,S0H\n+_nobit:\n+\t; a >>= 1\n+\tshlr\tA0H\n+\trotxr\tA0L\n+\trotxr\tA1H\n+\trotxr\tA1L\n+\t\n+\t; b <<= 1\n+\tadd.w\tA3,A3\n+\taddx\tA2L,A2L\n+\taddx\tA2H,A2H\n+\tbra \t_top\n+\n+_done:\n+\tmov.w\tS0,A0\t\n+\tmov.w\tS1,A1\n+\tPOPP\tS2P\n+\tPOPP\tS1P\n+\tPOPP\tS0P\n+\trts\n+\n+#else /* __H8300H__ */\n+\n+\t.h8300h\n+\n+\t.global\t___mulsi3\n+___mulsi3:\n+\tsub.l\tA2P,A2P\n+\n+\t; while (a)\n+_top:\tmov.l\tA0P,A0P\n+\tbeq\t_done\n+\n+\t; if (a & 1)\n+\tbld\t#0,A0L\n+\tbcc\t_nobit\n+\n+\t; r += b\n+\tadd.l\tA1P,A2P\n+\n+_nobit:\n+\t; a >>= 1\n+\tshlr.l\tA0P\n+\n+\t; b <<= 1\n+\tshll.l\tA1P\n+\tbra\t_top\n+\n+_done:\n+\tmov.l\tA2P,A0P\n+\trts\n+\n+#endif\n+#endif /* L_mulsi3 */\n\\ No newline at end of file"}]}