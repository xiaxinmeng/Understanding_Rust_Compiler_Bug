{"sha": "4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQwNDgyZjZlYjhhZDllY2MyZTU1MmEzMjg1MTc1YzBjZWNjOWM3Ng==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "2000-04-30T13:37:15Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-04-30T13:37:15Z"}, "message": "Fix memory corruption bug\n\nFrom-SVN: r33549", "tree": {"sha": "74401fe9691dc4567fa3d84e3580a0ddb99d3bf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74401fe9691dc4567fa3d84e3580a0ddb99d3bf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76/comments", "author": null, "committer": null, "parents": [{"sha": "a5c874cb0285942655bb8fcc71f4715c70cfb2ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c874cb0285942655bb8fcc71f4715c70cfb2ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c874cb0285942655bb8fcc71f4715c70cfb2ee"}], "stats": {"total": 64, "additions": 34, "deletions": 30}, "files": [{"sha": "7d27953030b6073ca3a1f8af97d47e71fce1e4ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76", "patch": "@@ -1,3 +1,16 @@\n+2000-04-30  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* simplify-rtx.c (check_value_useless): Delete function.\n+\t(discard_useless_locs): Don't call it; manage N_USELES_VALUES counter\n+\tby hand.\n+\t(cselib_invalidate_regno): Likewise.\n+\t(cselib_invalidate_mem_1): Likewise.\n+\t(references_value_p): Recognize useless values by the fact that they\n+\thave no locations.\n+\t(discard_useless_values): Likewise.\n+\t(cselib_record_set): This may turn a useless value\n+\tinto a useful one.\n+\t\n 2000-04-30  Richard Henderson  <rth@cygnus.com>\n \n \t* config/d30v: New port."}, {"sha": "e3508ef85b6d80189d740dae1b3fd8c4ceb25994", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=4d0482f6eb8ad9ecc2e552a3285175c0cecc9c76", "patch": "@@ -106,7 +106,6 @@ static void unchain_one_value\t\tPARAMS ((cselib_val *));\n static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n static void clear_table\t\t\tPARAMS ((void));\n-static int check_value_useless\t\tPARAMS ((cselib_val *));\n static int discard_useless_locs\t\tPARAMS ((void **, void *));\n static int discard_useless_values\tPARAMS ((void **, void *));\n static void remove_useless_values\tPARAMS ((void));\n@@ -2183,26 +2182,6 @@ get_value_hash (entry)\n   return v->value;\n }\n \n-/* If there are no more locations that hold a value, the value has become\n-   useless.  See whether that is the case for V.  Return 1 if this has\n-   just become useless.  */\n-\n-static int\n-check_value_useless (v)\n-     cselib_val *v;\n-{\n-  if (v->locs != 0)\n-    return 0;\n-\n-  if (v->value == 0)\n-    return 0;\n-\n-  /* This is a marker to indicate that the value will be reclaimed.  */\n-  v->value = 0;\n-  n_useless_values++;\n-  return 1;\n-}\n-\n /* Return true if X contains a VALUE rtx.  If ONLY_USELESS is set, we\n    only return true for values which point to a cselib_val whose value\n    element has been set to zero, which implies the cselib_val will be\n@@ -2218,7 +2197,7 @@ references_value_p (x, only_useless)\n   int i, j;\n \n   if (GET_CODE (x) == VALUE\n-      && (! only_useless || CSELIB_VAL_PTR (x)->value == 0))\n+      && (! only_useless || CSELIB_VAL_PTR (x)->locs == 0))\n     return 1;\n \n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -2245,6 +2224,7 @@ discard_useless_locs (x, info)\n {\n   cselib_val *v = (cselib_val *)*x;\n   struct elt_loc_list **p = &v->locs;\n+  int had_locs = v->locs != 0;\n \n   while (*p)\n     {\n@@ -2254,9 +2234,11 @@ discard_useless_locs (x, info)\n \tp = &(*p)->next;\n     }\n \n-  if (check_value_useless (v))\n-    values_became_useless = 1;\n-\n+  if (had_locs && v->locs == 0)\n+    {\n+      n_useless_values++;\n+      values_became_useless = 1;\n+    }\n   return 1;\n }\n \n@@ -2269,7 +2251,7 @@ discard_useless_values (x, info)\n {\n   cselib_val *v = (cselib_val *)*x;\n \n-  if (v->value == 0)\n+  if (v->locs == 0)\n     {\n       htab_clear_slot (hash_table, x);\n       unchain_one_value (v);\n@@ -2877,8 +2859,8 @@ cselib_invalidate_regno (regno, mode)\n \t\t  break;\n \t\t}\n \t    }\n-\n-\t  check_value_useless (v);\n+\t  if (v->locs == 0)\n+\t    n_useless_values++;\n \t}\n     }\n }\n@@ -2951,6 +2933,7 @@ cselib_invalidate_mem_1 (slot, info)\n   cselib_val *v = (cselib_val *) *slot;\n   rtx mem_rtx = (rtx) info;\n   struct elt_loc_list **p = &v->locs;\n+  int had_locs = v->locs != 0;\n \n   while (*p)\n     {\n@@ -2986,7 +2969,9 @@ cselib_invalidate_mem_1 (slot, info)\n       unchain_one_elt_loc_list (p);\n     }\n \n-  check_value_useless (v);\n+  if (had_locs && v->locs == 0)\n+    n_useless_values++;\n+\n   return 1;\n }\n \n@@ -3045,10 +3030,16 @@ cselib_record_set (dest, src_elt, dest_addr_elt)\n   if (dreg >= 0)\n     {\n       REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n+      if (src_elt->locs == 0)\n+\tn_useless_values--;\n       src_elt->locs = new_elt_loc_list (src_elt->locs, dest);\n     }\n   else if (GET_CODE (dest) == MEM && dest_addr_elt != 0)\n-    add_mem_for_addr (dest_addr_elt, src_elt, dest);\n+    {\n+      if (src_elt->locs == 0)\n+\tn_useless_values--;\n+      add_mem_for_addr (dest_addr_elt, src_elt, dest);\n+    }\n }\n \n /* Describe a single set that is part of an insn.  */"}]}