{"sha": "499193a692efa33c9b2fe3ad8da0f4d5e5fd0e0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk5MTkzYTY5MmVmYTMzYzliMmZlM2FkOGRhMGY0ZDVlNWZkMGUwYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-03T19:22:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-03T19:32:32Z"}, "message": "c++: Defer specialization registration [PR 99170]\n\nThis defers inserting specializations into the specialization table,\nuntil we have completed their streaming.  When streaming a cluster we\nensure that all imports are populated before any of the cluster, so\nthey need no visibility of other specializations.  Further within the\nsame import, we've already partitioned the graph, so no earlier\ncluster can be refering to a specialization in a later cluster.\nInserting them early causes problems when other specializations of the\nsame template are inserted.  (This doesn't fix 99170, but is a\nnecessary change for that PR).\n\nEarlier on, I had less deferred processing, but it has become clearer\nthat deferred worklists are the right way of handling a few things.\nThis patch highlights a fixme, in that we're streaming a key twice,\nand need not do that, but I wanted to get correctness first.  Besides\nthe second streaming will end up being a back reference, which is of\ncourse much cheaper than a by-value stream.\n\n\tPR c++/99170\n\tgcc/cp/\n\t* module.cc (trees_out::decl_value): Stream specialization keys\n\tafter decl.\n\t(trees_in::decl_value): Stream them back and insert after\n\tcompleting the decl.\n\t(trees_out::key_mergeable): Drop some streaming here ...\n\t(trees_in::key_mergeable): ... and here.  Don't insert into\n\tspecialization tables.", "tree": {"sha": "646724dddc6814d966646641b8a6caf69ad9ea6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/646724dddc6814d966646641b8a6caf69ad9ea6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/499193a692efa33c9b2fe3ad8da0f4d5e5fd0e0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/499193a692efa33c9b2fe3ad8da0f4d5e5fd0e0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/499193a692efa33c9b2fe3ad8da0f4d5e5fd0e0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/499193a692efa33c9b2fe3ad8da0f4d5e5fd0e0c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6177870dd2696501e3b8d3930fd5549d4acaeae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6177870dd2696501e3b8d3930fd5549d4acaeae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6177870dd2696501e3b8d3930fd5549d4acaeae"}], "stats": {"total": 94, "additions": 58, "deletions": 36}, "files": [{"sha": "b068acea3bdcbc26bab352218707aea4866aaf75", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/499193a692efa33c9b2fe3ad8da0f4d5e5fd0e0c/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/499193a692efa33c9b2fe3ad8da0f4d5e5fd0e0c/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=499193a692efa33c9b2fe3ad8da0f4d5e5fd0e0c", "patch": "@@ -7808,7 +7808,31 @@ trees_out::decl_value (tree decl, depset *dep)\n     }\n \n   if (!is_key_order ())\n-    tree_node (get_constraints (decl));\n+    {\n+      if (mk & MK_template_mask\n+\t  || mk == MK_partial\n+\t  || mk == MK_friend_spec)\n+\t{\n+\t  if (mk != MK_partial)\n+\t    {\n+\t      // FIXME: We should make use of the merge-key by\n+\t      // exposing it outside of key_mergeable.  But this gets\n+\t      // the job done.\n+\t      auto *entry = reinterpret_cast <spec_entry *> (dep->deps[0]);\n+\n+\t      if (streaming_p ())\n+\t\tu (get_mergeable_specialization_flags (entry->tmpl, decl));\n+\t      tree_node (entry->tmpl);\n+\t      tree_node (entry->args);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree_node (CLASSTYPE_TI_TEMPLATE (TREE_TYPE (inner)));\n+\t      tree_node (CLASSTYPE_TI_ARGS (TREE_TYPE (inner)));\n+\t    }\n+\t}\n+      tree_node (get_constraints (decl));\n+    }\n \n   if (streaming_p ())\n     {\n@@ -8096,7 +8120,22 @@ trees_in::decl_value ()\n \t       || (stub_decl && !tree_node_vals (stub_decl))))\n     goto bail;\n \n-  tree constraints = tree_node ();\n+  spec_entry spec;\n+  unsigned spec_flags = 0;\n+  if (mk & MK_template_mask\n+      || mk == MK_partial\n+      || mk == MK_friend_spec)\n+    {\n+      if (mk == MK_partial)\n+\tspec_flags = 2;\n+      else\n+\tspec_flags = u ();\n+\n+      spec.tmpl = tree_node ();\n+      spec.args = tree_node ();\n+    }\n+  /* Hold constraints on the spec field, for a short while.  */\n+  spec.spec = tree_node ();\n \n   dump (dumper::TREE) && dump (\"Read:%d %C:%N\", tag, TREE_CODE (decl), decl);\n \n@@ -8157,8 +8196,13 @@ trees_in::decl_value ()\n \t    }\n \t}\n \n-      if (constraints)\n-\tset_constraints (decl, constraints);\n+      if (spec.spec)\n+\tset_constraints (decl, spec.spec);\n+      if (mk & MK_template_mask\n+\t  || mk == MK_partial)\n+\t/* Add to specialization tables now that constraints etc are\n+\t   added.  */\n+\tadd_mergeable_specialization (spec.tmpl, spec.args, decl, spec_flags);\n \n       if (TREE_CODE (decl) == INTEGER_CST && !TREE_OVERFLOW (decl))\n \t{\n@@ -8247,6 +8291,15 @@ trees_in::decl_value ()\n       decl = existing;\n     }\n \n+  if (mk == MK_friend_spec)\n+    {\n+      tree e = match_mergeable_specialization (true, &spec);\n+      if (!e)\n+\tadd_mergeable_specialization (spec.tmpl, spec.args, decl, spec_flags);\n+      else if (e != existing)\n+\tset_overrun ();\n+    }\n+\n   if (is_typedef)\n     {\n       /* Insert the type into the array now.  */\n@@ -10415,8 +10468,6 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \n       tree_node (entry->tmpl);\n       tree_node (entry->args);\n-      if (streaming_p ())\n-\tu (get_mergeable_specialization_flags (entry->tmpl, decl));\n       if (mk & MK_tmpl_decl_mask)\n \tif (flag_concepts && TREE_CODE (inner) == VAR_DECL)\n \t  {\n@@ -10504,16 +10555,6 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t\tkey.ret = fndecl_declared_return_type (inner);\n \t    }\n \n-\t  if (mk == MK_friend_spec)\n-\t    {\n-\t      gcc_checking_assert (dep && dep->is_special ());\n-\t      spec_entry *entry = reinterpret_cast <spec_entry *> (dep->deps[0]);\n-\n-\t      tree_node (entry->tmpl);\n-\t      tree_node (entry->args);\n-\t      if (streaming_p ())\n-\t\tu (get_mergeable_specialization_flags (entry->tmpl, decl));\n-\t    }\n \t  break;\n \n \tcase MK_field:\n@@ -10763,7 +10804,6 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n       spec_entry spec;\n       spec.tmpl = tree_node ();\n       spec.args = tree_node ();\n-      unsigned flags = u ();\n \n       DECL_NAME (decl) = DECL_NAME (spec.tmpl);\n       DECL_CONTEXT (decl) = DECL_CONTEXT (spec.tmpl);\n@@ -10800,7 +10840,7 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \tremove_constraints (inner);\n \n       if (!existing)\n-\tadd_mergeable_specialization (spec.tmpl, spec.args, decl, flags);\n+\t; /* We'll add to the table once read.  */\n       else if (mk & MK_tmpl_decl_mask)\n \t{\n \t  /* A declaration specialization.  */\n@@ -10885,8 +10925,6 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t\t  break;\n \t\t}\n \t    }\n-\t  if (!existing)\n-\t    add_mergeable_specialization (key.ret, key.args, decl, 2);\n \t}\n       else\n \tswitch (TREE_CODE (container))\n@@ -11054,22 +11092,6 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t\t  }\n \t      }\n \t  }\n-\n-      if (mk == MK_friend_spec)\n-\t{\n-\t  spec_entry spec;\n-\t  spec.tmpl = tree_node ();\n-\t  spec.args = tree_node ();\n-\t  spec.spec = decl;\n-\t  unsigned flags = u ();\n-\n-\t  tree e = match_mergeable_specialization (true, &spec);\n-\t  if (!e)\n-\t    add_mergeable_specialization (spec.tmpl, spec.args,\n-\t\t\t\t\t  existing ? existing : decl, flags);\n-\t  else if (e != existing)\n-\t    set_overrun ();\n-\t}\n     }\n \n   dump (dumper::MERGE)"}]}