{"sha": "d9983d6c52ac3af3045ebff7d52de5f47979ac07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk5ODNkNmM1MmFjM2FmMzA0NWViZmY3ZDUyZGU1ZjQ3OTc5YWMwNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-09T11:28:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-09T11:28:53Z"}, "message": "(optimize_reg_copy_1): Tighten up code to properly handle the case when...\n\n(optimize_reg_copy_1): Tighten up code to properly handle the case\nwhen SRC or DEST is a multi-word hard register and only some parts of\nthe register are set or used.  Also, avoid updating register status\nfor DEST if we can't do the optimization.\n\nFrom-SVN: r2380", "tree": {"sha": "a59d3caf4d7fbf22dfca68da49523f479dbac707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a59d3caf4d7fbf22dfca68da49523f479dbac707"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9983d6c52ac3af3045ebff7d52de5f47979ac07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9983d6c52ac3af3045ebff7d52de5f47979ac07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9983d6c52ac3af3045ebff7d52de5f47979ac07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9983d6c52ac3af3045ebff7d52de5f47979ac07/comments", "author": null, "committer": null, "parents": [{"sha": "dd2cc343574538ab81669faf74a40ee1130cd514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd2cc343574538ab81669faf74a40ee1130cd514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd2cc343574538ab81669faf74a40ee1130cd514"}], "stats": {"total": 52, "additions": 44, "deletions": 8}, "files": [{"sha": "830f89fd0aaa5bf92f711dd206196f08e6f6b294", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9983d6c52ac3af3045ebff7d52de5f47979ac07/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9983d6c52ac3af3045ebff7d52de5f47979ac07/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=d9983d6c52ac3af3045ebff7d52de5f47979ac07", "patch": "@@ -686,11 +686,16 @@ optimize_reg_copy_1 (insn, dest, src)\n \t      && reg_overlap_mentioned_p (src, XEXP (PATTERN (p), 0))))\n \tbreak;\n \n-      if ((note = find_regno_note (p, REG_DEAD, sregno)) != 0)\n+      /* See if all of SRC dies in P.  This test is slightly more\n+\t conservative than it needs to be. */\n+      if ((note = find_regno_note (p, REG_DEAD, sregno)) != 0\n+\t  && GET_MODE (XEXP (note, 0)) == GET_MODE (src))\n \t{\n \t  int failed = 0;\n \t  int length = 0;\n+\t  int d_length = 0;\n \t  int n_calls = 0;\n+\t  int d_n_calls = 0;\n \n \t  /* We can do the optimization.  Scan forward from INSN again,\n \t     replacing regs as we go.  Set FAILED if a replacement can't\n@@ -702,9 +707,23 @@ optimize_reg_copy_1 (insn, dest, src)\n \t       q != next_real_insn (p);\n \t       q = next_real_insn (q))\n \t    {\n-\t      if (reg_mentioned_p (src, PATTERN (q)))\n+\t      if (reg_overlap_mentioned_p (src, PATTERN (q)))\n \t\t{\n-\t\t  if (validate_replace_rtx (src, dest, q))\n+\t\t  /* If SRC is a hard register, we might miss some\n+\t\t     overlapping registers with validate_replace_rtx,\n+\t\t     so we would have to undo it.  We can't if DEST is\n+\t\t     present in the insn, so fail in that combination\n+\t\t     of cases.  */\n+\t\t  if (sregno < FIRST_PSEUDO_REGISTER\n+\t\t      && reg_mentioned_p (dest, PATTERN (q)))\n+\t\t    failed = 1;\n+\n+\t\t  /* Replace all uses and make sure that the register\n+\t\t     isn't still present.  */\n+\t\t  else if (validate_replace_rtx (src, dest, q)\n+\t\t\t   && (sregno >= FIRST_PSEUDO_REGISTER\n+\t\t\t       || ! reg_overlap_mentioned_p (src,\n+\t\t\t\t\t\t\t     PATTERN (q))))\n \t\t    {\n \t\t      /* We assume that a register is used exactly once per\n \t\t\t insn in the updates below.  If this is not correct,\n@@ -715,26 +734,31 @@ optimize_reg_copy_1 (insn, dest, src)\n \t\t\treg_n_refs[dregno] += loop_depth;\n \t\t    }\n \t\t  else\n-\t\t    failed = 1;\n+\t\t    {\n+\t\t      validate_replace_rtx (dest, src, q);\n+\t\t      failed = 1;\n+\t\t    }\n \t\t}\n \n \t      /* Count the insns and CALL_INSNs passed.  If we passed the\n \t\t death note of DEST, show increased live length.  */\n \t      length++;\n \t      if (dest_death)\n-\t\treg_live_length[dregno]++;\n+\t\td_length++;\n \n \t      if (GET_CODE (q) == CALL_INSN)\n \t\t{\n \t\t  n_calls++;\n \t\t  if (dest_death)\n-\t\t    reg_n_calls_crossed[dregno]++;\n+\t\t    d_n_calls++;\n \t\t}\n \n \t      /* If DEST dies here, remove the death note and save it for\n-\t\t later.  */\n+\t\t later.  Make sure ALL of DEST dies here; again, this is\n+\t\t overly conservative.  */\n \t      if (dest_death == 0\n-\t\t  && (dest_death = find_regno_note (q, REG_DEAD, dregno)) != 0)\n+\t\t  && (dest_death = find_regno_note (q, REG_DEAD, dregno)) != 0\n+\t\t  && GET_MODE (XEXP (dest_death, 0)) == GET_MODE (dest))\n \t\tremove_note (q, dest_death);\n \t    }\n \n@@ -746,6 +770,12 @@ optimize_reg_copy_1 (insn, dest, src)\n \t\t  reg_n_calls_crossed[sregno] -= n_calls;\n \t\t}\n \n+\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  reg_live_length[dregno] += d_length;\n+\t\t  reg_n_calls_crossed[dregno] += d_n_calls;\n+\t\t}\n+\n \t      /* Move death note of SRC from P to INSN.  */\n \t      remove_note (p, note);\n \t      XEXP (note, 1) = REG_NOTES (insn);\n@@ -761,6 +791,12 @@ optimize_reg_copy_1 (insn, dest, src)\n \n \t  return;\n \t}\n+\n+      /* If SRC is a hard register which is set or killed in some other\n+\t way, we can't do this optimization.  */\n+      else if (sregno < FIRST_PSEUDO_REGISTER\n+\t       && dead_or_set_p (p, src))\n+\tbreak;\n     }\n }\n \f"}]}