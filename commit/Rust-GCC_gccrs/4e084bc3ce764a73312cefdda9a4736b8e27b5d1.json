{"sha": "4e084bc3ce764a73312cefdda9a4736b8e27b5d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGUwODRiYzNjZTc2NGE3MzMxMmNlZmRkYTlhNDczNmI4ZTI3YjVkMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:20:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:20:03Z"}, "message": "[69/77] Split scalar-only part out of convert_mode\n\nThis patch splits the final scalar-only part of convert_mode out\ninto its own subroutine and treats the modes as scalar_modes there.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expr.c (convert_mode): Split scalar handling out into...\n\t(convert_mode_scalar): ...this new function.  Treat the modes\n\tas scalar_modes.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251520", "tree": {"sha": "bf50b86e46d95330990a5a016fd6716c3897982d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf50b86e46d95330990a5a016fd6716c3897982d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e084bc3ce764a73312cefdda9a4736b8e27b5d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e084bc3ce764a73312cefdda9a4736b8e27b5d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e084bc3ce764a73312cefdda9a4736b8e27b5d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e084bc3ce764a73312cefdda9a4736b8e27b5d1/comments", "author": null, "committer": null, "parents": [{"sha": "3bd8f4816fe24ef00641cde33dd13155b83db6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd8f4816fe24ef00641cde33dd13155b83db6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd8f4816fe24ef00641cde33dd13155b83db6e1"}], "stats": {"total": 43, "additions": 32, "deletions": 11}, "files": [{"sha": "36cfad066477c7e5c39e4409cc1ff54114cd1829", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e084bc3ce764a73312cefdda9a4736b8e27b5d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e084bc3ce764a73312cefdda9a4736b8e27b5d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e084bc3ce764a73312cefdda9a4736b8e27b5d1", "patch": "@@ -1,3 +1,11 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expr.c (convert_mode): Split scalar handling out into...\n+\t(convert_mode_scalar): ...this new function.  Treat the modes\n+\tas scalar_modes.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "7e67f3dd8cae4ccc6ef0b3f422c058056a7a5445", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e084bc3ce764a73312cefdda9a4736b8e27b5d1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e084bc3ce764a73312cefdda9a4736b8e27b5d1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4e084bc3ce764a73312cefdda9a4736b8e27b5d1", "patch": "@@ -102,6 +102,7 @@ static rtx const_vector_from_tree (tree);\n static rtx const_scalar_mask_from_tree (scalar_int_mode, tree);\n static tree tree_expr_size (const_tree);\n static HOST_WIDE_INT int_expr_size (tree);\n+static void convert_mode_scalar (rtx, rtx, int);\n \n \f\n /* This is run to set up which modes can be used\n@@ -216,17 +217,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n {\n   machine_mode to_mode = GET_MODE (to);\n   machine_mode from_mode = GET_MODE (from);\n-  int to_real = SCALAR_FLOAT_MODE_P (to_mode);\n-  int from_real = SCALAR_FLOAT_MODE_P (from_mode);\n-  enum insn_code code;\n-  rtx libcall;\n-\n-  /* rtx code for making an equivalent value.  */\n-  enum rtx_code equiv_code = (unsignedp < 0 ? UNKNOWN\n-\t\t\t      : (unsignedp ? ZERO_EXTEND : SIGN_EXTEND));\n \n-\n-  gcc_assert (to_real == from_real);\n   gcc_assert (to_mode != BLKmode);\n   gcc_assert (from_mode != BLKmode);\n \n@@ -277,6 +268,28 @@ convert_move (rtx to, rtx from, int unsignedp)\n       return;\n     }\n \n+  convert_mode_scalar (to, from, unsignedp);\n+}\n+\n+/* Like convert_move, but deals only with scalar modes.  */\n+\n+static void\n+convert_mode_scalar (rtx to, rtx from, int unsignedp)\n+{\n+  /* Both modes should be scalar types.  */\n+  scalar_mode from_mode = as_a <scalar_mode> (GET_MODE (from));\n+  scalar_mode to_mode = as_a <scalar_mode> (GET_MODE (to));\n+  bool to_real = SCALAR_FLOAT_MODE_P (to_mode);\n+  bool from_real = SCALAR_FLOAT_MODE_P (from_mode);\n+  enum insn_code code;\n+  rtx libcall;\n+\n+  gcc_assert (to_real == from_real);\n+\n+  /* rtx code for making an equivalent value.  */\n+  enum rtx_code equiv_code = (unsignedp < 0 ? UNKNOWN\n+\t\t\t      : (unsignedp ? ZERO_EXTEND : SIGN_EXTEND));\n+\n   if (to_real)\n     {\n       rtx value;\n@@ -413,7 +426,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n       rtx fill_value;\n       rtx lowfrom;\n       int i;\n-      machine_mode lowpart_mode;\n+      scalar_mode lowpart_mode;\n       int nwords = CEIL (GET_MODE_SIZE (to_mode), UNITS_PER_WORD);\n \n       /* Try converting directly if the insn is supported.  */"}]}