{"sha": "3ef2513a1d3a2497773f9aa37ac1242e88df8652", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VmMjUxM2ExZDNhMjQ5Nzc3M2Y5YWEzN2FjMTI0MmU4OGRmODY1Mg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-03-21T14:37:03Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-03-21T14:37:03Z"}, "message": "re PR libfortran/32972 (performance of pack/unpack)\n\n2008-03-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32972\n\t* Makefile.am:  Add new variable, i_pack_c, containing\n\tpack_i1.c, pack_i2.c, pack_i4.c, pack_i8.c, pack_i16.c,\n\tpack_r4.c, pack_r8.c, pack_r10.c, pack_r16.c, pack_c4.c,\n\tpack_c8.c, pack_c10.c, pack_c16.c.\n\tAdd m4/pack.m4 to m4_files.\n\tAdd i_pack_c to gfor_built_src.\n\tAdd rule to generate i_pack_c from m4/pack.m4.\n\t* Makefile.in:  Regenerated.\n\t* libgfortran.h: Add prototypes for pack_i1, pack_i2, pack_i4,\n\tpack_i8, pack_i16, pack_r4, pack_r8, pack_c4, pack_c8,\n\tpack_c10, pack_c16.\n\t* intrinsics/pack_generic.c:  Add calls to specific\n\tpack functions.\n\t* m4/pack.m4:  New file.\n\t* generated/pack_i1.c:  New file.\n\t* generated/pack_i2.c:  New file.\n\t* generated/pack_i4.c:  New file.\n\t* generated/pack_i8.c:  New file.\n\t* generated/pack_i16.c:  New file.\n\t* generated/pack_r4.c:  New file.\n\t* generated/pack_r8.c:  New file.\n\t* generated/pack_r10.c:  New file.\n\t* generated/pack_r16.c:  New file.\n\t* generated/pack_c4.c:  New file.\n\t* generated/pack_c8.c:  New file.\n\t* generated/pack_c10.c:  New file.\n\t* generated/pack_c16.c:  New file.\n\n2008-03-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32972\n\t* internal_pack_1.f90:  New test case.\n\t* internal_pack_2.f90:  New test case.\n\t* internal_pack_3.f90:  New test case.\n\nFrom-SVN: r133427", "tree": {"sha": "04bf31b498d7e26a396dabb53adec7b17a4a8ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04bf31b498d7e26a396dabb53adec7b17a4a8ba4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ef2513a1d3a2497773f9aa37ac1242e88df8652", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef2513a1d3a2497773f9aa37ac1242e88df8652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ef2513a1d3a2497773f9aa37ac1242e88df8652", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef2513a1d3a2497773f9aa37ac1242e88df8652/comments", "author": null, "committer": null, "parents": [{"sha": "f4351641f0c9a8d7d0962da084bb9127ce41bef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4351641f0c9a8d7d0962da084bb9127ce41bef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4351641f0c9a8d7d0962da084bb9127ce41bef8"}], "stats": {"total": 4830, "additions": 4812, "deletions": 18}, "files": [{"sha": "ad3e1abf2f4a877c43a2489d989566a5552705ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -1,3 +1,10 @@\n+2008-03-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32972\n+\t* internal_pack_1.f90:  New test case.\n+\t* internal_pack_2.f90:  New test case.\n+\t* internal_pack_3.f90:  New test case.\n+\n 2008-03-21  Olivier Hainque  <hainque@adacore.com>\n \n \t* gnat.dg/empty_vector_length.adb: New testcase."}, {"sha": "580d776e58f6cad1d5e936fac6e8d3b8682eaa1c", "filename": "gcc/testsuite/gfortran.dg/intrinsic_pack_1.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_1.f90?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+! Take the pack intrinsic through its paces, with all types that are\n+! normally accessible.\n+program main\n+  implicit none\n+  integer :: i\n+  real(kind=4), dimension(3,3) :: r4\n+  real(kind=4), dimension(9) :: vr4\n+  real(kind=4), dimension(9) :: rr4\n+  real(kind=8), dimension(3,3) :: r8\n+  real(kind=8), dimension(9) :: vr8\n+  real(kind=8), dimension(9) :: rr8\n+  integer(kind=1), dimension(3,3) :: i1\n+  integer(kind=1), dimension(9) :: vi1\n+  integer(kind=1), dimension(9) :: ri1\n+  integer(kind=2), dimension(3,3) :: i2\n+  integer(kind=2), dimension(9) :: vi2\n+  integer(kind=2), dimension(9) :: ri2\n+  integer(kind=4), dimension(3,3) :: i4\n+  integer(kind=4), dimension(9) :: vi4\n+  integer(kind=4), dimension(9) :: ri4\n+  integer(kind=8), dimension(3,3) :: i8\n+  integer(kind=8), dimension(9) :: vi8\n+  integer(kind=8), dimension(9) :: ri8\n+\n+  vr4 = (/(i+10,i=1,9)/)\n+  r4 = reshape((/1.0_4, -3.0_4, 2.1_4, -4.21_4, 1.2_4, 0.98_4, -1.2_4, &\n+  &              -7.1_4, -9.9_4, 0.3_4 /), shape(r4))\n+  rr4 = pack(r4,r4>0,vr4)\n+  if (any(rr4 /= (/ 1.0_4, 2.1_4, 1.2_4, 0.98_4,  15._4, 16._4, 17._4, &\n+  &                  18._4, 19._4 /))) call abort\n+\n+  vr8 = (/(i+10,i=1,9)/)\n+  r8 = reshape((/1.0_8, -3.0_8, 2.1_8, -4.21_8, 1.2_8, 0.98_8, -1.2_8, &\n+  &              -7.1_8, -9.9_8, 0.3_8 /), shape(r8))\n+  rr8 = pack(r8,r8>0,vr8)\n+  if (any(rr8 /= (/ 1.0_8, 2.1_8, 1.2_8, 0.98_8,  15._8, 16._8, 17._8, &\n+  &                  18._8, 19._8 /))) call abort\n+\n+  vi1 = (/(i+10,i=1,9)/)\n+  i1 = reshape((/1_1, -1_1, 2_1, -2_1, 3_1, -3_1, 4_1, -4_1, 5_1/), shape(i1))\n+  ri1 = pack(i1,i1>0,vi1)\n+  if (any(ri1 /= (/1_1, 2_1, 3_1, 4_1, 5_1, 16_1, 17_1, 18_1, 19_1/))) &\n+       & call abort\n+\n+  vi2 = (/(i+10,i=1,9)/)\n+  i2 = reshape((/1_2, -1_2, 2_2, -2_2, 3_2, -3_2, 4_2, -4_2, 5_2/), shape(i2))\n+  ri2 = pack(i2,i2>0,vi2)\n+  if (any(ri2 /= (/1_2, 2_2, 3_2, 4_2, 5_2, 16_2, 17_2, 18_2, 19_2/))) &\n+       & call abort\n+\n+  vi4 = (/(i+10,i=1,9)/)\n+  i4 = reshape((/1_4, -1_4, 2_4, -2_4, 3_4, -3_4, 4_4, -4_4, 5_4/), shape(i4))\n+  ri4 = pack(i4,i4>0,vi4)\n+  if (any(ri4 /= (/1_4, 2_4, 3_4, 4_4, 5_4, 16_4, 17_4, 18_4, 19_4/))) &\n+       & call abort\n+\n+  vi8 = (/(i+10,i=1,9)/)\n+  i8 = reshape((/1_8, -1_8, 2_8, -2_8, 3_8, -3_8, 4_8, -4_8, 5_8/), shape(i8))\n+  ri8 = pack(i8,i8>0,vi8)\n+  if (any(ri8 /= (/1_8, 2_8, 3_8, 4_8, 5_8, 16_8, 17_8, 18_8, 19_8/))) &\n+       & call abort\n+\n+\n+end program main"}, {"sha": "aba93d232cb2ed2c516860e205965a600bb09716", "filename": "gcc/testsuite/gfortran.dg/intrinsic_pack_2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_2.f90?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_real }\n+! Take the pack intrinsic through its paces, with all types that are\n+! normally accessible.\n+program main\n+  implicit none\n+  integer,parameter :: k = selected_real_kind (precision (0.0_8) + 1)\n+  integer :: i\n+  real(kind=k), dimension(3,3) :: rk\n+  real(kind=k), dimension(9) :: vrk\n+  real(kind=k), dimension(9) :: rrk\n+\n+  vrk = (/(i+10,i=1,9)/)\n+  rk = reshape((/1.0_k, -3.0_k, 2.1_k, -4.21_k, 1.2_k, 0.98_k, -1.2_k, &\n+  &              -7.1_k, -9.9_k, 0.3_k /), shape(rk))\n+  rrk = pack(rk,rk>0,vrk)\n+  if (any(rrk /= (/ 1.0_k, 2.1_k, 1.2_k, 0.98_k,  15._k, 16._k, 17._k, &\n+  &                  18._k, 19._k /))) call abort\n+\n+end program main"}, {"sha": "d559e911207ee88a3c897274be97b6c5598bff97", "filename": "gcc/testsuite/gfortran.dg/intrinsic_pack_3.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_3.f90?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_int }\n+! Take the pack intrinsic through its paces, with all types that are\n+! normally accessible.\n+program main\n+  implicit none\n+  integer,parameter :: k = selected_int_kind (range (0_8) + 1)\n+  integer :: i\n+  integer(kind=k), dimension(3,3) :: ik\n+  integer(kind=k), dimension(9) :: vik\n+  integer(kind=k), dimension(9) :: rik\n+\n+  vik = (/(i+10,i=1,9)/)\n+  ik = reshape((/1_k, -1_k, 2_k, -2_k, 3_k, -3_k, 4_k, -4_k, 5_k/), shape(ik))\n+  rik = pack(ik,ik>0,vik)\n+  if (any(rik /= (/1_k, 2_k, 3_k, 4_k, 5_k, 16_k, 17_k, 18_k, 19_k/))) &\n+       & call abort\n+\n+\n+end program main"}, {"sha": "b2efca9b9f6b51ddc4a52b60068ee9419b4654ca", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -1,3 +1,34 @@\n+2008-03-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32972\n+\t* Makefile.am:  Add new variable, i_pack_c, containing\n+\tpack_i1.c, pack_i2.c, pack_i4.c, pack_i8.c, pack_i16.c,\n+\tpack_r4.c, pack_r8.c, pack_r10.c, pack_r16.c, pack_c4.c,\n+\tpack_c8.c, pack_c10.c, pack_c16.c.\n+\tAdd m4/pack.m4 to m4_files.\n+\tAdd i_pack_c to gfor_built_src.\n+\tAdd rule to generate i_pack_c from m4/pack.m4.\n+\t* Makefile.in:  Regenerated.\n+\t* libgfortran.h: Add prototypes for pack_i1, pack_i2, pack_i4,\n+\tpack_i8, pack_i16, pack_r4, pack_r8, pack_c4, pack_c8,\n+\tpack_c10, pack_c16.\n+\t* intrinsics/pack_generic.c:  Add calls to specific\n+\tpack functions.\n+\t* m4/pack.m4:  New file.\n+\t* generated/pack_i1.c:  New file.\n+\t* generated/pack_i2.c:  New file.\n+\t* generated/pack_i4.c:  New file.\n+\t* generated/pack_i8.c:  New file.\n+\t* generated/pack_i16.c:  New file.\n+\t* generated/pack_r4.c:  New file.\n+\t* generated/pack_r8.c:  New file.\n+\t* generated/pack_r10.c:  New file.\n+\t* generated/pack_r16.c:  New file.\n+\t* generated/pack_c4.c:  New file.\n+\t* generated/pack_c8.c:  New file.\n+\t* generated/pack_c10.c:  New file.\n+\t* generated/pack_c16.c:  New file.\n+\n 2008-03-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/35627"}, {"sha": "1706c6a29235fba2f663d6e28f39743d3cd3380b", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -476,6 +476,21 @@ $(srcdir)/generated/pow_c8_i16.c \\\n $(srcdir)/generated/pow_c10_i16.c \\\n $(srcdir)/generated/pow_c16_i16.c\n \n+i_pack_c = \\\n+$(srcdir)/generated/pack_i1.c \\\n+$(srcdir)/generated/pack_i2.c \\\n+$(srcdir)/generated/pack_i4.c \\\n+$(srcdir)/generated/pack_i8.c \\\n+$(srcdir)/generated/pack_i16.c \\\n+$(srcdir)/generated/pack_r4.c \\\n+$(srcdir)/generated/pack_r8.c \\\n+$(srcdir)/generated/pack_r10.c \\\n+$(srcdir)/generated/pack_r16.c \\\n+$(srcdir)/generated/pack_c4.c \\\n+$(srcdir)/generated/pack_c8.c \\\n+$(srcdir)/generated/pack_c10.c \\\n+$(srcdir)/generated/pack_c16.c\n+\n m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n@@ -484,15 +499,15 @@ m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/specific.m4 m4/specific2.m4 m4/head.m4 m4/shape.m4 m4/reshape.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n-    m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4\n+    m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4\n \n gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n     $(i_product_c) $(i_sum_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_transpose_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n-    $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) \\\n+    $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) \\\n     selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     kinds.inc c99_protos.inc fpu-target.h\n \n@@ -808,6 +823,9 @@ $(i_set_exponent_c): m4/set_exponent.m4 m4/mtype.m4\n $(i_pow_c): m4/pow.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 pow.m4 > $@\n \n+$(i_pack_c): m4/pack.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 pack.m4 > $@\n+\n $(gfor_built_specific_src): m4/specific.m4 m4/head.m4\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific.m4 > $@\n "}, {"sha": "286338b3bbb6a7889a163447e103b1fa3ead4357", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 147, "deletions": 15, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -363,7 +363,14 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \t$(srcdir)/generated/spacing_r4.c \\\n \t$(srcdir)/generated/spacing_r8.c \\\n \t$(srcdir)/generated/spacing_r10.c \\\n-\t$(srcdir)/generated/spacing_r16.c selected_int_kind.inc \\\n+\t$(srcdir)/generated/spacing_r16.c \\\n+\t$(srcdir)/generated/pack_i1.c $(srcdir)/generated/pack_i2.c \\\n+\t$(srcdir)/generated/pack_i4.c $(srcdir)/generated/pack_i8.c \\\n+\t$(srcdir)/generated/pack_i16.c $(srcdir)/generated/pack_r4.c \\\n+\t$(srcdir)/generated/pack_r8.c $(srcdir)/generated/pack_r10.c \\\n+\t$(srcdir)/generated/pack_r16.c $(srcdir)/generated/pack_c4.c \\\n+\t$(srcdir)/generated/pack_c8.c $(srcdir)/generated/pack_c10.c \\\n+\t$(srcdir)/generated/pack_c16.c selected_int_kind.inc \\\n \tselected_real_kind.inc kinds.h kinds.inc c99_protos.inc \\\n \tfpu-target.h io/close.c io/file_pos.c io/format.c io/inquire.c \\\n \tio/intrinsics.c io/list_read.c io/lock.c io/open.c io/read.c \\\n@@ -633,7 +640,10 @@ am__objects_28 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \\\n \trrspacing_r16.lo\n am__objects_29 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \\\n \tspacing_r16.lo\n-am__objects_30 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n+am__objects_30 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \\\n+\tpack_i16.lo pack_r4.lo pack_r8.lo pack_r10.lo pack_r16.lo \\\n+\tpack_c4.lo pack_c8.lo pack_c10.lo pack_c16.lo\n+am__objects_31 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_5) $(am__objects_6) $(am__objects_7) \\\n \t$(am__objects_8) $(am__objects_9) $(am__objects_10) \\\n \t$(am__objects_11) $(am__objects_12) $(am__objects_13) \\\n@@ -642,11 +652,11 @@ am__objects_30 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_20) $(am__objects_21) $(am__objects_22) \\\n \t$(am__objects_23) $(am__objects_24) $(am__objects_25) \\\n \t$(am__objects_26) $(am__objects_27) $(am__objects_28) \\\n-\t$(am__objects_29)\n-am__objects_31 = close.lo file_pos.lo format.lo inquire.lo \\\n+\t$(am__objects_29) $(am__objects_30)\n+am__objects_32 = close.lo file_pos.lo format.lo inquire.lo \\\n \tintrinsics.lo list_read.lo lock.lo open.lo read.lo \\\n \tsize_from_kind.lo transfer.lo unit.lo unix.lo write.lo\n-am__objects_32 = associated.lo abort.lo access.lo args.lo \\\n+am__objects_33 = associated.lo abort.lo access.lo args.lo \\\n \tc99_functions.lo chdir.lo chmod.lo clock.lo cpu_time.lo \\\n \tcshift0.lo ctime.lo date_and_time.lo dtime.lo env.lo \\\n \teoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo exit.lo \\\n@@ -660,8 +670,8 @@ am__objects_32 = associated.lo abort.lo access.lo args.lo \\\n \tsystem_clock.lo time.lo transpose_generic.lo umask.lo \\\n \tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n \tin_unpack_generic.lo\n-am__objects_33 =\n-am__objects_34 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_34 =\n+am__objects_35 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -685,18 +695,18 @@ am__objects_34 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_35 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_36 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_36 = misc_specifics.lo\n-am__objects_37 = $(am__objects_34) $(am__objects_35) $(am__objects_36) \\\n+am__objects_37 = misc_specifics.lo\n+am__objects_38 = $(am__objects_35) $(am__objects_36) $(am__objects_37) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_38 = $(am__objects_1) $(am__objects_30) $(am__objects_31) \\\n-\t$(am__objects_32) $(am__objects_33) $(am__objects_37)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_38)\n+am__objects_39 = $(am__objects_1) $(am__objects_31) $(am__objects_32) \\\n+\t$(am__objects_33) $(am__objects_34) $(am__objects_38)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_39)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n libgfortranbegin_la_LIBADD =\n@@ -1330,6 +1340,21 @@ $(srcdir)/generated/pow_c8_i16.c \\\n $(srcdir)/generated/pow_c10_i16.c \\\n $(srcdir)/generated/pow_c16_i16.c\n \n+i_pack_c = \\\n+$(srcdir)/generated/pack_i1.c \\\n+$(srcdir)/generated/pack_i2.c \\\n+$(srcdir)/generated/pack_i4.c \\\n+$(srcdir)/generated/pack_i8.c \\\n+$(srcdir)/generated/pack_i16.c \\\n+$(srcdir)/generated/pack_r4.c \\\n+$(srcdir)/generated/pack_r8.c \\\n+$(srcdir)/generated/pack_r10.c \\\n+$(srcdir)/generated/pack_r16.c \\\n+$(srcdir)/generated/pack_c4.c \\\n+$(srcdir)/generated/pack_c8.c \\\n+$(srcdir)/generated/pack_c10.c \\\n+$(srcdir)/generated/pack_c16.c\n+\n m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n@@ -1338,15 +1363,15 @@ m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/specific.m4 m4/specific2.m4 m4/head.m4 m4/shape.m4 m4/reshape.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n-    m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4\n+    m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4\n \n gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n     $(i_product_c) $(i_sum_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_transpose_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n-    $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) \\\n+    $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) \\\n     selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     kinds.inc c99_protos.inc fpu-target.h\n \n@@ -1902,7 +1927,20 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nearest_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nearest_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/open.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_generic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pause.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/perror.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pow_c10_i16.Plo@am__quote@\n@@ -4619,6 +4657,97 @@ spacing_r16.lo: $(srcdir)/generated/spacing_r16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spacing_r16.lo `test -f '$(srcdir)/generated/spacing_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/spacing_r16.c\n \n+pack_i1.lo: $(srcdir)/generated/pack_i1.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_i1.lo -MD -MP -MF \"$(DEPDIR)/pack_i1.Tpo\" -c -o pack_i1.lo `test -f '$(srcdir)/generated/pack_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i1.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_i1.Tpo\" \"$(DEPDIR)/pack_i1.Plo\"; else rm -f \"$(DEPDIR)/pack_i1.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_i1.c' object='pack_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_i1.lo `test -f '$(srcdir)/generated/pack_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i1.c\n+\n+pack_i2.lo: $(srcdir)/generated/pack_i2.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_i2.lo -MD -MP -MF \"$(DEPDIR)/pack_i2.Tpo\" -c -o pack_i2.lo `test -f '$(srcdir)/generated/pack_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i2.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_i2.Tpo\" \"$(DEPDIR)/pack_i2.Plo\"; else rm -f \"$(DEPDIR)/pack_i2.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_i2.c' object='pack_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_i2.lo `test -f '$(srcdir)/generated/pack_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i2.c\n+\n+pack_i4.lo: $(srcdir)/generated/pack_i4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_i4.lo -MD -MP -MF \"$(DEPDIR)/pack_i4.Tpo\" -c -o pack_i4.lo `test -f '$(srcdir)/generated/pack_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_i4.Tpo\" \"$(DEPDIR)/pack_i4.Plo\"; else rm -f \"$(DEPDIR)/pack_i4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_i4.c' object='pack_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_i4.lo `test -f '$(srcdir)/generated/pack_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i4.c\n+\n+pack_i8.lo: $(srcdir)/generated/pack_i8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_i8.lo -MD -MP -MF \"$(DEPDIR)/pack_i8.Tpo\" -c -o pack_i8.lo `test -f '$(srcdir)/generated/pack_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_i8.Tpo\" \"$(DEPDIR)/pack_i8.Plo\"; else rm -f \"$(DEPDIR)/pack_i8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_i8.c' object='pack_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_i8.lo `test -f '$(srcdir)/generated/pack_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i8.c\n+\n+pack_i16.lo: $(srcdir)/generated/pack_i16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_i16.lo -MD -MP -MF \"$(DEPDIR)/pack_i16.Tpo\" -c -o pack_i16.lo `test -f '$(srcdir)/generated/pack_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_i16.Tpo\" \"$(DEPDIR)/pack_i16.Plo\"; else rm -f \"$(DEPDIR)/pack_i16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_i16.c' object='pack_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_i16.lo `test -f '$(srcdir)/generated/pack_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_i16.c\n+\n+pack_r4.lo: $(srcdir)/generated/pack_r4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_r4.lo -MD -MP -MF \"$(DEPDIR)/pack_r4.Tpo\" -c -o pack_r4.lo `test -f '$(srcdir)/generated/pack_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_r4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_r4.Tpo\" \"$(DEPDIR)/pack_r4.Plo\"; else rm -f \"$(DEPDIR)/pack_r4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_r4.c' object='pack_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_r4.lo `test -f '$(srcdir)/generated/pack_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_r4.c\n+\n+pack_r8.lo: $(srcdir)/generated/pack_r8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_r8.lo -MD -MP -MF \"$(DEPDIR)/pack_r8.Tpo\" -c -o pack_r8.lo `test -f '$(srcdir)/generated/pack_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_r8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_r8.Tpo\" \"$(DEPDIR)/pack_r8.Plo\"; else rm -f \"$(DEPDIR)/pack_r8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_r8.c' object='pack_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_r8.lo `test -f '$(srcdir)/generated/pack_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_r8.c\n+\n+pack_r10.lo: $(srcdir)/generated/pack_r10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_r10.lo -MD -MP -MF \"$(DEPDIR)/pack_r10.Tpo\" -c -o pack_r10.lo `test -f '$(srcdir)/generated/pack_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_r10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_r10.Tpo\" \"$(DEPDIR)/pack_r10.Plo\"; else rm -f \"$(DEPDIR)/pack_r10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_r10.c' object='pack_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_r10.lo `test -f '$(srcdir)/generated/pack_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_r10.c\n+\n+pack_r16.lo: $(srcdir)/generated/pack_r16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_r16.lo -MD -MP -MF \"$(DEPDIR)/pack_r16.Tpo\" -c -o pack_r16.lo `test -f '$(srcdir)/generated/pack_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_r16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_r16.Tpo\" \"$(DEPDIR)/pack_r16.Plo\"; else rm -f \"$(DEPDIR)/pack_r16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_r16.c' object='pack_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_r16.lo `test -f '$(srcdir)/generated/pack_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_r16.c\n+\n+pack_c4.lo: $(srcdir)/generated/pack_c4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_c4.lo -MD -MP -MF \"$(DEPDIR)/pack_c4.Tpo\" -c -o pack_c4.lo `test -f '$(srcdir)/generated/pack_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_c4.Tpo\" \"$(DEPDIR)/pack_c4.Plo\"; else rm -f \"$(DEPDIR)/pack_c4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_c4.c' object='pack_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_c4.lo `test -f '$(srcdir)/generated/pack_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c4.c\n+\n+pack_c8.lo: $(srcdir)/generated/pack_c8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_c8.lo -MD -MP -MF \"$(DEPDIR)/pack_c8.Tpo\" -c -o pack_c8.lo `test -f '$(srcdir)/generated/pack_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_c8.Tpo\" \"$(DEPDIR)/pack_c8.Plo\"; else rm -f \"$(DEPDIR)/pack_c8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_c8.c' object='pack_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_c8.lo `test -f '$(srcdir)/generated/pack_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c8.c\n+\n+pack_c10.lo: $(srcdir)/generated/pack_c10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_c10.lo -MD -MP -MF \"$(DEPDIR)/pack_c10.Tpo\" -c -o pack_c10.lo `test -f '$(srcdir)/generated/pack_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_c10.Tpo\" \"$(DEPDIR)/pack_c10.Plo\"; else rm -f \"$(DEPDIR)/pack_c10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_c10.c' object='pack_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_c10.lo `test -f '$(srcdir)/generated/pack_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c10.c\n+\n+pack_c16.lo: $(srcdir)/generated/pack_c16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT pack_c16.lo -MD -MP -MF \"$(DEPDIR)/pack_c16.Tpo\" -c -o pack_c16.lo `test -f '$(srcdir)/generated/pack_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/pack_c16.Tpo\" \"$(DEPDIR)/pack_c16.Plo\"; else rm -f \"$(DEPDIR)/pack_c16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/pack_c16.c' object='pack_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_c16.lo `test -f '$(srcdir)/generated/pack_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c16.c\n+\n close.lo: io/close.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT close.lo -MD -MP -MF \"$(DEPDIR)/close.Tpo\" -c -o close.lo `test -f 'io/close.c' || echo '$(srcdir)/'`io/close.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/close.Tpo\" \"$(DEPDIR)/close.Plo\"; else rm -f \"$(DEPDIR)/close.Tpo\"; exit 1; fi\n@@ -5570,6 +5699,9 @@ fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n @MAINTAINER_MODE_TRUE@$(i_pow_c): m4/pow.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 pow.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_pack_c): m4/pack.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 pack.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(gfor_built_specific_src): m4/specific.m4 m4/head.m4\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific.m4 > $@\n "}, {"sha": "c9a0c58a5b5743bba4d5b2af47696a25cd004961", "filename": "libgfortran/generated/pack_c10.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c10.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_c10 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_COMPLEX_10 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_COMPLEX_10 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_COMPLEX_10) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "2996be2d220db028ff682786a4a9aae40a6586b3", "filename": "libgfortran/generated/pack_c16.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c16.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_c16 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_COMPLEX_16 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_COMPLEX_16 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_COMPLEX_16) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "ee41c0b8cbf0163092bb3de3b440c04d6d9c468a", "filename": "libgfortran/generated/pack_c4.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c4.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_c4 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_COMPLEX_4 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_COMPLEX_4 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_COMPLEX_4) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "a129422e04f732aef5e511f703b5c86a88c5420d", "filename": "libgfortran/generated/pack_c8.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c8.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_c8 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_COMPLEX_8 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_COMPLEX_8 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_COMPLEX_8) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "25d7f569de51b3d4cb6757e38fd2bd07c20c7988", "filename": "libgfortran/generated/pack_i1.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i1.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_i1 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_INTEGER_1 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_INTEGER_1 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "35c64ce8a9e5a3f447f78edf790caf27467f0449", "filename": "libgfortran/generated/pack_i16.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i16.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_i16 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_INTEGER_16 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_INTEGER_16 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "3a42bd38d78d3c5cbd75a26d8fa92dbed94e113d", "filename": "libgfortran/generated/pack_i2.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i2.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_i2 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_INTEGER_2 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_INTEGER_2 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "28e09f6abec215f537cc3b014038ab61e9e6ec63", "filename": "libgfortran/generated/pack_i4.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i4.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_i4 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_INTEGER_4 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_INTEGER_4 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "44fc430782fdfb5623efb6d2d53df208d4dd36a3", "filename": "libgfortran/generated/pack_i8.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i8.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_i8 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_INTEGER_8 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_INTEGER_8 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "72fe254d918acc34df844788563ce613f6bb1926", "filename": "libgfortran/generated/pack_r10.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r10.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_r10 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_REAL_10 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_REAL_10 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_REAL_10) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "0ced53ab017d45fe0f7619060aedba0a595766f3", "filename": "libgfortran/generated/pack_r16.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r16.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_r16 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_REAL_16 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_REAL_16 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_REAL_16) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "17172ed92a802ef878bf709aa10a643296a6b7f1", "filename": "libgfortran/generated/pack_r4.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r4.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_r4 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_REAL_4 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_REAL_4 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_REAL_4) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "9d0fb5b5d78ad2259996370c8e1d90f34261dfe9", "filename": "libgfortran/generated/pack_r8.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fgenerated%2Fpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r8.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,310 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_r8 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_REAL_8 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_REAL_8 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof (GFC_REAL_8) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "77760b463d9ef5dad73b39320be88c3963086d78", "filename": "libgfortran/intrinsics/pack_generic.c", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fintrinsics%2Fpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fintrinsics%2Fpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fpack_generic.c?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -313,7 +313,102 @@ void\n pack (gfc_array_char *ret, const gfc_array_char *array,\n       const gfc_array_l1 *mask, const gfc_array_char *vector)\n {\n-  pack_internal (ret, array, mask, vector, GFC_DESCRIPTOR_SIZE (array));\n+  int type;\n+  index_type size;\n+\n+  type = GFC_DESCRIPTOR_TYPE (array);\n+  size = GFC_DESCRIPTOR_SIZE (array);\n+\n+  switch(type)\n+    {\n+    case GFC_DTYPE_INTEGER:\n+    case GFC_DTYPE_LOGICAL:\n+      switch(size)\n+\t{\n+\tcase sizeof (GFC_INTEGER_1):\n+\t  pack_i1 ((gfc_array_i1 *) ret, (gfc_array_i1 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_i1 *) vector);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_2):\n+\t  pack_i2 ((gfc_array_i2 *) ret, (gfc_array_i2 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_i2 *) vector);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_4):\n+\t  pack_i4 ((gfc_array_i4 *) ret, (gfc_array_i4 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_i4 *) vector);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_8):\n+\t  pack_i8 ((gfc_array_i8 *) ret, (gfc_array_i8 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_i8 *) vector);\n+\t  return;\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+\tcase sizeof (GFC_INTEGER_16):\n+\t  pack_i1 ((gfc_array_i16 *) ret, (gfc_array_i16 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_i16 *) vector);\n+\t  return;\n+#endif\n+\t}\n+    case GFC_DTYPE_REAL:\n+      switch(size)\n+\t{\n+\tcase sizeof (GFC_REAL_4):\n+\t  pack_r4 ((gfc_array_r4 *) ret, (gfc_array_r4 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_r4 *) vector);\n+\t  return;\n+\n+\tcase sizeof (GFC_REAL_8):\n+\t  pack_r8 ((gfc_array_r8 *) ret, (gfc_array_r8 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_r8 *) vector);\n+\t  return;\n+\n+#ifdef HAVE_GFC_REAL_10\n+\tcase sizeof (GFC_REAL_10):\n+\t  pack_r10 ((gfc_array_r10 *) ret, (gfc_array_r10 *) array,\n+\t\t    (gfc_array_l1 *) mask, (gfc_array_r10 *) vector);\n+\t  return;\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+\tcase sizeof (GFC_REAL_16):\n+\t  pack_r16 ((gfc_array_r16 *) ret, (gfc_array_r16 *) array,\n+\t\t    (gfc_array_l1 *) mask, (gfc_array_r16 *) vector);\n+\t  return;\n+#endif\n+\t}\n+    case GFC_DTYPE_COMPLEX:\n+      switch(size)\n+\t{\n+\tcase sizeof (GFC_COMPLEX_4):\n+\t  pack_c4 ((gfc_array_c4 *) ret, (gfc_array_c4 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_c4 *) vector);\n+\t  return;\n+\n+\tcase sizeof (GFC_COMPLEX_8):\n+\t  pack_c8 ((gfc_array_c8 *) ret, (gfc_array_c8 *) array,\n+\t\t   (gfc_array_l1 *) mask, (gfc_array_c8 *) vector);\n+\t  return;\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+\tcase sizeof (GFC_COMPLEX_10):\n+\t  pack_c10 ((gfc_array_c10 *) ret, (gfc_array_c10 *) array,\n+\t\t    (gfc_array_l1 *) mask, (gfc_array_c10 *) vector);\n+\t  return;\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+\tcase sizeof (GFC_REAL_16):\n+\t  pack_c16 ((gfc_array_c16 *) ret, (gfc_array_c16 *) array,\n+\t\t    (gfc_array_l1 *) mask, (gfc_array_c16 *) vector);\n+\t  return;\n+#endif\n+\n+\t}\n+    }\n+  pack_internal (ret, array, mask, vector, size);\n }\n \n extern void pack_char (gfc_array_char *, GFC_INTEGER_4, const gfc_array_char *,"}, {"sha": "a2b023bd1399841d8f5552aefa8c89699a70d25d", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -710,6 +710,70 @@ extern void internal_unpack_c16 (gfc_array_c16 *, const GFC_COMPLEX_16 *);\n internal_proto(internal_unpack_c16);\n #endif\n \n+/* Internal auxiliary functions for the pack intrinsic.  */\n+\n+extern void pack_i1 (gfc_array_i1 *, const gfc_array_i1 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_i1 *);\n+internal_proto(pack_i1);\n+\n+extern void pack_i2 (gfc_array_i2 *, const gfc_array_i2 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_i2 *);\n+internal_proto(pack_i2);\n+\n+extern void pack_i4 (gfc_array_i4 *, const gfc_array_i4 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_i4 *);\n+internal_proto(pack_i4);\n+\n+extern void pack_i8 (gfc_array_i8 *, const gfc_array_i8 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_i8 *);\n+internal_proto(pack_i8);\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+extern void pack_i16 (gfc_array_i16 *, const gfc_array_i16 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_i16 *);\n+internal_proto(pack_i16);\n+#endif\n+\n+extern void pack_r4 (gfc_array_r4 *, const gfc_array_r4 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_r4 *);\n+internal_proto(pack_r4);\n+\n+extern void pack_r8 (gfc_array_r8 *, const gfc_array_r8 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_r8 *);\n+internal_proto(pack_r8);\n+\n+#ifdef HAVE_GFC_REAL_10\n+extern void pack_r10 (gfc_array_r10 *, const gfc_array_r10 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_r10 *);\n+internal_proto(pack_r10);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+extern void pack_r16 (gfc_array_r16 *, const gfc_array_r16 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_r16 *);\n+internal_proto(pack_r16);\n+#endif\n+\n+extern void pack_c4 (gfc_array_c4 *, const gfc_array_c4 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_c4 *);\n+internal_proto(pack_c4);\n+\n+extern void pack_c8 (gfc_array_c8 *, const gfc_array_c8 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_c8 *);\n+internal_proto(pack_c8);\n+\n+#ifdef HAVE_GFC_REAL_10\n+extern void pack_c10 (gfc_array_c10 *, const gfc_array_c10 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_c10 *);\n+internal_proto(pack_c10);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+extern void pack_c16 (gfc_array_c16 *, const gfc_array_c16 *,\n+\t\t     const gfc_array_l1 *, const gfc_array_c16 *);\n+internal_proto(pack_c16);\n+#endif\n+\n /* string_intrinsics.c */\n \n extern int compare_string (GFC_INTEGER_4, const char *,"}, {"sha": "87409a562233dc69559232f980845d0e1d1a8818", "filename": "libgfortran/m4/pack.m4", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fm4%2Fpack.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef2513a1d3a2497773f9aa37ac1242e88df8652/libgfortran%2Fm4%2Fpack.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fpack.m4?ref=3ef2513a1d3a2497773f9aa37ac1242e88df8652", "patch": "@@ -0,0 +1,312 @@\n+`/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>'\n+\n+include(iparm.m4)dnl\n+\n+`#if defined (HAVE_'rtype_name`)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_'rtype_code` ('rtype` *ret, const 'rtype` *array,\n+\t       const gfc_array_l1 *mask, const 'rtype` *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  'rtype_name` *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const 'rtype_name` *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (ret->data == NULL || compile_options.bounds_check)\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  /* We have to count the true elements in MASK.  */\n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it.\n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_1 *m = mptr;\n+\n+\t  total = 0;\n+\t  if (zero_sized)\n+\t    m = NULL;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so probably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      m += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (ret->data == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  ret->dim[0].lbound = 0;\n+\t  ret->dim[0].ubound = total - 1;\n+\t  ret->dim[0].stride = 1;\n+\n+\t  ret->offset = 0;\n+\t  if (total == 0)\n+\t    {\n+\t      /* In this case, nothing remains to be done.  */\n+\t      ret->data = internal_malloc_size (1);\n+\t      return;\n+\t    }\n+\t  else\n+\t    ret->data = internal_malloc_size (sizeof ('rtype_name`) * total);\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = ret->dim[0].stride;\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride;\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+'\n\\ No newline at end of file"}]}