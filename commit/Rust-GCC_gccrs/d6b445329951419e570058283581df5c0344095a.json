{"sha": "d6b445329951419e570058283581df5c0344095a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZiNDQ1MzI5OTUxNDE5ZTU3MDA1ODI4MzU4MWRmNWMwMzQ0MDk1YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-02-08T21:34:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-02-08T21:34:25Z"}, "message": "loop.c (reg_single_usage): New file-scope variable ...\n\n        * loop.c (reg_single_usage): New file-scope variable ...\n        (scan_loop): ... moved out of here.  Always initialize.\n        Test loop_has_call instead of reg_single_usage not zero.\n        Free reg_single_usage after strength reduction.\n        (count_loop_regs_set): Assume single_usage non-zero.\n        (combine_givs_used_by_other): Test reg_single_usage.\n        (load_mems_and_recount_loop_regs_set): Remove reg_single_usage\n        as a parameter.  Assume non-zero.\n\nFrom-SVN: r25098", "tree": {"sha": "7e0ae5b6e8d1979a0e3c710fbda9bacf0c8ffe2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0ae5b6e8d1979a0e3c710fbda9bacf0c8ffe2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6b445329951419e570058283581df5c0344095a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b445329951419e570058283581df5c0344095a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6b445329951419e570058283581df5c0344095a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b445329951419e570058283581df5c0344095a/comments", "author": null, "committer": null, "parents": [{"sha": "5dfa4da1309462fbefced93c213c28a5417eabdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dfa4da1309462fbefced93c213c28a5417eabdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dfa4da1309462fbefced93c213c28a5417eabdb"}], "stats": {"total": 75, "additions": 39, "deletions": 36}, "files": [{"sha": "fa39496866ab218f8234ae19f768a19f450502f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b445329951419e570058283581df5c0344095a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b445329951419e570058283581df5c0344095a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6b445329951419e570058283581df5c0344095a", "patch": "@@ -1,3 +1,14 @@\n+Mon Feb  8 21:31:06 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* loop.c (reg_single_usage): New file-scope variable ...\n+\t(scan_loop): ... moved out of here.  Always initialize.\n+\tTest loop_has_call instead of reg_single_usage not zero.\n+\tFree reg_single_usage after strength reduction.\n+\t(count_loop_regs_set): Assume single_usage non-zero.\n+\t(combine_givs_used_by_other): Test reg_single_usage.\n+\t(load_mems_and_recount_loop_regs_set): Remove reg_single_usage\n+\tas a parameter.  Assume non-zero.\n+\t\n 1999-02-08 23:25 -0500  Zack Weinberg  <zack@midnite.ec.rhno.columbia.edu>\n \n \t* cpplib.c (special_symbol): Rewrite.  Don't copy things"}, {"sha": "88aef058b29a5f655b99445ef5307734758a8b07", "filename": "gcc/loop.c", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b445329951419e570058283581df5c0344095a/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b445329951419e570058283581df5c0344095a/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=d6b445329951419e570058283581df5c0344095a", "patch": "@@ -164,6 +164,11 @@ static varray_type n_times_set;\n \n static varray_type may_not_optimize;\n \n+/* Contains the insn in which a register was used if it was used\n+   exactly once; contains const0_rtx if it was used more than once.  */\n+\n+static varray_type reg_single_usage;\n+\n /* Nonzero means reg N has already been moved out of one loop.\n    This reduces the desire to move it out of another.  */\n \n@@ -336,8 +341,7 @@ static void record_initial PROTO((rtx, rtx));\n static void update_reg_last_use PROTO((rtx, rtx));\n static rtx next_insn_in_loop PROTO((rtx, rtx, rtx, rtx));\n static void load_mems_and_recount_loop_regs_set PROTO((rtx, rtx, rtx,\n-\t\t\t\t\t\t       rtx, varray_type, \n-\t\t\t\t\t\t       int *));\n+\t\t\t\t\t\t       rtx, int *));\n static void load_mems PROTO((rtx, rtx, rtx, rtx));\n static int insert_loop_mem PROTO((rtx *, void *));\n static int replace_loop_mem PROTO((rtx *, void *));\n@@ -655,10 +659,6 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n      since in that case saving an insn makes more difference\n      and more registers are available.  */\n   int threshold;\n-  /* If we have calls, contains the insn in which a register was used\n-     if it was used exactly once; contains const0_rtx if it was used more\n-     than once.  */\n-  varray_type reg_single_usage = 0;\n   /* Nonzero if we are scanning instructions in a sub-loop.  */\n   int loop_depth = 0;\n   int nregs;\n@@ -738,8 +738,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \n   /* Count number of times each reg is set during this loop.\n      Set VARRAY_CHAR (may_not_optimize, I) if it is not safe to move out\n-     the setting of register I.  If this loop has calls, set\n-     VARRAY_RTX (reg_single_usage, I).  */\n+     the setting of register I.  Set VARRAY_RTX (reg_single_usage, I).  */\n   \n   /* Allocate extra space for REGS that might be created by\n      load_mems.  We allocate a little extra slop as well, in the hopes\n@@ -750,9 +749,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n   VARRAY_INT_INIT (set_in_loop, nregs, \"set_in_loop\");\n   VARRAY_INT_INIT (n_times_set, nregs, \"n_times_set\");\n   VARRAY_CHAR_INIT (may_not_optimize, nregs, \"may_not_optimize\");\n-\n-  if (loop_has_call)\n-    VARRAY_RTX_INIT (reg_single_usage, nregs, \"reg_single_usage\");\n+  VARRAY_RTX_INIT (reg_single_usage, nregs, \"reg_single_usage\");\n \n   count_loop_regs_set (loop_top ? loop_top : loop_start, end,\n \t\t       may_not_optimize, reg_single_usage, &insn_count, nregs);\n@@ -901,7 +898,8 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t\t Don't do this if P has a REG_RETVAL note or if we have\n \t\t SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */\n \n-\t      if (reg_single_usage && VARRAY_RTX (reg_single_usage, regno) != 0\n+\t      if (loop_has_call\n+\t\t  && VARRAY_RTX (reg_single_usage, regno) != 0\n \t\t  && VARRAY_RTX (reg_single_usage, regno) != const0_rtx\n \t\t  && REGNO_FIRST_UID (regno) == INSN_UID (p)\n \t\t  && (REGNO_LAST_UID (regno)\n@@ -1156,14 +1154,9 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n       VARRAY_INT (set_in_loop, i) = VARRAY_INT (n_times_set, i);\n \n   /* Now that we've moved some things out of the loop, we might be able to\n-     hoist even more memory references.  There's no need to pass\n-     reg_single_usage this time, since we're done with it.  */\n+     hoist even more memory references.  */\n   load_mems_and_recount_loop_regs_set (scan_start, end, loop_top,\n-\t\t\t\t       loop_start, 0,\n-\t\t\t\t       &insn_count);\n-\n-  /* set_in_loop is still used by invariant_p, so we can't free it now.  */\n-  VARRAY_FREE (reg_single_usage);\n+\t\t\t\t       loop_start, &insn_count);\n \n   if (flag_strength_reduce)\n     {\n@@ -1172,6 +1165,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n \t\t       insn_count, loop_start, end, loop_cont, unroll_p, bct_p);\n     }\n \n+  VARRAY_FREE (reg_single_usage);\n   VARRAY_FREE (set_in_loop);\n   VARRAY_FREE (n_times_set);\n   VARRAY_FREE (may_not_optimize);\n@@ -3496,15 +3490,12 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n \t{\n \t  ++count;\n \n-\t  /* If requested, record registers that have exactly one use.  */\n-\t  if (single_usage)\n-\t    {\n-\t      find_single_use_in_loop (insn, PATTERN (insn), single_usage);\n+\t  /* Record registers that have exactly one use.  */\n+\t  find_single_use_in_loop (insn, PATTERN (insn), single_usage);\n \n-\t      /* Include uses in REG_EQUAL notes.  */\n-\t      if (REG_NOTES (insn))\n-\t\tfind_single_use_in_loop (insn, REG_NOTES (insn), single_usage);\n-\t    }\n+\t  /* Include uses in REG_EQUAL notes.  */\n+\t  if (REG_NOTES (insn))\n+\t    find_single_use_in_loop (insn, REG_NOTES (insn), single_usage);\n \n \t  if (GET_CODE (PATTERN (insn)) == SET\n \t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n@@ -6766,19 +6757,23 @@ cmp_combine_givs_stats (x, y)\n   return d;\n }\n \n-/* If one of these givs is a DEST_REG that was used by the other giv,\n-   this is actually a single use.  Return 0 if this is not\n-   the case, -1 if g1 is the DEST_REG involved, and 1 if it was g2.  */\n+/* If one of these givs is a DEST_REG that was used once by the other giv,\n+   this is actually a single use.  Return 0 if this is not the case,\n+   -1 if g1 is the DEST_REG involved, and 1 if it was g2.  */\n \n static int\n combine_givs_used_by_other (g1, g2)\n      struct induction *g1, *g2;\n {\n   if (g1->giv_type == DEST_REG\n+      && VARRAY_RTX (reg_single_usage, REGNO (g1->dest_reg)) != 0\n+      && VARRAY_RTX (reg_single_usage, REGNO (g1->dest_reg)) != const0_rtx\n       && reg_mentioned_p (g1->dest_reg, PATTERN (g2->insn)))\n     return -1;\n \n   if (g2->giv_type == DEST_REG\n+      && VARRAY_RTX (reg_single_usage, REGNO (g2->dest_reg)) != 0\n+      && VARRAY_RTX (reg_single_usage, REGNO (g2->dest_reg)) != const0_rtx\n       && reg_mentioned_p (g2->dest_reg, PATTERN (g1->insn)))\n     return 1;\n \n@@ -9222,12 +9217,11 @@ insert_loop_mem (mem, data)\n \n static void\n load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n-\t\t\t\t     reg_single_usage, insn_count)\n+\t\t\t\t     insn_count)\n      rtx scan_start;\n      rtx end;\n      rtx loop_top;\n      rtx start;\n-     varray_type reg_single_usage;\n      int *insn_count;\n {\n   int nregs = max_reg_num ();\n@@ -9250,14 +9244,12 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n \t  VARRAY_GROW (set_in_loop, nregs);\n \t  VARRAY_GROW (n_times_set, nregs);\n \t  VARRAY_GROW (may_not_optimize, nregs);\n-\t  if (reg_single_usage)\n-\t    VARRAY_GROW (reg_single_usage, nregs);\n+\t  VARRAY_GROW (reg_single_usage, nregs);\n \t}\n       /* Clear the arrays */\n       bzero ((char *) &set_in_loop->data, nregs * sizeof (int));\n       bzero ((char *) &may_not_optimize->data, nregs * sizeof (char));\n-      if (reg_single_usage)\n-\tbzero ((char *) &reg_single_usage->data, nregs * sizeof (rtx));\n+      bzero ((char *) &reg_single_usage->data, nregs * sizeof (rtx));\n \n       count_loop_regs_set (loop_top ? loop_top : start, end,\n \t\t\t   may_not_optimize, reg_single_usage,"}]}