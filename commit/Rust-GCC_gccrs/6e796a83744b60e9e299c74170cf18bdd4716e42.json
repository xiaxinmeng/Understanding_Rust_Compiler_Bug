{"sha": "6e796a83744b60e9e299c74170cf18bdd4716e42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3OTZhODM3NDRiNjBlOWUyOTljNzQxNzBjZjE4YmRkNDcxNmU0Mg==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2011-10-17T20:18:31Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2011-10-17T20:18:31Z"}, "message": "fold-const.c (simple_operand_p_2): New function.\n\n\t* fold-const.c (simple_operand_p_2): New function.\n\t(fold_truthop): Rename to\n\t(fold_truth_andor_1): function name.\n\tAdditionally remove branching creation for logical and/or.\n\t(fold_truth_andor): Handle branching creation for logical and/or here.\n\nFrom-SVN: r180109", "tree": {"sha": "dec5203f466988b4b7edce44ebcf1a40da0880c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dec5203f466988b4b7edce44ebcf1a40da0880c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e796a83744b60e9e299c74170cf18bdd4716e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e796a83744b60e9e299c74170cf18bdd4716e42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e796a83744b60e9e299c74170cf18bdd4716e42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e796a83744b60e9e299c74170cf18bdd4716e42/comments", "author": null, "committer": null, "parents": [{"sha": "1eca213e3f5ee0be63a7befbde35d2c7e1ad6fb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eca213e3f5ee0be63a7befbde35d2c7e1ad6fb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eca213e3f5ee0be63a7befbde35d2c7e1ad6fb7"}], "stats": {"total": 126, "additions": 105, "deletions": 21}, "files": [{"sha": "98262b9cdaa1f2636c7c66fda16c28828781d5b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e796a83744b60e9e299c74170cf18bdd4716e42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e796a83744b60e9e299c74170cf18bdd4716e42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e796a83744b60e9e299c74170cf18bdd4716e42", "patch": "@@ -1,3 +1,11 @@\n+2011-10-17  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* fold-const.c (simple_operand_p_2): New function.\n+\t(fold_truthop): Rename to\n+\t(fold_truth_andor_1): function name.\n+\tAdditionally remove branching creation for logical and/or.\n+\t(fold_truth_andor): Handle branching creation for logical and/or here.\n+\n 2011-10-17  Andi Kleen  <ak@linux.intel.com>\n \n \t* ggc-page.c (USING_MADVISE): Adjust ifdef to check for"}, {"sha": "dc14576c1ad5baa3f1f9a3b33ffe8d09f6479b45", "filename": "gcc/fold-const.c", "status": "modified", "additions": 97, "deletions": 21, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e796a83744b60e9e299c74170cf18bdd4716e42/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e796a83744b60e9e299c74170cf18bdd4716e42/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6e796a83744b60e9e299c74170cf18bdd4716e42", "patch": "@@ -112,13 +112,13 @@ static tree decode_field_reference (location_t, tree, HOST_WIDE_INT *,\n static int all_ones_mask_p (const_tree, int);\n static tree sign_bit_p (tree, const_tree);\n static int simple_operand_p (const_tree);\n+static bool simple_operand_p_2 (tree);\n static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n static tree range_predecessor (tree);\n static tree range_successor (tree);\n static tree fold_range_test (location_t, enum tree_code, tree, tree, tree);\n static tree fold_cond_expr_with_comparison (location_t, tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n-static tree fold_truthop (location_t, enum tree_code, tree, tree, tree);\n static tree optimize_minmax_comparison (location_t, enum tree_code,\n \t\t\t\t\ttree, tree, tree);\n static tree extract_muldiv (tree, tree, enum tree_code, tree, bool *);\n@@ -3500,7 +3500,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n   return lhs;\n }\n \f\n-/* Subroutine for fold_truthop: decode a field reference.\n+/* Subroutine for fold_truth_andor_1: decode a field reference.\n \n    If EXP is a comparison reference, we return the innermost reference.\n \n@@ -3668,7 +3668,7 @@ sign_bit_p (tree exp, const_tree val)\n   return NULL_TREE;\n }\n \n-/* Subroutine for fold_truthop: determine if an operand is simple enough\n+/* Subroutine for fold_truth_andor_1: determine if an operand is simple enough\n    to be evaluated unconditionally.  */\n \n static int\n@@ -3678,7 +3678,7 @@ simple_operand_p (const_tree exp)\n   STRIP_NOPS (exp);\n \n   return (CONSTANT_CLASS_P (exp)\n-\t  || TREE_CODE (exp) == SSA_NAME\n+  \t  || TREE_CODE (exp) == SSA_NAME\n \t  || (DECL_P (exp)\n \t      && ! TREE_ADDRESSABLE (exp)\n \t      && ! TREE_THIS_VOLATILE (exp)\n@@ -3692,6 +3692,36 @@ simple_operand_p (const_tree exp)\n \t\t registers aren't expensive.  */\n \t      && (! TREE_STATIC (exp) || DECL_REGISTER (exp))));\n }\n+\n+/* Subroutine for fold_truth_andor: determine if an operand is simple enough\n+   to be evaluated unconditionally.\n+   I addition to simple_operand_p, we assume that comparisons and logic-not\n+   operations are simple, if their operands are simple, too.  */\n+\n+static bool\n+simple_operand_p_2 (tree exp)\n+{\n+  enum tree_code code;\n+\n+  /* Strip any conversions that don't change the machine mode.  */\n+  STRIP_NOPS (exp);\n+\n+  code = TREE_CODE (exp);\n+\n+  if (TREE_SIDE_EFFECTS (exp)\n+      || tree_could_trap_p (exp))\n+    return false;\n+\n+  if (TREE_CODE_CLASS (code) == tcc_comparison)\n+    return (simple_operand_p (TREE_OPERAND (exp, 0))\n+\t    && simple_operand_p (TREE_OPERAND (exp, 1)));\n+\n+  if (code == TRUTH_NOT_EXPR)\n+      return simple_operand_p_2 (TREE_OPERAND (exp, 0));\n+\n+  return simple_operand_p (exp);\n+}\n+\n \f\n /* The following functions are subroutines to fold_range_test and allow it to\n    try to change a logical combination of comparisons into a range test.\n@@ -4888,7 +4918,7 @@ fold_range_test (location_t loc, enum tree_code code, tree type,\n   return 0;\n }\n \f\n-/* Subroutine for fold_truthop: C is an INTEGER_CST interpreted as a P\n+/* Subroutine for fold_truth_andor_1: C is an INTEGER_CST interpreted as a P\n    bit value.  Arrange things so the extra bits will be set to zero if and\n    only if C is signed-extended to its full width.  If MASK is nonzero,\n    it is an INTEGER_CST that should be AND'ed with the extra bits.  */\n@@ -5025,8 +5055,8 @@ merge_truthop_with_opposite_arm (location_t loc, tree op, tree cmpop,\n    We return the simplified tree or 0 if no optimization is possible.  */\n \n static tree\n-fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n-\t      tree lhs, tree rhs)\n+fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n+\t\t    tree lhs, tree rhs)\n {\n   /* If this is the \"or\" of two comparisons, we can do something if\n      the comparisons are NE_EXPR.  If this is the \"and\", we can do something\n@@ -5054,8 +5084,6 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n   tree lntype, rntype, result;\n   HOST_WIDE_INT first_bit, end_bit;\n   int volatilep;\n-  tree orig_lhs = lhs, orig_rhs = rhs;\n-  enum tree_code orig_code = code;\n \n   /* Start by getting the comparison codes.  Fail if anything is volatile.\n      If one operand is a BIT_AND_EXPR with the constant one, treat it as if\n@@ -5119,8 +5147,7 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n   /* If the RHS can be evaluated unconditionally and its operands are\n      simple, it wins to evaluate the RHS unconditionally on machines\n      with expensive branches.  In this case, this isn't a comparison\n-     that can be merged.  Avoid doing this if the RHS is a floating-point\n-     comparison since those can trap.  */\n+     that can be merged.  */\n \n   if (BRANCH_COST (optimize_function_for_speed_p (cfun),\n \t\t   false) >= 2\n@@ -5149,13 +5176,6 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n \t\t\t   build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n \t\t\t\t   ll_arg, rl_arg),\n \t\t\t   build_int_cst (TREE_TYPE (ll_arg), 0));\n-\n-      if (LOGICAL_OP_NON_SHORT_CIRCUIT)\n-\t{\n-\t  if (code != orig_code || lhs != orig_lhs || rhs != orig_rhs)\n-\t    return build2_loc (loc, code, truth_type, lhs, rhs);\n-\t  return NULL_TREE;\n-\t}\n     }\n \n   /* See if the comparisons can be merged.  Then get all the parameters for\n@@ -8380,13 +8400,69 @@ fold_truth_andor (location_t loc, enum tree_code code, tree type,\n      lhs is another similar operation, try to merge its rhs with our\n      rhs.  Then try to merge our lhs and rhs.  */\n   if (TREE_CODE (arg0) == code\n-      && 0 != (tem = fold_truthop (loc, code, type,\n-\t\t\t\t   TREE_OPERAND (arg0, 1), arg1)))\n+      && 0 != (tem = fold_truth_andor_1 (loc, code, type,\n+\t\t\t\t\t TREE_OPERAND (arg0, 1), arg1)))\n     return fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0), tem);\n \n-  if ((tem = fold_truthop (loc, code, type, arg0, arg1)) != 0)\n+  if ((tem = fold_truth_andor_1 (loc, code, type, arg0, arg1)) != 0)\n     return tem;\n \n+  if ((BRANCH_COST (optimize_function_for_speed_p (cfun),\n+\t\t    false) >= 2)\n+      && LOGICAL_OP_NON_SHORT_CIRCUIT\n+      && (code == TRUTH_AND_EXPR\n+          || code == TRUTH_ANDIF_EXPR\n+          || code == TRUTH_OR_EXPR\n+          || code == TRUTH_ORIF_EXPR))\n+    {\n+      enum tree_code ncode, icode;\n+\n+      ncode = (code == TRUTH_ANDIF_EXPR || code == TRUTH_AND_EXPR)\n+\t      ? TRUTH_AND_EXPR : TRUTH_OR_EXPR;\n+      icode = ncode == TRUTH_AND_EXPR ? TRUTH_ANDIF_EXPR : TRUTH_ORIF_EXPR;\n+\n+      /* Transform ((A AND-IF B) AND[-IF] C) into (A AND-IF (B AND C)),\n+\t or ((A OR-IF B) OR[-IF] C) into (A OR-IF (B OR C))\n+\t We don't want to pack more than two leafs to a non-IF AND/OR\n+\t expression.\n+\t If tree-code of left-hand operand isn't an AND/OR-IF code and not\n+\t equal to IF-CODE, then we don't want to add right-hand operand.\n+\t If the inner right-hand side of left-hand operand has\n+\t side-effects, or isn't simple, then we can't add to it,\n+\t as otherwise we might destroy if-sequence.  */\n+      if (TREE_CODE (arg0) == icode\n+\t  && simple_operand_p_2 (arg1)\n+\t  /* Needed for sequence points to handle trappings, and\n+\t     side-effects.  */\n+\t  && simple_operand_p_2 (TREE_OPERAND (arg0, 1)))\n+\t{\n+\t  tem = fold_build2_loc (loc, ncode, type, TREE_OPERAND (arg0, 1),\n+\t\t\t\t arg1);\n+\t  return fold_build2_loc (loc, icode, type, TREE_OPERAND (arg0, 0),\n+\t\t\t\t  tem);\n+\t}\n+\t/* Same as abouve but for (A AND[-IF] (B AND-IF C)) -> ((A AND B) AND-IF C),\n+\t   or (A OR[-IF] (B OR-IF C) -> ((A OR B) OR-IF C).  */\n+      else if (TREE_CODE (arg1) == icode\n+\t  && simple_operand_p_2 (arg0)\n+\t  /* Needed for sequence points to handle trappings, and\n+\t     side-effects.  */\n+\t  && simple_operand_p_2 (TREE_OPERAND (arg1, 0)))\n+\t{\n+\t  tem = fold_build2_loc (loc, ncode, type, \n+\t\t\t\t arg0, TREE_OPERAND (arg1, 0));\n+\t  return fold_build2_loc (loc, icode, type, tem,\n+\t\t\t\t  TREE_OPERAND (arg1, 1));\n+\t}\n+      /* Transform (A AND-IF B) into (A AND B), or (A OR-IF B)\n+\t into (A OR B).\n+\t For sequence point consistancy, we need to check for trapping,\n+\t and side-effects.  */\n+      else if (code == icode && simple_operand_p_2 (arg0)\n+               && simple_operand_p_2 (arg1))\n+\treturn fold_build2_loc (loc, ncode, type, arg0, arg1);\n+    }\n+\n   return NULL_TREE;\n }\n "}]}