{"sha": "6a661315c2e9581727c969320d335da82dbd4829", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE2NjEzMTVjMmU5NTgxNzI3Yzk2OTMyMGQzMzVkYTgyZGJkNDgyOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-03-24T12:30:58Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-03-24T12:30:58Z"}, "message": "re PR fortran/31215 (ICE on valid code with gfortran)\n\n2007-03-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31215\n\t* trans-expr.c (gfc_apply_interface_mapping_to_expr): Return\n\tint result that is non-zero if the expression is the function\n\tresult.  Only the characteristics of the result expression\n\tcan be used in a procedure interface, so simplify LEN in situ\n\tusing its character length.\n\n\tPR fortran/31219\n\tPR fortran/31200\n\t* trans-expr.c (gfc_conv_function_call): Do not use\n\tgfc_conv_expr_reference for actual pointer function with formal\n\ttarget because a temporary is created that does not transfer\n\tthe reference correctly.  Do not indirect formal pointer\n\tfunctions since it is the function reference that is needed.\n\n2007-03-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31219\n\t* gfortran.dg/pointer_function_actual_1.f90: New test.\n\n\tPR fortran/31200\n\t* gfortran.dg/pointer_function_actual_2.f90: New test.\n\n\tPR fortran/31215\n\t* gfortran.dg/result_in_spec_1.f90: New test.\n\nFrom-SVN: r123183", "tree": {"sha": "1b826a7d7a962a2c539ee1473fd8adf32a1e60d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b826a7d7a962a2c539ee1473fd8adf32a1e60d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a661315c2e9581727c969320d335da82dbd4829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a661315c2e9581727c969320d335da82dbd4829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a661315c2e9581727c969320d335da82dbd4829", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a661315c2e9581727c969320d335da82dbd4829/comments", "author": null, "committer": null, "parents": [{"sha": "d87008f258866a0748fc92e34158b7039d0b5a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d87008f258866a0748fc92e34158b7039d0b5a70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d87008f258866a0748fc92e34158b7039d0b5a70"}], "stats": {"total": 188, "additions": 184, "deletions": 4}, "files": [{"sha": "ee5faa7421598fdecb85accd2fd02ebf22fd84e8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6a661315c2e9581727c969320d335da82dbd4829", "patch": "@@ -1,3 +1,20 @@\n+2007-03-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31215\n+\t* trans-expr.c (gfc_apply_interface_mapping_to_expr): Return\n+\tint result that is non-zero if the expression is the function\n+\tresult.  Only the characteristics of the result expression\n+\tcan be used in a procedure interface, so simplify LEN in situ\n+\tusing its character length.\n+\n+\tPR fortran/31219\n+\tPR fortran/31200\n+\t* trans-expr.c (gfc_conv_function_call): Do not use\n+\tgfc_conv_expr_reference for actual pointer function with formal\n+\ttarget because a temporary is created that does not transfer\n+\tthe reference correctly.  Do not indirect formal pointer\n+\tfunctions since it is the function reference that is needed.\n+\n 2007-03-24  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* gfortran.h: Edit comments on GFC_STD_*."}, {"sha": "036d55bdd282b29a56faf2097ec431ab84545232", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=6a661315c2e9581727c969320d335da82dbd4829", "patch": "@@ -43,7 +43,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"dependency.h\"\n \n static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr);\n-static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n+static int gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n \t\t\t\t\t\t gfc_expr *);\n \n /* Copy the scalarization loop variables.  */\n@@ -1601,15 +1601,16 @@ gfc_apply_interface_mapping_to_ref (gfc_interface_mapping * mapping,\n    dummy arguments that MAPPING maps to actual arguments.  Replace each such\n    reference with a reference to the associated actual argument.  */\n \n-static void\n+static int\n gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n \t\t\t\t     gfc_expr * expr)\n {\n   gfc_interface_sym_mapping *sym;\n   gfc_actual_arglist *actual;\n+  int seen_result = 0;\n \n   if (!expr)\n-    return;\n+    return 0;\n \n   /* Copying an expression does not copy its length, so do that here.  */\n   if (expr->ts.type == BT_CHARACTER && expr->ts.cl)\n@@ -1631,6 +1632,8 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n   switch (expr->expr_type)\n     {\n     case EXPR_VARIABLE:\n+      if (expr->symtree->n.sym->attr.result)\n+\tseen_result = 1;\n     case EXPR_CONSTANT:\n     case EXPR_NULL:\n     case EXPR_SUBSTRING:\n@@ -1642,6 +1645,21 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n       break;\n \n     case EXPR_FUNCTION:\n+      if (expr->value.function.actual->expr->expr_type == EXPR_VARIABLE\n+\t    && gfc_apply_interface_mapping_to_expr (mapping,\n+\t\t\texpr->value.function.actual->expr)\n+\t    && expr->value.function.esym == NULL\n+\t    && expr->value.function.isym != NULL\n+\t    && expr->value.function.isym->generic_id == GFC_ISYM_LEN)\n+\t{\n+\t  gfc_expr *new_expr;\n+\t  new_expr = gfc_copy_expr (expr->value.function.actual->expr->ts.cl->length);\n+\t  *expr = *new_expr;\n+\t  gfc_free (new_expr);\n+\t  gfc_apply_interface_mapping_to_expr (mapping, expr);\n+\t  break;\n+\t}\n+\n       for (sym = mapping->syms; sym; sym = sym->next)\n \tif (sym->old == expr->value.function.esym)\n \t  expr->value.function.esym = sym->new->n.sym;\n@@ -1655,6 +1673,7 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n       gfc_apply_interface_mapping_to_cons (mapping, expr->value.constructor);\n       break;\n     }\n+  return seen_result;\n }\n \n \n@@ -2087,11 +2106,19 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t/* Argument list functions %VAL, %LOC and %REF are signalled\n \t\t   through arg->name.  */\n \t\tconv_arglist_function (&parmse, arg->expr, arg->name);\n+\t      else if ((e->expr_type == EXPR_FUNCTION)\n+\t\t\t  && e->symtree->n.sym->attr.pointer\n+\t\t\t  && fsym && fsym->attr.target)\n+\t\t{\n+\t\t  gfc_conv_expr (&parmse, e);\n+\t\t  parmse.expr = build_fold_addr_expr (parmse.expr);\n+\t\t}\n \t      else\n \t\t{\n \t\t  gfc_conv_expr_reference (&parmse, e);\n \t\t  if (fsym && fsym->attr.pointer\n-\t\t\t&& e->expr_type != EXPR_NULL)\n+\t\t      && fsym->attr.flavor != FL_PROCEDURE\n+\t\t      && e->expr_type != EXPR_NULL)\n \t\t    {\n \t\t      /* Scalar pointer dummy args require an extra level of\n \t\t\t indirection. The null pointer already contains"}, {"sha": "4b1505e74fb871ae18b7f225b4f6b105ef3429d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a661315c2e9581727c969320d335da82dbd4829", "patch": "@@ -1,3 +1,14 @@\n+2007-03-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31219\n+\t* gfortran.dg/pointer_function_actual_1.f90: New test.\n+\n+\tPR fortran/31200\n+\t* gfortran.dg/pointer_function_actual_2.f90: New test.\n+\n+\tPR fortran/31215\n+\t* gfortran.dg/result_in_spec_1.f90: New test.\n+\n 2007-03-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/30834"}, {"sha": "91c340c3dc8d2926f53091bff201d1d852142682", "filename": "gcc/testsuite/gfortran.dg/pointer_function_actual_1.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_function_actual_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_function_actual_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_function_actual_1.f90?ref=6a661315c2e9581727c969320d335da82dbd4829", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+! Tests the fix for PR31219, in which an ICE would result because\n+! the reference to the pointer function f would be indirected, as\n+! if it were the result that is being passed.\n+!\n+! COntributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+FUNCTION F() RESULT(RES)\n+ INTEGER, POINTER :: RES\n+ ALLOCATE(RES)\n+ RES=2\n+END FUNCTION F\n+\n+SUBROUTINE S1(f,*,*)\n+ INTERFACE\n+  FUNCTION F() RESULT(RES)\n+   INTEGER, POINTER :: RES\n+  END FUNCTION F\n+ END INTERFACE\n+ RETURN F()\n+END SUBROUTINE\n+\n+PROGRAM TEST\n+   INTERFACE\n+    FUNCTION F() RESULT(RES)\n+     INTEGER, POINTER :: RES\n+    END FUNCTION F\n+   END INTERFACE\n+\n+\n+   INTERFACE\n+    SUBROUTINE S1(f,*,*)\n+      INTERFACE\n+       FUNCTION F() RESULT(RES)\n+        INTEGER, POINTER :: RES\n+       END FUNCTION F\n+      END INTERFACE\n+     END SUBROUTINE\n+   END INTERFACE\n+\n+   CALL S1(F,*1,*2)\n+\n+   1 CONTINUE\n+   CALL ABORT()\n+\n+   GOTO 3\n+   2 CONTINUE\n+\n+   3 CONTINUE\n+END\n+"}, {"sha": "11457ffd9a6df392cbc22b9ad38f246ab7d4da0f", "filename": "gcc/testsuite/gfortran.dg/pointer_function_actual_2.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_function_actual_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_function_actual_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_function_actual_2.f90?ref=6a661315c2e9581727c969320d335da82dbd4829", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! Tests the fix for PR31200, in which the target x would\n+! not be associated with p\n+!\n+! COntributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+  REAL,TARGET :: x\n+  CALL s3(f(x))\n+CONTAINS\n+  FUNCTION f(a)\n+    REAL,POINTER :: f\n+    REAL,TARGET :: a\n+    f => a\n+  END FUNCTION\n+  SUBROUTINE s3(targ)\n+    REAL,TARGET :: targ\n+    REAL,POINTER :: p\n+    p => targ\n+    IF (.NOT. ASSOCIATED(p,x)) CALL ABORT()\n+  END SUBROUTINE\n+END\n+"}, {"sha": "bfb5412224b0f583ef54896f47b3d14fc1266c62", "filename": "gcc/testsuite/gfortran.dg/result_in_spec_1.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_in_spec_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a661315c2e9581727c969320d335da82dbd4829/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_in_spec_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_in_spec_1.f90?ref=6a661315c2e9581727c969320d335da82dbd4829", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+! Tests the check for PR31215, in which actual/formal interface \n+! was not being correctly handled for the size of 'r' because\n+! it is a result.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+module test1\n+  implicit none\n+contains\n+  character(f(x)) function test2(x) result(r)\n+    implicit integer (x)\n+    dimension r(len(r)+1)\n+    integer, intent(in) :: x\n+    interface\n+      pure function f(x)\n+        integer, intent(in) :: x\n+        integer f\n+      end function f\n+    end interface\n+    integer i\n+    do i = 1, len(r)\n+      r(:)(i:i) = achar(mod(i,32)+iachar('@'))\n+    end do\n+  end function test2\n+end module test1\n+\n+program test\n+  use test1\n+  implicit none\n+! Original problem\n+  if (len(test2(10)) .ne. 21) call abort ()\n+! Check non-intrinsic calls are OK and check that fix does\n+! not confuse result variables.\n+  if (any (myfunc (test2(1)) .ne. \"ABC\")) call abort ()\n+contains\n+  function myfunc (ch) result (chr)\n+    character(len(ch)) :: chr(2)\n+    character (*) :: ch(:)\n+    if (len (ch) .ne. 3) call abort ()\n+    if (any (ch .ne. \"ABC\")) call abort ()\n+    chr = test2 (1)\n+    if (len(test2(len(chr))) .ne. 7) call abort ()\n+  end function myfunc\n+end program test\n+\n+pure function f(x)\n+  integer, intent(in) :: x\n+  integer f\n+  f = 2*x+1\n+end function f\n+! { dg-final { cleanup-modules \"test1\" } }"}]}