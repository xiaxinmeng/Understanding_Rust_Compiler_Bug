{"sha": "3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk3MWE0ZDIzNWJkODdiYTliY2ZlM2IzYjEwM2NhMTczYjdmMzY0Ng==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-08-09T16:51:15Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-08-09T16:51:15Z"}, "message": "deque.tcc, [...]: Re-indent contents of namespace std, re-wrap comment lines as necessary.\n\n2002-08-09  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* include/bits/deque.tcc, include/bits/list.tcc,\n\tinclude/bits/stl_deque.h, include/bits/stl_iterator_base_funcs.h,\n\tinclude/bits/stl_list.h, include/bits/stl_map.h,\n\tinclude/bits/stl_multimap.h, include/bits/stl_queue.h,\n\tinclude/bits/stl_stack.h, include/bits/stl_vector.h,\n\tinclude/bits/vector.tcc:  Re-indent contents of namespace std,\n\tre-wrap comment lines as necessary.\n\nFrom-SVN: r56165", "tree": {"sha": "b009990cf67b37b3e79e6bb6b4bcbcf800ee80a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b009990cf67b37b3e79e6bb6b4bcbcf800ee80a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/comments", "author": null, "committer": null, "parents": [{"sha": "2043c38e8dcf438b3e3f86c6559feaab84d852ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2043c38e8dcf438b3e3f86c6559feaab84d852ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2043c38e8dcf438b3e3f86c6559feaab84d852ef"}], "stats": {"total": 12424, "additions": 6194, "deletions": 6230}, "files": [{"sha": "e6e02788d984c80932d0d9ad3187a098e54d319c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -1,3 +1,13 @@\n+2002-08-09  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* include/bits/deque.tcc, include/bits/list.tcc,\n+\tinclude/bits/stl_deque.h, include/bits/stl_iterator_base_funcs.h,\n+\tinclude/bits/stl_list.h, include/bits/stl_map.h,\n+\tinclude/bits/stl_multimap.h, include/bits/stl_queue.h,\n+\tinclude/bits/stl_stack.h, include/bits/stl_vector.h,\n+\tinclude/bits/vector.tcc:  Re-indent contents of namespace std,\n+\tre-wrap comment lines as necessary.\n+\n 2002-08-08  Danny Smith  <dannysmith@users.sourceforge.net>\n             Benjamin Kosnik  <bkoz@redhat.com>\n \t"}, {"sha": "a8d43d024c29487d2e5cfce82f83968bb04495ec", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 574, "deletions": 579, "changes": 1153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -61,398 +61,155 @@\n #ifndef __GLIBCPP_INTERNAL_DEQUE_TCC\n #define __GLIBCPP_INTERNAL_DEQUE_TCC\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n { \n-\n-template <typename _Tp, typename _Alloc>\n-  deque<_Tp,_Alloc>&\n-  deque<_Tp,_Alloc>::\n-  operator=(const deque& __x)\n-  {\n-    const size_type __len = size();\n-    if (&__x != this)\n+  template <typename _Tp, typename _Alloc>\n+    deque<_Tp,_Alloc>&\n+    deque<_Tp,_Alloc>::\n+    operator=(const deque& __x)\n     {\n-      if (__len >= __x.size())\n-        erase(copy(__x.begin(), __x.end(), _M_start), _M_finish);\n-      else\n+      const size_type __len = size();\n+      if (&__x != this)\n       {\n-        const_iterator __mid = __x.begin() + difference_type(__len);\n-        copy(__x.begin(), __mid, _M_start);\n-        insert(_M_finish, __mid, __x.end());\n+        if (__len >= __x.size())\n+          erase(copy(__x.begin(), __x.end(), _M_start), _M_finish);\n+        else\n+        {\n+          const_iterator __mid = __x.begin() + difference_type(__len);\n+          copy(__x.begin(), __mid, _M_start);\n+          insert(_M_finish, __mid, __x.end());\n+        }\n       }\n-    }\n-    return *this;\n-  }        \n-\n-template <typename _Tp, typename _Alloc>\n-  typename deque<_Tp,_Alloc>::iterator \n-  deque<_Tp,_Alloc>::\n-  insert(iterator position, const value_type& __x)\n-  {\n-    if (position._M_cur == _M_start._M_cur)\n-    {\n-      push_front(__x);\n-      return _M_start;\n-    }\n-    else if (position._M_cur == _M_finish._M_cur)\n-    {\n-      push_back(__x);\n-      iterator __tmp = _M_finish;\n-      --__tmp;\n-      return __tmp;\n-    }\n-    else\n-      return _M_insert_aux(position, __x);\n-  }\n-\n-template <typename _Tp, typename _Alloc>\n-  typename deque<_Tp,_Alloc>::iterator \n-  deque<_Tp,_Alloc>::\n-  erase(iterator __position)\n-  {\n-    iterator __next = __position;\n-    ++__next;\n-    size_type __index = __position - _M_start;\n-    if (__index < (size() >> 1))\n-    {\n-      copy_backward(_M_start, __position, __next);\n-      pop_front();\n-    }\n-    else\n-    {\n-      copy(__next, _M_finish, __position);\n-      pop_back();\n-    }\n-    return _M_start + __index;\n-  }\n-\n-template <typename _Tp, typename _Alloc>\n-  typename deque<_Tp,_Alloc>::iterator \n-  deque<_Tp,_Alloc>::\n-  erase(iterator __first, iterator __last)\n-  {\n-    if (__first == _M_start && __last == _M_finish)\n-    {\n-      clear();\n-      return _M_finish;\n-    }\n-    else\n+      return *this;\n+    }        \n+  \n+  template <typename _Tp, typename _Alloc>\n+    typename deque<_Tp,_Alloc>::iterator \n+    deque<_Tp,_Alloc>::\n+    insert(iterator position, const value_type& __x)\n     {\n-      difference_type __n = __last - __first;\n-      difference_type __elems_before = __first - _M_start;\n-      if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)\n+      if (position._M_cur == _M_start._M_cur)\n       {\n-        copy_backward(_M_start, __first, __last);\n-        iterator __new_start = _M_start + __n;\n-        _Destroy(_M_start, __new_start);\n-        _M_destroy_nodes(_M_start._M_node, __new_start._M_node);\n-        _M_start = __new_start;\n+        push_front(__x);\n+        return _M_start;\n       }\n-      else\n+      else if (position._M_cur == _M_finish._M_cur)\n       {\n-        copy(__last, _M_finish, __first);\n-        iterator __new_finish = _M_finish - __n;\n-        _Destroy(__new_finish, _M_finish);\n-        _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);\n-        _M_finish = __new_finish;\n+        push_back(__x);\n+        iterator __tmp = _M_finish;\n+        --__tmp;\n+        return __tmp;\n       }\n-      return _M_start + __elems_before;\n-    }\n-  }\n-  \n-template <typename _Tp, typename _Alloc> \n-  void\n-  deque<_Tp,_Alloc>::\n-  clear()\n-  {\n-    for (_Map_pointer __node = _M_start._M_node + 1;\n-         __node < _M_finish._M_node;\n-         ++__node)\n-    {\n-      _Destroy(*__node, *__node + _S_buffer_size());\n-      _M_deallocate_node(*__node);\n-    }\n-  \n-    if (_M_start._M_node != _M_finish._M_node)\n-    {\n-      _Destroy(_M_start._M_cur, _M_start._M_last);\n-      _Destroy(_M_finish._M_first, _M_finish._M_cur);\n-      _M_deallocate_node(_M_finish._M_first);\n-    }\n-    else\n-      _Destroy(_M_start._M_cur, _M_finish._M_cur);\n-  \n-    _M_finish = _M_start;\n-  }\n-  \n-template <typename _Tp, class _Alloc>\n-  template <typename _InputIter>\n-    void\n-    deque<_Tp,_Alloc>\n-    ::_M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n-    {\n-      iterator __cur = begin();\n-      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n-        *__cur = *__first;\n-      if (__first == __last)\n-        erase(__cur, end());\n       else\n-        insert(end(), __first, __last);\n+        return _M_insert_aux(position, __x);\n     }\n   \n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n-  {\n-    if (__pos._M_cur == _M_start._M_cur)\n-    {\n-      iterator __new_start = _M_reserve_elements_at_front(__n);\n-      try\n-        {\n-          uninitialized_fill(__new_start, _M_start, __x);\n-          _M_start = __new_start;\n-        }\n-      catch(...)\n-        {\n-          _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n-          __throw_exception_again;\n-        }\n-    }\n-    else if (__pos._M_cur == _M_finish._M_cur)\n+  template <typename _Tp, typename _Alloc>\n+    typename deque<_Tp,_Alloc>::iterator \n+    deque<_Tp,_Alloc>::\n+    erase(iterator __position)\n     {\n-      iterator __new_finish = _M_reserve_elements_at_back(__n);\n-      try\n-        {\n-          uninitialized_fill(_M_finish, __new_finish, __x);\n-          _M_finish = __new_finish;\n-        }\n-      catch(...)\n-        {\n-          _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);    \n-          __throw_exception_again;\n-        }\n-    }\n-    else \n-      _M_insert_aux(__pos, __n, __x);\n-  }\n-  \n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_fill_initialize(const value_type& __value)\n-  {\n-    _Map_pointer __cur;\n-    try\n+      iterator __next = __position;\n+      ++__next;\n+      size_type __index = __position - _M_start;\n+      if (__index < (size() >> 1))\n       {\n-        for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n-          uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n-        uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);\n+        copy_backward(_M_start, __position, __next);\n+        pop_front();\n       }\n-    catch(...)\n+      else\n       {\n-        _Destroy(_M_start, iterator(*__cur, __cur));\n-        __throw_exception_again;\n+        copy(__next, _M_finish, __position);\n+        pop_back();\n       }\n-  }\n+      return _M_start + __index;\n+    }\n   \n-template <typename _Tp, typename _Alloc>\n-  template <typename _InputIterator>\n-    void\n+  template <typename _Tp, typename _Alloc>\n+    typename deque<_Tp,_Alloc>::iterator \n     deque<_Tp,_Alloc>::\n-    _M_range_initialize(_InputIterator __first, _InputIterator __last,\n-                        input_iterator_tag)\n+    erase(iterator __first, iterator __last)\n     {\n-      _M_initialize_map(0);\n-      try\n+      if (__first == _M_start && __last == _M_finish)\n+      {\n+        clear();\n+        return _M_finish;\n+      }\n+      else\n+      {\n+        difference_type __n = __last - __first;\n+        difference_type __elems_before = __first - _M_start;\n+        if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)\n         {\n-          for ( ; __first != __last; ++__first)\n-            push_back(*__first);\n+          copy_backward(_M_start, __first, __last);\n+          iterator __new_start = _M_start + __n;\n+          _Destroy(_M_start, __new_start);\n+          _M_destroy_nodes(_M_start._M_node, __new_start._M_node);\n+          _M_start = __new_start;\n         }\n-      catch(...)\n+        else\n         {\n-          clear();\n-          __throw_exception_again;\n+          copy(__last, _M_finish, __first);\n+          iterator __new_finish = _M_finish - __n;\n+          _Destroy(__new_finish, _M_finish);\n+          _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);\n+          _M_finish = __new_finish;\n         }\n+        return _M_start + __elems_before;\n+      }\n     }\n-  \n-template <typename _Tp, typename _Alloc>\n-  template <typename _ForwardIterator>\n+    \n+  template <typename _Tp, typename _Alloc> \n     void\n     deque<_Tp,_Alloc>::\n-    _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n-                        forward_iterator_tag)\n+    clear()\n     {\n-      size_type __n = distance(__first, __last);\n-      _M_initialize_map(__n);\n-    \n-      _Map_pointer __cur_node;\n-      try\n-        {\n-          for (__cur_node = _M_start._M_node; \n-               __cur_node < _M_finish._M_node; \n-               ++__cur_node)\n-          {\n-            _ForwardIterator __mid = __first;\n-            advance(__mid, _S_buffer_size());\n-            uninitialized_copy(__first, __mid, *__cur_node);\n-            __first = __mid;\n-          }\n-          uninitialized_copy(__first, __last, _M_finish._M_first);\n-        }\n-      catch(...)\n-        {\n-          _Destroy(_M_start, iterator(*__cur_node, __cur_node));\n-          __throw_exception_again;\n-        }\n-    }\n-  \n-// Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_push_back_aux(const value_type& __t)\n-  {\n-    value_type __t_copy = __t;\n-    _M_reserve_map_at_back();\n-    *(_M_finish._M_node + 1) = _M_allocate_node();\n-    try\n-      {\n-        _Construct(_M_finish._M_cur, __t_copy);\n-        _M_finish._M_set_node(_M_finish._M_node + 1);\n-        _M_finish._M_cur = _M_finish._M_first;\n-      }\n-    catch(...)\n+      for (_Map_pointer __node = _M_start._M_node + 1;\n+           __node < _M_finish._M_node;\n+           ++__node)\n       {\n-        _M_deallocate_node(*(_M_finish._M_node + 1));\n-        __throw_exception_again;\n+        _Destroy(*__node, *__node + _S_buffer_size());\n+        _M_deallocate_node(*__node);\n       }\n-  }\n-  \n-#ifdef _GLIBCPP_DEPRECATED\n-// Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_push_back_aux()\n-  {\n-    _M_reserve_map_at_back();\n-    *(_M_finish._M_node + 1) = _M_allocate_node();\n-    try\n-      {\n-        _Construct(_M_finish._M_cur);\n-        _M_finish._M_set_node(_M_finish._M_node + 1);\n-        _M_finish._M_cur = _M_finish._M_first;\n-      }\n-    catch(...)\n-      {\n-        _M_deallocate_node(*(_M_finish._M_node + 1));\n-        __throw_exception_again;\n-      }\n-  }\n-#endif\n-  \n-// Called only if _M_start._M_cur == _M_start._M_first.\n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_push_front_aux(const value_type& __t)\n-  {\n-    value_type __t_copy = __t;\n-    _M_reserve_map_at_front();\n-    *(_M_start._M_node - 1) = _M_allocate_node();\n-    try\n-      {\n-        _M_start._M_set_node(_M_start._M_node - 1);\n-        _M_start._M_cur = _M_start._M_last - 1;\n-        _Construct(_M_start._M_cur, __t_copy);\n-      }\n-    catch(...)\n-      {\n-        ++_M_start;\n-        _M_deallocate_node(*(_M_start._M_node - 1));\n-        __throw_exception_again;\n-      }\n-  } \n-  \n-#ifdef _GLIBCPP_DEPRECATED\n-// Called only if _M_start._M_cur == _M_start._M_first.\n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_push_front_aux()\n-  {\n-    _M_reserve_map_at_front();\n-    *(_M_start._M_node - 1) = _M_allocate_node();\n-    try\n+    \n+      if (_M_start._M_node != _M_finish._M_node)\n       {\n-        _M_start._M_set_node(_M_start._M_node - 1);\n-        _M_start._M_cur = _M_start._M_last - 1;\n-        _Construct(_M_start._M_cur);\n+        _Destroy(_M_start._M_cur, _M_start._M_last);\n+        _Destroy(_M_finish._M_first, _M_finish._M_cur);\n+        _M_deallocate_node(_M_finish._M_first);\n       }\n-    catch(...)\n+      else\n+        _Destroy(_M_start._M_cur, _M_finish._M_cur);\n+    \n+      _M_finish = _M_start;\n+    }\n+    \n+  template <typename _Tp, class _Alloc>\n+    template <typename _InputIter>\n+      void\n+      deque<_Tp,_Alloc>\n+      ::_M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n       {\n-        ++_M_start;\n-        _M_deallocate_node(*(_M_start._M_node - 1));\n-        __throw_exception_again;\n+        iterator __cur = begin();\n+        for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n+          *__cur = *__first;\n+        if (__first == __last)\n+          erase(__cur, end());\n+        else\n+          insert(end(), __first, __last);\n       }\n-  } \n-#endif\n-  \n-// Called only if _M_finish._M_cur == _M_finish._M_first.\n-template <typename _Tp, typename _Alloc>\n-  void deque<_Tp,_Alloc>::\n-  _M_pop_back_aux()\n-  {\n-    _M_deallocate_node(_M_finish._M_first);\n-    _M_finish._M_set_node(_M_finish._M_node - 1);\n-    _M_finish._M_cur = _M_finish._M_last - 1;\n-    _Destroy(_M_finish._M_cur);\n-  }\n-  \n-// Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that \n-// if the deque has at least one element (a precondition for this member \n-// function), and if _M_start._M_cur == _M_start._M_last, then the deque \n-// must have at least two nodes.\n-template <typename _Tp, typename _Alloc>\n-  void deque<_Tp,_Alloc>::\n-  _M_pop_front_aux()\n-  {\n-    _Destroy(_M_start._M_cur);\n-    _M_deallocate_node(_M_start._M_first);\n-    _M_start._M_set_node(_M_start._M_node + 1);\n-    _M_start._M_cur = _M_start._M_first;\n-  }      \n-  \n-template <typename _Tp, typename _Alloc>\n-  template <typename _InputIterator>\n-    void\n-    deque<_Tp,_Alloc>::\n-    _M_range_insert_aux(iterator __pos,\n-                        _InputIterator __first, _InputIterator __last,\n-                        input_iterator_tag)\n-    {\n-      copy(__first, __last, inserter(*this, __pos));\n-    }\n-  \n-template <typename _Tp, typename _Alloc>\n-  template <typename _ForwardIterator>\n+    \n+  template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n-    _M_range_insert_aux(iterator __pos,\n-                        _ForwardIterator __first, _ForwardIterator __last,\n-                        forward_iterator_tag)\n+    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n     {\n-      size_type __n = distance(__first, __last);\n       if (__pos._M_cur == _M_start._M_cur)\n       {\n         iterator __new_start = _M_reserve_elements_at_front(__n);\n         try\n           {\n-            uninitialized_copy(__first, __last, __new_start);\n+            uninitialized_fill(__new_start, _M_start, __x);\n             _M_start = __new_start;\n           }\n         catch(...)\n@@ -466,197 +223,362 @@ template <typename _Tp, typename _Alloc>\n         iterator __new_finish = _M_reserve_elements_at_back(__n);\n         try\n           {\n-            uninitialized_copy(__first, __last, _M_finish);\n+            uninitialized_fill(_M_finish, __new_finish, __x);\n             _M_finish = __new_finish;\n           }\n         catch(...)\n           {\n-            _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+            _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);    \n             __throw_exception_again;\n           }\n       }\n-      else\n-        _M_insert_aux(__pos, __first, __last, __n);\n-    }\n-  \n-template <typename _Tp, typename _Alloc>\n-  typename deque<_Tp, _Alloc>::iterator\n-  deque<_Tp,_Alloc>::\n-  _M_insert_aux(iterator __pos, const value_type& __x)\n-  {\n-    difference_type __index = __pos - _M_start;\n-    value_type __x_copy = __x; // XXX copy\n-    if (static_cast<size_type>(__index) < size() / 2)\n-    {\n-      push_front(front());\n-      iterator __front1 = _M_start;\n-      ++__front1;\n-      iterator __front2 = __front1;\n-      ++__front2;\n-      __pos = _M_start + __index;\n-      iterator __pos1 = __pos;\n-      ++__pos1;\n-      copy(__front2, __pos1, __front1);\n+      else \n+        _M_insert_aux(__pos, __n, __x);\n     }\n-    else\n+    \n+  template <typename _Tp, typename _Alloc>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_fill_initialize(const value_type& __value)\n     {\n-      push_back(back());\n-      iterator __back1 = _M_finish;\n-      --__back1;\n-      iterator __back2 = __back1;\n-      --__back2;\n-      __pos = _M_start + __index;\n-      copy_backward(__pos, __back2, __back1);\n+      _Map_pointer __cur;\n+      try\n+        {\n+          for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n+            uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n+          uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);\n+        }\n+      catch(...)\n+        {\n+          _Destroy(_M_start, iterator(*__cur, __cur));\n+          __throw_exception_again;\n+        }\n     }\n-    *__pos = __x_copy;\n-    return __pos;\n-  }\n-  \n-#ifdef _GLIBCPP_DEPRECATED\n-// Nothing seems to actually use this.  According to the pattern followed by\n-// the rest of the SGI code, it would be called by the deprecated insert(pos)\n-// function, but that has been replaced.  We'll take our time removing this\n-// anyhow; mark for 3.4.  -pme\n-template <typename _Tp, typename _Alloc>\n-  typename deque<_Tp,_Alloc>::iterator \n-  deque<_Tp,_Alloc>::\n-  _M_insert_aux(iterator __pos)\n-  {\n-    difference_type __index = __pos - _M_start;\n-    if (static_cast<size_type>(__index) < size() / 2)\n+    \n+  template <typename _Tp, typename _Alloc>\n+    template <typename _InputIterator>\n+      void\n+      deque<_Tp,_Alloc>::\n+      _M_range_initialize(_InputIterator __first, _InputIterator __last,\n+                          input_iterator_tag)\n+      {\n+        _M_initialize_map(0);\n+        try\n+          {\n+            for ( ; __first != __last; ++__first)\n+              push_back(*__first);\n+          }\n+        catch(...)\n+          {\n+            clear();\n+            __throw_exception_again;\n+          }\n+      }\n+    \n+  template <typename _Tp, typename _Alloc>\n+    template <typename _ForwardIterator>\n+      void\n+      deque<_Tp,_Alloc>::\n+      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n+                          forward_iterator_tag)\n+      {\n+        size_type __n = distance(__first, __last);\n+        _M_initialize_map(__n);\n+      \n+        _Map_pointer __cur_node;\n+        try\n+          {\n+            for (__cur_node = _M_start._M_node; \n+                 __cur_node < _M_finish._M_node; \n+                 ++__cur_node)\n+            {\n+              _ForwardIterator __mid = __first;\n+              advance(__mid, _S_buffer_size());\n+              uninitialized_copy(__first, __mid, *__cur_node);\n+              __first = __mid;\n+            }\n+            uninitialized_copy(__first, __last, _M_finish._M_first);\n+          }\n+        catch(...)\n+          {\n+            _Destroy(_M_start, iterator(*__cur_node, __cur_node));\n+            __throw_exception_again;\n+          }\n+      }\n+    \n+  // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n+  template <typename _Tp, typename _Alloc>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_push_back_aux(const value_type& __t)\n     {\n-      push_front(front());\n-      iterator __front1 = _M_start;\n-      ++__front1;\n-      iterator __front2 = __front1;\n-      ++__front2;\n-      __pos = _M_start + __index;\n-      iterator __pos1 = __pos;\n-      ++__pos1;\n-      copy(__front2, __pos1, __front1);\n+      value_type __t_copy = __t;\n+      _M_reserve_map_at_back();\n+      *(_M_finish._M_node + 1) = _M_allocate_node();\n+      try\n+        {\n+          _Construct(_M_finish._M_cur, __t_copy);\n+          _M_finish._M_set_node(_M_finish._M_node + 1);\n+          _M_finish._M_cur = _M_finish._M_first;\n+        }\n+      catch(...)\n+        {\n+          _M_deallocate_node(*(_M_finish._M_node + 1));\n+          __throw_exception_again;\n+        }\n     }\n-    else\n+    \n+  #ifdef _GLIBCPP_DEPRECATED\n+  // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n+  template <typename _Tp, typename _Alloc>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_push_back_aux()\n     {\n-      push_back(back());\n-      iterator __back1 = _M_finish;\n-      --__back1;\n-      iterator __back2 = __back1;\n-      --__back2;\n-      __pos = _M_start + __index;\n-      copy_backward(__pos, __back2, __back1);\n+      _M_reserve_map_at_back();\n+      *(_M_finish._M_node + 1) = _M_allocate_node();\n+      try\n+        {\n+          _Construct(_M_finish._M_cur);\n+          _M_finish._M_set_node(_M_finish._M_node + 1);\n+          _M_finish._M_cur = _M_finish._M_first;\n+        }\n+      catch(...)\n+        {\n+          _M_deallocate_node(*(_M_finish._M_node + 1));\n+          __throw_exception_again;\n+        }\n     }\n-    *__pos = value_type();\n-    return __pos;\n-  }\n-#endif\n-  \n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)\n-  {\n-    const difference_type __elems_before = __pos - _M_start;\n-    size_type __length = this->size();\n-    value_type __x_copy = __x;\n-    if (__elems_before < difference_type(__length / 2))\n+  #endif\n+    \n+  // Called only if _M_start._M_cur == _M_start._M_first.\n+  template <typename _Tp, typename _Alloc>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_push_front_aux(const value_type& __t)\n     {\n-      iterator __new_start = _M_reserve_elements_at_front(__n);\n-      iterator __old_start = _M_start;\n-      __pos = _M_start + __elems_before;\n+      value_type __t_copy = __t;\n+      _M_reserve_map_at_front();\n+      *(_M_start._M_node - 1) = _M_allocate_node();\n       try\n         {\n-          if (__elems_before >= difference_type(__n))\n-          {\n-            iterator __start_n = _M_start + difference_type(__n);\n-            uninitialized_copy(_M_start, __start_n, __new_start);\n-            _M_start = __new_start;\n-            copy(__start_n, __pos, __old_start);\n-            fill(__pos - difference_type(__n), __pos, __x_copy);\n-          }\n-          else\n-          {\n-            __uninitialized_copy_fill(_M_start, __pos, __new_start, \n-                                      _M_start, __x_copy);\n-            _M_start = __new_start;\n-            fill(__old_start, __pos, __x_copy);\n-          }\n+          _M_start._M_set_node(_M_start._M_node - 1);\n+          _M_start._M_cur = _M_start._M_last - 1;\n+          _Construct(_M_start._M_cur, __t_copy);\n         }\n       catch(...)\n-        { \n-          _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+        {\n+          ++_M_start;\n+          _M_deallocate_node(*(_M_start._M_node - 1));\n           __throw_exception_again;\n         }\n-    }\n-    else\n+    } \n+    \n+  #ifdef _GLIBCPP_DEPRECATED\n+  // Called only if _M_start._M_cur == _M_start._M_first.\n+  template <typename _Tp, typename _Alloc>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_push_front_aux()\n     {\n-      iterator __new_finish = _M_reserve_elements_at_back(__n);\n-      iterator __old_finish = _M_finish;\n-      const difference_type __elems_after = \n-        difference_type(__length) - __elems_before;\n-      __pos = _M_finish - __elems_after;\n+      _M_reserve_map_at_front();\n+      *(_M_start._M_node - 1) = _M_allocate_node();\n       try\n         {\n-          if (__elems_after > difference_type(__n))\n-          {\n-            iterator __finish_n = _M_finish - difference_type(__n);\n-            uninitialized_copy(__finish_n, _M_finish, _M_finish);\n-            _M_finish = __new_finish;\n-            copy_backward(__pos, __finish_n, __old_finish);\n-            fill(__pos, __pos + difference_type(__n), __x_copy);\n-          }\n-          else\n-          {\n-            __uninitialized_fill_copy(_M_finish, __pos + difference_type(__n),\n-                                      __x_copy, __pos, _M_finish);\n-            _M_finish = __new_finish;\n-            fill(__pos, __old_finish, __x_copy);\n-          }\n+          _M_start._M_set_node(_M_start._M_node - 1);\n+          _M_start._M_cur = _M_start._M_last - 1;\n+          _Construct(_M_start._M_cur);\n         }\n       catch(...)\n-        { \n-          _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+        {\n+          ++_M_start;\n+          _M_deallocate_node(*(_M_start._M_node - 1));\n           __throw_exception_again;\n         }\n+    } \n+  #endif\n+    \n+  // Called only if _M_finish._M_cur == _M_finish._M_first.\n+  template <typename _Tp, typename _Alloc>\n+    void deque<_Tp,_Alloc>::\n+    _M_pop_back_aux()\n+    {\n+      _M_deallocate_node(_M_finish._M_first);\n+      _M_finish._M_set_node(_M_finish._M_node - 1);\n+      _M_finish._M_cur = _M_finish._M_last - 1;\n+      _Destroy(_M_finish._M_cur);\n     }\n-  }\n-  \n-template <typename _Tp, typename _Alloc>\n-  template <typename _ForwardIterator>\n+    \n+  // Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that \n+  // if the deque has at least one element (a precondition for this member \n+  // function), and if _M_start._M_cur == _M_start._M_last, then the deque \n+  // must have at least two nodes.\n+  template <typename _Tp, typename _Alloc>\n+    void deque<_Tp,_Alloc>::\n+    _M_pop_front_aux()\n+    {\n+      _Destroy(_M_start._M_cur);\n+      _M_deallocate_node(_M_start._M_first);\n+      _M_start._M_set_node(_M_start._M_node + 1);\n+      _M_start._M_cur = _M_start._M_first;\n+    }      \n+    \n+  template <typename _Tp, typename _Alloc>\n+    template <typename _InputIterator>\n+      void\n+      deque<_Tp,_Alloc>::\n+      _M_range_insert_aux(iterator __pos,\n+                          _InputIterator __first, _InputIterator __last,\n+                          input_iterator_tag)\n+      {\n+        copy(__first, __last, inserter(*this, __pos));\n+      }\n+    \n+  template <typename _Tp, typename _Alloc>\n+    template <typename _ForwardIterator>\n+      void\n+      deque<_Tp,_Alloc>::\n+      _M_range_insert_aux(iterator __pos,\n+                          _ForwardIterator __first, _ForwardIterator __last,\n+                          forward_iterator_tag)\n+      {\n+        size_type __n = distance(__first, __last);\n+        if (__pos._M_cur == _M_start._M_cur)\n+        {\n+          iterator __new_start = _M_reserve_elements_at_front(__n);\n+          try\n+            {\n+              uninitialized_copy(__first, __last, __new_start);\n+              _M_start = __new_start;\n+            }\n+          catch(...)\n+            {\n+              _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+              __throw_exception_again;\n+            }\n+        }\n+        else if (__pos._M_cur == _M_finish._M_cur)\n+        {\n+          iterator __new_finish = _M_reserve_elements_at_back(__n);\n+          try\n+            {\n+              uninitialized_copy(__first, __last, _M_finish);\n+              _M_finish = __new_finish;\n+            }\n+          catch(...)\n+            {\n+              _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+              __throw_exception_again;\n+            }\n+        }\n+        else\n+          _M_insert_aux(__pos, __first, __last, __n);\n+      }\n+    \n+  template <typename _Tp, typename _Alloc>\n+    typename deque<_Tp, _Alloc>::iterator\n+    deque<_Tp,_Alloc>::\n+    _M_insert_aux(iterator __pos, const value_type& __x)\n+    {\n+      difference_type __index = __pos - _M_start;\n+      value_type __x_copy = __x; // XXX copy\n+      if (static_cast<size_type>(__index) < size() / 2)\n+      {\n+        push_front(front());\n+        iterator __front1 = _M_start;\n+        ++__front1;\n+        iterator __front2 = __front1;\n+        ++__front2;\n+        __pos = _M_start + __index;\n+        iterator __pos1 = __pos;\n+        ++__pos1;\n+        copy(__front2, __pos1, __front1);\n+      }\n+      else\n+      {\n+        push_back(back());\n+        iterator __back1 = _M_finish;\n+        --__back1;\n+        iterator __back2 = __back1;\n+        --__back2;\n+        __pos = _M_start + __index;\n+        copy_backward(__pos, __back2, __back1);\n+      }\n+      *__pos = __x_copy;\n+      return __pos;\n+    }\n+    \n+  #ifdef _GLIBCPP_DEPRECATED\n+  // Nothing seems to actually use this.  According to the pattern followed by\n+  // the rest of the SGI code, it would be called by the deprecated insert(pos)\n+  // function, but that has been replaced.  We'll take our time removing this\n+  // anyhow; mark for 3.4.  -pme\n+  template <typename _Tp, typename _Alloc>\n+    typename deque<_Tp,_Alloc>::iterator \n+    deque<_Tp,_Alloc>::\n+    _M_insert_aux(iterator __pos)\n+    {\n+      difference_type __index = __pos - _M_start;\n+      if (static_cast<size_type>(__index) < size() / 2)\n+      {\n+        push_front(front());\n+        iterator __front1 = _M_start;\n+        ++__front1;\n+        iterator __front2 = __front1;\n+        ++__front2;\n+        __pos = _M_start + __index;\n+        iterator __pos1 = __pos;\n+        ++__pos1;\n+        copy(__front2, __pos1, __front1);\n+      }\n+      else\n+      {\n+        push_back(back());\n+        iterator __back1 = _M_finish;\n+        --__back1;\n+        iterator __back2 = __back1;\n+        --__back2;\n+        __pos = _M_start + __index;\n+        copy_backward(__pos, __back2, __back1);\n+      }\n+      *__pos = value_type();\n+      return __pos;\n+    }\n+  #endif\n+    \n+  template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n-    _M_insert_aux(iterator __pos,\n-                  _ForwardIterator __first, _ForwardIterator __last,\n-                  size_type __n)\n+    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)\n     {\n-      const difference_type __elemsbefore = __pos - _M_start;\n-      size_type __length = size();\n-      if (static_cast<size_type>(__elemsbefore) < __length / 2)\n+      const difference_type __elems_before = __pos - _M_start;\n+      size_type __length = this->size();\n+      value_type __x_copy = __x;\n+      if (__elems_before < difference_type(__length / 2))\n       {\n         iterator __new_start = _M_reserve_elements_at_front(__n);\n         iterator __old_start = _M_start;\n-        __pos = _M_start + __elemsbefore;\n+        __pos = _M_start + __elems_before;\n         try\n           {\n-            if (__elemsbefore >= difference_type(__n))\n+            if (__elems_before >= difference_type(__n))\n             {\n-              iterator __start_n = _M_start + difference_type(__n); \n+              iterator __start_n = _M_start + difference_type(__n);\n               uninitialized_copy(_M_start, __start_n, __new_start);\n               _M_start = __new_start;\n               copy(__start_n, __pos, __old_start);\n-              copy(__first, __last, __pos - difference_type(__n));\n+              fill(__pos - difference_type(__n), __pos, __x_copy);\n             }\n             else\n             {\n-              _ForwardIterator __mid = __first;\n-              advance(__mid, difference_type(__n) - __elemsbefore);\n-              __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n-                                        __new_start);\n+              __uninitialized_copy_fill(_M_start, __pos, __new_start, \n+                                        _M_start, __x_copy);\n               _M_start = __new_start;\n-              copy(__mid, __last, __old_start);\n+              fill(__old_start, __pos, __x_copy);\n             }\n           }\n         catch(...)\n-          {\n+          { \n             _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n             __throw_exception_again;\n           }\n@@ -665,119 +587,192 @@ template <typename _Tp, typename _Alloc>\n       {\n         iterator __new_finish = _M_reserve_elements_at_back(__n);\n         iterator __old_finish = _M_finish;\n-        const difference_type __elemsafter = \n-          difference_type(__length) - __elemsbefore;\n-        __pos = _M_finish - __elemsafter;\n+        const difference_type __elems_after = \n+          difference_type(__length) - __elems_before;\n+        __pos = _M_finish - __elems_after;\n         try\n           {\n-            if (__elemsafter > difference_type(__n))\n+            if (__elems_after > difference_type(__n))\n             {\n               iterator __finish_n = _M_finish - difference_type(__n);\n               uninitialized_copy(__finish_n, _M_finish, _M_finish);\n               _M_finish = __new_finish;\n               copy_backward(__pos, __finish_n, __old_finish);\n-              copy(__first, __last, __pos);\n+              fill(__pos, __pos + difference_type(__n), __x_copy);\n             }\n             else\n             {\n-              _ForwardIterator __mid = __first;\n-              advance(__mid, __elemsafter);\n-              __uninitialized_copy_copy(__mid, __last, __pos,\n-                                        _M_finish, _M_finish);\n+              __uninitialized_fill_copy(_M_finish, __pos + difference_type(__n),\n+                                        __x_copy, __pos, _M_finish);\n               _M_finish = __new_finish;\n-              copy(__first, __mid, __pos);\n+              fill(__pos, __old_finish, __x_copy);\n             }\n           }\n         catch(...)\n-          {\n+          { \n             _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n             __throw_exception_again;\n           }\n       }\n     }\n-  \n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_new_elements_at_front(size_type __new_elems)\n-  {\n-    size_type __new_nodes\n-        = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n-    _M_reserve_map_at_front(__new_nodes);\n-    size_type __i;\n-    try\n-      {\n-        for (__i = 1; __i <= __new_nodes; ++__i)\n-          *(_M_start._M_node - __i) = _M_allocate_node();\n-      }\n-    catch(...)\n+    \n+  template <typename _Tp, typename _Alloc>\n+    template <typename _ForwardIterator>\n+      void\n+      deque<_Tp,_Alloc>::\n+      _M_insert_aux(iterator __pos,\n+                    _ForwardIterator __first, _ForwardIterator __last,\n+                    size_type __n)\n       {\n-        for (size_type __j = 1; __j < __i; ++__j)\n-          _M_deallocate_node(*(_M_start._M_node - __j));      \n-        __throw_exception_again;\n+        const difference_type __elemsbefore = __pos - _M_start;\n+        size_type __length = size();\n+        if (static_cast<size_type>(__elemsbefore) < __length / 2)\n+        {\n+          iterator __new_start = _M_reserve_elements_at_front(__n);\n+          iterator __old_start = _M_start;\n+          __pos = _M_start + __elemsbefore;\n+          try\n+            {\n+              if (__elemsbefore >= difference_type(__n))\n+              {\n+                iterator __start_n = _M_start + difference_type(__n); \n+                uninitialized_copy(_M_start, __start_n, __new_start);\n+                _M_start = __new_start;\n+                copy(__start_n, __pos, __old_start);\n+                copy(__first, __last, __pos - difference_type(__n));\n+              }\n+              else\n+              {\n+                _ForwardIterator __mid = __first;\n+                advance(__mid, difference_type(__n) - __elemsbefore);\n+                __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n+                                          __new_start);\n+                _M_start = __new_start;\n+                copy(__mid, __last, __old_start);\n+              }\n+            }\n+          catch(...)\n+            {\n+              _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+              __throw_exception_again;\n+            }\n+        }\n+        else\n+        {\n+          iterator __new_finish = _M_reserve_elements_at_back(__n);\n+          iterator __old_finish = _M_finish;\n+          const difference_type __elemsafter = \n+            difference_type(__length) - __elemsbefore;\n+          __pos = _M_finish - __elemsafter;\n+          try\n+            {\n+              if (__elemsafter > difference_type(__n))\n+              {\n+                iterator __finish_n = _M_finish - difference_type(__n);\n+                uninitialized_copy(__finish_n, _M_finish, _M_finish);\n+                _M_finish = __new_finish;\n+                copy_backward(__pos, __finish_n, __old_finish);\n+                copy(__first, __last, __pos);\n+              }\n+              else\n+              {\n+                _ForwardIterator __mid = __first;\n+                advance(__mid, __elemsafter);\n+                __uninitialized_copy_copy(__mid, __last, __pos,\n+                                          _M_finish, _M_finish);\n+                _M_finish = __new_finish;\n+                copy(__first, __mid, __pos);\n+              }\n+            }\n+          catch(...)\n+            {\n+              _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+              __throw_exception_again;\n+            }\n+        }\n       }\n-  }\n-  \n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_new_elements_at_back(size_type __new_elems)\n-  {\n-    size_type __new_nodes\n-        = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n-    _M_reserve_map_at_back(__new_nodes);\n-    size_type __i;\n-    try\n+    \n+  template <typename _Tp, typename _Alloc>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_new_elements_at_front(size_type __new_elems)\n+    {\n+      size_type __new_nodes\n+          = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n+      _M_reserve_map_at_front(__new_nodes);\n+      size_type __i;\n+      try\n+        {\n+          for (__i = 1; __i <= __new_nodes; ++__i)\n+            *(_M_start._M_node - __i) = _M_allocate_node();\n+        }\n+      catch(...)\n+        {\n+          for (size_type __j = 1; __j < __i; ++__j)\n+            _M_deallocate_node(*(_M_start._M_node - __j));      \n+          __throw_exception_again;\n+        }\n+    }\n+    \n+  template <typename _Tp, typename _Alloc>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_new_elements_at_back(size_type __new_elems)\n+    {\n+      size_type __new_nodes\n+          = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n+      _M_reserve_map_at_back(__new_nodes);\n+      size_type __i;\n+      try\n+        {\n+          for (__i = 1; __i <= __new_nodes; ++__i)\n+            *(_M_finish._M_node + __i) = _M_allocate_node();\n+        }\n+      catch(...)\n+        {\n+          for (size_type __j = 1; __j < __i; ++__j)\n+            _M_deallocate_node(*(_M_finish._M_node + __j));      \n+          __throw_exception_again;\n+        }\n+    }\n+    \n+  template <typename _Tp, typename _Alloc>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)\n+    {\n+      size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;\n+      size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n+    \n+      _Map_pointer __new_nstart;\n+      if (_M_map_size > 2 * __new_num_nodes)\n       {\n-        for (__i = 1; __i <= __new_nodes; ++__i)\n-          *(_M_finish._M_node + __i) = _M_allocate_node();\n+        __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 \n+                         + (__add_at_front ? __nodes_to_add : 0);\n+        if (__new_nstart < _M_start._M_node)\n+          copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n+        else\n+          copy_backward(_M_start._M_node, _M_finish._M_node + 1, \n+                        __new_nstart + __old_num_nodes);\n       }\n-    catch(...)\n+      else\n       {\n-        for (size_type __j = 1; __j < __i; ++__j)\n-          _M_deallocate_node(*(_M_finish._M_node + __j));      \n-        __throw_exception_again;\n-      }\n-  }\n-  \n-template <typename _Tp, typename _Alloc>\n-  void\n-  deque<_Tp,_Alloc>::\n-  _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)\n-  {\n-    size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;\n-    size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n-  \n-    _Map_pointer __new_nstart;\n-    if (_M_map_size > 2 * __new_num_nodes)\n-    {\n-      __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 \n-                       + (__add_at_front ? __nodes_to_add : 0);\n-      if (__new_nstart < _M_start._M_node)\n+        size_type __new_map_size = \n+          _M_map_size + max(_M_map_size, __nodes_to_add) + 2;\n+    \n+        _Map_pointer __new_map = _M_allocate_map(__new_map_size);\n+        __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n+                             + (__add_at_front ? __nodes_to_add : 0);\n         copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n-      else\n-        copy_backward(_M_start._M_node, _M_finish._M_node + 1, \n-                      __new_nstart + __old_num_nodes);\n-    }\n-    else\n-    {\n-      size_type __new_map_size = \n-        _M_map_size + max(_M_map_size, __nodes_to_add) + 2;\n-  \n-      _Map_pointer __new_map = _M_allocate_map(__new_map_size);\n-      __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n-                           + (__add_at_front ? __nodes_to_add : 0);\n-      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n-      _M_deallocate_map(_M_map, _M_map_size);\n-  \n-      _M_map = __new_map;\n-      _M_map_size = __new_map_size;\n+        _M_deallocate_map(_M_map, _M_map_size);\n+    \n+        _M_map = __new_map;\n+        _M_map_size = __new_map_size;\n+      }\n+    \n+      _M_start._M_set_node(__new_nstart);\n+      _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n     }\n-  \n-    _M_start._M_set_node(__new_nstart);\n-    _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n-  }\n-\n } // namespace std \n   \n #endif /* __GLIBCPP_INTERNAL_DEQUE_TCC */"}, {"sha": "898a5020c23bbf03a10f0aa0a04954b9d6ddd6a9", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 235, "deletions": 241, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -61,314 +61,308 @@\n #ifndef __GLIBCPP_INTERNAL_LIST_TCC\n #define __GLIBCPP_INTERNAL_LIST_TCC\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-\n-template<typename _Tp, typename _Alloc>\n-  void\n-  _List_base<_Tp,_Alloc>::\n-  __clear()\n-  {\n-    typedef _List_node<_Tp>  _Node;\n-    _Node* __cur = static_cast<_Node*>(_M_node->_M_next);\n-    while (__cur != _M_node)\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    _List_base<_Tp,_Alloc>::\n+    __clear()\n     {\n-      _Node* __tmp = __cur;\n-      __cur = static_cast<_Node*>(__cur->_M_next);\n-      _Destroy(&__tmp->_M_data);\n-      _M_put_node(__tmp);\n+      typedef _List_node<_Tp>  _Node;\n+      _Node* __cur = static_cast<_Node*>(_M_node->_M_next);\n+      while (__cur != _M_node)\n+      {\n+        _Node* __tmp = __cur;\n+        __cur = static_cast<_Node*>(__cur->_M_next);\n+        _Destroy(&__tmp->_M_data);\n+        _M_put_node(__tmp);\n+      }\n+      _M_node->_M_next = _M_node;\n+      _M_node->_M_prev = _M_node;\n     }\n-    _M_node->_M_next = _M_node;\n-    _M_node->_M_prev = _M_node;\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  typename list<_Tp,_Alloc>::iterator\n-  list<_Tp,_Alloc>::\n-  insert(iterator __position, const value_type& __x)\n-  {\n-    _Node* __tmp = _M_create_node(__x);\n-    __tmp->_M_next = __position._M_node;\n-    __tmp->_M_prev = __position._M_node->_M_prev;\n-    __position._M_node->_M_prev->_M_next = __tmp;\n-    __position._M_node->_M_prev = __tmp;\n-    return __tmp;\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  typename list<_Tp,_Alloc>::iterator\n-  list<_Tp,_Alloc>::\n-  erase(iterator __position)\n-  {\n-    _List_node_base* __next_node = __position._M_node->_M_next;\n-    _List_node_base* __prev_node = __position._M_node->_M_prev;\n-    _Node* __n = static_cast<_Node*>(__position._M_node);\n-    __prev_node->_M_next = __next_node;\n-    __next_node->_M_prev = __prev_node;\n-    _Destroy(&__n->_M_data);\n-    _M_put_node(__n);\n-    return iterator(static_cast<_Node*>(__next_node));\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  void\n-  list<_Tp,_Alloc>::\n-  resize(size_type __new_size, const value_type& __x)\n-  {\n-    iterator __i = begin();\n-    size_type __len = 0;\n-    for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n-      ;\n-    if (__len == __new_size)\n-      erase(__i, end());\n-    else                          // __i == end()\n-      insert(end(), __new_size - __len, __x);\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  list<_Tp,_Alloc>&\n-  list<_Tp,_Alloc>::\n-  operator=(const list& __x)\n-  {\n-    if (this != &__x)\n+  \n+  template<typename _Tp, typename _Alloc>\n+    typename list<_Tp,_Alloc>::iterator\n+    list<_Tp,_Alloc>::\n+    insert(iterator __position, const value_type& __x)\n     {\n-      iterator __first1 = begin();\n-      iterator __last1 = end();\n-      const_iterator __first2 = __x.begin();\n-      const_iterator __last2 = __x.end();\n-      while (__first1 != __last1 && __first2 != __last2)\n-        *__first1++ = *__first2++;\n-      if (__first2 == __last2)\n-        erase(__first1, __last1);\n-      else\n-        insert(__last1, __first2, __last2);\n+      _Node* __tmp = _M_create_node(__x);\n+      __tmp->_M_next = __position._M_node;\n+      __tmp->_M_prev = __position._M_node->_M_prev;\n+      __position._M_node->_M_prev->_M_next = __tmp;\n+      __position._M_node->_M_prev = __tmp;\n+      return __tmp;\n     }\n-    return *this;\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  void\n-  list<_Tp,_Alloc>::\n-  _M_fill_assign(size_type __n, const value_type& __val)\n-  {\n-    iterator __i = begin();\n-    for ( ; __i != end() && __n > 0; ++__i, --__n)\n-      *__i = __val;\n-    if (__n > 0)\n-      insert(end(), __n, __val);\n-    else\n-      erase(__i, end());\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _InputIter>\n-    void\n+  \n+  template<typename _Tp, typename _Alloc>\n+    typename list<_Tp,_Alloc>::iterator\n     list<_Tp,_Alloc>::\n-    _M_assign_dispatch(_InputIter __first2, _InputIter __last2, __false_type)\n+    erase(iterator __position)\n     {\n-      iterator __first1 = begin();\n-      iterator __last1 = end();\n-      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n-        *__first1 = *__first2;\n-      if (__first2 == __last2)\n-        erase(__first1, __last1);\n-      else\n-        insert(__last1, __first2, __last2);\n+      _List_node_base* __next_node = __position._M_node->_M_next;\n+      _List_node_base* __prev_node = __position._M_node->_M_prev;\n+      _Node* __n = static_cast<_Node*>(__position._M_node);\n+      __prev_node->_M_next = __next_node;\n+      __next_node->_M_prev = __prev_node;\n+      _Destroy(&__n->_M_data);\n+      _M_put_node(__n);\n+      return iterator(static_cast<_Node*>(__next_node));\n     }\n-\n-template<typename _Tp, typename _Alloc>\n-  void\n-  list<_Tp,_Alloc>::\n-  remove(const value_type& __value)\n-  {\n-    iterator __first = begin();\n-    iterator __last = end();\n-    while (__first != __last)\n+  \n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp,_Alloc>::\n+    resize(size_type __new_size, const value_type& __x)\n     {\n-      iterator __next = __first;\n-      ++__next;\n-      if (*__first == __value)\n-        erase(__first);\n-      __first = __next;\n+      iterator __i = begin();\n+      size_type __len = 0;\n+      for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n+        ;\n+      if (__len == __new_size)\n+        erase(__i, end());\n+      else                          // __i == end()\n+        insert(end(), __new_size - __len, __x);\n     }\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  void\n-  list<_Tp,_Alloc>::\n-  unique()\n-  {\n-    iterator __first = begin();\n-    iterator __last = end();\n-    if (__first == __last) return;\n-    iterator __next = __first;\n-    while (++__next != __last)\n+  \n+  template<typename _Tp, typename _Alloc>\n+    list<_Tp,_Alloc>&\n+    list<_Tp,_Alloc>::\n+    operator=(const list& __x)\n     {\n-      if (*__first == *__next)\n-        erase(__next);\n-      else\n-        __first = __next;\n-      __next = __first;\n-    }\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  void\n-  list<_Tp,_Alloc>::\n-  merge(list& __x)\n-  {\n-    iterator __first1 = begin();\n-    iterator __last1 = end();\n-    iterator __first2 = __x.begin();\n-    iterator __last2 = __x.end();\n-    while (__first1 != __last1 && __first2 != __last2)\n-      if (*__first2 < *__first1)\n+      if (this != &__x)\n       {\n-        iterator __next = __first2;\n-        _M_transfer(__first1, __first2, ++__next);\n-        __first2 = __next;\n+        iterator __first1 = begin();\n+        iterator __last1 = end();\n+        const_iterator __first2 = __x.begin();\n+        const_iterator __last2 = __x.end();\n+        while (__first1 != __last1 && __first2 != __last2)\n+          *__first1++ = *__first2++;\n+        if (__first2 == __last2)\n+          erase(__first1, __last1);\n+        else\n+          insert(__last1, __first2, __last2);\n       }\n-      else\n-        ++__first1;\n-    if (__first2 != __last2)\n-      _M_transfer(__last1, __first2, __last2);\n-  }\n-\n-// FIXME put this somewhere else\n-inline void\n-__List_base_reverse(_List_node_base* __p)\n-{\n-  _List_node_base* __tmp = __p;\n-  do {\n-    std::swap(__tmp->_M_next, __tmp->_M_prev);\n-    __tmp = __tmp->_M_prev;     // Old next node is now prev.\n-  } while (__tmp != __p);\n-}\n-\n-template<typename _Tp, typename _Alloc>\n-  void\n-  list<_Tp,_Alloc>::\n-  sort()\n-  {\n-    // Do nothing if the list has length 0 or 1.\n-    if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)\n+      return *this;\n+    }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp,_Alloc>::\n+    _M_fill_assign(size_type __n, const value_type& __val)\n     {\n-      list __carry;\n-      list __counter[64];\n-      int __fill = 0;\n-      while (!empty())\n+      iterator __i = begin();\n+      for ( ; __i != end() && __n > 0; ++__i, --__n)\n+        *__i = __val;\n+      if (__n > 0)\n+        insert(end(), __n, __val);\n+      else\n+        erase(__i, end());\n+    }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    template <typename _InputIter>\n+      void\n+      list<_Tp,_Alloc>::\n+      _M_assign_dispatch(_InputIter __first2, _InputIter __last2, __false_type)\n       {\n-        __carry.splice(__carry.begin(), *this, begin());\n-        int __i = 0;\n-        while(__i < __fill && !__counter[__i].empty())\n-        {\n-          __counter[__i].merge(__carry);\n-          __carry.swap(__counter[__i++]);\n-        }\n-        __carry.swap(__counter[__i]);\n-        if (__i == __fill) ++__fill;\n+        iterator __first1 = begin();\n+        iterator __last1 = end();\n+        for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n+          *__first1 = *__first2;\n+        if (__first2 == __last2)\n+          erase(__first1, __last1);\n+        else\n+          insert(__last1, __first2, __last2);\n       }\n-\n-      for (int __i = 1; __i < __fill; ++__i)\n-        __counter[__i].merge(__counter[__i-1]);\n-      swap(__counter[__fill-1]);\n-    }\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _Predicate>\n+  \n+  template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n-    remove_if(_Predicate __pred)\n+    remove(const value_type& __value)\n     {\n       iterator __first = begin();\n       iterator __last = end();\n       while (__first != __last)\n       {\n         iterator __next = __first;\n         ++__next;\n-        if (__pred(*__first)) erase(__first);\n+        if (*__first == __value)\n+          erase(__first);\n         __first = __next;\n       }\n     }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _BinaryPredicate>\n+  \n+  template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n-    unique(_BinaryPredicate __binary_pred)\n+    unique()\n     {\n       iterator __first = begin();\n       iterator __last = end();\n       if (__first == __last) return;\n       iterator __next = __first;\n       while (++__next != __last)\n       {\n-        if (__binary_pred(*__first, *__next))\n+        if (*__first == *__next)\n           erase(__next);\n         else\n           __first = __next;\n         __next = __first;\n       }\n     }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _StrictWeakOrdering>\n+  \n+  template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n-    merge(list& __x, _StrictWeakOrdering __comp)\n+    merge(list& __x)\n     {\n       iterator __first1 = begin();\n       iterator __last1 = end();\n       iterator __first2 = __x.begin();\n       iterator __last2 = __x.end();\n       while (__first1 != __last1 && __first2 != __last2)\n-        if (__comp(*__first2, *__first1))\n+        if (*__first2 < *__first1)\n         {\n           iterator __next = __first2;\n           _M_transfer(__first1, __first2, ++__next);\n           __first2 = __next;\n         }\n         else\n           ++__first1;\n-      if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n+      if (__first2 != __last2)\n+        _M_transfer(__last1, __first2, __last2);\n     }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _StrictWeakOrdering>\n-  void\n-  list<_Tp,_Alloc>::\n-  sort(_StrictWeakOrdering __comp)\n+  \n+  // FIXME put this somewhere else\n+  inline void\n+  __List_base_reverse(_List_node_base* __p)\n   {\n-    // Do nothing if the list has length 0 or 1.\n-    if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)\n+    _List_node_base* __tmp = __p;\n+    do {\n+      std::swap(__tmp->_M_next, __tmp->_M_prev);\n+      __tmp = __tmp->_M_prev;     // Old next node is now prev.\n+    } while (__tmp != __p);\n+  }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp,_Alloc>::\n+    sort()\n     {\n-      list __carry;\n-      list __counter[64];\n-      int __fill = 0;\n-      while (!empty())\n+      // Do nothing if the list has length 0 or 1.\n+      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)\n       {\n-        __carry.splice(__carry.begin(), *this, begin());\n-        int __i = 0;\n-        while(__i < __fill && !__counter[__i].empty())\n+        list __carry;\n+        list __counter[64];\n+        int __fill = 0;\n+        while (!empty())\n         {\n-          __counter[__i].merge(__carry, __comp);\n-          __carry.swap(__counter[__i++]);\n+          __carry.splice(__carry.begin(), *this, begin());\n+          int __i = 0;\n+          while(__i < __fill && !__counter[__i].empty())\n+          {\n+            __counter[__i].merge(__carry);\n+            __carry.swap(__counter[__i++]);\n+          }\n+          __carry.swap(__counter[__i]);\n+          if (__i == __fill) ++__fill;\n         }\n-        __carry.swap(__counter[__i]);\n-        if (__i == __fill) ++__fill;\n+  \n+        for (int __i = 1; __i < __fill; ++__i)\n+          __counter[__i].merge(__counter[__i-1]);\n+        swap(__counter[__fill-1]);\n+      }\n+    }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    template <typename _Predicate>\n+      void\n+      list<_Tp,_Alloc>::\n+      remove_if(_Predicate __pred)\n+      {\n+        iterator __first = begin();\n+        iterator __last = end();\n+        while (__first != __last)\n+        {\n+          iterator __next = __first;\n+          ++__next;\n+          if (__pred(*__first)) erase(__first);\n+          __first = __next;\n+        }\n+      }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    template <typename _BinaryPredicate>\n+      void\n+      list<_Tp,_Alloc>::\n+      unique(_BinaryPredicate __binary_pred)\n+      {\n+        iterator __first = begin();\n+        iterator __last = end();\n+        if (__first == __last) return;\n+        iterator __next = __first;\n+        while (++__next != __last)\n+        {\n+          if (__binary_pred(*__first, *__next))\n+            erase(__next);\n+          else\n+            __first = __next;\n+          __next = __first;\n+        }\n+      }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    template <typename _StrictWeakOrdering>\n+      void\n+      list<_Tp,_Alloc>::\n+      merge(list& __x, _StrictWeakOrdering __comp)\n+      {\n+        iterator __first1 = begin();\n+        iterator __last1 = end();\n+        iterator __first2 = __x.begin();\n+        iterator __last2 = __x.end();\n+        while (__first1 != __last1 && __first2 != __last2)\n+          if (__comp(*__first2, *__first1))\n+          {\n+            iterator __next = __first2;\n+            _M_transfer(__first1, __first2, ++__next);\n+            __first2 = __next;\n+          }\n+          else\n+            ++__first1;\n+        if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n+      }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    template <typename _StrictWeakOrdering>\n+    void\n+    list<_Tp,_Alloc>::\n+    sort(_StrictWeakOrdering __comp)\n+    {\n+      // Do nothing if the list has length 0 or 1.\n+      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)\n+      {\n+        list __carry;\n+        list __counter[64];\n+        int __fill = 0;\n+        while (!empty())\n+        {\n+          __carry.splice(__carry.begin(), *this, begin());\n+          int __i = 0;\n+          while(__i < __fill && !__counter[__i].empty())\n+          {\n+            __counter[__i].merge(__carry, __comp);\n+            __carry.swap(__counter[__i++]);\n+          }\n+          __carry.swap(__counter[__i]);\n+          if (__i == __fill) ++__fill;\n+        }\n+  \n+        for (int __i = 1; __i < __fill; ++__i)\n+          __counter[__i].merge(__counter[__i-1], __comp);\n+        swap(__counter[__fill-1]);\n       }\n-\n-      for (int __i = 1; __i < __fill; ++__i)\n-        __counter[__i].merge(__counter[__i-1], __comp);\n-      swap(__counter[__fill-1]);\n     }\n-  }\n-\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_LIST_TCC */\n-"}, {"sha": "aa1eef80aab2b9b23c480760000ee947daba854e", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 1426, "deletions": 1424, "changes": 2850, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646"}, {"sha": "7c245d056c6d2735a68add8f53f13ba55329fc19", "filename": "libstdc++-v3/include/bits/stl_iterator_base_funcs.h", "status": "modified", "additions": 95, "deletions": 103, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -67,113 +67,105 @@\n #pragma GCC system_header\n #include <bits/concept_check.h>\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-template<typename _InputIterator>\n-  inline typename iterator_traits<_InputIterator>::difference_type\n-  __distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)\n-  {\n-    // concept requirements\n-    __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>)\n-\n-    typename iterator_traits<_InputIterator>::difference_type __n = 0;\n-    while (__first != __last) {\n-      ++__first; ++__n;\n+  template<typename _InputIterator>\n+    inline typename iterator_traits<_InputIterator>::difference_type\n+    __distance(_InputIterator __first, _InputIterator __last,\n+               input_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>)\n+  \n+      typename iterator_traits<_InputIterator>::difference_type __n = 0;\n+      while (__first != __last) {\n+        ++__first; ++__n;\n+      }\n+      return __n;\n     }\n-    return __n;\n-  }\n-\n-template<typename _RandomAccessIterator>\n-  inline typename iterator_traits<_RandomAccessIterator>::difference_type\n-  __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-             random_access_iterator_tag)\n-  {\n-    // concept requirements\n-    __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n-    return __last - __first;\n-  }\n-\n-/**\n- *  @brief A generalization of pointer arithmetic.\n- *  @param  first  An input iterator.\n- *  @param  last  An input iterator.\n- *  @return  The distance between them.\n- *\n- *  Returns @c n such that first + n == last.  This requires that @p last\n- *  must be reachable from @p first.  Note that @c n may be negative.\n- *\n- *  For random access iterators, this uses their @c + and @c - operations\n- *  and are constant time.  For other %iterator classes they are linear time.\n-*/\n-template<typename _InputIterator>\n-  inline typename iterator_traits<_InputIterator>::difference_type\n-  distance(_InputIterator __first, _InputIterator __last)\n-  {\n-    // concept requirements -- taken care of in __distance\n-    return __distance(__first, __last, __iterator_category(__first));\n-  }\n-\n-template<typename _InputIter, typename _Distance>\n-  inline void\n-  __advance(_InputIter& __i, _Distance __n, input_iterator_tag)\n-  {\n-    // concept requirements\n-    __glibcpp_function_requires(_InputIteratorConcept<_InputIter>)\n-    while (__n--) ++__i;\n-  }\n-\n-template<typename _BidirectionalIterator, typename _Distance>\n-  inline void\n-  __advance(_BidirectionalIterator& __i, _Distance __n,\n-            bidirectional_iterator_tag)\n-  {\n-    // concept requirements\n-    __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>)\n-\n-    if (__n > 0)\n+  \n+  template<typename _RandomAccessIterator>\n+    inline typename iterator_traits<_RandomAccessIterator>::difference_type\n+    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+               random_access_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n+      return __last - __first;\n+    }\n+  \n+  /**\n+   *  @brief A generalization of pointer arithmetic.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   *  @return  The distance between them.\n+   *\n+   *  Returns @c n such that first + n == last.  This requires that @p last\n+   *  must be reachable from @p first.  Note that @c n may be negative.\n+   *\n+   *  For random access iterators, this uses their @c + and @c - operations\n+   *  and are constant time.  For other %iterator classes they are linear time.\n+  */\n+  template<typename _InputIterator>\n+    inline typename iterator_traits<_InputIterator>::difference_type\n+    distance(_InputIterator __first, _InputIterator __last)\n+    {\n+      // concept requirements -- taken care of in __distance\n+      return __distance(__first, __last, __iterator_category(__first));\n+    }\n+  \n+  template<typename _InputIter, typename _Distance>\n+    inline void\n+    __advance(_InputIter& __i, _Distance __n, input_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter>)\n       while (__n--) ++__i;\n-    else\n-      while (__n++) --__i;\n-  }\n-\n-template<typename _RandomAccessIterator, typename _Distance>\n-  inline void\n-  __advance(_RandomAccessIterator& __i, _Distance __n,\n-            random_access_iterator_tag)\n-  {\n-    // concept requirements\n-    __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n-    __i += __n;\n-  }\n-\n-/**\n- *  @brief A generalization of pointer arithmetic.\n- *  @param  i  An input iterator.\n- *  @param  n  The \"delta\" by which to change @p i.\n- *  @return  Nothing.\n- *\n- *  This increments @p i by @p n.  For bidirectional and random access\n- *  iterators, @p n may be negative, in which case @p i is decremented.\n- *\n- *  For random access iterators, this uses their @c + and @c - operations\n- *  and are constant time.  For other %iterator classes they are linear time.\n-*/\n-template<typename _InputIterator, typename _Distance>\n-  inline void\n-  advance(_InputIterator& __i, _Distance __n)\n-  {\n-    // concept requirements -- taken care of in __advance\n-    __advance(__i, __n, __iterator_category(__i));\n-  }\n-\n+    }\n+  \n+  template<typename _BidirectionalIterator, typename _Distance>\n+    inline void\n+    __advance(_BidirectionalIterator& __i, _Distance __n,\n+              bidirectional_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>)\n+  \n+      if (__n > 0)\n+        while (__n--) ++__i;\n+      else\n+        while (__n++) --__i;\n+    }\n+  \n+  template<typename _RandomAccessIterator, typename _Distance>\n+    inline void\n+    __advance(_RandomAccessIterator& __i, _Distance __n,\n+              random_access_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n+      __i += __n;\n+    }\n+  \n+  /**\n+   *  @brief A generalization of pointer arithmetic.\n+   *  @param  i  An input iterator.\n+   *  @param  n  The \"delta\" by which to change @p i.\n+   *  @return  Nothing.\n+   *\n+   *  This increments @p i by @p n.  For bidirectional and random access\n+   *  iterators, @p n may be negative, in which case @p i is decremented.\n+   *\n+   *  For random access iterators, this uses their @c + and @c - operations\n+   *  and are constant time.  For other %iterator classes they are linear time.\n+  */\n+  template<typename _InputIterator, typename _Distance>\n+    inline void\n+    advance(_InputIterator& __i, _Distance __n)\n+    {\n+      // concept requirements -- taken care of in __advance\n+      __advance(__i, __n, __iterator_category(__i));\n+    }\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_ITERATOR_BASE_FUNCS_H */\n-\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "9051d2cb933c34978571c8ab72adbdf518a4122b", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 1041, "deletions": 1045, "changes": 2086, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -63,1107 +63,1103 @@\n \n #include <bits/concept_check.h>\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-\n-// Supporting structures are split into common and templated types; the\n-// latter publicly inherits from the former in an effort to reduce code\n-// duplication.  This results in some \"needless\" static_cast'ing later on,\n-// but it's all safe downcasting.\n-\n-/// @if maint Common part of a node in the %list.  @endif\n-struct _List_node_base\n-{\n-  _List_node_base* _M_next;   ///< Self-explanatory\n-  _List_node_base* _M_prev;   ///< Self-explanatory\n-};\n-\n-/// @if maint An actual node in the %list.  @endif\n-template<typename _Tp>\n-  struct _List_node : public _List_node_base\n-{\n-  _Tp _M_data;                ///< User's data.\n-};\n-\n-\n-/**\n- *  @if maint\n- *  @brief Common part of a list::iterator.\n- *\n- *  A simple type to walk a doubly-linked list.  All operations here should\n- *  be self-explanatory after taking any decent introductory data structures\n- *  course.\n- *  @endif\n-*/\n-struct _List_iterator_base\n-{\n-  typedef size_t                        size_type;\n-  typedef ptrdiff_t                     difference_type;\n-  typedef bidirectional_iterator_tag    iterator_category;\n-\n-  /// The only member points to the %list element.\n-  _List_node_base* _M_node;\n-\n-  _List_iterator_base(_List_node_base* __x)\n-  : _M_node(__x)\n-  { }\n-\n-  _List_iterator_base()\n-  { }\n-\n-  /// Walk the %list forward.\n-  void\n-  _M_incr()\n-    { _M_node = _M_node->_M_next; }\n-\n-  /// Walk the %list backward.\n-  void\n-  _M_decr()\n-    { _M_node = _M_node->_M_prev; }\n-\n-  bool\n-  operator==(const _List_iterator_base& __x) const\n-    { return _M_node == __x._M_node; }\n-\n-  bool\n-  operator!=(const _List_iterator_base& __x) const\n-    { return _M_node != __x._M_node; }\n-};\n-\n-/**\n- *  @brief A list::iterator.\n- *\n- *  In addition to being used externally, a list holds one of these internally,\n- *  pointing to the sequence of data.\n- *\n- *  @if maint\n- *  All the functions are op overloads.\n- *  @endif\n-*/\n-template<typename _Tp, typename _Ref, typename _Ptr>\n-  struct _List_iterator : public _List_iterator_base\n-{\n-  typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-  typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-  typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n-\n-  typedef _Tp                                       value_type;\n-  typedef _Ptr                                      pointer;\n-  typedef _Ref                                      reference;\n-  typedef _List_node<_Tp>                           _Node;\n-\n-  _List_iterator(_Node* __x)\n-  : _List_iterator_base(__x)\n-  { }\n-\n-  _List_iterator()\n-  { }\n-\n-  _List_iterator(const iterator& __x)\n-  : _List_iterator_base(__x._M_node)\n-  { }\n-\n-  reference\n-  operator*() const\n-    { return static_cast<_Node*>(_M_node)->_M_data; }\n-    // Must downcast from List_node_base to _List_node to get to _M_data.\n-\n-  pointer\n-  operator->() const\n-    { return &(operator*()); }\n-\n-  _Self&\n-  operator++()\n+  // Supporting structures are split into common and templated types; the\n+  // latter publicly inherits from the former in an effort to reduce code\n+  // duplication.  This results in some \"needless\" static_cast'ing later on,\n+  // but it's all safe downcasting.\n+  \n+  /// @if maint Common part of a node in the %list.  @endif\n+  struct _List_node_base\n   {\n-    this->_M_incr();\n-    return *this;\n-  }\n-\n-  _Self\n-  operator++(int)\n+    _List_node_base* _M_next;   ///< Self-explanatory\n+    _List_node_base* _M_prev;   ///< Self-explanatory\n+  };\n+  \n+  /// @if maint An actual node in the %list.  @endif\n+  template<typename _Tp>\n+    struct _List_node : public _List_node_base\n   {\n-    _Self __tmp = *this;\n-    this->_M_incr();\n-    return __tmp;\n-  }\n-\n-  _Self&\n-  operator--()\n-  {\n-    this->_M_decr();\n-    return *this;\n-  }\n-\n-  _Self\n-  operator--(int)\n-  {\n-    _Self __tmp = *this;\n-    this->_M_decr();\n-    return __tmp;\n-  }\n-};\n-\n-\n-/// @if maint Primary default version.  @endif\n-/**\n- *  @if maint\n- *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n- *  @endif\n-*/\n-template<typename _Tp, typename _Allocator, bool _IsStatic>\n-  class _List_alloc_base\n-{\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-          allocator_type;\n-\n-  allocator_type\n-  get_allocator() const { return _M_node_allocator; }\n-\n-  _List_alloc_base(const allocator_type& __a)\n-  : _M_node_allocator(__a)\n-  { }\n-\n-protected:\n-  _List_node<_Tp>*\n-  _M_get_node()\n-    { return _M_node_allocator.allocate(1); }\n-\n-  void\n-  _M_put_node(_List_node<_Tp>* __p)\n-    { _M_node_allocator.deallocate(__p, 1); }\n-\n-  // NOTA BENE\n-  // The stored instance is not actually of \"allocator_type\"'s type.  Instead\n-  // we rebind the type to Allocator<List_node<Tp>>, which according to\n-  // [20.1.5]/4 should probably be the same.  List_node<Tp> is not the same\n-  // size as Tp (it's two pointers larger), and specializations on Tp may go\n-  // unused because List_node<Tp> is being bound instead.\n-  //\n-  // We put this to the test in get_allocator above; if the two types are\n-  // actually different, there had better be a conversion between them.\n-  //\n-  // None of the predefined allocators shipped with the library (as of 3.1)\n-  // use this instantiation anyhow; they're all instanceless.\n-  typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n-           _M_node_allocator;\n-\n-  _List_node<_Tp>* _M_node;\n-};\n-\n-/// @if maint Specialization for instanceless allocators.  @endif\n-template<typename _Tp, typename _Allocator>\n-  class _List_alloc_base<_Tp, _Allocator, true>\n-{\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-          allocator_type;\n-\n-  allocator_type\n-  get_allocator() const { return allocator_type(); }\n-\n-  _List_alloc_base(const allocator_type&)\n-  { }\n-\n-protected:\n-  // See comment in primary template class about why this is safe for the\n-  // standard predefined classes.\n-  typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type\n-          _Alloc_type;\n-\n-  _List_node<_Tp>*\n-  _M_get_node()\n-    { return _Alloc_type::allocate(1); }\n-\n-  void\n-  _M_put_node(_List_node<_Tp>* __p)\n-    { _Alloc_type::deallocate(__p, 1); }\n-\n-  _List_node<_Tp>* _M_node;\n-};\n-\n-\n-/**\n- *  @if maint\n- *  See bits/stl_deque.h's _Deque_base for an explanation.\n- *  @endif\n-*/\n-template <typename _Tp, typename _Alloc>\n-  class _List_base\n-  : public _List_alloc_base<_Tp, _Alloc,\n-                            _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-{\n-public:\n-  typedef _List_alloc_base<_Tp, _Alloc,\n-                           _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  _List_base(const allocator_type& __a)\n-  : _Base(__a)\n-  {\n-    _M_node = _M_get_node();\n-    _M_node->_M_next = _M_node;\n-    _M_node->_M_prev = _M_node;\n-  }\n-\n-  // This is what actually destroys the list.\n-  ~_List_base()\n-  {\n-    __clear();\n-    _M_put_node(_M_node);\n-  }\n-\n-  void\n-  __clear();\n-};\n-\n-\n-/**\n- *  @brief  A standard container with linear time access to elements, and\n- *  fixed time insertion/deletion at any point in the sequence.\n- *\n- *  @ingroup Containers\n- *  @ingroup Sequences\n- *\n- *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n- *  <a href=\"tables.html#66\">reversible container</a>, and a\n- *  <a href=\"tables.html#67\">sequence</a>, including the\n- *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n- *  %exception of @c at and @c operator[].\n- *\n- *  This is a @e doubly @e linked %list.  Traversal up and down the %list\n- *  requires linear time, but adding and removing elements (or @e nodes) is\n- *  done in constant time, regardless of where the change takes place.\n- *  Unlike std::vector and std::deque, random-access iterators are not\n- *  provided, so subscripting ( @c [] ) access is not allowed.  For algorithms\n- *  which only need sequential access, this lack makes no difference.\n- *\n- *  Also unlike the other standard containers, std::list provides specialized \n- *  algorithms %unique to linked lists, such as splicing, sorting, and\n- *  in-place reversal.\n- *\n- *  @if maint\n- *  A couple points on memory allocation for list<Tp>:\n- *\n- *  First, we never actually allocate a Tp, we actally allocate List_node<Tp>'s\n- *  and trust [20.1.5]/4 to DTRT.  This is to ensure that after elements from\n- *  %list<X,Alloc1> are spliced into %list<X,Alloc2>, destroying the memory of\n- *  the second %list is a valid operation, i.e., Alloc1 giveth and Alloc2\n- *  taketh away.\n- *\n- *  Second, a %list conceptually represented as\n- *  @code\n- *    A <---> B <---> C <---> D\n- *  @endcode\n- *  is actually circular; a link exists between A and D.  The %list class\n- *  holds (as its only data member) a private list::iterator pointing to\n- *  @e D, not to @e A!  To get to the head of the %list, we start at the tail\n- *  and move forward by one.  When this member iterator's next/previous\n- *  pointers refer to itself, the %list is %empty.\n- *  @endif\n-*/\n-template<typename _Tp, typename _Alloc = allocator<_Tp> >\n-  class list : protected _List_base<_Tp, _Alloc>\n-{\n-  // concept requirements\n-  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-\n-  typedef _List_base<_Tp, _Alloc>                       _Base;\n-\n-public:\n-  typedef _Tp                                           value_type;\n-  typedef value_type*                                   pointer;\n-  typedef const value_type*                             const_pointer;\n-  typedef _List_iterator<_Tp,_Tp&,_Tp*>                 iterator;\n-  typedef _List_iterator<_Tp,const _Tp&,const _Tp*>     const_iterator;\n-  typedef reverse_iterator<const_iterator>              const_reverse_iterator;\n-  typedef reverse_iterator<iterator>                    reverse_iterator;\n-  typedef value_type&                                   reference;\n-  typedef const value_type&                             const_reference;\n-  typedef size_t                                        size_type;\n-  typedef ptrdiff_t                                     difference_type;\n-  typedef typename _Base::allocator_type                allocator_type;\n-\n-protected:\n-  // Note that pointers-to-_Node's can be ctor-converted to iterator types.\n-  typedef _List_node<_Tp>                               _Node;\n-\n-  /** @if maint\n-   *  One data member plus two memory-handling functions.  If the _Alloc\n-   *  type requires separate instances, then one of those will also be\n-   *  included, accumulated from the topmost parent.\n-   *  @endif\n-  */\n-  using _Base::_M_node;\n-  using _Base::_M_put_node;\n-  using _Base::_M_get_node;\n-\n+    _Tp _M_data;                ///< User's data.\n+  };\n+  \n+  \n   /**\n    *  @if maint\n-   *  @param  x  An instance of user data.\n+   *  @brief Common part of a list::iterator.\n    *\n-   *  Allocates space for a new node and constructs a copy of @a x in it.\n+   *  A simple type to walk a doubly-linked list.  All operations here should\n+   *  be self-explanatory after taking any decent introductory data structures\n+   *  course.\n    *  @endif\n   */\n-  _Node*\n-  _M_create_node(const value_type& __x)\n+  struct _List_iterator_base\n   {\n-    _Node* __p = _M_get_node();\n-    try {\n-      _Construct(&__p->_M_data, __x);\n-    }\n-    catch(...)\n-    {\n-      _M_put_node(__p);\n-      __throw_exception_again;\n-    }\n-    return __p;\n-  }\n-\n+    typedef size_t                        size_type;\n+    typedef ptrdiff_t                     difference_type;\n+    typedef bidirectional_iterator_tag    iterator_category;\n+  \n+    /// The only member points to the %list element.\n+    _List_node_base* _M_node;\n+  \n+    _List_iterator_base(_List_node_base* __x)\n+    : _M_node(__x)\n+    { }\n+  \n+    _List_iterator_base()\n+    { }\n+  \n+    /// Walk the %list forward.\n+    void\n+    _M_incr()\n+      { _M_node = _M_node->_M_next; }\n+  \n+    /// Walk the %list backward.\n+    void\n+    _M_decr()\n+      { _M_node = _M_node->_M_prev; }\n+  \n+    bool\n+    operator==(const _List_iterator_base& __x) const\n+      { return _M_node == __x._M_node; }\n+  \n+    bool\n+    operator!=(const _List_iterator_base& __x) const\n+      { return _M_node != __x._M_node; }\n+  };\n+  \n   /**\n+   *  @brief A list::iterator.\n+   *\n+   *  In addition to being used externally, a list holds one of these\n+   *  internally, pointing to the sequence of data.\n+   *\n    *  @if maint\n-   *  Allocates space for a new node and default-constructs a new instance\n-   *  of @c value_type in it.\n+   *  All the functions are op overloads.\n    *  @endif\n   */\n-  _Node*\n-  _M_create_node()\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n+    struct _List_iterator : public _List_iterator_base\n   {\n-    _Node* __p = _M_get_node();\n-    try {\n-      _Construct(&__p->_M_data);\n+    typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+    typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+    typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n+  \n+    typedef _Tp                                       value_type;\n+    typedef _Ptr                                      pointer;\n+    typedef _Ref                                      reference;\n+    typedef _List_node<_Tp>                           _Node;\n+  \n+    _List_iterator(_Node* __x)\n+    : _List_iterator_base(__x)\n+    { }\n+  \n+    _List_iterator()\n+    { }\n+  \n+    _List_iterator(const iterator& __x)\n+    : _List_iterator_base(__x._M_node)\n+    { }\n+  \n+    reference\n+    operator*() const\n+      { return static_cast<_Node*>(_M_node)->_M_data; }\n+      // Must downcast from List_node_base to _List_node to get to _M_data.\n+  \n+    pointer\n+    operator->() const\n+      { return &(operator*()); }\n+  \n+    _Self&\n+    operator++()\n+    {\n+      this->_M_incr();\n+      return *this;\n     }\n-    catch(...)\n+  \n+    _Self\n+    operator++(int)\n     {\n-      _M_put_node(__p);\n-      __throw_exception_again;\n+      _Self __tmp = *this;\n+      this->_M_incr();\n+      return __tmp;\n     }\n-    return __p;\n-  }\n-\n-public:\n-  // [23.2.2.1] construct/copy/destroy\n-  // (assign() and get_allocator() are also listed in this section)\n-  /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  explicit\n-  list(const allocator_type& __a = allocator_type())\n-  : _Base(__a) { }\n-\n-  /**\n-   *  @brief  Create a %list with copies of an exemplar element.\n-   *  @param  n  The number of elements to initially create.\n-   *  @param  value  An element to copy.\n-   * \n-   *  This constructor fills the %list with @a n copies of @a value.\n-  */\n-  list(size_type __n, const value_type& __value,\n-       const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-    { this->insert(begin(), __n, __value); }\n-\n-  /**\n-   *  @brief  Create a %list with default elements.\n-   *  @param  n  The number of elements to initially create.\n-   * \n-   *  This constructor fills the %list with @a n copies of a\n-   *  default-constructed element.\n-  */\n-  explicit\n-  list(size_type __n)\n-    : _Base(allocator_type())\n-    { this->insert(begin(), __n, value_type()); }\n-\n+  \n+    _Self&\n+    operator--()\n+    {\n+      this->_M_decr();\n+      return *this;\n+    }\n+  \n+    _Self\n+    operator--(int)\n+    {\n+      _Self __tmp = *this;\n+      this->_M_decr();\n+      return __tmp;\n+    }\n+  };\n+  \n+  \n+  /// @if maint Primary default version.  @endif\n   /**\n-   *  @brief  %List copy constructor.\n-   *  @param  x  A %list of identical element and allocator types.\n-   * \n-   *  The newly-created %list uses a copy of the allocation object used\n-   *  by @a x.\n+   *  @if maint\n+   *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n+   *  @endif\n   */\n-  list(const list& __x)\n-    : _Base(__x.get_allocator())\n-    { this->insert(begin(), __x.begin(), __x.end()); }\n-\n+  template<typename _Tp, typename _Allocator, bool _IsStatic>\n+    class _List_alloc_base\n+  {\n+  public:\n+    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+            allocator_type;\n+  \n+    allocator_type\n+    get_allocator() const { return _M_node_allocator; }\n+  \n+    _List_alloc_base(const allocator_type& __a)\n+    : _M_node_allocator(__a)\n+    { }\n+  \n+  protected:\n+    _List_node<_Tp>*\n+    _M_get_node()\n+      { return _M_node_allocator.allocate(1); }\n+  \n+    void\n+    _M_put_node(_List_node<_Tp>* __p)\n+      { _M_node_allocator.deallocate(__p, 1); }\n+  \n+    // NOTA BENE\n+    // The stored instance is not actually of \"allocator_type\"'s type.  Instead\n+    // we rebind the type to Allocator<List_node<Tp>>, which according to\n+    // [20.1.5]/4 should probably be the same.  List_node<Tp> is not the same\n+    // size as Tp (it's two pointers larger), and specializations on Tp may go\n+    // unused because List_node<Tp> is being bound instead.\n+    //\n+    // We put this to the test in get_allocator above; if the two types are\n+    // actually different, there had better be a conversion between them.\n+    //\n+    // None of the predefined allocators shipped with the library (as of 3.1)\n+    // use this instantiation anyhow; they're all instanceless.\n+    typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n+             _M_node_allocator;\n+  \n+    _List_node<_Tp>* _M_node;\n+  };\n+  \n+  /// @if maint Specialization for instanceless allocators.  @endif\n+  template<typename _Tp, typename _Allocator>\n+    class _List_alloc_base<_Tp, _Allocator, true>\n+  {\n+  public:\n+    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+            allocator_type;\n+  \n+    allocator_type\n+    get_allocator() const { return allocator_type(); }\n+  \n+    _List_alloc_base(const allocator_type&)\n+    { }\n+  \n+  protected:\n+    // See comment in primary template class about why this is safe for the\n+    // standard predefined classes.\n+    typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type\n+            _Alloc_type;\n+  \n+    _List_node<_Tp>*\n+    _M_get_node()\n+      { return _Alloc_type::allocate(1); }\n+  \n+    void\n+    _M_put_node(_List_node<_Tp>* __p)\n+      { _Alloc_type::deallocate(__p, 1); }\n+  \n+    _List_node<_Tp>* _M_node;\n+  };\n+  \n+  \n   /**\n-   *  @brief  Builds a %list from a range.\n-   *  @param  first  An input iterator.\n-   *  @param  last  An input iterator.\n-   * \n-   *  Create a %list consisting of copies of the elements from [first,last).\n-   *  This is linear in N (where N is distance(first,last)).\n-   *\n    *  @if maint\n-   *  We don't need any dispatching tricks here, because insert does all of\n-   *  that anyway.\n+   *  See bits/stl_deque.h's _Deque_base for an explanation.\n    *  @endif\n   */\n-  template<typename _InputIterator>\n-    list(_InputIterator __first, _InputIterator __last,\n-         const allocator_type& __a = allocator_type())\n+  template <typename _Tp, typename _Alloc>\n+    class _List_base\n+    : public _List_alloc_base<_Tp, _Alloc,\n+                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+  {\n+  public:\n+    typedef _List_alloc_base<_Tp, _Alloc,\n+                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+            _Base;\n+    typedef typename _Base::allocator_type allocator_type;\n+  \n+    _List_base(const allocator_type& __a)\n     : _Base(__a)\n-    { this->insert(begin(), __first, __last); }\n-\n-  /**\n-   *  The dtor only erases the elements, and note that if the elements\n-   *  themselves are pointers, the pointed-to memory is not touched in any\n-   *  way.  Managing the pointer is the user's responsibilty.\n-  */\n-  ~list() { }\n-\n-  /**\n-   *  @brief  %List assignment operator.\n-   *  @param  x  A %list of identical element and allocator types.\n-   * \n-   *  All the elements of @a x are copied, but unlike the copy constructor, the\n-   *  allocator object is not copied.\n-  */\n-  list&\n-  operator=(const list& __x);\n-\n-  /**\n-   *  @brief  Assigns a given value to a %list.\n-   *  @param  n  Number of elements to be assigned.\n-   *  @param  val  Value to be assigned.\n-   *\n-   *  This function fills a %list with @a n copies of the given value.\n-   *  Note that the assignment completely changes the %list and that the\n-   *  resulting %list's size is the same as the number of elements assigned.\n-   *  Old data may be lost.\n-  */\n-  void\n-  assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n-\n-  /**\n-   *  @brief  Assigns a range to a %list.\n-   *  @param  first  An input iterator.\n-   *  @param  last   An input iterator.\n-   *\n-   *  This function fills a %list with copies of the elements in the\n-   *  range [first,last).\n-   *\n-   *  Note that the assignment completely changes the %list and that the\n-   *  resulting %list's size is the same as the number of elements assigned.\n-   *  Old data may be lost.\n-  */\n-  template<typename _InputIterator>\n-    void\n-    assign(_InputIterator __first, _InputIterator __last)\n     {\n-      // Check whether it's an integral type.  If so, it's not an iterator.\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_assign_dispatch(__first, __last, _Integral());\n+      _M_node = _M_get_node();\n+      _M_node->_M_next = _M_node;\n+      _M_node->_M_prev = _M_node;\n     }\n-\n-  /// Get a copy of the memory allocation object.\n-  allocator_type\n-  get_allocator() const { return _Base::get_allocator(); }\n-\n-  // iterators\n-  /**\n-   *  Returns a read/write iterator that points to the first element in the\n-   *  %list.  Iteration is done in ordinary element order.\n-  */\n-  iterator\n-  begin() { return static_cast<_Node*>(_M_node->_M_next); }\n-\n-  /**\n-   *  Returns a read-only (constant) iterator that points to the first element\n-   *  in the %list.  Iteration is done in ordinary element order.\n-  */\n-  const_iterator\n-  begin() const { return static_cast<_Node*>(_M_node->_M_next); }\n-\n-  /**\n-   *  Returns a read/write iterator that points one past the last element in\n-   *  the %list.  Iteration is done in ordinary element order.\n-  */\n-  iterator\n-  end() { return _M_node; }\n-\n-  /**\n-   *  Returns a read-only (constant) iterator that points one past the last\n-   *  element in the %list.  Iteration is done in ordinary element order.\n-  */\n-  const_iterator\n-  end() const { return _M_node; }\n-\n-  /**\n-   *  Returns a read/write reverse iterator that points to the last element in\n-   *  the %list.  Iteration is done in reverse element order.\n-  */\n-  reverse_iterator\n-  rbegin() { return reverse_iterator(end()); }\n-\n-  /**\n-   *  Returns a read-only (constant) reverse iterator that points to the last\n-   *  element in the %list.  Iteration is done in reverse element order.\n-  */\n-  const_reverse_iterator\n-  rbegin() const { return const_reverse_iterator(end()); }\n-\n-  /**\n-   *  Returns a read/write reverse iterator that points to one before the\n-   *  first element in the %list.  Iteration is done in reverse element\n-   *  order.\n-  */\n-  reverse_iterator\n-  rend() { return reverse_iterator(begin()); }\n-\n-  /**\n-   *  Returns a read-only (constant) reverse iterator that points to one\n-   *  before the first element in the %list.  Iteration is done in reverse\n-   *  element order.\n-  */\n-  const_reverse_iterator\n-  rend() const\n-  { return const_reverse_iterator(begin()); }\n-\n-  // [23.2.2.2] capacity\n-  /**\n-   *  Returns true if the %list is empty.  (Thus begin() would equal end().)\n-  */\n-  bool\n-  empty() const { return _M_node->_M_next == _M_node; }\n-\n-  /**  Returns the number of elements in the %list.  */\n-  size_type\n-  size() const { return distance(begin(), end()); }\n-\n-  /**  Returns the size() of the largest possible %list.  */\n-  size_type\n-  max_size() const { return size_type(-1); }\n-\n-  /**\n-   *  @brief  Resizes the %list to the specified number of elements.\n-   *  @param  new_size  Number of elements the %list should contain.\n-   *  @param  x  Data with which new elements should be populated.\n-   *\n-   *  This function will %resize the %list to the specified number of\n-   *  elements.  If the number is smaller than the %list's current size the\n-   *  %list is truncated, otherwise the %list is extended and new elements\n-   *  are populated with given data.\n-  */\n-  void\n-  resize(size_type __new_size, const value_type& __x);\n-\n-  /**\n-   *  @brief  Resizes the %list to the specified number of elements.\n-   *  @param  new_size  Number of elements the %list should contain.\n-   *\n-   *  This function will resize the %list to the specified number of\n-   *  elements.  If the number is smaller than the %list's current size the\n-   *  %list is truncated, otherwise the %list is extended and new elements\n-   *  are default-constructed.\n-  */\n-  void\n-  resize(size_type __new_size) { this->resize(__new_size, value_type()); }\n-\n-  // element access\n-  /**\n-   *  Returns a read/write reference to the data at the first element of the\n-   *  %list.\n-  */\n-  reference\n-  front() { return *begin(); }\n-\n-  /**\n-   *  Returns a read-only (constant) reference to the data at the first\n-   *  element of the %list.\n-  */\n-  const_reference\n-  front() const { return *begin(); }\n-\n-  /**\n-   *  Returns a read/write reference to the data at the last element of the\n-   *  %list.\n-  */\n-  reference\n-  back() { return *(--end()); }\n-\n-  /**\n-   *  Returns a read-only (constant) reference to the data at the last\n-   *  element of the %list.\n-  */\n-  const_reference\n-  back() const { return *(--end()); }\n-\n-  // [23.2.2.3] modifiers\n-  /**\n-   *  @brief  Add data to the front of the %list.\n-   *  @param  x  Data to be added.\n-   *\n-   *  This is a typical stack operation.  The function creates an element at\n-   *  the front of the %list and assigns the given data to it.  Due to the\n-   *  nature of a %list this operation can be done in constant time, and\n-   *  does not invalidate iterators and references.\n-  */\n-  void\n-  push_front(const value_type& __x) { this->insert(begin(), __x); }\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-  /**\n-   *  @brief  Add data to the front of the %list.\n-   *\n-   *  This is a typical stack operation.  The function creates a\n-   *  default-constructed element at the front of the %list.  Due to the nature\n-   *  of a %list this operation can be done in constant time.  You should\n-   *  consider using push_front(value_type()) instead.\n-   *\n-   *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n-   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n-   *        c++config.h.\n-  */\n-  void\n-  push_front() { this->insert(begin(), value_type()); }\n-#endif\n-\n+  \n+    // This is what actually destroys the list.\n+    ~_List_base()\n+    {\n+      __clear();\n+      _M_put_node(_M_node);\n+    }\n+  \n+    void\n+    __clear();\n+  };\n+  \n+  \n   /**\n-   *  @brief  Removes first element.\n+   *  @brief  A standard container with linear time access to elements, and\n+   *  fixed time insertion/deletion at any point in the sequence.\n    *\n-   *  This is a typical stack operation.  It shrinks the %list by one.\n-   *  Due to the nature of a %list this operation can be done in constant\n-   *  time, and only invalidates iterators/references to the element being\n-   *  removed.\n+   *  @ingroup Containers\n+   *  @ingroup Sequences\n    *\n-   *  Note that no data is returned, and if the first element's data is\n-   *  needed, it should be retrieved before pop_front() is called.\n-  */\n-  void\n-  pop_front() { this->erase(begin()); }\n-\n-  /**\n-   *  @brief  Add data to the end of the %list.\n-   *  @param  x  Data to be added.\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and a\n+   *  <a href=\"tables.html#67\">sequence</a>, including the\n+   *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n+   *  %exception of @c at and @c operator[].\n    *\n-   *  This is a typical stack operation.  The function creates an element at\n-   *  the end of the %list and assigns the given data to it.  Due to the\n-   *  nature of a %list this operation can be done in constant time, and\n-   *  does not invalidate iterators and references.\n-  */\n-  void\n-  push_back(const value_type& __x) { this->insert(end(), __x); }\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-  /**\n-   *  @brief  Add data to the end of the %list.\n+   *  This is a @e doubly @e linked %list.  Traversal up and down the %list\n+   *  requires linear time, but adding and removing elements (or @e nodes) is\n+   *  done in constant time, regardless of where the change takes place.\n+   *  Unlike std::vector and std::deque, random-access iterators are not\n+   *  provided, so subscripting ( @c [] ) access is not allowed.  For algorithms\n+   *  which only need sequential access, this lack makes no difference.\n    *\n-   *  This is a typical stack operation.  The function creates a\n-   *  default-constructed element at the end of the %list.  Due to the nature\n-   *  of a %list this operation can be done in constant time.  You should\n-   *  consider using push_back(value_type()) instead.\n+   *  Also unlike the other standard containers, std::list provides specialized \n+   *  algorithms %unique to linked lists, such as splicing, sorting, and\n+   *  in-place reversal.\n    *\n-   *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n-   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n-   *        c++config.h.\n-  */\n-  void\n-  push_back() { this->insert(end(), value_type()); }\n-#endif\n-\n-  /**\n-   *  @brief  Removes last element.\n+   *  @if maint\n+   *  A couple points on memory allocation for list<Tp>:\n    *\n-   *  This is a typical stack operation.  It shrinks the %list by one.\n-   *  Due to the nature of a %list this operation can be done in constant\n-   *  time, and only invalidates iterators/references to the element being\n-   *  removed.\n+   *  First, we never actually allocate a Tp, we allocate List_node<Tp>'s\n+   *  and trust [20.1.5]/4 to DTRT.  This is to ensure that after elements from\n+   *  %list<X,Alloc1> are spliced into %list<X,Alloc2>, destroying the memory of\n+   *  the second %list is a valid operation, i.e., Alloc1 giveth and Alloc2\n+   *  taketh away.\n    *\n-   *  Note that no data is returned, and if the last element's data is\n-   *  needed, it should be retrieved before pop_back() is called.\n+   *  Second, a %list conceptually represented as\n+   *  @code\n+   *    A <---> B <---> C <---> D\n+   *  @endcode\n+   *  is actually circular; a link exists between A and D.  The %list class\n+   *  holds (as its only data member) a private list::iterator pointing to\n+   *  @e D, not to @e A!  To get to the head of the %list, we start at the tail\n+   *  and move forward by one.  When this member iterator's next/previous\n+   *  pointers refer to itself, the %list is %empty.\n+   *  @endif\n   */\n-  void\n-  pop_back()\n+  template<typename _Tp, typename _Alloc = allocator<_Tp> >\n+    class list : protected _List_base<_Tp, _Alloc>\n   {\n-    iterator __tmp = end();\n-    this->erase(--__tmp);\n-  }\n-\n-  /**\n-   *  @brief  Inserts given value into %list before specified iterator.\n-   *  @param  position  An iterator into the %list.\n-   *  @param  x  Data to be inserted.\n-   *  @return  An iterator that points to the inserted data.\n-   *\n-   *  This function will insert a copy of the given value before the specified\n-   *  location.\n-   *  Due to the nature of a %list this operation can be done in constant\n-   *  time, and does not invalidate iterators and references.\n-  */\n-  iterator\n-  insert(iterator __position, const value_type& __x);\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-  /**\n-   *  @brief  Inserts an element into the %list.\n-   *  @param  position  An iterator into the %list.\n-   *  @return  An iterator that points to the inserted element.\n-   *\n-   *  This function will insert a default-constructed element before the\n-   *  specified location.  You should consider using\n-   *  insert(position,value_type()) instead.\n-   *  Due to the nature of a %list this operation can be done in constant\n-   *  time, and does not invalidate iterators and references.\n-   *\n-   *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n-   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n-   *        c++config.h.\n-  */\n-  iterator\n-  insert(iterator __position) { return insert(__position, value_type()); }\n-#endif\n-\n-  /**\n-   *  @brief  Inserts a number of copies of given data into the %list.\n-   *  @param  position  An iterator into the %list.\n-   *  @param  n  Number of elements to be inserted.\n-   *  @param  x  Data to be inserted.\n-   *\n-   *  This function will insert a specified number of copies of the given data\n-   *  before the location specified by @a position.\n-   *\n-   *  Due to the nature of a %list this operation can be done in constant\n-   *  time, and does not invalidate iterators and references.\n-  */\n-  void\n-  insert(iterator __pos, size_type __n, const value_type& __x)\n-    { _M_fill_insert(__pos, __n, __x); }\n-\n-  /**\n-   *  @brief  Inserts a range into the %list.\n-   *  @param  pos  An iterator into the %list.\n-   *  @param  first  An input iterator.\n-   *  @param  last   An input iterator.\n-   *\n-   *  This function will insert copies of the data in the range [first,last)\n-   *  into the %list before the location specified by @a pos.\n-   *\n-   *  Due to the nature of a %list this operation can be done in constant\n-   *  time, and does not invalidate iterators and references.\n-  */\n-  template<typename _InputIterator>\n-    void\n-    insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+    // concept requirements\n+    __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+  \n+    typedef _List_base<_Tp, _Alloc>                       _Base;\n+  \n+  public:\n+    typedef _Tp                                           value_type;\n+    typedef value_type*                                   pointer;\n+    typedef const value_type*                             const_pointer;\n+    typedef _List_iterator<_Tp,_Tp&,_Tp*>                 iterator;\n+    typedef _List_iterator<_Tp,const _Tp&,const _Tp*>     const_iterator;\n+    typedef reverse_iterator<const_iterator>              const_reverse_iterator;\n+    typedef reverse_iterator<iterator>                    reverse_iterator;\n+    typedef value_type&                                   reference;\n+    typedef const value_type&                             const_reference;\n+    typedef size_t                                        size_type;\n+    typedef ptrdiff_t                                     difference_type;\n+    typedef typename _Base::allocator_type                allocator_type;\n+  \n+  protected:\n+    // Note that pointers-to-_Node's can be ctor-converted to iterator types.\n+    typedef _List_node<_Tp>                               _Node;\n+  \n+    /** @if maint\n+     *  One data member plus two memory-handling functions.  If the _Alloc\n+     *  type requires separate instances, then one of those will also be\n+     *  included, accumulated from the topmost parent.\n+     *  @endif\n+    */\n+    using _Base::_M_node;\n+    using _Base::_M_put_node;\n+    using _Base::_M_get_node;\n+  \n+    /**\n+     *  @if maint\n+     *  @param  x  An instance of user data.\n+     *\n+     *  Allocates space for a new node and constructs a copy of @a x in it.\n+     *  @endif\n+    */\n+    _Node*\n+    _M_create_node(const value_type& __x)\n     {\n-      // Check whether it's an integral type.  If so, it's not an iterator.\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_insert_dispatch(__pos, __first, __last, _Integral());\n+      _Node* __p = _M_get_node();\n+      try {\n+        _Construct(&__p->_M_data, __x);\n+      }\n+      catch(...)\n+      {\n+        _M_put_node(__p);\n+        __throw_exception_again;\n+      }\n+      return __p;\n     }\n-\n-  /**\n-   *  @brief  Remove element at given position.\n-   *  @param  position  Iterator pointing to element to be erased.\n-   *  @return  An iterator pointing to the next element (or end()).\n-   *\n-   *  This function will erase the element at the given position and thus\n-   *  shorten the %list by one.\n-   *\n-   *  Due to the nature of a %list this operation can be done in constant\n-   *  time, and only invalidates iterators/references to the element being\n-   *  removed.\n-   *  The user is also cautioned that\n-   *  this function only erases the element, and that if the element is itself\n-   *  a pointer, the pointed-to memory is not touched in any way.  Managing\n-   *  the pointer is the user's responsibilty.\n-  */\n-  iterator\n-  erase(iterator __position);\n-\n-  /**\n-   *  @brief  Remove a range of elements.\n-   *  @param  first  Iterator pointing to the first element to be erased.\n-   *  @param  last  Iterator pointing to one past the last element to be erased.\n-   *  @return  An iterator pointing to the element pointed to by @a last\n-   *           prior to erasing (or end()).\n-   *\n-   *  This function will erase the elements in the range [first,last) and\n-   *  shorten the %list accordingly.\n-   *\n-   *  Due to the nature of a %list this operation can be done in constant\n-   *  time, and only invalidates iterators/references to the element being\n-   *  removed.\n-   *  The user is also cautioned that\n-   *  this function only erases the elements, and that if the elements\n-   *  themselves are pointers, the pointed-to memory is not touched in any\n-   *  way.  Managing the pointer is the user's responsibilty.\n-  */\n-  iterator\n-  erase(iterator __first, iterator __last)\n-  {\n-    while (__first != __last)\n-      erase(__first++);\n-    return __last;\n-  }\n-\n-  /**\n-   *  @brief  Swaps data with another %list.\n-   *  @param  x  A %list of the same element and allocator types.\n-   *\n-   *  This exchanges the elements between two lists in constant time.\n-   *  (It is only swapping a single pointer, so it should be quite fast.)\n-   *  Note that the global std::swap() function is specialized such that\n-   *  std::swap(l1,l2) will feed to this function.\n-  */\n-  void\n-  swap(list& __x) { std::swap(_M_node, __x._M_node); }\n-\n-  /**\n-   *  Erases all the elements.  Note that this function only erases the\n-   *  elements, and that if the elements themselves are pointers, the\n-   *  pointed-to memory is not touched in any way.  Managing the pointer is\n-   *  the user's responsibilty.\n-  */\n-  void\n-  clear() { _Base::__clear(); }\n-\n-  // [23.2.2.4] list operations\n-  /**\n-   *  @doctodo\n-  */\n-  void\n-  splice(iterator __position, list& __x)\n-  {\n-    if (!__x.empty())\n-      this->_M_transfer(__position, __x.begin(), __x.end());\n-  }\n-\n-  /**\n-   *  @doctodo\n-  */\n-  void\n-  splice(iterator __position, list&, iterator __i)\n-  {\n-    iterator __j = __i;\n-    ++__j;\n-    if (__position == __i || __position == __j) return;\n-    this->_M_transfer(__position, __i, __j);\n-  }\n-\n-  /**\n-   *  @doctodo\n-  */\n-  void\n-  splice(iterator __position, list&, iterator __first, iterator __last)\n-  {\n-    if (__first != __last)\n-      this->_M_transfer(__position, __first, __last);\n-  }\n-\n-  /**\n-   *  @doctodo\n-  */\n-  void\n-  remove(const _Tp& __value);\n-\n-  /**\n-   *  @doctodo\n-  */\n-  template<typename _Predicate>\n+  \n+    /**\n+     *  @if maint\n+     *  Allocates space for a new node and default-constructs a new instance\n+     *  of @c value_type in it.\n+     *  @endif\n+    */\n+    _Node*\n+    _M_create_node()\n+    {\n+      _Node* __p = _M_get_node();\n+      try {\n+        _Construct(&__p->_M_data);\n+      }\n+      catch(...)\n+      {\n+        _M_put_node(__p);\n+        __throw_exception_again;\n+      }\n+      return __p;\n+    }\n+  \n+  public:\n+    // [23.2.2.1] construct/copy/destroy\n+    // (assign() and get_allocator() are also listed in this section)\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    explicit\n+    list(const allocator_type& __a = allocator_type())\n+    : _Base(__a) { }\n+  \n+    /**\n+     *  @brief  Create a %list with copies of an exemplar element.\n+     *  @param  n  The number of elements to initially create.\n+     *  @param  value  An element to copy.\n+     * \n+     *  This constructor fills the %list with @a n copies of @a value.\n+    */\n+    list(size_type __n, const value_type& __value,\n+         const allocator_type& __a = allocator_type())\n+      : _Base(__a)\n+      { this->insert(begin(), __n, __value); }\n+  \n+    /**\n+     *  @brief  Create a %list with default elements.\n+     *  @param  n  The number of elements to initially create.\n+     * \n+     *  This constructor fills the %list with @a n copies of a\n+     *  default-constructed element.\n+    */\n+    explicit\n+    list(size_type __n)\n+      : _Base(allocator_type())\n+      { this->insert(begin(), __n, value_type()); }\n+  \n+    /**\n+     *  @brief  %List copy constructor.\n+     *  @param  x  A %list of identical element and allocator types.\n+     * \n+     *  The newly-created %list uses a copy of the allocation object used\n+     *  by @a x.\n+    */\n+    list(const list& __x)\n+      : _Base(__x.get_allocator())\n+      { this->insert(begin(), __x.begin(), __x.end()); }\n+  \n+    /**\n+     *  @brief  Builds a %list from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     * \n+     *  Create a %list consisting of copies of the elements from [first,last).\n+     *  This is linear in N (where N is distance(first,last)).\n+     *\n+     *  @if maint\n+     *  We don't need any dispatching tricks here, because insert does all of\n+     *  that anyway.\n+     *  @endif\n+    */\n+    template<typename _InputIterator>\n+      list(_InputIterator __first, _InputIterator __last,\n+           const allocator_type& __a = allocator_type())\n+      : _Base(__a)\n+      { this->insert(begin(), __first, __last); }\n+  \n+    /**\n+     *  The dtor only erases the elements, and note that if the elements\n+     *  themselves are pointers, the pointed-to memory is not touched in any\n+     *  way.  Managing the pointer is the user's responsibilty.\n+    */\n+    ~list() { }\n+  \n+    /**\n+     *  @brief  %List assignment operator.\n+     *  @param  x  A %list of identical element and allocator types.\n+     * \n+     *  All the elements of @a x are copied, but unlike the copy constructor,\n+     *  the allocator object is not copied.\n+    */\n+    list&\n+    operator=(const list& __x);\n+  \n+    /**\n+     *  @brief  Assigns a given value to a %list.\n+     *  @param  n  Number of elements to be assigned.\n+     *  @param  val  Value to be assigned.\n+     *\n+     *  This function fills a %list with @a n copies of the given value.\n+     *  Note that the assignment completely changes the %list and that the\n+     *  resulting %list's size is the same as the number of elements assigned.\n+     *  Old data may be lost.\n+    */\n     void\n-    remove_if(_Predicate);\n-\n-  /**\n-   *  @doctodo\n-  */\n-  void\n-  unique();\n-\n-  /**\n-   *  @doctodo\n-  */\n-  template<typename _BinaryPredicate>\n+    assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n+  \n+    /**\n+     *  @brief  Assigns a range to a %list.\n+     *  @param  first  An input iterator.\n+     *  @param  last   An input iterator.\n+     *\n+     *  This function fills a %list with copies of the elements in the\n+     *  range [first,last).\n+     *\n+     *  Note that the assignment completely changes the %list and that the\n+     *  resulting %list's size is the same as the number of elements assigned.\n+     *  Old data may be lost.\n+    */\n+    template<typename _InputIterator>\n+      void\n+      assign(_InputIterator __first, _InputIterator __last)\n+      {\n+        // Check whether it's an integral type.  If so, it's not an iterator.\n+        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+        _M_assign_dispatch(__first, __last, _Integral());\n+      }\n+  \n+    /// Get a copy of the memory allocation object.\n+    allocator_type\n+    get_allocator() const { return _Base::get_allocator(); }\n+  \n+    // iterators\n+    /**\n+     *  Returns a read/write iterator that points to the first element in the\n+     *  %list.  Iteration is done in ordinary element order.\n+    */\n+    iterator\n+    begin() { return static_cast<_Node*>(_M_node->_M_next); }\n+  \n+    /**\n+     *  Returns a read-only (constant) iterator that points to the first element\n+     *  in the %list.  Iteration is done in ordinary element order.\n+    */\n+    const_iterator\n+    begin() const { return static_cast<_Node*>(_M_node->_M_next); }\n+  \n+    /**\n+     *  Returns a read/write iterator that points one past the last element in\n+     *  the %list.  Iteration is done in ordinary element order.\n+    */\n+    iterator\n+    end() { return _M_node; }\n+  \n+    /**\n+     *  Returns a read-only (constant) iterator that points one past the last\n+     *  element in the %list.  Iteration is done in ordinary element order.\n+    */\n+    const_iterator\n+    end() const { return _M_node; }\n+  \n+    /**\n+     *  Returns a read/write reverse iterator that points to the last element in\n+     *  the %list.  Iteration is done in reverse element order.\n+    */\n+    reverse_iterator\n+    rbegin() { return reverse_iterator(end()); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reverse iterator that points to the last\n+     *  element in the %list.  Iteration is done in reverse element order.\n+    */\n+    const_reverse_iterator\n+    rbegin() const { return const_reverse_iterator(end()); }\n+  \n+    /**\n+     *  Returns a read/write reverse iterator that points to one before the\n+     *  first element in the %list.  Iteration is done in reverse element\n+     *  order.\n+    */\n+    reverse_iterator\n+    rend() { return reverse_iterator(begin()); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reverse iterator that points to one\n+     *  before the first element in the %list.  Iteration is done in reverse\n+     *  element order.\n+    */\n+    const_reverse_iterator\n+    rend() const\n+    { return const_reverse_iterator(begin()); }\n+  \n+    // [23.2.2.2] capacity\n+    /**\n+     *  Returns true if the %list is empty.  (Thus begin() would equal end().)\n+    */\n+    bool\n+    empty() const { return _M_node->_M_next == _M_node; }\n+  \n+    /**  Returns the number of elements in the %list.  */\n+    size_type\n+    size() const { return distance(begin(), end()); }\n+  \n+    /**  Returns the size() of the largest possible %list.  */\n+    size_type\n+    max_size() const { return size_type(-1); }\n+  \n+    /**\n+     *  @brief  Resizes the %list to the specified number of elements.\n+     *  @param  new_size  Number of elements the %list should contain.\n+     *  @param  x  Data with which new elements should be populated.\n+     *\n+     *  This function will %resize the %list to the specified number of\n+     *  elements.  If the number is smaller than the %list's current size the\n+     *  %list is truncated, otherwise the %list is extended and new elements\n+     *  are populated with given data.\n+    */\n     void\n-    unique(_BinaryPredicate);\n-\n-  /**\n-   *  @doctodo\n-  */\n-  void\n-  merge(list& __x);\n-\n-  /**\n-   *  @doctodo\n-  */\n-  template<typename _StrictWeakOrdering>\n+    resize(size_type __new_size, const value_type& __x);\n+  \n+    /**\n+     *  @brief  Resizes the %list to the specified number of elements.\n+     *  @param  new_size  Number of elements the %list should contain.\n+     *\n+     *  This function will resize the %list to the specified number of\n+     *  elements.  If the number is smaller than the %list's current size the\n+     *  %list is truncated, otherwise the %list is extended and new elements\n+     *  are default-constructed.\n+    */\n     void\n-    merge(list&, _StrictWeakOrdering);\n-\n-  /**\n-   *  @doctodo\n-  */\n-  void\n-  reverse() { __List_base_reverse(this->_M_node); }\n-\n-  /**\n-   *  @doctodo\n-  */\n-  void\n-  sort();\n-\n-  /**\n-   *  @doctodo\n-  */\n-  template<typename _StrictWeakOrdering>\n+    resize(size_type __new_size) { this->resize(__new_size, value_type()); }\n+  \n+    // element access\n+    /**\n+     *  Returns a read/write reference to the data at the first element of the\n+     *  %list.\n+    */\n+    reference\n+    front() { return *begin(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reference to the data at the first\n+     *  element of the %list.\n+    */\n+    const_reference\n+    front() const { return *begin(); }\n+  \n+    /**\n+     *  Returns a read/write reference to the data at the last element of the\n+     *  %list.\n+    */\n+    reference\n+    back() { return *(--end()); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reference to the data at the last\n+     *  element of the %list.\n+    */\n+    const_reference\n+    back() const { return *(--end()); }\n+  \n+    // [23.2.2.3] modifiers\n+    /**\n+     *  @brief  Add data to the front of the %list.\n+     *  @param  x  Data to be added.\n+     *\n+     *  This is a typical stack operation.  The function creates an element at\n+     *  the front of the %list and assigns the given data to it.  Due to the\n+     *  nature of a %list this operation can be done in constant time, and\n+     *  does not invalidate iterators and references.\n+    */\n     void\n-    sort(_StrictWeakOrdering);\n-\n-protected:\n-  // Internal assign functions follow.\n-\n-  // called by the range assign to implement [23.1.1]/9\n-  template<typename _Integer>\n+    push_front(const value_type& __x) { this->insert(begin(), __x); }\n+  \n+  #ifdef _GLIBCPP_DEPRECATED\n+    /**\n+     *  @brief  Add data to the front of the %list.\n+     *\n+     *  This is a typical stack operation.  The function creates a\n+     *  default-constructed element at the front of the %list.  Due to the\n+     *  nature of a %list this operation can be done in constant time.  You\n+     *  should consider using push_front(value_type()) instead.\n+     *\n+     *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n+     *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+     *        c++config.h.\n+    */\n     void\n-    _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+    push_front() { this->insert(begin(), value_type()); }\n+  #endif\n+  \n+    /**\n+     *  @brief  Removes first element.\n+     *\n+     *  This is a typical stack operation.  It shrinks the %list by one.\n+     *  Due to the nature of a %list this operation can be done in constant\n+     *  time, and only invalidates iterators/references to the element being\n+     *  removed.\n+     *\n+     *  Note that no data is returned, and if the first element's data is\n+     *  needed, it should be retrieved before pop_front() is called.\n+    */\n+    void\n+    pop_front() { this->erase(begin()); }\n+  \n+    /**\n+     *  @brief  Add data to the end of the %list.\n+     *  @param  x  Data to be added.\n+     *\n+     *  This is a typical stack operation.  The function creates an element at\n+     *  the end of the %list and assigns the given data to it.  Due to the\n+     *  nature of a %list this operation can be done in constant time, and\n+     *  does not invalidate iterators and references.\n+    */\n+    void\n+    push_back(const value_type& __x) { this->insert(end(), __x); }\n+  \n+  #ifdef _GLIBCPP_DEPRECATED\n+    /**\n+     *  @brief  Add data to the end of the %list.\n+     *\n+     *  This is a typical stack operation.  The function creates a\n+     *  default-constructed element at the end of the %list.  Due to the nature\n+     *  of a %list this operation can be done in constant time.  You should\n+     *  consider using push_back(value_type()) instead.\n+     *\n+     *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n+     *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+     *        c++config.h.\n+    */\n+    void\n+    push_back() { this->insert(end(), value_type()); }\n+  #endif\n+  \n+    /**\n+     *  @brief  Removes last element.\n+     *\n+     *  This is a typical stack operation.  It shrinks the %list by one.\n+     *  Due to the nature of a %list this operation can be done in constant\n+     *  time, and only invalidates iterators/references to the element being\n+     *  removed.\n+     *\n+     *  Note that no data is returned, and if the last element's data is\n+     *  needed, it should be retrieved before pop_back() is called.\n+    */\n+    void\n+    pop_back()\n     {\n-      _M_fill_assign(static_cast<size_type>(__n),\n-                     static_cast<value_type>(__val));\n+      iterator __tmp = end();\n+      this->erase(--__tmp);\n     }\n-\n-  // called by the range assign to implement [23.1.1]/9\n-  template<typename _InputIter>\n+  \n+    /**\n+     *  @brief  Inserts given value into %list before specified iterator.\n+     *  @param  position  An iterator into the %list.\n+     *  @param  x  Data to be inserted.\n+     *  @return  An iterator that points to the inserted data.\n+     *\n+     *  This function will insert a copy of the given value before the specified\n+     *  location.\n+     *  Due to the nature of a %list this operation can be done in constant\n+     *  time, and does not invalidate iterators and references.\n+    */\n+    iterator\n+    insert(iterator __position, const value_type& __x);\n+  \n+  #ifdef _GLIBCPP_DEPRECATED\n+    /**\n+     *  @brief  Inserts an element into the %list.\n+     *  @param  position  An iterator into the %list.\n+     *  @return  An iterator that points to the inserted element.\n+     *\n+     *  This function will insert a default-constructed element before the\n+     *  specified location.  You should consider using\n+     *  insert(position,value_type()) instead.\n+     *  Due to the nature of a %list this operation can be done in constant\n+     *  time, and does not invalidate iterators and references.\n+     *\n+     *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n+     *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+     *        c++config.h.\n+    */\n+    iterator\n+    insert(iterator __position) { return insert(__position, value_type()); }\n+  #endif\n+  \n+    /**\n+     *  @brief  Inserts a number of copies of given data into the %list.\n+     *  @param  position  An iterator into the %list.\n+     *  @param  n  Number of elements to be inserted.\n+     *  @param  x  Data to be inserted.\n+     *\n+     *  This function will insert a specified number of copies of the given data\n+     *  before the location specified by @a position.\n+     *\n+     *  Due to the nature of a %list this operation can be done in constant\n+     *  time, and does not invalidate iterators and references.\n+    */\n     void\n-    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type);\n-\n-  // Called by assign(n,t), and the range assign when it turns out to be the\n-  // same thing.\n-  void\n-  _M_fill_assign(size_type __n, const value_type& __val);\n-\n-\n-  // Internal insert functions follow.\n-\n-  // called by the range insert to implement [23.1.1]/9\n-  template<typename _Integer>\n+    insert(iterator __pos, size_type __n, const value_type& __x)\n+      { _M_fill_insert(__pos, __n, __x); }\n+  \n+    /**\n+     *  @brief  Inserts a range into the %list.\n+     *  @param  pos  An iterator into the %list.\n+     *  @param  first  An input iterator.\n+     *  @param  last   An input iterator.\n+     *\n+     *  This function will insert copies of the data in the range [first,last)\n+     *  into the %list before the location specified by @a pos.\n+     *\n+     *  Due to the nature of a %list this operation can be done in constant\n+     *  time, and does not invalidate iterators and references.\n+    */\n+    template<typename _InputIterator>\n+      void\n+      insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+      {\n+        // Check whether it's an integral type.  If so, it's not an iterator.\n+        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+        _M_insert_dispatch(__pos, __first, __last, _Integral());\n+      }\n+  \n+    /**\n+     *  @brief  Remove element at given position.\n+     *  @param  position  Iterator pointing to element to be erased.\n+     *  @return  An iterator pointing to the next element (or end()).\n+     *\n+     *  This function will erase the element at the given position and thus\n+     *  shorten the %list by one.\n+     *\n+     *  Due to the nature of a %list this operation can be done in constant\n+     *  time, and only invalidates iterators/references to the element being\n+     *  removed.\n+     *  The user is also cautioned that\n+     *  this function only erases the element, and that if the element is itself\n+     *  a pointer, the pointed-to memory is not touched in any way.  Managing\n+     *  the pointer is the user's responsibilty.\n+    */\n+    iterator\n+    erase(iterator __position);\n+  \n+    /**\n+     *  @brief  Remove a range of elements.\n+     *  @param  first  Iterator pointing to the first element to be erased.\n+     *  @param  last  Iterator pointing to one past the last element to be\n+     *                erased.\n+     *  @return  An iterator pointing to the element pointed to by @a last\n+     *           prior to erasing (or end()).\n+     *\n+     *  This function will erase the elements in the range [first,last) and\n+     *  shorten the %list accordingly.\n+     *\n+     *  Due to the nature of a %list this operation can be done in constant\n+     *  time, and only invalidates iterators/references to the element being\n+     *  removed.\n+     *  The user is also cautioned that\n+     *  this function only erases the elements, and that if the elements\n+     *  themselves are pointers, the pointed-to memory is not touched in any\n+     *  way.  Managing the pointer is the user's responsibilty.\n+    */\n+    iterator\n+    erase(iterator __first, iterator __last)\n+    {\n+      while (__first != __last)\n+        erase(__first++);\n+      return __last;\n+    }\n+  \n+    /**\n+     *  @brief  Swaps data with another %list.\n+     *  @param  x  A %list of the same element and allocator types.\n+     *\n+     *  This exchanges the elements between two lists in constant time.\n+     *  (It is only swapping a single pointer, so it should be quite fast.)\n+     *  Note that the global std::swap() function is specialized such that\n+     *  std::swap(l1,l2) will feed to this function.\n+    */\n     void\n-    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)\n+    swap(list& __x) { std::swap(_M_node, __x._M_node); }\n+  \n+    /**\n+     *  Erases all the elements.  Note that this function only erases the\n+     *  elements, and that if the elements themselves are pointers, the\n+     *  pointed-to memory is not touched in any way.  Managing the pointer is\n+     *  the user's responsibilty.\n+    */\n+    void\n+    clear() { _Base::__clear(); }\n+  \n+    // [23.2.2.4] list operations\n+    /**\n+     *  @doctodo\n+    */\n+    void\n+    splice(iterator __position, list& __x)\n     {\n-      _M_fill_insert(__pos, static_cast<size_type>(__n),\n-                     static_cast<value_type>(__x));\n+      if (!__x.empty())\n+        this->_M_transfer(__position, __x.begin(), __x.end());\n     }\n-\n-  // called by the range insert to implement [23.1.1]/9\n-  template<typename _InputIterator>\n+  \n+    /**\n+     *  @doctodo\n+    */\n     void\n-    _M_insert_dispatch(iterator __pos,\n-                       _InputIterator __first, _InputIterator __last,\n-                       __false_type)\n+    splice(iterator __position, list&, iterator __i)\n     {\n-      for ( ; __first != __last; ++__first)\n-        insert(__pos, *__first);\n+      iterator __j = __i;\n+      ++__j;\n+      if (__position == __i || __position == __j) return;\n+      this->_M_transfer(__position, __i, __j);\n     }\n-\n-  // Called by insert(p,n,x), and the range insert when it turns out to be\n-  // the same thing.\n-  void\n-  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n-  {\n-    for ( ; __n > 0; --__n)\n-      insert(__pos, __x);\n-  }\n-\n-\n-  // Moves the elements from [first,last) before position.\n-  void\n-  _M_transfer(iterator __position, iterator __first, iterator __last)\n-  {\n-    if (__position != __last) {\n-      // Remove [first, last) from its old position.\n-      __last._M_node->_M_prev->_M_next     = __position._M_node;\n-      __first._M_node->_M_prev->_M_next    = __last._M_node;\n-      __position._M_node->_M_prev->_M_next = __first._M_node;\n-\n-      // Splice [first, last) into its new position.\n-      _List_node_base* __tmp      = __position._M_node->_M_prev;\n-      __position._M_node->_M_prev = __last._M_node->_M_prev;\n-      __last._M_node->_M_prev     = __first._M_node->_M_prev;\n-      __first._M_node->_M_prev    = __tmp;\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    void\n+    splice(iterator __position, list&, iterator __first, iterator __last)\n+    {\n+      if (__first != __last)\n+        this->_M_transfer(__position, __first, __last);\n     }\n-  }\n-};\n-\n-\n-/**\n- *  @brief  List equality comparison.\n- *  @param  x  A %list.\n- *  @param  y  A %list of the same type as @a x.\n- *  @return  True iff the size and elements of the lists are equal.\n- *\n- *  This is an equivalence relation.  It is linear in the size of the\n- *  lists.  Lists are considered equivalent if their sizes are equal,\n- *  and if corresponding elements compare equal.\n-*/\n-template<typename _Tp, typename _Alloc>\n-inline bool\n-  operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-  {\n-    typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n-    const_iterator __end1 = __x.end();\n-    const_iterator __end2 = __y.end();\n-\n-    const_iterator __i1 = __x.begin();\n-    const_iterator __i2 = __y.begin();\n-    while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n-      ++__i1;\n-      ++__i2;\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    void\n+    remove(const _Tp& __value);\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    template<typename _Predicate>\n+      void\n+      remove_if(_Predicate);\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    void\n+    unique();\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    template<typename _BinaryPredicate>\n+      void\n+      unique(_BinaryPredicate);\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    void\n+    merge(list& __x);\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    template<typename _StrictWeakOrdering>\n+      void\n+      merge(list&, _StrictWeakOrdering);\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    void\n+    reverse() { __List_base_reverse(this->_M_node); }\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    void\n+    sort();\n+  \n+    /**\n+     *  @doctodo\n+    */\n+    template<typename _StrictWeakOrdering>\n+      void\n+      sort(_StrictWeakOrdering);\n+  \n+  protected:\n+    // Internal assign functions follow.\n+  \n+    // called by the range assign to implement [23.1.1]/9\n+    template<typename _Integer>\n+      void\n+      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+      {\n+        _M_fill_assign(static_cast<size_type>(__n),\n+                       static_cast<value_type>(__val));\n+      }\n+  \n+    // called by the range assign to implement [23.1.1]/9\n+    template<typename _InputIter>\n+      void\n+      _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type);\n+  \n+    // Called by assign(n,t), and the range assign when it turns out to be the\n+    // same thing.\n+    void\n+    _M_fill_assign(size_type __n, const value_type& __val);\n+  \n+  \n+    // Internal insert functions follow.\n+  \n+    // called by the range insert to implement [23.1.1]/9\n+    template<typename _Integer>\n+      void\n+      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n+                         __true_type)\n+      {\n+        _M_fill_insert(__pos, static_cast<size_type>(__n),\n+                       static_cast<value_type>(__x));\n+      }\n+  \n+    // called by the range insert to implement [23.1.1]/9\n+    template<typename _InputIterator>\n+      void\n+      _M_insert_dispatch(iterator __pos,\n+                         _InputIterator __first, _InputIterator __last,\n+                         __false_type)\n+      {\n+        for ( ; __first != __last; ++__first)\n+          insert(__pos, *__first);\n+      }\n+  \n+    // Called by insert(p,n,x), and the range insert when it turns out to be\n+    // the same thing.\n+    void\n+    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n+    {\n+      for ( ; __n > 0; --__n)\n+        insert(__pos, __x);\n     }\n-    return __i1 == __end1 && __i2 == __end2;\n-  }\n-\n-/**\n- *  @brief  List ordering relation.\n- *  @param  x  A %list.\n- *  @param  y  A %list of the same type as @a x.\n- *  @return  True iff @a x is lexographically less than @a y.\n- *\n- *  This is a total ordering relation.  It is linear in the size of the\n- *  lists.  The elements must be comparable with @c <.\n- *\n- *  See std::lexographical_compare() for how the determination is made.\n-*/\n-template<typename _Tp, typename _Alloc>\n-  inline bool\n-  operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-  {\n-    return lexicographical_compare(__x.begin(), __x.end(),\n-                                   __y.begin(), __y.end());\n-  }\n-\n-/// Based on operator==\n-template<typename _Tp, typename _Alloc>\n-  inline bool\n-  operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-  { return !(__x == __y); }\n-\n-/// Based on operator<\n-template<typename _Tp, typename _Alloc>\n-  inline bool\n-  operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-  { return __y < __x; }\n-\n-/// Based on operator<\n-template<typename _Tp, typename _Alloc>\n-  inline bool\n-  operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-  { return !(__y < __x); }\n-\n-/// Based on operator<\n-template<typename _Tp, typename _Alloc>\n+  \n+  \n+    // Moves the elements from [first,last) before position.\n+    void\n+    _M_transfer(iterator __position, iterator __first, iterator __last)\n+    {\n+      if (__position != __last) {\n+        // Remove [first, last) from its old position.\n+        __last._M_node->_M_prev->_M_next     = __position._M_node;\n+        __first._M_node->_M_prev->_M_next    = __last._M_node;\n+        __position._M_node->_M_prev->_M_next = __first._M_node;\n+  \n+        // Splice [first, last) into its new position.\n+        _List_node_base* __tmp      = __position._M_node->_M_prev;\n+        __position._M_node->_M_prev = __last._M_node->_M_prev;\n+        __last._M_node->_M_prev     = __first._M_node->_M_prev;\n+        __first._M_node->_M_prev    = __tmp;\n+      }\n+    }\n+  };\n+  \n+  \n+  /**\n+   *  @brief  List equality comparison.\n+   *  @param  x  A %list.\n+   *  @param  y  A %list of the same type as @a x.\n+   *  @return  True iff the size and elements of the lists are equal.\n+   *\n+   *  This is an equivalence relation.  It is linear in the size of the\n+   *  lists.  Lists are considered equivalent if their sizes are equal,\n+   *  and if corresponding elements compare equal.\n+  */\n+  template<typename _Tp, typename _Alloc>\n   inline bool\n-  operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-  { return !(__x < __y); }\n-\n-/// See std::list::swap().\n-template<typename _Tp, typename _Alloc>\n-  inline void\n-  swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n-  { __x.swap(__y); }\n-\n+    operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    {\n+      typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n+      const_iterator __end1 = __x.end();\n+      const_iterator __end2 = __y.end();\n+  \n+      const_iterator __i1 = __x.begin();\n+      const_iterator __i2 = __y.begin();\n+      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n+        ++__i1;\n+        ++__i2;\n+      }\n+      return __i1 == __end1 && __i2 == __end2;\n+    }\n+  \n+  /**\n+   *  @brief  List ordering relation.\n+   *  @param  x  A %list.\n+   *  @param  y  A %list of the same type as @a x.\n+   *  @return  True iff @a x is lexographically less than @a y.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  lists.  The elements must be comparable with @c <.\n+   *\n+   *  See std::lexographical_compare() for how the determination is made.\n+  */\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    {\n+      return lexicographical_compare(__x.begin(), __x.end(),\n+                                     __y.begin(), __y.end());\n+    }\n+  \n+  /// Based on operator==\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    { return !(__x == __y); }\n+  \n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    { return __y < __x; }\n+  \n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    { return !(__y < __x); }\n+  \n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    { return !(__x < __y); }\n+  \n+  /// See std::list::swap().\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n+    { __x.swap(__y); }\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_LIST_H */\n-"}, {"sha": "bf86ecedbe6c6108871fdeb511c7a58254e9f095", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 580, "deletions": 584, "changes": 1164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -63,603 +63,599 @@\n \n #include <bits/concept_check.h>\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-\n-/**\n- *  @brief A standard container made up of (key,value) pairs, which can be\n- *  retrieved based on a key, in logarithmic time.\n- *\n- *  @ingroup Containers\n- *  @ingroup Assoc_containers\n- *\n- *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n- *  <a href=\"tables.html#66\">reversible container</a>, and an\n- *  <a href=\"tables.html#69\">associative container</a> (using unique keys).\n- *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the\n- *  value_type is std::pair<const Key,T>.\n- *\n- *  Maps support bidirectional iterators.\n- *\n- *  @if maint\n- *  The private tree data is declared exactly the same way for map and\n- *  multimap; the distinction is made entirely in how the tree functions are\n- *  called (*_unique versus *_equal, same as the standard).\n- *  @endif\n-*/\n-template <typename _Key, typename _Tp, typename _Compare = less<_Key>,\n-          typename _Alloc = allocator<pair<const _Key, _Tp> > >\n-  class map\n-{\n-  // concept requirements\n-  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n-\n-public:\n-  typedef _Key                                          key_type;\n-  typedef _Tp                                           mapped_type;\n-  typedef pair<const _Key, _Tp>                         value_type;\n-  typedef _Compare                                      key_compare;\n-\n-  class value_compare\n-    : public binary_function<value_type, value_type, bool>\n-    {\n-      friend class map<_Key,_Tp,_Compare,_Alloc>;\n-    protected:\n-      _Compare comp;\n-      value_compare(_Compare __c) : comp(__c) {}\n-    public:\n-      bool operator()(const value_type& __x, const value_type& __y) const\n-        { return comp(__x.first, __y.first); }\n-    };\n-\n-private:\n-  /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n-  typedef _Rb_tree<key_type, value_type,\n-                   _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n-  /// @if maint  The actual tree structure.  @endif\n-  _Rep_type _M_t;\n-\n-public:\n-  // many of these are specified differently in ISO, but the following are\n-  // \"functionally equivalent\"\n-  typedef typename _Rep_type::allocator_type            allocator_type;\n-  typedef typename _Rep_type::reference                 reference;\n-  typedef typename _Rep_type::const_reference           const_reference;\n-  typedef typename _Rep_type::iterator                  iterator;\n-  typedef typename _Rep_type::const_iterator            const_iterator;\n-  typedef typename _Rep_type::size_type                 size_type;\n-  typedef typename _Rep_type::difference_type           difference_type;\n-  typedef typename _Rep_type::pointer                   pointer;\n-  typedef typename _Rep_type::const_pointer             const_pointer;\n-  typedef typename _Rep_type::reverse_iterator          reverse_iterator;\n-  typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n-\n-\n-  // [23.3.1.1] construct/copy/destroy\n-  // (get_allocator() is normally listed in this section, but seems to have\n-  // been accidentally omitted in the printed standard)\n-  /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  map() : _M_t(_Compare(), allocator_type()) { }\n-\n-  // for some reason this was made a separate function\n   /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  explicit\n-  map(const _Compare& __comp, const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { }\n-\n-  /**\n-   *  @brief  Map copy constructor.\n-   *  @param  x  A %map of identical element and allocator types.\n+   *  @brief A standard container made up of (key,value) pairs, which can be\n+   *  retrieved based on a key, in logarithmic time.\n    *\n-   *  The newly-created %map uses a copy of the allocation object used\n-   *  by @a x.\n-  */\n-  map(const map& __x)\n-    : _M_t(__x._M_t) { }\n-\n-  /**\n-   *  @brief  Builds a %map from a range.\n-   *  @param  first  An input iterator.\n-   *  @param  last  An input iterator.\n-   *\n-   *  Create a %map consisting of copies of the elements from [first,last).\n-   *  This is linear in N if the range is already sorted, and NlogN\n-   *  otherwise (where N is distance(first,last)).\n-  */\n-  template <typename _InputIterator>\n-    map(_InputIterator __first, _InputIterator __last)\n-    : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_unique(__first, __last); }\n-\n-  /**\n-   *  @brief  Builds a %map from a range.\n-   *  @param  first  An input iterator.\n-   *  @param  last  An input iterator.\n-   *  @param  comp  A comparison functor.\n-   *  @param  a  An allocator object.\n-   *\n-   *  Create a %map consisting of copies of the elements from [first,last).\n-   *  This is linear in N if the range is already sorted, and NlogN\n-   *  otherwise (where N is distance(first,last)).\n-  */\n-  template <typename _InputIterator>\n-    map(_InputIterator __first, _InputIterator __last,\n-        const _Compare& __comp, const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a)\n-    { _M_t.insert_unique(__first, __last); }\n-\n-  // FIXME There is no dtor declared, but we should have something generated\n-  // by Doxygen.  I don't know what tags to add to this paragraph to make\n-  // that happen:\n-  /**\n-   *  The dtor only erases the elements, and note that if the elements\n-   *  themselves are pointers, the pointed-to memory is not touched in any\n-   *  way.  Managing the pointer is the user's responsibilty.\n-  */\n-\n-  /**\n-   *  @brief  Map assignment operator.\n-   *  @param  x  A %map of identical element and allocator types.\n+   *  @ingroup Containers\n+   *  @ingroup Assoc_containers\n    *\n-   *  All the elements of @a x are copied, but unlike the copy constructor, the\n-   *  allocator object is not copied.\n-  */\n-  map&\n-  operator=(const map& __x)\n-  {\n-    _M_t = __x._M_t;\n-    return *this;\n-  }\n-\n-  /// Get a copy of the memory allocation object.\n-  allocator_type\n-  get_allocator() const { return _M_t.get_allocator(); }\n-\n-  // iterators\n-  /**\n-   *  Returns a read/write iterator that points to the first pair in the %map.\n-   *  Iteration is done in ascending order according to the keys.\n-  */\n-  iterator\n-  begin() { return _M_t.begin(); }\n-\n-  /**\n-   *  Returns a read-only (constant) iterator that points to the first pair\n-   *  in the %map.  Iteration is done in ascending order according to the keys.\n-  */\n-  const_iterator\n-  begin() const { return _M_t.begin(); }\n-\n-  /**\n-   *  Returns a read/write iterator that points one past the last pair in the\n-   *  %map.  Iteration is done in ascending order according to the keys.\n-  */\n-  iterator\n-  end() { return _M_t.end(); }\n-\n-  /**\n-   *  Returns a read-only (constant) iterator that points one past the last\n-   *  pair in the %map.  Iteration is done in ascending order according to the\n-   *  keys.\n-  */\n-  const_iterator\n-  end() const { return _M_t.end(); }\n-\n-  /**\n-   *  Returns a read/write reverse iterator that points to the last pair in\n-   *  the %map.  Iteration is done in descending order according to the keys.\n-  */\n-  reverse_iterator\n-  rbegin() { return _M_t.rbegin(); }\n-\n-  /**\n-   *  Returns a read-only (constant) reverse iterator that points to the last\n-   *  pair in the %map.  Iteration is done in descending order according to\n-   *  the keys.\n-  */\n-  const_reverse_iterator\n-  rbegin() const { return _M_t.rbegin(); }\n-\n-  /**\n-   *  Returns a read/write reverse iterator that points to one before the\n-   *  first pair in the %map.  Iteration is done in descending order according\n-   *  to the keys.\n-  */\n-  reverse_iterator\n-  rend() { return _M_t.rend(); }\n-\n-  /**\n-   *  Returns a read-only (constant) reverse iterator that points to one\n-   *  before the first pair in the %map.  Iteration is done in descending order\n-   *  according to the keys.\n-  */\n-  const_reverse_iterator\n-  rend() const { return _M_t.rend(); }\n-\n-  // capacity\n-  /** Returns true if the %map is empty.  (Thus begin() would equal end().)  */\n-  bool\n-  empty() const { return _M_t.empty(); }\n-\n-  /** Returns the size of the %map.  */\n-  size_type\n-  size() const { return _M_t.size(); }\n-\n-  /** Returns the maximum size of the %map.  */\n-  size_type\n-  max_size() const { return _M_t.max_size(); }\n-\n-  // [23.3.1.2] element access\n-  /**\n-   *  @brief  Subscript ( @c [] ) access to %map data.\n-   *  @param  k  The key for which data should be retrieved.\n-   *  @return  A reference to the data of the (key,data) %pair.\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and an\n+   *  <a href=\"tables.html#69\">associative container</a> (using unique keys).\n+   *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the\n+   *  value_type is std::pair<const Key,T>.\n    *\n-   *  Allows for easy lookup with the subscript ( @c [] ) operator.  Returns\n-   *  data associated with the key specified in subscript.  If the key does\n-   *  not exist, a pair with that key is created using default values, which\n-   *  is then returned.\n+   *  Maps support bidirectional iterators.\n    *\n-   *  Lookup requires logarithmic time.\n-  */\n-  mapped_type&\n-  operator[](const key_type& __k)\n+   *  @if maint\n+   *  The private tree data is declared exactly the same way for map and\n+   *  multimap; the distinction is made entirely in how the tree functions are\n+   *  called (*_unique versus *_equal, same as the standard).\n+   *  @endif\n+  */\n+  template <typename _Key, typename _Tp, typename _Compare = less<_Key>,\n+            typename _Alloc = allocator<pair<const _Key, _Tp> > >\n+    class map\n   {\n     // concept requirements\n-    __glibcpp_function_requires(_DefaultConstructibleConcept<mapped_type>)\n-\n-    iterator __i = lower_bound(__k);\n-    // __i->first is greater than or equivalent to __k.\n-    if (__i == end() || key_comp()(__k, (*__i).first))\n-      __i = insert(__i, value_type(__k, mapped_type()));\n-    return (*__i).second;\n-  }\n-\n-  // modifiers\n-  /**\n-   *  @brief Attempts to insert a std::pair into the %map.\n-   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n-   *             pairs).\n-   *  @return  A pair, of which the first element is an iterator that points\n-   *           to the possibly inserted pair, and the second is a bool that\n-   *           is true if the pair was actually inserted.\n-   *\n-   *  This function attempts to insert a (key, value) %pair into the %map.  A\n-   *  %map relies on unique keys and thus a %pair is only inserted if its first\n-   *  element (the key) is not already present in the %map.\n-   *\n-   *  Insertion requires logarithmic time.\n-  */\n-  pair<iterator,bool>\n-  insert(const value_type& __x)\n-    { return _M_t.insert_unique(__x); }\n-\n-  /**\n-   *  @brief Attempts to insert a std::pair into the %map.\n-   *  @param  position  An iterator that serves as a hint as to where the\n-   *                    pair should be inserted.\n-   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n-   *             pairs).\n-   *  @return  An iterator that points to the element with key of @a x (may\n-   *           or may not be the %pair passed in).\n-   *\n-   *  This function is not concerned about whether the insertion took place,\n-   *  and thus does not return a boolean like the single-argument\n-   *  insert() does.  Note that the first parameter is only a hint and can\n-   *  potentially improve the performance of the insertion process.  A bad\n-   *  hint would cause no gains in efficiency.\n-   *\n-   *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n-   *  for more on \"hinting\".\n-   *\n-   *  Insertion requires logarithmic time (if the hint is not taken).\n-  */\n-  iterator\n-  insert(iterator position, const value_type& __x)\n-    { return _M_t.insert_unique(position, __x); }\n-\n-  /**\n-   *  @brief A template function that attemps to insert a range of elements.\n-   *  @param  first  Iterator pointing to the start of the range to be inserted.\n-   *  @param  last  Iterator pointing to the end of the range.\n-   *\n-   *  Complexity similar to that of the range constructor.\n-  */\n-  template <typename _InputIterator>\n-    void\n-    insert(_InputIterator __first, _InputIterator __last)\n+    __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+    __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n+  \n+  public:\n+    typedef _Key                                          key_type;\n+    typedef _Tp                                           mapped_type;\n+    typedef pair<const _Key, _Tp>                         value_type;\n+    typedef _Compare                                      key_compare;\n+  \n+    class value_compare\n+      : public binary_function<value_type, value_type, bool>\n+      {\n+        friend class map<_Key,_Tp,_Compare,_Alloc>;\n+      protected:\n+        _Compare comp;\n+        value_compare(_Compare __c) : comp(__c) {}\n+      public:\n+        bool operator()(const value_type& __x, const value_type& __y) const\n+          { return comp(__x.first, __y.first); }\n+      };\n+  \n+  private:\n+    /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n+    typedef _Rb_tree<key_type, value_type,\n+                     _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n+    /// @if maint  The actual tree structure.  @endif\n+    _Rep_type _M_t;\n+  \n+  public:\n+    // many of these are specified differently in ISO, but the following are\n+    // \"functionally equivalent\"\n+    typedef typename _Rep_type::allocator_type            allocator_type;\n+    typedef typename _Rep_type::reference                 reference;\n+    typedef typename _Rep_type::const_reference           const_reference;\n+    typedef typename _Rep_type::iterator                  iterator;\n+    typedef typename _Rep_type::const_iterator            const_iterator;\n+    typedef typename _Rep_type::size_type                 size_type;\n+    typedef typename _Rep_type::difference_type           difference_type;\n+    typedef typename _Rep_type::pointer                   pointer;\n+    typedef typename _Rep_type::const_pointer             const_pointer;\n+    typedef typename _Rep_type::reverse_iterator          reverse_iterator;\n+    typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n+  \n+  \n+    // [23.3.1.1] construct/copy/destroy\n+    // (get_allocator() is normally listed in this section, but seems to have\n+    // been accidentally omitted in the printed standard)\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    map() : _M_t(_Compare(), allocator_type()) { }\n+  \n+    // for some reason this was made a separate function\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    explicit\n+    map(const _Compare& __comp, const allocator_type& __a = allocator_type())\n+      : _M_t(__comp, __a) { }\n+  \n+    /**\n+     *  @brief  Map copy constructor.\n+     *  @param  x  A %map of identical element and allocator types.\n+     *\n+     *  The newly-created %map uses a copy of the allocation object used\n+     *  by @a x.\n+    */\n+    map(const map& __x)\n+      : _M_t(__x._M_t) { }\n+  \n+    /**\n+     *  @brief  Builds a %map from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     *\n+     *  Create a %map consisting of copies of the elements from [first,last).\n+     *  This is linear in N if the range is already sorted, and NlogN\n+     *  otherwise (where N is distance(first,last)).\n+    */\n+    template <typename _InputIterator>\n+      map(_InputIterator __first, _InputIterator __last)\n+      : _M_t(_Compare(), allocator_type())\n       { _M_t.insert_unique(__first, __last); }\n-\n-  /**\n-   *  @brief Erases an element from a %map.\n-   *  @param  position  An iterator pointing to the element to be erased.\n-   *\n-   *  This function erases an element, pointed to by the given iterator, from\n-   *  a %map.  Note that this function only erases the element, and that if\n-   *  the element is itself a pointer, the pointed-to memory is not touched\n-   *  in any way.  Managing the pointer is the user's responsibilty.\n-  */\n-  void\n-  erase(iterator __position) { _M_t.erase(__position); }\n-\n-  /**\n-   *  @brief Erases elements according to the provided key.\n-   *  @param  x  Key of element to be erased.\n-   *  @return  The number of elements erased.\n-   *\n-   *  This function erases all the elements located by the given key from\n-   *  a %map.\n-   *  Note that this function only erases the element, and that if\n-   *  the element is itself a pointer, the pointed-to memory is not touched\n-   *  in any way.  Managing the pointer is the user's responsibilty.\n-  */\n-  size_type\n-  erase(const key_type& __x) { return _M_t.erase(__x); }\n-\n-  /**\n-   *  @brief Erases a [first,last) range of elements from a %map.\n-   *  @param  first  Iterator pointing to the start of the range to be erased.\n-   *  @param  last  Iterator pointing to the end of the range to be erased.\n-   *\n-   *  This function erases a sequence of elements from a %map.\n-   *  Note that this function only erases the element, and that if\n-   *  the element is itself a pointer, the pointed-to memory is not touched\n-   *  in any way.  Managing the pointer is the user's responsibilty.\n-  */\n-  void\n-  erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }\n-\n-  /**\n-   *  @brief  Swaps data with another %map.\n-   *  @param  x  A %map of the same element and allocator types.\n-   *\n-   *  This exchanges the elements between two maps in constant time.\n-   *  (It is only swapping a pointer, an integer, and an instance of\n-   *  the @c Compare type (which itself is often stateless and empty), so it\n-   *  should be quite fast.)\n-   *  Note that the global std::swap() function is specialized such that\n-   *  std::swap(m1,m2) will feed to this function.\n-  */\n-  void\n-  swap(map& __x) { _M_t.swap(__x._M_t); }\n-\n-  /**\n-   *  Erases all elements in a %map.  Note that this function only erases\n-   *  the elements, and that if the elements themselves are pointers, the\n-   *  pointed-to memory is not touched in any way.  Managing the pointer is\n-   *  the user's responsibilty.\n-  */\n-  void\n-  clear() { _M_t.clear(); }\n-\n-  // observers\n-  /**\n-   *  Returns the key comparison object out of which the %map was constructed.\n-  */\n-  key_compare\n-  key_comp() const { return _M_t.key_comp(); }\n-\n-  /**\n-   *  Returns a value comparison object, built from the key comparison\n-   *  object out of which the %map was constructed.\n-  */\n-  value_compare\n-  value_comp() const { return value_compare(_M_t.key_comp()); }\n-\n-  // [23.3.1.3] map operations\n-  /**\n-   *  @brief Tries to locate an element in a %map.\n-   *  @param  x  Key of (key, value) %pair to be located.\n-   *  @return  Iterator pointing to sought-after element, or end() if not\n-   *           found.\n-   *\n-   *  This function takes a key and tries to locate the element with which\n-   *  the key matches.  If successful the function returns an iterator\n-   *  pointing to the sought after %pair.  If unsuccessful it returns the\n-   *  past-the-end ( @c end() ) iterator.\n-  */\n-  iterator\n-  find(const key_type& __x) { return _M_t.find(__x); }\n-\n-  /**\n-   *  @brief Tries to locate an element in a %map.\n-   *  @param  x  Key of (key, value) %pair to be located.\n-   *  @return  Read-only (constant) iterator pointing to sought-after\n-   *           element, or end() if not found.\n-   *\n-   *  This function takes a key and tries to locate the element with which\n-   *  the key matches.  If successful the function returns a constant iterator\n-   *  pointing to the sought after %pair. If unsuccessful it returns the\n-   *  past-the-end ( @c end() ) iterator.\n-  */\n-  const_iterator\n-  find(const key_type& __x) const { return _M_t.find(__x); }\n-\n-  /**\n-   *  @brief  Finds the number of elements with given key.\n-   *  @param  x  Key of (key, value) pairs to be located.\n-   *  @return  Number of elements with specified key.\n-   *\n-   *  This function only makes sense for multimaps; for map the result will\n-   *  either be 0 (not present) or 1 (present).\n-  */\n-  size_type\n-  count(const key_type& __x) const\n-    { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n-\n-  /**\n-   *  @brief Finds the beginning of a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Iterator pointing to first element matching given key, or\n-   *           end() if not found.\n-   *\n-   *  This function is useful only with multimaps.  It returns the first\n-   *  element of a subsequence of elements that matches the given key.  If\n-   *  unsuccessful it returns an iterator pointing to the first element that\n-   *  has a greater value than given key or end() if no such element exists.\n-  */\n-  iterator\n-  lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }\n-\n-  /**\n-   *  @brief Finds the beginning of a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Read-only (constant) iterator pointing to first element\n-   *           matching given key, or end() if not found.\n-   *\n-   *  This function is useful only with multimaps.  It returns the first\n-   *  element of a subsequence of elements that matches the given key.  If\n-   *  unsuccessful the iterator will point to the next greatest element or,\n-   *  if no such greater element exists, to end().\n-  */\n-  const_iterator\n-  lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }\n-\n-  /**\n-   *  @brief Finds the end of a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return Iterator pointing to last element matching given key.\n-   *\n-   *  This function only makes sense with multimaps.\n-  */\n-  iterator\n-  upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }\n-\n-  /**\n-   *  @brief Finds the end of a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Read-only (constant) iterator pointing to last element matching\n-   *           given key.\n-   *\n-   *  This function only makes sense with multimaps.\n-  */\n-  const_iterator\n-  upper_bound(const key_type& __x) const\n-    { return _M_t.upper_bound(__x); }\n-\n-  /**\n-   *  @brief Finds a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pairs to be located.\n-   *  @return  Pair of iterators that possibly points to the subsequence\n-   *           matching given key.\n-   *\n-   *  This function returns a pair of which the first\n-   *  element possibly points to the first element matching the given key\n-   *  and the second element possibly points to the last element matching the\n-   *  given key.  If unsuccessful the first element of the returned pair will\n-   *  contain an iterator pointing to the next greatest element or, if no such\n-   *  greater element exists, to end().\n+  \n+    /**\n+     *  @brief  Builds a %map from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     *  @param  comp  A comparison functor.\n+     *  @param  a  An allocator object.\n+     *\n+     *  Create a %map consisting of copies of the elements from [first,last).\n+     *  This is linear in N if the range is already sorted, and NlogN\n+     *  otherwise (where N is distance(first,last)).\n+    */\n+    template <typename _InputIterator>\n+      map(_InputIterator __first, _InputIterator __last,\n+          const _Compare& __comp, const allocator_type& __a = allocator_type())\n+      : _M_t(__comp, __a)\n+      { _M_t.insert_unique(__first, __last); }\n+  \n+    // FIXME There is no dtor declared, but we should have something generated\n+    // by Doxygen.  I don't know what tags to add to this paragraph to make\n+    // that happen:\n+    /**\n+     *  The dtor only erases the elements, and note that if the elements\n+     *  themselves are pointers, the pointed-to memory is not touched in any\n+     *  way.  Managing the pointer is the user's responsibilty.\n+    */\n+  \n+    /**\n+     *  @brief  Map assignment operator.\n+     *  @param  x  A %map of identical element and allocator types.\n+     *\n+     *  All the elements of @a x are copied, but unlike the copy constructor,\n+     *  the allocator object is not copied.\n+    */\n+    map&\n+    operator=(const map& __x)\n+    {\n+      _M_t = __x._M_t;\n+      return *this;\n+    }\n+  \n+    /// Get a copy of the memory allocation object.\n+    allocator_type\n+    get_allocator() const { return _M_t.get_allocator(); }\n+  \n+    // iterators\n+    /**\n+     *  Returns a read/write iterator that points to the first pair in the %map.\n+     *  Iteration is done in ascending order according to the keys.\n+    */\n+    iterator\n+    begin() { return _M_t.begin(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) iterator that points to the first pair\n+     *  in the %map.  Iteration is done in ascending order according to the\n+     *  keys.\n+    */\n+    const_iterator\n+    begin() const { return _M_t.begin(); }\n+  \n+    /**\n+     *  Returns a read/write iterator that points one past the last pair in the\n+     *  %map.  Iteration is done in ascending order according to the keys.\n+    */\n+    iterator\n+    end() { return _M_t.end(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) iterator that points one past the last\n+     *  pair in the %map.  Iteration is done in ascending order according to the\n+     *  keys.\n+    */\n+    const_iterator\n+    end() const { return _M_t.end(); }\n+  \n+    /**\n+     *  Returns a read/write reverse iterator that points to the last pair in\n+     *  the %map.  Iteration is done in descending order according to the keys.\n+    */\n+    reverse_iterator\n+    rbegin() { return _M_t.rbegin(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reverse iterator that points to the last\n+     *  pair in the %map.  Iteration is done in descending order according to\n+     *  the keys.\n+    */\n+    const_reverse_iterator\n+    rbegin() const { return _M_t.rbegin(); }\n+  \n+    /**\n+     *  Returns a read/write reverse iterator that points to one before the\n+     *  first pair in the %map.  Iteration is done in descending order according\n+     *  to the keys.\n+    */\n+    reverse_iterator\n+    rend() { return _M_t.rend(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reverse iterator that points to one\n+     *  before the first pair in the %map.  Iteration is done in descending\n+     *  order according to the keys.\n+    */\n+    const_reverse_iterator\n+    rend() const { return _M_t.rend(); }\n+  \n+    // capacity\n+    /** Returns true if the %map is empty.  (Thus begin() would equal end().) */\n+    bool\n+    empty() const { return _M_t.empty(); }\n+  \n+    /** Returns the size of the %map.  */\n+    size_type\n+    size() const { return _M_t.size(); }\n+  \n+    /** Returns the maximum size of the %map.  */\n+    size_type\n+    max_size() const { return _M_t.max_size(); }\n+  \n+    // [23.3.1.2] element access\n+    /**\n+     *  @brief  Subscript ( @c [] ) access to %map data.\n+     *  @param  k  The key for which data should be retrieved.\n+     *  @return  A reference to the data of the (key,data) %pair.\n+     *\n+     *  Allows for easy lookup with the subscript ( @c [] ) operator.  Returns\n+     *  data associated with the key specified in subscript.  If the key does\n+     *  not exist, a pair with that key is created using default values, which\n+     *  is then returned.\n+     *\n+     *  Lookup requires logarithmic time.\n+    */\n+    mapped_type&\n+    operator[](const key_type& __k)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_DefaultConstructibleConcept<mapped_type>)\n+  \n+      iterator __i = lower_bound(__k);\n+      // __i->first is greater than or equivalent to __k.\n+      if (__i == end() || key_comp()(__k, (*__i).first))\n+        __i = insert(__i, value_type(__k, mapped_type()));\n+      return (*__i).second;\n+    }\n+  \n+    // modifiers\n+    /**\n+     *  @brief Attempts to insert a std::pair into the %map.\n+     *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+     *             pairs).\n+     *  @return  A pair, of which the first element is an iterator that points\n+     *           to the possibly inserted pair, and the second is a bool that\n+     *           is true if the pair was actually inserted.\n+     *\n+     *  This function attempts to insert a (key, value) %pair into the %map.\n+     *  A %map relies on unique keys and thus a %pair is only inserted if its\n+     *  first element (the key) is not already present in the %map.\n+     *\n+     *  Insertion requires logarithmic time.\n+    */\n+    pair<iterator,bool>\n+    insert(const value_type& __x)\n+      { return _M_t.insert_unique(__x); }\n+  \n+    /**\n+     *  @brief Attempts to insert a std::pair into the %map.\n+     *  @param  position  An iterator that serves as a hint as to where the\n+     *                    pair should be inserted.\n+     *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+     *             pairs).\n+     *  @return  An iterator that points to the element with key of @a x (may\n+     *           or may not be the %pair passed in).\n+     *\n+     *  This function is not concerned about whether the insertion took place,\n+     *  and thus does not return a boolean like the single-argument\n+     *  insert() does.  Note that the first parameter is only a hint and can\n+     *  potentially improve the performance of the insertion process.  A bad\n+     *  hint would cause no gains in efficiency.\n+     *\n+     *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+     *  for more on \"hinting\".\n+     *\n+     *  Insertion requires logarithmic time (if the hint is not taken).\n+    */\n+    iterator\n+    insert(iterator position, const value_type& __x)\n+      { return _M_t.insert_unique(position, __x); }\n+  \n+    /**\n+     *  @brief A template function that attemps to insert a range of elements.\n+     *  @param  first  Iterator pointing to the start of the range to be\n+     *                 inserted.\n+     *  @param  last  Iterator pointing to the end of the range.\n+     *\n+     *  Complexity similar to that of the range constructor.\n+    */\n+    template <typename _InputIterator>\n+      void\n+      insert(_InputIterator __first, _InputIterator __last)\n+        { _M_t.insert_unique(__first, __last); }\n+  \n+    /**\n+     *  @brief Erases an element from a %map.\n+     *  @param  position  An iterator pointing to the element to be erased.\n+     *\n+     *  This function erases an element, pointed to by the given iterator, from\n+     *  a %map.  Note that this function only erases the element, and that if\n+     *  the element is itself a pointer, the pointed-to memory is not touched\n+     *  in any way.  Managing the pointer is the user's responsibilty.\n+    */\n+    void\n+    erase(iterator __position) { _M_t.erase(__position); }\n+  \n+    /**\n+     *  @brief Erases elements according to the provided key.\n+     *  @param  x  Key of element to be erased.\n+     *  @return  The number of elements erased.\n+     *\n+     *  This function erases all the elements located by the given key from\n+     *  a %map.\n+     *  Note that this function only erases the element, and that if\n+     *  the element is itself a pointer, the pointed-to memory is not touched\n+     *  in any way.  Managing the pointer is the user's responsibilty.\n+    */\n+    size_type\n+    erase(const key_type& __x) { return _M_t.erase(__x); }\n+  \n+    /**\n+     *  @brief Erases a [first,last) range of elements from a %map.\n+     *  @param  first  Iterator pointing to the start of the range to be erased.\n+     *  @param  last  Iterator pointing to the end of the range to be erased.\n+     *\n+     *  This function erases a sequence of elements from a %map.\n+     *  Note that this function only erases the element, and that if\n+     *  the element is itself a pointer, the pointed-to memory is not touched\n+     *  in any way.  Managing the pointer is the user's responsibilty.\n+    */\n+    void\n+    erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }\n+  \n+    /**\n+     *  @brief  Swaps data with another %map.\n+     *  @param  x  A %map of the same element and allocator types.\n+     *\n+     *  This exchanges the elements between two maps in constant time.\n+     *  (It is only swapping a pointer, an integer, and an instance of\n+     *  the @c Compare type (which itself is often stateless and empty), so it\n+     *  should be quite fast.)\n+     *  Note that the global std::swap() function is specialized such that\n+     *  std::swap(m1,m2) will feed to this function.\n+    */\n+    void\n+    swap(map& __x) { _M_t.swap(__x._M_t); }\n+  \n+    /**\n+     *  Erases all elements in a %map.  Note that this function only erases\n+     *  the elements, and that if the elements themselves are pointers, the\n+     *  pointed-to memory is not touched in any way.  Managing the pointer is\n+     *  the user's responsibilty.\n+    */\n+    void\n+    clear() { _M_t.clear(); }\n+  \n+    // observers\n+    /**\n+     *  Returns the key comparison object out of which the %map was constructed.\n+    */\n+    key_compare\n+    key_comp() const { return _M_t.key_comp(); }\n+  \n+    /**\n+     *  Returns a value comparison object, built from the key comparison\n+     *  object out of which the %map was constructed.\n+    */\n+    value_compare\n+    value_comp() const { return value_compare(_M_t.key_comp()); }\n+  \n+    // [23.3.1.3] map operations\n+    /**\n+     *  @brief Tries to locate an element in a %map.\n+     *  @param  x  Key of (key, value) %pair to be located.\n+     *  @return  Iterator pointing to sought-after element, or end() if not\n+     *           found.\n+     *\n+     *  This function takes a key and tries to locate the element with which\n+     *  the key matches.  If successful the function returns an iterator\n+     *  pointing to the sought after %pair.  If unsuccessful it returns the\n+     *  past-the-end ( @c end() ) iterator.\n+    */\n+    iterator\n+    find(const key_type& __x) { return _M_t.find(__x); }\n+  \n+    /**\n+     *  @brief Tries to locate an element in a %map.\n+     *  @param  x  Key of (key, value) %pair to be located.\n+     *  @return  Read-only (constant) iterator pointing to sought-after\n+     *           element, or end() if not found.\n+     *\n+     *  This function takes a key and tries to locate the element with which\n+     *  the key matches.  If successful the function returns a constant iterator\n+     *  pointing to the sought after %pair. If unsuccessful it returns the\n+     *  past-the-end ( @c end() ) iterator.\n+    */\n+    const_iterator\n+    find(const key_type& __x) const { return _M_t.find(__x); }\n+  \n+    /**\n+     *  @brief  Finds the number of elements with given key.\n+     *  @param  x  Key of (key, value) pairs to be located.\n+     *  @return  Number of elements with specified key.\n+     *\n+     *  This function only makes sense for multimaps; for map the result will\n+     *  either be 0 (not present) or 1 (present).\n+    */\n+    size_type\n+    count(const key_type& __x) const\n+      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n+  \n+    /**\n+     *  @brief Finds the beginning of a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return  Iterator pointing to first element matching given key, or\n+     *           end() if not found.\n+     *\n+     *  This function is useful only with multimaps.  It returns the first\n+     *  element of a subsequence of elements that matches the given key.  If\n+     *  unsuccessful it returns an iterator pointing to the first element that\n+     *  has a greater value than given key or end() if no such element exists.\n+    */\n+    iterator\n+    lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }\n+  \n+    /**\n+     *  @brief Finds the beginning of a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return  Read-only (constant) iterator pointing to first element\n+     *           matching given key, or end() if not found.\n+     *\n+     *  This function is useful only with multimaps.  It returns the first\n+     *  element of a subsequence of elements that matches the given key.  If\n+     *  unsuccessful the iterator will point to the next greatest element or,\n+     *  if no such greater element exists, to end().\n+    */\n+    const_iterator\n+    lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }\n+  \n+    /**\n+     *  @brief Finds the end of a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return Iterator pointing to last element matching given key.\n+     *\n+     *  This function only makes sense with multimaps.\n+    */\n+    iterator\n+    upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }\n+  \n+    /**\n+     *  @brief Finds the end of a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return  Read-only (constant) iterator pointing to last element matching\n+     *           given key.\n+     *\n+     *  This function only makes sense with multimaps.\n+    */\n+    const_iterator\n+    upper_bound(const key_type& __x) const\n+      { return _M_t.upper_bound(__x); }\n+  \n+    /**\n+     *  @brief Finds a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pairs to be located.\n+     *  @return  Pair of iterators that possibly points to the subsequence\n+     *           matching given key.\n+     *\n+     *  This function returns a pair of which the first\n+     *  element possibly points to the first element matching the given key\n+     *  and the second element possibly points to the last element matching the\n+     *  given key.  If unsuccessful the first element of the returned pair will\n+     *  contain an iterator pointing to the next greatest element or, if no such\n+     *  greater element exists, to end().\n+     *\n+     *  This function only makes sense for multimaps.\n+    */\n+    pair<iterator,iterator>\n+    equal_range(const key_type& __x)\n+      { return _M_t.equal_range(__x); }\n+  \n+    /**\n+     *  @brief Finds a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pairs to be located.\n+     *  @return  Pair of read-only (constant) iterators that possibly points to\n+     *           the subsequence matching given key.\n+     *\n+     *  This function returns a pair of which the first\n+     *  element possibly points to the first element matching the given key\n+     *  and the second element possibly points to the last element matching the\n+     *  given key.  If unsuccessful the first element of the returned pair will\n+     *  contain an iterator pointing to the next greatest element or, if no such\n+     *  a greater element exists, to end().\n+     *\n+     *  This function only makes sense for multimaps.\n+    */\n+    pair<const_iterator,const_iterator>\n+    equal_range(const key_type& __x) const\n+      { return _M_t.equal_range(__x); }\n+  \n+    template <typename _K1, typename _T1, typename _C1, typename _A1>\n+    friend bool operator== (const map<_K1,_T1,_C1,_A1>&,\n+                            const map<_K1,_T1,_C1,_A1>&);\n+    template <typename _K1, typename _T1, typename _C1, typename _A1>\n+    friend bool operator< (const map<_K1,_T1,_C1,_A1>&,\n+                           const map<_K1,_T1,_C1,_A1>&);\n+  };\n+  \n+  \n+  /**\n+   *  @brief  Map equality comparison.\n+   *  @param  x  A %map.\n+   *  @param  y  A %map of the same type as @a x.\n+   *  @return  True iff the size and elements of the maps are equal.\n    *\n-   *  This function only makes sense for multimaps.\n-  */\n-  pair<iterator,iterator>\n-  equal_range(const key_type& __x)\n-    { return _M_t.equal_range(__x); }\n-\n-  /**\n-   *  @brief Finds a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pairs to be located.\n-   *  @return  Pair of read-only (constant) iterators that possibly points to\n-   *           the subsequence matching given key.\n+   *  This is an equivalence relation.  It is linear in the size of the\n+   *  maps.  Maps are considered equivalent if their sizes are equal,\n+   *  and if corresponding elements compare equal.\n+  */\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return __x._M_t == __y._M_t; }\n+  \n+  /**\n+   *  @brief  Map ordering relation.\n+   *  @param  x  A %map.\n+   *  @param  y  A %map of the same type as @a x.\n+   *  @return  True iff @a x is lexographically less than @a y.\n    *\n-   *  This function returns a pair of which the first\n-   *  element possibly points to the first element matching the given key\n-   *  and the second element possibly points to the last element matching the\n-   *  given key.  If unsuccessful the first element of the returned pair will\n-   *  contain an iterator pointing to the next greatest element or, if no such\n-   *  a greater element exists, to end().\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  maps.  The elements must be comparable with @c <.\n    *\n-   *  This function only makes sense for multimaps.\n-  */\n-  pair<const_iterator,const_iterator>\n-  equal_range(const key_type& __x) const\n-    { return _M_t.equal_range(__x); }\n-\n-  template <typename _K1, typename _T1, typename _C1, typename _A1>\n-  friend bool operator== (const map<_K1,_T1,_C1,_A1>&,\n-                          const map<_K1,_T1,_C1,_A1>&);\n-  template <typename _K1, typename _T1, typename _C1, typename _A1>\n-  friend bool operator< (const map<_K1,_T1,_C1,_A1>&,\n-                         const map<_K1,_T1,_C1,_A1>&);\n-};\n-\n-\n-/**\n- *  @brief  Map equality comparison.\n- *  @param  x  A %map.\n- *  @param  y  A %map of the same type as @a x.\n- *  @return  True iff the size and elements of the maps are equal.\n- *\n- *  This is an equivalence relation.  It is linear in the size of the\n- *  maps.  Maps are considered equivalent if their sizes are equal,\n- *  and if corresponding elements compare equal.\n-*/\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-             const map<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return __x._M_t == __y._M_t; }\n-\n-/**\n- *  @brief  Map ordering relation.\n- *  @param  x  A %map.\n- *  @param  y  A %map of the same type as @a x.\n- *  @return  True iff @a x is lexographically less than @a y.\n- *\n- *  This is a total ordering relation.  It is linear in the size of the\n- *  maps.  The elements must be comparable with @c <.\n- *\n- *  See std::lexographical_compare() for how the determination is made.\n-*/\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-            const map<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return __x._M_t < __y._M_t; }\n-\n-/// Based on operator==\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-             const map<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return !(__x == __y); }\n-\n-/// Based on operator<\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-            const map<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return __y < __x; }\n-\n-/// Based on operator<\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-             const map<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return !(__y < __x); }\n-\n-/// Based on operator<\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-             const map<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return !(__x < __y); }\n-\n-/// See std::map::swap().\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline void\n-  swap(map<_Key,_Tp,_Compare,_Alloc>& __x, map<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { __x.swap(__y); }\n-\n+   *  See std::lexographical_compare() for how the determination is made.\n+  */\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+              const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return __x._M_t < __y._M_t; }\n+  \n+  /// Based on operator==\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return !(__x == __y); }\n+  \n+  /// Based on operator<\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+              const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return __y < __x; }\n+  \n+  /// Based on operator<\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return !(__y < __x); }\n+  \n+  /// Based on operator<\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return !(__x < __y); }\n+  \n+  /// See std::map::swap().\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(map<_Key,_Tp,_Compare,_Alloc>& __x, map<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { __x.swap(__y); }\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_MAP_H */\n-"}, {"sha": "9cf8e0c5b0711c73fa40f23d2e07cb13330cfe22", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 556, "deletions": 561, "changes": 1117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -63,579 +63,574 @@\n \n #include <bits/concept_check.h>\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-\n-// Forward declaration of operators < and ==, needed for friend declaration.\n-\n-template <typename _Key, typename _Tp,\n-          typename _Compare = less<_Key>,\n-          typename _Alloc = allocator<pair<const _Key, _Tp> > >\n-class multimap;\n-\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n-\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-                      const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n-\n-/**\n- *  @brief A standard container made up of (key,value) pairs, which can be\n- *  retrieved based on a key, in logarithmic time.\n- *\n- *  @ingroup Containers\n- *  @ingroup Assoc_containers\n- *\n- *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n- *  <a href=\"tables.html#66\">reversible container</a>, and an\n- *  <a href=\"tables.html#69\">associative container</a> (using equivalent keys).\n- *  For a @c multimap<Key,T> the key_type is Key, the mapped_type is T, and\n- *  the value_type is std::pair<const Key,T>.\n- *\n- *  Multimaps support bidirectional iterators.\n- *\n- *  @if maint\n- *  The private tree data is declared exactly the same way for map and\n- *  multimap; the distinction is made entirely in how the tree functions are\n- *  called (*_unique versus *_equal, same as the standard).\n- *  @endif\n-*/\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  class multimap\n-{\n-  // concept requirements\n-  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n-\n-public:\n-  typedef _Key                                          key_type;\n-  typedef _Tp                                           mapped_type;\n-  typedef pair<const _Key, _Tp>                         value_type;\n-  typedef _Compare                                      key_compare;\n-\n-  class value_compare\n-    : public binary_function<value_type, value_type, bool>\n-    {\n-      friend class multimap<_Key,_Tp,_Compare,_Alloc>;\n-    protected:\n-      _Compare comp;\n-      value_compare(_Compare __c) : comp(__c) {}\n-    public:\n-      bool operator()(const value_type& __x, const value_type& __y) const\n-        { return comp(__x.first, __y.first); }\n-  };\n-\n-private:\n-  /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n-  typedef _Rb_tree<key_type, value_type,\n-                  _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n-  /// @if maint  The actual tree structure.  @endif\n-  _Rep_type _M_t;\n-\n-public:\n-  // many of these are specified differently in ISO, but the following are\n-  // \"functionally equivalent\"\n-  typedef typename _Rep_type::allocator_type            allocator_type;\n-  typedef typename _Rep_type::reference                 reference;\n-  typedef typename _Rep_type::const_reference           const_reference;\n-  typedef typename _Rep_type::iterator                  iterator;\n-  typedef typename _Rep_type::const_iterator            const_iterator;\n-  typedef typename _Rep_type::size_type                 size_type;\n-  typedef typename _Rep_type::difference_type           difference_type;\n-  typedef typename _Rep_type::pointer                   pointer;\n-  typedef typename _Rep_type::const_pointer             const_pointer;\n-  typedef typename _Rep_type::reverse_iterator          reverse_iterator;\n-  typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n-\n-\n-  // [23.3.2] construct/copy/destroy\n-  // (get_allocator() is also listed in this section)\n-  /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  multimap() : _M_t(_Compare(), allocator_type()) { }\n-\n-  // for some reason this was made a separate function\n-  /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  explicit\n-  multimap(const _Compare& __comp, const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { }\n-\n-  /**\n-   *  @brief  %Multimap copy constructor.\n-   *  @param  x  A %multimap of identical element and allocator types.\n+  // Forward declaration of operators < and ==, needed for friend declaration.\n+  \n+  template <typename _Key, typename _Tp,\n+            typename _Compare = less<_Key>,\n+            typename _Alloc = allocator<pair<const _Key, _Tp> > >\n+  class multimap;\n+  \n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+                         const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n+  \n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+                        const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n+  \n+  /**\n+   *  @brief A standard container made up of (key,value) pairs, which can be\n+   *  retrieved based on a key, in logarithmic time.\n    *\n-   *  The newly-created %multimap uses a copy of the allocation object used\n-   *  by @a x.\n-  */\n-  multimap(const multimap& __x)\n-    : _M_t(__x._M_t) { }\n-\n-  /**\n-   *  @brief  Builds a %multimap from a range.\n-   *  @param  first  An input iterator.\n-   *  @param  last  An input iterator.\n+   *  @ingroup Containers\n+   *  @ingroup Assoc_containers\n    *\n-   *  Create a %multimap consisting of copies of the elements from\n-   *  [first,last).  This is linear in N if the range is already sorted,\n-   *  and NlogN otherwise (where N is distance(first,last)).\n-  */\n-  template <typename _InputIterator>\n-    multimap(_InputIterator __first, _InputIterator __last)\n-      : _M_t(_Compare(), allocator_type())\n-      { _M_t.insert_equal(__first, __last); }\n-\n-  /**\n-   *  @brief  Builds a %multimap from a range.\n-   *  @param  first  An input iterator.\n-   *  @param  last  An input iterator.\n-   *  @param  comp  A comparison functor.\n-   *  @param  a  An allocator object.\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and an\n+   *  <a href=\"tables.html#69\">associative container</a> (using equivalent\n+   *  keys).  For a @c multimap<Key,T> the key_type is Key, the mapped_type\n+   *  is T, and the value_type is std::pair<const Key,T>.\n    *\n-   *  Create a %multimap consisting of copies of the elements from [first,last).\n-   *  This is linear in N if the range is already sorted, and NlogN\n-   *  otherwise (where N is distance(first,last)).\n-  */\n-  template <typename _InputIterator>\n-    multimap(_InputIterator __first, _InputIterator __last,\n-             const _Compare& __comp,\n-             const allocator_type& __a = allocator_type())\n-      : _M_t(__comp, __a)\n-      { _M_t.insert_equal(__first, __last); }\n-\n-  // FIXME There is no dtor declared, but we should have something generated\n-  // by Doxygen.  I don't know what tags to add to this paragraph to make\n-  // that happen:\n-  /**\n-   *  The dtor only erases the elements, and note that if the elements\n-   *  themselves are pointers, the pointed-to memory is not touched in any\n-   *  way.  Managing the pointer is the user's responsibilty.\n-  */\n-\n-  /**\n-   *  @brief  %Multimap assignment operator.\n-   *  @param  x  A %multimap of identical element and allocator types.\n+   *  Multimaps support bidirectional iterators.\n    *\n-   *  All the elements of @a x are copied, but unlike the copy constructor, the\n-   *  allocator object is not copied.\n-  */\n-  multimap&\n-  operator=(const multimap& __x)\n+   *  @if maint\n+   *  The private tree data is declared exactly the same way for map and\n+   *  multimap; the distinction is made entirely in how the tree functions are\n+   *  called (*_unique versus *_equal, same as the standard).\n+   *  @endif\n+  */\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    class multimap\n   {\n-    _M_t = __x._M_t;\n-    return *this;\n-  }\n-\n-  /// Get a copy of the memory allocation object.\n-  allocator_type\n-  get_allocator() const { return _M_t.get_allocator(); }\n-\n-  // iterators\n-  /**\n-   *  Returns a read/write iterator that points to the first pair in the\n-   *  %multimap.  Iteration is done in ascending order according to the keys.\n-  */\n-  iterator\n-  begin() { return _M_t.begin(); }\n-\n-  /**\n-   *  Returns a read-only (constant) iterator that points to the first pair\n-   *  in the %multimap.  Iteration is done in ascending order according to the\n-   *  keys.\n-  */\n-  const_iterator\n-  begin() const { return _M_t.begin(); }\n-\n-  /**\n-   *  Returns a read/write iterator that points one past the last pair in the\n-   *  %multimap.  Iteration is done in ascending order according to the keys.\n-  */\n-  iterator\n-  end() { return _M_t.end(); }\n-\n-  /**\n-   *  Returns a read-only (constant) iterator that points one past the last\n-   *  pair in the %multimap.  Iteration is done in ascending order according\n-   *  to the keys.\n-  */\n-  const_iterator\n-  end() const { return _M_t.end(); }\n-\n-  /**\n-   *  Returns a read/write reverse iterator that points to the last pair in\n-   *  the %multimap.  Iteration is done in descending order according to the\n-   *  keys.\n-  */\n-  reverse_iterator\n-  rbegin() { return _M_t.rbegin(); }\n-\n-  /**\n-   *  Returns a read-only (constant) reverse iterator that points to the last\n-   *  pair in the %multimap.  Iteration is done in descending order according\n-   *  to the keys.\n-  */\n-  const_reverse_iterator\n-  rbegin() const { return _M_t.rbegin(); }\n-\n-  /**\n-   *  Returns a read/write reverse iterator that points to one before the\n-   *  first pair in the %multimap.  Iteration is done in descending order\n-   *  according to the keys.\n-  */\n-  reverse_iterator\n-  rend() { return _M_t.rend(); }\n-\n-  /**\n-   *  Returns a read-only (constant) reverse iterator that points to one\n-   *  before the first pair in the %multimap.  Iteration is done in descending\n-   *  order according to the keys.\n-  */\n-  const_reverse_iterator\n-  rend() const { return _M_t.rend(); }\n-\n-  // capacity\n-  /** Returns true if the %multimap is empty.  */\n-  bool\n-  empty() const { return _M_t.empty(); }\n-\n-  /** Returns the size of the %multimap.  */\n-  size_type\n-  size() const { return _M_t.size(); }\n-\n-  /** Returns the maximum size of the %multimap.  */\n-  size_type\n-  max_size() const { return _M_t.max_size(); }\n-\n-  // modifiers\n-  /**\n-   *  @brief Inserts a std::pair into the %multimap.\n-   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n-   *             pairs).\n-   *  @return An iterator that points to the inserted (key,value) pair.\n-   *\n-   *  This function inserts a (key, value) pair into the %multimap.  Contrary\n-   *  to a std::map the %multimap does not rely on unique keys and thus\n-   *  multiple pairs with the same key can be inserted.\n-   *\n-   *  Insertion requires logarithmic time.\n-  */\n-  iterator\n-  insert(const value_type& __x) { return _M_t.insert_equal(__x); }\n-\n-  /**\n-   *  @brief Inserts a std::pair into the %multimap.\n-   *  @param  position  An iterator that serves as a hint as to where the\n-   *                    pair should be inserted.\n-   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n-   *             pairs).\n-   *  @return An iterator that points to the inserted (key,value) pair.\n-   *\n-   *  This function inserts a (key, value) pair into the %multimap.  Contrary\n-   *  to a std::map the %multimap does not rely on unique keys and thus\n-   *  multiple pairs with the same key can be inserted.\n-   *  Note that the first parameter is only a hint and can potentially\n-   *  improve the performance of the insertion process.  A bad hint would\n-   *  cause no gains in efficiency.\n-   *\n-   *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n-   *  for more on \"hinting\".\n-   *\n-   *  Insertion requires logarithmic time (if the hint is not taken).\n-  */\n-  iterator\n-  insert(iterator __position, const value_type& __x)\n-    { return _M_t.insert_equal(__position, __x); }\n-\n-  /**\n-   *  @brief A template function that attemps to insert a range of elements.\n-   *  @param  first  Iterator pointing to the start of the range to be inserted.\n-   *  @param  last  Iterator pointing to the end of the range.\n-   *\n-   *  Complexity similar to that of the range constructor.\n-  */\n-  template <typename _InputIterator>\n+    // concept requirements\n+    __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+    __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n+  \n+  public:\n+    typedef _Key                                          key_type;\n+    typedef _Tp                                           mapped_type;\n+    typedef pair<const _Key, _Tp>                         value_type;\n+    typedef _Compare                                      key_compare;\n+  \n+    class value_compare\n+      : public binary_function<value_type, value_type, bool>\n+      {\n+        friend class multimap<_Key,_Tp,_Compare,_Alloc>;\n+      protected:\n+        _Compare comp;\n+        value_compare(_Compare __c) : comp(__c) {}\n+      public:\n+        bool operator()(const value_type& __x, const value_type& __y) const\n+          { return comp(__x.first, __y.first); }\n+    };\n+  \n+  private:\n+    /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n+    typedef _Rb_tree<key_type, value_type,\n+                    _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n+    /// @if maint  The actual tree structure.  @endif\n+    _Rep_type _M_t;\n+  \n+  public:\n+    // many of these are specified differently in ISO, but the following are\n+    // \"functionally equivalent\"\n+    typedef typename _Rep_type::allocator_type            allocator_type;\n+    typedef typename _Rep_type::reference                 reference;\n+    typedef typename _Rep_type::const_reference           const_reference;\n+    typedef typename _Rep_type::iterator                  iterator;\n+    typedef typename _Rep_type::const_iterator            const_iterator;\n+    typedef typename _Rep_type::size_type                 size_type;\n+    typedef typename _Rep_type::difference_type           difference_type;\n+    typedef typename _Rep_type::pointer                   pointer;\n+    typedef typename _Rep_type::const_pointer             const_pointer;\n+    typedef typename _Rep_type::reverse_iterator          reverse_iterator;\n+    typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n+  \n+  \n+    // [23.3.2] construct/copy/destroy\n+    // (get_allocator() is also listed in this section)\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    multimap() : _M_t(_Compare(), allocator_type()) { }\n+  \n+    // for some reason this was made a separate function\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    explicit\n+    multimap(const _Compare& __comp, const allocator_type& __a = allocator_type())\n+      : _M_t(__comp, __a) { }\n+  \n+    /**\n+     *  @brief  %Multimap copy constructor.\n+     *  @param  x  A %multimap of identical element and allocator types.\n+     *\n+     *  The newly-created %multimap uses a copy of the allocation object used\n+     *  by @a x.\n+    */\n+    multimap(const multimap& __x)\n+      : _M_t(__x._M_t) { }\n+  \n+    /**\n+     *  @brief  Builds a %multimap from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     *\n+     *  Create a %multimap consisting of copies of the elements from\n+     *  [first,last).  This is linear in N if the range is already sorted,\n+     *  and NlogN otherwise (where N is distance(first,last)).\n+    */\n+    template <typename _InputIterator>\n+      multimap(_InputIterator __first, _InputIterator __last)\n+        : _M_t(_Compare(), allocator_type())\n+        { _M_t.insert_equal(__first, __last); }\n+  \n+    /**\n+     *  @brief  Builds a %multimap from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     *  @param  comp  A comparison functor.\n+     *  @param  a  An allocator object.\n+     *\n+     *  Create a %multimap consisting of copies of the elements from\n+     *  [first,last).  This is linear in N if the range is already sorted,\n+     *  and NlogN otherwise (where N is distance(first,last)).\n+    */\n+    template <typename _InputIterator>\n+      multimap(_InputIterator __first, _InputIterator __last,\n+               const _Compare& __comp,\n+               const allocator_type& __a = allocator_type())\n+        : _M_t(__comp, __a)\n+        { _M_t.insert_equal(__first, __last); }\n+  \n+    // FIXME There is no dtor declared, but we should have something generated\n+    // by Doxygen.  I don't know what tags to add to this paragraph to make\n+    // that happen:\n+    /**\n+     *  The dtor only erases the elements, and note that if the elements\n+     *  themselves are pointers, the pointed-to memory is not touched in any\n+     *  way.  Managing the pointer is the user's responsibilty.\n+    */\n+  \n+    /**\n+     *  @brief  %Multimap assignment operator.\n+     *  @param  x  A %multimap of identical element and allocator types.\n+     *\n+     *  All the elements of @a x are copied, but unlike the copy constructor,\n+     *  the allocator object is not copied.\n+    */\n+    multimap&\n+    operator=(const multimap& __x)\n+    {\n+      _M_t = __x._M_t;\n+      return *this;\n+    }\n+  \n+    /// Get a copy of the memory allocation object.\n+    allocator_type\n+    get_allocator() const { return _M_t.get_allocator(); }\n+  \n+    // iterators\n+    /**\n+     *  Returns a read/write iterator that points to the first pair in the\n+     *  %multimap.  Iteration is done in ascending order according to the keys.\n+    */\n+    iterator\n+    begin() { return _M_t.begin(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) iterator that points to the first pair\n+     *  in the %multimap.  Iteration is done in ascending order according to the\n+     *  keys.\n+    */\n+    const_iterator\n+    begin() const { return _M_t.begin(); }\n+  \n+    /**\n+     *  Returns a read/write iterator that points one past the last pair in the\n+     *  %multimap.  Iteration is done in ascending order according to the keys.\n+    */\n+    iterator\n+    end() { return _M_t.end(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) iterator that points one past the last\n+     *  pair in the %multimap.  Iteration is done in ascending order according\n+     *  to the keys.\n+    */\n+    const_iterator\n+    end() const { return _M_t.end(); }\n+  \n+    /**\n+     *  Returns a read/write reverse iterator that points to the last pair in\n+     *  the %multimap.  Iteration is done in descending order according to the\n+     *  keys.\n+    */\n+    reverse_iterator\n+    rbegin() { return _M_t.rbegin(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reverse iterator that points to the last\n+     *  pair in the %multimap.  Iteration is done in descending order according\n+     *  to the keys.\n+    */\n+    const_reverse_iterator\n+    rbegin() const { return _M_t.rbegin(); }\n+  \n+    /**\n+     *  Returns a read/write reverse iterator that points to one before the\n+     *  first pair in the %multimap.  Iteration is done in descending order\n+     *  according to the keys.\n+    */\n+    reverse_iterator\n+    rend() { return _M_t.rend(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reverse iterator that points to one\n+     *  before the first pair in the %multimap.  Iteration is done in descending\n+     *  order according to the keys.\n+    */\n+    const_reverse_iterator\n+    rend() const { return _M_t.rend(); }\n+  \n+    // capacity\n+    /** Returns true if the %multimap is empty.  */\n+    bool\n+    empty() const { return _M_t.empty(); }\n+  \n+    /** Returns the size of the %multimap.  */\n+    size_type\n+    size() const { return _M_t.size(); }\n+  \n+    /** Returns the maximum size of the %multimap.  */\n+    size_type\n+    max_size() const { return _M_t.max_size(); }\n+  \n+    // modifiers\n+    /**\n+     *  @brief Inserts a std::pair into the %multimap.\n+     *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+     *             pairs).\n+     *  @return An iterator that points to the inserted (key,value) pair.\n+     *\n+     *  This function inserts a (key, value) pair into the %multimap.  Contrary\n+     *  to a std::map the %multimap does not rely on unique keys and thus\n+     *  multiple pairs with the same key can be inserted.\n+     *\n+     *  Insertion requires logarithmic time.\n+    */\n+    iterator\n+    insert(const value_type& __x) { return _M_t.insert_equal(__x); }\n+  \n+    /**\n+     *  @brief Inserts a std::pair into the %multimap.\n+     *  @param  position  An iterator that serves as a hint as to where the\n+     *                    pair should be inserted.\n+     *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+     *             pairs).\n+     *  @return An iterator that points to the inserted (key,value) pair.\n+     *\n+     *  This function inserts a (key, value) pair into the %multimap.  Contrary\n+     *  to a std::map the %multimap does not rely on unique keys and thus\n+     *  multiple pairs with the same key can be inserted.\n+     *  Note that the first parameter is only a hint and can potentially\n+     *  improve the performance of the insertion process.  A bad hint would\n+     *  cause no gains in efficiency.\n+     *\n+     *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+     *  for more on \"hinting\".\n+     *\n+     *  Insertion requires logarithmic time (if the hint is not taken).\n+    */\n+    iterator\n+    insert(iterator __position, const value_type& __x)\n+      { return _M_t.insert_equal(__position, __x); }\n+  \n+    /**\n+     *  @brief A template function that attemps to insert a range of elements.\n+     *  @param  first  Iterator pointing to the start of the range to be\n+     *                 inserted.\n+     *  @param  last  Iterator pointing to the end of the range.\n+     *\n+     *  Complexity similar to that of the range constructor.\n+    */\n+    template <typename _InputIterator>\n+      void\n+      insert(_InputIterator __first, _InputIterator __last)\n+        { _M_t.insert_equal(__first, __last); }\n+  \n+    /**\n+     *  @brief Erases an element from a %multimap.\n+     *  @param  position  An iterator pointing to the element to be erased.\n+     *\n+     *  This function erases an element, pointed to by the given iterator, from\n+     *  a %multimap.  Note that this function only erases the element, and that\n+     *  if the element is itself a pointer, the pointed-to memory is not\n+     *  touched in any way.  Managing the pointer is the user's responsibilty.\n+    */\n     void\n-    insert(_InputIterator __first, _InputIterator __last)\n-      { _M_t.insert_equal(__first, __last); }\n-\n-  /**\n-   *  @brief Erases an element from a %multimap.\n-   *  @param  position  An iterator pointing to the element to be erased.\n-   *\n-   *  This function erases an element, pointed to by the given iterator, from\n-   *  a %multimap.  Note that this function only erases the element, and that\n-   *  if the element is itself a pointer, the pointed-to memory is not\n-   *  touched in any way.  Managing the pointer is the user's responsibilty.\n-  */\n-  void\n-  erase(iterator __position) { _M_t.erase(__position); }\n-\n-  /**\n-   *  @brief Erases elements according to the provided key.\n-   *  @param  x  Key of element to be erased.\n-   *  @return  The number of elements erased.\n-   *\n-   *  This function erases all elements located by the given key from a\n-   *  %multimap.\n-   *  Note that this function only erases the element, and that if\n-   *  the element is itself a pointer, the pointed-to memory is not touched\n-   *  in any way.  Managing the pointer is the user's responsibilty.\n-  */\n-  size_type\n-  erase(const key_type& __x) { return _M_t.erase(__x); }\n-\n-  /**\n-   *  @brief Erases a [first,last) range of elements from a %multimap.\n-   *  @param  first  Iterator pointing to the start of the range to be erased.\n-   *  @param  last  Iterator pointing to the end of the range to be erased.\n-   *\n-   *  This function erases a sequence of elements from a %multimap.\n-   *  Note that this function only erases the elements, and that if\n-   *  the elements themselves are pointers, the pointed-to memory is not\n-   *  touched in any way.  Managing the pointer is the user's responsibilty.\n-  */\n-  void\n-  erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }\n-\n-  /**\n-   *  @brief  Swaps data with another %multimap.\n-   *  @param  x  A %multimap of the same element and allocator types.\n-   *\n-   *  This exchanges the elements between two multimaps in constant time.\n-   *  (It is only swapping a pointer, an integer, and an instance of\n-   *  the @c Compare type (which itself is often stateless and empty), so it\n-   *  should be quite fast.)\n-   *  Note that the global std::swap() function is specialized such that\n-   *  std::swap(m1,m2) will feed to this function.\n-  */\n-  void\n-  swap(multimap& __x) { _M_t.swap(__x._M_t); }\n-\n-  /**\n-   *  Erases all elements in a %multimap.  Note that this function only erases\n-   *  the elements, and that if the elements themselves are pointers, the\n-   *  pointed-to memory is not touched in any way.  Managing the pointer is\n-   *  the user's responsibilty.\n-  */\n-  void\n-  clear() { _M_t.clear(); }\n-\n-  // observers\n-  /**\n-   *  Returns the key comparison object out of which the %multimap\n-   *  was constructed.\n-  */\n-  key_compare\n-  key_comp() const { return _M_t.key_comp(); }\n-\n-  /**\n-   *  Returns a value comparison object, built from the key comparison\n-   *  object out of which the %multimap was constructed.\n-  */\n-  value_compare\n-  value_comp() const { return value_compare(_M_t.key_comp()); }\n-\n-  // multimap operations\n-  /**\n-   *  @brief Tries to locate an element in a %multimap.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Iterator pointing to sought-after element,\n-   *           or end() if not found.\n-   *\n-   *  This function takes a key and tries to locate the element with which\n-   *  the key matches.  If successful the function returns an iterator\n-   *  pointing to the sought after %pair.  If unsuccessful it returns the\n-   *  past-the-end ( @c end() ) iterator.\n-  */\n-  iterator\n-  find(const key_type& __x) { return _M_t.find(__x); }\n-\n-  /**\n-   *  @brief Tries to locate an element in a %multimap.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Read-only (constant) iterator pointing to sought-after\n-   *           element, or end() if not found.\n-   *\n-   *  This function takes a key and tries to locate the element with which\n-   *  the key matches.  If successful the function returns a constant iterator\n-   *  pointing to the sought after %pair.  If unsuccessful it returns the\n-   *  past-the-end ( @c end() ) iterator.\n-  */\n-  const_iterator\n-  find(const key_type& __x) const { return _M_t.find(__x); }\n-\n-  /**\n-   *  @brief Finds the number of elements with given key.\n-   *  @param  x  Key of (key, value) pairs to be located.\n-   *  @return Number of elements with specified key.\n-  */\n-  size_type\n-  count(const key_type& __x) const { return _M_t.count(__x); }\n-\n+    erase(iterator __position) { _M_t.erase(__position); }\n+  \n+    /**\n+     *  @brief Erases elements according to the provided key.\n+     *  @param  x  Key of element to be erased.\n+     *  @return  The number of elements erased.\n+     *\n+     *  This function erases all elements located by the given key from a\n+     *  %multimap.\n+     *  Note that this function only erases the element, and that if\n+     *  the element is itself a pointer, the pointed-to memory is not touched\n+     *  in any way.  Managing the pointer is the user's responsibilty.\n+    */\n+    size_type\n+    erase(const key_type& __x) { return _M_t.erase(__x); }\n+  \n+    /**\n+     *  @brief Erases a [first,last) range of elements from a %multimap.\n+     *  @param  first  Iterator pointing to the start of the range to be erased.\n+     *  @param  last  Iterator pointing to the end of the range to be erased.\n+     *\n+     *  This function erases a sequence of elements from a %multimap.\n+     *  Note that this function only erases the elements, and that if\n+     *  the elements themselves are pointers, the pointed-to memory is not\n+     *  touched in any way.  Managing the pointer is the user's responsibilty.\n+    */\n+    void\n+    erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }\n+  \n+    /**\n+     *  @brief  Swaps data with another %multimap.\n+     *  @param  x  A %multimap of the same element and allocator types.\n+     *\n+     *  This exchanges the elements between two multimaps in constant time.\n+     *  (It is only swapping a pointer, an integer, and an instance of\n+     *  the @c Compare type (which itself is often stateless and empty), so it\n+     *  should be quite fast.)\n+     *  Note that the global std::swap() function is specialized such that\n+     *  std::swap(m1,m2) will feed to this function.\n+    */\n+    void\n+    swap(multimap& __x) { _M_t.swap(__x._M_t); }\n+  \n+    /**\n+     *  Erases all elements in a %multimap.  Note that this function only erases\n+     *  the elements, and that if the elements themselves are pointers, the\n+     *  pointed-to memory is not touched in any way.  Managing the pointer is\n+     *  the user's responsibilty.\n+    */\n+    void\n+    clear() { _M_t.clear(); }\n+  \n+    // observers\n+    /**\n+     *  Returns the key comparison object out of which the %multimap\n+     *  was constructed.\n+    */\n+    key_compare\n+    key_comp() const { return _M_t.key_comp(); }\n+  \n+    /**\n+     *  Returns a value comparison object, built from the key comparison\n+     *  object out of which the %multimap was constructed.\n+    */\n+    value_compare\n+    value_comp() const { return value_compare(_M_t.key_comp()); }\n+  \n+    // multimap operations\n+    /**\n+     *  @brief Tries to locate an element in a %multimap.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return  Iterator pointing to sought-after element,\n+     *           or end() if not found.\n+     *\n+     *  This function takes a key and tries to locate the element with which\n+     *  the key matches.  If successful the function returns an iterator\n+     *  pointing to the sought after %pair.  If unsuccessful it returns the\n+     *  past-the-end ( @c end() ) iterator.\n+    */\n+    iterator\n+    find(const key_type& __x) { return _M_t.find(__x); }\n+  \n+    /**\n+     *  @brief Tries to locate an element in a %multimap.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return  Read-only (constant) iterator pointing to sought-after\n+     *           element, or end() if not found.\n+     *\n+     *  This function takes a key and tries to locate the element with which\n+     *  the key matches.  If successful the function returns a constant iterator\n+     *  pointing to the sought after %pair.  If unsuccessful it returns the\n+     *  past-the-end ( @c end() ) iterator.\n+    */\n+    const_iterator\n+    find(const key_type& __x) const { return _M_t.find(__x); }\n+  \n+    /**\n+     *  @brief Finds the number of elements with given key.\n+     *  @param  x  Key of (key, value) pairs to be located.\n+     *  @return Number of elements with specified key.\n+    */\n+    size_type\n+    count(const key_type& __x) const { return _M_t.count(__x); }\n+  \n+    /**\n+     *  @brief Finds the beginning of a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return  Iterator pointing to first element matching given key, or\n+     *           end() if not found.\n+     *\n+     *  This function returns the first element of a subsequence of elements\n+     *  that matches the given key.  If unsuccessful it returns an iterator\n+     *  pointing to the first element that has a greater value than given key\n+     *  or end() if no such element exists.\n+    */\n+    iterator\n+    lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }\n+  \n+    /**\n+     *  @brief Finds the beginning of a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return  Read-only (constant) iterator pointing to first element\n+     *           matching given key, or end() if not found.\n+     *\n+     *  This function returns the first element of a subsequence of elements\n+     *  that matches the given key.  If unsuccessful the iterator will point\n+     *  to the next greatest element or, if no such greater element exists, to\n+     *  end().\n+    */\n+    const_iterator\n+    lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }\n+  \n+    /**\n+     *  @brief Finds the end of a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return Iterator pointing to last element matching given key.\n+    */\n+    iterator\n+    upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }\n+  \n+    /**\n+     *  @brief Finds the end of a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pair to be located.\n+     *  @return  Read-only (constant) iterator pointing to last element matching\n+     *           given key.\n+    */\n+    const_iterator\n+    upper_bound(const key_type& __x) const { return _M_t.upper_bound(__x); }\n+  \n+    /**\n+     *  @brief Finds a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pairs to be located.\n+     *  @return  Pair of iterators that possibly points to the subsequence\n+     *           matching given key.\n+     *\n+     *  This function returns a pair of which the first\n+     *  element possibly points to the first element matching the given key\n+     *  and the second element possibly points to the last element matching the\n+     *  given key.  If unsuccessful the first element of the returned pair will\n+     *  contain an iterator pointing to the next greatest element or, if no such\n+     *  greater element exists, to end().\n+    */\n+    pair<iterator,iterator>\n+    equal_range(const key_type& __x) { return _M_t.equal_range(__x); }\n+  \n+    /**\n+     *  @brief Finds a subsequence matching given key.\n+     *  @param  x  Key of (key, value) pairs to be located.\n+     *  @return  Pair of read-only (constant) iterators that possibly points to\n+     *           the subsequence matching given key.\n+     *\n+     *  This function returns a pair of which the first\n+     *  element possibly points to the first element matching the given key\n+     *  and the second element possibly points to the last element matching the\n+     *  given key.  If unsuccessful the first element of the returned pair will\n+     *  contain an iterator pointing to the next greatest element or, if no such\n+     *  a greater element exists, to end().\n+    */\n+    pair<const_iterator,const_iterator>\n+    equal_range(const key_type& __x) const { return _M_t.equal_range(__x); }\n+  \n+    template <typename _K1, typename _T1, typename _C1, typename _A1>\n+    friend bool operator== (const multimap<_K1,_T1,_C1,_A1>&,\n+                            const multimap<_K1,_T1,_C1,_A1>&);\n+    template <typename _K1, typename _T1, typename _C1, typename _A1>\n+    friend bool operator< (const multimap<_K1,_T1,_C1,_A1>&,\n+                           const multimap<_K1,_T1,_C1,_A1>&);\n+  };\n+  \n+  \n   /**\n-   *  @brief Finds the beginning of a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Iterator pointing to first element matching given key, or\n-   *           end() if not found.\n+   *  @brief  Multimap equality comparison.\n+   *  @param  x  A %multimap.\n+   *  @param  y  A %multimap of the same type as @a x.\n+   *  @return  True iff the size and elements of the maps are equal.\n    *\n-   *  This function returns the first element of a subsequence of elements\n-   *  that matches the given key.  If unsuccessful it returns an iterator\n-   *  pointing to the first element that has a greater value than given key\n-   *  or end() if no such element exists.\n-  */\n-  iterator\n-  lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }\n-\n-  /**\n-   *  @brief Finds the beginning of a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Read-only (constant) iterator pointing to first element\n-   *           matching given key, or end() if not found.\n+   *  This is an equivalence relation.  It is linear in the size of the\n+   *  multimaps.  Multimaps are considered equivalent if their sizes are equal,\n+   *  and if corresponding elements compare equal.\n+  */\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    {\n+      return __x._M_t == __y._M_t;\n+    }\n+  \n+  /**\n+   *  @brief  Multimap ordering relation.\n+   *  @param  x  A %multimap.\n+   *  @param  y  A %multimap of the same type as @a x.\n+   *  @return  True iff @a x is lexographically less than @a y.\n    *\n-   *  This function returns the first element of a subsequence of elements\n-   *  that matches the given key.  If unsuccessful the iterator will point\n-   *  to the next greatest element or, if no such greater element exists, to\n-   *  end().\n-  */\n-  const_iterator\n-  lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }\n-\n-  /**\n-   *  @brief Finds the end of a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return Iterator pointing to last element matching given key.\n-  */\n-  iterator\n-  upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }\n-\n-  /**\n-   *  @brief Finds the end of a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Read-only (constant) iterator pointing to last element matching\n-   *           given key.\n-  */\n-  const_iterator\n-  upper_bound(const key_type& __x) const { return _M_t.upper_bound(__x); }\n-\n-  /**\n-   *  @brief Finds a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pairs to be located.\n-   *  @return  Pair of iterators that possibly points to the subsequence\n-   *           matching given key.\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  multimaps.  The elements must be comparable with @c <.\n    *\n-   *  This function returns a pair of which the first\n-   *  element possibly points to the first element matching the given key\n-   *  and the second element possibly points to the last element matching the\n-   *  given key.  If unsuccessful the first element of the returned pair will\n-   *  contain an iterator pointing to the next greatest element or, if no such\n-   *  greater element exists, to end().\n-  */\n-  pair<iterator,iterator>\n-  equal_range(const key_type& __x) { return _M_t.equal_range(__x); }\n-\n-  /**\n-   *  @brief Finds a subsequence matching given key.\n-   *  @param  x  Key of (key, value) pairs to be located.\n-   *  @return  Pair of read-only (constant) iterators that possibly points to\n-   *           the subsequence matching given key.\n-   *\n-   *  This function returns a pair of which the first\n-   *  element possibly points to the first element matching the given key\n-   *  and the second element possibly points to the last element matching the\n-   *  given key.  If unsuccessful the first element of the returned pair will\n-   *  contain an iterator pointing to the next greatest element or, if no such\n-   *  a greater element exists, to end().\n-  */\n-  pair<const_iterator,const_iterator>\n-  equal_range(const key_type& __x) const { return _M_t.equal_range(__x); }\n-\n-  template <typename _K1, typename _T1, typename _C1, typename _A1>\n-  friend bool operator== (const multimap<_K1,_T1,_C1,_A1>&,\n-                          const multimap<_K1,_T1,_C1,_A1>&);\n-  template <typename _K1, typename _T1, typename _C1, typename _A1>\n-  friend bool operator< (const multimap<_K1,_T1,_C1,_A1>&,\n-                         const multimap<_K1,_T1,_C1,_A1>&);\n-};\n-\n-\n-/**\n- *  @brief  Multimap equality comparison.\n- *  @param  x  A %multimap.\n- *  @param  y  A %multimap of the same type as @a x.\n- *  @return  True iff the size and elements of the maps are equal.\n- *\n- *  This is an equivalence relation.  It is linear in the size of the\n- *  multimaps.  Multimaps are considered equivalent if their sizes are equal,\n- *  and if corresponding elements compare equal.\n-*/\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-             const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n-  {\n-    return __x._M_t == __y._M_t;\n-  }\n-\n-/**\n- *  @brief  Multimap ordering relation.\n- *  @param  x  A %multimap.\n- *  @param  y  A %multimap of the same type as @a x.\n- *  @return  True iff @a x is lexographically less than @a y.\n- *\n- *  This is a total ordering relation.  It is linear in the size of the\n- *  multimaps.  The elements must be comparable with @c <.\n- *\n- *  See std::lexographical_compare() for how the determination is made.\n-*/\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-            const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return __x._M_t < __y._M_t; }\n-\n-/// Based on operator==\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-             const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return !(__x == __y); }\n-\n-/// Based on operator<\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-            const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return __y < __x; }\n-\n-/// Based on operator<\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-             const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return !(__y < __x); }\n-\n-/// Based on operator<\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline bool\n-  operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-             const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { return !(__x < __y); }\n-\n-/// See std::multimap::swap().\n-template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n-  inline void\n-  swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-       multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n-  { __x.swap(__y); }\n-\n+   *  See std::lexographical_compare() for how the determination is made.\n+  */\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+              const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return __x._M_t < __y._M_t; }\n+  \n+  /// Based on operator==\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return !(__x == __y); }\n+  \n+  /// Based on operator<\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+              const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return __y < __x; }\n+  \n+  /// Based on operator<\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return !(__y < __x); }\n+  \n+  /// Based on operator<\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline bool\n+    operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { return !(__x < __y); }\n+  \n+  /// See std::multimap::swap().\n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+         multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+    { __x.swap(__y); }\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_MULTIMAP_H */\n-"}, {"sha": "ff2ba266aab733becbacf413526be7ca1be7fd57", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 343, "deletions": 348, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -63,373 +63,368 @@\n \n #include <bits/concept_check.h>\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-\n-// Forward declarations of operators < and ==, needed for friend declaration.\n-\n-template <typename _Tp, typename _Sequence = deque<_Tp> >\n-class queue;\n-\n-template <typename _Tp, typename _Seq>\n-inline bool operator==(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n-\n-template <typename _Tp, typename _Seq>\n-inline bool operator<(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n-\n-\n-/**\n- *  @brief  A standard container giving FIFO behavior.\n- *\n- *  @ingroup Containers\n- *  @ingroup Sequences\n- *\n- *  Meets many of the requirements of a <a href=\"tables.html#65\">container</a>,\n- *  but does not define anything to do with iterators.  Very few of the\n- *  other standard container interfaces are defined.\n- *\n- *  This is not a true container, but an @e adaptor.  It holds another\n- *  container, and provides a wrapper interface to that container.  The\n- *  wrapper is what enforces strict first-in-first-out %queue behavior.\n- *\n- *  The second template parameter defines the type of the underlying\n- *  sequence/container.  It defaults to std::deque, but it can be any type\n- *  that supports @c front, @c back, @c push_back, and @c pop_front,\n- *  such as std::list or an appropriate user-defined type.\n- *\n- *  Members not found in \"normal\" containers are @c container_type,\n- *  which is a typedef for the second Sequence parameter, and @c push and\n- *  @c pop, which are standard %queue/FIFO operations.\n-*/\n-template <typename _Tp, typename _Sequence>\n-  class queue\n-{\n-  // concept requirements\n-  typedef typename _Sequence::value_type _Sequence_value_type;\n-  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-  __glibcpp_class_requires(_Sequence, _FrontInsertionSequenceConcept)\n-  __glibcpp_class_requires(_Sequence, _BackInsertionSequenceConcept)\n-  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n-\n-  template <typename _Tp1, typename _Seq1>\n-  friend bool operator== (const queue<_Tp1, _Seq1>&,\n-                          const queue<_Tp1, _Seq1>&);\n-  template <typename _Tp1, typename _Seq1>\n-  friend bool operator< (const queue<_Tp1, _Seq1>&,\n-                         const queue<_Tp1, _Seq1>&);\n-\n-public:\n-  typedef typename _Sequence::value_type                value_type;\n-  typedef typename _Sequence::reference                 reference;\n-  typedef typename _Sequence::const_reference           const_reference;\n-  typedef typename _Sequence::size_type                 size_type;\n-  typedef          _Sequence                            container_type;\n-\n-protected:\n-  /**\n-   *  'c' is the underlying container.  Maintainers wondering why this isn't\n-   *  uglified as per style guidelines should note that this name is\n-   *  specified in the standard, [23.2.3.1].  (Why?  Presumably for the same\n-   *  reason that it's protected instead of private:  to allow derivation.\n-   *  But none of the other containers allow for derivation.  Odd.)\n-  */\n-  _Sequence c;\n-\n-public:\n-  /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  explicit\n-  queue(const _Sequence& __c = _Sequence())\n-  : c(__c) {}\n-\n-  /**\n-   *  Returns true if the %queue is empty.\n-  */\n-  bool\n-  empty() const { return c.empty(); }\n-\n-  /**  Returns the number of elements in the %queue.  */\n-  size_type\n-  size() const { return c.size(); }\n-\n-  /**\n-   *  Returns a read/write reference to the data at the first element of the\n-   *  %queue.\n-  */\n-  reference\n-  front() { return c.front(); }\n-\n-  /**\n-   *  Returns a read-only (constant) reference to the data at the first\n-   *  element of the %queue.\n-  */\n-  const_reference\n-  front() const { return c.front(); }\n-\n-  /**\n-   *  Returns a read/write reference to the data at the last element of the\n-   *  %queue.\n-  */\n-  reference\n-  back() { return c.back(); }\n-\n+  // Forward declarations of operators < and ==, needed for friend declaration.\n+  \n+  template <typename _Tp, typename _Sequence = deque<_Tp> >\n+  class queue;\n+  \n+  template <typename _Tp, typename _Seq>\n+  inline bool operator==(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n+  \n+  template <typename _Tp, typename _Seq>\n+  inline bool operator<(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n+  \n+  \n   /**\n-   *  Returns a read-only (constant) reference to the data at the last\n-   *  element of the %queue.\n-  */\n-  const_reference\n-  back() const { return c.back(); }\n-\n-  /**\n-   *  @brief  Add data to the end of the %queue.\n-   *  @param  x  Data to be added.\n+   *  @brief  A standard container giving FIFO behavior.\n    *\n-   *  This is a typical %queue operation.  The function creates an element at\n-   *  the end of the %queue and assigns the given data to it.\n-   *  The time complexity of the operation depends on the underlying\n-   *  sequence.\n-  */\n-  void\n-  push(const value_type& __x) { c.push_back(__x); }\n-\n-  /**\n-   *  @brief  Removes first element.\n+   *  @ingroup Containers\n+   *  @ingroup Sequences\n    *\n-   *  This is a typical %queue operation.  It shrinks the %queue by one.\n-   *  The time complexity of the operation depends on the underlying\n-   *  sequence.\n+   *  Meets many of the requirements of a\n+   *  <a href=\"tables.html#65\">container</a>,\n+   *  but does not define anything to do with iterators.  Very few of the\n+   *  other standard container interfaces are defined.\n    *\n-   *  Note that no data is returned, and if the first element's data is\n-   *  needed, it should be retrieved before pop() is called.\n-  */\n-  void\n-  pop() { c.pop_front(); }\n-};\n-\n-\n-/**\n- *  @brief  Queue equality comparison.\n- *  @param  x  A %queue.\n- *  @param  y  A %queue of the same type as @a x.\n- *  @return  True iff the size and elements of the queues are equal.\n- *\n- *  This is an equivalence relation.  Complexity and semantics depend on the\n- *  underlying sequence type, but the expected rules are:  this relation is\n- *  linear in the size of the sequences, and queues are considered equivalent\n- *  if their sequences compare equal.\n-*/\n-template <typename _Tp, typename _Sequence>\n-  inline bool \n-  operator==(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-  { return __x.c == __y.c; }\n-\n-/**\n- *  @brief  Queue ordering relation.\n- *  @param  x  A %queue.\n- *  @param  y  A %queue of the same type as @a x.\n- *  @return  True iff @a x is lexographically less than @a y.\n- *\n- *  This is an total ordering relation.  Complexity and semantics depend on the\n- *  underlying sequence type, but the expected rules are:  this relation is\n- *  linear in the size of the sequences, the elements must be comparable\n- *  with @c <, and std::lexographical_compare() is usually used to make the\n- *  determination.\n-*/\n-template <typename _Tp, typename _Sequence>\n-  inline bool\n-  operator<(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-  { return __x.c < __y.c; }\n-\n-/// Based on operator==\n-template <typename _Tp, typename _Sequence>\n-  inline bool\n-  operator!=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-  { return !(__x == __y); }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Sequence>\n-  inline bool \n-  operator>(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-  { return __y < __x; }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Sequence>\n-  inline bool \n-  operator<=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-  { return !(__y < __x); }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Sequence>\n-  inline bool \n-  operator>=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-  { return !(__x < __y); }\n-\n-\n-/**\n- *  @brief  A standard container automatically sorting its contents.\n- *\n- *  @ingroup Containers\n- *  @ingroup Sequences\n- *\n- *  This is not a true container, but an @e adaptor.  It holds another\n- *  container, and provides a wrapper interface to that container.  The\n- *  wrapper is what enforces sorting and first-in-first-out %queue behavior.\n- *  Very few of the standard container/sequence interface requirements are\n- *  met (e.g., iterators).\n- *\n- *  The second template parameter defines the type of the underlying\n- *  sequence/container.  It defaults to std::vector, but it can be any type\n- *  that supports @c front(), @c push_back, @c pop_back, and random-access\n- *  iterators, such as std::deque or an appropriate user-defined type.\n- *\n- *  The third template parameter supplies the means of making priority\n- *  comparisons.  It defaults to @c less<value_type> but can be anything\n- *  defining a strict weak ordering.\n- *\n- *  Members not found in \"normal\" containers are @c container_type,\n- *  which is a typedef for the second Sequence parameter, and @c push,\n- *  @c pop, and @c top, which are standard %queue/FIFO operations.\n- *\n- *  @note  No equality/comparison operators are provided for %priority_queue.\n- *\n- *  @note  Sorting of the elements takes place as they are added to, and\n- *         removed from, the %priority_queue using the %priority_queue's\n- *         member functions.  If you access the elements by other means, and\n- *         change their data such that the sorting order would be different,\n- *         the %priority_queue will not re-sort the elements for you.  (How\n- *         could it know to do so?)\n-*/\n-template <typename _Tp, typename _Sequence = vector<_Tp>,\n-          typename _Compare  = less<typename _Sequence::value_type> >\n-  class priority_queue\n-{\n-  // concept requirements\n-  typedef typename _Sequence::value_type _Sequence_value_type;\n-  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-  __glibcpp_class_requires(_Sequence, _SequenceConcept)\n-  __glibcpp_class_requires(_Sequence, _RandomAccessContainerConcept)\n-  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n-  __glibcpp_class_requires4(_Compare, bool, _Tp, _Tp, _BinaryFunctionConcept)\n-\n-public:\n-  typedef typename _Sequence::value_type                value_type;\n-  typedef typename _Sequence::reference                 reference;\n-  typedef typename _Sequence::const_reference           const_reference;\n-  typedef typename _Sequence::size_type                 size_type;\n-  typedef          _Sequence                            container_type;\n-\n-protected:\n-  //  See queue::c for notes on these names.\n-  _Sequence  c;\n-  _Compare   comp;\n-\n-public:\n-  /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  explicit\n-  priority_queue(const _Compare& __x = _Compare(),\n-                 const _Sequence& __s = _Sequence()) \n-  : c(__s), comp(__x) \n-  { make_heap(c.begin(), c.end(), comp); }\n-\n-  /**\n-   *  @brief  Builds a %queue from a range.\n-   *  @param  first  An input iterator.\n-   *  @param  last  An input iterator.\n-   *  @param  x  A comparison functor describing a strict weak ordering.\n-   *  @param  s  An initial sequence with which to start.\n-   * \n-   *  Begins by copying @a s, inserting a copy of the elements from\n-   *  @a [first,last) into the copy of @a s, then ordering the copy\n-   *  according to @a x.\n+   *  This is not a true container, but an @e adaptor.  It holds another\n+   *  container, and provides a wrapper interface to that container.  The\n+   *  wrapper is what enforces strict first-in-first-out %queue behavior.\n    *\n-   *  For more information on function objects, see the documentation on\n-   *  @link s20_3_1_base functor base classes@endlink.\n-  */\n-  template <typename _InputIterator>\n-    priority_queue(_InputIterator __first, _InputIterator __last,\n-                   const _Compare& __x = _Compare(),\n-                   const _Sequence& __s = _Sequence())\n-    : c(__s), comp(__x)\n-    { \n-      c.insert(c.end(), __first, __last);\n-      make_heap(c.begin(), c.end(), comp);\n-    }\n-\n-  /**\n-   *  Returns true if the %queue is empty.\n+   *  The second template parameter defines the type of the underlying\n+   *  sequence/container.  It defaults to std::deque, but it can be any type\n+   *  that supports @c front, @c back, @c push_back, and @c pop_front,\n+   *  such as std::list or an appropriate user-defined type.\n+   *\n+   *  Members not found in \"normal\" containers are @c container_type,\n+   *  which is a typedef for the second Sequence parameter, and @c push and\n+   *  @c pop, which are standard %queue/FIFO operations.\n   */\n-  bool\n-  empty() const { return c.empty(); }\n-\n-  /**  Returns the number of elements in the %queue.  */\n-  size_type\n-  size() const { return c.size(); }\n-\n+  template <typename _Tp, typename _Sequence>\n+    class queue\n+  {\n+    // concept requirements\n+    typedef typename _Sequence::value_type _Sequence_value_type;\n+    __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+    __glibcpp_class_requires(_Sequence, _FrontInsertionSequenceConcept)\n+    __glibcpp_class_requires(_Sequence, _BackInsertionSequenceConcept)\n+    __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n+  \n+    template <typename _Tp1, typename _Seq1>\n+    friend bool operator== (const queue<_Tp1, _Seq1>&,\n+                            const queue<_Tp1, _Seq1>&);\n+    template <typename _Tp1, typename _Seq1>\n+    friend bool operator< (const queue<_Tp1, _Seq1>&,\n+                           const queue<_Tp1, _Seq1>&);\n+  \n+  public:\n+    typedef typename _Sequence::value_type                value_type;\n+    typedef typename _Sequence::reference                 reference;\n+    typedef typename _Sequence::const_reference           const_reference;\n+    typedef typename _Sequence::size_type                 size_type;\n+    typedef          _Sequence                            container_type;\n+  \n+  protected:\n+    /**\n+     *  'c' is the underlying container.  Maintainers wondering why this isn't\n+     *  uglified as per style guidelines should note that this name is\n+     *  specified in the standard, [23.2.3.1].  (Why?  Presumably for the same\n+     *  reason that it's protected instead of private:  to allow derivation.\n+     *  But none of the other containers allow for derivation.  Odd.)\n+    */\n+    _Sequence c;\n+  \n+  public:\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    explicit\n+    queue(const _Sequence& __c = _Sequence())\n+    : c(__c) {}\n+  \n+    /**\n+     *  Returns true if the %queue is empty.\n+    */\n+    bool\n+    empty() const { return c.empty(); }\n+  \n+    /**  Returns the number of elements in the %queue.  */\n+    size_type\n+    size() const { return c.size(); }\n+  \n+    /**\n+     *  Returns a read/write reference to the data at the first element of the\n+     *  %queue.\n+    */\n+    reference\n+    front() { return c.front(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reference to the data at the first\n+     *  element of the %queue.\n+    */\n+    const_reference\n+    front() const { return c.front(); }\n+  \n+    /**\n+     *  Returns a read/write reference to the data at the last element of the\n+     *  %queue.\n+    */\n+    reference\n+    back() { return c.back(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reference to the data at the last\n+     *  element of the %queue.\n+    */\n+    const_reference\n+    back() const { return c.back(); }\n+  \n+    /**\n+     *  @brief  Add data to the end of the %queue.\n+     *  @param  x  Data to be added.\n+     *\n+     *  This is a typical %queue operation.  The function creates an element at\n+     *  the end of the %queue and assigns the given data to it.\n+     *  The time complexity of the operation depends on the underlying\n+     *  sequence.\n+    */\n+    void\n+    push(const value_type& __x) { c.push_back(__x); }\n+  \n+    /**\n+     *  @brief  Removes first element.\n+     *\n+     *  This is a typical %queue operation.  It shrinks the %queue by one.\n+     *  The time complexity of the operation depends on the underlying\n+     *  sequence.\n+     *\n+     *  Note that no data is returned, and if the first element's data is\n+     *  needed, it should be retrieved before pop() is called.\n+    */\n+    void\n+    pop() { c.pop_front(); }\n+  };\n+  \n+  \n   /**\n-   *  Returns a read-only (constant) reference to the data at the first\n-   *  element of the %queue.\n+   *  @brief  Queue equality comparison.\n+   *  @param  x  A %queue.\n+   *  @param  y  A %queue of the same type as @a x.\n+   *  @return  True iff the size and elements of the queues are equal.\n+   *\n+   *  This is an equivalence relation.  Complexity and semantics depend on the\n+   *  underlying sequence type, but the expected rules are:  this relation is\n+   *  linear in the size of the sequences, and queues are considered equivalent\n+   *  if their sequences compare equal.\n   */\n-  const_reference\n-  top() const { return c.front(); }\n-\n+  template <typename _Tp, typename _Sequence>\n+    inline bool \n+    operator==(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    { return __x.c == __y.c; }\n+  \n   /**\n-   *  @brief  Add data to the %queue.\n-   *  @param  x  Data to be added.\n+   *  @brief  Queue ordering relation.\n+   *  @param  x  A %queue.\n+   *  @param  y  A %queue of the same type as @a x.\n+   *  @return  True iff @a x is lexographically less than @a y.\n    *\n-   *  This is a typical %queue operation.\n-   *  The time complexity of the operation depends on the underlying\n-   *  sequence.\n+   *  This is an total ordering relation.  Complexity and semantics depend on\n+   *  the underlying sequence type, but the expected rules are:  this relation\n+   *  is linear in the size of the sequences, the elements must be comparable\n+   *  with @c <, and std::lexographical_compare() is usually used to make the\n+   *  determination.\n   */\n-  void \n-  push(const value_type& __x) \n-  {\n-    try \n-      {\n-        c.push_back(__x); \n-        push_heap(c.begin(), c.end(), comp);\n-      }\n-    catch(...)\n-      {\n-        c.clear();\n-        __throw_exception_again; \n-      }\n-  }\n-\n+  template <typename _Tp, typename _Sequence>\n+    inline bool\n+    operator<(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    { return __x.c < __y.c; }\n+  \n+  /// Based on operator==\n+  template <typename _Tp, typename _Sequence>\n+    inline bool\n+    operator!=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    { return !(__x == __y); }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Sequence>\n+    inline bool \n+    operator>(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    { return __y < __x; }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Sequence>\n+    inline bool \n+    operator<=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    { return !(__y < __x); }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Sequence>\n+    inline bool \n+    operator>=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    { return !(__x < __y); }\n+  \n+  \n   /**\n-   *  @brief  Removes first element.\n+   *  @brief  A standard container automatically sorting its contents.\n    *\n-   *  This is a typical %queue operation.  It shrinks the %queue by one.\n-   *  The time complexity of the operation depends on the underlying\n-   *  sequence.\n+   *  @ingroup Containers\n+   *  @ingroup Sequences\n    *\n-   *  Note that no data is returned, and if the first element's data is\n-   *  needed, it should be retrieved before pop() is called.\n+   *  This is not a true container, but an @e adaptor.  It holds another\n+   *  container, and provides a wrapper interface to that container.  The\n+   *  wrapper is what enforces sorting and first-in-first-out %queue behavior.\n+   *  Very few of the standard container/sequence interface requirements are\n+   *  met (e.g., iterators).\n+   *\n+   *  The second template parameter defines the type of the underlying\n+   *  sequence/container.  It defaults to std::vector, but it can be any type\n+   *  that supports @c front(), @c push_back, @c pop_back, and random-access\n+   *  iterators, such as std::deque or an appropriate user-defined type.\n+   *\n+   *  The third template parameter supplies the means of making priority\n+   *  comparisons.  It defaults to @c less<value_type> but can be anything\n+   *  defining a strict weak ordering.\n+   *\n+   *  Members not found in \"normal\" containers are @c container_type,\n+   *  which is a typedef for the second Sequence parameter, and @c push,\n+   *  @c pop, and @c top, which are standard %queue/FIFO operations.\n+   *\n+   *  @note  No equality/comparison operators are provided for %priority_queue.\n+   *\n+   *  @note  Sorting of the elements takes place as they are added to, and\n+   *         removed from, the %priority_queue using the %priority_queue's\n+   *         member functions.  If you access the elements by other means, and\n+   *         change their data such that the sorting order would be different,\n+   *         the %priority_queue will not re-sort the elements for you.  (How\n+   *         could it know to do so?)\n   */\n-  void \n-  pop() \n+  template <typename _Tp, typename _Sequence = vector<_Tp>,\n+            typename _Compare  = less<typename _Sequence::value_type> >\n+    class priority_queue\n   {\n-    try \n-      {\n-        pop_heap(c.begin(), c.end(), comp);\n-        c.pop_back();\n-      }\n-    catch(...)\n-      {\n-        c.clear();\n-        __throw_exception_again; \n+    // concept requirements\n+    typedef typename _Sequence::value_type _Sequence_value_type;\n+    __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+    __glibcpp_class_requires(_Sequence, _SequenceConcept)\n+    __glibcpp_class_requires(_Sequence, _RandomAccessContainerConcept)\n+    __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n+    __glibcpp_class_requires4(_Compare, bool, _Tp, _Tp, _BinaryFunctionConcept)\n+  \n+  public:\n+    typedef typename _Sequence::value_type                value_type;\n+    typedef typename _Sequence::reference                 reference;\n+    typedef typename _Sequence::const_reference           const_reference;\n+    typedef typename _Sequence::size_type                 size_type;\n+    typedef          _Sequence                            container_type;\n+  \n+  protected:\n+    //  See queue::c for notes on these names.\n+    _Sequence  c;\n+    _Compare   comp;\n+  \n+  public:\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    explicit\n+    priority_queue(const _Compare& __x = _Compare(),\n+                   const _Sequence& __s = _Sequence()) \n+    : c(__s), comp(__x) \n+    { make_heap(c.begin(), c.end(), comp); }\n+  \n+    /**\n+     *  @brief  Builds a %queue from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     *  @param  x  A comparison functor describing a strict weak ordering.\n+     *  @param  s  An initial sequence with which to start.\n+     * \n+     *  Begins by copying @a s, inserting a copy of the elements from\n+     *  @a [first,last) into the copy of @a s, then ordering the copy\n+     *  according to @a x.\n+     *\n+     *  For more information on function objects, see the documentation on\n+     *  @link s20_3_1_base functor base classes@endlink.\n+    */\n+    template <typename _InputIterator>\n+      priority_queue(_InputIterator __first, _InputIterator __last,\n+                     const _Compare& __x = _Compare(),\n+                     const _Sequence& __s = _Sequence())\n+      : c(__s), comp(__x)\n+      { \n+        c.insert(c.end(), __first, __last);\n+        make_heap(c.begin(), c.end(), comp);\n       }\n-  }\n-};\n-\n-// No equality/comparison operators are provided for priority_queue.\n-\n+  \n+    /**\n+     *  Returns true if the %queue is empty.\n+    */\n+    bool\n+    empty() const { return c.empty(); }\n+  \n+    /**  Returns the number of elements in the %queue.  */\n+    size_type\n+    size() const { return c.size(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reference to the data at the first\n+     *  element of the %queue.\n+    */\n+    const_reference\n+    top() const { return c.front(); }\n+  \n+    /**\n+     *  @brief  Add data to the %queue.\n+     *  @param  x  Data to be added.\n+     *\n+     *  This is a typical %queue operation.\n+     *  The time complexity of the operation depends on the underlying\n+     *  sequence.\n+    */\n+    void \n+    push(const value_type& __x) \n+    {\n+      try \n+        {\n+          c.push_back(__x); \n+          push_heap(c.begin(), c.end(), comp);\n+        }\n+      catch(...)\n+        {\n+          c.clear();\n+          __throw_exception_again; \n+        }\n+    }\n+  \n+    /**\n+     *  @brief  Removes first element.\n+     *\n+     *  This is a typical %queue operation.  It shrinks the %queue by one.\n+     *  The time complexity of the operation depends on the underlying\n+     *  sequence.\n+     *\n+     *  Note that no data is returned, and if the first element's data is\n+     *  needed, it should be retrieved before pop() is called.\n+    */\n+    void \n+    pop() \n+    {\n+      try \n+        {\n+          pop_heap(c.begin(), c.end(), comp);\n+          c.pop_back();\n+        }\n+      catch(...)\n+        {\n+          c.clear();\n+          __throw_exception_again; \n+        }\n+    }\n+  };\n+  \n+  // No equality/comparison operators are provided for priority_queue.\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_QUEUE_H */\n-"}, {"sha": "7f2496c383eb740b5f523ea65fa33d894b0a65fa", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "modified", "additions": 172, "deletions": 176, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -63,192 +63,188 @@\n \n #include <bits/concept_check.h>\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-\n-// Forward declarations of operators == and <, needed for friend declaration.\n-\n-template <typename _Tp, typename _Sequence = deque<_Tp> >\n-class stack;\n-\n-template <typename _Tp, typename _Seq>\n-inline bool operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n-\n-template <typename _Tp, typename _Seq>\n-inline bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n-\n-\n-/**\n- *  @brief  A standard container giving FILO behavior.\n- *\n- *  @ingroup Containers\n- *  @ingroup Sequences\n- *\n- *  Meets many of the requirements of a <a href=\"tables.html#65\">container</a>,\n- *  but does not define anything to do with iterators.  Very few of the\n- *  other standard container interfaces are defined.\n- *\n- *  This is not a true container, but an @e adaptor.  It holds another\n- *  container, and provides a wrapper interface to that container.  The\n- *  wrapper is what enforces strict first-in-last-out %stack behavior.\n- *\n- *  The second template parameter defines the type of the underlying\n- *  sequence/container.  It defaults to std::deque, but it can be any type\n- *  that supports @c back, @c push_back, and @c pop_front, such as\n- *  std::list, std::vector, or an appropriate user-defined type.\n- *\n- *  Members not found in \"normal\" containers are @c container_type,\n- *  which is a typedef for the second Sequence parameter, and @c push,\n- *  @c pop, and @c top, which are standard %stack/FILO operations.\n-*/\n-template <typename _Tp, typename _Sequence>\n-  class stack\n-{\n-  // concept requirements\n-  typedef typename _Sequence::value_type _Sequence_value_type;\n-  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-  __glibcpp_class_requires(_Sequence, _BackInsertionSequenceConcept)\n-  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n-\n-  template <typename _Tp1, typename _Seq1>\n-  friend bool operator== (const stack<_Tp1, _Seq1>&,\n-                          const stack<_Tp1, _Seq1>&);\n-  template <typename _Tp1, typename _Seq1>\n-  friend bool operator< (const stack<_Tp1, _Seq1>&,\n-                         const stack<_Tp1, _Seq1>&);\n-\n-public:\n-  typedef typename _Sequence::value_type                value_type;\n-  typedef typename _Sequence::reference                 reference;\n-  typedef typename _Sequence::const_reference           const_reference;\n-  typedef typename _Sequence::size_type                 size_type;\n-  typedef          _Sequence                            container_type;\n-\n-protected:\n-  //  See queue::c for notes on this name.\n-  _Sequence c;\n-\n-public:\n-  // XXX removed old def ctor, added def arg to this one to match 14882\n-  /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  explicit\n-  stack(const _Sequence& __c = _Sequence())\n-  : c(__c) {}\n-\n-  /**\n-   *  Returns true if the %stack is empty.\n-  */\n-  bool\n-  empty() const { return c.empty(); }\n-\n-  /**  Returns the number of elements in the %stack.  */\n-  size_type\n-  size() const { return c.size(); }\n-\n+  // Forward declarations of operators == and <, needed for friend declaration.\n+  \n+  template <typename _Tp, typename _Sequence = deque<_Tp> >\n+  class stack;\n+  \n+  template <typename _Tp, typename _Seq>\n+  inline bool operator==(const stack<_Tp,_Seq>& __x,\n+\t                 const stack<_Tp,_Seq>& __y);\n+  \n+  template <typename _Tp, typename _Seq>\n+  inline bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n+  \n+  \n   /**\n-   *  Returns a read/write reference to the data at the first element of the\n-   *  %stack.\n-  */\n-  reference\n-  top() { return c.back(); }\n-\n-  /**\n-   *  Returns a read-only (constant) reference to the data at the first\n-   *  element of the %stack.\n+   *  @brief  A standard container giving FILO behavior.\n+   *\n+   *  @ingroup Containers\n+   *  @ingroup Sequences\n+   *\n+   *  Meets many of the requirements of a\n+   *  <a href=\"tables.html#65\">container</a>,\n+   *  but does not define anything to do with iterators.  Very few of the\n+   *  other standard container interfaces are defined.\n+   *\n+   *  This is not a true container, but an @e adaptor.  It holds another\n+   *  container, and provides a wrapper interface to that container.  The\n+   *  wrapper is what enforces strict first-in-last-out %stack behavior.\n+   *\n+   *  The second template parameter defines the type of the underlying\n+   *  sequence/container.  It defaults to std::deque, but it can be any type\n+   *  that supports @c back, @c push_back, and @c pop_front, such as\n+   *  std::list, std::vector, or an appropriate user-defined type.\n+   *\n+   *  Members not found in \"normal\" containers are @c container_type,\n+   *  which is a typedef for the second Sequence parameter, and @c push,\n+   *  @c pop, and @c top, which are standard %stack/FILO operations.\n   */\n-  const_reference\n-  top() const { return c.back(); }\n-\n+  template <typename _Tp, typename _Sequence>\n+    class stack\n+  {\n+    // concept requirements\n+    typedef typename _Sequence::value_type _Sequence_value_type;\n+    __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+    __glibcpp_class_requires(_Sequence, _BackInsertionSequenceConcept)\n+    __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n+  \n+    template <typename _Tp1, typename _Seq1>\n+    friend bool operator== (const stack<_Tp1, _Seq1>&,\n+                            const stack<_Tp1, _Seq1>&);\n+    template <typename _Tp1, typename _Seq1>\n+    friend bool operator< (const stack<_Tp1, _Seq1>&,\n+                           const stack<_Tp1, _Seq1>&);\n+  \n+  public:\n+    typedef typename _Sequence::value_type                value_type;\n+    typedef typename _Sequence::reference                 reference;\n+    typedef typename _Sequence::const_reference           const_reference;\n+    typedef typename _Sequence::size_type                 size_type;\n+    typedef          _Sequence                            container_type;\n+  \n+  protected:\n+    //  See queue::c for notes on this name.\n+    _Sequence c;\n+  \n+  public:\n+    // XXX removed old def ctor, added def arg to this one to match 14882\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    explicit\n+    stack(const _Sequence& __c = _Sequence())\n+    : c(__c) {}\n+  \n+    /**\n+     *  Returns true if the %stack is empty.\n+    */\n+    bool\n+    empty() const { return c.empty(); }\n+  \n+    /**  Returns the number of elements in the %stack.  */\n+    size_type\n+    size() const { return c.size(); }\n+  \n+    /**\n+     *  Returns a read/write reference to the data at the first element of the\n+     *  %stack.\n+    */\n+    reference\n+    top() { return c.back(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reference to the data at the first\n+     *  element of the %stack.\n+    */\n+    const_reference\n+    top() const { return c.back(); }\n+  \n+    /**\n+     *  @brief  Add data to the top of the %stack.\n+     *  @param  x  Data to be added.\n+     *\n+     *  This is a typical %stack operation.  The function creates an element at\n+     *  the top of the %stack and assigns the given data to it.\n+     *  The time complexity of the operation depends on the underlying\n+     *  sequence.\n+    */\n+    void\n+    push(const value_type& __x) { c.push_back(__x); }\n+  \n+    /**\n+     *  @brief  Removes first element.\n+     *\n+     *  This is a typical %stack operation.  It shrinks the %stack by one.\n+     *  The time complexity of the operation depends on the underlying\n+     *  sequence.\n+     *\n+     *  Note that no data is returned, and if the first element's data is\n+     *  needed, it should be retrieved before pop() is called.\n+    */\n+    void\n+    pop() { c.pop_back(); }\n+  };\n+  \n+  \n   /**\n-   *  @brief  Add data to the top of the %stack.\n-   *  @param  x  Data to be added.\n+   *  @brief  Stack equality comparison.\n+   *  @param  x  A %stack.\n+   *  @param  y  A %stack of the same type as @a x.\n+   *  @return  True iff the size and elements of the stacks are equal.\n    *\n-   *  This is a typical %stack operation.  The function creates an element at\n-   *  the top of the %stack and assigns the given data to it.\n-   *  The time complexity of the operation depends on the underlying\n-   *  sequence.\n+   *  This is an equivalence relation.  Complexity and semantics depend on the\n+   *  underlying sequence type, but the expected rules are:  this relation is\n+   *  linear in the size of the sequences, and stacks are considered equivalent\n+   *  if their sequences compare equal.\n   */\n-  void\n-  push(const value_type& __x) { c.push_back(__x); }\n-\n+  template <typename _Tp, typename _Seq>\n+    inline bool\n+    operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    { return __x.c == __y.c; }\n+  \n   /**\n-   *  @brief  Removes first element.\n-   *\n-   *  This is a typical %stack operation.  It shrinks the %stack by one.\n-   *  The time complexity of the operation depends on the underlying\n-   *  sequence.\n+   *  @brief  Stack ordering relation.\n+   *  @param  x  A %stack.\n+   *  @param  y  A %stack of the same type as @a x.\n+   *  @return  True iff @a x is lexographically less than @a y.\n    *\n-   *  Note that no data is returned, and if the first element's data is\n-   *  needed, it should be retrieved before pop() is called.\n+   *  This is an total ordering relation.  Complexity and semantics depend on\n+   *  the underlying sequence type, but the expected rules are:  this relation\n+   *  is linear in the size of the sequences, the elements must be comparable\n+   *  with @c <, and std::lexographical_compare() is usually used to make the\n+   *  determination.\n   */\n-  void\n-  pop() { c.pop_back(); }\n-};\n-\n-\n-/**\n- *  @brief  Stack equality comparison.\n- *  @param  x  A %stack.\n- *  @param  y  A %stack of the same type as @a x.\n- *  @return  True iff the size and elements of the stacks are equal.\n- *\n- *  This is an equivalence relation.  Complexity and semantics depend on the\n- *  underlying sequence type, but the expected rules are:  this relation is\n- *  linear in the size of the sequences, and stacks are considered equivalent\n- *  if their sequences compare equal.\n-*/\n-template <typename _Tp, typename _Seq>\n-  inline bool\n-  operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-  { return __x.c == __y.c; }\n-\n-/**\n- *  @brief  Stack ordering relation.\n- *  @param  x  A %stack.\n- *  @param  y  A %stack of the same type as @a x.\n- *  @return  True iff @a x is lexographically less than @a y.\n- *\n- *  This is an total ordering relation.  Complexity and semantics depend on the\n- *  underlying sequence type, but the expected rules are:  this relation is\n- *  linear in the size of the sequences, the elements must be comparable\n- *  with @c <, and std::lexographical_compare() is usually used to make the\n- *  determination.\n-*/\n-template <typename _Tp, typename _Seq>\n-  inline bool\n-  operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-  { return __x.c < __y.c; }\n-\n-/// Based on operator==\n-template <typename _Tp, typename _Seq>\n-  inline bool\n-  operator!=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-  { return !(__x == __y); }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Seq>\n-  inline bool\n-  operator>(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-  { return __y < __x; }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Seq>\n-  inline bool\n-  operator<=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-  { return !(__y < __x); }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Seq>\n-  inline bool\n-  operator>=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-  { return !(__x < __y); }\n-\n+  template <typename _Tp, typename _Seq>\n+    inline bool\n+    operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    { return __x.c < __y.c; }\n+  \n+  /// Based on operator==\n+  template <typename _Tp, typename _Seq>\n+    inline bool\n+    operator!=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    { return !(__x == __y); }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Seq>\n+    inline bool\n+    operator>(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    { return __y < __x; }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Seq>\n+    inline bool\n+    operator<=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    { return !(__y < __x); }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Seq>\n+    inline bool\n+    operator>=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+    { return !(__x < __y); }\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_STACK_H */\n-"}, {"sha": "0e6a2ef1bef32549f7e8d7dba2b976df0ed7b2c8", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 860, "deletions": 863, "changes": 1723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -65,908 +65,905 @@\n #include <bits/functexcept.h>\n #include <bits/concept_check.h>\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-\n-/// @if maint Primary default version.  @endif\n-/**\n- *  @if maint\n- *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n- *  @endif\n-*/\n-template <typename _Tp, typename _Allocator, bool _IsStatic>\n-  class _Vector_alloc_base\n-{\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-          allocator_type;\n-\n-  allocator_type\n-  get_allocator() const { return _M_data_allocator; }\n-\n-  _Vector_alloc_base(const allocator_type& __a)\n-    : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n-  {}\n-\n-protected:\n-  allocator_type _M_data_allocator;\n-  _Tp*           _M_start;\n-  _Tp*           _M_finish;\n-  _Tp*           _M_end_of_storage;\n-\n-  _Tp*\n-  _M_allocate(size_t __n) { return _M_data_allocator.allocate(__n); }\n-\n-  void\n-  _M_deallocate(_Tp* __p, size_t __n)\n-    { if (__p) _M_data_allocator.deallocate(__p, __n); }\n-};\n-\n-/// @if maint Specialization for instanceless allocators.  @endif\n-template <typename _Tp, typename _Allocator>\n-  class _Vector_alloc_base<_Tp, _Allocator, true>\n-{\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-          allocator_type;\n-\n-  allocator_type\n-  get_allocator() const { return allocator_type(); }\n-\n-  _Vector_alloc_base(const allocator_type&)\n-    : _M_start(0), _M_finish(0), _M_end_of_storage(0)\n-  {}\n-\n-protected:\n-  _Tp* _M_start;\n-  _Tp* _M_finish;\n-  _Tp* _M_end_of_storage;\n-\n-  typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;\n-\n-  _Tp*\n-  _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }\n-\n-  void\n-  _M_deallocate(_Tp* __p, size_t __n) { _Alloc_type::deallocate(__p, __n);}\n-};\n-\n-\n-/**\n- *  @if maint\n- *  See bits/stl_deque.h's _Deque_base for an explanation.\n- *  @endif\n-*/\n-template <typename _Tp, typename _Alloc>\n-  struct _Vector_base\n-  : public _Vector_alloc_base<_Tp, _Alloc,\n-                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-{\n-public:\n-  typedef _Vector_alloc_base<_Tp, _Alloc,\n-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  _Vector_base(const allocator_type& __a)\n-    : _Base(__a) {}\n-  _Vector_base(size_t __n, const allocator_type& __a)\n-    : _Base(__a)\n-  {\n-    _M_start = _M_allocate(__n);\n-    _M_finish = _M_start;\n-    _M_end_of_storage = _M_start + __n;\n-  }\n-\n-  ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n-};\n-\n-\n-/**\n- *  @brief  A standard container which offers fixed time access to individual\n- *  elements in any order.\n- *\n- *  @ingroup Containers\n- *  @ingroup Sequences\n- *\n- *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n- *  <a href=\"tables.html#66\">reversible container</a>, and a\n- *  <a href=\"tables.html#67\">sequence</a>, including the\n- *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n- *  %exception of @c push_front and @c pop_front.\n- *\n- *  In some terminology a %vector can be described as a dynamic C-style array,\n- *  it offers fast and efficient access to individual elements in any order\n- *  and saves the user from worrying about memory and size allocation.\n- *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n-*/\n-template <typename _Tp, typename _Alloc = allocator<_Tp> >\n-  class vector : protected _Vector_base<_Tp, _Alloc>\n-{\n-  // concept requirements\n-  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-\n-  typedef _Vector_base<_Tp, _Alloc>                     _Base;\n-  typedef vector<_Tp, _Alloc>                           vector_type;\n-\n-public:\n-  typedef _Tp \t\t\t\t\t\tvalue_type;\n-  typedef value_type* \t\t\t\t\tpointer;\n-  typedef const value_type* \t\t\t\tconst_pointer;\n-  typedef __gnu_cxx::__normal_iterator<pointer, vector_type> \titerator;\n-  typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>\n-                                                        const_iterator;\n-  typedef reverse_iterator<const_iterator>              const_reverse_iterator;\n-  typedef reverse_iterator<iterator>                    reverse_iterator;\n-  typedef value_type& \t\t\t\t\treference;\n-  typedef const value_type& \t\t\t\tconst_reference;\n-  typedef size_t \t\t\t\t\tsize_type;\n-  typedef ptrdiff_t \t\t\t\t\tdifference_type;\n-  typedef typename _Base::allocator_type                allocator_type;\n-\n-protected:\n-  /** @if maint\n-   *  These two functions and three data members are all from the top-most\n-   *  base class, which varies depending on the type of %allocator.  They\n-   *  should be pretty self-explanatory, as %vector uses a simple contiguous \n-   *  allocation scheme.\n-   *  @endif\n-  */\n-  using _Base::_M_allocate;\n-  using _Base::_M_deallocate;\n-  using _Base::_M_start;\n-  using _Base::_M_finish;\n-  using _Base::_M_end_of_storage;\n-\n-public:\n-  // [23.2.4.1] construct/copy/destroy\n-  // (assign() and get_allocator() are also listed in this section)\n-  /**\n-   *  @brief  Default constructor creates no elements.\n-  */\n-  explicit\n-  vector(const allocator_type& __a = allocator_type())\n-    : _Base(__a) {}\n-\n+  /// @if maint Primary default version.  @endif\n   /**\n-   *  @brief  Create a %vector with copies of an exemplar element.\n-   *  @param  n  The number of elements to initially create.\n-   *  @param  value  An element to copy.\n-   * \n-   *  This constructor fills the %vector with @a n copies of @a value.\n-  */\n-  vector(size_type __n, const value_type& __value,\n-         const allocator_type& __a = allocator_type())\n-    : _Base(__n, __a)\n-    { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }\n-\n-  /**\n-   *  @brief  Create a %vector with default elements.\n-   *  @param  n  The number of elements to initially create.\n-   * \n-   *  This constructor fills the %vector with @a n copies of a\n-   *  default-constructed element.\n-  */\n-  explicit\n-  vector(size_type __n)\n-    : _Base(__n, allocator_type())\n-    { _M_finish = uninitialized_fill_n(_M_start, __n, value_type()); }\n-\n-  /**\n-   *  @brief  %Vector copy constructor.\n-   *  @param  x  A %vector of identical element and allocator types.\n-   * \n-   *  The newly-created %vector uses a copy of the allocation object used\n-   *  by @a x.  All the elements of @a x are copied, but any extra memory in\n-   *  @a x (for fast expansion) will not be copied.\n-  */\n-  vector(const vector& __x)\n-    : _Base(__x.size(), __x.get_allocator())\n-    { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n-\n-  /**\n-   *  @brief  Builds a %vector from a range.\n-   *  @param  first  An input iterator.\n-   *  @param  last  An input iterator.\n-   * \n-   *  Create a %vector consisting of copies of the elements from [first,last).\n-   *\n-   *  If the iterators are forward, bidirectional, or random-access, then\n-   *  this will call the elements' copy constructor N times (where N is\n-   *  distance(first,last)) and do no memory reallocation.  But if only\n-   *  input iterators are used, then this will do at most 2N calls to the\n-   *  copy constructor, and logN memory reallocations.\n-  */\n-  template <typename _InputIterator>\n-    vector(_InputIterator __first, _InputIterator __last,\n-           const allocator_type& __a = allocator_type())\n-      : _Base(__a)\n-    {\n-      // Check whether it's an integral type.  If so, it's not an iterator.\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_initialize_dispatch(__first, __last, _Integral());\n-    }\n-\n-  /**\n-   *  The dtor only erases the elements, and note that if the elements\n-   *  themselves are pointers, the pointed-to memory is not touched in any\n-   *  way.  Managing the pointer is the user's responsibilty.\n-  */\n-  ~vector() { _Destroy(_M_start, _M_finish); }\n-\n-  /**\n-   *  @brief  %Vector assignment operator.\n-   *  @param  x  A %vector of identical element and allocator types.\n-   * \n-   *  All the elements of @a x are copied, but any extra memory in @a x (for\n-   *  fast expansion) will not be copied.  Unlike the copy constructor, the\n-   *  allocator object is not copied.\n-  */\n-  vector&\n-  operator=(const vector& __x);\n-\n-  /**\n-   *  @brief  Assigns a given value to a %vector.\n-   *  @param  n  Number of elements to be assigned.\n-   *  @param  val  Value to be assigned.\n-   *\n-   *  This function fills a %vector with @a n copies of the given value.\n-   *  Note that the assignment completely changes the %vector and that the\n-   *  resulting %vector's size is the same as the number of elements assigned.\n-   *  Old data may be lost.\n-  */\n-  void\n-  assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n-\n-  /**\n-   *  @brief  Assigns a range to a %vector.\n-   *  @param  first  An input iterator.\n-   *  @param  last   An input iterator.\n-   *\n-   *  This function fills a %vector with copies of the elements in the\n-   *  range [first,last).\n-   *\n-   *  Note that the assignment completely changes the %vector and that the\n-   *  resulting %vector's size is the same as the number of elements assigned.\n-   *  Old data may be lost.\n-  */\n-  template<typename _InputIterator>\n-    void\n-    assign(_InputIterator __first, _InputIterator __last)\n-    {\n-      // Check whether it's an integral type.  If so, it's not an iterator.\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_assign_dispatch(__first, __last, _Integral());\n-    }\n-\n-  /// Get a copy of the memory allocation object.\n-  allocator_type\n-  get_allocator() const { return _Base::get_allocator(); }\n-\n-  // iterators\n-  /**\n-   *  Returns a read/write iterator that points to the first element in the\n-   *  %vector.  Iteration is done in ordinary element order.\n-  */\n-  iterator\n-  begin() { return iterator (_M_start); }\n-\n-  /**\n-   *  Returns a read-only (constant) iterator that points to the first element\n-   *  in the %vector.  Iteration is done in ordinary element order.\n-  */\n-  const_iterator\n-  begin() const { return const_iterator (_M_start); }\n-\n-  /**\n-   *  Returns a read/write iterator that points one past the last element in\n-   *  the %vector.  Iteration is done in ordinary element order.\n-  */\n-  iterator\n-  end() { return iterator (_M_finish); }\n-\n-  /**\n-   *  Returns a read-only (constant) iterator that points one past the last\n-   *  element in the %vector.  Iteration is done in ordinary element order.\n-  */\n-  const_iterator\n-  end() const { return const_iterator (_M_finish); }\n-\n-  /**\n-   *  Returns a read/write reverse iterator that points to the last element in\n-   *  the %vector.  Iteration is done in reverse element order.\n-  */\n-  reverse_iterator\n-  rbegin() { return reverse_iterator(end()); }\n-\n-  /**\n-   *  Returns a read-only (constant) reverse iterator that points to the last\n-   *  element in the %vector.  Iteration is done in reverse element order.\n-  */\n-  const_reverse_iterator\n-  rbegin() const { return const_reverse_iterator(end()); }\n-\n-  /**\n-   *  Returns a read/write reverse iterator that points to one before the\n-   *  first element in the %vector.  Iteration is done in reverse element\n-   *  order.\n-  */\n-  reverse_iterator\n-  rend() { return reverse_iterator(begin()); }\n-\n-  /**\n-   *  Returns a read-only (constant) reverse iterator that points to one\n-   *  before the first element in the %vector.  Iteration is done in reverse\n-   *  element order.\n-  */\n-  const_reverse_iterator\n-  rend() const { return const_reverse_iterator(begin()); }\n-\n-  // [23.2.4.2] capacity\n-  /**  Returns the number of elements in the %vector.  */\n-  size_type\n-  size() const { return size_type(end() - begin()); }\n-\n-  /**  Returns the size() of the largest possible %vector.  */\n-  size_type\n-  max_size() const { return size_type(-1) / sizeof(value_type); }\n-\n-  /**\n-   *  @brief  Resizes the %vector to the specified number of elements.\n-   *  @param  new_size  Number of elements the %vector should contain.\n-   *  @param  x  Data with which new elements should be populated.\n-   *\n-   *  This function will %resize the %vector to the specified number of\n-   *  elements.  If the number is smaller than the %vector's current size the\n-   *  %vector is truncated, otherwise the %vector is extended and new elements\n-   *  are populated with given data.\n+   *  @if maint\n+   *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n+   *  @endif\n   */\n-  void\n-  resize(size_type __new_size, const value_type& __x)\n+  template <typename _Tp, typename _Allocator, bool _IsStatic>\n+    class _Vector_alloc_base\n   {\n-    if (__new_size < size())\n-      erase(begin() + __new_size, end());\n-    else\n-      insert(end(), __new_size - size(), __x);\n-  }\n-\n-  /**\n-   *  @brief  Resizes the %vector to the specified number of elements.\n-   *  @param  new_size  Number of elements the %vector should contain.\n-   *\n-   *  This function will resize the %vector to the specified number of\n-   *  elements.  If the number is smaller than the %vector's current size the\n-   *  %vector is truncated, otherwise the %vector is extended and new elements\n-   *  are default-constructed.\n-  */\n-  void\n-  resize(size_type __new_size) { resize(__new_size, value_type()); }\n-\n-  /**\n-   *  Returns the total number of elements that the %vector can hold before\n-   *  needing to allocate more memory.\n-  */\n-  size_type\n-  capacity() const\n-    { return size_type(const_iterator(_M_end_of_storage) - begin()); }\n-\n-  /**\n-   *  Returns true if the %vector is empty.  (Thus begin() would equal end().)\n-  */\n-  bool\n-  empty() const { return begin() == end(); }\n-\n-  /**\n-   *  @brief  Attempt to preallocate enough memory for specified number of\n-   *          elements.\n-   *  @param  n  Number of elements required.\n-   *  @throw  std::length_error  If @a n exceeds @c max_size().\n-   *\n-   *  This function attempts to reserve enough memory for the %vector to hold\n-   *  the specified number of elements.  If the number requested is more than\n-   *  max_size(), length_error is thrown.\n-   *\n-   *  The advantage of this function is that if optimal code is a necessity\n-   *  and the user can determine the number of elements that will be required,\n-   *  the user can reserve the memory in %advance, and thus prevent a possible\n-   *  reallocation of memory and copying of %vector data.\n-  */\n-  void\n-  reserve(size_type __n);\n-\n-  // element access\n-  /**\n-   *  @brief  Subscript access to the data contained in the %vector.\n-   *  @param  n  The index of the element for which data should be accessed.\n-   *  @return  Read/write reference to data.\n-   *\n-   *  This operator allows for easy, array-style, data access.\n-   *  Note that data access with this operator is unchecked and out_of_range\n-   *  lookups are not defined. (For checked lookups see at().)\n-  */\n-  reference\n-  operator[](size_type __n) { return *(begin() + __n); }\n-\n-  /**\n-   *  @brief  Subscript access to the data contained in the %vector.\n-   *  @param  n  The index of the element for which data should be accessed.\n-   *  @return  Read-only (constant) reference to data.\n-   *\n-   *  This operator allows for easy, array-style, data access.\n-   *  Note that data access with this operator is unchecked and out_of_range\n-   *  lookups are not defined. (For checked lookups see at().)\n-  */\n-  const_reference\n-  operator[](size_type __n) const { return *(begin() + __n); }\n-\n-protected:\n-  /// @if maint Safety check used only from at().  @endif\n-  void\n-  _M_range_check(size_type __n) const\n+  public:\n+    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+            allocator_type;\n+  \n+    allocator_type\n+    get_allocator() const { return _M_data_allocator; }\n+  \n+    _Vector_alloc_base(const allocator_type& __a)\n+      : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n+    {}\n+  \n+  protected:\n+    allocator_type _M_data_allocator;\n+    _Tp*           _M_start;\n+    _Tp*           _M_finish;\n+    _Tp*           _M_end_of_storage;\n+  \n+    _Tp*\n+    _M_allocate(size_t __n) { return _M_data_allocator.allocate(__n); }\n+  \n+    void\n+    _M_deallocate(_Tp* __p, size_t __n)\n+      { if (__p) _M_data_allocator.deallocate(__p, __n); }\n+  };\n+  \n+  /// @if maint Specialization for instanceless allocators.  @endif\n+  template <typename _Tp, typename _Allocator>\n+    class _Vector_alloc_base<_Tp, _Allocator, true>\n   {\n-    if (__n >= this->size())\n-      __throw_out_of_range(\"vector [] access out of range\");\n-  }\n-\n-public:\n-  /**\n-   *  @brief  Provides access to the data contained in the %vector.\n-   *  @param  n  The index of the element for which data should be accessed.\n-   *  @return  Read/write reference to data.\n-   *  @throw  std::out_of_range  If @a n is an invalid index.\n-   *\n-   *  This function provides for safer data access.  The parameter is first\n-   *  checked that it is in the range of the vector.  The function throws\n-   *  out_of_range if the check fails.\n-  */\n-  reference\n-  at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n-\n-  /**\n-   *  @brief  Provides access to the data contained in the %vector.\n-   *  @param  n  The index of the element for which data should be accessed.\n-   *  @return  Read-only (constant) reference to data.\n-   *  @throw  std::out_of_range  If @a n is an invalid index.\n-   *\n-   *  This function provides for safer data access.  The parameter is first\n-   *  checked that it is in the range of the vector.  The function throws\n-   *  out_of_range if the check fails.\n-  */\n-  const_reference\n-  at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n-\n-  /**\n-   *  Returns a read/write reference to the data at the first element of the\n-   *  %vector.\n-  */\n-  reference\n-  front() { return *begin(); }\n-\n-  /**\n-   *  Returns a read-only (constant) reference to the data at the first\n-   *  element of the %vector.\n-  */\n-  const_reference\n-  front() const { return *begin(); }\n-\n-  /**\n-   *  Returns a read/write reference to the data at the last element of the\n-   *  %vector.\n-  */\n-  reference\n-  back() { return *(end() - 1); }\n-\n-  /**\n-   *  Returns a read-only (constant) reference to the data at the last\n-   *  element of the %vector.\n-  */\n-  const_reference\n-  back() const { return *(end() - 1); }\n-\n-  // [23.2.4.3] modifiers\n+  public:\n+    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+            allocator_type;\n+  \n+    allocator_type\n+    get_allocator() const { return allocator_type(); }\n+  \n+    _Vector_alloc_base(const allocator_type&)\n+      : _M_start(0), _M_finish(0), _M_end_of_storage(0)\n+    {}\n+  \n+  protected:\n+    _Tp* _M_start;\n+    _Tp* _M_finish;\n+    _Tp* _M_end_of_storage;\n+  \n+    typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;\n+  \n+    _Tp*\n+    _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }\n+  \n+    void\n+    _M_deallocate(_Tp* __p, size_t __n) { _Alloc_type::deallocate(__p, __n);}\n+  };\n+  \n+  \n   /**\n-   *  @brief  Add data to the end of the %vector.\n-   *  @param  x  Data to be added.\n-   *\n-   *  This is a typical stack operation.  The function creates an element at\n-   *  the end of the %vector and assigns the given data to it.\n-   *  Due to the nature of a %vector this operation can be done in constant\n-   *  time if the %vector has preallocated space available.\n+   *  @if maint\n+   *  See bits/stl_deque.h's _Deque_base for an explanation.\n+   *  @endif\n   */\n-  void\n-  push_back(const value_type& __x)\n+  template <typename _Tp, typename _Alloc>\n+    struct _Vector_base\n+    : public _Vector_alloc_base<_Tp, _Alloc,\n+                                _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n   {\n-    if (_M_finish != _M_end_of_storage)\n+  public:\n+    typedef _Vector_alloc_base<_Tp, _Alloc,\n+                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+            _Base;\n+    typedef typename _Base::allocator_type allocator_type;\n+  \n+    _Vector_base(const allocator_type& __a)\n+      : _Base(__a) {}\n+    _Vector_base(size_t __n, const allocator_type& __a)\n+      : _Base(__a)\n     {\n-      _Construct(_M_finish, __x);\n-      ++_M_finish;\n+      _M_start = _M_allocate(__n);\n+      _M_finish = _M_start;\n+      _M_end_of_storage = _M_start + __n;\n     }\n-    else\n-      _M_insert_aux(end(), __x);\n-  }\n-\n-  /**\n-   *  @brief  Removes last element.\n-   *\n-   *  This is a typical stack operation. It shrinks the %vector by one.\n-   *\n-   *  Note that no data is returned, and if the last element's data is\n-   *  needed, it should be retrieved before pop_back() is called.\n-  */\n-  void\n-  pop_back()\n-  {\n-    --_M_finish;\n-    _Destroy(_M_finish);\n-  }\n-\n-  /**\n-   *  @brief  Inserts given value into %vector before specified iterator.\n-   *  @param  position  An iterator into the %vector.\n-   *  @param  x  Data to be inserted.\n-   *  @return  An iterator that points to the inserted data.\n-   *\n-   *  This function will insert a copy of the given value before the specified\n-   *  location.\n-   *  Note that this kind of operation could be expensive for a %vector and if\n-   *  it is frequently used the user should consider using std::list.\n-  */\n-  iterator\n-  insert(iterator __position, const value_type& __x);\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-  /**\n-   *  @brief  Inserts an element into the %vector.\n-   *  @param  position  An iterator into the %vector.\n-   *  @return  An iterator that points to the inserted element.\n-   *\n-   *  This function will insert a default-constructed element before the\n-   *  specified location.  You should consider using\n-   *  insert(position,value_type()) instead.\n-   *  Note that this kind of operation could be expensive for a vector and if\n-   *  it is frequently used the user should consider using std::list.\n-   *\n-   *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n-   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n-   *        c++config.h.\n-  */\n-  iterator\n-  insert(iterator __position)\n-    { return insert(__position, value_type()); }\n-#endif\n-\n-  /**\n-   *  @brief  Inserts a number of copies of given data into the %vector.\n-   *  @param  position  An iterator into the %vector.\n-   *  @param  n  Number of elements to be inserted.\n-   *  @param  x  Data to be inserted.\n+  \n+    ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n+  };\n+  \n+  \n+  /**\n+   *  @brief  A standard container which offers fixed time access to individual\n+   *  elements in any order.\n    *\n-   *  This function will insert a specified number of copies of the given data\n-   *  before the location specified by @a position.\n+   *  @ingroup Containers\n+   *  @ingroup Sequences\n    *\n-   *  Note that this kind of operation could be expensive for a %vector and if\n-   *  it is frequently used the user should consider using std::list.\n-  */\n-  void\n-  insert (iterator __pos, size_type __n, const value_type& __x)\n-    { _M_fill_insert(__pos, __n, __x); }\n-\n-  /**\n-   *  @brief  Inserts a range into the %vector.\n-   *  @param  pos  An iterator into the %vector.\n-   *  @param  first  An input iterator.\n-   *  @param  last   An input iterator.\n-   *\n-   *  This function will insert copies of the data in the range [first,last)\n-   *  into the %vector before the location specified by @a pos.\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and a\n+   *  <a href=\"tables.html#67\">sequence</a>, including the\n+   *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n+   *  %exception of @c push_front and @c pop_front.\n    *\n-   *  Note that this kind of operation could be expensive for a %vector and if\n-   *  it is frequently used the user should consider using std::list.\n+   *  In some terminology a %vector can be described as a dynamic C-style array,\n+   *  it offers fast and efficient access to individual elements in any order\n+   *  and saves the user from worrying about memory and size allocation.\n+   *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n   */\n-  template<typename _InputIterator>\n-    void\n-    insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+  template <typename _Tp, typename _Alloc = allocator<_Tp> >\n+    class vector : protected _Vector_base<_Tp, _Alloc>\n+  {\n+    // concept requirements\n+    __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+  \n+    typedef _Vector_base<_Tp, _Alloc>                     _Base;\n+    typedef vector<_Tp, _Alloc>                           vector_type;\n+  \n+  public:\n+    typedef _Tp \t\t\t\t\t\tvalue_type;\n+    typedef value_type* \t\t\t\t\tpointer;\n+    typedef const value_type* \t\t\t\tconst_pointer;\n+    typedef __gnu_cxx::__normal_iterator<pointer, vector_type> \titerator;\n+    typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>\n+                                                          const_iterator;\n+    typedef reverse_iterator<const_iterator>              const_reverse_iterator;\n+    typedef reverse_iterator<iterator>                    reverse_iterator;\n+    typedef value_type& \t\t\t\t\treference;\n+    typedef const value_type& \t\t\t\tconst_reference;\n+    typedef size_t \t\t\t\t\tsize_type;\n+    typedef ptrdiff_t \t\t\t\t\tdifference_type;\n+    typedef typename _Base::allocator_type                allocator_type;\n+  \n+  protected:\n+    /** @if maint\n+     *  These two functions and three data members are all from the top-most\n+     *  base class, which varies depending on the type of %allocator.  They\n+     *  should be pretty self-explanatory, as %vector uses a simple contiguous \n+     *  allocation scheme.\n+     *  @endif\n+    */\n+    using _Base::_M_allocate;\n+    using _Base::_M_deallocate;\n+    using _Base::_M_start;\n+    using _Base::_M_finish;\n+    using _Base::_M_end_of_storage;\n+  \n+  public:\n+    // [23.2.4.1] construct/copy/destroy\n+    // (assign() and get_allocator() are also listed in this section)\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    explicit\n+    vector(const allocator_type& __a = allocator_type())\n+      : _Base(__a) {}\n+  \n+    /**\n+     *  @brief  Create a %vector with copies of an exemplar element.\n+     *  @param  n  The number of elements to initially create.\n+     *  @param  value  An element to copy.\n+     * \n+     *  This constructor fills the %vector with @a n copies of @a value.\n+    */\n+    vector(size_type __n, const value_type& __value,\n+           const allocator_type& __a = allocator_type())\n+      : _Base(__n, __a)\n+      { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }\n+  \n+    /**\n+     *  @brief  Create a %vector with default elements.\n+     *  @param  n  The number of elements to initially create.\n+     * \n+     *  This constructor fills the %vector with @a n copies of a\n+     *  default-constructed element.\n+    */\n+    explicit\n+    vector(size_type __n)\n+      : _Base(__n, allocator_type())\n+      { _M_finish = uninitialized_fill_n(_M_start, __n, value_type()); }\n+  \n+    /**\n+     *  @brief  %Vector copy constructor.\n+     *  @param  x  A %vector of identical element and allocator types.\n+     * \n+     *  The newly-created %vector uses a copy of the allocation object used\n+     *  by @a x.  All the elements of @a x are copied, but any extra memory in\n+     *  @a x (for fast expansion) will not be copied.\n+    */\n+    vector(const vector& __x)\n+      : _Base(__x.size(), __x.get_allocator())\n+      { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n+  \n+    /**\n+     *  @brief  Builds a %vector from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     * \n+     *  Create a %vector consisting of copies of the elements from [first,last).\n+     *\n+     *  If the iterators are forward, bidirectional, or random-access, then\n+     *  this will call the elements' copy constructor N times (where N is\n+     *  distance(first,last)) and do no memory reallocation.  But if only\n+     *  input iterators are used, then this will do at most 2N calls to the\n+     *  copy constructor, and logN memory reallocations.\n+    */\n+    template <typename _InputIterator>\n+      vector(_InputIterator __first, _InputIterator __last,\n+             const allocator_type& __a = allocator_type())\n+        : _Base(__a)\n       {\n         // Check whether it's an integral type.  If so, it's not an iterator.\n         typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-        _M_insert_dispatch(__pos, __first, __last, _Integral());\n+        _M_initialize_dispatch(__first, __last, _Integral());\n       }\n-\n-  /**\n-   *  @brief  Remove element at given position.\n-   *  @param  position  Iterator pointing to element to be erased.\n-   *  @return  An iterator pointing to the next element (or end()).\n-   *\n-   *  This function will erase the element at the given position and thus\n-   *  shorten the %vector by one.\n-   *\n-   *  Note This operation could be expensive and if it is frequently used the\n-   *  user should consider using std::list.  The user is also cautioned that\n-   *  this function only erases the element, and that if the element is itself\n-   *  a pointer, the pointed-to memory is not touched in any way.  Managing\n-   *  the pointer is the user's responsibilty.\n-  */\n-  iterator\n-  erase(iterator __position);\n-\n-  /**\n-   *  @brief  Remove a range of elements.\n-   *  @param  first  Iterator pointing to the first element to be erased.\n-   *  @param  last  Iterator pointing to one past the last element to be erased.\n-   *  @return  An iterator pointing to the element pointed to by @a last\n-   *           prior to erasing (or end()).\n-   *\n-   *  This function will erase the elements in the range [first,last) and\n-   *  shorten the %vector accordingly.\n-   *\n-   *  Note This operation could be expensive and if it is frequently used the\n-   *  user should consider using std::list.  The user is also cautioned that\n-   *  this function only erases the elements, and that if the elements\n-   *  themselves are pointers, the pointed-to memory is not touched in any\n-   *  way.  Managing the pointer is the user's responsibilty.\n-  */\n-  iterator\n-  erase(iterator __first, iterator __last);\n-\n-  /**\n-   *  @brief  Swaps data with another %vector.\n-   *  @param  x  A %vector of the same element and allocator types.\n-   *\n-   *  This exchanges the elements between two vectors in constant time.\n-   *  (Three pointers, so it should be quite fast.)\n-   *  Note that the global std::swap() function is specialized such that\n-   *  std::swap(v1,v2) will feed to this function.\n-  */\n-  void\n-  swap(vector& __x)\n-  {\n-    std::swap(_M_start, __x._M_start);\n-    std::swap(_M_finish, __x._M_finish);\n-    std::swap(_M_end_of_storage, __x._M_end_of_storage);\n-  }\n-\n-  /**\n-   *  Erases all the elements.  Note that this function only erases the\n-   *  elements, and that if the elements themselves are pointers, the\n-   *  pointed-to memory is not touched in any way.  Managing the pointer is\n-   *  the user's responsibilty.\n-  */\n-  void\n-  clear() { erase(begin(), end()); }\n-\n-protected:\n-  /**\n-   *  @if maint\n-   *  Memory expansion handler.  Uses the member allocation function to\n-   *  obtain @a n bytes of memory, and then copies [first,last) into it.\n-   *  @endif\n-  */\n-  template <typename _ForwardIterator>\n-  pointer\n-    _M_allocate_and_copy(size_type __n,\n-                         _ForwardIterator __first, _ForwardIterator __last)\n-  {\n-    pointer __result = _M_allocate(__n);\n-    try\n-      {\n-        uninitialized_copy(__first, __last, __result);\n-        return __result;\n-      }\n-    catch(...)\n+  \n+    /**\n+     *  The dtor only erases the elements, and note that if the elements\n+     *  themselves are pointers, the pointed-to memory is not touched in any\n+     *  way.  Managing the pointer is the user's responsibilty.\n+    */\n+    ~vector() { _Destroy(_M_start, _M_finish); }\n+  \n+    /**\n+     *  @brief  %Vector assignment operator.\n+     *  @param  x  A %vector of identical element and allocator types.\n+     * \n+     *  All the elements of @a x are copied, but any extra memory in @a x (for\n+     *  fast expansion) will not be copied.  Unlike the copy constructor, the\n+     *  allocator object is not copied.\n+    */\n+    vector&\n+    operator=(const vector& __x);\n+  \n+    /**\n+     *  @brief  Assigns a given value to a %vector.\n+     *  @param  n  Number of elements to be assigned.\n+     *  @param  val  Value to be assigned.\n+     *\n+     *  This function fills a %vector with @a n copies of the given value.\n+     *  Note that the assignment completely changes the %vector and that the\n+     *  resulting %vector's size is the same as the number of elements assigned.\n+     *  Old data may be lost.\n+    */\n+    void\n+    assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n+  \n+    /**\n+     *  @brief  Assigns a range to a %vector.\n+     *  @param  first  An input iterator.\n+     *  @param  last   An input iterator.\n+     *\n+     *  This function fills a %vector with copies of the elements in the\n+     *  range [first,last).\n+     *\n+     *  Note that the assignment completely changes the %vector and that the\n+     *  resulting %vector's size is the same as the number of elements assigned.\n+     *  Old data may be lost.\n+    */\n+    template<typename _InputIterator>\n+      void\n+      assign(_InputIterator __first, _InputIterator __last)\n       {\n-\t_M_deallocate(__result, __n);\n-\t__throw_exception_again;\n+        // Check whether it's an integral type.  If so, it's not an iterator.\n+        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+        _M_assign_dispatch(__first, __last, _Integral());\n       }\n-  }\n-\n-\n-  // Internal constructor functions follow.\n-\n-  // called by the range constructor to implement [23.1.1]/9\n-  template<typename _Integer>\n+  \n+    /// Get a copy of the memory allocation object.\n+    allocator_type\n+    get_allocator() const { return _Base::get_allocator(); }\n+  \n+    // iterators\n+    /**\n+     *  Returns a read/write iterator that points to the first element in the\n+     *  %vector.  Iteration is done in ordinary element order.\n+    */\n+    iterator\n+    begin() { return iterator (_M_start); }\n+  \n+    /**\n+     *  Returns a read-only (constant) iterator that points to the first element\n+     *  in the %vector.  Iteration is done in ordinary element order.\n+    */\n+    const_iterator\n+    begin() const { return const_iterator (_M_start); }\n+  \n+    /**\n+     *  Returns a read/write iterator that points one past the last element in\n+     *  the %vector.  Iteration is done in ordinary element order.\n+    */\n+    iterator\n+    end() { return iterator (_M_finish); }\n+  \n+    /**\n+     *  Returns a read-only (constant) iterator that points one past the last\n+     *  element in the %vector.  Iteration is done in ordinary element order.\n+    */\n+    const_iterator\n+    end() const { return const_iterator (_M_finish); }\n+  \n+    /**\n+     *  Returns a read/write reverse iterator that points to the last element in\n+     *  the %vector.  Iteration is done in reverse element order.\n+    */\n+    reverse_iterator\n+    rbegin() { return reverse_iterator(end()); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reverse iterator that points to the last\n+     *  element in the %vector.  Iteration is done in reverse element order.\n+    */\n+    const_reverse_iterator\n+    rbegin() const { return const_reverse_iterator(end()); }\n+  \n+    /**\n+     *  Returns a read/write reverse iterator that points to one before the\n+     *  first element in the %vector.  Iteration is done in reverse element\n+     *  order.\n+    */\n+    reverse_iterator\n+    rend() { return reverse_iterator(begin()); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reverse iterator that points to one\n+     *  before the first element in the %vector.  Iteration is done in reverse\n+     *  element order.\n+    */\n+    const_reverse_iterator\n+    rend() const { return const_reverse_iterator(begin()); }\n+  \n+    // [23.2.4.2] capacity\n+    /**  Returns the number of elements in the %vector.  */\n+    size_type\n+    size() const { return size_type(end() - begin()); }\n+  \n+    /**  Returns the size() of the largest possible %vector.  */\n+    size_type\n+    max_size() const { return size_type(-1) / sizeof(value_type); }\n+  \n+    /**\n+     *  @brief  Resizes the %vector to the specified number of elements.\n+     *  @param  new_size  Number of elements the %vector should contain.\n+     *  @param  x  Data with which new elements should be populated.\n+     *\n+     *  This function will %resize the %vector to the specified number of\n+     *  elements.  If the number is smaller than the %vector's current size the\n+     *  %vector is truncated, otherwise the %vector is extended and new elements\n+     *  are populated with given data.\n+    */\n     void\n-    _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n+    resize(size_type __new_size, const value_type& __x)\n     {\n-      _M_start = _M_allocate(__n);\n-      _M_end_of_storage = _M_start + __n;\n-      _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n+      if (__new_size < size())\n+        erase(begin() + __new_size, end());\n+      else\n+        insert(end(), __new_size - size(), __x);\n     }\n-\n-  // called by the range constructor to implement [23.1.1]/9\n-  template<typename _InputIter>\n+  \n+    /**\n+     *  @brief  Resizes the %vector to the specified number of elements.\n+     *  @param  new_size  Number of elements the %vector should contain.\n+     *\n+     *  This function will resize the %vector to the specified number of\n+     *  elements.  If the number is smaller than the %vector's current size the\n+     *  %vector is truncated, otherwise the %vector is extended and new elements\n+     *  are default-constructed.\n+    */\n+    void\n+    resize(size_type __new_size) { resize(__new_size, value_type()); }\n+  \n+    /**\n+     *  Returns the total number of elements that the %vector can hold before\n+     *  needing to allocate more memory.\n+    */\n+    size_type\n+    capacity() const\n+      { return size_type(const_iterator(_M_end_of_storage) - begin()); }\n+  \n+    /**\n+     *  Returns true if the %vector is empty.  (Thus begin() would equal end().)\n+    */\n+    bool\n+    empty() const { return begin() == end(); }\n+  \n+    /**\n+     *  @brief  Attempt to preallocate enough memory for specified number of\n+     *          elements.\n+     *  @param  n  Number of elements required.\n+     *  @throw  std::length_error  If @a n exceeds @c max_size().\n+     *\n+     *  This function attempts to reserve enough memory for the %vector to hold\n+     *  the specified number of elements.  If the number requested is more than\n+     *  max_size(), length_error is thrown.\n+     *\n+     *  The advantage of this function is that if optimal code is a necessity\n+     *  and the user can determine the number of elements that will be required,\n+     *  the user can reserve the memory in %advance, and thus prevent a possible\n+     *  reallocation of memory and copying of %vector data.\n+    */\n+    void\n+    reserve(size_type __n);\n+  \n+    // element access\n+    /**\n+     *  @brief  Subscript access to the data contained in the %vector.\n+     *  @param  n  The index of the element for which data should be accessed.\n+     *  @return  Read/write reference to data.\n+     *\n+     *  This operator allows for easy, array-style, data access.\n+     *  Note that data access with this operator is unchecked and out_of_range\n+     *  lookups are not defined. (For checked lookups see at().)\n+    */\n+    reference\n+    operator[](size_type __n) { return *(begin() + __n); }\n+  \n+    /**\n+     *  @brief  Subscript access to the data contained in the %vector.\n+     *  @param  n  The index of the element for which data should be accessed.\n+     *  @return  Read-only (constant) reference to data.\n+     *\n+     *  This operator allows for easy, array-style, data access.\n+     *  Note that data access with this operator is unchecked and out_of_range\n+     *  lookups are not defined. (For checked lookups see at().)\n+    */\n+    const_reference\n+    operator[](size_type __n) const { return *(begin() + __n); }\n+  \n+  protected:\n+    /// @if maint Safety check used only from at().  @endif\n     void\n-    _M_initialize_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    _M_range_check(size_type __n) const\n     {\n-      typedef typename iterator_traits<_InputIter>::iterator_category\n-                       _IterCategory;\n-      _M_range_initialize(__first, __last, _IterCategory());\n+      if (__n >= this->size())\n+        __throw_out_of_range(\"vector [] access out of range\");\n     }\n-\n-  // called by the second initialize_dispatch above\n-  template <typename _InputIterator>\n-  void\n-    _M_range_initialize(_InputIterator __first,\n-                        _InputIterator __last, input_iterator_tag)\n-  {\n-    for ( ; __first != __last; ++__first)\n-      push_back(*__first);\n-  }\n-\n-  // called by the second initialize_dispatch above\n-  template <typename _ForwardIterator>\n-  void _M_range_initialize(_ForwardIterator __first,\n-                           _ForwardIterator __last, forward_iterator_tag)\n-  {\n-    size_type __n = distance(__first, __last);\n-    _M_start = _M_allocate(__n);\n-    _M_end_of_storage = _M_start + __n;\n-    _M_finish = uninitialized_copy(__first, __last, _M_start);\n-  }\n-\n-\n-  // Internal assign functions follow.  The *_aux functions do the actual\n-  // assignment work for the range versions.\n-\n-  // called by the range assign to implement [23.1.1]/9\n-  template<typename _Integer>\n+  \n+  public:\n+    /**\n+     *  @brief  Provides access to the data contained in the %vector.\n+     *  @param  n  The index of the element for which data should be accessed.\n+     *  @return  Read/write reference to data.\n+     *  @throw  std::out_of_range  If @a n is an invalid index.\n+     *\n+     *  This function provides for safer data access.  The parameter is first\n+     *  checked that it is in the range of the vector.  The function throws\n+     *  out_of_range if the check fails.\n+    */\n+    reference\n+    at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n+  \n+    /**\n+     *  @brief  Provides access to the data contained in the %vector.\n+     *  @param  n  The index of the element for which data should be accessed.\n+     *  @return  Read-only (constant) reference to data.\n+     *  @throw  std::out_of_range  If @a n is an invalid index.\n+     *\n+     *  This function provides for safer data access.  The parameter is first\n+     *  checked that it is in the range of the vector.  The function throws\n+     *  out_of_range if the check fails.\n+    */\n+    const_reference\n+    at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n+  \n+    /**\n+     *  Returns a read/write reference to the data at the first element of the\n+     *  %vector.\n+    */\n+    reference\n+    front() { return *begin(); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reference to the data at the first\n+     *  element of the %vector.\n+    */\n+    const_reference\n+    front() const { return *begin(); }\n+  \n+    /**\n+     *  Returns a read/write reference to the data at the last element of the\n+     *  %vector.\n+    */\n+    reference\n+    back() { return *(end() - 1); }\n+  \n+    /**\n+     *  Returns a read-only (constant) reference to the data at the last\n+     *  element of the %vector.\n+    */\n+    const_reference\n+    back() const { return *(end() - 1); }\n+  \n+    // [23.2.4.3] modifiers\n+    /**\n+     *  @brief  Add data to the end of the %vector.\n+     *  @param  x  Data to be added.\n+     *\n+     *  This is a typical stack operation.  The function creates an element at\n+     *  the end of the %vector and assigns the given data to it.\n+     *  Due to the nature of a %vector this operation can be done in constant\n+     *  time if the %vector has preallocated space available.\n+    */\n     void\n-     _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-     {\n-       _M_fill_assign(static_cast<size_type>(__n),\n-                      static_cast<value_type>(__val));\n-     }\n-\n-  // called by the range assign to implement [23.1.1]/9\n-  template<typename _InputIter>\n+    push_back(const value_type& __x)\n+    {\n+      if (_M_finish != _M_end_of_storage)\n+      {\n+        _Construct(_M_finish, __x);\n+        ++_M_finish;\n+      }\n+      else\n+        _M_insert_aux(end(), __x);\n+    }\n+  \n+    /**\n+     *  @brief  Removes last element.\n+     *\n+     *  This is a typical stack operation. It shrinks the %vector by one.\n+     *\n+     *  Note that no data is returned, and if the last element's data is\n+     *  needed, it should be retrieved before pop_back() is called.\n+    */\n     void\n-    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    pop_back()\n     {\n-      typedef typename iterator_traits<_InputIter>::iterator_category\n-                       _IterCategory;\n-      _M_assign_aux(__first, __last, _IterCategory());\n+      --_M_finish;\n+      _Destroy(_M_finish);\n     }\n-\n-  // called by the second assign_dispatch above\n-  template <typename _InputIterator>\n-    void \n-    _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-\t\t  input_iterator_tag);\n-\n-  // called by the second assign_dispatch above\n-  template <typename _ForwardIterator>\n-    void \n-    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-\t\t  forward_iterator_tag);\n-\n-  // Called by assign(n,t), and the range assign when it turns out to be the\n-  // same thing.\n-  void\n-  _M_fill_assign(size_type __n, const value_type& __val);\n-\n-\n-  // Internal insert functions follow.\n-\n-  // called by the range insert to implement [23.1.1]/9\n-  template<typename _Integer>\n+  \n+    /**\n+     *  @brief  Inserts given value into %vector before specified iterator.\n+     *  @param  position  An iterator into the %vector.\n+     *  @param  x  Data to be inserted.\n+     *  @return  An iterator that points to the inserted data.\n+     *\n+     *  This function will insert a copy of the given value before the specified\n+     *  location.\n+     *  Note that this kind of operation could be expensive for a %vector and if\n+     *  it is frequently used the user should consider using std::list.\n+    */\n+    iterator\n+    insert(iterator __position, const value_type& __x);\n+  \n+  #ifdef _GLIBCPP_DEPRECATED\n+    /**\n+     *  @brief  Inserts an element into the %vector.\n+     *  @param  position  An iterator into the %vector.\n+     *  @return  An iterator that points to the inserted element.\n+     *\n+     *  This function will insert a default-constructed element before the\n+     *  specified location.  You should consider using\n+     *  insert(position,value_type()) instead.\n+     *  Note that this kind of operation could be expensive for a vector and if\n+     *  it is frequently used the user should consider using std::list.\n+     *\n+     *  @note This was deprecated in 3.2 and will be removed in 3.4.  You must\n+     *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+     *        c++config.h.\n+    */\n+    iterator\n+    insert(iterator __position)\n+      { return insert(__position, value_type()); }\n+  #endif\n+  \n+    /**\n+     *  @brief  Inserts a number of copies of given data into the %vector.\n+     *  @param  position  An iterator into the %vector.\n+     *  @param  n  Number of elements to be inserted.\n+     *  @param  x  Data to be inserted.\n+     *\n+     *  This function will insert a specified number of copies of the given data\n+     *  before the location specified by @a position.\n+     *\n+     *  Note that this kind of operation could be expensive for a %vector and if\n+     *  it is frequently used the user should consider using std::list.\n+    */\n     void\n-    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n-                       __true_type)\n+    insert (iterator __pos, size_type __n, const value_type& __x)\n+      { _M_fill_insert(__pos, __n, __x); }\n+  \n+    /**\n+     *  @brief  Inserts a range into the %vector.\n+     *  @param  pos  An iterator into the %vector.\n+     *  @param  first  An input iterator.\n+     *  @param  last   An input iterator.\n+     *\n+     *  This function will insert copies of the data in the range [first,last)\n+     *  into the %vector before the location specified by @a pos.\n+     *\n+     *  Note that this kind of operation could be expensive for a %vector and if\n+     *  it is frequently used the user should consider using std::list.\n+    */\n+    template<typename _InputIterator>\n+      void\n+      insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+        {\n+          // Check whether it's an integral type.  If so, it's not an iterator.\n+          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+          _M_insert_dispatch(__pos, __first, __last, _Integral());\n+        }\n+  \n+    /**\n+     *  @brief  Remove element at given position.\n+     *  @param  position  Iterator pointing to element to be erased.\n+     *  @return  An iterator pointing to the next element (or end()).\n+     *\n+     *  This function will erase the element at the given position and thus\n+     *  shorten the %vector by one.\n+     *\n+     *  Note This operation could be expensive and if it is frequently used the\n+     *  user should consider using std::list.  The user is also cautioned that\n+     *  this function only erases the element, and that if the element is itself\n+     *  a pointer, the pointed-to memory is not touched in any way.  Managing\n+     *  the pointer is the user's responsibilty.\n+    */\n+    iterator\n+    erase(iterator __position);\n+  \n+    /**\n+     *  @brief  Remove a range of elements.\n+     *  @param  first  Iterator pointing to the first element to be erased.\n+     *  @param  last  Iterator pointing to one past the last element to be\n+     *                erased.\n+     *  @return  An iterator pointing to the element pointed to by @a last\n+     *           prior to erasing (or end()).\n+     *\n+     *  This function will erase the elements in the range [first,last) and\n+     *  shorten the %vector accordingly.\n+     *\n+     *  Note This operation could be expensive and if it is frequently used the\n+     *  user should consider using std::list.  The user is also cautioned that\n+     *  this function only erases the elements, and that if the elements\n+     *  themselves are pointers, the pointed-to memory is not touched in any\n+     *  way.  Managing the pointer is the user's responsibilty.\n+    */\n+    iterator\n+    erase(iterator __first, iterator __last);\n+  \n+    /**\n+     *  @brief  Swaps data with another %vector.\n+     *  @param  x  A %vector of the same element and allocator types.\n+     *\n+     *  This exchanges the elements between two vectors in constant time.\n+     *  (Three pointers, so it should be quite fast.)\n+     *  Note that the global std::swap() function is specialized such that\n+     *  std::swap(v1,v2) will feed to this function.\n+    */\n+    void\n+    swap(vector& __x)\n     {\n-      _M_fill_insert(__pos, static_cast<size_type>(__n),\n-                            static_cast<value_type>(__val));\n+      std::swap(_M_start, __x._M_start);\n+      std::swap(_M_finish, __x._M_finish);\n+      std::swap(_M_end_of_storage, __x._M_end_of_storage);\n     }\n-\n-  // called by the range insert to implement [23.1.1]/9\n-  template<typename _InputIterator>\n+  \n+    /**\n+     *  Erases all the elements.  Note that this function only erases the\n+     *  elements, and that if the elements themselves are pointers, the\n+     *  pointed-to memory is not touched in any way.  Managing the pointer is\n+     *  the user's responsibilty.\n+    */\n     void\n-    _M_insert_dispatch(iterator __pos, _InputIterator __first,\n-                       _InputIterator __last, __false_type)\n+    clear() { erase(begin(), end()); }\n+  \n+  protected:\n+    /**\n+     *  @if maint\n+     *  Memory expansion handler.  Uses the member allocation function to\n+     *  obtain @a n bytes of memory, and then copies [first,last) into it.\n+     *  @endif\n+    */\n+    template <typename _ForwardIterator>\n+    pointer\n+      _M_allocate_and_copy(size_type __n,\n+                           _ForwardIterator __first, _ForwardIterator __last)\n     {\n-      typedef typename iterator_traits<_InputIterator>::iterator_category\n-                       _IterCategory;\n-      _M_range_insert(__pos, __first, __last, _IterCategory());\n+      pointer __result = _M_allocate(__n);\n+      try\n+        {\n+          uninitialized_copy(__first, __last, __result);\n+          return __result;\n+        }\n+      catch(...)\n+        {\n+  \t_M_deallocate(__result, __n);\n+  \t__throw_exception_again;\n+        }\n     }\n-\n-  // called by the second insert_dispatch above\n-  template <typename _InputIterator>\n+  \n+  \n+    // Internal constructor functions follow.\n+  \n+    // called by the range constructor to implement [23.1.1]/9\n+    template<typename _Integer>\n+      void\n+      _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n+      {\n+        _M_start = _M_allocate(__n);\n+        _M_end_of_storage = _M_start + __n;\n+        _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n+      }\n+  \n+    // called by the range constructor to implement [23.1.1]/9\n+    template<typename _InputIter>\n+      void\n+      _M_initialize_dispatch(_InputIter __first, _InputIter __last,\n+\t                     __false_type)\n+      {\n+        typedef typename iterator_traits<_InputIter>::iterator_category\n+                         _IterCategory;\n+        _M_range_initialize(__first, __last, _IterCategory());\n+      }\n+  \n+    // called by the second initialize_dispatch above\n+    template <typename _InputIterator>\n     void\n-    _M_range_insert(iterator __pos,\n-                    _InputIterator __first, _InputIterator __last,\n-                    input_iterator_tag);\n-\n-  // called by the second insert_dispatch above\n-  template <typename _ForwardIterator>\n+      _M_range_initialize(_InputIterator __first,\n+                          _InputIterator __last, input_iterator_tag)\n+    {\n+      for ( ; __first != __last; ++__first)\n+        push_back(*__first);\n+    }\n+  \n+    // called by the second initialize_dispatch above\n+    template <typename _ForwardIterator>\n+    void _M_range_initialize(_ForwardIterator __first,\n+                             _ForwardIterator __last, forward_iterator_tag)\n+    {\n+      size_type __n = distance(__first, __last);\n+      _M_start = _M_allocate(__n);\n+      _M_end_of_storage = _M_start + __n;\n+      _M_finish = uninitialized_copy(__first, __last, _M_start);\n+    }\n+  \n+  \n+    // Internal assign functions follow.  The *_aux functions do the actual\n+    // assignment work for the range versions.\n+  \n+    // called by the range assign to implement [23.1.1]/9\n+    template<typename _Integer>\n+      void\n+       _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+       {\n+         _M_fill_assign(static_cast<size_type>(__n),\n+                        static_cast<value_type>(__val));\n+       }\n+  \n+    // called by the range assign to implement [23.1.1]/9\n+    template<typename _InputIter>\n+      void\n+      _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+      {\n+        typedef typename iterator_traits<_InputIter>::iterator_category\n+                         _IterCategory;\n+        _M_assign_aux(__first, __last, _IterCategory());\n+      }\n+  \n+    // called by the second assign_dispatch above\n+    template <typename _InputIterator>\n+      void \n+      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+  \t\t  input_iterator_tag);\n+  \n+    // called by the second assign_dispatch above\n+    template <typename _ForwardIterator>\n+      void \n+      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+  \t\t  forward_iterator_tag);\n+  \n+    // Called by assign(n,t), and the range assign when it turns out to be the\n+    // same thing.\n     void\n-    _M_range_insert(iterator __pos,\n-                    _ForwardIterator __first, _ForwardIterator __last,\n-                    forward_iterator_tag);\n-\n-  // Called by insert(p,n,x), and the range insert when it turns out to be\n-  // the same thing.\n-  void\n-  _M_fill_insert (iterator __pos, size_type __n, const value_type& __x);\n-\n-  // called by insert(p,x)\n-  void\n-  _M_insert_aux(iterator __position, const value_type& __x);\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-  // unused now (same situation as in deque)\n-  void _M_insert_aux(iterator __position);\n-#endif\n-};\n-\n-\n-/**\n- *  @brief  Vector equality comparison.\n- *  @param  x  A %vector.\n- *  @param  y  A %vector of the same type as @a x.\n- *  @return  True iff the size and elements of the vectors are equal.\n- *\n- *  This is an equivalence relation.  It is linear in the size of the\n- *  vectors.  Vectors are considered equivalent if their sizes are equal,\n- *  and if corresponding elements compare equal.\n-*/\n-template <typename _Tp, typename _Alloc>\n-  inline bool\n-  operator==(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n-  {\n-    return __x.size() == __y.size() &&\n-           equal(__x.begin(), __x.end(), __y.begin());\n-  }\n-\n-/**\n- *  @brief  Vector ordering relation.\n- *  @param  x  A %vector.\n- *  @param  y  A %vector of the same type as @a x.\n- *  @return  True iff @a x is lexographically less than @a y.\n- *\n- *  This is a total ordering relation.  It is linear in the size of the\n- *  vectors.  The elements must be comparable with @c <.\n- *\n- *  See std::lexographical_compare() for how the determination is made.\n-*/\n-template <typename _Tp, typename _Alloc>\n-  inline bool\n-  operator<(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n-  {\n-    return lexicographical_compare(__x.begin(), __x.end(),\n-                                   __y.begin(), __y.end());\n-  }\n-\n-/// Based on operator==\n-template <typename _Tp, typename _Alloc>\n-  inline bool\n-  operator!=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n-  { return !(__x == __y); }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Alloc>\n-  inline bool\n-  operator>(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n-  { return __y < __x; }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Alloc>\n-  inline bool\n-  operator<=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n-  { return !(__y < __x); }\n-\n-/// Based on operator<\n-template <typename _Tp, typename _Alloc>\n-  inline bool\n-  operator>=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n-  { return !(__x < __y); }\n-\n-/// See std::vector::swap().\n-template <typename _Tp, typename _Alloc>\n-  inline void\n-  swap(vector<_Tp,_Alloc>& __x, vector<_Tp,_Alloc>& __y)\n-  { __x.swap(__y); }\n-\n+    _M_fill_assign(size_type __n, const value_type& __val);\n+  \n+  \n+    // Internal insert functions follow.\n+  \n+    // called by the range insert to implement [23.1.1]/9\n+    template<typename _Integer>\n+      void\n+      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n+                         __true_type)\n+      {\n+        _M_fill_insert(__pos, static_cast<size_type>(__n),\n+                              static_cast<value_type>(__val));\n+      }\n+  \n+    // called by the range insert to implement [23.1.1]/9\n+    template<typename _InputIterator>\n+      void\n+      _M_insert_dispatch(iterator __pos, _InputIterator __first,\n+                         _InputIterator __last, __false_type)\n+      {\n+        typedef typename iterator_traits<_InputIterator>::iterator_category\n+                         _IterCategory;\n+        _M_range_insert(__pos, __first, __last, _IterCategory());\n+      }\n+  \n+    // called by the second insert_dispatch above\n+    template <typename _InputIterator>\n+      void\n+      _M_range_insert(iterator __pos,\n+                      _InputIterator __first, _InputIterator __last,\n+                      input_iterator_tag);\n+  \n+    // called by the second insert_dispatch above\n+    template <typename _ForwardIterator>\n+      void\n+      _M_range_insert(iterator __pos,\n+                      _ForwardIterator __first, _ForwardIterator __last,\n+                      forward_iterator_tag);\n+  \n+    // Called by insert(p,n,x), and the range insert when it turns out to be\n+    // the same thing.\n+    void\n+    _M_fill_insert (iterator __pos, size_type __n, const value_type& __x);\n+  \n+    // called by insert(p,x)\n+    void\n+    _M_insert_aux(iterator __position, const value_type& __x);\n+  \n+  #ifdef _GLIBCPP_DEPRECATED\n+    // unused now (same situation as in deque)\n+    void _M_insert_aux(iterator __position);\n+  #endif\n+  };\n+  \n+  \n+  /**\n+   *  @brief  Vector equality comparison.\n+   *  @param  x  A %vector.\n+   *  @param  y  A %vector of the same type as @a x.\n+   *  @return  True iff the size and elements of the vectors are equal.\n+   *\n+   *  This is an equivalence relation.  It is linear in the size of the\n+   *  vectors.  Vectors are considered equivalent if their sizes are equal,\n+   *  and if corresponding elements compare equal.\n+  */\n+  template <typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    {\n+      return __x.size() == __y.size() &&\n+             equal(__x.begin(), __x.end(), __y.begin());\n+    }\n+  \n+  /**\n+   *  @brief  Vector ordering relation.\n+   *  @param  x  A %vector.\n+   *  @param  y  A %vector of the same type as @a x.\n+   *  @return  True iff @a x is lexographically less than @a y.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  vectors.  The elements must be comparable with @c <.\n+   *\n+   *  See std::lexographical_compare() for how the determination is made.\n+  */\n+  template <typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    {\n+      return lexicographical_compare(__x.begin(), __x.end(),\n+                                     __y.begin(), __y.end());\n+    }\n+  \n+  /// Based on operator==\n+  template <typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    { return !(__x == __y); }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    { return __y < __x; }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    { return !(__y < __x); }\n+  \n+  /// Based on operator<\n+  template <typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n+    { return !(__x < __y); }\n+  \n+  /// See std::vector::swap().\n+  template <typename _Tp, typename _Alloc>\n+    inline void\n+    swap(vector<_Tp,_Alloc>& __x, vector<_Tp,_Alloc>& __y)\n+    { __x.swap(__y); }\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_VECTOR_H */"}, {"sha": "9b21d0da9fcef752273845b5ff6b65bd92dffed4", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 302, "deletions": 306, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3971a4d235bd87ba9bcfe3b3b103ca173b7f3646/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=3971a4d235bd87ba9bcfe3b3b103ca173b7f3646", "patch": "@@ -61,379 +61,375 @@\n #ifndef __GLIBCPP_INTERNAL_VECTOR_TCC\n #define __GLIBCPP_INTERNAL_VECTOR_TCC\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-\n-template <typename _Tp, typename _Alloc>\n-  void\n-  vector<_Tp,_Alloc>::\n-  reserve(size_type __n)\n-  {\n-    if (capacity() < __n)\n-    {\n-      const size_type __old_size = size();\n-      pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);\n-      _Destroy(_M_start, _M_finish);\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __tmp;\n-      _M_finish = __tmp + __old_size;\n-      _M_end_of_storage = _M_start + __n;\n-    }\n-  }\n-\n-template <typename _Tp, typename _Alloc>\n-  typename vector<_Tp,_Alloc>::iterator\n-  vector<_Tp,_Alloc>::\n-  insert(iterator __position, const value_type& __x)\n-  {\n-    size_type __n = __position - begin();\n-    if (_M_finish != _M_end_of_storage && __position == end())\n+  template <typename _Tp, typename _Alloc>\n+    void\n+    vector<_Tp,_Alloc>::\n+    reserve(size_type __n)\n     {\n-      _Construct(_M_finish, __x);\n-      ++_M_finish;\n-    }\n-    else\n-      _M_insert_aux(__position, __x);\n-    return begin() + __n;\n-  }\n-\n-template <typename _Tp, typename _Alloc>\n-  typename vector<_Tp,_Alloc>::iterator\n-  vector<_Tp,_Alloc>::\n-  erase(iterator __position)\n-  {\n-    if (__position + 1 != end())\n-      copy(__position + 1, end(), __position);\n-    --_M_finish;\n-    _Destroy(_M_finish);\n-    return __position;\n-  }\n-\n-template <typename _Tp, typename _Alloc>\n-  typename vector<_Tp,_Alloc>::iterator\n-  vector<_Tp,_Alloc>::\n-  erase(iterator __first, iterator __last)\n-  {\n-    iterator __i(copy(__last, end(), __first));\n-    _Destroy(__i, end());\n-    _M_finish = _M_finish - (__last - __first);\n-    return __first;\n-  }\n-\n-template <typename _Tp, typename _Alloc>\n-  vector<_Tp,_Alloc>&\n-  vector<_Tp,_Alloc>::\n-  operator=(const vector<_Tp,_Alloc>& __x)\n-  {\n-    if (&__x != this)\n-    {\n-      const size_type __xlen = __x.size();\n-      if (__xlen > capacity())\n+      if (capacity() < __n)\n       {\n-        pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());\n+        const size_type __old_size = size();\n+        pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);\n         _Destroy(_M_start, _M_finish);\n         _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n         _M_start = __tmp;\n-        _M_end_of_storage = _M_start + __xlen;\n+        _M_finish = __tmp + __old_size;\n+        _M_end_of_storage = _M_start + __n;\n       }\n-      else if (size() >= __xlen)\n+    }\n+  \n+  template <typename _Tp, typename _Alloc>\n+    typename vector<_Tp,_Alloc>::iterator\n+    vector<_Tp,_Alloc>::\n+    insert(iterator __position, const value_type& __x)\n+    {\n+      size_type __n = __position - begin();\n+      if (_M_finish != _M_end_of_storage && __position == end())\n       {\n-        iterator __i(copy(__x.begin(), __x.end(), begin()));\n-        _Destroy(__i, end());\n+        _Construct(_M_finish, __x);\n+        ++_M_finish;\n       }\n       else\n-      {\n-        copy(__x.begin(), __x.begin() + size(), _M_start);\n-        uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);\n-      }\n-      _M_finish = _M_start + __xlen;\n+        _M_insert_aux(__position, __x);\n+      return begin() + __n;\n     }\n-    return *this;\n-  }\n-\n-template <typename _Tp, typename _Alloc>\n-  void\n-  vector<_Tp,_Alloc>::\n-  _M_fill_assign(size_t __n, const value_type& __val)\n-  {\n-    if (__n > capacity())\n+  \n+  template <typename _Tp, typename _Alloc>\n+    typename vector<_Tp,_Alloc>::iterator\n+    vector<_Tp,_Alloc>::\n+    erase(iterator __position)\n     {\n-      vector __tmp(__n, __val, get_allocator());\n-      __tmp.swap(*this);\n+      if (__position + 1 != end())\n+        copy(__position + 1, end(), __position);\n+      --_M_finish;\n+      _Destroy(_M_finish);\n+      return __position;\n     }\n-    else if (__n > size())\n+  \n+  template <typename _Tp, typename _Alloc>\n+    typename vector<_Tp,_Alloc>::iterator\n+    vector<_Tp,_Alloc>::\n+    erase(iterator __first, iterator __last)\n     {\n-      fill(begin(), end(), __val);\n-      _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);\n+      iterator __i(copy(__last, end(), __first));\n+      _Destroy(__i, end());\n+      _M_finish = _M_finish - (__last - __first);\n+      return __first;\n     }\n-    else\n-      erase(fill_n(begin(), __n, __val), end());\n-  }\n-\n-template <typename _Tp, typename _Alloc> template <typename _InputIter>\n-  void\n-  vector<_Tp,_Alloc>::\n-  _M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n-  {\n-    iterator __cur(begin());\n-    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n-      *__cur = *__first;\n-    if (__first == __last)\n-      erase(__cur, end());\n-    else\n-      insert(end(), __first, __last);\n-  }\n-\n-template <typename _Tp, typename _Alloc> template <typename _ForwardIter>\n-  void\n-  vector<_Tp,_Alloc>::\n-  _M_assign_aux(_ForwardIter __first, _ForwardIter __last, forward_iterator_tag)\n-  {\n-    size_type __len = distance(__first, __last);\n-\n-    if (__len > capacity())\n-    {\n-      pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n-      _Destroy(_M_start, _M_finish);\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __tmp;\n-      _M_end_of_storage = _M_finish = _M_start + __len;\n-    }\n-    else if (size() >= __len)\n-    {\n-      iterator __new_finish(copy(__first, __last, _M_start));\n-      _Destroy(__new_finish, end());\n-      _M_finish = __new_finish.base();\n-    }\n-    else\n+  \n+  template <typename _Tp, typename _Alloc>\n+    vector<_Tp,_Alloc>&\n+    vector<_Tp,_Alloc>::\n+    operator=(const vector<_Tp,_Alloc>& __x)\n     {\n-      _ForwardIter __mid = __first;\n-      advance(__mid, size());\n-      copy(__first, __mid, _M_start);\n-      _M_finish = uninitialized_copy(__mid, __last, _M_finish);\n-    }\n-  }\n-\n-template <typename _Tp, typename _Alloc>\n-  void\n-  vector<_Tp,_Alloc>::\n-  _M_insert_aux(iterator __position, const _Tp& __x)\n-  {\n-    if (_M_finish != _M_end_of_storage)\n-    {\n-      _Construct(_M_finish, *(_M_finish - 1));\n-      ++_M_finish;\n-      _Tp __x_copy = __x;\n-      copy_backward(__position, iterator(_M_finish-2), iterator(_M_finish-1));\n-      *__position = __x_copy;\n-    }\n-    else\n-    {\n-      const size_type __old_size = size();\n-      const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n-      iterator __new_start(_M_allocate(__len));\n-      iterator __new_finish(__new_start);\n-      try\n+      if (&__x != this)\n+      {\n+        const size_type __xlen = __x.size();\n+        if (__xlen > capacity())\n         {\n-          __new_finish = uninitialized_copy(iterator(_M_start), __position,\n-                                            __new_start);\n-          _Construct(__new_finish.base(), __x);\n-          ++__new_finish;\n-          __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n-                                            __new_finish);\n+          pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());\n+          _Destroy(_M_start, _M_finish);\n+          _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+          _M_start = __tmp;\n+          _M_end_of_storage = _M_start + __xlen;\n         }\n-      catch(...)\n+        else if (size() >= __xlen)\n         {\n-          _Destroy(__new_start,__new_finish);\n-          _M_deallocate(__new_start.base(),__len);\n-          __throw_exception_again;\n+          iterator __i(copy(__x.begin(), __x.end(), begin()));\n+          _Destroy(__i, end());\n         }\n-      _Destroy(begin(), end());\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __new_start.base();\n-      _M_finish = __new_finish.base();\n-      _M_end_of_storage = __new_start.base() + __len;\n+        else\n+        {\n+          copy(__x.begin(), __x.begin() + size(), _M_start);\n+          uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);\n+        }\n+        _M_finish = _M_start + __xlen;\n+      }\n+      return *this;\n     }\n-  }\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-template <typename _Tp, typename _Alloc>\n-  void\n-  vector<_Tp,_Alloc>::\n-  _M_insert_aux(iterator __position)\n-  {\n-    if (_M_finish != _M_end_of_storage)\n+  \n+  template <typename _Tp, typename _Alloc>\n+    void\n+    vector<_Tp,_Alloc>::\n+    _M_fill_assign(size_t __n, const value_type& __val)\n     {\n-      _Construct(_M_finish, *(_M_finish - 1));\n-      ++_M_finish;\n-      copy_backward(__position, iterator(_M_finish - 2),\n-                    iterator(_M_finish - 1));\n-      *__position = value_type();\n+      if (__n > capacity())\n+      {\n+        vector __tmp(__n, __val, get_allocator());\n+        __tmp.swap(*this);\n+      }\n+      else if (__n > size())\n+      {\n+        fill(begin(), end(), __val);\n+        _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);\n+      }\n+      else\n+        erase(fill_n(begin(), __n, __val), end());\n     }\n-    else\n+  \n+  template <typename _Tp, typename _Alloc> template <typename _InputIter>\n+    void\n+    vector<_Tp,_Alloc>::\n+    _M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n     {\n-      const size_type __old_size = size();\n-      const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n-      pointer __new_start = _M_allocate(__len);\n-      pointer __new_finish = __new_start;\n-      try\n-        {\n-          __new_finish = uninitialized_copy(iterator(_M_start), __position,\n-                                            __new_start);\n-          _Construct(__new_finish);\n-          ++__new_finish;\n-          __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n-                                            __new_finish);\n-        }\n-      catch(...)\n-        {\n-          _Destroy(__new_start,__new_finish);\n-          _M_deallocate(__new_start,__len);\n-          __throw_exception_again;\n-        }\n-      _Destroy(begin(), end());\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __new_start;\n-      _M_finish = __new_finish;\n-      _M_end_of_storage = __new_start + __len;\n+      iterator __cur(begin());\n+      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n+        *__cur = *__first;\n+      if (__first == __last)\n+        erase(__cur, end());\n+      else\n+        insert(end(), __first, __last);\n     }\n-  }\n-#endif\n-\n-template <typename _Tp, typename _Alloc>\n-  void\n-  vector<_Tp,_Alloc>::\n-  _M_fill_insert(iterator __position, size_type __n, const value_type& __x)\n-  {\n-    if (__n != 0)\n+  \n+  template <typename _Tp, typename _Alloc> template <typename _ForwardIter>\n+    void\n+    vector<_Tp,_Alloc>::\n+    _M_assign_aux(_ForwardIter __first, _ForwardIter __last,\n+                  forward_iterator_tag)\n     {\n-      if (size_type(_M_end_of_storage - _M_finish) >= __n) {\n-        value_type __x_copy = __x;\n-        const size_type __elems_after = end() - __position;\n-        iterator __old_finish(_M_finish);\n-        if (__elems_after > __n)\n-        {\n-          uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n-          _M_finish += __n;\n-          copy_backward(__position, __old_finish - __n, __old_finish);\n-          fill(__position, __position + __n, __x_copy);\n-        }\n-        else\n-        {\n-          uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);\n-          _M_finish += __n - __elems_after;\n-          uninitialized_copy(__position, __old_finish, _M_finish);\n-          _M_finish += __elems_after;\n-          fill(__position, __old_finish, __x_copy);\n-        }\n+      size_type __len = distance(__first, __last);\n+  \n+      if (__len > capacity())\n+      {\n+        pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n+        _Destroy(_M_start, _M_finish);\n+        _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+        _M_start = __tmp;\n+        _M_end_of_storage = _M_finish = _M_start + __len;\n+      }\n+      else if (size() >= __len)\n+      {\n+        iterator __new_finish(copy(__first, __last, _M_start));\n+        _Destroy(__new_finish, end());\n+        _M_finish = __new_finish.base();\n+      }\n+      else\n+      {\n+        _ForwardIter __mid = __first;\n+        advance(__mid, size());\n+        copy(__first, __mid, _M_start);\n+        _M_finish = uninitialized_copy(__mid, __last, _M_finish);\n+      }\n+    }\n+  \n+  template <typename _Tp, typename _Alloc>\n+    void\n+    vector<_Tp,_Alloc>::\n+    _M_insert_aux(iterator __position, const _Tp& __x)\n+    {\n+      if (_M_finish != _M_end_of_storage)\n+      {\n+        _Construct(_M_finish, *(_M_finish - 1));\n+        ++_M_finish;\n+        _Tp __x_copy = __x;\n+        copy_backward(__position, iterator(_M_finish-2), iterator(_M_finish-1));\n+        *__position = __x_copy;\n       }\n       else\n       {\n         const size_type __old_size = size();\n-        const size_type __len = __old_size + max(__old_size, __n);\n+        const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n         iterator __new_start(_M_allocate(__len));\n         iterator __new_finish(__new_start);\n         try\n           {\n-            __new_finish = uninitialized_copy(begin(), __position, __new_start);\n-            __new_finish = uninitialized_fill_n(__new_finish, __n, __x);\n-            __new_finish\n-              = uninitialized_copy(__position, end(), __new_finish);\n+            __new_finish = uninitialized_copy(iterator(_M_start), __position,\n+                                              __new_start);\n+            _Construct(__new_finish.base(), __x);\n+            ++__new_finish;\n+            __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n+                                              __new_finish);\n           }\n         catch(...)\n           {\n             _Destroy(__new_start,__new_finish);\n             _M_deallocate(__new_start.base(),__len);\n             __throw_exception_again;\n           }\n-        _Destroy(_M_start, _M_finish);\n+        _Destroy(begin(), end());\n         _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n         _M_start = __new_start.base();\n         _M_finish = __new_finish.base();\n         _M_end_of_storage = __new_start.base() + __len;\n       }\n     }\n-  }\n-\n-template <typename _Tp, typename _Alloc> template <typename _InputIterator>\n-  void\n-  vector<_Tp,_Alloc>::\n-  _M_range_insert(iterator __pos,\n-                  _InputIterator __first, _InputIterator __last,\n-                  input_iterator_tag)\n-  {\n-    for ( ; __first != __last; ++__first)\n-    {\n-      __pos = insert(__pos, *__first);\n-      ++__pos;\n-    }\n-  }\n-\n-template <typename _Tp, typename _Alloc> template <typename _ForwardIterator>\n-  void\n-  vector<_Tp,_Alloc>::\n-  _M_range_insert(iterator __position,\n-                  _ForwardIterator __first, _ForwardIterator __last,\n-                  forward_iterator_tag)\n-  {\n-    if (__first != __last)\n+  \n+  #ifdef _GLIBCPP_DEPRECATED\n+  template <typename _Tp, typename _Alloc>\n+    void\n+    vector<_Tp,_Alloc>::\n+    _M_insert_aux(iterator __position)\n     {\n-      size_type __n = distance(__first, __last);\n-      if (size_type(_M_end_of_storage - _M_finish) >= __n)\n+      if (_M_finish != _M_end_of_storage)\n       {\n-        const size_type __elems_after = end() - __position;\n-        iterator __old_finish(_M_finish);\n-        if (__elems_after > __n)\n-        {\n-          uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n-          _M_finish += __n;\n-          copy_backward(__position, __old_finish - __n, __old_finish);\n-          copy(__first, __last, __position);\n-        }\n-        else\n-        {\n-          _ForwardIterator __mid = __first;\n-          advance(__mid, __elems_after);\n-          uninitialized_copy(__mid, __last, _M_finish);\n-          _M_finish += __n - __elems_after;\n-          uninitialized_copy(__position, __old_finish, _M_finish);\n-          _M_finish += __elems_after;\n-          copy(__first, __mid, __position);\n-        }\n+        _Construct(_M_finish, *(_M_finish - 1));\n+        ++_M_finish;\n+        copy_backward(__position, iterator(_M_finish - 2),\n+                      iterator(_M_finish - 1));\n+        *__position = value_type();\n       }\n       else\n       {\n         const size_type __old_size = size();\n-        const size_type __len = __old_size + max(__old_size, __n);\n-        iterator __new_start(_M_allocate(__len));\n-        iterator __new_finish(__new_start);\n+        const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n+        pointer __new_start = _M_allocate(__len);\n+        pointer __new_finish = __new_start;\n         try\n           {\n-            __new_finish = uninitialized_copy(iterator(_M_start),\n-                                              __position, __new_start);\n-            __new_finish = uninitialized_copy(__first, __last, __new_finish);\n+            __new_finish = uninitialized_copy(iterator(_M_start), __position,\n+                                              __new_start);\n+            _Construct(__new_finish);\n+            ++__new_finish;\n             __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n                                               __new_finish);\n           }\n         catch(...)\n           {\n             _Destroy(__new_start,__new_finish);\n-            _M_deallocate(__new_start.base(), __len);\n+            _M_deallocate(__new_start,__len);\n             __throw_exception_again;\n           }\n-        _Destroy(_M_start, _M_finish);\n+        _Destroy(begin(), end());\n         _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-        _M_start = __new_start.base();\n-        _M_finish = __new_finish.base();\n-        _M_end_of_storage = __new_start.base() + __len;\n+        _M_start = __new_start;\n+        _M_finish = __new_finish;\n+        _M_end_of_storage = __new_start + __len;\n+      }\n+    }\n+  #endif\n+  \n+  template <typename _Tp, typename _Alloc>\n+    void\n+    vector<_Tp,_Alloc>::\n+    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)\n+    {\n+      if (__n != 0)\n+      {\n+        if (size_type(_M_end_of_storage - _M_finish) >= __n) {\n+          value_type __x_copy = __x;\n+          const size_type __elems_after = end() - __position;\n+          iterator __old_finish(_M_finish);\n+          if (__elems_after > __n)\n+          {\n+            uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n+            _M_finish += __n;\n+            copy_backward(__position, __old_finish - __n, __old_finish);\n+            fill(__position, __position + __n, __x_copy);\n+          }\n+          else\n+          {\n+            uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);\n+            _M_finish += __n - __elems_after;\n+            uninitialized_copy(__position, __old_finish, _M_finish);\n+            _M_finish += __elems_after;\n+            fill(__position, __old_finish, __x_copy);\n+          }\n+        }\n+        else\n+        {\n+          const size_type __old_size = size();\n+          const size_type __len = __old_size + max(__old_size, __n);\n+          iterator __new_start(_M_allocate(__len));\n+          iterator __new_finish(__new_start);\n+          try\n+            {\n+              __new_finish = uninitialized_copy(begin(), __position,\n+                                                __new_start);\n+              __new_finish = uninitialized_fill_n(__new_finish, __n, __x);\n+              __new_finish\n+                = uninitialized_copy(__position, end(), __new_finish);\n+            }\n+          catch(...)\n+            {\n+              _Destroy(__new_start,__new_finish);\n+              _M_deallocate(__new_start.base(),__len);\n+              __throw_exception_again;\n+            }\n+          _Destroy(_M_start, _M_finish);\n+          _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+          _M_start = __new_start.base();\n+          _M_finish = __new_finish.base();\n+          _M_end_of_storage = __new_start.base() + __len;\n+        }\n+      }\n+    }\n+  \n+  template <typename _Tp, typename _Alloc> template <typename _InputIterator>\n+    void\n+    vector<_Tp,_Alloc>::\n+    _M_range_insert(iterator __pos,\n+                    _InputIterator __first, _InputIterator __last,\n+                    input_iterator_tag)\n+    {\n+      for ( ; __first != __last; ++__first)\n+      {\n+        __pos = insert(__pos, *__first);\n+        ++__pos;\n+      }\n+    }\n+  \n+  template <typename _Tp, typename _Alloc> template <typename _ForwardIterator>\n+    void\n+    vector<_Tp,_Alloc>::\n+    _M_range_insert(iterator __position,\n+                    _ForwardIterator __first, _ForwardIterator __last,\n+                    forward_iterator_tag)\n+    {\n+      if (__first != __last)\n+      {\n+        size_type __n = distance(__first, __last);\n+        if (size_type(_M_end_of_storage - _M_finish) >= __n)\n+        {\n+          const size_type __elems_after = end() - __position;\n+          iterator __old_finish(_M_finish);\n+          if (__elems_after > __n)\n+          {\n+            uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n+            _M_finish += __n;\n+            copy_backward(__position, __old_finish - __n, __old_finish);\n+            copy(__first, __last, __position);\n+          }\n+          else\n+          {\n+            _ForwardIterator __mid = __first;\n+            advance(__mid, __elems_after);\n+            uninitialized_copy(__mid, __last, _M_finish);\n+            _M_finish += __n - __elems_after;\n+            uninitialized_copy(__position, __old_finish, _M_finish);\n+            _M_finish += __elems_after;\n+            copy(__first, __mid, __position);\n+          }\n+        }\n+        else\n+        {\n+          const size_type __old_size = size();\n+          const size_type __len = __old_size + max(__old_size, __n);\n+          iterator __new_start(_M_allocate(__len));\n+          iterator __new_finish(__new_start);\n+          try\n+            {\n+              __new_finish = uninitialized_copy(iterator(_M_start),\n+                                                __position, __new_start);\n+              __new_finish = uninitialized_copy(__first, __last, __new_finish);\n+              __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n+                                                __new_finish);\n+            }\n+          catch(...)\n+            {\n+              _Destroy(__new_start,__new_finish);\n+              _M_deallocate(__new_start.base(), __len);\n+              __throw_exception_again;\n+            }\n+          _Destroy(_M_start, _M_finish);\n+          _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+          _M_start = __new_start.base();\n+          _M_finish = __new_finish.base();\n+          _M_end_of_storage = __new_start.base() + __len;\n+        }\n       }\n     }\n-  }\n-\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_VECTOR_TCC */\n-"}]}