{"sha": "ec730df5fc5d0e879363556e6d9032f3104d0f49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM3MzBkZjVmYzVkMGU4NzkzNjM1NTZlNmQ5MDMyZjMxMDRkMGY0OQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@redhat.com", "date": "2004-03-09T19:14:23Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2004-03-09T19:14:23Z"}, "message": "Makefile.am: Build property resource files into libgcj.\n\n2004-03-08  Anthony Green  <green@redhat.com>\n\n\t* Makefile.am: Build property resource files into libgcj.\n\t* Makefile.in: Rebuilt.\n\t* java/util/regex/Matcher.java, java/util/regex/Pattern.java,\n\tjava/util/regex/PatternSyntaxException.java,\n\tgnu/regexp/CharIndexed.java,\n\tgnu/regexp/CharIndexedCharArray.java,\n\tgnu/regexp/CharIndexedInputStream.java,\n\tgnu/regexp/CharIndexedReader.java,\n\tgnu/regexp/CharIndexedString.java,\n\tgnu/regexp/CharIndexedStringBuffer.java, gnu/regexp/RE.java,\n\tgnu/regexp/REException.java,\n\tgnu/regexp/REFilterInputStream.java,\n\tgnu/regexp/REFilterReader.java, gnu/regexp/REMatch.java,\n\tgnu/regexp/REMatchEnumeration.java, gnu/regexp/RESyntax.java,\n\tgnu/regexp/REToken.java, gnu/regexp/RETokenAny.java,\n\tgnu/regexp/RETokenBackRef.java, gnu/regexp/RETokenChar.java,\n\tgnu/regexp/RETokenEnd.java, gnu/regexp/RETokenEndSub.java,\n\tgnu/regexp/RETokenLookAhead.java,\n\tgnu/regexp/RETokenOneOf.java, gnu/regexp/RETokenPOSIX.java,\n\tgnu/regexp/RETokenRange.java, gnu/regexp/RETokenRepeated.java,\n\tgnu/regexp/RETokenStart.java,\n\tgnu/regexp/RETokenWordBoundary.java,\n\tgnu/regexp/UncheckedRE.java: Files merged from GNU Classpath.\n\nFrom-SVN: r79198", "tree": {"sha": "d283cb10bc6a847ef8b3a81e1a9939e713be32eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d283cb10bc6a847ef8b3a81e1a9939e713be32eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec730df5fc5d0e879363556e6d9032f3104d0f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec730df5fc5d0e879363556e6d9032f3104d0f49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec730df5fc5d0e879363556e6d9032f3104d0f49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec730df5fc5d0e879363556e6d9032f3104d0f49/comments", "author": {"login": "atgreen", "id": 89993, "node_id": "MDQ6VXNlcjg5OTkz", "avatar_url": "https://avatars.githubusercontent.com/u/89993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atgreen", "html_url": "https://github.com/atgreen", "followers_url": "https://api.github.com/users/atgreen/followers", "following_url": "https://api.github.com/users/atgreen/following{/other_user}", "gists_url": "https://api.github.com/users/atgreen/gists{/gist_id}", "starred_url": "https://api.github.com/users/atgreen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atgreen/subscriptions", "organizations_url": "https://api.github.com/users/atgreen/orgs", "repos_url": "https://api.github.com/users/atgreen/repos", "events_url": "https://api.github.com/users/atgreen/events{/privacy}", "received_events_url": "https://api.github.com/users/atgreen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c497b9764aebf09840ff574869ff86485fe1a8f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c497b9764aebf09840ff574869ff86485fe1a8f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c497b9764aebf09840ff574869ff86485fe1a8f3"}], "stats": {"total": 5266, "additions": 5130, "deletions": 136}, "files": [{"sha": "d3e4b0ec815c8e0969a4f9ca17f18437565e3e87", "filename": "libjava/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -1,3 +1,29 @@\n+2004-03-08  Anthony Green  <green@redhat.com>\n+\n+\t* Makefile.am: Build property resource files into libgcj.\n+\t* Makefile.in: Rebuilt.\n+\t* java/util/regex/Matcher.java, java/util/regex/Pattern.java,\n+\tjava/util/regex/PatternSyntaxException.java,\n+\tgnu/regexp/CharIndexed.java,\n+\tgnu/regexp/CharIndexedCharArray.java,\n+\tgnu/regexp/CharIndexedInputStream.java,\n+\tgnu/regexp/CharIndexedReader.java,\n+\tgnu/regexp/CharIndexedString.java,\n+\tgnu/regexp/CharIndexedStringBuffer.java, gnu/regexp/RE.java,\n+\tgnu/regexp/REException.java,\n+\tgnu/regexp/REFilterInputStream.java,\n+\tgnu/regexp/REFilterReader.java, gnu/regexp/REMatch.java,\n+\tgnu/regexp/REMatchEnumeration.java, gnu/regexp/RESyntax.java,\n+\tgnu/regexp/REToken.java, gnu/regexp/RETokenAny.java,\n+\tgnu/regexp/RETokenBackRef.java, gnu/regexp/RETokenChar.java,\n+\tgnu/regexp/RETokenEnd.java, gnu/regexp/RETokenEndSub.java,\n+\tgnu/regexp/RETokenLookAhead.java,\n+\tgnu/regexp/RETokenOneOf.java, gnu/regexp/RETokenPOSIX.java,\n+\tgnu/regexp/RETokenRange.java, gnu/regexp/RETokenRepeated.java,\n+\tgnu/regexp/RETokenStart.java,\n+\tgnu/regexp/RETokenWordBoundary.java,\n+\tgnu/regexp/UncheckedRE.java: Files merged from GNU Classpath.\n+\n 2004-03-03  Per Bothner  <per@bothner.com>\n \n \t* java/nio/channels/Channels.java (newInputStream, newOutputStream):"}, {"sha": "f8ff9498ff4ee779ab708542862f82e473747639", "filename": "libjava/Makefile.am", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -156,10 +156,11 @@ EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n \t$(extra_cc_source_files) $(java_source_files) $(built_java_source_files)\n libgcj_la_DEPENDENCIES = libgcj-@gcc_version@.jar $(javao_files) \\\n \t$(c_files) $(extra_cc_files) $(GCOBJS) $(THREADOBJS) \\\n-       $(PLATFORMOBJS) $(LIBLTDL) $(LIBFFI) $(ZLIBS) $(GCLIBS)\n+\t$(PLATFORMOBJS) $(LIBLTDL) $(LIBFFI) $(ZLIBS) $(GCLIBS) \\\n+\t$(propertyo_files)\n \n libgcj_la_LIBADD = $(javao_files) $(c_files) $(extra_cc_files) $(GCOBJS) \\\n-\t$(THREADOBJS) $(PLATFORMOBJS)\n+\t$(THREADOBJS) $(PLATFORMOBJS) $(propertyo_files)\n # Include THREADLIBS here to ensure that the correct version of\n # certain linuxthread functions get linked:\n libgcj_la_LDFLAGS = -rpath $(toolexeclibdir) $(THREADLDFLAGS) $(THREADLIBS) \\\n@@ -374,6 +375,16 @@ all_java_source_files = \\\n \n all_java_class_files = $(all_java_source_files:.java=.class)\n \n+## Build property files into the library.\n+property_files = \\\n+gnu/regexp/MessagesBundle.properties \\\n+gnu/regexp/MessagesBundle_fr.properties \n+\n+propertyo_files = $(property_files:.properties=.properties.lo) \n+\n+%.properties.lo: %.properties\n+\t$(GCJCOMPILE) -o $@ -c $< -Wc,--resource,`echo $@ | sed \"s/\\.lo$$//\"`\n+\n if ONESTEP\n \n # Compile all classfiles in one go.\n@@ -433,7 +444,7 @@ distclean-local:\n clean-nat:\n \trm -f $(nat_files) $(x_nat_files)\n \n-SUFFIXES = .class .java .h\n+SUFFIXES = .class .java .h .properties\n \n .class.lo:\n \t$(GCJCOMPILE) -o $@ $<\n@@ -2368,6 +2379,33 @@ gnu/java/nio/charset/UTF_16Decoder.java \\\n gnu/java/nio/charset/UTF_16Encoder.java \\\n gnu/java/nio/charset/UTF_16LE.java \\\n gnu/java/nio/charset/UTF_8.java \\\n+gnu/regexp/CharIndexed.java \\\n+gnu/regexp/CharIndexedCharArray.java \\\n+gnu/regexp/CharIndexedInputStream.java \\\n+gnu/regexp/CharIndexedReader.java \\\n+gnu/regexp/CharIndexedString.java \\\n+gnu/regexp/CharIndexedStringBuffer.java \\\n+gnu/regexp/RE.java \\\n+gnu/regexp/REException.java \\\n+gnu/regexp/REFilterInputStream.java \\\n+gnu/regexp/REFilterReader.java \\\n+gnu/regexp/REMatch.java \\\n+gnu/regexp/REMatchEnumeration.java \\\n+gnu/regexp/RESyntax.java \\\n+gnu/regexp/REToken.java \\\n+gnu/regexp/RETokenAny.java \\\n+gnu/regexp/RETokenBackRef.java \\\n+gnu/regexp/RETokenChar.java \\\n+gnu/regexp/RETokenEnd.java \\\n+gnu/regexp/RETokenEndSub.java \\\n+gnu/regexp/RETokenLookAhead.java \\\n+gnu/regexp/RETokenOneOf.java \\\n+gnu/regexp/RETokenPOSIX.java \\\n+gnu/regexp/RETokenRange.java \\\n+gnu/regexp/RETokenRepeated.java \\\n+gnu/regexp/RETokenStart.java \\\n+gnu/regexp/RETokenWordBoundary.java \\\n+gnu/regexp/UncheckedRE.java \\\n gnu/java/security/Engine.java \\\n gnu/java/security/OID.java \\\n gnu/java/security/der/BitString.java \\"}, {"sha": "309d0ed32f9c112df7d63d5b3ff72c8dba00def7", "filename": "libjava/Makefile.in", "status": "modified", "additions": 151, "deletions": 98, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -252,11 +252,12 @@ EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n \n libgcj_la_DEPENDENCIES = libgcj-@gcc_version@.jar $(javao_files) \\\n \t$(c_files) $(extra_cc_files) $(GCOBJS) $(THREADOBJS) \\\n-       $(PLATFORMOBJS) $(LIBLTDL) $(LIBFFI) $(ZLIBS) $(GCLIBS)\n+\t$(PLATFORMOBJS) $(LIBLTDL) $(LIBFFI) $(ZLIBS) $(GCLIBS) \\\n+\t$(propertyo_files)\n \n \n libgcj_la_LIBADD = $(javao_files) $(c_files) $(extra_cc_files) $(GCOBJS) \\\n-\t$(THREADOBJS) $(PLATFORMOBJS)\n+\t$(THREADOBJS) $(PLATFORMOBJS) $(propertyo_files)\n \n # Include THREADLIBS here to ensure that the correct version of\n # certain linuxthread functions get linked:\n@@ -464,13 +465,20 @@ all_java_source_files = \\\n \n all_java_class_files = $(all_java_source_files:.java=.class)\n \n+property_files = \\\n+gnu/regexp/MessagesBundle.properties \\\n+gnu/regexp/MessagesBundle_fr.properties \n+\n+\n+propertyo_files = $(property_files:.properties=.properties.lo) \n+\n # Note: The libtool objects are removed by mostlyclean-local\n # because of command-line-length issues.\n MOSTLYCLEANFILES = $(nat_headers) $(x_nat_headers)\n \n CLEANFILES = libgcj-@gcc_version@.jar\n \n-SUFFIXES = .class .java .h\n+SUFFIXES = .class .java .h .properties\n \n ordinary_nat_headers = $(ordinary_java_source_files:.java=.h) \\\n \t$(built_java_source_files:.java=.h)\n@@ -2046,6 +2054,33 @@ gnu/java/nio/charset/UTF_16Decoder.java \\\n gnu/java/nio/charset/UTF_16Encoder.java \\\n gnu/java/nio/charset/UTF_16LE.java \\\n gnu/java/nio/charset/UTF_8.java \\\n+gnu/regexp/CharIndexed.java \\\n+gnu/regexp/CharIndexedCharArray.java \\\n+gnu/regexp/CharIndexedInputStream.java \\\n+gnu/regexp/CharIndexedReader.java \\\n+gnu/regexp/CharIndexedString.java \\\n+gnu/regexp/CharIndexedStringBuffer.java \\\n+gnu/regexp/RE.java \\\n+gnu/regexp/REException.java \\\n+gnu/regexp/REFilterInputStream.java \\\n+gnu/regexp/REFilterReader.java \\\n+gnu/regexp/REMatch.java \\\n+gnu/regexp/REMatchEnumeration.java \\\n+gnu/regexp/RESyntax.java \\\n+gnu/regexp/REToken.java \\\n+gnu/regexp/RETokenAny.java \\\n+gnu/regexp/RETokenBackRef.java \\\n+gnu/regexp/RETokenChar.java \\\n+gnu/regexp/RETokenEnd.java \\\n+gnu/regexp/RETokenEndSub.java \\\n+gnu/regexp/RETokenLookAhead.java \\\n+gnu/regexp/RETokenOneOf.java \\\n+gnu/regexp/RETokenPOSIX.java \\\n+gnu/regexp/RETokenRange.java \\\n+gnu/regexp/RETokenRepeated.java \\\n+gnu/regexp/RETokenStart.java \\\n+gnu/regexp/RETokenWordBoundary.java \\\n+gnu/regexp/UncheckedRE.java \\\n gnu/java/security/Engine.java \\\n gnu/java/security/OID.java \\\n gnu/java/security/der/BitString.java \\\n@@ -2737,6 +2772,83 @@ org/w3c/dom/traversal/NodeFilter.lo \\\n org/w3c/dom/traversal/NodeIterator.lo \\\n org/w3c/dom/traversal/TreeWalker.lo\n lib_gnu_java_awt_peer_gtk_la_DEPENDENCIES = \n+@GTK_CAIRO_FALSE@lib_gnu_java_awt_peer_gtk_la_OBJECTS =  \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkClasspathFontPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkClasspathFontPeerMetrics.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkFontMetrics.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGlyphVector.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGraphics.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGraphics2D.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkPixbufDecoder.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkArg.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkArgList.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkButtonPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkCanvasPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkCheckboxGroupPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkCheckboxMenuItemPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkCheckboxPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkChoicePeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkClipboard.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkComponentPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkContainerPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkDialogPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkEmbeddedWindowPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkFileDialogPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkFontPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkFramePeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkGenericPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkImage.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkImagePainter.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkLabelPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkListPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMainThread.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMenuBarPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMenuComponentPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMenuItemPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMenuPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkOffScreenImage.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkPanelPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkPopupMenuPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkScrollPanePeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkScrollbarPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkTextAreaPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkTextComponentPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkTextFieldPeer.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkToolkit.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkWindowPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontMetrics.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GdkPixbufDecoder.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCanvasPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxMenuItemPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkChoicePeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkClipboard.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEmbeddedWindowPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkImagePainter.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuBarPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuComponentPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuItemPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPanelPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPopupMenuPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkScrollBarPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkScrollPanePeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextFieldPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.lo \\\n+@GTK_CAIRO_FALSE@jni/gtk-peer/gthread-jni.lo jni/classpath/jcl.lo \\\n+@GTK_CAIRO_FALSE@jni/classpath/jnilink.lo jni/classpath/native_state.lo \\\n+@GTK_CAIRO_FALSE@jni/classpath/primlib.lo\n @GTK_CAIRO_TRUE@lib_gnu_java_awt_peer_gtk_la_OBJECTS =  \\\n @GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GdkClasspathFontPeer.lo \\\n @GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GdkClasspathFontPeerMetrics.lo \\\n@@ -2818,83 +2930,6 @@ lib_gnu_java_awt_peer_gtk_la_DEPENDENCIES =\n @GTK_CAIRO_TRUE@jni/gtk-peer/gthread-jni.lo jni/classpath/jcl.lo \\\n @GTK_CAIRO_TRUE@jni/classpath/jnilink.lo jni/classpath/native_state.lo \\\n @GTK_CAIRO_TRUE@jni/classpath/primlib.lo\n-@GTK_CAIRO_FALSE@lib_gnu_java_awt_peer_gtk_la_OBJECTS =  \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkClasspathFontPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkClasspathFontPeerMetrics.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkFontMetrics.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGlyphVector.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGraphics.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGraphics2D.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkPixbufDecoder.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkArg.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkArgList.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkButtonPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkCanvasPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkCheckboxGroupPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkCheckboxMenuItemPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkCheckboxPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkChoicePeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkClipboard.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkComponentPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkContainerPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkDialogPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkEmbeddedWindowPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkFileDialogPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkFontPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkFramePeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkGenericPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkImage.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkImagePainter.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkLabelPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkListPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMainThread.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMenuBarPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMenuComponentPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMenuItemPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkMenuPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkOffScreenImage.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkPanelPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkPopupMenuPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkScrollPanePeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkScrollbarPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkTextAreaPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkTextComponentPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkTextFieldPeer.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkToolkit.lo \\\n-@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkWindowPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontMetrics.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GdkPixbufDecoder.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCanvasPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxMenuItemPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkChoicePeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkClipboard.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEmbeddedWindowPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkImagePainter.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuBarPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuComponentPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuItemPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPanelPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPopupMenuPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkScrollBarPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkScrollPanePeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextFieldPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.lo \\\n-@GTK_CAIRO_FALSE@jni/gtk-peer/gthread-jni.lo jni/classpath/jcl.lo \\\n-@GTK_CAIRO_FALSE@jni/classpath/jnilink.lo jni/classpath/native_state.lo \\\n-@GTK_CAIRO_FALSE@jni/classpath/primlib.lo\n lib_gnu_awt_xlib_la_OBJECTS =  gnu/gcj/xlib/natClip.lo \\\n gnu/gcj/xlib/natColormap.lo gnu/gcj/xlib/natDisplay.lo \\\n gnu/gcj/xlib/natDrawable.lo gnu/gcj/xlib/natFont.lo \\\n@@ -3352,23 +3387,38 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/javax/rmi/CORBA/StubDelegateImpl.P \\\n .deps/gnu/javax/rmi/CORBA/UtilDelegateImpl.P \\\n .deps/gnu/javax/rmi/CORBA/ValueHandlerImpl.P \\\n-.deps/gnu/javax/rmi/PortableServer.P .deps/interpret.P \\\n-.deps/java/applet/Applet.P .deps/java/applet/AppletContext.P \\\n-.deps/java/applet/AppletStub.P .deps/java/applet/AudioClip.P \\\n-.deps/java/awt/AWTError.P .deps/java/awt/AWTEvent.P \\\n-.deps/java/awt/AWTEventMulticaster.P .deps/java/awt/AWTException.P \\\n-.deps/java/awt/AWTKeyStroke.P .deps/java/awt/AWTPermission.P \\\n-.deps/java/awt/ActiveEvent.P .deps/java/awt/Adjustable.P \\\n-.deps/java/awt/AlphaComposite.P .deps/java/awt/AttributeValue.P \\\n-.deps/java/awt/BasicStroke.P .deps/java/awt/BorderLayout.P \\\n-.deps/java/awt/BufferCapabilities.P .deps/java/awt/Button.P \\\n-.deps/java/awt/Canvas.P .deps/java/awt/CardLayout.P \\\n-.deps/java/awt/Checkbox.P .deps/java/awt/CheckboxGroup.P \\\n-.deps/java/awt/CheckboxMenuItem.P .deps/java/awt/Choice.P \\\n-.deps/java/awt/Color.P .deps/java/awt/ColorPaintContext.P \\\n-.deps/java/awt/Component.P .deps/java/awt/ComponentOrientation.P \\\n-.deps/java/awt/Composite.P .deps/java/awt/CompositeContext.P \\\n-.deps/java/awt/Container.P \\\n+.deps/gnu/javax/rmi/PortableServer.P .deps/gnu/regexp/CharIndexed.P \\\n+.deps/gnu/regexp/CharIndexedCharArray.P \\\n+.deps/gnu/regexp/CharIndexedInputStream.P \\\n+.deps/gnu/regexp/CharIndexedReader.P \\\n+.deps/gnu/regexp/CharIndexedString.P \\\n+.deps/gnu/regexp/CharIndexedStringBuffer.P .deps/gnu/regexp/RE.P \\\n+.deps/gnu/regexp/REException.P .deps/gnu/regexp/REFilterInputStream.P \\\n+.deps/gnu/regexp/REFilterReader.P .deps/gnu/regexp/REMatch.P \\\n+.deps/gnu/regexp/REMatchEnumeration.P .deps/gnu/regexp/RESyntax.P \\\n+.deps/gnu/regexp/REToken.P .deps/gnu/regexp/RETokenAny.P \\\n+.deps/gnu/regexp/RETokenBackRef.P .deps/gnu/regexp/RETokenChar.P \\\n+.deps/gnu/regexp/RETokenEnd.P .deps/gnu/regexp/RETokenEndSub.P \\\n+.deps/gnu/regexp/RETokenLookAhead.P .deps/gnu/regexp/RETokenOneOf.P \\\n+.deps/gnu/regexp/RETokenPOSIX.P .deps/gnu/regexp/RETokenRange.P \\\n+.deps/gnu/regexp/RETokenRepeated.P .deps/gnu/regexp/RETokenStart.P \\\n+.deps/gnu/regexp/RETokenWordBoundary.P .deps/gnu/regexp/UncheckedRE.P \\\n+.deps/interpret.P .deps/java/applet/Applet.P \\\n+.deps/java/applet/AppletContext.P .deps/java/applet/AppletStub.P \\\n+.deps/java/applet/AudioClip.P .deps/java/awt/AWTError.P \\\n+.deps/java/awt/AWTEvent.P .deps/java/awt/AWTEventMulticaster.P \\\n+.deps/java/awt/AWTException.P .deps/java/awt/AWTKeyStroke.P \\\n+.deps/java/awt/AWTPermission.P .deps/java/awt/ActiveEvent.P \\\n+.deps/java/awt/Adjustable.P .deps/java/awt/AlphaComposite.P \\\n+.deps/java/awt/AttributeValue.P .deps/java/awt/BasicStroke.P \\\n+.deps/java/awt/BorderLayout.P .deps/java/awt/BufferCapabilities.P \\\n+.deps/java/awt/Button.P .deps/java/awt/Canvas.P \\\n+.deps/java/awt/CardLayout.P .deps/java/awt/Checkbox.P \\\n+.deps/java/awt/CheckboxGroup.P .deps/java/awt/CheckboxMenuItem.P \\\n+.deps/java/awt/Choice.P .deps/java/awt/Color.P \\\n+.deps/java/awt/ColorPaintContext.P .deps/java/awt/Component.P \\\n+.deps/java/awt/ComponentOrientation.P .deps/java/awt/Composite.P \\\n+.deps/java/awt/CompositeContext.P .deps/java/awt/Container.P \\\n .deps/java/awt/ContainerOrderFocusTraversalPolicy.P \\\n .deps/java/awt/Cursor.P .deps/java/awt/DefaultFocusTraversalPolicy.P \\\n .deps/java/awt/DefaultKeyboardFocusManager.P .deps/java/awt/Dialog.P \\\n@@ -4646,7 +4696,7 @@ OBJECTS = $(libgcj_la_OBJECTS) $(lib_org_xml_sax_la_OBJECTS) $(lib_org_w3c_dom_l\n \n all: all-redirect\n .SUFFIXES:\n-.SUFFIXES: .S .c .cc .class .h .java .lo .o .obj .s\n+.SUFFIXES: .S .c .cc .class .h .java .lo .o .obj .properties .s\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n \tcd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile\n \n@@ -5196,6 +5246,9 @@ $(gtk_c_headers): $(gtk_awt_peer_sources)\n \techo \"$(GCJH) -jni -d jniinclude -classpath '' -bootclasspath $(top_builddir) $$input\"; \\\n \t$(GCJH) -jni -d jniinclude -classpath '' -bootclasspath $(top_builddir) $$input\n \n+%.properties.lo: %.properties\n+\t$(GCJCOMPILE) -o $@ -c $< -Wc,--resource,`echo $@ | sed \"s/\\.lo$$//\"`\n+\n # Compile all classfiles in one go.\n \n @ONESTEP_TRUE@libgcj-@gcc_version@.jar: $(all_java_source_files)"}, {"sha": "eb1be13fd7877bc17029511eb81919a9b2c3aa5d", "filename": "libjava/gnu/regexp/CharIndexed.java", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexed.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexed.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FCharIndexed.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,84 @@\n+/* gnu/regexp/CharIndexed.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+\n+/**\n+ * Defines the interface used internally so that different types of source\n+ * text can be accessed in the same way.  Built-in concrete classes provide\n+ * support for String, StringBuffer, InputStream and char[] types.\n+ * A class that is CharIndexed supports the notion of a cursor within a\n+ * block of text.  The cursor must be able to be advanced via the move()\n+ * method.  The charAt() method returns the character at the cursor position\n+ * plus a given offset.\n+ *\n+ * @author <A HREF=\"mailto:wes@cacas.org\">Wes Biggs</A>\n+ */\n+public interface CharIndexed {\n+    /**\n+     * Defines a constant (0xFFFF was somewhat arbitrarily chosen)\n+     * that can be returned by the charAt() function indicating that\n+     * the specified index is out of range.\n+     */\n+    char OUT_OF_BOUNDS = '\\uFFFF';\n+\n+    /**\n+     * Returns the character at the given offset past the current cursor\n+     * position in the input.  The index of the current position is zero.\n+     * It is possible for this method to be called with a negative index.\n+     * This happens when using the '^' operator in multiline matching mode\n+     * or the '\\b' or '\\<' word boundary operators.  In any case, the lower\n+     * bound is currently fixed at -2 (for '^' with a two-character newline).\n+     *\n+     * @param index the offset position in the character field to examine\n+     * @return the character at the specified index, or the OUT_OF_BOUNDS\n+     *   character defined by this interface.\n+     */\n+    char charAt(int index);\n+\n+    /**\n+     * Shifts the input buffer by a given number of positions.  Returns\n+     * true if the new cursor position is valid.\n+     */\n+    boolean move(int index);\n+\n+    /**\n+     * Returns true if the most recent move() operation placed the cursor\n+     * position at a valid position in the input.\n+     */\n+    boolean isValid();\n+}"}, {"sha": "dc488ba44ea7e6164a455507ea0e816271a885c1", "filename": "libjava/gnu/regexp/CharIndexedCharArray.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedCharArray.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedCharArray.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FCharIndexedCharArray.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,62 @@\n+/* gnu/regexp/CharIndexedCharArray.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+import java.io.Serializable;\n+\n+class CharIndexedCharArray implements CharIndexed, Serializable {\n+    private char[] s;\n+    private int anchor;\n+    \n+    CharIndexedCharArray(char[] str, int index) {\n+\ts = str;\n+\tanchor = index;\n+    }\n+    \n+    public char charAt(int index) {\n+\tint pos = anchor + index;\n+\treturn ((pos < s.length) && (pos >= 0)) ? s[pos] : OUT_OF_BOUNDS;\n+    }\n+    \n+    public boolean isValid() {\n+\treturn (anchor < s.length);\n+    }\n+    \n+    public boolean move(int index) {\n+\treturn ((anchor += index) < s.length);\n+    }\n+}"}, {"sha": "776f533ca818f4eda4287951f40524c7e260de89", "filename": "libjava/gnu/regexp/CharIndexedInputStream.java", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FCharIndexedInputStream.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,149 @@\n+/* gnu/regexp/CharIndexedInputStream.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+import java.io.InputStream;\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+\n+// TODO: move(x) shouldn't rely on calling next() x times\n+\n+class CharIndexedInputStream implements CharIndexed {\n+    private static final int BUFFER_INCREMENT = 1024;\n+    private static final int UNKNOWN = Integer.MAX_VALUE; // value for end\n+    \n+    private BufferedInputStream br;\n+\n+    // so that we don't try to reset() right away\n+    private int index = -1;\n+\n+    private int bufsize = BUFFER_INCREMENT;\n+\n+    private int end = UNKNOWN;\n+\n+    private char cached = OUT_OF_BOUNDS;\n+\n+    // Big enough for a \\r\\n pair\n+    // lookBehind[0] = most recent\n+    // lookBehind[1] = second most recent\n+    private char[] lookBehind = new char[] { OUT_OF_BOUNDS, OUT_OF_BOUNDS }; \n+    \n+    CharIndexedInputStream(InputStream str, int index) {\n+\tif (str instanceof BufferedInputStream) br = (BufferedInputStream) str;\n+\telse br = new BufferedInputStream(str,BUFFER_INCREMENT);\n+\tnext();\n+\tif (index > 0) move(index);\n+    }\n+    \n+    private boolean next() {\n+\tif (end == 1) return false;\n+\tend--; // closer to end\n+\n+\ttry {\n+\t    if (index != -1) {\n+\t\tbr.reset();\n+\t    }\n+\t    int i = br.read();\n+\t    br.mark(bufsize);\n+\t    if (i == -1) {\n+\t\tend = 1;\n+\t\tcached = OUT_OF_BOUNDS;\n+\t\treturn false;\n+\t    }\n+\t    cached = (char) i;\n+\t    index = 1;\n+\t} catch (IOException e) { \n+\t    e.printStackTrace();\n+\t    cached = OUT_OF_BOUNDS;\n+\t    return false; \n+\t}\n+\treturn true;\n+    }\n+    \n+    public char charAt(int index) {\n+\tif (index == 0) {\n+\t    return cached;\n+\t} else if (index >= end) {\n+\t    return OUT_OF_BOUNDS;\n+\t} else if (index == -1) {\n+\t    return lookBehind[0];\n+\t} else if (index == -2) {\n+\t    return lookBehind[1];\n+\t} else if (index < -2) {\n+\t    return OUT_OF_BOUNDS;\n+\t} else if (index >= bufsize) {\n+\t    // Allocate more space in the buffer.\n+\t    try {\n+\t\twhile (bufsize <= index) bufsize += BUFFER_INCREMENT;\n+\t\tbr.reset();\n+\t\tbr.mark(bufsize);\n+\t\tbr.skip(index-1);\n+\t    } catch (IOException e) { }\n+\t} else if (this.index != index) {\n+\t    try {\n+\t\tbr.reset();\n+\t\tbr.skip(index-1);\n+\t    } catch (IOException e) { }\n+\t}\n+\tchar ch = OUT_OF_BOUNDS;\n+\t\n+\ttry {\n+\t    int i = br.read();\n+\t    this.index = index+1; // this.index is index of next pos relative to charAt(0)\n+\t    if (i == -1) {\n+\t\t// set flag that next should fail next time?\n+\t\tend = index;\n+\t\treturn ch;\n+\t    }\n+\t    ch = (char) i;\n+\t} catch (IOException ie) { }\n+\t\n+\treturn ch;\n+    }\n+    \n+    public boolean move(int index) {\n+\t// move read position [index] clicks from 'charAt(0)'\n+\tboolean retval = true;\n+\twhile (retval && (index-- > 0)) retval = next();\n+\treturn retval;\n+    }\n+    \n+    public boolean isValid() {\n+\treturn (cached != OUT_OF_BOUNDS);\n+    }\n+}\n+"}, {"sha": "aa0fa5a313d96ae84fd34252f5e16980149b7704", "filename": "libjava/gnu/regexp/CharIndexedReader.java", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FCharIndexedReader.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,142 @@\n+/*\n+ *  gnu/regexp/CharIndexedReader.java\n+ *  Copyright (C) 2001 Lee Sau Dan\n+ *  Based on gnu.regexp.CharIndexedInputStream by Wes Biggs\n+ *\n+ *  This library is free software; you can redistribute it and/or modify\n+ *  it under the terms of the GNU Lesser General Public License as published\n+ *  by the Free Software Foundation; either version 2.1 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  This library is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU Lesser General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU Lesser General Public License\n+ *  along with this program; if not, write to the Free Software\n+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n+ */\n+\n+package gnu.regexp;\n+import java.io.Reader;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+\n+// TODO: move(x) shouldn't rely on calling next() x times\n+\n+class CharIndexedReader implements CharIndexed {\n+    private static final int BUFFER_INCREMENT = 1024;\n+    private static final int UNKNOWN = Integer.MAX_VALUE; // value for end\n+    \n+    private final BufferedReader br;\n+    // so that we don't try to reset() right away\n+    private int index = -1;\n+\n+    private int bufsize = BUFFER_INCREMENT;\n+\n+    private int end = UNKNOWN;\n+\n+    private char cached = OUT_OF_BOUNDS;\n+\n+    // Big enough for a \\r\\n pair\n+    // lookBehind[0] = most recent\n+    // lookBehind[1] = second most recent\n+    private char[] lookBehind = new char[] { OUT_OF_BOUNDS, OUT_OF_BOUNDS }; \n+  \n+    CharIndexedReader(Reader reader, int index) {\n+\tif (reader instanceof BufferedReader) {\n+\t    br = (BufferedReader) reader; \n+\t} else {\n+\t    br = new BufferedReader(reader,BUFFER_INCREMENT);\n+\t}\n+\tnext();\n+\tif (index > 0) move(index);\n+    }\n+    \n+    private boolean next() {\n+\tlookBehind[1] = lookBehind[0];\n+\tlookBehind[0] = cached;\n+\n+\tif (end == 1) {\n+\t    cached = OUT_OF_BOUNDS;\n+\t    return false;\n+\t}\n+\tend--; // closer to end\n+\t\n+\ttry {\n+\t    if (index != -1) {\n+\t\tbr.reset();\n+\t    }\n+\t    int i = br.read();\n+\t    br.mark(bufsize);\n+\t    if (i == -1) {\n+\t\tend = 1;\n+\t\tcached = OUT_OF_BOUNDS;\n+\t\treturn false;\n+\t    }\n+\n+\t    // convert the byte read into a char\n+\t    cached = (char) i;\n+\t    index = 1;\n+\t} catch (IOException e) { \n+\t    e.printStackTrace();\n+\t    cached = OUT_OF_BOUNDS;\n+\t    return false; \n+\t}\n+\treturn true;\n+    }\n+    \n+    public char charAt(int index) {\n+\tif (index == 0) {\n+\t    return cached;\n+\t} else if (index >= end) {\n+\t    return OUT_OF_BOUNDS;\n+\t} else if (index >= bufsize) {\n+\t    // Allocate more space in the buffer.\n+\t    try {\n+\t\twhile (bufsize <= index) bufsize += BUFFER_INCREMENT;\n+\t\tbr.reset();\n+\t\tbr.mark(bufsize);\n+\t\tbr.skip(index-1);\n+\t    } catch (IOException e) { }\n+\t} else if (this.index != index) {\n+\t    try {\n+\t\tbr.reset();\n+\t\tbr.skip(index-1);\n+\t    } catch (IOException e) { }\n+\t} else if (index == -1) {\n+\t    return lookBehind[0];\n+\t} else if (index == -2) {\n+\t    return lookBehind[1];\n+\t} else if (index < -2) {\n+\t    return OUT_OF_BOUNDS;\n+\t}\n+\n+\tchar ch = OUT_OF_BOUNDS;\n+\t\n+\ttry {\n+\t    int i = br.read();\n+\t    this.index = index+1; // this.index is index of next pos relative to charAt(0)\n+\t    if (i == -1) {\n+\t\t// set flag that next should fail next time?\n+\t\tend = index;\n+\t\treturn ch;\n+\t    }\n+\t    ch = (char) i;\n+\t} catch (IOException ie) { }\n+\t\n+\treturn ch;\n+    }\n+    \n+    public boolean move(int index) {\n+\t// move read position [index] clicks from 'charAt(0)'\n+\tboolean retval = true;\n+\twhile (retval && (index-- > 0)) retval = next();\n+\treturn retval;\n+    }\n+    \n+    public boolean isValid() {\n+\treturn (cached != OUT_OF_BOUNDS);\n+    }\n+}"}, {"sha": "adff7ac7186a8882448ac0117ee7b9ff358b21f3", "filename": "libjava/gnu/regexp/CharIndexedString.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FCharIndexedString.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,64 @@\n+/* gnu/regexp/CharIndexedString.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+import java.io.Serializable;\n+\n+class CharIndexedString implements CharIndexed, Serializable {\n+    private String s;\n+    private int anchor;\n+    private int len;\n+    \n+    CharIndexedString(String str, int index) {\n+\ts = str;\n+\tlen = s.length();\n+\tanchor = index;\n+    }\n+\n+    public char charAt(int index) {\n+\tint pos = anchor + index;\n+\treturn ((pos < len) && (pos >= 0)) ? s.charAt(pos) : OUT_OF_BOUNDS;\n+    }\n+    \n+    public boolean isValid() {\n+\treturn (anchor < len);\n+    }\n+    \n+    public boolean move(int index) {\n+\treturn ((anchor += index) < len);\n+    }\n+}"}, {"sha": "2eb8c23f36a133ac3550586dee93b326d1ed87c6", "filename": "libjava/gnu/regexp/CharIndexedStringBuffer.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedStringBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FCharIndexedStringBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FCharIndexedStringBuffer.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,62 @@\n+/* gnu/regexp/CharIndexedStringBuffer.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+import java.io.Serializable;\n+\n+class CharIndexedStringBuffer implements CharIndexed, Serializable {\n+    private StringBuffer s;\n+    private int anchor;\n+\n+    CharIndexedStringBuffer(StringBuffer str, int index) {\n+\ts = str;\n+\tanchor = index;\n+    }\n+\n+  public char charAt(int index) {\n+      int pos = anchor + index;\n+    return ((pos < s.length()) && (pos >= 0)) ? s.charAt(pos) : OUT_OF_BOUNDS;\n+  }\n+\n+  public boolean isValid() {\n+    return (anchor < s.length());\n+  }\n+\n+  public boolean move(int index) {\n+    return ((anchor += index) < s.length());\n+  }\n+}"}, {"sha": "1e077a4033cf533532539050ec96028327ddf936", "filename": "libjava/gnu/regexp/MessagesBundle.properties", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FMessagesBundle.properties", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FMessagesBundle.properties", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FMessagesBundle.properties?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,22 @@\n+# Localized error messages for gnu.regexp\n+\n+# Prefix for REException messages\n+error.prefix=At position {0} in regular expression pattern:\n+\n+# REException (parse error) messages\n+repeat.assertion=repeated token is zero-width assertion\n+repeat.chained=attempted to repeat a token that is already repeated\n+repeat.no.token=quantifier (?*+{}) without preceding token\n+repeat.empty.token=repeated token may be empty\n+unmatched.brace=unmatched brace\n+unmatched.bracket=unmatched bracket\n+unmatched.paren=unmatched parenthesis\n+interval.no.end=expected end of interval\n+class.no.end=expected end of character class\n+subexpr.no.end=expected end of subexpression\n+interval.order=interval minimum is greater than maximum\n+interval.error=interval is empty or contains illegal characters\n+ends.with.backslash=backslash at end of pattern\n+\n+# RESyntax message\n+syntax.final=Syntax has been declared final and cannot be modified"}, {"sha": "8ab8356c17b85b3400595f4f86b38daac13398de", "filename": "libjava/gnu/regexp/MessagesBundle_fr.properties", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FMessagesBundle_fr.properties", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FMessagesBundle_fr.properties", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FMessagesBundle_fr.properties?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,22 @@\n+# Localized error messages for gnu.regexp\n+\n+# Prefix for REException messages\n+error.prefix=A l''index {0} dans le mod\ufffdle d''expression r\ufffdguli\ufffdre:\n+\n+# REException (parse error) messages\n+repeat.assertion=l'\ufffdl\ufffdment r\ufffdp\ufffdt\ufffd est de largeur z\ufffdro\n+repeat.chained=tentative de r\ufffdp\ufffdtition d'un \ufffdl\ufffdment d\ufffdj\ufffd r\ufffdp\ufffdt\ufffd\n+repeat.no.token=quantifieur (?*+{}) sans \ufffdl\ufffdment pr\ufffdc\ufffddent\n+repeat.empty.token=l'\ufffdl\ufffdment r\ufffdp\ufffdt\ufffd peut \ufffdtre vide\n+unmatched.brace=accolade in\ufffdgal\ufffde\n+unmatched.bracket=crochet in\ufffdgal\ufffd\n+unmatched.paren=parenth\ufffdse in\ufffdgal\ufffde\n+interval.no.end=fin d'interval attendue\n+class.no.end=fin de classe de caract\ufffdres attendue\n+subexpr.no.end=fin de sous-expression attendue\n+interval.order=l'interval minimum est sup\ufffdrieur \ufffd l'interval maximum\n+interval.error=l'interval est vide ou contient des caract\ufffdres ill\ufffdgaux\n+ends.with.backslash=antislash \ufffd la fin du mod\ufffdle\n+\n+# RESyntax message\n+syntax.final=La syntaxe a \ufffdt\ufffd d\ufffdclar\ufffde finale et ne peut pas \ufffdtre modifi\ufffde"}, {"sha": "fdc00feb3fb638f6a949a7cba10e675ddb392c15", "filename": "libjava/gnu/regexp/RE.java", "status": "added", "additions": 1350, "deletions": 0, "changes": 1350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRE.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRE.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRE.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,1350 @@\n+/* gnu/regexp/RE.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.util.Locale;\n+import java.util.PropertyResourceBundle;\n+import java.util.ResourceBundle;\n+import java.util.Vector;\n+\n+class IntPair implements Serializable {\n+  public int first, second;\n+}\n+\n+class CharUnit implements Serializable {\n+  public char ch;\n+  public boolean bk;\n+}\n+\n+/**\n+ * RE provides the user interface for compiling and matching regular\n+ * expressions.\n+ * <P>\n+ * A regular expression object (class RE) is compiled by constructing it\n+ * from a String, StringBuffer or character array, with optional \n+ * compilation flags (below)\n+ * and an optional syntax specification (see RESyntax; if not specified,\n+ * <code>RESyntax.RE_SYNTAX_PERL5</code> is used).\n+ * <P>\n+ * Once compiled, a regular expression object is reusable as well as\n+ * threadsafe: multiple threads can use the RE instance simultaneously\n+ * to match against different input text.\n+ * <P>\n+ * Various methods attempt to match input text against a compiled\n+ * regular expression.  These methods are:\n+ * <LI><code>isMatch</code>: returns true if the input text in its\n+ * entirety matches the regular expression pattern.\n+ * <LI><code>getMatch</code>: returns the first match found in the\n+ * input text, or null if no match is found.\n+ * <LI><code>getAllMatches</code>: returns an array of all\n+ * non-overlapping matches found in the input text.  If no matches are\n+ * found, the array is zero-length.\n+ * <LI><code>substitute</code>: substitute the first occurence of the\n+ * pattern in the input text with a replacement string (which may\n+ * include metacharacters $0-$9, see REMatch.substituteInto).\n+ * <LI><code>substituteAll</code>: same as above, but repeat for each\n+ * match before returning.\n+ * <LI><code>getMatchEnumeration</code>: returns an REMatchEnumeration\n+ * object that allows iteration over the matches (see\n+ * REMatchEnumeration for some reasons why you may want to do this\n+ * instead of using <code>getAllMatches</code>.\n+ * <P>\n+ *\n+ * These methods all have similar argument lists.  The input can be a\n+ * String, a character array, a StringBuffer, or an\n+ * InputStream of some sort.  Note that when using an\n+ * InputStream, the stream read position cannot be guaranteed after\n+ * attempting a match (this is not a bug, but a consequence of the way\n+ * regular expressions work).  Using an REMatchEnumeration can\n+ * eliminate most positioning problems.\n+ *\n+ * <P>\n+ *\n+ * The optional index argument specifies the offset from the beginning\n+ * of the text at which the search should start (see the descriptions\n+ * of some of the execution flags for how this can affect positional\n+ * pattern operators).  For an InputStream, this means an\n+ * offset from the current read position, so subsequent calls with the\n+ * same index argument on an InputStream will not\n+ * necessarily access the same position on the stream, whereas\n+ * repeated searches at a given index in a fixed string will return\n+ * consistent results.\n+ *\n+ * <P>\n+ * You can optionally affect the execution environment by using a\n+ * combination of execution flags (constants listed below).\n+ * \n+ * <P>\n+ * All operations on a regular expression are performed in a\n+ * thread-safe manner.\n+ *\n+ * @author <A HREF=\"mailto:wes@cacas.org\">Wes Biggs</A>\n+ * @version 1.1.5-dev, to be released\n+ */\n+\n+public class RE extends REToken {\n+  // This String will be returned by getVersion()\n+  private static final String VERSION = \"1.1.5-dev\";\n+\n+  // The localized strings are kept in a separate file\n+  private static ResourceBundle messages = PropertyResourceBundle.getBundle(\"gnu/regexp/MessagesBundle\", Locale.getDefault());\n+\n+  // These are, respectively, the first and last tokens in our linked list\n+  // If there is only one token, firstToken == lastToken\n+  private REToken firstToken, lastToken;\n+\n+  // This is the number of subexpressions in this regular expression,\n+  // with a minimum value of zero.  Returned by getNumSubs()\n+  private int numSubs;\n+\n+    /** Minimum length, in characters, of any possible match. */\n+    private int minimumLength;\n+\n+  /**\n+   * Compilation flag. Do  not  differentiate  case.   Subsequent\n+   * searches  using  this  RE will be case insensitive.\n+   */\n+  public static final int REG_ICASE = 2;\n+\n+  /**\n+   * Compilation flag. The match-any-character operator (dot)\n+   * will match a newline character.  When set this overrides the syntax\n+   * bit RE_DOT_NEWLINE (see RESyntax for details).  This is equivalent to\n+   * the \"/s\" operator in Perl.\n+   */\n+  public static final int REG_DOT_NEWLINE = 4;\n+\n+  /**\n+   * Compilation flag. Use multiline mode.  In this mode, the ^ and $\n+   * anchors will match based on newlines within the input. This is\n+   * equivalent to the \"/m\" operator in Perl.\n+   */\n+  public static final int REG_MULTILINE = 8;\n+\n+  /**\n+   * Execution flag.\n+   * The match-beginning operator (^) will not match at the beginning\n+   * of the input string. Useful for matching on a substring when you\n+   * know the context of the input is such that position zero of the\n+   * input to the match test is not actually position zero of the text.\n+   * <P>\n+   * This example demonstrates the results of various ways of matching on\n+   * a substring.\n+   * <P>\n+   * <CODE>\n+   * String s = \"food bar fool\";<BR>\n+   * RE exp = new RE(\"^foo.\");<BR>\n+   * REMatch m0 = exp.getMatch(s);<BR>\n+   * REMatch m1 = exp.getMatch(s.substring(8));<BR>\n+   * REMatch m2 = exp.getMatch(s.substring(8),0,RE.REG_NOTBOL); <BR>\n+   * REMatch m3 = exp.getMatch(s,8);                            <BR>\n+   * REMatch m4 = exp.getMatch(s,8,RE.REG_ANCHORINDEX);         <BR>\n+   * <P>\n+   * // Results:<BR>\n+   * //  m0.toString(): \"food\"<BR>\n+   * //  m1.toString(): \"fool\"<BR>\n+   * //  m2.toString(): null<BR>\n+   * //  m3.toString(): null<BR>\n+   * //  m4.toString(): \"fool\"<BR>\n+   * </CODE>\n+   */\n+  public static final int REG_NOTBOL = 16;\n+\n+  /**\n+   * Execution flag.\n+   * The match-end operator ($) does not match at the end\n+   * of the input string. Useful for matching on substrings.\n+   */\n+  public static final int REG_NOTEOL = 32;\n+\n+  /**\n+   * Execution flag.\n+   * When a match method is invoked that starts matching at a non-zero\n+   * index into the input, treat the input as if it begins at the index\n+   * given.  The effect of this flag is that the engine does not \"see\"\n+   * any text in the input before the given index.  This is useful so\n+   * that the match-beginning operator (^) matches not at position 0\n+   * in the input string, but at the position the search started at\n+   * (based on the index input given to the getMatch function).  See\n+   * the example under REG_NOTBOL.  It also affects the use of the \\&lt;\n+   * and \\b operators.\n+   */\n+  public static final int REG_ANCHORINDEX = 64;\n+\n+  /**\n+   * Execution flag.\n+   * The substitute and substituteAll methods will not attempt to\n+   * interpolate occurrences of $1-$9 in the replacement text with\n+   * the corresponding subexpressions.  For example, you may want to\n+   * replace all matches of \"one dollar\" with \"$1\".\n+   */\n+  public static final int REG_NO_INTERPOLATE = 128;\n+\n+  /** Returns a string representing the version of the gnu.regexp package. */\n+  public static final String version() {\n+    return VERSION;\n+  }\n+\n+  // Retrieves a message from the ResourceBundle\n+  static final String getLocalizedMessage(String key) {\n+    return messages.getString(key);\n+  }\n+\n+  /**\n+   * Constructs a regular expression pattern buffer without any compilation\n+   * flags set, and using the default syntax (RESyntax.RE_SYNTAX_PERL5).\n+   *\n+   * @param pattern A regular expression pattern, in the form of a String,\n+   *   StringBuffer or char[].  Other input types will be converted to\n+   *   strings using the toString() method.\n+   * @exception REException The input pattern could not be parsed.\n+   * @exception NullPointerException The pattern was null.\n+   */\n+  public RE(Object pattern) throws REException {\n+    this(pattern,0,RESyntax.RE_SYNTAX_PERL5,0,0);\n+  }\n+\n+  /**\n+   * Constructs a regular expression pattern buffer using the specified\n+   * compilation flags and the default syntax (RESyntax.RE_SYNTAX_PERL5).\n+   *\n+   * @param pattern A regular expression pattern, in the form of a String,\n+   *   StringBuffer, or char[].  Other input types will be converted to\n+   *   strings using the toString() method.\n+   * @param cflags The logical OR of any combination of the compilation flags listed above.\n+   * @exception REException The input pattern could not be parsed.\n+   * @exception NullPointerException The pattern was null.\n+   */\n+  public RE(Object pattern, int cflags) throws REException {\n+    this(pattern,cflags,RESyntax.RE_SYNTAX_PERL5,0,0);\n+  }\n+\n+  /**\n+   * Constructs a regular expression pattern buffer using the specified\n+   * compilation flags and regular expression syntax.\n+   *\n+   * @param pattern A regular expression pattern, in the form of a String,\n+   *   StringBuffer, or char[].  Other input types will be converted to\n+   *   strings using the toString() method.\n+   * @param cflags The logical OR of any combination of the compilation flags listed above.\n+   * @param syntax The type of regular expression syntax to use.\n+   * @exception REException The input pattern could not be parsed.\n+   * @exception NullPointerException The pattern was null.\n+   */\n+  public RE(Object pattern, int cflags, RESyntax syntax) throws REException {\n+    this(pattern,cflags,syntax,0,0);\n+  }\n+\n+  // internal constructor used for alternation\n+  private RE(REToken first, REToken last,int subs, int subIndex, int minLength) {\n+    super(subIndex);\n+    firstToken = first;\n+    lastToken = last;\n+    numSubs = subs;\n+    minimumLength = minLength;\n+    addToken(new RETokenEndSub(subIndex));\n+  }\n+\n+  private RE(Object patternObj, int cflags, RESyntax syntax, int myIndex, int nextSub) throws REException {\n+    super(myIndex); // Subexpression index of this token.\n+    initialize(patternObj, cflags, syntax, myIndex, nextSub);\n+  }\n+\n+    // For use by subclasses\n+    protected RE() { super(0); }\n+\n+    // The meat of construction\n+  protected void initialize(Object patternObj, int cflags, RESyntax syntax, int myIndex, int nextSub) throws REException {\n+      char[] pattern;\n+    if (patternObj instanceof String) {\n+      pattern = ((String) patternObj).toCharArray();\n+    } else if (patternObj instanceof char[]) {\n+      pattern = (char[]) patternObj;\n+    } else if (patternObj instanceof StringBuffer) {\n+      pattern = new char [((StringBuffer) patternObj).length()];\n+      ((StringBuffer) patternObj).getChars(0,pattern.length,pattern,0);\n+    } else {\n+\tpattern = patternObj.toString().toCharArray();\n+    }\n+\n+    int pLength = pattern.length;\n+\n+    numSubs = 0; // Number of subexpressions in this token.\n+    Vector branches = null;\n+\n+    // linked list of tokens (sort of -- some closed loops can exist)\n+    firstToken = lastToken = null;\n+\n+    // Precalculate these so we don't pay for the math every time we\n+    // need to access them.\n+    boolean insens = ((cflags & REG_ICASE) > 0);\n+\n+    // Parse pattern into tokens.  Does anyone know if it's more efficient\n+    // to use char[] than a String.charAt()?  I'm assuming so.\n+\n+    // index tracks the position in the char array\n+    int index = 0;\n+\n+    // this will be the current parse character (pattern[index])\n+    CharUnit unit = new CharUnit();\n+\n+    // This is used for {x,y} calculations\n+    IntPair minMax = new IntPair();\n+\n+    // Buffer a token so we can create a TokenRepeated, etc.\n+    REToken currentToken = null;\n+    char ch;\n+\n+    while (index < pLength) {\n+      // read the next character unit (including backslash escapes)\n+      index = getCharUnit(pattern,index,unit);\n+\n+      // ALTERNATION OPERATOR\n+      //  \\| or | (if RE_NO_BK_VBAR) or newline (if RE_NEWLINE_ALT)\n+      //  not available if RE_LIMITED_OPS is set\n+\n+      // TODO: the '\\n' literal here should be a test against REToken.newline,\n+      // which unfortunately may be more than a single character.\n+      if ( ( (unit.ch == '|' && (syntax.get(RESyntax.RE_NO_BK_VBAR) ^ unit.bk))\n+\t     || (syntax.get(RESyntax.RE_NEWLINE_ALT) && (unit.ch == '\\n') && !unit.bk) )\n+\t   && !syntax.get(RESyntax.RE_LIMITED_OPS)) {\n+\t// make everything up to here be a branch. create vector if nec.\n+\taddToken(currentToken);\n+\tRE theBranch = new RE(firstToken, lastToken, numSubs, subIndex, minimumLength);\n+\tminimumLength = 0;\n+\tif (branches == null) {\n+\t    branches = new Vector();\n+\t}\n+\tbranches.addElement(theBranch);\n+\tfirstToken = lastToken = currentToken = null;\n+      }\n+      \n+      // INTERVAL OPERATOR:\n+      //  {x} | {x,} | {x,y}  (RE_INTERVALS && RE_NO_BK_BRACES)\n+      //  \\{x\\} | \\{x,\\} | \\{x,y\\} (RE_INTERVALS && !RE_NO_BK_BRACES)\n+      //\n+      // OPEN QUESTION: \n+      //  what is proper interpretation of '{' at start of string?\n+\n+      else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)) {\n+\tint newIndex = getMinMax(pattern,index,minMax,syntax);\n+        if (newIndex > index) {\n+          if (minMax.first > minMax.second)\n+            throw new REException(getLocalizedMessage(\"interval.order\"),REException.REG_BADRPT,newIndex);\n+          if (currentToken == null)\n+            throw new REException(getLocalizedMessage(\"repeat.no.token\"),REException.REG_BADRPT,newIndex);\n+          if (currentToken instanceof RETokenRepeated) \n+            throw new REException(getLocalizedMessage(\"repeat.chained\"),REException.REG_BADRPT,newIndex);\n+          if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)\n+            throw new REException(getLocalizedMessage(\"repeat.assertion\"),REException.REG_BADRPT,newIndex);\n+          if ((currentToken.getMinimumLength() == 0) && (minMax.second == Integer.MAX_VALUE))\n+            throw new REException(getLocalizedMessage(\"repeat.empty.token\"),REException.REG_BADRPT,newIndex);\n+          index = newIndex;\n+          currentToken = setRepeated(currentToken,minMax.first,minMax.second,index); \n+        }\n+        else {\n+          addToken(currentToken);\n+          currentToken = new RETokenChar(subIndex,unit.ch,insens);\n+        } \n+      }\n+      \n+      // LIST OPERATOR:\n+      //  [...] | [^...]\n+\n+      else if ((unit.ch == '[') && !unit.bk) {\n+\tVector options = new Vector();\n+\tboolean negative = false;\n+\tchar lastChar = 0;\n+\tif (index == pLength) throw new REException(getLocalizedMessage(\"unmatched.bracket\"),REException.REG_EBRACK,index);\n+\t\n+\t// Check for initial caret, negation\n+\tif ((ch = pattern[index]) == '^') {\n+\t  negative = true;\n+\t  if (++index == pLength) throw new REException(getLocalizedMessage(\"class.no.end\"),REException.REG_EBRACK,index);\n+\t  ch = pattern[index];\n+\t}\n+\n+\t// Check for leading right bracket literal\n+\tif (ch == ']') {\n+\t  lastChar = ch;\n+\t  if (++index == pLength) throw new REException(getLocalizedMessage(\"class.no.end\"),REException.REG_EBRACK,index);\n+\t}\n+\n+\twhile ((ch = pattern[index++]) != ']') {\n+\t  if ((ch == '-') && (lastChar != 0)) {\n+\t    if (index == pLength) throw new REException(getLocalizedMessage(\"class.no.end\"),REException.REG_EBRACK,index);\n+\t    if ((ch = pattern[index]) == ']') {\n+\t      options.addElement(new RETokenChar(subIndex,lastChar,insens));\n+\t      lastChar = '-';\n+\t    } else {\n+\t      options.addElement(new RETokenRange(subIndex,lastChar,ch,insens));\n+\t      lastChar = 0;\n+\t      index++;\n+\t    }\n+          } else if ((ch == '\\\\') && syntax.get(RESyntax.RE_BACKSLASH_ESCAPE_IN_LISTS)) {\n+            if (index == pLength) throw new REException(getLocalizedMessage(\"class.no.end\"),REException.REG_EBRACK,index);\n+\t    int posixID = -1;\n+\t    boolean negate = false;\n+            char asciiEsc = 0;\n+\t    if ((\"dswDSW\".indexOf(pattern[index]) != -1) && syntax.get(RESyntax.RE_CHAR_CLASS_ESC_IN_LISTS)) {\n+\t      switch (pattern[index]) {\n+\t      case 'D':\n+\t\tnegate = true;\n+\t      case 'd':\n+\t\tposixID = RETokenPOSIX.DIGIT;\n+\t\tbreak;\n+\t      case 'S':\n+\t\tnegate = true;\n+\t      case 's':\n+\t\tposixID = RETokenPOSIX.SPACE;\n+\t\tbreak;\n+\t      case 'W':\n+\t\tnegate = true;\n+\t      case 'w':\n+\t\tposixID = RETokenPOSIX.ALNUM;\n+\t\tbreak;\n+\t      }\n+\t    }\n+            else if (\"nrt\".indexOf(pattern[index]) != -1) {\n+              switch (pattern[index]) {\n+                case 'n':\n+                  asciiEsc = '\\n';\n+                  break;\n+                case 't':\n+                  asciiEsc = '\\t';\n+                  break;\n+                case 'r':\n+                  asciiEsc = '\\r';\n+                  break;\n+              }\n+            }\n+\t    if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));\n+\t    \n+\t    if (posixID != -1) {\n+\t      options.addElement(new RETokenPOSIX(subIndex,posixID,insens,negate));\n+\t    } else if (asciiEsc != 0) {\n+\t      lastChar = asciiEsc;\n+\t    } else {\n+\t      lastChar = pattern[index];\n+\t    }\n+\t    ++index;\n+\t  } else if ((ch == '[') && (syntax.get(RESyntax.RE_CHAR_CLASSES)) && (index < pLength) && (pattern[index] == ':')) {\n+\t    StringBuffer posixSet = new StringBuffer();\n+\t    index = getPosixSet(pattern,index+1,posixSet);\n+\t    int posixId = RETokenPOSIX.intValue(posixSet.toString());\n+\t    if (posixId != -1)\n+\t      options.addElement(new RETokenPOSIX(subIndex,posixId,insens,false));\n+\t  } else {\n+\t    if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));\n+\t    lastChar = ch;\n+\t  }\n+\t  if (index == pLength) throw new REException(getLocalizedMessage(\"class.no.end\"),REException.REG_EBRACK,index);\n+\t} // while in list\n+\t// Out of list, index is one past ']'\n+\t    \n+\tif (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));\n+\t    \n+\t// Create a new RETokenOneOf\n+\taddToken(currentToken);\n+\toptions.trimToSize();\n+\tcurrentToken = new RETokenOneOf(subIndex,options,negative);\n+      }\n+\n+      // SUBEXPRESSIONS\n+      //  (...) | \\(...\\) depending on RE_NO_BK_PARENS\n+\n+      else if ((unit.ch == '(') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) {\n+\tboolean pure = false;\n+\tboolean comment = false;\n+\tif ((index+1 < pLength) && (pattern[index] == '?')) {\n+\t  switch (pattern[index+1]) {\n+\t  case ':':\n+\t    if (syntax.get(RESyntax.RE_PURE_GROUPING)) {\n+\t      pure = true;\n+\t      index += 2;\n+\t    }\n+\t    break;\n+\t  case '#':\n+\t    if (syntax.get(RESyntax.RE_COMMENTS)) {\n+\t      comment = true;\n+\t    }\n+\t    break;\n+          default:\n+            throw new REException(getLocalizedMessage(\"repeat.no.token\"), REException.REG_BADRPT, index);\n+\t  }\n+\t}\n+\n+\tif (index >= pLength) {\n+\t    throw new REException(getLocalizedMessage(\"unmatched.paren\"), REException.REG_ESUBREG,index);\n+\t}\n+\n+\t// find end of subexpression\n+\tint endIndex = index;\n+\tint nextIndex = index;\n+\tint nested = 0;\n+\n+\twhile ( ((nextIndex = getCharUnit(pattern,endIndex,unit)) > 0)\n+\t\t&& !(nested == 0 && (unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) )\n+\t  if ((endIndex = nextIndex) >= pLength)\n+\t    throw new REException(getLocalizedMessage(\"subexpr.no.end\"),REException.REG_ESUBREG,nextIndex);\n+\t  else if (unit.ch == '(' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))\n+\t    nested++;\n+\t  else if (unit.ch == ')' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))\n+\t    nested--;\n+\n+\t// endIndex is now position at a ')','\\)' \n+\t// nextIndex is end of string or position after ')' or '\\)'\n+\n+\tif (comment) index = nextIndex;\n+\telse { // not a comment\n+\t  // create RE subexpression as token.\n+\t  addToken(currentToken);\n+\t  if (!pure) {\n+\t    numSubs++;\n+\t  }\n+\n+\t  int useIndex = (pure) ? 0 : nextSub + numSubs;\n+\t  currentToken = new RE(String.valueOf(pattern,index,endIndex-index).toCharArray(),cflags,syntax,useIndex,nextSub + numSubs);\n+\t  numSubs += ((RE) currentToken).getNumSubs();\n+\n+\t  index = nextIndex;\n+\t} // not a comment\n+      } // subexpression\n+    \n+      // UNMATCHED RIGHT PAREN\n+      // ) or \\) throw exception if\n+      // !syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD)\n+      else if (!syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD) && ((unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))) {\n+\tthrow new REException(getLocalizedMessage(\"unmatched.paren\"),REException.REG_EPAREN,index);\n+      }\n+\n+      // START OF LINE OPERATOR\n+      //  ^\n+\n+      else if ((unit.ch == '^') && !unit.bk) {\n+\taddToken(currentToken);\n+\tcurrentToken = null;\n+\taddToken(new RETokenStart(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));\n+      }\n+\n+      // END OF LINE OPERATOR\n+      //  $\n+\n+      else if ((unit.ch == '$') && !unit.bk) {\n+\taddToken(currentToken);\n+\tcurrentToken = null;\n+\taddToken(new RETokenEnd(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));\n+      }\n+\n+      // MATCH-ANY-CHARACTER OPERATOR (except possibly newline and null)\n+      //  .\n+\n+      else if ((unit.ch == '.') && !unit.bk) {\n+\taddToken(currentToken);\n+\tcurrentToken = new RETokenAny(subIndex,syntax.get(RESyntax.RE_DOT_NEWLINE) || ((cflags & REG_DOT_NEWLINE) > 0),syntax.get(RESyntax.RE_DOT_NOT_NULL));\n+      }\n+\n+      // ZERO-OR-MORE REPEAT OPERATOR\n+      //  *\n+\n+      else if ((unit.ch == '*') && !unit.bk) {\n+\tif (currentToken == null)\n+          throw new REException(getLocalizedMessage(\"repeat.no.token\"),REException.REG_BADRPT,index);\n+\tif (currentToken instanceof RETokenRepeated)\n+          throw new REException(getLocalizedMessage(\"repeat.chained\"),REException.REG_BADRPT,index);\n+\tif (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)\n+\t  throw new REException(getLocalizedMessage(\"repeat.assertion\"),REException.REG_BADRPT,index);\n+\tif (currentToken.getMinimumLength() == 0)\n+\t  throw new REException(getLocalizedMessage(\"repeat.empty.token\"),REException.REG_BADRPT,index);\n+\tcurrentToken = setRepeated(currentToken,0,Integer.MAX_VALUE,index);\n+      }\n+\n+      // ONE-OR-MORE REPEAT OPERATOR\n+      //  + | \\+ depending on RE_BK_PLUS_QM\n+      //  not available if RE_LIMITED_OPS is set\n+\n+      else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {\n+\tif (currentToken == null)\n+          throw new REException(getLocalizedMessage(\"repeat.no.token\"),REException.REG_BADRPT,index);\n+\tif (currentToken instanceof RETokenRepeated)\n+          throw new REException(getLocalizedMessage(\"repeat.chained\"),REException.REG_BADRPT,index);\n+\tif (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)\n+\t  throw new REException(getLocalizedMessage(\"repeat.assertion\"),REException.REG_BADRPT,index);\n+\tif (currentToken.getMinimumLength() == 0)\n+\t  throw new REException(getLocalizedMessage(\"repeat.empty.token\"),REException.REG_BADRPT,index);\n+\tcurrentToken = setRepeated(currentToken,1,Integer.MAX_VALUE,index);\n+      }\n+\n+      // ZERO-OR-ONE REPEAT OPERATOR / STINGY MATCHING OPERATOR\n+      //  ? | \\? depending on RE_BK_PLUS_QM\n+      //  not available if RE_LIMITED_OPS is set\n+      //  stingy matching if RE_STINGY_OPS is set and it follows a quantifier\n+\n+      else if ((unit.ch == '?') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {\n+\tif (currentToken == null) throw new REException(getLocalizedMessage(\"repeat.no.token\"),REException.REG_BADRPT,index);\n+\n+\t// Check for stingy matching on RETokenRepeated\n+\tif (currentToken instanceof RETokenRepeated) {\n+          if (syntax.get(RESyntax.RE_STINGY_OPS) && !((RETokenRepeated)currentToken).isStingy())\n+            ((RETokenRepeated)currentToken).makeStingy();\n+          else\n+            throw new REException(getLocalizedMessage(\"repeat.chained\"),REException.REG_BADRPT,index);\n+        }\n+        else if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)\n+          throw new REException(getLocalizedMessage(\"repeat.assertion\"),REException.REG_BADRPT,index);\n+\telse\n+\t  currentToken = setRepeated(currentToken,0,1,index);\n+      }\n+\t\n+      // BACKREFERENCE OPERATOR\n+      //  \\1 \\2 ... \\9\n+      // not available if RE_NO_BK_REFS is set\n+\n+      else if (unit.bk && Character.isDigit(unit.ch) && !syntax.get(RESyntax.RE_NO_BK_REFS)) {\n+\taddToken(currentToken);\n+\tcurrentToken = new RETokenBackRef(subIndex,Character.digit(unit.ch,10),insens);\n+      }\n+\n+      // START OF STRING OPERATOR\n+      //  \\A if RE_STRING_ANCHORS is set\n+      \n+      else if (unit.bk && (unit.ch == 'A') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {\n+\taddToken(currentToken);\n+\tcurrentToken = new RETokenStart(subIndex,null);\n+      }\n+\n+      // WORD BREAK OPERATOR\n+      //  \\b if ????\n+\n+      else if (unit.bk && (unit.ch == 'b') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN | RETokenWordBoundary.END, false);\n+      } \n+\n+      // WORD BEGIN OPERATOR \n+      //  \\< if ????\n+      else if (unit.bk && (unit.ch == '<')) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN, false);\n+      } \n+\n+      // WORD END OPERATOR \n+      //  \\> if ????\n+      else if (unit.bk && (unit.ch == '>')) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.END, false);\n+      } \n+\n+      // NON-WORD BREAK OPERATOR\n+      // \\B if ????\n+\n+      else if (unit.bk && (unit.ch == 'B') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN | RETokenWordBoundary.END, true);\n+      } \n+\n+      \n+      // DIGIT OPERATOR\n+      //  \\d if RE_CHAR_CLASS_ESCAPES is set\n+      \n+      else if (unit.bk && (unit.ch == 'd') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {\n+\taddToken(currentToken);\n+\tcurrentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.DIGIT,insens,false);\n+      }\n+\n+      // NON-DIGIT OPERATOR\n+      //  \\D\n+\n+\telse if (unit.bk && (unit.ch == 'D') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.DIGIT,insens,true);\n+\t}\n+\n+\t// NEWLINE ESCAPE\n+        //  \\n\n+\n+\telse if (unit.bk && (unit.ch == 'n')) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenChar(subIndex,'\\n',false);\n+\t}\n+\n+\t// RETURN ESCAPE\n+        //  \\r\n+\n+\telse if (unit.bk && (unit.ch == 'r')) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenChar(subIndex,'\\r',false);\n+\t}\n+\n+\t// WHITESPACE OPERATOR\n+        //  \\s if RE_CHAR_CLASS_ESCAPES is set\n+\n+\telse if (unit.bk && (unit.ch == 's') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.SPACE,insens,false);\n+\t}\n+\n+\t// NON-WHITESPACE OPERATOR\n+        //  \\S\n+\n+\telse if (unit.bk && (unit.ch == 'S') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.SPACE,insens,true);\n+\t}\n+\n+\t// TAB ESCAPE\n+        //  \\t\n+\n+\telse if (unit.bk && (unit.ch == 't')) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenChar(subIndex,'\\t',false);\n+\t}\n+\n+\t// ALPHANUMERIC OPERATOR\n+        //  \\w\n+\n+\telse if (unit.bk && (unit.ch == 'w') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.ALNUM,insens,false);\n+\t}\n+\n+\t// NON-ALPHANUMERIC OPERATOR\n+        //  \\W\n+\n+\telse if (unit.bk && (unit.ch == 'W') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.ALNUM,insens,true);\n+\t}\n+\n+\t// END OF STRING OPERATOR\n+        //  \\Z\n+\n+\telse if (unit.bk && (unit.ch == 'Z') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenEnd(subIndex,null);\n+\t}\n+\n+\t// NON-SPECIAL CHARACTER (or escape to make literal)\n+        //  c | \\* for example\n+\n+\telse {  // not a special character\n+\t  addToken(currentToken);\n+\t  currentToken = new RETokenChar(subIndex,unit.ch,insens);\n+\t} \n+      } // end while\n+\n+    // Add final buffered token and an EndSub marker\n+    addToken(currentToken);\n+      \n+    if (branches != null) {\n+\tbranches.addElement(new RE(firstToken,lastToken,numSubs,subIndex,minimumLength));\n+\tbranches.trimToSize(); // compact the Vector\n+\tminimumLength = 0;\n+\tfirstToken = lastToken = null;\n+\taddToken(new RETokenOneOf(subIndex,branches,false));\n+    } \n+    else addToken(new RETokenEndSub(subIndex));\n+\n+  }\n+\n+  private static int getCharUnit(char[] input, int index, CharUnit unit) throws REException {\n+    unit.ch = input[index++];\n+    if (unit.bk = (unit.ch == '\\\\'))\n+      if (index < input.length)\n+\tunit.ch = input[index++];\n+      else throw new REException(getLocalizedMessage(\"ends.with.backslash\"),REException.REG_ESCAPE,index);\n+    return index;\n+  }\n+\n+  /**\n+   * Checks if the regular expression matches the input in its entirety.\n+   *\n+   * @param input The input text.\n+   */\n+  public boolean isMatch(Object input) {\n+    return isMatch(input,0,0);\n+  }\n+  \n+  /**\n+   * Checks if the input string, starting from index, is an exact match of\n+   * this regular expression.\n+   *\n+   * @param input The input text.\n+   * @param index The offset index at which the search should be begin.\n+   */\n+  public boolean isMatch(Object input,int index) {\n+    return isMatch(input,index,0);\n+  }\n+  \n+\n+  /**\n+   * Checks if the input, starting from index and using the specified\n+   * execution flags, is an exact match of this regular expression.\n+   *\n+   * @param input The input text.\n+   * @param index The offset index at which the search should be begin.\n+   * @param eflags The logical OR of any execution flags above.\n+   */\n+  public boolean isMatch(Object input,int index,int eflags) {\n+    return isMatchImpl(makeCharIndexed(input,index),index,eflags);\n+  }\n+\n+  private boolean isMatchImpl(CharIndexed input, int index, int eflags) {\n+    if (firstToken == null)  // Trivial case\n+      return (input.charAt(0) == CharIndexed.OUT_OF_BOUNDS);\n+    REMatch m = new REMatch(numSubs, index, eflags);\n+    if (firstToken.match(input, m)) {\n+\twhile (m != null) {\n+\t    if (input.charAt(m.index) == CharIndexed.OUT_OF_BOUNDS) {\n+\t\treturn true;\n+\t    }\n+\t    m = m.next;\n+\t}\n+    }\n+    return false;\n+  }\n+    \n+  /**\n+   * Returns the maximum number of subexpressions in this regular expression.\n+   * If the expression contains branches, the value returned will be the\n+   * maximum subexpressions in any of the branches.\n+   */\n+  public int getNumSubs() {\n+    return numSubs;\n+  }\n+\n+  // Overrides REToken.setUncle\n+  void setUncle(REToken uncle) {\n+      if (lastToken != null) {\n+\t  lastToken.setUncle(uncle);\n+      } else super.setUncle(uncle); // to deal with empty subexpressions\n+  }\n+\n+  // Overrides REToken.chain\n+\n+  boolean chain(REToken next) {\n+    super.chain(next);\n+    setUncle(next);\n+    return true;\n+  }\n+\n+  /**\n+   * Returns the minimum number of characters that could possibly\n+   * constitute a match of this regular expression.\n+   */\n+  public int getMinimumLength() {\n+      return minimumLength;\n+  }\n+\n+  /**\n+   * Returns an array of all matches found in the input.\n+   *\n+   * If the regular expression allows the empty string to match, it will\n+   * substitute matches at all positions except the end of the input.\n+   *\n+   * @param input The input text.\n+   * @return a non-null (but possibly zero-length) array of matches\n+   */\n+  public REMatch[] getAllMatches(Object input) {\n+    return getAllMatches(input,0,0);\n+  }\n+\n+  /**\n+   * Returns an array of all matches found in the input,\n+   * beginning at the specified index position.\n+   *\n+   * If the regular expression allows the empty string to match, it will\n+   * substitute matches at all positions except the end of the input.\n+   *\n+   * @param input The input text.\n+   * @param index The offset index at which the search should be begin.\n+   * @return a non-null (but possibly zero-length) array of matches\n+   */\n+  public REMatch[] getAllMatches(Object input, int index) {\n+    return getAllMatches(input,index,0);\n+  }\n+\n+  /**\n+   * Returns an array of all matches found in the input string,\n+   * beginning at the specified index position and using the specified\n+   * execution flags.\n+   *\n+   * If the regular expression allows the empty string to match, it will\n+   * substitute matches at all positions except the end of the input.\n+   *\n+   * @param input The input text.\n+   * @param index The offset index at which the search should be begin.\n+   * @param eflags The logical OR of any execution flags above.\n+   * @return a non-null (but possibly zero-length) array of matches\n+   */\n+  public REMatch[] getAllMatches(Object input, int index, int eflags) {\n+    return getAllMatchesImpl(makeCharIndexed(input,index),index,eflags);\n+  }\n+\n+  // this has been changed since 1.03 to be non-overlapping matches\n+  private REMatch[] getAllMatchesImpl(CharIndexed input, int index, int eflags) {\n+    Vector all = new Vector();\n+    REMatch m = null;\n+    while ((m = getMatchImpl(input,index,eflags,null)) != null) {\n+      all.addElement(m);\n+      index = m.getEndIndex();\n+      if (m.end[0] == 0) {   // handle pathological case of zero-length match\n+\tindex++;\n+\tinput.move(1);\n+      } else {\n+\tinput.move(m.end[0]);\n+      }\n+      if (!input.isValid()) break;\n+    }\n+    REMatch[] mset = new REMatch[all.size()];\n+    all.copyInto(mset);\n+    return mset;\n+  }\n+  \n+    /* Implements abstract method REToken.match() */\n+    boolean match(CharIndexed input, REMatch mymatch) { \n+\tif (firstToken == null) return next(input, mymatch);\n+\n+\t// Note the start of this subexpression\n+\tmymatch.start[subIndex] = mymatch.index;\n+\n+\treturn firstToken.match(input, mymatch);\n+    }\n+  \n+  /**\n+   * Returns the first match found in the input.  If no match is found,\n+   * null is returned.\n+   *\n+   * @param input The input text.\n+   * @return An REMatch instance referencing the match, or null if none.\n+   */\n+  public REMatch getMatch(Object input) {\n+    return getMatch(input,0,0);\n+  }\n+  \n+  /**\n+   * Returns the first match found in the input, beginning\n+   * the search at the specified index.  If no match is found,\n+   * returns null.\n+   *\n+   * @param input The input text.\n+   * @param index The offset within the text to begin looking for a match.\n+   * @return An REMatch instance referencing the match, or null if none.\n+   */\n+  public REMatch getMatch(Object input, int index) {\n+    return getMatch(input,index,0);\n+  }\n+  \n+  /**\n+   * Returns the first match found in the input, beginning\n+   * the search at the specified index, and using the specified\n+   * execution flags.  If no match is found, returns null.\n+   *\n+   * @param input The input text.\n+   * @param index The offset index at which the search should be begin.\n+   * @param eflags The logical OR of any execution flags above.\n+   * @return An REMatch instance referencing the match, or null if none.\n+   */\n+  public REMatch getMatch(Object input, int index, int eflags) {\n+    return getMatch(input,index,eflags,null);\n+  }\n+\n+  /**\n+   * Returns the first match found in the input, beginning the search\n+   * at the specified index, and using the specified execution flags.\n+   * If no match is found, returns null.  If a StringBuffer is\n+   * provided and is non-null, the contents of the input text from the\n+   * index to the beginning of the match (or to the end of the input,\n+   * if there is no match) are appended to the StringBuffer.\n+   *\n+   * @param input The input text.\n+   * @param index The offset index at which the search should be begin.\n+   * @param eflags The logical OR of any execution flags above.\n+   * @param buffer The StringBuffer to save pre-match text in.\n+   * @return An REMatch instance referencing the match, or null if none.  */\n+  public REMatch getMatch(Object input, int index, int eflags, StringBuffer buffer) {\n+    return getMatchImpl(makeCharIndexed(input,index),index,eflags,buffer);\n+  }\n+\n+  REMatch getMatchImpl(CharIndexed input, int anchor, int eflags, StringBuffer buffer) {\n+      // Create a new REMatch to hold results\n+      REMatch mymatch = new REMatch(numSubs, anchor, eflags);\n+      do {\n+\t  // Optimization: check if anchor + minimumLength > length\n+\t  if (minimumLength == 0 || input.charAt(minimumLength-1) != CharIndexed.OUT_OF_BOUNDS) {\n+\t      if (match(input, mymatch)) {\n+\t\t  // Find longest match of them all to observe leftmost longest\n+\t\t  REMatch longest = mymatch;\n+\t\t  while ((mymatch = mymatch.next) != null) {\n+\t\t      if (mymatch.index > longest.index) {\n+\t\t\t  longest = mymatch;\n+\t\t      }\n+\t\t  }\n+\t\t  \n+\t\t  longest.end[0] = longest.index;\n+\t\t  longest.finish(input);\n+\t\t  return longest;\n+\t      }\n+\t  }\n+\t  mymatch.clear(++anchor);\n+\t  // Append character to buffer if needed\n+\t  if (buffer != null && input.charAt(0) != CharIndexed.OUT_OF_BOUNDS) {\n+\t      buffer.append(input.charAt(0));\n+\t  }\n+      } while (input.move(1));\n+      \n+      // Special handling at end of input for e.g. \"$\"\n+      if (minimumLength == 0) {\n+\t  if (match(input, mymatch)) {\n+\t      mymatch.finish(input);\n+\t      return mymatch;\n+\t  }\n+      }\n+\n+      return null;\n+  }\n+\n+  /**\n+   * Returns an REMatchEnumeration that can be used to iterate over the\n+   * matches found in the input text.\n+   *\n+   * @param input The input text.\n+   * @return A non-null REMatchEnumeration instance.\n+   */\n+  public REMatchEnumeration getMatchEnumeration(Object input) {\n+    return getMatchEnumeration(input,0,0);\n+  }\n+\n+\n+  /**\n+   * Returns an REMatchEnumeration that can be used to iterate over the\n+   * matches found in the input text.\n+   *\n+   * @param input The input text.\n+   * @param index The offset index at which the search should be begin.\n+   * @return A non-null REMatchEnumeration instance, with its input cursor\n+   *  set to the index position specified.\n+   */\n+  public REMatchEnumeration getMatchEnumeration(Object input, int index) {\n+    return getMatchEnumeration(input,index,0);\n+  }\n+\n+  /**\n+   * Returns an REMatchEnumeration that can be used to iterate over the\n+   * matches found in the input text.\n+   *\n+   * @param input The input text.\n+   * @param index The offset index at which the search should be begin.\n+   * @param eflags The logical OR of any execution flags above.\n+   * @return A non-null REMatchEnumeration instance, with its input cursor\n+   *  set to the index position specified.\n+   */\n+  public REMatchEnumeration getMatchEnumeration(Object input, int index, int eflags) {\n+    return new REMatchEnumeration(this,makeCharIndexed(input,index),index,eflags);\n+  }\n+\n+\n+  /**\n+   * Substitutes the replacement text for the first match found in the input.\n+   *\n+   * @param input The input text.\n+   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).\n+   * @return A String interpolating the substituted text.\n+   * @see REMatch#substituteInto\n+   */\n+  public String substitute(Object input,String replace) {\n+    return substitute(input,replace,0,0);\n+  }\n+\n+  /**\n+   * Substitutes the replacement text for the first match found in the input\n+   * beginning at the specified index position.  Specifying an index\n+   * effectively causes the regular expression engine to throw away the\n+   * specified number of characters. \n+   *\n+   * @param input The input text.\n+   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).\n+   * @param index The offset index at which the search should be begin.\n+   * @return A String containing the substring of the input, starting\n+   *   at the index position, and interpolating the substituted text.\n+   * @see REMatch#substituteInto\n+   */\n+  public String substitute(Object input,String replace,int index) {\n+    return substitute(input,replace,index,0);\n+  }\n+\n+  /**\n+   * Substitutes the replacement text for the first match found in the input\n+   * string, beginning at the specified index position and using the\n+   * specified execution flags.\n+   *\n+   * @param input The input text.\n+   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).\n+   * @param index The offset index at which the search should be begin.\n+   * @param eflags The logical OR of any execution flags above.\n+   * @return A String containing the substring of the input, starting\n+   *   at the index position, and interpolating the substituted text.\n+   * @see REMatch#substituteInto\n+   */\n+  public String substitute(Object input,String replace,int index,int eflags) {\n+    return substituteImpl(makeCharIndexed(input,index),replace,index,eflags);\n+  }\n+\n+  private String substituteImpl(CharIndexed input,String replace,int index,int eflags) {\n+    StringBuffer buffer = new StringBuffer();\n+    REMatch m = getMatchImpl(input,index,eflags,buffer);\n+    if (m==null) return buffer.toString();\n+    buffer.append( ((eflags & REG_NO_INTERPOLATE) > 0) ?\n+\t\t   replace : m.substituteInto(replace) );\n+    if (input.move(m.end[0])) {\n+      do {\n+\tbuffer.append(input.charAt(0));\n+      } while (input.move(1));\n+    }\n+    return buffer.toString();\n+  }\n+  \n+  /**\n+   * Substitutes the replacement text for each non-overlapping match found \n+   * in the input text.\n+   *\n+   * @param input The input text.\n+   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).\n+   * @return A String interpolating the substituted text.\n+   * @see REMatch#substituteInto\n+   */\n+  public String substituteAll(Object input,String replace) {\n+    return substituteAll(input,replace,0,0);\n+  }\n+\n+  /**\n+   * Substitutes the replacement text for each non-overlapping match found \n+   * in the input text, starting at the specified index.\n+   *\n+   * If the regular expression allows the empty string to match, it will\n+   * substitute matches at all positions except the end of the input.\n+   *\n+   * @param input The input text.\n+   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).\n+   * @param index The offset index at which the search should be begin.\n+   * @return A String containing the substring of the input, starting\n+   *   at the index position, and interpolating the substituted text.\n+   * @see REMatch#substituteInto\n+   */\n+  public String substituteAll(Object input,String replace,int index) {\n+    return substituteAll(input,replace,index,0);\n+  }\n+ \n+  /**\n+   * Substitutes the replacement text for each non-overlapping match found \n+   * in the input text, starting at the specified index and using the\n+   * specified execution flags.\n+   *\n+   * @param input The input text.\n+   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).\n+   * @param index The offset index at which the search should be begin.\n+   * @param eflags The logical OR of any execution flags above.\n+   * @return A String containing the substring of the input, starting\n+   *   at the index position, and interpolating the substituted text.\n+   * @see REMatch#substituteInto\n+   */\n+  public String substituteAll(Object input,String replace,int index,int eflags) {\n+    return substituteAllImpl(makeCharIndexed(input,index),replace,index,eflags);\n+  }\n+\n+  private String substituteAllImpl(CharIndexed input,String replace,int index,int eflags) {\n+    StringBuffer buffer = new StringBuffer();\n+    REMatch m;\n+    while ((m = getMatchImpl(input,index,eflags,buffer)) != null) {\n+\tbuffer.append( ((eflags & REG_NO_INTERPOLATE) > 0) ?\n+\t\t       replace : m.substituteInto(replace) );\n+      index = m.getEndIndex();\n+      if (m.end[0] == 0) {\n+\tchar ch = input.charAt(0);\n+\tif (ch != CharIndexed.OUT_OF_BOUNDS) \n+\t    buffer.append(ch);\n+\tinput.move(1);\n+      } else {\n+\t  input.move(m.end[0]);\n+      }\n+\n+      if (!input.isValid()) break;\n+    }\n+    return buffer.toString();\n+  }\n+  \n+  /* Helper function for constructor */\n+  private void addToken(REToken next) {\n+    if (next == null) return;\n+    minimumLength += next.getMinimumLength();\n+    if (firstToken == null) {\n+\tlastToken = firstToken = next;\n+    } else {\n+      // if chain returns false, it \"rejected\" the token due to\n+      // an optimization, and next was combined with lastToken\n+      if (lastToken.chain(next)) {\n+\t  lastToken = next;\n+      }\n+    }\n+  }\n+\n+  private static REToken setRepeated(REToken current, int min, int max, int index) throws REException {\n+    if (current == null) throw new REException(getLocalizedMessage(\"repeat.no.token\"),REException.REG_BADRPT,index);\n+    return new RETokenRepeated(current.subIndex,current,min,max);\n+  }\n+\n+  private static int getPosixSet(char[] pattern,int index,StringBuffer buf) {\n+    // Precondition: pattern[index-1] == ':'\n+    // we will return pos of closing ']'.\n+    int i;\n+    for (i=index; i<(pattern.length-1); i++) {\n+      if ((pattern[i] == ':') && (pattern[i+1] == ']'))\n+\treturn i+2;\n+      buf.append(pattern[i]);\n+    }\n+    return index; // didn't match up\n+  }\n+\n+  private int getMinMax(char[] input,int index,IntPair minMax,RESyntax syntax) throws REException {\n+    // Precondition: input[index-1] == '{', minMax != null\n+\n+    boolean mustMatch = !syntax.get(RESyntax.RE_NO_BK_BRACES);\n+    int startIndex = index;\n+    if (index == input.length) {\n+      if (mustMatch)\n+        throw new REException(getLocalizedMessage(\"unmatched.brace\"),REException.REG_EBRACE,index);\n+      else\n+        return startIndex;\n+    }\n+    \n+    int min,max=0;\n+    CharUnit unit = new CharUnit();\n+    StringBuffer buf = new StringBuffer();\n+    \n+    // Read string of digits\n+    do {\n+      index = getCharUnit(input,index,unit);\n+      if (Character.isDigit(unit.ch))\n+        buf.append(unit.ch);\n+    } while ((index != input.length) && Character.isDigit(unit.ch));\n+\n+    // Check for {} tomfoolery\n+    if (buf.length() == 0) {\n+      if (mustMatch)\n+        throw new REException(getLocalizedMessage(\"interval.error\"),REException.REG_EBRACE,index);\n+      else\n+        return startIndex;\n+    }\n+\n+    min = Integer.parseInt(buf.toString());\n+\t\n+    if ((unit.ch == '}') && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk))\n+      max = min;\n+    else if (index == input.length)\n+      if (mustMatch)\n+        throw new REException(getLocalizedMessage(\"interval.no.end\"),REException.REG_EBRACE,index);\n+      else\n+        return startIndex;\n+    else if ((unit.ch == ',') && !unit.bk) {\n+      buf = new StringBuffer();\n+      // Read string of digits\n+      while (((index = getCharUnit(input,index,unit)) != input.length) && Character.isDigit(unit.ch))\n+\tbuf.append(unit.ch);\n+\n+      if (!((unit.ch == '}') && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)))\n+        if (mustMatch)\n+          throw new REException(getLocalizedMessage(\"interval.error\"),REException.REG_EBRACE,index);\n+        else\n+          return startIndex;\n+\n+      // This is the case of {x,}\n+      if (buf.length() == 0) max = Integer.MAX_VALUE;\n+      else max = Integer.parseInt(buf.toString());\n+    } else\n+      if (mustMatch)\n+        throw new REException(getLocalizedMessage(\"interval.error\"),REException.REG_EBRACE,index);\n+      else\n+        return startIndex;\n+\n+    // We know min and max now, and they are valid.\n+\n+    minMax.first = min;\n+    minMax.second = max;\n+\n+    // return the index following the '}'\n+    return index;\n+  }\n+\n+   /**\n+    * Return a human readable form of the compiled regular expression,\n+    * useful for debugging.\n+    */\n+   public String toString() {\n+     StringBuffer sb = new StringBuffer();\n+     dump(sb);\n+     return sb.toString();\n+   }\n+\n+  void dump(StringBuffer os) {\n+    os.append('(');\n+    if (subIndex == 0)\n+      os.append(\"?:\");\n+    if (firstToken != null)\n+      firstToken.dumpAll(os);\n+    os.append(')');\n+  }\n+\n+  // Cast input appropriately or throw exception\n+  private static CharIndexed makeCharIndexed(Object input, int index) {\n+      // We could let a String fall through to final input, but since\n+      // it's the most likely input type, we check it first.\n+    if (input instanceof String)\n+      return new CharIndexedString((String) input,index);\n+    else if (input instanceof char[])\n+      return new CharIndexedCharArray((char[]) input,index);\n+    else if (input instanceof StringBuffer)\n+      return new CharIndexedStringBuffer((StringBuffer) input,index);\n+    else if (input instanceof InputStream)\n+      return new CharIndexedInputStream((InputStream) input,index);\n+    else if (input instanceof CharIndexed)\n+\treturn (CharIndexed) input; // do we lose index info?\n+    else \n+\treturn new CharIndexedString(input.toString(), index);\n+  }\n+}"}, {"sha": "a10d2fc71fef66c2753a6610df4bb3e7db5c74ee", "filename": "libjava/gnu/regexp/REException.java", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FREException.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,182 @@\n+/* gnu/regexp/REException.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+\n+import java.text.MessageFormat;\n+\n+/**\n+ * This is the regular expression exception class.  An exception of this type\n+ * defines the three attributes:\n+ * <OL>\n+ * <LI> A descriptive message of the error.\n+ * <LI> An integral type code equivalent to one of the statically\n+ *      defined symbols listed below.\n+ * <LI> The approximate position in the input string where the error\n+ *      occurred.\n+ * </OL>\n+ *\n+ * @author <A HREF=\"mailto:wes@cacas.org\">Wes Biggs</A>\n+ */\n+\n+public class REException extends Exception {\n+  private int type;\n+  private int pos;\n+\n+  // Error conditions from GNU regcomp(3) manual\n+\n+  /**\n+   * Error flag.\n+   * Invalid use of repetition operators such  as  using\n+   * `*' as the first character.\n+   */\n+  public static final int REG_BADRPT  =  1;\n+\n+  /**\n+   * Error flag.\n+   * Invalid use of back reference operator.\n+   */\n+  public static final int REG_BADBR   =  2;\n+\n+  /**\n+   * Error flag.\n+   * Un-matched brace interval operators.\n+   */\n+  public static final int REG_EBRACE  =  3;\n+\n+  /**\n+   * Error flag.\n+   * Un-matched bracket list operators.\n+   */\n+  public static final int REG_EBRACK  =  4;\n+\n+  /**\n+   * Error flag.\n+   * Invalid  use  of the range operator, eg. the ending\n+   * point of the range occurs  prior  to  the  starting\n+   * point.\n+   */\n+  public static final int REG_ERANGE  =  5;\n+\n+  /**\n+   * Error flag.\n+   * Unknown character class name. <B>Not implemented</B>.\n+   */\n+  public static final int REG_ECTYPE  =  6;\n+\n+  /**\n+   * Error flag.\n+   * Un-matched parenthesis group operators.\n+   */\n+  public static final int REG_EPAREN  =  7;\n+\n+  /**\n+   * Error flag.\n+   * Invalid back reference to a subexpression.\n+   */\n+  public static final int REG_ESUBREG =  8;\n+\n+  /**\n+   * Error flag.\n+   * Non specific error. <B>Not implemented</B>.\n+   */\n+  public static final int REG_EEND    =  9;\n+\n+  /**\n+   * Error flag.\n+   * Invalid escape sequence. <B>Not implemented</B>.\n+   */\n+  public static final int REG_ESCAPE  = 10;\n+\n+  /**\n+   * Error flag.\n+   * Invalid  use  of pattern operators such as group or list.\n+   */\n+  public static final int REG_BADPAT  = 11;\n+\n+  /**\n+   * Error flag.\n+   * Compiled  regular  expression  requires  a  pattern\n+   * buffer larger than 64Kb. <B>Not implemented</B>.\n+   */\n+  public static final int REG_ESIZE   = 12;\n+\n+  /**\n+   * Error flag.\n+   * The regex routines ran out of memory. <B>Not implemented</B>.\n+   */\n+  public static final int REG_ESPACE  = 13;\n+\n+  REException(String msg, int type, int position) { \n+    super(msg); \n+    this.type = type;\n+    this.pos = position;\n+  }\n+\n+  /**\n+   * Returns the type of the exception, one of the constants listed above.\n+   */\n+\n+  public int getType() {\n+    return type;\n+  }\n+\n+  /**\n+   * Returns the position, relative to the string or character array being\n+   * compiled, where the error occurred.  This position is generally the point\n+   * where the error was detected, not necessarily the starting index of\n+   * a bad subexpression.\n+   */\n+  public int getPosition() {\n+    return pos;\n+  }\n+\n+  /**\n+   * Reports the descriptive message associated with this exception\n+   * as well as its index position in the string or character array\n+   * being compiled.\n+   */\n+  public String getMessage() {\n+    Object[] args = {new Integer(pos)};\n+    StringBuffer sb = new StringBuffer();\n+    String prefix = RE.getLocalizedMessage(\"error.prefix\");\n+    sb.append(MessageFormat.format(prefix, args));\n+    sb.append('\\n');\n+    sb.append(super.getMessage());\n+    return sb.toString();\n+  }\n+}"}, {"sha": "f56a9a2a9cba93042c9d3b5f8efe5e50261801de", "filename": "libjava/gnu/regexp/REFilterInputStream.java", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREFilterInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREFilterInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FREFilterInputStream.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,140 @@\n+/* gnu/regexp/REFilterInputStream.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+\n+/**\n+ * Replaces instances of a given RE found within an InputStream\n+ * with replacement text.   The replacements are interpolated into the\n+ * stream when a match is found.\n+ *\n+ * @author <A HREF=\"mailto:wes@cacas.org\">Wes Biggs</A>\n+ * @deprecated This class cannot properly handle all character\n+ *             encodings.  For proper handling, use the REFilterReader\n+ *             class instead.\n+ */\n+\n+public class REFilterInputStream extends FilterInputStream {\n+\n+    private RE expr;\n+    private String replace;\n+    private String buffer;\n+    private int bufpos;\n+    private int offset;\n+    private CharIndexedInputStream stream;\n+\n+  /**\n+   * Creates an REFilterInputStream.  When reading from this stream,\n+   * occurrences of patterns matching the supplied regular expression\n+   * will be replaced with the supplied replacement text (the\n+   * metacharacters $0 through $9 may be used to refer to the full\n+   * match or subexpression matches).\n+   *\n+   * @param stream The InputStream to be filtered.\n+   * @param expr The regular expression to search for.\n+   * @param replace The text pattern to replace matches with.  \n+   */\n+  public REFilterInputStream(InputStream stream, RE expr, String replace) {\n+    super(stream);\n+    this.stream = new CharIndexedInputStream(stream,0);\n+    this.expr = expr;\n+    this.replace = replace;\n+  }\n+\n+  /**\n+   * Reads the next byte from the stream per the general contract of\n+   * InputStream.read().  Returns -1 on error or end of stream.\n+   */\n+  public int read() {\n+    // If we have buffered replace data, use it.\n+    if ((buffer != null) && (bufpos < buffer.length())) {\n+      return (int) buffer.charAt(bufpos++);\n+    }\n+\n+    // check if input is at a valid position\n+    if (!stream.isValid()) return -1;\n+\n+    REMatch mymatch = new REMatch(expr.getNumSubs(),offset,0);\n+    if (expr.match(stream, mymatch)) {\n+      mymatch.end[0] = mymatch.index;\n+      mymatch.finish(stream);\n+      stream.move(mymatch.toString().length());\n+      offset += mymatch.toString().length();\n+      buffer = mymatch.substituteInto(replace);\n+      bufpos = 1;\n+\n+      // This is prone to infinite loops if replace string turns out empty.\n+      if (buffer.length() > 0) {\n+\t  return buffer.charAt(0);\n+      }\n+    }\n+    char ch = stream.charAt(0);\n+    if (ch == CharIndexed.OUT_OF_BOUNDS) return -1;\n+    stream.move(1);\n+    offset++;\n+    return ch;\n+  }\n+\n+  /** \n+   * Returns false.  REFilterInputStream does not support mark() and\n+   * reset() methods. \n+   */\n+  public boolean markSupported() {\n+    return false;\n+  }\n+\n+  /** Reads from the stream into the provided array. */\n+  public int read(byte[] b, int off, int len) {\n+    int i;\n+    int ok = 0;\n+    while (len-- > 0) {\n+      i = read();\n+      if (i == -1) return (ok == 0) ? -1 : ok;\n+      b[off++] = (byte) i;\n+      ok++;\n+    }\n+    return ok;\n+  }\n+\n+  /** Reads from the stream into the provided array. */\n+  public int read(byte[] b) {\n+    return read(b,0,b.length);\n+  }\n+}"}, {"sha": "449efcc9b1c10beb4063d39a5779f790362f7259", "filename": "libjava/gnu/regexp/REFilterReader.java", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREFilterReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREFilterReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FREFilterReader.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,117 @@\n+/*\n+ *  gnu/regexp/REFilterReader.java\n+ *  Copyright (C) 2001 Lee Sau Dan\n+ *  Based on gnu.regexp.REFilterInputStream by Wes Biggs\n+ *\n+ *  This library is free software; you can redistribute it and/or modify\n+ *  it under the terms of the GNU Lesser General Public License as published\n+ *  by the Free Software Foundation; either version 2.1 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  This library is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU Lesser General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU Lesser General Public License\n+ *  along with this program; if not, write to the Free Software\n+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n+ */\n+\n+package gnu.regexp;\n+import java.io.FilterReader;\n+import java.io.Reader;\n+\n+/**\n+ * Replaces instances of a given RE with replacement text. \n+ *\n+ * @author <A HREF=\"http://www.csis.hku.hk/~sdlee/\">Lee Sau Dan</A>\n+ * @since gnu.regexp 1.1.0\n+ */\n+\n+public class REFilterReader extends FilterReader {\n+\n+  private RE expr;\n+  private String replace;\n+  private String buffer;\n+  private int bufpos;\n+  private int offset;\n+  private CharIndexedReader stream;\n+\n+  /**\n+   * Creates an REFilterReader.  When reading from this stream,\n+   * occurrences of patterns matching the supplied regular expression\n+   * will be replaced with the supplied replacement text (the\n+   * metacharacters $0 through $9 may be used to refer to the full\n+   * match or subexpression matches.\n+   *\n+   * @param stream The Reader to be filtered.\n+   * @param expr The regular expression to search for.\n+   * @param replace The text pattern to replace matches with.  \n+   */\n+  public REFilterReader(Reader stream, RE expr, String replace) {\n+    super(stream);\n+    this.stream = new CharIndexedReader(stream,0);\n+    this.expr = expr;\n+    this.replace = replace;\n+  }\n+\n+  /**\n+   * Reads the next character from the stream per the general contract of\n+   * Reader.read().  Returns -1 on error or end of stream.\n+   */\n+  public int read() {\n+    // If we have buffered replace data, use it.\n+    if ((buffer != null) && (bufpos < buffer.length())) {\n+      return (int) buffer.charAt(bufpos++);\n+    }\n+\n+    // check if input is at a valid position\n+    if (!stream.isValid()) return -1;\n+\n+    REMatch mymatch = new REMatch(expr.getNumSubs(),offset,0);\n+    if (expr.match(stream,mymatch)) {\n+      mymatch.end[0] = mymatch.index;\n+      mymatch.finish(stream);\n+      stream.move(mymatch.toString().length());\n+      offset += mymatch.toString().length();\n+      buffer = mymatch.substituteInto(replace);\n+      bufpos = 1;\n+\n+      if (buffer.length() > 0) {\n+\t  return buffer.charAt(0);\n+      }\n+    }\n+    char ch = stream.charAt(0);\n+    if (ch == CharIndexed.OUT_OF_BOUNDS) return -1;\n+    stream.move(1);\n+    offset++;\n+    return ch;\n+  }\n+\n+  /** \n+   * Returns false.  REFilterReader does not support mark() and\n+   * reset() methods. \n+   */\n+  public boolean markSupported() {\n+    return false;\n+  }\n+\n+  /** Reads from the stream into the provided array. */\n+  public int read(char[] b, int off, int len) {\n+    int i;\n+    int ok = 0;\n+    while (len-- > 0) {\n+      i = read();\n+      if (i == -1) return (ok == 0) ? -1 : ok;\n+      b[off++] = (char) i;\n+      ok++;\n+    }\n+    return ok;\n+  }\n+\n+  /** Reads from the stream into the provided array. */\n+  public int read(char[] b) {\n+    return read(b,0,b.length);\n+  }\n+}"}, {"sha": "ac6c80e919671023ac4b583ebac581af4c02db17", "filename": "libjava/gnu/regexp/REMatch.java", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREMatch.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREMatch.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FREMatch.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,263 @@\n+/* gnu/regexp/REMatch.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+import java.io.Serializable;\n+\n+/**\n+ * An instance of this class represents a match\n+ * completed by a gnu.regexp matching function. It can be used\n+ * to obtain relevant information about the location of a match\n+ * or submatch.\n+ *\n+ * @author <A HREF=\"mailto:wes@cacas.org\">Wes Biggs</A>\n+ */\n+public final class REMatch implements Serializable, Cloneable {\n+    private String matchedText;\n+\n+    // These variables are package scope for fast access within the engine\n+    int eflags; // execution flags this match was made using\n+\n+    // Offset in source text where match was tried.  This is zero-based;\n+    // the actual position in the source text is given by (offset + anchor).\n+    int offset;\n+\n+    // Anchor position refers to the index into the source input\n+    // at which the matching operation began.\n+    // This is also useful for the ANCHORINDEX option.\n+    int anchor;\n+\n+    // Package scope; used by RE.\n+    int index; // used while matching to mark current match position in input\n+    int[] start; // start positions (relative to offset) for each (sub)exp.\n+    int[] end;   // end positions for the same\n+    REMatch next; // other possibility (to avoid having to use arrays)\n+\n+    public Object clone() {\n+\ttry {\n+\t    REMatch copy = (REMatch) super.clone();\n+\t    copy.next = null;\n+\n+\t    copy.start = (int[]) start.clone();\n+\t    copy.end = (int[]) end.clone();\n+\n+\t    return copy;\n+\t} catch (CloneNotSupportedException e) {\n+\t    throw new Error(); // doesn't happen\n+\t}\n+    }\n+\n+    void assignFrom(REMatch other) {\n+\tstart = other.start;\n+\tend = other.end;\n+\tindex = other.index;\n+\t// need to deep clone?\n+\tnext = other.next;\n+    }\n+\n+    REMatch(int subs, int anchor, int eflags) {\n+\tstart = new int[subs+1];\n+\tend = new int[subs+1];\n+\tthis.anchor = anchor;\n+\tthis.eflags = eflags;\n+\tclear(anchor);\n+    }\n+\n+    void finish(CharIndexed text) {\n+\tstart[0] = 0;\n+\tStringBuffer sb = new StringBuffer();\n+\tint i;\n+\tfor (i = 0; i < end[0]; i++)\n+\t    sb.append(text.charAt(i));\n+\tmatchedText = sb.toString();\n+\tfor (i = 0; i < start.length; i++) {\n+\t    // If any subexpressions didn't terminate, they don't count\n+\t    // TODO check if this code ever gets hit\n+\t    if ((start[i] == -1) ^ (end[i] == -1)) {\n+\t\tstart[i] = -1;\n+\t\tend[i] = -1;\n+\t    }\n+\t}\n+\tnext = null; // cut off alternates\n+    }\n+    \n+    /** Clears the current match and moves the offset to the new index. */\n+    void clear(int index) {\n+\toffset = index;\n+\tthis.index = 0;\n+\tfor (int i = 0; i < start.length; i++) {\n+\t    start[i] = end[i] = -1;\n+\t}\n+\tnext = null; // cut off alternates\n+    }\n+    \n+    /**\n+     * Returns the string matching the pattern.  This makes it convenient\n+     * to write code like the following:\n+     * <P>\n+     * <code> \n+     * REMatch myMatch = myExpression.getMatch(myString);<br>\n+     * if (myMatch != null) System.out.println(\"Regexp found: \"+myMatch);\n+     * </code>\n+     */\n+    public String toString() {\n+\treturn matchedText;\n+    }\n+    \n+    /**\n+     * Returns the index within the input text where the match in its entirety\n+     * began.\n+     */\n+    public int getStartIndex() {\n+\treturn offset + start[0];\n+    }\n+    \n+    /**\n+     * Returns the index within the input string where the match in\n+     * its entirety ends.  The return value is the next position after\n+     * the end of the string; therefore, a match created by the\n+     * following call:\n+     *\n+     * <P>\n+     * <code>REMatch myMatch = myExpression.getMatch(myString);</code>\n+     * <P>\n+     * can be viewed (given that myMatch is not null) by creating\n+     * <P>\n+     * <code>String theMatch = myString.substring(myMatch.getStartIndex(),\n+     * myMatch.getEndIndex());</code>\n+     * <P>\n+     * But you can save yourself that work, since the <code>toString()</code>\n+     * method (above) does exactly that for you.  \n+     */\n+    public int getEndIndex() {\n+\treturn offset + end[0];\n+    }\n+  \n+    /**\n+     * Returns the string matching the given subexpression.  The subexpressions\n+     * are indexed starting with one, not zero.  That is, the subexpression\n+     * identified by the first set of parentheses in a regular expression\n+     * could be retrieved from an REMatch by calling match.toString(1).\n+     *\n+     * @param sub Index of the subexpression.\n+     */\n+    public String toString(int sub) {\n+\tif ((sub >= start.length) || (start[sub] == -1)) return \"\";\n+\treturn (matchedText.substring(start[sub],end[sub]));\n+    }\n+    \n+    /** \n+     * Returns the index within the input string used to generate this match\n+     * where subexpression number <i>sub</i> begins, or <code>-1</code> if\n+     * the subexpression does not exist.  The initial position is zero.\n+     *\n+     * @param sub Subexpression index\n+     * @deprecated Use getStartIndex(int) instead.\n+     */\n+    public int getSubStartIndex(int sub) {\n+\tif (sub >= start.length) return -1;\n+\tint x = start[sub];\n+\treturn (x == -1) ? x : offset + x;\n+    }\n+    \n+    /** \n+     * Returns the index within the input string used to generate this match\n+     * where subexpression number <i>sub</i> begins, or <code>-1</code> if\n+     * the subexpression does not exist.  The initial position is zero.\n+     *\n+     * @param sub Subexpression index\n+     * @since gnu.regexp 1.1.0\n+     */\n+    public int getStartIndex(int sub) {\n+\tif (sub >= start.length) return -1;\n+\tint x = start[sub];\n+\treturn (x == -1) ? x : offset + x;\n+    }\n+  \n+    /** \n+     * Returns the index within the input string used to generate this match\n+     * where subexpression number <i>sub</i> ends, or <code>-1</code> if\n+     * the subexpression does not exist.  The initial position is zero.\n+     *\n+     * @param sub Subexpression index\n+     * @deprecated Use getEndIndex(int) instead\n+     */\n+    public int getSubEndIndex(int sub) {\n+\tif (sub >= start.length) return -1;\n+\tint x = end[sub];\n+\treturn (x == -1) ? x : offset + x;\n+    }\n+    \n+    /** \n+     * Returns the index within the input string used to generate this match\n+     * where subexpression number <i>sub</i> ends, or <code>-1</code> if\n+     * the subexpression does not exist.  The initial position is zero.\n+     *\n+     * @param sub Subexpression index\n+     */\n+    public int getEndIndex(int sub) {\n+\tif (sub >= start.length) return -1;\n+\tint x = end[sub];\n+\treturn (x == -1) ? x : offset + x;\n+    }\n+    \n+    /**\n+     * Substitute the results of this match to create a new string.\n+     * This is patterned after PERL, so the tokens to watch out for are\n+     * <code>$0</code> through <code>$9</code>.  <code>$0</code> matches\n+     * the full substring matched; <code>$<i>n</i></code> matches\n+     * subexpression number <i>n</i>.\n+     *\n+     * @param input A string consisting of literals and <code>$<i>n</i></code> tokens.\n+     */\n+    public String substituteInto(String input) {\n+\t// a la Perl, $0 is whole thing, $1 - $9 are subexpressions\n+\tStringBuffer output = new StringBuffer();\n+\tint pos;\n+\tfor (pos = 0; pos < input.length()-1; pos++) {\n+\t    if ((input.charAt(pos) == '$') && (Character.isDigit(input.charAt(pos+1)))) {\n+\t\tint val = Character.digit(input.charAt(++pos),10);\n+\t\tif (val < start.length) {\n+\t\t    output.append(toString(val));\n+\t\t} \n+\t    } else output.append(input.charAt(pos));\n+\t}\n+\tif (pos < input.length()) output.append(input.charAt(pos));\n+\treturn output.toString();\n+    }\n+}"}, {"sha": "c8e208a94389e0b8584fc55ab9a44e77ca85ce26", "filename": "libjava/gnu/regexp/REMatchEnumeration.java", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREMatchEnumeration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREMatchEnumeration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FREMatchEnumeration.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,135 @@\n+/* gnu/regexp/REMatchEnumeration.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+import java.io.Serializable;\n+import java.util.Enumeration;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * An REMatchEnumeration enumerates regular expression matches over a\n+ * given input text.  You obtain a reference to an enumeration using\n+ * the <code>getMatchEnumeration()</code> methods on an instance of\n+ * RE. \n+ *\n+ * <P>\n+ *\n+ * REMatchEnumeration does lazy computation; that is, it will not\n+ * search for a match until it needs to.  If you'd rather just get all\n+ * the matches at once in a big array, use the\n+ * <code>getAllMatches()</code> methods on RE.  However, using an\n+ * enumeration can help speed performance when the entire text does\n+ * not need to be searched immediately.\n+ *\n+ * <P>\n+ * \n+ * The enumerated type is especially useful when searching on a Reader\n+ * or InputStream, because the InputStream read position cannot be\n+ * guaranteed after calling <code>getMatch()</code> (see the\n+ * description of that method for an explanation of why).  Enumeration\n+ * also saves a lot of overhead required when calling\n+ * <code>getMatch()</code> multiple times.\n+ * \n+ * @author <A HREF=\"mailto:wes@cacas.org\">Wes Biggs</A> \n+ */\n+public class REMatchEnumeration implements Enumeration, Serializable {\n+  private static final int YES = 1;\n+  private static final int MAYBE = 0;\n+  private static final int NO = -1;\n+  \n+  private int more;\n+  private REMatch match;\n+  private RE expr;\n+  private CharIndexed input;\n+  private int eflags;\n+    private int index;\n+\n+  // Package scope constructor is used by RE.getMatchEnumeration()\n+  REMatchEnumeration(RE expr, CharIndexed input, int index, int eflags) {\n+    more = MAYBE;\n+    this.expr = expr;\n+    this.input = input;\n+    this.index = index;\n+    this.eflags = eflags;\n+  }\n+\n+  /** Returns true if there are more matches in the input text. */\n+  public boolean hasMoreElements() {\n+    return hasMoreMatches(null);\n+  }\n+\n+  /** Returns true if there are more matches in the input text. */\n+  public boolean hasMoreMatches() {\n+    return hasMoreMatches(null);\n+  }\n+\n+  /** Returns true if there are more matches in the input text.\n+   * Saves the text leading up to the match (or to the end of the input)\n+   * in the specified buffer.\n+   */\n+  public boolean hasMoreMatches(StringBuffer buffer) {\n+    if (more == MAYBE) {\n+\tmatch = expr.getMatchImpl(input,index,eflags,buffer);\n+\tif (match != null) {\n+\t    input.move((match.end[0] > 0) ? match.end[0] : 1);\n+\t    \n+\t    index = (match.end[0] > 0) ? match.end[0] + match.offset : index + 1;\n+\t    more = YES;\n+\t} else more = NO;\n+    }\n+    return (more == YES);\n+  }\n+\n+  /** Returns the next match in the input text. */\n+  public Object nextElement() throws NoSuchElementException {\n+    return nextMatch();\n+  }\n+\n+  /** \n+   * Returns the next match in the input text. This method is provided\n+   * for convenience to avoid having to explicitly cast the return value\n+   * to class REMatch.\n+   */\n+  public REMatch nextMatch() throws NoSuchElementException {\n+    if (hasMoreElements()) {\n+\tmore = (input.isValid()) ? MAYBE : NO;\n+\treturn match;\n+    }\n+    throw new NoSuchElementException();\n+  }\n+}\n+"}, {"sha": "649bd0df584fa013f07015b5bf281d588f7a48a9", "filename": "libjava/gnu/regexp/RESyntax.java", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRESyntax.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRESyntax.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRESyntax.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,521 @@\n+/* gnu/regexp/RESyntax.java\n+   Copyright (C) 1998-2002, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+import java.io.Serializable;\n+import java.util.BitSet;\n+\n+/**\n+ * An RESyntax specifies the way a regular expression will be compiled.\n+ * This class provides a number of predefined useful constants for\n+ * emulating popular regular expression syntaxes.  Additionally the\n+ * user may construct his or her own syntax, using any combination of the\n+ * syntax bit constants.  The syntax is an optional argument to any of the\n+ * matching methods on class RE.\n+ *\n+ * @author <A HREF=\"mailto:wes@cacas.org\">Wes Biggs</A>\n+ */\n+\n+public final class RESyntax implements Serializable {\n+    static final String DEFAULT_LINE_SEPARATOR = System.getProperty(\"line.separator\");\n+\n+    private static final String SYNTAX_IS_FINAL = RE.getLocalizedMessage(\"syntax.final\");\n+\n+    private BitSet bits;\n+\n+    // true for the constant defined syntaxes\n+    private boolean isFinal = false;\n+\n+    private String lineSeparator = DEFAULT_LINE_SEPARATOR;\n+\n+  // Values for constants are bit indexes\n+\n+  /**\n+   * Syntax bit. Backslash is an escape character in lists.\n+   */\n+  public static final int RE_BACKSLASH_ESCAPE_IN_LISTS =  0;\n+\n+  /**\n+   * Syntax bit. Use \\? instead of ? and \\+ instead of +.\n+   */\n+  public static final int RE_BK_PLUS_QM                =  1;\n+\n+  /**\n+   * Syntax bit. POSIX character classes ([:...:]) in lists are allowed.\n+   */\n+  public static final int RE_CHAR_CLASSES              =  2;\n+\n+  /**\n+   * Syntax bit. ^ and $ are special everywhere.\n+   * <B>Not implemented.</B>\n+   */\n+  public static final int RE_CONTEXT_INDEP_ANCHORS     =  3; \n+\n+  /**\n+   * Syntax bit. Repetition operators are only special in valid positions.\n+   * <B>Not implemented.</B>\n+   */\n+  public static final int RE_CONTEXT_INDEP_OPS         =  4; \n+\n+  /**\n+   * Syntax bit. Repetition and alternation operators are invalid\n+   * at start and end of pattern and other places. \n+   * <B>Not implemented</B>.\n+   */\n+  public static final int RE_CONTEXT_INVALID_OPS       =  5; \n+\n+  /**\n+   * Syntax bit. Match-any-character operator (.) matches a newline.\n+   */\n+  public static final int RE_DOT_NEWLINE               =  6;\n+\n+  /**\n+   * Syntax bit. Match-any-character operator (.) does not match a null.\n+   */\n+  public static final int RE_DOT_NOT_NULL              =  7;\n+\n+  /**\n+   * Syntax bit. Intervals ({x}, {x,}, {x,y}) are allowed.\n+   */\n+  public static final int RE_INTERVALS                 =  8;\n+\n+  /**\n+   * Syntax bit. No alternation (|), match one-or-more (+), or \n+   * match zero-or-one (?) operators.\n+   */\n+  public static final int RE_LIMITED_OPS               =  9;\n+\n+  /**\n+   * Syntax bit. Newline is an alternation operator.\n+   */\n+  public static final int RE_NEWLINE_ALT               = 10; // impl.\n+\n+  /**\n+   * Syntax bit. Intervals use { } instead of \\{ \\}\n+   */\n+  public static final int RE_NO_BK_BRACES              = 11; \n+\n+  /**\n+   * Syntax bit. Grouping uses ( ) instead of \\( \\).\n+   */\n+  public static final int RE_NO_BK_PARENS              = 12;\n+\n+  /**\n+   * Syntax bit. Backreferences not allowed.\n+   */\n+  public static final int RE_NO_BK_REFS                = 13;\n+\n+  /**\n+   * Syntax bit. Alternation uses | instead of \\|\n+   */\n+  public static final int RE_NO_BK_VBAR                = 14;\n+\n+  /**\n+   * Syntax bit. <B>Not implemented</B>.\n+   */\n+  public static final int RE_NO_EMPTY_RANGES           = 15;\n+\n+  /**\n+   * Syntax bit. An unmatched right parenthesis (')' or '\\)', depending\n+   * on RE_NO_BK_PARENS) will throw an exception when compiling.\n+   */\n+  public static final int RE_UNMATCHED_RIGHT_PAREN_ORD = 16;\n+\n+  /**\n+   * Syntax bit. <B>Not implemented.</B>\n+   */\n+  public static final int RE_HAT_LISTS_NOT_NEWLINE     = 17;\n+\n+  /**\n+   * Syntax bit.  Stingy matching is allowed (+?, *?, ??, {x,y}?).\n+   */\n+  public static final int RE_STINGY_OPS                = 18;\n+\n+  /**\n+   * Syntax bit. Allow character class escapes (\\d, \\D, \\s, \\S, \\w, \\W).\n+   */\n+  public static final int RE_CHAR_CLASS_ESCAPES        = 19;\n+\n+  /**\n+   * Syntax bit. Allow use of (?:xxx) grouping (subexpression is not saved).\n+   */\n+  public static final int RE_PURE_GROUPING             = 20;\n+\n+  /**\n+   * Syntax bit. Allow use of (?=xxx) and (?!xxx) apply the subexpression\n+   * to the text following the current position without consuming that text.\n+   */\n+  public static final int RE_LOOKAHEAD                 = 21;\n+\n+  /**\n+   * Syntax bit. Allow beginning- and end-of-string anchors (\\A, \\Z).\n+   */\n+  public static final int RE_STRING_ANCHORS            = 22;\n+\n+  /**\n+   * Syntax bit. Allow embedded comments, (?#comment), as in Perl5.\n+   */\n+  public static final int RE_COMMENTS                  = 23;\n+\n+  /**\n+   * Syntax bit. Allow character class escapes within lists, as in Perl5.\n+   */\n+  public static final int RE_CHAR_CLASS_ESC_IN_LISTS   = 24;\n+\n+  private static final int BIT_TOTAL                   = 25;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in the awk utility.\n+   */\n+  public static final RESyntax RE_SYNTAX_AWK;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in the ed utility.\n+   */\n+  public static final RESyntax RE_SYNTAX_ED;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in the egrep utility.\n+   */\n+  public static final RESyntax RE_SYNTAX_EGREP;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in the GNU Emacs editor.\n+   */\n+  public static final RESyntax RE_SYNTAX_EMACS;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in the grep utility.\n+   */\n+  public static final RESyntax RE_SYNTAX_GREP;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in the POSIX awk specification.\n+   */\n+  public static final RESyntax RE_SYNTAX_POSIX_AWK;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates POSIX basic regular expression support.\n+   */\n+  public static final RESyntax RE_SYNTAX_POSIX_BASIC;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in the POSIX egrep specification.\n+   */\n+  public static final RESyntax RE_SYNTAX_POSIX_EGREP;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates POSIX extended regular expression support.\n+   */\n+  public static final RESyntax RE_SYNTAX_POSIX_EXTENDED;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates POSIX basic minimal regular expressions.\n+   */\n+  public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_BASIC;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates POSIX extended minimal regular expressions.\n+   */\n+  public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_EXTENDED;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in the sed utility.\n+   */\n+  public static final RESyntax RE_SYNTAX_SED;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in Larry Wall's perl, version 4,\n+   */\n+  public static final RESyntax RE_SYNTAX_PERL4;\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in Larry Wall's perl, version 4,\n+   * using single line mode (/s modifier).\n+   */\n+  public static final RESyntax RE_SYNTAX_PERL4_S; // single line mode (/s)\n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in Larry Wall's perl, version 5.\n+   */\n+  public static final RESyntax RE_SYNTAX_PERL5;  \n+\n+  /**\n+   * Predefined syntax.\n+   * Emulates regular expression support in Larry Wall's perl, version 5,\n+   * using single line mode (/s modifier).\n+   */\n+  public static final RESyntax RE_SYNTAX_PERL5_S;\n+\n+    /**\n+     * Predefined syntax.\n+     * Emulates regular expression support in Java 1.4's java.util.regex\n+     * package.\n+     */\n+    public static final RESyntax RE_SYNTAX_JAVA_1_4;\n+\n+  static {\n+      // Define syntaxes\n+      \n+      RE_SYNTAX_EMACS = new RESyntax().makeFinal();\n+      \n+      RESyntax RE_SYNTAX_POSIX_COMMON = new RESyntax()\n+\t  .set(RE_CHAR_CLASSES)\n+\t  .set(RE_DOT_NEWLINE)\n+\t  .set(RE_DOT_NOT_NULL)\n+\t  .set(RE_INTERVALS)\n+\t  .set(RE_NO_EMPTY_RANGES)\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_POSIX_BASIC = new RESyntax(RE_SYNTAX_POSIX_COMMON)\n+\t  .set(RE_BK_PLUS_QM)\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_POSIX_EXTENDED = new RESyntax(RE_SYNTAX_POSIX_COMMON)\n+\t  .set(RE_CONTEXT_INDEP_ANCHORS)\n+\t  .set(RE_CONTEXT_INDEP_OPS)\n+\t  .set(RE_NO_BK_BRACES)\n+\t  .set(RE_NO_BK_PARENS)\n+\t  .set(RE_NO_BK_VBAR)\n+\t  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)\n+\t  .makeFinal();\n+\n+      RE_SYNTAX_AWK = new RESyntax()\n+\t  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)\n+\t  .set(RE_DOT_NOT_NULL)\n+\t  .set(RE_NO_BK_PARENS)\n+\t  .set(RE_NO_BK_REFS)\n+\t  .set(RE_NO_BK_VBAR)\n+\t  .set(RE_NO_EMPTY_RANGES)\n+\t  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_POSIX_AWK = new RESyntax(RE_SYNTAX_POSIX_EXTENDED)\n+\t  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_GREP = new RESyntax()\n+\t  .set(RE_BK_PLUS_QM)\n+\t  .set(RE_CHAR_CLASSES)\n+\t  .set(RE_HAT_LISTS_NOT_NEWLINE)\n+\t  .set(RE_INTERVALS)\n+\t  .set(RE_NEWLINE_ALT)\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_EGREP = new RESyntax()\n+\t  .set(RE_CHAR_CLASSES)\n+\t  .set(RE_CONTEXT_INDEP_ANCHORS)\n+\t  .set(RE_CONTEXT_INDEP_OPS)\n+\t  .set(RE_HAT_LISTS_NOT_NEWLINE)\n+\t  .set(RE_NEWLINE_ALT)\n+\t  .set(RE_NO_BK_PARENS)\n+\t  .set(RE_NO_BK_VBAR)\n+\t  .makeFinal();\n+    \n+      RE_SYNTAX_POSIX_EGREP = new RESyntax(RE_SYNTAX_EGREP)\n+\t  .set(RE_INTERVALS)\n+\t  .set(RE_NO_BK_BRACES)\n+\t  .makeFinal();\n+    \n+      /* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */\n+    \n+      RE_SYNTAX_ED = new RESyntax(RE_SYNTAX_POSIX_BASIC)\n+\t  .makeFinal();\n+    \n+      RE_SYNTAX_SED = new RESyntax(RE_SYNTAX_POSIX_BASIC)\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_POSIX_MINIMAL_BASIC = new RESyntax(RE_SYNTAX_POSIX_COMMON)\n+\t  .set(RE_LIMITED_OPS)\n+\t  .makeFinal();\n+      \n+      /* Differs from RE_SYNTAX_POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS\n+\t replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added. */\n+      \n+      RE_SYNTAX_POSIX_MINIMAL_EXTENDED = new RESyntax(RE_SYNTAX_POSIX_COMMON)\n+\t  .set(RE_CONTEXT_INDEP_ANCHORS)\n+\t  .set(RE_CONTEXT_INVALID_OPS)\n+\t  .set(RE_NO_BK_BRACES)\n+\t  .set(RE_NO_BK_PARENS)\n+\t  .set(RE_NO_BK_REFS)\n+\t  .set(RE_NO_BK_VBAR)\n+\t  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)\n+\t  .makeFinal();\n+      \n+      /* There is no official Perl spec, but here's a \"best guess\" */\n+      \n+      RE_SYNTAX_PERL4 = new RESyntax()\n+\t  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)\n+\t  .set(RE_CONTEXT_INDEP_ANCHORS)\n+\t  .set(RE_CONTEXT_INDEP_OPS)          // except for '{', apparently\n+\t  .set(RE_INTERVALS)\n+\t  .set(RE_NO_BK_BRACES)\n+\t  .set(RE_NO_BK_PARENS)\n+\t  .set(RE_NO_BK_VBAR)\n+\t  .set(RE_NO_EMPTY_RANGES)\n+\t  .set(RE_CHAR_CLASS_ESCAPES)    // \\d,\\D,\\w,\\W,\\s,\\S\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_PERL4_S = new RESyntax(RE_SYNTAX_PERL4)\n+\t  .set(RE_DOT_NEWLINE)\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_PERL5 = new RESyntax(RE_SYNTAX_PERL4)\n+\t  .set(RE_PURE_GROUPING)          // (?:)\n+\t  .set(RE_STINGY_OPS)             // *?,??,+?,{}?\n+\t  .set(RE_LOOKAHEAD)              // (?=)(?!)\n+\t  .set(RE_STRING_ANCHORS)         // \\A,\\Z\n+\t  .set(RE_CHAR_CLASS_ESC_IN_LISTS)// \\d,\\D,\\w,\\W,\\s,\\S within []\n+\t  .set(RE_COMMENTS)              // (?#)\n+\t  .makeFinal();\n+      \n+      RE_SYNTAX_PERL5_S = new RESyntax(RE_SYNTAX_PERL5)\n+\t  .set(RE_DOT_NEWLINE)\n+\t  .makeFinal();\n+\n+      RE_SYNTAX_JAVA_1_4 = new RESyntax(RE_SYNTAX_PERL5)\n+\t  // XXX\n+\t  .makeFinal();\n+  }\n+\n+  /**\n+   * Construct a new syntax object with all bits turned off.\n+   * This is equivalent to RE_SYNTAX_EMACS.\n+   */\n+  public RESyntax() {\n+    bits = new BitSet(BIT_TOTAL);\n+  }\n+\n+    /**\n+     * Called internally when constructing predefined syntaxes\n+     * so their interpretation cannot vary.  Conceivably useful\n+     * for your syntaxes as well.  Causes IllegalAccessError to\n+     * be thrown if any attempt to modify the syntax is made.\n+     *\n+     * @return this object for convenient chaining\n+     */\n+    public RESyntax makeFinal() {\n+\tisFinal = true;\n+\treturn this;\n+    }\n+\n+  /**\n+   * Construct a new syntax object with all bits set the same \n+   * as the other syntax.\n+   */\n+  public RESyntax(RESyntax other) {\n+    bits = (BitSet) other.bits.clone();\n+  }\n+\n+  /**\n+   * Check if a given bit is set in this syntax.\n+   */\n+  public boolean get(int index) {\n+    return bits.get(index);\n+  }\n+\n+  /**\n+   * Set a given bit in this syntax. \n+   *\n+   * @param index the constant (RESyntax.RE_xxx) bit to set.\n+   * @return a reference to this object for easy chaining.\n+   */\n+  public RESyntax set(int index) {\n+      if (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);\n+    bits.set(index);\n+    return this;\n+  }\n+\n+  /**\n+   * Clear a given bit in this syntax. \n+   *\n+   * @param index the constant (RESyntax.RE_xxx) bit to clear.\n+   * @return a reference to this object for easy chaining.\n+   */\n+  public RESyntax clear(int index) {\n+      if (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);\n+      bits.clear(index);\n+      return this;\n+  }\n+\n+    /**\n+     * Changes the line separator string for regular expressions\n+     * created using this RESyntax.  The default separator is the\n+     * value returned by the system property \"line.separator\", which\n+     * should be correct when reading platform-specific files from a\n+     * filesystem.  However, many programs may collect input from\n+     * sources where the line separator is differently specified (for\n+     * example, in the applet environment, the text box widget\n+     * interprets line breaks as single-character newlines,\n+     * regardless of the host platform.\n+     *\n+     * Note that setting the line separator to a character or\n+     * characters that have specific meaning within the current syntax\n+     * can cause unexpected chronosynclastic infundibula.\n+     *\n+     * @return this object for convenient chaining \n+     */\n+    public RESyntax setLineSeparator(String aSeparator) {\n+\tif (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);\n+\tlineSeparator = aSeparator;\n+\treturn this;\n+    }\n+\n+    /**\n+     * Returns the currently active line separator string.  The default\n+     * is the platform-dependent system property \"line.separator\".\n+     */\n+    public String getLineSeparator() {\n+\treturn lineSeparator;\n+    }\n+}"}, {"sha": "aa576a5adde8de43627ab4a1ffa84b7e724426cf", "filename": "libjava/gnu/regexp/REToken.java", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREToken.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FREToken.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FREToken.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,86 @@\n+/* gnu/regexp/REToken.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+import java.io.Serializable;\n+\n+abstract class REToken implements Serializable {\n+\n+  protected REToken next = null;\n+  protected REToken uncle = null;\n+  protected int subIndex;\n+\n+  protected REToken(int subIndex) {\n+      this.subIndex = subIndex;\n+  }\n+\n+  int getMinimumLength() {\n+    return 0;\n+  }\n+\n+  void setUncle(REToken anUncle) {\n+    uncle = anUncle;\n+  }\n+\n+    /** Returns true if the match succeeded, false if it failed. */\n+    abstract boolean match(CharIndexed input, REMatch mymatch);\n+  \n+    /** Returns true if the rest of the tokens match, false if they fail. */\n+    protected boolean next(CharIndexed input, REMatch mymatch) {\n+\tif (next == null) {\n+\t    if (uncle == null) {\n+\t\treturn true;\n+\t    } else {\n+\t\treturn uncle.match(input, mymatch);\n+\t    }\n+\t} else {\n+\t    return next.match(input, mymatch);\n+\t}\n+    }\n+  \n+  boolean chain(REToken token) {\n+      next = token;\n+      return true; // Token was accepted\n+  }\n+\n+    abstract void dump(StringBuffer os);\n+\n+  void dumpAll(StringBuffer os) {\n+    dump(os);\n+    if (next != null) next.dumpAll(os);\n+  }\n+}"}, {"sha": "42fdd9e284cf260dc9111e49d619723b1c1fb48c", "filename": "libjava/gnu/regexp/RETokenAny.java", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenAny.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenAny.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenAny.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,73 @@\n+/* gnu/regexp/RETokenAny.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+\n+final class RETokenAny extends REToken {\n+  /** True if '.' can match a newline (RE_DOT_NEWLINE) */\n+  private boolean newline; \n+\n+  /** True if '.' can't match a null (RE_DOT_NOT_NULL) */\n+  private boolean matchNull;    \n+  \n+  RETokenAny(int subIndex, boolean newline, boolean matchNull) { \n+    super(subIndex);\n+    this.newline = newline;\n+    this.matchNull = matchNull;\n+  }\n+\n+  int getMinimumLength() {\n+    return 1;\n+  }\n+\n+    boolean match(CharIndexed input, REMatch mymatch) {\n+    char ch = input.charAt(mymatch.index);\n+    if ((ch == CharIndexed.OUT_OF_BOUNDS)\n+\t|| (!newline && (ch == '\\n'))\n+\t|| (matchNull && (ch == 0))) {\n+\treturn false;\n+    }\n+    ++mymatch.index;\n+    return next(input, mymatch);\n+  }\n+\n+  void dump(StringBuffer os) {\n+    os.append('.');\n+  }\n+}\n+"}, {"sha": "a811e16a7b37f91afe7118ae833064dd75d3de5d", "filename": "libjava/gnu/regexp/RETokenBackRef.java", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenBackRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenBackRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenBackRef.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,72 @@\n+/* gnu/regexp/RETokenBackRef.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+\n+final class RETokenBackRef extends REToken {\n+  private int num;\n+  private boolean insens;\n+  \n+  RETokenBackRef(int subIndex, int num, boolean insens) {\n+    super(subIndex);\n+    this.num = num;\n+    this.insens = insens;\n+  }\n+\n+  // should implement getMinimumLength() -- any ideas?\n+\n+    boolean match(CharIndexed input, REMatch mymatch) {\n+\tint b,e;\n+\tb = mymatch.start[num];\n+\te = mymatch.end[num];\n+\tif ((b==-1)||(e==-1)) return false; // this shouldn't happen, but...\n+\tfor (int i=b; i<e; i++) {\n+\t    if (input.charAt(mymatch.index+i-b) != input.charAt(i)) {\n+\t\treturn false;\n+\t    }\n+\t}\n+\tmymatch.index += e-b;\n+\treturn next(input, mymatch);\n+    }\n+    \n+    void dump(StringBuffer os) {\n+\tos.append('\\\\').append(num);\n+    }\n+}\n+\n+"}, {"sha": "17712e3478764059f2d752d1baa12fbc669f416f", "filename": "libjava/gnu/regexp/RETokenChar.java", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenChar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenChar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenChar.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,91 @@\n+/* gnu/regexp/RETokenChar.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+\n+final class RETokenChar extends REToken {\n+  private char[] ch;\n+  private boolean insens;\n+\n+  RETokenChar(int subIndex, char c, boolean ins) {\n+    super(subIndex);\n+    ch = new char [1];\n+    ch[0] = (insens = ins) ? Character.toLowerCase(c) : c;\n+  }\n+\n+  int getMinimumLength() {\n+    return ch.length;\n+  }\n+  \n+    boolean match(CharIndexed input, REMatch mymatch) {\n+\tint z = ch.length;\n+\tchar c;\n+\tfor (int i=0; i<z; i++) {\n+\t    c = input.charAt(mymatch.index+i);\n+\t    if (( (insens) ? Character.toLowerCase(c) : c ) != ch[i]) {\n+\t\treturn false;\n+\t    }\n+\t}\n+\tmymatch.index += z;\n+\n+\treturn next(input, mymatch);\n+    }\n+\n+  // Overrides REToken.chain() to optimize for strings\n+  boolean chain(REToken next) {\n+    if (next instanceof RETokenChar) {\n+      RETokenChar cnext = (RETokenChar) next;\n+      // assume for now that next can only be one character\n+      int newsize = ch.length + cnext.ch.length;\n+      \n+      char[] chTemp = new char [newsize];\n+      \n+      System.arraycopy(ch,0,chTemp,0,ch.length);\n+      System.arraycopy(cnext.ch,0,chTemp,ch.length,cnext.ch.length);\n+      \n+      ch = chTemp;\n+      return false;\n+    } else return super.chain(next);\n+  }\n+\n+  void dump(StringBuffer os) {\n+    os.append(ch);\n+  }\n+}\n+\n+"}, {"sha": "08e57084da1b217dc7cfad721f79e7bd951544c9", "filename": "libjava/gnu/regexp/RETokenEnd.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenEnd.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenEnd.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenEnd.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,75 @@\n+/* gnu/regexp/RETokenEnd.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+\n+final class RETokenEnd extends REToken {\n+    /**\n+     * Indicates whether this token should match on a line break.\n+     */\n+  private String newline;\n+\n+  RETokenEnd(int subIndex,String newline) { \n+    super(subIndex);\n+    this.newline = newline;\n+  }\n+\n+    boolean match(CharIndexed input, REMatch mymatch) {\n+\tchar ch = input.charAt(mymatch.index);\n+\tif (ch == CharIndexed.OUT_OF_BOUNDS)\n+\t    return ((mymatch.eflags & RE.REG_NOTEOL)>0) ? \n+\t\tfalse : next(input, mymatch);\n+\tif (newline != null) {\n+\t    char z;\n+\t    int i = 0; // position in newline\n+\t    do {\n+\t\tz = newline.charAt(i);\n+\t\tif (ch != z) return false;\n+\t\t++i;\n+\t\tch = input.charAt(mymatch.index + i);\n+\t    } while (i < newline.length());\n+\t    \n+\t    return next(input, mymatch);\n+\t}\n+\treturn false;\n+    }\n+\n+  void dump(StringBuffer os) {\n+    os.append('$');\n+  }\n+}"}, {"sha": "913d3f85c051d2ba8fb62f5555cb1de8323c28e8", "filename": "libjava/gnu/regexp/RETokenEndSub.java", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenEndSub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenEndSub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenEndSub.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,53 @@\n+/* gnu/regexp/RETokenEndSub.java\n+   Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+\n+final class RETokenEndSub extends REToken {\n+    RETokenEndSub(int subIndex) {\n+\tsuper(subIndex);\n+    }\n+    \n+    boolean match(CharIndexed input, REMatch mymatch) {\n+\tmymatch.end[subIndex] = mymatch.index;\n+\treturn next(input, mymatch);\n+    }\n+    \n+    void dump(StringBuffer os) {\n+\t// handled by RE\n+    }\n+}"}, {"sha": "74a9bfe2465452951c27a6c1d4d98279edff15ba", "filename": "libjava/gnu/regexp/RETokenLookAhead.java", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenLookAhead.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenLookAhead.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenLookAhead.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,68 @@\n+/*\n+ *  gnu/regexp/RETokenOneOf.java\n+ *  Copyright (C) 1998-2001 Wes Biggs\n+ *\n+ *  This library is free software; you can redistribute it and/or modify\n+ *  it under the terms of the GNU Lesser General Public License as published\n+ *  by the Free Software Foundation; either version 2.1 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  This library is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU Lesser General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU Lesser General Public License\n+ *  along with this program; if not, write to the Free Software\n+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n+ */\n+package gnu.regexp;\n+\n+/**\n+ * @since gnu.regexp 1.1.3\n+ * @author Shashank Bapat\n+ */\n+final class RETokenLookAhead extends REToken\n+{\n+  REToken re;\n+  boolean negative;\n+\n+  RETokenLookAhead(REToken re, boolean negative) throws REException {\n+    super(0);\n+    this.re = re;\n+    this.negative = negative;\n+  }\n+\n+  boolean match(CharIndexed input, REMatch mymatch)\n+  {\n+    REMatch trymatch = (REMatch)mymatch.clone();\n+    REMatch trymatch1 = (REMatch)mymatch.clone();\n+    REMatch newMatch = null;\n+    if (re.match(input, trymatch)) {\n+      if (negative) return false;\n+      if (next(input, trymatch1))\n+        newMatch = trymatch1;\n+    }\n+\n+    if (newMatch != null) {\n+      if (negative) return false;\n+      //else\n+      mymatch.assignFrom(newMatch);\n+      return true;\n+    }\n+    else { // no match\n+      if (negative)\n+        return next(input, mymatch);\n+      //else\n+      return false;\n+    }\n+  }\n+\n+    void dump(StringBuffer os) {\n+\tos.append(\"(?\");\n+\tos.append(negative ? '!' : '=');\n+\tre.dumpAll(os);\n+\tos.append(')');\n+    }\n+}\n+"}, {"sha": "7752b25771c6e39c89560dee38f3ac1f1795f745", "filename": "libjava/gnu/regexp/RETokenOneOf.java", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenOneOf.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenOneOf.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenOneOf.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,130 @@\n+/* gnu/regexp/RETokenOneOf.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+import java.util.Vector;\n+\n+final class RETokenOneOf extends REToken {\n+  private Vector options;\n+  private boolean negative;\n+\n+  // This constructor is used for convenience when we know the set beforehand,\n+  // e.g. \\d --> new RETokenOneOf(\"0123456789\",false, ..)\n+  //      \\D --> new RETokenOneOf(\"0123456789\",true, ..)\n+\n+  RETokenOneOf(int subIndex, String optionsStr, boolean negative, boolean insens) {\n+    super(subIndex);\n+    options = new Vector();\n+    this.negative = negative;\n+    for (int i = 0; i < optionsStr.length(); i++)\n+      options.addElement(new RETokenChar(subIndex,optionsStr.charAt(i),insens));\n+  }\n+\n+  RETokenOneOf(int subIndex, Vector options, boolean negative) {\n+    super(subIndex);\n+    this.options = options;\n+    this.negative = negative;\n+  }\n+\n+  int getMinimumLength() {\n+    int min = Integer.MAX_VALUE;\n+    int x;\n+    for (int i=0; i < options.size(); i++) {\n+      if ((x = ((REToken) options.elementAt(i)).getMinimumLength()) < min)\n+\tmin = x;\n+    }\n+    return min;\n+  }\n+\n+    boolean match(CharIndexed input, REMatch mymatch) {\n+    if (negative && (input.charAt(mymatch.index) == CharIndexed.OUT_OF_BOUNDS)) \n+      return false;\n+\n+    REMatch newMatch = null;\n+    REMatch last = null;\n+    REToken tk;\n+    boolean isMatch;\n+    for (int i=0; i < options.size(); i++) {\n+\ttk = (REToken) options.elementAt(i);\n+\tREMatch tryMatch = (REMatch) mymatch.clone();\n+\tif (tk.match(input, tryMatch)) { // match was successful\n+\t    if (negative) return false;\n+\n+\t    if (next(input, tryMatch)) {\n+\t\t// Add tryMatch to list of possibilities.\n+\t\tif (last == null) {\n+\t\t    newMatch = tryMatch;\n+\t\t    last = tryMatch;\n+\t\t} else {\n+\t\t    last.next = tryMatch;\n+\t\t    last = tryMatch;\n+\t\t}\n+\t    } // next succeeds\n+\t} // is a match\n+    } // try next option\n+\n+    if (newMatch != null) {\n+\tif (negative) {\n+\t    return false;\n+\t} else {\n+\t    // set contents of mymatch equal to newMatch\n+\n+\t    // try each one that matched\n+\t    mymatch.assignFrom(newMatch);\n+\t    return true;\n+\t}\n+    } else {\n+\tif (negative) {\n+\t    ++mymatch.index;\n+\t    return next(input, mymatch);\n+\t} else {\n+\t    return false;\n+\t}\n+    }\n+\n+    // index+1 works for [^abc] lists, not for generic lookahead (--> index)\n+  }\n+\n+  void dump(StringBuffer os) {\n+    os.append(negative ? \"[^\" : \"(?:\");\n+    for (int i = 0; i < options.size(); i++) {\n+      if (!negative && (i > 0)) os.append('|');\n+      ((REToken) options.elementAt(i)).dumpAll(os);\n+    }\n+    os.append(negative ? ']' : ')');\n+  }  \n+}"}, {"sha": "00fcf301ad9f85c52ad4ee57c5737617d7659cba", "filename": "libjava/gnu/regexp/RETokenPOSIX.java", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenPOSIX.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenPOSIX.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenPOSIX.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,144 @@\n+/* gnu/regexp/RETokenPOSIX.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+\n+final class RETokenPOSIX extends REToken {\n+  int type;\n+  boolean insens;\n+  boolean negated;\n+\n+  static final int  ALNUM = 0;\n+  static final int  ALPHA = 1;\n+  static final int  BLANK = 2;\n+  static final int  CNTRL = 3;\n+  static final int  DIGIT = 4;\n+  static final int  GRAPH = 5;\n+  static final int  LOWER = 6;\n+  static final int  PRINT = 7;\n+  static final int  PUNCT = 8;\n+  static final int  SPACE = 9;\n+  static final int  UPPER = 10;\n+  static final int XDIGIT = 11;\n+\n+  // Array indices correspond to constants defined above.\n+  static final String[] s_nameTable =  {\n+    \"alnum\", \"alpha\", \"blank\", \"cntrl\", \"digit\", \"graph\", \"lower\",\n+    \"print\", \"punct\", \"space\", \"upper\", \"xdigit\" \n+  };\n+\n+  // The RE constructor uses this to look up the constant for a string\n+  static int intValue(String key) {\n+    for (int i = 0; i < s_nameTable.length; i++) {\n+      if (s_nameTable[i].equals(key)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  RETokenPOSIX(int subIndex, int type, boolean insens, boolean negated) {\n+    super(subIndex);\n+    this.type = type;\n+    this.insens = insens;\n+    this.negated = negated;\n+  }\n+\n+    int getMinimumLength() {\n+\treturn 1;\n+    }\n+\n+    boolean match(CharIndexed input, REMatch mymatch) {\n+    char ch = input.charAt(mymatch.index);\n+    if (ch == CharIndexed.OUT_OF_BOUNDS)\n+      return false;\n+    \n+    boolean retval = false;\n+    switch (type) {\n+    case ALNUM:\n+\t// Note that there is some debate over whether '_' should be included\n+\tretval = Character.isLetterOrDigit(ch) || (ch == '_');\n+\tbreak;\n+    case ALPHA:\n+\tretval = Character.isLetter(ch);\n+\tbreak;\n+    case BLANK:\n+\tretval = ((ch == ' ') || (ch == '\\t'));\n+\tbreak;\n+    case CNTRL:\n+\tretval = Character.isISOControl(ch);\n+\tbreak;\n+    case DIGIT:\n+\tretval = Character.isDigit(ch);\n+\tbreak;\n+    case GRAPH:\n+\tretval = (!(Character.isWhitespace(ch) || Character.isISOControl(ch)));\n+\tbreak;\n+    case LOWER:\n+\tretval = ((insens && Character.isLetter(ch)) || Character.isLowerCase(ch));\n+\tbreak;\n+    case PRINT:\n+\tretval = (!(Character.isWhitespace(ch) || Character.isISOControl(ch)))\n+\t    || (ch == ' ');\n+\tbreak;\n+    case PUNCT:\n+\t// This feels sloppy, especially for non-U.S. locales.\n+\tretval = (\"`~!@#$%^&*()-_=+[]{}\\\\|;:'\\\"/?,.<>\".indexOf(ch)!=-1);\n+\tbreak;\n+    case SPACE:\n+\tretval = Character.isWhitespace(ch);\n+\tbreak;\n+    case UPPER:\n+\tretval = ((insens && Character.isLetter(ch)) || Character.isUpperCase(ch));\n+\tbreak;\n+    case XDIGIT:\n+\tretval = (Character.isDigit(ch) || (\"abcdefABCDEF\".indexOf(ch)!=-1));\n+\tbreak;\n+    }\n+\n+    if (negated) retval = !retval;\n+    if (retval) {\n+\t++mymatch.index;\n+\treturn next(input, mymatch);\n+    }\n+    else return false;\n+  }\n+\n+  void dump(StringBuffer os) {\n+    if (negated) os.append('^');\n+    os.append(\"[:\" + s_nameTable[type] + \":]\");\n+  }\n+}"}, {"sha": "9ce3be926b9971384f076570d2569a37a031917f", "filename": "libjava/gnu/regexp/RETokenRange.java", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenRange.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenRange.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenRange.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,69 @@\n+/* gnu/regexp/RETokenRange.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+\n+final class RETokenRange extends REToken {\n+  private char lo, hi;\n+  private boolean insens;\n+\n+  RETokenRange(int subIndex, char lo, char hi, boolean ins) {\n+    super(subIndex);\n+    this.lo = (insens = ins) ? Character.toLowerCase(lo) : lo;\n+    this.hi = ins ? Character.toLowerCase(hi) : hi;\n+  }\n+\n+  int getMinimumLength() {\n+    return 1;\n+  }\n+\n+    boolean match(CharIndexed input, REMatch mymatch) {\n+\tchar c = input.charAt(mymatch.index);\n+\tif (c == CharIndexed.OUT_OF_BOUNDS) return false;\n+\tif (insens) c = Character.toLowerCase(c);\n+\tif ((c >= lo) && (c <= hi)) {\n+\t    ++mymatch.index;\n+\t    return next(input, mymatch);\n+\t}\n+\treturn false;\n+    }\n+    \n+  void dump(StringBuffer os) {\n+    os.append(lo).append('-').append(hi);\n+  }\n+}\n+"}, {"sha": "8c7892712205938674941ad1a354d26272e23c3d", "filename": "libjava/gnu/regexp/RETokenRepeated.java", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenRepeated.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenRepeated.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenRepeated.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,227 @@\n+/* gnu/regexp/RETokenRepeated.java\n+   Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+\n+import java.util.Vector;\n+\n+final class RETokenRepeated extends REToken {\n+    private REToken token;\n+    private int min,max;\n+    private boolean stingy;\n+    \n+    RETokenRepeated(int subIndex, REToken token, int min, int max) {\n+\tsuper(subIndex);\n+\tthis.token = token;\n+\tthis.min = min;\n+\tthis.max = max;\n+    }\n+\n+    /** Sets the minimal matching mode to true. */\n+    void makeStingy() {\n+\tstingy = true;\n+    }\n+    \n+    /** Queries if this token has minimal matching enabled. */\n+    boolean isStingy() {\n+\treturn stingy;\n+    }\n+    \n+    /**\n+     * The minimum length of a repeated token is the minimum length\n+     * of the token multiplied by the minimum number of times it must\n+     * match.\n+     */\n+    int getMinimumLength() {\n+\treturn (min * token.getMinimumLength());\n+    }\n+\n+    // We do need to save every possible point, but the number of clone()\n+    // invocations here is really a killer for performance on non-stingy\n+    // repeat operators.  I'm open to suggestions...\n+\n+    // Hypothetical question: can you have a RE that matches 1 times,\n+    // 3 times, 5 times, but not 2 times or 4 times?  Does having\n+    // the subexpression back-reference operator allow that?\n+\n+    boolean match(CharIndexed input, REMatch mymatch) {\n+\t// number of times we've matched so far\n+\tint numRepeats = 0; \n+\t\n+\t// Possible positions for the next repeat to match at\n+\tREMatch newMatch = mymatch;\n+\tREMatch last = null;\n+\tREMatch current;\n+\n+\t// Add the '0-repeats' index\n+\t// positions.elementAt(z) == position [] in input after <<z>> matches\n+\tVector positions = new Vector();\n+\tpositions.addElement(newMatch);\n+\t\n+\t// Declare variables used in loop\n+\tREMatch doables;\n+\tREMatch doablesLast;\n+\tREMatch recurrent;\n+\n+\tdo {\n+\t    // Check for stingy match for each possibility.\n+\t    if (stingy && (numRepeats >= min)) {\n+\t\tREMatch result = matchRest(input, newMatch);\n+\t\tif (result != null) {\n+\t\t    mymatch.assignFrom(result);\n+\t\t    return true;\n+\t\t}\n+\t    }\n+\n+\t    doables = null;\n+\t    doablesLast = null;\n+\n+\t    // try next repeat at all possible positions\n+\t    for (current = newMatch; current != null; current = current.next) {\n+\t\trecurrent = (REMatch) current.clone();\n+\t\tif (token.match(input, recurrent)) {\n+\t\t    // add all items in current to doables array\n+\t\t    if (doables == null) {\n+\t\t\tdoables = recurrent;\n+\t\t\tdoablesLast = recurrent;\n+\t\t    } else {\n+\t\t\t// Order these from longest to shortest\n+\t\t\t// Start by assuming longest (more repeats)\n+\t\t\tdoablesLast.next = recurrent;\n+\t\t    }\n+\t\t    // Find new doablesLast\n+\t\t    while (doablesLast.next != null) {\n+\t\t\tdoablesLast = doablesLast.next;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    // if none of the possibilities worked out, break out of do/while\n+\t    if (doables == null) break;\n+\t    \n+\t    // reassign where the next repeat can match\n+\t    newMatch = doables;\n+\t    \n+\t    // increment how many repeats we've successfully found\n+\t    ++numRepeats;\n+\t    \n+\t    positions.addElement(newMatch);\n+\t} while (numRepeats < max);\n+\t\n+\t// If there aren't enough repeats, then fail\n+\tif (numRepeats < min) return false;\n+\t\n+\t// We're greedy, but ease off until a true match is found \n+\tint posIndex = positions.size();\n+\t\n+\t// At this point we've either got too many or just the right amount.\n+\t// See if this numRepeats works with the rest of the regexp.\n+\tREMatch allResults = null;\n+\tREMatch allResultsLast = null;\n+\n+\tREMatch results = null;\n+\twhile (--posIndex >= min) {\n+\t    newMatch = (REMatch) positions.elementAt(posIndex);\n+\t    results = matchRest(input, newMatch);\n+\t    if (results != null) {\n+\t\tif (allResults == null) {\n+\t\t    allResults = results;\n+\t\t    allResultsLast = results;\n+\t\t} else {\n+\t\t    // Order these from longest to shortest\n+\t\t    // Start by assuming longest (more repeats)\n+\t\t    allResultsLast.next = results;\n+\t\t}\n+\t\t// Find new doablesLast\n+\t\twhile (allResultsLast.next != null) {\n+\t\t    allResultsLast = allResultsLast.next;\n+\t\t}\n+\t    }\n+\t    // else did not match rest of the tokens, try again on smaller sample\n+\t}\n+\tif (allResults != null) {\n+\t    mymatch.assignFrom(allResults); // does this get all?\n+\t    return true;\n+\t}\n+\t// If we fall out, no matches.\n+\treturn false;\n+    }\n+\n+    private REMatch matchRest(CharIndexed input, final REMatch newMatch) {\n+\tREMatch current, single;\n+\tREMatch doneIndex = null;\n+\tREMatch doneIndexLast = null;\n+\t// Test all possible matches for this number of repeats\n+\tfor (current = newMatch; current != null; current = current.next) {\n+\t    // clone() separates a single match from the chain\n+\t    single = (REMatch) current.clone();\n+\t    if (next(input, single)) {\n+\t\t// chain results to doneIndex\n+\t\tif (doneIndex == null) {\n+\t\t    doneIndex = single;\n+\t\t    doneIndexLast = single;\n+\t\t} else {\n+\t\t    doneIndexLast.next = single;\n+\t\t}\n+\t\t// Find new doneIndexLast\n+\t\twhile (doneIndexLast.next != null) {\n+\t\t    doneIndexLast = doneIndexLast.next;\n+\t\t}\n+\t    }\n+\t}\n+\treturn doneIndex;\n+    }\n+\n+    void dump(StringBuffer os) {\n+\tos.append(\"(?:\");\n+\ttoken.dumpAll(os);\n+\tos.append(')');\n+\tif ((max == Integer.MAX_VALUE) && (min <= 1))\n+\t    os.append( (min == 0) ? '*' : '+' );\n+\telse if ((min == 0) && (max == 1))\n+\t    os.append('?');\n+\telse {\n+\t    os.append('{').append(min);\n+\t    if (max > min) {\n+\t\tos.append(',');\n+\t\tif (max != Integer.MAX_VALUE) os.append(max);\n+\t    }\n+\t    os.append('}');\n+\t}\n+\tif (stingy) os.append('?');\n+    }\n+}"}, {"sha": "8adb8c89ce29f60020ffd6128ca34509e3b4d674", "filename": "libjava/gnu/regexp/RETokenStart.java", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenStart.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenStart.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenStart.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,87 @@\n+/*  gnu/regexp/RETokenStart.java\n+    Copyright (C) 1998-2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+\n+class RETokenStart extends REToken {\n+    private String newline; // matches after a newline\n+    \n+    RETokenStart(int subIndex, String newline) {\n+\tsuper(subIndex);\n+\tthis.newline = newline;\n+    }\n+    \n+    boolean match(CharIndexed input, REMatch mymatch) {\n+\t// charAt(index-n) may be unknown on a Reader/InputStream. FIXME\n+\t// Match after a newline if in multiline mode\n+\t\n+\tif (newline != null) {\n+\t    int len = newline.length();\n+\t    if (mymatch.offset >= len) {\n+\t\tboolean found = true;\n+\t\tchar z;\n+\t\tint i = 0; // position in REToken.newline\n+\t\tchar ch = input.charAt(mymatch.index - len);\n+\t\tdo {\n+\t\t    z = newline.charAt(i);\n+\t\t    if (ch != z) {\n+\t\t\tfound = false;\n+\t\t\tbreak;\n+\t\t    }\n+\t\t    ++i;\n+\t\t    ch = input.charAt(mymatch.index - len + i);\n+\t\t} while (i < len);\n+\t    \n+\t\tif (found) return next(input, mymatch);\n+\t    }\n+\t}\n+\t\n+\t// Don't match at all if REG_NOTBOL is set.\n+\tif ((mymatch.eflags & RE.REG_NOTBOL) > 0) return false;\n+\t\n+\tif ((mymatch.eflags & RE.REG_ANCHORINDEX) > 0)\n+\t    return (mymatch.anchor == mymatch.offset) ? \n+\t\tnext(input, mymatch) : false;\n+\telse\n+\t    return ((mymatch.index == 0) && (mymatch.offset == 0)) ?\n+\t\tnext(input, mymatch) : false;\n+    }\n+    \n+    void dump(StringBuffer os) {\n+\tos.append('^');\n+    }\n+}"}, {"sha": "38baaec13d59e12a16b4cf36d6124877cdf75df2", "filename": "libjava/gnu/regexp/RETokenWordBoundary.java", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenWordBoundary.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FRETokenWordBoundary.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRETokenWordBoundary.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,104 @@\n+/* gnu/regexp/RETokenWordBoundary.java\n+   Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.regexp;\n+\n+/**\n+ * Represents a combination lookahead/lookbehind for POSIX [:alnum:].\n+ */\n+final class RETokenWordBoundary extends REToken {\n+    private boolean negated;\n+    private int where;\n+    static final int BEGIN = 1;\n+    static final int END = 2;\n+\n+    RETokenWordBoundary(int subIndex, int where, boolean negated) {\n+\tsuper(subIndex);\n+\tthis.where = where;\n+\tthis.negated = negated;\n+    }\n+    \n+    boolean match(CharIndexed input, REMatch mymatch) {\n+\t// Word boundary means input[index-1] was a word character\n+\t// and input[index] is not, or input[index] is a word character\n+\t// and input[index-1] was not\n+\t//  In the string \"one two three\", these positions match:\n+\t//  |o|n|e| |t|w|o| |t|h|r|e|e|\n+\t//  ^     ^ ^     ^ ^         ^\n+\tboolean after = false;  // is current character a letter or digit?\n+\tboolean before = false; // is previous character a letter or digit?\n+\tchar ch;\n+\n+\t// TODO: Also check REG_ANCHORINDEX vs. anchor\n+\tif (((mymatch.eflags & RE.REG_ANCHORINDEX) != RE.REG_ANCHORINDEX) \n+\t    || (mymatch.offset + mymatch.index > mymatch.anchor)) {\n+\t    if ((ch = input.charAt(mymatch.index - 1)) != CharIndexed.OUT_OF_BOUNDS) {\n+\t\tbefore = Character.isLetterOrDigit(ch) || (ch == '_');\n+\t    }\n+\t}\n+\n+\tif ((ch = input.charAt(mymatch.index)) != CharIndexed.OUT_OF_BOUNDS) {\n+\t    after = Character.isLetterOrDigit(ch) || (ch == '_');\n+\t}\n+\n+\t// if (before) and (!after), we're at end (\\>)\n+\t// if (after) and (!before), we're at beginning (\\<)\n+\tboolean doNext = false;\n+\n+\tif ((where & BEGIN) == BEGIN) {\n+\t    doNext = after && !before;\n+\t}\n+\tif ((where & END) == END) {\n+\t    doNext ^= before && !after;\n+\t}\n+\n+\tif (negated) doNext = !doNext;\n+\n+\treturn (doNext ? next(input, mymatch) : false);\n+    }\n+    \n+    void dump(StringBuffer os) {\n+\tif (where == (BEGIN | END)) {\n+\t    os.append( negated ? \"\\\\B\" : \"\\\\b\" );\n+\t} else if (where == BEGIN) {\n+\t    os.append(\"\\\\<\");\n+\t} else {\n+\t    os.append(\"\\\\>\");\n+\t}\n+    }\n+}"}, {"sha": "660466eabbb39a294d92cfe5bc7b702e48987c03", "filename": "libjava/gnu/regexp/UncheckedRE.java", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FUncheckedRE.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fgnu%2Fregexp%2FUncheckedRE.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FUncheckedRE.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -0,0 +1,109 @@\n+/* gnu/regexp/UncheckedRE.java\n+   Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.regexp;\n+\n+/**\n+ * UncheckedRE is a subclass of RE that allows programmers an easier means\n+ * of programmatically precompiling regular expressions.  It is constructed\n+ * and used in exactly the same manner as an instance of the RE class; the\n+ * only difference is that its constructors do not throw REException.\n+ * Instead, if a syntax error is encountered during construction, a\n+ * RuntimeException will be thrown.\n+ * <P>\n+ * Note that this makes UncheckedRE dangerous if constructed with\n+ * dynamic data.  Do not use UncheckedRE unless you are completely sure\n+ * that all input being passed to it contains valid, well-formed \n+ * regular expressions for the syntax specified.\n+ *\n+ * @author <A HREF=\"mailto:wes@cacas.org\">Wes Biggs</A>\n+ * @see gnu.regexp.RE \n+ * @since gnu.regexp 1.1.4\n+ */\n+\n+public final class UncheckedRE extends RE {\n+  /**\n+   * Constructs a regular expression pattern buffer without any compilation\n+   * flags set, and using the default syntax (RESyntax.RE_SYNTAX_PERL5).\n+   *\n+   * @param pattern A regular expression pattern, in the form of a String,\n+   *   StringBuffer or char[].  Other input types will be converted to\n+   *   strings using the toString() method.\n+   * @exception RuntimeException The input pattern could not be parsed.\n+   * @exception NullPointerException The pattern was null.\n+   */\n+  public UncheckedRE(Object pattern) {\n+      this(pattern,0,RESyntax.RE_SYNTAX_PERL5);\n+  }\n+\n+  /**\n+   * Constructs a regular expression pattern buffer using the specified\n+   * compilation flags and the default syntax (RESyntax.RE_SYNTAX_PERL5).\n+   *\n+   * @param pattern A regular expression pattern, in the form of a String,\n+   *   StringBuffer, or char[].  Other input types will be converted to\n+   *   strings using the toString() method.\n+   * @param cflags The logical OR of any combination of the compilation flags in the RE class.\n+   * @exception RuntimeException The input pattern could not be parsed.\n+   * @exception NullPointerException The pattern was null.\n+   */\n+  public UncheckedRE(Object pattern, int cflags) {\n+      this(pattern,cflags,RESyntax.RE_SYNTAX_PERL5);\n+  }\n+\n+  /**\n+   * Constructs a regular expression pattern buffer using the specified\n+   * compilation flags and regular expression syntax.\n+   *\n+   * @param pattern A regular expression pattern, in the form of a String,\n+   *   StringBuffer, or char[].  Other input types will be converted to\n+   *   strings using the toString() method.\n+   * @param cflags The logical OR of any combination of the compilation flags in the RE class.\n+   * @param syntax The type of regular expression syntax to use.\n+   * @exception RuntimeException The input pattern could not be parsed.\n+   * @exception NullPointerException The pattern was null.\n+   */\n+  public UncheckedRE(Object pattern, int cflags, RESyntax syntax) {\n+      try {\n+\t  initialize(pattern,cflags,syntax,0,0);\n+      } catch (REException e) { \n+\t  throw new RuntimeException(e.getMessage());\n+      }\n+  }\n+}\n+\n+"}, {"sha": "28835d294e336e0e4bcc4759c1add8ce4c40edc7", "filename": "libjava/java/util/regex/Matcher.java", "status": "modified", "additions": 93, "deletions": 22, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fjava%2Futil%2Fregex%2FMatcher.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fjava%2Futil%2Fregex%2FMatcher.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fregex%2FMatcher.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -1,5 +1,5 @@\n-/* Matcher.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* Matcher.java -- Instance of a regular expression applied to a char sequence.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,13 +38,27 @@\n \n package java.util.regex;\n \n+import gnu.regexp.RE;\n+import gnu.regexp.REMatch;\n+\n /**\n- * @author Michael Koch\n+ * Instance of a regular expression applied to a char sequence.\n+ *\n  * @since 1.4\n  */\n public class Matcher\n {\n   private Pattern pattern;\n+  private CharSequence input;\n+  private int position;\n+  private int appendPosition;\n+  private REMatch match;\n+\n+  Matcher(Pattern pattern, CharSequence input)\n+  {\n+    this.pattern = pattern;\n+    this.input = input;\n+  }\n   \n   /**\n    * @param sb The target string buffer\n@@ -58,15 +72,21 @@\n   public Matcher appendReplacement (StringBuffer sb, String replacement)\n     throws IllegalStateException\n   {\n-    throw new Error(\"Not implemented\");\n+    assertMatchOp();\n+    sb.append(input.subSequence(appendPosition,\n+\t\t\t\tmatch.getStartIndex()).toString());\n+    sb.append(match.substituteInto(replacement));\n+    appendPosition = match.getEndIndex();\n+    return this;\n   }\n \n   /**\n    * @param sb The target string buffer\n    */\n   public StringBuffer appendTail (StringBuffer sb)\n   {\n-    throw new Error(\"Not implemented\");\n+    sb.append(input.subSequence(appendPosition, input.length()).toString());\n+    return sb;\n   }\n  \n   /**\n@@ -76,7 +96,8 @@ public StringBuffer appendTail (StringBuffer sb)\n   public int end ()\n     throws IllegalStateException\n   {\n-    throw new Error (\"Not implemented\");\n+    assertMatchOp();\n+    return match.getEndIndex();\n   }\n   \n   /**\n@@ -90,14 +111,36 @@ public int end ()\n   public int end (int group)\n     throws IllegalStateException\n   {\n-    throw new Error (\"Not implemented\");\n+    assertMatchOp();\n+    return match.getEndIndex(group);\n   }\n  \n   public boolean find ()\n   {\n-    throw new Error (\"Not implemented\");\n-  }\n-  \n+    boolean first = (match == null);\n+    match = pattern.getRE().getMatch(input, position);\n+    if (match != null)\n+      {\n+\tint endIndex = match.getEndIndex();\n+\t// Are we stuck at the same position?\n+\tif (!first && endIndex == position)\n+\t  {\n+\t    match = null;\n+\t    // Not at the end of the input yet?\n+\t    if (position < input.length() - 1)\n+\t      {\n+\t\tposition++;\n+\t\treturn find(position);\n+\t      }\n+\t    else\n+\t      return false;\n+\t  }\n+\tposition = endIndex;\n+\treturn true;\n+      }\n+    return false;\n+  } \n+\n   /**\n    * @param start The index to start the new pattern matching\n    *\n@@ -106,7 +149,13 @@ public boolean find ()\n    */\n   public boolean find (int start)\n   {\n-    throw new Error (\"Not implemented\");\n+    match = pattern.getRE().getMatch(input, start);\n+    if (match != null)\n+      {\n+\tposition = match.getEndIndex();\n+\treturn true;\n+      }\n+    return false;\n   }\n  \n   /**\n@@ -115,7 +164,8 @@ public boolean find (int start)\n    */\n   public String group ()\n   {\n-    throw new Error (\"Not implemented\");\n+    assertMatchOp();\n+    return match.toString();\n   }\n   \n   /**\n@@ -129,33 +179,44 @@ public String group ()\n   public String group (int group)\n     throws IllegalStateException\n   {\n-    throw new Error (\"Not implemented\");\n+    assertMatchOp();\n+    return match.toString(group);\n   }\n \n   /**\n    * @param replacement The replacement string\n    */\n   public String replaceFirst (String replacement)\n   {\n-    throw new Error (\"Not implemented\");\n+    reset();\n+    // Semantics might not quite match\n+    return pattern.getRE().substitute(input, replacement, position);\n   }\n \n   /**\n    * @param replacement The replacement string\n    */\n   public String replaceAll (String replacement)\n   {\n-    throw new Error (\"Not implemented\");\n+    reset();\n+    return pattern.getRE().substituteAll(input, replacement, position);\n   }\n   \n   public int groupCount ()\n   {\n-    throw new Error(\"Not implemented\");\n+    return pattern.getRE().getNumSubs();\n   }\n  \n   public boolean lookingAt ()\n   {\n-    throw new Error(\"Not implemented\");\n+    match = pattern.getRE().getMatch(input, 0);\n+    if (match != null)\n+      {\n+\tif (match.getStartIndex() == 0)\n+\t  return true;\n+\tmatch = null;\n+      }\n+    return false;\n   }\n   \n   /**\n@@ -170,7 +231,7 @@ public boolean lookingAt ()\n    */\n   public boolean matches ()\n   {\n-    throw new Error(\"Not implemented\");\n+    return find(0);\n   }\n   \n   /**\n@@ -183,15 +244,18 @@ public Pattern pattern ()\n   \n   public Matcher reset ()\n   {\n-    throw new Error (\"Not implemented\");\n+    position = 0;\n+    match = null;\n+    return this;\n   }\n   \n   /**\n    * @param input The new input character sequence\n    */\n   public Matcher reset (CharSequence input)\n   {\n-    throw new Error (\"Not implemented\");\n+    this.input = input;\n+    return reset();\n   }\n   \n   /**\n@@ -203,7 +267,8 @@ public Matcher reset (CharSequence input)\n   public int start ()\n     throws IllegalStateException\n   {\n-    throw new Error(\"Not implemented\");\n+    assertMatchOp();\n+    return match.getStartIndex();\n   }\n \n   /**\n@@ -217,6 +282,12 @@ public int start ()\n   public int start (int group)\n     throws IllegalStateException\n   {\n-    throw new Error(\"Not implemented\");\n+    assertMatchOp();\n+    return match.getStartIndex(group);\n+  }\n+\n+  private void assertMatchOp()\n+  {\n+    if (match == null) throw new IllegalStateException();\n   }\n }"}, {"sha": "d30096049e561d2ada0591f161d052511967097b", "filename": "libjava/java/util/regex/Pattern.java", "status": "modified", "additions": 116, "deletions": 13, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fjava%2Futil%2Fregex%2FPattern.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec730df5fc5d0e879363556e6d9032f3104d0f49/libjava%2Fjava%2Futil%2Fregex%2FPattern.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fregex%2FPattern.java?ref=ec730df5fc5d0e879363556e6d9032f3104d0f49", "patch": "@@ -1,5 +1,5 @@\n-/* Pattern.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* Pattern.java -- Compiled regular expression ready to be applied.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,13 +35,19 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-// Stub class until java.util.regex is implemented.\n package java.util.regex;\n \n+import gnu.regexp.RE;\n+import gnu.regexp.RESyntax;\n+import gnu.regexp.REException;\n+\n import java.io.Serializable;\n+import java.util.ArrayList;\n+\n \n /**\n- * @author Michael Koch\n+ * Compiled regular expression ready to be applied. \n+ *\n  * @since 1.4\n  */\n public class Pattern implements Serializable\n@@ -56,8 +62,10 @@ public class Pattern implements Serializable\n   public static final int UNICODE_CASE = 64;\n   public static final int UNIX_LINES = 1;\n   \n-  private String regex;\n-  private int flags;\n+  private final String regex;\n+  private final int flags;\n+\n+  private final RE re;\n \n   private Pattern (String regex)\n     throws PatternSyntaxException\n@@ -71,9 +79,48 @@ private Pattern (String regex, int flags)\n     this.regex = regex;\n     this.flags = flags;\n \n-    throw new Error (\"Not implemented\");\n+    int gnuFlags = 0;\n+    if ((flags & CASE_INSENSITIVE) != 0)\n+      gnuFlags |= RE.REG_ICASE;\n+    if ((flags & MULTILINE) != 0)\n+      gnuFlags |= RE.REG_MULTILINE;\n+    if ((flags & DOTALL) != 0)\n+      gnuFlags |= RE.REG_DOT_NEWLINE;\n+    // not yet supported:\n+    // if ((flags & UNICODE_CASE) != 0) gnuFlags =\n+    // if ((flags & CANON_EQ) != 0) gnuFlags =\n+\n+    // Eventually there will be such a thing as JDK 1_4 syntax\n+    RESyntax syntax = RESyntax.RE_SYNTAX_PERL5;\n+    if ((flags & UNIX_LINES) != 0)\n+      {\n+\t// Use a syntax set with \\n for linefeeds?\n+\tsyntax = new RESyntax(syntax);\n+\tsyntax.setLineSeparator(\"\\n\");\n+      }\n+\n+    if ((flags & COMMENTS) != 0)\n+      {\n+\t// Use a syntax with support for comments?\n+      }\n+\n+    try\n+      {\n+\tthis.re = new RE(regex, gnuFlags, syntax);\n+      }\n+    catch (REException e)\n+      {\n+\tthrow new PatternSyntaxException(e.getMessage(),\n+\t\t\t\t\t regex, e.getPosition());\n+      }\n   }\n  \n+  // package private accessor method\n+  RE getRE()\n+  {\n+    return re;\n+  }\n+\n   /**\n    * @param regex The regular expression\n    *\n@@ -82,7 +129,7 @@ private Pattern (String regex, int flags)\n   public static Pattern compile (String regex)\n     throws PatternSyntaxException\n   {\n-    throw new Error (\"Not implemented\");\n+    return compile(regex, 0);\n   }\n   \n   /**\n@@ -116,23 +163,23 @@ public int flags ()\n    */\n   public static boolean matches (String regex, CharSequence input) \n   {\n-    throw new Error (\"Not implemented\");\n+    return compile(regex).matcher(input).matches();\n   }\n   \n   /**\n    * @param input The character sequence to be matched\n    */\n   public Matcher matcher (CharSequence input)\n   {\n-    throw new Error (\"Not implemented\");\n+    return new Matcher(this, input);\n   }\n   \n   /**\n    * @param input The character sequence to be matched\n    */\n   public String[] split (CharSequence input)\n   {\n-    throw new Error (\"Not implemented\");\n+    return split(input, 0);\n   }\n   \n   /**\n@@ -141,11 +188,67 @@ public String[] split (CharSequence input)\n    */\n   public String[] split (CharSequence input, int limit)\n   {\n-    throw new Error (\"Not implemented\");\n+    Matcher matcher = new Matcher(this, input);\n+    ArrayList list = new ArrayList();\n+    int empties = 0;\n+    int count = 0;\n+    int start = 0;\n+    int end;\n+    boolean matched;\n+\n+    while (matched = matcher.find() && (limit <= 0 || count < limit - 1))\n+      {\n+\t++count;\n+\tend = matcher.start();\n+\tif (start == end)\n+\t  empties++;\n+\telse\n+\t  {\n+\t    while (empties-- > 0)\n+\t      list.add(\"\");\n+\n+\t    String text = input.subSequence(start, end).toString();\n+\t    list.add(text);\n+\t  }\n+\tstart = matcher.end();\n+      }\n+\n+    // We matched nothing.\n+    if (!matched && count == 0)\n+      return new String[] { input.toString() };\n+    \n+    // Is the last token empty?\n+    boolean emptyLast = (start == input.length());\n+\n+    // Can/Must we add empties or an extra last token at the end?\n+    if (list.size() < limit || limit < 0 || (limit == 0 && !emptyLast))\n+      {\n+\tif (limit > list.size())\n+\t  {\n+\t    int max = limit - list.size();\n+\t    empties = (empties > max) ? max : empties;\n+\t  }\n+\twhile (empties-- > 0)\n+\t  list.add(\"\");\n+      }\n+\n+    // last token at end\n+    if (limit != 0 || (limit == 0 && !emptyLast))\n+      {\n+\tString t = input.subSequence(start, input.length()).toString();\n+\tif (\"\".equals(t) && limit == 0)\n+\t  ; // Don't add.\n+\telse\n+\t  list.add(t);\n+      }\n+\n+    String[] output = new String [list.size()];\n+    list.toArray(output);\n+    return output;\n   }\n   \n   public String pattern ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return regex;\n   }\n }"}]}