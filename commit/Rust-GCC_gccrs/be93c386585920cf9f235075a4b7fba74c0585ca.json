{"sha": "be93c386585920cf9f235075a4b7fba74c0585ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU5M2MzODY1ODU5MjBjZjlmMjM1MDc1YTRiN2ZiYTc0YzA1ODVjYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-16T12:57:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-16T12:57:45Z"}, "message": "[multiple changes]\n\n2012-07-16  Thomas Quinot  <quinot@adacore.com>\n\n\t* gnat_rm.texi: Minor documentation improvements.\n\n2012-07-16  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Allow Pre\n\tand Pre'Class aspects on the same declaration.\n\t* sem_prag.adb (Chain_PPC): Allow Pre and Pre'Class aspects on the\n\tsame hierarchy of primitive operations.\n\nFrom-SVN: r189533", "tree": {"sha": "e1a504af744399992806bf977765bb5d5364f7e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1a504af744399992806bf977765bb5d5364f7e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be93c386585920cf9f235075a4b7fba74c0585ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be93c386585920cf9f235075a4b7fba74c0585ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be93c386585920cf9f235075a4b7fba74c0585ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be93c386585920cf9f235075a4b7fba74c0585ca/comments", "author": null, "committer": null, "parents": [{"sha": "5df1266a05ba1c1d0a3970a2151f66d9a598b333", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5df1266a05ba1c1d0a3970a2151f66d9a598b333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5df1266a05ba1c1d0a3970a2151f66d9a598b333"}], "stats": {"total": 108, "additions": 23, "deletions": 85}, "files": [{"sha": "307206bb5b4a1cc844d5068f378d567bb68e7c74", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93c386585920cf9f235075a4b7fba74c0585ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93c386585920cf9f235075a4b7fba74c0585ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=be93c386585920cf9f235075a4b7fba74c0585ca", "patch": "@@ -1,3 +1,14 @@\n+2012-07-16  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* gnat_rm.texi: Minor documentation improvements.\n+\n+2012-07-16  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Allow Pre\n+\tand Pre'Class aspects on the same declaration.\n+\t* sem_prag.adb (Chain_PPC): Allow Pre and Pre'Class aspects on the\n+\tsame hierarchy of primitive operations.\n+\n 2012-07-16  Thomas Quinot  <quinot@adacore.com>\n \n \t* freeze.adb (Check_Component_Storage_Order): Do not reject a"}, {"sha": "9770f1930722b22bdc619f8eddbdaede7f66189e", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93c386585920cf9f235075a4b7fba74c0585ca/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93c386585920cf9f235075a4b7fba74c0585ca/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=be93c386585920cf9f235075a4b7fba74c0585ca", "patch": "@@ -6726,15 +6726,17 @@ have a @code{Scalar_Storage_Order} attribute definition clause. In addition,\n if the component does not start on a byte boundary, then the scalar storage\n order specified for S and for the nested component type shall be identical.\n \n+No component of a type that has a @code{Scalar_Storage_Order} attribute\n+definition may be aliased.\n+\n A confirming @code{Scalar_Storage_Order} attribute definition clause (i.e.\n with a value equal to @code{System.Default_Bit_Order}) has no effect.\n \n-If the opposite storage order is specified, then whenever the\n-value of a scalar component of S is read, the storage elements of the\n-enclosing machine scalar are first reversed (before retrieving the\n-component value, possibly applying some shift and mask operatings on the\n-enclosing machine scalar), and the opposite operation is done for\n-writes.\n+If the opposite storage order is specified, then whenever the value of\n+a scalar component of S is read, the storage elements of the enclosing\n+machine scalar are first reversed (before retrieving the component value,\n+possibly applying some shift and mask operatings on the enclosing machine\n+scalar), and the opposite operation is done for writes.\n \n In that case, the restrictions set forth in 13.5.1(10.3/2) for scalar components\n are relaxed. Instead, the following rules apply:\n@@ -13705,7 +13707,9 @@ ENCODING=[UTF8|8BITS]\n @end smallexample\n \n @noindent\n-The use of these parameters is described later in this section.\n+The use of these parameters is described later in this section. If an\n+unrecognized keyword appears in a form string, it is silently ignored\n+and not considered invalid.\n \n @node Direct_IO\n @section Direct_IO"}, {"sha": "144d66df13571e7e918d2eaa62f6ca0a859dda02", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93c386585920cf9f235075a4b7fba74c0585ca/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93c386585920cf9f235075a4b7fba74c0585ca/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=be93c386585920cf9f235075a4b7fba74c0585ca", "patch": "@@ -1098,29 +1098,7 @@ package body Sem_Ch13 is\n                              (\"aspect `%''Class` for & previously given#\",\n                               Id, E);\n                         end if;\n-\n-                        --  Case of Pre and Pre'Class both specified\n-\n-                     elsif Nam = Name_Pre then\n-                        if Class_Present (Aspect) then\n-                           Error_Msg_NE\n-                             (\"aspect `Pre''Class` for & is not allowed here\",\n-                              Id, E);\n-                           Error_Msg_NE\n-                             (\"\\since aspect `Pre` previously given#\",\n-                              Id, E);\n-\n-                        else\n-                           Error_Msg_NE\n-                             (\"aspect `Pre` for & is not allowed here\",\n-                              Id, E);\n-                           Error_Msg_NE\n-                             (\"\\since aspect `Pre''Class` previously given#\",\n-                              Id, E);\n-                        end if;\n                      end if;\n-\n-                     --  Allowed case of X and X'Class both specified\n                   end if;\n \n                   Next (Anod);"}, {"sha": "fffbe0d223d1360e8bfe61c16e7c07aec5cff229", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 56, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93c386585920cf9f235075a4b7fba74c0585ca/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93c386585920cf9f235075a4b7fba74c0585ca/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=be93c386585920cf9f235075a4b7fba74c0585ca", "patch": "@@ -2011,8 +2011,7 @@ package body Sem_Prag is\n          ---------------\n \n          procedure Chain_PPC (PO : Node_Id) is\n-            S   : Entity_Id;\n-            P   : Node_Id;\n+            S : Entity_Id;\n \n          begin\n             if Nkind (PO) = N_Abstract_Subprogram_Declaration then\n@@ -2060,60 +2059,6 @@ package body Sem_Prag is\n                S := Defining_Unit_Name (Specification (PO));\n             end if;\n \n-            --  Make sure we do not have the case of a precondition pragma when\n-            --  the Pre'Class aspect is present.\n-\n-            --  We do this by looking at pragmas already chained to the entity\n-            --  since the aspect derived pragma will be put on this list first.\n-\n-            if Pragma_Name (N) = Name_Precondition then\n-               if not From_Aspect_Specification (N) then\n-                  P := Spec_PPC_List (Contract (S));\n-                  while Present (P) loop\n-                     if Pragma_Name (P) = Name_Precondition\n-                       and then From_Aspect_Specification (P)\n-                       and then Class_Present (P)\n-                     then\n-                        Error_Msg_Sloc := Sloc (P);\n-                        Error_Pragma\n-                          (\"pragma% not allowed, `Pre''Class` aspect given#\");\n-                     end if;\n-\n-                     P := Next_Pragma (P);\n-                  end loop;\n-               end if;\n-            end if;\n-\n-            --  Similarly check for Pre with inherited Pre'Class. Note that\n-            --  we cover the aspect case as well here.\n-\n-            if Pragma_Name (N) = Name_Precondition\n-              and then not Class_Present (N)\n-            then\n-               declare\n-                  Inherited : constant Subprogram_List :=\n-                                Inherited_Subprograms (S);\n-                  P         : Node_Id;\n-\n-               begin\n-                  for J in Inherited'Range loop\n-                     P := Spec_PPC_List (Contract (Inherited (J)));\n-                     while Present (P) loop\n-                        if Pragma_Name (P) = Name_Precondition\n-                          and then Class_Present (P)\n-                        then\n-                           Error_Msg_Sloc := Sloc (P);\n-                           Error_Pragma\n-                             (\"pragma% not allowed, `Pre''Class` \"\n-                              & \"aspect inherited from#\");\n-                        end if;\n-\n-                        P := Next_Pragma (P);\n-                     end loop;\n-                  end loop;\n-               end;\n-            end if;\n-\n             --  Note: we do not analyze the pragma at this point. Instead we\n             --  delay this analysis until the end of the declarative part in\n             --  which the pragma appears. This implements the required delay"}]}