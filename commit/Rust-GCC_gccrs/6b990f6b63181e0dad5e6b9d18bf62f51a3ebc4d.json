{"sha": "6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI5OTBmNmI2MzE4MWUwZGFkNWU2YjlkMThiZjYyZjUxYTNlYmM0ZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-01-22T16:01:43Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-01-22T16:01:43Z"}, "message": "arm.c (arm_address_register_rtx_p): New function.\n\n* arm.c (arm_address_register_rtx_p): New function.\n(arm_legitimate_address_p): New function.\n(arm_legitimate_index_p): New function.\n(legitimize_pic_address): Use arm_legitimate_index_p.\n* arm-protos.h (arm_legtimate_address_p): Add prototype.\n* arm.h (ARM_GO_IF_LEGITIMATE_INDEX): Delete.\n(ARM_GO_IF_LEGITIMATE_ADDRESS): Call arm_legitimate_address_p.\n\nFrom-SVN: r61592", "tree": {"sha": "dedcd9aeff704d0a1603d069d19aeaba2edc1666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dedcd9aeff704d0a1603d069d19aeaba2edc1666"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/comments", "author": null, "committer": null, "parents": [{"sha": "f0bf1270067a1649d703c7bd883d4e660c05c8c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0bf1270067a1649d703c7bd883d4e660c05c8c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0bf1270067a1649d703c7bd883d4e660c05c8c0"}], "stats": {"total": 338, "additions": 203, "deletions": 135}, "files": [{"sha": "e110c0e3d76d8f47e4061af942792647122c091d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d", "patch": "@@ -1,3 +1,13 @@\n+2003-01-22  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_address_register_rtx_p): New function.\n+\t(arm_legitimate_address_p): New function.\n+\t(arm_legitimate_index_p): New function.\n+\t(legitimize_pic_address): Use arm_legitimate_index_p.\n+\t* arm-protos.h (arm_legtimate_address_p): Add prototype.\n+\t* arm.h (ARM_GO_IF_LEGITIMATE_INDEX): Delete.\n+\t(ARM_GO_IF_LEGITIMATE_ADDRESS): Call arm_legitimate_address_p.\n+\n 2003-01-22  Hartmut Penner  <hpenner@de.ibm.com>\n \n \t* config/s390/s390.md (floatdfdi2): Insn has type 'itof'."}, {"sha": "83788a0529f47715aab9d5e9e499dcb4bb28f3d8", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d", "patch": "@@ -52,6 +52,7 @@ extern int    arm_split_constant\tPARAMS ((RTX_CODE, enum machine_mode,\n extern RTX_CODE arm_canonicalize_comparison PARAMS ((RTX_CODE, rtx *));\n extern int    legitimate_pic_operand_p\tPARAMS ((rtx));\n extern rtx    legitimize_pic_address\tPARAMS ((rtx, enum machine_mode, rtx));\n+extern int    arm_legitimate_address_p  PARAMS ((enum machine_mode, rtx, int));\n extern int    arm_rtx_costs\t\tPARAMS ((rtx, RTX_CODE, RTX_CODE));\n extern int    const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n extern int    neg_const_double_rtx_ok_for_fpu\tPARAMS ((rtx));"}, {"sha": "4a8d85a2146f450c7bbd72f3b639ad2820cf651f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 179, "deletions": 7, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d", "patch": "@@ -68,6 +68,9 @@ const struct attribute_spec arm_attribute_table[];\n static void      arm_add_gc_roots \t\tPARAMS ((void));\n static int       arm_gen_constant\t\tPARAMS ((enum rtx_code, Mmode, Hint, rtx, rtx, int, int));\n static unsigned  bit_count \t\t\tPARAMS ((Ulong));\n+static int\t arm_address_register_rtx_p\tPARAMS ((rtx, int));\n+static int\t arm_legitimate_index_p\t\tPARAMS ((enum machine_mode,\n+\t\t\t\t\t\t\t rtx, int));\n static int       const_ok_for_op \t\tPARAMS ((Hint, enum rtx_code));\n static int       eliminate_lr2ip\t\tPARAMS ((rtx *));\n static rtx\t emit_multi_reg_push\t\tPARAMS ((int));\n@@ -2357,6 +2360,10 @@ arm_function_ok_for_sibcall (decl, exp)\n }\n \n \f\n+/* Addressing mode support functions.  */\n+\n+/* Return non-zero if X is a legitimate immediate operand when compiling\n+   for PIC.  */\n int\n legitimate_pic_operand_p (x)\n      rtx x;\n@@ -2463,14 +2470,14 @@ legitimize_pic_address (orig, mode, reg)\n \t{\n \t  /* The base register doesn't really matter, we only want to\n \t     test the index for the appropriate mode.  */\n-\t  ARM_GO_IF_LEGITIMATE_INDEX (mode, 0, offset, win);\n-\n-\t  if (!no_new_pseudos)\n-\t    offset = force_reg (Pmode, offset);\n-\t  else\n-\t    abort ();\n+\t  if (!arm_legitimate_index_p (mode, offset, 0))\n+\t    {\n+\t      if (!no_new_pseudos)\n+\t\toffset = force_reg (Pmode, offset);\n+\t      else\n+\t\tabort ();\n+\t    }\n \n-\twin:\n \t  if (GET_CODE (offset) == CONST_INT)\n \t    return plus_constant (base, INTVAL (offset));\n \t}\n@@ -2548,6 +2555,171 @@ arm_finalize_pic (prologue)\n #endif /* AOF_ASSEMBLER */\n }\n \n+/* Return nonzero if X is valid as an ARM state addressing register.  */\n+static int\n+arm_address_register_rtx_p (x, strict_p)\n+     rtx x;\n+     int strict_p;\n+{\n+  int regno;\n+\n+  if (GET_CODE (x) != REG)\n+    return 0;\n+\n+  regno = REGNO (x);\n+\n+  if (strict_p)\n+    return ARM_REGNO_OK_FOR_BASE_P (regno);\n+\n+  return (regno <= LAST_ARM_REGNUM\n+\t  || regno >= FIRST_PSEUDO_REGISTER\n+\t  || regno == FRAME_POINTER_REGNUM\n+\t  || regno == ARG_POINTER_REGNUM);\n+}\n+\n+/* Return nonzero if X is a valid ARM state address operand.  */\n+int\n+arm_legitimate_address_p (mode, x, strict_p)\n+     enum machine_mode mode;\n+     rtx x;\n+     int strict_p;\n+{\n+  if (arm_address_register_rtx_p (x, strict_p))\n+    return 1;\n+\n+  else if (GET_CODE (x) == POST_INC || GET_CODE (x) == PRE_DEC)\n+    return arm_address_register_rtx_p (XEXP (x, 0), strict_p);\n+\n+  else if ((GET_CODE (x) == POST_MODIFY || GET_CODE (x) == PRE_MODIFY)\n+\t   && GET_MODE_SIZE (mode) <= 4\n+\t   && arm_address_register_rtx_p (XEXP (x, 0), strict_p)\n+\t   && GET_CODE (XEXP (x, 1)) == PLUS\n+\t   && XEXP (XEXP (x, 1), 0) == XEXP (x, 0))\n+    return arm_legitimate_index_p (mode, XEXP (XEXP (x, 1), 1), strict_p);\n+\n+  /* After reload constants split into minipools will have addresses\n+     from a LABEL_REF.  */\n+  else if (GET_MODE_SIZE (mode) >= 4 && reload_completed\n+\t   && (GET_CODE (x) == LABEL_REF\n+\t       || (GET_CODE (x) == CONST\n+\t\t   && GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n+\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n+    return 1;\n+\n+  else if (mode == TImode)\n+    return 0;\n+\n+  else if (mode == DImode || (TARGET_SOFT_FLOAT && mode == DFmode))\n+    {\n+      if (GET_CODE (x) == PLUS\n+\t  && arm_address_register_rtx_p (XEXP (x, 0), strict_p)\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n+\n+          if (val == 4 || val == -4 || val == -8)\n+\t    return 1;\n+\t}\n+    }\n+\n+  else if (GET_CODE (x) == PLUS)\n+    {\n+      rtx xop0 = XEXP (x, 0);\n+      rtx xop1 = XEXP (x, 1);\n+\n+      return ((arm_address_register_rtx_p (xop0, strict_p)\n+\t       && arm_legitimate_index_p (mode, xop1, strict_p))\n+\t      || (arm_address_register_rtx_p (xop1, strict_p)\n+\t\t  && arm_legitimate_index_p (mode, xop0, strict_p)));\n+    }\n+\n+#if 0\n+  /* Reload currently can't handle MINUS, so disable this for now */\n+  else if (GET_CODE (x) == MINUS)\n+    {\n+      rtx xop0 = XEXP (x, 0);\n+      rtx xop1 = XEXP (x, 1);\n+\n+      return (arm_address_register_rtx_p (xop0, strict_p)\n+\t      && arm_legitimate_index_p (mode, xop1, strict_p));\n+    }\n+#endif\n+\n+  else if (GET_MODE_CLASS (mode) != MODE_FLOAT\n+\t   && GET_CODE (x) == SYMBOL_REF\n+\t   && CONSTANT_POOL_ADDRESS_P (x)\n+\t   && ! (flag_pic\n+\t\t && symbol_mentioned_p (get_pool_constant (x))))\n+    return 1;\n+\n+  else if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == POST_DEC)\n+\t   && (GET_MODE_SIZE (mode) <= 4)\n+\t   && arm_address_register_rtx_p (XEXP (x, 0), strict_p))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return nonzero if INDEX is valid for an address index operand in\n+   ARM state.  */\n+static int\n+arm_legitimate_index_p (mode, index, strict_p)\n+     enum machine_mode mode;\n+     rtx index;\n+     int strict_p;\n+{\n+  HOST_WIDE_INT range;\n+  enum rtx_code code = GET_CODE (index);\n+\n+  if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    return (code == CONST_INT && INTVAL (index) < 1024\n+\t    && INTVAL (index) > -1024\n+\t    && (INTVAL (index) & 3) == 0);\n+\n+  if (arm_address_register_rtx_p (index, strict_p)\n+      && GET_MODE_SIZE (mode) <= 4)\n+    return 1;\n+\n+  /* XXX What about ldrsb?  */\n+  if (GET_MODE_SIZE (mode) <= 4  && code == MULT\n+      && (!arm_arch4 || (mode) != HImode))\n+    {\n+      rtx xiop0 = XEXP (index, 0);\n+      rtx xiop1 = XEXP (index, 1);\n+\n+      return ((arm_address_register_rtx_p (xiop0, strict_p)\n+\t       && power_of_two_operand (xiop1, SImode))\n+\t      || (arm_address_register_rtx_p (xiop1, strict_p)\n+\t\t  && power_of_two_operand (xiop0, SImode)));\n+    }\n+\n+  if (GET_MODE_SIZE (mode) <= 4\n+      && (code == LSHIFTRT || code == ASHIFTRT\n+\t  || code == ASHIFT || code == ROTATERT)\n+      && (!arm_arch4 || (mode) != HImode))\n+    {\n+      rtx op = XEXP (index, 1);\n+\n+      return (arm_address_register_rtx_p (XEXP (index, 0), strict_p)\n+\t      && GET_CODE (op) == CONST_INT\n+\t      && INTVAL (op) > 0\n+\t      && INTVAL (op) <= 31);\n+    }\n+\n+  /* XXX For ARM v4 we may be doing a sign-extend operation during the\n+     load, but that has a restricted addressing range and we are unable\n+     to tell here whether that is the case.  To be safe we restrict all\n+     loads to that range.  */\n+  range = ((mode) == HImode || (mode) == QImode)\n+    ? (arm_arch4 ? 256 : 4095) : 4096;\n+\n+  return (code == CONST_INT\n+\t  && INTVAL (index) < range\n+\t  && INTVAL (index) > -range);\n+}  \n+\f\n+\n #define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\\n   (GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n    || (GET_CODE (X) == SUBREG && GET_CODE (SUBREG_REG (X)) == REG))"}, {"sha": "c0708016d167aaf396e1760af0ff6cc3816f2547", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 13, "deletions": 128, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6b990f6b63181e0dad5e6b9d18bf62f51a3ebc4d", "patch": "@@ -1943,134 +1943,19 @@ typedef struct\n #define ARM_INDEX_REGISTER_RTX_P(X)  \\\n   (GET_CODE (X) == REG && ARM_REG_OK_FOR_INDEX_P (X))\n \n-/* A C statement (sans semicolon) to jump to LABEL for legitimate index RTXs\n-   used by the macro GO_IF_LEGITIMATE_ADDRESS.  Floating point indices can\n-   only be small constants. */\n-#define ARM_GO_IF_LEGITIMATE_INDEX(MODE, BASE_REGNO, INDEX, LABEL)\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT range;\t\t\t\t\t\t\\\n-      enum rtx_code code = GET_CODE (INDEX);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (code == CONST_INT && INTVAL (INDEX) < 1024\t\t\\\n-\t      && INTVAL (INDEX) > -1024\t\t\t\t\t\\\n-\t      && (INTVAL (INDEX) & 3) == 0)\t\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (ARM_INDEX_REGISTER_RTX_P (INDEX)\t\t\t\t\\\n-\t      && GET_MODE_SIZE (MODE) <= 4)\t\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t  if (GET_MODE_SIZE (MODE) <= 4  && code == MULT\t\t\\\n-\t      && (! arm_arch4 || (MODE) != HImode))\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      rtx xiop0 = XEXP (INDEX, 0);\t\t\t\t\\\n-\t      rtx xiop1 = XEXP (INDEX, 1);\t\t\t\t\\\n-\t      if (ARM_INDEX_REGISTER_RTX_P (xiop0)\t\t\t\\\n-\t\t  && power_of_two_operand (xiop1, SImode))\t\t\\\n-\t\tgoto LABEL;\t\t\t\t\t\t\\\n-\t      if (ARM_INDEX_REGISTER_RTX_P (xiop1)\t\t\t\\\n-\t\t  && power_of_two_operand (xiop0, SImode))\t\t\\\n-\t\tgoto LABEL;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n-\t      && (code == LSHIFTRT || code == ASHIFTRT\t\t\t\\\n-\t\t  || code == ASHIFT || code == ROTATERT)\t\t\\\n-\t      && (! arm_arch4 || (MODE) != HImode))\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      rtx op = XEXP (INDEX, 1);\t\t\t\t\t\\\n-\t      if (ARM_INDEX_REGISTER_RTX_P (XEXP (INDEX, 0))\t\t\\\n-\t\t  && GET_CODE (op) == CONST_INT && INTVAL (op) > 0\t\\\n-\t\t  && INTVAL (op) <= 31)\t\t\t\t\t\\\n-\t\tgoto LABEL;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  /* NASTY: Since this limits the addressing of unsigned\t\\\n-\t     byte loads.  */\t\t\t\t\t\t\\\n-\t  range = ((MODE) == HImode || (MODE) == QImode)\t\t\\\n-\t    ? (arm_arch4 ? 256 : 4095) : 4096;\t\t\t\t\\\n-\t  if (code == CONST_INT && INTVAL (INDEX) < range\t\t\\\n-\t      && INTVAL (INDEX) > -range)\t\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Jump to LABEL if X is a valid address RTX.  This must take\n-   REG_OK_STRICT into account when deciding about valid registers.\n-\n-   Allow REG, REG+REG, REG+INDEX, INDEX+REG, REG-INDEX, and non\n-   floating SYMBOL_REF to the constant pool.  Allow REG-only and\n-   AUTINC-REG if handling TImode or HImode.  Other symbol refs must be\n-   forced though a static cell to ensure addressability.  */\n-#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t \\\n-{\t\t\t\t\t\t\t\t\t \\\n-  if (ARM_BASE_REGISTER_RTX_P (X))\t\t\t\t\t \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t \\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t \\\n-\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-  else if ((GET_CODE (X) == POST_MODIFY || GET_CODE (X) == PRE_MODIFY)\t \\\n-\t   && GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t \\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t \\\n-\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t \\\n-\t   && GET_CODE (XEXP (X, 1)) == PLUS\t\t\t\t \\\n-\t   && XEXP (XEXP (X, 1), 0) == XEXP (X, 0))\t\t\t \\\n-    ARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (XEXP (X, 0)), \t\t \\\n-\t\t\t\tXEXP (XEXP (X, 1), 1), LABEL);\t\t \\\n-  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t \\\n-\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t \\\n-\t       || (GET_CODE (X) == CONST\t\t\t\t \\\n-\t\t   && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t \\\n-\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 0)) == LABEL_REF\t \\\n-\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 1)) == CONST_INT))) \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-  else if ((MODE) == TImode)\t\t\t\t\t\t \\\n-    ;\t\t\t\t\t\t\t\t\t \\\n-  else if ((MODE) == DImode || (TARGET_SOFT_FLOAT && (MODE) == DFmode))\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      if (GET_CODE (X) == PLUS && ARM_BASE_REGISTER_RTX_P (XEXP (X, 0))\t \\\n-\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t \\\n-          if (val == 4 || val == -4 || val == -8)\t\t\t \\\n-\t    goto LABEL;\t\t\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t \\\n-      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-      if (ARM_BASE_REGISTER_RTX_P (xop0))\t\t\t\t \\\n-\tARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t \\\n-      else if (ARM_BASE_REGISTER_RTX_P (xop1))\t\t\t\t \\\n-\tARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL);\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  /* Reload currently can't handle MINUS, so disable this for now */\t \\\n-  /* else if (GET_CODE (X) == MINUS)\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      rtx xop0 = XEXP (X,0);\t\t\t\t\t\t \\\n-      rtx xop1 = XEXP (X,1);\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-      if (ARM_BASE_REGISTER_RTX_P (xop0))\t\t\t\t \\\n-\tARM_GO_IF_LEGITIMATE_INDEX (MODE, -1, xop1, LABEL);\t\t \\\n-    } */\t\t\t\t\t\t\t\t \\\n-  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t \\\n-\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t \\\n-\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t \\\n-\t   && ! (flag_pic\t\t\t\t\t\t \\\n-\t\t && symbol_mentioned_p (get_pool_constant (X))))\t \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t \\\n-\t   && (GET_MODE_SIZE (MODE) <= 4)\t\t\t\t \\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t \\\n-\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-}\n+#ifdef REG_OK_STRICT\n+#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    if (arm_legitimate_address_p (MODE, X, 1))\t\t\\\n+      goto WIN;\t\t\t\t\t\t\\\n+  }\n+#else\n+#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    if (arm_legitimate_address_p (MODE, X, 0))\t\t\\\n+      goto WIN;\t\t\t\t\t\t\\\n+  }\n+#endif\n \n /* ---------------------thumb version----------------------------------*/     \n #define THUMB_LEGITIMATE_OFFSET(MODE, VAL)\t\t\t\t\\"}]}