{"sha": "be6b029b8cdf4c17a9f040332b8345f0fa13ed43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU2YjAyOWI4Y2RmNGMxN2E5ZjA0MDMzMmI4MzQ1ZjBmYTEzZWQ0Mw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-04T15:04:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-04T15:04:15Z"}, "message": "tree-data-ref.c (stores_from_loop): Remove.\n\n2012-06-04  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-data-ref.c (stores_from_loop): Remove.\n\t(stmt_with_adjacent_zero_store_dr_p): Likewise.\n\t(stores_zero_from_loop): Likewise.\n\t* tree-data-ref.h (stores_from_loop, stores_zero_from_loop,\n\tstmt_with_adjacent_zero_store_dr_p, stride_of_unit_type_p): Remove.\n\t(adjacent_store_dr_p): New function.\n\t* tree-loop-distribution.c (generate_memset_builtin): Pass\n\tthe RDG, use the already available data-reference.\n\t(generate_code_for_partition): Pass down RDG.\n\t(classify_partition): Inline parts of the former\n\tstmt_with_adjacent_zero_store_dr_p here and use adjacent_store_dr_p.\n\t(ldist_gen): Remember if there was any detected builtin and\n\tdo less work if not and flag_tree_loop_distribution is not set.\n\t(tree_loop_distribution): Inline and fuse stores_from_loop\n\tand stores_zero_from_loop here.\n\nFrom-SVN: r188186", "tree": {"sha": "1745a46aaf5a6b03f3fbcde7185c2656be7d45bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1745a46aaf5a6b03f3fbcde7185c2656be7d45bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be6b029b8cdf4c17a9f040332b8345f0fa13ed43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be6b029b8cdf4c17a9f040332b8345f0fa13ed43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be6b029b8cdf4c17a9f040332b8345f0fa13ed43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36829666e2790ceef58549aa6b3c5dbb357b0af9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36829666e2790ceef58549aa6b3c5dbb357b0af9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36829666e2790ceef58549aa6b3c5dbb357b0af9"}], "stats": {"total": 208, "additions": 93, "deletions": 115}, "files": [{"sha": "c77ccda9df9ed1eee64ff305a2fdc36dfa8848eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be6b029b8cdf4c17a9f040332b8345f0fa13ed43", "patch": "@@ -1,3 +1,21 @@\n+2012-06-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-data-ref.c (stores_from_loop): Remove.\n+\t(stmt_with_adjacent_zero_store_dr_p): Likewise.\n+\t(stores_zero_from_loop): Likewise.\n+\t* tree-data-ref.h (stores_from_loop, stores_zero_from_loop,\n+\tstmt_with_adjacent_zero_store_dr_p, stride_of_unit_type_p): Remove.\n+\t(adjacent_store_dr_p): New function.\n+\t* tree-loop-distribution.c (generate_memset_builtin): Pass\n+\tthe RDG, use the already available data-reference.\n+\t(generate_code_for_partition): Pass down RDG.\n+\t(classify_partition): Inline parts of the former\n+\tstmt_with_adjacent_zero_store_dr_p here and use adjacent_store_dr_p.\n+\t(ldist_gen): Remember if there was any detected builtin and\n+\tdo less work if not and flag_tree_loop_distribution is not set.\n+\t(tree_loop_distribution): Inline and fuse stores_from_loop\n+\tand stores_zero_from_loop here.\n+\n 2012-06-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/53471"}, {"sha": "274a336ed84fe720ed0da96c00d46ada25008199", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=be6b029b8cdf4c17a9f040332b8345f0fa13ed43", "patch": "@@ -5174,88 +5174,6 @@ free_rdg (struct graph *rdg)\n   free_graph (rdg);\n }\n \n-/* Initialize STMTS with all the statements of LOOP that contain a\n-   store to memory.  */\n-\n-void\n-stores_from_loop (struct loop *loop, VEC (gimple, heap) **stmts)\n-{\n-  unsigned int i;\n-  basic_block *bbs = get_loop_body_in_dom_order (loop);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      basic_block bb = bbs[i];\n-      gimple_stmt_iterator bsi;\n-\n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\tif (gimple_vdef (gsi_stmt (bsi)))\n-\t  VEC_safe_push (gimple, heap, *stmts, gsi_stmt (bsi));\n-    }\n-\n-  free (bbs);\n-}\n-\n-/* Returns true when the statement at STMT is of the form \"A[i] = 0\"\n-   that contains a data reference on its LHS with a stride of the same\n-   size as its unit type.  */\n-\n-bool\n-stmt_with_adjacent_zero_store_dr_p (gimple stmt)\n-{\n-  tree lhs, rhs;\n-  bool res;\n-  struct data_reference *dr;\n-\n-  if (!stmt\n-      || !gimple_vdef (stmt)\n-      || !gimple_assign_single_p (stmt))\n-    return false;\n-\n-  lhs = gimple_assign_lhs (stmt);\n-  rhs = gimple_assign_rhs1 (stmt);\n-\n-  /* If this is a bitfield store bail out.  */\n-  if (TREE_CODE (lhs) == COMPONENT_REF\n-      && DECL_BIT_FIELD (TREE_OPERAND (lhs, 1)))\n-    return false;\n-\n-  if (!(integer_zerop (rhs) || real_zerop (rhs)))\n-    return false;\n-\n-  dr = XCNEW (struct data_reference);\n-\n-  DR_STMT (dr) = stmt;\n-  DR_REF (dr) = lhs;\n-\n-  res = dr_analyze_innermost (dr, loop_containing_stmt (stmt))\n-    && stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (lhs));\n-\n-  free_data_ref (dr);\n-  return res;\n-}\n-\n-/* Initialize STMTS with all the statements of LOOP that contain a\n-   store to memory of the form \"A[i] = 0\".  */\n-\n-void\n-stores_zero_from_loop (struct loop *loop, VEC (gimple, heap) **stmts)\n-{\n-  unsigned int i;\n-  basic_block bb;\n-  gimple_stmt_iterator si;\n-  gimple stmt;\n-  basic_block *bbs = get_loop_body_in_dom_order (loop);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    for (bb = bbs[i], si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-      if ((stmt = gsi_stmt (si))\n-\t  && stmt_with_adjacent_zero_store_dr_p (stmt))\n-\tVEC_safe_push (gimple, heap, *stmts, gsi_stmt (si));\n-\n-  free (bbs);\n-}\n-\n /* Determines whether the statement from vertex V of the RDG has a\n    definition used outside the loop that contains this statement.  */\n "}, {"sha": "853dd81341164b6118b3f84af17c5392d35be2a1", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=be6b029b8cdf4c17a9f040332b8345f0fa13ed43", "patch": "@@ -609,21 +609,29 @@ index_in_loop_nest (int var, VEC (loop_p, heap) *loop_nest)\n   return var_index;\n }\n \n-void stores_from_loop (struct loop *, VEC (gimple, heap) **);\n-void stores_zero_from_loop (struct loop *, VEC (gimple, heap) **);\n bool rdg_defs_used_in_other_loops_p (struct graph *, int);\n-bool stmt_with_adjacent_zero_store_dr_p (gimple);\n \n-/* Returns true when STRIDE is equal in absolute value to the size of\n-   the unit type of TYPE.  */\n+/* Returns true when the data reference DR the form \"A[i] = ...\"\n+   with a stride equal to its unit type size.  */\n \n static inline bool\n-stride_of_unit_type_p (tree stride, tree type)\n+adjacent_store_dr_p (struct data_reference *dr)\n {\n-  return (TREE_CODE (stride) == INTEGER_CST\n-\t  && tree_int_cst_equal (fold_unary (ABS_EXPR, TREE_TYPE (stride),\n-\t\t\t\t\t     stride),\n-\t\t\t\t TYPE_SIZE_UNIT (type)));\n+  if (!DR_IS_WRITE (dr))\n+    return false;\n+\n+  /* If this is a bitfield store bail out.  */\n+  if (TREE_CODE (DR_REF (dr)) == COMPONENT_REF\n+      && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))\n+    return false;\n+\n+  if (!DR_STEP (dr)\n+      || TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n+    return false;\n+\n+  return tree_int_cst_equal (fold_unary (ABS_EXPR, TREE_TYPE (DR_STEP (dr)),\n+\t\t\t\t\t DR_STEP (dr)),\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr))));\n }\n \n /* In tree-data-ref.c  */"}, {"sha": "db4fefc3420119b009762de348c5d3214aed55df", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 57, "deletions": 23, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6b029b8cdf4c17a9f040332b8345f0fa13ed43/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=be6b029b8cdf4c17a9f040332b8345f0fa13ed43", "patch": "@@ -323,15 +323,15 @@ build_size_arg_loc (location_t loc, tree nb_iter, tree op,\n /* Generate a call to memset for PARTITION in LOOP.  */\n \n static void\n-generate_memset_builtin (struct loop *loop, partition_t partition)\n+generate_memset_builtin (struct loop *loop, struct graph *rdg,\n+\t\t\t partition_t partition)\n {\n   gimple_stmt_iterator gsi;\n   gimple stmt, fn_call;\n   tree op0, nb_iter, mem, fn, addr_base, nb_bytes;\n   gimple_seq stmt_list = NULL, stmts;\n   struct data_reference *dr = XCNEW (struct data_reference);\n   location_t loc;\n-  bool res;\n \n   stmt = partition->main_stmt;\n   loc = gimple_location (stmt);\n@@ -344,11 +344,8 @@ generate_memset_builtin (struct loop *loop, partition_t partition)\n   /* The new statements will be placed before LOOP.  */\n   gsi = gsi_last_bb (loop_preheader_edge (loop)->src);\n \n-  DR_STMT (dr) = stmt;\n-  DR_REF (dr) = op0;\n-  res = dr_analyze_innermost (dr, loop_containing_stmt (stmt));\n-  gcc_assert (res && stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0)));\n-\n+  dr = VEC_index (data_reference_p,\n+\t\t  RDG_DATAREFS (rdg, rdg_vertex_for_stmt (rdg, stmt)), 0);\n   nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);\n   addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n   addr_base = fold_convert_loc (loc, sizetype, addr_base);\n@@ -374,8 +371,6 @@ generate_memset_builtin (struct loop *loop, partition_t partition)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"generated memset zero\\n\");\n-\n-  free_data_ref (dr);\n }\n \n /* Remove and destroy the loop LOOP.  */\n@@ -429,13 +424,13 @@ destroy_loop (struct loop *loop)\n /* Generates code for PARTITION.  */\n \n static void\n-generate_code_for_partition (struct loop *loop, partition_t partition,\n-\t\t\t     bool copy_p)\n+generate_code_for_partition (struct loop *loop, struct graph *rdg,\n+\t\t\t     partition_t partition, bool copy_p)\n {\n   switch (partition->kind)\n     {\n     case PKIND_MEMSET:\n-      generate_memset_builtin (loop, partition);\n+      generate_memset_builtin (loop, rdg, partition);\n       /* If this is the last partition for which we generate code, we have\n \t to destroy the loop.  */\n       if (!copy_p)\n@@ -865,16 +860,24 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n       if (gimple_assign_single_p (stmt)\n \t  && !is_gimple_reg (gimple_assign_lhs (stmt)))\n \t{\n+\t  tree rhs;\n \t  if (partition->main_stmt != NULL)\n \t    return;\n \t  partition->main_stmt = stmt;\n+\t  rhs = gimple_assign_rhs1 (stmt);\n+\t  if (!(integer_zerop (rhs) || real_zerop (rhs)))\n+\t    return;\n+\t  if (VEC_length (data_reference_p, RDG_DATAREFS (rdg, i)) != 1)\n+\t    return;\n+\t  if (!adjacent_store_dr_p (VEC_index (data_reference_p,\n+\t\t\t\t\t       RDG_DATAREFS (rdg, i), 0)))\n+\t    return;\n \t}\n       else\n \treturn;\n     }\n \n-  if (partition->main_stmt != NULL\n-      && stmt_with_adjacent_zero_store_dr_p (partition->main_stmt))\n+  if (partition->main_stmt != NULL)\n     partition->kind = PKIND_MEMSET;\n }\n \n@@ -1095,6 +1098,7 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n   VEC (int, heap) *other_stores = VEC_alloc (int, heap, 3);\n   partition_t partition;\n   bitmap processed = BITMAP_ALLOC (NULL);\n+  bool any_builtin;\n \n   remaining_stmts = BITMAP_ALLOC (NULL);\n   upstream_mem_writes = BITMAP_ALLOC (NULL);\n@@ -1129,15 +1133,25 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n \t\t\tprocessed);\n   BITMAP_FREE (processed);\n \n+  any_builtin = false;\n   FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n-    classify_partition (loop, rdg, partition);\n+    {\n+      classify_partition (loop, rdg, partition);\n+      any_builtin |= partition_builtin_p (partition);\n+    }\n \n   /* If we are only distributing patterns fuse all partitions that\n      were not properly classified as builtins.  Else fuse partitions\n      with similar memory accesses.  */\n   if (!flag_tree_loop_distribution)\n     {\n       partition_t into;\n+      /* If we did not detect any builtin simply bail out.  */\n+      if (!any_builtin)\n+\t{\n+\t  nbp = 0;\n+\t  goto ldist_done;\n+\t}\n       for (i = 0; VEC_iterate (partition_t, partitions, i, into); ++i)\n \tif (!partition_builtin_p (into))\n \t  break;\n@@ -1197,7 +1211,7 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n     dump_rdg_partitions (dump_file, partitions);\n \n   FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n-    generate_code_for_partition (loop, partition, i < nbp - 1);\n+    generate_code_for_partition (loop, rdg, partition, i < nbp - 1);\n \n  ldist_done:\n \n@@ -1301,8 +1315,10 @@ tree_loop_distribution (void)\n   FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n     {\n       VEC (gimple, heap) *work_list = NULL;\n+      basic_block *bbs;\n       int num = loop->num;\n       int nb_generated_loops = 0;\n+      unsigned int i;\n \n       /* If the loop doesn't have a single exit we will fail anyway,\n \t so do that early.  */\n@@ -1313,13 +1329,31 @@ tree_loop_distribution (void)\n       if (loop->num_nodes > 2)\n \tcontinue;\n \n-      /* -ftree-loop-distribution strictly distributes more but also\n-         enables pattern detection.  For now simply distribute all stores\n-\t or memset like stores.  */\n-      if (flag_tree_loop_distribution)\n-\tstores_from_loop (loop, &work_list);\n-      else if (flag_tree_loop_distribute_patterns)\n-\tstores_zero_from_loop (loop, &work_list);\n+      /* Initialize the worklist with stmts we seed the partitions with.  */\n+      bbs = get_loop_body_in_dom_order (loop);\n+      for (i = 0; i < loop->num_nodes; ++i)\n+\t{\n+\t  gimple_stmt_iterator gsi;\n+\t  for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\t      /* Only distribute stores for now.\n+\t         ???  We should also try to distribute scalar reductions,\n+\t\t thus SSA defs that have scalar uses outside of the loop.  */\n+\t      if (!gimple_assign_single_p (stmt)\n+\t\t  || is_gimple_reg (gimple_assign_lhs (stmt)))\n+\t\tcontinue;\n+\n+\t      /* If we are only performing pattern detection restrict\n+\t\t what we try to distribute to stores from constants.  */\n+\t      if (!flag_tree_loop_distribution\n+\t\t  && !is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n+\t\tcontinue;\n+\n+\t      VEC_safe_push (gimple, heap, work_list, stmt);\n+\t    }\n+\t}\n+      free (bbs);\n \n       if (VEC_length (gimple, work_list) > 0)\n \tnb_generated_loops = distribute_loop (loop, work_list);"}]}