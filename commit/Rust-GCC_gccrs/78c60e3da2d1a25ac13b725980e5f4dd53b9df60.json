{"sha": "78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhjNjBlM2RhMmQxYTI1YWMxM2I3MjU5ODBlNWY0ZGQ1M2I5ZGY2MA==", "commit": {"author": {"name": "Sharad Singhai", "email": "singhai@google.com", "date": "2012-10-01T05:43:06Z"}, "committer": {"name": "Sharad Singhai", "email": "singhai@gcc.gnu.org", "date": "2012-10-01T05:43:06Z"}, "message": "invoke.texi: Add documentation for the new option.\n\n2012-09-30  Sharad Singhai  <singhai@google.com>\n\n\t* doc/invoke.texi: Add documentation for the new option.\n\t* tree-dump.c: Move general dump file related functionality into\n\tdumpfile.c. Remove unneeded headers.\n\t* tree-dump.h: Move function declarations into dumpfile.h.\n\t* dumpfile.h: Include \"line-map.h\". Add defines for MSG flags.\n\t(struct dump_file_info): Move here from tree-dump.c.  Rename flags\n\tto pflags, state to pstate, stream to pstream, filename to\n\tpfilename. All callers updated. Add alt_flags, alt_state,\n\talt_filenmae, alt_stream.\n\t* tree-vectorizer.c: Include \"dumpfile.h\". Remove vect_dump.\n\t(vect_set_dump_settings): Remove.\n\t(vect_print_dump_info): Ditto.\n\t* tree-vectorizer.h: Remove declaration of vect_dump and\n\tvect_print_dump_info.\n\t* tree-vect-loop.c: Include \"dumpfile.h\". Use new dump style.\n\t* tree-vect-data-refs.c: Ditto.\n\t* tree-vect-stmts.c: Ditto.\n\t* tree-vect-slp.c: Ditto.\n\t* tree-vect-patterns.c: Ditto.\n\t* tree-vect-loop-manip.c: Ditto.\n\t* testsuite/gcc.target/i386/vect-double-1.c: Fix test.\n\t* opts.c (vect_set_verbosity_level): Remove.\n\t(common_handle_option): Handle -fopt-info flag. Deprecate\n\t-ftree-vectorizer-verbose.\n\t* tree-parloops.c (gather_scalar_reductions): Remove reference to\n\tvect_dump.\n\t* flag-types.h: Remove vect_verbosity_levels.\n\t* common.opt: Add -fopt-info. Deprecate -ftree-vectorizer-verbose.\n\t* opts-global.c (dump_remap_tree_vectorizer_verbose): New\n\tfunction.\n\t(handle_common_deferred_options): Handle -fopt-info and\n\t-ftree-vectorizer-verbose.\n\t* Makefile.in: Add dumpfile.o.\n\t(tree-dump.o): Update dependencies.\n\t(tree-vect-loop.o): Ditto.\n\t(tree-vect-loop-manip.o): Ditto.\n\t(tree-vect-slp.o): Ditto.\n\t(tree-vect-stmts.o): Ditto.\n\t(tree-vectorizer.o): Ditto.\n\t(opts.o): Ditto.\n\t* passes.c (finish_optimization_passes): Instead of using\n\tdump_begin/dump_end, use dump_start/dump_finish. Do not use dump_file.\n\t(pass_init_dump_file): Ditto.\n\t* c-decl.c (c_write_global_declarations): Use a different method\n\tto determine if the dump has ben initialized.\n\t* decl2.c (cp_write_global_declarations): Use a different method\n\tto determine if the dump has ben initialized.\n\nFrom-SVN: r191883", "tree": {"sha": "525ba5cb84f1f7d04874c56225d38fe09fea8455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/525ba5cb84f1f7d04874c56225d38fe09fea8455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/comments", "author": null, "committer": null, "parents": [{"sha": "d0cfc26205e59848a644a42790fcb3a76d82a287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cfc26205e59848a644a42790fcb3a76d82a287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0cfc26205e59848a644a42790fcb3a76d82a287"}], "stats": {"total": 4127, "additions": 2137, "deletions": 1990}, "files": [{"sha": "af62cff0f9bfe172c80ea7b9a549fa9ae72ee013", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -1,3 +1,48 @@\n+2012-09-30  Sharad Singhai  <singhai@google.com>\n+\n+\t* doc/invoke.texi: Add documentation for the new -fopt-info option.\n+\t* tree-dump.c: Move general dump file related functionality into\n+\tdumpfile.c. Remove unneeded headers.\n+\t* tree-dump.h: Move function declarations into dumpfile.h.\n+\t* dumpfile.h: Include \"line-map.h\". Add defines for MSG flags.\n+\t(struct dump_file_info): Move here from tree-dump.c.  Rename flags\n+\tto pflags, state to pstate, stream to pstream, filename to\n+\tpfilename. All callers updated. Add alt_flags, alt_state,\n+\talt_filenmae, alt_stream.\n+\t* tree-vectorizer.c: Include \"dumpfile.h\". Remove vect_dump.\n+\t(vect_set_dump_settings): Remove.\n+\t(vect_print_dump_info): Ditto.\n+\t* tree-vectorizer.h: Remove declaration of vect_dump and\n+\tvect_print_dump_info.\n+\t* tree-vect-loop.c: Include \"dumpfile.h\". Use new dump style.\n+\t* tree-vect-data-refs.c: Ditto.\n+\t* tree-vect-stmts.c: Ditto.\n+\t* tree-vect-slp.c: Ditto.\n+\t* tree-vect-patterns.c: Ditto.\n+\t* tree-vect-loop-manip.c: Ditto.\n+\t* testsuite/gcc.target/i386/vect-double-1.c: Fix test.\n+\t* opts.c (vect_set_verbosity_level): Remove.\n+\t(common_handle_option): Handle -fopt-info flag. Deprecate\n+\t-ftree-vectorizer-verbose.\n+\t* tree-parloops.c (gather_scalar_reductions): Remove reference to\n+\tvect_dump.\n+\t* flag-types.h: Remove vect_verbosity_levels.\n+\t* common.opt: Add -fopt-info. Deprecate -ftree-vectorizer-verbose.\n+\t* opts-global.c (dump_remap_tree_vectorizer_verbose): New function.\n+\t(handle_common_deferred_options): Handle -fopt-info and\n+\t-ftree-vectorizer-verbose.\n+\t* Makefile.in: Add dumpfile.o.\n+\t(tree-dump.o): Update dependencies.\n+\t(tree-vect-loop.o): Ditto.\n+\t(tree-vect-loop-manip.o): Ditto.\n+\t(tree-vect-slp.o): Ditto.\n+\t(tree-vect-stmts.o): Ditto.\n+\t(tree-vectorizer.o): Ditto.\n+\t(opts.o): Ditto.\n+\t* passes.c (finish_optimization_passes): Instead of using\n+\tdump_begin/dump_end, use dump_start/dump_finish. Do not use dump_file.\n+\t(pass_init_dump_file): Ditto.\n+\n 2012-09-30  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR rtl-optimization/38449:"}, {"sha": "94ac3b536fe9f15c49bd73c3de1be5a837489b6f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -916,7 +916,7 @@ MKDEPS_H = $(srcdir)/../libcpp/include/mkdeps.h\n SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h $(OBSTACK_H)\n CPP_ID_DATA_H = $(CPPLIB_H) $(srcdir)/../libcpp/include/cpp-id-data.h\n CPP_INTERNAL_H = $(srcdir)/../libcpp/internal.h $(CPP_ID_DATA_H)\n-TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H)\n+TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H) dumpfile.h\n TREE_PASS_H = tree-pass.h $(TIMEVAR_H) dumpfile.h\n TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n \t\t$(BITMAP_H) sbitmap.h $(BASIC_BLOCK_H) $(GIMPLE_H) \\\n@@ -1193,6 +1193,7 @@ OBJS = \\\n \tdomwalk.o \\\n \tdouble-int.o \\\n \tdse.o \\\n+\tdumpfile.o \\\n \tdwarf2asm.o \\\n \tdwarf2cfi.o \\\n \tdwarf2out.o \\\n@@ -2182,9 +2183,8 @@ tree.o: tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_PASS_H) $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) $(CGRAPH_H) \\\n    $(EXCEPT_H) debug.h intl.h tree-diagnostic.h $(TREE_PRETTY_PRINT_H) \\\n    $(COMMON_TARGET_H)\n-tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) langhooks.h toplev.h $(SPLAY_TREE_H) $(TREE_DUMP_H) \\\n-   tree-iterator.h $(TREE_PASS_H) $(DIAGNOSTIC_H)\n+tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \\\n+   langhooks.h $(TREE_DUMP_H) tree-iterator.h\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(FLAGS_H) $(PARAMS_H) $(INPUT_H) insn-config.h \\\n    $(HASHTAB_H) langhooks.h $(TREE_INLINE_H) $(CGRAPH_H) \\\n@@ -2544,12 +2544,12 @@ graphite-optimize-isl.o : graphite-optimize-isl.c $(CONFIG_H) $(SYSTEM_H) \\\n     coretypes.h dumpfile.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(SCEV_H) \\\n     sese.h graphite-poly.h\n tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n+   $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) dumpfile.h \\\n    $(CFGLOOP_H) $(EXPR_H) $(RECOG_H) $(OPTABS_H) \\\n    $(DIAGNOSTIC_CORE_H) $(SCEV_H) $(TREE_VECTORIZER_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) $(TARGET_H) $(TREE_DATA_REF_H)\n tree-vect-loop-manip.o: tree-vect-loop-manip.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) \\\n+   coretypes.h dumpfile.h $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) $(CFGLOOP_H) $(DIAGNOSTIC_CORE_H) \\\n    $(SCEV_H) $(TREE_VECTORIZER_H) langhooks.h $(GIMPLE_PRETTY_PRINT_H)\n tree-vect-patterns.o: tree-vect-patterns.c $(CONFIG_H) $(SYSTEM_H) \\\n@@ -2558,8 +2558,8 @@ tree-vect-patterns.o: tree-vect-patterns.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_FLOW_H) $(CFGLOOP_H) $(EXPR_H) $(OPTABS_H) $(PARAMS_H) \\\n    $(TREE_DATA_REF_H) $(TREE_VECTORIZER_H) $(RECOG_H) $(DIAGNOSTIC_CORE_H) \\\n    $(GIMPLE_PRETTY_PRINT_H)\n-tree-vect-slp.o: tree-vect-slp.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \\\n+tree-vect-slp.o: tree-vect-slp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   dumpfile.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(CFGLOOP_H) \\\n    $(EXPR_H) $(RECOG_H) $(OPTABS_H) $(TREE_VECTORIZER_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) $(TREE_DATA_REF_H) langhooks.h\n@@ -2574,7 +2574,7 @@ tree-vect-data-refs.o: tree-vect-data-refs.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(EXPR_H) $(OPTABS_H) $(SCEV_H) $(TREE_VECTORIZER_H) \\\n    $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(GIMPLE_PRETTY_PRINT_H)\n tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TM_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) \\\n+   dumpfile.h $(TM_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) \\\n    $(CFGLOOP_H) $(TREE_PASS_H) $(TREE_VECTORIZER_H) \\\n    $(TREE_PRETTY_PRINT_H)\n tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) \\\n@@ -2623,7 +2623,7 @@ diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    version.h $(DEMANGLE_H) $(INPUT_H) intl.h $(BACKTRACE_H) $(DIAGNOSTIC_H) \\\n    diagnostic.def\n opts.o : opts.c $(OPTS_H) $(OPTIONS_H) $(DIAGNOSTIC_CORE_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) \\\n+   coretypes.h dumpfile.h $(TM_H) \\\n    $(DIAGNOSTIC_H) insn-attr-common.h intl.h $(COMMON_TARGET_H) \\\n    $(FLAGS_H) $(PARAMS_H) opts-diagnostic.h\n opts-global.o : opts-global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -2923,6 +2923,8 @@ dce.o : dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) $(EXCEPT_H) $(DF_H) cselib.h \\\n    $(DBGCNT_H) dce.h $(VALTRACK_H) $(TREE_PASS_H) $(DBGCNT_H) $(TM_P_H) \\\n    $(EMIT_RTL_H)\n+dumpfile.o: dumpfile.c dumpfile.h $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(DIAGNOSTIC_CORE_H) $(GIMPLE_PRETTY_PRINT_H) $(TREE_H)\n dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) \\"}, {"sha": "1e27e2c1e25f89e7bf09107a27b0fb7d36302e75", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -2535,7 +2535,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n   int is_class = false;\n   tree name = TYPE_NAME (TREE_TYPE (t));\n   tree decl_name = DECL_NAME (t);\n-  bool dump_internal = get_dump_file_info (TDI_ada)->flags & TDF_RAW;\n+  bool dump_internal = get_dump_file_info (TDI_ada)->pflags & TDF_RAW;\n   tree orig = NULL_TREE;\n \n   if (cpp_check && cpp_check (t, IS_TEMPLATE))"}, {"sha": "770683c6ab57dae537ef172caa842c8be65fc44a", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -1,3 +1,8 @@\n+2012-09-30  Sharad Singhai  <singhai@google.com>\n+\n+\t* c-decl.c (c_write_global_declarations): Use a different method\n+\tto determine if the dump has ben initialized.\n+\n 2012-09-14  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/54552"}, {"sha": "1b4d764ca4953d6f446278bab66f9c05fbf01983", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -10079,10 +10079,10 @@ c_write_global_declarations (void)\n   gcc_assert (!current_scope);\n \n   /* Handle -fdump-ada-spec[-slim]. */\n-  if (dump_enabled_p (TDI_ada))\n+  if (dump_initialized_p (TDI_ada))\n     {\n       /* Build a table of files to generate specs for */\n-      if (get_dump_file_info (TDI_ada)->flags & TDF_SLIM)\n+      if (get_dump_file_info (TDI_ada)->pflags & TDF_SLIM)\n \tcollect_source_ref (main_input_filename);\n       else\n \tfor_each_global_decl (collect_source_ref_cb);"}, {"sha": "f0e757ca6fa577e58b58ec58c87c05401727bde2", "filename": "gcc/common.opt", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -141,9 +141,6 @@ bool use_gnu_debug_info_extensions\n Variable\n unsigned int initial_max_fld_align = TARGET_DEFAULT_PACK_STRUCT\n \n-Variable\n-enum vect_verbosity_levels user_vect_verbosity_level = MAX_VERBOSITY_LEVEL\n-\n ; Type of stack check.\n Variable\n enum stack_check_type flag_stack_check = NO_STACK_CHECK\n@@ -1536,6 +1533,14 @@ fomit-frame-pointer\n Common Report Var(flag_omit_frame_pointer) Optimization\n When possible do not generate stack frames\n \n+fopt-info\n+Common Report Var(flag_opt_info) Optimization\n+Enable all optimization info dumps on stderr\n+\n+fopt-info-\n+Common Joined RejectNegative Var(common_deferred_options) Defer\n+-fopt-info[-<type>=filename]\tDump compiler optimization details\n+\n foptimize-register-move\n Common Report Var(flag_regmove) Optimization\n Do the full register move optimization pass\n@@ -2195,6 +2200,10 @@ ftree-vectorize\n Common Report Var(flag_tree_vectorize) Optimization\n Enable loop vectorization on trees\n \n+ftree-vectorizer-verbose=\n+Common RejectNegative Joined UInteger Var(common_deferred_options) Defer\n+-ftree-vectorizer-verbose=<number>\tThis switch is deprecated. Use -fopt-info instead.\n+\n ftree-slp-vectorize\n Common Report Var(flag_tree_slp_vectorize) Init(2) Optimization\n Enable basic block vectorization (SLP) on trees\n@@ -2207,10 +2216,6 @@ ftree-vect-loop-version\n Common Report Var(flag_tree_vect_loop_version) Init(1) Optimization\n Enable loop versioning when doing loop vectorization on trees\n \n-ftree-vectorizer-verbose=\n-Common RejectNegative Joined UInteger\n--ftree-vectorizer-verbose=<number>\tSet the verbosity level of the vectorizer\n-\n ftree-scev-cprop\n Common Report Var(flag_tree_scev_cprop) Init(1) Optimization\n Enable copy propagation of scalar-evolution information."}, {"sha": "2fa9565a201a7bf94a75a5c3771645ab40a6045b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -1,3 +1,8 @@\n+2012-09-30  Sharad Singhai  <singhai@google.com>\n+\n+\t* decl2.c (cp_write_global_declarations): Use a different method\n+\tto determine if the dump has ben initialized.\n+\n 2012-09-29  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/54738"}, {"sha": "9b1a5a1856dbbbec569a4d541eae1070da5aa886", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -3698,9 +3698,9 @@ cp_write_global_declarations (void)\n   cgraph_process_same_body_aliases ();\n \n   /* Handle -fdump-ada-spec[-slim] */\n-  if (dump_enabled_p (TDI_ada))\n+  if (dump_initialized_p (TDI_ada))\n     {\n-      if (get_dump_file_info (TDI_ada)->flags & TDF_SLIM)\n+      if (get_dump_file_info (TDI_ada)->pflags & TDF_SLIM)\n \tcollect_source_ref (main_input_filename);\n       else\n \tcollect_source_refs (global_namespace);"}, {"sha": "205faa7015e09a1fe1df467708ae630c6de2fe18", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 125, "deletions": 40, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -330,6 +330,8 @@ Objective-C and Objective-C++ Dialects}.\n -fenable-@var{kind}-@var{pass}=@var{range-list} @gol\n -fdebug-types-section -fmem-report-wpa @gol\n -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol\n+-fopt-info @gol\n+-fopt-info-@var{options}@r{[}=@var{file}@r{]} @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n -fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol\n -fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol\n@@ -5350,20 +5352,23 @@ Here are some examples showing uses of these options.\n \n @item -d@var{letters}\n @itemx -fdump-rtl-@var{pass}\n+@itemx -fdump-rtl-@var{pass}=@var{filename}\n @opindex d\n Says to make debugging dumps during compilation at times specified by\n @var{letters}.  This is used for debugging the RTL-based passes of the\n compiler.  The file names for most of the dumps are made by appending\n a pass number and a word to the @var{dumpname}, and the files are\n-created in the directory of the output file.  Note that the pass\n-number is computed statically as passes get registered into the pass\n-manager.  Thus the numbering is not related to the dynamic order of\n-execution of passes.  In particular, a pass installed by a plugin\n-could have a number over 200 even if it executed quite early.\n-@var{dumpname} is generated from the name of the output file, if\n-explicitly specified and it is not an executable, otherwise it is the\n-basename of the source file. These switches may have different effects\n-when @option{-E} is used for preprocessing.\n+created in the directory of the output file. In case of\n+@option{=@var{filename}} option, the dump is output on the given file\n+instead of the pass numbered dump files. Note that the pass number is\n+computed statically as passes get registered into the pass manager.\n+Thus the numbering is not related to the dynamic order of execution of\n+passes.  In particular, a pass installed by a plugin could have a\n+number over 200 even if it executed quite early.  @var{dumpname} is\n+generated from the name of the output file, if explicitly specified\n+and it is not an executable, otherwise it is the basename of the\n+source file. These switches may have different effects when\n+@option{-E} is used for preprocessing.\n \n Debug dumps can be enabled with a @option{-fdump-rtl} switch or some\n @option{-d} option @var{letters}.  Here are the possible\n@@ -5744,15 +5749,18 @@ counters for each function compiled.\n \n @item -fdump-tree-@var{switch}\n @itemx -fdump-tree-@var{switch}-@var{options}\n+@itemx -fdump-tree-@var{switch}-@var{options}=@var{filename}\n @opindex fdump-tree\n Control the dumping at various stages of processing the intermediate\n language tree to a file.  The file name is generated by appending a\n switch-specific suffix to the source file name, and the file is\n-created in the same directory as the output file.  If the\n-@samp{-@var{options}} form is used, @var{options} is a list of\n-@samp{-} separated options which control the details of the dump.  Not\n-all options are applicable to all dumps; those that are not\n-meaningful are ignored.  The following options are available\n+created in the same directory as the output file. In case of\n+@option{=@var{filename}} option, the dump is output on the given file\n+instead of the auto named dump files.  If the @samp{-@var{options}}\n+form is used, @var{options} is a list of @samp{-} separated options\n+which control the details of the dump.  Not all options are applicable\n+to all dumps; those that are not meaningful are ignored.  The\n+following options are available\n \n @table @samp\n @item address\n@@ -5772,7 +5780,8 @@ trees, this option inhibits dumping the bodies of control structures.\n Print a raw representation of the tree.  By default, trees are\n pretty-printed into a C-like representation.\n @item details\n-Enable more detailed dumps (not honored by every dump option).\n+Enable more detailed dumps (not honored by every dump option). Also\n+include information from the optimization passes.\n @item stats\n Enable dumping various statistics about the pass (not honored by every dump\n option).\n@@ -5790,9 +5799,38 @@ Enable showing the tree dump for each statement.\n Enable showing the EH region number holding each statement.\n @item scev\n Enable showing scalar evolution analysis details.\n+@item optimized\n+Enable showing optimization information (only available in certain\n+passes).\n+@item missed\n+Enable showing missed optimization information (only available in certain\n+passes).\n+@item notes\n+Enable other detailed optimization information (only available in\n+certain passes).\n+@item =@var{filename}\n+Instead of an auto named dump file, output into the given file\n+name. The file names @file{stdout} and @file{stderr} are treated\n+specially and are considered already open standard streams. For\n+example,\n+\n+@smallexample\n+gcc -O2 -ftree-vectorize -fdump-tree-vect-blocks=foo.dump\n+     -fdump-tree-pre=stderr file.c\n+@end smallexample\n+\n+outputs vectorizer dump into @file{foo.dump}, while the PRE dump is\n+output on to @file{stderr}. If two conflicting dump filenames are\n+given for the same pass, then the latter option overrides the earlier\n+one.\n+\n @item all\n Turn on all options, except @option{raw}, @option{slim}, @option{verbose}\n and @option{lineno}.\n+\n+@item optall\n+Turn on all optimization options, i.e., @option{optimized},\n+@option{missed}, and @option{note}.\n @end table\n \n The following tree dumps are possible:\n@@ -5940,33 +5978,80 @@ is made by appending @file{.vrp} to the source file name.\n Enable all the available tree dumps with the flags provided in this option.\n @end table\n \n+@item -fopt-info\n+@itemx -fopt-info-@var{options}\n+@itemx -fopt-info-@var{options}=@var{filename}\n+@opindex fopt-info\n+Controls optimization dumps from all the passes. If the\n+@samp{-@var{options}} form is used, @var{options} is a list of\n+@samp{-} separated options to control the dump details.  If\n+@var{options} is not specified, it defaults to @option{optall}. If the\n+@var{filename} is not specified, it defaults to @file{stderr}. Note\n+that the output @var{filename} will be overwritten in case of multiple\n+translation units. If a combined output from multiple translation\n+units is desired, @file{stderr} should be used instead.\n+\n+The following options are available\n+\n+@table @samp\n+@item optimized\n+Print information when an optimization is successfully applied. It is\n+up to a pass to decide which information is relevant. For example, the\n+vectorizer pass prints the location of loop which got vectorized.\n+@item missed\n+Print information about missed optimizations. Individual passes\n+control which information to include in the output. For example,\n+\n+@smallexample\n+gcc -O2 -ftree-vectorize -fopt-info-missed\n+@end smallexample\n+\n+will print information about missed optimization opportunities on\n+stderr.\n+@item note\n+Print verbose information about optimizations, such as certain\n+transformations, more detailed messages about decisions etc.\n+@item optall\n+Print detailed optimization information. This includes\n+@var{optimized}, @var{missed}, and @var{note}. For example,\n+\n+@smallexample\n+gcc -O2 -ftree-vectorize -fopt-info-optall=opt.all\n+@end smallexample\n+\n+outputs detailed optimization report from all the passes into\n+@file{opt.all}.\n+@end table\n+\n+It applies the dump options to all the passes. If the @var{filename}\n+is provided, the dump from all the passes is concatenated, otherwise\n+the dump is output onto @file{stderr}. If @var{options} is omitted, it\n+defaults to @option{optall}.\n+\n+@smallexample\n+gcc -O3 -fopt-info-optimized-missed=optdump.txt\n+@end smallexample\n+\n+This will output information about missed optimizations as well as\n+optimized locations from all the passes into @file{optdump.txt}.\n+\n @item -ftree-vectorizer-verbose=@var{n}\n @opindex ftree-vectorizer-verbose\n-This option controls the amount of debugging output the vectorizer prints.\n-This information is written to standard error, unless\n-@option{-fdump-tree-all} or @option{-fdump-tree-vect} is specified,\n-in which case it is output to the usual dump listing file, @file{.vect}.\n-For @var{n}=0 no diagnostic information is reported.\n-If @var{n}=1 the vectorizer reports each loop that got vectorized,\n-and the total number of loops that got vectorized.\n-If @var{n}=2 the vectorizer also reports non-vectorized loops that passed\n-the first analysis phase (vect_analyze_loop_form) - i.e.@: countable,\n-inner-most, single-bb, single-entry/exit loops.  This is the same verbosity\n-level that @option{-fdump-tree-vect-stats} uses.\n-Higher verbosity levels mean either more information dumped for each\n-reported loop, or same amount of information reported for more loops:\n-if @var{n}=3, vectorizer cost model information is reported.\n-If @var{n}=4, alignment related information is added to the reports.\n-If @var{n}=5, data-references related information (e.g.@: memory dependences,\n-memory access-patterns) is added to the reports.\n-If @var{n}=6, the vectorizer reports also non-vectorized inner-most loops\n-that did not pass the first analysis phase (i.e., may not be countable, or\n-may have complicated control-flow).\n-If @var{n}=7, the vectorizer reports also non-vectorized nested loops.\n-If @var{n}=8, SLP related information is added to the reports.\n-For @var{n}=9, all the information the vectorizer generates during its\n-analysis and transformation is reported.  This is the same verbosity level\n-that @option{-fdump-tree-vect-details} uses.\n+This option is deprecated and is implemented in terms of\n+@option{-fopt-info}. Please use @option{-fopt-info-@var{kind}} form\n+instead, where @var{kind} is one of the valid opt-info options. It\n+prints additional optimization information.  For @var{n}=0 no\n+diagnostic information is reported.  If @var{n}=1 the vectorizer\n+reports each loop that got vectorized, and the total number of loops\n+that got vectorized.  If @var{n}=2 the vectorizer reports locations\n+which could not be vectorized and the reasons for those. For any\n+higher verbosity levels all the analysis and transformation\n+information from the vectorizer is reported.\n+\n+Note that the information output by @option{-ftree-vectorizer-verbose}\n+option is sent to @file{stderr}. If the equivalent form\n+@option{-fopt-info-@var{options}=@var{filename}} is used then the\n+output is sent into @var{filename} instead.\n \n @item -frandom-seed=@var{string}\n @opindex frandom-seed"}, {"sha": "cbaf47de4221fa356b77eba88ebd01c2d990310f", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_DUMPFILE_H\n #define GCC_DUMPFILE_H 1\n \n+#include \"line-map.h\"\n+\n /* Different tree dump places.  When you add new tree dump places,\n    extend the DUMP_FILES array in tree-dump.c.  */\n enum tree_dump_index\n@@ -43,9 +45,11 @@ enum tree_dump_index\n   TDI_end\n };\n \n-/* Bit masks to control dumping. Not all values are applicable to\n-   all dumps. Add new ones at the end. When you define new\n-   values, extend the DUMP_OPTIONS array in tree-dump.c */\n+/* Bit masks to control dumping. Not all values are applicable to all\n+   dumps. Add new ones at the end. When you define new values, extend\n+   the DUMP_OPTIONS array in tree-dump.c. The TDF_* flags coexist with\n+   MSG_* flags (for -fopt-info) and the bit values must be chosen\n+   to allow that.  */\n #define TDF_ADDRESS\t(1 << 0)\t/* dump node addresses */\n #define TDF_SLIM\t(1 << 1)\t/* don't go wild following links */\n #define TDF_RAW  \t(1 << 2)\t/* don't unparse the function */\n@@ -82,18 +86,59 @@ enum tree_dump_index\n #define TDF_CSELIB\t(1 << 23)\t/* Dump cselib details.  */\n #define TDF_SCEV\t(1 << 24)\t/* Dump SCEV details.  */\n #define TDF_COMMENT\t(1 << 25)\t/* Dump lines with prefix \";;\"  */\n+#define MSG_OPTIMIZED_LOCATIONS  (1 << 26)  /* -fopt-info optimized sources */\n+#define MSG_MISSED_OPTIMIZATION  (1 << 27)  /* missed opportunities */\n+#define MSG_NOTE                 (1 << 28)  /* general optimization info */\n+#define MSG_ALL         (MSG_OPTIMIZED_LOCATIONS | MSG_MISSED_OPTIMIZATION \\\n+                         | MSG_NOTE)\n \n+/* Define a tree dump switch.  */\n+struct dump_file_info\n+{\n+  const char *suffix;           /* suffix to give output file.  */\n+  const char *swtch;            /* command line dump switch */\n+  const char *glob;             /* command line glob  */\n+  const char *pfilename;        /* filename for the pass-specific stream  */\n+  const char *alt_filename;     /* filename for the opt-info stream  */\n+  FILE *pstream;                /* pass-specific dump stream  */\n+  FILE *alt_stream;             /* opt-info stream */\n+  int pflags;                   /* dump flags */\n+  int alt_flags;                /* flags for opt-info */\n+  int pstate;                   /* state of pass-specific stream */\n+  int alt_state;                /* state of the opt-info stream */\n+  int num;                      /* dump file number */\n+};\n \n-/* In tree-dump.c */\n \n+/* In dumpfile.c */\n extern char *get_dump_file_name (int);\n-extern int dump_enabled_p (int);\n extern int dump_initialized_p (int);\n extern FILE *dump_begin (int, int *);\n extern void dump_end (int, FILE *);\n+extern int dump_start (int, int *);\n+extern void dump_finish (int);\n extern void dump_node (const_tree, int, FILE *);\n extern int dump_switch_p (const char *);\n+extern int opt_info_switch_p (const char *);\n extern const char *dump_flag_name (int);\n+extern bool dump_kind_p (int);\n+extern void dump_printf (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n+extern void dump_printf_loc (int, source_location,\n+                             const char *, ...) ATTRIBUTE_PRINTF_3;\n+extern void dump_basic_block (int, basic_block, int);\n+extern void dump_generic_expr_loc (int, source_location, int, tree);\n+extern void dump_generic_expr (int, int, tree);\n+extern void dump_gimple_stmt_loc (int, source_location, int, gimple, int);\n+extern void dump_gimple_stmt (int, int, gimple, int);\n+extern void print_combine_total_stats (void);\n+extern unsigned int dump_register (const char *, const char *, const char *,\n+                                   int);\n+extern bool enable_rtl_dump_file (void);\n+\n+/* In combine.c  */\n+extern void dump_combine_total_stats (FILE *);\n+/* In cfghooks.c  */\n+extern void dump_bb (FILE *, basic_block, int, int);\n \n /* Global variables used to communicate with passes.  */\n extern FILE *dump_file;\n@@ -103,16 +148,4 @@ extern const char *dump_file_name;\n /* Return the dump_file_info for the given phase.  */\n extern struct dump_file_info *get_dump_file_info (int);\n \n-/* Define a tree dump switch.  */\n-struct dump_file_info\n-{\n-  const char *suffix;           /* suffix to give output file.  */\n-  const char *swtch;            /* command line switch */\n-  const char *glob;             /* command line glob  */\n-  int flags;                    /* user flags */\n-  int state;                    /* state of play */\n-  int num;                      /* dump file number */\n-};\n-\n-\n #endif /* GCC_DUMPFILE_H */"}, {"sha": "d6c2610072d28c0094888b0f1dd429baa4ca7e77", "filename": "gcc/flag-types.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -200,20 +200,4 @@ enum fp_contract_mode {\n   FP_CONTRACT_FAST = 2\n };\n \n-/* Vectorizer verbosity levels.  */\n-enum vect_verbosity_levels {\n-  REPORT_NONE,\n-  REPORT_VECTORIZED_LOCATIONS,\n-  REPORT_UNVECTORIZED_LOCATIONS,\n-  REPORT_COST,\n-  REPORT_ALIGNMENT,\n-  REPORT_DR_DETAILS,\n-  REPORT_BAD_FORM_LOOPS,\n-  REPORT_OUTER_LOOPS,\n-  REPORT_SLP,\n-  REPORT_DETAILS,\n-  /* New verbosity levels should be added before this one.  */\n-  MAX_VERBOSITY_LEVEL\n-};\n-\n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "ccbfeef247fe8889f223da00d4315b8284680d69", "filename": "gcc/opts-global.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fopts-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fopts-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-global.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -233,6 +233,40 @@ read_cmdline_options (struct gcc_options *opts, struct gcc_options *opts_set,\n     }\n }\n \n+/* Handle -ftree-vectorizer-verbose=ARG by remapping it to -fopt-info.\n+   It remaps the old verbosity values as following:\n+\n+   REPORT_NONE ==> No dump is output\n+   REPORT_VECTORIZED_LOCATIONS ==> \"-optimized\"\n+   REPORT_UNVECTORIZED_LOCATIONS ==> \"-missed\"\n+\n+   Any higher verbosity levels get mapped to \"-optall\" flags.  */\n+\n+static void\n+dump_remap_tree_vectorizer_verbose (const char *arg)\n+{\n+  int value = atoi (arg);\n+  const char *remapped_opt_info = NULL;\n+\n+  switch (value)\n+    {\n+    case 0:\n+      break;\n+    case 1:\n+      remapped_opt_info = \"optimized\";\n+      break;\n+    case 2:\n+      remapped_opt_info = \"missed\";\n+      break;\n+    default:\n+      remapped_opt_info = \"optall\";\n+      break;\n+    }\n+\n+  if (remapped_opt_info)\n+    opt_info_switch_p (remapped_opt_info);\n+}\n+\n /* Language mask determined at initialization.  */\n static unsigned int initial_lang_mask;\n \n@@ -322,6 +356,9 @@ handle_common_deferred_options (void)\n   if (flag_dump_all_passed)\n     enable_rtl_dump_file ();\n \n+  if (flag_opt_info)\n+    opt_info_switch_p (NULL);\n+\n   FOR_EACH_VEC_ELT (cl_deferred_option, vec, i, opt)\n     {\n       switch (opt->opt_index)\n@@ -351,6 +388,12 @@ handle_common_deferred_options (void)\n \t    error (\"unrecognized command line option %<-fdump-%s%>\", opt->arg);\n \t  break;\n \n+        case OPT_fopt_info_:\n+\t  if (!opt_info_switch_p (opt->arg))\n+\t    error (\"unrecognized command line option %<-fopt-info%s%>\",\n+                   opt->arg);\n+          break;\n+\n \tcase OPT_fenable_:\n \tcase OPT_fdisable_:\n \t  if (opt->opt_index == OPT_fenable_)\n@@ -410,6 +453,10 @@ handle_common_deferred_options (void)\n \t  stack_limit_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (opt->arg));\n \t  break;\n \n+        case OPT_ftree_vectorizer_verbose_:\n+\t  dump_remap_tree_vectorizer_verbose (opt->arg);\n+          break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "8608a56dfe35b9a6219660592147c8a3b63faa25", "filename": "gcc/opts.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -139,19 +139,6 @@ set_struct_debug_option (struct gcc_options *opts, location_t loc,\n     }\n }\n \n-/* Handle -ftree-vectorizer-verbose=VAL for options OPTS.  */\n-\n-static void\n-vect_set_verbosity_level (struct gcc_options *opts, int val)\n-{\n-   if (val < MAX_VERBOSITY_LEVEL)\n-     opts->x_user_vect_verbosity_level = (enum vect_verbosity_levels) val;\n-   else\n-     opts->x_user_vect_verbosity_level\n-      = (enum vect_verbosity_levels) (MAX_VERBOSITY_LEVEL - 1);\n-}\n-\n-\n /* Strip off a legitimate source ending from the input string NAME of\n    length LEN.  Rather than having to know the names used by all of\n    our front ends, we strip off an ending of a period followed by\n@@ -1559,6 +1546,11 @@ common_handle_option (struct gcc_options *opts,\n       diagnostic_set_caret_max_width (dc, value);\n       break;\n \n+    case OPT_fopt_info:\n+    case OPT_fopt_info_:\n+      /* Deferred.  */\n+      break;\n+\n     case OPT_fpack_struct_:\n       if (value <= 0 || (value & (value - 1)) || value > 16)\n \terror_at (loc,\n@@ -1694,7 +1686,9 @@ common_handle_option (struct gcc_options *opts,\n       break;\n \n     case OPT_ftree_vectorizer_verbose_:\n-      vect_set_verbosity_level (opts, value);\n+      /* -ftree-vectorizer-verbose is deprecated. It is defined in\n+         -terms of fopt-info=N. */\n+      /* Deferred.  */\n       break;\n \n     case OPT_g:"}, {"sha": "86c8255450c455ec35c6c20d15910d0e85fdea87", "filename": "gcc/passes.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -231,27 +231,23 @@ finish_optimization_passes (void)\n   timevar_push (TV_DUMP);\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n-      dump_file = dump_begin (pass_profile.pass.static_pass_number, NULL);\n+      dump_start (pass_profile.pass.static_pass_number, NULL);\n       end_branch_prob ();\n-      if (dump_file)\n-\tdump_end (pass_profile.pass.static_pass_number, dump_file);\n+      dump_finish (pass_profile.pass.static_pass_number);\n     }\n \n   if (optimize > 0)\n     {\n-      dump_file = dump_begin (pass_combine.pass.static_pass_number, NULL);\n-      if (dump_file)\n-\t{\n-\t  dump_combine_total_stats (dump_file);\n-          dump_end (pass_combine.pass.static_pass_number, dump_file);\n-\t}\n+      dump_start (pass_profile.pass.static_pass_number, NULL);\n+      print_combine_total_stats ();\n+      dump_finish (pass_combine.pass.static_pass_number);\n     }\n \n   /* Do whatever is necessary to finish printing the graphs.  */\n   if (graph_dump_format != no_graph)\n     for (i = TDI_end; (dfi = get_dump_file_info (i)) != NULL; ++i)\n       if (dump_initialized_p (i)\n-\t  && (dfi->flags & TDF_GRAPH) != 0\n+\t  && (dfi->pflags & TDF_GRAPH) != 0\n \t  && (name = get_dump_file_name (i)) != NULL)\n \t{\n \t  finish_graph_dump_file (name);\n@@ -1238,9 +1234,9 @@ register_pass (struct register_pass_info *pass_info)\n       else\n         tdi = TDI_rtl_all;\n       /* Check if dump-all flag is specified.  */\n-      if (get_dump_file_info (tdi)->state)\n+      if (get_dump_file_info (tdi)->pstate)\n         get_dump_file_info (added_pass_nodes->pass->static_pass_number)\n-            ->state = get_dump_file_info (tdi)->state;\n+            ->pstate = get_dump_file_info (tdi)->pstate;\n       XDELETE (added_pass_nodes);\n       added_pass_nodes = next_node;\n     }\n@@ -1945,7 +1941,7 @@ pass_init_dump_file (struct opt_pass *pass)\n     {\n       bool initializing_dump = !dump_initialized_p (pass->static_pass_number);\n       dump_file_name = get_dump_file_name (pass->static_pass_number);\n-      dump_file = dump_begin (pass->static_pass_number, &dump_flags);\n+      dump_start (pass->static_pass_number, &dump_flags);\n       if (dump_file && current_function_decl)\n         dump_function_header (dump_file, current_function_decl, dump_flags);\n       return initializing_dump;\n@@ -1967,11 +1963,7 @@ pass_fini_dump_file (struct opt_pass *pass)\n       dump_file_name = NULL;\n     }\n \n-  if (dump_file)\n-    {\n-      dump_end (pass->static_pass_number, dump_file);\n-      dump_file = NULL;\n-    }\n+  dump_finish (pass->static_pass_number);\n }\n \n /* After executing the pass, apply expected changes to the function\n@@ -2213,7 +2205,7 @@ execute_one_pass (struct opt_pass *pass)\n       && (cfun->curr_properties & (PROP_cfg | PROP_rtl))\n \t  == (PROP_cfg | PROP_rtl))\n     {\n-      get_dump_file_info (pass->static_pass_number)->flags |= TDF_GRAPH;\n+      get_dump_file_info (pass->static_pass_number)->pflags |= TDF_GRAPH;\n       dump_flags |= TDF_GRAPH;\n       clean_graph_dump_file (dump_file_name);\n     }"}, {"sha": "1b3eefbd263a8327cb22a3432d31c17bc12a1c9d", "filename": "gcc/statistics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -255,7 +255,7 @@ void\n statistics_init (void)\n {\n   statistics_dump_file = dump_begin (statistics_dump_nr, NULL);\n-  statistics_dump_flags = get_dump_file_info (statistics_dump_nr)->flags;\n+  statistics_dump_flags = get_dump_file_info (statistics_dump_nr)->pflags;\n }\n \n /* Lookup or add a statistics counter in the hashtable HASH with ID, VAL"}, {"sha": "d96d6399ccdbff7b196ad1a7ed2f8dd895dddff3", "filename": "gcc/testsuite/gcc.target/i386/vect-double-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-double-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-double-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-double-1.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -32,5 +32,5 @@ sse2_test (void)\n     }\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorized loops: 1\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a1511ea7eea443d378c79e5506994d4f5adffd31", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 16, "deletions": 366, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -26,17 +26,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"splay-tree.h\"\n #include \"filenames.h\"\n-#include \"diagnostic-core.h\"\n-#include \"toplev.h\"\n #include \"tree-dump.h\"\n #include \"langhooks.h\"\n #include \"tree-iterator.h\"\n \n-/* If non-NULL, return one past-the-end of the matching SUBPART of\n-   the WHOLE string.  */\n-#define skip_leading_substring(whole,  part) \\\n-   (strncmp (whole, part, strlen (part)) ? NULL : whole + strlen (part))\n-\n static unsigned int queue (dump_info_p, const_tree, int);\n static void dump_index (dump_info_p, unsigned int);\n static void dequeue_and_dump (dump_info_p);\n@@ -162,6 +155,22 @@ dump_maybe_newline (dump_info_p di)\n     }\n }\n \n+/* Dump FUNCTION_DECL FN as tree dump PHASE.  */\n+\n+void\n+dump_function (int phase, tree fn)\n+{\n+  FILE *stream;\n+  int flags;\n+\n+  stream = dump_begin (phase, &flags);\n+  if (stream)\n+    {\n+      dump_function_to_file (fn, stream, flags);\n+      dump_end (phase, stream);\n+    }\n+}\n+\n /* Dump pointer PTR using FIELD to identify it.  */\n \n void\n@@ -766,362 +775,3 @@ dump_node (const_tree t, int flags, FILE *stream)\n     }\n   splay_tree_delete (di.nodes);\n }\n-\f\n-\n-/* Table of tree dump switches. This must be consistent with the\n-   tree_dump_index enumeration in tree-pass.h.  */\n-static struct dump_file_info dump_files[TDI_end] =\n-{\n-  {NULL, NULL, NULL, 0, 0, 0},\n-  {\".cgraph\", \"ipa-cgraph\", NULL, TDF_IPA, 0,  0},\n-  {\".tu\", \"translation-unit\", NULL, TDF_TREE, 0, 1},\n-  {\".class\", \"class-hierarchy\", NULL, TDF_TREE, 0, 2},\n-  {\".original\", \"tree-original\", NULL, TDF_TREE, 0, 3},\n-  {\".gimple\", \"tree-gimple\", NULL, TDF_TREE, 0, 4},\n-  {\".nested\", \"tree-nested\", NULL, TDF_TREE, 0, 5},\n-  {\".vcg\", \"tree-vcg\", NULL, TDF_TREE, 0, 6},\n-  {\".ads\", \"ada-spec\", NULL, 0, 0, 7},\n-#define FIRST_AUTO_NUMBERED_DUMP 8\n-\n-  {NULL, \"tree-all\", NULL, TDF_TREE, 0, 0},\n-  {NULL, \"rtl-all\", NULL, TDF_RTL, 0, 0},\n-  {NULL, \"ipa-all\", NULL, TDF_IPA, 0, 0},\n-};\n-\n-/* Dynamically registered tree dump files and switches.  */\n-static struct dump_file_info *extra_dump_files;\n-static size_t extra_dump_files_in_use;\n-static size_t extra_dump_files_alloced;\n-\n-/* Define a name->number mapping for a dump flag value.  */\n-struct dump_option_value_info\n-{\n-  const char *const name;\t/* the name of the value */\n-  const int value;\t\t/* the value of the name */\n-};\n-\n-/* Table of dump options. This must be consistent with the TDF_* flags\n-   in tree.h */\n-static const struct dump_option_value_info dump_options[] =\n-{\n-  {\"address\", TDF_ADDRESS},\n-  {\"asmname\", TDF_ASMNAME},\n-  {\"slim\", TDF_SLIM},\n-  {\"raw\", TDF_RAW},\n-  {\"graph\", TDF_GRAPH},\n-  {\"details\", TDF_DETAILS},\n-  {\"cselib\", TDF_CSELIB},\n-  {\"stats\", TDF_STATS},\n-  {\"blocks\", TDF_BLOCKS},\n-  {\"vops\", TDF_VOPS},\n-  {\"lineno\", TDF_LINENO},\n-  {\"uid\", TDF_UID},\n-  {\"stmtaddr\", TDF_STMTADDR},\n-  {\"memsyms\", TDF_MEMSYMS},\n-  {\"verbose\", TDF_VERBOSE},\n-  {\"eh\", TDF_EH},\n-  {\"alias\", TDF_ALIAS},\n-  {\"nouid\", TDF_NOUID},\n-  {\"enumerate_locals\", TDF_ENUMERATE_LOCALS},\n-  {\"scev\", TDF_SCEV},\n-  {\"all\", ~(TDF_RAW | TDF_SLIM | TDF_LINENO | TDF_TREE | TDF_RTL | TDF_IPA\n-\t    | TDF_STMTADDR | TDF_GRAPH | TDF_DIAGNOSTIC | TDF_VERBOSE\n-\t    | TDF_RHS_ONLY | TDF_NOUID | TDF_ENUMERATE_LOCALS | TDF_SCEV)},\n-  {NULL, 0}\n-};\n-\n-unsigned int\n-dump_register (const char *suffix, const char *swtch, const char *glob,\n-\t       int flags)\n-{\n-  static int next_dump = FIRST_AUTO_NUMBERED_DUMP;\n-  int num = next_dump++;\n-\n-  size_t count = extra_dump_files_in_use++;\n-\n-  if (count >= extra_dump_files_alloced)\n-    {\n-      if (extra_dump_files_alloced == 0)\n-\textra_dump_files_alloced = 32;\n-      else\n-\textra_dump_files_alloced *= 2;\n-      extra_dump_files = XRESIZEVEC (struct dump_file_info,\n-\t\t\t\t     extra_dump_files,\n-\t\t\t\t     extra_dump_files_alloced);\n-    }\n-\n-  memset (&extra_dump_files[count], 0, sizeof (struct dump_file_info));\n-  extra_dump_files[count].suffix = suffix;\n-  extra_dump_files[count].swtch = swtch;\n-  extra_dump_files[count].glob = glob;\n-  extra_dump_files[count].flags = flags;\n-  extra_dump_files[count].num = num;\n-\n-  return count + TDI_end;\n-}\n-\n-\n-/* Return the dump_file_info for the given phase.  */\n-\n-struct dump_file_info *\n-get_dump_file_info (int phase)\n-{\n-  if (phase < TDI_end)\n-    return &dump_files[phase];\n-  else if ((size_t) (phase - TDI_end) >= extra_dump_files_in_use)\n-    return NULL;\n-  else\n-    return extra_dump_files + (phase - TDI_end);\n-}\n-\n-\n-/* Return the name of the dump file for the given phase.\n-   If the dump is not enabled, returns NULL.  */\n-\n-char *\n-get_dump_file_name (int phase)\n-{\n-  char dump_id[10];\n-  struct dump_file_info *dfi;\n-\n-  if (phase == TDI_none)\n-    return NULL;\n-\n-  dfi = get_dump_file_info (phase);\n-  if (dfi->state == 0)\n-    return NULL;\n-\n-  if (dfi->num < 0)\n-    dump_id[0] = '\\0';\n-  else\n-    {\n-      char suffix;\n-      if (dfi->flags & TDF_TREE)\n-\tsuffix = 't';\n-      else if (dfi->flags & TDF_IPA)\n-\tsuffix = 'i';\n-      else\n-\tsuffix = 'r';\n-\n-      if (snprintf (dump_id, sizeof (dump_id), \".%03d%c\", dfi->num, suffix) < 0)\n-\tdump_id[0] = '\\0';\n-    }\n-\n-  return concat (dump_base_name, dump_id, dfi->suffix, NULL);\n-}\n-\n-/* Begin a tree dump for PHASE. Stores any user supplied flag in\n-   *FLAG_PTR and returns a stream to write to. If the dump is not\n-   enabled, returns NULL.\n-   Multiple calls will reopen and append to the dump file.  */\n-\n-FILE *\n-dump_begin (int phase, int *flag_ptr)\n-{\n-  char *name;\n-  struct dump_file_info *dfi;\n-  FILE *stream;\n-\n-  if (phase == TDI_none || !dump_enabled_p (phase))\n-    return NULL;\n-\n-  name = get_dump_file_name (phase);\n-  dfi = get_dump_file_info (phase);\n-  stream = fopen (name, dfi->state < 0 ? \"w\" : \"a\");\n-  if (!stream)\n-    error (\"could not open dump file %qs: %m\", name);\n-  else\n-    dfi->state = 1;\n-  free (name);\n-\n-  if (flag_ptr)\n-    *flag_ptr = dfi->flags;\n-\n-  return stream;\n-}\n-\n-/* Returns nonzero if tree dump PHASE is enabled.  If PHASE is\n-   TDI_tree_all, return nonzero if any dump is enabled.  */\n-\n-int\n-dump_enabled_p (int phase)\n-{\n-  if (phase == TDI_tree_all)\n-    {\n-      size_t i;\n-      for (i = TDI_none + 1; i < (size_t) TDI_end; i++)\n-\tif (dump_files[i].state)\n-\t  return 1;\n-      for (i = 0; i < extra_dump_files_in_use; i++)\n-\tif (extra_dump_files[i].state)\n-\t  return 1;\n-      return 0;\n-    }\n-  else\n-    {\n-      struct dump_file_info *dfi = get_dump_file_info (phase);\n-      return dfi->state;\n-    }\n-}\n-\n-/* Returns nonzero if tree dump PHASE has been initialized.  */\n-\n-int\n-dump_initialized_p (int phase)\n-{\n-  struct dump_file_info *dfi = get_dump_file_info (phase);\n-  return dfi->state > 0;\n-}\n-\n-/* Returns the switch name of PHASE.  */\n-\n-const char *\n-dump_flag_name (int phase)\n-{\n-  struct dump_file_info *dfi = get_dump_file_info (phase);\n-  return dfi->swtch;\n-}\n-\n-/* Finish a tree dump for PHASE. STREAM is the stream created by\n-   dump_begin.  */\n-\n-void\n-dump_end (int phase ATTRIBUTE_UNUSED, FILE *stream)\n-{\n-  fclose (stream);\n-}\n-\n-/* Enable all tree dumps.  Return number of enabled tree dumps.  */\n-\n-static int\n-dump_enable_all (int flags)\n-{\n-  int ir_dump_type = (flags & (TDF_TREE | TDF_RTL | TDF_IPA));\n-  int n = 0;\n-  size_t i;\n-\n-  for (i = TDI_none + 1; i < (size_t) TDI_end; i++)\n-    if ((dump_files[i].flags & ir_dump_type))\n-      {\n-        dump_files[i].state = -1;\n-        dump_files[i].flags |= flags;\n-        n++;\n-      }\n-\n-  for (i = 0; i < extra_dump_files_in_use; i++)\n-    if ((extra_dump_files[i].flags & ir_dump_type))\n-      {\n-        extra_dump_files[i].state = -1;\n-        extra_dump_files[i].flags |= flags;\n-\tn++;\n-      }\n-\n-  return n;\n-}\n-\n-/* Parse ARG as a dump switch. Return nonzero if it is, and store the\n-   relevant details in the dump_files array.  */\n-\n-static int\n-dump_switch_p_1 (const char *arg, struct dump_file_info *dfi, bool doglob)\n-{\n-  const char *option_value;\n-  const char *ptr;\n-  int flags;\n-\n-  if (doglob && !dfi->glob)\n-    return 0;\n-\n-  option_value = skip_leading_substring (arg, doglob ? dfi->glob : dfi->swtch);\n-  if (!option_value)\n-    return 0;\n-\n-  if (*option_value && *option_value != '-')\n-    return 0;\n-\n-  ptr = option_value;\n-  flags = 0;\n-\n-  while (*ptr)\n-    {\n-      const struct dump_option_value_info *option_ptr;\n-      const char *end_ptr;\n-      unsigned length;\n-\n-      while (*ptr == '-')\n-\tptr++;\n-      end_ptr = strchr (ptr, '-');\n-      if (!end_ptr)\n-\tend_ptr = ptr + strlen (ptr);\n-      length = end_ptr - ptr;\n-\n-      for (option_ptr = dump_options; option_ptr->name; option_ptr++)\n-\tif (strlen (option_ptr->name) == length\n-\t    && !memcmp (option_ptr->name, ptr, length))\n-\t  {\n-\t    flags |= option_ptr->value;\n-\t    goto found;\n-\t  }\n-      warning (0, \"ignoring unknown option %q.*s in %<-fdump-%s%>\",\n-\t       length, ptr, dfi->swtch);\n-    found:;\n-      ptr = end_ptr;\n-    }\n-\n-  dfi->state = -1;\n-  dfi->flags |= flags;\n-\n-  /* Process -fdump-tree-all and -fdump-rtl-all, by enabling all the\n-     known dumps.  */\n-  if (dfi->suffix == NULL)\n-    dump_enable_all (dfi->flags);\n-\n-  return 1;\n-}\n-\n-int\n-dump_switch_p (const char *arg)\n-{\n-  size_t i;\n-  int any = 0;\n-\n-  for (i = TDI_none + 1; i != TDI_end; i++)\n-    any |= dump_switch_p_1 (arg, &dump_files[i], false);\n-\n-  /* Don't glob if we got a hit already */\n-  if (!any)\n-    for (i = TDI_none + 1; i != TDI_end; i++)\n-      any |= dump_switch_p_1 (arg, &dump_files[i], true);\n-\n-  for (i = 0; i < extra_dump_files_in_use; i++)\n-    any |= dump_switch_p_1 (arg, &extra_dump_files[i], false);\n-\n-  if (!any)\n-    for (i = 0; i < extra_dump_files_in_use; i++)\n-      any |= dump_switch_p_1 (arg, &extra_dump_files[i], true);\n-\n-\n-  return any;\n-}\n-\n-/* Dump FUNCTION_DECL FN as tree dump PHASE.  */\n-\n-void\n-dump_function (int phase, tree fn)\n-{\n-  FILE *stream;\n-  int flags;\n-\n-  stream = dump_begin (phase, &flags);\n-  if (stream)\n-    {\n-      dump_function_to_file (fn, stream, flags);\n-      dump_end (phase, stream);\n-    }\n-}\n-\n-bool\n-enable_rtl_dump_file (void)\n-{\n-  return dump_enable_all (TDF_RTL | TDF_DETAILS | TDF_BLOCKS) > 0;\n-}"}, {"sha": "67ea6e5f715ca50793cc6ed6eca5c3d32efdeefd", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -89,12 +89,9 @@ extern void dump_string_field (dump_info_p, const char *, const char *);\n extern void queue_and_dump_index (dump_info_p, const char *, const_tree, int);\n extern void queue_and_dump_type (dump_info_p, const_tree);\n extern void dump_function (int, tree);\n-extern void dump_function_to_file (tree, FILE *, int);\n-extern void debug_function (tree, int);\n extern int dump_flag (dump_info_p, int, const_tree);\n \n-extern unsigned int dump_register (const char *, const char *, const char *,\n-\t\t\t\t   int);\n-\n+/* In tree-cfg.c  */\n+extern void dump_function_to_file (tree, FILE *, int);\n \n #endif /* ! GCC_TREE_DUMP_H */"}, {"sha": "a3b981ec0a54451e1798cd7c5798ad5f2d14424e", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -1944,7 +1944,6 @@ gather_scalar_reductions (loop_p loop, htab_t reduction_list)\n   gimple_stmt_iterator gsi;\n   loop_vec_info simple_loop_info;\n \n-  vect_dump = NULL;\n   simple_loop_info = vect_analyze_loop_form (loop);\n \n   for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))"}, {"sha": "dc6e1e72b9e0f41bc1cccf78a3e4f4abab60515e", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 413, "deletions": 314, "changes": 727, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"dumpfile.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n@@ -59,23 +60,26 @@ vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n \n   if (array_mode == BLKmode)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"no array mode for %s[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n-\t\t GET_MODE_NAME (mode), count);\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                         \"no array mode for %s[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n+                         GET_MODE_NAME (mode), count);\n       return false;\n     }\n \n   if (convert_optab_handler (optab, array_mode, mode) == CODE_FOR_nothing)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"cannot use %s<%s><%s>\",\n-\t\t name, GET_MODE_NAME (array_mode), GET_MODE_NAME (mode));\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"cannot use %s<%s><%s>\", name,\n+                         GET_MODE_NAME (array_mode), GET_MODE_NAME (mode));\n       return false;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"can use %s<%s><%s>\",\n-\t     name, GET_MODE_NAME (array_mode), GET_MODE_NAME (mode));\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"can use %s<%s><%s>\", name, GET_MODE_NAME (array_mode),\n+                     GET_MODE_NAME (mode));\n \n   return true;\n }\n@@ -435,12 +439,13 @@ vect_check_interleaving (struct data_reference *dra,\n       if (diff_mod_size == 0)\n \t{\n \t  vect_update_interleaving_chain (drb, dra);\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"Detected interleaving \");\n-\t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-\t      fprintf (vect_dump, \" and \");\n-\t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"Detected interleaving \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+\t      dump_printf (MSG_NOTE,  \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n \t    }\n \t  return true;\n \t}\n@@ -457,12 +462,13 @@ vect_check_interleaving (struct data_reference *dra,\n       if (diff_mod_size == 0)\n \t{\n \t  vect_update_interleaving_chain (dra, drb);\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"Detected interleaving \");\n-\t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-\t      fprintf (vect_dump, \" and \");\n-\t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"Detected interleaving \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+\t      dump_printf (MSG_NOTE,  \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n \t    }\n \t  return true;\n \t}\n@@ -518,26 +524,29 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n   if ((unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS) == 0)\n     return false;\n \n-  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"mark for run-time aliasing test between \");\n-      print_generic_expr (vect_dump, DR_REF (DDR_A (ddr)), TDF_SLIM);\n-      fprintf (vect_dump, \" and \");\n-      print_generic_expr (vect_dump, DR_REF (DDR_B (ddr)), TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+                       \"mark for run-time aliasing test between \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr)));\n+      dump_printf (MSG_NOTE,  \" and \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr)));\n     }\n \n   if (optimize_loop_nest_for_size_p (loop))\n     {\n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\tfprintf (vect_dump, \"versioning not supported when optimizing for size.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                         \"versioning not supported when optimizing for size.\");\n       return false;\n     }\n \n   /* FORNOW: We don't support versioning with outer-loop vectorization.  */\n   if (loop->inner)\n     {\n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\tfprintf (vect_dump, \"versioning not yet supported for outer-loops.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                         \"versioning not yet supported for outer-loops.\");\n       return false;\n     }\n \n@@ -546,9 +555,10 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n   if (TREE_CODE (DR_STEP (DDR_A (ddr))) != INTEGER_CST\n       || TREE_CODE (DR_STEP (DDR_B (ddr))) != INTEGER_CST)\n     {\n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\tfprintf (vect_dump, \"versioning not yet supported for non-constant \"\n-\t\t \"step\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                         \"versioning not yet supported for non-constant \"\n+                         \"step\");\n       return false;\n     }\n \n@@ -601,13 +611,16 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \n       if (loop_vinfo)\n         {\n-          if (vect_print_dump_info (REPORT_DR_DETAILS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"versioning for alias required: \"\n-                                  \"can't determine dependence between \");\n-              print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-              fprintf (vect_dump, \" and \");\n-              print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                               \"versioning for alias required: \"\n+                               \"can't determine dependence between \");\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                 DR_REF (dra));\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                 DR_REF (drb));\n             }\n \n           /* Add to list of ddrs that need to be tested at run-time.  */\n@@ -624,12 +637,13 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       if (DR_IS_READ (dra) && DR_IS_READ (drb))\n         return false;\n \n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"can't determine dependence between \");\n-          print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-          fprintf (vect_dump, \" and \");\n-          print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"can't determine dependence between \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n+          dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n         }\n \n       /* We do not vectorize basic blocks with write-write dependencies.  */\n@@ -652,31 +666,34 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       if (dra != drb && vect_check_interleaving (dra, drb))\n         return false;\n \n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"determined dependence between \");\n-          print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-          fprintf (vect_dump, \" and \");\n-          print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"determined dependence between \");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+          dump_printf (MSG_NOTE, \" and \");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n         }\n \n       /* Do not vectorize basic blcoks with write-write dependences.  */\n       if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n         return true;\n \n-      /* Check if this dependence is allowed in basic block vectorization.  */ \n+      /* Check if this dependence is allowed in basic block vectorization.  */\n       return vect_drs_dependent_in_basic_block (dra, drb);\n     }\n \n   /* Loop-based vectorization and known data dependence.  */\n   if (DDR_NUM_DIST_VECTS (ddr) == 0)\n     {\n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"versioning for alias required: bad dist vector for \");\n-          print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-          fprintf (vect_dump, \" and \");\n-          print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                           \"versioning for alias required: \"\n+                           \"bad dist vector for \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n+          dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n         }\n       /* Add to list of ddrs that need to be tested at run-time.  */\n       return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n@@ -687,17 +704,19 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n     {\n       int dist = dist_v[loop_depth];\n \n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\tfprintf (vect_dump, \"dependence distance  = %d.\", dist);\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"dependence distance  = %d.\", dist);\n \n       if (dist == 0)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"dependence distance == 0 between \");\n-\t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-\t      fprintf (vect_dump, \" and \");\n-\t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \n+                               \"dependence distance == 0 between \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+\t      dump_printf (MSG_NOTE, \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n \t    }\n \n           /* For interleaving, mark that there is a read-write dependency if\n@@ -718,8 +737,9 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  /* If DDR_REVERSED_P the order of the data-refs in DDR was\n \t     reversed (to make distance vector positive), and the actual\n \t     distance is negative.  */\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\t    fprintf (vect_dump, \"dependence distance negative.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"dependence distance negative.\");\n \t  continue;\n \t}\n \n@@ -729,27 +749,30 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  /* The dependence distance requires reduction of the maximal\n \t     vectorization factor.  */\n \t  *max_vf = abs (dist);\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\t    fprintf (vect_dump, \"adjusting maximal vectorization factor to %i\",\n-\t\t     *max_vf);\n+\t  if (dump_kind_p (MSG_NOTE))\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+                             \"adjusting maximal vectorization factor to %i\",\n+                             *max_vf);\n \t}\n \n       if (abs (dist) >= *max_vf)\n \t{\n \t  /* Dependence distance does not create dependence, as far as\n \t     vectorization is concerned, in this case.  */\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\t    fprintf (vect_dump, \"dependence distance >= VF.\");\n+\t  if (dump_kind_p (MSG_NOTE))\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+                             \"dependence distance >= VF.\");\n \t  continue;\n \t}\n \n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t{\n-\t  fprintf (vect_dump, \"not vectorized, possible dependence \"\n-    \t\t              \"between data-refs \");\n-\t  print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-\t  fprintf (vect_dump, \" and \");\n-\t  print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                       \"not vectorized, possible dependence \"\n+                       \"between data-refs \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+\t  dump_printf (MSG_NOTE,  \" and \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n \t}\n \n       return true;\n@@ -772,9 +795,9 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n   VEC (ddr_p, heap) *ddrs = NULL;\n   struct data_dependence_relation *ddr;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n-\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_analyze_dependences ===\");\n   if (loop_vinfo)\n     ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n   else\n@@ -814,8 +837,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   tree misalign;\n   tree aligned_to, alignment;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vect_compute_data_ref_alignment:\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"vect_compute_data_ref_alignment:\");\n \n   if (loop_vinfo)\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -846,16 +870,18 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n       if (dr_step % GET_MODE_SIZE (TYPE_MODE (vectype)) == 0)\n         {\n-          if (vect_print_dump_info (REPORT_ALIGNMENT))\n-            fprintf (vect_dump, \"inner step divides the vector-size.\");\n+          if (dump_kind_p (MSG_NOTE))\n+            dump_printf_loc (MSG_NOTE, vect_location,\n+                             \"inner step divides the vector-size.\");\n \t  misalign = STMT_VINFO_DR_INIT (stmt_info);\n \t  aligned_to = STMT_VINFO_DR_ALIGNED_TO (stmt_info);\n \t  base_addr = STMT_VINFO_DR_BASE_ADDRESS (stmt_info);\n         }\n       else\n \t{\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\t    fprintf (vect_dump, \"inner step doesn't divide the vector-size.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"inner step doesn't divide the vector-size.\");\n \t  misalign = NULL_TREE;\n \t}\n     }\n@@ -872,8 +898,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n       if (dr_step % GET_MODE_SIZE (TYPE_MODE (vectype)) != 0)\n \t{\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\t    fprintf (vect_dump, \"SLP: step doesn't divide the vector-size.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                             \"SLP: step doesn't divide the vector-size.\");\n \t  misalign = NULL_TREE;\n \t}\n     }\n@@ -884,10 +911,11 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   if ((aligned_to && tree_int_cst_compare (aligned_to, alignment) < 0)\n       || !misalign)\n     {\n-      if (vect_print_dump_info (REPORT_ALIGNMENT))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t{\n-\t  fprintf (vect_dump, \"Unknown alignment for access: \");\n-\t  print_generic_expr (vect_dump, base, TDF_SLIM);\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"Unknown alignment for access: \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, base);\n \t}\n       return true;\n     }\n@@ -913,21 +941,22 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype))\n \t  || (TREE_STATIC (base) && flag_section_anchors))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"can't force alignment of ref: \");\n-\t      print_generic_expr (vect_dump, ref, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"can't force alignment of ref: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n \t    }\n \t  return true;\n \t}\n \n       /* Force the alignment of the decl.\n \t NOTE: This is the only change to the code we make during\n \t the analysis phase, before deciding to vectorize the loop.  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"force alignment of \");\n-          print_generic_expr (vect_dump, ref, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location, \"force alignment of \");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n         }\n \n       DECL_ALIGN (base) = TYPE_ALIGN (vectype);\n@@ -958,17 +987,19 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   if (!host_integerp (misalign, 1))\n     {\n       /* Negative or overflowed misalignment value.  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"unexpected misalign value\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"unexpected misalign value\");\n       return false;\n     }\n \n   SET_DR_MISALIGNMENT (dr, TREE_INT_CST_LOW (misalign));\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n     {\n-      fprintf (vect_dump, \"misalign = %d bytes of ref \", DR_MISALIGNMENT (dr));\n-      print_generic_expr (vect_dump, ref, TDF_SLIM);\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                       \"misalign = %d bytes of ref \", DR_MISALIGNMENT (dr));\n+      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, ref);\n     }\n \n   return true;\n@@ -1064,8 +1095,8 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n       return;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"Setting misalignment to -1.\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"Setting misalignment to -1.\");\n   SET_DR_MISALIGNMENT (dr, -1);\n }\n \n@@ -1111,22 +1142,25 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n       if (!supportable_dr_alignment)\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n               if (DR_IS_READ (dr))\n-                fprintf (vect_dump,\n-                         \"not vectorized: unsupported unaligned load.\");\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                 \"not vectorized: unsupported unaligned load.\");\n               else\n-                fprintf (vect_dump,\n-                         \"not vectorized: unsupported unaligned store.\");\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                 \"not vectorized: unsupported unaligned \"\n+                                 \"store.\");\n \n-              print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM);\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                 DR_REF (dr));\n             }\n           return false;\n         }\n       if (supportable_dr_alignment != dr_aligned\n-          && vect_print_dump_info (REPORT_ALIGNMENT))\n-        fprintf (vect_dump, \"Vectorizing an unaligned access.\");\n+          && dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"Vectorizing an unaligned access.\");\n     }\n   return true;\n }\n@@ -1181,15 +1215,18 @@ vector_alignment_reachable_p (struct data_reference *dr)\n     {\n       HOST_WIDE_INT elmsize =\n \t\tint_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n \t{\n-\t  fprintf (vect_dump, \"data size =\" HOST_WIDE_INT_PRINT_DEC, elmsize);\n-\t  fprintf (vect_dump, \". misalignment = %d. \", DR_MISALIGNMENT (dr));\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \n+                           \"data size =\" HOST_WIDE_INT_PRINT_DEC, elmsize);\n+\t  dump_printf (MSG_NOTE, \n+                       \". misalignment = %d. \", DR_MISALIGNMENT (dr));\n \t}\n       if (DR_MISALIGNMENT (dr) % elmsize)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"data size does not divide the misalignment.\\n\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                             \"data size does not divide the misalignment.\\n\");\n \t  return false;\n \t}\n     }\n@@ -1198,8 +1235,9 @@ vector_alignment_reachable_p (struct data_reference *dr)\n     {\n       tree type = TREE_TYPE (DR_REF (dr));\n       bool is_packed = not_size_aligned (DR_REF (dr));\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"Unknown misalignment, is_packed = %d\",is_packed);\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                         \"Unknown misalignment, is_packed = %d\",is_packed);\n       if (targetm.vectorize.vector_alignment_reachable (type, is_packed))\n \treturn true;\n       else\n@@ -1231,9 +1269,10 @@ vect_get_data_access_cost (struct data_reference *dr,\n   else\n     vect_get_store_cost (dr, ncopies, inside_cost, body_cost_vec);\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"vect_get_data_access_cost: inside_cost = %d, \"\n-             \"outside_cost = %d.\", *inside_cost, *outside_cost);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"vect_get_data_access_cost: inside_cost = %d, \"\n+                     \"outside_cost = %d.\", *inside_cost, *outside_cost);\n }\n \n \n@@ -1528,8 +1567,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   unsigned int nelements, mis, same_align_drs_max = 0;\n   stmt_vector_for_cost body_cost_vec = NULL;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_enhance_data_refs_alignment ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_enhance_data_refs_alignment ===\");\n \n   /* While cost model enhancements are expected in the future, the high level\n      view of the code at this time is as follows:\n@@ -1582,8 +1622,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t and so we can't generate the new base for the pointer.  */\n       if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"strided load prevents peeling\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"strided load prevents peeling\");\n \t  do_peeling = false;\n \t  break;\n \t}\n@@ -1697,9 +1738,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         {\n           if (!aligned_access_p (dr))\n             {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"vector alignment may not be reachable\");\n-\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                 \"vector alignment may not be reachable\");\n               break;\n             }\n         }\n@@ -1838,8 +1879,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \t    npeel /= GROUP_SIZE (stmt_info);\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"Try peeling by %d\", npeel);\n+          if (dump_kind_p (MSG_NOTE))\n+            dump_printf_loc (MSG_NOTE, vect_location,\n+                             \"Try peeling by %d\", npeel);\n         }\n \n       /* Ensure that all data refs can be vectorized after the peel.  */\n@@ -1909,12 +1951,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           else\n             LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n \t  SET_DR_MISALIGNMENT (dr0, 0);\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n-            fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n-\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"Peeling for alignment will be applied.\");\n-\n+\t  if (dump_kind_p (MSG_NOTE))\n+            {\n+              dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"Alignment of access forced using peeling.\");\n+              dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"Peeling for alignment will be applied.\");\n+            }\n \t  /* We've delayed passing the inside-loop peeling costs to the\n \t     target cost model until we were sure peeling would happen.\n \t     Do so now.  */\n@@ -2034,12 +2077,14 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n           dr = STMT_VINFO_DATA_REF (stmt_info);\n \t  SET_DR_MISALIGNMENT (dr, 0);\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n-            fprintf (vect_dump, \"Alignment of access forced using versioning.\");\n+\t  if (dump_kind_p (MSG_NOTE))\n+            dump_printf_loc (MSG_NOTE, vect_location, \n+                             \"Alignment of access forced using versioning.\");\n         }\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"Versioning for alignment will be applied.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location, \n+                         \"Versioning for alignment will be applied.\");\n \n       /* Peeling and versioning can't be done together at this time.  */\n       gcc_assert (! (do_peeling && do_versioning));\n@@ -2103,8 +2148,9 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n     {\n       int dist = dist_v[loop_depth];\n \n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\tfprintf (vect_dump, \"dependence distance  = %d.\", dist);\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"dependence distance  = %d.\", dist);\n \n       /* Same loop iteration.  */\n       if (dist == 0\n@@ -2113,14 +2159,15 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n \t  /* Two references with distance zero have the same alignment.  */\n \t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n \t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\t    fprintf (vect_dump, \"accesses have the same alignment.\");\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"dependence distance modulo vf == 0 between \");\n-\t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-\t      fprintf (vect_dump, \" and \");\n-\t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+              dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"accesses have the same alignment.\");\n+\t      dump_printf (MSG_NOTE,\n+                           \"dependence distance modulo vf == 0 between \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+\t      dump_printf (MSG_NOTE,  \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n \t    }\n \t}\n     }\n@@ -2136,8 +2183,9 @@ bool\n vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n                                   bb_vec_info bb_vinfo)\n {\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_data_refs_alignment ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_analyze_data_refs_alignment ===\");\n \n   /* Mark groups of data references with same alignment using\n      data dependence information.  */\n@@ -2153,9 +2201,10 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n \n   if (!vect_compute_data_refs_alignment (loop_vinfo, bb_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-\tfprintf (vect_dump,\n-\t\t \"not vectorized: can't calculate alignment for data ref.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                         \"not vectorized: can't calculate alignment \"\n+                         \"for data ref.\");\n       return false;\n     }\n \n@@ -2205,24 +2254,27 @@ vect_analyze_group_access (struct data_reference *dr)\n \t{\n \t  GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = stmt;\n \t  GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"Detected single element interleaving \");\n-\t      print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM);\n-\t      fprintf (vect_dump, \" step \");\n-\t      print_generic_expr (vect_dump, step, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \n+                               \"Detected single element interleaving \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr));\n+\t      dump_printf (MSG_NOTE, \" step \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, step);\n \t    }\n \n \t  if (loop_vinfo)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"Data access with gaps requires scalar \"\n-\t\t\t\t    \"epilogue loop\");\n+\t      if (dump_kind_p (MSG_NOTE))\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+                                 \"Data access with gaps requires scalar \"\n+                                 \"epilogue loop\");\n               if (loop->inner)\n                 {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump, \"Peeling for outer loop is not\"\n-                                        \" supported\");\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                     \"Peeling for outer loop is not\"\n+                                     \" supported\");\n                   return false;\n                 }\n \n@@ -2232,10 +2284,11 @@ vect_analyze_group_access (struct data_reference *dr)\n \t  return true;\n \t}\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n- \t  fprintf (vect_dump, \"not consecutive access \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+ \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"not consecutive access \");\n+          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n         }\n \n       if (bb_vinfo)\n@@ -2244,7 +2297,7 @@ vect_analyze_group_access (struct data_reference *dr)\n           STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n           return true;\n         }\n-    \n+\n       return false;\n     }\n \n@@ -2271,8 +2324,9 @@ vect_analyze_group_access (struct data_reference *dr)\n             {\n               if (DR_IS_WRITE (data_ref))\n                 {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump, \"Two store stmts share the same dr.\");\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                     \"Two store stmts share the same dr.\");\n                   return false;\n                 }\n \n@@ -2281,9 +2335,9 @@ vect_analyze_group_access (struct data_reference *dr)\n               if (GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (next))\n                   || GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (prev)))\n                 {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump,\n-                             \"READ_WRITE dependence in interleaving.\");\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                     \"READ_WRITE dependence in interleaving.\");\n                   return false;\n                 }\n \n@@ -2301,8 +2355,9 @@ vect_analyze_group_access (struct data_reference *dr)\n           next_step = DR_STEP (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n           if (tree_int_cst_compare (step, next_step))\n             {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"not consecutive access in interleaving\");\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                 \"not consecutive access in interleaving\");\n               return false;\n             }\n \n@@ -2317,8 +2372,9 @@ vect_analyze_group_access (struct data_reference *dr)\n \t      slp_impossible = true;\n \t      if (DR_IS_WRITE (data_ref))\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t    fprintf (vect_dump, \"interleaved store with gaps\");\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                     \"interleaved store with gaps\");\n \t\t  return false;\n \t\t}\n \n@@ -2345,10 +2401,11 @@ vect_analyze_group_access (struct data_reference *dr)\n          greater than STEP.  */\n       if (dr_step && dr_step < count_in_bytes + gaps * type_size)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"interleaving size is greater than step for \");\n-              print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                               \"interleaving size is greater than step for \");\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dr));\n             }\n           return false;\n         }\n@@ -2367,22 +2424,24 @@ vect_analyze_group_access (struct data_reference *dr)\n             }\n           else\n             {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"interleaved store with gaps\");\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                 \"interleaved store with gaps\");\n               return false;\n             }\n         }\n \n       /* Check that STEP is a multiple of type size.  */\n       if (dr_step && (dr_step % type_size) != 0)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"step is not a multiple of type size: step \");\n-              print_generic_expr (vect_dump, step, TDF_SLIM);\n-              fprintf (vect_dump, \" size \");\n-              print_generic_expr (vect_dump, TYPE_SIZE_UNIT (scalar_type),\n-                                  TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                               \"step is not a multiple of type size: step \");\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, step);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \" size \");\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                 TYPE_SIZE_UNIT (scalar_type));\n             }\n           return false;\n         }\n@@ -2391,8 +2450,9 @@ vect_analyze_group_access (struct data_reference *dr)\n         groupsize = count;\n \n       GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"Detected interleaving of size %d\", (int)groupsize);\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location, \n+                         \"Detected interleaving of size %d\", (int)groupsize);\n \n       /* SLP: create an SLP data structure for every interleaving group of\n \t stores for further analysis in vect_analyse_slp.  */\n@@ -2409,13 +2469,15 @@ vect_analyze_group_access (struct data_reference *dr)\n       /* There is a gap in the end of the group.  */\n       if (groupsize - last_accessed_element > 0 && loop_vinfo)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"Data access with gaps requires scalar \"\n-\t\t\t\t\"epilogue loop\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"Data access with gaps requires scalar \"\n+                             \"epilogue loop\");\n           if (loop->inner)\n             {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"Peeling for outer loop is not supported\");\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                 \"Peeling for outer loop is not supported\");\n               return false;\n             }\n \n@@ -2446,8 +2508,9 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n   if (loop_vinfo && !step)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data-ref access in loop\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                         \"bad data-ref access in loop\");\n       return false;\n     }\n \n@@ -2468,8 +2531,9 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n       step = STMT_VINFO_DR_STEP (stmt_info);\n       if (integer_zerop (step))\n \t{\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\t    fprintf (vect_dump, \"zero step in outer loop.\");\n+\t  if (dump_kind_p (MSG_NOTE))\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+                             \"zero step in outer loop.\");\n \t  if (DR_IS_READ (dr))\n   \t    return true;\n \t  else\n@@ -2493,8 +2557,9 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n   if (loop && nested_in_vect_loop_p (loop, stmt))\n     {\n-      if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\tfprintf (vect_dump, \"grouped access in outer loop.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"grouped access in outer loop.\");\n       return false;\n     }\n \n@@ -2523,8 +2588,9 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   VEC (data_reference_p, heap) *datarefs;\n   struct data_reference *dr;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_data_ref_accesses ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_analyze_data_ref_accesses ===\");\n \n   if (loop_vinfo)\n     datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n@@ -2535,8 +2601,9 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n     if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) \n         && !vect_analyze_data_ref_access (dr))\n       {\n-\tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-\t  fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n+\tif (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                           \"not vectorized: complicated access pattern.\");\n \n         if (bb_vinfo)\n           {\n@@ -2564,8 +2631,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n     LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n   unsigned i, j;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_prune_runtime_alias_test_list ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_prune_runtime_alias_test_list ===\");\n \n   for (i = 0; i < VEC_length (ddr_p, ddrs); )\n     {\n@@ -2581,16 +2649,17 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n \t  if (vect_vfa_range_equal (ddr_i, ddr_j))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t      if (dump_kind_p (MSG_NOTE))\n \t\t{\n-\t\t  fprintf (vect_dump, \"found equal ranges \");\n-\t\t  print_generic_expr (vect_dump, DR_REF (DDR_A (ddr_i)), TDF_SLIM);\n-\t\t  fprintf (vect_dump, \", \");\n-\t\t  print_generic_expr (vect_dump, DR_REF (DDR_B (ddr_i)), TDF_SLIM);\n-\t\t  fprintf (vect_dump, \" and \");\n-\t\t  print_generic_expr (vect_dump, DR_REF (DDR_A (ddr_j)), TDF_SLIM);\n-\t\t  fprintf (vect_dump, \", \");\n-\t\t  print_generic_expr (vect_dump, DR_REF (DDR_B (ddr_j)), TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+                                   \"found equal ranges \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr_i)));\n+\t\t  dump_printf (MSG_NOTE,  \", \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr_i)));\n+\t\t  dump_printf (MSG_NOTE,  \" and \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr_j)));\n+\t\t  dump_printf (MSG_NOTE,  \", \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr_j)));\n \t\t}\n \t      found = true;\n \t      break;\n@@ -2608,11 +2677,11 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   if (VEC_length (ddr_p, ddrs) >\n        (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n     {\n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t{\n-\t  fprintf (vect_dump,\n-\t\t   \"disable versioning for alias - max number of generated \"\n-\t\t   \"checks exceeded.\");\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location, \n+                           \"disable versioning for alias - max number of \"\n+                           \"generated checks exceeded.\");\n \t}\n \n       VEC_truncate (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), 0);\n@@ -2895,8 +2964,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n   tree scalar_type;\n   bool res, stop_bb_analysis = false;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_data_refs ===\\n\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_analyze_data_refs ===\\n\");\n \n   if (loop_vinfo)\n     {\n@@ -2909,9 +2979,10 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (!res)\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-\t    fprintf (vect_dump, \"not vectorized: loop contains function calls\"\n-\t\t     \" or data references that cannot be analyzed\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                             \"not vectorized: loop contains function calls\"\n+                             \" or data references that cannot be analyzed\");\n \t  return false;\n \t}\n \n@@ -2940,9 +3011,11 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       if (!compute_all_dependences (BB_VINFO_DATAREFS (bb_vinfo),\n \t\t\t\t    &BB_VINFO_DDRS (bb_vinfo), NULL, true))\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-\t    fprintf (vect_dump, \"not vectorized: basic block contains function\"\n-\t\t     \" calls or data references that cannot be analyzed\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                             \"not vectorized: basic block contains function\"\n+                             \" calls or data references that cannot be\"\n+                             \" analyzed\");\n \t  return false;\n \t}\n \n@@ -2962,9 +3035,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (!dr || !DR_REF (dr))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-\t    fprintf (vect_dump, \"not vectorized: unhandled data-ref \");\n-\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"not vectorized: unhandled data-ref \");\n           return false;\n         }\n \n@@ -3008,11 +3081,12 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n \t  if (!gather)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump, \"not vectorized: data ref analysis \"\n-\t\t\t\t      \"failed \");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                   \"not vectorized: data ref analysis \"\n+                                   \"failed \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \n \t      if (bb_vinfo)\n@@ -3028,9 +3102,10 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (TREE_CODE (DR_BASE_ADDRESS (dr)) == INTEGER_CST)\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-            fprintf (vect_dump, \"not vectorized: base addr of dr is a \"\n-                     \"constant\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"not vectorized: base addr of dr is a \"\n+                             \"constant\");\n \n           if (bb_vinfo)\n             {\n@@ -3046,10 +3121,11 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (TREE_THIS_VOLATILE (DR_REF (dr)))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"not vectorized: volatile type \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                               \"not vectorized: volatile type \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n \n           if (bb_vinfo)\n@@ -3064,11 +3140,12 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (stmt_can_throw_internal (stmt))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"not vectorized: statement can throw an \"\n-                       \"exception \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                               \"not vectorized: statement can throw an \"\n+                               \"exception \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n \n           if (bb_vinfo)\n@@ -3086,11 +3163,12 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       if (TREE_CODE (DR_REF (dr)) == COMPONENT_REF\n \t  && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))\n \t{\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"not vectorized: statement is bitfield \"\n-                       \"access \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                               \"not vectorized: statement is bitfield \"\n+                               \"access \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n \n           if (bb_vinfo)\n@@ -3111,10 +3189,11 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (is_gimple_call (stmt))\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t    {\n-\t      fprintf (vect_dump, \"not vectorized: dr in a call \");\n-\t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n+                               \"not vectorized: dr in a call \");\n+\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t    }\n \n \t  if (bb_vinfo)\n@@ -3153,10 +3232,11 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           tree inner_base = build_fold_indirect_ref\n                                 (fold_build_pointer_plus (base, init));\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"analyze in outer-loop: \");\n-\t      print_generic_expr (vect_dump, inner_base, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"analyze in outer-loop: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, inner_base);\n \t    }\n \n \t  outer_base = get_inner_reference (inner_base, &pbitsize, &pbitpos,\n@@ -3165,17 +3245,19 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n \t  if (pbitpos % BITS_PER_UNIT != 0)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"failed: bit offset alignment.\\n\");\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                 \"failed: bit offset alignment.\\n\");\n \t      return false;\n \t    }\n \n \t  outer_base = build_fold_addr_expr (outer_base);\n \t  if (!simple_iv (loop, loop_containing_stmt (stmt), outer_base,\n                           &base_iv, false))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"failed: evolution of base is not affine.\\n\");\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                 \"failed: evolution of base is not affine.\\n\");\n \t      return false;\n \t    }\n \n@@ -3196,8 +3278,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  else if (!simple_iv (loop, loop_containing_stmt (stmt), poffset,\n                                &offset_iv, false))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t        fprintf (vect_dump, \"evolution of offset is not affine.\\n\");\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                 \"evolution of offset is not affine.\\n\");\n \t      return false;\n \t    }\n \n@@ -3220,28 +3303,36 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  STMT_VINFO_DR_ALIGNED_TO (stmt_info) =\n \t\t\t\tsize_int (highest_pow2_factor (offset_iv.base));\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"\\touter base_address: \");\n-\t      print_generic_expr (vect_dump, STMT_VINFO_DR_BASE_ADDRESS (stmt_info), TDF_SLIM);\n-\t      fprintf (vect_dump, \"\\n\\touter offset from base address: \");\n-\t      print_generic_expr (vect_dump, STMT_VINFO_DR_OFFSET (stmt_info), TDF_SLIM);\n-\t      fprintf (vect_dump, \"\\n\\touter constant offset from base address: \");\n-\t      print_generic_expr (vect_dump, STMT_VINFO_DR_INIT (stmt_info), TDF_SLIM);\n-\t      fprintf (vect_dump, \"\\n\\touter step: \");\n-\t      print_generic_expr (vect_dump, STMT_VINFO_DR_STEP (stmt_info), TDF_SLIM);\n-\t      fprintf (vect_dump, \"\\n\\touter aligned to: \");\n-\t      print_generic_expr (vect_dump, STMT_VINFO_DR_ALIGNED_TO (stmt_info), TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"\\touter base_address: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+                                 STMT_VINFO_DR_BASE_ADDRESS (stmt_info));\n+\t      dump_printf (MSG_NOTE, \"\\n\\touter offset from base address: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+                                 STMT_VINFO_DR_OFFSET (stmt_info));\n+\t      dump_printf (MSG_NOTE,\n+                           \"\\n\\touter constant offset from base address: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+                                 STMT_VINFO_DR_INIT (stmt_info));\n+\t      dump_printf (MSG_NOTE, \"\\n\\touter step: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+                                 STMT_VINFO_DR_STEP (stmt_info));\n+\t      dump_printf (MSG_NOTE, \"\\n\\touter aligned to: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+                                 STMT_VINFO_DR_ALIGNED_TO (stmt_info));\n \t    }\n \t}\n \n       if (STMT_VINFO_DATA_REF (stmt_info))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump,\n-                       \"not vectorized: more than one data ref in stmt: \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                               \"not vectorized: more than one data ref \"\n+                               \"in stmt: \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n \n           if (bb_vinfo)\n@@ -3264,13 +3355,14 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                 get_vectype_for_scalar_type (scalar_type);\n       if (!STMT_VINFO_VECTYPE (stmt_info))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump,\n-                       \"not vectorized: no vectype for stmt: \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-              fprintf (vect_dump, \" scalar_type: \");\n-              print_generic_expr (vect_dump, scalar_type, TDF_DETAILS);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                               \"not vectorized: no vectype for stmt: \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \" scalar_type: \");\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_DETAILS,\n+                                 scalar_type);\n             }\n \n           if (bb_vinfo)\n@@ -3314,11 +3406,12 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t    {\n \t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n \t      free_data_ref (dr);\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump,\n-\t\t\t   \"not vectorized: not suitable for gather load \");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                   \"not vectorized: not suitable for gather \"\n+                                   \"load \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \t      return false;\n \t    }\n@@ -3366,12 +3459,12 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n \t  if (bad)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump,\n-\t\t\t   \"not vectorized: data dependence conflict\"\n-\t\t\t   \" prevents gather load\");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                   \"not vectorized: data dependence conflict\"\n+                                   \" prevents gather load\");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \t      return false;\n \t    }\n@@ -3387,11 +3480,12 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      = vect_check_strided_load (stmt, loop_vinfo, NULL, NULL);\n \t  if (!strided_load)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump,\n-\t\t\t   \"not vectorized: not suitable for strided load \");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                   \"not vectorized: not suitable for strided \"\n+                                   \"load \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \t      return false;\n \t    }\n@@ -3574,10 +3668,10 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n \tmark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (vec_stmt));\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"created \");\n-      print_generic_expr (vect_dump, vec_stmt, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"created \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, vec_stmt);\n     }\n \n   return vec_stmt;\n@@ -3696,20 +3790,21 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n      in LOOP.  */\n   base_name = build_fold_indirect_ref (unshare_expr (DR_BASE_ADDRESS (dr)));\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n       tree data_ref_base = base_name;\n-      fprintf (vect_dump, \"create %s-pointer variable to type: \",\n-\t       tree_code_name[(int) TREE_CODE (aggr_type)]);\n-      print_generic_expr (vect_dump, aggr_type, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+                       \"create %s-pointer variable to type: \",\n+                       tree_code_name[(int) TREE_CODE (aggr_type)]);\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, aggr_type);\n       if (TREE_CODE (data_ref_base) == VAR_DECL\n           || TREE_CODE (data_ref_base) == ARRAY_REF)\n-        fprintf (vect_dump, \"  vectorizing an array ref: \");\n+        dump_printf (MSG_NOTE, \"  vectorizing an array ref: \");\n       else if (TREE_CODE (data_ref_base) == COMPONENT_REF)\n-        fprintf (vect_dump, \"  vectorizing a record based array ref: \");\n+        dump_printf (MSG_NOTE, \"  vectorizing a record based array ref: \");\n       else if (TREE_CODE (data_ref_base) == SSA_NAME)\n-        fprintf (vect_dump, \"  vectorizing a pointer ref: \");\n-      print_generic_expr (vect_dump, base_name, TDF_SLIM);\n+        dump_printf (MSG_NOTE, \"  vectorizing a pointer ref: \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, base_name);\n     }\n \n   /* (1) Create the new aggregate-pointer variable.  */\n@@ -4025,9 +4120,10 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   /* vect_permute_store_chain requires the group size to be a power of two.  */\n   if (exact_log2 (count) == -1)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"the size of the group of accesses\"\n-\t\t \" is not a power of 2\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"the size of the group of accesses\"\n+                         \" is not a power of 2\");\n       return false;\n     }\n \n@@ -4050,8 +4146,9 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t}\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"interleave op not supported by target.\");\n+  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+    dump_printf (MSG_MISSED_OPTIMIZATION,\n+                 \"interleave op not supported by target.\");\n   return false;\n }\n \n@@ -4467,9 +4564,10 @@ vect_grouped_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   /* vect_permute_load_chain requires the group size to be a power of two.  */\n   if (exact_log2 (count) == -1)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"the size of the group of accesses\"\n-\t\t \" is not a power of 2\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"the size of the group of accesses\"\n+                         \" is not a power of 2\");\n       return false;\n     }\n \n@@ -4490,8 +4588,9 @@ vect_grouped_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t}\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"extract even/odd not supported by target\");\n+  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                     \"extract even/odd not supported by target\");\n   return false;\n }\n "}, {"sha": "d9b3040c2d1215edb571eb3da126ba04f8a9ed8d", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 70, "deletions": 64, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"dumpfile.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n@@ -791,14 +792,12 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   free_stmt_vec_info (orig_cond);\n \n   loop_loc = find_loop_location (loop);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      if (loop_loc != UNKNOWN_LOC)\n-        fprintf (dump_file, \"\\nloop at %s:%d: \",\n-                 LOC_FILE (loop_loc), LOC_LINE (loop_loc));\n-      print_gimple_stmt (dump_file, cond_stmt, 0, TDF_SLIM);\n+      dump_printf (MSG_NOTE, \"\\nloop at %s:%d: \", LOC_FILE (loop_loc),\n+                   LOC_LINE (loop_loc));\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, cond_stmt, 0);\n     }\n-\n   loop->nb_iterations = niters;\n }\n \n@@ -1246,13 +1245,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   if (!(new_loop = slpeel_tree_duplicate_loop_to_edge_cfg (loop, e)))\n     {\n       loop_loc = find_loop_location (loop);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-          if (loop_loc != UNKNOWN_LOC)\n-            fprintf (dump_file, \"\\n%s:%d: note: \",\n-                     LOC_FILE (loop_loc), LOC_LINE (loop_loc));\n-          fprintf (dump_file, \"tree_duplicate_loop_to_edge_cfg failed.\\n\");\n-        }\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, loop_loc,\n+                       \"tree_duplicate_loop_to_edge_cfg failed.\\n\");\n       return NULL;\n     }\n \n@@ -1688,37 +1682,38 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n   /* Analyze phi functions of the loop header.  */\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vect_can_advance_ivs_p:\");\n-\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"vect_can_advance_ivs_p:\");\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       tree access_fn = NULL;\n       tree evolution_part;\n \n       phi = gsi_stmt (gsi);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n \t{\n-          fprintf (vect_dump, \"Analyze phi: \");\n-          print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n+          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n \t}\n \n       /* Skip virtual phi's. The data dependences that are associated with\n          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n \n       if (virtual_operand_p (PHI_RESULT (phi)))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"virtual phi. skip.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"virtual phi. skip.\");\n \t  continue;\n \t}\n \n       /* Skip reduction phis.  */\n \n       if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (phi)) == vect_reduction_def)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"reduc phi. skip.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"reduc phi. skip.\");\n           continue;\n         }\n \n@@ -1729,23 +1724,25 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (!access_fn)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"No Access function.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"No Access function.\");\n \t  return false;\n \t}\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-\t  fprintf (vect_dump, \"Access function of PHI: \");\n-\t  print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"Access function of PHI: \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, access_fn);\n         }\n \n       evolution_part = evolution_part_in_loop_num (access_fn, loop->num);\n \n       if (evolution_part == NULL_TREE)\n         {\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"No evolution.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf (MSG_MISSED_OPTIMIZATION, \"No evolution.\");\n \t  return false;\n         }\n \n@@ -1829,26 +1826,29 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \n       phi = gsi_stmt (gsi);\n       phi1 = gsi_stmt (gsi1);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"vect_update_ivs_after_vectorizer: phi: \");\n-\t  print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"vect_update_ivs_after_vectorizer: phi: \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n         }\n \n       /* Skip virtual phi's.  */\n       if (virtual_operand_p (PHI_RESULT (phi)))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"virtual phi. skip.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"virtual phi. skip.\");\n \t  continue;\n \t}\n \n       /* Skip reduction phis.  */\n       stmt_info = vinfo_for_stmt (phi);\n       if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"reduc phi. skip.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"reduc phi. skip.\");\n           continue;\n         }\n \n@@ -1909,8 +1909,9 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_do_peeling_for_loop_bound ===\");\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                     \"=== vect_do_peeling_for_loop_bound ===\");\n \n   initialize_original_copy_tables ();\n \n@@ -1956,9 +1957,9 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   if (check_profitability)\n     max_iter = MAX (max_iter, (int) th);\n   record_niter_bound (new_loop, double_int::from_shwi (max_iter), false, true);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Setting upper bound of nb iterations for epilogue \"\n-\t     \"loop to %d\\n\", max_iter);\n+  dump_printf (MSG_OPTIMIZED_LOCATIONS,\n+               \"Setting upper bound of nb iterations for epilogue \"\n+               \"loop to %d\\n\", max_iter);\n \n   /* After peeling we have to reset scalar evolution analyzer.  */\n   scev_reset ();\n@@ -2020,8 +2021,9 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n     {\n       int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"known peeling = %d.\", npeel);\n+      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+        dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                         \"known peeling = %d.\", npeel);\n \n       iters = build_int_cst (niters_type, npeel);\n       *bound = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n@@ -2073,10 +2075,11 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n   if (TREE_CODE (loop_niters) != INTEGER_CST)\n     iters = fold_build2 (MIN_EXPR, niters_type, iters, loop_niters);\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n     {\n-      fprintf (vect_dump, \"niters for prolog loop: \");\n-      print_generic_expr (vect_dump, iters, TDF_SLIM);\n+      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                       \"niters for prolog loop: \");\n+      dump_generic_expr (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, iters);\n     }\n \n   var = create_tmp_var (niters_type, \"prolog_loop_niters\");\n@@ -2129,9 +2132,10 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n   unsigned int i;\n   VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct data_reference *dr;\n-\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_update_inits_of_dr ===\");\n+ \n+ if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                     \"=== vect_update_inits_of_dr ===\");\n \n   FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     vect_update_init_of_dr (dr, niters);\n@@ -2158,8 +2162,9 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,\n   int max_iter;\n   int bound = 0;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_do_peeling_for_alignment ===\");\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                     \"=== vect_do_peeling_for_alignment ===\");\n \n   initialize_original_copy_tables ();\n \n@@ -2184,9 +2189,9 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,\n   if (check_profitability)\n     max_iter = MAX (max_iter, (int) th);\n   record_niter_bound (new_loop, double_int::from_shwi (max_iter), false, true);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Setting upper bound of nb iterations for prologue \"\n-\t     \"loop to %d\\n\", max_iter);\n+  dump_printf (MSG_OPTIMIZED_LOCATIONS,\n+               \"Setting upper bound of nb iterations for prologue \"\n+               \"loop to %d\\n\", max_iter);\n \n   /* Update number of times loop executes.  */\n   n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n@@ -2469,13 +2474,13 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n       segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n       segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n \n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n \t{\n-\t  fprintf (vect_dump,\n-\t\t   \"create runtime check for data references \");\n-\t  print_generic_expr (vect_dump, DR_REF (dr_a), TDF_SLIM);\n-\t  fprintf (vect_dump, \" and \");\n-\t  print_generic_expr (vect_dump, DR_REF (dr_b), TDF_SLIM);\n+\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                           \"create runtime check for data references \");\n+\t  dump_generic_expr (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, DR_REF (dr_a));\n+\t  dump_printf (MSG_OPTIMIZED_LOCATIONS, \" and \");\n+\t  dump_generic_expr (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, DR_REF (dr_b));\n \t}\n \n       seg_a_min = addr_base_a;\n@@ -2500,9 +2505,10 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \t*cond_expr = part_cond_expr;\n     }\n \n-  if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS))\n-    fprintf (vect_dump, \"created %u versioning for alias checks.\\n\",\n-             VEC_length (ddr_p, may_alias_ddrs));\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t     \"created %u versioning for alias checks.\\n\",\n+\t\t     VEC_length (ddr_p, may_alias_ddrs));\n }\n \n "}, {"sha": "d01203e8a8282381ecc5e6e4a9d5114e1590a5bc", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 560, "deletions": 439, "changes": 999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"dumpfile.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n@@ -184,8 +185,9 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   gimple_stmt_iterator pattern_def_si = gsi_none ();\n   bool analyze_pattern_stmt = false;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_determine_vectorization_factor ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_determine_vectorization_factor ===\");\n \n   for (i = 0; i < nbbs; i++)\n     {\n@@ -195,10 +197,10 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t{\n \t  phi = gsi_stmt (si);\n \t  stmt_info = vinfo_for_stmt (phi);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"==> examining phi: \");\n-\t      print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining phi: \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n \t    }\n \n \t  gcc_assert (stmt_info);\n@@ -208,34 +210,37 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      gcc_assert (!STMT_VINFO_VECTYPE (stmt_info));\n               scalar_type = TREE_TYPE (PHI_RESULT (phi));\n \n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t      if (dump_kind_p (MSG_NOTE))\n \t\t{\n-\t\t  fprintf (vect_dump, \"get vectype for scalar type:  \");\n-\t\t  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+                                   \"get vectype for scalar type:  \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n \t\t}\n \n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t    {\n-\t\t      fprintf (vect_dump,\n-\t\t               \"not vectorized: unsupported data-type \");\n-\t\t      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                       \"not vectorized: unsupported \"\n+                                       \"data-type \");\n+\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                         scalar_type);\n \t\t    }\n \t\t  return false;\n \t\t}\n \t      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t      if (dump_kind_p (MSG_NOTE))\n \t\t{\n-\t\t  fprintf (vect_dump, \"vectype: \");\n-\t\t  print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n \t\t}\n \n \t      nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"nunits = %d\", nunits);\n+\t      if (dump_kind_p (MSG_NOTE))\n+\t\tdump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\", nunits);\n \n \t      if (!vectorization_factor\n \t\t  || (nunits > vectorization_factor))\n@@ -254,10 +259,11 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n           stmt_info = vinfo_for_stmt (stmt);\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"==> examining statement: \");\n-\t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"==> examining statement: \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n \t    }\n \n \t  gcc_assert (stmt_info);\n@@ -273,16 +279,17 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                 {\n                   stmt = pattern_stmt;\n                   stmt_info = vinfo_for_stmt (pattern_stmt);\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n+                  if (dump_kind_p (MSG_NOTE))\n                     {\n-                      fprintf (vect_dump, \"==> examining pattern statement: \");\n-                      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                      dump_printf_loc (MSG_NOTE, vect_location,\n+                                       \"==> examining pattern statement: \");\n+                      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n                     }\n                 }\n               else\n \t        {\n-\t          if (vect_print_dump_info (REPORT_DETAILS))\n-\t            fprintf (vect_dump, \"skip.\");\n+\t          if (dump_kind_p (MSG_NOTE))\n+\t            dump_printf_loc (MSG_NOTE, vect_location, \"skip.\");\n                   gsi_next (&si);\n \t          continue;\n                 }\n@@ -321,12 +328,12 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t\t  if (!gsi_end_p (pattern_def_si))\n \t\t    {\n-\t\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t      if (dump_kind_p (MSG_NOTE))\n \t\t\t{\n-\t\t\t  fprintf (vect_dump,\n-\t\t\t\t   \"==> examining pattern def stmt: \");\n-\t\t\t  print_gimple_stmt (vect_dump, pattern_def_stmt, 0,\n-\t\t\t\t\t     TDF_SLIM);\n+\t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+                                           \"==> examining pattern def stmt: \");\n+\t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n+                                            pattern_def_stmt, 0);\n \t\t\t}\n \n \t\t      stmt = pattern_def_stmt;\n@@ -344,20 +351,23 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t  if (gimple_get_lhs (stmt) == NULL_TREE)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t          fprintf (vect_dump, \"not vectorized: irregular stmt.\");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                   \"not vectorized: irregular stmt.\");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,  TDF_SLIM, stmt,\n+                                    0);\n \t\t}\n \t      return false;\n \t    }\n \n \t  if (VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t        {\n-\t          fprintf (vect_dump, \"not vectorized: vector stmt in loop:\");\n-\t          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                   \"not vectorized: vector stmt in loop:\");\n+\t          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t        }\n \t      return false;\n \t    }\n@@ -377,19 +387,22 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    {\n \t      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n \t      scalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t      if (dump_kind_p (MSG_NOTE))\n \t\t{\n-\t\t  fprintf (vect_dump, \"get vectype for scalar type:  \");\n-\t\t  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+                                   \"get vectype for scalar type:  \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n \t\t}\n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t    {\n-\t\t      fprintf (vect_dump,\n-\t\t\t       \"not vectorized: unsupported data-type \");\n-\t\t      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                       \"not vectorized: unsupported \"\n+                                       \"data-type \");\n+\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                         scalar_type);\n \t\t    }\n \t\t  return false;\n \t\t}\n@@ -402,48 +415,51 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t     support one vector size per loop).  */\n \t  scalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n \t\t\t\t\t\t       &dummy);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"get vectype for scalar type:  \");\n-\t      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"get vectype for scalar type:  \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n \t    }\n \t  vf_vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vf_vectype)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump,\n-\t\t\t   \"not vectorized: unsupported data-type \");\n-\t\t  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                   \"not vectorized: unsupported data-type \");\n+\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                     scalar_type);\n \t\t}\n \t      return false;\n \t    }\n \n \t  if ((GET_MODE_SIZE (TYPE_MODE (vectype))\n \t       != GET_MODE_SIZE (TYPE_MODE (vf_vectype))))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump,\n-\t\t\t   \"not vectorized: different sized vector \"\n-\t\t\t   \"types in statement, \");\n-\t\t  print_generic_expr (vect_dump, vectype, TDF_SLIM);\n-\t\t  fprintf (vect_dump, \" and \");\n-\t\t  print_generic_expr (vect_dump, vf_vectype, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                   \"not vectorized: different sized vector \"\n+                                   \"types in statement, \");\n+\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                     vectype);\n+\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n+\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                     vf_vectype);\n \t\t}\n \t      return false;\n \t    }\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"vectype: \");\n-\t      print_generic_expr (vect_dump, vf_vectype, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, vf_vectype);\n \t    }\n \n \t  nunits = TYPE_VECTOR_SUBPARTS (vf_vectype);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"nunits = %d\", nunits);\n-\n+\t  if (dump_kind_p (MSG_NOTE))\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\", nunits);\n \t  if (!vectorization_factor\n \t      || (nunits > vectorization_factor))\n \t    vectorization_factor = nunits;\n@@ -457,12 +473,14 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n     }\n \n   /* TODO: Analyze cost. Decide if worth while to vectorize.  */\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vectorization factor = %d\", vectorization_factor);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"vectorization factor = %d\",\n+                     vectorization_factor);\n   if (vectorization_factor <= 1)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: unsupported data-type\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"not vectorized: unsupported data-type\");\n       return false;\n     }\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n@@ -497,21 +515,22 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n   step_expr = evolution_part;\n   init_expr = unshare_expr (initial_condition_in_loop_num (access_fn, loop_nb));\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"step: \");\n-      print_generic_expr (vect_dump, step_expr, TDF_SLIM);\n-      fprintf (vect_dump, \",  init: \");\n-      print_generic_expr (vect_dump, init_expr, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"step: \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, step_expr);\n+      dump_printf (MSG_NOTE, \",  init: \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, init_expr);\n     }\n \n   *init = init_expr;\n   *step = step_expr;\n \n   if (TREE_CODE (step_expr) != INTEGER_CST)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"step unknown.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"step unknown.\");\n       return false;\n     }\n \n@@ -534,8 +553,9 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n   gimple_stmt_iterator gsi;\n   bool double_reduc;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_scalar_cycles ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_analyze_scalar_cycles ===\");\n \n   /* First - identify all inductions.  Reduction detection assumes that all the\n      inductions have been identified, therefore, this order must not be\n@@ -547,10 +567,10 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       tree def = PHI_RESULT (phi);\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n \t{\n-\t  fprintf (vect_dump, \"Analyze phi: \");\n-\t  print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n \t}\n \n       /* Skip virtual phi's.  The data dependences that are associated with\n@@ -565,10 +585,11 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       if (access_fn)\n \t{\n \t  STRIP_NOPS (access_fn);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"Access function of PHI: \");\n-\t      print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"Access function of PHI: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, access_fn);\n \t    }\n \t  STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo)\n \t    = evolution_part_in_loop_num (access_fn, loop->num);\n@@ -583,8 +604,8 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n \n       gcc_assert (STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo) != NULL_TREE);\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"Detected induction.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"Detected induction.\");\n       STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_induction_def;\n     }\n \n@@ -598,10 +619,10 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       gimple reduc_stmt;\n       bool nested_cycle;\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"Analyze phi: \");\n-          print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n+          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n         }\n \n       gcc_assert (!virtual_operand_p (def)\n@@ -614,8 +635,9 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n         {\n           if (double_reduc)\n             {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"Detected double reduction.\");\n+              if (dump_kind_p (MSG_NOTE))\n+                dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Detected double reduction.\");\n \n               STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_double_reduction_def;\n               STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n@@ -625,17 +647,19 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n             {\n               if (nested_cycle)\n                 {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump, \"Detected vectorizable nested cycle.\");\n+                  if (dump_kind_p (MSG_NOTE))\n+                    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t     \"Detected vectorizable nested cycle.\");\n \n                   STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_nested_cycle;\n                   STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n                                                              vect_nested_cycle;\n                 }\n               else\n                 {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump, \"Detected reduction.\");\n+                  if (dump_kind_p (MSG_NOTE))\n+                    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t     \"Detected reduction.\");\n \n                   STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_reduction_def;\n                   STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n@@ -649,8 +673,9 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n             }\n         }\n       else\n-        if (vect_print_dump_info (REPORT_DETAILS))\n-          fprintf (vect_dump, \"Unknown def-use cycle pattern.\");\n+        if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"Unknown def-use cycle pattern.\");\n     }\n \n   VEC_free (gimple, heap, worklist);\n@@ -710,20 +735,20 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n {\n   tree niters;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== get_loop_niters ===\");\n-\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"=== get_loop_niters ===\");\n   niters = number_of_exit_cond_executions (loop);\n \n   if (niters != NULL_TREE\n       && niters != chrec_dont_know)\n     {\n       *number_of_iterations = niters;\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"==> get_loop_niters:\" );\n-          print_generic_expr (vect_dump, *number_of_iterations, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location, \"==> get_loop_niters:\");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, *number_of_iterations);\n         }\n     }\n \n@@ -968,16 +993,18 @@ vect_analyze_loop_1 (struct loop *loop)\n {\n   loop_vec_info loop_vinfo;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"===== analyze_loop_nest_1 =====\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"===== analyze_loop_nest_1 =====\");\n \n   /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n \n   loop_vinfo = vect_analyze_loop_form (loop);\n   if (!loop_vinfo)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"bad inner-loop form.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad inner-loop form.\");\n       return NULL;\n     }\n \n@@ -1001,8 +1028,9 @@ vect_analyze_loop_form (struct loop *loop)\n   tree number_of_iterations = NULL;\n   loop_vec_info inner_loop_vinfo = NULL;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_loop_form ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"=== vect_analyze_loop_form ===\");\n \n   /* Different restrictions apply when we are considering an inner-most loop,\n      vs. an outer (nested) loop.\n@@ -1024,15 +1052,17 @@ vect_analyze_loop_form (struct loop *loop)\n \n       if (loop->num_nodes != 2)\n         {\n-          if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-            fprintf (vect_dump, \"not vectorized: control flow in loop.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: control flow in loop.\");\n           return NULL;\n         }\n \n       if (empty_block_p (loop->header))\n     {\n-          if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-            fprintf (vect_dump, \"not vectorized: empty loop.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: empty loop.\");\n       return NULL;\n     }\n     }\n@@ -1060,34 +1090,37 @@ vect_analyze_loop_form (struct loop *loop)\n \n       if ((loop->inner)->inner || (loop->inner)->next)\n \t{\n-\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: multiple nested loops.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: multiple nested loops.\");\n \t  return NULL;\n \t}\n \n       /* Analyze the inner-loop.  */\n       inner_loop_vinfo = vect_analyze_loop_1 (loop->inner);\n       if (!inner_loop_vinfo)\n \t{\n-\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-            fprintf (vect_dump, \"not vectorized: Bad inner loop.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: Bad inner loop.\");\n \t  return NULL;\n \t}\n \n       if (!expr_invariant_in_loop_p (loop,\n \t\t\t\t\tLOOP_VINFO_NITERS (inner_loop_vinfo)))\n \t{\n-\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-\t    fprintf (vect_dump,\n-\t\t     \"not vectorized: inner-loop count not invariant.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t     \"not vectorized: inner-loop count not invariant.\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n \t}\n \n       if (loop->num_nodes != 5)\n         {\n-\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: control flow in loop.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: control flow in loop.\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n         }\n@@ -1101,25 +1134,29 @@ vect_analyze_loop_form (struct loop *loop)\n \t  || !single_exit (innerloop)\n \t  || single_exit (innerloop)->dest !=  EDGE_PRED (loop->latch, 0)->src)\n \t{\n-\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: unsupported outerloop form.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t     \"not vectorized: unsupported outerloop form.\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n \t}\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"Considering outer-loop vectorization.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Considering outer-loop vectorization.\");\n     }\n \n   if (!single_exit (loop)\n       || EDGE_COUNT (loop->header->preds) != 2)\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n           if (!single_exit (loop))\n-            fprintf (vect_dump, \"not vectorized: multiple exits.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: multiple exits.\");\n           else if (EDGE_COUNT (loop->header->preds) != 2)\n-            fprintf (vect_dump, \"not vectorized: too many incoming edges.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t     \"not vectorized: too many incoming edges.\");\n         }\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n@@ -1133,8 +1170,9 @@ vect_analyze_loop_form (struct loop *loop)\n   if (!empty_block_p (loop->latch)\n         || !gimple_seq_empty_p (phi_nodes (loop->latch)))\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-        fprintf (vect_dump, \"not vectorized: unexpected loop form.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: unexpected loop form.\");\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n@@ -1147,13 +1185,14 @@ vect_analyze_loop_form (struct loop *loop)\n       if (!(e->flags & EDGE_ABNORMAL))\n \t{\n \t  split_loop_exit_edge (e);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"split exit edge.\");\n+\t  if (dump_kind_p (MSG_NOTE))\n+\t    dump_printf (MSG_NOTE, \"split exit edge.\");\n \t}\n       else\n \t{\n-\t  if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: abnormal loop exit edge.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t     \"not vectorized: abnormal loop exit edge.\");\n \t  if (inner_loop_vinfo)\n \t    destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n@@ -1163,44 +1202,49 @@ vect_analyze_loop_form (struct loop *loop)\n   loop_cond = vect_get_loop_niters (loop, &number_of_iterations);\n   if (!loop_cond)\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-\tfprintf (vect_dump, \"not vectorized: complicated exit condition.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t \"not vectorized: complicated exit condition.\");\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n     }\n \n   if (!number_of_iterations)\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-\tfprintf (vect_dump,\n-\t\t \"not vectorized: number of iterations cannot be computed.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t \"not vectorized: number of iterations cannot be \"\n+\t\t\t \"computed.\");\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n     }\n \n   if (chrec_contains_undetermined (number_of_iterations))\n     {\n-      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n-        fprintf (vect_dump, \"Infinite number of iterations.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Infinite number of iterations.\");\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n     }\n \n   if (!NITERS_KNOWN_P (number_of_iterations))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"Symbolic number of iterations is \");\n-          print_generic_expr (vect_dump, number_of_iterations, TDF_DETAILS);\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"Symbolic number of iterations is \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_DETAILS, number_of_iterations);\n         }\n     }\n   else if (TREE_INT_CST_LOW (number_of_iterations) == 0)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: number of iterations = 0.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: number of iterations = 0.\");\n       if (inner_loop_vinfo)\n         destroy_loop_vec_info (inner_loop_vinfo, false);\n       return NULL;\n@@ -1244,8 +1288,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n   bool only_slp_in_loop = true, ok;\n   HOST_WIDE_INT max_niter;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_loop_operations ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"=== vect_analyze_loop_operations ===\");\n \n   gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n   vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n@@ -1279,9 +1324,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \t\t\t\tLOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n \n       LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"Updating vectorization factor to %d \",\n-\t \t\t    vectorization_factor);\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Updating vectorization factor to %d \",\n+\t\t\t vectorization_factor);\n     }\n \n   for (i = 0; i < nbbs; i++)\n@@ -1294,10 +1340,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n           ok = true;\n \n           stmt_info = vinfo_for_stmt (phi);\n-          if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_NOTE))\n             {\n-              fprintf (vect_dump, \"examining phi: \");\n-              print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_NOTE, vect_location, \"examining phi: \");\n+              dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n             }\n \n           /* Inner-loop loop-closed exit phi in outer-loop vectorization\n@@ -1313,9 +1359,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n                   && STMT_VINFO_DEF_TYPE (stmt_info)\n                      != vect_double_reduction_def)\n                 {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump,\n-                             \"Unsupported loop-closed phi in outer-loop.\");\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t     \"Unsupported loop-closed phi in \"\n+\t\t\t\t     \"outer-loop.\");\n                   return false;\n                 }\n \n@@ -1354,17 +1401,19 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n           if (STMT_VINFO_LIVE_P (stmt_info))\n             {\n               /* FORNOW: not yet supported.  */\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-                fprintf (vect_dump, \"not vectorized: value used after loop.\");\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: value used after loop.\");\n               return false;\n             }\n \n           if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_scope\n               && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n             {\n               /* A scalar-dependence cycle that we don't support.  */\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-                fprintf (vect_dump, \"not vectorized: scalar dependence cycle.\");\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t \"not vectorized: scalar dependence cycle.\");\n               return false;\n             }\n \n@@ -1377,11 +1426,12 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \n           if (!ok)\n             {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n                 {\n-                  fprintf (vect_dump,\n-                           \"not vectorized: relevant phi not supported: \");\n-                  print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t   \"not vectorized: relevant phi not \"\n+\t\t\t\t   \"supported: \");\n+                  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, phi, 0);\n                 }\n \t      return false;\n             }\n@@ -1402,31 +1452,35 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n      touching this loop.  */\n   if (!need_to_vectorize)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump,\n-                 \"All the computation can be taken out of the loop.\");\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump,\n-                 \"not vectorized: redundant loop. no profit to vectorize.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"All the computation can be taken out of the loop.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t \"not vectorized: redundant loop. no profit to \"\n+\t\t\t \"vectorize.\");\n       return false;\n     }\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump,\n-        \"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n-        vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n+      && dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"vectorization_factor = %d, niters = \"\n+\t\t     HOST_WIDE_INT_PRINT_DEC, vectorization_factor,\n+\t\t     LOOP_VINFO_INT_NITERS (loop_vinfo));\n \n   if ((LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n        && (LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor))\n       || ((max_niter = max_stmt_executions_int (loop)) != -1\n \t  && (unsigned HOST_WIDE_INT) max_niter < vectorization_factor))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: iteration count too small.\");\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump,\"not vectorized: iteration count smaller than \"\n-                 \"vectorization factor.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: iteration count too small.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: iteration count smaller than \"\n+\t\t\t \"vectorization factor.\");\n       return false;\n     }\n \n@@ -1441,11 +1495,13 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \n   if (min_profitable_iters < 0)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: vectorization not profitable.\");\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"not vectorized: vector version will never be \"\n-                 \"profitable.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vectorization not profitable.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t \"not vectorized: vector version will never be \"\n+\t\t\t \"profitable.\");\n       return false;\n     }\n \n@@ -1464,34 +1520,35 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && LOOP_VINFO_INT_NITERS (loop_vinfo) <= th)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: vectorization not \"\n-                 \"profitable.\");\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"not vectorized: iteration count smaller than \"\n-                 \"user specified loop bound parameter or minimum \"\n-                 \"profitable iterations (whichever is more conservative).\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vectorization not profitable.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"not vectorized: iteration count smaller than user \"\n+\t\t\t \"specified loop bound parameter or minimum profitable \"\n+\t\t\t \"iterations (whichever is more conservative).\");\n       return false;\n     }\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0\n       || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"epilog loop required.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location, \"epilog loop required.\");\n       if (!vect_can_advance_ivs_p (loop_vinfo))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-            fprintf (vect_dump,\n-                     \"not vectorized: can't create epilog loop 1.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t     \"not vectorized: can't create epilog loop 1.\");\n           return false;\n         }\n       if (!slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-            fprintf (vect_dump,\n-                     \"not vectorized: can't create epilog loop 2.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t     \"not vectorized: can't create epilog loop 2.\");\n           return false;\n         }\n     }\n@@ -1522,8 +1579,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_data_refs (loop_vinfo, NULL, &min_vf);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data references.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad data references.\");\n       return false;\n     }\n \n@@ -1539,8 +1597,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"unexpected pattern.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"unexpected pattern.\");\n       return false;\n     }\n \n@@ -1553,22 +1612,25 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   if (!ok\n       || max_vf < min_vf)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data dependence.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"bad data dependence.\");\n       return false;\n     }\n \n   ok = vect_determine_vectorization_factor (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"can't determine vectorization factor.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't determine vectorization factor.\");\n       return false;\n     }\n   if (max_vf < LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data dependence.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad data dependence.\");\n       return false;\n     }\n \n@@ -1578,8 +1640,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_data_refs_alignment (loop_vinfo, NULL);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data alignment.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad data alignment.\");\n       return false;\n     }\n \n@@ -1589,8 +1652,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_data_ref_accesses (loop_vinfo, NULL);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data access.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad data access.\");\n       return false;\n     }\n \n@@ -1600,9 +1664,10 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_prune_runtime_alias_test_list (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"too long list of versioning for alias \"\n-\t\t\t    \"run-time tests.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"too long list of versioning for alias \"\n+\t\t\t \"run-time tests.\");\n       return false;\n     }\n \n@@ -1612,8 +1677,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_enhance_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"bad data alignment.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad data alignment.\");\n       return false;\n     }\n \n@@ -1636,8 +1702,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_loop_operations (loop_vinfo, slp);\n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad operation or unsupported loop bound.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad operation or unsupported loop bound.\");\n       return false;\n     }\n \n@@ -1659,15 +1726,17 @@ vect_analyze_loop (struct loop *loop)\n   current_vector_size = 0;\n   vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"===== analyze_loop_nest =====\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"===== analyze_loop_nest =====\");\n \n   if (loop_outer (loop)\n       && loop_vec_info_for_loop (loop_outer (loop))\n       && LOOP_VINFO_VECTORIZABLE_P (loop_vec_info_for_loop (loop_outer (loop))))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"outer-loop already vectorized.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"outer-loop already vectorized.\");\n       return NULL;\n     }\n \n@@ -1677,8 +1746,9 @@ vect_analyze_loop (struct loop *loop)\n       loop_vinfo = vect_analyze_loop_form (loop);\n       if (!loop_vinfo)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"bad loop form.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"bad loop form.\");\n \t  return NULL;\n \t}\n \n@@ -1698,9 +1768,10 @@ vect_analyze_loop (struct loop *loop)\n \n       /* Try the next biggest vector size.  */\n       current_vector_size = 1 << floor_log2 (vector_sizes);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"***** Re-trying analysis with \"\n-\t\t \"vector size %d\\n\", current_vector_size);\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Re-trying analysis with \"\n+\t\t\t \"vector size %d\\n\", current_vector_size);\n     }\n }\n \n@@ -1754,10 +1825,10 @@ reduction_code_for_scalar_code (enum tree_code code,\n    STMT is printed with a message MSG. */\n \n static void\n-report_vect_op (gimple stmt, const char *msg)\n+report_vect_op (int msg_type, gimple stmt, const char *msg)\n {\n-  fprintf (vect_dump, \"%s\", msg);\n-  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+  dump_printf_loc (msg_type, vect_location, \"%s\", msg);\n+  dump_gimple_stmt (msg_type, TDF_SLIM, stmt, 0);\n }\n \n \n@@ -1929,10 +2000,10 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple phi, gimple first_stmt)\n                                   == vect_internal_def\n                       && !is_loop_header_bb_p (gimple_bb (def_stmt)))))\n   \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t      if (dump_kind_p (MSG_NOTE))\n \t\t{\n-\t\t  fprintf (vect_dump, \"swapping oprnds: \");\n-\t\t  print_gimple_stmt (vect_dump, next_stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"swapping oprnds: \");\n+\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, next_stmt, 0);\n \t\t}\n \n \t      swap_tree_operands (next_stmt,\n@@ -2031,8 +2102,9 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \n       if (!flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"intermediate value used outside loop.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"intermediate value used outside loop.\");\n \n           return NULL;\n         }\n@@ -2042,34 +2114,37 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n         nloop_uses++;\n       if (nloop_uses > 1)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"reduction used in loop.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"reduction used in loop.\");\n           return NULL;\n         }\n     }\n \n   if (TREE_CODE (loop_arg) != SSA_NAME)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t{\n-\t  fprintf (vect_dump, \"reduction: not ssa_name: \");\n-\t  print_generic_expr (vect_dump, loop_arg, TDF_SLIM);\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"reduction: not ssa_name: \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, loop_arg);\n \t}\n       return NULL;\n     }\n \n   def_stmt = SSA_NAME_DEF_STMT (loop_arg);\n   if (!def_stmt)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"reduction: no def_stmt.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"reduction: no def_stmt.\");\n       return NULL;\n     }\n \n   if (!is_gimple_assign (def_stmt) && gimple_code (def_stmt) != GIMPLE_PHI)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        print_gimple_stmt (vect_dump, def_stmt, 0, TDF_SLIM);\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n       return NULL;\n     }\n \n@@ -2096,8 +2171,9 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \tnloop_uses++;\n       if (nloop_uses > 1)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"reduction used in loop.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"reduction used in loop.\");\n \t  return NULL;\n \t}\n     }\n@@ -2111,8 +2187,9 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n       if (gimple_phi_num_args (def_stmt) != 1\n           || TREE_CODE (op1) != SSA_NAME)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"unsupported phi node definition.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"unsupported phi node definition.\");\n \n           return NULL;\n         }\n@@ -2123,8 +2200,9 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n           && flow_bb_inside_loop_p (loop->inner, gimple_bb (def1))\n           && is_gimple_assign (def1))\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            report_vect_op (def_stmt, \"detected double reduction: \");\n+          if (dump_kind_p (MSG_NOTE))\n+            report_vect_op (MSG_NOTE, def_stmt,\n+\t\t\t    \"detected double reduction: \");\n \n           *double_reduc = true;\n           return def_stmt;\n@@ -2149,17 +2227,19 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n   if (check_reduction\n       && (!commutative_tree_code (code) || !associative_tree_code (code)))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        report_vect_op (def_stmt, \"reduction: not commutative/associative: \");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t\"reduction: not commutative/associative: \");\n       return NULL;\n     }\n \n   if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS)\n     {\n       if (code != COND_EXPR)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-\t    report_vect_op (def_stmt, \"reduction: not binary operation: \");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t    \"reduction: not binary operation: \");\n \n           return NULL;\n         }\n@@ -2176,8 +2256,9 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \n       if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            report_vect_op (def_stmt, \"reduction: uses not ssa_names: \");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t    \"reduction: uses not ssa_names: \");\n \n           return NULL;\n         }\n@@ -2189,8 +2270,9 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \n       if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-\t    report_vect_op (def_stmt, \"reduction: uses not ssa_names: \");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t    \"reduction: uses not ssa_names: \");\n \n           return NULL;\n         }\n@@ -2206,24 +2288,29 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n       || (op4 && TREE_CODE (op4) == SSA_NAME\n           && !types_compatible_p (type, TREE_TYPE (op4))))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"reduction: multiple types: operation type: \");\n-          print_generic_expr (vect_dump, type, TDF_SLIM);\n-          fprintf (vect_dump, \", operands types: \");\n-          print_generic_expr (vect_dump, TREE_TYPE (op1), TDF_SLIM);\n-          fprintf (vect_dump, \",\");\n-          print_generic_expr (vect_dump, TREE_TYPE (op2), TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"reduction: multiple types: operation type: \");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, type);\n+          dump_printf (MSG_NOTE, \", operands types: \");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t\t     TREE_TYPE (op1));\n+          dump_printf (MSG_NOTE, \",\");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t\t     TREE_TYPE (op2));\n           if (op3)\n             {\n-              fprintf (vect_dump, \",\");\n-              print_generic_expr (vect_dump, TREE_TYPE (op3), TDF_SLIM);\n+              dump_printf (MSG_NOTE, \",\");\n+              dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t\t\t TREE_TYPE (op3));\n             }\n \n           if (op4)\n             {\n-              fprintf (vect_dump, \",\");\n-              print_generic_expr (vect_dump, TREE_TYPE (op4), TDF_SLIM);\n+              dump_printf (MSG_NOTE, \",\");\n+              dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t\t\t TREE_TYPE (op4));\n             }\n         }\n \n@@ -2243,23 +2330,25 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n       && check_reduction)\n     {\n       /* Changing the order of operations changes the semantics.  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"reduction: unsafe fp math optimization: \");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t\"reduction: unsafe fp math optimization: \");\n       return NULL;\n     }\n   else if (INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type)\n \t   && check_reduction)\n     {\n       /* Changing the order of operations changes the semantics.  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"reduction: unsafe int math optimization: \");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t\"reduction: unsafe int math optimization: \");\n       return NULL;\n     }\n   else if (SAT_FIXED_POINT_TYPE_P (type) && check_reduction)\n     {\n       /* Changing the order of operations changes the semantics.  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt,\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t\t\"reduction: unsafe fixed-point math optimization: \");\n       return NULL;\n     }\n@@ -2295,8 +2384,8 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n   if (code != COND_EXPR\n       && ((!def1 || gimple_nop_p (def1)) && (!def2 || gimple_nop_p (def2))))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"reduction: no defs for operands: \");\n+      if (dump_kind_p (MSG_NOTE))\n+\treport_vect_op (MSG_NOTE, def_stmt, \"reduction: no defs for operands: \");\n       return NULL;\n     }\n \n@@ -2317,8 +2406,8 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n                           == vect_internal_def\n  \t              && !is_loop_header_bb_p (gimple_bb (def1)))))))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"detected reduction: \");\n+      if (dump_kind_p (MSG_NOTE))\n+\treport_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n       return def_stmt;\n     }\n \n@@ -2340,8 +2429,8 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n           /* Swap operands (just for simplicity - so that the rest of the code\n \t     can assume that the reduction variable is always the last (second)\n \t     argument).  */\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-\t    report_vect_op (def_stmt,\n+          if (dump_kind_p (MSG_NOTE))\n+\t    report_vect_op (MSG_NOTE, def_stmt,\n \t  \t            \"detected reduction: need to swap operands: \");\n \n           swap_tree_operands (def_stmt, gimple_assign_rhs1_ptr (def_stmt),\n@@ -2352,8 +2441,8 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n         }\n       else\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            report_vect_op (def_stmt, \"detected reduction: \");\n+          if (dump_kind_p (MSG_NOTE))\n+            report_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n         }\n \n       return def_stmt;\n@@ -2362,14 +2451,16 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n   /* Try to find SLP reduction chain.  */\n   if (check_reduction && vect_is_slp_reduction (loop_info, phi, def_stmt))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        report_vect_op (def_stmt, \"reduction: detected reduction chain: \");\n+      if (dump_kind_p (MSG_NOTE))\n+        report_vect_op (MSG_NOTE, def_stmt,\n+\t\t\t\"reduction: detected reduction chain: \");\n \n       return def_stmt;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    report_vect_op (def_stmt, \"reduction: unknown pattern: \");\n+  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t    \"reduction: unknown pattern: \");\n        \n   return NULL;\n }\n@@ -2475,10 +2566,10 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n       *peel_iters_epilogue = vf/2;\n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"cost model: \"\n-                            \"epilogue peel iters set to vf/2 because \"\n-                            \"loop iterations are unknown .\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"cost model: epilogue peel iters set to vf/2 \"\n+\t\t\t \"because loop iterations are unknown .\");\n \n       /* If peeled iterations are known but number of scalar loop\n          iterations are unknown, count a taken branch per peeled loop.  */\n@@ -2536,8 +2627,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   /* Cost model disabled.  */\n   if (!flag_vect_cost_model)\n     {\n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"cost model disabled.\");\n+      dump_printf_loc (MSG_NOTE, vect_location, \"cost model disabled.\");\n       return 0;\n     }\n \n@@ -2549,9 +2639,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t\t\t\t LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n       (void) add_stmt_cost (target_cost_data, len, vector_stmt, NULL, 0,\n \t\t\t    vect_prologue);\n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n-                 \"versioning to treat misalignment.\\n\");\n+      dump_printf (MSG_NOTE,\n+                   \"cost model: Adding cost of checks for loop \"\n+                   \"versioning to treat misalignment.\\n\");\n     }\n \n   /* Requires loop versioning with alias checks.  */\n@@ -2561,9 +2651,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n       unsigned len = VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n       (void) add_stmt_cost (target_cost_data, len, vector_stmt, NULL, 0,\n \t\t\t    vect_prologue);\n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n-                 \"versioning aliasing.\\n\");\n+      dump_printf (MSG_NOTE,\n+                   \"cost model: Adding cost of checks for loop \"\n+                   \"versioning aliasing.\\n\");\n     }\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n@@ -2593,17 +2683,15 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   if (npeel  < 0)\n     {\n       peel_iters_prologue = vf/2;\n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"cost model: \"\n-                 \"prologue peel iters set to vf/2.\");\n+      dump_printf (MSG_NOTE, \"cost model: \"\n+                   \"prologue peel iters set to vf/2.\");\n \n       /* If peeling for alignment is unknown, loop bound of main loop becomes\n          unknown.  */\n       peel_iters_epilogue = vf/2;\n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"cost model: \"\n-                 \"epilogue peel iters set to vf/2 because \"\n-                 \"peeling for alignment is unknown .\");\n+      dump_printf (MSG_NOTE, \"cost model: \"\n+                   \"epilogue peel iters set to vf/2 because \"\n+                   \"peeling for alignment is unknown.\");\n \n       /* If peeled iterations are unknown, count a taken branch and a not taken\n          branch per peeled loop. Even if scalar loop iterations are known,\n@@ -2769,32 +2857,35 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   /* vector version will never be profitable.  */\n   else\n     {\n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"cost model: the vector iteration cost = %d \"\n-\t\t \"divided by the scalar iteration cost = %d \"\n-\t\t \"is greater or equal to the vectorization factor = %d.\",\n-                 vec_inside_cost, scalar_single_iter_cost, vf);\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"cost model: the vector iteration cost = %d \"\n+\t\t\t \"divided by the scalar iteration cost = %d \"\n+\t\t\t \"is greater or equal to the vectorization factor = %d.\",\n+\t\t\t vec_inside_cost, scalar_single_iter_cost, vf);\n       return -1;\n     }\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    {\n-      fprintf (vect_dump, \"Cost model analysis: \\n\");\n-      fprintf (vect_dump, \"  Vector inside of loop cost: %d\\n\",\n-\t       vec_inside_cost);\n-      fprintf (vect_dump, \"  Vector prologue cost: %d\\n\",\n-\t       vec_prologue_cost);\n-      fprintf (vect_dump, \"  Vector epilogue cost: %d\\n\",\n-\t       vec_epilogue_cost);\n-      fprintf (vect_dump, \"  Scalar iteration cost: %d\\n\",\n-\t       scalar_single_iter_cost);\n-      fprintf (vect_dump, \"  Scalar outside cost: %d\\n\", scalar_outside_cost);\n-      fprintf (vect_dump, \"  prologue iterations: %d\\n\",\n-               peel_iters_prologue);\n-      fprintf (vect_dump, \"  epilogue iterations: %d\\n\",\n-               peel_iters_epilogue);\n-      fprintf (vect_dump, \"  Calculated minimum iters for profitability: %d\\n\",\n-\t       min_profitable_iters);\n+  if (dump_kind_p (MSG_NOTE))\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");\n+      dump_printf (MSG_NOTE, \"  Vector inside of loop cost: %d\\n\",\n+                   vec_inside_cost);\n+      dump_printf (MSG_NOTE, \"  Vector prologue cost: %d\\n\",\n+                   vec_prologue_cost);\n+      dump_printf (MSG_NOTE, \"  Vector epilogue cost: %d\\n\",\n+                   vec_epilogue_cost);\n+      dump_printf (MSG_NOTE, \"  Scalar iteration cost: %d\\n\",\n+                   scalar_single_iter_cost);\n+      dump_printf (MSG_NOTE, \"  Scalar outside cost: %d\\n\",\n+                   scalar_outside_cost);\n+      dump_printf (MSG_NOTE, \"  prologue iterations: %d\\n\",\n+                   peel_iters_prologue);\n+      dump_printf (MSG_NOTE, \"  epilogue iterations: %d\\n\",\n+                   peel_iters_epilogue);\n+      dump_printf (MSG_NOTE, \n+                   \"  Calculated minimum iters for profitability: %d\\n\",\n+                   min_profitable_iters);\n     }\n \n   min_profitable_iters =\n@@ -2805,9 +2896,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n        then skip the vectorized loop.  */\n   min_profitable_iters--;\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"  Profitability threshold = %d\\n\",\n-\t     min_profitable_iters);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"  Profitability threshold = %d\\n\", min_profitable_iters);\n \n   return min_profitable_iters;\n }\n@@ -2864,10 +2955,12 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n   if (!vectype)\n     {\n-      if (vect_print_dump_info (REPORT_COST))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"unsupported data-type \");\n-          print_generic_expr (vect_dump, TREE_TYPE (reduction_op), TDF_SLIM);\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"unsupported data-type \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t     TREE_TYPE (reduction_op));\n         }\n       return false;\n    }\n@@ -2933,10 +3026,11 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t}\n     }\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"vect_model_reduction_cost: inside_cost = %d, \"\n-             \"prologue_cost = %d, epilogue_cost = %d .\", inside_cost,\n-\t     prologue_cost, epilogue_cost);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf (MSG_NOTE, \n+                 \"vect_model_reduction_cost: inside_cost = %d, \"\n+                 \"prologue_cost = %d, epilogue_cost = %d .\", inside_cost,\n+                 prologue_cost, epilogue_cost);\n \n   return true;\n }\n@@ -2961,9 +3055,10 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n   prologue_cost = add_stmt_cost (target_cost_data, 2, scalar_to_vec,\n \t\t\t\t stmt_info, 0, vect_prologue);\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"vect_model_induction_cost: inside_cost = %d, \"\n-             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"vect_model_induction_cost: inside_cost = %d, \"\n+                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n \n@@ -3089,10 +3184,11 @@ get_initial_def_for_induction (gimple iv_phi)\n \t  new_bb = gsi_insert_on_edge_immediate (pe, init_stmt);\n \t  gcc_assert (!new_bb);\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"created new init_stmt: \");\n-\t      print_gimple_stmt (vect_dump, init_stmt, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"created new init_stmt: \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, init_stmt, 0);\n \t    }\n \t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n \t}\n@@ -3231,21 +3327,24 @@ get_initial_def_for_induction (gimple iv_phi)\n \t\t      && !STMT_VINFO_LIVE_P (stmt_vinfo));\n \n \t  STMT_VINFO_VEC_STMT (stmt_vinfo) = new_stmt;\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"vector of inductions after inner-loop:\");\n-\t      print_gimple_stmt (vect_dump, new_stmt, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"vector of inductions after inner-loop:\");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n \t    }\n \t}\n     }\n \n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"transform induction: created def-use cycle: \");\n-      print_gimple_stmt (vect_dump, induction_phi, 0, TDF_SLIM);\n-      fprintf (vect_dump, \"\\n\");\n-      print_gimple_stmt (vect_dump, SSA_NAME_DEF_STMT (vec_def), 0, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"transform induction: created def-use cycle: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, induction_phi, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n+\t\t\tSSA_NAME_DEF_STMT (vec_def), 0);\n     }\n \n   STMT_VINFO_VEC_STMT (phi_info) = induction_phi;\n@@ -3646,14 +3745,13 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n           add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_NOTE))\n             {\n-              fprintf (vect_dump, \"transform reduction: created def-use\"\n-                                  \" cycle: \");\n-              print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n-              fprintf (vect_dump, \"\\n\");\n-              print_gimple_stmt (vect_dump, SSA_NAME_DEF_STMT (def), 0,\n-                                 TDF_SLIM);\n+              dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"transform reduction: created def-use cycle: \");\n+              dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n+              dump_gimple_stmt (MSG_NOTE, TDF_SLIM, SSA_NAME_DEF_STMT (def), 0);\n             }\n \n           phi = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi));\n@@ -3848,8 +3946,9 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n       /*** Case 1:  Create:\n            v_out2 = reduc_expr <v_out1>  */\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"Reduce using direct vector reduction.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Reduce using direct vector reduction.\");\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       tmp = build1 (reduc_code, vectype, new_phi_result);\n@@ -3898,8 +3997,9 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                   Create:  va = vop <va, va'>\n                 }  */\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"Reduce using vector shifts\");\n+          if (dump_kind_p (MSG_NOTE))\n+            dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Reduce using vector shifts\");\n \n           vec_dest = vect_create_destination_var (scalar_dest, vectype);\n           new_temp = new_phi_result;\n@@ -3938,8 +4038,9 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                  Create:  s = op <s, s'>  // For non SLP cases\n                }  */\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"Reduce using scalar code. \");\n+          if (dump_kind_p (MSG_NOTE))\n+            dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Reduce using scalar code. \");\n \n           vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n           FOR_EACH_VEC_ELT (gimple, new_phis, i, new_phi)\n@@ -4028,8 +4129,9 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n     {\n       tree rhs;\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"extract scalar result\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"extract scalar result\");\n \n       if (BYTES_BIG_ENDIAN)\n         bitpos = size_binop (MULT_EXPR,\n@@ -4266,11 +4368,11 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                                UNKNOWN_LOCATION);\n                   add_phi_arg (vect_phi, PHI_RESULT (inner_phi),\n                                loop_latch_edge (outer_loop), UNKNOWN_LOCATION);\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n+                  if (dump_kind_p (MSG_NOTE))\n                     {\n-                      fprintf (vect_dump, \"created double reduction phi \"\n-                                          \"node: \");\n-                      print_gimple_stmt (vect_dump, vect_phi, 0, TDF_SLIM);\n+                      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t       \"created double reduction phi node: \");\n+                      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vect_phi, 0);\n                     }\n \n                   vect_phi_res = PHI_RESULT (vect_phi);\n@@ -4616,8 +4718,9 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (!vectorizable_condition (stmt, gsi, NULL, ops[reduc_index], 0, NULL))\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"unsupported condition in reduction\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"unsupported condition in reduction\");\n \n             return false;\n         }\n@@ -4630,33 +4733,35 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       optab = optab_for_tree_code (code, vectype_in, optab_default);\n       if (!optab)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"no optab.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"no optab.\");\n \n           return false;\n         }\n \n       if (optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"op not supported by target.\");\n+          if (dump_kind_p (MSG_NOTE))\n+            dump_printf (MSG_NOTE, \"op not supported by target.\");\n \n           if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n               || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n \t          < vect_min_worthwhile_factor (code))\n             return false;\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-  \t    fprintf (vect_dump, \"proceeding using word mode.\");\n+          if (dump_kind_p (MSG_NOTE))\n+  \t    dump_printf (MSG_NOTE, \"proceeding using word mode.\");\n         }\n \n       /* Worthwhile without SIMD support?  */\n       if (!VECTOR_MODE_P (TYPE_MODE (vectype_in))\n           && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n    \t     < vect_min_worthwhile_factor (code))\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"not worthwhile without SIMD support.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not worthwhile without SIMD support.\");\n \n           return false;\n         }\n@@ -4735,17 +4840,19 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n                                          optab_default);\n       if (!reduc_optab)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"no optab for reduction.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"no optab for reduction.\");\n \n           epilog_reduc_code = ERROR_MARK;\n         }\n \n       if (reduc_optab\n           && optab_handler (reduc_optab, vec_mode) == CODE_FOR_nothing)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"reduc op not supported by target.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"reduc op not supported by target.\");\n \n           epilog_reduc_code = ERROR_MARK;\n         }\n@@ -4754,17 +4861,19 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (!nested_cycle || double_reduc)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"no reduc code for scalar code.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"no reduc code for scalar code.\");\n \n           return false;\n         }\n     }\n \n   if (double_reduc && ncopies > 1)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"multiple types in double reduction\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"multiple types in double reduction\");\n \n       return false;\n     }\n@@ -4781,8 +4890,9 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         ops[1] = fold_convert (TREE_TYPE (ops[0]), ops[1]);\n       else\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"invalid types in dot-prod\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"invalid types in dot-prod\");\n \n           return false;\n         }\n@@ -4798,8 +4908,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform reduction.\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform reduction.\");\n \n   /* FORNOW: Multiple types are not supported for condition.  */\n   if (code == COND_EXPR)\n@@ -5084,8 +5194,9 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \n       if (ncopies > 1)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"multiple types in nested loop.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"multiple types in nested loop.\");\n \t  return false;\n \t}\n \n@@ -5107,9 +5218,10 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \t  if (!(STMT_VINFO_RELEVANT_P (exit_phi_vinfo)\n \t\t&& !STMT_VINFO_LIVE_P (exit_phi_vinfo)))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"inner-loop induction only used outside \"\n-\t\t\t \"of the outer vectorized loop.\");\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t \"inner-loop induction only used outside \"\n+\t\t\t\t \"of the outer vectorized loop.\");\n \t      return false;\n \t    }\n \t}\n@@ -5130,16 +5242,17 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"=== vectorizable_induction ===\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"=== vectorizable_induction ===\");\n       vect_model_induction_cost (stmt_info, ncopies);\n       return true;\n     }\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform induction phi.\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform induction phi.\");\n \n   vec_def = get_initial_def_for_induction (phi);\n   *vec_stmt = SSA_NAME_DEF_STMT (vec_def);\n@@ -5203,8 +5316,9 @@ vectorizable_live_operation (gimple stmt,\n           && !vect_is_simple_use (op, stmt, loop_vinfo, NULL, &def_stmt, &def,\n \t\t\t\t  &dt))\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"use not simple.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"use not simple.\");\n           return false;\n         }\n \n@@ -5241,8 +5355,9 @@ vect_loop_kill_debug_uses (struct loop *loop, gimple stmt)\n \t    {\n \t      if (gimple_debug_bind_p (ustmt))\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t    fprintf (vect_dump, \"killing debug use\");\n+\t\t  if (dump_kind_p (MSG_NOTE))\n+\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n+                                     \"killing debug use\");\n \n \t\t  gimple_debug_bind_reset_value (ustmt);\n \t\t  update_stmt (ustmt);\n@@ -5280,8 +5395,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   bool check_profitability = false;\n   int th;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vec_transform_loop ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"=== vec_transform_loop ===\");\n \n   /* Use the more conservative vectorization threshold.  If the number\n      of iterations is constant assume the cost check has been performed\n@@ -5294,9 +5409,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   if (th >= LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1\n       && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_COST))\n-\tfprintf (vect_dump,\n-\t\t \"Profitability threshold is %d loop iterations.\", th);\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Profitability threshold is %d loop iterations.\", th);\n       check_profitability = true;\n     }\n \n@@ -5355,10 +5470,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n \t  phi = gsi_stmt (si);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"------>vectorizing phi: \");\n-\t      print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"------>vectorizing phi: \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n \t    }\n \t  stmt_info = vinfo_for_stmt (phi);\n \t  if (!stmt_info)\n@@ -5373,13 +5489,13 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t  if ((TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n \t        != (unsigned HOST_WIDE_INT) vectorization_factor)\n-\t      && vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"multiple-types.\");\n+\t      && dump_kind_p (MSG_NOTE))\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\");\n \n \t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"transform phi.\");\n+\t      if (dump_kind_p (MSG_NOTE))\n+\t\tdump_printf_loc (MSG_NOTE, vect_location, \"transform phi.\");\n \t      vect_transform_stmt (phi, NULL, NULL, NULL, NULL);\n \t    }\n \t}\n@@ -5394,10 +5510,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n           else\n             stmt = gsi_stmt (si);\n \n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"------>vectorizing statement: \");\n-\t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"------>vectorizing statement: \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n \t    }\n \n \t  stmt_info = vinfo_for_stmt (stmt);\n@@ -5465,12 +5582,13 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t\t  if (!gsi_end_p (pattern_def_si))\n \t\t    {\n-\t\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t      if (dump_kind_p (MSG_NOTE))\n \t\t\t{\n-\t\t\t  fprintf (vect_dump, \"==> vectorizing pattern def\"\n-\t\t\t\t\t      \" stmt: \");\n-\t\t\t  print_gimple_stmt (vect_dump, pattern_def_stmt, 0,\n-\t\t\t\t\t     TDF_SLIM);\n+\t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t\t   \"==> vectorizing pattern def \"\n+\t\t\t\t\t   \"stmt: \");\n+\t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n+\t\t\t\t\t    pattern_def_stmt, 0);\n \t\t\t}\n \n \t\t      stmt = pattern_def_stmt;\n@@ -5491,10 +5609,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n                                                STMT_VINFO_VECTYPE (stmt_info));\n \t  if (!STMT_SLP_TYPE (stmt_info)\n \t      && nunits != (unsigned int) vectorization_factor\n-              && vect_print_dump_info (REPORT_DETAILS))\n+              && dump_kind_p (MSG_NOTE))\n \t    /* For SLP VF is set according to unrolling factor, and not to\n \t       vector size, hence for SLP this print is not valid.  */\n-            fprintf (vect_dump, \"multiple-types.\");\n+            dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"multiple-types.\");\n \n \t  /* SLP. Schedule all the SLP instances when the first SLP stmt is\n \t     reached.  */\n@@ -5504,8 +5623,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t{\n \t\t  slp_scheduled = true;\n \n-\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t    fprintf (vect_dump, \"=== scheduling SLP instances ===\");\n+\t\t  if (dump_kind_p (MSG_NOTE))\n+\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t     \"=== scheduling SLP instances ===\");\n \n \t\t  vect_schedule_slp (loop_vinfo, NULL);\n \t\t}\n@@ -5523,8 +5643,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    }\n \n \t  /* -------- vectorize statement ------------ */\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"transform statement.\");\n+\t  if (dump_kind_p (MSG_NOTE))\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"transform statement.\");\n \n \t  grouped_store = false;\n \t  is_store = vect_transform_stmt (stmt, &si, &grouped_store, NULL, NULL);\n@@ -5566,8 +5686,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      until all the loops have been transformed?  */\n   update_ssa (TODO_update_ssa);\n \n-  if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS))\n-    fprintf (vect_dump, \"LOOP VECTORIZED.\");\n-  if (loop->inner && vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS))\n-    fprintf (vect_dump, \"OUTER LOOP VECTORIZED.\");\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \"LOOP VECTORIZED.\");\n+  if (loop->inner && dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t     \"OUTER LOOP VECTORIZED.\");\n }"}, {"sha": "b0974ec196d6511d89dd057d1ac8b19cf1527be8", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -416,10 +416,11 @@ vect_recog_dot_prod_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   pattern_stmt = gimple_build_assign_with_ops (DOT_PROD_EXPR, var,\n \t\t\t\t\t       oprnd00, oprnd01, oprnd1);\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n     {\n-      fprintf (vect_dump, \"vect_recog_dot_prod_pattern: detected: \");\n-      print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                       \"vect_recog_dot_prod_pattern: detected: \");\n+      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);\n     }\n \n   /* We don't allow changing the order of the computation in the inner-loop\n@@ -675,8 +676,9 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Pattern detected.  */\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vect_recog_widen_mult_pattern: detected: \");\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                     \"vect_recog_widen_mult_pattern: detected: \");\n \n   /* Check target support  */\n   vectype = get_vectype_for_scalar_type (half_type0);\n@@ -697,8 +699,8 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n   pattern_stmt = gimple_build_assign_with_ops (WIDEN_MULT_EXPR, var, oprnd0,\n \t\t\t\t\t       oprnd1);\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n \n   VEC_safe_push (gimple, heap, *stmts, last_stmt);\n   return pattern_stmt;\n@@ -910,10 +912,11 @@ vect_recog_widen_sum_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   pattern_stmt = gimple_build_assign_with_ops (WIDEN_SUM_EXPR, var,\n \t\t\t\t\t       oprnd0, oprnd1);\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n     {\n-      fprintf (vect_dump, \"vect_recog_widen_sum_pattern: detected: \");\n-      print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                       \"vect_recog_widen_sum_pattern: detected: \");\n+      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);\n     }\n \n   /* We don't allow changing the order of the computation in the inner-loop\n@@ -1214,10 +1217,11 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n       STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt)) = pattern_stmt;\n       new_pattern_def_seq (vinfo_for_stmt (stmt), new_def_stmt);\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n         {\n-          fprintf (vect_dump, \"created pattern stmt: \");\n-          print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                           \"created pattern stmt: \");\n+          dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);\n         }\n \n       type = gimple_expr_type (stmt);\n@@ -1281,10 +1285,11 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Pattern detected.  */\n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n     {\n-      fprintf (vect_dump, \"vect_recog_over_widening_pattern: detected: \");\n-      print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                       \"vect_recog_over_widening_pattern: detected: \");\n+      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);\n     }\n \n   return pattern_stmt;\n@@ -1416,8 +1421,9 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Pattern detected.  */\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vect_recog_widen_shift_pattern: detected: \");\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                     \"vect_recog_widen_shift_pattern: detected: \");\n \n   /* Check target support.  */\n   vectype = get_vectype_for_scalar_type (half_type0);\n@@ -1439,8 +1445,8 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n   pattern_stmt =\n     gimple_build_assign_with_ops (WIDEN_LSHIFT_EXPR, var, oprnd0, oprnd1);\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n \n   VEC_safe_push (gimple, heap, *stmts, last_stmt);\n   return pattern_stmt;\n@@ -1561,15 +1567,16 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n     }\n \n   /* Pattern detected.  */\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vect_recog_vector_vector_shift_pattern: detected: \");\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                     \"vect_recog_vector_vector_shift_pattern: detected: \");\n \n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n   var = vect_recog_temp_ssa_var (TREE_TYPE (oprnd0), NULL);\n   pattern_stmt = gimple_build_assign_with_ops (rhs_code, var, oprnd0, def);\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n \n   VEC_safe_push (gimple, heap, *stmts, last_stmt);\n   return pattern_stmt;\n@@ -1678,8 +1685,9 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \treturn NULL;\n \n       /* Pattern detected.  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"vect_recog_divmod_pattern: detected: \");\n+      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+        dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                         \"vect_recog_divmod_pattern: detected: \");\n \n       cond = build2 (LT_EXPR, boolean_type_node, oprnd0,\n \t\t     build_int_cst (itype, 0));\n@@ -1781,8 +1789,9 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \t\t\t\t\t    signmask);\n \t}\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tprint_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt,\n+                              0);\n \n       VEC_safe_push (gimple, heap, *stmts, last_stmt);\n \n@@ -2022,11 +2031,12 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n     }\n \n   /* Pattern detected.  */\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vect_recog_divmod_pattern: detected: \");\n-\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    {\n+      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                       \"vect_recog_divmod_pattern: detected: \");\n+      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);\n+    }\n \n   VEC_safe_push (gimple, heap, *stmts, last_stmt);\n \n@@ -2189,8 +2199,9 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   *type_in = vecitype;\n   *type_out = vectype;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vect_recog_mixed_size_cond_pattern: detected: \");\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                     \"vect_recog_mixed_size_cond_pattern: detected: \");\n \n   return pattern_stmt;\n }\n@@ -2581,8 +2592,9 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       *type_out = vectype;\n       *type_in = vectype;\n       VEC_safe_push (gimple, heap, *stmts, last_stmt);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"vect_recog_bool_pattern: detected: \");\n+      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n+                         \"vect_recog_bool_pattern: detected: \");\n \n       return pattern_stmt;\n     }\n@@ -2626,8 +2638,9 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       *type_out = vectype;\n       *type_in = vectype;\n       VEC_safe_push (gimple, heap, *stmts, last_stmt);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"vect_recog_bool_pattern: detected: \");\n+      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                         \"vect_recog_bool_pattern: detected: \");\n       return pattern_stmt;\n     }\n   else\n@@ -2775,10 +2788,11 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n     }\n \n   /* Found a vectorizable pattern.  */\n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n     {\n-      fprintf (vect_dump, \"pattern recognized: \");\n-      print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                       \"pattern recognized: \");\n+      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);\n     }\n \n   /* Mark the stmts that are involved in the pattern. */\n@@ -2800,10 +2814,11 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n     {\n       stmt_info = vinfo_for_stmt (stmt);\n       pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n         {\n-          fprintf (vect_dump, \"additional pattern stmt: \");\n-          print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+                           \"additional pattern stmt: \");\n+          dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);\n         }\n \n       vect_mark_pattern_stmts (stmt, pattern_stmt, NULL_TREE);\n@@ -2900,8 +2915,9 @@ vect_pattern_recog (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   VEC (gimple, heap) *stmts_to_replace = VEC_alloc (gimple, heap, 1);\n   gimple stmt;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_pattern_recog ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_pattern_recog ===\");\n \n   if (loop_vinfo)\n     {"}, {"sha": "1c4f2762fd8d6346fb1e52d4e907edbf2f64c123", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 270, "deletions": 208, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"dumpfile.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n@@ -237,10 +238,11 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t       &def, &dt)\n \t  || (!def_stmt && dt != vect_constant_def))\n \t{\n-\t  if (vect_print_dump_info (REPORT_SLP))\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t    {\n-\t      fprintf (vect_dump, \"Build SLP failed: can't find def for \");\n-\t      print_generic_expr (vect_dump, oprnd, TDF_SLIM);\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"Build SLP failed: can't find def for \");\n+\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n \t    }\n \n \t  return false;\n@@ -261,11 +263,12 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           pattern = true;\n           if (!first && !oprnd_info->first_pattern)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump, \"Build SLP failed: some of the stmts\"\n-\t\t\t\t\" are in a pattern, and others are not \");\n-\t\t  print_generic_expr (vect_dump, oprnd, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"Build SLP failed: some of the stmts\"\n+\t\t\t\t   \" are in a pattern, and others are not \");\n+\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n \t\t}\n \n \t      return false;\n@@ -276,8 +279,9 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n           if (dt == vect_unknown_def_type)\n             {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"Unsupported pattern.\");\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Unsupported pattern.\");\n               return false;\n             }\n \n@@ -292,8 +296,9 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                 break;\n \n               default:\n-                if (vect_print_dump_info (REPORT_DETAILS))\n-                  fprintf (vect_dump, \"unsupported defining stmt: \");\n+                if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"unsupported defining stmt: \");\n                 return false;\n             }\n         }\n@@ -356,8 +361,9 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t    {\n \t      if (number_of_oprnds != 2)\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_SLP))\n-\t\t    fprintf (vect_dump, \"Build SLP failed: different types \");\n+\t\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Build SLP failed: different types \");\n \n \t\t  return false;\n                 }\n@@ -382,19 +388,21 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                            && !types_compatible_p (oprnd_info->first_def_type,\n                                                    TREE_TYPE (def_op0))))\n                     {\n-                      if (vect_print_dump_info (REPORT_SLP))\n+                      if (dump_kind_p (MSG_NOTE))\n \t                {\n-\t\t\t  fprintf (vect_dump, \"Swapping operands of \");\n- \t\t          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t\t   \"Swapping operands of \");\n+ \t\t          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n \t\t\t}\n \n  \t\t      swap_tree_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n  \t                                  gimple_assign_rhs2_ptr (stmt));\n \t\t    }\n                   else\n                     {\n-         \t      if (vect_print_dump_info (REPORT_SLP))\n-\t\t\tfprintf (vect_dump, \"Build SLP failed: different types \");\n+         \t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t\t \"Build SLP failed: different types \");\n \n \t\t      return false;\n \t\t    }\n@@ -427,10 +435,11 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n \tdefault:\n \t  /* FORNOW: Not supported.  */\n-\t  if (vect_print_dump_info (REPORT_SLP))\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t    {\n-\t      fprintf (vect_dump, \"Build SLP failed: illegal type of def \");\n-\t      print_generic_expr (vect_dump, def, TDF_SLIM);\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"Build SLP failed: illegal type of def \");\n+\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, def);\n \t    }\n \n \t  return false;\n@@ -495,20 +504,20 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* For every stmt in NODE find its def stmt/s.  */\n   FOR_EACH_VEC_ELT (gimple, stmts, i, stmt)\n     {\n-      if (vect_print_dump_info (REPORT_SLP))\n+      if (dump_kind_p (MSG_NOTE))\n \t{\n-\t  fprintf (vect_dump, \"Build SLP for \");\n-\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"Build SLP for \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n \t}\n \n       /* Fail to vectorize statements marked as unvectorizable.  */\n       if (!STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n         {\n-          if (vect_print_dump_info (REPORT_SLP))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump,\n-                       \"Build SLP failed: unvectorizable statement \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"Build SLP failed: unvectorizable statement \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n \n \t  vect_free_oprnd_info (&oprnds_info);\n@@ -518,11 +527,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       lhs = gimple_get_lhs (stmt);\n       if (lhs == NULL_TREE)\n \t{\n-\t  if (vect_print_dump_info (REPORT_SLP))\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t    {\n-\t      fprintf (vect_dump,\n-\t\t       \"Build SLP failed: not GIMPLE_ASSIGN nor GIMPLE_CALL \");\n-\t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"Build SLP failed: not GIMPLE_ASSIGN nor \"\n+\t\t\t       \"GIMPLE_CALL \");\n+\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t    }\n \n \t  vect_free_oprnd_info (&oprnds_info);\n@@ -534,11 +544,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n            && (cond = gimple_assign_rhs1 (stmt))\n            && !COMPARISON_CLASS_P (cond))\n         {\n-          if (vect_print_dump_info (REPORT_SLP))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump,\n-                       \"Build SLP failed: condition is not comparison \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t       \"Build SLP failed: condition is not \"\n+\t\t\t       \"comparison \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n \n \t  vect_free_oprnd_info (&oprnds_info);\n@@ -549,10 +560,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)\n         {\n-          if (vect_print_dump_info (REPORT_SLP))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"Build SLP failed: unsupported data-type \");\n-              print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t       \"Build SLP failed: unsupported data-type \");\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t scalar_type);\n             }\n \n \t  vect_free_oprnd_info (&oprnds_info);\n@@ -578,11 +591,11 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      || !gimple_call_nothrow_p (stmt)\n \t      || gimple_call_chain (stmt))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_SLP))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump,\n-\t\t\t   \"Build SLP failed: unsupported call type \");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t   \"Build SLP failed: unsupported call type \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \n \t      vect_free_oprnd_info (&oprnds_info);\n@@ -618,17 +631,19 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n \t\t  if (!optab)\n \t\t    {\n-\t\t      if (vect_print_dump_info (REPORT_SLP))\n-\t\t\tfprintf (vect_dump, \"Build SLP failed: no optab.\");\n+\t\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t\t \"Build SLP failed: no optab.\");\n \t  \t      vect_free_oprnd_info (&oprnds_info);\n \t\t      return false;\n \t\t    }\n \t\t  icode = (int) optab_handler (optab, vec_mode);\n \t\t  if (icode == CODE_FOR_nothing)\n \t\t    {\n-\t\t      if (vect_print_dump_info (REPORT_SLP))\n-\t\t\tfprintf (vect_dump, \"Build SLP failed: \"\n-\t\t\t\t            \"op not supported by target.\");\n+\t\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t\t \"Build SLP failed: \"\n+\t\t\t\t\t \"op not supported by target.\");\n \t  \t      vect_free_oprnd_info (&oprnds_info);\n \t\t      return false;\n \t\t    }\n@@ -659,11 +674,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                        || first_stmt_code == COMPONENT_REF\n                        || first_stmt_code == MEM_REF)))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_SLP))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump,\n-\t\t\t   \"Build SLP failed: different operation in stmt \");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t   \"Build SLP failed: different operation \"\n+\t\t\t\t   \"in stmt \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \n \t      vect_free_oprnd_info (&oprnds_info);\n@@ -673,11 +689,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  if (need_same_oprnds\n \t      && !operand_equal_p (first_op1, gimple_assign_rhs2 (stmt), 0))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_SLP))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump,\n-\t\t\t   \"Build SLP failed: different shift arguments in \");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t   \"Build SLP failed: different shift \"\n+\t\t\t\t   \"arguments in \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \n \t      vect_free_oprnd_info (&oprnds_info);\n@@ -693,11 +710,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  || gimple_call_fntype (first_stmt)\n \t\t     != gimple_call_fntype (stmt))\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_SLP))\n+\t\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t    {\n-\t\t      fprintf (vect_dump,\n-\t\t\t       \"Build SLP failed: different calls in \");\n-\t\t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t       \"Build SLP failed: different calls in \");\n+\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\tstmt, 0);\n \t\t    }\n \n \t\t  vect_free_oprnd_info (&oprnds_info);\n@@ -731,11 +749,13 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                   || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != stmt\n                       && GROUP_GAP (vinfo_for_stmt (stmt)) != 1))\n                 {\n-                  if (vect_print_dump_info (REPORT_SLP))\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n                     {\n-                      fprintf (vect_dump, \"Build SLP failed: grouped \"\n-                                          \"loads have gaps \");\n-                      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t       \"Build SLP failed: grouped \"\n+\t\t\t\t       \"loads have gaps \");\n+                      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\tstmt, 0);\n                     }\n \n \t  \t  vect_free_oprnd_info (&oprnds_info);\n@@ -747,12 +767,14 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               if (loop_vinfo\n                   && GROUP_SIZE (vinfo_for_stmt (stmt)) > ncopies * group_size)\n                 {\n-                  if (vect_print_dump_info (REPORT_SLP))\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n                     {\n-                      fprintf (vect_dump, \"Build SLP failed: the number of \"\n-                                          \"interleaved loads is greater than\"\n-                                          \" the SLP group size \");\n-                      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t       \"Build SLP failed: the number \"\n+\t\t\t\t       \"of interleaved loads is greater than \"\n+\t\t\t\t       \"the SLP group size \");\n+                      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\tstmt, 0);\n                     }\n \n \t  \t  vect_free_oprnd_info (&oprnds_info);\n@@ -767,16 +789,19 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                      chains in the same node.  The only exception is complex\n                      numbers.  */\n                   if (prev_first_load != first_load\n-                      && rhs_code != REALPART_EXPR \n+                      && rhs_code != REALPART_EXPR\n                       && rhs_code != IMAGPART_EXPR)\n-                    {    \n-                      if (vect_print_dump_info (REPORT_SLP))\n+                    {\n+                      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n                         {\n-                          fprintf (vect_dump, \"Build SLP failed: different \"\n-                                           \"interleaving chains in one node \");\n-                          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                          dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t\t   vect_location, \n+\t\t\t\t\t   \"Build SLP failed: different \"\n+\t\t\t\t\t   \"interleaving chains in one node \");\n+                          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\t    stmt, 0);\n                         }\n- \n+\n \t  \t      vect_free_oprnd_info (&oprnds_info);\n                       return false;\n                     }\n@@ -792,11 +817,14 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                   if (vect_supportable_dr_alignment (first_dr, false)\n                       == dr_unaligned_unsupported)\n                     {\n-                      if (vect_print_dump_info (REPORT_SLP))\n+                      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n                         {\n-                          fprintf (vect_dump, \"Build SLP failed: unsupported \"\n-                                              \"unaligned load \");\n-                          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                          dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t\t   vect_location, \n+\t\t\t\t\t   \"Build SLP failed: unsupported \"\n+\t\t\t\t\t   \"unaligned load \");\n+                          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\t    stmt, 0);\n                         }\n \n \t  \t      vect_free_oprnd_info (&oprnds_info);\n@@ -829,10 +857,11 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  if (TREE_CODE_CLASS (rhs_code) == tcc_reference)\n \t    {\n \t      /* Not grouped load.  */\n-\t      if (vect_print_dump_info (REPORT_SLP))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump, \"Build SLP failed: not grouped load \");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t   \"Build SLP failed: not grouped load \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \n \t      /* FORNOW: Not grouped loads are not supported.  */\n@@ -846,11 +875,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      && rhs_code != COND_EXPR\n \t      && rhs_code != CALL_EXPR)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_SLP))\n+\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t{\n-\t\t  fprintf (vect_dump, \"Build SLP failed: operation\");\n-\t\t  fprintf (vect_dump, \" unsupported \");\n-\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"Build SLP failed: operation\");\n+\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" unsupported \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n \n \t      vect_free_oprnd_info (&oprnds_info);\n@@ -865,11 +895,13 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\tfirst_cond_code = TREE_CODE (cond_expr);\n               else if (first_cond_code != TREE_CODE (cond_expr))\n                 {\n-                  if (vect_print_dump_info (REPORT_SLP))\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n                     {\n-                      fprintf (vect_dump, \"Build SLP failed: different\"\n-\t\t\t\t\t  \" operation\");\n-                      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t       \"Build SLP failed: different\"\n+\t\t\t\t       \" operation\");\n+                      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\tstmt, 0);\n                     }\n \n \t\t  vect_free_oprnd_info (&oprnds_info);\n@@ -944,9 +976,10 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   return true;\n }\n \n+/* Dump a slp tree NODE using flags specified in DUMP_KIND.  */\n \n static void\n-vect_print_slp_tree (slp_tree node)\n+vect_print_slp_tree (int dump_kind, slp_tree node)\n {\n   int i;\n   gimple stmt;\n@@ -955,16 +988,16 @@ vect_print_slp_tree (slp_tree node)\n   if (!node)\n     return;\n \n-  fprintf (vect_dump, \"node \");\n+  dump_printf (dump_kind, \"node \");\n   FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n-      fprintf (vect_dump, \"\\n\\tstmt %d \", i);\n-      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+      dump_printf (dump_kind, \"\\n\\tstmt %d \", i);\n+      dump_gimple_stmt (dump_kind, TDF_SLIM, stmt, 0);\n     }\n-  fprintf (vect_dump, \"\\n\");\n+  dump_printf (dump_kind, \"\\n\");\n \n   FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n-    vect_print_slp_tree ((slp_tree) child);\n+    vect_print_slp_tree (dump_kind, (slp_tree) child);\n }\n \n \n@@ -1047,11 +1080,13 @@ vect_supported_slp_permutation_p (slp_instance instance)\n       /* Check that the loads are all in the same interleaving chain.  */\n       if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (scalar_stmt)) != first_load)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"Build SLP failed: unsupported data \"\n-                                   \"permutation \");\n-              print_gimple_stmt (vect_dump, scalar_stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"Build SLP failed: unsupported data \"\n+\t\t\t       \"permutation \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\tscalar_stmt, 0);\n             }\n \n           free (tmp_loads);\n@@ -1134,11 +1169,11 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   if (!slp_instn)\n     return false;\n \n-  if (vect_print_dump_info (REPORT_SLP))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"Load permutation \");\n+      dump_printf_loc (MSG_NOTE, vect_location, \"Load permutation \");\n       FOR_EACH_VEC_ELT (int, load_permutation, i, next)\n-        fprintf (vect_dump, \"%d \", next);\n+        dump_printf (MSG_NOTE, \"%d \", next);\n     }\n \n   /* In case of reduction every load permutation is allowed, since the order\n@@ -1341,11 +1376,13 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n                   if (vect_supportable_dr_alignment (dr, false)\n  \t               == dr_unaligned_unsupported)\n                     {\n-   \t\t      if (vect_print_dump_info (REPORT_SLP))\n+   \t\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t        {\n-  \t                  fprintf (vect_dump, \"unsupported unaligned load \");\n-                          print_gimple_stmt (vect_dump, first_load, 0,\n-\t\t\t\t\t     TDF_SLIM);\n+  \t                  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t\t   vect_location, \n+\t\t\t\t\t   \"unsupported unaligned load \");\n+                          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\t    first_load, 0);\n                         }\n   \t\t      bad_permutation = true;\n                       break;\n@@ -1499,10 +1536,11 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n   if (!vectype)\n     {\n-      if (vect_print_dump_info (REPORT_SLP))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"Build SLP failed: unsupported data-type \");\n-          print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"Build SLP failed: unsupported data-type \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, scalar_type);\n         }\n \n       return false;\n@@ -1518,9 +1556,10 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n   if (unrolling_factor != 1 && !loop_vinfo)\n     {\n-      if (vect_print_dump_info (REPORT_SLP))\n-        fprintf (vect_dump, \"Build SLP failed: unrolling required in basic\"\n-                            \" block SLP\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t \"Build SLP failed: unrolling required in basic\"\n+\t\t\t \" block SLP\");\n \n       return false;\n     }\n@@ -1579,9 +1618,10 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n       if (unrolling_factor != 1 && !loop_vinfo)\n         {\n-          if (vect_print_dump_info (REPORT_SLP))\n-            fprintf (vect_dump, \"Build SLP failed: unrolling required in basic\"\n-                               \" block SLP\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t     \"Build SLP failed: unrolling required in basic\"\n+\t\t\t     \" block SLP\");\n \t  vect_free_slp_tree (node);\n \t  VEC_free (stmt_info_for_cost, heap, body_cost_vec);\n \t  VEC_free (stmt_info_for_cost, heap, prologue_cost_vec);\n@@ -1605,11 +1645,12 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           if (!vect_supported_load_permutation_p (new_instance, group_size,\n                                                   load_permutation))\n             {\n-              if (vect_print_dump_info (REPORT_SLP))\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n                 {\n-                  fprintf (vect_dump, \"Build SLP failed: unsupported load \"\n-                                      \"permutation \");\n-                  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t\t   \"Build SLP failed: unsupported load \"\n+\t\t\t\t   \"permutation \");\n+                  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n                 }\n \n               vect_free_slp_instance (new_instance);\n@@ -1644,8 +1685,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n         VEC_safe_push (slp_instance, heap, BB_VINFO_SLP_INSTANCES (bb_vinfo),\n                        new_instance);\n \n-      if (vect_print_dump_info (REPORT_SLP))\n-\tvect_print_slp_tree (node);\n+      if (dump_kind_p (MSG_NOTE))\n+\tvect_print_slp_tree (MSG_NOTE, node);\n \n       return true;\n     }\n@@ -1676,8 +1717,8 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   gimple first_element;\n   bool ok = false;\n \n-  if (vect_print_dump_info (REPORT_SLP))\n-    fprintf (vect_dump, \"=== vect_analyze_slp ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_analyze_slp ===\");\n \n   if (loop_vinfo)\n     {\n@@ -1695,8 +1736,9 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n   if (bb_vinfo && !ok)\n     {\n-      if (vect_print_dump_info (REPORT_SLP))\n-        fprintf (vect_dump, \"Failed to SLP the basic block.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Failed to SLP the basic block.\");\n \n       return false;\n     }\n@@ -1738,8 +1780,8 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   slp_instance instance;\n   int decided_to_slp = 0;\n \n-  if (vect_print_dump_info (REPORT_SLP))\n-    fprintf (vect_dump, \"=== vect_make_slp_decision ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_make_slp_decision ===\");\n \n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n@@ -1756,9 +1798,10 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n \n   LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo) = unrolling_factor;\n \n-  if (decided_to_slp && vect_print_dump_info (REPORT_SLP))\n-    fprintf (vect_dump, \"Decided to SLP %d instances. Unrolling factor %d\",\n-\t     decided_to_slp, unrolling_factor);\n+  if (decided_to_slp && dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t     \"Decided to SLP %d instances. Unrolling factor %d\",\n+\t\t     decided_to_slp, unrolling_factor);\n \n   return (decided_to_slp > 0);\n }\n@@ -1820,8 +1863,8 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n   VEC (slp_instance, heap) *slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   slp_instance instance;\n \n-  if (vect_print_dump_info (REPORT_SLP))\n-    fprintf (vect_dump, \"=== vect_detect_hybrid_slp ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_detect_hybrid_slp ===\");\n \n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance));\n@@ -2017,14 +2060,14 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n \n   vec_outside_cost = vec_prologue_cost + vec_epilogue_cost;\n \n-  if (vect_print_dump_info (REPORT_COST))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"Cost model analysis: \\n\");\n-      fprintf (vect_dump, \"  Vector inside of basic block cost: %d\\n\",\n-               vec_inside_cost);\n-      fprintf (vect_dump, \"  Vector prologue cost: %d\\n\", vec_prologue_cost);\n-      fprintf (vect_dump, \"  Vector epilogue cost: %d\\n\", vec_epilogue_cost);\n-      fprintf (vect_dump, \"  Scalar cost of basic block: %d\", scalar_cost);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");\n+      dump_printf (MSG_NOTE, \"  Vector inside of basic block cost: %d\\n\",\n+\t\t   vec_inside_cost);\n+      dump_printf (MSG_NOTE, \"  Vector prologue cost: %d\\n\", vec_prologue_cost);\n+      dump_printf (MSG_NOTE, \"  Vector epilogue cost: %d\\n\", vec_epilogue_cost);\n+      dump_printf (MSG_NOTE, \"  Scalar cost of basic block: %d\", scalar_cost);\n     }\n \n   /* Vectorization is profitable if its cost is less than the cost of scalar\n@@ -2054,9 +2097,10 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   if (!vect_analyze_data_refs (NULL, bb_vinfo, &min_vf))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: unhandled data-ref in basic \"\n-                            \"block.\\n\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: unhandled data-ref in basic \"\n+\t\t\t \"block.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n@@ -2065,9 +2109,10 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   ddrs = BB_VINFO_DDRS (bb_vinfo);\n   if (!VEC_length (ddr_p, ddrs))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: not enough data-refs in basic \"\n-                            \"block.\\n\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: not enough data-refs in \"\n+\t\t\t \"basic block.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n@@ -2078,29 +2123,32 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo, &max_vf)\n        || min_vf > max_vf)\n      {\n-       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-\t fprintf (vect_dump, \"not vectorized: unhandled data dependence \"\n-\t\t  \"in basic block.\\n\");\n+       if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t  \"not vectorized: unhandled data dependence \"\n+\t\t\t  \"in basic block.\\n\");\n \n        destroy_bb_vec_info (bb_vinfo);\n        return NULL;\n      }\n \n   if (!vect_analyze_data_refs_alignment (NULL, bb_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: bad data alignment in basic \"\n-                            \"block.\\n\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: bad data alignment in basic \"\n+\t\t\t \"block.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n     }\n \n   if (!vect_analyze_data_ref_accesses (NULL, bb_vinfo))\n     {\n-     if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-       fprintf (vect_dump, \"not vectorized: unhandled data access in basic \"\n-                           \"block.\\n\");\n+     if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\"not vectorized: unhandled data access in \"\n+\t\t\t\"basic block.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n@@ -2110,9 +2158,10 @@ vect_slp_analyze_bb_1 (basic_block bb)\n      trees.  */\n   if (!vect_analyze_slp (NULL, bb_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: failed to find SLP opportunities \"\n-                            \"in basic block.\\n\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t \"not vectorized: failed to find SLP opportunities \"\n+\t\t\t \"in basic block.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n@@ -2130,18 +2179,19 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   if (!vect_verify_datarefs_alignment (NULL, bb_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: unsupported alignment in basic \"\n-                            \"block.\\n\");\n-\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"not vectorized: unsupported alignment in basic \"\n+                         \"block.\\n\");\n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n     }\n \n   if (!vect_slp_analyze_operations (bb_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: bad operation in basic block.\\n\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t \"not vectorized: bad operation in basic block.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n@@ -2151,16 +2201,18 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   if (flag_vect_cost_model\n       && !vect_bb_vectorization_profitable_p (bb_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: vectorization is not \"\n-                            \"profitable.\\n\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vectorization is not \"\n+\t\t\t \"profitable.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"Basic block will be vectorized using SLP\\n\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Basic block will be vectorized using SLP\\n\");\n \n   return bb_vinfo;\n }\n@@ -2174,8 +2226,8 @@ vect_slp_analyze_bb (basic_block bb)\n   gimple_stmt_iterator gsi;\n   unsigned int vector_sizes;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"===vect_slp_analyze_bb===\\n\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"===vect_slp_analyze_bb===\\n\");\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n@@ -2188,9 +2240,10 @@ vect_slp_analyze_bb (basic_block bb)\n \n   if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: too many instructions in basic \"\n-                            \"block.\\n\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: too many instructions in \"\n+\t\t\t \"basic block.\\n\");\n \n       return NULL;\n     }\n@@ -2214,9 +2267,10 @@ vect_slp_analyze_bb (basic_block bb)\n \n       /* Try the next biggest vector size.  */\n       current_vector_size = 1 << floor_log2 (vector_sizes);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"***** Re-trying analysis with \"\n-                 \"vector size %d\\n\", current_vector_size);\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Re-trying analysis with \"\n+\t\t\t \"vector size %d\\n\", current_vector_size);\n     }\n }\n \n@@ -2238,8 +2292,9 @@ vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n   stmt_info_for_cost *si;\n   void *data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n-  if (vect_print_dump_info (REPORT_SLP))\n-    fprintf (vect_dump, \"=== vect_update_slp_costs_according_to_vf ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"=== vect_update_slp_costs_according_to_vf ===\");\n \n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n@@ -2719,10 +2774,11 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n      the next vector as well.  */\n   if (only_one_vec && *current_mask_element >= mask_nunits)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"permutation requires at least two vectors \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t\t   \"permutation requires at least two vectors \");\n+          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n         }\n \n       return false;\n@@ -2736,11 +2792,12 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n           /* We either need the first vector too or have already moved to the\n              next vector. In both cases, this permutation needs three\n              vectors.  */\n-          if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-              fprintf (vect_dump, \"permutation requires at \"\n-                                  \"least three vectors \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"permutation requires at \"\n+\t\t\t       \"least three vectors \");\n+              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n \n           return false;\n@@ -2801,10 +2858,11 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \n   if (!can_vec_perm_p (mode, false, NULL))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"no vect permute for \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"no vect permute for \");\n+          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n         }\n       return false;\n     }\n@@ -2880,12 +2938,15 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \n \t\t  if (!can_vec_perm_p (mode, false, mask))\n \t\t    {\n-\t\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t\t\t{\n-\t\t\t  fprintf (vect_dump, \"unsupported vect permute { \");\n+\t\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t\t   vect_location, \n+\t\t\t\t\t   \"unsupported vect permute { \");\n \t\t\t  for (i = 0; i < nunits; ++i)\n-\t\t\t    fprintf (vect_dump, \"%d \", mask[i]);\n-\t\t\t  fprintf (vect_dump, \"}\\n\");\n+\t\t\t    dump_printf (MSG_MISSED_OPTIMIZATION, \"%d \",\n+\t\t\t\t\t mask[i]);\n+\t\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"}\\n\");\n \t\t\t}\n \t\t      return false;\n \t\t    }\n@@ -2981,10 +3042,11 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       SLP_TREE_NUMBER_OF_VEC_STMTS (node) = vec_stmts_size;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"------>vectorizing SLP node starting from: \");\n-      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE,vect_location,\n+\t\t       \"------>vectorizing SLP node starting from: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n     }\n \n   /* Loads should be inserted before the first load.  */\n@@ -3089,9 +3151,9 @@ vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       /* Schedule the tree of INSTANCE.  */\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n                                              instance, vf);\n-      if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS)\n-\t  || vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-\tfprintf (vect_dump, \"vectorizing stmts using SLP.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"vectorizing stmts using SLP.\");\n     }\n \n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n@@ -3134,18 +3196,19 @@ vect_slp_transform_bb (basic_block bb)\n \n   gcc_assert (bb_vinfo);\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"SLPing BB\\n\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB\\n\");\n \n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       gimple stmt = gsi_stmt (si);\n       stmt_vec_info stmt_info;\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"------>SLPing statement: \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"------>SLPing statement: \");\n+          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n         }\n \n       stmt_info = vinfo_for_stmt (stmt);\n@@ -3159,9 +3222,8 @@ vect_slp_transform_bb (basic_block bb)\n         }\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"BASIC BLOCK VECTORIZED\\n\");\n+  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+    dump_printf (MSG_OPTIMIZED_LOCATIONS, \"BASIC BLOCK VECTORIZED\\n\");\n \n   destroy_bb_vec_info (bb_vinfo);\n }\n-"}, {"sha": "1cc37ff22560a85d9829f54080867e5a330e27d0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 396, "deletions": 298, "changes": 694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"dumpfile.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n@@ -189,8 +190,9 @@ vect_mark_relevant (VEC(gimple,heap) **worklist, gimple stmt,\n   bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n   gimple pattern_stmt;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"mark relevant %d, live %d.\", relevant, live_p);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"mark relevant %d, live %d.\", relevant, live_p);\n \n   /* If this stmt is an original stmt in a pattern, we might need to mark its\n      related pattern stmt instead of the original stmt.  However, such stmts\n@@ -244,9 +246,10 @@ vect_mark_relevant (VEC(gimple,heap) **worklist, gimple stmt,\n \n           pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n \n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"last stmt in pattern. don't mark\"\n-                                \" relevant/live.\");\n+          if (dump_kind_p (MSG_NOTE))\n+            dump_printf_loc (MSG_NOTE, vect_location,\n+                             \"last stmt in pattern. don't mark\"\n+                             \" relevant/live.\");\n           stmt_info = vinfo_for_stmt (pattern_stmt);\n           gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == stmt);\n           save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n@@ -262,8 +265,9 @@ vect_mark_relevant (VEC(gimple,heap) **worklist, gimple stmt,\n   if (STMT_VINFO_RELEVANT (stmt_info) == save_relevant\n       && STMT_VINFO_LIVE_P (stmt_info) == save_live_p)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"already marked relevant/live.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"already marked relevant/live.\");\n       return;\n     }\n \n@@ -306,8 +310,9 @@ vect_stmt_relevant_p (gimple stmt, loop_vec_info loop_vinfo,\n   if (gimple_code (stmt) != GIMPLE_PHI)\n     if (gimple_vdef (stmt))\n       {\n-\tif (vect_print_dump_info (REPORT_DETAILS))\n-\t  fprintf (vect_dump, \"vec_stmt_relevant_p: stmt has vdefs.\");\n+\tif (dump_kind_p (MSG_NOTE))\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"vec_stmt_relevant_p: stmt has vdefs.\");\n \t*relevant = vect_used_in_scope;\n       }\n \n@@ -319,8 +324,9 @@ vect_stmt_relevant_p (gimple stmt, loop_vec_info loop_vinfo,\n \t  basic_block bb = gimple_bb (USE_STMT (use_p));\n \t  if (!flow_bb_inside_loop_p (loop, bb))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"vec_stmt_relevant_p: used out of loop.\");\n+\t      if (dump_kind_p (MSG_NOTE))\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+                                 \"vec_stmt_relevant_p: used out of loop.\");\n \n \t      if (is_gimple_debug (USE_STMT (use_p)))\n \t\tcontinue;\n@@ -431,8 +437,9 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \n   if (!vect_is_simple_use (use, stmt, loop_vinfo, NULL, &def_stmt, &def, &dt))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"not vectorized: unsupported use in stmt.\");\n       return false;\n     }\n \n@@ -442,8 +449,8 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   def_bb = gimple_bb (def_stmt);\n   if (!flow_bb_inside_loop_p (loop, def_bb))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"def_stmt is out of loop.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"def_stmt is out of loop.\");\n       return true;\n     }\n \n@@ -460,8 +467,9 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n       && STMT_VINFO_DEF_TYPE (dstmt_vinfo) == vect_reduction_def\n       && bb->loop_father == def_bb->loop_father)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"reduc-stmt defining reduc-phi in the same nest.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"reduc-stmt defining reduc-phi in the same nest.\");\n       if (STMT_VINFO_IN_PATTERN_P (dstmt_vinfo))\n \tdstmt_vinfo = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (dstmt_vinfo));\n       gcc_assert (STMT_VINFO_RELEVANT (dstmt_vinfo) < vect_used_by_reduction);\n@@ -479,8 +487,9 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \t\t...\t\t  */\n   if (flow_loop_nested_p (def_bb->loop_father, bb->loop_father))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"outer-loop def-stmt defining inner-loop stmt.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"outer-loop def-stmt defining inner-loop stmt.\");\n \n       switch (relevant)\n \t{\n@@ -516,8 +525,9 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \t\tstmt # use (d)\t\t*/\n   else if (flow_loop_nested_p (bb->loop_father, def_bb->loop_father))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"inner-loop def-stmt defining outer-loop stmt.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"inner-loop def-stmt defining outer-loop stmt.\");\n \n       switch (relevant)\n         {\n@@ -579,8 +589,9 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   enum vect_relevant relevant, tmp_relevant;\n   enum vect_def_type def_type;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_mark_stmts_to_be_vectorized ===\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_mark_stmts_to_be_vectorized ===\");\n \n   worklist = VEC_alloc (gimple, heap, 64);\n \n@@ -591,10 +602,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  phi = gsi_stmt (si);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"init: phi relevant? \");\n-\t      print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \"init: phi relevant? \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n \t    }\n \n \t  if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant, &live_p))\n@@ -603,10 +614,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  stmt = gsi_stmt (si);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  if (dump_kind_p (MSG_NOTE))\n \t    {\n-\t      fprintf (vect_dump, \"init: stmt relevant? \");\n-\t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \"init: stmt relevant? \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n \t    }\n \n \t  if (vect_stmt_relevant_p (stmt, loop_vinfo, &relevant, &live_p))\n@@ -621,10 +632,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       ssa_op_iter iter;\n \n       stmt = VEC_pop (gimple, worklist);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n \t{\n-          fprintf (vect_dump, \"worklist: examine stmt: \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location, \"worklist: examine stmt: \");\n+          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n \t}\n \n       /* Examine the USEs of STMT. For each USE, mark the stmt that defines it\n@@ -666,9 +677,9 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   \t          /* fall through */\n \n \t        default:\n-\t          if (vect_print_dump_info (REPORT_DETAILS))\n-\t            fprintf (vect_dump, \"unsupported use of reduction.\");\n-\n+\t          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                     \"unsupported use of reduction.\");\n   \t          VEC_free (gimple, heap, worklist);\n \t          return false;\n \t      }\n@@ -681,8 +692,9 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n                 && tmp_relevant != vect_used_in_outer_by_reduction\n                 && tmp_relevant != vect_used_in_outer)\n               {\n-                if (vect_print_dump_info (REPORT_DETAILS))\n-                  fprintf (vect_dump, \"unsupported use of nested cycle.\");\n+                if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                   \"unsupported use of nested cycle.\");\n \n                 VEC_free (gimple, heap, worklist);\n                 return false;\n@@ -695,8 +707,9 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n             if (tmp_relevant != vect_unused_in_scope\n                 && tmp_relevant != vect_used_by_reduction)\n               {\n-                if (vect_print_dump_info (REPORT_DETAILS))\n-                  fprintf (vect_dump, \"unsupported use of double reduction.\");\n+                if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                   \"unsupported use of double reduction.\");\n \n                 VEC_free (gimple, heap, worklist);\n                 return false;\n@@ -817,9 +830,10 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   inside_cost = record_stmt_cost (body_cost_vec, ncopies, vector_stmt,\n \t\t\t\t  stmt_info, 0, vect_body);\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"vect_model_simple_cost: inside_cost = %d, \"\n-             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"vect_model_simple_cost: inside_cost = %d, \"\n+                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n \n@@ -862,9 +876,10 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n       prologue_cost += add_stmt_cost (target_cost_data, 1, vector_stmt,\n \t\t\t\t      stmt_info, 0, vect_prologue);\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"vect_model_promotion_demotion_cost: inside_cost = %d, \"\n-             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"vect_model_promotion_demotion_cost: inside_cost = %d, \"\n+                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n /* Function vect_cost_group_size\n@@ -945,17 +960,19 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n       inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n \t\t\t\t      stmt_info, 0, vect_body);\n \n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"vect_model_store_cost: strided group_size = %d .\",\n-                 group_size);\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"vect_model_store_cost: strided group_size = %d .\",\n+                         group_size);\n     }\n \n   /* Costs of the stores.  */\n   vect_get_store_cost (first_dr, ncopies, &inside_cost, body_cost_vec);\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"vect_model_store_cost: inside_cost = %d, \"\n-             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"vect_model_store_cost: inside_cost = %d, \"\n+                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n \n@@ -977,9 +994,9 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \t\t\t\t\t  vector_store, stmt_info, 0,\n \t\t\t\t\t  vect_body);\n \n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump, \"vect_model_store_cost: aligned.\");\n-\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"vect_model_store_cost: aligned.\");\n         break;\n       }\n \n@@ -989,21 +1006,20 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \t*inside_cost += record_stmt_cost (body_cost_vec, ncopies,\n \t\t\t\t\t  unaligned_store, stmt_info,\n \t\t\t\t\t  DR_MISALIGNMENT (dr), vect_body);\n-\n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump, \"vect_model_store_cost: unaligned supported by \"\n-                   \"hardware.\");\n-\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"vect_model_store_cost: unaligned supported by \"\n+                           \"hardware.\");\n         break;\n       }\n \n     case dr_unaligned_unsupported:\n       {\n         *inside_cost = VECT_MAX_COST;\n \n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump, \"vect_model_store_cost: unsupported access.\");\n-\n+        if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"vect_model_store_cost: unsupported access.\");\n         break;\n       }\n \n@@ -1060,9 +1076,10 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n       inside_cost += record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n \t\t\t\t       stmt_info, 0, vect_body);\n \n-      if (vect_print_dump_info (REPORT_COST))\n-        fprintf (vect_dump, \"vect_model_load_cost: strided group_size = %d .\",\n-                 group_size);\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location, \n+                         \"vect_model_load_cost: strided group_size = %d .\",\n+                         group_size);\n     }\n \n   /* The loads themselves.  */\n@@ -1083,9 +1100,10 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\t&inside_cost, &prologue_cost, \n \t\t\tprologue_cost_vec, body_cost_vec, true);\n \n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"vect_model_load_cost: inside_cost = %d, \"\n-             \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"vect_model_load_cost: inside_cost = %d, \"\n+                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n }\n \n \n@@ -1109,8 +1127,9 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t*inside_cost += record_stmt_cost (body_cost_vec, ncopies, vector_load,\n \t\t\t\t\t  stmt_info, 0, vect_body);\n \n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump, \"vect_model_load_cost: aligned.\");\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"vect_model_load_cost: aligned.\");\n \n         break;\n       }\n@@ -1121,9 +1140,10 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t\t\t\t\t  unaligned_load, stmt_info,\n \t\t\t\t\t  DR_MISALIGNMENT (dr), vect_body);\n \n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump, \"vect_model_load_cost: unaligned supported by \"\n-                   \"hardware.\");\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"vect_model_load_cost: unaligned supported by \"\n+                           \"hardware.\");\n \n         break;\n       }\n@@ -1141,16 +1161,18 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t  *inside_cost += record_stmt_cost (body_cost_vec, 1, vector_stmt,\n \t\t\t\t\t    stmt_info, 0, vect_body);\n \n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump, \"vect_model_load_cost: explicit realign\");\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location, \n+                           \"vect_model_load_cost: explicit realign\");\n \n         break;\n       }\n     case dr_explicit_realign_optimized:\n       {\n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump, \"vect_model_load_cost: unaligned software \"\n-                   \"pipelined.\");\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location, \n+                           \"vect_model_load_cost: unaligned software \"\n+                           \"pipelined.\");\n \n         /* Unaligned software pipeline has a load of an address, an initial\n            load, and possibly a mask operation to \"prime\" the loop.  However,\n@@ -1175,9 +1197,9 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t*inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_perm,\n \t\t\t\t\t  stmt_info, 0, vect_body);\n \n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump,\n-\t\t   \"vect_model_load_cost: explicit realign optimized\");\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"vect_model_load_cost: explicit realign optimized\");\n \n         break;\n       }\n@@ -1186,9 +1208,9 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n       {\n         *inside_cost = VECT_MAX_COST;\n \n-        if (vect_print_dump_info (REPORT_COST))\n-          fprintf (vect_dump, \"vect_model_load_cost: unsupported access.\");\n-\n+        if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"vect_model_load_cost: unsupported access.\");\n         break;\n       }\n \n@@ -1236,10 +1258,11 @@ vect_init_vector_1 (gimple stmt, gimple new_stmt, gimple_stmt_iterator *gsi)\n        }\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"created new init_stmt: \");\n-      print_gimple_stmt (vect_dump, new_stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+                       \"created new init_stmt: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n     }\n }\n \n@@ -1317,26 +1340,32 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n   bool is_simple_use;\n   tree vector_type;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"vect_get_vec_def_for_operand: \");\n-      print_generic_expr (vect_dump, op, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+                       \"vect_get_vec_def_for_operand: \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, op);\n     }\n \n   is_simple_use = vect_is_simple_use (op, stmt, loop_vinfo, NULL,\n \t\t\t\t      &def_stmt, &def, &dt);\n   gcc_assert (is_simple_use);\n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n+      int loc_printed = 0;\n       if (def)\n         {\n-          fprintf (vect_dump, \"def =  \");\n-          print_generic_expr (vect_dump, def, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location, \"def =  \");\n+          loc_printed = 1;\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, def);\n         }\n       if (def_stmt)\n         {\n-          fprintf (vect_dump, \"  def_stmt =  \");\n-\t  print_gimple_stmt (vect_dump, def_stmt, 0, TDF_SLIM);\n+          if (loc_printed)\n+            dump_printf (MSG_NOTE, \"  def_stmt =  \");\n+          else\n+            dump_printf_loc (MSG_NOTE, vect_location, \"  def_stmt =  \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n         }\n     }\n \n@@ -1353,8 +1382,9 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \t  *scalar_def = op;\n \n         /* Create 'vect_cst_ = {cst,cst,...,cst}'  */\n-        if (vect_print_dump_info (REPORT_DETAILS))\n-          fprintf (vect_dump, \"Create vector_cst. nunits = %d\", nunits);\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"Create vector_cst. nunits = %d\", nunits);\n \n         return vect_init_vector (stmt, op, vector_type, NULL);\n       }\n@@ -1369,8 +1399,8 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \t  *scalar_def = def;\n \n         /* Create 'vec_inv = {inv,inv,..,inv}'  */\n-        if (vect_print_dump_info (REPORT_DETAILS))\n-          fprintf (vect_dump, \"Create vector_inv.\");\n+        if (dump_kind_p (MSG_NOTE))\n+          dump_printf_loc (MSG_NOTE, vect_location, \"Create vector_inv.\");\n \n         return vect_init_vector (stmt, def, vector_type, NULL);\n       }\n@@ -1631,10 +1661,10 @@ vect_finish_stmt_generation (gimple stmt, gimple vec_stmt,\n   set_vinfo_for_stmt (vec_stmt, new_stmt_vec_info (vec_stmt, loop_vinfo,\n                                                    bb_vinfo));\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"add new stmt: \");\n-      print_gimple_stmt (vect_dump, vec_stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vec_stmt, 0);\n     }\n \n   gimple_set_location (vec_stmt, gimple_location (stmt));\n@@ -1734,8 +1764,9 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if (rhs_type\n \t  && !types_compatible_p (rhs_type, TREE_TYPE (op)))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"argument types differ.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"argument types differ.\");\n \t  return false;\n \t}\n       if (!rhs_type)\n@@ -1744,8 +1775,9 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n \t\t\t\t &def_stmt, &def, &dt[i], &opvectype))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"use not simple.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"use not simple.\");\n \t  return false;\n \t}\n \n@@ -1754,8 +1786,9 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       else if (opvectype\n \t       && opvectype != vectype_in)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"argument vector types differ.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"argument vector types differ.\");\n \t  return false;\n \t}\n     }\n@@ -1767,10 +1800,11 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     gcc_assert (vectype_in);\n   if (!vectype_in)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"no vectype for scalar type \");\n-          print_generic_expr (vect_dump, rhs_type, TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"no vectype for scalar type \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, rhs_type);\n         }\n \n       return false;\n@@ -1795,8 +1829,9 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   fndecl = vectorizable_function (stmt, vectype_out, vectype_in);\n   if (fndecl == NULL_TREE)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"function is not vectorizable.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"function is not vectorizable.\");\n \n       return false;\n     }\n@@ -1817,16 +1852,16 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"=== vectorizable_call ===\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform call.\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform call.\");\n \n   /* Handle def.  */\n   scalar_dest = gimple_call_lhs (stmt);\n@@ -2340,18 +2375,19 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  && (TYPE_PRECISION (rhs_type)\n \t      != GET_MODE_PRECISION (TYPE_MODE (rhs_type)))))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump,\n-\t\t \"type conversion to/from bit-precision unsupported.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"type conversion to/from bit-precision unsupported.\");\n       return false;\n     }\n \n   /* Check the operands of the operation.  */\n   if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"use not simple.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"use not simple.\");\n       return false;\n     }\n   if (op_type == binary_op)\n@@ -2371,8 +2407,9 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n       if (!ok)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"use not simple.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"use not simple.\");\n \t  return false;\n \t}\n     }\n@@ -2385,10 +2422,11 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     gcc_assert (vectype_in);\n   if (!vectype_in)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n \t{\n-\t  fprintf (vect_dump, \"no vectype for scalar type \");\n-\t  print_generic_expr (vect_dump, rhs_type, TDF_SLIM);\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"no vectype for scalar type \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, rhs_type);\n \t}\n \n       return false;\n@@ -2428,8 +2466,9 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \tbreak;\n       /* FALLTHRU */\n     unsupported:\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"conversion not supported by target.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"conversion not supported by target.\");\n       return false;\n \n     case WIDEN:\n@@ -2526,8 +2565,9 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (!vec_stmt)\t\t/* transformation not required.  */\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"=== vectorizable_conversion ===\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"=== vectorizable_conversion ===\");\n       if (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR)\n         {\n \t  STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n@@ -2548,8 +2588,9 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /** Transform.  **/\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform conversion. ncopies = %d.\", ncopies);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"transform conversion. ncopies = %d.\", ncopies);\n \n   if (op_type == binary_op)\n     {\n@@ -2900,8 +2941,9 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"use not simple.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"use not simple.\");\n       return false;\n     }\n \n@@ -2928,24 +2970,26 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n \t    > TYPE_PRECISION (TREE_TYPE (op)))\n \t   && TYPE_UNSIGNED (TREE_TYPE (op))))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"type conversion to/from bit-precision \"\n-\t\t \"unsupported.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"type conversion to/from bit-precision \"\n+                         \"unsupported.\");\n       return false;\n     }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"=== vectorizable_assignment ===\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"=== vectorizable_assignment ===\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform assignment.\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform assignment.\");\n \n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -3091,17 +3135,19 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   if (TYPE_PRECISION (TREE_TYPE (scalar_dest))\n       != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"bit-precision shifts not supported.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"bit-precision shifts not supported.\");\n       return false;\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n   if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n                              &def_stmt, &def, &dt[0], &vectype))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"use not simple.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"use not simple.\");\n       return false;\n     }\n   /* If op0 is an external or constant def use a vector type with\n@@ -3112,12 +3158,9 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     gcc_assert (vectype);\n   if (!vectype)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        {\n-          fprintf (vect_dump, \"no vectype for scalar type \");\n-          print_generic_expr (vect_dump, TREE_TYPE (op0), TDF_SLIM);\n-        }\n-\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"no vectype for scalar type \");\n       return false;\n     }\n \n@@ -3130,8 +3173,9 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use_1 (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t     &def, &dt[1], &op1_vectype))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"use not simple.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"use not simple.\");\n       return false;\n     }\n \n@@ -3174,25 +3218,29 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n   else\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"operand mode requires invariant argument.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"operand mode requires invariant argument.\");\n       return false;\n     }\n \n   /* Vector shifted by vector.  */\n   if (!scalar_shift_arg)\n     {\n       optab = optab_for_tree_code (code, vectype, optab_vector);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"vector/vector shift/rotate found.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"vector/vector shift/rotate found.\");\n+\n       if (!op1_vectype)\n \top1_vectype = get_same_sized_vectype (TREE_TYPE (op1), vectype_out);\n       if (op1_vectype == NULL_TREE\n \t  || TYPE_MODE (op1_vectype) != TYPE_MODE (vectype))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"unusable type for last operand in\"\n-\t\t\t\t\" vector/vector shift/rotate.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"unusable type for last operand in\"\n+                             \" vector/vector shift/rotate.\");\n \t  return false;\n \t}\n     }\n@@ -3204,8 +3252,9 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n       if (optab\n           && optab_handler (optab, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"vector/scalar shift/rotate found.\");\n+          if (dump_kind_p (MSG_NOTE))\n+            dump_printf_loc (MSG_NOTE, vect_location,\n+                             \"vector/scalar shift/rotate found.\");\n         }\n       else\n         {\n@@ -3216,8 +3265,9 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n             {\n \t      scalar_shift_arg = false;\n \n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"vector/vector shift/rotate found.\");\n+              if (dump_kind_p (MSG_NOTE))\n+                dump_printf_loc (MSG_NOTE, vect_location,\n+                                 \"vector/vector shift/rotate found.\");\n \n               /* Unlike the other binary operators, shifts/rotates have\n                  the rhs being int, instead of the same type as the lhs,\n@@ -3232,9 +3282,10 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t      && TYPE_MODE (TREE_TYPE (vectype))\n \t\t\t != TYPE_MODE (TREE_TYPE (op1)))\n \t\t    {\n-\t\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t      fprintf (vect_dump, \"unusable type for last operand in\"\n-\t\t\t\t\t  \" vector/vector shift/rotate.\");\n+                      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                         \"unusable type for last operand in\"\n+                                         \" vector/vector shift/rotate.\");\n \t\t\treturn false;\n \t\t    }\n \t\t  if (vec_stmt && !slp_node)\n@@ -3251,48 +3302,52 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Supportable by target?  */\n   if (!optab)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"no optab.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"no optab.\");\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n   icode = (int) optab_handler (optab, vec_mode);\n   if (icode == CODE_FOR_nothing)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"op not supported by target.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"op not supported by target.\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n           || (vf < vect_min_worthwhile_factor (code)\n               && !vec_stmt))\n         return false;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"proceeding using word mode.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location, \"proceeding using word mode.\");\n     }\n \n   /* Worthwhile without SIMD support?  Check only during analysis.  */\n   if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n       && vf < vect_min_worthwhile_factor (code)\n       && !vec_stmt)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"not worthwhile without SIMD support.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"not worthwhile without SIMD support.\");\n       return false;\n     }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = shift_vec_info_type;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"=== vectorizable_shift ===\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_shift ===\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform binary/unary operation.\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"transform binary/unary operation.\");\n \n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -3327,8 +3382,9 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n               optab_op2_mode = insn_data[icode].operand[2].mode;\n               if (!VECTOR_MODE_P (optab_op2_mode))\n                 {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump, \"operand 1 using scalar mode.\");\n+                  if (dump_kind_p (MSG_NOTE))\n+                    dump_printf_loc (MSG_NOTE, vect_location,\n+                                     \"operand 1 using scalar mode.\");\n                   vec_oprnd1 = op1;\n                   VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n                   if (slp_node)\n@@ -3454,9 +3510,10 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   op_type = TREE_CODE_LENGTH (code);\n   if (op_type != unary_op && op_type != binary_op && op_type != ternary_op)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"num. args = %d (not unary/binary/ternary op).\",\n-\t\t op_type);\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"num. args = %d (not unary/binary/ternary op).\",\n+                         op_type);\n       return false;\n     }\n \n@@ -3472,17 +3529,19 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       && code != BIT_XOR_EXPR\n       && code != BIT_AND_EXPR)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"bit-precision arithmetic not supported.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"bit-precision arithmetic not supported.\");\n       return false;\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n   if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"use not simple.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"use not simple.\");\n       return false;\n     }\n   /* If op0 is an external or constant def use a vector type with\n@@ -3493,10 +3552,12 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     gcc_assert (vectype);\n   if (!vectype)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"no vectype for scalar type \");\n-          print_generic_expr (vect_dump, TREE_TYPE (op0), TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"no vectype for scalar type \");\n+          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                             TREE_TYPE (op0));\n         }\n \n       return false;\n@@ -3513,8 +3574,9 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       if (!vect_is_simple_use (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t       &def, &dt[1]))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"use not simple.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"use not simple.\");\n \t  return false;\n \t}\n     }\n@@ -3524,8 +3586,9 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       if (!vect_is_simple_use (op2, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t       &def, &dt[2]))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"use not simple.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"use not simple.\");\n \t  return false;\n \t}\n     }\n@@ -3565,48 +3628,52 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       optab = optab_for_tree_code (code, vectype, optab_default);\n       if (!optab)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"no optab.\");\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"no optab.\");\n \t  return false;\n \t}\n       icode = (int) optab_handler (optab, vec_mode);\n     }\n \n   if (icode == CODE_FOR_nothing)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"op not supported by target.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"op not supported by target.\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n \t  || (!vec_stmt && vf < vect_min_worthwhile_factor (code)))\n         return false;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"proceeding using word mode.\");\n+      if (dump_kind_p (MSG_NOTE))\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"proceeding using word mode.\");\n     }\n \n   /* Worthwhile without SIMD support?  Check only during analysis.  */\n   if (!VECTOR_MODE_P (vec_mode)\n       && !vec_stmt\n       && vf < vect_min_worthwhile_factor (code))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"not worthwhile without SIMD support.\");\n-      return false;\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"not worthwhile without SIMD support.\");\n     }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"=== vectorizable_operation ===\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"=== vectorizable_operation ===\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform binary/unary operation.\");\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"transform binary/unary operation.\");\n \n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -3792,8 +3859,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   /* FORNOW. This restriction should be relaxed.  */\n   if (loop && nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"multiple types in nested loop.\");\n       return false;\n     }\n \n@@ -3825,8 +3893,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vect_is_simple_use (op, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t   &def, &dt))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"use not simple.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"use not simple.\");\n       return false;\n     }\n \n@@ -3845,8 +3914,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t    ? STMT_VINFO_DR_STEP (stmt_info) : DR_STEP (dr),\n \t\t\t    size_zero_node) < 0)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"negative step for store.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"negative step for store.\");\n       return false;\n     }\n \n@@ -3875,8 +3945,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n               if (!vect_is_simple_use (op, next_stmt, loop_vinfo, bb_vinfo,\n \t\t\t\t       &def_stmt, &def, &dt))\n                 {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump, \"use not simple.\");\n+                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                     \"use not simple.\");\n                   return false;\n                 }\n               next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n@@ -3936,8 +4007,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       group_size = vec_num = 1;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform store. ncopies = %d\",ncopies);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"transform store. ncopies = %d\", ncopies);\n \n   dr_chain = VEC_alloc (tree, heap, group_size);\n   oprnds = VEC_alloc (tree, heap, group_size);\n@@ -4323,8 +4395,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   /* FORNOW. This restriction should be relaxed.  */\n   if (nested_in_vect_loop && ncopies > 1)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"multiple types in nested loop.\");\n       return false;\n     }\n \n@@ -4362,8 +4435,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     (e.g. - data copies).  */\n   if (optab_handler (mov_optab, mode) == CODE_FOR_nothing)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"Aligned load, but unsupported type.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"Aligned load, but unsupported type.\");\n       return false;\n     }\n \n@@ -4397,8 +4471,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t &def_stmt, &def, &gather_dt,\n \t\t\t\t &gather_off_vectype))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"gather index use not simple.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"gather index use not simple.\");\n \t  return false;\n \t}\n     }\n@@ -4416,8 +4491,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t       size_zero_node) < 0;\n       if (negative && ncopies > 1)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"multiple types with negative step.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"multiple types with negative step.\");\n \t  return false;\n \t}\n \n@@ -4428,14 +4504,16 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  if (alignment_support_scheme != dr_aligned\n \t      && alignment_support_scheme != dr_unaligned_supported)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"negative step but alignment required.\");\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                 \"negative step but alignment required.\");\n \t      return false;\n \t    }\n \t  if (!perm_mask_for_reverse (vectype))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"negative step and reversing not supported.\");\n+              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                 \"negative step and reversing not supported.\");\n \t      return false;\n \t    }\n \t}\n@@ -4448,8 +4526,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return true;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform load. ncopies = %d\", ncopies);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"transform load. ncopies = %d\", ncopies);\n \n   /** Transform.  **/\n \n@@ -5248,8 +5327,9 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"value used after loop.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"value used after loop.\");\n       return false;\n     }\n \n@@ -5447,16 +5527,17 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   gimple pattern_stmt;\n   gimple_seq pattern_def_seq;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"==> examining statement: \");\n-      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n     }\n \n   if (gimple_has_volatile_ops (stmt))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: stmt has volatile operands\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"not vectorized: stmt has volatile operands\");\n \n       return false;\n     }\n@@ -5487,16 +5568,17 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n           /* Analyze PATTERN_STMT instead of the original stmt.  */\n           stmt = pattern_stmt;\n           stmt_info = vinfo_for_stmt (pattern_stmt);\n-          if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_NOTE))\n             {\n-              fprintf (vect_dump, \"==> examining pattern statement: \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+              dump_printf_loc (MSG_NOTE, vect_location,\n+                               \"==> examining pattern statement: \");\n+              dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n             }\n         }\n       else\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"irrelevant.\");\n+          if (dump_kind_p (MSG_NOTE))\n+            dump_printf_loc (MSG_NOTE, vect_location, \"irrelevant.\");\n \n           return true;\n         }\n@@ -5508,10 +5590,11 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n     {\n       /* Analyze PATTERN_STMT too.  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"==> examining pattern statement: \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"==> examining pattern statement: \");\n+          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n         }\n \n       if (!vect_analyze_stmt (pattern_stmt, need_to_vectorize, node))\n@@ -5531,10 +5614,11 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \t      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt)))\n \t    {\n \t      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t      if (dump_kind_p (MSG_NOTE))\n \t\t{\n-\t\t  fprintf (vect_dump, \"==> examining pattern def statement: \");\n-\t\t  print_gimple_stmt (vect_dump, pattern_def_stmt, 0, TDF_SLIM);\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+                                   \"==> examining pattern def statement: \");\n+\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_def_stmt, 0);\n \t\t}\n \n \t      if (!vect_analyze_stmt (pattern_def_stmt,\n@@ -5569,27 +5653,30 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n       gcc_assert (PURE_SLP_STMT (stmt_info));\n \n       scalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"get vectype for scalar type:  \");\n-          print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"get vectype for scalar type:  \");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n         }\n \n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n+          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n             {\n-               fprintf (vect_dump, \"not SLPed: unsupported data-type \");\n-               print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                \"not SLPed: unsupported data-type \");\n+               dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                  scalar_type);\n             }\n           return false;\n         }\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (dump_kind_p (MSG_NOTE))\n         {\n-          fprintf (vect_dump, \"vectype:  \");\n-          print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+          dump_printf_loc (MSG_NOTE, vect_location, \"vectype:  \");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n         }\n \n       STMT_VINFO_VECTYPE (stmt_info) = vectype;\n@@ -5630,11 +5717,12 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"not vectorized: relevant stmt not \");\n-          fprintf (vect_dump, \"supported: \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"not vectorized: relevant stmt not \");\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"supported: \");\n+          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n         }\n \n       return false;\n@@ -5651,11 +5739,12 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \n   if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n         {\n-          fprintf (vect_dump, \"not vectorized: live stmt not \");\n-          fprintf (vect_dump, \"supported: \");\n-          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"not vectorized: live stmt not \");\n+          dump_printf (MSG_MISSED_OPTIMIZATION,  \"supported: \");\n+          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n         }\n \n        return false;\n@@ -5750,8 +5839,9 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n     default:\n       if (!STMT_VINFO_LIVE_P (stmt_info))\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"stmt not supported.\");\n+\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"stmt not supported.\");\n \t  gcc_unreachable ();\n \t}\n     }\n@@ -5774,8 +5864,9 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n       tree scalar_dest;\n       gimple exit_phi;\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"Record the vdef for outer-loop vectorization.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"Record the vdef for outer-loop vectorization.\");\n \n       /* Find the relevant loop-exit phi-node, and reord the vec_stmt there\n         (to be used when vectorizing outer-loop stmts that use the DEF of\n@@ -6005,26 +6096,28 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n     return NULL_TREE;\n \n   vectype = build_vector_type (scalar_type, nunits);\n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"get vectype with %d units of type \", nunits);\n-      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+                       \"get vectype with %d units of type \", nunits);\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n     }\n \n   if (!vectype)\n     return NULL_TREE;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"vectype: \");\n-      print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n     }\n \n   if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n       && !INTEGRAL_MODE_P (TYPE_MODE (vectype)))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"mode not supported by target.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"mode not supported by target.\");\n       return NULL_TREE;\n     }\n \n@@ -6093,10 +6186,11 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n   *def_stmt = NULL;\n   *def = NULL_TREE;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"vect_is_simple_use: operand \");\n-      print_generic_expr (vect_dump, operand, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+                       \"vect_is_simple_use: operand \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, operand);\n     }\n \n   if (CONSTANT_CLASS_P (operand))\n@@ -6114,30 +6208,32 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n \n   if (TREE_CODE (operand) == PAREN_EXPR)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"non-associatable copy.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location, \"non-associatable copy.\");\n       operand = TREE_OPERAND (operand, 0);\n     }\n \n   if (TREE_CODE (operand) != SSA_NAME)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"not ssa-name.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"not ssa-name.\");\n       return false;\n     }\n \n   *def_stmt = SSA_NAME_DEF_STMT (operand);\n   if (*def_stmt == NULL)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"no def_stmt.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"no def_stmt.\");\n       return false;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (dump_kind_p (MSG_NOTE))\n     {\n-      fprintf (vect_dump, \"def_stmt: \");\n-      print_gimple_stmt (vect_dump, *def_stmt, 0, TDF_SLIM);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"def_stmt: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, *def_stmt, 0);\n     }\n \n   /* Empty stmt is expected only in case of a function argument.\n@@ -6166,13 +6262,14 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n \t  && *dt == vect_double_reduction_def\n \t  && gimple_code (stmt) != GIMPLE_PHI))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"Unsupported pattern.\");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"Unsupported pattern.\");\n       return false;\n     }\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"type of def: %d.\",*dt);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location, \"type of def: %d.\", *dt);\n \n   switch (gimple_code (*def_stmt))\n     {\n@@ -6190,8 +6287,9 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n \tbreak;\n       /* FALLTHRU */\n     default:\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"unsupported defining stmt: \");\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"unsupported defining stmt: \");\n       return false;\n     }\n "}, {"sha": "777a126bb2ccdde9304f2b5c25c2ae1928285805", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 18, "deletions": 113, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"dumpfile.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n@@ -67,96 +68,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"tree-pass.h\"\n \n-/* vect_dump will be set to stderr or dump_file if exist.  */\n-FILE *vect_dump;\n-\n-/* vect_verbosity_level set to an invalid value\n-   to mark that it's uninitialized.  */\n-static enum vect_verbosity_levels vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n-\n /* Loop or bb location.  */\n LOC vect_location;\n \n /* Vector mapping GIMPLE stmt to stmt_vec_info. */\n VEC(vec_void_p,heap) *stmt_vec_info_vec;\n \n \f\n-\n-/* Function vect_set_dump_settings.\n-\n-   Fix the verbosity level of the vectorizer if the\n-   requested level was not set explicitly using the flag\n-   -ftree-vectorizer-verbose=N.\n-   Decide where to print the debugging information (dump_file/stderr).\n-   If the user defined the verbosity level, but there is no dump file,\n-   print to stderr, otherwise print to the dump file.  */\n-\n-static void\n-vect_set_dump_settings (bool slp)\n-{\n-  vect_dump = dump_file;\n-\n-  /* Check if the verbosity level was defined by the user:  */\n-  if (user_vect_verbosity_level != MAX_VERBOSITY_LEVEL)\n-    {\n-      vect_verbosity_level = user_vect_verbosity_level;\n-      /* Ignore user defined verbosity if dump flags require higher level of\n-         verbosity.  */\n-      if (dump_file)\n-        {\n-          if (((dump_flags & TDF_DETAILS)\n-                && vect_verbosity_level >= REPORT_DETAILS)\n-  \t       || ((dump_flags & TDF_STATS)\n-\t            && vect_verbosity_level >= REPORT_UNVECTORIZED_LOCATIONS))\n-            return;\n-        }\n-      else\n-        {\n-          /* If there is no dump file, print to stderr in case of loop\n-             vectorization.  */\n-          if (!slp)\n-            vect_dump = stderr;\n-\n-          return;\n-        }\n-    }\n-\n-  /* User didn't specify verbosity level:  */\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    vect_verbosity_level = REPORT_DETAILS;\n-  else if (dump_file && (dump_flags & TDF_STATS))\n-    vect_verbosity_level = REPORT_UNVECTORIZED_LOCATIONS;\n-  else\n-    vect_verbosity_level = REPORT_NONE;\n-\n-  gcc_assert (dump_file || vect_verbosity_level == REPORT_NONE);\n-}\n-\n-\n-/* Function debug_loop_details.\n-\n-   For vectorization debug dumps.  */\n-\n-bool\n-vect_print_dump_info (enum vect_verbosity_levels vl)\n-{\n-  if (vl > vect_verbosity_level)\n-    return false;\n-\n-  if (!current_function_decl || !vect_dump)\n-    return false;\n-\n-  if (vect_location == UNKNOWN_LOC)\n-    fprintf (vect_dump, \"\\n%s:%d: note: \",\n-\t     DECL_SOURCE_FILE (current_function_decl),\n-\t     DECL_SOURCE_LINE (current_function_decl));\n-  else\n-    fprintf (vect_dump, \"\\n%d: \", LOC_LINE (vect_location));\n-\n-  return true;\n-}\n-\n-\n /* Function vectorize_loops.\n \n    Entry point to loop vectorization phase.  */\n@@ -176,9 +94,6 @@ vectorize_loops (void)\n   if (vect_loops_num <= 1)\n     return 0;\n \n-  /* Fix the verbosity level if not defined explicitly by the user.  */\n-  vect_set_dump_settings (false);\n-\n   init_stmt_vec_info_vec ();\n \n   /*  ----------- Analyze loops. -----------  */\n@@ -190,36 +105,32 @@ vectorize_loops (void)\n     if (optimize_loop_nest_for_speed_p (loop))\n       {\n \tloop_vec_info loop_vinfo;\n-\n \tvect_location = find_loop_location (loop);\n-        if (vect_location != UNKNOWN_LOC\n-            && vect_verbosity_level > REPORT_NONE)\n-\t  fprintf (vect_dump, \"\\nAnalyzing loop at %s:%d\\n\",\n-            LOC_FILE (vect_location), LOC_LINE (vect_location));\n+        if (vect_location != UNKNOWN_LOC && dump_kind_p (MSG_ALL))\n+\t  dump_printf (MSG_ALL, \"\\nAnalyzing loop at %s:%d\\n\",\n+                       LOC_FILE (vect_location), LOC_LINE (vect_location));\n \n \tloop_vinfo = vect_analyze_loop (loop);\n \tloop->aux = loop_vinfo;\n \n \tif (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n \t  continue;\n \n-        if (vect_location != UNKNOWN_LOC\n-            && vect_verbosity_level > REPORT_NONE)\n-          fprintf (vect_dump, \"\\n\\nVectorizing loop at %s:%d\\n\",\n-            LOC_FILE (vect_location), LOC_LINE (vect_location));\n-\n+        if (vect_location != UNKNOWN_LOC && dump_kind_p (MSG_ALL))\n+          dump_printf (MSG_ALL, \"\\n\\nVectorizing loop at %s:%d\\n\",\n+                       LOC_FILE (vect_location), LOC_LINE (vect_location));\n \tvect_transform_loop (loop_vinfo);\n \tnum_vectorized_loops++;\n       }\n \n   vect_location = UNKNOWN_LOC;\n \n   statistics_counter_event (cfun, \"Vectorized loops\", num_vectorized_loops);\n-  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS)\n-      || (num_vectorized_loops > 0\n-\t  && vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS)))\n-    fprintf (vect_dump, \"vectorized %u loops in function.\\n\",\n-\t     num_vectorized_loops);\n+  if (dump_kind_p (MSG_ALL)\n+      || (num_vectorized_loops > 0 && dump_kind_p (MSG_ALL)))\n+    dump_printf_loc (MSG_ALL, vect_location,\n+                     \"vectorized %u loops in function.\\n\",\n+                     num_vectorized_loops);\n \n   /*  ----------- Finalize. -----------  */\n \n@@ -248,9 +159,6 @@ execute_vect_slp (void)\n {\n   basic_block bb;\n \n-  /* Fix the verbosity level if not defined explicitly by the user.  */\n-  vect_set_dump_settings (true);\n-\n   init_stmt_vec_info_vec ();\n \n   FOR_EACH_BB (bb)\n@@ -260,9 +168,9 @@ execute_vect_slp (void)\n       if (vect_slp_analyze_bb (bb))\n         {\n           vect_slp_transform_bb (bb);\n-\n-          if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS))\n-            fprintf (vect_dump, \"basic block vectorized using SLP\\n\");\n+          if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+            dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t     \"basic block vectorized using SLP\\n\");\n         }\n     }\n \n@@ -335,12 +243,9 @@ increase_alignment (void)\n         {\n           DECL_ALIGN (decl) = TYPE_ALIGN (vectype);\n           DECL_USER_ALIGN (decl) = 1;\n-          if (dump_file)\n-            {\n-              fprintf (dump_file, \"Increasing alignment of decl: \");\n-              print_generic_expr (dump_file, decl, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-            }\n+          dump_printf (MSG_NOTE, \"Increasing alignment of decl: \");\n+          dump_generic_expr (MSG_NOTE, TDF_SLIM, decl);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n     }\n   return 0;"}, {"sha": "6c997760cd7c5dce83a75c822083dbc26e5d4e54", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c60e3da2d1a25ac13b725980e5f4dd53b9df60/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=78c60e3da2d1a25ac13b725980e5f4dd53b9df60", "patch": "@@ -848,9 +848,8 @@ known_alignment_for_access_p (struct data_reference *data_ref_info)\n   return (DR_MISALIGNMENT (data_ref_info) != -1);\n }\n \n-/* vect_dump will be set to stderr or dump_file if exist.  */\n-extern FILE *vect_dump;\n-extern LOC vect_loop_location;\n+/* Source location */\n+extern LOC vect_location;\n \n /*-----------------------------------------------------------------*/\n /* Function prototypes.                                            */\n@@ -1012,7 +1011,5 @@ void vect_pattern_recog (loop_vec_info, bb_vec_info);\n \n /* In tree-vectorizer.c.  */\n unsigned vectorize_loops (void);\n-/* Vectorization debug information */\n-extern bool vect_print_dump_info (enum vect_verbosity_levels);\n \n #endif  /* GCC_TREE_VECTORIZER_H  */"}]}