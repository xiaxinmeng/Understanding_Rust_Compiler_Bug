{"sha": "23475a8131d2bd284758bcab85fa1c5bb98f1010", "node_id": "C_kwDOANBUbNoAKDIzNDc1YTgxMzFkMmJkMjg0NzU4YmNhYjg1ZmExYzViYjk4ZjEwMTA", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-10-02T20:50:52Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-10-02T21:03:54Z"}, "message": "Fix lexer to not produce bad unicode escape values\n\nThere were a couple of issues in the lexer unicode escape code.\nUnicode escape sequences must always start with an opening curly\nbracket (and end with a closing one). Underscores are not allowed as\nstarting character. And the produced values must be unicode scalar\nvalues, which excludes surrogate values (D800 to DFFF) or values\nlarger than 10FFFF.\n\nAlso try to recover more gracefully from errors by trying to skip past\nany bad characters to the end of the escape sequence.\n\nTest all of the above in a new testcase unicode_escape.rs.", "tree": {"sha": "49aa28db4ebc157b521ea49547de2a5b21ec6af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49aa28db4ebc157b521ea49547de2a5b21ec6af5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23475a8131d2bd284758bcab85fa1c5bb98f1010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23475a8131d2bd284758bcab85fa1c5bb98f1010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23475a8131d2bd284758bcab85fa1c5bb98f1010", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23475a8131d2bd284758bcab85fa1c5bb98f1010/comments", "author": null, "committer": null, "parents": [{"sha": "fdcad086e134b889ba542fadc1150bb2fcef8aea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdcad086e134b889ba542fadc1150bb2fcef8aea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdcad086e134b889ba542fadc1150bb2fcef8aea"}], "stats": {"total": 148, "additions": 132, "deletions": 16}, "files": [{"sha": "2b3c89b48be82bc7d2246e12f782b019c2299887", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23475a8131d2bd284758bcab85fa1c5bb98f1010/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23475a8131d2bd284758bcab85fa1c5bb98f1010/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=23475a8131d2bd284758bcab85fa1c5bb98f1010", "patch": "@@ -1273,6 +1273,8 @@ Lexer::parse_escape (char opening_char)\n       rust_error_at (get_current_location (),\n \t\t     \"cannot have a unicode escape \\\\u in a byte %s\",\n \t\t     opening_char == '\\'' ? \"character\" : \"string\");\n+      // Try to parse it anyway, just to skip it\n+      parse_partial_unicode_escape ();\n       return std::make_tuple (output_char, additional_length_offset, false);\n     case '\\r':\n     case '\\n':\n@@ -1461,16 +1463,34 @@ Lexer::parse_partial_unicode_escape ()\n {\n   skip_input ();\n   current_char = peek_input ();\n-  int additional_length_offset = 1;\n+  int additional_length_offset = 0;\n \n-  bool need_close_brace = false;\n-  if (current_char == '{')\n+  if (current_char != '{')\n     {\n-      need_close_brace = true;\n+      rust_error_at (get_current_location (),\n+\t\t     \"unicode escape should start with %<{%>\");\n+      /* Skip what should probaby have been between brackets.  */\n+      while (is_x_digit (current_char) || current_char == '_')\n+\t{\n+\t  skip_input ();\n+\t  current_char = peek_input ();\n+\t  additional_length_offset++;\n+\t}\n+      return std::make_pair (Codepoint (0), additional_length_offset);\n+    }\n \n+  skip_input ();\n+  current_char = peek_input ();\n+  additional_length_offset++;\n+\n+  if (current_char == '_')\n+    {\n+      rust_error_at (get_current_location (),\n+\t\t     \"unicode escape cannot start with %<_%>\");\n       skip_input ();\n       current_char = peek_input ();\n       additional_length_offset++;\n+      // fallthrough and try to parse the rest anyway\n     }\n \n   // parse unicode escape - 1-6 hex digits\n@@ -1500,21 +1520,45 @@ Lexer::parse_partial_unicode_escape ()\n       current_char = peek_input ();\n     }\n \n-  // ensure closing brace if required\n-  if (need_close_brace)\n+  if (current_char == '}')\n     {\n-      if (current_char == '}')\n+      skip_input ();\n+      current_char = peek_input ();\n+      additional_length_offset++;\n+    }\n+  else\n+    {\n+      // actually an error, but allow propagation anyway Assume that\n+      // wrong bracketm whitespace or single/double quotes are wrong\n+      // termination, otherwise it is a wrong character, then skip to the actual\n+      // terminator.\n+      if (current_char == '{' || is_whitespace (current_char)\n+\t  || current_char == '\\'' || current_char == '\"')\n \t{\n-\t  skip_input ();\n-\t  current_char = peek_input ();\n-\t  additional_length_offset++;\n+\t  rust_error_at (get_current_location (),\n+\t\t\t \"expected terminating %<}%> in unicode escape\");\n+\t  return std::make_pair (Codepoint (0), additional_length_offset);\n \t}\n       else\n \t{\n-\t  // actually an error, but allow propagation anyway\n \t  rust_error_at (get_current_location (),\n-\t\t\t \"expected terminating %<}%> in unicode escape\");\n-\t  // return false;\n+\t\t\t \"invalid character %<%c%> in unicode escape\",\n+\t\t\t current_char);\n+\t  while (current_char != '}' && current_char != '{'\n+\t\t && !is_whitespace (current_char) && current_char != '\\''\n+\t\t && current_char != '\"')\n+\t    {\n+\t      skip_input ();\n+\t      current_char = peek_input ();\n+\t      additional_length_offset++;\n+\t    }\n+\t  // Consume the actual closing bracket if found\n+\t  if (current_char == '}')\n+\t    {\n+\t      skip_input ();\n+\t      current_char = peek_input ();\n+\t      additional_length_offset++;\n+\t    }\n \t  return std::make_pair (Codepoint (0), additional_length_offset);\n \t}\n     }\n@@ -1530,10 +1574,22 @@ Lexer::parse_partial_unicode_escape ()\n       return std::make_pair (Codepoint (0), additional_length_offset);\n     }\n \n-  long hex_num = std::strtol (num_str.c_str (), nullptr, 16);\n+  unsigned long hex_num = std::strtoul (num_str.c_str (), nullptr, 16);\n \n-  // assert fits a uint32_t\n-  gcc_assert (hex_num < 4294967296);\n+  if (hex_num > 0xd7ff && hex_num < 0xe000)\n+    {\n+      rust_error_at (\n+\tget_current_location (),\n+\t\"unicode escape cannot be a surrogate value (D800 to DFFF)\");\n+      return std::make_pair (Codepoint (0), additional_length_offset);\n+    }\n+\n+  if (hex_num > 0x10ffff)\n+    {\n+      rust_error_at (get_current_location (),\n+\t\t     \"unicode escape cannot be larger than 10FFFF\");\n+      return std::make_pair (Codepoint (0), additional_length_offset);\n+    }\n \n   // return true;\n   return std::make_pair (Codepoint (static_cast<uint32_t> (hex_num)),"}, {"sha": "39b91d8a95c3cb6a6b24fbfa6dfa06ab14105e48", "filename": "gcc/testsuite/rust/compile/unicode_escape.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23475a8131d2bd284758bcab85fa1c5bb98f1010/gcc%2Ftestsuite%2Frust%2Fcompile%2Funicode_escape.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23475a8131d2bd284758bcab85fa1c5bb98f1010/gcc%2Ftestsuite%2Frust%2Fcompile%2Funicode_escape.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Funicode_escape.rs?ref=23475a8131d2bd284758bcab85fa1c5bb98f1010", "patch": "@@ -0,0 +1,60 @@\n+fn main ()\n+{\n+  // Braces are required\n+  let _cbl = '\\u013'; // { dg-error \"unicode escape\" }\n+  let _sbl = \"\\u013\"; //{ dg-error \"unicode escape\" }\n+\n+  // One to six hex digits\n+  let _c0 = '\\u{}'; // { dg-error \"unicode escape\" }\n+  let _c1 = '\\u{0}';\n+  let _c2 = '\\u{00}';\n+  let _c3 = '\\u{000}';\n+  let _c4 = '\\u{0000}';\n+  let _c5 = '\\u{00000}';\n+  let _c6 = '\\u{000000}';\n+  let _c7 = '\\u{0000000}'; // { dg-error \"unicode escape\" }\n+\n+  let _s0 = \"\\u{}\"; // { dg-error \"unicode escape\" }\n+  let _s1 = \"\\u{0}\";\n+  let _s2 = \"\\u{00}\";\n+  let _s3 = \"\\u{000}\";\n+  let _s4 = \"\\u{0000}\";\n+  let _s5 = \"\\u{00000}\";\n+  let _s6 = \"\\u{000000}\";\n+  let _s7 = \"\\u{0000000}\"; // { dg-error \"unicode escape\" }\n+\n+  // Underscores OK except for start\n+  let _c_ = '\\u{00___01__0_1_}';\n+  let _s_ = \"\\u{00___01__0_1_}\";\n+  let _c__ = '\\u{_00__01__0_}'; // { dg-error \"unicode escape\" }\n+  let _s__ = \"\\u{_00__01__0_}\"; // { dg-error \"unicode escape\" }\n+\n+  // Must be hex chars\n+  let _chex = '\\u{hex}';  // { dg-error \"unicode escape\" }\n+  let _shex = '\\u{hex}';  // { dg-error \"unicode escape\" }\n+\n+  // Only valid from 0x0 to 0xD7FF and from 0xE000 to 0x10FFF\n+  let _cd7ff = '\\u{D7FF}';\n+  let _sd7ff = \"\\u{D7FF}\";\n+  let _cd800 = '\\u{D800}'; // { dg-error \"unicode escape\" }\n+  let _sd800 = \"\\u{D800}\"; // { dg-error \"unicode escape\" }\n+\n+  let _cdfff = '\\u{DFFF}'; // { dg-error \"unicode escape\" }\n+  let _sdfff = \"\\u{DFFF}\"; // { dg-error \"unicode escape\" }\n+  let _ce000 = '\\u{E000}';\n+  let _se000 = \"\\u{E000}\";\n+\n+  let _clast = '\\u{10FFFF}';\n+  let _slast = \"\\u{10FFFF}\";\n+  let _clast1 = '\\u{110000}'; // { dg-error \"unicode escape\" }\n+  let _slast1 = \"\\u{110000}\"; // { dg-error \"unicode escape\" }\n+\n+  let _cffffff = '\\u{FFFFFF}'; // { dg-error \"unicode escape\" }\n+  let _sffffff = \"\\u{FFFFFF}\"; // { dg-error \"unicode escape\" }\n+\n+  // unicode escapes cannot be used in bytes or byte strings.\n+  // Except in raw byte strings (where they aren't escapes).\n+  let _bc = b'\\u{000A}'; // { dg-error \"unicode escape\" }\n+  let _bs = b\"\\u{000A}\"; // { dg-error \"unicode escape\" }\n+  let _rbs = br\"\\u{000A}\";\n+}"}]}