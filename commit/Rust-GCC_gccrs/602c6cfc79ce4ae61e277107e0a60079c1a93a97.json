{"sha": "602c6cfc79ce4ae61e277107e0a60079c1a93a97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAyYzZjZmM3OWNlNGFlNjFlMjc3MTA3ZTBhNjAwNzljMWE5M2E5Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-13T14:58:41Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-13T15:04:48Z"}, "message": "Improve handling of memory operands in ipa-icf 2/4\n\nthis patch iplements new class ao_compare that is derived from operand_compare\nand adds a method to compare and hash ao_refs.  This is used by ICF to enable\nmore merging.\n\nComparsion is done as follows\n\n1) Verify that the memory access will happen at the same address\n   and will have same size.\n\n   For constant addresses this is done by comparing ao_ref_base\n   and offset/size\n\n   For varable accesses it uses operand_equal_p but with OEP_ADDRESS\n   (that does not match TBAA metadata) and then operand_equal_p on\n   type size.\n\n2) Compare alignments.  I use get_object_alignment_1 like ipa-icf\n   did before revamp to operand_equal_p in gcc 9.\n   I noticed that return value is bitodd so added a comment\n\n3) Match MR_DEPENDENCE_CLIQUE\n\nAt this point the memory refrences are same except for TBAA information.\nWe continue by checking\n\n4) ref and base alias sets.  Now if lto streaming is going to happen\n   instead of comparing alias sets themselves we compare alias_ptr_types\n\n   (the patch depends on the ao_ref_alias_ptr_tyep and\n    ao_ref_base_alias_ptr_type acessors I sent yesterday)\n\n5) See if accesses are view converted.\n   If they are we are done since access path is not present\n\n6) Compare the part of access path relevant for TBAA.\n   I recall FRE relies on the fact that if base and ref types are same the\n   access path is, but I do not thing this is 100% reliable especially with LTO\n   alias sets.\n\n   The access path comparsion logic is also useful for modref (for next stage1).\n   Tracking the access paths improves quite noticeably disambiguation in C++\n   code by being able to distinquish different fields of same type within a\n   struct.  I had the comparsion logic in my tree for some time and it seems to\n   work quite well.\n\n   During cc1plus build we have some cases where we find mismatch after matching\n   the base/ref alias sets.  These are due to failed type merging: access path\n   oracle in LTO uses TYPE_MAIN_VARIANTs.\n\nI implemented relatively basic hashing using base and offset.\n\ngcc/ChangeLog:\n\t* ipa-icf-gimple.c: Include tree-ssa-alias-compare.h.\n\t(find_checker::func_checker): Initialize m_tbaa.\n\t(func_checker::hash_operand): Use hash_ao_ref for memory accesses.\n\t(func_checker::compare_operand): Use compare_ao_refs for memory\n\taccesses.\n\t(func_checker::cmopare_gimple_assign): Do not check LHS types\n\tof memory stores.\n\t* ipa-icf-gimple.h (func_checker): Derive from ao_compare;\n\tadd m_tbaa.\n\t* ipa-icf.c: Include tree-ssa-alias-compare.h.\n\t(sem_function::equals_private): Update call of\n\tfunc_checker::func_checker.\n\t* ipa-utils.h (lto_streaming_expected_p): New inline\n\tpredicate.\n\t* tree-ssa-alias-compare.h: New file.\n\t* tree-ssa-alias.c: Include tree-ssa-alias-compare.h\n\tand bultins.h\n\t(view_converted_memref_p): New function.\n\t(types_equal_for_same_type_for_tbaa_p): New function.\n\t(ao_ref_alias_ptr_type, ao_ref_base_alias_ptr_type): New functions.\n\t(ao_compare::compare_ao_refs): New member function.\n\t(ao_compare::hash_ao_ref): New function\n\t* tree-ssa-alias.h (ao_ref_base_alias_ptr_type,\n\tao_ref_alias_ptr_type): Declare.\n\ngcc/testsuite/ChangeLog:\n\t* c-c++-common/Wstringop-overflow-2.c: Disable ICF.\n\t* g++.dg/warn/Warray-bounds-8.C: Disable ICF.", "tree": {"sha": "18887e2bfad2d6da7bcb7079212922628d6130d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18887e2bfad2d6da7bcb7079212922628d6130d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/602c6cfc79ce4ae61e277107e0a60079c1a93a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602c6cfc79ce4ae61e277107e0a60079c1a93a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602c6cfc79ce4ae61e277107e0a60079c1a93a97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602c6cfc79ce4ae61e277107e0a60079c1a93a97/comments", "author": null, "committer": null, "parents": [{"sha": "a1fdc16da341187846dd0577e96ee00df5f28608", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fdc16da341187846dd0577e96ee00df5f28608", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1fdc16da341187846dd0577e96ee00df5f28608"}], "stats": {"total": 523, "additions": 499, "deletions": 24}, "files": [{"sha": "ffb1baddbdb03bfb9d3f04c0b6ee300677a731e7", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"gimple-walk.h\"\n \n+#include \"tree-ssa-alias-compare.h\"\n #include \"ipa-icf-gimple.h\"\n \n namespace ipa_icf_gimple {\n@@ -52,13 +53,13 @@ namespace ipa_icf_gimple {\n    of declarations that can be skipped.  */\n \n func_checker::func_checker (tree source_func_decl, tree target_func_decl,\n-\t\t\t    bool ignore_labels,\n+\t\t\t    bool ignore_labels, bool tbaa,\n \t\t\t    hash_set<symtab_node *> *ignored_source_nodes,\n \t\t\t    hash_set<symtab_node *> *ignored_target_nodes)\n   : m_source_func_decl (source_func_decl), m_target_func_decl (target_func_decl),\n     m_ignored_source_nodes (ignored_source_nodes),\n     m_ignored_target_nodes (ignored_target_nodes),\n-    m_ignore_labels (ignore_labels)\n+    m_ignore_labels (ignore_labels), m_tbaa (tbaa)\n {\n   function *source_func = DECL_STRUCT_FUNCTION (source_func_decl);\n   function *target_func = DECL_STRUCT_FUNCTION (target_func_decl);\n@@ -252,9 +253,16 @@ func_checker::hash_operand (const_tree arg, inchash::hash &hstate,\n \n void\n func_checker::hash_operand (const_tree arg, inchash::hash &hstate,\n-\t\t\t    unsigned int flags, operand_access_type)\n+\t\t\t    unsigned int flags, operand_access_type access)\n {\n-  return hash_operand (arg, hstate, flags);\n+  if (access == OP_MEMORY)\n+    {\n+      ao_ref ref;\n+      ao_ref_init (&ref, const_cast <tree> (arg));\n+      return hash_ao_ref (&ref, lto_streaming_expected_p (), m_tbaa, hstate);\n+    }\n+  else\n+    return hash_operand (arg, hstate, flags);\n }\n \n bool\n@@ -314,18 +322,40 @@ func_checker::compare_operand (tree t1, tree t2, operand_access_type access)\n     return true;\n   else if (!t1 || !t2)\n     return false;\n-  if (operand_equal_p (t1, t2, OEP_MATCH_SIDE_EFFECTS))\n-    return true;\n-  switch (access)\n+  if (access == OP_MEMORY)\n     {\n-    case OP_MEMORY:\n-      return return_false_with_msg\n-\t\t (\"operand_equal_p failed (access == memory)\");\n-    case OP_NORMAL:\n+      ao_ref ref1, ref2;\n+      ao_ref_init (&ref1, const_cast <tree> (t1));\n+      ao_ref_init (&ref2, const_cast <tree> (t2));\n+      int flags = compare_ao_refs (&ref1, &ref2,\n+\t\t\t\t   lto_streaming_expected_p (), m_tbaa);\n+\n+      if (!flags)\n+\treturn true;\n+      if (flags & SEMANTICS)\n+\treturn return_false_with_msg\n+\t\t(\"compare_ao_refs failed (semantic difference)\");\n+      if (flags & BASE_ALIAS_SET)\n+\treturn return_false_with_msg\n+\t\t(\"compare_ao_refs failed (base alias set difference)\");\n+      if (flags & REF_ALIAS_SET)\n+\treturn return_false_with_msg\n+\t\t (\"compare_ao_refs failed (ref alias set difference)\");\n+      if (flags & ACCESS_PATH)\n+\treturn return_false_with_msg\n+\t\t (\"compare_ao_refs failed (access path difference)\");\n+      if (flags & DEPENDENCE_CLIQUE)\n+\treturn return_false_with_msg\n+\t\t (\"compare_ao_refs failed (dependence clique difference)\");\n+      gcc_unreachable ();\n+    }\n+  else\n+    {\n+      if (operand_equal_p (t1, t2, OEP_MATCH_SIDE_EFFECTS))\n+\treturn true;\n       return return_false_with_msg\n-\t\t (\"operand_equal_p failed (access == normal)\");\n+\t\t (\"operand_equal_p failed\");\n     }\n-  gcc_unreachable ();\n }\n \n bool\n@@ -593,10 +623,17 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n \n   tree fntype1 = gimple_call_fntype (s1);\n   tree fntype2 = gimple_call_fntype (s2);\n-  if ((fntype1 && !fntype2)\n-      || (!fntype1 && fntype2)\n-      || (fntype1 && !types_compatible_p (fntype1, fntype2)))\n-    return return_false_with_msg (\"call function types are not compatible\");\n+\n+  /* For direct calls we verify that types are comopatible so if we matced\n+     callees, callers must match, too.  For indirect calls however verify\n+     function type.  */\n+  if (!gimple_call_fndecl (s1))\n+    {\n+      if ((fntype1 && !fntype2)\n+\t  || (!fntype1 && fntype2)\n+\t  || (fntype1 && !types_compatible_p (fntype1, fntype2)))\n+\treturn return_false_with_msg (\"call function types are not compatible\");\n+    }\n \n   if (fntype1 && fntype2 && comp_type_attributes (fntype1, fntype2) != 1)\n     return return_false_with_msg (\"different fntype attributes\");\n@@ -652,10 +689,10 @@ func_checker::compare_gimple_assign (gimple *s1, gimple *s2)\n       arg2 = gimple_op (s2, i);\n \n       /* Compare types for LHS.  */\n-      if (i == 0)\n+      if (i == 0 && !gimple_store_p (s1))\n \t{\n \t  if (!compatible_types_p (TREE_TYPE (arg1), TREE_TYPE (arg2)))\n-\t    return return_false_with_msg (\"GIMPLE NOP LHS type mismatch\");\n+\t    return return_false_with_msg (\"GIMPLE LHS type mismatch\");\n \t}\n \n       if (!compare_operand (arg1, arg2, get_operand_access_type (&map, arg1)))"}, {"sha": "40f7474738ef2ff5647715ef35c4e521bb7ed931", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -118,14 +118,14 @@ class sem_bb\n \n /* A class aggregating all connections and semantic equivalents\n    for a given pair of semantic function candidates.  */\n-class func_checker : operand_compare\n+class func_checker : ao_compare\n {\n public:\n   /* Default constructor.  */\n   func_checker ():\n     m_source_func_decl (NULL_TREE), m_target_func_decl (NULL_TREE),\n     m_ignored_source_nodes (NULL), m_ignored_target_nodes (NULL),\n-    m_ignore_labels (false)\n+    m_ignore_labels (false), m_tbaa (true)\n   {\n     m_source_ssa_names.create (0);\n     m_target_ssa_names.create (0);\n@@ -139,6 +139,7 @@ class func_checker : operand_compare\n      of declarations that can be skipped.  */\n   func_checker (tree source_func_decl, tree target_func_decl,\n \t\tbool ignore_labels = false,\n+\t\tbool tbaa = true,\n \t\thash_set<symtab_node *> *ignored_source_nodes = NULL,\n \t\thash_set<symtab_node *> *ignored_target_nodes = NULL);\n \n@@ -275,6 +276,9 @@ class func_checker : operand_compare\n   /* Flag if ignore labels in comparison.  */\n   bool m_ignore_labels;\n \n+  /* Flag if we should compare type based alias analysis info.  */\n+  bool m_tbaa;\n+\n public:\n   /* Return true if two operands are equal.  The flags fields can be used\n      to specify OEP flags described above.  */"}, {"sha": "a283195a487431b49c5c96a44effabd1fbf5009a", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -78,6 +78,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"print-tree.h\"\n #include \"ipa-utils.h\"\n+#include \"tree-ssa-alias-compare.h\"\n #include \"ipa-icf-gimple.h\"\n #include \"fibonacci_heap.h\"\n #include \"ipa-icf.h\"\n@@ -843,6 +844,8 @@ sem_function::equals_private (sem_item *item)\n \n   m_checker = new func_checker (decl, m_compared_func->decl,\n \t\t\t\tfalse,\n+\t\t\t\topt_for_fn (m_compared_func->decl,\n+\t\t\t\t\t    flag_strict_aliasing),\n \t\t\t\t&refs_set,\n \t\t\t\t&m_compared_func->refs_set);\n   arg1 = DECL_ARGUMENTS (decl);"}, {"sha": "880e527c590ae70407e0a267596d751d0487c34f", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -265,4 +265,16 @@ get_odr_name_for_type (tree type)\n   return IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (type_name));\n }\n \n+/* Return true if we are going to do LTO streaming.  */\n+\n+inline bool\n+lto_streaming_expected_p ()\n+{\n+  /* Compilation before LTO stremaing.  */\n+  if (flag_lto && !in_lto_p && symtab->state < IPA_SSA_AFTER_INLINING)\n+    return true;\n+  /* WPA or incremental link.  */\n+  return (flag_wpa || flag_incremental_link == INCREMENTAL_LINK_LTO);\n+}\n+\n #endif  /* GCC_IPA_UTILS_H  */"}, {"sha": "63b1a30956471f96d7b4d440392a74e4295ea3c7", "filename": "gcc/testsuite/c-c++-common/Wstringop-overflow-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -1,7 +1,7 @@\n /* PR middle-end/91458 - inconsistent warning for writing past the end\n    of an array member\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -fno-ipa-icf\" } */\n \n void sink (void*);\n "}, {"sha": "6e0d7f3ccc4b3e10c5cd2ff705848d6bce3022f3", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -3,7 +3,7 @@\n    See Wstringop-overflow-3.C for the same test that exercises the other\n    warning.\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -Wno-stringop-overflow\" }\n+   { dg-options \"-O2 -Wall -Wno-stringop-overflow -fno-ipa-icf\" }\n    { dg-skip-if \"\" { *-*-aix* } } */\n \n void sink (void*);"}, {"sha": "0e8409a75652c34ce063585cd5eea70b6e27c61d", "filename": "gcc/tree-ssa-alias-compare.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftree-ssa-alias-compare.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftree-ssa-alias-compare.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias-compare.h?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -0,0 +1,43 @@\n+/* Comparsion of AO ref.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef TREE_SSA_ALIAS_COMPARE_H\n+#define TREE_SSA_ALIAS_COMPARE_H\n+\n+class operand_compare;\n+/* A class aggregating all connections and semantic equivalents\n+   for a given pair of semantic function candidates.  */\n+class ao_compare : public operand_compare\n+{\n+  public:\n+  enum ao_ref_diff\n+  {\n+    SEMANTICS = 1,\n+    BASE_ALIAS_SET = 2,\n+    REF_ALIAS_SET = 4,\n+    ACCESS_PATH = 8,\n+    DEPENDENCE_CLIQUE = 16\n+  };\n+  int compare_ao_refs (ao_ref *ref1, ao_ref *ref2, bool lto_streaming_safe,\n+\t\t       bool tbaa);\n+  void hash_ao_ref (ao_ref *ref, bool lto_streaming_safe, bool tbaa,\n+\t\t    inchash::hash &hstate);\n+};\n+\n+#endif"}, {"sha": "9f279c805e5f831d3f4412ba8290e7c9180de720", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 375, "deletions": 1, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -45,6 +45,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"gimple-pretty-print.h\"\n #include \"print-tree.h\"\n+#include \"tree-ssa-alias-compare.h\"\n+#include \"builtins.h\"\n \n /* Broad overview of how alias analysis on gimple works:\n \n@@ -739,6 +741,38 @@ ao_ref_alias_set (ao_ref *ref)\n   return ref->ref_alias_set;\n }\n \n+/* Returns a type satisfying\n+   get_deref_alias_set (type) == ao_ref_base_alias_set (REF).  */\n+\n+tree\n+ao_ref_base_alias_ptr_type (ao_ref *ref)\n+{\n+  tree base_ref;\n+\n+  if (!ref->ref)\n+    return NULL_TREE;\n+  base_ref = ref->ref;\n+  while (handled_component_p (base_ref))\n+    base_ref = TREE_OPERAND (base_ref, 0);\n+  tree ret = reference_alias_ptr_type (base_ref);\n+  gcc_checking_assert (get_deref_alias_set (ret) == ao_ref_base_alias_set (ref));\n+  return ret;\n+}\n+\n+/* Returns a type satisfying\n+   get_deref_alias_set (type) == ao_ref_alias_set (REF).  */\n+\n+tree\n+ao_ref_alias_ptr_type (ao_ref *ref)\n+{\n+  if (!ref->ref)\n+    return NULL_TREE;\n+  tree ret = reference_alias_ptr_type (ref->ref);\n+  gcc_checking_assert (get_deref_alias_set (ret) == ao_ref_alias_set (ref));\n+  return ret;\n+}\n+\n+\n /* Init an alias-oracle reference representation from a gimple pointer\n    PTR a range specified by OFFSET, SIZE and MAX_SIZE under the assumption\n    that RANGE_KNOWN is set.\n@@ -1175,7 +1209,7 @@ aliasing_component_refs_p (tree ref1,\n \t   struct a {int array1[0]; int array[];};\n \t Such struct has size 0 but accesses to a.array may have non-zero size.\n \t In this case the size of TREE_TYPE (base1) is smaller than\n-\t size of TREE_TYPE (TREE_OPERNAD (base1, 0)).\n+\t size of TREE_TYPE (TREE_OPERAND (base1, 0)).\n \n \t Because we compare sizes of arrays just by sizes of their elements,\n \t we only need to care about zero sized array fields here.  */\n@@ -1950,6 +1984,20 @@ decl_refs_may_alias_p (tree ref1, tree base1,\n   return true;     \n }\n \n+/* Return true if access with BASE is view converted.\n+   Base must not be stripped from inner MEM_REF (&decl)\n+   which is done by ao_ref_base and thus one extra walk\n+   of handled components is needed.  */\n+\n+static bool\n+view_converted_memref_p (tree base)\n+{\n+  if (TREE_CODE (base) != MEM_REF && TREE_CODE (base) != TARGET_MEM_REF)\n+    return false;\n+  return same_type_for_tbaa (TREE_TYPE (base),\n+\t\t\t     TREE_TYPE (TREE_OPERAND (base, 1))) != 1;\n+}\n+\n /* Return true if an indirect reference based on *PTR1 constrained\n    to [OFFSET1, OFFSET1 + MAX_SIZE1) may alias a variable based on BASE2\n    constrained to [OFFSET2, OFFSET2 + MAX_SIZE2).  *PTR1 and BASE2 have\n@@ -3840,3 +3888,329 @@ attr_fnspec::verify ()\n \tinternal_error (\"invalid fn spec attribute \\\"%s\\\" arg %i\", str, i);\n     }\n }\n+\n+/* Return ture if TYPE1 and TYPE2 will always give the same answer\n+   when compared wit hother types using same_type_for_tbaa_p.  */\n+\n+static bool\n+types_equal_for_same_type_for_tbaa_p (tree type1, tree type2,\n+\t\t\t\t      bool lto_streaming_safe)\n+{\n+  /* We use same_type_for_tbaa_p to match types in the access path.\n+     This check is overly conservative.  */\n+  type1 = TYPE_MAIN_VARIANT (type1);\n+  type2 = TYPE_MAIN_VARIANT (type2);\n+\n+  if (TYPE_STRUCTURAL_EQUALITY_P (type1)\n+      != TYPE_STRUCTURAL_EQUALITY_P (type2))\n+    return false;\n+  if (TYPE_STRUCTURAL_EQUALITY_P (type1))\n+    return true;\n+\n+  if (lto_streaming_safe)\n+    return type1 == type2;\n+  else\n+    return TYPE_CANONICAL (type1) == TYPE_CANONICAL (type2);\n+}\n+\n+/* Compare REF1 and REF2 and return flags specifying their differences.\n+   If LTO_STREAMING_SAFE is true do not use alias sets and canonical\n+   types that are going to be recomputed.\n+   If TBAA is true also compare TBAA metadata.  */\n+\n+int\n+ao_compare::compare_ao_refs (ao_ref *ref1, ao_ref *ref2,\n+\t\t\t     bool lto_streaming_safe,\n+\t\t\t     bool tbaa)\n+{\n+  if (TREE_THIS_VOLATILE (ref1->ref) != TREE_THIS_VOLATILE (ref2->ref))\n+    return SEMANTICS;\n+  tree base1 = ao_ref_base (ref1);\n+  tree base2 = ao_ref_base (ref2);\n+\n+  if (!known_eq (ref1->offset, ref2->offset)\n+      || !known_eq (ref1->size, ref2->size)\n+      || !known_eq (ref1->max_size, ref2->max_size))\n+    return SEMANTICS;\n+\n+  /* For variable accesses we need to compare actual paths\n+     to check that both refs are accessing same address and the access size.  */\n+  if (!known_eq (ref1->size, ref1->max_size))\n+    {\n+      if (!operand_equal_p (TYPE_SIZE (TREE_TYPE (ref1->ref)),\n+\t\t\t    TYPE_SIZE (TREE_TYPE (ref2->ref)), 0))\n+\treturn SEMANTICS;\n+      tree r1 = ref1->ref;\n+      tree r2 = ref2->ref;\n+\n+      /* Handle toplevel COMPONENT_REFs of bitfields.\n+\t Those are special since they are not allowed in\n+\t ADDR_EXPR.  */\n+      if (TREE_CODE (r1) == COMPONENT_REF\n+\t  && DECL_BIT_FIELD (TREE_OPERAND (r1, 1)))\n+\t{\n+\t  if (TREE_CODE (r2) != COMPONENT_REF\n+\t      || !DECL_BIT_FIELD (TREE_OPERAND (r2, 1)))\n+\t    return SEMANTICS;\n+\t  tree field1 = TREE_OPERAND (r1, 1);\n+\t  tree field2 = TREE_OPERAND (r2, 1);\n+\t  if (!operand_equal_p (DECL_FIELD_OFFSET (field1),\n+\t\t\t\tDECL_FIELD_OFFSET (field2), 0)\n+\t      || !operand_equal_p (DECL_FIELD_BIT_OFFSET (field1),\n+\t\t\t\t   DECL_FIELD_BIT_OFFSET (field2), 0)\n+\t      || !operand_equal_p (DECL_SIZE (field1), DECL_SIZE (field2), 0)\n+\t      || !types_compatible_p (TREE_TYPE (r1),\n+\t\t\t\t      TREE_TYPE (r2)))\n+\t    return SEMANTICS;\n+\t  r1 = TREE_OPERAND (r1, 0);\n+\t  r2 = TREE_OPERAND (r2, 0);\n+\t}\n+      else if (TREE_CODE (r2) == COMPONENT_REF\n+\t       && DECL_BIT_FIELD (TREE_OPERAND (r2, 1)))\n+\treturn SEMANTICS;\n+\n+      /* Similarly for bit field refs.  */\n+      if (TREE_CODE (r1) == BIT_FIELD_REF)\n+\t{\n+ \t  if (TREE_CODE (r2) != BIT_FIELD_REF\n+\t      || !operand_equal_p (TREE_OPERAND (r1, 1),\n+\t\t\t\t   TREE_OPERAND (r2, 1), 0)\n+\t      || !operand_equal_p (TREE_OPERAND (r1, 2),\n+\t\t\t\t   TREE_OPERAND (r2, 2), 0)\n+\t      || !types_compatible_p (TREE_TYPE (r1),\n+\t\t\t\t      TREE_TYPE (r2)))\n+\t    return SEMANTICS;\n+\t  r1 = TREE_OPERAND (r1, 0);\n+\t  r2 = TREE_OPERAND (r2, 0);\n+\t}\n+      else if (TREE_CODE (r2) == BIT_FIELD_REF)\n+\treturn SEMANTICS;\n+\n+      /* Now we can compare the address of actual memory access.  */\n+      if (!operand_equal_p (r1, r2, OEP_ADDRESS_OF))\n+\treturn SEMANTICS;\n+    }\n+  /* For constant accesses we get more matches by comparing offset only.  */\n+  else if (!operand_equal_p (base1, base2, OEP_ADDRESS_OF))\n+    return SEMANTICS;\n+\n+  /* We can't simply use get_object_alignment_1 on the full\n+     reference as for accesses with variable indexes this reports\n+     too conservative alignment.  */\n+  unsigned int align1, align2;\n+  unsigned HOST_WIDE_INT bitpos1, bitpos2;\n+  bool known1 = get_object_alignment_1 (base1, &align1, &bitpos1);\n+  bool known2 = get_object_alignment_1 (base2, &align2, &bitpos2);\n+  /* ??? For MEMREF get_object_alignment_1 determines aligned from\n+     TYPE_ALIGN but still returns false.  This seem to contradict\n+     its description.  So compare even if alignment is unknown.   */\n+  if (known1 != known2\n+      || (bitpos1 != bitpos2 || align1 != align2))\n+    return SEMANTICS;\n+\n+  /* Now we know that accesses are semantically same.  */\n+  int flags = 0;\n+\n+  /* ao_ref_base strips inner MEM_REF [&decl], recover from that here.  */\n+  tree rbase1 = ref1->ref;\n+  if (rbase1)\n+    while (handled_component_p (rbase1))\n+      rbase1 = TREE_OPERAND (rbase1, 0);\n+  tree rbase2 = ref2->ref;\n+  while (handled_component_p (rbase2))\n+    rbase2 = TREE_OPERAND (rbase2, 0);\n+\n+  /* MEM_REFs and TARGET_MEM_REFs record dependence cliques which are used to\n+     implement restrict pointers.  MR_DEPENDENCE_CLIQUE 0 means no information.\n+     Otherwise we need to match bases and cliques.  */\n+  if ((((TREE_CODE (rbase1) == MEM_REF || TREE_CODE (rbase1) == TARGET_MEM_REF)\n+\t&& MR_DEPENDENCE_CLIQUE (rbase1))\n+       || ((TREE_CODE (rbase2) == MEM_REF || TREE_CODE (rbase2) == TARGET_MEM_REF)\n+\t   && MR_DEPENDENCE_CLIQUE (rbase2)))\n+      && (TREE_CODE (rbase1) != TREE_CODE (rbase2)\n+\t  || MR_DEPENDENCE_CLIQUE (rbase1) != MR_DEPENDENCE_CLIQUE (rbase2)\n+\t  || (MR_DEPENDENCE_BASE (rbase1) != MR_DEPENDENCE_BASE (rbase2))))\n+    flags |= DEPENDENCE_CLIQUE;\n+\n+  if (!tbaa)\n+    return flags;\n+\n+  /* Alias sets are not stable across LTO sreaming; be conservative here\n+     and compare types the alias sets are ultimately based on.  */\n+  if (lto_streaming_safe)\n+    {\n+      tree t1 = ao_ref_alias_ptr_type (ref1);\n+      tree t2 = ao_ref_alias_ptr_type (ref2);\n+      if (!alias_ptr_types_compatible_p (t1, t2))\n+\tflags |= REF_ALIAS_SET;\n+\n+      t1 = ao_ref_base_alias_ptr_type (ref1);\n+      t2 = ao_ref_base_alias_ptr_type (ref2);\n+      if (!alias_ptr_types_compatible_p (t1, t2))\n+\tflags |= BASE_ALIAS_SET;\n+    }\n+  else\n+    {\n+      if (ao_ref_alias_set (ref1) != ao_ref_alias_set (ref2))\n+\tflags |= REF_ALIAS_SET;\n+      if (ao_ref_base_alias_set (ref1) != ao_ref_base_alias_set (ref2))\n+\tflags |= BASE_ALIAS_SET;\n+    }\n+\n+  /* Access path is used only on non-view-converted references.  */\n+  bool view_converted = view_converted_memref_p (rbase1);\n+  if (view_converted_memref_p (rbase2) != view_converted)\n+    return flags | ACCESS_PATH;\n+  else if (view_converted)\n+    return flags;\n+\n+\n+  /* Find start of access paths and look for trailing arrays.  */\n+  tree c1 = ref1->ref, c2 = ref2->ref;\n+  tree end_struct_ref1 = NULL, end_struct_ref2 = NULL;\n+  int nskipped1 = 0, nskipped2 = 0;\n+  int i = 0;\n+\n+  for (tree p1 = ref1->ref; handled_component_p (p1); p1 = TREE_OPERAND (p1, 0))\n+    {\n+      if (component_ref_to_zero_sized_trailing_array_p (p1))\n+\tend_struct_ref1 = p1;\n+      if (ends_tbaa_access_path_p (p1))\n+\tc1 = p1, nskipped1 = i;\n+      i++;\n+    }\n+  for (tree p2 = ref2->ref; handled_component_p (p2); p2 = TREE_OPERAND (p2, 0))\n+    {\n+      if (component_ref_to_zero_sized_trailing_array_p (p2))\n+\tend_struct_ref2 = p2;\n+      if (ends_tbaa_access_path_p (p2))\n+\tc2 = p2, nskipped1 = i;\n+      i++;\n+    }\n+\n+  /* For variable accesses we can not rely on offset match bellow.\n+     We know that paths are struturally same, so only check that\n+     starts of TBAA paths did not diverge.  */\n+  if (!known_eq (ref1->size, ref1->max_size)\n+      && nskipped1 != nskipped2)\n+    return flags | ACCESS_PATH;\n+\n+  /* Information about trailing refs is used by\n+     aliasing_component_refs_p that is applied only if paths\n+     has handled components..  */\n+  if (!handled_component_p (c1) && !handled_component_p (c2))\n+    ;\n+  else if ((end_struct_ref1 != NULL) != (end_struct_ref2 != NULL))\n+    return flags | ACCESS_PATH;\n+  if (end_struct_ref1\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (end_struct_ref1))\n+\t != TYPE_MAIN_VARIANT (TREE_TYPE (end_struct_ref2)))\n+    return flags | ACCESS_PATH;\n+\n+  /* Now compare all handled components of the access path.\n+     We have three oracles that cares about access paths:\n+       - aliasing_component_refs_p\n+       - nonoverlapping_refs_since_match_p\n+       - nonoverlapping_component_refs_p\n+     We need to match things these oracles compare.\n+\n+     It is only necessary to check types for compatibility\n+     and offsets.  Rest of what oracles compares are actual\n+     addresses.  Those are already known to be same:\n+       - for constant accesses we check offsets\n+       - for variable accesses we already matched\n+\t the path lexically with operand_equal_p.  */\n+  while (true)\n+    {\n+      bool comp1 = handled_component_p (c1);\n+      bool comp2 = handled_component_p (c2);\n+\n+      if (comp1 != comp2)\n+\treturn flags | ACCESS_PATH;\n+      if (!comp1)\n+\tbreak;\n+\n+      if (TREE_CODE (c1) != TREE_CODE (c2))\n+\treturn flags | ACCESS_PATH;\n+\n+      /* aliasing_component_refs_p attempts to find type match within\n+\t the paths.  For that reason both types needs to be equal\n+\t with respect to same_type_for_tbaa_p.  */\n+      if (!types_equal_for_same_type_for_tbaa_p (TREE_TYPE (c1),\n+\t\t\t\t\t\t TREE_TYPE (c2),\n+\t\t\t\t\t\t lto_streaming_safe))\n+\treturn flags | ACCESS_PATH;\n+      if (component_ref_to_zero_sized_trailing_array_p (c1)\n+\t  != component_ref_to_zero_sized_trailing_array_p (c2))\n+\treturn flags | ACCESS_PATH;\n+\n+      /* aliasing_matching_component_refs_p compares\n+\t offsets within the path.  Other properties are ignored.\n+\t Do not bother to verify offsets in variable accesses.  Here we\n+\t already compared them by operand_equal_p so they are\n+\t structurally same.  */\n+      if (!known_eq (ref1->size, ref1->max_size))\n+\t{\n+\t  poly_int64 offadj1, sztmc1, msztmc1;\n+\t  bool reverse1;\n+\t  get_ref_base_and_extent (c1, &offadj1, &sztmc1, &msztmc1, &reverse1);\n+\t  poly_int64 offadj2, sztmc2, msztmc2;\n+\t  bool reverse2;\n+\t  get_ref_base_and_extent (c2, &offadj2, &sztmc2, &msztmc2, &reverse2);\n+\t  if (!known_eq (offadj1, offadj2))\n+\t    return flags | ACCESS_PATH;\n+\t}\n+      c1 = TREE_OPERAND (c1, 0);\n+      c2 = TREE_OPERAND (c2, 0);\n+    }\n+  /* Finally test the access type.  */\n+  if (!types_equal_for_same_type_for_tbaa_p (TREE_TYPE (c1),\n+\t\t\t\t\t     TREE_TYPE (c2),\n+\t\t\t\t\t     lto_streaming_safe))\n+    return flags | ACCESS_PATH;\n+  return flags;\n+}\n+\n+/* Hash REF to HSTATE.  If LTO_STREAMING_SAFE do not use alias sets\n+   and canonical types.  */\n+void\n+ao_compare::hash_ao_ref (ao_ref *ref, bool lto_streaming_safe, bool tbaa,\n+\t\t\t inchash::hash &hstate)\n+{\n+  tree base = ao_ref_base (ref);\n+  tree tbase = base;\n+\n+  if (!known_eq (ref->size, ref->max_size))\n+    {\n+      tree r = ref->ref;\n+      if (TREE_CODE (r) == COMPONENT_REF\n+\t  && DECL_BIT_FIELD (TREE_OPERAND (r, 1)))\n+\t{\n+\t  tree field = TREE_OPERAND (r, 1);\n+\t  hash_operand (DECL_FIELD_OFFSET (field), hstate, 0);\n+\t  hash_operand (DECL_FIELD_BIT_OFFSET (field), hstate, 0);\n+\t  hash_operand (DECL_SIZE (field), hstate, 0);\n+\t  r = TREE_OPERAND (r, 0);\n+\t}\n+      if (TREE_CODE (r) == BIT_FIELD_REF)\n+\t{\n+\t  hash_operand (TREE_OPERAND (r, 1), hstate, 0);\n+\t  hash_operand (TREE_OPERAND (r, 2), hstate, 0);\n+\t  r = TREE_OPERAND (r, 0);\n+\t}\n+      hash_operand (TYPE_SIZE (TREE_TYPE (ref->ref)), hstate, 0);\n+      hash_operand (r, hstate, OEP_ADDRESS_OF);\n+    }\n+  else\n+    {\n+      hash_operand (tbase, hstate, OEP_ADDRESS_OF);\n+      hstate.add_poly_int (ref->offset);\n+      hstate.add_poly_int (ref->size);\n+      hstate.add_poly_int (ref->max_size);\n+    }\n+  if (!lto_streaming_safe && tbaa)\n+    {\n+      hstate.add_int (ao_ref_alias_set (ref));\n+      hstate.add_int (ao_ref_base_alias_set (ref));\n+    }\n+}"}, {"sha": "830ac1bf84db030b416287d9e82448182dd77440", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602c6cfc79ce4ae61e277107e0a60079c1a93a97/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=602c6cfc79ce4ae61e277107e0a60079c1a93a97", "patch": "@@ -114,6 +114,8 @@ extern void ao_ref_init_from_ptr_and_size (ao_ref *, tree, tree);\n extern tree ao_ref_base (ao_ref *);\n extern alias_set_type ao_ref_alias_set (ao_ref *);\n extern alias_set_type ao_ref_base_alias_set (ao_ref *);\n+extern tree ao_ref_alias_ptr_type (ao_ref *);\n+extern tree ao_ref_base_alias_ptr_type (ao_ref *);\n extern bool ptr_deref_may_alias_global_p (tree);\n extern bool ptr_derefs_may_alias_p (tree, tree);\n extern bool ptrs_compare_unequal (tree, tree);"}]}