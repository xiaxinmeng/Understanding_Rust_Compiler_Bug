{"sha": "90cf3ecc837d6f0c8d7b9068d9321bf494a830c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjZjNlY2M4MzdkNmYwYzhkN2I5MDY4ZDkzMjFiZjQ5NGE4MzBjNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-02-06T14:22:48Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-02-06T14:22:48Z"}, "message": "re PR fortran/47592 (Multiple function invocation with ALLOCATE (SOURCE=REPEAT('x',bar())))\n\n2011-02-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47592\n\t* trans-stmt.c (gfc_trans_allocate): For deferred character\n\tlength allocations with SOURCE, store to the values and string\n\tlength to avoid calculating twice.  Replace gfc_start_block\n\twith gfc_init_block to avoid unnecessary contexts and to keep\n\tdeclarations of temporaries where they should be. Tidy up the\n\tcode a bit.\n\n2011-02-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47592\n\t* gfortran.dg/allocate_with_source_1 : New test.\n\nFrom-SVN: r169862", "tree": {"sha": "83ccb035c9e45ef14dd291bdc88ba6dea11e5cf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83ccb035c9e45ef14dd291bdc88ba6dea11e5cf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/comments", "author": null, "committer": null, "parents": [{"sha": "d5d3781a0d0934ad401412cd5471adc8519e463d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d3781a0d0934ad401412cd5471adc8519e463d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5d3781a0d0934ad401412cd5471adc8519e463d"}], "stats": {"total": 131, "additions": 86, "deletions": 45}, "files": [{"sha": "7fc66e0e60fb638b1c98a451991a458918136066", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=90cf3ecc837d6f0c8d7b9068d9321bf494a830c6", "patch": "@@ -1,3 +1,13 @@\n+2011-02-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47592\n+\t* trans-stmt.c (gfc_trans_allocate): For deferred character\n+\tlength allocations with SOURCE, store to the values and string\n+\tlength to avoid calculating twice.  Replace gfc_start_block\n+\twith gfc_init_block to avoid unnecessary contexts and to keep\n+\tdeclarations of temporaries where they should be. Tidy up the\n+\tcode a bit.\n+\n 2011-02-05  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/42434"}, {"sha": "6ddb2cab3ed7347c8a6fdeaffd7f224bee19a4c4", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 42, "deletions": 45, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=90cf3ecc837d6f0c8d7b9068d9321bf494a830c6", "patch": "@@ -4451,14 +4451,20 @@ gfc_trans_allocate (gfc_code * code)\n   tree pstat;\n   tree error_label;\n   tree memsz;\n+  tree expr3;\n+  tree slen3;\n   stmtblock_t block;\n+  stmtblock_t post;\n+  gfc_expr *sz;\n+  gfc_se se_sz;\n \n   if (!code->ext.alloc.list)\n     return NULL_TREE;\n \n   pstat = stat = error_label = tmp = memsz = NULL_TREE;\n \n-  gfc_start_block (&block);\n+  gfc_init_block (&block);\n+  gfc_init_block (&post);\n \n   /* Either STAT= and/or ERRMSG is present.  */\n   if (code->expr1 || code->expr2)\n@@ -4472,6 +4478,9 @@ gfc_trans_allocate (gfc_code * code)\n       TREE_USED (error_label) = 1;\n     }\n \n+  expr3 = NULL_TREE;\n+  slen3 = NULL_TREE;\n+\n   for (al = code->ext.alloc.list; al != NULL; al = al->next)\n     {\n       expr = gfc_copy_expr (al->expr);\n@@ -4480,7 +4489,6 @@ gfc_trans_allocate (gfc_code * code)\n \tgfc_add_data_component (expr);\n \n       gfc_init_se (&se, NULL);\n-      gfc_start_block (&se.pre);\n \n       se.want_pointer = 1;\n       se.descriptor_only = 1;\n@@ -4495,8 +4503,6 @@ gfc_trans_allocate (gfc_code * code)\n \t    {\n \t      if (code->expr3->ts.type == BT_CLASS)\n \t\t{\n-\t\t  gfc_expr *sz;\n-\t\t  gfc_se se_sz;\n \t\t  sz = gfc_copy_expr (code->expr3);\n \t\t  gfc_add_vptr_component (sz);\n \t\t  gfc_add_size_component (sz);\n@@ -4514,15 +4520,15 @@ gfc_trans_allocate (gfc_code * code)\n \t      if (!code->expr3->ts.u.cl->backend_decl)\n \t\t{\n \t\t  /* Convert and use the length expression.  */\n-\t\t  gfc_se se_sz;\n \t\t  gfc_init_se (&se_sz, NULL);\n \t\t  if (code->expr3->expr_type == EXPR_VARIABLE\n \t\t\t|| code->expr3->expr_type == EXPR_CONSTANT)\n \t\t    {\n \t\t      gfc_conv_expr (&se_sz, code->expr3);\n \t\t      memsz = se_sz.string_length;\n \t\t    }\n-\t\t  else if (code->expr3->ts.u.cl\n+\t\t  else if (code->expr3->mold\n+\t\t\t     && code->expr3->ts.u.cl\n \t\t\t     && code->expr3->ts.u.cl->length)\n \t\t    {\n \t\t      gfc_conv_expr (&se_sz, code->expr3->ts.u.cl->length);\n@@ -4531,20 +4537,21 @@ gfc_trans_allocate (gfc_code * code)\n \t\t      gfc_add_block_to_block (&se.pre, &se_sz.post);\n \t\t      memsz = se_sz.expr;\n \t\t    }\n-\t\t  else if (code->ext.alloc.ts.u.cl\n-\t\t\t     && code->ext.alloc.ts.u.cl->length)\n-\t\t    {\n-\t\t      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);\n-\t\t      memsz = se_sz.expr;\n-\t\t    }\n \t\t  else\n \t\t    {\n-\t\t      /* This is likely to be inefficient.  */\n-\t\t      gfc_conv_expr (&se_sz, code->expr3);\n-\t\t      gfc_add_block_to_block (&se.pre, &se_sz.pre);\n-\t\t      se_sz.expr = gfc_evaluate_now (se_sz.expr, &se.pre);\n-\t\t      gfc_add_block_to_block (&se.pre, &se_sz.post);\n-\t\t      memsz = se_sz.string_length;\n+\t\t      /* This is would be inefficient and possibly could\n+\t\t\t generate wrong code if the result were not stored\n+\t\t\t in expr3/slen3.  */\n+\t\t      if (slen3 == NULL_TREE)\n+\t\t\t{\n+\t\t\t  gfc_conv_expr (&se_sz, code->expr3);\n+\t\t\t  gfc_add_block_to_block (&se.pre, &se_sz.pre);\n+\t\t\t  expr3 = gfc_evaluate_now (se_sz.expr, &se.pre);\n+\t\t\t  gfc_add_block_to_block (&post, &se_sz.post);\n+\t\t\t  slen3 = gfc_evaluate_now (se_sz.string_length,\n+\t\t\t\t\t\t    &se.pre);\n+\t\t\t}\n+\t\t      memsz = slen3;\n \t\t    }\n \t\t}\n \t      else\n@@ -4580,31 +4587,13 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t       TREE_TYPE (tmp), tmp,\n \t\t\t\t       fold_convert (TREE_TYPE (tmp), memsz));\n \t    }\n+\n \t  /* Allocate - for non-pointers with re-alloc checking.  */\n-\t  {\n-\t    gfc_ref *ref;\n-\t    bool allocatable;\n-\n-\t    ref = expr->ref;\n-\n-\t    /* Find the last reference in the chain.  */\n-\t    while (ref && ref->next != NULL)\n-\t      {\n-\t        gcc_assert (ref->type != REF_ARRAY || ref->u.ar.type == AR_ELEMENT);\n-\t        ref = ref->next;\n-\t      }\n-\n-\t    if (!ref)\n-\t      allocatable = expr->symtree->n.sym->attr.allocatable;\n-\t    else\n-\t      allocatable = ref->u.c.component->attr.allocatable;\n-\n-\t    if (allocatable)\n-\t      tmp = gfc_allocate_array_with_status (&se.pre, se.expr, memsz,\n-\t\t\t\t\t\t    pstat, expr);\n-\t    else\n-\t      tmp = gfc_allocate_with_status (&se.pre, memsz, pstat);\n-\t  }\n+\t  if (gfc_expr_attr (expr).allocatable)\n+\t    tmp = gfc_allocate_array_with_status (&se.pre, se.expr, memsz,\n+\t\t\t\t\t\t  pstat, expr);\n+\t  else\n+\t    tmp = gfc_allocate_with_status (&se.pre, memsz, pstat);\n \n \t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n \t\t\t\t se.expr,\n@@ -4629,11 +4618,9 @@ gfc_trans_allocate (gfc_code * code)\n \t      tmp = gfc_nullify_alloc_comp (expr->ts.u.derived, tmp, 0);\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n-\n \t}\n \n-      tmp = gfc_finish_block (&se.pre);\n-      gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_block_to_block (&block, &se.pre);\n \n       if (code->expr3 && !code->expr3->mold)\n \t{\n@@ -4668,6 +4655,13 @@ gfc_trans_allocate (gfc_code * code)\n \t      gfc_add_block_to_block (&call.pre, &call.post);\n \t      tmp = gfc_finish_block (&call.pre);\n \t    }\n+\t  else if (expr3 != NULL_TREE)\n+\t    {\n+\t      tmp = build_fold_indirect_ref_loc (input_location, se.expr);\n+\t      gfc_trans_string_copy (&block, slen3, tmp, code->expr3->ts.kind,\n+\t\t\t\t     slen3, expr3, code->expr3->ts.kind);\n+\t      tmp = NULL_TREE;\n+\t    }\n \t  else\n \t    {\n \t      /* Switch off automatic reallocation since we have just done\n@@ -4799,6 +4793,9 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n+  gfc_add_block_to_block (&block, &se.post);\n+  gfc_add_block_to_block (&block, &post);\n+\n   return gfc_finish_block (&block);\n }\n "}, {"sha": "7bb00576f21a6f911e80441c8abceaaf1231f251", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90cf3ecc837d6f0c8d7b9068d9321bf494a830c6", "patch": "@@ -1,3 +1,8 @@\n+2011-02-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47592\n+\t* gfortran.dg/allocate_with_source_1 : New test.\n+\n 2011-02-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/47610"}, {"sha": "d386bb33b7c99f02c6570c31d03c46e766e95f42", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cf3ecc837d6f0c8d7b9068d9321bf494a830c6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_1.f90?ref=90cf3ecc837d6f0c8d7b9068d9321bf494a830c6", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! Test the fix for PR47592, in which the SOURCE expression was\n+! being called twice.\n+!\n+! Contributed by Thomas Koenig  <tkoenig@gcc.gnu.org>\n+!\n+module foo\n+  implicit none\n+contains\n+  function bar()\n+    integer bar\n+    integer :: i=9\n+    i = i + 1\n+    bar = i\n+  end function bar\n+end module foo\n+\n+program note7_35\n+  use foo\n+  implicit none\n+  character(:), allocatable :: name\n+  character(:), allocatable :: src\n+  integer n\n+  n = 10\n+  allocate(name, SOURCE=repeat('x',bar()))\n+  if (name .ne. 'xxxxxxxxxx') call abort\n+  if (len (name) .ne. 10 ) call abort\n+end program note7_35\n+! { dg-final { cleanup-modules \"foo\" } }"}]}