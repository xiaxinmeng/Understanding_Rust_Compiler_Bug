{"sha": "dee03828528cbb823102897fee49e1ef0019e0a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlMDM4Mjg1MjhjYmI4MjMxMDI4OTdmZWU0OWUxZWYwMDE5ZTBhMg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-12-17T21:57:16Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-12-17T21:57:16Z"}, "message": "* doc/cppinternals.texi: Update.\n\nFrom-SVN: r48130", "tree": {"sha": "cc9a75d72d5e9d45a02e79d84707bdd538caafbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc9a75d72d5e9d45a02e79d84707bdd538caafbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dee03828528cbb823102897fee49e1ef0019e0a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee03828528cbb823102897fee49e1ef0019e0a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee03828528cbb823102897fee49e1ef0019e0a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee03828528cbb823102897fee49e1ef0019e0a2/comments", "author": null, "committer": null, "parents": [{"sha": "2d628c257e6c1d328249740191dbf6e05ebc4ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d628c257e6c1d328249740191dbf6e05ebc4ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d628c257e6c1d328249740191dbf6e05ebc4ce5"}], "stats": {"total": 52, "additions": 48, "deletions": 4}, "files": [{"sha": "88594a49df3b0a58b71dc5f40b1d439312e3f9af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee03828528cbb823102897fee49e1ef0019e0a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee03828528cbb823102897fee49e1ef0019e0a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dee03828528cbb823102897fee49e1ef0019e0a2", "patch": "@@ -1,3 +1,7 @@\n+2001-12-17  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* doc/cppinternals.texi: Update.\n+\n Mon Dec 17 14:21:21 2001  Jeffrey A Law  (law@redhat.com)\n \n \t* expmed.c (emit_store_flag): Extract updated comparison code"}, {"sha": "a831922a51e86431a4f4635a68b2aef699467592", "filename": "gcc/doc/cppinternals.texi", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee03828528cbb823102897fee49e1ef0019e0a2/gcc%2Fdoc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee03828528cbb823102897fee49e1ef0019e0a2/gcc%2Fdoc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppinternals.texi?ref=dee03828528cbb823102897fee49e1ef0019e0a2", "patch": "@@ -41,7 +41,7 @@ into another language, under the above conditions for modified versions.\n @titlepage\n @c @finalout\n @title Cpplib Internals\n-@subtitle Last revised October 2001\n+@subtitle Last revised December 2001\n @subtitle for GCC version 3.1\n @author Neil Booth\n @page\n@@ -373,7 +373,7 @@ the pointers to the tokens of its expansion that we return will always\n remain valid.  However, macros are a little trickier than that, since\n they give rise to three sources of fresh tokens.  They are the built-in\n macros like @code{__LINE__}, and the @samp{#} and @samp{##} operators\n-for stringifcation and token pasting.  I handled this by allocating\n+for stringification and token pasting.  I handled this by allocating\n space for these tokens from the lexer's token run chain.  This means\n they automatically receive the same lifetime guarantees as lexed tokens,\n and we don't need to concern ourselves with freeing them.\n@@ -467,6 +467,46 @@ enum stored in its hash node, so that directive lookup is also O(1).\n \n @node Macro Expansion\n @unnumbered Macro Expansion Algorithm\n+@cindex macro expansion\n+\n+Macro expansion is a surprisingly tricky operation, fraught with nasty\n+corner cases and situations that render what you thought was a nifty\n+way to optimize the preprocessor's expansion algorithm wrong in quite\n+subtle ways.\n+\n+I strongly recommend you have a good grasp of how the C and C++\n+standards require macros to be expanded before diving into this\n+section, let alone the code!.  If you don't have a clear mental\n+picture of how things like nested macro expansion, stringification and\n+token pasting are supposed to work, damage to you sanity can quickly\n+result.\n+\n+@section Internal representation of Macros\n+@cindex macro representation (internal)\n+\n+The preprocessor stores macro expansions in tokenized form.  This\n+saves repeated lexing passes during expansion, at the cost of a small\n+increase in memory consumption on average.  The tokens are stored\n+contiguously in memory, so a pointer to the first one and a token\n+count is all we need.\n+\n+If the macro is a function-like macro the preprocessor also stores its\n+parameters, in the form of an ordered list of pointers to the hash\n+table entry of each parameter's identifier.  Further, in the macro's\n+stored expansion each occurrence of a parameter is replaced with a\n+special token of type @code{CPP_MACRO_ARG}.  Each such token holds the\n+index of the parameter it represents in the parameter list, which\n+allows rapid replacement of parameters with their arguments during\n+expansion.  Despite this optimization it is still necessary to store\n+the original parameters to the macro, both for dumping with e.g.,\n+@option{-dD}, and to warn about non-trivial macro redefinitions when\n+the parameter names have changed.\n+\n+@section Nested object-like macros\n+\n+@c TODO\n+\n+@section Function-like macros\n \n @c TODO\n \n@@ -479,8 +519,8 @@ enum stored in its hash node, so that directive lookup is also O(1).\n First, let's look at an issue that only concerns the stand-alone\n preprocessor: we want to guarantee that re-reading its preprocessed\n output results in an identical token stream.  Without taking special\n-measures, this might not be the case because of macro substitution.  For\n-example:\n+measures, this might not be the case because of macro substitution.\n+For example:\n \n @smallexample\n #define PLUS +"}]}