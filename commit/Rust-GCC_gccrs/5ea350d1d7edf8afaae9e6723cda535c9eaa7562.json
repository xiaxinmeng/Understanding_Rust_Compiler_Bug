{"sha": "5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVhMzUwZDFkN2VkZjhhZmFhZTllNjcyM2NkYTUzNWM5ZWFhNzU2Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-08T18:57:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-08T22:01:04Z"}, "message": "libgo: update to 1.15.6 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/276153", "tree": {"sha": "715c0290f1c8179bac2d58bf9f5cc0fde2aec2db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/715c0290f1c8179bac2d58bf9f5cc0fde2aec2db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "570c312c03e151477505c8b70b25411e52751ff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570c312c03e151477505c8b70b25411e52751ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/570c312c03e151477505c8b70b25411e52751ff4"}], "stats": {"total": 223, "additions": 202, "deletions": 21}, "files": [{"sha": "dc2682d95d1d655acd97984508bb544f4b1eae73", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -1,4 +1,4 @@\n-f4069d94a25893afc9f2fcf641359366f3ede017\n+0d0b423739b2fee9788cb6cb8af9ced29375e545\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e95c59a132d769f473bef8851009b5a1ed07641f", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -1,4 +1,4 @@\n-c53315d6cf1b4bfea6ff356b4a1524778c683bb9\n+9b955d2d3fcff6a5bc8bce7bafdc4c634a28e95b\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "7b6d7469626d9e6696f5a51394f5ca288ab98c8f", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -1 +1 @@\n-go1.15.5\n+go1.15.6"}, {"sha": "3898b2047c3a746e6cd611712a02fd758bca3c77", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -2778,6 +2778,21 @@ func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgo\n \t\t\t\tidx = bytes.Index(src, []byte(cgoLdflag))\n \t\t\t}\n \t\t}\n+\n+\t\t// We expect to find the contents of cgoLDFLAGS in flags.\n+\t\tif len(cgoLDFLAGS) > 0 {\n+\t\touter:\n+\t\t\tfor i := range flags {\n+\t\t\t\tfor j, f := range cgoLDFLAGS {\n+\t\t\t\t\tif f != flags[i+j] {\n+\t\t\t\t\t\tcontinue outer\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tflags = append(flags[:i], flags[i+len(cgoLDFLAGS):]...)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n \t\tif err := checkLinkerFlags(\"LDFLAGS\", \"go:cgo_ldflag\", flags); err != nil {\n \t\t\treturn nil, nil, err\n \t\t}"}, {"sha": "fc34aef4cba0e4320bba3e51f1be3677ab590870", "filename": "libgo/go/internal/poll/copy_file_range_linux.go", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Finternal%2Fpoll%2Fcopy_file_range_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Finternal%2Fpoll%2Fcopy_file_range_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Fcopy_file_range_linux.go?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -10,15 +10,61 @@ import (\n \t\"syscall\"\n )\n \n-var copyFileRangeSupported int32 = 1 // accessed atomically\n+var copyFileRangeSupported int32 = -1 // accessed atomically\n \n const maxCopyFileRangeRound = 1 << 30\n \n+func kernelVersion() (major int, minor int) {\n+\tvar uname syscall.Utsname\n+\tif err := syscall.Uname(&uname); err != nil {\n+\t\treturn\n+\t}\n+\n+\trl := uname.Release\n+\tvar values [2]int\n+\tvi := 0\n+\tvalue := 0\n+\tfor _, c := range rl {\n+\t\tif '0' <= c && c <= '9' {\n+\t\t\tvalue = (value * 10) + int(c-'0')\n+\t\t} else {\n+\t\t\t// Note that we're assuming N.N.N here.  If we see anything else we are likely to\n+\t\t\t// mis-parse it.\n+\t\t\tvalues[vi] = value\n+\t\t\tvi++\n+\t\t\tif vi >= len(values) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tvalue = 0\n+\t\t}\n+\t}\n+\tswitch vi {\n+\tcase 0:\n+\t\treturn 0, 0\n+\tcase 1:\n+\t\treturn values[0], 0\n+\tcase 2:\n+\t\treturn values[0], values[1]\n+\t}\n+\treturn\n+}\n+\n // CopyFileRange copies at most remain bytes of data from src to dst, using\n // the copy_file_range system call. dst and src must refer to regular files.\n func CopyFileRange(dst, src *FD, remain int64) (written int64, handled bool, err error) {\n-\tif atomic.LoadInt32(&copyFileRangeSupported) == 0 {\n+\tif supported := atomic.LoadInt32(&copyFileRangeSupported); supported == 0 {\n \t\treturn 0, false, nil\n+\t} else if supported == -1 {\n+\t\tmajor, minor := kernelVersion()\n+\t\tif major > 5 || (major == 5 && minor >= 3) {\n+\t\t\tatomic.StoreInt32(&copyFileRangeSupported, 1)\n+\t\t} else {\n+\t\t\t// copy_file_range(2) is broken in various ways on kernels older than 5.3,\n+\t\t\t// see issue #42400 and\n+\t\t\t// https://man7.org/linux/man-pages/man2/copy_file_range.2.html#VERSIONS\n+\t\t\tatomic.StoreInt32(&copyFileRangeSupported, 0)\n+\t\t\treturn 0, false, nil\n+\t\t}\n \t}\n \tfor remain > 0 {\n \t\tmax := remain\n@@ -41,7 +87,7 @@ func CopyFileRange(dst, src *FD, remain int64) (written int64, handled bool, err\n \t\t\t// use copy_file_range(2) again.\n \t\t\tatomic.StoreInt32(&copyFileRangeSupported, 0)\n \t\t\treturn 0, false, nil\n-\t\tcase syscall.EXDEV, syscall.EINVAL, syscall.EOPNOTSUPP, syscall.EPERM:\n+\t\tcase syscall.EXDEV, syscall.EINVAL, syscall.EIO, syscall.EOPNOTSUPP, syscall.EPERM:\n \t\t\t// Prior to Linux 5.3, it was not possible to\n \t\t\t// copy_file_range across file systems. Similarly to\n \t\t\t// the ENOSYS case above, if we see EXDEV, we have\n@@ -53,6 +99,9 @@ func CopyFileRange(dst, src *FD, remain int64) (written int64, handled bool, err\n \t\t\t// file. This is another case where no data has been\n \t\t\t// transfered, so we consider it unhandled.\n \t\t\t//\n+\t\t\t// If src and dst are on CIFS, we can see EIO.\n+\t\t\t// See issue #42334.\n+\t\t\t//\n \t\t\t// If the file is on NFS, we can see EOPNOTSUPP.\n \t\t\t// See issue #40731.\n \t\t\t//"}, {"sha": "64a7c088585cdee9f7d0ce3f59a421a0b68e3912", "filename": "libgo/go/runtime/crash_cgo_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -612,3 +612,16 @@ func TestEINTR(t *testing.T) {\n \t\tt.Fatalf(\"want %s, got %s\\n\", want, output)\n \t}\n }\n+\n+// Issue #42207.\n+func TestNeedmDeadlock(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Skipf(\"no signals on %s\", runtime.GOOS)\n+\t}\n+\toutput := runTestProg(t, \"testprogcgo\", \"NeedmDeadlock\")\n+\twant := \"OK\\n\"\n+\tif output != want {\n+\t\tt.Fatalf(\"want %s, got %s\\n\", want, output)\n+\t}\n+}"}, {"sha": "94983b358d4abdc604a84fcb488e3628bc81e397", "filename": "libgo/go/runtime/os_js.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Fos_js.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Fos_js.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_js.go?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -59,7 +59,7 @@ func mpreinit(mp *m) {\n }\n \n //go:nosplit\n-func msigsave(mp *m) {\n+func sigsave(p *sigset) {\n }\n \n //go:nosplit"}, {"sha": "e0b4b50456e3942f4abe262ae00695e85e7a5c17", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -571,7 +571,7 @@ func schedinit() {\n \tcpuinit() // must run before alginit\n \talginit() // maps must not be used before this call\n \n-\tmsigsave(_g_.m)\n+\tsigsave(&_g_.m.sigmask)\n \tinitSigmask = _g_.m.sigmask\n \n \tgoargs()\n@@ -1496,6 +1496,18 @@ func needm(x byte) {\n \t\texit(1)\n \t}\n \n+\t// Save and block signals before getting an M.\n+\t// The signal handler may call needm itself,\n+\t// and we must avoid a deadlock. Also, once g is installed,\n+\t// any incoming signals will try to execute,\n+\t// but we won't have the sigaltstack settings and other data\n+\t// set up appropriately until the end of minit, which will\n+\t// unblock the signals. This is the same dance as when\n+\t// starting a new m to run Go code via newosproc.\n+\tvar sigmask sigset\n+\tsigsave(&sigmask)\n+\tsigblock()\n+\n \t// Lock extra list, take head, unlock popped list.\n \t// nilokay=false is safe here because of the invariant above,\n \t// that the extra list always contains or will soon contain\n@@ -1513,14 +1525,8 @@ func needm(x byte) {\n \textraMCount--\n \tunlockextra(mp.schedlink.ptr())\n \n-\t// Save and block signals before installing g.\n-\t// Once g is installed, any incoming signals will try to execute,\n-\t// but we won't have the sigaltstack settings and other data\n-\t// set up appropriately until the end of minit, which will\n-\t// unblock the signals. This is the same dance as when\n-\t// starting a new m to run Go code via newosproc.\n-\tmsigsave(mp)\n-\tsigblock()\n+\t// Store the original signal mask for use by minit.\n+\tmp.sigmask = sigmask\n \n \t// Install g (= m->curg).\n \tsetg(mp.curg)\n@@ -3300,7 +3306,7 @@ func beforefork() {\n \t// a signal handler before exec if a signal is sent to the process\n \t// group. See issue #18600.\n \tgp.m.locks++\n-\tmsigsave(gp.m)\n+\tsigsave(&gp.m.sigmask)\n \tsigblock()\n }\n "}, {"sha": "ec7c6471b5d8a97c794400c1c6ab946e65ab15ca", "filename": "libgo/go/runtime/signal_unix.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -956,15 +956,15 @@ func sigfwdgo(sig uint32, info *_siginfo_t, ctx unsafe.Pointer) bool {\n \treturn true\n }\n \n-// msigsave saves the current thread's signal mask into mp.sigmask.\n+// sigsave saves the current thread's signal mask into *p.\n // This is used to preserve the non-Go signal mask when a non-Go\n // thread calls a Go function.\n // This is nosplit and nowritebarrierrec because it is called by needm\n // which may be called on a non-Go thread with no g available.\n //go:nosplit\n //go:nowritebarrierrec\n-func msigsave(mp *m) {\n-\tsigprocmask(_SIG_SETMASK, nil, &mp.sigmask)\n+func sigsave(p *sigset) {\n+\tsigprocmask(_SIG_SETMASK, nil, p)\n }\n \n // msigrestore sets the current thread's signal mask to sigmask.\n@@ -1038,7 +1038,7 @@ func minitSignalStack() {\n // thread's signal mask. When this is called all signals have been\n // blocked for the thread.  This starts with m.sigmask, which was set\n // either from initSigmask for a newly created thread or by calling\n-// msigsave if this is a non-Go thread calling a Go function. It\n+// sigsave if this is a non-Go thread calling a Go function. It\n // removes all essential signals from the mask, thus causing those\n // signals to not be blocked. Then it sets the thread's signal mask.\n // After this is called the thread can receive signals."}, {"sha": "5a9c359006d7af6a26dd0e39110c2775fb3cfce2", "filename": "libgo/go/runtime/testdata/testprogcgo/needmdeadlock.go", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fneedmdeadlock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fneedmdeadlock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fneedmdeadlock.go?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !plan9,!windows\n+\n+package main\n+\n+// This is for issue #42207.\n+// During a call to needm we could get a SIGCHLD signal\n+// which would itself call needm, causing a deadlock.\n+\n+/*\n+#include <signal.h>\n+#include <pthread.h>\n+#include <sched.h>\n+#include <unistd.h>\n+\n+extern void GoNeedM();\n+\n+#define SIGNALERS 10\n+\n+static void* needmSignalThread(void* p) {\n+\tpthread_t* pt = (pthread_t*)(p);\n+\tint i;\n+\n+\tfor (i = 0; i < 100; i++) {\n+\t\tif (pthread_kill(*pt, SIGCHLD) < 0) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tusleep(1);\n+\t}\n+\treturn NULL;\n+}\n+\n+// We don't need many calls, as the deadlock is only likely\n+// to occur the first couple of times that needm is called.\n+// After that there will likely be an extra M available.\n+#define CALLS 10\n+\n+static void* needmCallbackThread(void* p) {\n+\tint i;\n+\n+\tfor (i = 0; i < SIGNALERS; i++) {\n+\t\tsched_yield(); // Help the signal threads get started.\n+\t}\n+\tfor (i = 0; i < CALLS; i++) {\n+\t\tGoNeedM();\n+\t}\n+\treturn NULL;\n+}\n+\n+static void runNeedmSignalThread() {\n+\tint i;\n+\tpthread_t caller;\n+\tpthread_t s[SIGNALERS];\n+\n+\tpthread_create(&caller, NULL, needmCallbackThread, NULL);\n+\tfor (i = 0; i < SIGNALERS; i++) {\n+\t\tpthread_create(&s[i], NULL, needmSignalThread, &caller);\n+\t}\n+\tfor (i = 0; i < SIGNALERS; i++) {\n+\t\tpthread_join(s[i], NULL);\n+\t}\n+\tpthread_join(caller, NULL);\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"time\"\n+)\n+\n+func init() {\n+\tregister(\"NeedmDeadlock\", NeedmDeadlock)\n+}\n+\n+//export GoNeedM\n+func GoNeedM() {\n+}\n+\n+func NeedmDeadlock() {\n+\t// The failure symptom is that the program hangs because of a\n+\t// deadlock in needm, so set an alarm.\n+\tgo func() {\n+\t\ttime.Sleep(5 * time.Second)\n+\t\tfmt.Println(\"Hung for 5 seconds\")\n+\t\tos.Exit(1)\n+\t}()\n+\n+\tC.runNeedmSignalThread()\n+\tfmt.Println(\"OK\")\n+}"}, {"sha": "c037df645b9accc100908b3b4df194b24e753ace", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea350d1d7edf8afaae9e6723cda535c9eaa7562/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=5ea350d1d7edf8afaae9e6723cda535c9eaa7562", "patch": "@@ -222,6 +222,9 @@ runtime_m(void)\n }\n \n // Set g.\n+\n+void runtime_setg(G*) __attribute__ ((no_split_stack));\n+\n void\n runtime_setg(G* gp)\n {"}]}