{"sha": "f7854b908977adce4ff669c4e0332ef868568b7c", "node_id": "C_kwDOANBUbNoAKGY3ODU0YjkwODk3N2FkY2U0ZmY2NjljNGUwMzMyZWY4Njg1NjhiN2M", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-06-19T15:16:45Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-12-03T13:12:30Z"}, "message": "Add TARGET_IFUNC_REF_LOCAL_OK\n\n1. On some targets, like PowerPC, reference to ifunc function resolver\nmust be non-local so that compiler will properly emit PLT call.  Add\nTARGET_IFUNC_REF_LOCAL_OK to allow binding indirect function resolver\nlocally for targets which don't require special PLT call sequence.\n2. Add ix86_call_use_plt_p to call local ifunc function resolvers via\nPLT.\n\ngcc/\n\n\tPR target/51469\n\tPR target/83782\n\t* target.def (ifunc_ref_local_ok): Add a target hook.\n\t* varasm.c (default_binds_local_p_3): Force indirect function\n\tresolver non-local only if targetm.ifunc_ref_local_ok returns\n\tfalse.\n\t* config/i386/i386-expand.c (ix86_expand_call): Call\n\tix86_call_use_plt_p to check if PLT should be used.\n\t* config/i386/i386-protos.h (ix86_call_use_plt_p): New.\n\t* config/i386/i386.c (output_pic_addr_const): Call\n\tix86_call_use_plt_p to check if \"@PLT\" is needed.\n\t(ix86_call_use_plt_p): New.\n\t(TARGET_IFUNC_REF_LOCAL_OK): New.\n\t* doc/tm.texi.in: Add TARGET_IFUNC_REF_LOCAL_OK.\n\t* doc/tm.texi: Regenerated.\n\ngcc/testsuite/\n\n\tPR target/51469\n\tPR target/83782\n\t* gcc.target/i386/pr83782-1.c: New test.\n\t* gcc.target/i386/pr83782-2.c: Likewise.", "tree": {"sha": "d2f77c87c4dd0166bbb3f636f2d7d717a26eed12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f77c87c4dd0166bbb3f636f2d7d717a26eed12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7854b908977adce4ff669c4e0332ef868568b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7854b908977adce4ff669c4e0332ef868568b7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7854b908977adce4ff669c4e0332ef868568b7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7854b908977adce4ff669c4e0332ef868568b7c/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97ffef3553267f52ca83dbebdcc8b5e3739febee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97ffef3553267f52ca83dbebdcc8b5e3739febee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97ffef3553267f52ca83dbebdcc8b5e3739febee"}], "stats": {"total": 98, "additions": 95, "deletions": 3}, "files": [{"sha": "068c5c23358a8a256bbf80ffcfccf04538c3d475", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -9133,7 +9133,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t it an indirect call.  */\n       if (flag_pic\n \t  && GET_CODE (addr) == SYMBOL_REF\n-\t  && !SYMBOL_REF_LOCAL_P (addr))\n+\t  && ix86_call_use_plt_p (addr))\n \t{\n \t  if (flag_plt\n \t      && (SYMBOL_REF_DECL (addr) == NULL_TREE"}, {"sha": "7ffb4089a0d895f1cabba405b131e1cf0fd0f768", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -152,6 +152,7 @@ extern void ix86_expand_sse_movcc (rtx, rtx, rtx, rtx);\n extern void ix86_expand_sse_unpack (rtx, rtx, bool, bool);\n extern bool ix86_expand_int_addcc (rtx[]);\n extern rtx_insn *ix86_expand_call (rtx, rtx, rtx, rtx, rtx, bool);\n+extern bool ix86_call_use_plt_p (rtx);\n extern void ix86_split_call_vzeroupper (rtx, rtx);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);\n extern rtx ix86_zero_extend_to_Pmode (rtx);"}, {"sha": "ccb57afee0521d57e8f7a7ae19fa5ba9027cd8e3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -12150,7 +12150,7 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n \t  assemble_name (file, name);\n \t}\n       if (!TARGET_MACHO && !(TARGET_64BIT && TARGET_PECOFF)\n-\t  && code == 'P' && ! SYMBOL_REF_LOCAL_P (x))\n+\t  && code == 'P' && ix86_call_use_plt_p (x))\n \tfputs (\"@PLT\", file);\n       break;\n \n@@ -15980,6 +15980,26 @@ ix86_zero_extend_to_Pmode (rtx exp)\n   return force_reg (Pmode, convert_to_mode (Pmode, exp, 1));\n }\n \n+/* Return true if the function is called via PLT.   */\n+\n+bool\n+ix86_call_use_plt_p (rtx call_op)\n+{\n+  if (SYMBOL_REF_LOCAL_P (call_op))\n+    {\n+      if (SYMBOL_REF_DECL (call_op))\n+\t{\n+\t  /* NB: All ifunc functions must be called via PLT.  */\n+\t  cgraph_node *node\n+\t    = cgraph_node::get (SYMBOL_REF_DECL (call_op));\n+\t  if (node && node->ifunc_resolver)\n+\t    return true;\n+\t}\n+      return false;\n+    }\n+  return true;\n+}\n+\n /* Return true if the function being called was marked with attribute\n    \"noplt\" or using -fno-plt and we are compiling for non-PIC.  We need\n    to handle the non-PIC case in the backend because there is no easy\n@@ -24582,6 +24602,9 @@ ix86_libgcc_floating_mode_supported_p\n #define TARGET_GET_MULTILIB_ABI_NAME \\\n   ix86_get_multilib_abi_name\n \n+#undef TARGET_IFUNC_REF_LOCAL_OK\n+#define TARGET_IFUNC_REF_LOCAL_OK hook_bool_void_true\n+\n static bool ix86_libc_has_fast_function (int fcode ATTRIBUTE_UNUSED)\n {\n #ifdef OPTION_GLIBC"}, {"sha": "78cc1a287dd25951ef3169c3fe8ac0531c7fc36b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -12359,6 +12359,11 @@ The support includes the assembler, linker and dynamic linker.\n The default value of this hook is based on target's libc.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_IFUNC_REF_LOCAL_OK (void)\n+Return true if it is OK to reference indirect function resolvers\n+locally.  The default is to return false.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {unsigned int} TARGET_ATOMIC_ALIGN_FOR_MODE (machine_mode @var{mode})\n If defined, this function returns an appropriate alignment in bits for an\n atomic object of machine_mode @var{mode}.  If 0 is returned then the"}, {"sha": "50c4fe62dc7405e20fd9b70044477d36a462975b", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -8098,6 +8098,8 @@ and the associated definitions of those functions.\n \n @hook TARGET_HAS_IFUNC_P\n \n+@hook TARGET_IFUNC_REF_LOCAL_OK\n+\n @hook TARGET_ATOMIC_ALIGN_FOR_MODE\n \n @hook TARGET_ATOMIC_ASSIGN_EXPAND_FENV"}, {"sha": "2f0ae55f82e16bfcb7ef1f432e88154c26b9007e", "filename": "gcc/target.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -2979,6 +2979,14 @@ The default value of this hook is based on target's libc.\",\n  bool, (void),\n  default_has_ifunc_p)\n \n+/* True if it is OK to reference indirect function resolvers locally.  */\n+DEFHOOK\n+(ifunc_ref_local_ok,\n+ \"Return true if it is OK to reference indirect function resolvers\\n\\\n+locally.  The default is to return false.\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n /* True if it is OK to do sibling call optimization for the specified\n    call expression EXP.  DECL will be the called function, or NULL if\n    this is an indirect call.  */"}, {"sha": "f4c7370142a70f9782a50c51e53a4ebf622b3b17", "filename": "gcc/testsuite/gcc.target/i386/pr83782-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83782-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83782-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83782-1.c?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-require-ifunc \"\" } */\n+/* { dg-options \"-O2 -fpic\" } */\n+\n+static void\n+my_foo (void)\n+{\n+}\n+\n+static void (*resolve_foo (void)) (void)\n+{\n+  return my_foo;\n+}\n+\n+extern void foo (void) __attribute__((ifunc(\"resolve_foo\"), visibility(\"hidden\")));\n+\n+void *\n+bar(void)\n+{\n+  return foo;\n+}\n+\n+/* { dg-final { scan-assembler {leal[ \\t]foo@GOTOFF\\(%[^,]*\\),[ \\t]%eax} { target ia32 } } } */\n+/* { dg-final { scan-assembler {leaq[ \\t]foo\\(%rip\\),[ \\t]%rax} { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"foo@GOT\\\\\\(\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"foo@GOTPCREL\\\\\\(\" { target { ! ia32 } } } } */"}, {"sha": "6c6528fff4604b8114cde1d8fca451dc2e0812d0", "filename": "gcc/testsuite/gcc.target/i386/pr83782-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83782-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83782-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83782-2.c?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-require-ifunc \"\" } */\n+/* { dg-options \"-O2 -fpic\" } */\n+\n+static void\n+my_foo (void)\n+{\n+}\n+\n+static void (*resolve_foo (void)) (void)\n+{\n+  return my_foo;\n+}\n+\n+static void foo (void) __attribute__((ifunc(\"resolve_foo\")));\n+\n+void *\n+bar(void)\n+{\n+  return foo;\n+}\n+\n+/* { dg-final { scan-assembler {leal[ \\t]foo@GOTOFF\\(%[^,]*\\),[ \\t]%eax} { target ia32 } } } */\n+/* { dg-final { scan-assembler {leaq[ \\t]foo\\(%rip\\),[ \\t]%rax} { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"foo@GOT\\\\\\(\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"foo@GOTPCREL\\\\\\(\" { target { ! ia32 } } } } */"}, {"sha": "5da3b8f6fbb0863fe1a2da2aa7c72627d296abf7", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7854b908977adce4ff669c4e0332ef868568b7c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f7854b908977adce4ff669c4e0332ef868568b7c", "patch": "@@ -7474,7 +7474,8 @@ default_binds_local_p_3 (const_tree exp, bool shlib, bool weak_dominate,\n      FIXME: We can resolve the weakref case more curefuly by looking at the\n      weakref alias.  */\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (exp))\n-      || (TREE_CODE (exp) == FUNCTION_DECL\n+      || (!targetm.ifunc_ref_local_ok ()\n+\t  && TREE_CODE (exp) == FUNCTION_DECL\n \t  && cgraph_node::get (exp)\n \t  && cgraph_node::get (exp)->ifunc_resolver))\n     return false;"}]}