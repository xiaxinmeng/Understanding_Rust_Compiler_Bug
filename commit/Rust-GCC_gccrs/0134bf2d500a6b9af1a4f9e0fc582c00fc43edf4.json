{"sha": "0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzNGJmMmQ1MDBhNmI5YWYxYTRmOWUwZmM1ODJjMDBmYzQzZWRmNA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2002-01-05T16:52:31Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2002-01-05T16:52:31Z"}, "message": "rs6000.h (TARGET_POWERPC): For IN_LIBGCC2, define as 1 for __powerpc64__ as well.\n\n        * config/rs6000/rs6000.h (TARGET_POWERPC): For IN_LIBGCC2, define\n        as 1 for __powerpc64__ as well.\n\n        * config/rs6000/t-aix43 (T_ADAFLAGS): Define.\n\n        * alias.c (find_base_value, PLUS/MINUS): If we found a base,\n        return it.\n\nFrom-SVN: r48567", "tree": {"sha": "131996aa50fc0d657567aee2f7cb3cea0cccd4bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/131996aa50fc0d657567aee2f7cb3cea0cccd4bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/comments", "author": null, "committer": null, "parents": [{"sha": "9ca88d5a79485825234cc12ca6e2af02b18b9503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca88d5a79485825234cc12ca6e2af02b18b9503", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ca88d5a79485825234cc12ca6e2af02b18b9503"}], "stats": {"total": 58, "additions": 45, "deletions": 13}, "files": [{"sha": "8a1a383d1fd4c2ffd480646097bcb07fa3a5bab0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4", "patch": "@@ -1,3 +1,13 @@\n+2002-01-05  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.h (TARGET_POWERPC): For IN_LIBGCC2, define\n+\tas 1 for __powerpc64__ as well.\n+\n+\t* config/rs6000/t-aix43 (T_ADAFLAGS): Define.\n+\n+\t* alias.c (find_base_value, PLUS/MINUS): If we found a base,\n+\treturn it.\n+\n 2002-01-05  Daniel Berlin  <dan@dberlin.org>\n \n \t* lcm.c: Revert change, due to performance regression it causes on"}, {"sha": "9843d0605b53ae6c4c9778a01f55973503cad415", "filename": "gcc/alias.c", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4", "patch": "@@ -779,22 +779,46 @@ find_base_value (src)\n       {\n \trtx temp, src_0 = XEXP (src, 0), src_1 = XEXP (src, 1);\n \n+\t/* If either operand is a REG that is a known pointer, then it\n+\t   is the base.  */\n+\tif (REG_P (src_0) && REG_POINTER (src_0))\n+\t  return find_base_value (src_0);\n+\tif (REG_P (src_1) && REG_POINTER (src_1))\n+\t  return find_base_value (src_1);\n+\n \t/* If either operand is a REG, then see if we already have\n \t   a known value for it.  */\n-\tif (GET_CODE (src_0) == REG)\n+\tif (REG_P (src_0))\n \t  {\n \t    temp = find_base_value (src_0);\n \t    if (temp != 0)\n \t      src_0 = temp;\n \t  }\n \n-\tif (GET_CODE (src_1) == REG)\n+\tif (REG_P (src_1))\n \t  {\n \t    temp = find_base_value (src_1);\n \t    if (temp!= 0)\n \t      src_1 = temp;\n \t  }\n \n+\t/* If either base is named object or a special address\n+\t   (like an argument or stack reference), then use it for the\n+\t   base term.  */\n+\tif (src_0 != 0\n+\t    && (GET_CODE (src_0) == SYMBOL_REF\n+\t\t|| GET_CODE (src_0) == LABEL_REF\n+\t\t|| (GET_CODE (src_0) == ADDRESS\n+\t\t    && GET_MODE (src_0) != VOIDmode)))\n+\t  return src_0;\n+\n+\tif (src_1 != 0\n+\t    && (GET_CODE (src_1) == SYMBOL_REF\n+\t\t|| GET_CODE (src_1) == LABEL_REF\n+\t\t|| (GET_CODE (src_1) == ADDRESS\n+\t\t    && GET_MODE (src_1) != VOIDmode)))\n+\t  return src_1;\n+\n \t/* Guess which operand is the base address:\n \t   If either operand is a symbol, then it is the base.  If\n \t   either operand is a CONST_INT, then the other is the base.  */\n@@ -803,14 +827,6 @@ find_base_value (src)\n \telse if (GET_CODE (src_0) == CONST_INT || CONSTANT_P (src_1))\n \t  return find_base_value (src_1);\n \n-\t/* This might not be necessary anymore:\n-\t   If either operand is a REG that is a known pointer, then it\n-\t   is the base.  */\n-\telse if (GET_CODE (src_0) == REG && REG_POINTER (src_0))\n-\t  return find_base_value (src_0);\n-\telse if (GET_CODE (src_1) == REG && REG_POINTER (src_1))\n-\t  return find_base_value (src_1);\n-\n \treturn 0;\n       }\n "}, {"sha": "0ed3b2b7df5929c4559be5ba1023a2c6543fcd37", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4", "patch": "@@ -253,7 +253,7 @@ extern int target_flags;\n \n #ifdef IN_LIBGCC2\n /* For libgcc2 we make sure this is a compile time constant */\n-#ifdef __64BIT__\n+#if defined (__64BIT__) || defined (__powerpc64__)\n #define TARGET_POWERPC64\t1\n #else\n #define TARGET_POWERPC64\t0"}, {"sha": "209a7637ef1e899693c8c672f7a7862871add9a0", "filename": "gcc/config/rs6000/t-aix43", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/gcc%2Fconfig%2Frs6000%2Ft-aix43", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4/gcc%2Fconfig%2Frs6000%2Ft-aix43", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-aix43?ref=0134bf2d500a6b9af1a4f9e0fc582c00fc43edf4", "patch": "@@ -64,5 +64,11 @@ SHLIB_MKMAP = $(srcdir)/mkmap-flat.awk\n SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver\n SHLIB_NM_FLAGS = -Bpg\n \n-# Both 32-bit and 64-bit objects in archives\n-AR_FLAGS_FOR_TARGET=-X32_64\n+# Either 32-bit and 64-bit objects in archives.\n+AR_FLAGS_FOR_TARGET = -X32_64\n+\n+# Compile Ada files with minimal-toc.  The primary focus is gnatlib, so\n+# that the library does not use nearly the entire TOC of applications\n+# until gnatlib is built as a shared library on AIX.  Compiling the\n+# compiler with -mminimal-toc does not cause any harm.\n+T_ADAFLAGS = -mminimal-toc"}]}