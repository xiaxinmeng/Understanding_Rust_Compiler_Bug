{"sha": "766a866c11644e16aadc27aa954332d4b0c464ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY2YTg2NmMxMTY0NGUxNmFhZGMyN2FhOTU0MzMyZDRiMGM0NjRhYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-04-08T19:48:29Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-04-08T19:48:29Z"}, "message": "Add -fpic/-fPIC support\n\nFrom-SVN: r11676", "tree": {"sha": "a72000c5003c2623a66a656aa3890c50072b574e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a72000c5003c2623a66a656aa3890c50072b574e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/766a866c11644e16aadc27aa954332d4b0c464ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766a866c11644e16aadc27aa954332d4b0c464ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/766a866c11644e16aadc27aa954332d4b0c464ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766a866c11644e16aadc27aa954332d4b0c464ac/comments", "author": null, "committer": null, "parents": [{"sha": "2038dc12982de24c46a65f5339c105ad81c4a5f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2038dc12982de24c46a65f5339c105ad81c4a5f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2038dc12982de24c46a65f5339c105ad81c4a5f9"}], "stats": {"total": 151, "additions": 148, "deletions": 3}, "files": [{"sha": "cd3f675d73b296662a19725de95fb96114a4eb0f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766a866c11644e16aadc27aa954332d4b0c464ac/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766a866c11644e16aadc27aa954332d4b0c464ac/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=766a866c11644e16aadc27aa954332d4b0c464ac", "patch": "@@ -93,6 +93,9 @@ enum rs6000_abi rs6000_current_abi;\n /* Temporary memory used to convert integer -> float */\n static rtx stack_temps[NUM_MACHINE_MODES];\n \n+/* Current PIC register used by the V4 code */\n+struct rtx_def *rs6000_pic_register = (struct rtx_def *)0;\n+\n \f\n /* Print the options used in the assembly file.  */\n \n@@ -524,6 +527,18 @@ reg_or_cint_operand (op, mode)\n      return GET_CODE (op) == CONST_INT || gpc_reg_operand (op, mode);\n }\n \n+/* Return 1 if the operand is an operand that can be loaded via the GOT */\n+\n+int\n+got_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == SYMBOL_REF\n+\t  || GET_CODE (op) == CONST\n+\t  || GET_CODE (op) == LABEL_REF);\n+}\n+\n /* Return the number of instructions it takes to form a constant in an\n    integer register.  */\n \n@@ -3663,6 +3678,7 @@ output_epilog (file, size)\n   /* Reset varargs and save TOC indicator */\n   rs6000_sysv_varargs_p = 0;\n   rs6000_save_toc_p = 0;\n+  rs6000_pic_register = (rtx)0;\n \n   if (DEFAULT_ABI == ABI_NT)\n     {"}, {"sha": "1620ad484e10c631a31673b7ce73558f6150d012", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766a866c11644e16aadc27aa954332d4b0c464ac/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766a866c11644e16aadc27aa954332d4b0c464ac/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=766a866c11644e16aadc27aa954332d4b0c464ac", "patch": "@@ -1841,6 +1841,54 @@ typedef struct rs6000_args\n   if (GET_CODE (ADDR) == LO_SUM)\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\\\n }\n+\f\n+/* The register number of the register used to address a table of\n+   static data addresses in memory.  In some cases this register is\n+   defined by a processor's \"application binary interface\" (ABI).\n+   When this macro is defined, RTL is generated for this register\n+   once, as with the stack pointer and frame pointer registers.  If\n+   this macro is not defined, it is up to the machine-dependent files\n+   to allocate such a register (if necessary).  */\n+\n+/* #define PIC_OFFSET_TABLE_REGNUM */\n+\n+/* Define this macro if the register defined by\n+   `PIC_OFFSET_TABLE_REGNUM' is clobbered by calls.  Do not define\n+   this macro if `PPIC_OFFSET_TABLE_REGNUM' is not defined. */\n+\n+/* #define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED */\n+\n+/* By generating position-independent code, when two different\n+   programs (A and B) share a common library (libC.a), the text of\n+   the library can be shared whether or not the library is linked at\n+   the same address for both programs.  In some of these\n+   environments, position-independent code requires not only the use\n+   of different addressing modes, but also special code to enable the\n+   use of these addressing modes.\n+\n+   The `FINALIZE_PIC' macro serves as a hook to emit these special\n+   codes once the function is being compiled into assembly code, but\n+   not before.  (It is not done before, because in the case of\n+   compiling an inline function, it would lead to multiple PIC\n+   prologues being included in functions which used inline functions\n+   and were compiled to assembly language.)  */\n+\n+/* #define FINALIZE_PIC */\n+\n+/* Current PIC register used by the V4 code */\n+extern struct rtx_def *rs6000_pic_register;\n+\n+\n+/* A C expression that is nonzero if X is a legitimate immediate\n+   operand on the target machine when generating position independent\n+   code.  You can assume that X satisfies `CONSTANT_P', so you need\n+   not check this.  You can also assume FLAG_PIC is true, so you need\n+   not check it either.  You need not define this macro if all\n+   constants (including `SYMBOL_REF') can be immediate operands when\n+   generating position independent code.  */\n+\n+/* #define LEGITIMATE_PIC_OPERAND_P (X) */\n+\n \f\n /* Define this if some processing needs to be done immediately before\n    emitting code for an insn.  */\n@@ -2769,6 +2817,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"reg_or_neg_short_operand\", {SUBREG, REG, CONST_INT}},\t\\\n   {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n   {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\\\n   {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\\\n   {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\\\n@@ -2804,7 +2853,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n    (no need to use the default) */\n #define MACHINE_issue_rate\n \n-/* General optimization flags.  */\n+/* General flags.  */\n+extern int flag_pic;\n extern int optimize;\n extern int flag_expensive_optimizations;\n \n@@ -2824,6 +2874,7 @@ extern int reg_or_short_operand ();\n extern int reg_or_neg_short_operand ();\n extern int reg_or_u_short_operand ();\n extern int reg_or_cint_operand ();\n+extern int got_operand ();\n extern int num_insns_constant ();\n extern int easy_fp_constant ();\n extern int volatile_mem_operand ();"}, {"sha": "5aa18139142c76688ee3b96dc539146c55344b51", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766a866c11644e16aadc27aa954332d4b0c464ac/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766a866c11644e16aadc27aa954332d4b0c464ac/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=766a866c11644e16aadc27aa954332d4b0c464ac", "patch": "@@ -4815,6 +4815,68 @@\n    \"TARGET_ELF && !TARGET_64BIT\"\n    \"{cal %0,%a2@l(%1)|addi %0,%1,%2@l}\")\n \n+;; Set up a register with a value from the GOT table\n+\n+(define_expand \"movsi_got\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(unspec [(match_operand:SI 1 \"got_operand\" \"\")\n+\t\t (match_dup 2)] 8))]\n+  \"DEFAULT_ABI == ABI_V4 && flag_pic\"\n+  \"\n+{\n+  if (!rs6000_pic_register)\n+    {\n+      rs6000_pic_register = gen_reg_rtx (SImode);\n+      emit_insn (gen_init_v4_pic (rs6000_pic_register));\n+    }\n+\n+  operands[2] = rs6000_pic_register;\n+  if (flag_pic > 1)\n+    {\n+      emit_insn (gen_movsi_got_large (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*movsi_got_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec [(match_operand:SI 1 \"got_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"b\")] 8))]\n+  \"DEFAULT_ABI == ABI_V4 && flag_pic == 1\"\n+  \"{l|lwz} %0,%a1@got(%2)\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"movsi_got_large\"\n+  [(set (match_dup 3)\n+\t(unspec [(match_operand:SI 1 \"got_operand\" \"\")] 9))\n+   (set (match_dup 3)\n+\t(unspec [(match_dup 1)\n+\t\t (match_dup 3)] 10))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (plus:SI (match_dup 3)\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"\"))))]\n+  \"DEFAULT_ABI == ABI_V4 && flag_pic > 1\"\n+  \"\n+{\n+  if (reload_completed || reload_in_progress)\n+    abort ();\n+\n+  operands[3] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_insn \"*movsi_got_internal2_high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(unspec [(match_operand:SI 1 \"got_operand\" \"\")] 9))]\n+  \"DEFAULT_ABI == ABI_V4 && flag_pic > 1\"\n+  \"{cau|addis} %0,0,%1@got@ha\")\n+\n+(define_insn \"*movsi_got_internal2_losum\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec [(match_operand:SI 1 \"got_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"b\")] 10))]\n+  \"DEFAULT_ABI == ABI_V4 && flag_pic > 1\"\n+  \"{cal %0,%a1@got@l(%2)|addi %0,%2,%a1@got@l}\")\n+\n ;; For SI, we special-case integers that can't be loaded in one insn.  We\n ;; do the load 16-bits at a time.  We could do this by loading from memory,\n ;; and this is even supposed to be faster, but it is simpler not to get\n@@ -4842,6 +4904,12 @@\n       DONE;\n     }\n \n+  if (DEFAULT_ABI == ABI_V4 && flag_pic && got_operand (operands[1], SImode))\n+    {\n+      emit_insn (gen_movsi_got (operands[0], operands[1]));\n+      DONE;\n+    }\n+\n   if (TARGET_ELF && TARGET_NO_TOC && !TARGET_64BIT\n       && CONSTANT_P (operands[1])\n       && GET_CODE (operands[1]) != HIGH\n@@ -6985,7 +7053,7 @@\n   else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n \n-  return \\\"bl %z0\\\";\n+  return (flag_pic) ? \\\"bl %z0@plt\\\" : \\\"bl %z0\\\";\n }\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n@@ -7055,7 +7123,7 @@\n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n \n-  return \\\"bl %z1\\\";\n+  return (flag_pic) ? \\\"bl %z1@plt\\\" : \\\"bl %z1\\\";\n }\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n@@ -7123,6 +7191,16 @@\n   \"\"\n   \"{ics|isync}\")\n \n+\n+;; V.4 specific code to initialize the PIC register\n+\n+(define_insn \"init_v4_pic\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(unspec [(const_int 0)] 7))]\n+  \"DEFAULT_ABI == ABI_V4\"\n+  \"bl _GLOBAL_OFFSET_TABLE_-4\"\n+  [(set_attr \"type\" \"branch\")])\n+\n \f\n ;; Compare insns are next.  Note that the RS/6000 has two types of compares,\n ;; signed & unsigned, and one type of branch."}]}