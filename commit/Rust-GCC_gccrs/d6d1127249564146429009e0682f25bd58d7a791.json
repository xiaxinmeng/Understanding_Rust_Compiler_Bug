{"sha": "d6d1127249564146429009e0682f25bd58d7a791", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkMTEyNzI0OTU2NDE0NjQyOTAwOWUwNjgyZjI1YmQ1OGQ3YTc5MQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2013-09-27T16:48:15Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2013-09-27T16:48:15Z"}, "message": "vectorizer cost model enhancement\n\nFrom-SVN: r202980", "tree": {"sha": "f6309abb88289dcaa19aca96778e0ef0659d91a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6309abb88289dcaa19aca96778e0ef0659d91a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6d1127249564146429009e0682f25bd58d7a791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d1127249564146429009e0682f25bd58d7a791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6d1127249564146429009e0682f25bd58d7a791", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d1127249564146429009e0682f25bd58d7a791/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ac1857a3ef390df0c1b8faf745f855e8c5346b10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1857a3ef390df0c1b8faf745f855e8c5346b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1857a3ef390df0c1b8faf745f855e8c5346b10"}], "stats": {"total": 186, "additions": 123, "deletions": 63}, "files": [{"sha": "9712bc80dfeb39d101596251b0a9029a9023bcf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -1,3 +1,24 @@\n+2013-09-27  Xinliang David Li  <davidxl@google.com>\n+\n+\t* opts.c (finish_options): Adjust parameters\n+\taccording to vect cost model.\n+\t(common_handle_option): Set dynamic vect cost\n+\tmodel for FDO.\n+\ttarghooks.c (default_add_stmt_cost): Compute stmt cost\n+\tunconditionally.\n+\t* tree-vect-loop.c (vect_estimate_min_profitable_iters):\n+\tUse helper function.\n+\t* tree-vectorizer.h (unlimited_cost_model): New function.\n+\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Use helper function.\n+\t* tree-vect-data-refs.c (vect_peeling_hash_insert): Use helper\n+\tfunction.\n+\t(vect_enhance_data_refs_alignment): Ditto.\n+\t* flag-types.h: New enum.\n+\t* common/config/i386/i386-common.c (ix86_option_init_struct):\n+\tNo need to initialize vect_cost_model flag.\n+\t* config/i386/i386.c (ix86_add_stmt_cost): Compute stmt cost\n+\tunconditionally.\n+\n 2013-09-27  Diego Novillo  <dnovillo@google.com>\n \n \t* gimple.h (enum ssa_mode): Remove."}, {"sha": "c2b3d35730258c4b8635dc2969cd75c0bfb4b533", "filename": "gcc/common.opt", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -2278,13 +2278,33 @@ ftree-slp-vectorize\n Common Report Var(flag_tree_slp_vectorize) Optimization\n Enable basic block vectorization (SLP) on trees\n \n+fvect-cost-model=\n+Common Joined RejectNegative Enum(vect_cost_model) Var(flag_vect_cost_model) Init(VECT_COST_MODEL_DEFAULT)\n+Specifies the cost model for vectorization\n+ \n+Enum\n+Name(vect_cost_model) Type(enum vect_cost_model) UnknownError(unknown vectorizer cost model %qs)\n+\n+EnumValue\n+Enum(vect_cost_model) String(unlimited) Value(VECT_COST_MODEL_UNLIMITED)\n+\n+EnumValue\n+Enum(vect_cost_model) String(dynamic) Value(VECT_COST_MODEL_DYNAMIC)\n+\n+EnumValue\n+Enum(vect_cost_model) String(cheap) Value(VECT_COST_MODEL_CHEAP)\n+\n fvect-cost-model\n-Common Report Var(flag_vect_cost_model) Optimization\n-Enable use of cost model in vectorization\n+Common RejectNegative Alias(fvect-cost-model=,dynamic)\n+Enables the dynamic vectorizer cost model.  Preserved for backward compatibility.\n+\n+fno-vect-cost-model\n+Common RejectNegative Alias(fvect-cost-model=,unlimited)\n+Enables the unlimited vectorizer cost model.  Preserved for backward compatibility.\n \n ftree-vect-loop-version\n-Common Report Var(flag_tree_vect_loop_version) Init(1) Optimization\n-Enable loop versioning when doing loop vectorization on trees\n+Common Ignore\n+Does nothing. Preserved for backward compatibility.\n \n ftree-scev-cprop\n Common Report Var(flag_tree_scev_cprop) Init(1) Optimization"}, {"sha": "341637b4a10ad848fb8996047ff4d4e25e3a1836", "filename": "gcc/common/config/i386/i386-common.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -811,7 +811,6 @@ ix86_option_init_struct (struct gcc_options *opts)\n \n   opts->x_flag_pcc_struct_return = 2;\n   opts->x_flag_asynchronous_unwind_tables = 2;\n-  opts->x_flag_vect_cost_model = 1;\n }\n \n /* On the x86 -fsplit-stack and -fstack-protector both use the same"}, {"sha": "21fc5314861c2621beacc0a1121677e2f58b659b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -42782,20 +42782,17 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n   unsigned *cost = (unsigned *) data;\n   unsigned retval = 0;\n \n-  if (flag_vect_cost_model)\n-    {\n-      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n-      int stmt_cost = ix86_builtin_vectorization_cost (kind, vectype, misalign);\n+  tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n+  int stmt_cost = ix86_builtin_vectorization_cost (kind, vectype, misalign);\n \n-      /* Statements in an inner loop relative to the loop being\n-\t vectorized are weighted more heavily.  The value here is\n-\t arbitrary and could potentially be improved with analysis.  */\n-      if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n-\tcount *= 50;  /* FIXME.  */\n+  /* Statements in an inner loop relative to the loop being\n+     vectorized are weighted more heavily.  The value here is\n+      arbitrary and could potentially be improved with analysis.  */\n+  if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n+    count *= 50;  /* FIXME.  */\n \n-      retval = (unsigned) (count * stmt_cost);\n-      cost[where] += retval;\n-    }\n+  retval = (unsigned) (count * stmt_cost);\n+  cost[where] += retval;\n \n   return retval;\n }"}, {"sha": "8bfd3db6c66a287b3840665da782587acc3ab4ff", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -423,7 +423,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-partial-pre -ftree-pta @gol\n -ftree-reassoc -ftree-sink -ftree-slsr -ftree-sra @gol\n -ftree-switch-conversion -ftree-tail-merge -ftree-ter @gol\n--ftree-vect-loop-version -ftree-vectorize -ftree-vrp @gol\n+-ftree-vectorize -ftree-vrp @gol\n -funit-at-a-time -funroll-all-loops -funroll-loops @gol\n -funsafe-loop-optimizations -funsafe-math-optimizations -funswitch-loops @gol\n -fvariable-expansion-in-unroller -fvect-cost-model -fvpt -fweb @gol\n@@ -6770,7 +6770,7 @@ optimizations designed to reduce code size.\n @option{-Os} disables the following optimization flags:\n @gccoptlist{-falign-functions  -falign-jumps  -falign-loops @gol\n -falign-labels  -freorder-blocks  -freorder-blocks-and-partition @gol\n--fprefetch-loop-arrays  -ftree-vect-loop-version}\n+-fprefetch-loop-arrays}\n \n @item -Ofast\n @opindex Ofast\n@@ -8025,19 +8025,20 @@ Perform loop vectorization on trees. This flag is enabled by default at\n Perform basic block vectorization on trees. This flag is enabled by default at\n @option{-O3} and when @option{-ftree-vectorize} is enabled.\n \n-@item -ftree-vect-loop-version\n-@opindex ftree-vect-loop-version\n-Perform loop versioning when doing loop vectorization on trees.  When a loop\n-appears to be vectorizable except that data alignment or data dependence cannot\n-be determined at compile time, then vectorized and non-vectorized versions of\n-the loop are generated along with run-time checks for alignment or dependence\n-to control which version is executed.  This option is enabled by default\n-except at level @option{-Os} where it is disabled.\n-\n-@item -fvect-cost-model\n+@item -fvect-cost-model=@var{model}\n @opindex fvect-cost-model\n-Enable cost model for vectorization.  This option is enabled by default at\n-@option{-O3}.\n+Alter the cost model used for vectorization.  The @var{model} argument\n+should be one of @code{unlimited}, @code{dynamic} or @code{cheap}.\n+With the @code{unlimited} model the vectorized code-path is assumed\n+to be profitable while with the @code{dynamic} model a runtime check\n+will guard the vectorized code-path to enable it only for iteration\n+counts that will likely execute faster than when executing the original\n+scalar loop.  The @code{cheap} model will disable vectorization of\n+loops where doing so would be cost prohibitive for example due to\n+required runtime checks for data dependence or alignment but otherwise\n+is equal to the @code{dynamic} model.\n+The default cost model depends on other optimization flags and is\n+either @code{dynamic} or @code{cheap}.\n \n @item -ftree-vrp\n @opindex ftree-vrp\n@@ -9443,13 +9444,11 @@ constraints.  The default value is 0.\n \n @item vect-max-version-for-alignment-checks\n The maximum number of run-time checks that can be performed when\n-doing loop versioning for alignment in the vectorizer.  See option\n-@option{-ftree-vect-loop-version} for more information.\n+doing loop versioning for alignment in the vectorizer. \n \n @item vect-max-version-for-alias-checks\n The maximum number of run-time checks that can be performed when\n-doing loop versioning for alias in the vectorizer.  See option\n-@option{-ftree-vect-loop-version} for more information.\n+doing loop versioning for alias in the vectorizer. \n \n @item vect-max-peeling-for-alignment\n The maximum number of loop peels to enhance access alignment"}, {"sha": "a2be8bb1ad2e4d5663c6573450002787f7a2547c", "filename": "gcc/flag-types.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -191,6 +191,15 @@ enum fp_contract_mode {\n   FP_CONTRACT_FAST = 2\n };\n \n+/* Vectorizer cost-model.  */\n+enum vect_cost_model {\n+  VECT_COST_MODEL_UNLIMITED = 0,\n+  VECT_COST_MODEL_CHEAP = 1,\n+  VECT_COST_MODEL_DYNAMIC = 2,\n+  VECT_COST_MODEL_DEFAULT = 3\n+};\n+\n+\n /* Different instrumentation modes.  */\n enum sanitize_code {\n   /* AddressSanitizer.  */"}, {"sha": "b1fadb162328121290ab69d33e0815a27cc5d0db", "filename": "gcc/opts.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -486,6 +486,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_falign_labels, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_falign_functions, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_tail_merge, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_CHEAP },\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_foptimize_strlen, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fhoist_adjacent_loads, NULL, 1 },\n \n@@ -500,7 +501,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_3_PLUS, OPT_fgcse_after_reload, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_vectorize, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_ftree_slp_vectorize, NULL, 1 },\n-    { OPT_LEVELS_3_PLUS, OPT_fvect_cost_model, NULL, 1 },\n+    { OPT_LEVELS_3_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_DYNAMIC },\n     { OPT_LEVELS_3_PLUS, OPT_fipa_cp_clone, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_ftree_partial_pre, NULL, 1 },\n \n@@ -825,6 +826,17 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \t}\n     }\n \n+  /* Tune vectorization related parametees according to cost model.  */\n+  if (opts->x_flag_vect_cost_model == VECT_COST_MODEL_CHEAP)\n+    {\n+      maybe_set_param_value (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS,\n+            6, opts->x_param_values, opts_set->x_param_values);\n+      maybe_set_param_value (PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS,\n+            0, opts->x_param_values, opts_set->x_param_values);\n+      maybe_set_param_value (PARAM_VECT_MAX_PEELING_FOR_ALIGNMENT,\n+            0, opts->x_param_values, opts_set->x_param_values);\n+    }\n+\n   /* Set PARAM_MAX_STORES_TO_SINK to 0 if either vectorization or if-conversion\n      is disabled.  */\n   if ((!opts->x_flag_tree_loop_vectorize && !opts->x_flag_tree_slp_vectorize)\n@@ -1669,7 +1681,7 @@ common_handle_option (struct gcc_options *opts,\n           && !opts_set->x_flag_tree_vectorize)\n \topts->x_flag_tree_slp_vectorize = value;\n       if (!opts_set->x_flag_vect_cost_model)\n-\topts->x_flag_vect_cost_model = value;\n+\topts->x_flag_vect_cost_model = VECT_COST_MODEL_DYNAMIC;\n       if (!opts_set->x_flag_tree_loop_distribute_patterns)\n \topts->x_flag_tree_loop_distribute_patterns = value;\n       /* Indirect call profiling should do all useful transformations"}, {"sha": "798aacf73a0f0aa25701babf7491d90d5b9a0e13", "filename": "gcc/targhooks.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -1057,20 +1057,17 @@ default_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n   unsigned *cost = (unsigned *) data;\n   unsigned retval = 0;\n \n-  if (flag_vect_cost_model)\n-    {\n-      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n-      int stmt_cost = default_builtin_vectorization_cost (kind, vectype,\n+  tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n+  int stmt_cost = default_builtin_vectorization_cost (kind, vectype,\n \t\t\t\t\t\t\t  misalign);\n-      /* Statements in an inner loop relative to the loop being\n-\t vectorized are weighted more heavily.  The value here is\n-\t arbitrary and could potentially be improved with analysis.  */\n-      if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n-\tcount *= 50;  /* FIXME.  */\n-\n-      retval = (unsigned) (count * stmt_cost);\n-      cost[where] += retval;\n-    }\n+   /* Statements in an inner loop relative to the loop being\n+      vectorized are weighted more heavily.  The value here is\n+      arbitrary and could potentially be improved with analysis.  */\n+  if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n+    count *= 50;  /* FIXME.  */\n+\n+  retval = (unsigned) (count * stmt_cost);\n+  cost[where] += retval;\n \n   return retval;\n }"}, {"sha": "b8988d9d264a06312029ebbf8a9af0df61212f04", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -1115,7 +1115,7 @@ vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n       *new_slot = slot;\n     }\n \n-  if (!supportable_dr_alignment && !flag_vect_cost_model)\n+  if (!supportable_dr_alignment && unlimited_cost_model ())\n     slot->count += VECT_MAX_COST;\n }\n \n@@ -1225,7 +1225,7 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n    res.peel_info.dr = NULL;\n    res.body_cost_vec = stmt_vector_for_cost();\n \n-   if (flag_vect_cost_model)\n+   if (!unlimited_cost_model ())\n      {\n        res.inside_cost = INT_MAX;\n        res.outside_cost = INT_MAX;\n@@ -1454,15 +1454,15 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  vectorization factor.\n                  We do this automtically for cost model, since we calculate cost\n                  for every peeling option.  */\n-              if (!flag_vect_cost_model)\n+              if (unlimited_cost_model ())\n                 possible_npeel_number = vf /nelements;\n \n               /* Handle the aligned case. We may decide to align some other\n                  access, making DR unaligned.  */\n               if (DR_MISALIGNMENT (dr) == 0)\n                 {\n                   npeel_tmp = 0;\n-                  if (!flag_vect_cost_model)\n+                  if (unlimited_cost_model ())\n                     possible_npeel_number++;\n                 }\n \n@@ -1795,16 +1795,14 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   /* (2) Versioning to force alignment.  */\n \n   /* Try versioning if:\n-     1) flag_tree_vect_loop_version is TRUE\n-     2) optimize loop for speed\n-     3) there is at least one unsupported misaligned data ref with an unknown\n+     1) optimize loop for speed\n+     2) there is at least one unsupported misaligned data ref with an unknown\n         misalignment, and\n-     4) all misaligned data refs with a known misalignment are supported, and\n-     5) the number of runtime alignment checks is within reason.  */\n+     3) all misaligned data refs with a known misalignment are supported, and\n+     4) the number of runtime alignment checks is within reason.  */\n \n   do_versioning =\n-\tflag_tree_vect_loop_version\n-\t&& optimize_loop_nest_for_speed_p (loop)\n+\toptimize_loop_nest_for_speed_p (loop)\n \t&& (!loop->inner); /* FORNOW */\n \n   if (do_versioning)"}, {"sha": "baea8b7f8275b53f4a592f46df382ef71ccd66ef", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -2680,7 +2680,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n   /* Cost model disabled.  */\n-  if (!flag_vect_cost_model)\n+  if (unlimited_cost_model ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"cost model disabled.\\n\");\n       *ret_min_profitable_niters = 0;"}, {"sha": "b3b3abec11005a49ce734e84dd40d63128203fc3", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -2168,7 +2168,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n     }\n \n   /* Cost model: check if the vectorization is worthwhile.  */\n-  if (flag_vect_cost_model\n+  if (!unlimited_cost_model ()\n       && !vect_bb_vectorization_profitable_p (bb_vinfo))\n     {\n       if (dump_enabled_p ())"}, {"sha": "7cb8f4d9d06a7ffe91cafe52a1ac25f07c083c27", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d1127249564146429009e0682f25bd58d7a791/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d6d1127249564146429009e0682f25bd58d7a791", "patch": "@@ -880,6 +880,14 @@ known_alignment_for_access_p (struct data_reference *data_ref_info)\n   return (DR_MISALIGNMENT (data_ref_info) != -1);\n }\n \n+\n+/* Return true if the vect cost model is unlimited.  */\n+static inline bool\n+unlimited_cost_model ()\n+{\n+  return flag_vect_cost_model == VECT_COST_MODEL_UNLIMITED;\n+}\n+\n /* Source location */\n extern LOC vect_location;\n "}]}