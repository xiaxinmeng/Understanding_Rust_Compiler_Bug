{"sha": "01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiM2I5ZTM5ZmQ4Mzc5NzRjMjBlYTJhOGQ1MGJkZTFmZjUwOTYwZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-05-30T15:47:32Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-05-30T15:47:32Z"}, "message": "Update libstdc++ documentation for Support and Diagnostics clauses\n\n\t* doc/xml/manual/diagnostics.xml: Update list of headers that define\n\texception classes.\n\t* doc/xml/manual/support.xml: Rewrite advice around NULL. Rewrite\n\tsection about new/delete overloads. Improve section on verbose\n\tterminate handler.\n\t* doc/html/*: Regenerate.\n\nFrom-SVN: r271782", "tree": {"sha": "3ab3dcfbffc1c88465a36580a41d87d333ad4eac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ab3dcfbffc1c88465a36580a41d87d333ad4eac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30f78ec756bce65bca622a55916933860279632a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f78ec756bce65bca622a55916933860279632a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30f78ec756bce65bca622a55916933860279632a"}], "stats": {"total": 618, "additions": 440, "deletions": 178}, "files": [{"sha": "15a388c62d3243669bf19b84550c31eac8f29e25", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -1,5 +1,12 @@\n 2019-05-30  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* doc/xml/manual/diagnostics.xml: Update list of headers that define\n+\texception classes.\n+\t* doc/xml/manual/support.xml: Rewrite advice around NULL. Rewrite\n+\tsection about new/delete overloads. Improve section on verbose\n+\tterminate handler.\n+\t* doc/html/*: Regenerate.\n+\n \t* doc/xml/manual/status_cxx2020.xml: Add feature-test macro for\n \tP0811R3. Change status of P1353R0.\n \t* doc/html/*: Regenerate."}, {"sha": "6302b323beebe79ed94e2434772284f7d6640225", "filename": "libstdc++-v3/doc/html/index.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Findex.html?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -28,7 +28,7 @@\n   </a></span></dt><dd><dl><dt><span class=\"chapter\"><a href=\"manual/support.html\">4. \n   Support\n   \n-</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/support.html#std.support.types\">Types</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/support.html#std.support.types.fundamental\">Fundamental Types</a></span></dt><dt><span class=\"section\"><a href=\"manual/support.html#std.support.types.numeric_limits\">Numeric Properties</a></span></dt><dt><span class=\"section\"><a href=\"manual/support.html#std.support.types.null\">NULL</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"manual/dynamic_memory.html\">Dynamic Memory</a></span></dt><dt><span class=\"section\"><a href=\"manual/termination.html\">Termination</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/termination.html#support.termination.handlers\">Termination Handlers</a></span></dt><dt><span class=\"section\"><a href=\"manual/termination.html#support.termination.verbose\">Verbose Terminate Handler</a></span></dt></dl></dd></dl></dd><dt><span class=\"chapter\"><a href=\"manual/diagnostics.html\">5. \n+</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/support.html#std.support.types\">Types</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/support.html#std.support.types.fundamental\">Fundamental Types</a></span></dt><dt><span class=\"section\"><a href=\"manual/support.html#std.support.types.numeric_limits\">Numeric Properties</a></span></dt><dt><span class=\"section\"><a href=\"manual/support.html#std.support.types.null\">NULL</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"manual/dynamic_memory.html\">Dynamic Memory</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/dynamic_memory.html#std.support.memory.notes\">Additional Notes</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"manual/termination.html\">Termination</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/termination.html#support.termination.handlers\">Termination Handlers</a></span></dt><dt><span class=\"section\"><a href=\"manual/termination.html#support.termination.verbose\">Verbose Terminate Handler</a></span></dt></dl></dd></dl></dd><dt><span class=\"chapter\"><a href=\"manual/diagnostics.html\">5. \n   Diagnostics\n   \n </a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/diagnostics.html#std.diagnostics.exceptions\">Exceptions</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"manual/diagnostics.html#std.diagnostics.exceptions.api\">API Reference</a></span></dt><dt><span class=\"section\"><a href=\"manual/diagnostics.html#std.diagnostics.exceptions.data\">Adding Data to <code class=\"classname\">exception</code></a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"manual/errno.html\">Use of errno by the library</a></span></dt><dt><span class=\"section\"><a href=\"manual/concept_checking.html\">Concept Checking</a></span></dt></dl></dd><dt><span class=\"chapter\"><a href=\"manual/utilities.html\">6. "}, {"sha": "23eb1a8189af4d43713063cee9de8013afed3743", "filename": "libstdc++-v3/doc/html/manual/diagnostics.html", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdiagnostics.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdiagnostics.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdiagnostics.html?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -8,20 +8,32 @@\n   Diagnostics\n   <a id=\"id-1.3.4.3.1.1.1\" class=\"indexterm\"></a>\n </h2></div></div></div><div class=\"toc\"><p><strong>Table of Contents</strong></p><dl class=\"toc\"><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions\">Exceptions</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions.api\">API Reference</a></span></dt><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions.data\">Adding Data to <code class=\"classname\">exception</code></a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"errno.html\">Use of errno by the library</a></span></dt><dt><span class=\"section\"><a href=\"concept_checking.html\">Concept Checking</a></span></dt></dl></div><div class=\"section\"><div class=\"titlepage\"><div><div><h2 class=\"title\" style=\"clear: both\"><a id=\"std.diagnostics.exceptions\"></a>Exceptions</h2></div></div></div><div class=\"section\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"std.diagnostics.exceptions.api\"></a>API Reference</h3></div></div></div><p>\n-      All exception objects are defined in one of the standard header\n-      files: <code class=\"filename\">exception</code>,\n-      <code class=\"filename\">stdexcept</code>, <code class=\"filename\">new</code>, and\n-      <code class=\"filename\">typeinfo</code>.\n+      Most exception classes are defined in one of the standard headers\n+      <code class=\"filename\">&lt;exception&gt;</code>,\n+      <code class=\"filename\">&lt;stdexcept&gt;</code>,\n+      <code class=\"filename\">&lt;new&gt;</code>, and\n+      <code class=\"filename\">&lt;typeinfo&gt;</code>.\n+      The C++ 2011 revision of the standard added more exception types\n+      in the headers\n+      <code class=\"filename\">&lt;functional&gt;</code>,\n+      <code class=\"filename\">&lt;future&gt;</code>,\n+      <code class=\"filename\">&lt;regex&gt;</code>, and\n+      <code class=\"filename\">&lt;system_error&gt;</code>.\n+      The C++ 2017 revision of the standard added more exception types\n+      in the headers\n+      <code class=\"filename\">&lt;any&gt;</code>,\n+      <code class=\"filename\">&lt;filesystem&gt;</code>,\n+      <code class=\"filename\">&lt;optional&gt;</code>, and\n+      <code class=\"filename\">&lt;variant&gt;</code>.\n     </p><p>\n-      The base exception object is <code class=\"classname\">exception</code>,\n-      located in <code class=\"filename\">exception</code>. This object has no\n-      <code class=\"classname\">string</code> member.\n+      All exceptions thrown by the library have a base class of type\n+      <code class=\"classname\">std::exception</code>,\n+      defined in <code class=\"filename\">&lt;exception&gt;</code>.\n+      This type has no <code class=\"classname\">std::string</code> member.\n     </p><p>\n       Derived from this are several classes that may have a\n-      <code class=\"classname\">string</code> member: a full hierarchy can be\n+      <code class=\"classname\">std::string</code> member. A full hierarchy can be\n       found in the source documentation.\n-    </p><p>\n-      Full API details.\n     </p></div><div class=\"section\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"std.diagnostics.exceptions.data\"></a>Adding Data to <code class=\"classname\">exception</code></h3></div></div></div><p>\n       The standard exception classes carry with them a single string as\n       data (usually describing what went wrong or where the 'throw' took"}, {"sha": "9b7a1fc064428d1214508ccdf513d2c6fc8b70d6", "filename": "libstdc++-v3/doc/html/manual/dynamic_memory.html", "status": "modified", "additions": 120, "deletions": 39, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdynamic_memory.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdynamic_memory.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdynamic_memory.html?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -3,52 +3,128 @@\n   Support\n   \n </th><td width=\"20%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"termination.html\">Next</a></td></tr></table><hr /></div><div class=\"section\"><div class=\"titlepage\"><div><div><h2 class=\"title\" style=\"clear: both\"><a id=\"std.support.memory\"></a>Dynamic Memory</h2></div></div></div><p>\n-    There are six flavors each of <code class=\"function\">new</code> and\n-    <code class=\"function\">delete</code>, so make certain that you're using the right\n-    ones. Here are quickie descriptions of <code class=\"function\">new</code>:\n-  </p><div class=\"itemizedlist\"><ul class=\"itemizedlist\" style=\"list-style-type: disc; \"><li class=\"listitem\"><p>\n-\tsingle object form, throwing a\n-\t<code class=\"classname\">bad_alloc</code> on errors; this is what most\n-\tpeople are used to using\n-      </p></li><li class=\"listitem\"><p>\n-\tSingle object \"nothrow\" form, returning NULL on errors\n-      </p></li><li class=\"listitem\"><p>\n-\tArray <code class=\"function\">new</code>, throwing\n-\t<code class=\"classname\">bad_alloc</code> on errors\n-      </p></li><li class=\"listitem\"><p>\n-\tArray nothrow <code class=\"function\">new</code>, returning\n-\t<code class=\"constant\">NULL</code> on errors\n-      </p></li><li class=\"listitem\"><p>\n-\tPlacement <code class=\"function\">new</code>, which does nothing (like\n-\tit's supposed to)\n-      </p></li><li class=\"listitem\"><p>\n-\tPlacement array <code class=\"function\">new</code>, which also does\n-\tnothing\n-      </p></li></ul></div><p>\n-     They are distinguished by the parameters that you pass to them, like\n-     any other overloaded function.  The six flavors of <code class=\"function\">delete</code>\n+    In C++98 there are six flavors each of <code class=\"function\">operator new</code>\n+    and <code class=\"function\">operator delete</code>, so make certain that you're\n+    using the right ones.\n+    Here are quickie descriptions of <code class=\"function\">operator new</code>:\n+  </p><div class=\"variablelist\"><dl class=\"variablelist\"><dt><span class=\"term\"><code class=\"code\">void* operator new(std::size_t);</code></span></dt><dd>\n+\tSingle object form.\n+        Throws <code class=\"classname\">std::bad_alloc</code> on error.\n+        This is what most people are used to using.\n+      </dd><dt><span class=\"term\"><code class=\"code\">void* operator new(std::size_t, std::nothrow_t) noexcept;</code></span></dt><dd>\n+\tSingle object <span class=\"quote\">\u201c<span class=\"quote\">nothrow</span>\u201d</span> form.\n+        Calls <code class=\"code\">operator new(std::size_t)</code> but if that throws,\n+        returns a null pointer instead.\n+      </dd><dt><span class=\"term\"><code class=\"code\">void* operator new[](std::size_t);</code></span></dt><dd>\n+\tArray <code class=\"function\">new</code>.\n+        Calls <code class=\"code\">operator new(std::size_t)</code> and so\n+\tthrows <code class=\"classname\">std::bad_alloc</code> on error.\n+      </dd><dt><span class=\"term\"><code class=\"code\">void* operator new[](std::size_t, std::nothrow_t) noexcept;</code></span></dt><dd>\n+\tArray <span class=\"quote\">\u201c<span class=\"quote\">nothrow</span>\u201d</span><code class=\"function\">new</code>.\n+        Calls <code class=\"code\">operator new[](std::size_t)</code> but if that throws,\n+        returns a null pointer instead.\n+      </dd><dt><span class=\"term\"><code class=\"code\">void* operator new(std::size_t, void*) noexcept;</code></span></dt><dd>\n+\tNon-allocating, <span class=\"quote\">\u201c<span class=\"quote\">placement</span>\u201d</span> single-object <code class=\"function\">new</code>,\n+        which does nothing except return its argument.\n+        This function cannot be replaced.\n+      </dd><dt><span class=\"term\"><code class=\"code\">void* operator new[](std::size_t, void*) noexcept;</code></span></dt><dd>\n+\tNon-allocating, <span class=\"quote\">\u201c<span class=\"quote\">placement</span>\u201d</span> array <code class=\"function\">new</code>,\n+        which also does nothing except return its argument.\n+        This function cannot be replaced.\n+      </dd></dl></div><p>\n+     They are distinguished by the arguments that you pass to them, like\n+     any other overloaded function.  The six flavors of\n+     <code class=\"function\">operator delete</code>\n      are distinguished the same way, but none of them are allowed to throw\n-     an exception under any circumstances anyhow.  (They match up for\n-     completeness' sake.)\n+     an exception under any circumstances anyhow.  (The overloads match up\n+     with the ones above, for completeness' sake.)\n    </p><p>\n-     Remember that it is perfectly okay to call <code class=\"function\">delete</code> on a\n-     NULL pointer!  Nothing happens, by definition.  That is not the\n-     same thing as deleting a pointer twice.\n+     The C++ 2014 revision of the standard added two additional overloads of\n+     <code class=\"function\">operator delete</code> for <span class=\"quote\">\u201c<span class=\"quote\">sized deallocation</span>\u201d</span>,\n+     allowing the compiler to provide the size of the storage being freed.\n+   </p><p>\n+     The C++ 2017 standard added even more overloads of both\n+     <code class=\"function\">operator new</code> and <code class=\"function\">operator delete</code>\n+     for allocating and deallocating storage for overaligned types.\n+     These overloads correspond to each of the allocating forms of\n+     <code class=\"function\">operator new</code> and <code class=\"function\">operator delete</code>\n+     but with an additional parameter of type <span class=\"type\">std::align_val_t</span>.\n+     These new overloads are not interchangeable with the versions without\n+     an aligment parameter, so if memory was allocated by an overload of\n+     <code class=\"function\">operator new</code> taking an alignment parameter,\n+     then it must be decallocated by the corresponding overload of\n+     <code class=\"function\">operator delete</code> that takes an alignment parameter.\n+   </p><p>\n+     Apart from the non-allocating forms, the default versions of the array\n+     and nothrow <code class=\"function\">operator new</code> functions will all result\n+     in a call to either <code class=\"function\">operator new(std::size_t)</code> or\n+     <code class=\"function\">operator new(std::size_t, std::align_val_t)</code>,\n+     and similarly the default versions of the array and nothrow\n+     <code class=\"function\">operator delete</code> functions will result in a call to\n+     either <code class=\"function\">operator delete(void*)</code> or\n+     <code class=\"function\">operator delete(void*, std::align_val_t)</code>\n+     (or the sized versions of those).\n    </p><p>\n-     By default, if one of the <span class=\"quote\">\u201c<span class=\"quote\">throwing <code class=\"function\">new</code>s</span>\u201d</span> can't\n-     allocate the memory requested, it tosses an instance of a\n-     <code class=\"classname\">bad_alloc</code> exception (or, technically, some class derived\n-     from it).  You can change this by writing your own function (called a\n-     new-handler) and then registering it with <code class=\"function\">set_new_handler()</code>:\n+     Apart from the non-allocating forms, any of these functions can be\n+     replaced by defining a function with the same signature in your program.\n+     Replacement versions must preserve certain guarantees, such as memory\n+     obtained from a nothrow <code class=\"function\">operator new</code> being free-able\n+     by the normal (non-nothrow) <code class=\"function\">operator delete</code>,\n+     and the sized and unsized forms of <code class=\"function\">operator delete</code>\n+     being interchangeable (because it's unspecified whether\n+     the compiler calls the sized delete instead of the normal one).\n+     The simplest way to meet the guarantees is to only replace the ordinary\n+     <code class=\"function\">operator new(size_t)</code> and\n+     <code class=\"function\">operator delete(void*)</code> and\n+     <code class=\"function\">operator delete(void*, std::size_t)</code>\n+     functions, and the replaced versions will be used by all of\n+     <code class=\"function\">operator new(size_t, nothrow_t)</code>,\n+     <code class=\"function\">operator new[](size_t)</code> and\n+     <code class=\"function\">operator new[](size_t, nothrow_t)</code>\n+     and the corresponding <code class=\"function\">operator delete</code> functions.\n+     To support types with extended alignment you may also need to replace\n+     <code class=\"function\">operator new(size_t, align_val_t)</code> and\n+     <code class=\"function\">operator delete(void*, align_val_t)</code>\n+     <code class=\"function\">operator delete(void*, size_t, align_val_t)</code>\n+     (which will then be used by the nothrow and array forms for\n+     extended alignments).\n+     If you do need to replace other forms (e.g. to define the nothrow\n+     <code class=\"function\">operator new</code> to allocate memory directly, so it\n+     works with exceptions disabled) then make sure the memory it allocates\n+     can still be freed by the non-nothrow forms of\n+     <code class=\"function\">operator delete</code>.\n+   </p><p>\n+     If the default versions of <code class=\"function\">operator new(std::size_t)</code>\n+     and <code class=\"function\">operator new(size_t, std::align_val_t)</code>\n+     can't allocate the memory requested, they usually throw an exception\n+     object of type <code class=\"classname\">std::bad_alloc</code> (or some class\n+     derived from that). However, the program can influence that behavior\n+     by registering a <span class=\"quote\">\u201c<span class=\"quote\">new-handler</span>\u201d</span>, because what\n+     <code class=\"function\">operator new</code> actually does is something like:\n    </p><pre class=\"programlisting\">\n-   typedef void (*PFV)(void);\n+    while (true)\n+    {\n+      if (void* p = /* try to allocate memory */)\n+        return p;\n+      else if (std::new_handler h = std::get_new_handler ())\n+        h ();\n+      else\n+        throw bad_alloc{};\n+    }\n+   </pre><p>\n+     This means you can influence what happens on allocation failure by\n+     writing your own new-handler and then registering it with\n+     <code class=\"function\">std::set_new_handler</code>:\n+   </p><pre class=\"programlisting\">\n+   typedef void (*PFV)();\n \n    static char*  safety;\n    static PFV    old_handler;\n \n    void my_new_handler ()\n    {\n        delete[] safety;\n+       safety = nullptr;\n        popup_window (\"Dude, you are running low on heap memory.  You\"\n \t\t     \" should, like, close some windows, or something.\"\n \t\t     \" The next time you run out, we're gonna burn!\");\n@@ -62,10 +138,15 @@\n        old_handler = set_new_handler (&amp;my_new_handler);\n        ...\n    }\n-   </pre><p>\n-     <code class=\"classname\">bad_alloc</code> is derived from the base <code class=\"classname\">exception</code>\n-     class defined in Sect1 19.\n-   </p></div><div class=\"navfooter\"><hr /><table width=\"100%\" summary=\"Navigation footer\"><tr><td width=\"40%\" align=\"left\"><a accesskey=\"p\" href=\"support.html\">Prev</a>\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"u\" href=\"support.html\">Up</a></td><td width=\"40%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"termination.html\">Next</a></td></tr><tr><td width=\"40%\" align=\"left\" valign=\"top\">Chapter\u00a04.\u00a0\n+   </pre><div class=\"section\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"std.support.memory.notes\"></a>Additional Notes</h3></div></div></div><p>\n+     Remember that it is perfectly okay to <code class=\"function\">delete</code> a\n+     null pointer!  Nothing happens, by definition.  That is not the\n+     same thing as deleting a pointer twice.\n+   </p><p>\n+     <code class=\"classname\">std::bad_alloc</code> is derived from the base\n+     <code class=\"classname\">std::exception</code> class,\n+     see <a class=\"xref\" href=\"diagnostics.html#std.diagnostics.exceptions\" title=\"Exceptions\">Exceptions</a>.\n+   </p></div></div><div class=\"navfooter\"><hr /><table width=\"100%\" summary=\"Navigation footer\"><tr><td width=\"40%\" align=\"left\"><a accesskey=\"p\" href=\"support.html\">Prev</a>\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"u\" href=\"support.html\">Up</a></td><td width=\"40%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"termination.html\">Next</a></td></tr><tr><td width=\"40%\" align=\"left\" valign=\"top\">Chapter\u00a04.\u00a0\n   Support\n   \n \u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"h\" href=\"../index.html\">Home</a></td><td width=\"40%\" align=\"right\" valign=\"top\">\u00a0Termination</td></tr></table></div></body></html>\n\\ No newline at end of file"}, {"sha": "3f2a48291f9f2b801e344e539633c55a5c6e4ded", "filename": "libstdc++-v3/doc/html/manual/index.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Findex.html?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -9,7 +9,7 @@\n   </a></span></dt><dd><dl><dt><span class=\"chapter\"><a href=\"support.html\">4. \n   Support\n   \n-</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types\">Types</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types.fundamental\">Fundamental Types</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.numeric_limits\">Numeric Properties</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.null\">NULL</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"dynamic_memory.html\">Dynamic Memory</a></span></dt><dt><span class=\"section\"><a href=\"termination.html\">Termination</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"termination.html#support.termination.handlers\">Termination Handlers</a></span></dt><dt><span class=\"section\"><a href=\"termination.html#support.termination.verbose\">Verbose Terminate Handler</a></span></dt></dl></dd></dl></dd><dt><span class=\"chapter\"><a href=\"diagnostics.html\">5. \n+</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types\">Types</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types.fundamental\">Fundamental Types</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.numeric_limits\">Numeric Properties</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.null\">NULL</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"dynamic_memory.html\">Dynamic Memory</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"dynamic_memory.html#std.support.memory.notes\">Additional Notes</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"termination.html\">Termination</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"termination.html#support.termination.handlers\">Termination Handlers</a></span></dt><dt><span class=\"section\"><a href=\"termination.html#support.termination.verbose\">Verbose Terminate Handler</a></span></dt></dl></dd></dl></dd><dt><span class=\"chapter\"><a href=\"diagnostics.html\">5. \n   Diagnostics\n   \n </a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions\">Exceptions</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions.api\">API Reference</a></span></dt><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions.data\">Adding Data to <code class=\"classname\">exception</code></a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"errno.html\">Use of errno by the library</a></span></dt><dt><span class=\"section\"><a href=\"concept_checking.html\">Concept Checking</a></span></dt></dl></dd><dt><span class=\"chapter\"><a href=\"utilities.html\">6. "}, {"sha": "14586e8c75bb32a0465ec23f2c6aee90cc288679", "filename": "libstdc++-v3/doc/html/manual/std_contents.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstd_contents.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstd_contents.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstd_contents.html?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -6,7 +6,7 @@\n   </h1></div></div></div><div class=\"toc\"><p><strong>Table of Contents</strong></p><dl class=\"toc\"><dt><span class=\"chapter\"><a href=\"support.html\">4. \n   Support\n   \n-</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types\">Types</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types.fundamental\">Fundamental Types</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.numeric_limits\">Numeric Properties</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.null\">NULL</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"dynamic_memory.html\">Dynamic Memory</a></span></dt><dt><span class=\"section\"><a href=\"termination.html\">Termination</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"termination.html#support.termination.handlers\">Termination Handlers</a></span></dt><dt><span class=\"section\"><a href=\"termination.html#support.termination.verbose\">Verbose Terminate Handler</a></span></dt></dl></dd></dl></dd><dt><span class=\"chapter\"><a href=\"diagnostics.html\">5. \n+</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types\">Types</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types.fundamental\">Fundamental Types</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.numeric_limits\">Numeric Properties</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.null\">NULL</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"dynamic_memory.html\">Dynamic Memory</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"dynamic_memory.html#std.support.memory.notes\">Additional Notes</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"termination.html\">Termination</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"termination.html#support.termination.handlers\">Termination Handlers</a></span></dt><dt><span class=\"section\"><a href=\"termination.html#support.termination.verbose\">Verbose Terminate Handler</a></span></dt></dl></dd></dl></dd><dt><span class=\"chapter\"><a href=\"diagnostics.html\">5. \n   Diagnostics\n   \n </a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions\">Exceptions</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions.api\">API Reference</a></span></dt><dt><span class=\"section\"><a href=\"diagnostics.html#std.diagnostics.exceptions.data\">Adding Data to <code class=\"classname\">exception</code></a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"errno.html\">Use of errno by the library</a></span></dt><dt><span class=\"section\"><a href=\"concept_checking.html\">Concept Checking</a></span></dt></dl></dd><dt><span class=\"chapter\"><a href=\"utilities.html\">6. "}, {"sha": "c7c1cfedcc9413e8e7391b419631c24358581dd1", "filename": "libstdc++-v3/doc/html/manual/support.html", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fsupport.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fsupport.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fsupport.html?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -7,7 +7,7 @@\n   </th><td width=\"20%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"dynamic_memory.html\">Next</a></td></tr></table><hr /></div><div class=\"chapter\"><div class=\"titlepage\"><div><div><h2 class=\"title\"><a id=\"std.support\"></a>Chapter\u00a04.\u00a0\n   Support\n   <a id=\"id-1.3.4.2.1.1.1\" class=\"indexterm\"></a>\n-</h2></div></div></div><div class=\"toc\"><p><strong>Table of Contents</strong></p><dl class=\"toc\"><dt><span class=\"section\"><a href=\"support.html#std.support.types\">Types</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types.fundamental\">Fundamental Types</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.numeric_limits\">Numeric Properties</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.null\">NULL</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"dynamic_memory.html\">Dynamic Memory</a></span></dt><dt><span class=\"section\"><a href=\"termination.html\">Termination</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"termination.html#support.termination.handlers\">Termination Handlers</a></span></dt><dt><span class=\"section\"><a href=\"termination.html#support.termination.verbose\">Verbose Terminate Handler</a></span></dt></dl></dd></dl></div><p>\n+</h2></div></div></div><div class=\"toc\"><p><strong>Table of Contents</strong></p><dl class=\"toc\"><dt><span class=\"section\"><a href=\"support.html#std.support.types\">Types</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"support.html#std.support.types.fundamental\">Fundamental Types</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.numeric_limits\">Numeric Properties</a></span></dt><dt><span class=\"section\"><a href=\"support.html#std.support.types.null\">NULL</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"dynamic_memory.html\">Dynamic Memory</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"dynamic_memory.html#std.support.memory.notes\">Additional Notes</a></span></dt></dl></dd><dt><span class=\"section\"><a href=\"termination.html\">Termination</a></span></dt><dd><dl><dt><span class=\"section\"><a href=\"termination.html#support.termination.handlers\">Termination Handlers</a></span></dt><dt><span class=\"section\"><a href=\"termination.html#support.termination.verbose\">Verbose Terminate Handler</a></span></dt></dl></dd></dl></div><p>\n     This part deals with the functions called and objects created\n     automatically during the course of a program's existence.\n   </p><p>\n@@ -53,7 +53,7 @@\n       Specializing parts of the library on these types is prohibited:\n       instead, use a POD.\n     </p></div><div class=\"section\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"std.support.types.numeric_limits\"></a>Numeric Properties</h3></div></div></div><p>\n-    The header <code class=\"filename\">limits</code> defines\n+    The header <code class=\"filename\">&lt;limits&gt;</code> defines\n     traits classes to give access to various implementation\n     defined-aspects of the fundamental types. The traits classes --\n     fourteen in total -- are all specializations of the class template\n@@ -102,28 +102,36 @@\n      The only change that might affect people is the type of\n      <code class=\"constant\">NULL</code>: while it is required to be a macro,\n      the definition of that macro is <span class=\"emphasis\"><em>not</em></span> allowed\n-     to be <code class=\"constant\">(void*)0</code>, which is often used in C.\n+     to be an expression with pointer type such as\n+     <code class=\"constant\">(void*)0</code>, which is often used in C.\n     </p><p>\n      For <span class=\"command\"><strong>g++</strong></span>, <code class=\"constant\">NULL</code> is\n      <code class=\"code\">#define</code>'d to be\n      <code class=\"constant\">__null</code>, a magic keyword extension of\n-     <span class=\"command\"><strong>g++</strong></span>.\n+     <span class=\"command\"><strong>g++</strong></span> that is slightly safer than a plain integer.\n     </p><p>\n      The biggest problem of #defining <code class=\"constant\">NULL</code> to be\n      something like <span class=\"quote\">\u201c<span class=\"quote\">0L</span>\u201d</span> is that the compiler will view\n      that as a long integer before it views it as a pointer, so\n-     overloading won't do what you expect. (This is why\n-     <span class=\"command\"><strong>g++</strong></span> has a magic extension, so that\n-     <code class=\"constant\">NULL</code> is always a pointer.)\n-    </p><p>In his book <a class=\"link\" href=\"http://www.aristeia.com/books.html\" target=\"_top\"><span class=\"emphasis\"><em>Effective\n-      C++</em></span></a>, Scott Meyers points out that the best way\n-    to solve this problem is to not overload on pointer-vs-integer\n-    types to begin with.  He also offers a way to make your own magic\n-    <code class=\"constant\">NULL</code> that will match pointers before it\n-    matches integers.\n-    </p><p>See the\n-      <a class=\"link\" href=\"http://www.aristeia.com/books.html\" target=\"_top\"><span class=\"emphasis\"><em>Effective\n-      C++ CD</em></span></a> example.\n+     overloading won't do what you expect. It might not even have the\n+     same size as a pointer, so passing <code class=\"constant\">NULL</code> to a\n+     varargs function where a pointer is expected might not even work\n+     correctly if <code class=\"code\">sizeof(NULL) &lt; sizeof(void*)</code>.\n+     The G++ <code class=\"constant\">__null</code> extension is defined so that\n+     <code class=\"code\">sizeof(__null) == sizeof(void*)</code> to avoid this problem.\n+    </p><p>\n+     Scott Meyers explains this in more detail in his book\n+     <a class=\"link\" href=\"https://www.aristeia.com/books.html\" target=\"_top\"><span class=\"emphasis\"><em>Effective\n+     Modern C++</em></span></a> and as a guideline to solve this problem\n+     recommends to not overload on pointer-vs-integer types to begin with.\n+    </p><p>\n+     The C++ 2011 standard added the <code class=\"constant\">nullptr</code> keyword,\n+     which is a null pointer constant of a special type,\n+     <code class=\"classname\">std::nullptr_t</code>. Values of this type can be\n+     implicitly converted to <span class=\"emphasis\"><em>any</em></span> pointer type,\n+     and cannot convert to integer types or be deduced as an integer type.\n+     Unless you need to be compatible with C++98/C++03 or C you should prefer\n+     to use <code class=\"constant\">nullptr</code>  instead of <code class=\"constant\">NULL</code>.\n     </p></div></div></div><div class=\"navfooter\"><hr /><table width=\"100%\" summary=\"Navigation footer\"><tr><td width=\"40%\" align=\"left\"><a accesskey=\"p\" href=\"std_contents.html\">Prev</a>\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"u\" href=\"std_contents.html\">Up</a></td><td width=\"40%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"dynamic_memory.html\">Next</a></td></tr><tr><td width=\"40%\" align=\"left\" valign=\"top\">Part\u00a0II.\u00a0\n     Standard Contents\n   \u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"h\" href=\"../index.html\">Home</a></td><td width=\"40%\" align=\"right\" valign=\"top\">\u00a0Dynamic Memory</td></tr></table></div></body></html>\n\\ No newline at end of file"}, {"sha": "d30f0e0eaea21bb35bf9ba6190a7cfcf9b568928", "filename": "libstdc++-v3/doc/html/manual/termination.html", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Ftermination.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Ftermination.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Ftermination.html?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -3,7 +3,9 @@\n   Support\n   \n </th><td width=\"20%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"diagnostics.html\">Next</a></td></tr></table><hr /></div><div class=\"section\"><div class=\"titlepage\"><div><div><h2 class=\"title\" style=\"clear: both\"><a id=\"std.support.termination\"></a>Termination</h2></div></div></div><div class=\"section\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"support.termination.handlers\"></a>Termination Handlers</h3></div></div></div><p>\n-      Not many changes here to <code class=\"filename\">cstdlib</code>.  You should note that the\n+      Not many changes here to\n+      <code class=\"filename\">&lt;cstdlib&gt;</code>.\n+      You should note that the\n       <code class=\"function\">abort()</code> function does not call the\n       destructors of automatic nor static objects, so if you're\n       depending on those to do cleanup, it isn't going to happen.\n@@ -24,8 +26,8 @@\n \tThe previous two actions are <span class=\"quote\">\u201c<span class=\"quote\">interleaved,</span>\u201d</span> that is,\n \tgiven this pseudocode:\n \t</p><pre class=\"programlisting\">\n-  extern \"C or C++\" void  f1 (void);\n-  extern \"C or C++\" void  f2 (void);\n+  extern \"C or C++\" void f1 ();\n+  extern \"C or C++\" void f2 ();\n \n   static Thing obj1;\n   atexit(f1);\n@@ -43,11 +45,20 @@\n       Note also that <code class=\"function\">atexit()</code> is only required to store 32\n       functions, and the compiler/library might already be using some of\n       those slots.  If you think you may run out, we recommend using\n-      the <code class=\"function\">xatexit</code>/<code class=\"function\">xexit</code> combination from <code class=\"literal\">libiberty</code>, which has no such limit.\n+      the <code class=\"function\">xatexit</code>/<code class=\"function\">xexit</code> combination\n+      from <code class=\"literal\">libiberty</code>, which has no such limit.\n     </p></div><div class=\"section\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"support.termination.verbose\"></a>Verbose Terminate Handler</h3></div></div></div><p>\n       If you are having difficulty with uncaught exceptions and want a\n       little bit of help debugging the causes of the core dumps, you can\n       make use of a GNU extension, the verbose terminate handler.\n+    </p><p>\n+      The verbose terminate handler is only available for hosted environments\n+      (see <a class=\"xref\" href=\"configure.html\" title=\"Configure\">Configuring</a>) and will be used\n+      by default unless the library is built with\n+      <code class=\"option\">--disable-libstdcxx-verbose</code>\n+      or with exceptions disabled.\n+      If you need to enable it explicitly you can do so by calling the\n+      <code class=\"function\">std::set_terminate</code> function.\n     </p><pre class=\"programlisting\">\n #include &lt;exception&gt;\n \n@@ -61,12 +72,13 @@\n </pre><p>\n      The <code class=\"function\">__verbose_terminate_handler</code> function\n      obtains the name of the current exception, attempts to demangle\n-     it, and prints it to stderr.  If the exception is derived from\n-     <code class=\"classname\">exception</code> then the output from\n+     it, and prints it to <code class=\"literal\">stderr</code>.\n+     If the exception is derived from\n+     <code class=\"classname\">std::exception</code> then the output from\n      <code class=\"function\">what()</code> will be included.\n    </p><p>\n      Any replacement termination function is required to kill the\n-     program without returning; this one calls abort.\n+     program without returning; this one calls <code class=\"function\">std::abort</code>.\n    </p><p>\n      For example:\n    </p><pre class=\"programlisting\">\n@@ -99,22 +111,23 @@\n    Aborted\n    </code>\n    </pre><p>\n-     The 'Aborted' line comes from the call to\n-     <code class=\"function\">abort()</code>, of course.\n+     The 'Aborted' line is printed by the shell after the process exits\n+     by calling <code class=\"function\">abort()</code>.\n    </p><p>\n-     This is the default termination handler; nothing need be done to\n+     As this is the default termination handler, nothing need be done to\n      use it.  To go back to the previous <span class=\"quote\">\u201c<span class=\"quote\">silent death</span>\u201d</span>\n-     method, simply include <code class=\"filename\">exception</code> and\n-     <code class=\"filename\">cstdlib</code>, and call\n+     method, simply include\n+     <code class=\"filename\">&lt;exception&gt;</code> and\n+     <code class=\"filename\">&lt;cstdlib&gt;</code>, and call\n    </p><pre class=\"programlisting\">\n      std::set_terminate(std::abort);\n    </pre><p>\n      After this, all calls to <code class=\"function\">terminate</code> will use\n      <code class=\"function\">abort</code> as the terminate handler.\n    </p><p>\n      Note: the verbose terminate handler will attempt to write to\n-     stderr.  If your application closes stderr or redirects it to an\n-     inappropriate location,\n+     <code class=\"literal\">stderr</code>.  If your application closes\n+     <code class=\"literal\">stderr</code> or redirects it to an inappropriate location,\n      <code class=\"function\">__verbose_terminate_handler</code> will behave in\n      an unspecified manner.\n    </p></div></div><div class=\"navfooter\"><hr /><table width=\"100%\" summary=\"Navigation footer\"><tr><td width=\"40%\" align=\"left\"><a accesskey=\"p\" href=\"dynamic_memory.html\">Prev</a>\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"u\" href=\"support.html\">Up</a></td><td width=\"40%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"diagnostics.html\">Next</a></td></tr><tr><td width=\"40%\" align=\"left\" valign=\"top\">Dynamic Memory\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"h\" href=\"../index.html\">Home</a></td><td width=\"40%\" align=\"right\" valign=\"top\">\u00a0Chapter\u00a05.\u00a0"}, {"sha": "08f576965d216fa365cd7aafb67da44d483ca5fc", "filename": "libstdc++-v3/doc/xml/manual/diagnostics.xml", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdiagnostics.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdiagnostics.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdiagnostics.xml?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -21,28 +21,38 @@\n   <section xml:id=\"std.diagnostics.exceptions.api\"><info><title>API Reference</title></info>\n     \n     <para>\n-      All exception objects are defined in one of the standard header\n-      files: <filename>exception</filename>,\n-      <filename>stdexcept</filename>, <filename>new</filename>, and\n-      <filename>typeinfo</filename>.\n+      Most exception classes are defined in one of the standard headers\n+      <filename class=\"headerfile\">&lt;exception&gt;</filename>,\n+      <filename class=\"headerfile\">&lt;stdexcept&gt;</filename>,\n+      <filename class=\"headerfile\">&lt;new&gt;</filename>, and\n+      <filename class=\"headerfile\">&lt;typeinfo&gt;</filename>.\n+      The C++ 2011 revision of the standard added more exception types\n+      in the headers\n+      <filename class=\"headerfile\">&lt;functional&gt;</filename>,\n+      <filename class=\"headerfile\">&lt;future&gt;</filename>,\n+      <filename class=\"headerfile\">&lt;regex&gt;</filename>, and\n+      <filename class=\"headerfile\">&lt;system_error&gt;</filename>.\n+      The C++ 2017 revision of the standard added more exception types\n+      in the headers\n+      <filename class=\"headerfile\">&lt;any&gt;</filename>,\n+      <filename class=\"headerfile\">&lt;filesystem&gt;</filename>,\n+      <filename class=\"headerfile\">&lt;optional&gt;</filename>, and\n+      <filename class=\"headerfile\">&lt;variant&gt;</filename>.\n     </para>\n \n     <para>\n-      The base exception object is <classname>exception</classname>,\n-      located in <filename>exception</filename>. This object has no\n-      <classname>string</classname> member.\n+      All exceptions thrown by the library have a base class of type\n+      <classname>std::exception</classname>,\n+      defined in <filename class=\"headerfile\">&lt;exception&gt;</filename>.\n+      This type has no <classname>std::string</classname> member.\n     </para>\n \n     <para>\n       Derived from this are several classes that may have a\n-      <classname>string</classname> member: a full hierarchy can be\n+      <classname>std::string</classname> member. A full hierarchy can be\n       found in the source documentation.\n     </para>\n     \n-    <para>\n-      Full API details.\n-    </para>\n-    \n     <!-- Doxygen XML: api/group__exceptions.xml -->\n       \n   </section>"}, {"sha": "da8fed0e015805c6b3069a249fa073f39d3d4af7", "filename": "libstdc++-v3/doc/xml/manual/support.xml", "status": "modified", "additions": 215, "deletions": 84, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fsupport.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b3b9e39fd837974c20ea2a8d50bde1ff50960f/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fsupport.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fsupport.xml?ref=01b3b9e39fd837974c20ea2a8d50bde1ff50960f", "patch": "@@ -26,9 +26,9 @@\n \n <section xml:id=\"std.support.types\" xreflabel=\"Types\"><info><title>Types</title></info>\n   <?dbhtml filename=\"fundamental_types.html\"?>\n-  \n+\n   <section xml:id=\"std.support.types.fundamental\" xreflabel=\"Fundamental Types\"><info><title>Fundamental Types</title></info>\n-    \n+\n     <para>\n       C++ has the following builtin types:\n     </para>\n@@ -90,11 +90,9 @@\n \n   </section>\n   <section xml:id=\"std.support.types.numeric_limits\" xreflabel=\"Numeric Properties\"><info><title>Numeric Properties</title></info>\n-    \n-\n \n     <para>\n-    The header <filename class=\"headerfile\">limits</filename> defines\n+    The header <filename class=\"headerfile\">&lt;limits&gt;</filename> defines\n     traits classes to give access to various implementation\n     defined-aspects of the fundamental types. The traits classes --\n     fourteen in total -- are all specializations of the class template\n@@ -145,109 +143,216 @@\n   </section>\n \n   <section xml:id=\"std.support.types.null\" xreflabel=\"NULL\"><info><title>NULL</title></info>\n-    \n+\n     <para>\n      The only change that might affect people is the type of\n      <constant>NULL</constant>: while it is required to be a macro,\n      the definition of that macro is <emphasis>not</emphasis> allowed\n-     to be <constant>(void*)0</constant>, which is often used in C.\n+     to be an expression with pointer type such as\n+     <constant>(void*)0</constant>, which is often used in C.\n     </para>\n \n     <para>\n      For <command>g++</command>, <constant>NULL</constant> is\n      <code>#define</code>'d to be\n      <constant>__null</constant>, a magic keyword extension of\n-     <command>g++</command>.\n+     <command>g++</command> that is slightly safer than a plain integer.\n     </para>\n \n     <para>\n      The biggest problem of #defining <constant>NULL</constant> to be\n      something like <quote>0L</quote> is that the compiler will view\n      that as a long integer before it views it as a pointer, so\n-     overloading won't do what you expect. (This is why\n-     <command>g++</command> has a magic extension, so that\n-     <constant>NULL</constant> is always a pointer.)\n+     overloading won't do what you expect. It might not even have the\n+     same size as a pointer, so passing <constant>NULL</constant> to a\n+     varargs function where a pointer is expected might not even work\n+     correctly if <code>sizeof(NULL) &lt; sizeof(void*)</code>.\n+     The G++ <constant>__null</constant> extension is defined so that\n+     <code>sizeof(__null) == sizeof(void*)</code> to avoid this problem.\n     </para>\n \n-    <para>In his book <link xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n-      xlink:href=\"http://www.aristeia.com/books.html\"><emphasis>Effective\n-      C++</emphasis></link>, Scott Meyers points out that the best way\n-    to solve this problem is to not overload on pointer-vs-integer\n-    types to begin with.  He also offers a way to make your own magic\n-    <constant>NULL</constant> that will match pointers before it\n-    matches integers.\n+    <para>\n+     Scott Meyers explains this in more detail in his book\n+     <link xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n+      xlink:href=\"https://www.aristeia.com/books.html\"><emphasis>Effective\n+     Modern C++</emphasis></link> and as a guideline to solve this problem\n+     recommends to not overload on pointer-vs-integer types to begin with.\n     </para>\n-    <para>See the\n-      <link xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n-      xlink:href=\"http://www.aristeia.com/books.html\"><emphasis>Effective\n-      C++ CD</emphasis></link> example.\n+\n+    <para>\n+     The C++ 2011 standard added the <constant>nullptr</constant> keyword,\n+     which is a null pointer constant of a special type,\n+     <classname>std::nullptr_t</classname>. Values of this type can be\n+     implicitly converted to <emphasis>any</emphasis> pointer type,\n+     and cannot convert to integer types or be deduced as an integer type.\n+     Unless you need to be compatible with C++98/C++03 or C you should prefer\n+     to use <constant>nullptr</constant>  instead of <constant>NULL</constant>.\n     </para>\n   </section>\n \n </section>\n \n <section xml:id=\"std.support.memory\" xreflabel=\"Dynamic Memory\"><info><title>Dynamic Memory</title></info>\n   <?dbhtml filename=\"dynamic_memory.html\"?>\n-  \n+\n   <para>\n-    There are six flavors each of <function>new</function> and\n-    <function>delete</function>, so make certain that you're using the right\n-    ones. Here are quickie descriptions of <function>new</function>:\n+    In C++98 there are six flavors each of <function>operator new</function>\n+    and <function>operator delete</function>, so make certain that you're\n+    using the right ones.\n+    Here are quickie descriptions of <function>operator new</function>:\n   </para>\n-  <itemizedlist>\n-      <listitem><para>\n-\tsingle object form, throwing a\n-\t<classname>bad_alloc</classname> on errors; this is what most\n-\tpeople are used to using\n-      </para></listitem>\n-      <listitem><para>\n-\tSingle object \"nothrow\" form, returning NULL on errors\n-      </para></listitem>\n-      <listitem><para>\n-\tArray <function>new</function>, throwing\n-\t<classname>bad_alloc</classname> on errors\n-      </para></listitem>\n-      <listitem><para>\n-\tArray nothrow <function>new</function>, returning\n-\t<constant>NULL</constant> on errors\n-      </para></listitem>\n-      <listitem><para>\n-\tPlacement <function>new</function>, which does nothing (like\n-\tit's supposed to)\n-      </para></listitem>\n-      <listitem><para>\n-\tPlacement array <function>new</function>, which also does\n-\tnothing\n-      </para></listitem>\n-   </itemizedlist>\n+  <variablelist>\n+    <varlistentry>\n+      <term><code>void* operator new(std::size_t);</code></term>\n+      <listitem>\n+\tSingle object form.\n+        Throws <classname>std::bad_alloc</classname> on error.\n+        This is what most people are used to using.\n+      </listitem>\n+    </varlistentry>\n+    <varlistentry>\n+      <term><code>void* operator new(std::size_t, std::nothrow_t) noexcept;</code></term>\n+      <listitem>\n+\tSingle object <quote>nothrow</quote> form.\n+        Calls <code>operator new(std::size_t)</code> but if that throws,\n+        returns a null pointer instead.\n+      </listitem>\n+    </varlistentry>\n+    <varlistentry>\n+      <term><code>void* operator new[](std::size_t);</code></term>\n+      <listitem>\n+\tArray <function>new</function>.\n+        Calls <code>operator new(std::size_t)</code> and so\n+\tthrows <classname>std::bad_alloc</classname> on error.\n+      </listitem>\n+    </varlistentry>\n+    <varlistentry>\n+      <term><code>void* operator new[](std::size_t, std::nothrow_t) noexcept;</code></term>\n+      <listitem>\n+\tArray <quote>nothrow</quote> <function>new</function>.\n+        Calls <code>operator new[](std::size_t)</code> but if that throws,\n+        returns a null pointer instead.\n+      </listitem>\n+    </varlistentry>\n+    <varlistentry>\n+      <term><code>void* operator new(std::size_t, void*) noexcept;</code></term>\n+      <listitem>\n+\tNon-allocating, <quote>placement</quote> single-object <function>new</function>,\n+        which does nothing except return its argument.\n+        This function cannot be replaced.\n+      </listitem>\n+    </varlistentry>\n+    <varlistentry>\n+      <term><code>void* operator new[](std::size_t, void*) noexcept;</code></term>\n+      <listitem>\n+\tNon-allocating, <quote>placement</quote> array <function>new</function>,\n+        which also does nothing except return its argument.\n+        This function cannot be replaced.\n+      </listitem>\n+    </varlistentry>\n+   </variablelist>\n    <para>\n-     They are distinguished by the parameters that you pass to them, like\n-     any other overloaded function.  The six flavors of <function>delete</function>\n+     They are distinguished by the arguments that you pass to them, like\n+     any other overloaded function.  The six flavors of\n+     <function>operator delete</function>\n      are distinguished the same way, but none of them are allowed to throw\n-     an exception under any circumstances anyhow.  (They match up for\n-     completeness' sake.)\n+     an exception under any circumstances anyhow.  (The overloads match up\n+     with the ones above, for completeness' sake.)\n    </para>\n    <para>\n-     Remember that it is perfectly okay to call <function>delete</function> on a\n-     NULL pointer!  Nothing happens, by definition.  That is not the\n-     same thing as deleting a pointer twice.\n+     The C++ 2014 revision of the standard added two additional overloads of\n+     <function>operator delete</function> for <quote>sized deallocation</quote>,\n+     allowing the compiler to provide the size of the storage being freed.\n+   </para>\n+   <para>\n+     The C++ 2017 standard added even more overloads of both\n+     <function>operator new</function> and <function>operator delete</function>\n+     for allocating and deallocating storage for overaligned types.\n+     These overloads correspond to each of the allocating forms of\n+     <function>operator new</function> and <function>operator delete</function>\n+     but with an additional parameter of type <type>std::align_val_t</type>.\n+     These new overloads are not interchangeable with the versions without\n+     an aligment parameter, so if memory was allocated by an overload of\n+     <function>operator new</function> taking an alignment parameter,\n+     then it must be decallocated by the corresponding overload of\n+     <function>operator delete</function> that takes an alignment parameter.\n    </para>\n    <para>\n-     By default, if one of the <quote>throwing <function>new</function>s</quote> can't\n-     allocate the memory requested, it tosses an instance of a\n-     <classname>bad_alloc</classname> exception (or, technically, some class derived\n-     from it).  You can change this by writing your own function (called a\n-     new-handler) and then registering it with <function>set_new_handler()</function>:\n+     Apart from the non-allocating forms, the default versions of the array\n+     and nothrow <function>operator new</function> functions will all result\n+     in a call to either <function>operator new(std::size_t)</function> or\n+     <function>operator new(std::size_t, std::align_val_t)</function>,\n+     and similarly the default versions of the array and nothrow\n+     <function>operator delete</function> functions will result in a call to\n+     either <function>operator delete(void*)</function> or\n+     <function>operator delete(void*, std::align_val_t)</function>\n+     (or the sized versions of those).\n+   </para>\n+   <para>\n+     Apart from the non-allocating forms, any of these functions can be\n+     replaced by defining a function with the same signature in your program.\n+     Replacement versions must preserve certain guarantees, such as memory\n+     obtained from a nothrow <function>operator new</function> being free-able\n+     by the normal (non-nothrow) <function>operator delete</function>,\n+     and the sized and unsized forms of <function>operator delete</function>\n+     being interchangeable (because it's unspecified whether\n+     the compiler calls the sized delete instead of the normal one).\n+     The simplest way to meet the guarantees is to only replace the ordinary\n+     <function>operator new(size_t)</function> and\n+     <function>operator delete(void*)</function> and\n+     <function>operator delete(void*, std::size_t)</function>\n+     functions, and the replaced versions will be used by all of\n+     <function>operator new(size_t, nothrow_t)</function>,\n+     <function>operator new[](size_t)</function> and\n+     <function>operator new[](size_t, nothrow_t)</function>\n+     and the corresponding <function>operator delete</function> functions.\n+     To support types with extended alignment you may also need to replace\n+     <function>operator new(size_t, align_val_t)</function> and\n+     <function>operator delete(void*, align_val_t)</function>\n+     <function>operator delete(void*, size_t, align_val_t)</function>\n+     (which will then be used by the nothrow and array forms for\n+     extended alignments).\n+     If you do need to replace other forms (e.g. to define the nothrow\n+     <function>operator new</function> to allocate memory directly, so it\n+     works with exceptions disabled) then make sure the memory it allocates\n+     can still be freed by the non-nothrow forms of\n+     <function>operator delete</function>.\n+   </para>\n+   <para>\n+     If the default versions of <function>operator new(std::size_t)</function>\n+     and <function>operator new(size_t, std::align_val_t)</function>\n+     can't allocate the memory requested, they usually throw an exception\n+     object of type <classname>std::bad_alloc</classname> (or some class\n+     derived from that). However, the program can influence that behavior\n+     by registering a <quote>new-handler</quote>, because what\n+     <function>operator new</function> actually does is something like:\n    </para>\n    <programlisting>\n-   typedef void (*PFV)(void);\n+    while (true)\n+    {\n+      if (void* p = /* try to allocate memory */)\n+        return p;\n+      else if (std::new_handler h = std::get_new_handler ())\n+        h ();\n+      else\n+        throw bad_alloc{};\n+    }\n+   </programlisting>\n+   <para>\n+     This means you can influence what happens on allocation failure by\n+     writing your own new-handler and then registering it with\n+     <function>std::set_new_handler</function>:\n+   </para>\n+   <programlisting>\n+   typedef void (*PFV)();\n \n    static char*  safety;\n    static PFV    old_handler;\n \n    void my_new_handler ()\n    {\n        delete[] safety;\n+       safety = nullptr;\n        popup_window (\"Dude, you are running low on heap memory.  You\"\n \t\t     \" should, like, close some windows, or something.\"\n \t\t     \" The next time you run out, we're gonna burn!\");\n@@ -262,19 +367,32 @@\n        ...\n    }\n    </programlisting>\n+\n+   <section xml:id=\"std.support.memory.notes\" xreflabel=\"Dynamic Memory Notes\"><info><title>Additional Notes</title></info>\n+\n    <para>\n-     <classname>bad_alloc</classname> is derived from the base <classname>exception</classname>\n-     class defined in Sect1 19.\n+     Remember that it is perfectly okay to <function>delete</function> a\n+     null pointer!  Nothing happens, by definition.  That is not the\n+     same thing as deleting a pointer twice.\n    </para>\n+   <para>\n+     <classname>std::bad_alloc</classname> is derived from the base\n+     <classname>std::exception</classname> class,\n+     see <xref linkend=\"std.diagnostics.exceptions\"/>.\n+   </para>\n+   </section>\n+\n </section>\n \n <section xml:id=\"std.support.termination\" xreflabel=\"Termination\"><info><title>Termination</title></info>\n   <?dbhtml filename=\"termination.html\"?>\n-  \n+\n   <section xml:id=\"support.termination.handlers\" xreflabel=\"Termination Handlers\"><info><title>Termination Handlers</title></info>\n-    \n+\n     <para>\n-      Not many changes here to <filename class=\"headerfile\">cstdlib</filename>.  You should note that the\n+      Not many changes here to\n+      <filename class=\"headerfile\">&lt;cstdlib&gt;</filename>.\n+      You should note that the\n       <function>abort()</function> function does not call the\n       destructors of automatic nor static objects, so if you're\n       depending on those to do cleanup, it isn't going to happen.\n@@ -306,8 +424,8 @@\n \tgiven this pseudocode:\n \t</para>\n <programlisting>\n-  extern \"C or C++\" void  f1 (void);\n-  extern \"C or C++\" void  f2 (void);\n+  extern \"C or C++\" void f1 ();\n+  extern \"C or C++\" void f2 ();\n \n   static Thing obj1;\n   atexit(f1);\n@@ -329,19 +447,30 @@\n       Note also that <function>atexit()</function> is only required to store 32\n       functions, and the compiler/library might already be using some of\n       those slots.  If you think you may run out, we recommend using\n-      the <function>xatexit</function>/<function>xexit</function> combination from <literal>libiberty</literal>, which has no such limit.\n+      the <function>xatexit</function>/<function>xexit</function> combination\n+      from <literal>libiberty</literal>, which has no such limit.\n     </para>\n   </section>\n \n   <section xml:id=\"support.termination.verbose\" xreflabel=\"Verbose Terminate Handler\"><info><title>Verbose Terminate Handler</title></info>\n   <?dbhtml filename=\"verbose_termination.html\"?>\n-    \n+\n     <para>\n       If you are having difficulty with uncaught exceptions and want a\n       little bit of help debugging the causes of the core dumps, you can\n       make use of a GNU extension, the verbose terminate handler.\n     </para>\n \n+    <para>\n+      The verbose terminate handler is only available for hosted environments\n+      (see <xref linkend=\"manual.intro.setup.configure\"/>) and will be used\n+      by default unless the library is built with\n+      <option>--disable-libstdcxx-verbose</option>\n+      or with exceptions disabled.\n+      If you need to enable it explicitly you can do so by calling the\n+      <function>std::set_terminate</function> function.\n+    </para>\n+\n <programlisting>\n #include &lt;exception&gt;\n \n@@ -357,14 +486,15 @@ int main()\n    <para>\n      The <function>__verbose_terminate_handler</function> function\n      obtains the name of the current exception, attempts to demangle\n-     it, and prints it to stderr.  If the exception is derived from\n-     <classname>exception</classname> then the output from\n+     it, and prints it to <literal>stderr</literal>.\n+     If the exception is derived from\n+     <classname>std::exception</classname> then the output from\n      <function>what()</function> will be included.\n    </para>\n \n    <para>\n      Any replacement termination function is required to kill the\n-     program without returning; this one calls abort.\n+     program without returning; this one calls <function>std::abort</function>.\n    </para>\n \n    <para>\n@@ -407,15 +537,16 @@ int main(int argc)\n    </screen>\n \n    <para>\n-     The 'Aborted' line comes from the call to\n-     <function>abort()</function>, of course.\n+     The 'Aborted' line is printed by the shell after the process exits\n+     by calling <function>abort()</function>.\n    </para>\n \n    <para>\n-     This is the default termination handler; nothing need be done to\n+     As this is the default termination handler, nothing need be done to\n      use it.  To go back to the previous <quote>silent death</quote>\n-     method, simply include <filename>exception</filename> and\n-     <filename>cstdlib</filename>, and call\n+     method, simply include\n+     <filename class=\"headerfile\">&lt;exception&gt;</filename> and\n+     <filename class=\"headerfile\">&lt;cstdlib&gt;</filename>, and call\n    </para>\n \n    <programlisting>\n@@ -429,8 +560,8 @@ int main(int argc)\n \n    <para>\n      Note: the verbose terminate handler will attempt to write to\n-     stderr.  If your application closes stderr or redirects it to an\n-     inappropriate location,\n+     <literal>stderr</literal>.  If your application closes\n+     <literal>stderr</literal> or redirects it to an inappropriate location,\n      <function>__verbose_terminate_handler</function> will behave in\n      an unspecified manner.\n    </para>"}]}