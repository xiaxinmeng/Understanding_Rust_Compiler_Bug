{"sha": "e38cd64ac6cb4da740d643589c857d2f910b6bba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4Y2Q2NGFjNmNiNGRhNzQwZDY0MzU4OWM4NTdkMmY5MTBiNmJiYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-09T12:59:59Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-09T13:09:50Z"}, "message": "c++: ADL refactor\n\nThis refactors the ADL lookup.  It just so happens the refactoring\nmakes dropping modules in simpler :) We break apart the namespace and\nclass fn processing, and move scope iteration to an outer function.\nIt'll also become possible to find the same enum in multiple place, so\nwe need to handle that idempotently.\n\n\tgcc/cp/\n\t* cp-tree.h (LOOKUP_FOUND_P): Add ENUMERAL_TYPE.\n\t* name-lookup.c (class name_lookup): Add comments.\n\t(name_lookup::adl_namespace_only): Replace with ...\n\t(name_lookup::adl_class_fns): ... this and ...\n\t(name_lookup::adl_namespace_fns): ... this.\n\t(name_lookup::adl_namespace): Deal with inline nests here.\n\t(name_lookup::adl_class): Complete the type here.\n\t(name_lookup::adl_type): Call broken-out enum ..\n\t(name_lookup::adl_enum): New.  No need to call the namespace adl\n\tif it is class-scope.\n\t(name_lookup::search_adl): Iterate over collected scopes here.", "tree": {"sha": "5c093d0bbd7c14c6a8b90eae000dc6ced7380833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c093d0bbd7c14c6a8b90eae000dc6ced7380833"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e38cd64ac6cb4da740d643589c857d2f910b6bba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38cd64ac6cb4da740d643589c857d2f910b6bba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e38cd64ac6cb4da740d643589c857d2f910b6bba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38cd64ac6cb4da740d643589c857d2f910b6bba/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4081596e852a3a1c2baaa5aa5bb539a8de1a78a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4081596e852a3a1c2baaa5aa5bb539a8de1a78a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4081596e852a3a1c2baaa5aa5bb539a8de1a78a3"}], "stats": {"total": 163, "additions": 109, "deletions": 54}, "files": [{"sha": "081373076b99ebbe777cd59c99181029b43c0058", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38cd64ac6cb4da740d643589c857d2f910b6bba/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38cd64ac6cb4da740d643589c857d2f910b6bba/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e38cd64ac6cb4da740d643589c857d2f910b6bba", "patch": "@@ -487,7 +487,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       DECL_TINFO_P (in VAR_DECL)\n       FUNCTION_REF_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n       OVL_LOOKUP_P (in OVERLOAD)\n-      LOOKUP_FOUND_P (in RECORD_TYPE, UNION_TYPE, NAMESPACE_DECL)\n+      LOOKUP_FOUND_P (in RECORD_TYPE, UNION_TYPE, ENUMERAL_TYPE, NAMESPACE_DECL)\n    5: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       FUNCTION_RVALUE_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n       CALL_EXPR_REVERSE_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n@@ -745,9 +745,10 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n     && flag_hosted)\n \n /* Lookup walker marking.  */\n-#define LOOKUP_SEEN_P(NODE) TREE_VISITED(NODE)\n+#define LOOKUP_SEEN_P(NODE) TREE_VISITED (NODE)\n #define LOOKUP_FOUND_P(NODE) \\\n-  TREE_LANG_FLAG_4 (TREE_CHECK3(NODE,RECORD_TYPE,UNION_TYPE,NAMESPACE_DECL))\n+  TREE_LANG_FLAG_4 (TREE_CHECK4 (NODE,RECORD_TYPE,UNION_TYPE,ENUMERAL_TYPE,\\\n+\t\t\t\t NAMESPACE_DECL))\n \n /* These two accessors should only be used by OVL manipulators.\n    Other users should use iterators and convenience functions.  */"}, {"sha": "410ec595c82794c4068f625b8518c08a6c8d660b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 105, "deletions": 51, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38cd64ac6cb4da740d643589c857d2f910b6bba/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38cd64ac6cb4da740d643589c857d2f910b6bba/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=e38cd64ac6cb4da740d643589c857d2f910b6bba", "patch": "@@ -171,8 +171,13 @@ class name_lookup\n \n public:\n   tree name;\t/* The identifier being looked for.  */\n+\n+  /* Usually we just add things to the VALUE binding, but we record\n+     (hidden) IMPLICIT_TYPEDEFs on the type binding, which is used for\n+     using-decl resolution.  */\n   tree value;\t/* A (possibly ambiguous) set of things found.  */\n   tree type;\t/* A type that has been found.  */\n+\n   LOOK_want want;  /* What kind of entity we want.  */\n \n   bool deduping; /* Full deduping is needed because using declarations\n@@ -263,14 +268,17 @@ class name_lookup\n private:\n   void add_fns (tree);\n \n+ private:\n   void adl_expr (tree);\n   void adl_type (tree);\n   void adl_template_arg (tree);\n   void adl_class (tree);\n+  void adl_enum (tree);\n   void adl_bases (tree);\n   void adl_class_only (tree);\n   void adl_namespace (tree);\n-  void adl_namespace_only (tree);\n+  void adl_class_fns (tree);\n+  void adl_namespace_fns (tree);\n \n public:\n   /* Search namespace + inlines + maybe usings as qualified lookup.  */\n@@ -433,8 +441,8 @@ name_lookup::add_overload (tree fns)\n       if (probe && TREE_CODE (probe) == OVERLOAD\n \t  && OVL_DEDUP_P (probe))\n \t{\n-\t  /* We're about to add something found by a using\n-\t     declaration, so need to engage deduping mode.  */\n+\t  /* We're about to add something found by multiple paths, so\n+\t     need to engage deduping mode.  */\n \t  lookup_mark (value, true);\n \t  deduping = true;\n \t}\n@@ -777,20 +785,56 @@ name_lookup::add_fns (tree fns)\n   add_overload (fns);\n }\n \n-/* Add functions of a namespace to the lookup structure.  */\n+/* Add the overloaded fns of SCOPE.  */\n \n void\n-name_lookup::adl_namespace_only (tree scope)\n+name_lookup::adl_namespace_fns (tree scope)\n {\n-  mark_seen (scope);\n+  if (tree *binding = find_namespace_slot (scope, name))\n+    {\n+      tree val = *binding;\n+      add_fns (ovl_skip_hidden (MAYBE_STAT_DECL (val)));\n+    }\n+}\n \n-  /* Look down into inline namespaces.  */\n-  if (vec<tree, va_gc> *inlinees = DECL_NAMESPACE_INLINEES (scope))\n-    for (unsigned ix = inlinees->length (); ix--;)\n-      adl_namespace_only ((*inlinees)[ix]);\n+/* Add the hidden friends of SCOPE.  */\n+\n+void\n+name_lookup::adl_class_fns (tree type)\n+{\n+  /* Add friends.  */\n+  for (tree list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type));\n+       list; list = TREE_CHAIN (list))\n+    if (name == FRIEND_NAME (list))\n+      {\n+\ttree context = NULL_TREE; /* Lazily computed.  */\n+\tfor (tree friends = FRIEND_DECLS (list); friends;\n+\t     friends = TREE_CHAIN (friends))\n+\t  {\n+\t    tree fn = TREE_VALUE (friends);\n \n-  if (tree fns = find_namespace_value (scope, name))\n-    add_fns (ovl_skip_hidden (fns));\n+\t    /* Only interested in global functions with potentially hidden\n+\t       (i.e. unqualified) declarations.  */\n+\t    if (!context)\n+\t      context = decl_namespace_context (type);\n+\t    if (CP_DECL_CONTEXT (fn) != context)\n+\t      continue;\n+\n+\t    if (!deduping)\n+\t      {\n+\t\tlookup_mark (value, true);\n+\t\tdeduping = true;\n+\t      }\n+\n+\t    /* Template specializations are never found by name lookup.\n+\t       (Templates themselves can be found, but not template\n+\t       specializations.)  */\n+\t    if (TREE_CODE (fn) == FUNCTION_DECL && DECL_USE_TEMPLATE (fn))\n+\t      continue;\n+\n+\t    add_fns (fn);\n+\t  }\n+      }\n }\n \n /* Find the containing non-inlined namespace, add it and all its\n@@ -799,14 +843,17 @@ name_lookup::adl_namespace_only (tree scope)\n void\n name_lookup::adl_namespace (tree scope)\n {\n-  if (seen_p (scope))\n+  if (see_and_mark (scope))\n     return;\n \n-  /* Find the containing non-inline namespace.  */\n-  while (DECL_NAMESPACE_INLINE_P (scope))\n-    scope = CP_DECL_CONTEXT (scope);\n+  /* Look down into inline namespaces.  */\n+  if (vec<tree, va_gc> *inlinees = DECL_NAMESPACE_INLINEES (scope))\n+    for (unsigned ix = inlinees->length (); ix--;)\n+      adl_namespace ((*inlinees)[ix]);\n \n-  adl_namespace_only (scope);\n+  if (DECL_NAMESPACE_INLINE_P (scope))\n+    /* Mark parent.  */\n+    adl_namespace (CP_DECL_CONTEXT (scope));\n }\n \n /* Adds the class and its friends to the lookup structure.  */\n@@ -826,31 +873,6 @@ name_lookup::adl_class_only (tree type)\n \n   tree context = decl_namespace_context (type);\n   adl_namespace (context);\n-\n-  complete_type (type);\n-\n-  /* Add friends.  */\n-  for (tree list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list;\n-       list = TREE_CHAIN (list))\n-    if (name == FRIEND_NAME (list))\n-      for (tree friends = FRIEND_DECLS (list); friends;\n-\t   friends = TREE_CHAIN (friends))\n-\t{\n-\t  tree fn = TREE_VALUE (friends);\n-\n-\t  /* Only interested in global functions with potentially hidden\n-\t     (i.e. unqualified) declarations.  */\n-\t  if (CP_DECL_CONTEXT (fn) != context)\n-\t    continue;\n-\n-\t  /* Template specializations are never found by name lookup.\n-\t     (Templates themselves can be found, but not template\n-\t     specializations.)  */\n-\t  if (TREE_CODE (fn) == FUNCTION_DECL && DECL_USE_TEMPLATE (fn))\n-\t    continue;\n-\n-\t  add_fns (fn);\n-\t}\n }\n \n /* Adds the class and its bases to the lookup structure.\n@@ -873,7 +895,7 @@ name_lookup::adl_bases (tree type)\n }\n \n /* Adds everything associated with a class argument type to the lookup\n-   structure.  Returns true on error.\n+   structure.\n \n    If T is a class type (including unions), its associated classes are: the\n    class itself; the class of which it is a member, if any; and its direct\n@@ -897,11 +919,13 @@ name_lookup::adl_class (tree type)\n     return;\n \n   type = TYPE_MAIN_VARIANT (type);\n+\n   /* We don't set found here because we have to have set seen first,\n      which is done in the adl_bases walk.  */\n   if (found_p (type))\n     return;\n \n+  complete_type (type);\n   adl_bases (type);\n   mark_found (type);\n \n@@ -918,6 +942,19 @@ name_lookup::adl_class (tree type)\n     }\n }\n \n+void\n+name_lookup::adl_enum (tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+  if (see_and_mark (type))\n+    return;\n+\n+  if (TYPE_CLASS_SCOPE_P (type))\n+    adl_class_only (TYPE_CONTEXT (type));\n+  else\n+    adl_namespace (decl_namespace_context (type));\n+}\n+\n void\n name_lookup::adl_expr (tree expr)\n {\n@@ -1003,9 +1040,7 @@ name_lookup::adl_type (tree type)\n       return;\n \n     case ENUMERAL_TYPE:\n-      if (TYPE_CLASS_SCOPE_P (type))\n-\tadl_class_only (TYPE_CONTEXT (type));\n-      adl_namespace (decl_namespace_context (type));\n+      adl_enum (type);\n       return;\n \n     case LANG_TYPE:\n@@ -1074,10 +1109,9 @@ name_lookup::adl_template_arg (tree arg)\n tree\n name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n {\n-  deduping = true;\n-  lookup_mark (fns, true);\n-  value = fns;\n-\n+  gcc_checking_assert (!vec_safe_length (scopes));\n+  \n+  /* Gather each associated entity onto the lookup's scope list.  */\n   unsigned ix;\n   tree arg;\n \n@@ -1089,7 +1123,27 @@ name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n     else\n       adl_expr (arg);\n \n-  fns = value;\n+  if (vec_safe_length (scopes))\n+    {\n+      /* Now do the lookups.  */\n+      if (fns)\n+\t{\n+\t  deduping = true;\n+\t  lookup_mark (fns, true);\n+\t}\n+      value = fns;\n+\n+      for (unsigned ix = scopes->length (); ix--;)\n+\t{\n+\t  tree scope = (*scopes)[ix];\n+\t  if (TREE_CODE (scope) == NAMESPACE_DECL)\n+\t    adl_namespace_fns (scope);\n+\t  else if (RECORD_OR_UNION_TYPE_P (scope))\n+\t    adl_class_fns (scope);\n+\t}\n+\n+      fns = value;\n+    }\n \n   return fns;\n }"}]}