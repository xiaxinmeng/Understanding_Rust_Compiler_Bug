{"sha": "2bd15617e73acf76207127e5580cd10b1fab91a5", "node_id": "C_kwDOANBUbNoAKDJiZDE1NjE3ZTczYWNmNzYyMDcxMjdlNTU4MGNkMTBiMWZhYjkxYTU", "commit": {"author": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-07-07T17:59:27Z"}, "committer": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-07-08T13:43:33Z"}, "message": "diagnostics: Make line-ending logic consistent with libcpp [PR91733]\n\nlibcpp recognizes a lone \\r as a valid line ending, so the infrastructure\nfor retrieving source lines to be output in diagnostics needs to do the\nsame. This patch fixes file_cache_slot::get_next_line() accordingly so that\ndiagnostics display the correct part of the source when \\r line endings are in\nuse.\n\ngcc/ChangeLog:\n\n\tPR preprocessor/91733\n\t* input.cc (find_end_of_line): New helper function.\n\t(file_cache_slot::get_next_line): Recognize \\r as a line ending.\n\t* diagnostic-show-locus.cc (test_escaping_bytes_1): Adapt selftest\n\tsince \\r will now be interpreted as a line-ending.\n\ngcc/testsuite/ChangeLog:\n\n\tPR preprocessor/91733\n\t* c-c++-common/pr91733.c: New test.", "tree": {"sha": "35be9178e2ae2b13bc5a7c6bf4ff695c2f2f565e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35be9178e2ae2b13bc5a7c6bf4ff695c2f2f565e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bd15617e73acf76207127e5580cd10b1fab91a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd15617e73acf76207127e5580cd10b1fab91a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bd15617e73acf76207127e5580cd10b1fab91a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd15617e73acf76207127e5580cd10b1fab91a5/comments", "author": null, "committer": null, "parents": [{"sha": "6da7f7c5ac03f85a753989712588511e5f56e73d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da7f7c5ac03f85a753989712588511e5f56e73d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6da7f7c5ac03f85a753989712588511e5f56e73d"}], "stats": {"total": 98, "additions": 76, "deletions": 22}, "files": [{"sha": "08dab20e6cdb2df6094dffc7eea1479c1e82d16b", "filename": "gcc/diagnostic-show-locus.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd15617e73acf76207127e5580cd10b1fab91a5/gcc%2Fdiagnostic-show-locus.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd15617e73acf76207127e5580cd10b1fab91a5/gcc%2Fdiagnostic-show-locus.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.cc?ref=2bd15617e73acf76207127e5580cd10b1fab91a5", "patch": "@@ -5533,7 +5533,7 @@ test_tab_expansion (const line_table_case &case_)\n static void\n test_escaping_bytes_1 (const line_table_case &case_)\n {\n-  const char content[] = \"before\\0\\1\\2\\3\\r\\x80\\xff\"\"after\\n\";\n+  const char content[] = \"before\\0\\1\\2\\3\\v\\x80\\xff\"\"after\\n\";\n   const size_t sz = sizeof (content);\n   temp_source_file tmp (SELFTEST_LOCATION, \".c\", content, sz);\n   line_table_test ltt (case_);\n@@ -5548,18 +5548,18 @@ test_escaping_bytes_1 (const line_table_case &case_)\n   if (finish > LINE_MAP_MAX_LOCATION_WITH_COLS)\n     return;\n \n-  /* Locations of the NUL and \\r bytes.  */\n+  /* Locations of the NUL and \\v bytes.  */\n   location_t nul_loc\n     = linemap_position_for_line_and_column (line_table, ord_map, 1, 7);\n-  location_t r_loc\n+  location_t v_loc\n     = linemap_position_for_line_and_column (line_table, ord_map, 1, 11);\n   gcc_rich_location richloc (nul_loc);\n-  richloc.add_range (r_loc);\n+  richloc.add_range (v_loc);\n \n   {\n     test_diagnostic_context dc;\n     diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n-    ASSERT_STREQ (\" before \\1\\2\\3 \\x80\\xff\"\"after\\n\"\n+    ASSERT_STREQ (\" before \\1\\2\\3\\v\\x80\\xff\"\"after\\n\"\n \t\t  \"       ^   ~\\n\",\n \t\t  pp_formatted_text (dc.printer));\n   }\n@@ -5569,15 +5569,15 @@ test_escaping_bytes_1 (const line_table_case &case_)\n     dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_UNICODE;\n     diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n     ASSERT_STREQ\n-      (\" before<U+0000><U+0001><U+0002><U+0003><U+000D><80><ff>after\\n\"\n+      (\" before<U+0000><U+0001><U+0002><U+0003><U+000B><80><ff>after\\n\"\n        \"       ^~~~~~~~                        ~~~~~~~~\\n\",\n        pp_formatted_text (dc.printer));\n   }\n   {\n     test_diagnostic_context dc;\n     dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_BYTES;\n     diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n-    ASSERT_STREQ (\" before<00><01><02><03><0d><80><ff>after\\n\"\n+    ASSERT_STREQ (\" before<00><01><02><03><0b><80><ff>after\\n\"\n \t\t  \"       ^~~~            ~~~~\\n\",\n \t\t  pp_formatted_text (dc.printer));\n   }"}, {"sha": "060ca16012686035c2f117c97613a56bf1afebc3", "filename": "gcc/input.cc", "status": "modified", "additions": 52, "deletions": 15, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd15617e73acf76207127e5580cd10b1fab91a5/gcc%2Finput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd15617e73acf76207127e5580cd10b1fab91a5/gcc%2Finput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.cc?ref=2bd15617e73acf76207127e5580cd10b1fab91a5", "patch": "@@ -646,6 +646,37 @@ file_cache_slot::maybe_read_data ()\n   return read_data ();\n }\n \n+/* Helper function for file_cache_slot::get_next_line (), to find the end of\n+   the next line.  Returns with the memchr convention, i.e. nullptr if a line\n+   terminator was not found.  We need to determine line endings in the same\n+   manner that libcpp does: any of \\n, \\r\\n, or \\r is a line ending.  */\n+\n+static char *\n+find_end_of_line (char *s, size_t len)\n+{\n+  for (const auto end = s + len; s != end; ++s)\n+    {\n+      if (*s == '\\n')\n+\treturn s;\n+      if (*s == '\\r')\n+\t{\n+\t  const auto next = s + 1;\n+\t  if (next == end)\n+\t    {\n+\t      /* Don't find the line ending if \\r is the very last character\n+\t\t in the buffer; we do not know if it's the end of the file or\n+\t\t just the end of what has been read so far, and we wouldn't\n+\t\t want to break in the middle of what's actually a \\r\\n\n+\t\t sequence.  Instead, we will handle the case of a file ending\n+\t\t in a \\r later.  */\n+\t      break;\n+\t    }\n+\t  return (*next == '\\n' ? next : s);\n+\t}\n+    }\n+  return nullptr;\n+}\n+\n /* Read a new line from file FP, using C as a cache for the data\n    coming from the file.  Upon successful completion, *LINE is set to\n    the beginning of the line found.  *LINE points directly in the\n@@ -671,17 +702,16 @@ file_cache_slot::get_next_line (char **line, ssize_t *line_len)\n \n   char *next_line_start = NULL;\n   size_t len = 0;\n-  char *line_end = (char *) memchr (line_start, '\\n', remaining_size);\n+  char *line_end = find_end_of_line (line_start, remaining_size);\n   if (line_end == NULL)\n     {\n-      /* We haven't found the end-of-line delimiter in the cache.\n-\t Fill the cache with more data from the file and look for the\n-\t '\\n'.  */\n+      /* We haven't found an end-of-line delimiter in the cache.\n+\t Fill the cache with more data from the file and look again.  */\n       while (maybe_read_data ())\n \t{\n \t  line_start = m_data + m_line_start_idx;\n \t  remaining_size = m_nb_read - m_line_start_idx;\n-\t  line_end = (char *) memchr (line_start, '\\n', remaining_size);\n+\t  line_end = find_end_of_line (line_start, remaining_size);\n \t  if (line_end != NULL)\n \t    {\n \t      next_line_start = line_end + 1;\n@@ -690,14 +720,22 @@ file_cache_slot::get_next_line (char **line, ssize_t *line_len)\n \t}\n       if (line_end == NULL)\n \t{\n-\t  /* We've loadded all the file into the cache and still no\n-\t     '\\n'.  Let's say the line ends up at one byte passed the\n+\t  /* We've loaded all the file into the cache and still no\n+\t     terminator.  Let's say the line ends up at one byte past the\n \t     end of the file.  This is to stay consistent with the case\n-\t     of when the line ends up with a '\\n' and line_end points to\n-\t     that terminal '\\n'.  That consistency is useful below in\n-\t     the len calculation.  */\n-\t  line_end = m_data + m_nb_read ;\n-\t  m_missing_trailing_newline = true;\n+\t     of when the line ends up with a terminator and line_end points to\n+\t     that.  That consistency is useful below in the len calculation.\n+\n+\t     If the file ends in a \\r, we didn't identify it as a line\n+\t     terminator above, so do that now instead.  */\n+\t  line_end = m_data + m_nb_read;\n+\t  if (m_nb_read && line_end[-1] == '\\r')\n+\t    {\n+\t      --line_end;\n+\t      m_missing_trailing_newline = false;\n+\t    }\n+\t  else\n+\t    m_missing_trailing_newline = true;\n \t}\n       else\n \tm_missing_trailing_newline = false;\n@@ -711,9 +749,8 @@ file_cache_slot::get_next_line (char **line, ssize_t *line_len)\n   if (m_fp && ferror (m_fp))\n     return false;\n \n-  /* At this point, we've found the end of the of line.  It either\n-     points to the '\\n' or to one byte after the last byte of the\n-     file.  */\n+  /* At this point, we've found the end of the of line.  It either points to\n+     the line terminator or to one byte after the last byte of the file.  */\n   gcc_assert (line_end != NULL);\n \n   len = line_end - line_start;"}, {"sha": "1539bb4f386d5fcbe621b852e3cd3b11913422e4", "filename": "gcc/testsuite/c-c++-common/pr91733.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd15617e73acf76207127e5580cd10b1fab91a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr91733.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd15617e73acf76207127e5580cd10b1fab91a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr91733.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr91733.c?ref=2bd15617e73acf76207127e5580cd10b1fab91a5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do preprocess } */\n+/* { dg-additional-options \"-fdiagnostics-show-caret\" } */\n+\n+const char *s = \"\r\";\n+\n+/* { dg-warning \"missing terminating \\\"\" \"test1\" { target *-*-* } 4 } */\n+/* { dg-warning \"missing terminating \\\"\" \"test2\" { target *-*-* } 5 } */\n+\n+/* { dg-begin-multiline-output \"test3\" }\n+ const char *s = \"\n+                 ^\n+{ dg-end-multiline-output \"test3\" } */\n+\n+/* { dg-begin-multiline-output \"test4\" }\n+ \";\n+ ^\n+{ dg-end-multiline-output \"test4\" } */"}]}