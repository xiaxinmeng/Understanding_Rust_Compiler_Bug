{"sha": "8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI0NDA1N2Q5Yjc0MTcyOTNjMmU5ZmM4MWJiMGYzNTVjYWJlODNiNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2005-11-20T18:49:18Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-11-20T18:49:18Z"}, "message": "expr.c (expand_expr_real): Use usmul_optab for widening signed * unsigned multiplies.\n\n\t* expr.c (expand_expr_real): Use usmul_optab for widening\n\tsigned * unsigned multiplies.\n\t* genopinit.c (optabs): Add usmul_widen_optab.\n\t* optabs.c (init_optabs): Likewise.\n\t* optabs.h (enum optab_index): Add OTI_usmul_widen.\n\t(usmul_widen_optab): Define.\n\t* config/bfin/bfin.md (usmulhisi3): New pattern.\n\n\t* doc/md.texi (usmulqihi3, usmulhisi3, usmulsidi3): Document.\n\nFrom-SVN: r107258", "tree": {"sha": "ced326957170072ff9481ff36ed4bba3a5eb7c8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ced326957170072ff9481ff36ed4bba3a5eb7c8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/comments", "author": null, "committer": null, "parents": [{"sha": "23ffc23579daf0e63042a4952ff47317125279dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23ffc23579daf0e63042a4952ff47317125279dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23ffc23579daf0e63042a4952ff47317125279dd"}], "stats": {"total": 73, "additions": 71, "deletions": 2}, "files": [{"sha": "b3ab01ee76669890fdb1ef52bb12ffd1ef04a07d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "patch": "@@ -1,3 +1,15 @@\n+2005-11-20  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* expr.c (expand_expr_real): Use usmul_optab for widening\n+\tsigned * unsigned multiplies.\n+\t* genopinit.c (optabs): Add usmul_widen_optab.\n+\t* optabs.c (init_optabs): Likewise.\n+\t* optabs.h (enum optab_index): Add OTI_usmul_widen.\n+\t(usmul_widen_optab): Define.\n+\t* config/bfin/bfin.md (usmulhisi3): New pattern.\n+\n+\t* doc/md.texi (usmulqihi3, usmulhisi3, usmulsidi3): Document.\n+\n 2005-11-20  Graham Stott <btinternet.com>\n \n \t* gensupport.c (std_preds): Fixed extraneous `false` in last change."}, {"sha": "63fc99ca1fe7b31055897d4ebbbc5d948738376e", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "patch": "@@ -908,6 +908,14 @@\n   \"%0 = %h1 * %h2 (FU);\"\n   [(set_attr \"type\" \"dsp32\")])\n \n+(define_insn \"usmulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=W\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"W\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"W\"))))]\n+  \"\"\n+  \"%0 = %h2 * %h1 (IS,M);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n ;; The processor also supports ireg += mreg or ireg -= mreg, but these\n ;; are unusable if we don't ensure that the corresponding lreg is zero.\n ;; The same applies to the add/subtract constant versions involving"}, {"sha": "115de4a2aba4e21a8383baac281ab9b8e9438403", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "patch": "@@ -3125,6 +3125,14 @@ Similar widening-multiplication instructions of other widths.\n Similar widening-multiplication instructions that do unsigned\n multiplication.\n \n+@cindex @code{usmulqihi3} instruction pattern\n+@cindex @code{usmulhisi3} instruction pattern\n+@cindex @code{usmulsidi3} instruction pattern\n+@item @samp{usmulqihi3}, @samp{usmulhisi3}, @samp{usmulsidi3}\n+Similar widening-multiplication instructions that interpret the first\n+operand as unsigned and the second operand as signed, then do a signed\n+multiplication.\n+\n @cindex @code{smul@var{m}3_highpart} instruction pattern\n @item @samp{smul@var{m}3_highpart}\n Perform a signed multiplication of operands 1 and 2, which have mode"}, {"sha": "60582c91db6c13c8cb0688cadc672612f74654e8", "filename": "gcc/expr.c", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "patch": "@@ -6543,7 +6543,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   optab this_optab;\n   rtx subtarget, original_target;\n   int ignore;\n-  tree context;\n+  tree context, subexp0, subexp1;\n   bool reduce_bit_field = false;\n #define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field && !ignore\t\t  \\\n \t\t\t\t ? reduce_to_bit_field_precision ((expr), \\\n@@ -7824,7 +7824,43 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t from a narrower type.  If this machine supports multiplying\n \t in that narrower type with a result in the desired type,\n \t do it that way, and avoid the explicit type-conversion.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == NOP_EXPR\n+\n+      subexp0 = TREE_OPERAND (exp, 0);\n+      subexp1 = TREE_OPERAND (exp, 1);\n+      /* First, check if we have a multiplication of one signed and one\n+\t unsigned operand.  */\n+      if (TREE_CODE (subexp0) == NOP_EXPR\n+\t  && TREE_CODE (subexp1) == NOP_EXPR\n+\t  && TREE_CODE (type) == INTEGER_TYPE\n+\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subexp0, 0)))\n+\t      < TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subexp0, 0)))\n+\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subexp1, 0))))\n+\t  && (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subexp0, 0)))\n+\t      != TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subexp1, 0)))))\n+\t{\n+\t  enum machine_mode innermode\n+\t    = TYPE_MODE (TREE_TYPE (TREE_OPERAND (subexp0, 0)));\n+\t  this_optab = usmul_widen_optab;\n+\t  if (mode == GET_MODE_WIDER_MODE (innermode))\n+\t    {\n+\t      if (this_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t\t{\n+\t\t  if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subexp0, 0))))\n+\t\t    expand_operands (TREE_OPERAND (subexp0, 0),\n+\t\t\t\t     TREE_OPERAND (subexp1, 0),\n+\t\t\t\t     NULL_RTX, &op0, &op1, 0);\n+\t\t  else\n+\t\t    expand_operands (TREE_OPERAND (subexp0, 0),\n+\t\t\t\t     TREE_OPERAND (subexp1, 0),\n+\t\t\t\t     NULL_RTX, &op1, &op0, 0);\n+\n+\t\t  goto binop2;\n+\t\t}\n+\t    }\n+\t}\n+      /* Check for a multiplication with matching signedness.  */\n+      else if (TREE_CODE (TREE_OPERAND (exp, 0)) == NOP_EXPR\n \t  && TREE_CODE (type) == INTEGER_TYPE\n \t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n \t      < TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (exp, 0))))"}, {"sha": "c48d07979bd28b98a19f36b0853fa65217eafc39", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "patch": "@@ -84,6 +84,7 @@ static const char * const optabs[] =\n   \"smul_highpart_optab->handlers[$A].insn_code = CODE_FOR_$(smul$a3_highpart$)\",\n   \"smul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(mul$a$b3$)$N\",\n   \"umul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(umul$a$b3$)$N\",\n+  \"usmul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(usmul$a$b3$)$N\",\n   \"sdiv_optab->handlers[$A].insn_code = CODE_FOR_$(div$a3$)\",\n   \"sdivv_optab->handlers[$A].insn_code = CODE_FOR_$(div$V$I$a3$)\",\n   \"udiv_optab->handlers[$A].insn_code = CODE_FOR_$(udiv$I$a3$)\","}, {"sha": "b10dfa4b1319cbfedaf0c79b5083643bb1a71b1f", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "patch": "@@ -5010,6 +5010,7 @@ init_optabs (void)\n   umul_highpart_optab = init_optab (UNKNOWN);\n   smul_widen_optab = init_optab (UNKNOWN);\n   umul_widen_optab = init_optab (UNKNOWN);\n+  usmul_widen_optab = init_optab (UNKNOWN);\n   sdiv_optab = init_optab (DIV);\n   sdivv_optab = init_optabv (DIV);\n   sdivmod_optab = init_optab (UNKNOWN);"}, {"sha": "78cf53b15ff117cc150d6fdf8e6190597ef99927", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b44057d9b7417293c2e9fc81bb0f355cabe83b6/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=8b44057d9b7417293c2e9fc81bb0f355cabe83b6", "patch": "@@ -82,6 +82,8 @@ enum optab_index\n   /* Signed multiply with result one machine mode wider than args */\n   OTI_smul_widen,\n   OTI_umul_widen,\n+  /* Widening multiply of one unsigned and one signed operand.  */\n+  OTI_usmul_widen,\n \n   /* Signed divide */\n   OTI_sdiv,\n@@ -268,6 +270,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define umul_highpart_optab (optab_table[OTI_umul_highpart])\n #define smul_widen_optab (optab_table[OTI_smul_widen])\n #define umul_widen_optab (optab_table[OTI_umul_widen])\n+#define usmul_widen_optab (optab_table[OTI_usmul_widen])\n #define sdiv_optab (optab_table[OTI_sdiv])\n #define smulv_optab (optab_table[OTI_smulv])\n #define sdivv_optab (optab_table[OTI_sdivv])"}]}