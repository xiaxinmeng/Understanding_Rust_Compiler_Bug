{"sha": "a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUxM2ZlODg2YjFkYmEzZDJjOWVkMzlmZDYzM2MzNWRlNDVkZGQ0Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-06-13T23:24:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-06-13T23:24:47Z"}, "message": "tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): No longer simplify DIV, MOD or ABS expressions using VRP information.\n\n        * tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): No longer\n        simplify DIV, MOD or ABS expressions using VRP information.\n        Remove WALK_DATA parameter.  Prototype and all callers updated.\n        (eliminate_redundant_computations): Remove WALK_DATA parameter.\n        Prototype and all callers updated.\n        (optimize_stmt): WALK_DATA parameter is now unused.\n\n        * tree-vrp.c (local_fold): New function.  Like fold, but\n        strips useless type conversions in the result.\n        (simplify_using_ranges): New function, largely cribbed from\n        tree-ssa-dom.c::simplify_rhs_and_lookup_avail_expr.\n        (vrp_finalize): Call simplify_using_ranges.\n\n        * gcc.dg/tree-ssa/20030807-10.c: VRP is now expected to\n        perform the desired transformations.\n        * gcc.dg/tree-ssa/20030806-6.c: Similarly.\n        * gcc.dg/tree-ssa/20040514-2.c: Similarly.\n\nFrom-SVN: r100909", "tree": {"sha": "8a76829140490cc690c7da63ffdce7aaa8e1f9a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a76829140490cc690c7da63ffdce7aaa8e1f9a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/comments", "author": null, "committer": null, "parents": [{"sha": "2b5554f3c0d84b54c5863e8054bd68fd367cdc4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5554f3c0d84b54c5863e8054bd68fd367cdc4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b5554f3c0d84b54c5863e8054bd68fd367cdc4a"}], "stats": {"total": 331, "additions": 183, "deletions": 148}, "files": [{"sha": "ee9433529e120330477ff8701991fa22a0ae0bdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "patch": "@@ -1,3 +1,18 @@\n+2005-06-13  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): No longer\n+\tsimplify DIV, MOD or ABS expressions using VRP information.\n+\tRemove WALK_DATA parameter.  Prototype and all callers updated.\n+\t(eliminate_redundant_computations): Remove WALK_DATA parameter.\n+\tPrototype and all callers updated.\n+\t(optimize_stmt): WALK_DATA parameter is now unused.\n+\n+\t* tree-vrp.c (local_fold): New function.  Like fold, but\n+\tstrips useless type conversions in the result.\n+\t(simplify_using_ranges): New function, largely cribbed from\n+\ttree-ssa-dom.c::simplify_rhs_and_lookup_avail_expr.\n+\t(vrp_finalize): Call simplify_using_ranges.\n+\n 2005-06-13  Mark Mitchell  <mark@codesourcery.com>\n \n \t* config/i386/x86-64.h (ASM_SPEC): Explicitly pass --64 to the"}, {"sha": "1b5d552341b8cb7d91aa1f5734cbf10db17886e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "patch": "@@ -1,3 +1,10 @@\n+2005-06-13  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20030807-10.c: VRP is now expected to\n+\tperform the desired transformations.\n+\t* gcc.dg/tree-ssa/20030806-6.c: Similarly.\n+\t* gcc.dg/tree-ssa/20040514-2.c: Similarly.\n+\n 2005-06-13  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/22038"}, {"sha": "a7c98bf886a23a05e49b3fc173aa57445d025377", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030807-10.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-10.c?ref=a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-dom3\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n      \n \n extern const unsigned char mode_size[];\n@@ -18,9 +18,9 @@ subreg_highpart_offset (outermode, innermode)\n }\n \n /* There should be one mask with the value 3.  */\n-/* { dg-final { scan-tree-dump-times \" \\& 3\" 1 \"dom3\"} } */\n+/* { dg-final { scan-tree-dump-times \" \\& 3\" 1 \"vrp\"} } */\n   \n /* There should be one right shift by 2 places.  */\n-/* { dg-final { scan-tree-dump-times \" >> 2\" 1 \"dom3\"} } */\n+/* { dg-final { scan-tree-dump-times \" >> 2\" 1 \"vrp\"} } */\n \n-/* { dg-final { cleanup-tree-dump \"dom3\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "12a623adcb651cbb5e74ed7dd83b34672fe96e1f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030807-6.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-6.c?ref=a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "patch": "@@ -1,8 +1,8 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-dom3\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n      \n \n-static void\n+void\n foo (distance, i, j)\n      int distance[13][13];\n      int i, j;\n@@ -11,7 +11,7 @@ foo (distance, i, j)\n    distance[i][0] = ((distance[i][j]) < 0 ? -(distance[i][j])  : (distance[i][j]));\n }\n \n-static void\n+void\n foo2 (distance, i, j)\n      int distance[13][13];\n      int i, j;\n@@ -20,7 +20,7 @@ foo2 (distance, i, j)\n    distance[i][0] = ((distance[i][j]) < 0 ? -(distance[i][j])  : (distance[i][j]));\n }\n \n-static void\n+void\n foo3 (distance, i, j)\n      int distance[13][13];\n      int i, j;\n@@ -29,7 +29,7 @@ foo3 (distance, i, j)\n    distance[i][0] = ((distance[i][j]) < 0 ? -(distance[i][j])  : (distance[i][j]));\n }\n \n-static void\n+void\n foo4 (distance, i, j)\n      double distance[13][13];\n      int i, j;\n@@ -39,5 +39,5 @@ foo4 (distance, i, j)\n }\n \n /* There should be no ABS_EXPR.  */\n-/* { dg-final { scan-tree-dump-times \"ABS_EXPR \" 0 \"dom3\"} } */\n-/* { dg-final { cleanup-tree-dump \"dom3\" } } */\n+/* { dg-final { scan-tree-dump-times \"ABS_EXPR \" 0 \"vrp\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "11f766716040bbb0a44137e553a84f714d32370a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040514-2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-2.c?ref=a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-dom3\" } */\n+/* { dg-options \"-O2 -fdump-tree-phiopt1\" } */\n int\n foo2 (distance, i, j)\n      int distance;\n@@ -12,7 +12,6 @@ foo2 (distance, i, j)\n }\n \n /* There should be one ABS_EXPR and no conditionals.  */\n-/* { dg-final { scan-tree-dump-times \"ABS_EXPR \" 1 \"dom3\"} } */\n-/* { dg-final { scan-tree-dump-times \"if \" 0 \"dom3\"} } */\n+/* { dg-final { scan-tree-dump-times \"ABS_EXPR \" 1 \"phiopt1\"} } */\n+/* { dg-final { scan-tree-dump-times \"if \" 0 \"phiopt1\"} } */\n \n-/* { dg-final { cleanup-tree-dump \"dom3\" } } */"}, {"sha": "03365619ed9932833b60982c5c85eff85d42b570", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 8, "deletions": 133, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "patch": "@@ -272,17 +272,15 @@ static void record_cond (tree, tree);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n static tree update_rhs_and_lookup_avail_expr (tree, tree, bool);\n-static tree simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *,\n-\t\t\t\t\t\ttree, int);\n+static tree simplify_rhs_and_lookup_avail_expr (tree, int);\n static tree simplify_cond_and_lookup_avail_expr (tree, stmt_ann_t, int);\n static tree simplify_switch_and_lookup_avail_expr (tree, int);\n static tree find_equivalent_equality_comparison (tree);\n static void record_range (tree, basic_block);\n static bool extract_range_from_cond (tree, tree *, tree *, int *);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block);\n-static bool eliminate_redundant_computations (struct dom_walk_data *,\n-\t\t\t\t\t      tree, stmt_ann_t);\n+static bool eliminate_redundant_computations (tree, stmt_ann_t);\n static void record_equivalences_from_stmt (tree, int, stmt_ann_t);\n static void thread_across_edge (struct dom_walk_data *, edge);\n static void dom_opt_finalize_block (struct dom_walk_data *, basic_block);\n@@ -1715,8 +1713,7 @@ simple_iv_increment_p (tree stmt)\n    the hash table and return the result.  Otherwise return NULL.  */\n \n static tree\n-simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n-\t\t\t\t    tree stmt, int insert)\n+simplify_rhs_and_lookup_avail_expr (tree stmt, int insert)\n {\n   tree rhs = TREE_OPERAND (stmt, 1);\n   enum tree_code rhs_code = TREE_CODE (rhs);\n@@ -1840,127 +1837,6 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n  dont_fold_assoc:;\n     }\n \n-  /* Transform TRUNC_DIV_EXPR and TRUNC_MOD_EXPR into RSHIFT_EXPR\n-     and BIT_AND_EXPR respectively if the first operand is greater\n-     than zero and the second operand is an exact power of two.  */\n-  if ((rhs_code == TRUNC_DIV_EXPR || rhs_code == TRUNC_MOD_EXPR)\n-      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0)))\n-      && integer_pow2p (TREE_OPERAND (rhs, 1)))\n-    {\n-      tree val;\n-      tree op = TREE_OPERAND (rhs, 0);\n-\n-      if (TYPE_UNSIGNED (TREE_TYPE (op)))\n-\t{\n-\t  val = integer_one_node;\n-\t}\n-      else\n-\t{\n-\t  tree dummy_cond = walk_data->global_data;\n-\n-\t  if (! dummy_cond)\n-\t    {\n-\t      dummy_cond = build (GT_EXPR, boolean_type_node,\n-\t\t\t\t  op, integer_zero_node);\n-\t      dummy_cond = build (COND_EXPR, void_type_node,\n-\t\t\t\t  dummy_cond, NULL, NULL);\n-\t      walk_data->global_data = dummy_cond;\n-\t    }\n-          else\n-\t    {\n-\t      TREE_SET_CODE (COND_EXPR_COND (dummy_cond), GT_EXPR);\n-\t      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 0) = op;\n-\t      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 1)\n-\t\t= integer_zero_node;\n-\t    }\n-\t  val = simplify_cond_and_lookup_avail_expr (dummy_cond, NULL, false);\n-\t}\n-\n-      if (val && integer_onep (val))\n-\t{\n-\t  tree t;\n-\t  tree op0 = TREE_OPERAND (rhs, 0);\n-\t  tree op1 = TREE_OPERAND (rhs, 1);\n-\n-\t  if (rhs_code == TRUNC_DIV_EXPR)\n-\t    t = build (RSHIFT_EXPR, TREE_TYPE (op0), op0,\n-\t\t       build_int_cst (NULL_TREE, tree_log2 (op1)));\n-\t  else\n-\t    t = build (BIT_AND_EXPR, TREE_TYPE (op0), op0,\n-\t\t       local_fold (build (MINUS_EXPR, TREE_TYPE (op1),\n-\t\t\t\t\t  op1, integer_one_node)));\n-\n-\t  result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n-\t}\n-    }\n-\n-  /* Transform ABS (X) into X or -X as appropriate.  */\n-  if (rhs_code == ABS_EXPR\n-      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0))))\n-    {\n-      tree val;\n-      tree op = TREE_OPERAND (rhs, 0);\n-      tree type = TREE_TYPE (op);\n-\n-      if (TYPE_UNSIGNED (type))\n-\t{\n-\t  val = integer_zero_node;\n-\t}\n-      else\n-\t{\n-\t  tree dummy_cond = walk_data->global_data;\n-\n-\t  if (! dummy_cond)\n-\t    {\n-\t      dummy_cond = build (LE_EXPR, boolean_type_node,\n-\t\t\t\t  op, integer_zero_node);\n-\t      dummy_cond = build (COND_EXPR, void_type_node,\n-\t\t\t\t  dummy_cond, NULL, NULL);\n-\t      walk_data->global_data = dummy_cond;\n-\t    }\n-\t  else\n-\t    {\n-\t      TREE_SET_CODE (COND_EXPR_COND (dummy_cond), LE_EXPR);\n-\t      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 0) = op;\n-\t      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 1)\n-\t\t= build_int_cst (type, 0);\n-\t    }\n-\t  val = simplify_cond_and_lookup_avail_expr (dummy_cond, NULL, false);\n-\n-\t  if (!val)\n-\t    {\n-\t      TREE_SET_CODE (COND_EXPR_COND (dummy_cond), GE_EXPR);\n-\t      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 0) = op;\n-\t      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 1)\n-\t\t= build_int_cst (type, 0);\n-\n-\t      val = simplify_cond_and_lookup_avail_expr (dummy_cond,\n-\t\t\t\t\t\t\t NULL, false);\n-\n-\t      if (val)\n-\t\t{\n-\t\t  if (integer_zerop (val))\n-\t\t    val = integer_one_node;\n-\t\t  else if (integer_onep (val))\n-\t\t    val = integer_zero_node;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (val\n-\t  && (integer_onep (val) || integer_zerop (val)))\n-\t{\n-\t  tree t;\n-\n-\t  if (integer_onep (val))\n-\t    t = build1 (NEGATE_EXPR, TREE_TYPE (op), op);\n-\t  else\n-\t    t = op;\n-\n-\t  result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n-\t}\n-    }\n-\n   /* Optimize *\"foo\" into 'f'.  This is done here rather than\n      in fold to avoid problems with stuff like &*\"foo\".  */\n   if (TREE_CODE (rhs) == INDIRECT_REF || TREE_CODE (rhs) == ARRAY_REF)\n@@ -2602,8 +2478,7 @@ propagate_to_outgoing_edges (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n    table.  */\n \n static bool\n-eliminate_redundant_computations (struct dom_walk_data *walk_data,\n-\t\t\t\t  tree stmt, stmt_ann_t ann)\n+eliminate_redundant_computations (tree stmt, stmt_ann_t ann)\n {\n   tree *expr_p, def = NULL_TREE;\n   bool insert = true;\n@@ -2632,7 +2507,7 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n      then try to simplify the RHS and lookup the new RHS in the\n      hash table.  */\n   if (! cached_lhs && TREE_CODE (stmt) == MODIFY_EXPR)\n-    cached_lhs = simplify_rhs_and_lookup_avail_expr (walk_data, stmt, insert);\n+    cached_lhs = simplify_rhs_and_lookup_avail_expr (stmt, insert);\n   /* Similarly if this is a COND_EXPR and we did not find its\n      expression in the hash table, simplify the condition and\n      try again.  */\n@@ -2955,8 +2830,8 @@ cprop_into_stmt (tree stmt)\n       the variable in the LHS in the CONST_AND_COPIES table.  */\n \n static void\n-optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n-\t       block_stmt_iterator si)\n+optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t       basic_block bb, block_stmt_iterator si)\n {\n   stmt_ann_t ann;\n   tree stmt, old_stmt;\n@@ -3026,7 +2901,7 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n \n   if (may_optimize_p)\n     may_have_exposed_new_symbols\n-      |= eliminate_redundant_computations (walk_data, stmt, ann);\n+      |= eliminate_redundant_computations (stmt, ann);\n \n   /* Record any additional equivalences created by this statement.  */\n   if (TREE_CODE (stmt) == MODIFY_EXPR)"}, {"sha": "89dae4b850de6d05caecec8cd4c90a0a31aa5862", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513fe886b1dba3d2c9ed39fd633c35de45ddd4b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=a513fe886b1dba3d2c9ed39fd633c35de45ddd4b", "patch": "@@ -94,6 +94,21 @@ static sbitmap blocks_visited;\n    of values that SSA name N_I may take.  */\n static value_range_t **vr_value;\n \n+/* Local version of fold that doesn't introduce cruft.  */\n+\n+static tree\n+local_fold (tree t)\n+{\n+  t = fold (t);\n+\n+  /* Strip away useless type conversions.  Both the NON_LVALUE_EXPR that\n+     may have been added by fold, and \"useless\" type conversions that might\n+     now be apparent due to propagation.  */\n+  STRIP_USELESS_TYPE_CONVERSION (t);\n+\n+  return t;\n+}\n+\n /* Given a comparison code, return its opposite.  Note that this is *not*\n    the same as inverting its truth value (invert_tree_comparison).  Here we\n    just want to literally flip the comparison around.\n@@ -3402,6 +3417,124 @@ vrp_visit_phi_node (tree phi)\n   return SSA_PROP_VARYING;\n }\n \n+/* Walk through the IL simplifying expressions using knowledge\n+   gathered by VRP.  */\n+\n+static void\n+simplify_using_ranges (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t    {\n+\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      enum tree_code rhs_code = TREE_CODE (rhs);\n+\n+\t      /* Transform TRUNC_DIV_EXPR and TRUNC_MOD_EXPR into RSHIFT_EXPR\n+\t\t and BIT_AND_EXPR respectively if the first operand is greater\n+\t\t than zero and the second operand is an exact power of two.  */\n+\t      if ((rhs_code == TRUNC_DIV_EXPR || rhs_code == TRUNC_MOD_EXPR)\n+\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0)))\n+\t\t  && integer_pow2p (TREE_OPERAND (rhs, 1)))\n+\t\t{\n+\t\t  tree val = NULL;\n+\t\t  tree op = TREE_OPERAND (rhs, 0);\n+\t\t  value_range_t *vr = get_value_range (TREE_OPERAND (rhs, 0));\n+\n+\t\t  if (TYPE_UNSIGNED (TREE_TYPE (op)))\n+\t\t    {\n+\t\t      val = integer_one_node;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      val = compare_range_with_value (GT_EXPR, vr,\n+\t\t\t\t\t\t      integer_zero_node);\n+\t\t    }\n+\n+\t\t  if (val && integer_onep (val))\n+\t\t    {\n+\t\t      tree t;\n+\t\t      tree op0 = TREE_OPERAND (rhs, 0);\n+\t\t      tree op1 = TREE_OPERAND (rhs, 1);\n+\n+\t\t      if (rhs_code == TRUNC_DIV_EXPR)\n+\t\t\tt = build (RSHIFT_EXPR, TREE_TYPE (op0), op0,\n+\t\t\t\t   build_int_cst (NULL_TREE, tree_log2 (op1)));\n+\t\t      else\n+\t\t\tt = build (BIT_AND_EXPR, TREE_TYPE (op0), op0,\n+\t\t\t\t   local_fold (build (MINUS_EXPR,\n+\t\t\t\t\t\t      TREE_TYPE (op1),\n+\t\t\t\t\t\t      op1,\n+\t\t\t\t\t\t      integer_one_node)));\n+\n+\t\t      TREE_OPERAND (stmt, 1) = t;\n+\t\t      update_stmt (stmt);\n+\t\t    }\n+\n+\t\t}\n+\n+\t      /* Transform ABS (X) into X or -X as appropriate.  */\n+\t      if (rhs_code == ABS_EXPR\n+\t\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0))))\n+\t\t{\n+\t\t  tree val = NULL;\n+\t\t  tree op = TREE_OPERAND (rhs, 0);\n+\t\t  tree type = TREE_TYPE (op);\n+\t\t  value_range_t *vr = get_value_range (TREE_OPERAND (rhs, 0));\n+\n+\t\t  if (TYPE_UNSIGNED (type))\n+\t\t    {\n+\t\t      val = integer_zero_node;\n+\t\t    }\n+\t\t  else if (vr)\n+\t\t    {\n+\t\t      val = compare_range_with_value (LE_EXPR, vr,\n+\t\t\t\t\t\t      integer_zero_node);\n+\t\t      if (!val)\n+\t\t\t{\n+\t\t\t  val = compare_range_with_value (GE_EXPR, vr,\n+\t\t\t\t\t\t\t  integer_zero_node);\n+\n+\t\t\t  if (val)\n+\t\t\t    {\n+\t\t\t      if (integer_zerop (val))\n+\t\t\t\tval = integer_one_node;\n+\t\t\t      else if (integer_onep (val))\n+\t\t\t\tval = integer_zero_node;\n+\t\t\t    }\n+\t\t\t}\n+\n+\t\t      if (val\n+\t\t\t  && (integer_onep (val) || integer_zerop (val)))\n+\t\t\t{\n+\t\t\t  tree t;\n+\n+\t\t\t  if (integer_onep (val))\n+\t\t\t    t = build1 (NEGATE_EXPR, TREE_TYPE (op), op);\n+\t\t\t  else\n+\t\t\t    t = op;\n+\n+\t\t\t  TREE_OPERAND (stmt, 1) = t;\n+\t\t\t  update_stmt (stmt);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* TODO.  Simplify conditionals.   */\n+\t}\n+    }\n+}\n+\n \n /* Traverse all the blocks folding conditionals with known ranges.  */\n \n@@ -3445,6 +3578,12 @@ vrp_finalize (void)\n \n   substitute_and_fold (single_val_range, true);\n \n+  /* One could argue all simplifications should be done here\n+     rather than using substitute_and_fold since this code\n+     is going to have to perform a complete walk through the\n+     IL anyway.  */\n+  simplify_using_ranges ();\n+\n   /* Free allocated memory.  */\n   for (i = 0; i < num_ssa_names; i++)\n     if (vr_value[i])"}]}