{"sha": "d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc5ZTYyMWFmMjdmYmQ1MzA2YWVhOWQ1Y2U4ZDFjMmY5NWI1NWRiNQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2009-07-07T10:52:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-07T10:52:14Z"}, "message": "checks.adb (Generate_Range_Check): Replace type conversions with unchecked conversions to support the case of...\n\n2009-07-07  Gary Dismukes  <dismukes@adacore.com>\n\n\t* checks.adb (Generate_Range_Check): Replace type conversions with\n\tunchecked conversions to support the case of performing range checks\n\ton Enum'Val (permits integer values to be converted to enumeration).\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference, cases Attribute_Pred,\n\tAttribute_Succ): Set Do_Range_Check to False before calling\n\tExpand_Pred_Succ, to prevent gigi from generating any range checks.\n\t(Expand_N_Attribute_Reference, case Attribute_Val):\n\tGenerate a range check when needed (and set Do_Range_Check to False).\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Generate a range check on\n\tscalar object initialization if needed.\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): Generate range checks\n\twhen needed on scalar allocators.\n\t(Expand_N_Qualified_Expression): Generate range check when needed.\n\t(Expand_N_Slice): Remove call to Enable_Range_Check on slice ranges.\n\tChecks on slice ranges handled in Resolve_Slice.\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): Generate a range check,\n\twhen needed, for all scalar assignments, not just discrete.\n\t(Expand_Simple_Function_Return): Resolve the conversion created for a\n\tscalar function return so that the conversion will get expanded to\n\tgenerate a possible constraint check.\n\n\t* exp_ch6.adb (Expand_Actuals): Call Add_Call_By_Copy_Code for out and\n\tin out scalar actuals when subtypes don't match, to ensure generation\n\tof return checks (and set Do_Range_Check to False).\n\t(Expand_Call): Uncomment code to perform range checks, but make it apply\n\tonly to in and in out parameters (checks on parameter returns are\n\thandled in Expand_Actuals). If a scalar actual for a call to a derived\n\tsubprogram is marked as needing a range check, peform it here (and set\n\tDo_Range_Check to False).\n\n\t* sem_aggr.adb (Resolve_*_Aggregate.Resolve_Aggr_Expr): Generate a\n\trange check on scalar component associations when needed.\n\n\t* sem_eval.adb (In_Subrange_Of): Return False when the first type has\n\tinfinities but the second type does not, as these aren't compatible\n\tfloating-point types.\n\n\t* sem_res.adb (Resolve_Slice): In the case where the prefix of the\n\tslice is itself a slice, pick up the Etype of the prefix. This handles\n\tthe case where the prefix was an Image attribute expanded to a slice,\n\tand ensures that we get the subtype with the slice constraint rather\n\tthan the unconstrained subbtype of the 'Image.\n\nFrom-SVN: r149318", "tree": {"sha": "4a3fab9b0c75a5d51724885326e43a7653d4866b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a3fab9b0c75a5d51724885326e43a7653d4866b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0ba1bfd6445f979c50a9faba4ac91f90722ef4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ba1bfd6445f979c50a9faba4ac91f90722ef4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ba1bfd6445f979c50a9faba4ac91f90722ef4e"}], "stats": {"total": 226, "additions": 179, "deletions": 47}, "files": [{"sha": "edb7aeeb92118706a0f1c61b4ded2a870637a76b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -1,3 +1,52 @@\n+2009-07-07  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* checks.adb (Generate_Range_Check): Replace type conversions with\n+\tunchecked conversions to support the case of performing range checks\n+\ton Enum'Val (permits integer values to be converted to enumeration).\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference, cases Attribute_Pred,\n+\tAttribute_Succ): Set Do_Range_Check to False before calling\n+\tExpand_Pred_Succ, to prevent gigi from generating any range checks.\n+\t(Expand_N_Attribute_Reference, case Attribute_Val):\n+\tGenerate a range check when needed (and set Do_Range_Check to False).\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Generate a range check on\n+\tscalar object initialization if needed.\n+\n+\t* exp_ch4.adb (Expand_Allocator_Expression): Generate range checks\n+\twhen needed on scalar allocators.\n+\t(Expand_N_Qualified_Expression): Generate range check when needed.\n+\t(Expand_N_Slice): Remove call to Enable_Range_Check on slice ranges.\n+\tChecks on slice ranges handled in Resolve_Slice.\n+\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Generate a range check,\n+\twhen needed, for all scalar assignments, not just discrete.\n+\t(Expand_Simple_Function_Return): Resolve the conversion created for a\n+\tscalar function return so that the conversion will get expanded to\n+\tgenerate a possible constraint check.\n+\n+\t* exp_ch6.adb (Expand_Actuals): Call Add_Call_By_Copy_Code for out and\n+\tin out scalar actuals when subtypes don't match, to ensure generation\n+\tof return checks (and set Do_Range_Check to False).\n+\t(Expand_Call): Uncomment code to perform range checks, but make it apply\n+\tonly to in and in out parameters (checks on parameter returns are\n+\thandled in Expand_Actuals). If a scalar actual for a call to a derived\n+\tsubprogram is marked as needing a range check, peform it here (and set\n+\tDo_Range_Check to False).\n+\n+\t* sem_aggr.adb (Resolve_*_Aggregate.Resolve_Aggr_Expr): Generate a\n+\trange check on scalar component associations when needed.\n+\n+\t* sem_eval.adb (In_Subrange_Of): Return False when the first type has\n+\tinfinities but the second type does not, as these aren't compatible\n+\tfloating-point types.\n+\n+\t* sem_res.adb (Resolve_Slice): In the case where the prefix of the\n+\tslice is itself a slice, pick up the Etype of the prefix. This handles\n+\tthe case where the prefix was an Image attribute expanded to a slice,\n+\tand ensures that we get the subtype with the slice constraint rather\n+\tthan the unconstrained subbtype of the 'Image.\n+\n 2009-07-07  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch4.adb (Analyze_Conditional_Expression): handle properly"}, {"sha": "fe6ac149f1dd043c857110e86193b0dda148deac", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -4682,6 +4682,12 @@ package body Checks is\n \n       --  The conversions will always work and need no check\n \n+      --  Unchecked_Convert_To is used instead of Convert_To to handle the case\n+      --  of converting from an enumeration value to an integer type, such as\n+      --  occurs for the case of generating a range check on Enum'Val(Exp)\n+      --  (which used to be handled by gigi). This is OK, since the conversion\n+      --  itself does not require a check.\n+\n       elsif In_Subrange_Of (Target_Type, Source_Base_Type) then\n          Insert_Action (N,\n            Make_Raise_Constraint_Error (Loc,\n@@ -4692,14 +4698,14 @@ package body Checks is\n                  Right_Opnd =>\n                    Make_Range (Loc,\n                      Low_Bound =>\n-                       Convert_To (Source_Base_Type,\n+                       Unchecked_Convert_To (Source_Base_Type,\n                          Make_Attribute_Reference (Loc,\n                            Prefix =>\n                              New_Occurrence_Of (Target_Type, Loc),\n                            Attribute_Name => Name_First)),\n \n                      High_Bound =>\n-                       Convert_To (Source_Base_Type,\n+                       Unchecked_Convert_To (Source_Base_Type,\n                          Make_Attribute_Reference (Loc,\n                            Prefix =>\n                              New_Occurrence_Of (Target_Type, Loc),\n@@ -4891,7 +4897,7 @@ package body Checks is\n                      New_Occurrence_Of (Target_Base_Type, Loc),\n                    Constant_Present    => True,\n                    Expression          =>\n-                     Make_Type_Conversion (Loc,\n+                     Make_Unchecked_Type_Conversion (Loc,\n                        Subtype_Mark =>\n                          New_Occurrence_Of (Target_Base_Type, Loc),\n                        Expression   => Duplicate_Subexpr (N))),"}, {"sha": "c22598582cacb41682e21f8e25ee56cdd885dd9b", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -3388,10 +3388,13 @@ package body Exp_Attr is\n          elsif Is_Modular_Integer_Type (Ptyp) then\n             null;\n \n-         --  For other types, if range checking is enabled, we must generate\n-         --  a check if overflow checking is enabled.\n+         --  For other types, if argument is marked as needing a range check or\n+         --  overflow checking is enabled, we must generate a check.\n \n-         elsif not Overflow_Checks_Suppressed (Ptyp) then\n+         elsif not Overflow_Checks_Suppressed (Ptyp)\n+           or else Do_Range_Check (First (Exprs))\n+         then\n+            Set_Do_Range_Check (First (Exprs), False);\n             Expand_Pred_Succ (N);\n          end if;\n       end Pred;\n@@ -4319,10 +4322,13 @@ package body Exp_Attr is\n          elsif Is_Modular_Integer_Type (Ptyp) then\n             null;\n \n-         --  For other types, if range checking is enabled, we must generate\n-         --  a check if overflow checking is enabled.\n+         --  For other types, if argument is marked as needing a range check or\n+         --  overflow checking is enabled, we must generate a check.\n \n-         elsif not Overflow_Checks_Suppressed (Ptyp) then\n+         elsif not Overflow_Checks_Suppressed (Ptyp)\n+           or else Do_Range_Check (First (Exprs))\n+         then\n+            Set_Do_Range_Check (First (Exprs), False);\n             Expand_Pred_Succ (N);\n          end if;\n       end Succ;\n@@ -4629,6 +4635,13 @@ package body Exp_Attr is\n             end if;\n \n             Analyze_And_Resolve (N, Typ);\n+\n+         --  If the argument is marked as requiring a range check then generate\n+         --  it here.\n+\n+         elsif Do_Range_Check (First (Exprs)) then\n+            Set_Do_Range_Check (First (Exprs), False);\n+            Generate_Range_Check (First (Exprs), Etyp, CE_Range_Check_Failed);\n          end if;\n       end Val;\n "}, {"sha": "5aa5b64453989b14864794ae70a1aa0c094e8bea", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -4515,6 +4515,14 @@ package body Exp_Ch3 is\n                   null;\n                else\n                   Apply_Constraint_Check (Expr, Typ);\n+\n+                  --  If the expression has been marked as requiring a range\n+                  --  generate it now and reset the flag.\n+\n+                  if Do_Range_Check (Expr) then\n+                     Set_Do_Range_Check (Expr, False);\n+                     Generate_Range_Check (Expr, Typ, CE_Range_Check_Failed);\n+                  end if;\n                end if;\n             end if;\n "}, {"sha": "4d50e0b9ccb7132607cab71e0ed9a270be087778", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -1038,6 +1038,11 @@ package body Exp_Ch4 is\n \n          Apply_Constraint_Check (Exp, T, No_Sliding => True);\n \n+         if Do_Range_Check (Exp) then\n+            Set_Do_Range_Check (Exp, False);\n+            Generate_Range_Check (Exp, DesigT, CE_Range_Check_Failed);\n+         end if;\n+\n          --  A check is also needed in cases where the designated subtype is\n          --  constrained and differs from the subtype given in the qualified\n          --  expression. Note that the check on the qualified expression does\n@@ -1048,6 +1053,11 @@ package body Exp_Ch4 is\n          then\n             Apply_Constraint_Check\n               (Exp, DesigT, No_Sliding => False);\n+\n+            if Do_Range_Check (Exp) then\n+               Set_Do_Range_Check (Exp, False);\n+               Generate_Range_Check (Exp, DesigT, CE_Range_Check_Failed);\n+            end if;\n          end if;\n \n          --  For an access to unconstrained packed array, GIGI needs to see an\n@@ -7073,6 +7083,11 @@ package body Exp_Ch4 is\n       --  Apply possible constraint check\n \n       Apply_Constraint_Check (Operand, Target_Type, No_Sliding => True);\n+\n+      if Do_Range_Check (Operand) then\n+         Set_Do_Range_Check (Operand, False);\n+         Generate_Range_Check (Operand, Target_Type, CE_Range_Check_Failed);\n+      end if;\n    end Expand_N_Qualified_Expression;\n \n    ---------------------------------\n@@ -7429,32 +7444,6 @@ package body Exp_Ch4 is\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pfx);\n       end if;\n \n-      --  Range checks are potentially also needed for cases involving a slice\n-      --  indexed by a subtype indication, but Do_Range_Check can currently\n-      --  only be set for expressions ???\n-\n-      if not Index_Checks_Suppressed (Ptp)\n-        and then (not Is_Entity_Name (Pfx)\n-                   or else not Index_Checks_Suppressed (Entity (Pfx)))\n-        and then Nkind (Discrete_Range (N)) /= N_Subtype_Indication\n-\n-         --  Do not enable range check to nodes associated with the frontend\n-         --  expansion of the dispatch table. We first check if Ada.Tags is\n-         --  already loaded to avoid the addition of an undesired dependence\n-         --  on such run-time unit.\n-\n-        and then\n-          (not Tagged_Type_Expansion\n-            or else not\n-             (RTU_Loaded (Ada_Tags)\n-               and then Nkind (Prefix (N)) = N_Selected_Component\n-               and then Present (Entity (Selector_Name (Prefix (N))))\n-               and then Entity (Selector_Name (Prefix (N))) =\n-                                  RTE_Record_Component (RE_Prims_Ptr)))\n-      then\n-         Enable_Range_Check (Discrete_Range (N));\n-      end if;\n-\n       --  The remaining case to be handled is packed slices. We can leave\n       --  packed slices as they are in the following situations:\n "}, {"sha": "ddbe19f5b651e41bb9fbb1a34e8b2e4d92677d4f", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -1530,12 +1530,9 @@ package body Exp_Ch5 is\n          end;\n       end if;\n \n-      --  First deal with generation of range check if required. For now we do\n-      --  this only for discrete types.\n+      --  First deal with generation of range check if required\n \n-      if Do_Range_Check (Rhs)\n-        and then Is_Discrete_Type (Typ)\n-      then\n+      if Do_Range_Check (Rhs) then\n          Set_Do_Range_Check (Rhs, False);\n          Generate_Range_Check (Rhs, Typ, CE_Range_Check_Failed);\n       end if;\n@@ -3853,7 +3850,11 @@ package body Exp_Ch5 is\n \n       if Is_Scalar_Type (Exptyp) then\n          Rewrite (Exp, Convert_To (R_Type, Exp));\n-         Analyze (Exp);\n+\n+         --  The expression is resolved to ensure that the conversion gets\n+         --  expanded to generate a possible constraint check.\n+\n+         Analyze_And_Resolve (Exp, R_Type);\n       end if;\n \n       --  Deal with returning variable length objects and controlled types"}, {"sha": "55e1f15db7457b1762e2d8e52a483ac02e338ba5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -1589,6 +1589,25 @@ package body Exp_Ch6 is\n               and then Has_Volatile_Components (Entity (Prefix (Actual)))\n             then\n                Add_Call_By_Copy_Code;\n+\n+            --  Add call-by-copy code for the case of scalar out parameters\n+            --  when it is not known at compile time that the subtype of the\n+            --  formal is a subrange of the subtype of the actual, in order\n+            --  to get return range checks on such actuals. (Maybe this case\n+            --  should be handled earlier in the if statement???)\n+\n+            elsif Is_Scalar_Type (E_Formal)\n+              and then not In_Subrange_Of (E_Formal, Etype (Actual))\n+            then\n+               --  Perhaps the setting back to False should be done within\n+               --  Add_Call_By_Copy_Code, since it could get set on other\n+               --  cases occurring above???\n+\n+               if Do_Range_Check (Actual) then\n+                  Set_Do_Range_Check (Actual, False);\n+               end if;\n+\n+               Add_Call_By_Copy_Code;\n             end if;\n \n          --  Processing for IN parameters\n@@ -2028,13 +2047,15 @@ package body Exp_Ch6 is\n       Param_Count := 1;\n       while Present (Formal) loop\n \n-         --  Generate range check if required (not activated yet ???)\n+         --  Generate range check if required\n \n---         if Do_Range_Check (Actual) then\n---            Set_Do_Range_Check (Actual, False);\n---            Generate_Range_Check\n---              (Actual, Etype (Formal), CE_Range_Check_Failed);\n---         end if;\n+         if Do_Range_Check (Actual)\n+           and then Ekind (Formal) /= E_Out_Parameter\n+         then\n+            Set_Do_Range_Check (Actual, False);\n+            Generate_Range_Check\n+              (Actual, Etype (Formal), CE_Range_Check_Failed);\n+         end if;\n \n          --  Prepare to examine current entry\n \n@@ -2711,6 +2732,15 @@ package body Exp_Ch6 is\n                      Convert (Actual, Parent_Typ);\n                      Enable_Range_Check (Actual);\n \n+                     --  If the actual has been marked as requiring a range\n+                     --  check, then generate it here.\n+\n+                     if Do_Range_Check (Actual) then\n+                        Set_Do_Range_Check (Actual, False);\n+                        Generate_Range_Check\n+                          (Actual, Etype (Formal), CE_Range_Check_Failed);\n+                     end if;\n+\n                   --  For access types, the parent formal type and actual type\n                   --  differ.\n "}, {"sha": "2c40c92ad172dfc19542ba0fff40248535d99b84", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -1473,6 +1473,14 @@ package body Sem_Aggr is\n             Set_Raises_Constraint_Error (N);\n          end if;\n \n+         --  If the expression has been marked as requiring a range check,\n+         --  then generate it here.\n+\n+         if Do_Range_Check (Expr) then\n+            Set_Do_Range_Check (Expr, False);\n+            Generate_Range_Check (Expr, Component_Typ, CE_Range_Check_Failed);\n+         end if;\n+\n          return Resolution_OK;\n       end Resolve_Aggr_Expr;\n \n@@ -2801,6 +2809,14 @@ package body Sem_Aggr is\n             Set_Raises_Constraint_Error (N);\n          end if;\n \n+         --  If the expression has been marked as requiring a range check,\n+         --  then generate it here.\n+\n+         if Do_Range_Check (Expr) then\n+            Set_Do_Range_Check (Expr, False);\n+            Generate_Range_Check (Expr, Expr_Type, CE_Range_Check_Failed);\n+         end if;\n+\n          if Relocate then\n             Add_Association (New_C, Relocate_Node (Expr), New_Assoc_List);\n          else"}, {"sha": "1e948f09566bef3f449e23b1f150e99b9855c634", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -3738,6 +3738,16 @@ package body Sem_Eval is\n       elsif not Is_Scalar_Type (T1) or else not Is_Scalar_Type (T1) then\n          return False;\n \n+      --  If T1 has infinities but T2 doesn't have infinities, then T1 is\n+      --  definitely not compatible with T2.\n+\n+      elsif Is_Floating_Point_Type (T1)\n+        and then Has_Infinities (T1)\n+        and then Is_Floating_Point_Type (T2)\n+        and then not Has_Infinities (T2)\n+      then\n+         return False;\n+\n       else\n          L1 := Type_Low_Bound  (T1);\n          H1 := Type_High_Bound (T1);"}, {"sha": "3af4785a0262dfd89e70724c636053557331acb0", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79e621af27fbd5306aea9d5ce8d1c2f95b55db5/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d79e621af27fbd5306aea9d5ce8d1c2f95b55db5", "patch": "@@ -7887,6 +7887,16 @@ package body Sem_Res is\n             Insert_Action (N, Act_Decl);\n             Array_Type := Defining_Identifier (Act_Decl);\n          end;\n+\n+      --  Maybe this should just be \"else\", instead of checking for the\n+      --  specific case of slice??? This is needed for the case where\n+      --  the prefix is an Image attribute, which gets expanded to a\n+      --  slice, and so has a constrained subtype which we want to use\n+      --  for the slice range check applied below (the range check won't\n+      --  get done if the unconstrained subtype of the 'Image is used).\n+\n+      elsif Nkind (Name) = N_Slice then\n+         Array_Type := Etype (Name);\n       end if;\n \n       --  If name was overloaded, set slice type correctly now"}]}