{"sha": "fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMxYzJkMDQ4MjI2MGM4MGNmZTgzNjNmOTZhY2U5YTU3ZjEwY2JmNA==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2016-05-02T08:54:34Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2016-05-02T08:54:34Z"}, "message": "[ARC] Add new ARCv2 instructions.\n\ngcc/\n2016-05-02  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc-protos.h (compact_memory_operand_p): Declare.\n\t* config/arc/arc.c (arc_output_commutative_cond_exec): Consider\n\tbmaskn instruction.\n\t(arc_dwarf_register_span): Remove enum keyword.\n\t(compact_memory_operand_p): New function.\n\t* config/arc/arc.h (reg_class): Add code density register classes.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t* config/arc/arc.md (*movqi_insn): Add code density instructions.\n\t(*movhi_insn, *movsi_insn, *movsf_insn): Likewise.\n\t(*extendhisi2_i, andsi3_i, cmpsi_cc_insn_mixed): Likewise.\n\t(*cmpsi_cc_c_insn, *movsi_ne): Likewise.\n\t* config/arc/constraints.md (C2p, Uts, Cm1, Cm3, Ucd): New\n\tconstraints.\n\t(h, Rcd, Rsd, Rzd): New register constraints.\n\t(T): Use compact_memory_operand_p function.\n\t* config/arc/predicates.md (compact_load_memory_operand): Remove.\n\nFrom-SVN: r235707", "tree": {"sha": "c40e671c5b2a36bde4b5873c1bb266562c0fc4a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c40e671c5b2a36bde4b5873c1bb266562c0fc4a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02673c66c6477d1212a49a602f74c624267dda29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02673c66c6477d1212a49a602f74c624267dda29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02673c66c6477d1212a49a602f74c624267dda29"}], "stats": {"total": 481, "additions": 324, "deletions": 157}, "files": [{"sha": "fecfdab68becca0b2bdd0ca81fa5853c35d14e76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "patch": "@@ -1,3 +1,23 @@\n+2016-05-02  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-protos.h (compact_memory_operand_p): Declare.\n+\t* config/arc/arc.c (arc_output_commutative_cond_exec): Consider\n+\tbmaskn instruction.\n+\t(arc_dwarf_register_span): Remove enum keyword.\n+\t(compact_memory_operand_p): New function.\n+\t* config/arc/arc.h (reg_class): Add code density register classes.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t* config/arc/arc.md (*movqi_insn): Add code density instructions.\n+\t(*movhi_insn, *movsi_insn, *movsf_insn): Likewise.\n+\t(*extendhisi2_i, andsi3_i, cmpsi_cc_insn_mixed): Likewise.\n+\t(*cmpsi_cc_c_insn, *movsi_ne): Likewise.\n+\t* config/arc/constraints.md (C2p, Uts, Cm1, Cm3, Ucd): New\n+\tconstraints.\n+\t(h, Rcd, Rsd, Rzd): New register constraints.\n+\t(T): Use compact_memory_operand_p function.\n+\t* config/arc/predicates.md (compact_load_memory_operand): Remove.\n+\n 2016-05-02  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.md (*negnegt, *movtt): Remove."}, {"sha": "8630e2d84daabd8d5fa0f6a190c2c5dd2a9b5463", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "patch": "@@ -44,7 +44,7 @@ extern void emit_shift (enum rtx_code, rtx, rtx, rtx);\n extern void arc_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern void arc_split_compare_and_swap (rtx *);\n extern void arc_expand_compare_and_swap (rtx *);\n-\n+extern bool compact_memory_operand_p (rtx, machine_mode, bool, bool);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "a54fddb45d329e3d098435ee3134a8642bc3913e", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "patch": "@@ -7389,6 +7389,11 @@ arc_output_commutative_cond_exec (rtx *operands, bool output_p)\n       case AND:\n \tif (satisfies_constraint_C1p (operands[2]))\n \t  pat = \"bmsk%? %0,%1,%Z2\";\n+\telse if (satisfies_constraint_C2p (operands[2]))\n+\t  {\n+\t    operands[2] = GEN_INT ((~INTVAL (operands[2])));\n+\t    pat = \"bmskn%? %0,%1,%Z2\";\n+\t  }\n \telse if (satisfies_constraint_Ccp (operands[2]))\n \t  pat = \"bclr%? %0,%1,%M2\";\n \telse if (satisfies_constraint_CnL (operands[2]))\n@@ -9859,12 +9864,153 @@ arc_dwarf_register_span (rtx rtl)\n \n /* We can't inline this in INSN_REFERENCES_ARE_DELAYED because\n    resource.h doesn't include the required header files.  */\n+\n bool\n insn_is_tls_gd_dispatch (rtx_insn *insn)\n {\n   return recog_memoized (insn) == CODE_FOR_tls_gd_dispatch;\n }\n \n+/* Return true if OP is an acceptable memory operand for ARCompact\n+   16-bit load instructions of MODE.\n+\n+   AV2SHORT: TRUE if address needs to fit into the new ARCv2 short\n+   non scaled instructions.\n+\n+   SCALED: TRUE if address can be scaled.  */\n+\n+bool\n+compact_memory_operand_p (rtx op, machine_mode mode,\n+\t\t\t  bool av2short, bool scaled)\n+{\n+  rtx addr, plus0, plus1;\n+  int size, off;\n+\n+  /* Eliminate non-memory operations.  */\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  /* .di instructions have no 16-bit form.  */\n+  if (MEM_VOLATILE_P (op) && !TARGET_VOLATILE_CACHE_SET)\n+    return false;\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  size = GET_MODE_SIZE (mode);\n+\n+  /* dword operations really put out 2 instructions, so eliminate\n+     them.  */\n+  if (size > UNITS_PER_WORD)\n+    return false;\n+\n+  /* Decode the address now.  */\n+  addr = XEXP (op, 0);\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      return (REGNO (addr) >= FIRST_PSEUDO_REGISTER\n+\t      || COMPACT_GP_REG_P (REGNO (addr))\n+\t      || (SP_REG_P (REGNO (addr)) && (size != 2)));\n+    case PLUS:\n+      plus0 = XEXP (addr, 0);\n+      plus1 = XEXP (addr, 1);\n+\n+      if ((GET_CODE (plus0) == REG)\n+\t  && ((REGNO (plus0) >= FIRST_PSEUDO_REGISTER)\n+\t      || COMPACT_GP_REG_P (REGNO (plus0)))\n+\t  && ((GET_CODE (plus1) == REG)\n+\t      && ((REGNO (plus1) >= FIRST_PSEUDO_REGISTER)\n+\t\t  || COMPACT_GP_REG_P (REGNO (plus1)))))\n+\t{\n+\t  return !av2short;\n+\t}\n+\n+      if ((GET_CODE (plus0) == REG)\n+\t  && ((REGNO (plus0) >= FIRST_PSEUDO_REGISTER)\n+\t      || (COMPACT_GP_REG_P (REGNO (plus0)) && !av2short)\n+\t      || (IN_RANGE (REGNO (plus0), 0, 31) && av2short))\n+\t  && (GET_CODE (plus1) == CONST_INT))\n+\t{\n+\t  bool valid = false;\n+\n+\t  off = INTVAL (plus1);\n+\n+\t  /* Negative offset is not supported in 16-bit load/store insns.  */\n+\t  if (off < 0)\n+\t    return 0;\n+\n+\t  /* Only u5 immediates allowed in code density instructions.  */\n+\t  if (av2short)\n+\t    {\n+\t      switch (size)\n+\t\t{\n+\t\tcase 1:\n+\t\t  return false;\n+\t\tcase 2:\n+\t\t  /* This is an ldh_s.x instruction, check the u6\n+\t\t     immediate.  */\n+\t\t  if (COMPACT_GP_REG_P (REGNO (plus0)))\n+\t\t    valid = true;\n+\t\t  break;\n+\t\tcase 4:\n+\t\t  /* Only u5 immediates allowed in 32bit access code\n+\t\t     density instructions.  */\n+\t\t  if (REGNO (plus0) <= 31)\n+\t\t    return ((off < 32) && (off % 4 == 0));\n+\t\t  break;\n+\t\tdefault:\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t  else\n+\t    if (COMPACT_GP_REG_P (REGNO (plus0)))\n+\t      valid = true;\n+\n+\t  if (valid)\n+\t    {\n+\n+\t      switch (size)\n+\t\t{\n+\t\tcase 1:\n+\t\t  return (off < 32);\n+\t\tcase 2:\n+\t\t  /* The 6-bit constant get shifted to fit the real\n+\t\t     5-bits field.  Check also for the alignment.  */\n+\t\t  return ((off < 64) && (off % 2 == 0));\n+\t\tcase 4:\n+\t\t  return ((off < 128) && (off % 4 == 0));\n+\t\tdefault:\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (REG_P (plus0) && CONST_INT_P (plus1)\n+\t  && ((REGNO (plus0) >= FIRST_PSEUDO_REGISTER)\n+\t      || SP_REG_P (REGNO (plus0)))\n+\t  && !av2short)\n+\t{\n+\t  off = INTVAL (plus1);\n+\t  return ((size != 2) && (off >= 0 && off < 128) && (off % 4 == 0));\n+\t}\n+\n+      if ((GET_CODE (plus0) == MULT)\n+\t  && (GET_CODE (XEXP (plus0, 0)) == REG)\n+\t  && ((REGNO (XEXP (plus0, 0)) >= FIRST_PSEUDO_REGISTER)\n+\t      || COMPACT_GP_REG_P (REGNO (XEXP (plus0, 0))))\n+\t  && (GET_CODE (plus1) == REG)\n+\t  && ((REGNO (plus1) >= FIRST_PSEUDO_REGISTER)\n+\t      || COMPACT_GP_REG_P (REGNO (plus1))))\n+\treturn scaled;\n+    default:\n+      break ;\n+      /* TODO: 'gp' and 'pcl' are to supported as base address operand\n+\t for 16-bit load instructions.  */\n+    }\n+  return false;\n+}\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-arc.h\""}, {"sha": "f6b85ea7e51b19501c044b338a17b0d4cf8a03a5", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "patch": "@@ -674,6 +674,9 @@ enum reg_class\n    WRITABLE_CORE_REGS,\t\t/* 'w' */\n    CHEAP_CORE_REGS,\t\t/* 'c' */\n    ALL_CORE_REGS,\t\t/* 'Rac' */\n+   R0R3_CD_REGS,\t\t/* 'Rcd' */\n+   R0R1_CD_REGS,\t\t/* 'Rsd' */\n+   AC16_H_REGS,\t\t\t/* 'h' */\n    ALL_REGS,\n    LIM_REG_CLASSES\n };\n@@ -700,6 +703,9 @@ enum reg_class\n   \"MPY_WRITABLE_CORE_REGS\",   \\\n   \"WRITABLE_CORE_REGS\",   \\\n   \"CHEAP_CORE_REGS\",\t  \\\n+  \"R0R3_CD_REGS\", \\\n+  \"R0R1_CD_REGS\", \\\n+  \"AC16_H_REGS\",\t    \\\n   \"ALL_CORE_REGS\",\t  \\\n   \"ALL_REGS\"          \t  \\\n }\n@@ -732,6 +738,9 @@ enum reg_class\n   {0xffffffff, 0xd0000000, 0x00000000, 0x00000000, 0x00000000},      /* 'w', r0-r31, r60 */ \\\n   {0xffffffff, 0xdfffffff, 0x00000000, 0x00000000, 0x00000000},      /* 'c', r0-r60, ap, pcl */ \\\n   {0xffffffff, 0xdfffffff, 0x00000000, 0x00000000, 0x00000000},      /* 'Rac', r0-r60, ap, pcl */ \\\n+  {0x0000000f, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'Rcd', r0-r3 */ \\\n+  {0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'Rsd', r0-r1 */ \\\n+  {0x9fffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'h',  r0-28, r30 */ \\\n   {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0003ffff}       /* All Registers */\t\t\\\n }\n "}, {"sha": "85e54587d99df9866a0f5396deccee22fde237ff", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 89, "deletions": 65, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "patch": "@@ -620,14 +620,15 @@\n ; The iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n (define_insn \"*movqi_insn\"\n-  [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,w,w,w,???w,w,Rcq,S,!*x,r,r,Ucm,m,???m\")\n-\t(match_operand:QI 1 \"move_src_operand\"  \"cL,cP,Rcq#q,cL,I,?Rac,?i,T,Rcq,Usd,Ucm,m,?Rac,c,?Rac\"))]\n+  [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,   h, w,w,???w, w,Rcq,  S,!*x,  r,r, Ucm,m,???m\")\n+\t(match_operand:QI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,hCm1,cL,I,?Rac,?i,  T,Rcq,Usd,Ucm,m,?Rac,c,?Rac\"))]\n   \"register_operand (operands[0], QImode)\n    || register_operand (operands[1], QImode)\"\n   \"@\n    mov%? %0,%1%&\n    mov%? %0,%1%&\n    mov%? %0,%1%&\n+   mov%? %0,%1%&\n    mov%? %0,%1\n    mov%? %0,%1\n    mov%? %0,%1\n@@ -640,10 +641,10 @@\n    xstb%U0 %1,%0\n    stb%U0%V0 %1,%0\n    stb%U0%V0 %1,%0\"\n-  [(set_attr \"type\" \"move,move,move,move,move,move,move,load,store,load,load,load,store,store,store\")\n-   (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false,false,true,true,true,false,false,false,false,false\")\n-   (set_attr \"predicable\" \"yes,no,yes,yes,no,yes,yes,no,no,no,no,no,no,no,no\")\n-   (set_attr \"cpu_facility\" \"*,*,av1,*,*,*,*,*,*,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"move,move,move,move,move,move,move,move,load,store,load,load,load,store,store,store\")\n+   (set_attr \"iscompact\" \"maybe,maybe,maybe,true,false,false,false,false,true,true,true,false,false,false,false,false\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,yes,no,yes,yes,no,no,no,no,no,no,no,no\")\n+   (set_attr \"cpu_facility\" \"*,*,av1,av2,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"move_dest_operand\" \"\")\n@@ -652,8 +653,8 @@\n   \"if (prepare_move_operands (operands, HImode)) DONE;\")\n \n (define_insn \"*movhi_insn\"\n-  [(set (match_operand:HI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,w,w,w,???w,Rcq#q,w,Rcq,S,r,r,Ucm,m,???m,VUsc\")\n-\t(match_operand:HI 1 \"move_src_operand\" \"cL,cP,Rcq#q,cL,I,?Rac,?i,?i,T,Rcq,Ucm,m,?Rac,c,?Rac,i\"))]\n+  [(set (match_operand:HI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,   h, w,w,???w,Rcq#q, w,Rcq,  S,  r,r, Ucm,m,???m,VUsc,VUsc\")\n+\t(match_operand:HI 1 \"move_src_operand\" \"   cL,   cP,Rcq#q,hCm1,cL,I,?Rac,   ?i,?i,  T,Rcq,Ucm,m,?Rac,c,?Rac, Cm3,i\"))]\n   \"register_operand (operands[0], HImode)\n    || register_operand (operands[1], HImode)\n    || (CONSTANT_P (operands[1])\n@@ -665,6 +666,7 @@\n    mov%? %0,%1%&\n    mov%? %0,%1%&\n    mov%? %0,%1%&\n+   mov%? %0,%1%&\n    mov%? %0,%1\n    mov%? %0,%1\n    mov%? %0,%1\n@@ -677,11 +679,12 @@\n    xst%_%U0 %1,%0\n    st%_%U0%V0 %1,%0\n    st%_%U0%V0 %1,%0\n+   st%_%U0%V0 %S1,%0\n    st%_%U0%V0 %S1,%0\"\n-  [(set_attr \"type\" \"move,move,move,move,move,move,move,move,load,store,load,load,store,store,store,store\")\n-   (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false,maybe_limm,false,true,true,false,false,false,false,false,false\")\n-   (set_attr \"predicable\" \"yes,no,yes,yes,no,yes,yes,yes,no,no,no,no,no,no,no,no\")\n-   (set_attr \"cpu_facility\" \"*,*,av1,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"move,move,move,move,move,move,move,move,move,load,store,load,load,store,store,store,store,store\")\n+   (set_attr \"iscompact\" \"maybe,maybe,maybe,true,false,false,false,maybe_limm,false,true,true,false,false,false,false,false,false,false\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,yes,no,yes,yes,yes,no,no,no,no,no,no,no,no,no\")\n+   (set_attr \"cpu_facility\" \"*,*,av1,av2,*,*,*,*,*,*,*,*,*,*,*,*,av2,*\")])\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"move_dest_operand\" \"\")\n@@ -699,9 +702,9 @@\n ; the iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n ; N.B. operand 1 of alternative 7 expands into pcl,symbol@gotpc .\n-(define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,w,w,w,w,w,w,w,???w,?w,w,Rcq#q,w,Rcq,S,Us<,RcqRck,!*x,r,r,Ucm,m,???m,VUsc\")\n-\t(match_operand:SI 1 \"move_src_operand\"  \"cL,cP,Rcq#q,cL,I,Crr,Clo,Chi,Cbi,?Rac,Cpc,Clb,?Cal,?Cal,T,Rcq,RcqRck,Us>,Usd,Ucm,m,w,c,?Rac,C32\"))]\n+(define_insn \"*movsi_insn\"                      ;   0     1     2    3  4 5   6   7   8   9   10  11  12    13   14  15  16     17     18 19   20    21    22 23 24    25 26  27   28   29\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,   h, w,w,  w,  w,  w,  w,???w, ?w,  w,Rcq#q,   w,Rcq,  S,   Us<,RcqRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,???m,VUsc,VUsc\")\n+\t(match_operand:SI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,hCm1,cL,I,Crr,Clo,Chi,Cbi,?Rac,Cpc,Clb, ?Cal,?Cal,  T,Rcq,RcqRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  w,!*Rzd,c,?Rac, Cm3, C32\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\n    || (CONSTANT_P (operands[1])\n@@ -713,35 +716,40 @@\n    mov%? %0,%1%&\t;0\n    mov%? %0,%1%&\t;1\n    mov%? %0,%1%&\t;2\n-   mov%? %0,%1\t\t;3\n+   mov%? %0,%1%&\t;3\n    mov%? %0,%1\t\t;4\n-   ror %0,((%1*2+1) & 0x3f) ;5\n-   movl.cl %0,%1       ;6\n-   movh.cl %0,%L1>>16  ;7\n+   mov%? %0,%1\t\t;5\n+   ror %0,((%1*2+1) & 0x3f) ;6\n+   movl.cl %0,%1\t;7\n+   movh.cl %0,%L1>>16   ;8\n    * return INTVAL (operands[1]) & 0xffffff ? \\\"movbi.cl %0,%1 >> %p1,%p1,8;8\\\" : \\\"movbi.cl %0,%L1 >> 24,24,8;9\\\";\n-   mov%? %0,%1\t\t;9\n-   add %0,%S1\t\t;10\n+   mov%? %0,%1\t\t;10\n+   add %0,%S1\t\t;11\n    * return arc_get_unalign () ? \\\"add %0,pcl,%1-.+2\\\" : \\\"add %0,pcl,%1-.\\\";\n-   mov%? %0,%S1%&\t;12\n-   mov%? %0,%S1\t\t;13\n-   ld%? %0,%1%&\t\t;14\n-   st%? %1,%0%&\t\t;15\n+   mov%? %0,%S1%&\t;13\n+   mov%? %0,%S1\t\t;14\n+   ld%? %0,%1%&\t\t;15\n+   st%? %1,%0%&\t\t;16\n    * return arc_short_long (insn, \\\"push%? %1%&\\\", \\\"st%U0 %1,%0%&\\\");\n    * return arc_short_long (insn, \\\"pop%? %0%&\\\",  \\\"ld%U1 %0,%1%&\\\");\n-   ld%? %0,%1%&\t\t;18\n-   xld%U1 %0,%1                ;19\n-   ld%U1%V1 %0,%1\t;20\n-   xst%U0 %1,%0                ;21\n-   st%U0%V0 %1,%0       ;22\n-   st%U0%V0 %1,%0       ;23\n-   st%U0%V0 %S1,%0      ;24\"\n-  [(set_attr \"type\" \"move,move,move,move,move,two_cycle_core,shift,shift,shift,move,binary,binary,move,move,load,store,store,load,load,load,load,store,store,store,store\")\n-   (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false,false,false,false,false,false,false,maybe_limm,false,true,true,true,true,true,false,false,false,false,false,false\")\n+   ld%? %0,%1%&\t\t;19\n+   xld%U1 %0,%1\t\t;20\n+   ld%? %0,%1%&\t\t;21\n+   ld%? %0,%1%&\t\t;22\n+   ld%U1%V1 %0,%1\t;23\n+   xst%U0 %1,%0\t\t;24\n+   st%? %1,%0%&\t\t;25\n+   st%U0%V0 %1,%0\t;26\n+   st%U0%V0 %1,%0\t;27\n+   st%U0%V0 %1,%0\t;28\n+   st%U0%V0 %S1,%0\t;29\"\n+  [(set_attr \"type\" \"move,move,move,move,move,move,two_cycle_core,shift,shift,shift,move,binary,binary,move,move,load,store,store,load,load,load,load,load,load,store,store,store,store,store,store\")\n+   (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false,false,false,false,false,false,false,maybe_limm,false,true,true,true,true,true,false,false,false,false,false,false,false,false,false,false,false\")\n    ; Use default length for iscompact to allow for COND_EXEC.  But set length\n    ; of Crr to 4.\n-   (set_attr \"length\" \"*,*,*,4,4,4,4,4,4,4,8,8,*,8,*,*,*,*,*,4,*,4,*,*,8\")\n-   (set_attr \"predicable\" \"yes,no,yes,yes,no,no,no,no,no,yes,no,no,yes,yes,no,no,no,no,no,no,no,no,no,no,no\")\n-   (set_attr \"cpu_facility\" \"*,*,av1,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n+   (set_attr \"length\" \"*,*,*,*,4,4,4,4,4,4,4,8,8,*,8,*,*,*,*,*,4,*,4,*,*,*,*,*,4,8\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,yes,no,no,no,no,no,yes,no,no,yes,yes,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no\")\n+   (set_attr \"cpu_facility\" \"*,*,av1,av2,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,av2,av2,*,*,av2,*,*,av2,*\")])\n \n ;; Sometimes generated by the epilogue code.  We don't want to\n ;; recognize these addresses in general, because the limm is costly,\n@@ -1136,17 +1144,19 @@\n   \"if (prepare_move_operands (operands, SFmode)) DONE;\")\n \n (define_insn \"*movsf_insn\"\n-  [(set (match_operand:SF 0 \"move_dest_operand\" \"=w,w,r,m\")\n-\t(match_operand:SF 1 \"move_src_operand\" \"c,E,m,c\"))]\n+  [(set (match_operand:SF 0 \"move_dest_operand\"    \"=h,w,w,r,m\")\n+\t(match_operand:SF 1 \"move_src_operand\"   \"hCm1,c,E,m,c\"))]\n   \"register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode)\"\n   \"@\n+   mov%? %0,%1\n    mov%? %0,%1\n    mov%? %0,%1 ; %A1\n    ld%U1%V1 %0,%1\n    st%U0%V0 %1,%0\"\n-  [(set_attr \"type\" \"move,move,load,store\")\n-   (set_attr \"predicable\" \"yes,yes,no,no\")])\n+  [(set_attr \"type\" \"move,move,move,load,store\")\n+   (set_attr \"predicable\" \"no,yes,yes,no,no\")\n+   (set_attr \"iscompact\" \"true,false,false,false,false\")])\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n@@ -1664,17 +1674,18 @@\n )\n \n (define_insn \"*extendhisi2_i\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcqq,w,r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"Rcqq,c,Uex,m\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcqq,w,Rcq,r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"Rcqq,c,Ucd,Uex,m\")))]\n   \"\"\n   \"@\n    sex%_%? %0,%1%&\n    sex%_ %0,%1\n+   ldh%?.x %0,%1%&\n    ld%_.x%U1%V1 %0,%1\n    ld%_.x%U1%V1 %0,%1\"\n-  [(set_attr \"type\" \"unary,unary,load,load\")\n-   (set_attr \"iscompact\" \"true,false,false,false\")\n-   (set_attr \"length\" \"*,*,4,8\")])\n+  [(set_attr \"type\" \"unary,unary,load,load,load\")\n+   (set_attr \"iscompact\" \"true,false,true,false,false\")\n+   (set_attr \"length\" \"*,*,*,4,8\")])\n \n (define_expand \"extendhisi2\"\n   [(set (match_operand:SI 0 \"dest_reg_operand\" \"\")\n@@ -3041,9 +3052,9 @@\n      operands[1] = arc_rewrite_small_data (operands[1]);\")\n \n (define_insn \"andsi3_i\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcqq,Rcq,Rcqq,Rcqq,Rcqq,Rcw,Rcw,Rcw,Rcw,Rcw,Rcw,w,w,w,w,Rrq,w,Rcw,w,W\")\n-\t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,Rcq,0,0,Rcqq,0,c,0,0,0,0,c,c,c,c,Rrq,0,0,c,o\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"Rcqq,0,C1p,Ccp,Cux,cL,0,C1p,Ccp,CnL,I,Lc,C1p,Ccp,CnL,Cbf,I,Cal,Cal,Cux\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\"          \"=Rcqq,Rcq,Rcqq,Rcqq,Rcqq,Rcw,Rcw,   Rcw,Rcw,Rcw,Rcw, w,     w,  w,  w,Rrq,w,Rcw,  w,W\")\n+\t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,Rcq,   0,   0,Rcqq,  0,  c,     0,  0,  0,  0, c,     c,  c,  c,Rrq,0,  0,  c,o\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\"  \"Rcqq,  0, C1p, Ccp, Cux, cL,  0,C2pC1p,Ccp,CnL,  I,Lc,C2pC1p,Ccp,CnL,Cbf,I,Cal,Cal,Cux\")))]\n   \"(register_operand (operands[1], SImode)\n     && nonmemory_operand (operands[2], SImode))\n    || (memory_operand (operands[1], SImode)\n@@ -3055,8 +3066,18 @@\n       return \"and%? %0,%1,%2%&\";\n     case 1: case 6:\n       return \"and%? %0,%2,%1%&\";\n-    case 2: case 7: case 12:\n+    case 2:\n       return \"bmsk%? %0,%1,%Z2%&\";\n+    case 7: case 12:\n+     if (satisfies_constraint_C2p (operands[2]))\n+       {\n+\toperands[2] = GEN_INT ((~INTVAL (operands[2])));\n+\treturn \"bmskn%? %0,%1,%Z2%&\";\n+       }\n+     else\n+       {\n+\treturn \"bmsk%? %0,%1,%Z2%&\";\n+       }\n     case 3: case 8: case 13:\n       return \"bclr%? %0,%1,%M2%&\";\n     case 4:\n@@ -3368,15 +3389,15 @@\n ;; modifed cc user if second, but not first operand is a compact register.\n (define_insn \"cmpsi_cc_insn_mixed\"\n   [(set (reg:CC CC_REG)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"Rcq#q,c,c, qRcq, c\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"cO,cI,cL,  Cal, Cal\")))]\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"Rcq#q,  h, c, c,qRcq,c\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\"   \"cO,Cm1,cI,cL, Cal,Cal\")))]\n   \"\"\n   \"cmp%? %0,%B1%&\"\n   [(set_attr \"type\" \"compare\")\n-   (set_attr \"iscompact\" \"true,false,false,true_limm,false\")\n-   (set_attr \"predicable\" \"no,no,yes,no,yes\")\n+   (set_attr \"iscompact\" \"true,true,false,false,true_limm,false\")\n+   (set_attr \"predicable\" \"no,no,no,yes,no,yes\")\n    (set_attr \"cond\" \"set\")\n-   (set_attr \"length\" \"*,4,4,*,8\")])\n+   (set_attr \"length\" \"*,*,4,4,*,8\")])\n \n (define_insn \"*cmpsi_cc_zn_insn\"\n   [(set (reg:CC_ZN CC_REG)\n@@ -3452,14 +3473,14 @@\n \n (define_insn \"*cmpsi_cc_c_insn\"\n   [(set (reg:CC_C CC_REG)\n-\t(compare:CC_C (match_operand:SI 0 \"register_operand\"  \"Rcqq, c,Rcqq,  c\")\n-\t\t      (match_operand:SI 1 \"nonmemory_operand\" \"cO,  cI, Cal,Cal\")))]\n+\t(compare:CC_C (match_operand:SI 0 \"register_operand\"  \"Rcqq,  h, c,Rcqq,  c\")\n+\t\t      (match_operand:SI 1 \"nonmemory_operand\"   \"cO,Cm1,cI, Cal,Cal\")))]\n   \"\"\n   \"cmp%? %0,%S1%&\"\n   [(set_attr \"type\" \"compare\")\n-   (set_attr \"iscompact\" \"true,false,true_limm,false\")\n+   (set_attr \"iscompact\" \"true,true,false,true_limm,false\")\n    (set_attr \"cond\" \"set\")\n-   (set_attr \"length\" \"*,4,*,8\")])\n+   (set_attr \"length\" \"*,*,4,*,8\")])\n \n ;; Next come the scc insns.\n \n@@ -3552,17 +3573,20 @@\n ; cond_exec patterns\n (define_insn \"*movsi_ne\"\n   [(cond_exec\n-     (ne (match_operand:CC_Z 2 \"cc_use_register\" \"Rcc,Rcc,Rcc\") (const_int 0))\n-     (set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcq#q,w,w\")\n-\t  (match_operand:SI 1 \"nonmemory_operand\" \"C_0,Lc,?Cal\")))]\n+     (ne (match_operand:CC_Z 2 \"cc_use_register\"    \"Rcc,  Rcc,  Rcc,Rcc,Rcc\") (const_int 0))\n+     (set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcq#q,Rcq#q,Rcq#q,  w,w\")\n+\t  (match_operand:SI 1 \"nonmemory_operand\"   \"C_0,    h, ?Cal, Lc,?Cal\")))]\n   \"\"\n   \"@\n \t* current_insn_predicate = 0; return \\\"sub%?.ne %0,%0,%0%&\\\";\n+\t* current_insn_predicate = 0; return \\\"mov%?.ne %0,%1\\\";\n+\t* current_insn_predicate = 0; return \\\"mov%?.ne %0,%1\\\";\n \tmov.ne %0,%1\n \tmov.ne %0,%S1\"\n-  [(set_attr \"type\" \"cmove,cmove,cmove\")\n-   (set_attr \"iscompact\" \"true,false,false\")\n-   (set_attr \"length\" \"2,4,8\")])\n+  [(set_attr \"type\" \"cmove\")\n+   (set_attr \"iscompact\" \"true,true,true_limm,false,false\")\n+   (set_attr \"length\" \"2,2,6,4,8\")\n+   (set_attr \"cpu_facility\" \"*,av2,av2,*,*\")])\n \n (define_insn \"*movsi_cond_exec\"\n   [(cond_exec"}, {"sha": "b7bf2d39c4e880e2e558b36d485f0958538fe1ff", "filename": "gcc/config/arc/constraints.md", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fconstraints.md?ref=fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "patch": "@@ -226,6 +226,14 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival && IS_POWEROF2_P (ival + 1)\")))\n \n+(define_constraint \"C2p\"\n+ \"@internal\n+  constant such that (~x)+1 is a power of two, and x < -1\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_V2\n+\t\t    && (ival < -1)\n+\t\t    && IS_POWEROF2_P ((~ival) + 1)\")))\n+\n (define_constraint \"C3p\"\n  \"@internal\n   constant int used to select xbfu a,b,u6 instruction.  The values accepted are 1 and 2.\"\n@@ -317,7 +325,13 @@\n   \"@internal\n    A valid memory operand for ARCompact load instructions\"\n   (and (match_code \"mem\")\n-       (match_test \"compact_load_memory_operand (op, VOIDmode)\")))\n+       (match_test \"compact_memory_operand_p (op, mode, false, false)\")))\n+\n+(define_memory_constraint \"Uts\"\n+  \"@internal\n+   A valid memory operand for ARCompact load instructions scaled\"\n+  (and (match_code \"mem\")\n+       (match_test \"compact_memory_operand_p (op, mode, false, TARGET_CODE_DENSITY)\")))\n \n (define_memory_constraint \"S\"\n   \"@internal\n@@ -340,7 +354,7 @@\n    \"@internal\n     A valid _small-data_ memory operand for ARCompact instructions\"\n    (and (match_code \"mem\")\n-        (match_test \"compact_sda_memory_operand (op, VOIDmode)\")))\n+\t(match_test \"compact_sda_memory_operand (op, VOIDmode)\")))\n \n (define_memory_constraint \"Usc\"\n   \"@internal\n@@ -483,12 +497,26 @@\n   (and (match_code \"const_int\")\n        (match_test \"IS_ZERO (ival)\")))\n \n+(define_constraint \"Cm1\"\n+  \"@internal\n+   Integer signed constant in the interval [-1,6]\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival >= -1) && (ival <=6)\")\n+       (match_test \"TARGET_V2\")))\n+\n (define_constraint \"Cm2\"\n   \"@internal\n    A signed 9-bit integer constant.\"\n   (and (match_code \"const_int\")\n        (match_test \"(ival >= -256) && (ival <=255)\")))\n \n+(define_constraint \"Cm3\"\n+  \"@internal\n+   A signed 6-bit integer constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival >= -32) && (ival <=31)\")\n+       (match_test \"TARGET_V2\")))\n+\n (define_constraint \"C62\"\n   \"@internal\n    An unsigned 6-bit integer constant, up to 62.\"\n@@ -511,3 +539,32 @@\n    An unsigned 16-bit integer constant\"\n   (and (match_code \"const_int\")\n        (match_test \"UNSIGNED_INT16 (ival)\")))\n+\n+; Memory addresses suited for code density load ops\n+(define_memory_constraint \"Ucd\"\n+  \"@internal\n+   A valid memory operand for use with code density load ops\"\n+  (and (match_code \"mem\")\n+       (match_test \"compact_memory_operand_p (op, mode, true, false)\")\n+       (match_test \"TARGET_V2\")))\n+\n+(define_register_constraint \"h\"\n+  \"TARGET_V2 ? AC16_H_REGS : NO_REGS\"\n+  \"5-bit h register set except @code{r30} and @code{r29}:\n+   @code{r0}-@code{r31}, nonfixed core register\")\n+\n+; Code density registers\n+(define_register_constraint \"Rcd\"\n+  \"TARGET_CODE_DENSITY ? R0R3_CD_REGS : NO_REGS\"\n+  \"@internal\n+   core register @code{r0}-@code{r3}\")\n+\n+(define_register_constraint \"Rsd\"\n+  \"TARGET_CODE_DENSITY ? R0R1_CD_REGS : NO_REGS\"\n+  \"@internal\n+   core register @code{r0}-@code{r1}\")\n+\n+(define_register_constraint \"Rzd\"\n+  \"TARGET_CODE_DENSITY ? R0_REGS : NO_REGS\"\n+  \"@internal\n+   @code{r0} register for code density instructions.\")"}, {"sha": "f85f931d46011af6ed0533e38be455af5cede4e1", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "patch": "@@ -184,95 +184,6 @@\n   }\n )\n \n-;; Return true if OP is an acceptable memory operand for ARCompact\n-;; 16-bit load instructions.\n-(define_predicate \"compact_load_memory_operand\"\n-  (match_code \"mem\")\n-{\n-  rtx addr, plus0, plus1;\n-  int size, off;\n-\n-  /* Eliminate non-memory operations.  */\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  /* .di instructions have no 16-bit form.  */\n-  if (MEM_VOLATILE_P (op) && !TARGET_VOLATILE_CACHE_SET)\n-     return 0;\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  size = GET_MODE_SIZE (mode);\n-\n-  /* dword operations really put out 2 instructions, so eliminate them.  */\n-  if (size > UNITS_PER_WORD)\n-    return 0;\n-\n-  /* Decode the address now.  */\n-  addr = XEXP (op, 0);\n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      return (REGNO (addr) >= FIRST_PSEUDO_REGISTER\n-\t      || COMPACT_GP_REG_P (REGNO (addr))\n-\t      || (SP_REG_P (REGNO (addr)) && (size != 2)));\n-\t/* Reverting for the moment since ldw_s does not have sp as a valid\n-\t   parameter.  */\n-    case PLUS:\n-      plus0 = XEXP (addr, 0);\n-      plus1 = XEXP (addr, 1);\n-\n-      if ((GET_CODE (plus0) == REG)\n-\t  && ((REGNO (plus0) >= FIRST_PSEUDO_REGISTER)\n-\t      || COMPACT_GP_REG_P (REGNO (plus0)))\n-\t  && ((GET_CODE (plus1) == REG)\n-\t      && ((REGNO (plus1) >= FIRST_PSEUDO_REGISTER)\n-\t\t  || COMPACT_GP_REG_P (REGNO (plus1)))))\n-\t{\n-\t  return 1;\n-\t}\n-\n-      if ((GET_CODE (plus0) == REG)\n-\t  && ((REGNO (plus0) >= FIRST_PSEUDO_REGISTER)\n-\t      || COMPACT_GP_REG_P (REGNO (plus0)))\n-\t  && (GET_CODE (plus1) == CONST_INT))\n-\t{\n-\t  off = INTVAL (plus1);\n-\n-\t  /* Negative offset is not supported in 16-bit load/store insns.  */\n-\t  if (off < 0)\n-\t    return 0;\n-\n-\t  switch (size)\n-\t    {\n-\t    case 1:\n-\t      return (off < 32);\n-\t    case 2:\n-\t      return ((off < 64) && (off % 2 == 0));\n-\t    case 4:\n-\t      return ((off < 128) && (off % 4 == 0));\n-\t    }\n-\t}\n-\n-      if ((GET_CODE (plus0) == REG)\n-\t  && ((REGNO (plus0) >= FIRST_PSEUDO_REGISTER)\n-\t      || SP_REG_P (REGNO (plus0)))\n-\t  && (GET_CODE (plus1) == CONST_INT))\n-\t{\n-\t  off = INTVAL (plus1);\n-\t  return ((size != 2) && (off >= 0 && off < 128) && (off % 4 == 0));\n-\t}\n-    default:\n-      break ;\n-      /* TODO: 'gp' and 'pcl' are to supported as base address operand\n-\t       for 16-bit load instructions.  */\n-    }\n-  return 0;\n-\n-}\n-)\n-\n ;; Return true if OP is an acceptable memory operand for ARCompact\n ;; 16-bit store instructions\n (define_predicate \"compact_store_memory_operand\""}]}