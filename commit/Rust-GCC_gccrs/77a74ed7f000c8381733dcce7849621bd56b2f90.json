{"sha": "77a74ed7f000c8381733dcce7849621bd56b2f90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdhNzRlZDdmMDAwYzgzODE3MzNkY2NlNzg0OTYyMWJkNTZiMmY5MA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-10-21T13:08:28Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-10-21T13:08:28Z"}, "message": "basic-block.h (single_succ_edge): Use gcc_checking_assert.\n\n\t* basic-block.h (single_succ_edge): Use gcc_checking_assert.\n\t(single_pred_edge, ei_container, ei_next, ei_prev): Likewise.\n\t* cfghooks.c (fixup_reorder_chain): Likewise.\n\t* cfgrtl.c (cfg_layout_merge_blocks): Likewise.\n\t* cgraph.c (cgraph_add_thunk): Likewise.\n\t(cgraph_create_edge_1): Likewise.\n\t(cgraph_create_virtual_clone): Likewise.\n\t* ddg.c (add_cross_iteration_register_deps): Likewise.\n\t* dwarf2out.c (modified_type_die): Likewise.\n\t* emit-rtl.c (set_mem_alias_set): Likewise.\n\t* ggc-zone.c (zone_allocate_marks): Likewise.\n\t* gimple-iterator.c (gsi_move_to_bb_end): Likewise.\n\t* gimple.c (iterative_hash_gimple_type): Likewise.\n\t* graphite-scop-detection.c (create_single_entry_edge): Likewise.\n\t(create_single_exit_edge): Likewise.\n\t* haifa-sched.c (choose_ready): Likewise.\n\t* lto-streamer-in.c (input_gimple_stmt): Likewise.\n\t* passes.c (execute_todo): Likewise.\n\t* sched-ebb.c (begin_schedule_ready): Likewise.\n\t* sel-sched.c (code_motion_process_successors): Likewise.\n\t* tree-call-cdce.c (gen_conditions_for_pow): Likewise.\n\t* tree-cfg-cleanup.c (tree_forwarder_block_p): Likewise.\n\t* tree-flow-inline.h (link_imm_use, move_use_after_head): Likewise.\n\t(phi_arg_index_from_use, phi_ssa_name_p): Likewise.\n\t* tree-into-ssa.c (insert_updated_phi_nodes_for): Likewise.\n\t* tree-ssa-coalesce.c (ssa_conflicts_test_p): Likewise.\n\t(ssa_conflicts_add): Likewise.\n\t* tree-ssa-copy.c (replace_exp): Likewise.\n\t* tree-ssa-dom.c (eliminate_redundant_computations): Likewise.\n\t* tree-ssa-forwprop.c (simple_gimple_switch): Likewise.\n\t* tree-ssa-math-opts.c (execute_cse_reciprocals): Likewise.\n\t* tree-ssa-pre.c (bitmap_value_insert_into_set): Likewise.\n\t(compute_antic): Likewise.\n\t* tree-ssa-ter.c (add_to_partition_kill_list): Likewise.\n\t(add_dependence): Likewise.\n\t(process_replaceable, kill_expr, find_replaceable_exprs): Likewise.\n\t* tree-vrp.c (supports_overflow_infinity): Likewise.\n\t(make_overflow_infinity, negative_overflow_infinity): Likewise.\n\t(avoid_overflow_infinity, register_new_assert_for): Likewise.\n\t(process_assert_insertions_for): Likewise.\n\t* var-tracking.c (dv_is_value_p, dv_as_decl, dv_from_decl): Likewise.\n\t(dv_from_value, variable_union, find_loc_in_1pdv): Likewise.\n\t(intersect_loc_chains, variable_merge_over_cur): Likewise.\n\nFrom-SVN: r165774", "tree": {"sha": "3fd18866b18d41be7c750796537c0bd5af606091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fd18866b18d41be7c750796537c0bd5af606091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77a74ed7f000c8381733dcce7849621bd56b2f90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a74ed7f000c8381733dcce7849621bd56b2f90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77a74ed7f000c8381733dcce7849621bd56b2f90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a74ed7f000c8381733dcce7849621bd56b2f90/comments", "author": null, "committer": null, "parents": [{"sha": "31ff2426f662ec821ef48bee12eb3f08e4e16d9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31ff2426f662ec821ef48bee12eb3f08e4e16d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31ff2426f662ec821ef48bee12eb3f08e4e16d9b"}], "stats": {"total": 397, "additions": 159, "deletions": 238}, "files": [{"sha": "d9316e0e9f1dd0b08ae235442befa6b8613f1ba6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -1,3 +1,49 @@\n+2010-10-21  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* basic-block.h (single_succ_edge): Use gcc_checking_assert.\n+\t(single_pred_edge, ei_container, ei_next, ei_prev): Likewise.\n+\t* cfghooks.c (fixup_reorder_chain): Likewise.\n+\t* cfgrtl.c (cfg_layout_merge_blocks): Likewise.\n+\t* cgraph.c (cgraph_add_thunk): Likewise.\n+\t(cgraph_create_edge_1): Likewise.\n+\t(cgraph_create_virtual_clone): Likewise.\n+\t* ddg.c (add_cross_iteration_register_deps): Likewise.\n+\t* dwarf2out.c (modified_type_die): Likewise.\n+\t* emit-rtl.c (set_mem_alias_set): Likewise.\n+\t* ggc-zone.c (zone_allocate_marks): Likewise.\n+\t* gimple-iterator.c (gsi_move_to_bb_end): Likewise.\n+\t* gimple.c (iterative_hash_gimple_type): Likewise.\n+\t* graphite-scop-detection.c (create_single_entry_edge): Likewise.\n+\t(create_single_exit_edge): Likewise.\n+\t* haifa-sched.c (choose_ready): Likewise.\n+\t* lto-streamer-in.c (input_gimple_stmt): Likewise.\n+\t* passes.c (execute_todo): Likewise.\n+\t* sched-ebb.c (begin_schedule_ready): Likewise.\n+\t* sel-sched.c (code_motion_process_successors): Likewise.\n+\t* tree-call-cdce.c (gen_conditions_for_pow): Likewise.\n+\t* tree-cfg-cleanup.c (tree_forwarder_block_p): Likewise.\n+\t* tree-flow-inline.h (link_imm_use, move_use_after_head): Likewise.\n+\t(phi_arg_index_from_use, phi_ssa_name_p): Likewise.\n+\t* tree-into-ssa.c (insert_updated_phi_nodes_for): Likewise.\n+\t* tree-ssa-coalesce.c (ssa_conflicts_test_p): Likewise.\n+\t(ssa_conflicts_add): Likewise.\n+\t* tree-ssa-copy.c (replace_exp): Likewise.\n+\t* tree-ssa-dom.c (eliminate_redundant_computations): Likewise.\n+\t* tree-ssa-forwprop.c (simple_gimple_switch): Likewise.\n+\t* tree-ssa-math-opts.c (execute_cse_reciprocals): Likewise.\n+\t* tree-ssa-pre.c (bitmap_value_insert_into_set): Likewise.\n+\t(compute_antic): Likewise.\n+\t* tree-ssa-ter.c (add_to_partition_kill_list): Likewise.\n+\t(add_dependence): Likewise.\n+\t(process_replaceable, kill_expr, find_replaceable_exprs): Likewise.\n+\t* tree-vrp.c (supports_overflow_infinity): Likewise.\n+\t(make_overflow_infinity, negative_overflow_infinity): Likewise.\n+\t(avoid_overflow_infinity, register_new_assert_for): Likewise.\n+\t(process_assert_insertions_for): Likewise.\n+\t* var-tracking.c (dv_is_value_p, dv_as_decl, dv_from_decl): Likewise.\n+\t(dv_from_value, variable_union, find_loc_in_1pdv): Likewise.\n+\t(intersect_loc_chains, variable_merge_over_cur): Likewise.\n+\n 2010-10-21  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* cfgloop.c (flow_loops_find): Call bb_has_abnormal_pred."}, {"sha": "f175208cfd3a71632aa31283f5d47e3a257106ef", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -560,9 +560,7 @@ single_pred_p (const_basic_block bb)\n static inline edge\n single_succ_edge (const_basic_block bb)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (single_succ_p (bb));\n-#endif\n+  gcc_checking_assert (single_succ_p (bb));\n   return EDGE_SUCC (bb, 0);\n }\n \n@@ -572,9 +570,7 @@ single_succ_edge (const_basic_block bb)\n static inline edge\n single_pred_edge (const_basic_block bb)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (single_pred_p (bb));\n-#endif\n+  gcc_checking_assert (single_pred_p (bb));\n   return EDGE_PRED (bb, 0);\n }\n \n@@ -606,9 +602,7 @@ typedef struct {\n static inline VEC(edge,gc) *\n ei_container (edge_iterator i)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (i.container);\n-#endif\n+  gcc_checking_assert (i.container);\n   return *i.container;\n }\n \n@@ -659,19 +653,15 @@ ei_one_before_end_p (edge_iterator i)\n static inline void\n ei_next (edge_iterator *i)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (i->index < EDGE_COUNT (ei_container (*i)));\n-#endif\n+  gcc_checking_assert (i->index < EDGE_COUNT (ei_container (*i)));\n   i->index++;\n }\n \n /* Move the iterator to the previous element.  */\n static inline void\n ei_prev (edge_iterator *i)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (i->index > 0);\n-#endif\n+  gcc_checking_assert (i->index > 0);\n   i->index--;\n }\n "}, {"sha": "c6e4bc0331338d7fb2224184d8a7865b88076548", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -906,9 +906,7 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n   if (bb->count < new_count)\n     new_count = bb->count;\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (can_duplicate_block_p (bb));\n-#endif\n+  gcc_checking_assert (can_duplicate_block_p (bb));\n \n   new_bb = cfg_hooks->duplicate_block (bb);\n   if (after)"}, {"sha": "8a0d35cb6198d5ea0baf93b10d625483a90ef87b", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -828,10 +828,8 @@ fixup_reorder_chain (void)\n \t\t\t\t       : label_for_bb (e_fall->dest)), 0))\n \t\t    {\n \t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n-#ifdef ENABLE_CHECKING\n-\t\t      gcc_assert (could_fall_through\n-\t\t\t\t  (e_taken->src, e_taken->dest));\n-#endif\n+\t\t      gcc_checking_assert (could_fall_through\n+\t\t\t\t\t   (e_taken->src, e_taken->dest));\n \t\t      e_taken->flags |= EDGE_FALLTHRU;\n \t\t      update_br_prob_note (bb);\n \t\t      e = e_fall, e_fall = e_taken, e_taken = e;\n@@ -852,10 +850,8 @@ fixup_reorder_chain (void)\n \t\t\t\t     : label_for_bb (e_fall->dest)), 0))\n \t\t{\n \t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n-#ifdef ENABLE_CHECKING\n-\t\t  gcc_assert (could_fall_through\n-\t\t\t      (e_taken->src, e_taken->dest));\n-#endif\n+\t\t  gcc_checking_assert (could_fall_through\n+\t\t\t\t       (e_taken->src, e_taken->dest));\n \t\t  e_taken->flags |= EDGE_FALLTHRU;\n \t\t  update_br_prob_note (bb);\n \t\t  continue;"}, {"sha": "a158112ee055a17b4bbe5fdff3ff80ae03751d8c", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -2692,9 +2692,7 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n static void\n cfg_layout_merge_blocks (basic_block a, basic_block b)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (cfg_layout_can_merge_blocks_p (a, b));\n-#endif\n+  gcc_checking_assert (cfg_layout_can_merge_blocks_p (a, b));\n \n   if (dump_file)\n     fprintf (dump_file, \"merging block %d into block %d\\n\", b->index, a->index);"}, {"sha": "e1f47c29dad6a29d51a053f2291dc23ef2f83eb9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -594,10 +594,9 @@ cgraph_add_thunk (tree alias, tree decl, bool this_adjusting,\n   \n   node = cgraph_same_body_alias_1 (alias, decl);\n   gcc_assert (node);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (!virtual_offset\n-  \t      || tree_int_cst_equal (virtual_offset, size_int (virtual_value)));\n-#endif\n+  gcc_checking_assert (!virtual_offset\n+\t\t       || tree_int_cst_equal (virtual_offset,\n+\t\t\t\t\t      size_int (virtual_value)));\n   node->thunk.fixed_offset = fixed_offset;\n   node->thunk.this_adjusting = this_adjusting;\n   node->thunk.virtual_value = virtual_value;\n@@ -984,11 +983,9 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n      have not been loaded yet.  */\n   if (call_stmt)\n     {\n-#ifdef ENABLE_CHECKING\n-      /* This is rather pricely check possibly trigerring construction of\n-\t call stmt hashtable.  */\n-      gcc_assert (!cgraph_edge (caller, call_stmt));\n-#endif\n+      /* This is a rather expensive check possibly trigerring\n+\t construction of call stmt hashtable.  */\n+      gcc_checking_assert (!cgraph_edge (caller, call_stmt));\n \n       gcc_assert (is_gimple_call (call_stmt));\n     }\n@@ -2258,10 +2255,8 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   size_t i;\n   struct ipa_replace_map *map;\n \n-#ifdef ENABLE_CHECKING\n   if (!flag_wpa)\n-    gcc_assert  (tree_versionable_function_p (old_decl));\n-#endif\n+    gcc_checking_assert  (tree_versionable_function_p (old_decl));\n \n   /* Make a new FUNCTION_DECL tree node */\n   if (!args_to_skip)"}, {"sha": "d7b093b94142d621d03a4d911a9431ea5a46d458", "filename": "gcc/ddg.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -262,10 +262,9 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n   gcc_assert (last_def_node);\n   gcc_assert (first_def);\n \n-#ifdef ENABLE_CHECKING\n   if (DF_REF_ID (last_def) != DF_REF_ID (first_def))\n-    gcc_assert (!bitmap_bit_p (&bb_info->gen, DF_REF_ID (first_def)));\n-#endif\n+    gcc_checking_assert (!bitmap_bit_p (&bb_info->gen,\n+\t\t\t\t\tDF_REF_ID (first_def)));\n \n   /* Create inter-loop true dependences and anti dependences.  */\n   for (r_use = DF_REF_CHAIN (last_def); r_use != NULL; r_use = r_use->next)"}, {"sha": "33a7b561c4de57bacb056242185f72731663fafb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -12715,15 +12715,14 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n       && TYPE_NAME (qualified_type)\n       && TREE_CODE (TYPE_NAME (qualified_type)) == TYPE_DECL)\n     {\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (TREE_CODE (TREE_TYPE (TYPE_NAME (qualified_type)))\n-\t\t  == INTEGER_TYPE\n-\t\t  && TYPE_PRECISION (TREE_TYPE (TYPE_NAME (qualified_type)))\n-\t\t     == TYPE_PRECISION (qualified_type)\n-\t\t  && TYPE_UNSIGNED (TREE_TYPE (TYPE_NAME (qualified_type)))\n-\t\t     == TYPE_UNSIGNED (qualified_type));\n-#endif\n-      qualified_type = TREE_TYPE (TYPE_NAME (qualified_type));\n+      tree t = TREE_TYPE (TYPE_NAME (qualified_type));\n+\n+      gcc_checking_assert (TREE_CODE (t) == INTEGER_TYPE\n+\t\t\t   && TYPE_PRECISION (t)\n+\t\t\t   == TYPE_PRECISION (qualified_type)\n+\t\t\t   && TYPE_UNSIGNED (t)\n+\t\t\t   == TYPE_UNSIGNED (qualified_type));\n+      qualified_type = t;\n     }\n \n   /* If we do, then we can just use its DIE, if it exists.  */"}, {"sha": "19d290c4b2c3b7b4b4951b3041a7bbd5de8bbd5f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -1839,10 +1839,8 @@ set_mem_attributes (rtx ref, tree t, int objectp)\n void\n set_mem_alias_set (rtx mem, alias_set_type set)\n {\n-#ifdef ENABLE_CHECKING\n   /* If the new and old alias sets don't conflict, something is wrong.  */\n-  gcc_assert (alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)));\n-#endif\n+  gcc_checking_assert (alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)));\n \n   MEM_ATTRS (mem) = get_mem_attrs (set, MEM_EXPR (mem), MEM_OFFSET (mem),\n \t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem),"}, {"sha": "7d8420a11b7f331fa789261b7004b41db89052cc", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -802,9 +802,7 @@ zone_allocate_marks (void)\n \t  n++;\n #endif\n \t}\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (n == zone->n_small_pages);\n-#endif\n+      gcc_checking_assert (n == zone->n_small_pages);\n     }\n \n   /* We don't collect the PCH zone, but we do have to mark it"}, {"sha": "d654f2fa28de2dffc5743e5445ebafe23ac53d9b", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -597,9 +597,7 @@ void\n gsi_move_to_bb_end (gimple_stmt_iterator *from, basic_block bb)\n {\n   gimple_stmt_iterator last = gsi_last_bb (bb);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (gsi_bb (last) == bb);\n-#endif\n+  gcc_checking_assert (gsi_bb (last) == bb);\n \n   /* Have to check gsi_end_p because it could be an empty block.  */\n   if (!gsi_end_p (last) && is_ctrl_stmt (gsi_stmt (last)))"}, {"sha": "6547567bdd4e5e9d79fde0ec3142368380b2d9b5", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -3999,10 +3999,8 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n   void **slot;\n   struct sccs *state;\n \n-#ifdef ENABLE_CHECKING\n   /* Not visited during this DFS walk.  */\n-  gcc_assert (!pointer_map_contains (sccstate, type));\n-#endif\n+  gcc_checking_assert (!pointer_map_contains (sccstate, type));\n   state = XOBNEW (sccstate_obstack, struct sccs);\n   *pointer_map_insert (sccstate, type) = state;\n "}, {"sha": "7110efe0a08367648bcfccb97b06310d42c4693d", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -899,9 +899,7 @@ create_single_entry_edge (sd_region *region)\n        single edge pointing from outside into the loop.  */\n     gcc_unreachable ();\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (find_single_entry_edge (region));\n-#endif\n+  gcc_checking_assert (find_single_entry_edge (region));\n }\n \n /* Check if the sd_region, mentioned in EDGE, has no exit bb.  */\n@@ -967,9 +965,7 @@ create_single_exit_edge (sd_region *region)\n     if (e->aux)\n       ((sd_region *) e->aux)->exit = forwarder->dest;\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (find_single_exit_edge (region));\n-#endif\n+  gcc_checking_assert (find_single_exit_edge (region));\n }\n \n /* Unmark the exit edges of all REGIONS."}, {"sha": "40f125de3c7953baee07a9b9b3ed051949146f09", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -2727,14 +2727,12 @@ choose_ready (struct ready_list *ready, rtx *insn_ptr)\n \t  {\n \t    insn = ready_element (ready, i);\n \n-#ifdef ENABLE_CHECKING\n \t    /* If this insn is recognizable we should have already\n \t       recognized it earlier.\n \t       ??? Not very clear where this is supposed to be done.\n \t       See dep_cost_1.  */\n-\t    gcc_assert (INSN_CODE (insn) >= 0\n-\t\t\t|| recog_memoized (insn) < 0);\n-#endif\n+\t    gcc_checking_assert (INSN_CODE (insn) >= 0\n+\t\t\t\t || recog_memoized (insn) < 0);\n \n \t    ready_try [i]\n \t      = (/* INSN_CODE check can be omitted here as it is also done later"}, {"sha": "50352e896a2a61e5b97d6a8e4e569a14fb396142", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -973,9 +973,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t\t     to unify some types and thus not find a proper\n \t\t     field-decl here.  So only assert here if checking\n \t\t     is enabled.  */\n-#ifdef ENABLE_CHECKING\n-\t\t  gcc_assert (tem != NULL_TREE);\n-#endif\n+\t\t  gcc_checking_assert (tem != NULL_TREE);\n \t\t  if (tem != NULL_TREE)\n \t\t    TREE_OPERAND (op, 1) = tem;\n \t\t}"}, {"sha": "1ee3400e0cac15bf66dcd31d880cdb3cdbaa03bb", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -1310,9 +1310,7 @@ execute_todo (unsigned int flags)\n static void\n verify_interpass_invariants (void)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (!fold_deferring_overflow_warnings_p ());\n-#endif\n+  gcc_checking_assert (!fold_deferring_overflow_warnings_p ());\n }\n \n /* Clear the last verified flag.  */"}, {"sha": "8090898f8ed88131e09780c7e9a54c1551b5336f", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -147,24 +147,22 @@ begin_schedule_ready (rtx insn, rtx last)\n \n       e = find_fallthru_edge (last_bb->succs);\n \n-#ifdef ENABLE_CHECKING\n-      gcc_assert (!e || !(e->flags & EDGE_COMPLEX));\n+      gcc_checking_assert (!e || !(e->flags & EDGE_COMPLEX));\n \n-      gcc_assert (BLOCK_FOR_INSN (insn) == last_bb\n-\t\t  && !IS_SPECULATION_CHECK_P (insn)\n-\t\t  && BB_HEAD (last_bb) != insn\n-\t\t  && BB_END (last_bb) == insn);\n+      gcc_checking_assert (BLOCK_FOR_INSN (insn) == last_bb\n+\t\t\t   && !IS_SPECULATION_CHECK_P (insn)\n+\t\t\t   && BB_HEAD (last_bb) != insn\n+\t\t\t   && BB_END (last_bb) == insn);\n \n       {\n \trtx x;\n \n \tx = NEXT_INSN (insn);\n \tif (e)\n-\t  gcc_assert (NOTE_P (x) || LABEL_P (x));\n+\t  gcc_checking_assert (NOTE_P (x) || LABEL_P (x));\n \telse\n-\t  gcc_assert (BARRIER_P (x));\n+\t  gcc_checking_assert (BARRIER_P (x));\n       }\n-#endif\n \n       if (e)\n \t{"}, {"sha": "378e561bf59a3a93e639e4a3d31fc451bde2e23f", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -6360,20 +6360,18 @@ code_motion_process_successors (insn_t insn, av_set_t orig_ops,\n         goto rescan;\n     }\n \n-#ifdef ENABLE_CHECKING\n   /* Here, RES==1 if original expr was found at least for one of the\n      successors.  After the loop, RES may happen to have zero value\n      only if at some point the expr searched is present in av_set, but is\n      not found below.  In most cases, this situation is an error.\n      The exception is when the original operation is blocked by\n      bookkeeping generated for another fence or for another path in current\n      move_op.  */\n-  gcc_assert (res == 1\n-              || (res == 0\n-                  && av_set_could_be_blocked_by_bookkeeping_p (orig_ops,\n-\t\t\t\t\t\t\t       static_params))\n-              || res == -1);\n-#endif\n+  gcc_checking_assert (res == 1\n+\t\t       || (res == 0\n+\t\t\t   && av_set_could_be_blocked_by_bookkeeping_p (orig_ops,\n+\t\t\t\t\t\t\t\t\tstatic_params))\n+\t\t       || res == -1);\n \n   /* Merge data, clean up, etc.  */\n   if (res != -1 && code_motion_path_driver_info->after_merge_succs)"}, {"sha": "25476e61a09c9dff2236b5fb03c858a6d5c7fd8f", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -541,9 +541,7 @@ gen_conditions_for_pow (gimple pow_call, VEC (gimple, heap) *conds,\n   tree base, expn;\n   enum tree_code bc;\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (check_pow (pow_call));\n-#endif\n+  gcc_checking_assert (check_pow (pow_call));\n \n   *nconds = 0;\n "}, {"sha": "403566edd7df31c1dcbb96f00c27f387d216462b", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -279,9 +279,7 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n       || (single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n     return false;\n \n-#if ENABLE_CHECKING\n-  gcc_assert (bb != ENTRY_BLOCK_PTR);\n-#endif\n+  gcc_checking_assert (bb != ENTRY_BLOCK_PTR);\n \n   locus = single_succ_edge (bb)->goto_locus;\n "}, {"sha": "1a62cdd1f44f99455c3b0b52d9584434e657f4f9", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -230,10 +230,8 @@ link_imm_use (ssa_use_operand_t *linknode, tree def)\n   else\n     {\n       root = &(SSA_NAME_IMM_USE_NODE (def));\n-#ifdef ENABLE_CHECKING\n       if (linknode->use)\n         gcc_checking_assert (*(linknode->use) == def);\n-#endif\n       link_imm_use_to_list (linknode, root);\n     }\n }\n@@ -556,13 +554,11 @@ phi_arg_index_from_use (use_operand_p use)\n   root = gimple_phi_arg (phi, 0);\n   index = element - root;\n \n-#ifdef ENABLE_CHECKING\n   /* Make sure the calculation doesn't have any leftover bytes.  If it does,\n      then imm_use is likely not the first element in phi_arg_d.  */\n-  gcc_assert ((((char *)element - (char *)root)\n-\t       % sizeof (struct phi_arg_d)) == 0\n-\t      && index < gimple_phi_capacity (phi));\n-#endif\n+  gcc_checking_assert ((((char *)element - (char *)root)\n+\t\t\t% sizeof (struct phi_arg_d)) == 0\n+\t\t       && index < gimple_phi_capacity (phi));\n \n  return index;\n }\n@@ -613,9 +609,7 @@ phi_ssa_name_p (const_tree t)\n {\n   if (TREE_CODE (t) == SSA_NAME)\n     return true;\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (is_gimple_min_invariant (t));\n-#endif\n+  gcc_checking_assert (is_gimple_min_invariant (t));\n   return false;\n }\n \n@@ -975,9 +969,7 @@ static inline use_operand_p\n move_use_after_head (use_operand_p use_p, use_operand_p head,\n \t\t      use_operand_p last_p)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (USE_FROM_PTR (use_p) == USE_FROM_PTR (head));\n-#endif\n+  gcc_checking_assert (USE_FROM_PTR (use_p) == USE_FROM_PTR (head));\n   /* Skip head when we find it.  */\n   if (use_p != head)\n     {"}, {"sha": "91b5fc83667a146edd1801f79b246274df453980", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -2998,12 +2998,10 @@ insert_updated_phi_nodes_for (tree var, bitmap_head *dfs, bitmap blocks,\n   bitmap_iterator bi;\n   unsigned i;\n \n-#if defined ENABLE_CHECKING\n   if (TREE_CODE (var) == SSA_NAME)\n-    gcc_assert (is_old_name (var));\n+    gcc_checking_assert (is_old_name (var));\n   else\n-    gcc_assert (symbol_marked_for_renaming (var));\n-#endif\n+    gcc_checking_assert (symbol_marked_for_renaming (var));\n \n   /* Get all the definition sites for VAR.  */\n   db = find_def_blocks_for (var);"}, {"sha": "7615612e67bfbe0d52a8d8f2a5e2a036fe33d094", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -547,11 +547,9 @@ ssa_conflicts_test_p (ssa_conflicts_p ptr, unsigned x, unsigned y)\n {\n   bitmap b;\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (x < ptr->size);\n-  gcc_assert (y < ptr->size);\n-  gcc_assert (x != y);\n-#endif\n+  gcc_checking_assert (x < ptr->size);\n+  gcc_checking_assert (y < ptr->size);\n+  gcc_checking_assert (x != y);\n \n   b = ptr->conflicts[x];\n   if (b)\n@@ -579,11 +577,9 @@ ssa_conflicts_add_one (ssa_conflicts_p ptr, unsigned x, unsigned y)\n static inline void\n ssa_conflicts_add (ssa_conflicts_p ptr, unsigned x, unsigned y)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (x < ptr->size);\n-  gcc_assert (y < ptr->size);\n-  gcc_assert (x != y);\n-#endif\n+  gcc_checking_assert (x < ptr->size);\n+  gcc_checking_assert (y < ptr->size);\n+  gcc_checking_assert (x != y);\n   ssa_conflicts_add_one (ptr, x, y);\n   ssa_conflicts_add_one (ptr, y, x);\n }"}, {"sha": "a92b63be5f95b65ec94a1398026c5f3bd0964744", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -211,12 +211,10 @@ replace_exp (use_operand_p op_p, tree val)\n void\n propagate_tree_value (tree *op_p, tree val)\n {\n-#if defined ENABLE_CHECKING\n-  gcc_assert (!(TREE_CODE (val) == SSA_NAME\n-                && *op_p\n-\t\t&& TREE_CODE (*op_p) == SSA_NAME\n-\t\t&& !may_propagate_copy (*op_p, val)));\n-#endif\n+  gcc_checking_assert (!(TREE_CODE (val) == SSA_NAME\n+\t\t\t && *op_p\n+\t\t\t && TREE_CODE (*op_p) == SSA_NAME\n+\t\t\t && !may_propagate_copy (*op_p, val)));\n \n   if (TREE_CODE (val) == SSA_NAME)\n     *op_p = val;"}, {"sha": "bab6ced1c601bbd84d7c7aff8edc426b9c3c1ae2", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -1852,10 +1852,8 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi)\n            || useless_type_conversion_p (expr_type, TREE_TYPE (cached_lhs))))\n       || may_propagate_copy_into_stmt (stmt, cached_lhs))\n   {\n-#if defined ENABLE_CHECKING\n-      gcc_assert (TREE_CODE (cached_lhs) == SSA_NAME\n-\t\t  || is_gimple_min_invariant (cached_lhs));\n-#endif\n+      gcc_checking_assert (TREE_CODE (cached_lhs) == SSA_NAME\n+\t\t\t   || is_gimple_min_invariant (cached_lhs));\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{"}, {"sha": "f4808e78fffbb9786ed6f8d763b8a428aa17b6cd", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -1286,10 +1286,8 @@ simplify_gimple_switch (gimple stmt)\n \n \t      def = gimple_assign_rhs1 (def_stmt);\n \n-#ifdef ENABLE_CHECKING\n \t      /* ??? Why was Jeff testing this?  We are gimple...  */\n-\t      gcc_assert (is_gimple_val (def));\n-#endif\n+\t      gcc_checking_assert (is_gimple_val (def));\n \n \t      to = TREE_TYPE (cond);\n \t      ti = TREE_TYPE (def);"}, {"sha": "8f91bd699b8645f1462274b36f236bc00f482eb6", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -895,9 +895,7 @@ bitmap_value_insert_into_set (bitmap_set_t set, pre_expr expr)\n {\n   unsigned int val = get_expr_value_id (expr);\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (expr->id == get_or_alloc_expression_id (expr));\n-#endif\n+  gcc_checking_assert (expr->id == get_or_alloc_expression_id (expr));\n \n   /* Constant values are always considered to be part of the set.  */\n   if (value_id_constant_p (val))\n@@ -2608,10 +2606,8 @@ compute_antic (void)\n \t\t\t\t\t\t      block->index));\n \t    }\n \t}\n-#ifdef ENABLE_CHECKING\n       /* Theoretically possible, but *highly* unlikely.  */\n-      gcc_assert (num_iterations < 500);\n-#endif\n+      gcc_checking_assert (num_iterations < 500);\n     }\n \n   statistics_histogram_event (cfun, \"compute_antic iterations\",\n@@ -2640,10 +2636,8 @@ compute_antic (void)\n \t\t\t\t\t\t\t    block->index));\n \t\t}\n \t    }\n-#ifdef ENABLE_CHECKING\n \t  /* Theoretically possible, but *highly* unlikely.  */\n-\t  gcc_assert (num_iterations < 500);\n-#endif\n+\t  gcc_checking_assert (num_iterations < 500);\n \t}\n       statistics_histogram_event (cfun, \"compute_partial_antic iterations\",\n \t\t\t\t  num_iterations);"}, {"sha": "7bd766954fa2c8ffa32f3b4b1cb80eabe8f10013", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -296,9 +296,7 @@ add_to_partition_kill_list (temp_expr_table_p tab, int p, int ver)\n static inline void\n remove_from_partition_kill_list (temp_expr_table_p tab, int p, int version)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (tab->kill_list[p]);\n-#endif\n+  gcc_checking_assert (tab->kill_list[p]);\n   bitmap_clear_bit (tab->kill_list[p], version);\n   if (bitmap_empty_p (tab->kill_list[p]))\n     {\n@@ -345,10 +343,8 @@ add_dependence (temp_expr_table_p tab, int version, tree var)\n   else\n     {\n       i = var_to_partition (tab->map, var);\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (i != NO_PARTITION);\n-      gcc_assert (tab->num_in_part[i] != 0);\n-#endif\n+      gcc_checking_assert (i != NO_PARTITION);\n+      gcc_checking_assert (tab->num_in_part[i] != 0);\n       /* Only dependencies on ssa_names which are coalesced with something need\n          to be tracked.  Partitions with containing only a single SSA_NAME\n \t *cannot* have their value changed.  */\n@@ -479,9 +475,7 @@ process_replaceable (temp_expr_table_p tab, gimple stmt, int call_cnt)\n   ssa_op_iter iter;\n   bitmap def_vars, use_vars;\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (is_replaceable_p (stmt));\n-#endif\n+  gcc_checking_assert (is_replaceable_p (stmt));\n \n   def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n   version = SSA_NAME_VERSION (def);\n@@ -534,9 +528,7 @@ kill_expr (temp_expr_table_p tab, int partition)\n       finished_with_expr (tab, version, true);\n     }\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (!tab->kill_list[partition]);\n-#endif\n+  gcc_checking_assert (!tab->kill_list[partition]);\n }\n \n \n@@ -704,9 +696,7 @@ find_replaceable_exprs (var_map map)\n   FOR_EACH_BB (bb)\n     {\n       find_replaceable_in_bb (table, bb);\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (bitmap_empty_p (table->partition_in_use));\n-#endif\n+      gcc_checking_assert (bitmap_empty_p (table->partition_in_use));\n     }\n \n   ret = free_temp_expr_table (table);"}, {"sha": "8ab986ef1bd107db2efd0049566c50039a912fa3", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -243,9 +243,7 @@ supports_overflow_infinity (const_tree type)\n static inline tree\n make_overflow_infinity (tree val)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (val != NULL_TREE && CONSTANT_CLASS_P (val));\n-#endif\n+  gcc_checking_assert (val != NULL_TREE && CONSTANT_CLASS_P (val));\n   val = copy_node (val);\n   TREE_OVERFLOW (val) = 1;\n   return val;\n@@ -256,9 +254,7 @@ make_overflow_infinity (tree val)\n static inline tree\n negative_overflow_infinity (tree type)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (supports_overflow_infinity (type));\n-#endif\n+  gcc_checking_assert (supports_overflow_infinity (type));\n   return make_overflow_infinity (vrp_val_min (type));\n }\n \n@@ -267,9 +263,7 @@ negative_overflow_infinity (tree type)\n static inline tree\n positive_overflow_infinity (tree type)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (supports_overflow_infinity (type));\n-#endif\n+  gcc_checking_assert (supports_overflow_infinity (type));\n   return make_overflow_infinity (vrp_val_max (type));\n }\n \n@@ -332,9 +326,7 @@ avoid_overflow_infinity (tree val)\n     return vrp_val_max (TREE_TYPE (val));\n   else\n     {\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (vrp_val_is_min (val));\n-#endif\n+      gcc_checking_assert (vrp_val_is_min (val));\n       return vrp_val_min (TREE_TYPE (val));\n     }\n }\n@@ -4131,13 +4123,11 @@ register_new_assert_for (tree name, tree expr,\n   assert_locus_t n, loc, last_loc;\n   basic_block dest_bb;\n \n-#if defined ENABLE_CHECKING\n-  gcc_assert (bb == NULL || e == NULL);\n+  gcc_checking_assert (bb == NULL || e == NULL);\n \n   if (e == NULL)\n-    gcc_assert (gimple_code (gsi_stmt (si)) != GIMPLE_COND\n-\t\t&& gimple_code (gsi_stmt (si)) != GIMPLE_SWITCH);\n-#endif\n+    gcc_checking_assert (gimple_code (gsi_stmt (si)) != GIMPLE_COND\n+\t\t\t && gimple_code (gsi_stmt (si)) != GIMPLE_SWITCH);\n \n   /* Never build an assert comparing against an integer constant with\n      TREE_OVERFLOW set.  This confuses our undefined overflow warning\n@@ -5059,10 +5049,9 @@ process_assert_insertions_for (tree name, assert_locus_t loc)\n     {\n       /* We have been asked to insert the assertion on an edge.  This\n \t is used only by COND_EXPR and SWITCH_EXPR assertions.  */\n-#if defined ENABLE_CHECKING\n-      gcc_assert (gimple_code (gsi_stmt (loc->si)) == GIMPLE_COND\n-\t  || gimple_code (gsi_stmt (loc->si)) == GIMPLE_SWITCH);\n-#endif\n+      gcc_checking_assert (gimple_code (gsi_stmt (loc->si)) == GIMPLE_COND\n+\t\t\t   || (gimple_code (gsi_stmt (loc->si))\n+\t\t\t       == GIMPLE_SWITCH));\n \n       gsi_insert_on_edge (loc->e, assert_stmt);\n       return true;"}, {"sha": "c3d5077dbaf6566efc1ebe6e23702229482a0d60", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 22, "deletions": 49, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a74ed7f000c8381733dcce7849621bd56b2f90/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=77a74ed7f000c8381733dcce7849621bd56b2f90", "patch": "@@ -1075,19 +1075,15 @@ dv_is_value_p (decl_or_value dv)\n static inline tree\n dv_as_decl (decl_or_value dv)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (dv_is_decl_p (dv));\n-#endif\n+  gcc_checking_assert (dv_is_decl_p (dv));\n   return (tree) dv;\n }\n \n /* Return the value in the decl_or_value.  */\n static inline rtx\n dv_as_value (decl_or_value dv)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (dv_is_value_p (dv));\n-#endif\n+  gcc_checking_assert (dv_is_value_p (dv));\n   return (rtx)dv;\n }\n \n@@ -1136,9 +1132,7 @@ dv_from_decl (tree decl)\n {\n   decl_or_value dv;\n   dv = decl;\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (dv_is_decl_p (dv));\n-#endif\n+  gcc_checking_assert (dv_is_decl_p (dv));\n   return dv;\n }\n \n@@ -1148,9 +1142,7 @@ dv_from_value (rtx value)\n {\n   decl_or_value dv;\n   dv = value;\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (dv_is_value_p (dv));\n-#endif\n+  gcc_checking_assert (dv_is_value_p (dv));\n   return dv;\n }\n \n@@ -2182,10 +2174,8 @@ variable_union (variable src, dataflow_set *set)\n \t      nnode->next = dnode;\n \t      dnode = nnode;\n \t    }\n-#ifdef ENABLE_CHECKING\n \t  else if (r == 0)\n-\t    gcc_assert (rtx_equal_p (dnode->loc, snode->loc));\n-#endif\n+\t    gcc_checking_assert (rtx_equal_p (dnode->loc, snode->loc));\n \n \t  if (r >= 0)\n \t    snode = snode->next;\n@@ -2549,17 +2539,13 @@ find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n   if (!var)\n     return NULL;\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (dv_onepart_p (var->dv));\n-#endif\n+  gcc_checking_assert (dv_onepart_p (var->dv));\n \n   if (!var->n_var_parts)\n     return NULL;\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (var->var_part[0].offset == 0);\n-  gcc_assert (loc != dv_as_opaque (var->dv));\n-#endif\n+  gcc_checking_assert (var->var_part[0].offset == 0);\n+  gcc_checking_assert (loc != dv_as_opaque (var->dv));\n \n   loc_code = GET_CODE (loc);\n   for (node = var->var_part[0].loc_chain; node; node = node->next)\n@@ -2591,20 +2577,16 @@ find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n \t  while (node->next && GET_CODE (node->next->loc) == VALUE)\n \t    {\n \t      node = node->next;\n-#ifdef ENABLE_CHECKING\n-\t      gcc_assert (!canon_value_cmp (node->loc,\n-\t\t\t\t\t    dv_as_value (var->dv)));\n-#endif\n+\t      gcc_checking_assert (!canon_value_cmp (node->loc,\n+\t\t\t\t\t\t     dv_as_value (var->dv)));\n \t      if (loc == node->loc)\n \t\treturn node;\n \t    }\n \t  continue;\n \t}\n \n-#ifdef ENABLE_CHECKING\n-      gcc_assert (node == var->var_part[0].loc_chain);\n-      gcc_assert (!node->next);\n-#endif\n+      gcc_checking_assert (node == var->var_part[0].loc_chain);\n+      gcc_checking_assert (!node->next);\n \n       dv = dv_from_value (node->loc);\n       rvar = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n@@ -2672,15 +2654,11 @@ intersect_loc_chains (rtx val, location_chain *dest, struct dfset_merge *dsm,\n     {\n       location_chain s2node;\n \n-#ifdef ENABLE_CHECKING\n-      gcc_assert (dv_onepart_p (s2var->dv));\n-#endif\n+      gcc_checking_assert (dv_onepart_p (s2var->dv));\n \n       if (s2var->n_var_parts)\n \t{\n-#ifdef ENABLE_CHECKING\n-\t  gcc_assert (s2var->var_part[0].offset == 0);\n-#endif\n+\t  gcc_checking_assert (s2var->var_part[0].offset == 0);\n \t  s2node = s2var->var_part[0].loc_chain;\n \n \t  for (; s1node && s2node;\n@@ -2829,10 +2807,8 @@ loc_cmp (rtx x, rtx y)\n       if (DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x))\n \t  < DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (y)))\n \treturn -1;\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x))\n-\t\t  > DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (y)));\n-#endif\n+      gcc_checking_assert (DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x))\n+\t\t\t   > DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (y)));\n       return 1;\n     }\n \n@@ -3592,10 +3568,9 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n       dstslot = shared_hash_find_slot_noinsert_1 (dst->vars, dv, dvhash);\n       gcc_assert (*dstslot == dvar);\n       canonicalize_values_star (dstslot, dst);\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (dstslot\n-\t\t  == shared_hash_find_slot_noinsert_1 (dst->vars, dv, dvhash));\n-#endif\n+      gcc_checking_assert (dstslot\n+\t\t\t   == shared_hash_find_slot_noinsert_1 (dst->vars,\n+\t\t\t\t\t\t\t\tdv, dvhash));\n       dvar = (variable)*dstslot;\n     }\n   else\n@@ -3660,11 +3635,9 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n \t  dstslot = shared_hash_find_slot_noinsert_1 (dst->vars, dv, dvhash);\n \t  gcc_assert (*dstslot == dvar);\n \t  canonicalize_values_star (dstslot, dst);\n-#ifdef ENABLE_CHECKING\n-\t  gcc_assert (dstslot\n-\t\t      == shared_hash_find_slot_noinsert_1 (dst->vars,\n-\t\t\t\t\t\t\t   dv, dvhash));\n-#endif\n+\t  gcc_checking_assert (dstslot\n+\t\t\t       == shared_hash_find_slot_noinsert_1 (dst->vars,\n+\t\t\t\t\t\t\t\t    dv, dvhash));\n \t  dvar = (variable)*dstslot;\n \t}\n     }"}]}