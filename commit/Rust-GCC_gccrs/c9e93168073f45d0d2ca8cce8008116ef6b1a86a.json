{"sha": "c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzllOTMxNjgwNzNmNDVkMGQyY2E4Y2NlODAwODExNmVmNmIxYTg2YQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-09-27T16:10:42Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-09-27T16:10:42Z"}, "message": "re PR middle-end/43864 (Same basic blocks should be merged)\n\n2011-09-27  Tom de Vries  <tom@codesourcery.com>\n\n\tPR middle-end/43864\n\t* tree-ssa-tail-merge.c: New file.\n\t(struct same_succ_def): Define.\n\t(same_succ, const_same_succ): New typedef.\n\t(struct bb_cluster_def): Define.\n\t(bb_cluster, const_bb_cluster): New typedef.\n\t(struct aux_bb_info): Define.\n\t(BB_SIZE, BB_SAME_SUCC, BB_CLUSTER, BB_VOP_AT_EXIT): Define.\n\t(gvn_uses_equal): New function.\n\t(same_succ_print, same_succ_print_traverse, update_dep_bb)\n\t(stmt_update_dep_bb, local_def, same_succ_hash)\n\t(inverse_flags, same_succ_equal, same_succ_alloc, same_succ_delete)\n\t(same_succ_reset): New function.\n\t(same_succ_htab, same_succ_edge_flags)\n\t(deleted_bbs, deleted_bb_preds): New var.\n\t(debug_same_succ): New function.\n\t(worklist): New var.\n\t(print_worklist, add_to_worklist, find_same_succ_bb, find_same_succ)\n\t(init_worklist, delete_worklist, delete_basic_block_same_succ)\n\t(same_succ_flush_bbs, purge_bbs, update_worklist): New function.\n\t(print_cluster, debug_cluster, update_rep_bb)\n\t(add_bb_to_cluster, new_cluster, delete_cluster): New function.\n\t(all_clusters): New var.\n\t(alloc_cluster_vectors, reset_cluster_vectors, delete_cluster_vectors)\n\t(merge_clusters, set_cluster): New function.\n\t(gimple_equal_p, gsi_advance_bw_nondebug_nonlocal, find_duplicate)\n\t(same_phi_alternatives_1, same_phi_alternatives, bb_has_non_vop_phi)\n\t(deps_ok_for_redirect_from_bb_to_bb, deps_ok_for_redirect)\n\t(find_clusters_1, find_clusters): New function.\n\t(update_vuses, vop_phi, vop_at_entry, replace_block_by): New function.\n\t(update_bbs): New var.\n\t(apply_clusters): New function.\n\t(update_debug_stmt, update_debug_stmts): New function.\n\t(tail_merge_optimize): New function.\n\ttree-pass.h (tail_merge_optimize): Declare.\n\t* tree-ssa-pre.c (execute_pre): Use tail_merge_optimize.\n\t* Makefile.in (OBJS-common): Add tree-ssa-tail-merge.o.\n\t(tree-ssa-tail-merge.o): New rule.\n\t* opts.c (default_options_table): Set OPT_ftree_tail_merge by default at\n\tOPT_LEVELS_2_PLUS.\n\t* tree-ssa-sccvn.c (vn_valueize): Move to ...\n\t* tree-ssa-sccvn.h (vn_valueize): Here.\n\t* timevar.def (TV_TREE_TAIL_MERGE): New timevar.\n\t* common.opt (ftree-tail-merge): New switch.\n\t* params.def (PARAM_MAX_TAIL_MERGE_COMPARISONS)\n\t(PARAM_MAX_TAIL_MERGE_ITERATIONS): New parameter.\n\t* doc/invoke.texi (Optimization Options, -O2): Add -ftree-tail-merge.\n\t(-ftree-tail-merge, max-tail-merge-comparisons)\n\t(max-tail-merge-iterations): New item.\n\nFrom-SVN: r179275", "tree": {"sha": "9fb115ebc32f781835ba38daf51902c0c2321a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fb115ebc32f781835ba38daf51902c0c2321a0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/comments", "author": null, "committer": null, "parents": [{"sha": "99e299a8c7583da12320b55684681c9277ab9b3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99e299a8c7583da12320b55684681c9277ab9b3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99e299a8c7583da12320b55684681c9277ab9b3f"}], "stats": {"total": 1840, "additions": 1824, "deletions": 16}, "files": [{"sha": "19a0a280f46cae88e41b12cb379559e29bf8d001", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -1,3 +1,55 @@\n+2011-09-27  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR middle-end/43864\n+\t* tree-ssa-tail-merge.c: New file.\n+\t(struct same_succ_def): Define.\n+\t(same_succ, const_same_succ): New typedef.\n+\t(struct bb_cluster_def): Define.\n+\t(bb_cluster, const_bb_cluster): New typedef.\n+\t(struct aux_bb_info): Define.\n+\t(BB_SIZE, BB_SAME_SUCC, BB_CLUSTER, BB_VOP_AT_EXIT): Define.\n+\t(gvn_uses_equal): New function.\n+\t(same_succ_print, same_succ_print_traverse, update_dep_bb)\n+\t(stmt_update_dep_bb, local_def, same_succ_hash)\n+\t(inverse_flags, same_succ_equal, same_succ_alloc, same_succ_delete)\n+\t(same_succ_reset): New function.\n+\t(same_succ_htab, same_succ_edge_flags)\n+\t(deleted_bbs, deleted_bb_preds): New var.\n+\t(debug_same_succ): New function.\n+\t(worklist): New var.\n+\t(print_worklist, add_to_worklist, find_same_succ_bb, find_same_succ)\n+\t(init_worklist, delete_worklist, delete_basic_block_same_succ)\n+\t(same_succ_flush_bbs, purge_bbs, update_worklist): New function.\n+\t(print_cluster, debug_cluster, update_rep_bb)\n+\t(add_bb_to_cluster, new_cluster, delete_cluster): New function.\n+\t(all_clusters): New var.\n+\t(alloc_cluster_vectors, reset_cluster_vectors, delete_cluster_vectors)\n+\t(merge_clusters, set_cluster): New function.\n+\t(gimple_equal_p, gsi_advance_bw_nondebug_nonlocal, find_duplicate)\n+\t(same_phi_alternatives_1, same_phi_alternatives, bb_has_non_vop_phi)\n+\t(deps_ok_for_redirect_from_bb_to_bb, deps_ok_for_redirect)\n+\t(find_clusters_1, find_clusters): New function.\n+\t(update_vuses, vop_phi, vop_at_entry, replace_block_by): New function.\n+\t(update_bbs): New var.\n+\t(apply_clusters): New function.\n+\t(update_debug_stmt, update_debug_stmts): New function.\n+\t(tail_merge_optimize): New function.\n+\ttree-pass.h (tail_merge_optimize): Declare.\n+\t* tree-ssa-pre.c (execute_pre): Use tail_merge_optimize.\n+\t* Makefile.in (OBJS-common): Add tree-ssa-tail-merge.o.\n+\t(tree-ssa-tail-merge.o): New rule.\n+\t* opts.c (default_options_table): Set OPT_ftree_tail_merge by default at\n+\tOPT_LEVELS_2_PLUS.\n+\t* tree-ssa-sccvn.c (vn_valueize): Move to ...\n+\t* tree-ssa-sccvn.h (vn_valueize): Here.\n+\t* timevar.def (TV_TREE_TAIL_MERGE): New timevar.\n+\t* common.opt (ftree-tail-merge): New switch.\n+\t* params.def (PARAM_MAX_TAIL_MERGE_COMPARISONS)\n+\t(PARAM_MAX_TAIL_MERGE_ITERATIONS): New parameter.\n+\t* doc/invoke.texi (Optimization Options, -O2): Add -ftree-tail-merge.\n+\t(-ftree-tail-merge, max-tail-merge-comparisons)\n+\t(max-tail-merge-iterations): New item.\n+\n 2011-09-27  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline-analysis.c (MAX_TIME): Reduce to avoid overflows."}, {"sha": "9827d21753e179023eea881511e417f69edd9c3f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -1476,6 +1476,7 @@ OBJS = \\\n \ttree-ssa-sccvn.o \\\n \ttree-ssa-sink.o \\\n \ttree-ssa-structalias.o \\\n+\ttree-ssa-tail-merge.o \\\n \ttree-ssa-ter.o \\\n \ttree-ssa-threadedge.o \\\n \ttree-ssa-threadupdate.o \\\n@@ -2382,6 +2383,13 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(PARAMS_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) output.h $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) $(TARGET_H) langhooks.h $(REGS_H) gt-stor-layout.h \\\n    $(DIAGNOSTIC_CORE_H) $(CGRAPH_H) $(TREE_INLINE_H) $(TREE_DUMP_H) $(GIMPLE_H)\n+tree-ssa-tail-merge.o: tree-ssa-tail-merge.c \\\n+   $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(BITMAP_H) \\\n+   $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) output.h \\\n+   $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n+   $(GIMPLE_H) $(FUNCTION_H) \\\n+   $(TIMEVAR_H) tree-ssa-sccvn.h \\\n+   $(CGRAPH_H) gimple-pretty-print.h tree-pretty-print.h $(PARAMS_H)\n tree-ssa-structalias.o: tree-ssa-structalias.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) output.h \\"}, {"sha": "50d7904c75f1ee96cc4624d597fd181ab2bc6fd4", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -1945,6 +1945,10 @@ ftree-dominator-opts\n Common Report Var(flag_tree_dom) Optimization\n Enable dominator optimizations\n \n+ftree-tail-merge\n+Common Report Var(flag_tree_tail_merge) Optimization\n+Enable tail merging on trees\n+\n ftree-dse\n Common Report Var(flag_tree_dse) Optimization\n Enable dead store elimination"}, {"sha": "e166964c28d8a9f7b81e45dc256c5779c4d240c0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -407,7 +407,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-pta -ftree-reassoc @gol\n--ftree-sink -ftree-sra -ftree-switch-conversion @gol\n+-ftree-sink -ftree-sra -ftree-switch-conversion -ftree-tail-merge @gol\n -ftree-ter -ftree-vect-loop-version -ftree-vectorize -ftree-vrp @gol\n -funit-at-a-time -funroll-all-loops -funroll-loops @gol\n -funsafe-loop-optimizations -funsafe-math-optimizations -funswitch-loops @gol\n@@ -6137,7 +6137,7 @@ also turns on the following optimization flags:\n -fsched-interblock  -fsched-spec @gol\n -fschedule-insns  -fschedule-insns2 @gol\n -fstrict-aliasing -fstrict-overflow @gol\n--ftree-switch-conversion @gol\n+-ftree-switch-conversion -ftree-tail-merge @gol\n -ftree-pre @gol\n -ftree-vrp}\n \n@@ -7020,6 +7020,13 @@ Perform conversion of simple initializations in a switch to\n initializations from a scalar array.  This flag is enabled by default\n at @option{-O2} and higher.\n \n+@item -ftree-tail-merge\n+Look for identical code sequences.  When found, replace one with a jump to the\n+other.  This optimization is known as tail merging or cross jumping.  This flag\n+is enabled by default at @option{-O2} and higher.  The run time of this pass can\n+be limited using @option{max-tail-merge-comparisons} parameter and\n+@option{max-tail-merge-iterations} parameter.\n+\n @item -ftree-dce\n @opindex ftree-dce\n Perform dead code elimination (DCE) on trees.  This flag is enabled by\n@@ -8603,6 +8610,14 @@ This is used to avoid quadratic behavior in hoisting algorithm.\n The value of 0 will avoid limiting the search, but may slow down compilation\n of huge functions.  The default value is 30.\n \n+@item max-tail-merge-comparisons\n+The maximum amount of similar bbs to compare a bb with.  This is used to\n+avoid quadratic behaviour in tree tail merging.  The default value is 10.\n+\n+@item max-tail-merge-iterations\n+The maximum amount of iterations of the pass over the function.  This is used to\n+limit run time in tree tail merging.  The default value is 2.\n+\n @item max-unrolled-insns\n The maximum number of instructions that a loop should have if that loop\n is unrolled, and if the loop is unrolled, it determines how many times"}, {"sha": "92462fd075528c7bde4a50ecf4bb8e81a4397017", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -484,6 +484,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_falign_jumps, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_falign_labels, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_falign_functions, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_ftree_tail_merge, NULL, 1 },\n \n     /* -O3 optimizations.  */\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },"}, {"sha": "0adf0470a663cc31b365ceaff91ee55870bfcfec", "filename": "gcc/params.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -921,6 +921,15 @@ DEFPARAM (PARAM_TREE_REASSOC_WIDTH,\n \t  \"reassociated tree. If 0, use the target dependent heuristic.\",\n \t  0, 0, 0)\n \n+DEFPARAM (PARAM_MAX_TAIL_MERGE_COMPARISONS,\n+          \"max-tail-merge-comparisons\",\n+          \"Maximum amount of similar bbs to compare a bb with\",\n+          10, 0, 0)\n+\n+DEFPARAM (PARAM_MAX_TAIL_MERGE_ITERATIONS,\n+          \"max-tail-merge-iterations\",\n+          \"Maximum amount of iterations of the pass over a function\",\n+          2, 0, 0)\n \n /*\n Local variables:"}, {"sha": "373bae67e13c1696d0b29208a00182dab12fd4d3", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -127,6 +127,7 @@ DEFTIMEVAR (TV_TREE_GIMPLIFY\t     , \"tree gimplify\")\n DEFTIMEVAR (TV_TREE_EH\t\t     , \"tree eh\")\n DEFTIMEVAR (TV_TREE_CFG\t\t     , \"tree CFG construction\")\n DEFTIMEVAR (TV_TREE_CLEANUP_CFG\t     , \"tree CFG cleanup\")\n+DEFTIMEVAR (TV_TREE_TAIL_MERGE       , \"tree tail merge\")\n DEFTIMEVAR (TV_TREE_VRP              , \"tree VRP\")\n DEFTIMEVAR (TV_TREE_COPY_PROP        , \"tree copy propagation\")\n DEFTIMEVAR (TV_FIND_REFERENCED_VARS  , \"tree find ref. vars\")"}, {"sha": "ee442a5b112e9adc8f0b81c4151e06fa91cb933d", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -401,6 +401,7 @@ extern struct gimple_opt_pass pass_call_cdce;\n extern struct gimple_opt_pass pass_merge_phi;\n extern struct gimple_opt_pass pass_split_crit_edges;\n extern struct gimple_opt_pass pass_pre;\n+extern unsigned int tail_merge_optimize (unsigned int);\n extern struct gimple_opt_pass pass_profile;\n extern struct gimple_opt_pass pass_strip_predict_hints;\n extern struct gimple_opt_pass pass_lower_complex_O0;"}, {"sha": "a7f6cee35d8fe41f91d941995b7c30fc55f3c055", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -4915,7 +4915,6 @@ execute_pre (bool do_fre)\n   statistics_counter_event (cfun, \"Constified\", pre_stats.constified);\n \n   clear_expression_ids ();\n-  free_scc_vn ();\n   if (!do_fre)\n     {\n       remove_dead_inserted_code ();\n@@ -4925,6 +4924,17 @@ execute_pre (bool do_fre)\n   scev_finalize ();\n   fini_pre (do_fre);\n \n+  if (!do_fre)\n+    /* TODO: tail_merge_optimize may merge all predecessors of a block, in which\n+       case we can merge the block with the remaining predecessor of the block.\n+       It should either:\n+       - call merge_blocks after each tail merge iteration\n+       - call merge_blocks after all tail merge iterations\n+       - mark TODO_cleanup_cfg when necessary\n+       - share the cfg cleanup with fini_pre.  */\n+    todo |= tail_merge_optimize (todo);\n+  free_scc_vn ();\n+\n   return todo;\n }\n "}, {"sha": "003804b3ca88062f0cd7174945141e709393f779", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -2820,19 +2820,6 @@ stmt_has_constants (gimple stmt)\n   return false;\n }\n \n-/* Valueize NAME if it is an SSA name, otherwise just return it.  */\n-\n-static inline tree\n-vn_valueize (tree name)\n-{\n-  if (TREE_CODE (name) == SSA_NAME)\n-    {\n-      tree tem = SSA_VAL (name);\n-      return tem == VN_TOP ? name : tem;\n-    }\n-  return name;\n-}\n-\n /* Replace SSA_NAMES in expr with their value numbers, and return the\n    result.\n    This is performed in place. */"}, {"sha": "b37b084413d91867dbf36d7923aa97fd6460d80b", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -215,4 +215,18 @@ unsigned int get_constant_value_id (tree);\n unsigned int get_or_alloc_constant_value_id (tree);\n bool value_id_constant_p (unsigned int);\n tree fully_constant_vn_reference_p (vn_reference_t);\n+\n+/* Valueize NAME if it is an SSA name, otherwise just return it.  */\n+\n+static inline tree\n+vn_valueize (tree name)\n+{\n+  if (TREE_CODE (name) == SSA_NAME)\n+    {\n+      tree tem = VN_INFO (name)->valnum;\n+      return tem == VN_TOP ? name : tem;\n+    }\n+  return name;\n+}\n+\n #endif /* TREE_SSA_SCCVN_H  */"}, {"sha": "611a30f23a47c8a954eddb2c5ec7c1530cf08b2f", "filename": "gcc/tree-ssa-tail-merge.c", "status": "added", "additions": 1706, "deletions": 0, "changes": 1706, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e93168073f45d0d2ca8cce8008116ef6b1a86a/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=c9e93168073f45d0d2ca8cce8008116ef6b1a86a", "patch": "@@ -0,0 +1,1706 @@\n+/* Tail merging for gimple.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Tom de Vries (tom@codesourcery.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Pass overview.\n+\n+\n+   MOTIVATIONAL EXAMPLE\n+\n+   gimple representation of gcc/testsuite/gcc.dg/pr43864.c at\n+\n+   hprofStartupp (charD.1 * outputFileNameD.2600, charD.1 * ctxD.2601)\n+   {\n+     struct FILED.1638 * fpD.2605;\n+     charD.1 fileNameD.2604[1000];\n+     intD.0 D.3915;\n+     const charD.1 * restrict outputFileName.0D.3914;\n+\n+     # BLOCK 2 freq:10000\n+     # PRED: ENTRY [100.0%]  (fallthru,exec)\n+     # PT = nonlocal { D.3926 } (restr)\n+     outputFileName.0D.3914_3\n+       = (const charD.1 * restrict) outputFileNameD.2600_2(D);\n+     # .MEMD.3923_13 = VDEF <.MEMD.3923_12(D)>\n+     # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     sprintfD.759 (&fileNameD.2604, outputFileName.0D.3914_3);\n+     # .MEMD.3923_14 = VDEF <.MEMD.3923_13>\n+     # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     D.3915_4 = accessD.2606 (&fileNameD.2604, 1);\n+     if (D.3915_4 == 0)\n+       goto <bb 3>;\n+     else\n+       goto <bb 4>;\n+     # SUCC: 3 [10.0%]  (true,exec) 4 [90.0%]  (false,exec)\n+\n+     # BLOCK 3 freq:1000\n+     # PRED: 2 [10.0%]  (true,exec)\n+     # .MEMD.3923_15 = VDEF <.MEMD.3923_14>\n+     # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     freeD.898 (ctxD.2601_5(D));\n+     goto <bb 7>;\n+     # SUCC: 7 [100.0%]  (fallthru,exec)\n+\n+     # BLOCK 4 freq:9000\n+     # PRED: 2 [90.0%]  (false,exec)\n+     # .MEMD.3923_16 = VDEF <.MEMD.3923_14>\n+     # PT = nonlocal escaped\n+     # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     fpD.2605_8 = fopenD.1805 (&fileNameD.2604[0], 0B);\n+     if (fpD.2605_8 == 0B)\n+       goto <bb 5>;\n+     else\n+       goto <bb 6>;\n+     # SUCC: 5 [1.9%]  (true,exec) 6 [98.1%]  (false,exec)\n+\n+     # BLOCK 5 freq:173\n+     # PRED: 4 [1.9%]  (true,exec)\n+     # .MEMD.3923_17 = VDEF <.MEMD.3923_16>\n+     # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     freeD.898 (ctxD.2601_5(D));\n+     goto <bb 7>;\n+     # SUCC: 7 [100.0%]  (fallthru,exec)\n+\n+     # BLOCK 6 freq:8827\n+     # PRED: 4 [98.1%]  (false,exec)\n+     # .MEMD.3923_18 = VDEF <.MEMD.3923_16>\n+     # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)\n+     fooD.2599 (outputFileNameD.2600_2(D), fpD.2605_8);\n+     # SUCC: 7 [100.0%]  (fallthru,exec)\n+\n+     # BLOCK 7 freq:10000\n+     # PRED: 3 [100.0%]  (fallthru,exec) 5 [100.0%]  (fallthru,exec)\n+             6 [100.0%]  (fallthru,exec)\n+     # PT = nonlocal null\n+\n+     # ctxD.2601_1 = PHI <0B(3), 0B(5), ctxD.2601_5(D)(6)>\n+     # .MEMD.3923_11 = PHI <.MEMD.3923_15(3), .MEMD.3923_17(5),\n+                            .MEMD.3923_18(6)>\n+     # VUSE <.MEMD.3923_11>\n+     return ctxD.2601_1;\n+     # SUCC: EXIT [100.0%]\n+   }\n+\n+   bb 3 and bb 5 can be merged.  The blocks have different predecessors, but the\n+   same successors, and the same operations.\n+\n+\n+   CONTEXT\n+\n+   A technique called tail merging (or cross jumping) can fix the example\n+   above.  For a block, we look for common code at the end (the tail) of the\n+   predecessor blocks, and insert jumps from one block to the other.\n+   The example is a special case for tail merging, in that 2 whole blocks\n+   can be merged, rather than just the end parts of it.\n+   We currently only focus on whole block merging, so in that sense\n+   calling this pass tail merge is a bit of a misnomer.\n+\n+   We distinguish 2 kinds of situations in which blocks can be merged:\n+   - same operations, same predecessors.  The successor edges coming from one\n+     block are redirected to come from the other block.\n+   - same operations, same successors.  The predecessor edges entering one block\n+     are redirected to enter the other block.  Note that this operation might\n+     involve introducing phi operations.\n+\n+   For efficient implementation, we would like to value numbers the blocks, and\n+   have a comparison operator that tells us whether the blocks are equal.\n+   Besides being runtime efficient, block value numbering should also abstract\n+   from irrelevant differences in order of operations, much like normal value\n+   numbering abstracts from irrelevant order of operations.\n+\n+   For the first situation (same_operations, same predecessors), normal value\n+   numbering fits well.  We can calculate a block value number based on the\n+   value numbers of the defs and vdefs.\n+\n+   For the second situation (same operations, same successors), this approach\n+   doesn't work so well.  We can illustrate this using the example.  The calls\n+   to free use different vdefs: MEMD.3923_16 and MEMD.3923_14, and these will\n+   remain different in value numbering, since they represent different memory\n+   states.  So the resulting vdefs of the frees will be different in value\n+   numbering, so the block value numbers will be different.\n+\n+   The reason why we call the blocks equal is not because they define the same\n+   values, but because uses in the blocks use (possibly different) defs in the\n+   same way.  To be able to detect this efficiently, we need to do some kind of\n+   reverse value numbering, meaning number the uses rather than the defs, and\n+   calculate a block value number based on the value number of the uses.\n+   Ideally, a block comparison operator will also indicate which phis are needed\n+   to merge the blocks.\n+\n+   For the moment, we don't do block value numbering, but we do insn-by-insn\n+   matching, using scc value numbers to match operations with results, and\n+   structural comparison otherwise, while ignoring vop mismatches.\n+\n+\n+   IMPLEMENTATION\n+\n+   1. The pass first determines all groups of blocks with the same successor\n+      blocks.\n+   2. Within each group, it tries to determine clusters of equal basic blocks.\n+   3. The clusters are applied.\n+   4. The same successor groups are updated.\n+   5. This process is repeated from 2 onwards, until no more changes.\n+\n+\n+   LIMITATIONS/TODO\n+\n+   - block only\n+   - handles only 'same operations, same successors'.\n+     It handles same predecessors as a special subcase though.\n+   - does not implement the reverse value numbering and block value numbering.\n+   - improve memory allocation: use garbage collected memory, obstacks,\n+     allocpools where appropriate.\n+   - no insertion of gimple_reg phis,  We only introduce vop-phis.\n+   - handle blocks with gimple_reg phi_nodes.\n+\n+\n+   SWITCHES\n+\n+   - ftree-tail-merge.  On at -O2.  We may have to enable it only at -Os.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"tree-flow.h\"\n+#include \"timevar.h\"\n+#include \"bitmap.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"params.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"hashtab.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree-ssa-sccvn.h\"\n+#include \"tree-dump.h\"\n+\n+/* Describes a group of bbs with the same successors.  The successor bbs are\n+   cached in succs, and the successor edge flags are cached in succ_flags.\n+   If a bb has the EDGE_TRUE/VALSE_VALUE flags swapped compared to succ_flags,\n+   it's marked in inverse.\n+   Additionally, the hash value for the struct is cached in hashval, and\n+   in_worklist indicates whether it's currently part of worklist.  */\n+\n+struct same_succ_def\n+{\n+  /* The bbs that have the same successor bbs.  */\n+  bitmap bbs;\n+  /* The successor bbs.  */\n+  bitmap succs;\n+  /* Indicates whether the EDGE_TRUE/FALSE_VALUEs of succ_flags are swapped for\n+     bb.  */\n+  bitmap inverse;\n+  /* The edge flags for each of the successor bbs.  */\n+  VEC (int, heap) *succ_flags;\n+  /* Indicates whether the struct is currently in the worklist.  */\n+  bool in_worklist;\n+  /* The hash value of the struct.  */\n+  hashval_t hashval;\n+};\n+typedef struct same_succ_def *same_succ;\n+typedef const struct same_succ_def *const_same_succ;\n+\n+/* A group of bbs where 1 bb from bbs can replace the other bbs.  */\n+\n+struct bb_cluster_def\n+{\n+  /* The bbs in the cluster.  */\n+  bitmap bbs;\n+  /* The preds of the bbs in the cluster.  */\n+  bitmap preds;\n+  /* Index in all_clusters vector.  */\n+  int index;\n+  /* The bb to replace the cluster with.  */\n+  basic_block rep_bb;\n+};\n+typedef struct bb_cluster_def *bb_cluster;\n+typedef const struct bb_cluster_def *const_bb_cluster;\n+\n+/* Per bb-info.  */\n+\n+struct aux_bb_info\n+{\n+  /* The number of non-debug statements in the bb.  */\n+  int size;\n+  /* The same_succ that this bb is a member of.  */\n+  same_succ bb_same_succ;\n+  /* The cluster that this bb is a member of.  */\n+  bb_cluster cluster;\n+  /* The vop state at the exit of a bb.  This is shortlived data, used to\n+     communicate data between update_block_by and update_vuses.  */\n+  tree vop_at_exit;\n+  /* The bb that either contains or is dominated by the dependencies of the\n+     bb.  */\n+  basic_block dep_bb;\n+};\n+\n+/* Macros to access the fields of struct aux_bb_info.  */\n+\n+#define BB_SIZE(bb) (((struct aux_bb_info *)bb->aux)->size)\n+#define BB_SAME_SUCC(bb) (((struct aux_bb_info *)bb->aux)->bb_same_succ)\n+#define BB_CLUSTER(bb) (((struct aux_bb_info *)bb->aux)->cluster)\n+#define BB_VOP_AT_EXIT(bb) (((struct aux_bb_info *)bb->aux)->vop_at_exit)\n+#define BB_DEP_BB(bb) (((struct aux_bb_info *)bb->aux)->dep_bb)\n+\n+/* VAL1 and VAL2 are either:\n+   - uses in BB1 and BB2, or\n+   - phi alternatives for BB1 and BB2.\n+   Return true if the uses have the same gvn value.  */\n+\n+static bool\n+gvn_uses_equal (tree val1, tree val2)\n+{\n+  gcc_checking_assert (val1 != NULL_TREE && val2 != NULL_TREE);\n+\n+  if (val1 == val2)\n+    return true;\n+\n+  if (vn_valueize (val1) != vn_valueize (val2))\n+    return false;\n+\n+  return ((TREE_CODE (val1) == SSA_NAME || CONSTANT_CLASS_P (val1))\n+\t  && (TREE_CODE (val2) == SSA_NAME || CONSTANT_CLASS_P (val2)));\n+}\n+\n+/* Prints E to FILE.  */\n+\n+static void\n+same_succ_print (FILE *file, const same_succ e)\n+{\n+  unsigned int i;\n+  bitmap_print (file, e->bbs, \"bbs:\", \"\\n\");\n+  bitmap_print (file, e->succs, \"succs:\", \"\\n\");\n+  bitmap_print (file, e->inverse, \"inverse:\", \"\\n\");\n+  fprintf (file, \"flags:\");\n+  for (i = 0; i < VEC_length (int, e->succ_flags); ++i)\n+    fprintf (file, \" %x\", VEC_index (int, e->succ_flags, i));\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Prints same_succ VE to VFILE.  */\n+\n+static int\n+same_succ_print_traverse (void **ve, void *vfile)\n+{\n+  const same_succ e = *((const same_succ *)ve);\n+  FILE *file = ((FILE*)vfile);\n+  same_succ_print (file, e);\n+  return 1;\n+}\n+\n+/* Update BB_DEP_BB (USE_BB), given a use of VAL in USE_BB.  */\n+\n+static void\n+update_dep_bb (basic_block use_bb, tree val)\n+{\n+  basic_block dep_bb;\n+\n+  /* Not a dep.  */\n+  if (TREE_CODE (val) != SSA_NAME)\n+    return;\n+\n+  /* Skip use of global def.  */\n+  if (SSA_NAME_IS_DEFAULT_DEF (val))\n+    return;\n+\n+  /* Skip use of local def.  */\n+  dep_bb = gimple_bb (SSA_NAME_DEF_STMT (val));\n+  if (dep_bb == use_bb)\n+    return;\n+\n+  if (BB_DEP_BB (use_bb) == NULL\n+      || dominated_by_p (CDI_DOMINATORS, dep_bb, BB_DEP_BB (use_bb)))\n+    BB_DEP_BB (use_bb) = dep_bb;\n+}\n+\n+/* Update BB_DEP_BB, given the dependencies in STMT.  */\n+\n+static void\n+stmt_update_dep_bb (gimple stmt)\n+{\n+  ssa_op_iter iter;\n+  use_operand_p use;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+    update_dep_bb (gimple_bb (stmt), USE_FROM_PTR (use));\n+}\n+\n+/* Returns whether VAL is used in the same bb as in which it is defined, or\n+   in the phi of a successor bb.  */\n+\n+static bool\n+local_def (tree val)\n+{\n+  gimple stmt, def_stmt;\n+  basic_block bb, def_bb;\n+  imm_use_iterator iter;\n+  bool res;\n+\n+  if (TREE_CODE (val) != SSA_NAME)\n+    return false;\n+  def_stmt = SSA_NAME_DEF_STMT (val);\n+  def_bb = gimple_bb (def_stmt);\n+\n+  res = true;\n+  FOR_EACH_IMM_USE_STMT (stmt, iter, val)\n+    {\n+      bb = gimple_bb (stmt);\n+      if (bb == def_bb)\n+\tcontinue;\n+      if (gimple_code (stmt) == GIMPLE_PHI\n+\t  && find_edge (def_bb, bb))\n+\tcontinue;\n+      res = false;\n+      BREAK_FROM_IMM_USE_STMT (iter);\n+    }\n+  return res;\n+}\n+\n+/* Calculates hash value for same_succ VE.  */\n+\n+static hashval_t\n+same_succ_hash (const void *ve)\n+{\n+  const_same_succ e = (const_same_succ)ve;\n+  hashval_t hashval = bitmap_hash (e->succs);\n+  int flags;\n+  unsigned int i;\n+  unsigned int first = bitmap_first_set_bit (e->bbs);\n+  basic_block bb = BASIC_BLOCK (first);\n+  int size = 0;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n+  tree arg;\n+  unsigned int s;\n+  bitmap_iterator bs;\n+\n+  for (gsi = gsi_start_nondebug_bb (bb);\n+       !gsi_end_p (gsi); gsi_next_nondebug (&gsi))\n+    {\n+      stmt = gsi_stmt (gsi);\n+      stmt_update_dep_bb (stmt);\n+      if (is_gimple_assign (stmt) && local_def (gimple_get_lhs (stmt))\n+\t  && !gimple_has_side_effects (stmt))\n+\tcontinue;\n+      size++;\n+\n+      hashval = iterative_hash_hashval_t (gimple_code (stmt), hashval);\n+      if (is_gimple_assign (stmt))\n+\thashval = iterative_hash_hashval_t (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t    hashval);\n+      if (!is_gimple_call (stmt))\n+\tcontinue;\n+      if (gimple_call_internal_p (stmt))\n+\thashval = iterative_hash_hashval_t\n+\t  ((hashval_t) gimple_call_internal_fn (stmt), hashval);\n+      else\n+\thashval = iterative_hash_expr (gimple_call_fn (stmt), hashval);\n+      for (i = 0; i < gimple_call_num_args (stmt); i++)\n+\t{\n+\t  arg = gimple_call_arg (stmt, i);\n+\t  arg = vn_valueize (arg);\n+\t  hashval = iterative_hash_expr (arg, hashval);\n+\t}\n+    }\n+\n+  hashval = iterative_hash_hashval_t (size, hashval);\n+  BB_SIZE (bb) = size;\n+\n+  for (i = 0; i < VEC_length (int, e->succ_flags); ++i)\n+    {\n+      flags = VEC_index (int, e->succ_flags, i);\n+      flags = flags & ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+      hashval = iterative_hash_hashval_t (flags, hashval);\n+    }\n+\n+  EXECUTE_IF_SET_IN_BITMAP (e->succs, 0, s, bs)\n+    {\n+      int n = find_edge (bb, BASIC_BLOCK (s))->dest_idx;\n+      for (gsi = gsi_start_phis (BASIC_BLOCK (s)); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple phi = gsi_stmt (gsi);\n+\t  tree lhs = gimple_phi_result (phi);\n+\t  tree val = gimple_phi_arg_def (phi, n);\n+\n+\t  if (!is_gimple_reg (lhs))\n+\t    continue;\n+\t  update_dep_bb (bb, val);\n+\t}\n+    }\n+\n+  return hashval;\n+}\n+\n+/* Returns true if E1 and E2 have 2 successors, and if the successor flags\n+   are inverse for the EDGE_TRUE_VALUE and EDGE_FALSE_VALUE flags, and equal for\n+   the other edge flags.  */\n+\n+static bool\n+inverse_flags (const_same_succ e1, const_same_succ e2)\n+{\n+  int f1a, f1b, f2a, f2b;\n+  int mask = ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+\n+  if (VEC_length (int, e1->succ_flags) != 2)\n+    return false;\n+\n+  f1a = VEC_index (int, e1->succ_flags, 0);\n+  f1b = VEC_index (int, e1->succ_flags, 1);\n+  f2a = VEC_index (int, e2->succ_flags, 0);\n+  f2b = VEC_index (int, e2->succ_flags, 1);\n+\n+  if (f1a == f2a && f1b == f2b)\n+    return false;\n+\n+  return (f1a & mask) == (f2a & mask) && (f1b & mask) == (f2b & mask);\n+}\n+\n+/* Compares SAME_SUCCs VE1 and VE2.  */\n+\n+static int\n+same_succ_equal (const void *ve1, const void *ve2)\n+{\n+  const_same_succ e1 = (const_same_succ)ve1;\n+  const_same_succ e2 = (const_same_succ)ve2;\n+  unsigned int i, first1, first2;\n+  gimple_stmt_iterator gsi1, gsi2;\n+  gimple s1, s2;\n+  basic_block bb1, bb2;\n+\n+  if (e1->hashval != e2->hashval)\n+    return 0;\n+\n+  if (VEC_length (int, e1->succ_flags) != VEC_length (int, e2->succ_flags))\n+    return 0;\n+\n+  if (!bitmap_equal_p (e1->succs, e2->succs))\n+    return 0;\n+\n+  if (!inverse_flags (e1, e2))\n+    {\n+      for (i = 0; i < VEC_length (int, e1->succ_flags); ++i)\n+\tif (VEC_index (int, e1->succ_flags, i)\n+\t    != VEC_index (int, e1->succ_flags, i))\n+\t  return 0;\n+    }\n+\n+  first1 = bitmap_first_set_bit (e1->bbs);\n+  first2 = bitmap_first_set_bit (e2->bbs);\n+\n+  bb1 = BASIC_BLOCK (first1);\n+  bb2 = BASIC_BLOCK (first2);\n+\n+  if (BB_SIZE (bb1) != BB_SIZE (bb2))\n+    return 0;\n+\n+  gsi1 = gsi_start_nondebug_bb (bb1);\n+  gsi2 = gsi_start_nondebug_bb (bb2);\n+  while (!(gsi_end_p (gsi1) || gsi_end_p (gsi2)))\n+    {\n+      s1 = gsi_stmt (gsi1);\n+      s2 = gsi_stmt (gsi2);\n+      if (gimple_code (s1) != gimple_code (s2))\n+\treturn 0;\n+      if (is_gimple_call (s1) && !gimple_call_same_target_p (s1, s2))\n+\treturn 0;\n+      gsi_next_nondebug (&gsi1);\n+      gsi_next_nondebug (&gsi2);\n+    }\n+\n+  return 1;\n+}\n+\n+/* Alloc and init a new SAME_SUCC.  */\n+\n+static same_succ\n+same_succ_alloc (void)\n+{\n+  same_succ same = XNEW (struct same_succ_def);\n+\n+  same->bbs = BITMAP_ALLOC (NULL);\n+  same->succs = BITMAP_ALLOC (NULL);\n+  same->inverse = BITMAP_ALLOC (NULL);\n+  same->succ_flags = VEC_alloc (int, heap, 10);\n+  same->in_worklist = false;\n+\n+  return same;\n+}\n+\n+/* Delete same_succ VE.  */\n+\n+static void\n+same_succ_delete (void *ve)\n+{\n+  same_succ e = (same_succ)ve;\n+\n+  BITMAP_FREE (e->bbs);\n+  BITMAP_FREE (e->succs);\n+  BITMAP_FREE (e->inverse);\n+  VEC_free (int, heap, e->succ_flags);\n+\n+  XDELETE (ve);\n+}\n+\n+/* Reset same_succ SAME.  */\n+\n+static void\n+same_succ_reset (same_succ same)\n+{\n+  bitmap_clear (same->bbs);\n+  bitmap_clear (same->succs);\n+  bitmap_clear (same->inverse);\n+  VEC_truncate (int, same->succ_flags, 0);\n+}\n+\n+/* Hash table with all same_succ entries.  */\n+\n+static htab_t same_succ_htab;\n+\n+/* Array that is used to store the edge flags for a successor.  */\n+\n+static int *same_succ_edge_flags;\n+\n+/* Bitmap that is used to mark bbs that are recently deleted.  */\n+\n+static bitmap deleted_bbs;\n+\n+/* Bitmap that is used to mark predecessors of bbs that are\n+   deleted.  */\n+\n+static bitmap deleted_bb_preds;\n+\n+/* Prints same_succ_htab to stderr.  */\n+\n+extern void debug_same_succ (void);\n+DEBUG_FUNCTION void\n+debug_same_succ ( void)\n+{\n+  htab_traverse (same_succ_htab, same_succ_print_traverse, stderr);\n+}\n+\n+DEF_VEC_P (same_succ);\n+DEF_VEC_ALLOC_P (same_succ, heap);\n+\n+/* Vector of bbs to process.  */\n+\n+static VEC (same_succ, heap) *worklist;\n+\n+/* Prints worklist to FILE.  */\n+\n+static void\n+print_worklist (FILE *file)\n+{\n+  unsigned int i;\n+  for (i = 0; i < VEC_length (same_succ, worklist); ++i)\n+    same_succ_print (file, VEC_index (same_succ, worklist, i));\n+}\n+\n+/* Adds SAME to worklist.  */\n+\n+static void\n+add_to_worklist (same_succ same)\n+{\n+  if (same->in_worklist)\n+    return;\n+\n+  if (bitmap_count_bits (same->bbs) < 2)\n+    return;\n+\n+  same->in_worklist = true;\n+  VEC_safe_push (same_succ, heap, worklist, same);\n+}\n+\n+/* Add BB to same_succ_htab.  */\n+\n+static void\n+find_same_succ_bb (basic_block bb, same_succ *same_p)\n+{\n+  unsigned int j;\n+  bitmap_iterator bj;\n+  same_succ same = *same_p;\n+  same_succ *slot;\n+  edge_iterator ei;\n+  edge e;\n+\n+  if (bb == NULL)\n+    return;\n+  bitmap_set_bit (same->bbs, bb->index);\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      int index = e->dest->index;\n+      bitmap_set_bit (same->succs, index);\n+      same_succ_edge_flags[index] = e->flags;\n+    }\n+  EXECUTE_IF_SET_IN_BITMAP (same->succs, 0, j, bj)\n+    VEC_safe_push (int, heap, same->succ_flags, same_succ_edge_flags[j]);\n+\n+  same->hashval = same_succ_hash (same);\n+\n+  slot = (same_succ *) htab_find_slot_with_hash (same_succ_htab, same,\n+\t\t\t\t\t\t   same->hashval, INSERT);\n+  if (*slot == NULL)\n+    {\n+      *slot = same;\n+      BB_SAME_SUCC (bb) = same;\n+      add_to_worklist (same);\n+      *same_p = NULL;\n+    }\n+  else\n+    {\n+      bitmap_set_bit ((*slot)->bbs, bb->index);\n+      BB_SAME_SUCC (bb) = *slot;\n+      add_to_worklist (*slot);\n+      if (inverse_flags (same, *slot))\n+\tbitmap_set_bit ((*slot)->inverse, bb->index);\n+      same_succ_reset (same);\n+    }\n+}\n+\n+/* Find bbs with same successors.  */\n+\n+static void\n+find_same_succ (void)\n+{\n+  same_succ same = same_succ_alloc ();\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      find_same_succ_bb (bb, &same);\n+      if (same == NULL)\n+\tsame = same_succ_alloc ();\n+    }\n+\n+  same_succ_delete (same);\n+}\n+\n+/* Initializes worklist administration.  */\n+\n+static void\n+init_worklist (void)\n+{\n+  alloc_aux_for_blocks (sizeof (struct aux_bb_info));\n+  same_succ_htab\n+    = htab_create (n_basic_blocks, same_succ_hash, same_succ_equal,\n+\t\t   same_succ_delete);\n+  same_succ_edge_flags = XCNEWVEC (int, last_basic_block);\n+  deleted_bbs = BITMAP_ALLOC (NULL);\n+  deleted_bb_preds = BITMAP_ALLOC (NULL);\n+  worklist = VEC_alloc (same_succ, heap, n_basic_blocks);\n+  find_same_succ ();\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"initial worklist:\\n\");\n+      print_worklist (dump_file);\n+    }\n+}\n+\n+/* Deletes worklist administration.  */\n+\n+static void\n+delete_worklist (void)\n+{\n+  free_aux_for_blocks ();\n+  htab_delete (same_succ_htab);\n+  same_succ_htab = NULL;\n+  XDELETEVEC (same_succ_edge_flags);\n+  same_succ_edge_flags = NULL;\n+  BITMAP_FREE (deleted_bbs);\n+  BITMAP_FREE (deleted_bb_preds);\n+  VEC_free (same_succ, heap, worklist);\n+}\n+\n+/* Mark BB as deleted, and mark its predecessors.  */\n+\n+static void\n+delete_basic_block_same_succ (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  bitmap_set_bit (deleted_bbs, bb->index);\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    bitmap_set_bit (deleted_bb_preds, e->src->index);\n+}\n+\n+/* Removes all bbs in BBS from their corresponding same_succ.  */\n+\n+static void\n+same_succ_flush_bbs (bitmap bbs)\n+{\n+  unsigned int i;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (bbs, 0, i, bi)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      same_succ same = BB_SAME_SUCC (bb);\n+      BB_SAME_SUCC (bb) = NULL;\n+      if (bitmap_single_bit_set_p (same->bbs))\n+\thtab_remove_elt_with_hash (same_succ_htab, same, same->hashval);\n+      else\n+\tbitmap_clear_bit (same->bbs, i);\n+    }\n+}\n+\n+/* Delete all deleted_bbs.  */\n+\n+static void\n+purge_bbs (void)\n+{\n+  unsigned int i;\n+  bitmap_iterator bi;\n+\n+  same_succ_flush_bbs (deleted_bbs);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (deleted_bbs, 0, i, bi)\n+    delete_basic_block (BASIC_BLOCK (i));\n+\n+  bitmap_and_compl_into (deleted_bb_preds, deleted_bbs);\n+  bitmap_clear (deleted_bbs);\n+}\n+\n+/* For deleted_bb_preds, find bbs with same successors.  */\n+\n+static void\n+update_worklist (void)\n+{\n+  unsigned int i;\n+  bitmap_iterator bi;\n+  basic_block bb;\n+  same_succ same;\n+\n+  bitmap_clear_bit (deleted_bb_preds, ENTRY_BLOCK);\n+  same_succ_flush_bbs (deleted_bb_preds);\n+\n+  same = same_succ_alloc ();\n+  EXECUTE_IF_SET_IN_BITMAP (deleted_bb_preds, 0, i, bi)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      gcc_assert (bb != NULL);\n+      find_same_succ_bb (bb, &same);\n+      if (same == NULL)\n+\tsame = same_succ_alloc ();\n+    }\n+  same_succ_delete (same);\n+  bitmap_clear (deleted_bb_preds);\n+}\n+\n+/* Prints cluster C to FILE.  */\n+\n+static void\n+print_cluster (FILE *file, bb_cluster c)\n+{\n+  if (c == NULL)\n+    return;\n+  bitmap_print (file, c->bbs, \"bbs:\", \"\\n\");\n+  bitmap_print (file, c->preds, \"preds:\", \"\\n\");\n+}\n+\n+/* Prints cluster C to stderr.  */\n+\n+extern void debug_cluster (bb_cluster);\n+DEBUG_FUNCTION void\n+debug_cluster (bb_cluster c)\n+{\n+  print_cluster (stderr, c);\n+}\n+\n+/* Update C->rep_bb, given that BB is added to the cluster.  */\n+\n+static void\n+update_rep_bb (bb_cluster c, basic_block bb)\n+{\n+  /* Initial.  */\n+  if (c->rep_bb == NULL)\n+    {\n+      c->rep_bb = bb;\n+      return;\n+    }\n+\n+  /* Current needs no deps, keep it.  */\n+  if (BB_DEP_BB (c->rep_bb) == NULL)\n+    return;\n+\n+  /* Bb needs no deps, change rep_bb.  */\n+  if (BB_DEP_BB (bb) == NULL)\n+    {\n+      c->rep_bb = bb;\n+      return;\n+    }\n+\n+  /* Bb needs last deps earlier than current, change rep_bb.  A potential\n+     problem with this, is that the first deps might also be earlier, which\n+     would mean we prefer longer lifetimes for the deps.  To be able to check\n+     for this, we would have to trace BB_FIRST_DEP_BB as well, besides\n+     BB_DEP_BB, which is really BB_LAST_DEP_BB.\n+     The benefit of choosing the bb with last deps earlier, is that it can\n+     potentially be used as replacement for more bbs.  */\n+  if (dominated_by_p (CDI_DOMINATORS, BB_DEP_BB (c->rep_bb), BB_DEP_BB (bb)))\n+    c->rep_bb = bb;\n+}\n+\n+/* Add BB to cluster C.  Sets BB in C->bbs, and preds of BB in C->preds.  */\n+\n+static void\n+add_bb_to_cluster (bb_cluster c, basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  bitmap_set_bit (c->bbs, bb->index);\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    bitmap_set_bit (c->preds, e->src->index);\n+\n+  update_rep_bb (c, bb);\n+}\n+\n+/* Allocate and init new cluster.  */\n+\n+static bb_cluster\n+new_cluster (void)\n+{\n+  bb_cluster c;\n+  c = XCNEW (struct bb_cluster_def);\n+  c->bbs = BITMAP_ALLOC (NULL);\n+  c->preds = BITMAP_ALLOC (NULL);\n+  c->rep_bb = NULL;\n+  return c;\n+}\n+\n+/* Delete clusters.  */\n+\n+static void\n+delete_cluster (bb_cluster c)\n+{\n+  if (c == NULL)\n+    return;\n+  BITMAP_FREE (c->bbs);\n+  BITMAP_FREE (c->preds);\n+  XDELETE (c);\n+}\n+\n+DEF_VEC_P (bb_cluster);\n+DEF_VEC_ALLOC_P (bb_cluster, heap);\n+\n+/* Array that contains all clusters.  */\n+\n+static VEC (bb_cluster, heap) *all_clusters;\n+\n+/* Allocate all cluster vectors.  */\n+\n+static void\n+alloc_cluster_vectors (void)\n+{\n+  all_clusters = VEC_alloc (bb_cluster, heap, n_basic_blocks);\n+}\n+\n+/* Reset all cluster vectors.  */\n+\n+static void\n+reset_cluster_vectors (void)\n+{\n+  unsigned int i;\n+  basic_block bb;\n+  for (i = 0; i < VEC_length (bb_cluster, all_clusters); ++i)\n+    delete_cluster (VEC_index (bb_cluster, all_clusters, i));\n+  VEC_truncate (bb_cluster, all_clusters, 0);\n+  FOR_EACH_BB (bb)\n+    BB_CLUSTER (bb) = NULL;\n+}\n+\n+/* Delete all cluster vectors.  */\n+\n+static void\n+delete_cluster_vectors (void)\n+{\n+  unsigned int i;\n+  for (i = 0; i < VEC_length (bb_cluster, all_clusters); ++i)\n+    delete_cluster (VEC_index (bb_cluster, all_clusters, i));\n+  VEC_free (bb_cluster, heap, all_clusters);\n+}\n+\n+/* Merge cluster C2 into C1.  */\n+\n+static void\n+merge_clusters (bb_cluster c1, bb_cluster c2)\n+{\n+  bitmap_ior_into (c1->bbs, c2->bbs);\n+  bitmap_ior_into (c1->preds, c2->preds);\n+}\n+\n+/* Register equivalence of BB1 and BB2 (members of cluster C).  Store c in\n+   all_clusters, or merge c with existing cluster.  */\n+\n+static void\n+set_cluster (basic_block bb1, basic_block bb2)\n+{\n+  basic_block merge_bb, other_bb;\n+  bb_cluster merge, old, c;\n+\n+  if (BB_CLUSTER (bb1) == NULL && BB_CLUSTER (bb2) == NULL)\n+    {\n+      c = new_cluster ();\n+      add_bb_to_cluster (c, bb1);\n+      add_bb_to_cluster (c, bb2);\n+      BB_CLUSTER (bb1) = c;\n+      BB_CLUSTER (bb2) = c;\n+      c->index = VEC_length (bb_cluster, all_clusters);\n+      VEC_safe_push (bb_cluster, heap, all_clusters, c);\n+    }\n+  else if (BB_CLUSTER (bb1) == NULL || BB_CLUSTER (bb2) == NULL)\n+    {\n+      merge_bb = BB_CLUSTER (bb1) == NULL ? bb2 : bb1;\n+      other_bb = BB_CLUSTER (bb1) == NULL ? bb1 : bb2;\n+      merge = BB_CLUSTER (merge_bb);\n+      add_bb_to_cluster (merge, other_bb);\n+      BB_CLUSTER (other_bb) = merge;\n+    }\n+  else if (BB_CLUSTER (bb1) != BB_CLUSTER (bb2))\n+    {\n+      unsigned int i;\n+      bitmap_iterator bi;\n+\n+      old = BB_CLUSTER (bb2);\n+      merge = BB_CLUSTER (bb1);\n+      merge_clusters (merge, old);\n+      EXECUTE_IF_SET_IN_BITMAP (old->bbs, 0, i, bi)\n+\tBB_CLUSTER (BASIC_BLOCK (i)) = merge;\n+      VEC_replace (bb_cluster, all_clusters, old->index, NULL);\n+      update_rep_bb (merge, old->rep_bb);\n+      delete_cluster (old);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Return true if gimple statements S1 and S2 are equal.  Gimple_bb (s1) and\n+   gimple_bb (s2) are members of SAME_SUCC.  */\n+\n+static bool\n+gimple_equal_p (same_succ same_succ, gimple s1, gimple s2)\n+{\n+  unsigned int i;\n+  tree lhs1, lhs2;\n+  basic_block bb1 = gimple_bb (s1), bb2 = gimple_bb (s2);\n+  tree t1, t2;\n+  bool equal, inv_cond;\n+  enum tree_code code1, code2;\n+\n+  if (gimple_code (s1) != gimple_code (s2))\n+    return false;\n+\n+  switch (gimple_code (s1))\n+    {\n+    case GIMPLE_CALL:\n+      if (gimple_call_num_args (s1) != gimple_call_num_args (s2))\n+\treturn false;\n+      if (!gimple_call_same_target_p (s1, s2))\n+        return false;\n+\n+      equal = true;\n+      for (i = 0; i < gimple_call_num_args (s1); ++i)\n+\t{\n+\t  t1 = gimple_call_arg (s1, i);\n+\t  t2 = gimple_call_arg (s2, i);\n+\t  if (operand_equal_p (t1, t2, 0))\n+\t    continue;\n+\t  if (gvn_uses_equal (t1, t2))\n+\t    continue;\n+\t  equal = false;\n+\t  break;\n+\t}\n+      if (equal)\n+\treturn true;\n+\n+      lhs1 = gimple_get_lhs (s1);\n+      lhs2 = gimple_get_lhs (s2);\n+      return (lhs1 != NULL_TREE && lhs2 != NULL_TREE\n+\t      && TREE_CODE (lhs1) == SSA_NAME && TREE_CODE (lhs2) == SSA_NAME\n+\t      && vn_valueize (lhs1) == vn_valueize (lhs2));\n+\n+    case GIMPLE_ASSIGN:\n+      lhs1 = gimple_get_lhs (s1);\n+      lhs2 = gimple_get_lhs (s2);\n+      return (TREE_CODE (lhs1) == SSA_NAME\n+\t      && TREE_CODE (lhs2) == SSA_NAME\n+\t      && vn_valueize (lhs1) == vn_valueize (lhs2));\n+\n+    case GIMPLE_COND:\n+      t1 = gimple_cond_lhs (s1);\n+      t2 = gimple_cond_lhs (s2);\n+      if (!operand_equal_p (t1, t2, 0)\n+\t  && !gvn_uses_equal (t1, t2))\n+\treturn false;\n+\n+      t1 = gimple_cond_rhs (s1);\n+      t2 = gimple_cond_rhs (s2);\n+      if (!operand_equal_p (t1, t2, 0)\n+\t  && !gvn_uses_equal (t1, t2))\n+\treturn false;\n+\n+      code1 = gimple_expr_code (s1);\n+      code2 = gimple_expr_code (s2);\n+      inv_cond = (bitmap_bit_p (same_succ->inverse, bb1->index)\n+\t\t  != bitmap_bit_p (same_succ->inverse, bb2->index));\n+      if (inv_cond)\n+\t{\n+\t  bool honor_nans\n+\t    = HONOR_NANS (TYPE_MODE (TREE_TYPE (gimple_cond_lhs (s1))));\n+\t  code2 = invert_tree_comparison (code2, honor_nans);\n+\t}\n+      return code1 == code2;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Let GSI skip backwards over local defs.  */\n+\n+static void\n+gsi_advance_bw_nondebug_nonlocal (gimple_stmt_iterator *gsi)\n+{\n+  gimple stmt;\n+\n+  while (true)\n+    {\n+      if (gsi_end_p (*gsi))\n+\treturn;\n+      stmt = gsi_stmt (*gsi);\n+      if (!(is_gimple_assign (stmt) && local_def (gimple_get_lhs (stmt))\n+\t    && !gimple_has_side_effects (stmt)))\n+\treturn;\n+      gsi_prev_nondebug (gsi);\n+    }\n+}\n+\n+/* Determines whether BB1 and BB2 (members of same_succ) are duplicates.  If so,\n+   clusters them.  */\n+\n+static void\n+find_duplicate (same_succ same_succ, basic_block bb1, basic_block bb2)\n+{\n+  gimple_stmt_iterator gsi1 = gsi_last_nondebug_bb (bb1);\n+  gimple_stmt_iterator gsi2 = gsi_last_nondebug_bb (bb2);\n+\n+  gsi_advance_bw_nondebug_nonlocal (&gsi1);\n+  gsi_advance_bw_nondebug_nonlocal (&gsi2);\n+\n+  while (!gsi_end_p (gsi1) && !gsi_end_p (gsi2))\n+    {\n+      if (!gimple_equal_p (same_succ, gsi_stmt (gsi1), gsi_stmt (gsi2)))\n+\treturn;\n+\n+      gsi_prev_nondebug (&gsi1);\n+      gsi_prev_nondebug (&gsi2);\n+      gsi_advance_bw_nondebug_nonlocal (&gsi1);\n+      gsi_advance_bw_nondebug_nonlocal (&gsi2);\n+    }\n+\n+  if (!(gsi_end_p (gsi1) && gsi_end_p (gsi2)))\n+    return;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"find_duplicates: <bb %d> duplicate of <bb %d>\\n\",\n+\t     bb1->index, bb2->index);\n+\n+  set_cluster (bb1, bb2);\n+}\n+\n+/* Returns whether for all phis in DEST the phi alternatives for E1 and\n+   E2 are equal.  */\n+\n+static bool\n+same_phi_alternatives_1 (basic_block dest, edge e1, edge e2)\n+{\n+  int n1 = e1->dest_idx, n2 = e2->dest_idx;\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_phis (dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      tree lhs = gimple_phi_result (phi);\n+      tree val1 = gimple_phi_arg_def (phi, n1);\n+      tree val2 = gimple_phi_arg_def (phi, n2);\n+\n+      if (!is_gimple_reg (lhs))\n+\tcontinue;\n+\n+      if (operand_equal_for_phi_arg_p (val1, val2))\n+        continue;\n+      if (gvn_uses_equal (val1, val2))\n+\tcontinue;\n+\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Returns whether for all successors of BB1 and BB2 (members of SAME_SUCC), the\n+   phi alternatives for BB1 and BB2 are equal.  */\n+\n+static bool\n+same_phi_alternatives (same_succ same_succ, basic_block bb1, basic_block bb2)\n+{\n+  unsigned int s;\n+  bitmap_iterator bs;\n+  edge e1, e2;\n+  basic_block succ;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (same_succ->succs, 0, s, bs)\n+    {\n+      succ = BASIC_BLOCK (s);\n+      e1 = find_edge (bb1, succ);\n+      e2 = find_edge (bb2, succ);\n+      if (e1->flags & EDGE_COMPLEX\n+\t  || e2->flags & EDGE_COMPLEX)\n+\treturn false;\n+\n+      /* For all phis in bb, the phi alternatives for e1 and e2 need to have\n+\t the same value.  */\n+      if (!same_phi_alternatives_1 (succ, e1, e2))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true if BB has non-vop phis.  */\n+\n+static bool\n+bb_has_non_vop_phi (basic_block bb)\n+{\n+  gimple_seq phis = phi_nodes (bb);\n+  gimple phi;\n+\n+  if (phis == NULL)\n+    return false;\n+\n+  if (!gimple_seq_singleton_p (phis))\n+    return true;\n+\n+  phi = gimple_seq_first_stmt (phis);\n+  return is_gimple_reg (gimple_phi_result (phi));\n+}\n+\n+/* Returns true if redirecting the incoming edges of FROM to TO maintains the\n+   invariant that uses in FROM are dominates by their defs.  */\n+\n+static bool\n+deps_ok_for_redirect_from_bb_to_bb (basic_block from, basic_block to)\n+{\n+  basic_block cd, dep_bb = BB_DEP_BB (to);\n+  edge_iterator ei;\n+  edge e;\n+  bitmap from_preds = BITMAP_ALLOC (NULL);\n+\n+  if (dep_bb == NULL)\n+    return true;\n+\n+  FOR_EACH_EDGE (e, ei, from->preds)\n+    bitmap_set_bit (from_preds, e->src->index);\n+  cd = nearest_common_dominator_for_set (CDI_DOMINATORS, from_preds);\n+  BITMAP_FREE (from_preds);\n+\n+  return dominated_by_p (CDI_DOMINATORS, dep_bb, cd);\n+}\n+\n+/* Returns true if replacing BB1 (or its replacement bb) by BB2 (or its\n+   replacement bb) and vice versa maintains the invariant that uses in the\n+   replacement are dominates by their defs.  */\n+\n+static bool\n+deps_ok_for_redirect (basic_block bb1, basic_block bb2)\n+{\n+  if (BB_CLUSTER (bb1) != NULL)\n+    bb1 = BB_CLUSTER (bb1)->rep_bb;\n+\n+  if (BB_CLUSTER (bb2) != NULL)\n+    bb2 = BB_CLUSTER (bb2)->rep_bb;\n+\n+  return (deps_ok_for_redirect_from_bb_to_bb (bb1, bb2)\n+\t  && deps_ok_for_redirect_from_bb_to_bb (bb2, bb1));\n+}\n+\n+/* Within SAME_SUCC->bbs, find clusters of bbs which can be merged.  */\n+\n+static void\n+find_clusters_1 (same_succ same_succ)\n+{\n+  basic_block bb1, bb2;\n+  unsigned int i, j;\n+  bitmap_iterator bi, bj;\n+  int nr_comparisons;\n+  int max_comparisons = PARAM_VALUE (PARAM_MAX_TAIL_MERGE_COMPARISONS);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (same_succ->bbs, 0, i, bi)\n+    {\n+      bb1 = BASIC_BLOCK (i);\n+\n+      /* TODO: handle blocks with phi-nodes.  We'll have to find corresponding\n+\t phi-nodes in bb1 and bb2, with the same alternatives for the same\n+\t preds.  */\n+      if (bb_has_non_vop_phi (bb1))\n+\tcontinue;\n+\n+      nr_comparisons = 0;\n+      EXECUTE_IF_SET_IN_BITMAP (same_succ->bbs, i + 1, j, bj)\n+\t{\n+\t  bb2 = BASIC_BLOCK (j);\n+\n+\t  if (bb_has_non_vop_phi (bb2))\n+\t    continue;\n+\n+\t  if (BB_CLUSTER (bb1) != NULL && BB_CLUSTER (bb1) == BB_CLUSTER (bb2))\n+\t    continue;\n+\n+\t  /* Limit quadratic behaviour.  */\n+\t  nr_comparisons++;\n+\t  if (nr_comparisons > max_comparisons)\n+\t    break;\n+\n+\t  /* This is a conservative dependency check.  We could test more\n+\t     precise for allowed replacement direction.  */\n+\t  if (!deps_ok_for_redirect (bb1, bb2))\n+\t    continue;\n+\n+\t  if (!(same_phi_alternatives (same_succ, bb1, bb2)))\n+\t    continue;\n+\n+\t  find_duplicate (same_succ, bb1, bb2);\n+        }\n+    }\n+}\n+\n+/* Find clusters of bbs which can be merged.  */\n+\n+static void\n+find_clusters (void)\n+{\n+  same_succ same;\n+\n+  while (!VEC_empty (same_succ, worklist))\n+    {\n+      same = VEC_pop (same_succ, worklist);\n+      same->in_worklist = false;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"processing worklist entry\\n\");\n+\t  same_succ_print (dump_file, same);\n+\t}\n+      find_clusters_1 (same);\n+    }\n+}\n+\n+/* Create or update a vop phi in BB2.  Use VUSE1 arguments for all the\n+   REDIRECTED_EDGES, or if VUSE1 is NULL_TREE, use BB_VOP_AT_EXIT.  If a new\n+   phis is created, use the phi instead of VUSE2 in BB2.  */\n+\n+static void\n+update_vuses (tree vuse1, tree vuse2, basic_block bb2,\n+              VEC (edge,heap) *redirected_edges)\n+{\n+  gimple stmt, phi = NULL;\n+  tree lhs = NULL_TREE, arg;\n+  unsigned int i;\n+  gimple def_stmt2;\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n+  edge_iterator ei;\n+  edge e;\n+\n+  def_stmt2 = SSA_NAME_DEF_STMT (vuse2);\n+\n+  if (gimple_bb (def_stmt2) == bb2)\n+    /* Update existing phi.  */\n+    phi = def_stmt2;\n+  else\n+    {\n+      /* No need to create a phi with 2 equal arguments.  */\n+      if (vuse1 == vuse2)\n+\treturn;\n+\n+      /* Create a phi.  */\n+      lhs = make_ssa_name (SSA_NAME_VAR (vuse2), NULL);\n+      VN_INFO_GET (lhs);\n+      phi = create_phi_node (lhs, bb2);\n+      SSA_NAME_DEF_STMT (lhs) = phi;\n+\n+      /* Set default argument vuse2 for all preds.  */\n+      FOR_EACH_EDGE (e, ei, bb2->preds)\n+\tadd_phi_arg (phi, vuse2, e, UNKNOWN_LOCATION);\n+    }\n+\n+  /* Update phi.  */\n+  for (i = 0; i < EDGE_COUNT (redirected_edges); ++i)\n+    {\n+      e = VEC_index (edge, redirected_edges, i);\n+      if (vuse1 != NULL_TREE)\n+\targ = vuse1;\n+      else\n+\targ = BB_VOP_AT_EXIT (e->src);\n+      add_phi_arg (phi, arg, e, UNKNOWN_LOCATION);\n+    }\n+\n+  /* Return if we updated an existing phi.  */\n+  if (gimple_bb (def_stmt2) == bb2)\n+    return;\n+\n+  /* Replace relevant uses of vuse2 with the newly created phi.  */\n+  FOR_EACH_IMM_USE_STMT (stmt, iter, vuse2)\n+    {\n+      if (stmt == phi)\n+\tcontinue;\n+      if (gimple_code (stmt) != GIMPLE_PHI)\n+\tif (gimple_bb (stmt) != bb2)\n+\t  continue;\n+\n+      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t{\n+\t  if (gimple_code (stmt) == GIMPLE_PHI)\n+\t    {\n+\t      unsigned int pred_index = PHI_ARG_INDEX_FROM_USE (use_p);\n+\t      basic_block pred = EDGE_PRED (gimple_bb (stmt), pred_index)->src;\n+\t      if (pred !=  bb2)\n+\t\tcontinue;\n+\t    }\n+\t  SET_USE (use_p, lhs);\n+\t  update_stmt (stmt);\n+\t}\n+    }\n+}\n+\n+/* Returns the vop phi of BB, if any.  */\n+\n+static gimple\n+vop_phi (basic_block bb)\n+{\n+  gimple stmt;\n+  gimple_stmt_iterator gsi;\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      stmt = gsi_stmt (gsi);\n+      if (is_gimple_reg (gimple_phi_result (stmt)))\n+\tcontinue;\n+      return stmt;\n+    }\n+  return NULL;\n+}\n+\n+/* Returns the vop state at the entry of BB, if found in BB or a successor\n+   bb.  */\n+\n+static tree\n+vop_at_entry (basic_block bb)\n+{\n+  gimple bb_phi, succ_phi;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n+  tree vuse, vdef;\n+  basic_block succ;\n+\n+  bb_phi = vop_phi (bb);\n+  if (bb_phi != NULL)\n+    return gimple_phi_result (bb_phi);\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      stmt = gsi_stmt (gsi);\n+      vuse = gimple_vuse (stmt);\n+      vdef = gimple_vdef (stmt);\n+      if (vuse != NULL_TREE)\n+\treturn vuse;\n+      if (vdef != NULL_TREE)\n+\treturn NULL_TREE;\n+    }\n+\n+  if (EDGE_COUNT (bb->succs) == 0)\n+    return NULL_TREE;\n+\n+  succ = EDGE_SUCC (bb, 0)->dest;\n+  succ_phi = vop_phi (succ);\n+  return (succ_phi != NULL\n+\t  ? PHI_ARG_DEF_FROM_EDGE (succ_phi, find_edge (bb, succ))\n+\t  : NULL_TREE);\n+}\n+\n+/* Redirect all edges from BB1 to BB2, marks BB1 for removal, and if\n+   UPDATE_VOPS, inserts vop phis.  */\n+\n+static void\n+replace_block_by (basic_block bb1, basic_block bb2, bool update_vops)\n+{\n+  edge pred_edge;\n+  unsigned int i;\n+  tree phi_vuse1 = NULL_TREE, phi_vuse2 = NULL_TREE, arg;\n+  VEC (edge,heap) *redirected_edges = NULL;\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (update_vops)\n+    {\n+      /* Find the vops at entry of bb1 and bb2.  */\n+      phi_vuse1 = vop_at_entry (bb1);\n+      phi_vuse2 = vop_at_entry (bb2);\n+\n+      /* If one of the 2 not found, it means there's no need to update.  */\n+      update_vops = phi_vuse1 != NULL_TREE && phi_vuse2 != NULL_TREE;\n+    }\n+\n+  if (update_vops && gimple_bb (SSA_NAME_DEF_STMT (phi_vuse1)) == bb1)\n+    {\n+      /* If the vop at entry of bb1 is a phi, save the phi alternatives in\n+\t BB_VOP_AT_EXIT, before we lose that information by redirecting the\n+\t edges.  */\n+      FOR_EACH_EDGE (e, ei, bb1->preds)\n+\t{\n+\t  arg = PHI_ARG_DEF_FROM_EDGE (SSA_NAME_DEF_STMT (phi_vuse1), e);\n+\t  BB_VOP_AT_EXIT (e->src) = arg;\n+\t}\n+      phi_vuse1 = NULL;\n+    }\n+\n+  /* Mark the basic block for later deletion.  */\n+  delete_basic_block_same_succ (bb1);\n+\n+  if (update_vops)\n+    redirected_edges = VEC_alloc (edge, heap, 10);\n+\n+  /* Redirect the incoming edges of bb1 to bb2.  */\n+  for (i = EDGE_COUNT (bb1->preds); i > 0 ; --i)\n+    {\n+      pred_edge = EDGE_PRED (bb1, i - 1);\n+      pred_edge = redirect_edge_and_branch (pred_edge, bb2);\n+      gcc_assert (pred_edge != NULL);\n+      if (update_vops)\n+\tVEC_safe_push (edge, heap, redirected_edges, pred_edge);\n+    }\n+\n+  /* Update the vops.  */\n+  if (update_vops)\n+    {\n+      update_vuses (phi_vuse1, phi_vuse2, bb2, redirected_edges);\n+      VEC_free (edge, heap, redirected_edges);\n+    }\n+}\n+\n+/* Bbs for which update_debug_stmt need to be called.  */\n+\n+static bitmap update_bbs;\n+\n+/* For each cluster in all_clusters, merge all cluster->bbs.  Returns\n+   number of bbs removed.  Insert vop phis if UPDATE_VOPS.  */\n+\n+static int\n+apply_clusters (bool update_vops)\n+{\n+  basic_block bb1, bb2;\n+  bb_cluster c;\n+  unsigned int i, j;\n+  bitmap_iterator bj;\n+  int nr_bbs_removed = 0;\n+\n+  for (i = 0; i < VEC_length (bb_cluster, all_clusters); ++i)\n+    {\n+      c = VEC_index (bb_cluster, all_clusters, i);\n+      if (c == NULL)\n+\tcontinue;\n+\n+      bb2 = c->rep_bb;\n+      bitmap_set_bit (update_bbs, bb2->index);\n+\n+      bitmap_clear_bit (c->bbs, bb2->index);\n+      EXECUTE_IF_SET_IN_BITMAP (c->bbs, 0, j, bj)\n+\t{\n+\t  bb1 = BASIC_BLOCK (j);\n+\t  bitmap_clear_bit (update_bbs, bb1->index);\n+\n+\t  replace_block_by (bb1, bb2, update_vops);\n+\t  nr_bbs_removed++;\n+\t}\n+    }\n+\n+  return nr_bbs_removed;\n+}\n+\n+/* Resets debug statement STMT if it has uses that are not dominated by their\n+   defs.  */\n+\n+static void\n+update_debug_stmt (gimple stmt)\n+{\n+  use_operand_p use_p;\n+  ssa_op_iter oi;\n+  basic_block bbdef, bbuse;\n+  gimple def_stmt;\n+  tree name;\n+\n+  if (!gimple_debug_bind_p (stmt))\n+    return;\n+\n+  bbuse = gimple_bb (stmt);\n+  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, oi, SSA_OP_USE)\n+    {\n+      name = USE_FROM_PTR (use_p);\n+      gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+      def_stmt = SSA_NAME_DEF_STMT (name);\n+      gcc_assert (def_stmt != NULL);\n+\n+      bbdef = gimple_bb (def_stmt);\n+      if (bbdef == NULL || bbuse == bbdef\n+\t  || dominated_by_p (CDI_DOMINATORS, bbuse, bbdef))\n+\tcontinue;\n+\n+      gimple_debug_bind_reset_value (stmt);\n+      update_stmt (stmt);\n+    }\n+}\n+\n+/* Resets all debug statements that have uses that are not\n+   dominated by their defs.  */\n+\n+static void\n+update_debug_stmts (void)\n+{\n+  basic_block bb;\n+  bitmap_iterator bi;\n+  unsigned int i;\n+\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (update_bbs, 0, i, bi)\n+    {\n+      gimple stmt;\n+      gimple_stmt_iterator gsi;\n+\n+      bb = BASIC_BLOCK (i);\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  stmt = gsi_stmt (gsi);\n+\t  if (!is_gimple_debug (stmt))\n+\t    continue;\n+\t  update_debug_stmt (stmt);\n+\t}\n+    }\n+}\n+\n+/* Runs tail merge optimization.  */\n+\n+unsigned int\n+tail_merge_optimize (unsigned int todo)\n+{\n+  int nr_bbs_removed_total = 0;\n+  int nr_bbs_removed;\n+  bool loop_entered = false;\n+  int iteration_nr = 0;\n+  bool update_vops = !symbol_marked_for_renaming (gimple_vop (cfun));\n+  int max_iterations = PARAM_VALUE (PARAM_MAX_TAIL_MERGE_ITERATIONS);\n+\n+  if (!flag_tree_tail_merge || max_iterations == 0)\n+    return 0;\n+\n+  timevar_push (TV_TREE_TAIL_MERGE);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  init_worklist ();\n+\n+  while (!VEC_empty (same_succ, worklist))\n+    {\n+      if (!loop_entered)\n+\t{\n+\t  loop_entered = true;\n+\t  alloc_cluster_vectors ();\n+\t  update_bbs = BITMAP_ALLOC (NULL);\n+\t}\n+      else\n+\treset_cluster_vectors ();\n+\n+      iteration_nr++;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"worklist iteration #%d\\n\", iteration_nr);\n+\n+      find_clusters ();\n+      gcc_assert (VEC_empty (same_succ, worklist));\n+      if (VEC_empty (bb_cluster, all_clusters))\n+\tbreak;\n+\n+      nr_bbs_removed = apply_clusters (update_vops);\n+      nr_bbs_removed_total += nr_bbs_removed;\n+      if (nr_bbs_removed == 0)\n+\tbreak;\n+\n+      free_dominance_info (CDI_DOMINATORS);\n+      purge_bbs ();\n+\n+      if (iteration_nr == max_iterations)\n+\tbreak;\n+\n+      calculate_dominance_info (CDI_DOMINATORS);\n+      update_worklist ();\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"htab collision / search: %f\\n\",\n+\t     htab_collisions (same_succ_htab));\n+\n+  if (nr_bbs_removed_total > 0)\n+    {\n+      calculate_dominance_info (CDI_DOMINATORS);\n+      update_debug_stmts ();\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Before TODOs.\\n\");\n+\t  dump_function_to_file (current_function_decl, dump_file, dump_flags);\n+\t}\n+\n+      todo |= (TODO_verify_ssa | TODO_verify_stmts | TODO_verify_flow\n+\t       | TODO_dump_func);\n+    }\n+\n+  delete_worklist ();\n+  if (loop_entered)\n+    {\n+      delete_cluster_vectors ();\n+      BITMAP_FREE (update_bbs);\n+    }\n+\n+  timevar_pop (TV_TREE_TAIL_MERGE);\n+\n+  return todo;\n+}"}]}