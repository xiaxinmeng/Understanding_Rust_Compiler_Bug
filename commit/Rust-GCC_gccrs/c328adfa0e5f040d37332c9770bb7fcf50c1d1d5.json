{"sha": "c328adfa0e5f040d37332c9770bb7fcf50c1d1d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMyOGFkZmEwZTVmMDQwZDM3MzMyYzk3NzBiYjdmY2Y1MGMxZDFkNQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-04-16T17:06:50Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-04-16T17:06:50Z"}, "message": "pa-protos.h (function_arg): Remove last argument.\n\n\tPR/10271\n\t* pa-protos.h (function_arg): Remove last argument.\n\t* pa.c (function_arg): Likewise.  Use CUMULATIVE_ARGS struct instead.\n\t* pa.h (struct hppa_args): Add member incoming.\n\t(INIT_CUMULATIVE_ARGS, INIT_CUMULATIVE_INCOMING_ARGS): Initialize\n\tmember incoming.\n\t(FUNCTION_ARG): Revise call to function_arg.\n\t(FUNCTION_INCOMING_ARG): Delete.\n\nFrom-SVN: r65687", "tree": {"sha": "8ccf4ead4e53e45a1d34e8860575df8175203cf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ccf4ead4e53e45a1d34e8860575df8175203cf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/comments", "author": null, "committer": null, "parents": [{"sha": "771aa05a0bb290df9d593cb29da7eb311b57d6db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771aa05a0bb290df9d593cb29da7eb311b57d6db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/771aa05a0bb290df9d593cb29da7eb311b57d6db"}], "stats": {"total": 53, "additions": 36, "deletions": 17}, "files": [{"sha": "6d31695eef5821af87733ff41054e5884c6eea3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c328adfa0e5f040d37332c9770bb7fcf50c1d1d5", "patch": "@@ -1,3 +1,14 @@\n+2003-04-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR/10271\n+\t* pa-protos.h (function_arg): Remove last argument.\n+\t* pa.c (function_arg): Likewise.  Use CUMULATIVE_ARGS struct instead.\n+\t* pa.h (struct hppa_args): Add member incoming. \n+\t(INIT_CUMULATIVE_ARGS, INIT_CUMULATIVE_INCOMING_ARGS): Initialize\n+\tmember incoming.\n+\t(FUNCTION_ARG): Revise call to function_arg.\n+\t(FUNCTION_INCOMING_ARG): Delete.\n+\n 2003-04-15  Zack Weinberg  <zack@codesourcery.com>\n \n \t* configure.in: Unify the code which creates symlinks to a"}, {"sha": "11f652b868ca61e0424e003d2fe015733e39a9cb", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=c328adfa0e5f040d37332c9770bb7fcf50c1d1d5", "patch": "@@ -160,7 +160,7 @@ extern int cmpib_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int reloc_needed PARAMS ((tree));\n #ifdef RTX_CODE\n extern rtx function_arg PARAMS ((CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t tree, int, int));\n+\t\t\t\t tree, int));\n extern rtx function_value PARAMS ((tree, tree));\n #endif\n extern int function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *,"}, {"sha": "3e46ffba481e924fe91f99cf573b050acbf88e3f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=c328adfa0e5f040d37332c9770bb7fcf50c1d1d5", "patch": "@@ -8246,12 +8246,11 @@ function_value (valtype, func)\n    ??? We might want to restructure this so that it looks more like other\n    ports.  */\n rtx\n-function_arg (cum, mode, type, named, incoming)\n+function_arg (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\n      enum machine_mode mode;\n      tree type;\n      int named ATTRIBUTE_UNUSED;\n-     int incoming;\n {\n   int max_arg_words = (TARGET_64BIT ? 8 : 4);\n   int alignment = 0;\n@@ -8393,7 +8392,7 @@ function_arg (cum, mode, type, named, incoming)\n   if (((TARGET_PORTABLE_RUNTIME || TARGET_64BIT || TARGET_ELF32)\n        /* If we are doing soft-float with portable runtime, then there\n \t  is no need to worry about FP regs.  */\n-       && ! TARGET_SOFT_FLOAT\n+       && !TARGET_SOFT_FLOAT\n        /* The parameter must be some kind of float, else we can just\n \t  pass it in integer registers.  */\n        && FLOAT_MODE_P (mode)\n@@ -8402,14 +8401,15 @@ function_arg (cum, mode, type, named, incoming)\n        /* libcalls do not need to pass items in both FP and general\n \t  registers.  */\n        && type != NULL_TREE\n-       /* All this hair applies to outgoing args only.  */\n-       && ! incoming)\n+       /* All this hair applies to \"outgoing\" args only.  This includes\n+\t  sibcall arguments setup with FUNCTION_INCOMING_ARG.  */\n+       && !cum->incoming)\n       /* Also pass outgoing floating arguments in both registers in indirect\n \t calls with the 32 bit ABI and the HP assembler since there is no\n \t way to the specify argument locations in static functions.  */\n-      || (! TARGET_64BIT\n-\t  && ! TARGET_GAS\n-\t  && ! incoming\n+      || (!TARGET_64BIT\n+\t  && !TARGET_GAS\n+\t  && !cum->incoming\n \t  && cum->indirect\n \t  && FLOAT_MODE_P (mode)))\n     {"}, {"sha": "ff1e91829286b57e95ed265cc0abb3d48798d055", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c328adfa0e5f040d37332c9770bb7fcf50c1d1d5/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=c328adfa0e5f040d37332c9770bb7fcf50c1d1d5", "patch": "@@ -772,12 +772,21 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n \n-   On the HP-PA, this is a single integer, which is a number of words\n+   On the HP-PA, the WORDS field holds the number of words\n    of arguments scanned so far (including the invisible argument,\n-   if any, which holds the structure-value-address).\n-   Thus 4 or more means all following args should go on the stack.  */\n+   if any, which holds the structure-value-address).  Thus, 4 or\n+   more means all following args should go on the stack.\n+   \n+   The INCOMING field tracks whether this is an \"incoming\" or\n+   \"outgoing\" argument.\n+   \n+   The INDIRECT field indicates whether this is is an indirect\n+   call or not.\n+   \n+   The NARGS_PROTOTYPE field indicates that an argument does not\n+   have a prototype when it less than or equal to 0.  */\n \n-struct hppa_args {int words, nargs_prototype, indirect; };\n+struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n \n #define CUMULATIVE_ARGS struct hppa_args\n \n@@ -787,6 +796,7 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n \n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL) \\\n   (CUM).words = 0, \t\t\t\t\t\t\t\\\n+  (CUM).incoming = 0,\t\t\t\t\t\t\t\\\n   (CUM).indirect = (FNTYPE) && !(FNDECL),\t\t\t\t\\\n   (CUM).nargs_prototype = (FNTYPE && TYPE_ARG_TYPES (FNTYPE)\t\t\\\n \t\t\t   ? (list_length (TYPE_ARG_TYPES (FNTYPE)) - 1\t\\\n@@ -801,6 +811,7 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n \n #define INIT_CUMULATIVE_INCOMING_ARGS(CUM,FNTYPE,IGNORE) \\\n   (CUM).words = 0,\t\t\t\t\\\n+  (CUM).incoming = 1,\t\t\t\t\\\n   (CUM).indirect = 0,\t\t\t\t\\\n   (CUM).nargs_prototype = 1000\n \n@@ -876,17 +887,14 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n    tempted to try and simply it, but I worry about breaking something.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  function_arg (&CUM, MODE, TYPE, NAMED, 0)\n+  function_arg (&CUM, MODE, TYPE, NAMED)\n \n /* Nonzero if we do not know how to pass TYPE solely in registers.  */\n #define MUST_PASS_IN_STACK(MODE,TYPE) \\\n   ((TYPE) != 0\t\t\t\t\t\t\t\\\n    && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n        || TREE_ADDRESSABLE (TYPE)))\n \n-#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n-  function_arg (&CUM, MODE, TYPE, NAMED, 1)\n-\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */"}]}