{"sha": "6560f85165c084768a77dda7086269604781ce5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU2MGY4NTE2NWMwODQ3NjhhNzdkZGE3MDg2MjY5NjA0NzgxY2U1ZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-01-11T08:54:12Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-01-11T08:54:12Z"}, "message": "[Ada] Secondary stack leaks during object initialization\n\nThis patch modifies the transient scope mechanism to prevent secondary stack\nleaks during object initialization. The modifications are as follows:\n\n1) Prior to this change, the secondary stack was never managed within type\ninitialization procedures, for reasons unknown. It is speculated that the\ncontrolled type model used at that time may have influenced this decision.\nThe secondary stack is now managed within type initialization procedures\nin order to recover the memory once individual components or whole objects\nare initialized.\n\n2) A transient scope now delegates the secondary stack management to an\nenclosing scope if there is no suitable context to wrap. This ensures that\nthe requirement to manage the secondary stack is not lost when the scope was\nestablished for that purpose in mind.\n\n3) A previous mechanism which examined the definition of a type (recursively)\nto determine whether the type will involve the secondary stack was removed\nbecause a) the mechanism could not detect this need with certainty, and b) the\ntrigger for secondary stack usage is now moved to the resolution of function\ncalls, which is always accurate.\n\n------------\n-- Source --\n------------\n\n--  types.ads\n\nwith Ada.Finalization; use Ada.Finalization;\n\npackage Types is\n   type Ctrl is new Controlled with record\n      Id : Integer;\n   end record;\n\n   procedure Initialize (Obj : in out Ctrl);\n\n   function Make_Ctrl return Ctrl;\n   function Make_Ctrl_From (Obj : Ctrl) return Ctrl;\n\n   type Constr is array (1 .. 3) of Ctrl;\n   type Unconstr is array (Integer range <>) of Ctrl;\n\n   function Make_Constr return Constr;\n   function Make_Unconstr (Low : Integer; High : Integer) return Unconstr;\n\n   type Rec_1 is new Controlled with record\n      Comp : Ctrl := Make_Ctrl;\n   end record;\n\n   type Rec_2 is new Controlled with record\n      Comp : Ctrl := Make_Ctrl_From (Make_Ctrl);\n   end record;\n\n   type Rec_3 is new Controlled with record\n      Comp : Constr := Make_Constr;\n   end record;\n\n   type Rec_4 is new Controlled with record\n      Comp : Unconstr (1 .. 3) := Make_Unconstr (1, 3);\n   end record;\n\n   type Rec_5 is record\n      Comp : Integer := 1 + Make_Ctrl.Id;\n   end record;\n\n   type Rec_6 is record\n      Comp : Boolean := (for all X in 1 .. Make_Ctrl.Id =>\n                           X = Make_Ctrl.Id);\n   end record;\nend Types;\n\n--  types.adb\n\npackage body Types is\n   Id_Gen : Integer := 0;\n\n   procedure Initialize (Obj : in out Ctrl) is\n   begin\n      Id_Gen := Id_Gen + 1;\n      Obj.Id := Id_Gen;\n   end Initialize;\n\n   function Make_Constr return Constr is\n      Result : constant Constr := (others => Make_Ctrl);\n   begin\n      return Result;\n   end Make_Constr;\n\n   function Make_Ctrl return Ctrl is\n      Result : Ctrl;\n   begin\n      return Result;\n   end Make_Ctrl;\n\n   function Make_Ctrl_From (Obj : Ctrl) return Ctrl is\n      Result : Ctrl;\n   begin\n      Result.Id := Obj.Id;\n      return Result;\n   end Make_Ctrl_From;\n\n   function Make_Unconstr (Low : Integer; High : Integer) return Unconstr is\n      Result : constant Unconstr (Low .. High) := (others => Make_Ctrl);\n   begin\n      return Result;\n   end Make_Unconstr;\nend Types;\n\n--  maker.ads\n\ngeneric\n   type Obj_Typ is private;\nprocedure Maker (Count : Positive);\n\n--  maker.adb\n\nprocedure Maker (Count : Positive) is\n   procedure Create is\n      Obj : Obj_Typ;\n      pragma Warnings (Off, Obj);\n   begin null; end Create;\n\nbegin\n   for Iter in 1 .. Count loop\n      Create;\n   end loop;\nend Maker;\n\n--  leaks.adb\n\nwith Maker;\nwith Types; use Types;\n\nwith Maker;\nwith Types; use Types;\n\nprocedure Leaks is\n   procedure Make_1 is new Maker (Rec_1);\n   procedure Make_2 is new Maker (Rec_2);\n   procedure Make_3 is new Maker (Rec_3);\n   procedure Make_4 is new Maker (Rec_4);\n   procedure Make_5 is new Maker (Rec_5);\n   procedure Make_6 is new Maker (Rec_6);\n\nbegin\n   Make_1 (5_000);\n   Make_2 (5_000);\n   Make_3 (5_000);\n   Make_4 (5_000);\n   Make_5 (5_000);\n   Make_6 (5_000);\nend Leaks;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q leaks.adb\n$ valgrind ./leaks > leaks.txt 2>&1\n$ grep -c \"still reachable\" leaks.txt\n0\n\n2018-01-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_aggr.adb (Convert_Aggr_In_Object_Decl): Update the call to\n\tEstablish_Transient_Scope.\n\t(Convert_To_Assignments): Update the call to Establish_Transient_Scope.\n\t(Expand_Array_Aggregate): Update the call to Establish_Transient_Scope.\n\t* exp_ch6.adb (Expand_Call_Helper): Update the call to\n\tEstablish_Transient_Scope.\n\t(Make_Build_In_Place_Call_In_Object_Declaration): Update the call to\n\tEstablish_Transient_Scope.\n\t* exp_ch7.adb (Establish_Transient_Scope): Restructured. Delegate the\n\tmanagement of the secondary stack to an enclosing scope if there is no\n\tsuitable construct to wrap, and the transient scope was intended to\n\tmanage the secondary stack.\n\t(Find_Node_To_Be_Wrapped): Restructured. A case_statement_alternative\n\tis a valid boundary for a transient expression which comes from the\n\tstatements of the alternative, otherwise alternatives cannot be\n\twrapped. Assignments of controlled objects which have controlled\n\tactions suppressed now stop the traversal as there is no point in\n\tlooking for an enclosing construct. Add several N_xxx_Body choices to\n\tthe termination conditions for completeness.\n\t* exp_ch7.ads (Establish_Transient_Scope): Update the parameter profile\n\tand the associated comment on usage.\n\t* exp_smem.adb (Add_Shared_Var_Lock_Procs): Update the call to\n\tEstablish_Transient_Scope.\n\t(Add_Write_After): Update the call to Establish_Transient_Scope.\n\t* sem_res.adb (Check_Initialization_Call): Removed.\n\t(Resolve_Actuals): Account for additional cases where finalization\n\tactions are required by utilizing predicate Needs_Finalization rather\n\tthan Is_Controlled.\n\t(Resolve_Call): Type initialization procedures can now utilize\n\ttransient scopes to manage the secondary stack, thus preventing leaks\n\tduring initialization.  Remove the previous kludgy algorithm which\n\tattempts to manage the secondary stack at the object creation site.\n\nFrom-SVN: r256513", "tree": {"sha": "d03f65e8902bd3c00fd505ba13d5b1edf9dd9239", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d03f65e8902bd3c00fd505ba13d5b1edf9dd9239"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6560f85165c084768a77dda7086269604781ce5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6560f85165c084768a77dda7086269604781ce5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6560f85165c084768a77dda7086269604781ce5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6560f85165c084768a77dda7086269604781ce5e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9e8030617cb310758929ee622cc8bff2372bb55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e8030617cb310758929ee622cc8bff2372bb55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e8030617cb310758929ee622cc8bff2372bb55"}], "stats": {"total": 697, "additions": 375, "deletions": 322}, "files": [{"sha": "8559dc97c419f7233998fd2cf6016103564f45ed", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6560f85165c084768a77dda7086269604781ce5e", "patch": "@@ -1,3 +1,38 @@\n+2018-01-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_aggr.adb (Convert_Aggr_In_Object_Decl): Update the call to\n+\tEstablish_Transient_Scope.\n+\t(Convert_To_Assignments): Update the call to Establish_Transient_Scope.\n+\t(Expand_Array_Aggregate): Update the call to Establish_Transient_Scope.\n+\t* exp_ch6.adb (Expand_Call_Helper): Update the call to\n+\tEstablish_Transient_Scope.\n+\t(Make_Build_In_Place_Call_In_Object_Declaration): Update the call to\n+\tEstablish_Transient_Scope.\n+\t* exp_ch7.adb (Establish_Transient_Scope): Restructured. Delegate the\n+\tmanagement of the secondary stack to an enclosing scope if there is no\n+\tsuitable construct to wrap, and the transient scope was intended to\n+\tmanage the secondary stack.\n+\t(Find_Node_To_Be_Wrapped): Restructured. A case_statement_alternative\n+\tis a valid boundary for a transient expression which comes from the\n+\tstatements of the alternative, otherwise alternatives cannot be\n+\twrapped. Assignments of controlled objects which have controlled\n+\tactions suppressed now stop the traversal as there is no point in\n+\tlooking for an enclosing construct. Add several N_xxx_Body choices to\n+\tthe termination conditions for completeness.\n+\t* exp_ch7.ads (Establish_Transient_Scope): Update the parameter profile\n+\tand the associated comment on usage.\n+\t* exp_smem.adb (Add_Shared_Var_Lock_Procs): Update the call to\n+\tEstablish_Transient_Scope.\n+\t(Add_Write_After): Update the call to Establish_Transient_Scope.\n+\t* sem_res.adb (Check_Initialization_Call): Removed.\n+\t(Resolve_Actuals): Account for additional cases where finalization\n+\tactions are required by utilizing predicate Needs_Finalization rather\n+\tthan Is_Controlled.\n+\t(Resolve_Call): Type initialization procedures can now utilize\n+\ttransient scopes to manage the secondary stack, thus preventing leaks\n+\tduring initialization.  Remove the previous kludgy algorithm which\n+\tattempts to manage the secondary stack at the object creation site.\n+\n 2018-01-11  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* libgnat/g-soliop__qnx.ads: New."}, {"sha": "f723c1b4d993818ae48ee63d6e3a3df3ffd3945a", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=6560f85165c084768a77dda7086269604781ce5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2018, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4092,15 +4092,16 @@ package body Exp_Aggr is\n         and then Ekind (Current_Scope) /= E_Return_Statement\n         and then not Is_Limited_Type (Typ)\n       then\n-         Establish_Transient_Scope (Aggr, Sec_Stack => False);\n+         Establish_Transient_Scope (Aggr, Manage_Sec_Stack => False);\n       end if;\n \n       declare\n-         Node_After   : constant Node_Id := Next (N);\n+         Node_After : constant Node_Id := Next (N);\n       begin\n          Insert_Actions_After (N, Late_Expansion (Aggr, Typ, Occ));\n          Collect_Initialization_Statements (Obj, N, Node_After);\n       end;\n+\n       Set_No_Initialization (N);\n       Initialize_Discriminants (N, Typ);\n    end Convert_Aggr_In_Object_Decl;\n@@ -4228,7 +4229,7 @@ package body Exp_Aggr is\n       --  Should the condition be more restrictive ???\n \n       if Requires_Transient_Scope (Typ) and then not Inside_Init_Proc then\n-         Establish_Transient_Scope (N, Sec_Stack => False);\n+         Establish_Transient_Scope (N, Manage_Sec_Stack => False);\n       end if;\n \n       --  If the aggregate is nonlimited, create a temporary. If it is limited\n@@ -6161,7 +6162,7 @@ package body Exp_Aggr is\n       --  for default initialization, e.g. with Initialize_Scalars.\n \n       if Requires_Transient_Scope (Typ) then\n-         Establish_Transient_Scope (N, Sec_Stack => False);\n+         Establish_Transient_Scope (N, Manage_Sec_Stack => False);\n       end if;\n \n       if Has_Default_Init_Comps (N) then\n@@ -6292,15 +6293,15 @@ package body Exp_Aggr is\n          Set_No_Initialization (Tmp_Decl, True);\n \n          --  If we are within a loop, the temporary will be pushed on the\n-         --  stack at each iteration. If the aggregate is the expression for an\n-         --  allocator, it will be immediately copied to the heap and can\n-         --  be reclaimed at once. We create a transient scope around the\n-         --  aggregate for this purpose.\n+         --  stack at each iteration. If the aggregate is the expression\n+         --  for an allocator, it will be immediately copied to the heap\n+         --  and can be reclaimed at once. We create a transient scope\n+         --  around the aggregate for this purpose.\n \n          if Ekind (Current_Scope) = E_Loop\n            and then Nkind (Parent (Parent (N))) = N_Allocator\n          then\n-            Establish_Transient_Scope (N, Sec_Stack => False);\n+            Establish_Transient_Scope (N, Manage_Sec_Stack => False);\n          end if;\n \n          Insert_Action (N, Tmp_Decl);"}, {"sha": "e52fb8c398b7840ea7d62d68147330e44c191867", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6560f85165c084768a77dda7086269604781ce5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2018, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4369,7 +4369,7 @@ package body Exp_Ch6 is\n                or else Nkind (Parent (N)) /= N_Function_Call\n                or else not Is_Build_In_Place_Function_Call (Parent (N)))\n          then\n-            Establish_Transient_Scope (Call_Node, Sec_Stack => True);\n+            Establish_Transient_Scope (Call_Node, Manage_Sec_Stack => True);\n          end if;\n       end if;\n    end Expand_Call_Helper;\n@@ -8548,8 +8548,8 @@ package body Exp_Ch6 is\n                 Attribute_Name => Name_Unrestricted_Access);\n          end if;\n \n-      --  In other indefinite cases, pass an indication to do the allocation on\n-      --  the secondary stack and set Caller_Object to Empty so that a null\n+      --  In other indefinite cases, pass an indication to do the allocation\n+      --  on the secondary stack and set Caller_Object to Empty so that a null\n       --  value will be passed for the caller's object address. A transient\n       --  scope is established to ensure eventual cleanup of the result.\n \n@@ -8558,7 +8558,7 @@ package body Exp_Ch6 is\n            (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n          Caller_Object := Empty;\n \n-         Establish_Transient_Scope (Obj_Decl, Sec_Stack => True);\n+         Establish_Transient_Scope (Obj_Decl, Manage_Sec_Stack => True);\n       end if;\n \n       --  Pass along any finalization master actual, which is needed in the"}, {"sha": "e669454243431dff50e92ee224d39a31842cac57", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 284, "deletions": 169, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=6560f85165c084768a77dda7086269604781ce5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2018, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4066,92 +4066,51 @@ package body Exp_Ch7 is\n    --  result. It creates a new scope on the scope stack in order to enclose\n    --  all transient variables generated.\n \n-   procedure Establish_Transient_Scope (N : Node_Id; Sec_Stack : Boolean) is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Iter_Loop : Entity_Id;\n-      Scop_Id   : Entity_Id;\n-      Scop_Rec  : Scope_Stack_Entry;\n-      Wrap_Node : Node_Id;\n-\n-   begin\n-      --  Do not create a new transient scope if there is an existing transient\n-      --  scope on the stack.\n-\n-      for Index in reverse Scope_Stack.First .. Scope_Stack.Last loop\n-         Scop_Rec := Scope_Stack.Table (Index);\n-         Scop_Id  := Scop_Rec.Entity;\n-\n-         --  The current scope is transient. If the scope being established\n-         --  needs to manage the secondary stack, then the existing scope\n-         --  overtakes that function.\n-\n-         if Scop_Rec.Is_Transient then\n-            if Sec_Stack then\n-               Set_Uses_Sec_Stack (Scop_Id);\n-            end if;\n-\n-            return;\n-\n-         --  Prevent the search from going too far because transient blocks\n-         --  are bounded by packages and subprogram scopes. Reaching Standard\n-         --  should be impossible without hitting one of the other cases first\n-         --  unless Standard was manually pushed.\n-\n-         elsif Scop_Id = Standard_Standard\n-           or else Ekind_In (Scop_Id, E_Entry,\n-                                      E_Entry_Family,\n-                                      E_Function,\n-                                      E_Package,\n-                                      E_Procedure,\n-                                      E_Subprogram_Body)\n-         then\n-            exit;\n-         end if;\n-      end loop;\n+   procedure Establish_Transient_Scope\n+     (N                : Node_Id;\n+      Manage_Sec_Stack : Boolean)\n+   is\n+      procedure Create_Transient_Scope (Constr : Node_Id);\n+      --  Place a new scope on the scope stack in order to service construct\n+      --  Constr. The new scope may also manage the secondary stack.\n \n-      Wrap_Node := Find_Node_To_Be_Wrapped (N);\n+      procedure Delegate_Sec_Stack_Management;\n+      --  Move the management of the secondary stack to the nearest enclosing\n+      --  suitable scope.\n \n-      --  The context does not contain a node that requires a transient scope,\n-      --  nothing to do.\n+      function Find_Enclosing_Transient_Scope return Entity_Id;\n+      --  Examine the scope stack looking for the nearest enclosing transient\n+      --  scope. Return Empty if no such scope exists.\n \n-      if No (Wrap_Node) then\n-         null;\n+      function Is_OK_Construct (Constr : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node Constr is a suitable construct which\n+      --  requires handling by a transient scope.\n \n-      --  If the node to wrap is an iteration_scheme, the expression is one of\n-      --  the bounds, and the expansion will make an explicit declaration for\n-      --  it (see Analyze_Iteration_Scheme, sem_ch5.adb), so do not apply any\n-      --  transformations here. Same for an Ada 2012 iterator specification,\n-      --  where a block is created for the expression that build the container.\n+      function Is_Package_Or_Subprogram (Id : Entity_Id) return Boolean;\n+      --  Determine whether arbitrary Id denotes a package or subprogram [body]\n \n-      elsif Nkind_In (Wrap_Node, N_Iteration_Scheme,\n-                                 N_Iterator_Specification)\n-      then\n-         null;\n+      ----------------------------\n+      -- Create_Transient_Scope --\n+      ----------------------------\n \n-      --  In formal verification mode, if the node to wrap is a pragma check,\n-      --  this node and enclosed expression are not expanded, so do not apply\n-      --  any transformations here.\n+      procedure Create_Transient_Scope (Constr : Node_Id) is\n+         Loc : constant Source_Ptr := Sloc (N);\n \n-      elsif GNATprove_Mode\n-        and then Nkind (Wrap_Node) = N_Pragma\n-        and then Get_Pragma_Id (Wrap_Node) = Pragma_Check\n-      then\n-         null;\n+         Iter_Loop  : Entity_Id;\n+         Trans_Scop : Entity_Id;\n \n-      --  Create a block entity to act as a transient scope. Note that when the\n-      --  node to be wrapped is an expression or a statement, a real physical\n-      --  block is constructed (see routines Wrap_Transient_Expression and\n-      --  Wrap_Transient_Statement) and inserted into the tree.\n+      begin\n+         Trans_Scop := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n+         Set_Etype (Trans_Scop, Standard_Void_Type);\n \n-      else\n-         Push_Scope (New_Internal_Entity (E_Block, Current_Scope, Loc, 'B'));\n+         Push_Scope (Trans_Scop);\n+         Set_Node_To_Be_Wrapped (Constr);\n          Set_Scope_Is_Transient;\n \n-         --  The transient scope must also take care of the secondary stack\n-         --  management.\n+         --  The transient scope must also manage the secondary stack\n \n-         if Sec_Stack then\n-            Set_Uses_Sec_Stack (Current_Scope);\n+         if Manage_Sec_Stack then\n+            Set_Uses_Sec_Stack (Trans_Scop);\n             Check_Restriction (No_Secondary_Stack, N);\n \n             --  The expansion of iterator loops generates references to objects\n@@ -4178,20 +4137,180 @@ package body Exp_Ch7 is\n             --  machinery to manage the secondary stack (see routine\n             --  Process_Statements_For_Controlled_Objects).\n \n-            Iter_Loop := Find_Enclosing_Iterator_Loop (Current_Scope);\n+            Iter_Loop := Find_Enclosing_Iterator_Loop (Trans_Scop);\n \n             if Present (Iter_Loop) then\n                Set_Uses_Sec_Stack (Iter_Loop);\n             end if;\n          end if;\n \n-         Set_Etype (Current_Scope, Standard_Void_Type);\n-         Set_Node_To_Be_Wrapped (Wrap_Node);\n-\n          if Debug_Flag_W then\n             Write_Str (\"    <Transient>\");\n             Write_Eol;\n          end if;\n+      end Create_Transient_Scope;\n+\n+      -----------------------------------\n+      -- Delegate_Sec_Stack_Management --\n+      -----------------------------------\n+\n+      procedure Delegate_Sec_Stack_Management is\n+         Scop_Id  : Entity_Id;\n+         Scop_Rec : Scope_Stack_Entry;\n+\n+      begin\n+         for Index in reverse Scope_Stack.First .. Scope_Stack.Last loop\n+            Scop_Rec := Scope_Stack.Table (Index);\n+            Scop_Id  := Scop_Rec.Entity;\n+\n+            --  Prevent the search from going too far or within the scope space\n+            --  of another unit.\n+\n+            if Scop_Id = Standard_Standard then\n+               return;\n+\n+            --  No transient scope should be encountered during the traversal\n+            --  because Establish_Transient_Scope should have already handled\n+            --  this case.\n+\n+            elsif Scop_Rec.Is_Transient then\n+               pragma Assert (False);\n+               return;\n+\n+            --  The construct which requires secondary stack management is\n+            --  always enclosed by a package or subprogram scope.\n+\n+            elsif Is_Package_Or_Subprogram (Scop_Id) then\n+               Set_Uses_Sec_Stack (Scop_Id);\n+               Check_Restriction (No_Secondary_Stack, N);\n+\n+               return;\n+            end if;\n+         end loop;\n+\n+         --  At this point no suitable scope was found. This should never occur\n+         --  because a construct is always enclosed by a compilation unit which\n+         --  has a scope.\n+\n+         pragma Assert (False);\n+      end Delegate_Sec_Stack_Management;\n+\n+      ------------------------------------\n+      -- Find_Enclosing_Transient_Scope --\n+      ------------------------------------\n+\n+      function Find_Enclosing_Transient_Scope return Entity_Id is\n+         Scop_Id   : Entity_Id;\n+         Scop_Rec  : Scope_Stack_Entry;\n+\n+      begin\n+         for Index in reverse Scope_Stack.First .. Scope_Stack.Last loop\n+            Scop_Rec := Scope_Stack.Table (Index);\n+            Scop_Id  := Scop_Rec.Entity;\n+\n+            --  Prevent the search from going too far or within the scope space\n+            --  of another unit.\n+\n+            if Scop_Id = Standard_Standard\n+              or else Is_Package_Or_Subprogram (Scop_Id)\n+            then\n+               exit;\n+\n+            elsif Scop_Rec.Is_Transient then\n+               return Scop_Id;\n+            end if;\n+         end loop;\n+\n+         return Empty;\n+      end Find_Enclosing_Transient_Scope;\n+\n+      ---------------------\n+      -- Is_OK_Construct --\n+      ---------------------\n+\n+      function Is_OK_Construct (Constr : Node_Id) return Boolean is\n+      begin\n+         --  Nothing to do when there is no construct to consider\n+\n+         if No (Constr) then\n+            return False;\n+\n+         --  Nothing to do when the construct is an iteration scheme or an Ada\n+         --  2012 iterator because the expression is one of the bounds, and the\n+         --  expansion will create an explicit declaration for it (see routine\n+         --  Analyze_Iteration_Scheme).\n+\n+         elsif Nkind_In (Constr, N_Iteration_Scheme,\n+                                 N_Iterator_Specification)\n+         then\n+            return False;\n+\n+         --  Nothing to do in formal verification mode when the construct is\n+         --  pragma Check, because the pragma remains unexpanded.\n+\n+         elsif GNATprove_Mode\n+           and then Nkind (Constr) = N_Pragma\n+           and then Get_Pragma_Id (Constr) = Pragma_Check\n+         then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Is_OK_Construct;\n+\n+      ------------------------------\n+      -- Is_Package_Or_Subprogram --\n+      ------------------------------\n+\n+      function Is_Package_Or_Subprogram (Id : Entity_Id) return Boolean is\n+      begin\n+         return Ekind_In (Id, E_Entry,\n+                              E_Entry_Family,\n+                              E_Function,\n+                              E_Package,\n+                              E_Procedure,\n+                              E_Subprogram_Body);\n+      end Is_Package_Or_Subprogram;\n+\n+      --  Local variables\n+\n+      Scop_Id : constant Entity_Id := Find_Enclosing_Transient_Scope;\n+      Constr  : Node_Id;\n+\n+   --  Start of processing for Establish_Transient_Scope\n+\n+   begin\n+      --  Do not create a new transient scope if there is an existing transient\n+      --  scope on the stack.\n+\n+      if Present (Scop_Id) then\n+\n+         --  If the transient scope was requested for purposes of managing the\n+         --  secondary stack, then the existing scope must perform this task.\n+\n+         if Manage_Sec_Stack then\n+            Set_Uses_Sec_Stack (Scop_Id);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      --  At this point it is known that the scope stack is free of transient\n+      --  scopes. Locate the proper construct which must be serviced by a new\n+      --  transient scope.\n+\n+      Constr := Find_Node_To_Be_Wrapped (N);\n+\n+      if Is_OK_Construct (Constr) then\n+         Create_Transient_Scope (Constr);\n+\n+      --  Otherwise there is no suitable construct which requires handling by\n+      --  a transient scope. If the transient scope was requested for purposes\n+      --  of managing the secondary stack, delegate the work to an enclosing\n+      --  scope.\n+\n+      elsif Manage_Sec_Stack then\n+         Delegate_Sec_Stack_Management;\n       end if;\n    end Establish_Transient_Scope;\n \n@@ -4701,70 +4820,35 @@ package body Exp_Ch7 is\n    -----------------------------\n \n    function Find_Node_To_Be_Wrapped (N : Node_Id) return Node_Id is\n-      P          : Node_Id;\n-      The_Parent : Node_Id;\n+      Curr : Node_Id;\n+      Prev : Node_Id;\n \n    begin\n-      The_Parent := N;\n-      P          := Empty;\n+      Curr := N;\n+      Prev := Empty;\n       loop\n-         case Nkind (The_Parent) is\n-\n-            --  Simple statement can be wrapped\n-\n-            when N_Pragma =>\n-               return The_Parent;\n-\n-            --  Usually assignments are good candidate for wrapping except\n-            --  when they have been generated as part of a controlled aggregate\n-            --  where the wrapping should take place more globally. Note that\n-            --  No_Ctrl_Actions may be set also for non-controlled assignements\n-            --  in order to disable the use of dispatching _assign, so we need\n-            --  to test explicitly for a controlled type here.\n+         case Nkind (Curr) is\n \n-            when N_Assignment_Statement =>\n-               if No_Ctrl_Actions (The_Parent)\n-                 and then Needs_Finalization (Etype (Name (The_Parent)))\n-               then\n-                  null;\n-               else\n-                  return The_Parent;\n-               end if;\n-\n-            --  An entry call statement is a special case if it occurs in the\n-            --  context of a Timed_Entry_Call. In this case we wrap the entire\n-            --  timed entry call.\n-\n-            when N_Entry_Call_Statement\n-               | N_Procedure_Call_Statement\n-            =>\n-               if Nkind (Parent (The_Parent)) = N_Entry_Call_Alternative\n-                 and then Nkind_In (Parent (Parent (The_Parent)),\n-                                    N_Timed_Entry_Call,\n-                                    N_Conditional_Entry_Call)\n-               then\n-                  return Parent (Parent (The_Parent));\n-               else\n-                  return The_Parent;\n-               end if;\n+            --  Declarations\n \n-            --  Object declarations are also a boundary for the transient scope\n-            --  even if they are not really wrapped. For further details, see\n-            --  Wrap_Transient_Declaration.\n+            --  Declarations act as a boundary for a transient scope even if\n+            --  they are not wrapped, see Wrap_Transient_Declaration.\n \n             when N_Object_Declaration\n                | N_Object_Renaming_Declaration\n                | N_Subtype_Declaration\n             =>\n-               return The_Parent;\n+               return Curr;\n+\n+            --  Statements\n \n-            --  The expression itself is to be wrapped if its parent is a\n-            --  compound statement or any other statement where the expression\n-            --  is known to be scalar.\n+            --  Statements and statement-like constructs act as a boundary for\n+            --  a transient scope.\n \n             when N_Accept_Alternative\n                | N_Attribute_Definition_Clause\n                | N_Case_Statement\n+               | N_Case_Statement_Alternative\n                | N_Code_Statement\n                | N_Delay_Alternative\n                | N_Delay_Until_Statement\n@@ -4777,76 +4861,107 @@ package body Exp_Ch7 is\n                | N_Iteration_Scheme\n                | N_Terminate_Alternative\n             =>\n-               pragma Assert (Present (P));\n-               return P;\n+               pragma Assert (Present (Prev));\n+               return Prev;\n \n-            when N_Attribute_Reference =>\n-               if Is_Procedure_Attribute_Name\n-                    (Attribute_Name (The_Parent))\n+            --  Assignment statements are usually wrapped in a transient block\n+            --  except when they are generated as part of controlled aggregate\n+            --  where the wrapping should take place more globally. Note that\n+            --  No_Ctrl_Actions is set also for non-controlled assignments, in\n+            --  order to disable the use of dispatching _assign, thus the test\n+            --  for a controlled type.\n+\n+            when N_Assignment_Statement =>\n+               if No_Ctrl_Actions (Curr)\n+                 and then Needs_Finalization (Etype (Name (Curr)))\n                then\n-                  return The_Parent;\n+                  return Empty;\n+               else\n+                  return Curr;\n                end if;\n \n-            --  A raise statement can be wrapped. This will arise when the\n-            --  expression in a raise_with_expression uses the secondary\n-            --  stack, for example.\n+            --  An entry of procedure call is usually wrapped except when it\n+            --  acts as the alternative of a conditional or timed entry call.\n+            --  In that case wrap the context of the alternative.\n \n-            when N_Raise_Statement =>\n-               return The_Parent;\n+            when N_Entry_Call_Statement\n+               | N_Procedure_Call_Statement\n+            =>\n+               if Nkind (Parent (Curr)) = N_Entry_Call_Alternative\n+                 and then Nkind_In (Parent (Parent (Curr)),\n+                                    N_Conditional_Entry_Call,\n+                                    N_Timed_Entry_Call)\n+               then\n+                  return Parent (Parent (Curr));\n+               else\n+                  return Curr;\n+               end if;\n+\n+            when N_Pragma\n+               | N_Raise_Statement\n+            =>\n+               return Curr;\n \n-            --  If the expression is within the iteration scheme of a loop,\n-            --  we must create a declaration for it, followed by an assignment\n-            --  in order to have a usable statement to wrap.\n+            --  A return statement is not wrapped when the associated function\n+            --  would require wrapping.\n+\n+            when N_Simple_Return_Statement =>\n+               if Requires_Transient_Scope (Etype\n+                    (Return_Applies_To (Return_Statement_Entity (Curr))))\n+               then\n+                  return Empty;\n+               else\n+                  return Curr;\n+               end if;\n+\n+            --  Special\n+\n+            when N_Attribute_Reference =>\n+               if Is_Procedure_Attribute_Name (Attribute_Name (Curr)) then\n+                  return Curr;\n+               end if;\n+\n+            --  If the construct is within the iteration scheme of a loop, it\n+            --  requires a declaration followed by an assignment, in order to\n+            --  have a usable statement to wrap.\n \n             when N_Loop_Parameter_Specification =>\n-               return Parent (The_Parent);\n+               return Parent (Curr);\n \n-            --  The following nodes contains \"dummy calls\" which don't need to\n-            --  be wrapped.\n+            --  Termination\n+\n+            --  The following nodes represent \"dummy contexts\" which do not\n+            --  need to be wrapped.\n \n             when N_Component_Declaration\n                | N_Discriminant_Specification\n                | N_Parameter_Specification\n             =>\n                return Empty;\n \n-            --  The return statement is not to be wrapped when the function\n-            --  itself needs wrapping at the outer-level\n-\n-            when N_Simple_Return_Statement =>\n-               declare\n-                  Applies_To : constant Entity_Id :=\n-                                 Return_Applies_To\n-                                   (Return_Statement_Entity (The_Parent));\n-                  Return_Type : constant Entity_Id := Etype (Applies_To);\n-               begin\n-                  if Requires_Transient_Scope (Return_Type) then\n-                     return Empty;\n-                  else\n-                     return The_Parent;\n-                  end if;\n-               end;\n-\n-            --  If we leave a scope without having been able to find a node to\n-            --  wrap, something is going wrong but this can happen in error\n-            --  situation that are not detected yet (such as a dynamic string\n-            --  in a pragma export)\n+            --  If the traversal leaves a scope without having been able to\n+            --  find a construct to wrap, something is going wrong, but this\n+            --  can happen in error situations that are not detected yet (such\n+            --  as a dynamic string in a pragma Export).\n \n             when N_Block_Statement\n+               | N_Entry_Body\n                | N_Package_Body\n                | N_Package_Declaration\n+               | N_Protected_Body\n                | N_Subprogram_Body\n+               | N_Task_Body\n             =>\n                return Empty;\n \n-            --  Otherwise continue the search\n+            --  Default\n \n             when others =>\n                null;\n          end case;\n \n-         P          := The_Parent;\n-         The_Parent := Parent (P);\n+         Prev := Curr;\n+         Curr := Parent (Curr);\n       end loop;\n    end Find_Node_To_Be_Wrapped;\n "}, {"sha": "06b37588b4c5880c654bef55e52c928d5e0a9bc5", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=6560f85165c084768a77dda7086269604781ce5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2018, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -276,10 +276,12 @@ package Exp_Ch7 is\n    --  a \"scope node\" that is to say one of the following: N_Block_Statement,\n    --  N_Subprogram_Body, N_Task_Body, N_Entry_Body.\n \n-   procedure Establish_Transient_Scope (N : Node_Id; Sec_Stack : Boolean);\n-   --  Push a new transient scope on the scope stack. N is the node responsible\n-   --  for the need of a transient scope. If Sec_Stack is True then the\n-   --  secondary stack is brought in, otherwise it isn't.\n+   procedure Establish_Transient_Scope\n+     (N                : Node_Id;\n+      Manage_Sec_Stack : Boolean);\n+   --  Push a new transient scope on the scope stack. N is the node which must\n+   --  be serviced by the transient scope. Set Manage_Sec_Stack when the scope\n+   --  must mark and release the secondary stack.\n \n    function Node_To_Be_Wrapped return Node_Id;\n    --  Return the node to be wrapped if the current scope is transient"}, {"sha": "a5cbab5c14d37361f4011ba786830b7441f04c05", "filename": "gcc/ada/exp_smem.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fexp_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.adb?ref=6560f85165c084768a77dda7086269604781ce5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2018, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -207,7 +207,7 @@ package body Exp_Smem is\n \n       else\n          Insert_Action (N, Vde);\n-         Establish_Transient_Scope (N, Sec_Stack => False);\n+         Establish_Transient_Scope (N, Manage_Sec_Stack => False);\n       end if;\n \n       --  Mark object as locked in the current (transient) scope\n@@ -255,13 +255,15 @@ package body Exp_Smem is\n    ---------------------\n \n    procedure Add_Write_After (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n       Ent : constant Entity_Id  := Entity (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n       Par : constant Node_Id    := Insert_Node;\n+\n    begin\n       if Present (Shared_Var_Procs_Instance (Ent)) then\n          if Nkind (Insert_Node) = N_Function_Call then\n-            Establish_Transient_Scope (Insert_Node, Sec_Stack => False);\n+            Establish_Transient_Scope (Insert_Node, Manage_Sec_Stack => False);\n+\n             Store_After_Actions_In_Scope (New_List (\n               Build_Shared_Var_Proc_Call (Loc, Ent, Name_Write)));\n          else"}, {"sha": "a4d6a26db17e6df2691139a0a70fab2dddc40849", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 27, "deletions": 129, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6560f85165c084768a77dda7086269604781ce5e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6560f85165c084768a77dda7086269604781ce5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2018, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -117,13 +117,6 @@ package body Sem_Res is\n    --  an infinite recursion, and if so, outputs appropriate messages. Returns\n    --  True if an infinite recursion is detected, and False otherwise.\n \n-   procedure Check_Initialization_Call (N : Entity_Id; Nam : Entity_Id);\n-   --  If the type of the object being initialized uses the secondary stack\n-   --  directly or indirectly, create a transient scope for the call to the\n-   --  init proc. This is because we do not create transient scopes for the\n-   --  initialization of individual components within the init proc itself.\n-   --  Could be optimized away perhaps?\n-\n    procedure Check_No_Direct_Boolean_Operators (N : Node_Id);\n    --  N is the node for a logical operator. If the operator is predefined, and\n    --  the root type of the operands is Standard.Boolean, then a check is made\n@@ -858,89 +851,6 @@ package body Sem_Res is\n       return True;\n    end Check_Infinite_Recursion;\n \n-   -------------------------------\n-   -- Check_Initialization_Call --\n-   -------------------------------\n-\n-   procedure Check_Initialization_Call (N : Entity_Id; Nam : Entity_Id) is\n-      Typ : constant Entity_Id := Etype (First_Formal (Nam));\n-\n-      function Uses_SS (T : Entity_Id) return Boolean;\n-      --  Check whether the creation of an object of the type will involve\n-      --  use of the secondary stack. If T is a record type, this is true\n-      --  if the expression for some component uses the secondary stack, e.g.\n-      --  through a call to a function that returns an unconstrained value.\n-      --  False if T is controlled, because cleanups occur elsewhere.\n-\n-      -------------\n-      -- Uses_SS --\n-      -------------\n-\n-      function Uses_SS (T : Entity_Id) return Boolean is\n-         Comp      : Entity_Id;\n-         Expr      : Node_Id;\n-         Full_Type : Entity_Id := Underlying_Type (T);\n-\n-      begin\n-         --  Normally we want to use the underlying type, but if it's not set\n-         --  then continue with T.\n-\n-         if not Present (Full_Type) then\n-            Full_Type := T;\n-         end if;\n-\n-         if Is_Array_Type (Full_Type) then\n-            return Uses_SS (Component_Type (Full_Type));\n-\n-         elsif Is_Record_Type (Full_Type) then\n-            Comp := First_Component (Full_Type);\n-            while Present (Comp) loop\n-               if Ekind (Comp) = E_Component\n-                 and then Nkind (Parent (Comp)) = N_Component_Declaration\n-               then\n-                  --  The expression for a dynamic component may be rewritten\n-                  --  as a dereference, so retrieve original node.\n-\n-                  Expr := Original_Node (Expression (Parent (Comp)));\n-\n-                  --  Return True if the expression is a call to a function\n-                  --  (including an attribute function such as Image, or a\n-                  --  user-defined operator) with a result that requires a\n-                  --  transient scope.\n-\n-                  if (Nkind (Expr) = N_Function_Call\n-                       or else Nkind (Expr) in N_Op\n-                       or else (Nkind (Expr) = N_Attribute_Reference\n-                                 and then Present (Expressions (Expr))))\n-                    and then Requires_Transient_Scope (Etype (Expr))\n-                  then\n-                     return True;\n-\n-                  elsif Uses_SS (Etype (Comp)) then\n-                     return True;\n-                  end if;\n-               end if;\n-\n-               Next_Component (Comp);\n-            end loop;\n-\n-            return False;\n-\n-         else\n-            return False;\n-         end if;\n-      end Uses_SS;\n-\n-   --  Start of processing for Check_Initialization_Call\n-\n-   begin\n-      --  Establish a transient scope if the type needs it\n-\n-      if Uses_SS (Typ) then\n-         Establish_Transient_Scope (First_Actual (N), Sec_Stack => True);\n-      end if;\n-   end Check_Initialization_Call;\n-\n    ---------------------------------------\n    -- Check_No_Direct_Boolean_Operators --\n    ---------------------------------------\n@@ -3930,13 +3840,14 @@ package body Sem_Res is\n             --  transient scope for it, so that it can receive the proper\n             --  finalization list.\n \n-            elsif Nkind (A) = N_Function_Call\n+            elsif Expander_Active\n+              and then Nkind (A) = N_Function_Call\n               and then Is_Limited_Record (Etype (F))\n               and then not Is_Constrained (Etype (F))\n-              and then Expander_Active\n-              and then (Is_Controlled (Etype (F)) or else Has_Task (Etype (F)))\n+              and then (Needs_Finalization (Etype (F))\n+                         or else Has_Task (Etype (F)))\n             then\n-               Establish_Transient_Scope (A, Sec_Stack => False);\n+               Establish_Transient_Scope (A, Manage_Sec_Stack => False);\n                Resolve (A, Etype (F));\n \n             --  A small optimization: if one of the actuals is a concatenation\n@@ -3947,28 +3858,27 @@ package body Sem_Res is\n             --  static string, and we want to preserve warnings involving\n             --  sequences of such statements.\n \n-            elsif Nkind (A) = N_Op_Concat\n+            elsif Expander_Active\n+              and then Nkind (A) = N_Op_Concat\n               and then Nkind (N) = N_Procedure_Call_Statement\n-              and then Expander_Active\n-              and then\n-                not (Is_Intrinsic_Subprogram (Nam)\n-                      and then Chars (Nam) = Name_Asm)\n+              and then not (Is_Intrinsic_Subprogram (Nam)\n+                             and then Chars (Nam) = Name_Asm)\n               and then not Static_Concatenation (A)\n             then\n-               Establish_Transient_Scope (A, Sec_Stack => False);\n+               Establish_Transient_Scope (A, Manage_Sec_Stack => False);\n                Resolve (A, Etype (F));\n \n             else\n                if Nkind (A) = N_Type_Conversion\n                  and then Is_Array_Type (Etype (F))\n                  and then not Same_Ancestor (Etype (F), Etype (Expression (A)))\n                  and then\n-                  (Is_Limited_Type (Etype (F))\n-                    or else Is_Limited_Type (Etype (Expression (A))))\n+                   (Is_Limited_Type (Etype (F))\n+                     or else Is_Limited_Type (Etype (Expression (A))))\n                then\n                   Error_Msg_N\n-                    (\"conversion between unrelated limited array types \"\n-                     & \"not allowed ('A'I-00246)\", A);\n+                    (\"conversion between unrelated limited array types not \"\n+                     & \"allowed ('A'I-00246)\", A);\n \n                   if Is_Limited_Type (Etype (F)) then\n                      Explain_Limited_Type (Etype (F), A);\n@@ -4011,10 +3921,12 @@ package body Sem_Res is\n                      --  enabled only, otherwise the transient scope will not\n                      --  be removed in the expansion of the wrapped construct.\n \n-                     if (Is_Controlled (DDT) or else Has_Task (DDT))\n-                       and then Expander_Active\n+                     if Expander_Active\n+                       and then (Needs_Finalization (DDT)\n+                                  or else Has_Task (DDT))\n                      then\n-                        Establish_Transient_Scope (A, Sec_Stack => False);\n+                        Establish_Transient_Scope\n+                          (A, Manage_Sec_Stack => False);\n                      end if;\n                   end;\n \n@@ -6443,11 +6355,6 @@ package body Sem_Res is\n       --  is already present. It may not be available if e.g. the subprogram is\n       --  declared in a child instance.\n \n-      --  If this is an initialization call for a type whose construction\n-      --  uses the secondary stack, and it is not a nested call to initialize\n-      --  a component, we do need to create a transient scope for it. We\n-      --  check for this by traversing the type in Check_Initialization_Call.\n-\n       if Is_Inlined (Nam)\n         and then Has_Pragma_Inline (Nam)\n         and then Nkind (Unit_Declaration_Node (Nam)) = N_Subprogram_Declaration\n@@ -6463,26 +6370,17 @@ package body Sem_Res is\n          null;\n \n       elsif Expander_Active\n-        and then Is_Type (Etype (Nam))\n+        and then Ekind (Nam) = E_Function\n         and then Requires_Transient_Scope (Etype (Nam))\n-        and then\n-          (not Within_Init_Proc\n-            or else\n-              (not Is_Init_Proc (Nam) and then Ekind (Nam) /= E_Function))\n       then\n-         Establish_Transient_Scope (N, Sec_Stack => True);\n+         Establish_Transient_Scope (N, Manage_Sec_Stack => True);\n \n-         --  If the call appears within the bounds of a loop, it will\n-         --  be rewritten and reanalyzed, nothing left to do here.\n+         --  If the call appears within the bounds of a loop, it will be\n+         --  rewritten and reanalyzed, nothing left to do here.\n \n          if Nkind (N) /= N_Function_Call then\n             return;\n          end if;\n-\n-      elsif Is_Init_Proc (Nam)\n-        and then not Within_Init_Proc\n-      then\n-         Check_Initialization_Call (N, Nam);\n       end if;\n \n       --  A protected function cannot be called within the definition of the\n@@ -7890,13 +7788,13 @@ package body Sem_Res is\n             Set_Analyzed (N, True);\n          end;\n \n-      --  Protected functions can return on the secondary stack, in which\n-      --  case we must trigger the transient scope mechanism.\n+      --  Protected functions can return on the secondary stack, in which case\n+      --  we must trigger the transient scope mechanism.\n \n       elsif Expander_Active\n         and then Requires_Transient_Scope (Etype (Nam))\n       then\n-         Establish_Transient_Scope (N, Sec_Stack => True);\n+         Establish_Transient_Scope (N, Manage_Sec_Stack => True);\n       end if;\n    end Resolve_Entry_Call;\n "}]}