{"sha": "df5d402aba66d2e83690dadb6267accc6539e220", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY1ZDQwMmFiYTY2ZDJlODM2OTBkYWRiNjI2N2FjY2M2NTM5ZTIyMA==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2014-08-14T16:13:59Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2014-08-14T16:13:59Z"}, "message": "Fix if-conversion pass for dead type-unsafe code\n\n2014-08-14  Tom de Vries  <tom@codesourcery.com>\n\n\tPR rtl-optimization/62004\n\tPR rtl-optimization/62030\n\t* ifcvt.c (rtx_interchangeable_p): New function.\n\t(noce_try_move, noce_process_if_block): Use rtx_interchangeable_p.\n\t* emit-rtl.h (mem_attrs_eq_p): Declare.\n\n\t* gcc.dg/pr62004.c: New test.\n\t* gcc.dg/pr62030.c: Same.\n\t* gcc.target/mips/pr62030-octeon.c: Same.\n\nFrom-SVN: r213970", "tree": {"sha": "f42d2015dd1fca0bc416d04f437ea88b5e3608bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f42d2015dd1fca0bc416d04f437ea88b5e3608bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df5d402aba66d2e83690dadb6267accc6539e220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df5d402aba66d2e83690dadb6267accc6539e220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df5d402aba66d2e83690dadb6267accc6539e220", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df5d402aba66d2e83690dadb6267accc6539e220/comments", "author": null, "committer": null, "parents": [{"sha": "821fce246e47ef5b4b923f9ed92fa367a9098d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821fce246e47ef5b4b923f9ed92fa367a9098d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/821fce246e47ef5b4b923f9ed92fa367a9098d26"}], "stats": {"total": 196, "additions": 193, "deletions": 3}, "files": [{"sha": "4194ac7d59e4645f6c8dad7fc764e21b0aa2f5f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df5d402aba66d2e83690dadb6267accc6539e220", "patch": "@@ -1,3 +1,12 @@\n+2014-08-14  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR rtl-optimization/62004\n+\tPR rtl-optimization/62030\n+\t* ifcvt.c (rtx_interchangeable_p): New function.\n+\t(noce_try_move, noce_process_if_block): Use rtx_interchangeable_p.\n+\t* emit-rtl.c (mem_attrs_eq_p): Remove static.\n+\t* emit-rtl.h (mem_attrs_eq_p): Declare.\n+\n 2014-08-14  Roman Gareev  <gareevroman@gmail.com>\n \n \t* graphite-scop-detection.c:"}, {"sha": "bae6e696fd36f466411d08c5e1648e69b3d27893", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=df5d402aba66d2e83690dadb6267accc6539e220", "patch": "@@ -72,6 +72,7 @@ extern void set_reg_attrs_for_parm (rtx, rtx);\n extern void set_reg_attrs_for_decl_rtl (tree t, rtx x);\n extern void adjust_reg_mode (rtx, enum machine_mode);\n extern int mem_expr_equal_p (const_tree, const_tree);\n+extern bool mem_attrs_eq_p (const struct mem_attrs *, const struct mem_attrs *);\n \n extern bool need_atomic_barrier_p (enum memmodel, bool);\n "}, {"sha": "521dca0d1ddb13921c73d3f6f8a7ba7d107dd3a9", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=df5d402aba66d2e83690dadb6267accc6539e220", "patch": "@@ -305,6 +305,28 @@ block_fallthru (basic_block bb)\n \n   return (e) ? e->dest : NULL_BLOCK;\n }\n+\n+/* Return true if RTXs A and B can be safely interchanged.  */\n+\n+static bool\n+rtx_interchangeable_p (const_rtx a, const_rtx b)\n+{\n+  if (!rtx_equal_p (a, b))\n+    return false;\n+\n+  if (GET_CODE (a) != MEM)\n+    return true;\n+\n+  /* A dead type-unsafe memory reference is legal, but a live type-unsafe memory\n+     reference is not.  Interchanging a dead type-unsafe memory reference with\n+     a live type-safe one creates a live type-unsafe memory reference, in other\n+     words, it makes the program illegal.\n+     We check here conservatively whether the two memory references have equal\n+     memory attributes.  */\n+\n+  return mem_attrs_eq_p (get_mem_attrs (a), get_mem_attrs (b));\n+}\n+\n \f\n /* Go through a bunch of insns, converting them to conditional\n    execution format if possible.  Return TRUE if all of the non-note\n@@ -1033,6 +1055,9 @@ noce_try_move (struct noce_if_info *if_info)\n       || (rtx_equal_p (if_info->a, XEXP (cond, 1))\n \t  && rtx_equal_p (if_info->b, XEXP (cond, 0))))\n     {\n+      if (!rtx_interchangeable_p (if_info->a, if_info->b))\n+\treturn FALSE;\n+\n       y = (code == EQ) ? if_info->a : if_info->b;\n \n       /* Avoid generating the move if the source is the destination.  */\n@@ -2503,7 +2528,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n       if (! insn_b\n \t  || insn_b != last_active_insn (else_bb, FALSE)\n \t  || (set_b = single_set (insn_b)) == NULL_RTX\n-\t  || ! rtx_equal_p (x, SET_DEST (set_b)))\n+\t  || ! rtx_interchangeable_p (x, SET_DEST (set_b)))\n \treturn FALSE;\n     }\n   else\n@@ -2516,7 +2541,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n \t  || BLOCK_FOR_INSN (insn_b) != BLOCK_FOR_INSN (if_info->cond_earliest)\n \t  || !NONJUMP_INSN_P (insn_b)\n \t  || (set_b = single_set (insn_b)) == NULL_RTX\n-\t  || ! rtx_equal_p (x, SET_DEST (set_b))\n+\t  || ! rtx_interchangeable_p (x, SET_DEST (set_b))\n \t  || ! noce_operand_ok (SET_SRC (set_b))\n \t  || reg_overlap_mentioned_p (x, SET_SRC (set_b))\n \t  || modified_between_p (SET_SRC (set_b), insn_b, jump)\n@@ -2582,7 +2607,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n \n   /* Look and see if A and B are really the same.  Avoid creating silly\n      cmove constructs that no one will fix up later.  */\n-  if (rtx_equal_p (a, b))\n+  if (rtx_interchangeable_p (a, b))\n     {\n       /* If we have an INSN_B, we don't have to create any new rtl.  Just\n \t move the instruction that we already have.  If we don't have an"}, {"sha": "7a28779ea6bae9adc07f3d13236a751e20cc8b6b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df5d402aba66d2e83690dadb6267accc6539e220", "patch": "@@ -1,3 +1,11 @@\n+2014-08-14  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR rtl-optimization/62004\n+\tPR rtl-optimization/62030\n+\t* gcc.dg/pr62004.c: New test.\n+\t* gcc.dg/pr62030.c: Same.\n+\t* gcc.target/mips/pr62030-octeon.c: Same.\n+\n 2014-08-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/cpp0x/alias-decl-4.C: Adjust for parser change."}, {"sha": "c994a411b3b2c3edc00501dbabf729655d5663e9", "filename": "gcc/testsuite/gcc.dg/pr62004.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62004.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62004.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62004.c?ref=df5d402aba66d2e83690dadb6267accc6539e220", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-tree-tail-merge\" } */\n+\n+struct node\n+{\n+  struct node *next;\n+  struct node *prev;\n+};\n+\n+struct node node;\n+\n+struct head\n+{\n+  struct node *first;\n+};\n+\n+struct head heads[5];\n+\n+int k = 2;\n+\n+struct head *head = &heads[2];\n+\n+int\n+main ()\n+{\n+  struct node *p;\n+\n+  node.next = (void*)0;\n+\n+  node.prev = (void *)head;\n+\n+  head->first = &node;\n+\n+  struct node *n = head->first;\n+\n+  struct head *h = &heads[k];\n+\n+  heads[2].first = n->next;\n+\n+  if ((void*)n->prev == (void *)h)\n+    p = h->first;\n+  else\n+    /* Dead tbaa-unsafe load from ((struct node *)&heads[2])->next.  */\n+    p = n->prev->next;\n+\n+  return !(p == (void*)0);\n+}"}, {"sha": "b8baf934354c8042f26c77aa1fc2c8200662db23", "filename": "gcc/testsuite/gcc.dg/pr62030.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62030.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62030.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62030.c?ref=df5d402aba66d2e83690dadb6267accc6539e220", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+\n+struct node\n+{\n+  struct node *next;\n+  struct node *prev;\n+};\n+\n+struct node node;\n+\n+struct head\n+{\n+  struct node *first;\n+};\n+\n+struct head heads[5];\n+\n+int k = 2;\n+\n+struct head *head = &heads[2];\n+\n+static int __attribute__((noinline))\n+foo (void)\n+{\n+  node.prev = (void *)head;\n+  head->first = &node;\n+\n+  struct node *n = head->first;\n+  struct head *h = &heads[k];\n+  struct node *next = n->next;\n+\n+  if (n->prev == (void *)h)\n+    h->first = next;\n+  else\n+    n->prev->next = next;\n+\n+  n->next = h->first;\n+  return n->next == &node;\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo ())\n+    abort ();\n+  return 0;\n+}"}, {"sha": "5e3d3b3b635ee1d34d095043feb08e2f62bcc649", "filename": "gcc/testsuite/gcc.target/mips/pr62030-octeon.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr62030-octeon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5d402aba66d2e83690dadb6267accc6539e220/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr62030-octeon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr62030-octeon.c?ref=df5d402aba66d2e83690dadb6267accc6539e220", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-march=octeon\" } */\n+\n+extern void abort (void);\n+\n+struct node\n+{\n+  struct node *next;\n+  struct node *prev;\n+};\n+\n+struct node node;\n+\n+struct head\n+{\n+  struct node *first;\n+};\n+\n+struct head heads[5];\n+\n+int k = 2;\n+\n+struct head *head = &heads[2];\n+\n+static int __attribute__((noinline))\n+foo (void)\n+{\n+  node.prev = (void *)head;\n+  head->first = &node;\n+\n+  struct node *n = head->first;\n+  struct head *h = &heads[k];\n+  struct node *next = n->next;\n+\n+  if (n->prev == (void *)h)\n+    h->first = next;\n+  else\n+    n->prev->next = next;\n+\n+  n->next = h->first;\n+  return n->next == &node;\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo ())\n+    abort ();\n+  return 0;\n+}"}]}