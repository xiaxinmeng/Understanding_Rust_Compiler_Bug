{"sha": "885035eacb36b5bf1aa3b0d05f675ab89665d7be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg1MDM1ZWFjYjM2YjViZjFhYTNiMGQwNWY2NzVhYjg5NjY1ZDdiZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-20T01:13:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-20T20:59:17Z"}, "message": "c++: designators in single-element init lists\n\nWhile looking at PR100489, it occurred to me that places that currently\nuse an initializer-list with a single element to initialize an object of the\nsame type shouldn't do that if the element has a designator.\n\ngcc/cp/ChangeLog:\n\n\t* call.c (reference_binding): Check for designator.\n\t(implicit_conversion_1, build_special_member_call): Likewise.\n\t* decl.c (reshape_init_r): Likewise.\n\t* pt.c (do_class_deduction): Likewise.\n\t* typeck2.c (digest_init_r): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/desig19.C: New test.", "tree": {"sha": "ff4cd9403ff68ee97e53d5ac5d48d23502412479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff4cd9403ff68ee97e53d5ac5d48d23502412479"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/885035eacb36b5bf1aa3b0d05f675ab89665d7be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885035eacb36b5bf1aa3b0d05f675ab89665d7be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/885035eacb36b5bf1aa3b0d05f675ab89665d7be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885035eacb36b5bf1aa3b0d05f675ab89665d7be/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7"}], "stats": {"total": 44, "additions": 42, "deletions": 2}, "files": [{"sha": "cfccf273632b02e0a392ea7142cbbb89efac455e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=885035eacb36b5bf1aa3b0d05f675ab89665d7be", "patch": "@@ -1731,7 +1731,8 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n \t because A[] and A[2] are reference-related.  But we don't do it\n \t because grok_reference_init has deduced the array size (to 1), and\n \t A[1] and A[2] aren't reference-related.  */\n-      if (CONSTRUCTOR_NELTS (expr) == 1)\n+      if (CONSTRUCTOR_NELTS (expr) == 1\n+\t  && !CONSTRUCTOR_IS_DESIGNATED_INIT (expr))\n \t{\n \t  tree elt = CONSTRUCTOR_ELT (expr, 0)->value;\n \t  if (error_operand_p (elt))\n@@ -2095,6 +2096,7 @@ implicit_conversion_1 (tree to, tree from, tree expr, bool c_cast_p,\n \t{\n \t  if (BRACE_ENCLOSED_INITIALIZER_P (expr)\n \t      && CONSTRUCTOR_NELTS (expr) == 1\n+\t      && !CONSTRUCTOR_IS_DESIGNATED_INIT (expr)\n \t      && !is_list_ctor (cand->fn))\n \t    {\n \t      /* \"If C is not an initializer-list constructor and the\n@@ -10199,6 +10201,7 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n \n       if (BRACE_ENCLOSED_INITIALIZER_P (arg)\n \t  && !TYPE_HAS_LIST_CTOR (class_type)\n+\t  && !CONSTRUCTOR_IS_DESIGNATED_INIT (arg)\n \t  && CONSTRUCTOR_NELTS (arg) == 1)\n \targ = CONSTRUCTOR_ELT (arg, 0)->value;\n "}, {"sha": "e7268d5ad18aa61b0120d1478c722c043e3d97fc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=885035eacb36b5bf1aa3b0d05f675ab89665d7be", "patch": "@@ -6650,6 +6650,8 @@ reshape_init_r (tree type, reshape_iter *d, tree first_initializer_p,\n      initialized from that element.\"  Even if T is an aggregate.  */\n   if (cxx_dialect >= cxx11 && (CLASS_TYPE_P (type) || VECTOR_TYPE_P (type))\n       && first_initializer_p\n+      /* But not if it's a designated init.  */\n+      && !d->cur->index\n       && d->end - d->cur == 1\n       && reference_related_p (type, TREE_TYPE (init)))\n     {"}, {"sha": "99a9ee5ade2e81930ba66329bc39f4a783a64171", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=885035eacb36b5bf1aa3b0d05f675ab89665d7be", "patch": "@@ -29326,7 +29326,8 @@ do_class_deduction (tree ptype, tree tmpl, tree init,\n     {\n       list_init_p = true;\n       try_list_ctor = TYPE_HAS_LIST_CTOR (type);\n-      if (try_list_ctor && CONSTRUCTOR_NELTS (init) == 1)\n+      if (try_list_ctor && CONSTRUCTOR_NELTS (init) == 1\n+\t  && !CONSTRUCTOR_IS_DESIGNATED_INIT (init))\n \t{\n \t  /* As an exception, the first phase in 16.3.1.7 (considering the\n \t     initializer list as a single argument) is omitted if the"}, {"sha": "6679e247816412cf6e43602751a0512a122e8c88", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=885035eacb36b5bf1aa3b0d05f675ab89665d7be", "patch": "@@ -1183,6 +1183,7 @@ digest_init_r (tree type, tree init, int nested, int flags,\n      the object is initialized from that element.\"  */\n   if (cxx_dialect >= cxx11\n       && BRACE_ENCLOSED_INITIALIZER_P (stripped_init)\n+      && !CONSTRUCTOR_IS_DESIGNATED_INIT (stripped_init)\n       && CONSTRUCTOR_NELTS (stripped_init) == 1\n       && ((CLASS_TYPE_P (type) && !CLASSTYPE_NON_AGGREGATE (type))\n \t  || VECTOR_TYPE_P (type)))"}, {"sha": "3321da85802091ec3faf628db21e4feda9461bd2", "filename": "gcc/testsuite/g++.dg/cpp2a/desig19.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/885035eacb36b5bf1aa3b0d05f675ab89665d7be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig19.C?ref=885035eacb36b5bf1aa3b0d05f675ab89665d7be", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" }\n+\n+struct A\n+{\n+  int i;\n+  constexpr operator int() { return 42; }\n+};\n+\n+#define SA(X) static_assert ((X),#X)\n+constexpr A a1 { A() };\n+SA(a1.i == 0);\n+constexpr A a2 { i: A() };\n+SA(a2.i == 42);\n+#if __cpp_constexpr >= 201304L\n+constexpr int f3 () { A const &r { A() }; return r.i; }\n+SA(f3() == 0);\n+constexpr int f4 () { A const &r { i: A() }; return r.i; }\n+SA(f4() == 42);\n+constexpr int f5 () { A ar[1]{{ A() }}; return ar[0].i; }\n+SA(f5() == 0);\n+constexpr int f5a () { A ar[1]{{ i: A() }}; return ar[0].i; }\n+SA(f5a() == 42);\n+#if __cpp_constexpr >= 201907L\n+constexpr int f6 () { A* p = new A{A()}; int i = p->i; delete p; return i; }\n+SA(f6() == 0);\n+constexpr int f6a () { A* p = new A{i:A()}; int i = p->i; delete p; return i; }\n+SA(f6a() == 42);\n+#endif\n+#endif\n+constexpr int f7 (A a) { return a.i; }\n+SA(f7({A()}) == 0);\n+SA(f7({i:A()}) == 42);"}]}