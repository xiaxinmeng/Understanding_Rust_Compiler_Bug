{"sha": "6e73e66606ebe0f3a1827b4401d259fac87fb36e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3M2U2NjYwNmViZTBmM2ExODI3YjQ0MDFkMjU5ZmFjODdmYjM2ZQ==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1997-12-24T21:39:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-24T21:39:44Z"}, "message": "flags.h, [...]: Remove flag_alias_check; optimization is now always enabled.\n\n        * flags.h, toplev.c, calls.c, alias.c: Remove flag_alias_check;\n        optimization is now always enabled.\n        * calls.c (expand_call): Recognize C++ operator new as malloc-like\n        function.\n        * alias.c (memrefs_conflict_p): Eliminate tests now done by\n        base_alias_check.\n        (*_dependence): Call canon_rtx before base_alias_check.\n        (init_alias_once): New function to precompute set of registers which\n        can hold Pmode function arguments.\n        * rtl.h: Declare init_alias_once.\n        * toplev.c (compile_file): Call init_alias_once.\n\nFrom-SVN: r17226", "tree": {"sha": "16ba7b39b3187d844bce4bf136901fa626027edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16ba7b39b3187d844bce4bf136901fa626027edb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e73e66606ebe0f3a1827b4401d259fac87fb36e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e73e66606ebe0f3a1827b4401d259fac87fb36e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e73e66606ebe0f3a1827b4401d259fac87fb36e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e73e66606ebe0f3a1827b4401d259fac87fb36e/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "280e521f029df248a105d1bd90c251ef26080f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280e521f029df248a105d1bd90c251ef26080f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/280e521f029df248a105d1bd90c251ef26080f09"}], "stats": {"total": 309, "additions": 131, "deletions": 178}, "files": [{"sha": "1a896454935996fda76dfcde6a24fcd5f1660954", "filename": "gcc/alias.c", "status": "modified", "additions": 122, "deletions": 164, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6e73e66606ebe0f3a1827b4401d259fac87fb36e", "patch": "@@ -293,7 +293,7 @@ record_base_value (regno, val)\n      int regno;\n      rtx val;\n {\n-  if (!flag_alias_check || regno >= reg_base_value_size)\n+  if (regno >= reg_base_value_size)\n     return;\n   if (GET_CODE (val) == REG)\n     {\n@@ -606,12 +606,6 @@ base_alias_check (x, y)\n    being referenced as a side effect.  This can happen when using AND to\n    align memory references, as is done on the Alpha.\n \n-   We recognize the following cases of non-conflicting memory:\n-\n-\t(1) addresses involving the frame pointer cannot conflict\n-\t    with addresses involving static variables.\n-\t(2) static variables with different addresses cannot conflict.\n-\n    Nice to notice that varying addresses cannot conflict with fp if no\n    local variables had their addresses taken, but that's too hard now.  */\n \n@@ -646,40 +640,8 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n       return 0;\n     }\n \n-  if (y == frame_pointer_rtx || y == hard_frame_pointer_rtx\n-      || y == stack_pointer_rtx || y == arg_pointer_rtx)\n-    {\n-      rtx t = y;\n-      int tsize = ysize;\n-      y = x; ysize = xsize;\n-      x = t; xsize = tsize;\n-    }\n-\n-  if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n-      || x == stack_pointer_rtx || x == arg_pointer_rtx)\n-    {\n-      rtx y1;\n-\n-      if (CONSTANT_P (y))\n-\treturn 0;\n-\n-      if (GET_CODE (y) == PLUS\n-\t  && canon_rtx (XEXP (y, 0)) == x\n-\t  && (y1 = canon_rtx (XEXP (y, 1)))\n-\t  && GET_CODE (y1) == CONST_INT)\n-\t{\n-\t  c += INTVAL (y1);\n-\t  return (xsize <= 0 || ysize <= 0\n-\t\t  || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n-\t}\n-\n-      if (GET_CODE (y) == PLUS\n-\t  && (y1 = canon_rtx (XEXP (y, 0)))\n-\t  && CONSTANT_P (y1))\n-\treturn 0;\n-\n-      return 1;\n-    }\n+  /* This code used to check for conflicts involving stack references and\n+     globals but the base address alias code now handles these cases.  */\n \n   if (GET_CODE (x) == PLUS)\n     {\n@@ -708,16 +670,7 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n \t  else if (GET_CODE (y1) == CONST_INT)\n \t    return memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n \n-\t  /* Handle case where we cannot understand iteration operators,\n-\t     but we notice that the base addresses are distinct objects.  */\n-\t  /* ??? Is this still necessary? */\n-\t  x = find_symbolic_term (x);\n-\t  if (x == 0)\n-\t    return 1;\n-\t  y = find_symbolic_term (y);\n-\t  if (y == 0)\n-\t    return 1;\n-\t  return rtx_equal_for_memref_p (x, y);\n+\t  return 1;\n \t}\n       else if (GET_CODE (x1) == CONST_INT)\n \treturn memrefs_conflict_p (xsize, x0, ysize, y, c - INTVAL (x1));\n@@ -854,17 +807,11 @@ true_dependence (mem, mem_mode, x, varies)\n      rtx x;\n      int (*varies)();\n {\n-  rtx x_addr, mem_addr;\n+  register rtx x_addr, mem_addr;\n \n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n-  x_addr = XEXP (x, 0);\n-  mem_addr = XEXP (mem, 0);\n-\n-  if (flag_alias_check && ! base_alias_check (x_addr, mem_addr))\n-    return 0;\n-\n   /* If X is an unchanging read, then it can't possibly conflict with any\n      non-unchanging store.  It may conflict with an unchanging write though,\n      because there may be a single store to this address to initialize it.\n@@ -875,8 +822,14 @@ true_dependence (mem, mem_mode, x, varies)\n   if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n     return 0;\n \n-  x_addr = canon_rtx (x_addr);\n-  mem_addr = canon_rtx (mem_addr);\n+  x_addr = canon_rtx (XEXP (x, 0));\n+  mem_addr = canon_rtx (XEXP (mem, 0));\n+\n+  /* Calling base_alias_check after canon_rtx detects more nonconflicting\n+     accesses at the cost of increased memory use. */\n+  if (! base_alias_check (x_addr, mem_addr))\n+    return 0;\n+\n   if (mem_mode == VOIDmode)\n     mem_mode = GET_MODE (mem);\n \n@@ -917,12 +870,11 @@ anti_dependence (mem, x)\n      rtx mem;\n      rtx x;\n {\n+  rtx x_addr, mem_addr;\n+\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n-  if (flag_alias_check && ! base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n-    return 0;\n-\n   /* If MEM is an unchanging read, then it can't possibly conflict with\n      the store to X, because there is at most one store to MEM, and it must\n      have occurred somewhere before MEM.  */\n@@ -931,15 +883,21 @@ anti_dependence (mem, x)\n   if (RTX_UNCHANGING_P (mem))\n     return 0;\n \n-  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n-\t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n+  x_addr = XEXP (x, 0);\n+  mem_addr = XEXP (mem, 0);\n+\n+  if (! base_alias_check (x_addr, mem_addr))\n+    return 0;\n+\n+  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n+\t\t\t      SIZE_FOR_MODE (x), x_addr, 0)\n \t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n \t\t&& GET_MODE (mem) != QImode\n-\t\t&& GET_CODE (XEXP (mem, 0)) != AND\n+\t\t&& GET_CODE (mem_addr) != AND\n \t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n \t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n \t\t&& GET_MODE (x) != QImode\n-\t\t&& GET_CODE (XEXP (x, 0)) != AND\n+\t\t&& GET_CODE (x_addr) != AND\n \t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n }\n \n@@ -953,11 +911,12 @@ output_dependence (mem, x)\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n-  if (flag_alias_check && !base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n-    return 0;\n-\n   x = canon_rtx (x);\n   mem = canon_rtx (mem);\n+\n+  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n+    return 0;\n+\n   return (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n \t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n \t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n@@ -970,15 +929,33 @@ output_dependence (mem, x)\n \t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n }\n \n+\n+static HARD_REG_SET argument_registers;\n+\n+void\n+init_alias_once ()\n+{\n+  register int i;\n+\n+#ifndef OUTGOING_REGNO\n+#define OUTGOING_REGNO(N) N\n+#endif\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    /* Check whether this register can hold an incoming pointer\n+       argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n+       numbers, so translate if necessary due to register windows. */\n+    if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))\n+\t&& HARD_REGNO_MODE_OK (i, Pmode))\n+      SET_HARD_REG_BIT (argument_registers, i);\n+}\n+\n void\n init_alias_analysis ()\n {\n   int maxreg = max_reg_num ();\n   int changed, pass;\n   register int i;\n   register rtx insn;\n-  rtx note;\n-  rtx set;\n \n   reg_known_value_size = maxreg;\n \n@@ -992,25 +969,22 @@ init_alias_analysis ()\n   bzero (reg_known_equiv_p + FIRST_PSEUDO_REGISTER,\n \t (maxreg - FIRST_PSEUDO_REGISTER) * sizeof (char));\n \n-  if (flag_alias_check)\n-    {\n-      /* Overallocate reg_base_value to allow some growth during loop\n-\t optimization.  Loop unrolling can create a large number of\n-\t registers.  */\n-      reg_base_value_size = maxreg * 2;\n-      reg_base_value = (rtx *)oballoc (reg_base_value_size * sizeof (rtx));\n-      new_reg_base_value = (rtx *)alloca (reg_base_value_size * sizeof (rtx));\n-      reg_seen = (char *)alloca (reg_base_value_size);\n-      bzero ((char *) reg_base_value, reg_base_value_size * sizeof (rtx));\n-    }\n+  /* Overallocate reg_base_value to allow some growth during loop\n+     optimization.  Loop unrolling can create a large number of\n+     registers.  */\n+  reg_base_value_size = maxreg * 2;\n+  reg_base_value = (rtx *)oballoc (reg_base_value_size * sizeof (rtx));\n+  new_reg_base_value = (rtx *)alloca (reg_base_value_size * sizeof (rtx));\n+  reg_seen = (char *)alloca (reg_base_value_size);\n+  bzero ((char *) reg_base_value, reg_base_value_size * sizeof (rtx));\n \n   /* The basic idea is that each pass through this loop will use the\n      \"constant\" information from the previous pass to propagate alias\n      information through another level of assignments.\n \n      This could get expensive if the assignment chains are long.  Maybe\n      we should throttle the number of iterations, possibly based on\n-     the optimization level.\n+     the optimization level or flag_expensive_optimizations.\n \n      We could propagate more information in the first pass by making use\n      of REG_N_SETS to determine immediately that the alias information\n@@ -1022,13 +996,10 @@ init_alias_analysis ()\n \n      The state of the arrays for the set chain in question does not matter\n      since the program has undefined behavior.  */\n-  changed = 1;\n+\n   pass = 0;\n-  while (changed && pass < MAX_ALIAS_LOOP_PASSES)\n+  do\n     {\n-      /* Keep track of the pass number so we can break out of the loop.  */\n-      pass++;\n-\n       /* Assume nothing will change this iteration of the loop.  */\n       changed = 0;\n \n@@ -1040,113 +1011,100 @@ init_alias_analysis ()\n \t loop, so we're copying arguments.  */\n       copying_arguments = 1;\n \n-      /* Only perform initialization of the arrays if we're actually\n-\t performing alias analysis. */\n-      if (flag_alias_check)\n-\t{\n-\t  /* Wipe the potential alias information clean for this pass.  */\n-\t  bzero ((char *) new_reg_base_value,\n-\t\t reg_base_value_size * sizeof (rtx));\n+      /* Wipe the potential alias information clean for this pass.  */\n+      bzero ((char *) new_reg_base_value, reg_base_value_size * sizeof (rtx));\n \n-\t  /* Wipe the reg_seen array clean.  */\n-\t  bzero ((char *) reg_seen, reg_base_value_size);\n+      /* Wipe the reg_seen array clean.  */\n+      bzero ((char *) reg_seen, reg_base_value_size);\n \n-\t  /* Mark all hard registers which may contain an address.\n-\t     The stack, frame and argument pointers may contain an address.\n-\t     An argument register which can hold a Pmode value may contain\n-\t     an address even if it is not in BASE_REGS.\n+      /* Mark all hard registers which may contain an address.\n+\t The stack, frame and argument pointers may contain an address.\n+\t An argument register which can hold a Pmode value may contain\n+\t an address even if it is not in BASE_REGS.\n \n-\t     The address expression is VOIDmode for an argument and\n-\t     Pmode for other registers.  */\n-#ifndef OUTGOING_REGNO\n-#define OUTGOING_REGNO(N) N\n-#endif\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    /* Check whether this register can hold an incoming pointer\n-\t       argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n-\t       numbers, so translate if necessary due to register windows. */\n-\t    if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))\n-\t\t&& HARD_REGNO_MODE_OK (i, Pmode))\n-\t      new_reg_base_value[i] = gen_rtx (ADDRESS, VOIDmode,\n-\t\t\t\t\t       gen_rtx (REG, Pmode, i));\n-\n-\t  new_reg_base_value[STACK_POINTER_REGNUM]\n-\t    = gen_rtx (ADDRESS, Pmode, stack_pointer_rtx);\n-\t  new_reg_base_value[ARG_POINTER_REGNUM]\n-\t    = gen_rtx (ADDRESS, Pmode, arg_pointer_rtx);\n-\t  new_reg_base_value[FRAME_POINTER_REGNUM]\n-\t    = gen_rtx (ADDRESS, Pmode, frame_pointer_rtx);\n+\t The address expression is VOIDmode for an argument and\n+\t Pmode for other registers.  */\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (argument_registers, i))\n+\t  new_reg_base_value[i] = gen_rtx (ADDRESS, VOIDmode,\n+\t\t\t\t\t   gen_rtx (REG, Pmode, i));\n+\n+      new_reg_base_value[STACK_POINTER_REGNUM]\n+\t= gen_rtx (ADDRESS, Pmode, stack_pointer_rtx);\n+      new_reg_base_value[ARG_POINTER_REGNUM]\n+\t= gen_rtx (ADDRESS, Pmode, arg_pointer_rtx);\n+      new_reg_base_value[FRAME_POINTER_REGNUM]\n+\t= gen_rtx (ADDRESS, Pmode, frame_pointer_rtx);\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t  new_reg_base_value[HARD_FRAME_POINTER_REGNUM]\n-\t    = gen_rtx (ADDRESS, Pmode, hard_frame_pointer_rtx);\n+      new_reg_base_value[HARD_FRAME_POINTER_REGNUM]\n+\t= gen_rtx (ADDRESS, Pmode, hard_frame_pointer_rtx);\n #endif\n-\t  if (struct_value_incoming_rtx\n-\t      && GET_CODE (struct_value_incoming_rtx) == REG)\n-\t    new_reg_base_value[REGNO (struct_value_incoming_rtx)]\n-\t      = gen_rtx (ADDRESS, Pmode, struct_value_incoming_rtx);\n-\n-\t  if (static_chain_rtx\n-\t      && GET_CODE (static_chain_rtx) == REG)\n-\t    new_reg_base_value[REGNO (static_chain_rtx)]\n-\t      = gen_rtx (ADDRESS, Pmode, static_chain_rtx);\n-\t}\n+      if (struct_value_incoming_rtx\n+\t  && GET_CODE (struct_value_incoming_rtx) == REG)\n+\tnew_reg_base_value[REGNO (struct_value_incoming_rtx)]\n+\t  = gen_rtx (ADDRESS, Pmode, struct_value_incoming_rtx);\n+\n+      if (static_chain_rtx\n+\t  && GET_CODE (static_chain_rtx) == REG)\n+\tnew_reg_base_value[REGNO (static_chain_rtx)]\n+\t  = gen_rtx (ADDRESS, Pmode, static_chain_rtx);\n \n       /* Walk the insns adding values to the new_reg_base_value array.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n-\t  if (flag_alias_check && GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t    {\n+\t      rtx note, set;\n \t      /* If this insn has a noalias note, process it,  Otherwise,\n \t         scan for sets.  A simple set will have no side effects\n \t         which could change the base value of any other register. */\n-\t      rtx noalias_note;\n+\n \t      if (GET_CODE (PATTERN (insn)) == SET\n-\t\t  && (noalias_note = find_reg_note (insn,\n-\t\t\t\t\t\t    REG_NOALIAS, NULL_RTX)))\n+\t\t  && (find_reg_note (insn, REG_NOALIAS, NULL_RTX)))\n \t\trecord_set (SET_DEST (PATTERN (insn)), 0);\n \t      else\n \t\tnote_stores (PATTERN (insn), record_set);\n+\n+\t      set = single_set (insn);\n+\n+\t      if (set != 0\n+\t\t  && GET_CODE (SET_DEST (set)) == REG\n+\t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t\t  && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n+\t\t       && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n+\t\t      || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n+\t\t  && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n+\t\t{\n+\t\t  int regno = REGNO (SET_DEST (set));\n+\t\t  reg_known_value[regno] = XEXP (note, 0);\n+\t\t  reg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+\t\t}\n \t    }\n \t  else if (GET_CODE (insn) == NOTE\n \t\t   && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n \t    copying_arguments = 0;\n+\t}\n \n-\t  if ((set = single_set (insn)) != 0\n-\t      && GET_CODE (SET_DEST (set)) == REG\n-\t      && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n-\t      && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n-\t\t   && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n-\t\t  || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n-\t      && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n+      /* Now propagate values from new_reg_base_value to reg_base_value.  */\n+      for (i = 0; i < reg_base_value_size; i++)\n+\t{\n+\t  if (new_reg_base_value[i]\n+\t      && new_reg_base_value[i] != reg_base_value[i]\n+\t      && ! rtx_equal_p (new_reg_base_value[i], reg_base_value[i]))\n \t    {\n-\t      int regno = REGNO (SET_DEST (set));\n-\t      reg_known_value[regno] = XEXP (note, 0);\n-\t      reg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+\t      reg_base_value[i] = new_reg_base_value[i];\n+\t      changed = 1;\n \t    }\n \t}\n-\n-      /* Now propagate values from new_reg_base_value to reg_base_value.  */\n-      if (flag_alias_check)\n-\tfor (i = 0; i < reg_base_value_size; i++)\n-\t  {\n-\t    if (new_reg_base_value[i]\n-\t        && new_reg_base_value[i] != reg_base_value[i]\n-\t        && !rtx_equal_p (new_reg_base_value[i], reg_base_value[i]))\n-\t      {\n-\t        reg_base_value[i] = new_reg_base_value[i];\n-\t        changed = 1;\n-\t      }\n-\t  }\n     }\n+  while (changed && ++pass < MAX_ALIAS_LOOP_PASSES);\n \n   /* Fill in the remaining entries.  */\n   for (i = FIRST_PSEUDO_REGISTER; i < maxreg; i++)\n     if (reg_known_value[i] == 0)\n       reg_known_value[i] = regno_reg_rtx[i];\n \n-  if (! flag_alias_check)\n-    return;\n-\n   /* Simplify the reg_base_value array so that no register refers to\n      another register, except to special registers indirectly through\n      ADDRESS expressions."}, {"sha": "d7794622128f9425f5a504ce3de9cbbc67b467d1", "filename": "gcc/calls.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6e73e66606ebe0f3a1827b4401d259fac87fb36e", "patch": "@@ -889,11 +889,13 @@ expand_call (exp, target, ignore)\n       else if (tname[0] == 'l' && tname[1] == 'o'\n \t       && ! strcmp (tname, \"longjmp\"))\n \tis_longjmp = 1;\n-      /* Only recognize malloc when alias analysis is enabled.  */\n-      else if (flag_alias_check\n-\t       && ((tname[0] == 'm' && ! strcmp(tname + 1, \"alloc\"))\n-\t\t   || (tname[0] == 'c' && ! strcmp(tname + 1, \"alloc\"))\n-\t\t   || (tname[0] == 'r' && ! strcmp(tname + 1, \"ealloc\"))))\n+      /* XXX should have \"malloc\" attribute on functions instead\n+\t of recognizing them by name.  */\n+      else if (! strcmp (tname, \"malloc\")\n+\t       || ! strcmp (tname, \"calloc\")\n+\t       || ! strcmp (tname, \"realloc\")\n+\t       || ! strcmp (tname, \"__builtin_new\")\n+\t       || ! strcmp (tname, \"__builtin_vec_new\"))\n \tis_malloc = 1;\n     }\n "}, {"sha": "05feed25b355f787f0adc3b6f66e4a73aaa593ab", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=6e73e66606ebe0f3a1827b4401d259fac87fb36e", "patch": "@@ -420,10 +420,6 @@ extern int flag_gnu_linker;\n /* Tag all structures with __attribute__(packed) */\n extern int flag_pack_struct;\n \n-/* 1 if alias checking is enabled: symbols do not alias each other\n-   and parameters do not alias the current stack frame.  */\n-extern int flag_alias_check;\n-\n /* This flag is only tested if alias checking is enabled.\n    0 if pointer arguments may alias each other.  True in C.\n    1 if pointer arguments may not alias each other but may alias"}, {"sha": "683546ea6d4ee2952f3a8e3042ecae1b74f2837c", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6e73e66606ebe0f3a1827b4401d259fac87fb36e", "patch": "@@ -1371,6 +1371,7 @@ extern int true_dependence\t\tPROTO ((rtx, enum machine_mode, rtx,\n extern int read_dependence\t\tPROTO ((rtx, rtx));\n extern int anti_dependence\t\tPROTO ((rtx, rtx));\n extern int output_dependence\t\tPROTO ((rtx, rtx));\n+extern void init_alias_once\t\tPROTO ((void));\n extern void init_alias_analysis\t\tPROTO ((void));\n extern void end_alias_analysis\t\tPROTO ((void));\n "}, {"sha": "10f6f48e8d8093729ab6f44b67c92412f08fa761", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e66606ebe0f3a1827b4401d259fac87fb36e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6e73e66606ebe0f3a1827b4401d259fac87fb36e", "patch": "@@ -672,9 +672,6 @@ int flag_prefix_function_name = 0;\n \n int flag_regmove = 0;\n \n-/* 1 if alias checking is on (by default, when -O).  */\n-int flag_alias_check = 0;\n-\n /* 0 if pointer arguments may alias each other.  True in C.\n    1 if pointer arguments may not alias each other but may alias\n    global variables.\n@@ -752,7 +749,6 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"pack-struct\", &flag_pack_struct, 1},\n   {\"stack-check\", &flag_stack_check, 1},\n   {\"bytecode\", &output_bytecode, 1},\n-  {\"alias-check\", &flag_alias_check, 1},\n   {\"argument-alias\", &flag_argument_noalias, 0},\n   {\"argument-noalias\", &flag_argument_noalias, 1},\n   {\"argument-noalias-global\", &flag_argument_noalias, 2},\n@@ -2277,6 +2273,7 @@ compile_file (name)\n   init_expr_once ();\n   init_loop ();\n   init_reload ();\n+  init_alias_once ();\n \n   if (flag_caller_saves)\n     init_caller_save ();\n@@ -3897,7 +3894,6 @@ main (argc, argv, envp)\n #ifdef CAN_DEBUG_WITHOUT_FP\n       flag_omit_frame_pointer = 1;\n #endif\n-      flag_alias_check = 1;\n     }\n \n   if (optimize >= 2)"}]}