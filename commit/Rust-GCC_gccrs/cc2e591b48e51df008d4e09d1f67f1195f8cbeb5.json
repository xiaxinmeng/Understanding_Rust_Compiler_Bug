{"sha": "cc2e591b48e51df008d4e09d1f67f1195f8cbeb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MyZTU5MWI0OGU1MWRmMDA4ZDRlMDlkMWY2N2YxMTk1ZjhjYmViNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-26T13:56:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-26T13:56:34Z"}, "message": "i386.md (push mem DI peep2): New.\n\n\t* i386.md (push mem DI peep2): New.\n\t(mov 0, mov -1 peep2): Handle 64bit.\n\t(lea to arithmetics peep2): Handle 64bit leas.\n\t(rsp arithmetics to push/pop peep2s): New.\n\n\t* i386.md (truncdfsf2_3, trunctfsf2_2): Change predicate to memory_operand.\n\nFrom-SVN: r40847", "tree": {"sha": "fc22ba8e7d086f9d7db904862931e20340cefe1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc22ba8e7d086f9d7db904862931e20340cefe1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc2e591b48e51df008d4e09d1f67f1195f8cbeb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2e591b48e51df008d4e09d1f67f1195f8cbeb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2e591b48e51df008d4e09d1f67f1195f8cbeb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2e591b48e51df008d4e09d1f67f1195f8cbeb5/comments", "author": null, "committer": null, "parents": [{"sha": "8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8362f4207eaa70dbee88b09a893cd5aa0515ee7f"}], "stats": {"total": 190, "additions": 183, "deletions": 7}, "files": [{"sha": "477517c0c1559b6309918abcdc647eea04aee761", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2e591b48e51df008d4e09d1f67f1195f8cbeb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2e591b48e51df008d4e09d1f67f1195f8cbeb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc2e591b48e51df008d4e09d1f67f1195f8cbeb5", "patch": "@@ -1,3 +1,12 @@\n+Mon Mar 26 15:55:08 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (push mem DI peep2): New.\n+\t(mov 0, mov -1 peep2): Handle 64bit.\n+\t(lea to arithmetics peep2): Handle 64bit leas.\n+\t(rsp arithmetics to push/pop peep2s): New.\n+\n+\t* i386.md (truncdfsf2_3, trunctfsf2_2): Change predicate to memory_operand.\n+\n Mon Mar 26 14:35:18 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (struct machine_function): Add save_varrargs_registers."}, {"sha": "8f6c36b31157087ca7156e5d8882d239f258a07c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 174, "deletions": 7, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2e591b48e51df008d4e09d1f67f1195f8cbeb5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2e591b48e51df008d4e09d1f67f1195f8cbeb5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cc2e591b48e51df008d4e09d1f67f1195f8cbeb5", "patch": "@@ -4341,7 +4341,7 @@\n    (set_attr \"mode\" \"DF,SF\")])\n \n (define_insn \"truncdfsf2_3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m\")\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n \t(float_truncate:SF\n \t (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_80387\"\n@@ -4490,7 +4490,7 @@\n    (set_attr \"mode\" \"SF\")])\n \n (define_insn \"*trunctfsf2_2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m\")\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n \t(float_truncate:SF\n \t (match_operand:TF 1 \"register_operand\" \"f\")))]\n   \"TARGET_80387\"\n@@ -15890,6 +15890,15 @@\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n \n+(define_peephole2\n+  [(set (match_operand:DI 0 \"push_operand\" \"\")\n+\t(match_operand:DI 1 \"memory_operand\" \"\"))\n+   (match_scratch:DI 2 \"r\")]\n+  \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"\")\n+\n ;; We need to handle SFmode only, because DFmode and XFmode is split to\n ;; SImode pushes.\n (define_peephole2\n@@ -16209,12 +16218,14 @@\n \t(const_int 0))]\n   \"(GET_MODE (operands[0]) == QImode\n     || GET_MODE (operands[0]) == HImode\n-    || GET_MODE (operands[0]) == SImode)\n+    || GET_MODE (operands[0]) == SImode\n+    || (GET_MODE (operands[0]) == DImode && TARGET_64BIT))\n    && (! TARGET_USE_MOV0 || optimize_size)\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (const_int 0))\n \t      (clobber (reg:CC 17))])]\n-  \"operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]));\")\n+  \"operands[0] = gen_rtx_REG (GET_MODE (operands[0]) == DImode ? DImode : SImode,\n+\t\t\t      true_regnum (operands[0]));\")\n \n (define_peephole2\n   [(set (strict_low_part (match_operand 0 \"register_operand\" \"\"))\n@@ -16231,12 +16242,14 @@\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(const_int -1))]\n   \"(GET_MODE (operands[0]) == HImode\n-    || GET_MODE (operands[0]) == SImode)\n+    || GET_MODE (operands[0]) == SImode \n+    || (GET_MODE (operands[0]) == DImode && TARGET_64BIT))\n    && (optimize_size || TARGET_PENTIUM)\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (const_int -1))\n \t      (clobber (reg:CC 17))])]\n-  \"operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]));\")\n+  \"operands[0] = gen_rtx_REG (GET_MODE (operands[0]) == DImode ? DImode : SImode,\n+\t\t\t      true_regnum (operands[0]));\")\n \n ;; Attempt to convert simple leas to adds. These can be created by\n ;; move expanders.\n@@ -16249,16 +16262,55 @@\n \t      (clobber (reg:CC 17))])]\n   \"\")\n \n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+  \t(subreg:SI (plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t    (match_operand:DI 2 \"nonmemory_operand\" \"\")) 0))]\n+  \"peep2_regno_dead_p (0, FLAGS_REG) && REGNO (operands[0]) == REGNO (operands[1])\"\n+  [(parallel [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))\n+\t      (clobber (reg:CC 17))])]\n+  \"operands[2] = gen_lowpart (SImode, operands[2]);\")\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+  \t(plus:DI (match_dup 0)\n+\t\t (match_operand:DI 1 \"x86_64_general_operand\" \"\")))]\n+  \"peep2_regno_dead_p (0, FLAGS_REG)\"\n+  [(parallel [(set (match_dup 0) (plus:DI (match_dup 0) (match_dup 1)))\n+\t      (clobber (reg:CC 17))])]\n+  \"\")\n+\n (define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n   \t(mult:SI (match_dup 0)\n-\t\t (match_operand:SI 1 \"immediate_operand\" \"\")))]\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))]\n   \"exact_log2 (INTVAL (operands[1])) >= 0\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))\n \t      (clobber (reg:CC 17))])]\n   \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1])));\")\n \n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+  \t(mult:DI (match_dup 0)\n+\t\t (match_operand:DI 1 \"const_int_operand\" \"\")))]\n+  \"exact_log2 (INTVAL (operands[1])) >= 0\n+   && peep2_regno_dead_p (0, FLAGS_REG)\"\n+  [(parallel [(set (match_dup 0) (ashift:DI (match_dup 0) (match_dup 2)))\n+\t      (clobber (reg:CC 17))])]\n+  \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1])));\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+  \t(subreg:SI (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:DI 2 \"const_int_operand\" \"\")) 0))]\n+  \"exact_log2 (INTVAL (operands[1])) >= 0\n+   && REGNO (operands[0]) == REGNO (operands[1])\n+   && peep2_regno_dead_p (0, FLAGS_REG)\"\n+  [(parallel [(set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))\n+\t      (clobber (reg:CC 17))])]\n+  \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\")\n+\n ;; The ESP adjustments can be done by the push and pop instructions.  Resulting\n ;; code is shorter, since push is only 1 byte, while add imm, %esp 3 bytes.  On\n ;; many CPUs it is also faster, since special hardware to avoid esp\n@@ -16456,6 +16508,121 @@\n \t      (clobber (match_dup 0))])]\n   \"\")\n \f\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int -8)))\n+\t      (set (reg:DI 6) (reg:DI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_SUB_ESP_4\"\n+  [(clobber (match_dup 0))\n+   (parallel [(set (mem:DI (pre_dec:DI (reg:DI 7))) (match_dup 0))\n+\t      (set (reg:DI 6) (reg:DI 6))])])\n+\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int -16)))\n+\t      (set (reg:DI 6) (reg:DI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_SUB_ESP_8\"\n+  [(clobber (match_dup 0))\n+   (set (mem:DI (pre_dec:DI (reg:DI 7))) (match_dup 0))\n+   (parallel [(set (mem:DI (pre_dec:DI (reg:DI 7))) (match_dup 0))\n+\t      (set (reg:DI 6) (reg:DI 6))])])\n+\n+;; Convert esp substractions to push.\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int -8)))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_SUB_ESP_4\"\n+  [(clobber (match_dup 0))\n+   (set (mem:DI (pre_dec:DI (reg:DI 7))) (match_dup 0))])\n+\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int -16)))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_SUB_ESP_8\"\n+  [(clobber (match_dup 0))\n+   (set (mem:DI (pre_dec:DI (reg:DI 7))) (match_dup 0))\n+   (set (mem:DI (pre_dec:DI (reg:DI 7))) (match_dup 0))])\n+\n+;; Convert epilogue deallocator to pop.\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))\n+\t      (set (reg:DI 6) (reg:DI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_ADD_ESP_4\"\n+  [(parallel [(set (match_dup 0) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))\n+\t      (set (reg:DI 6) (reg:DI 6))])]\n+  \"\")\n+\n+;; Two pops case is tricky, since pop causes dependency on destination register.\n+;; We use two registers if available.\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (match_scratch:DI 1 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 16)))\n+\t      (set (reg:DI 6) (reg:DI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_ADD_ESP_8\"\n+  [(parallel [(set (match_dup 0) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))\n+\t      (set (reg:DI 6) (reg:DI 6))])\n+   (parallel [(set (match_dup 1) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))])]\n+  \"\")\n+\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 16)))\n+\t      (set (reg:DI 6) (reg:DI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size\"\n+  [(parallel [(set (match_dup 0) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))\n+\t      (set (reg:DI 6) (reg:DI 6))])\n+   (parallel [(set (match_dup 0) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))])]\n+  \"\")\n+\n+;; Convert esp additions to pop.\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))])]\n+  \"\")\n+\n+;; Two pops case is tricky, since pop causes dependency on destination register.\n+;; We use two registers if available.\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (match_scratch:DI 1 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 16)))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))])\n+   (parallel [(set (match_dup 1) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))])]\n+  \"\")\n+\n+(define_peephole2\n+  [(match_scratch:DI 0 \"r\")\n+   (parallel [(set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 16)))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size\"\n+  [(parallel [(set (match_dup 0) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))])\n+   (parallel [(set (match_dup 0) (mem:DI (reg:DI 7)))\n+\t      (set (reg:DI 7) (plus:DI (reg:DI 7) (const_int 8)))])]\n+  \"\")\n+\f\n ;; Call-value patterns last so that the wildcard operand does not\n ;; disrupt insn-recog's switch tables.\n "}]}