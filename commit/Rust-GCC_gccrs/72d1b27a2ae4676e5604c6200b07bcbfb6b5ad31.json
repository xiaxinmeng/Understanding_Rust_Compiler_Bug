{"sha": "72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJkMWIyN2EyYWU0Njc2ZTU2MDRjNjIwMGIwN2JjYmZiNmI1YWQzMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T14:02:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T14:02:49Z"}, "message": "[multiple changes]\n\n2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Is_Matching_Input): Account\n\tfor the case where a state with a null refinement appears as\n\tthe last input of a refinement clause.\n\n2013-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_aux.ads, sem_aux.adb: Minor reformatting.\n\nFrom-SVN: r203766", "tree": {"sha": "c4e24a50bbfeb879ea8d177433e14b3d5ae6b2fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4e24a50bbfeb879ea8d177433e14b3d5ae6b2fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/comments", "author": null, "committer": null, "parents": [{"sha": "8b58a060443a7a04f2e1fa854ec2f9fac1a7ff1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b58a060443a7a04f2e1fa854ec2f9fac1a7ff1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b58a060443a7a04f2e1fa854ec2f9fac1a7ff1c"}], "stats": {"total": 232, "additions": 128, "deletions": 104}, "files": [{"sha": "39b8d248b182b19574d5d7dd81dadb781c9cb0ae", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "patch": "@@ -1,3 +1,13 @@\n+2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Is_Matching_Input): Account\n+\tfor the case where a state with a null refinement appears as\n+\tthe last input of a refinement clause.\n+\n+2013-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_aux.ads, sem_aux.adb: Minor reformatting.\n+\n 2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* aspects.adb, aspects.ads, sem_prag.ads: Remove all entries"}, {"sha": "d67517e2cebe829bff27558916f88811092b50fe", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "patch": "@@ -813,105 +813,6 @@ package body Sem_Aux is\n       end if;\n    end Is_Generic_Formal;\n \n-   ---------------------\n-   -- Is_Limited_View --\n-   ---------------------\n-\n-   function Is_Limited_View (Ent : Entity_Id) return Boolean is\n-      Btype : constant Entity_Id := Available_View (Base_Type (Ent));\n-\n-   begin\n-      if Is_Limited_Record (Btype) then\n-         return True;\n-\n-      elsif Ekind (Btype) = E_Limited_Private_Type\n-        and then Nkind (Parent (Btype)) = N_Formal_Type_Declaration\n-      then\n-         return not In_Package_Body (Scope ((Btype)));\n-\n-      elsif Is_Private_Type (Btype) then\n-\n-         --  AI05-0063: A type derived from a limited private formal type is\n-         --  not immutably limited in a generic body.\n-\n-         if Is_Derived_Type (Btype)\n-           and then Is_Generic_Type (Etype (Btype))\n-         then\n-            if not Is_Limited_Type (Etype (Btype)) then\n-               return False;\n-\n-            --  A descendant of a limited formal type is not immutably limited\n-            --  in the generic body, or in the body of a generic child.\n-\n-            elsif Ekind (Scope (Etype (Btype))) = E_Generic_Package then\n-               return not In_Package_Body (Scope (Btype));\n-\n-            else\n-               return False;\n-            end if;\n-\n-         else\n-            declare\n-               Utyp : constant Entity_Id := Underlying_Type (Btype);\n-            begin\n-               if No (Utyp) then\n-                  return False;\n-               else\n-                  return Is_Limited_View (Utyp);\n-               end if;\n-            end;\n-         end if;\n-\n-      elsif Is_Concurrent_Type (Btype) then\n-         return True;\n-\n-      elsif Is_Record_Type (Btype) then\n-\n-         --  Note that we return True for all limited interfaces, even though\n-         --  (unsynchronized) limited interfaces can have descendants that are\n-         --  nonlimited, because this is a predicate on the type itself, and\n-         --  things like functions with limited interface results need to be\n-         --  handled as build in place even though they might return objects\n-         --  of a type that is not inherently limited.\n-\n-         if Is_Class_Wide_Type (Btype) then\n-            return Is_Limited_View (Root_Type (Btype));\n-\n-         else\n-            declare\n-               C : Entity_Id;\n-\n-            begin\n-               C := First_Component (Btype);\n-               while Present (C) loop\n-\n-                  --  Don't consider components with interface types (which can\n-                  --  only occur in the case of a _parent component anyway).\n-                  --  They don't have any components, plus it would cause this\n-                  --  function to return true for nonlimited types derived from\n-                  --  limited interfaces.\n-\n-                  if not Is_Interface (Etype (C))\n-                    and then Is_Limited_View (Etype (C))\n-                  then\n-                     return True;\n-                  end if;\n-\n-                  C := Next_Component (C);\n-               end loop;\n-            end;\n-\n-            return False;\n-         end if;\n-\n-      elsif Is_Array_Type (Btype) then\n-         return Is_Limited_View (Component_Type (Btype));\n-\n-      else\n-         return False;\n-      end if;\n-   end Is_Limited_View;\n-\n    -------------------------------\n    -- Is_Immutably_Limited_Type --\n    -------------------------------\n@@ -1081,6 +982,105 @@ package body Sem_Aux is\n       end if;\n    end Is_Limited_Type;\n \n+   ---------------------\n+   -- Is_Limited_View --\n+   ---------------------\n+\n+   function Is_Limited_View (Ent : Entity_Id) return Boolean is\n+      Btype : constant Entity_Id := Available_View (Base_Type (Ent));\n+\n+   begin\n+      if Is_Limited_Record (Btype) then\n+         return True;\n+\n+      elsif Ekind (Btype) = E_Limited_Private_Type\n+        and then Nkind (Parent (Btype)) = N_Formal_Type_Declaration\n+      then\n+         return not In_Package_Body (Scope ((Btype)));\n+\n+      elsif Is_Private_Type (Btype) then\n+\n+         --  AI05-0063: A type derived from a limited private formal type is\n+         --  not immutably limited in a generic body.\n+\n+         if Is_Derived_Type (Btype)\n+           and then Is_Generic_Type (Etype (Btype))\n+         then\n+            if not Is_Limited_Type (Etype (Btype)) then\n+               return False;\n+\n+            --  A descendant of a limited formal type is not immutably limited\n+            --  in the generic body, or in the body of a generic child.\n+\n+            elsif Ekind (Scope (Etype (Btype))) = E_Generic_Package then\n+               return not In_Package_Body (Scope (Btype));\n+\n+            else\n+               return False;\n+            end if;\n+\n+         else\n+            declare\n+               Utyp : constant Entity_Id := Underlying_Type (Btype);\n+            begin\n+               if No (Utyp) then\n+                  return False;\n+               else\n+                  return Is_Limited_View (Utyp);\n+               end if;\n+            end;\n+         end if;\n+\n+      elsif Is_Concurrent_Type (Btype) then\n+         return True;\n+\n+      elsif Is_Record_Type (Btype) then\n+\n+         --  Note that we return True for all limited interfaces, even though\n+         --  (unsynchronized) limited interfaces can have descendants that are\n+         --  nonlimited, because this is a predicate on the type itself, and\n+         --  things like functions with limited interface results need to be\n+         --  handled as build in place even though they might return objects\n+         --  of a type that is not inherently limited.\n+\n+         if Is_Class_Wide_Type (Btype) then\n+            return Is_Limited_View (Root_Type (Btype));\n+\n+         else\n+            declare\n+               C : Entity_Id;\n+\n+            begin\n+               C := First_Component (Btype);\n+               while Present (C) loop\n+\n+                  --  Don't consider components with interface types (which can\n+                  --  only occur in the case of a _parent component anyway).\n+                  --  They don't have any components, plus it would cause this\n+                  --  function to return true for nonlimited types derived from\n+                  --  limited interfaces.\n+\n+                  if not Is_Interface (Etype (C))\n+                    and then Is_Limited_View (Etype (C))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  C := Next_Component (C);\n+               end loop;\n+            end;\n+\n+            return False;\n+         end if;\n+\n+      elsif Is_Array_Type (Btype) then\n+         return Is_Limited_View (Component_Type (Btype));\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Limited_View;\n+\n    ----------------------\n    -- Nearest_Ancestor --\n    ----------------------"}, {"sha": "49d75acfa7062696f041dcd1ba4edf272de3e0c0", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "patch": "@@ -283,7 +283,7 @@ package Sem_Aux is\n    function Is_Immutably_Limited_Type (Ent : Entity_Id) return Boolean;\n    --  Implements definition in Ada 2012 RM-7.5 (8.1/3). This differs from the\n    --  following predicate in that an untagged record with immutably limited\n-   --  components is NOT by itself immutably limited. This matters, eg. when\n+   --  components is NOT by itself immutably limited. This matters, e.g. when\n    --  checking the legality of an access to the current instance.\n \n    function Is_Limited_View (Ent : Entity_Id) return Boolean;\n@@ -301,7 +301,7 @@ package Sem_Aux is\n    --  private type, limited interface type, task type, protected type,\n    --  composite containing a limited component, or a subtype of any of\n    --  these types). This older routine overlaps with the previous one, this\n-   --  should be cleaned up?\n+   --  should be cleaned up???\n \n    function Nearest_Ancestor (Typ : Entity_Id) return Entity_Id;\n    --  Given a subtype Typ, this function finds out the nearest ancestor from"}, {"sha": "33f24075d6fc89ccd501a446aa8d15b147f0c4b9", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "patch": "@@ -20004,17 +20004,17 @@ package body Sem_Prag is\n                         --  A state with a null refinement matches either a\n                         --  null input list or nothing at all (no input):\n \n-                        --    Refined_State (State => null)\n+                        --    Refined_State   => (State => null)\n \n                         --  No input\n \n                         --    Depends         => (<output> => (State, Input))\n-                        --    Refined_Depends => (<output> => Input  --  OK\n+                        --    Refined_Depends => (<output> => Input)  --  OK\n \n                         --  Null input list\n \n                         --    Depends         => (<output> => State)\n-                        --    Refined_Depends => (<output> => null)  --  OK\n+                        --    Refined_Depends => (<output> => null)   --  OK\n \n                         if Has_Null_Refinement (Dep_Id) then\n                            Has_Null_State := True;\n@@ -20073,6 +20073,20 @@ package body Sem_Prag is\n \n                      Ref_Input := Next_Ref_Input;\n                   end loop;\n+\n+                  --  When a state with a null refinement appears as the last\n+                  --  input, it matches nothing:\n+\n+                  --    Refined_State   => (State => null)\n+                  --    Depends         => (<output> => (Input, State))\n+                  --    Refined_Depends => (<output> => Input)  --  OK\n+\n+                  if Ekind (Dep_Id) = E_Abstract_State\n+                    and then Has_Null_Refinement (Dep_Id)\n+                    and then No (Ref_Input)\n+                  then\n+                     Has_Null_State := True;\n+                  end if;\n                end if;\n \n                --  A state with visible refinement was matched against one or"}]}