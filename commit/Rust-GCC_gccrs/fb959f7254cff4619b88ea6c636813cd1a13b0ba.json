{"sha": "fb959f7254cff4619b88ea6c636813cd1a13b0ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI5NTlmNzI1NGNmZjQ2MTliODhlYTZjNjM2ODEzY2QxYTEzYjBiYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2008-03-25T20:43:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-03-25T20:43:06Z"}, "message": "re PR rtl-optimization/35232 (ICE in fp-int-convert-double.c at -O2)\n\ngcc/\n\tPR rtl-optimization/35232\n\t* reload1.c (reg_reloaded_call_part_clobbered): Clarify comment.\n\t(forget_old_reloads_1, forget_marked_reloads): Don't clear\n\treg_reloaded_call_part_clobbered here.\n\t(reload_regs_reach_end_p): New function.\n\t(reload_reg_rtx_for_input): New variable.\n\t(reload_reg_rtx_for_output): Likewise.\n\t(emit_input_reload_insns): Use reloadreg rather than rl->reg_rtx\n\twhen reassigning a pseudo register.  Load reloadreg from \n\treload_reg_rtx_for_input, moving the mode and register\n\tcalculation to...\n\t(do_input_reload): ...here.  Use the mode-adjusted reg_rtx\n\tinstead of the original when deciding whether an input reload\n\twould be a no-op or whether an output reload can be deleted.\n\t(emit_output_reload_insns): Use the mode-adjusted reg_rtx\n\twhen setting up new_spill_reg_store.  Load it from\n\treload_reg_rtx_for_output, moving the mode and register\n\tcalculation to...\n\t(do_output_reload): ...here.  Use the mode-adjusted reg_rtx\n\tinstead of the original when deciding whether an output reload\n\twould be a no-op.  Do the same when modifying insn notes.\n\tUse rtx_equal_p instead of == to compare the registers.\n\t(inherit_piecemeal_p): Take a mode and two register numbers\n\tas argument.\n\t(emit_reload_insns): Clear new_spill_reg_store for every hard\n\tregister in the reload register.  Remove spill registers\n\tfrom reg_reloaded_valid before considering whether to record\n\tinheritance information for them.  Use reload_reg_rtx_for_output\n\tinstead of reg_rtx when recording output reloads.  Use\n\treload_reg_rtx_for_input instead of reg_rtx when recording\n\tinput reloads.  Set or clear reg_reloaded_call_part_clobbered\n\tat the same time as setting reg_reloaded_valid.\n\t(delete_output_reload): Add a new_reload_reg parameter and use it\n\tinstead of rld[j].reg_rtx.\n\t(emit_input_reload_insns, do_input_reload, do_output_reload): Adjust\n\tcalls accordingly.\n\ngcc/testsuite/\n\tPR rtl-optimization/35232\n\t* gcc.target/mips/pr35232.c: New test.\n\nFrom-SVN: r133531", "tree": {"sha": "b1b2f237525f27c1997461a77818e3213244e2d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1b2f237525f27c1997461a77818e3213244e2d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb959f7254cff4619b88ea6c636813cd1a13b0ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb959f7254cff4619b88ea6c636813cd1a13b0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb959f7254cff4619b88ea6c636813cd1a13b0ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb959f7254cff4619b88ea6c636813cd1a13b0ba/comments", "author": null, "committer": null, "parents": [{"sha": "a8c86f3f8162c50f42135fc5c3b0485302b2dd9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c86f3f8162c50f42135fc5c3b0485302b2dd9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8c86f3f8162c50f42135fc5c3b0485302b2dd9f"}], "stats": {"total": 587, "additions": 345, "deletions": 242}, "files": [{"sha": "70c9ec34125a864d2ec43f16ac400fd5d2c9c201", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb959f7254cff4619b88ea6c636813cd1a13b0ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb959f7254cff4619b88ea6c636813cd1a13b0ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb959f7254cff4619b88ea6c636813cd1a13b0ba", "patch": "@@ -1,3 +1,42 @@\n+2008-03-25  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR rtl-optimization/35232\n+\t* reload1.c (reg_reloaded_call_part_clobbered): Clarify comment.\n+\t(forget_old_reloads_1, forget_marked_reloads): Don't clear\n+\treg_reloaded_call_part_clobbered here.\n+\t(reload_regs_reach_end_p): New function.\n+\t(reload_reg_rtx_for_input): New variable.\n+\t(reload_reg_rtx_for_output): Likewise.\n+\t(emit_input_reload_insns): Use reloadreg rather than rl->reg_rtx\n+\twhen reassigning a pseudo register.  Load reloadreg from \n+\treload_reg_rtx_for_input, moving the mode and register\n+\tcalculation to...\n+\t(do_input_reload): ...here.  Use the mode-adjusted reg_rtx\n+\tinstead of the original when deciding whether an input reload\n+\twould be a no-op or whether an output reload can be deleted.\n+\t(emit_output_reload_insns): Use the mode-adjusted reg_rtx\n+\twhen setting up new_spill_reg_store.  Load it from\n+\treload_reg_rtx_for_output, moving the mode and register\n+\tcalculation to...\n+\t(do_output_reload): ...here.  Use the mode-adjusted reg_rtx\n+\tinstead of the original when deciding whether an output reload\n+\twould be a no-op.  Do the same when modifying insn notes.\n+\tUse rtx_equal_p instead of == to compare the registers.\n+\t(inherit_piecemeal_p): Take a mode and two register numbers\n+\tas argument.\n+\t(emit_reload_insns): Clear new_spill_reg_store for every hard\n+\tregister in the reload register.  Remove spill registers\n+\tfrom reg_reloaded_valid before considering whether to record\n+\tinheritance information for them.  Use reload_reg_rtx_for_output\n+\tinstead of reg_rtx when recording output reloads.  Use\n+\treload_reg_rtx_for_input instead of reg_rtx when recording\n+\tinput reloads.  Set or clear reg_reloaded_call_part_clobbered\n+\tat the same time as setting reg_reloaded_valid.\n+\t(delete_output_reload): Add a new_reload_reg parameter and use it\n+\tinstead of rld[j].reg_rtx.\n+\t(emit_input_reload_insns, do_input_reload, do_output_reload): Adjust\n+\tcalls accordingly.\n+\n 2008-03-25  Tom Tromey  <tromey@redhat.com>\n \n \t* Makefile.in (build/gensupport.o): Depend on insn-modes.h."}, {"sha": "47d97fba477c476fe1d2c1a9d2b2d3f887203a52", "filename": "gcc/reload1.c", "status": "modified", "additions": 284, "deletions": 242, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb959f7254cff4619b88ea6c636813cd1a13b0ba/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb959f7254cff4619b88ea6c636813cd1a13b0ba/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=fb959f7254cff4619b88ea6c636813cd1a13b0ba", "patch": "@@ -158,7 +158,7 @@ static HARD_REG_SET reg_reloaded_dead;\n \n /* Indicate whether the register's current value is one that is not\n    safe to retain across a call, even for registers that are normally\n-   call-saved.  */\n+   call-saved.  This is only meaningful for members of reg_reloaded_valid.  */\n static HARD_REG_SET reg_reloaded_call_part_clobbered;\n \n /* Number of spill-regs so far; number of valid elements of spill_regs.  */\n@@ -434,9 +434,8 @@ static void emit_output_reload_insns (struct insn_chain *, struct reload *,\n \t\t\t\t      int);\n static void do_input_reload (struct insn_chain *, struct reload *, int);\n static void do_output_reload (struct insn_chain *, struct reload *, int);\n-static bool inherit_piecemeal_p (int, int);\n static void emit_reload_insns (struct insn_chain *);\n-static void delete_output_reload (rtx, int, int);\n+static void delete_output_reload (rtx, int, int, rtx);\n static void delete_address_reloads (rtx, rtx);\n static void delete_address_reloads_1 (rtx, rtx, rtx);\n static rtx inc_for_reload (rtx, rtx, rtx, int);\n@@ -4371,7 +4370,6 @@ forget_old_reloads_1 (rtx x, const_rtx ignored ATTRIBUTE_UNUSED,\n \t      || ! TEST_HARD_REG_BIT (reg_is_output_reload, regno + i))\n \t    {\n \t      CLEAR_HARD_REG_BIT (reg_reloaded_valid, regno + i);\n-\t      CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, regno + i);\n \t      spill_reg_store[regno + i] = 0;\n \t    }\n     }\n@@ -4408,7 +4406,6 @@ forget_marked_reloads (regset regs)\n \t      || ! TEST_HARD_REG_BIT (reg_is_output_reload, reg)))\n \t  {\n \t    CLEAR_HARD_REG_BIT (reg_reloaded_valid, reg);\n-\t    CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, reg);\n \t    spill_reg_store[reg] = 0;\n \t  }\n       if (n_reloads == 0\n@@ -4922,6 +4919,21 @@ reload_reg_reaches_end_p (unsigned int regno, int opnum, enum reload_type type)\n       gcc_unreachable ();\n     }\n }\n+\n+/* Like reload_reg_reaches_end_p, but check that the condition holds for\n+   every register in the range [REGNO, REGNO + NREGS).  */\n+\n+static bool\n+reload_regs_reach_end_p (unsigned int regno, int nregs,\n+\t\t\t int opnum, enum reload_type type)\n+{\n+  int i;\n+\n+  for (i = 0; i < nregs; i++)\n+    if (!reload_reg_reaches_end_p (regno + i, opnum, type))\n+      return false;\n+  return true;\n+}\n \f\n \n /*  Returns whether R1 and R2 are uniquely chained: the value of one\n@@ -5061,6 +5073,12 @@ static rtx reload_override_in[MAX_RELOADS];\n    or -1 if we did not need a register for this reload.  */\n static int reload_spill_index[MAX_RELOADS];\n \n+/* Index X is the value of rld[X].reg_rtx, adjusted for the input mode.  */\n+static rtx reload_reg_rtx_for_input[MAX_RELOADS];\n+\n+/* Index X is the value of rld[X].reg_rtx, adjusted for the output mode.  */\n+static rtx reload_reg_rtx_for_output[MAX_RELOADS];\n+\n /* Subroutine of free_for_value_p, used to check a single register.\n    START_REGNO is the starting regno of the full reload register\n    (possibly comprising multiple hard registers) that we are considering.  */\n@@ -6552,49 +6570,13 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t\t rtx old, int j)\n {\n   rtx insn = chain->insn;\n-  rtx reloadreg = rl->reg_rtx;\n+  rtx reloadreg;\n   rtx oldequiv_reg = 0;\n   rtx oldequiv = 0;\n   int special = 0;\n   enum machine_mode mode;\n   rtx *where;\n \n-  /* Determine the mode to reload in.\n-     This is very tricky because we have three to choose from.\n-     There is the mode the insn operand wants (rl->inmode).\n-     There is the mode of the reload register RELOADREG.\n-     There is the intrinsic mode of the operand, which we could find\n-     by stripping some SUBREGs.\n-     It turns out that RELOADREG's mode is irrelevant:\n-     we can change that arbitrarily.\n-\n-     Consider (SUBREG:SI foo:QI) as an operand that must be SImode;\n-     then the reload reg may not support QImode moves, so use SImode.\n-     If foo is in memory due to spilling a pseudo reg, this is safe,\n-     because the QImode value is in the least significant part of a\n-     slot big enough for a SImode.  If foo is some other sort of\n-     memory reference, then it is impossible to reload this case,\n-     so previous passes had better make sure this never happens.\n-\n-     Then consider a one-word union which has SImode and one of its\n-     members is a float, being fetched as (SUBREG:SF union:SI).\n-     We must fetch that as SFmode because we could be loading into\n-     a float-only register.  In this case OLD's mode is correct.\n-\n-     Consider an immediate integer: it has VOIDmode.  Here we need\n-     to get a mode from something else.\n-\n-     In some cases, there is a fourth mode, the operand's\n-     containing mode.  If the insn specifies a containing mode for\n-     this operand, it overrides all others.\n-\n-     I am not sure whether the algorithm here is always right,\n-     but it does the right things in those cases.  */\n-\n-  mode = GET_MODE (old);\n-  if (mode == VOIDmode)\n-    mode = rl->inmode;\n-\n   /* delete_output_reload is only invoked properly if old contains\n      the original pseudo register.  Since this is replaced with a\n      hard reg when RELOAD_OVERRIDE_IN is set, see if we can\n@@ -6612,6 +6594,9 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n   else if (GET_CODE (oldequiv) == SUBREG)\n     oldequiv_reg = SUBREG_REG (oldequiv);\n \n+  reloadreg = reload_reg_rtx_for_input[j];\n+  mode = GET_MODE (reloadreg);\n+\n   /* If we are reloading from a register that was recently stored in\n      with an output-reload, see if we can prove there was\n      actually no need to store the old value in it.  */\n@@ -6623,16 +6608,11 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n       && (dead_or_set_p (insn, spill_reg_stored_to[REGNO (oldequiv)])\n \t  || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n \t\t\t  rl->out_reg)))\n-    delete_output_reload (insn, j, REGNO (oldequiv));\n+    delete_output_reload (insn, j, REGNO (oldequiv), reloadreg);\n \n-  /* Encapsulate both RELOADREG and OLDEQUIV into that mode,\n-     then load RELOADREG from OLDEQUIV.  Note that we cannot use\n-     gen_lowpart_common since it can do the wrong thing when\n-     RELOADREG has a multi-word mode.  Note that RELOADREG\n-     must always be a REG here.  */\n+  /* Encapsulate OLDEQUIV into the reload mode, then load RELOADREG from\n+     OLDEQUIV.  */\n \n-  if (GET_MODE (reloadreg) != mode)\n-    reloadreg = reload_adjust_reg_for_mode (reloadreg, mode);\n   while (GET_CODE (oldequiv) == SUBREG && GET_MODE (oldequiv) != mode)\n     oldequiv = SUBREG_REG (oldequiv);\n   if (GET_MODE (oldequiv) != VOIDmode\n@@ -6696,7 +6676,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t\t     spill_reg_stored_to[REGNO (oldequiv)])\n \t      || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n \t\t\t      old)))\n-\tdelete_output_reload (insn, j, REGNO (oldequiv));\n+\tdelete_output_reload (insn, j, REGNO (oldequiv), reloadreg);\n \n       /* Prevent normal processing of this reload.  */\n       special = 1;\n@@ -6756,7 +6736,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t      if (REG_N_DEATHS (REGNO (old)) == 1\n \t\t  && REG_N_SETS (REGNO (old)) == 1)\n \t\t{\n-\t\t  reg_renumber[REGNO (old)] = REGNO (rl->reg_rtx);\n+\t\t  reg_renumber[REGNO (old)] = REGNO (reloadreg);\n \t\t  alter_reg (REGNO (old), -1);\n \t\t}\n \t      special = 1;\n@@ -7015,35 +6995,23 @@ static void\n emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t\t  int j)\n {\n-  rtx reloadreg = rl->reg_rtx;\n+  rtx reloadreg;\n   rtx insn = chain->insn;\n   int special = 0;\n   rtx old = rl->out;\n-  enum machine_mode mode = GET_MODE (old);\n+  enum machine_mode mode;\n   rtx p;\n+  rtx rl_reg_rtx;\n \n   if (rl->when_needed == RELOAD_OTHER)\n     start_sequence ();\n   else\n     push_to_sequence (output_reload_insns[rl->opnum]);\n \n-  /* Determine the mode to reload in.\n-     See comments above (for input reloading).  */\n-\n-  if (mode == VOIDmode)\n-    {\n-      /* VOIDmode should never happen for an output.  */\n-      if (asm_noperands (PATTERN (insn)) < 0)\n-\t/* It's the compiler's fault.  */\n-\tfatal_insn (\"VOIDmode on an output\", insn);\n-      error_for_asm (insn, \"output operand is constant in %<asm%>\");\n-      /* Prevent crash--use something we know is valid.  */\n-      mode = word_mode;\n-      old = gen_rtx_REG (mode, REGNO (reloadreg));\n-    }\n+  rl_reg_rtx = reload_reg_rtx_for_output[j];\n+  mode = GET_MODE (rl_reg_rtx);\n \n-  if (GET_MODE (reloadreg) != mode)\n-    reloadreg = reload_adjust_reg_for_mode (reloadreg, mode);\n+  reloadreg = rl_reg_rtx;\n \n   /* If we need two reload regs, set RELOADREG to the intermediate\n      one, since it will be stored into OLD.  We might need a secondary\n@@ -7167,12 +7135,12 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t   reg_has_output_reload will make this do nothing.  */\n \tnote_stores (pat, forget_old_reloads_1, NULL);\n \n-\tif (reg_mentioned_p (rl->reg_rtx, pat))\n+\tif (reg_mentioned_p (rl_reg_rtx, pat))\n \t  {\n \t    rtx set = single_set (insn);\n \t    if (reload_spill_index[j] < 0\n \t\t&& set\n-\t\t&& SET_SRC (set) == rl->reg_rtx)\n+\t\t&& SET_SRC (set) == rl_reg_rtx)\n \t      {\n \t\tint src = REGNO (SET_SRC (set));\n \n@@ -7181,7 +7149,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\tif (find_regno_note (insn, REG_DEAD, src))\n \t\t  SET_HARD_REG_BIT (reg_reloaded_died, src);\n \t      }\n-\t    if (REGNO (rl->reg_rtx) < FIRST_PSEUDO_REGISTER)\n+\t    if (HARD_REGISTER_P (rl_reg_rtx))\n \t      {\n \t\tint s = rl->secondary_out_reload;\n \t\tset = single_set (p);\n@@ -7194,7 +7162,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t     made; leave new_spill_reg_store alone.  */\n \t\t  ;\n \t\telse if (s >= 0\n-\t\t\t && SET_SRC (set) == rl->reg_rtx\n+\t\t\t && SET_SRC (set) == rl_reg_rtx\n \t\t\t && SET_DEST (set) == rld[s].reg_rtx)\n \t\t  {\n \t\t    /* Usually the next instruction will be the\n@@ -7215,7 +7183,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t      }\n \t\t  }\n \t\telse\n-\t\t  new_spill_reg_store[REGNO (rl->reg_rtx)] = p;\n+\t\t  new_spill_reg_store[REGNO (rl_reg_rtx)] = p;\n \t      }\n \t  }\n       }\n@@ -7242,13 +7210,62 @@ do_input_reload (struct insn_chain *chain, struct reload *rl, int j)\n   rtx insn = chain->insn;\n   rtx old = (rl->in && MEM_P (rl->in)\n \t     ? rl->in_reg : rl->in);\n+  rtx reg_rtx = rl->reg_rtx;\n+\n+  if (old && reg_rtx)\n+    {\n+      enum machine_mode mode;\n+\n+      /* Determine the mode to reload in.\n+\t This is very tricky because we have three to choose from.\n+\t There is the mode the insn operand wants (rl->inmode).\n+\t There is the mode of the reload register RELOADREG.\n+\t There is the intrinsic mode of the operand, which we could find\n+\t by stripping some SUBREGs.\n+\t It turns out that RELOADREG's mode is irrelevant:\n+\t we can change that arbitrarily.\n+\n+\t Consider (SUBREG:SI foo:QI) as an operand that must be SImode;\n+\t then the reload reg may not support QImode moves, so use SImode.\n+\t If foo is in memory due to spilling a pseudo reg, this is safe,\n+\t because the QImode value is in the least significant part of a\n+\t slot big enough for a SImode.  If foo is some other sort of\n+\t memory reference, then it is impossible to reload this case,\n+\t so previous passes had better make sure this never happens.\n+\n+\t Then consider a one-word union which has SImode and one of its\n+\t members is a float, being fetched as (SUBREG:SF union:SI).\n+\t We must fetch that as SFmode because we could be loading into\n+\t a float-only register.  In this case OLD's mode is correct.\n+\n+\t Consider an immediate integer: it has VOIDmode.  Here we need\n+\t to get a mode from something else.\n+\n+\t In some cases, there is a fourth mode, the operand's\n+\t containing mode.  If the insn specifies a containing mode for\n+\t this operand, it overrides all others.\n+\n+\t I am not sure whether the algorithm here is always right,\n+\t but it does the right things in those cases.  */\n+\n+      mode = GET_MODE (old);\n+      if (mode == VOIDmode)\n+\tmode = rl->inmode;\n+\n+      /* We cannot use gen_lowpart_common since it can do the wrong thing\n+\t when REG_RTX has a multi-word mode.  Note that REG_RTX must\n+\t always be a REG here.  */\n+      if (GET_MODE (reg_rtx) != mode)\n+\treg_rtx = reload_adjust_reg_for_mode (reg_rtx, mode);\n+    }\n+  reload_reg_rtx_for_input[j] = reg_rtx;\n \n   if (old != 0\n       /* AUTO_INC reloads need to be handled even if inherited.  We got an\n \t AUTO_INC reload if reload_out is set but reload_out_reg isn't.  */\n       && (! reload_inherited[j] || (rl->out && ! rl->out_reg))\n-      && ! rtx_equal_p (rl->reg_rtx, old)\n-      && rl->reg_rtx != 0)\n+      && ! rtx_equal_p (reg_rtx, old)\n+      && reg_rtx != 0)\n     emit_input_reload_insns (chain, rld + j, old, j);\n \n   /* When inheriting a wider reload, we have a MEM in rl->in,\n@@ -7267,24 +7284,21 @@ do_input_reload (struct insn_chain *chain, struct reload *rl, int j)\n \n   if (optimize\n       && (reload_inherited[j] || reload_override_in[j])\n-      && rl->reg_rtx\n-      && REG_P (rl->reg_rtx)\n-      && spill_reg_store[REGNO (rl->reg_rtx)] != 0\n+      && reg_rtx\n+      && REG_P (reg_rtx)\n+      && spill_reg_store[REGNO (reg_rtx)] != 0\n #if 0\n       /* There doesn't seem to be any reason to restrict this to pseudos\n \t and doing so loses in the case where we are copying from a\n \t register of the wrong class.  */\n-      && (REGNO (spill_reg_stored_to[REGNO (rl->reg_rtx)])\n-\t  >= FIRST_PSEUDO_REGISTER)\n+      && !HARD_REGISTER_P (spill_reg_stored_to[REGNO (reg_rtx)])\n #endif\n       /* The insn might have already some references to stackslots\n \t replaced by MEMs, while reload_out_reg still names the\n \t original pseudo.  */\n-      && (dead_or_set_p (insn,\n-\t\t\t spill_reg_stored_to[REGNO (rl->reg_rtx)])\n-\t  || rtx_equal_p (spill_reg_stored_to[REGNO (rl->reg_rtx)],\n-\t\t\t  rl->out_reg)))\n-    delete_output_reload (insn, j, REGNO (rl->reg_rtx));\n+      && (dead_or_set_p (insn, spill_reg_stored_to[REGNO (reg_rtx)])\n+\t  || rtx_equal_p (spill_reg_stored_to[REGNO (reg_rtx)], rl->out_reg)))\n+    delete_output_reload (insn, j, REGNO (reg_rtx), reg_rtx);\n }\n \n /* Do output reloading for reload RL, which is for the insn described by\n@@ -7300,6 +7314,30 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n      not loaded in this same reload, see if we can eliminate a previous\n      store.  */\n   rtx pseudo = rl->out_reg;\n+  rtx reg_rtx = rl->reg_rtx;\n+\n+  if (rl->out && reg_rtx)\n+    {\n+      enum machine_mode mode;\n+\n+      /* Determine the mode to reload in.\n+\t See comments above (for input reloading).  */\n+      mode = GET_MODE (rl->out);\n+      if (mode == VOIDmode)\n+\t{\n+\t  /* VOIDmode should never happen for an output.  */\n+\t  if (asm_noperands (PATTERN (insn)) < 0)\n+\t    /* It's the compiler's fault.  */\n+\t    fatal_insn (\"VOIDmode on an output\", insn);\n+\t  error_for_asm (insn, \"output operand is constant in %<asm%>\");\n+\t  /* Prevent crash--use something we know is valid.  */\n+\t  mode = word_mode;\n+\t  rl->out = gen_rtx_REG (mode, REGNO (reg_rtx));\n+\t}\n+      if (GET_MODE (reg_rtx) != mode)\n+\treg_rtx = reload_adjust_reg_for_mode (reg_rtx, mode);\n+    }\n+  reload_reg_rtx_for_output[j] = reg_rtx;\n \n   if (pseudo\n       && optimize\n@@ -7318,13 +7356,13 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n \t  && reg_reloaded_contents[last_regno] == pseudo_no\n \t  && spill_reg_store[last_regno]\n \t  && rtx_equal_p (pseudo, spill_reg_stored_to[last_regno]))\n-\tdelete_output_reload (insn, j, last_regno);\n+\tdelete_output_reload (insn, j, last_regno, reg_rtx);\n     }\n \n   old = rl->out_reg;\n   if (old == 0\n-      || rl->reg_rtx == old\n-      || rl->reg_rtx == 0)\n+      || reg_rtx == 0\n+      || rtx_equal_p (old, reg_rtx))\n     return;\n \n   /* An output operand that dies right away does need a reload,\n@@ -7333,7 +7371,7 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n   if ((REG_P (old) || GET_CODE (old) == SCRATCH)\n       && (note = find_reg_note (insn, REG_UNUSED, old)) != 0)\n     {\n-      XEXP (note, 0) = rl->reg_rtx;\n+      XEXP (note, 0) = reg_rtx;\n       return;\n     }\n   /* Likewise for a SUBREG of an operand that dies.  */\n@@ -7342,8 +7380,7 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n \t   && 0 != (note = find_reg_note (insn, REG_UNUSED,\n \t\t\t\t\t  SUBREG_REG (old))))\n     {\n-      XEXP (note, 0) = gen_lowpart_common (GET_MODE (old),\n-\t\t\t\t\t   rl->reg_rtx);\n+      XEXP (note, 0) = gen_lowpart_common (GET_MODE (old), reg_rtx);\n       return;\n     }\n   else if (GET_CODE (old) == SCRATCH)\n@@ -7357,22 +7394,20 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n   emit_output_reload_insns (chain, rld + j, j);\n }\n \n-/* Reload number R reloads from or to a group of hard registers starting at\n-   register REGNO.  Return true if it can be treated for inheritance purposes\n-   like a group of reloads, each one reloading a single hard register.\n-   The caller has already checked that the spill register and REGNO use\n-   the same number of registers to store the reload value.  */\n+/* A reload copies values of MODE from register SRC to register DEST.\n+   Return true if it can be treated for inheritance purposes like a\n+   group of reloads, each one reloading a single hard register.  The\n+   caller has already checked that (reg:MODE SRC) and (reg:MODE DEST)\n+   occupy the same number of hard registers.  */\n \n static bool\n-inherit_piecemeal_p (int r ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED)\n+inherit_piecemeal_p (int dest ATTRIBUTE_UNUSED,\n+\t\t     int src ATTRIBUTE_UNUSED,\n+\t\t     enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-  return (!REG_CANNOT_CHANGE_MODE_P (reload_spill_index[r],\n-\t\t\t\t     GET_MODE (rld[r].reg_rtx),\n-\t\t\t\t     reg_raw_mode[reload_spill_index[r]])\n-\t  && !REG_CANNOT_CHANGE_MODE_P (regno,\n-\t\t\t\t\tGET_MODE (rld[r].reg_rtx),\n-\t\t\t\t\treg_raw_mode[regno]));\n+  return (!REG_CANNOT_CHANGE_MODE_P (dest, mode, reg_raw_mode[dest])\n+\t  && !REG_CANNOT_CHANGE_MODE_P (src, mode, reg_raw_mode[src]));\n #else\n   return true;\n #endif\n@@ -7414,9 +7449,13 @@ emit_reload_insns (struct insn_chain *chain)\n \n   for (j = 0; j < n_reloads; j++)\n     {\n-      if (rld[j].reg_rtx\n-\t  && REGNO (rld[j].reg_rtx) < FIRST_PSEUDO_REGISTER)\n-\tnew_spill_reg_store[REGNO (rld[j].reg_rtx)] = 0;\n+      if (rld[j].reg_rtx && HARD_REGISTER_P (rld[j].reg_rtx))\n+\t{\n+\t  unsigned int i;\n+\n+\t  for (i = REGNO (rld[j].reg_rtx); i < END_REGNO (rld[j].reg_rtx); i++)\n+\t    new_spill_reg_store[i] = 0;\n+\t}\n \n       do_input_reload (chain, rld + j, j);\n       do_output_reload (chain, rld + j, j);\n@@ -7515,104 +7554,108 @@ emit_reload_insns (struct insn_chain *chain)\n \t{\n \t  int nr = hard_regno_nregs[i][GET_MODE (rld[r].reg_rtx)];\n \t  int k;\n-\t  int part_reaches_end = 0;\n-\t  int all_reaches_end = 1;\n \n \t  /* For a multi register reload, we need to check if all or part\n \t     of the value lives to the end.  */\n \t  for (k = 0; k < nr; k++)\n-\t    {\n-\t      if (reload_reg_reaches_end_p (i + k, rld[r].opnum,\n-\t\t\t\t\t    rld[r].when_needed))\n-\t\tpart_reaches_end = 1;\n-\t      else\n-\t\tall_reaches_end = 0;\n-\t    }\n+\t    if (reload_reg_reaches_end_p (i + k, rld[r].opnum,\n+\t\t\t\t\t  rld[r].when_needed))\n+\t      CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \n-\t  /* Ignore reloads that don't reach the end of the insn in\n-\t     entirety.  */\n-\t  if (all_reaches_end)\n-\t    {\n-\t      /* First, clear out memory of what used to be in this spill reg.\n-\t\t If consecutive registers are used, clear them all.  */\n-\n-\t      for (k = 0; k < nr; k++)\n-  \t        {\n-\t\tCLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n-  \t\t  CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, i + k);\n-  \t\t}\n-\n-\t      /* Maybe the spill reg contains a copy of reload_out.  */\n-\t      if (rld[r].out != 0\n-\t\t  && (REG_P (rld[r].out)\n+\t  /* Maybe the spill reg contains a copy of reload_out.  */\n+\t  if (rld[r].out != 0\n+\t      && (REG_P (rld[r].out)\n #ifdef AUTO_INC_DEC\n-\t\t      || ! rld[r].out_reg\n+\t\t  || ! rld[r].out_reg\n #endif\n-\t\t      || REG_P (rld[r].out_reg)))\n+\t\t  || REG_P (rld[r].out_reg)))\n+\t    {\n+\t      rtx reg;\n+\t      enum machine_mode mode;\n+\t      int regno, nregs;\n+\n+\t      reg = reload_reg_rtx_for_output[r];\n+\t      mode = GET_MODE (reg);\n+\t      regno = REGNO (reg);\n+\t      nregs = hard_regno_nregs[regno][mode];\n+\t      if (reload_regs_reach_end_p (regno, nregs, rld[r].opnum,\n+\t\t\t\t\t   rld[r].when_needed))\n \t\t{\n \t\t  rtx out = (REG_P (rld[r].out)\n \t\t\t     ? rld[r].out\n \t\t\t     : rld[r].out_reg\n \t\t\t     ? rld[r].out_reg\n /* AUTO_INC */\t\t     : XEXP (rld[r].in_reg, 0));\n-\t\t  int nregno = REGNO (out);\n-\t\t  int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t     : hard_regno_nregs[nregno]\n-\t\t\t\t\t       [GET_MODE (rld[r].reg_rtx)]);\n+\t\t  int out_regno = REGNO (out);\n+\t\t  int out_nregs = (!HARD_REGISTER_NUM_P (out_regno) ? 1\n+\t\t\t\t   : hard_regno_nregs[out_regno][mode]);\n \t\t  bool piecemeal;\n \n-\t\t  spill_reg_store[i] = new_spill_reg_store[i];\n-\t\t  spill_reg_stored_to[i] = out;\n-\t\t  reg_last_reload_reg[nregno] = rld[r].reg_rtx;\n+\t\t  spill_reg_store[regno] = new_spill_reg_store[regno];\n+\t\t  spill_reg_stored_to[regno] = out;\n+\t\t  reg_last_reload_reg[out_regno] = reg;\n \n-\t\t  piecemeal = (nregno < FIRST_PSEUDO_REGISTER\n-\t\t\t       && nr == nnr\n-\t\t\t       && inherit_piecemeal_p (r, nregno));\n+\t\t  piecemeal = (HARD_REGISTER_NUM_P (out_regno)\n+\t\t\t       && nregs == out_nregs\n+\t\t\t       && inherit_piecemeal_p (out_regno, regno, mode));\n \n-\t\t  /* If NREGNO is a hard register, it may occupy more than\n+\t\t  /* If OUT_REGNO is a hard register, it may occupy more than\n \t\t     one register.  If it does, say what is in the\n \t\t     rest of the registers assuming that both registers\n \t\t     agree on how many words the object takes.  If not,\n \t\t     invalidate the subsequent registers.  */\n \n-\t\t  if (nregno < FIRST_PSEUDO_REGISTER)\n-\t\t    for (k = 1; k < nnr; k++)\n-\t\t      reg_last_reload_reg[nregno + k]\n-\t\t\t= (piecemeal\n-\t\t\t   ? regno_reg_rtx[REGNO (rld[r].reg_rtx) + k]\n-\t\t\t   : 0);\n+\t\t  if (HARD_REGISTER_NUM_P (out_regno))\n+\t\t    for (k = 1; k < out_nregs; k++)\n+\t\t      reg_last_reload_reg[out_regno + k]\n+\t\t\t= (piecemeal ? regno_reg_rtx[regno + k] : 0);\n \n \t\t  /* Now do the inverse operation.  */\n-\t\t  for (k = 0; k < nr; k++)\n+\t\t  for (k = 0; k < nregs; k++)\n \t\t    {\n-\t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, i + k);\n-\t\t      reg_reloaded_contents[i + k]\n-\t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || !piecemeal\n-\t\t\t   ? nregno\n-\t\t\t   : nregno + k);\n-\t\t      reg_reloaded_insn[i + k] = insn;\n-\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, i + k);\n-\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (i + k, GET_MODE (out)))\n-\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered, i + k);\n+\t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, regno + k);\n+\t\t      reg_reloaded_contents[regno + k]\n+\t\t\t= (!HARD_REGISTER_NUM_P (out_regno) || !piecemeal\n+\t\t\t   ? out_regno\n+\t\t\t   : out_regno + k);\n+\t\t      reg_reloaded_insn[regno + k] = insn;\n+\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n+\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (regno + k, mode))\n+\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n+\t\t\t\t\t  regno + k);\n+\t\t      else\n+\t\t\tCLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n+\t\t\t\t\t    regno + k);\n \t\t    }\n \t\t}\n-\n-\t      /* Maybe the spill reg contains a copy of reload_in.  Only do\n-\t\t something if there will not be an output reload for\n-\t\t the register being reloaded.  */\n-\t      else if (rld[r].out_reg == 0\n-\t\t       && rld[r].in != 0\n-\t\t       && ((REG_P (rld[r].in)\n-\t\t\t    && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER\n-\t                    && !REGNO_REG_SET_P (&reg_has_output_reload,\n-\t\t\t      \t\t\t REGNO (rld[r].in)))\n-\t\t\t   || (REG_P (rld[r].in_reg)\n-\t\t\t       && !REGNO_REG_SET_P (&reg_has_output_reload,\n-\t\t\t\t\t\t    REGNO (rld[r].in_reg))))\n-\t\t       && ! reg_set_p (rld[r].reg_rtx, PATTERN (insn)))\n+\t    }\n+\t  /* Maybe the spill reg contains a copy of reload_in.  Only do\n+\t     something if there will not be an output reload for\n+\t     the register being reloaded.  */\n+\t  else if (rld[r].out_reg == 0\n+\t\t   && rld[r].in != 0\n+\t\t   && ((REG_P (rld[r].in)\n+\t\t\t&& !HARD_REGISTER_P (rld[r].in)\n+\t\t\t&& !REGNO_REG_SET_P (&reg_has_output_reload,\n+\t\t\t\t\t     REGNO (rld[r].in)))\n+\t\t       || (REG_P (rld[r].in_reg)\n+\t\t\t   && !REGNO_REG_SET_P (&reg_has_output_reload,\n+\t\t\t\t\t\tREGNO (rld[r].in_reg))))\n+\t\t   && !reg_set_p (reload_reg_rtx_for_input[r], PATTERN (insn)))\n+\t    {\n+\t      rtx reg;\n+\t      enum machine_mode mode;\n+\t      int regno, nregs;\n+\n+\t      reg = reload_reg_rtx_for_input[r];\n+\t      mode = GET_MODE (reg);\n+\t      regno = REGNO (reg);\n+\t      nregs = hard_regno_nregs[regno][mode];\n+\t      if (reload_regs_reach_end_p (regno, nregs, rld[r].opnum,\n+\t\t\t\t\t   rld[r].when_needed))\n \t\t{\n-\t\t  int nregno;\n-\t\t  int nnr;\n+\t\t  int in_regno;\n+\t\t  int in_nregs;\n \t\t  rtx in;\n \t\t  bool piecemeal;\n \n@@ -7623,58 +7666,48 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t    in = rld[r].in_reg;\n \t\t  else\n \t\t    in = XEXP (rld[r].in_reg, 0);\n-\t\t  nregno = REGNO (in);\n+\t\t  in_regno = REGNO (in);\n \n-\t\t  nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t : hard_regno_nregs[nregno]\n-\t\t\t\t\t   [GET_MODE (rld[r].reg_rtx)]);\n+\t\t  in_nregs = (!HARD_REGISTER_NUM_P (in_regno) ? 1\n+\t\t\t      : hard_regno_nregs[in_regno][mode]);\n \n-\t\t  reg_last_reload_reg[nregno] = rld[r].reg_rtx;\n+\t\t  reg_last_reload_reg[in_regno] = reg;\n \n-\t\t  piecemeal = (nregno < FIRST_PSEUDO_REGISTER\n-\t\t\t       && nr == nnr\n-\t\t\t       && inherit_piecemeal_p (r, nregno));\n+\t\t  piecemeal = (HARD_REGISTER_NUM_P (in_regno)\n+\t\t\t       && nregs == in_nregs\n+\t\t\t       && inherit_piecemeal_p (regno, in_regno, mode));\n \n-\t\t  if (nregno < FIRST_PSEUDO_REGISTER)\n-\t\t    for (k = 1; k < nnr; k++)\n-\t\t      reg_last_reload_reg[nregno + k]\n-\t\t\t= (piecemeal\n-\t\t\t   ? regno_reg_rtx[REGNO (rld[r].reg_rtx) + k]\n-\t\t\t   : 0);\n+\t\t  if (HARD_REGISTER_NUM_P (in_regno))\n+\t\t    for (k = 1; k < in_nregs; k++)\n+\t\t      reg_last_reload_reg[in_regno + k]\n+\t\t\t= (piecemeal ? regno_reg_rtx[regno + k] : 0);\n \n \t\t  /* Unless we inherited this reload, show we haven't\n \t\t     recently done a store.\n \t\t     Previous stores of inherited auto_inc expressions\n \t\t     also have to be discarded.  */\n \t\t  if (! reload_inherited[r]\n \t\t      || (rld[r].out && ! rld[r].out_reg))\n-\t\t    spill_reg_store[i] = 0;\n+\t\t    spill_reg_store[regno] = 0;\n \n-\t\t  for (k = 0; k < nr; k++)\n+\t\t  for (k = 0; k < nregs; k++)\n \t\t    {\n-\t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, i + k);\n-\t\t      reg_reloaded_contents[i + k]\n-\t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || !piecemeal\n-\t\t\t   ? nregno\n-\t\t\t   : nregno + k);\n-\t\t      reg_reloaded_insn[i + k] = insn;\n-\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, i + k);\n-\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (i + k, GET_MODE (in)))\n-\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered, i + k);\n+\t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, regno + k);\n+\t\t      reg_reloaded_contents[regno + k]\n+\t\t\t= (!HARD_REGISTER_NUM_P (in_regno) || !piecemeal\n+\t\t\t   ? in_regno\n+\t\t\t   : in_regno + k);\n+\t\t      reg_reloaded_insn[regno + k] = insn;\n+\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n+\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (regno + k, mode))\n+\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n+\t\t\t\t\t  regno + k);\n+\t\t      else\n+\t\t\tCLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n+\t\t\t\t\t    regno + k);\n \t\t    }\n \t\t}\n \t    }\n-\n-\t  /* However, if part of the reload reaches the end, then we must\n-\t     invalidate the old info for the part that survives to the end.  */\n-\t  else if (part_reaches_end)\n-\t    {\n-\t      for (k = 0; k < nr; k++)\n-\t\tif (reload_reg_reaches_end_p (i + k,\n-\t\t\t\t\t      rld[r].opnum,\n-\t\t\t\t\t      rld[r].when_needed))\n-\t\t  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n-\t    }\n \t}\n \n       /* The following if-statement was #if 0'd in 1.34 (or before...).\n@@ -7687,7 +7720,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t it thinks only about the original insn.  So invalidate it here.\n \t Also do the same thing for RELOAD_OTHER constraints where the\n \t output is discarded.  */\n-      if (i < 0 \n+      if (i < 0\n \t  && ((rld[r].out != 0\n \t       && (REG_P (rld[r].out)\n \t\t   || (MEM_P (rld[r].out)\n@@ -7697,7 +7730,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t{\n \t  rtx out = ((rld[r].out && REG_P (rld[r].out))\n \t\t     ? rld[r].out : rld[r].out_reg);\n-\t  int nregno = REGNO (out);\n+\t  int out_regno = REGNO (out);\n+\t  enum machine_mode mode = GET_MODE (out);\n \n \t  /* REG_RTX is now set or clobbered by the main instruction.\n \t     As the comment above explains, forget_old_reloads_1 only\n@@ -7715,16 +7749,16 @@ emit_reload_insns (struct insn_chain *chain)\n \t  if (rld[r].reg_rtx && rld[r].reg_rtx != out)\n \t    forget_old_reloads_1 (rld[r].reg_rtx, NULL_RTX, NULL);\n \n-\t  if (nregno >= FIRST_PSEUDO_REGISTER)\n+\t  if (!HARD_REGISTER_NUM_P (out_regno))\n \t    {\n \t      rtx src_reg, store_insn = NULL_RTX;\n \n-\t      reg_last_reload_reg[nregno] = 0;\n+\t      reg_last_reload_reg[out_regno] = 0;\n \n \t      /* If we can find a hard register that is stored, record\n \t\t the storing insn so that we may delete this insn with\n \t\t delete_output_reload.  */\n-\t      src_reg = rld[r].reg_rtx;\n+\t      src_reg = reload_reg_rtx_for_output[r];\n \n \t      /* If this is an optional reload, try to find the source reg\n \t\t from an input reload.  */\n@@ -7741,7 +7775,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t{\n \t\t\t  if (rld[k].in == src_reg)\n \t\t\t    {\n-\t\t\t      src_reg = rld[k].reg_rtx;\n+\t\t\t      src_reg = reload_reg_rtx_for_input[k];\n \t\t\t      break;\n \t\t\t    }\n \t\t\t}\n@@ -7752,47 +7786,54 @@ emit_reload_insns (struct insn_chain *chain)\n \t      if (src_reg && REG_P (src_reg)\n \t\t  && REGNO (src_reg) < FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  int src_regno = REGNO (src_reg);\n-\t\t  int nr = hard_regno_nregs[src_regno][rld[r].mode];\n+\t\t  int src_regno, src_nregs, k;\n+\t\t  rtx note;\n+\n+\t\t  gcc_assert (GET_MODE (src_reg) == mode);\n+\t\t  src_regno = REGNO (src_reg);\n+\t\t  src_nregs = hard_regno_nregs[src_regno][mode];\n \t\t  /* The place where to find a death note varies with\n \t\t     PRESERVE_DEATH_INFO_REGNO_P .  The condition is not\n \t\t     necessarily checked exactly in the code that moves\n \t\t     notes, so just check both locations.  */\n-\t\t  rtx note = find_regno_note (insn, REG_DEAD, src_regno);\n+\t\t  note = find_regno_note (insn, REG_DEAD, src_regno);\n \t\t  if (! note && store_insn)\n \t\t    note = find_regno_note (store_insn, REG_DEAD, src_regno);\n-\t\t  while (nr-- > 0)\n+\t\t  for (k = 0; k < src_nregs; k++)\n \t\t    {\n-\t\t      spill_reg_store[src_regno + nr] = store_insn;\n-\t\t      spill_reg_stored_to[src_regno + nr] = out;\n-\t\t      reg_reloaded_contents[src_regno + nr] = nregno;\n-\t\t      reg_reloaded_insn[src_regno + nr] = store_insn;\n-\t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, src_regno + nr);\n-\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, src_regno + nr);\n-\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (src_regno + nr, \n-\t\t\t\t\t\t\t  GET_MODE (src_reg)))\n+\t\t      spill_reg_store[src_regno + k] = store_insn;\n+\t\t      spill_reg_stored_to[src_regno + k] = out;\n+\t\t      reg_reloaded_contents[src_regno + k] = out_regno;\n+\t\t      reg_reloaded_insn[src_regno + k] = store_insn;\n+\t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, src_regno + k);\n+\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, src_regno + k);\n+\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (src_regno + k,\n+\t\t\t\t\t\t\t  mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered, \n-\t\t\t\t\t  src_regno + nr);\n-\t\t      SET_HARD_REG_BIT (reg_is_output_reload, src_regno + nr);\n+\t\t\t\t\t  src_regno + k);\n+\t\t      else\n+\t\t\tCLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n+\t\t\t\t\t    src_regno + k);\n+\t\t      SET_HARD_REG_BIT (reg_is_output_reload, src_regno + k);\n \t\t      if (note)\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_died, src_regno);\n \t\t      else\n \t\t\tCLEAR_HARD_REG_BIT (reg_reloaded_died, src_regno);\n \t\t    }\n-\t\t  reg_last_reload_reg[nregno] = src_reg;\n+\t\t  reg_last_reload_reg[out_regno] = src_reg;\n \t\t  /* We have to set reg_has_output_reload here, or else \n \t\t     forget_old_reloads_1 will clear reg_last_reload_reg\n \t\t     right away.  */\n \t\t  SET_REGNO_REG_SET (&reg_has_output_reload,\n-\t\t\t\t     nregno);\n+\t\t\t\t     out_regno);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      int num_regs = hard_regno_nregs[nregno][GET_MODE (out)];\n+\t      int k, out_nregs = hard_regno_nregs[out_regno][mode];\n \n-\t      while (num_regs-- > 0)\n-\t\treg_last_reload_reg[nregno + num_regs] = 0;\n+\t      for (k = 0; k < out_nregs; k++)\n+\t\treg_last_reload_reg[out_regno + k] = 0;\n \t    }\n \t}\n     }\n@@ -8075,10 +8116,11 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n    LAST_RELOAD_REG is the hard register number for which we want to delete\n    the last output reload.\n    J is the reload-number that originally used REG.  The caller has made\n-   certain that reload J doesn't use REG any longer for input.  */\n+   certain that reload J doesn't use REG any longer for input.\n+   NEW_RELOAD_REG is reload register that reload J is using for REG.  */\n \n static void\n-delete_output_reload (rtx insn, int j, int last_reload_reg)\n+delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n {\n   rtx output_reload_insn = spill_reg_store[last_reload_reg];\n   rtx reg = spill_reg_stored_to[last_reload_reg];\n@@ -8230,7 +8272,7 @@ delete_output_reload (rtx insn, int j, int last_reload_reg)\n \t}\n \n       /* For the debugging info, say the pseudo lives in this reload reg.  */\n-      reg_renumber[REGNO (reg)] = REGNO (rld[j].reg_rtx);\n+      reg_renumber[REGNO (reg)] = REGNO (new_reload_reg);\n       alter_reg (REGNO (reg), -1);\n     }\n   else"}, {"sha": "79c4693c6f550c9def63d0c38324ebdc555be521", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb959f7254cff4619b88ea6c636813cd1a13b0ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb959f7254cff4619b88ea6c636813cd1a13b0ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fb959f7254cff4619b88ea6c636813cd1a13b0ba", "patch": "@@ -1,3 +1,8 @@\n+2008-03-25  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR rtl-optimization/35232\n+\t* gcc.target/mips/pr35232.c: New test.\n+\n 2008-03-25  Douglas Gregor  <doug.gregor@gmail.com>\n \n        * g++.dg/template/sfinae4.C: New."}, {"sha": "c0e0649b52ea645d04e4cecb9f9ee6354b417b7e", "filename": "gcc/testsuite/gcc.target/mips/pr35232.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb959f7254cff4619b88ea6c636813cd1a13b0ba/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr35232.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb959f7254cff4619b88ea6c636813cd1a13b0ba/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr35232.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr35232.c?ref=fb959f7254cff4619b88ea6c636813cd1a13b0ba", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do run } */\n+/* { dg-mips-options \"-O\" } */\n+\n+NOMIPS16 unsigned int\n+f1 (unsigned long long x)\n+{\n+  unsigned int r;\n+  asm (\"# %0\" : \"=a\" (r) : \"0\" (x));\n+  asm (\"# %0\" : \"=h\" (r) : \"0\" (r));\n+  return r;\n+}\n+\n+int\n+main (void)\n+{\n+  return f1 (4) != 4;\n+}"}]}