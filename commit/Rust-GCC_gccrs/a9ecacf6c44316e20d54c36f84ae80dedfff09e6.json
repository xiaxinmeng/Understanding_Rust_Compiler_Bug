{"sha": "a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTllY2FjZjZjNDQzMTZlMjBkNTRjMzZmODRhZTgwZGVkZmZmMDllNg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@act-europe.fr", "date": "2003-04-16T21:33:19Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-04-16T21:33:19Z"}, "message": "tree.c (skip_simple_arithmetics_at, [...]): New functions.\n\n        * tree.c (skip_simple_arithmetics_at, saved_expr_p): New functions.\n        (save_expr): Replace loop by call to skip_simple_arithmetics_at.\n        * tree.h: Add prototypes for the two new functions.\n        * fold-const.c (fold_binary_op_with_conditional_arg): Replace test\n        updates introduced in the previous revision by call to saved_expr_p.\n        * stor-layout.c (put_pending_size): Use skip_simple_arithmetics_at.\n\nFrom-SVN: r65702", "tree": {"sha": "d54db0fbb9e85319256be0471da62b0bf8117eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d54db0fbb9e85319256be0471da62b0bf8117eb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/comments", "author": null, "committer": null, "parents": [{"sha": "15b19a7dbf433b1936eecd042ce7dedbb23220f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b19a7dbf433b1936eecd042ce7dedbb23220f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b19a7dbf433b1936eecd042ce7dedbb23220f9"}], "stats": {"total": 132, "additions": 83, "deletions": 49}, "files": [{"sha": "19fdf5af8fcdf030e718d8c93475727de27009f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "patch": "@@ -1,5 +1,12 @@\n 2003-04-16  Olivier Hainque <hainque@act-europe.fr>\n \n+        * tree.c (skip_simple_arithmetics_at, saved_expr_p): New functions.\n+        (save_expr): Replace loop by call to skip_simple_arithmetics_at.\n+        * tree.h: Add prototypes for the two new functions.\n+        * fold-const.c (fold_binary_op_with_conditional_arg): Replace test\n+        updates introduced in the previous revision by call to saved_expr_p.\n+        * stor-layout.c (put_pending_size): Use skip_simple_arithmetics_at.\n+\n         * expr.c (store_field): Force usage of bitfield instructions when\n         the field position requires it, whatever SLOW_UNALIGNED_ACCESS.\n         (expand_expr, case BIT_FIELD_REF): likewise."}, {"sha": "fa64fd2b956bb707b6404bbbe34444c5a07f4fd3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "patch": "@@ -4568,21 +4568,19 @@ fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n       false_value = convert (testtype, integer_zero_node);\n     }\n \n-  /* If ARG is complex we want to make sure we only evaluate\n-     it once.  Though this is only required if it is volatile, it\n-     might be more efficient even if it is not.  However, if we\n-     succeed in folding one part to a constant, we do not need\n-     to make this SAVE_EXPR.  Since we do this optimization\n-     primarily to see if we do end up with constant and this\n-     SAVE_EXPR interferes with later optimizations, suppressing\n-     it when we can is important.\n-\n-     If we are not in a function, we can't make a SAVE_EXPR, so don't\n-     try to do so.  Don't try to see if the result is a constant\n-     if an arm is a COND_EXPR since we get exponential behavior\n-     in that case.  */\n-\n-  if (TREE_CODE (arg) == SAVE_EXPR)\n+  /* If ARG is complex we want to make sure we only evaluate it once.  Though\n+     this is only required if it is volatile, it might be more efficient even\n+     if it is not.  However, if we succeed in folding one part to a constant,\n+     we do not need to make this SAVE_EXPR.  Since we do this optimization\n+     primarily to see if we do end up with constant and this SAVE_EXPR\n+     interferes with later optimizations, suppressing it when we can is\n+     important.\n+\n+     If we are not in a function, we can't make a SAVE_EXPR, so don't try to\n+     do so.  Don't try to see if the result is a constant if an arm is a\n+     COND_EXPR since we get exponential behavior in that case.  */\n+\n+  if (saved_expr_p (arg))\n     save = 1;\n   else if (lhs == 0 && rhs == 0\n \t   && !TREE_CONSTANT (arg)"}, {"sha": "66067d6f276e140e6f43dba1ca1be9a95ddea08f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "patch": "@@ -128,10 +128,7 @@ put_pending_size (expr)\n {\n   /* Strip any simple arithmetic from EXPR to see if it has an underlying\n      SAVE_EXPR.  */\n-  while (TREE_CODE_CLASS (TREE_CODE (expr)) == '1'\n-\t || (TREE_CODE_CLASS (TREE_CODE (expr)) == '2'\n-\t    && TREE_CONSTANT (TREE_OPERAND (expr, 1))))\n-    expr = TREE_OPERAND (expr, 0);\n+  expr = skip_simple_arithmetic (expr);\n \n   if (TREE_CODE (expr) == SAVE_EXPR)\n     pending_sizes = tree_cons (NULL_TREE, expr, pending_sizes);"}, {"sha": "ce5e21997b13b28081cbdddff2f15f17ecd7ac8b", "filename": "gcc/tree.c", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "patch": "@@ -1379,34 +1379,7 @@ save_expr (expr)\n      tree expr;\n {\n   tree t = fold (expr);\n-  tree inner;\n-\n-  /* We don't care about whether this can be used as an lvalue in this\n-     context.  */\n-  while (TREE_CODE (t) == NON_LVALUE_EXPR)\n-    t = TREE_OPERAND (t, 0);\n-\n-  /* If we have simple operations applied to a SAVE_EXPR or to a SAVE_EXPR and\n-     a constant, it will be more efficient to not make another SAVE_EXPR since\n-     it will allow better simplification and GCSE will be able to merge the\n-     computations if they actually occur.  */\n-  inner = t;\n-  while (1)\n-    {\n-      if (TREE_CODE_CLASS (TREE_CODE (inner)) == '1')\n-\tinner = TREE_OPERAND (inner, 0);\n-      else if (TREE_CODE_CLASS (TREE_CODE (inner)) == '2')\n-\t{\n-\t  if (TREE_CONSTANT (TREE_OPERAND (inner, 1)))\n-\t    inner = TREE_OPERAND (inner, 0);\n-\t  else if (TREE_CONSTANT (TREE_OPERAND (inner, 0)))\n-\t    inner = TREE_OPERAND (inner, 1);\n-\t  else\n-\t    break;\n-\t}\n-      else\n-\tbreak;\n-    }\n+  tree inner = skip_simple_arithmetic (t);\n \n   /* If the tree evaluates to a constant, then we don't want to hide that\n      fact (i.e. this allows further folding, and direct checks for constants).\n@@ -1419,7 +1392,7 @@ save_expr (expr)\n       || TREE_CODE (inner) == ERROR_MARK)\n     return t;\n \n-  /* If T contains a PLACEHOLDER_EXPR, we must evaluate it each time, since\n+  /* If INNER contains a PLACEHOLDER_EXPR, we must evaluate it each time, since\n      it means that the size or offset of some field of an object depends on\n      the value within another field.\n \n@@ -1428,7 +1401,7 @@ save_expr (expr)\n      evaluated more than once.  Front-ends must assure this case cannot\n      happen by surrounding any such subexpressions in their own SAVE_EXPR\n      and forcing evaluation at the proper time.  */\n-  if (contains_placeholder_p (t))\n+  if (contains_placeholder_p (inner))\n     return t;\n \n   t = build (SAVE_EXPR, TREE_TYPE (expr), t, current_function_decl, NULL_TREE);\n@@ -1441,6 +1414,55 @@ save_expr (expr)\n   return t;\n }\n \n+/* Look inside EXPR and into any simple arithmetic operations.  Return\n+   the innermost non-arithmetic node.  */\n+\n+tree\n+skip_simple_arithmetic (expr)\n+     tree expr;\n+{\n+  tree inner;\n+  \n+  /* We don't care about whether this can be used as an lvalue in this\n+     context.  */\n+  while (TREE_CODE (expr) == NON_LVALUE_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  /* If we have simple operations applied to a SAVE_EXPR or to a SAVE_EXPR and\n+     a constant, it will be more efficient to not make another SAVE_EXPR since\n+     it will allow better simplification and GCSE will be able to merge the\n+     computations if they actually occur.  */\n+  inner = expr;\n+  while (1)\n+    {\n+      if (TREE_CODE_CLASS (TREE_CODE (inner)) == '1')\n+\tinner = TREE_OPERAND (inner, 0);\n+      else if (TREE_CODE_CLASS (TREE_CODE (inner)) == '2')\n+\t{\n+\t  if (TREE_CONSTANT (TREE_OPERAND (inner, 1)))\n+\t    inner = TREE_OPERAND (inner, 0);\n+\t  else if (TREE_CONSTANT (TREE_OPERAND (inner, 0)))\n+\t    inner = TREE_OPERAND (inner, 1);\n+\t  else\n+\t    break;\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  return inner;\n+}\n+\n+/* Return TRUE if EXPR is a SAVE_EXPR or wraps simple arithmetic around a\n+   SAVE_EXPR.  Return FALSE otherwise.  */\n+\n+bool\n+saved_expr_p (expr)\n+     tree expr;\n+{\n+  return TREE_CODE (skip_simple_arithmetic (expr)) == SAVE_EXPR;\n+}\n+\n /* Arrange for an expression to be expanded multiple independent\n    times.  This is useful for cleanup actions, as the backend can\n    expand them multiple times in different places.  */"}, {"sha": "44ccd45178458c039ed8915cb7f7f7d00b0ae9db", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ecacf6c44316e20d54c36f84ae80dedfff09e6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a9ecacf6c44316e20d54c36f84ae80dedfff09e6", "patch": "@@ -2681,6 +2681,16 @@ extern int lvalue_or_else\t\tPARAMS ((tree, const char *));\n \n extern tree save_expr\t\t\tPARAMS ((tree));\n \n+/* Look inside EXPR and into any simple arithmetic operations.  Return\n+   the innermost non-arithmetic node.  */\n+\n+extern tree skip_simple_arithmetic\tPARAMS ((tree));\n+\n+/* Return TRUE if EXPR is a SAVE_EXPR or wraps simple arithmetic around a\n+   SAVE_EXPR.  Return FALSE otherwise.  */\n+\n+extern bool saved_expr_p                PARAMS ((tree));\n+\n /* Returns the index of the first non-tree operand for CODE, or the number\n    of operands if all are trees.  */\n "}]}