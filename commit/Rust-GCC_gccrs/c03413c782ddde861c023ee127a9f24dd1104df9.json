{"sha": "c03413c782ddde861c023ee127a9f24dd1104df9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAzNDEzYzc4MmRkZGU4NjFjMDIzZWUxMjdhOWYyNGRkMTEwNGRmOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-12-08T19:13:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-12-08T19:13:25Z"}, "message": "(char_name): New var.\n\n(initialize_char_syntax): Initialize it.\n(handle_directive): Use it to simplify printing of diagnostics.\nWarn about '\\r' too.\n(create_definition, do_pragma, do_endif, make_assertion): Be consistent\nabout skipping all horizontal white space, not just space and tab.\n\nFrom-SVN: r8627", "tree": {"sha": "d465c48583fc34795d2f0558d47b2e07a2b831aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d465c48583fc34795d2f0558d47b2e07a2b831aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c03413c782ddde861c023ee127a9f24dd1104df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c03413c782ddde861c023ee127a9f24dd1104df9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c03413c782ddde861c023ee127a9f24dd1104df9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c03413c782ddde861c023ee127a9f24dd1104df9/comments", "author": null, "committer": null, "parents": [{"sha": "bced43dd6ca22ea9d76ed6b5cd75e2f8f6af4972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bced43dd6ca22ea9d76ed6b5cd75e2f8f6af4972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bced43dd6ca22ea9d76ed6b5cd75e2f8f6af4972"}], "stats": {"total": 53, "additions": 23, "deletions": 30}, "files": [{"sha": "fa6d363dea557a84af4a9fe2c0702afbd90a0494", "filename": "gcc/cccp.c", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c03413c782ddde861c023ee127a9f24dd1104df9/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c03413c782ddde861c023ee127a9f24dd1104df9/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=c03413c782ddde861c023ee127a9f24dd1104df9", "patch": "@@ -966,6 +966,8 @@ U_CHAR is_idstart[256];\n U_CHAR is_hor_space[256];\n /* table to tell if c is horizontal or vertical space.  */\n static U_CHAR is_space[256];\n+/* names of some characters */\n+static char *char_name[256];\n \n #define SKIP_WHITE_SPACE(p) do { while (is_hor_space[*p]) p++; } while (0)\n #define SKIP_ALL_WHITE_SPACE(p) do { while (is_space[*p]) p++; } while (0)\n@@ -3469,9 +3471,8 @@ handle_directive (ip, op)\n   /* Skip whitespace and \\-newline.  */\n   while (1) {\n     if (is_hor_space[*bp]) {\n-      if ((*bp == '\\f' || *bp == '\\v') && pedantic)\n-\tpedwarn (\"%s in preprocessing directive\",\n-\t\t *bp == '\\f' ? \"formfeed\" : \"vertical tab\");\n+      if (*bp != ' ' && *bp != '\\t' && pedantic)\n+\tpedwarn (\"%s in preprocessing directive\", char_name[*bp]);\n       bp++;\n     } else if (*bp == '/' && (bp[1] == '*'\n \t\t\t      || (cplusplus_comments && bp[1] == '/'))) {\n@@ -3644,10 +3645,10 @@ handle_directive (ip, op)\n \t  break;\n \n \tcase '\\f':\n+\tcase '\\r':\n \tcase '\\v':\n \t  if (pedantic)\n-\t    pedwarn (\"%s in preprocessing directive\",\n-\t\t     c == '\\f' ? \"formfeed\" : \"vertical tab\");\n+\t    pedwarn (\"%s in preprocessing directive\", char_name[c]);\n \t  break;\n \n \tcase '\\n':\n@@ -5403,9 +5404,7 @@ create_definition (buf, limit, op)\n     }\n \n     ++bp;\t\t\t/* skip paren */\n-    /* Skip spaces and tabs if any.  */\n-    while (bp < limit && (*bp == ' ' || *bp == '\\t'))\n-      ++bp;\n+    SKIP_WHITE_SPACE (bp);\n     /* now everything from bp before limit is the definition. */\n     defn = collect_expansion (bp, limit, argno, arg_ptrs);\n     defn->rest_args = rest_args;\n@@ -5432,14 +5431,11 @@ create_definition (buf, limit, op)\n \n     if (bp < limit)\n       {\n-\tswitch (*bp)\n-\t  {\n-\t    case '\\t': case ' ': case '\\r':\n-\t      /* Skip spaces and tabs.  */\n-\t      while (++bp < limit && (*bp == ' ' || *bp == '\\t' || *bp == '\\r'))\n-\t\tcontinue;\n-\t      break;\n-\n+\tif (is_hor_space[*bp]) {\n+\t  bp++;\n+\t  SKIP_WHITE_SPACE (bp);\n+\t} else {\n+\t  switch (*bp) {\n \t    case '!':  case '\"':  case '#':  case '%':  case '&':  case '\\'':\n \t    case ')':  case '*':  case '+':  case ',':  case '-':  case '.':\n \t    case '/':  case ':':  case ';':  case '<':  case '=':  case '>':\n@@ -5454,6 +5450,7 @@ create_definition (buf, limit, op)\n \t\t       sym_length, symname);\n \t      break;\n \t  }\n+\t}\n       }\n     /* Now everything from bp before limit is the definition. */\n     defn = collect_expansion (bp, limit, -1, NULL_PTR);\n@@ -6640,8 +6637,7 @@ static int\n do_pragma (buf, limit)\n      U_CHAR *buf, *limit;\n {\n-  while (*buf == ' ' || *buf == '\\t')\n-    buf++;\n+  SKIP_WHITE_SPACE (buf);\n   if (!strncmp (buf, \"once\", 4)) {\n     /* Allow #pragma once in system headers, since that's not the user's\n        fault.  */\n@@ -7271,23 +7267,16 @@ do_endif (buf, limit, op, keyword)\n \n       while (p != ep) {\n \tU_CHAR c = *p++;\n-\tswitch (c) {\n-\tcase ' ':\n-\tcase '\\t':\n-\tcase '\\n':\n-\t  break;\n-\tcase '/':\n-\t  if (p != ep && *p == '*') {\n+\tif (!is_space[c]) {\n+\t  if (c == '/' && p != ep && *p == '*') {\n \t    /* Skip this comment.  */\n \t    int junk = 0;\n \t    U_CHAR *save_bufp = ip->bufp;\n \t    ip->bufp = p + 1;\n \t    p = skip_to_end_of_comment (ip, &junk, 1);\n \t    ip->bufp = save_bufp;\n-\t  }\n-\t  break;\n-\tdefault:\n-\t  goto fail;\n+\t  } else\n+\t    goto fail;\n \t}\n       }\n       /* If we get here, this #endif ends a #ifndef\n@@ -9169,6 +9158,10 @@ initialize_char_syntax ()\n   is_space['\\f'] = 1;\n   is_space['\\n'] = 1;\n   is_space['\\r'] = 1;\n+\n+  char_name['\\v'] = \"vertical tab\";\n+  char_name['\\f'] = \"formfeed\";\n+  char_name['\\r'] = \"carriage return\";\n }\n \n /* Initialize the built-in macros.  */\n@@ -9414,7 +9407,7 @@ make_assertion (option, str)\n   }\n   while (is_idchar[*++p])\n     ;\n-  while (*p == ' ' || *p == '\\t') p++;\n+  SKIP_WHITE_SPACE (p);\n   if (! (*p == 0 || *p == '(')) {\n     error (\"malformed option `%s %s'\", option, str);\n     return;"}]}