{"sha": "1312c143f8f7a87b44e0536d66364bd9216ff5a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMxMmMxNDNmOGY3YTg3YjQ0ZTA1MzZkNjYzNjRiZDkyMTZmZjVhNA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-01-13T23:30:02Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-01-13T23:30:02Z"}, "message": "c-common.c: Move format checking code to ...\n\n\t* c-common.c: Move format checking code to ...\n\t* c-format.c: ... here.  New file.  Reorder some functions and\n\tdeclarations.\n\t(decl_handle_format_attribute, decl_handle_format_arg_attribute):\n\tNew functions.\n\t* c-common.h (decl_handle_format_attribute,\n\tdecl_handle_format_arg_attribute): Declare.\n\t* Makefile.in (C_AND_OBJC_OBJS): Add c-format.o.\n\t(c-common.o): Adjust dependencies.\n\t(c-format.o): New list of dependencies.\n\ncp:\n\t* Make-lang.in (CXX_C_OBJS): Add c-format.o.\n\nFrom-SVN: r38998", "tree": {"sha": "ce98ecc92b90fd99c0d66480bbe34c393cb5a611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce98ecc92b90fd99c0d66480bbe34c393cb5a611"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1312c143f8f7a87b44e0536d66364bd9216ff5a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1312c143f8f7a87b44e0536d66364bd9216ff5a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1312c143f8f7a87b44e0536d66364bd9216ff5a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1312c143f8f7a87b44e0536d66364bd9216ff5a4/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f6684e69928cbedf89f63fbe90a09c31e9dd6aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f6684e69928cbedf89f63fbe90a09c31e9dd6aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f6684e69928cbedf89f63fbe90a09c31e9dd6aa"}], "stats": {"total": 4994, "additions": 2537, "deletions": 2457}, "files": [{"sha": "d8a1822de5d459a3fc29a9a32fa8495bb8831dce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1312c143f8f7a87b44e0536d66364bd9216ff5a4", "patch": "@@ -1,3 +1,16 @@\n+2001-01-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c: Move format checking code to ...\n+\t* c-format.c: ... here.  New file.  Reorder some functions and\n+\tdeclarations.\n+\t(decl_handle_format_attribute, decl_handle_format_arg_attribute):\n+\tNew functions.\n+\t* c-common.h (decl_handle_format_attribute,\n+\tdecl_handle_format_arg_attribute): Declare.\n+\t* Makefile.in (C_AND_OBJC_OBJS): Add c-format.o.\n+\t(c-common.o): Adjust dependencies.\n+\t(c-format.o): New list of dependencies.\n+\n 2001-01-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* unroll.c (loop_iterations): If we cannot prove iteration variable"}, {"sha": "0091585ae254c222df74774fe30d2c963b855834", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1312c143f8f7a87b44e0536d66364bd9216ff5a4", "patch": "@@ -725,8 +725,8 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n \n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n-  c-convert.o c-aux-info.o c-common.o c-semantics.o c-dump.o libcpp.a \\\n-  $(C_TARGET_OBJS)\n+  c-convert.o c-aux-info.o c-common.o c-format.o c-semantics.o c-dump.o \\\n+  libcpp.a $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n@@ -1230,7 +1230,10 @@ s-under: $(GCC_PASSES)\n \n c-common.o : c-common.c $(CONFIG_H) system.h $(TREE_H) $(OBSTACK_H) \\\n \t$(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n-\t$(EXPR_H) diagnostic.h\n+\t$(EXPR_H)\n+\n+c-format.o : c-format.c $(CONFIG_H) system.h $(TREE_H) \\\n+\t$(C_COMMON_H) flags.h toplev.h intl.h diagnostic.h\n \n c-semantics.o : c-semantics.c $(CONFIG_H) system.h $(TREE_H) $(C_TREE_H) \\\n \tc-lex.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\"}, {"sha": "14b77d12e9a49da1b40a2a66838af81aa3c46327", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 2453, "changes": 2457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=1312c143f8f7a87b44e0536d66364bd9216ff5a4", "patch": "@@ -32,8 +32,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-common.h\"\n #include \"defaults.h\"\n #include \"tm_p.h\"\n-#include \"intl.h\"\n-#include \"diagnostic.h\"\n #include \"obstack.h\"\n #include \"cpplib.h\"\n cpp_reader *parse_in;\t\t/* Declared in c-lex.h.  */\n@@ -199,26 +197,6 @@ int flag_short_wchar;\n \n const char *flag_dump_translation_unit;\n \n-/* Warn about *printf or *scanf format/argument anomalies. */\n-\n-int warn_format;\n-\n-/* Warn about Y2K problems with strftime formats.  */\n-\n-int warn_format_y2k;\n-\n-/* Warn about excess arguments to formats.  */\n-\n-int warn_format_extra_args;\n-\n-/* Warn about non-literal format arguments.  */\n-\n-int warn_format_nonliteral;\n-\n-/* Warn about possible security problems with calls to format functions.  */\n-\n-int warn_format_security;\n-\n /* Nonzero means warn about possible violations of sequence point rules.  */\n \n int warn_sequence_point;\n@@ -251,19 +229,9 @@ enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n \t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS, A_MALLOC,\n \t    A_NO_LIMIT_STACK, A_PURE};\n \n-/* This must be in the same order as format_types, with format_type_error\n-   last.  */\n-enum format_type { printf_format_type, scanf_format_type,\n-\t\t   strftime_format_type, strfmon_format_type,\n-\t\t   format_type_error };\n-\n static void add_attribute\t\tPARAMS ((enum attrs, const char *,\n \t\t\t\t\t\t int, int, int));\n static void init_attributes\t\tPARAMS ((void));\n-static enum format_type decode_format_type\tPARAMS ((const char *));\n-static void record_function_format\tPARAMS ((tree, tree, enum format_type,\n-\t\t\t\t\t\t int, int));\n-static void record_international_format\tPARAMS ((tree, tree, int));\n static int default_valid_lang_attribute PARAMS ((tree, tree, tree, tree));\n \n /* Keep a stack of if statements.  We record the number of compound\n@@ -948,179 +916,12 @@ decl_attributes (node, attributes, prefix_attributes)\n \t  break;\n \n \tcase A_FORMAT:\n-\t  {\n-\t    tree format_type_id = TREE_VALUE (args);\n-\t    tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n-\t    tree first_arg_num_expr\n-\t      = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n-\t    unsigned HOST_WIDE_INT format_num, first_arg_num;\n-\t    enum format_type format_type;\n-\t    tree argument;\n-\t    unsigned int arg_num;\n-\n-\t    if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t      {\n-\t\terror_with_decl (decl,\n-\t\t\t \"argument format specified for non-function `%s'\");\n-\t\tcontinue;\n-\t      }\n-\n-\t    if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n-\t      {\n-\t\terror (\"unrecognized format specifier\");\n-\t\tcontinue;\n-\t      }\n-\t    else\n-\t      {\n-\t\tconst char *p = IDENTIFIER_POINTER (format_type_id);\n-\n-\t\tformat_type = decode_format_type (p);\n-\n-\t\tif (format_type == format_type_error)\n-\t\t  {\n-\t\t    warning (\"`%s' is an unrecognized format function type\", p);\n-\t\t    continue;\n-\t\t  }\n-\t      }\n-\n-\t    /* Strip any conversions from the string index and first arg number\n-\t       and verify they are constants.  */\n-\t    while (TREE_CODE (format_num_expr) == NOP_EXPR\n-\t\t   || TREE_CODE (format_num_expr) == CONVERT_EXPR\n-\t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n-\t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n-\n-\t    while (TREE_CODE (first_arg_num_expr) == NOP_EXPR\n-\t\t   || TREE_CODE (first_arg_num_expr) == CONVERT_EXPR\n-\t\t   || TREE_CODE (first_arg_num_expr) == NON_LVALUE_EXPR)\n-\t      first_arg_num_expr = TREE_OPERAND (first_arg_num_expr, 0);\n-\n-\t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n-\t\t|| TREE_INT_CST_HIGH (format_num_expr) != 0\n-\t\t|| TREE_CODE (first_arg_num_expr) != INTEGER_CST\n-\t\t|| TREE_INT_CST_HIGH (first_arg_num_expr) != 0)\n-\t      {\n-\t\terror (\"format string has invalid operand number\");\n-\t\tcontinue;\n-\t      }\n-\n-\t    format_num = TREE_INT_CST_LOW (format_num_expr);\n-\t    first_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);\n-\t    if (first_arg_num != 0 && first_arg_num <= format_num)\n-\t      {\n-\t\terror (\"format string arg follows the args to be formatted\");\n-\t\tcontinue;\n-\t      }\n-\n-\t    /* If a parameter list is specified, verify that the format_num\n-\t       argument is actually a string, in case the format attribute\n-\t       is in error.  */\n-\t    argument = TYPE_ARG_TYPES (type);\n-\t    if (argument)\n-\t      {\n-\t\tfor (arg_num = 1; argument != 0 && arg_num != format_num;\n-\t\t     ++arg_num, argument = TREE_CHAIN (argument))\n-\t\t  ;\n-\n-\t\tif (! argument\n-\t\t    || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n-\t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n-\t\t      != char_type_node))\n-\t\t  {\n-\t\t    error (\"format string arg not a string type\");\n-\t\t    continue;\n-\t\t  }\n-\n-\t\telse if (first_arg_num != 0)\n-\t\t  {\n-\t\t    /* Verify that first_arg_num points to the last arg,\n-\t\t       the ...  */\n-\t\t    while (argument)\n-\t\t      arg_num++, argument = TREE_CHAIN (argument);\n-\n-\t\t    if (arg_num != first_arg_num)\n-\t\t      {\n-\t\t\terror (\"args to be formatted is not '...'\");\n-\t\t\tcontinue;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\n-\t    if (format_type == strftime_format_type && first_arg_num != 0)\n-\t      {\n-\t\terror (\"strftime formats cannot format arguments\");\n-\t\tcontinue;\n-\t      }\n-\n-\t    record_function_format (DECL_NAME (decl),\n-\t\t\t\t    DECL_ASSEMBLER_NAME (decl),\n-\t\t\t\t    format_type, format_num, first_arg_num);\n-\t    break;\n-\t  }\n+\t  decl_handle_format_attribute (decl, args);\n+\t  break;\n \n \tcase A_FORMAT_ARG:\n-\t  {\n-\t    tree format_num_expr = TREE_VALUE (args);\n-\t    unsigned HOST_WIDE_INT format_num;\n-\t    unsigned int arg_num;\n-\t    tree argument;\n-\n-\t    if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t      {\n-\t\terror_with_decl (decl,\n-\t\t\t \"argument format specified for non-function `%s'\");\n-\t\tcontinue;\n-\t      }\n-\n-\t    /* Strip any conversions from the first arg number and verify it\n-\t       is a constant.  */\n-\t    while (TREE_CODE (format_num_expr) == NOP_EXPR\n-\t\t   || TREE_CODE (format_num_expr) == CONVERT_EXPR\n-\t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n-\t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n-\n-\t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n-\t\t|| TREE_INT_CST_HIGH (format_num_expr) != 0)\n-\t      {\n-\t\terror (\"format string has invalid operand number\");\n-\t\tcontinue;\n-\t      }\n-\n-\t    format_num = TREE_INT_CST_LOW (format_num_expr);\n-\n-\t    /* If a parameter list is specified, verify that the format_num\n-\t       argument is actually a string, in case the format attribute\n-\t       is in error.  */\n-\t    argument = TYPE_ARG_TYPES (type);\n-\t    if (argument)\n-\t      {\n-\t\tfor (arg_num = 1; argument != 0 && arg_num != format_num;\n-\t\t     ++arg_num, argument = TREE_CHAIN (argument))\n-\t\t  ;\n-\n-\t\tif (! argument\n-\t\t    || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n-\t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n-\t\t      != char_type_node))\n-\t\t  {\n-\t\t    error (\"format string arg not a string type\");\n-\t\t    continue;\n-\t\t  }\n-\t      }\n-\n-\t    if (TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) != POINTER_TYPE\n-\t\t|| (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (TREE_TYPE (decl))))\n-\t\t    != char_type_node))\n-\t      {\n-\t\terror (\"function does not return string type\");\n-\t\tcontinue;\n-\t      }\n-\n-\t    record_international_format (DECL_NAME (decl),\n-\t\t\t\t\t DECL_ASSEMBLER_NAME (decl),\n-\t\t\t\t\t format_num);\n-\t    break;\n-\t  }\n+\t  decl_handle_format_arg_attribute (decl, args);\n+\t  break;\n \n \tcase A_WEAK:\n \t  declare_weak (decl);\n@@ -1312,2262 +1113,12 @@ strip_attrs (specs_attrs)\n   return specs;\n }\n \f\n-/* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against\n-   a parameter list.  */\n-\n-/* The meaningfully distinct length modifiers for format checking recognised\n-   by GCC.  */\n-enum format_lengths\n-{\n-  FMT_LEN_none,\n-  FMT_LEN_hh,\n-  FMT_LEN_h,\n-  FMT_LEN_l,\n-  FMT_LEN_ll,\n-  FMT_LEN_L,\n-  FMT_LEN_z,\n-  FMT_LEN_t,\n-  FMT_LEN_j,\n-  FMT_LEN_MAX\n-};\n-\n-\n-/* The standard versions in which various format features appeared.  */\n-enum format_std_version\n-{\n-  STD_C89,\n-  STD_C94,\n-  STD_C9L, /* C99, but treat as C89 if -Wno-long-long.  */\n-  STD_C99,\n-  STD_EXT\n-};\n-\n-/* The C standard version C++ is treated as equivalent to\n-   or inheriting from, for the purpose of format features supported.  */\n-#define CPLUSPLUS_STD_VER\tSTD_C89\n-/* The C standard version we are checking formats against when pedantic.  */\n-#define C_STD_VER\t\t(c_language == clk_cplusplus\t\t  \\\n-\t\t\t\t ? CPLUSPLUS_STD_VER\t\t\t  \\\n-\t\t\t\t : (flag_isoc99\t\t\t\t  \\\n-\t\t\t\t    ? STD_C99\t\t\t\t  \\\n-\t\t\t\t    : (flag_isoc94 ? STD_C94 : STD_C89)))\n-/* The name to give to the standard version we are warning about when\n-   pedantic.  FEATURE_VER is the version in which the feature warned out\n-   appeared, which is higher than C_STD_VER.  */\n-#define C_STD_NAME(FEATURE_VER) (c_language == clk_cplusplus\t\\\n-\t\t\t\t ? \"ISO C++\"\t\t\t\\\n-\t\t\t\t : ((FEATURE_VER) == STD_EXT\t\\\n-\t\t\t\t    ? \"ISO C\"\t\t\t\\\n-\t\t\t\t    : \"ISO C89\"))\n-/* Adjust a C standard version, which may be STD_C9L, to account for\n-   -Wno-long-long.  Returns other standard versions unchanged.  */\n-#define ADJ_STD(VER)\t\t((int)((VER) == STD_C9L\t\t\t      \\\n-\t\t\t\t       ? (warn_long_long ? STD_C99 : STD_C89) \\\n-\t\t\t\t       : (VER)))\n-\n-/* Flags that may apply to a particular kind of format checked by GCC.  */\n-enum\n-{\n-  /* This format converts arguments of types determined by the\n-     format string.  */\n-  FMT_FLAG_ARG_CONVERT = 1,\n-  /* The scanf allocation 'a' kludge applies to this format kind.  */\n-  FMT_FLAG_SCANF_A_KLUDGE = 2,\n-  /* A % during parsing a specifier is allowed to be a modified % rather\n-     that indicating the format is broken and we are out-of-sync.  */\n-  FMT_FLAG_FANCY_PERCENT_OK = 4,\n-  /* With $ operand numbers, it is OK to reference the same argument more\n-     than once.  */\n-  FMT_FLAG_DOLLAR_MULTIPLE = 8,\n-  /* This format type uses $ operand numbers (strfmon doesn't).  */\n-  FMT_FLAG_USE_DOLLAR = 16,\n-  /* Zero width is bad in this type of format (scanf).  */\n-  FMT_FLAG_ZERO_WIDTH_BAD = 32,\n-  /* Empty precision specification is OK in this type of format (printf).  */\n-  FMT_FLAG_EMPTY_PREC_OK = 64\n-  /* Not included here: details of whether width or precision may occur\n-     (controlled by width_char and precision_char); details of whether\n-     '*' can be used for these (width_type and precision_type); details\n-     of whether length modifiers can occur (length_char_specs).  */\n-};\n-\n-\n-/* Structure describing a length modifier supported in format checking, and\n-   possibly a doubled version such as \"hh\".  */\n-typedef struct\n-{\n-  /* Name of the single-character length modifier.  */\n-  const char *name;\n-  /* Index into a format_char_info.types array.  */\n-  enum format_lengths index;\n-  /* Standard version this length appears in.  */\n-  enum format_std_version std;\n-  /* Same, if the modifier can be repeated, or NULL if it can't.  */\n-  const char *double_name;\n-  enum format_lengths double_index;\n-  enum format_std_version double_std;\n-} format_length_info;\n-\n-\n-/* Structure desribing the combination of a conversion specifier\n-   (or a set of specifiers which act identically) and a length modifier.  */\n-typedef struct\n-{\n-  /* The standard version this combination of length and type appeared in.\n-     This is only relevant if greater than those for length and type\n-     individually; otherwise it is ignored.  */\n-  enum format_std_version std;\n-  /* The name to use for the type, if different from that generated internally\n-     (e.g., \"signed size_t\").  */\n-  const char *name;\n-  /* The type itself.  */\n-  tree *type;\n-} format_type_detail;\n-\n-\n-/* Macros to fill out tables of these.  */\n-#define BADLEN\t{ 0, NULL, NULL }\n-#define NOLENGTHS\t{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n-\n-\n-/* Structure desribing a format conversion specifier (or a set of specifiers\n-   which act identically), and the length modifiers used with it.  */\n-typedef struct\n-{\n-  const char *format_chars;\n-  int pointer_count;\n-  enum format_std_version std;\n-  /* Types accepted for each length modifier.  */\n-  format_type_detail types[FMT_LEN_MAX];\n-  /* List of other modifier characters allowed with these specifiers.\n-     This lists flags, and additionally \"w\" for width, \"p\" for precision\n-     (right precision, for strfmon), \"#\" for left precision (strfmon),\n-     \"a\" for scanf \"a\" allocation extension (not applicable in C99 mode),\n-     \"*\" for scanf suppression, and \"E\" and \"O\" for those strftime\n-     modifiers.  */\n-  const char *flag_chars;\n-  /* List of additional flags describing these conversion specifiers.\n-     \"c\" for generic character pointers being allowed, \"2\" for strftime\n-     two digit year formats, \"3\" for strftime formats giving two digit\n-     years in some locales, \"4\" for \"2\" which becomes \"3\" with an \"E\" modifier,\n-     \"o\" if use of strftime \"O\" is a GNU extension beyond C99,\n-     \"W\" if the argument is a pointer which is dereferenced and written into,\n-     \"R\" if the argument is a pointer which is dereferenced and read from,\n-     \"i\" for printf integer formats where the '0' flag is ignored with\n-     precision, and \"[\" for the starting character of a scanf scanset.  */\n-  const char *flags2;\n-} format_char_info;\n-\n-\n-/* Structure describing a flag accepted by some kind of format.  */\n-typedef struct\n-{\n-  /* The flag character in question (0 for end of array).  */\n-  int flag_char;\n-  /* Zero if this entry describes the flag character in general, or a\n-     non-zero character that may be found in flags2 if it describes the\n-     flag when used with certain formats only.  If the latter, only\n-     the first such entry found that applies to the current conversion\n-     specifier is used; the values of `name' and `long_name' it supplies\n-     will be used, if non-NULL and the standard version is higher than\n-     the unpredicated one, for any pedantic warning.  For example, 'o'\n-     for strftime formats (meaning 'O' is an extension over C99).  */\n-  int predicate;\n-  /* Nonzero if the next character after this flag in the format should\n-     be skipped ('=' in strfmon), zero otherwise.  */\n-  int skip_next_char;\n-  /* The name to use for this flag in diagnostic messages.  For example,\n-     N_(\"`0' flag\"), N_(\"field width\").  */\n-  const char *name;\n-  /* Long name for this flag in diagnostic messages; currently only used for\n-     \"ISO C does not support ...\".  For example, N_(\"the `I' printf flag\").  */\n-  const char *long_name;\n-  /* The standard version in which it appeared.  */\n-  enum format_std_version std;\n-} format_flag_spec;\n-\n-\n-/* Structure describing a combination of flags that is bad for some kind\n-   of format.  */\n-typedef struct\n-{\n-  /* The first flag character in question (0 for end of array).  */\n-  int flag_char1;\n-  /* The second flag character.  */\n-  int flag_char2;\n-  /* Non-zero if the message should say that the first flag is ignored with\n-     the second, zero if the combination should simply be objected to.  */\n-  int ignored;\n-  /* Zero if this entry applies whenever this flag combination occurs,\n-     a non-zero character from flags2 if it only applies in some\n-     circumstances (e.g. 'i' for printf formats ignoring 0 with precision).  */\n-  int predicate;\n-} format_flag_pair;\n-\n-\n-/* Structure describing a particular kind of format processed by GCC.  */\n-typedef struct\n-{\n-  /* The name of this kind of format, for use in diagnostics.  Also\n-     the name of the attribute (without preceding and following __).  */\n-  const char *name;\n-  /* Specifications of the length modifiers accepted; possibly NULL.  */\n-  const format_length_info *length_char_specs;\n-  /* Details of the conversion specification characters accepted.  */\n-  const format_char_info *conversion_specs;\n-  /* String listing the flag characters that are accepted.  */\n-  const char *flag_chars;\n-  /* String listing modifier characters (strftime) accepted.  May be NULL.  */\n-  const char *modifier_chars;\n-  /* Details of the flag characters, including pseudo-flags.  */\n-  const format_flag_spec *flag_specs;\n-  /* Details of bad combinations of flags.  */\n-  const format_flag_pair *bad_flag_pairs;\n-  /* Flags applicable to this kind of format.  */\n-  int flags;\n-  /* Flag character to treat a width as, or 0 if width not used.  */\n-  int width_char;\n-  /* Flag character to treat a left precision (strfmon) as,\n-     or 0 if left precision not used.  */\n-  int left_precision_char;\n-  /* Flag character to treat a precision (for strfmon, right precision) as,\n-     or 0 if precision not used.  */\n-  int precision_char;\n-  /* If a flag character has the effect of suppressing the conversion of\n-     an argument ('*' in scanf), that flag character, otherwise 0.  */\n-  int suppression_char;\n-  /* Flag character to treat a length modifier as (ignored if length\n-     modifiers not used).  Need not be placed in flag_chars for conversion\n-     specifiers, but is used to check for bad combinations such as length\n-     modifier with assignment suppression in scanf.  */\n-  int length_code_char;\n-  /* Pointer to type of argument expected if '*' is used for a width,\n-     or NULL if '*' not used for widths.  */\n-  tree *width_type;\n-  /* Pointer to type of argument expected if '*' is used for a precision,\n-     or NULL if '*' not used for precisions.  */\n-  tree *precision_type;\n-} format_kind_info;\n-\n-\n-/* Structure describing details of a type expected in format checking,\n-   and the type to check against it.  */\n-typedef struct format_wanted_type\n-{\n-  /* The type wanted.  */\n-  tree wanted_type;\n-  /* The name of this type to use in diagnostics.  */\n-  const char *wanted_type_name;\n-  /* The level of indirection through pointers at which this type occurs.  */\n-  int pointer_count;\n-  /* Whether, when pointer_count is 1, to allow any character type when\n-     pedantic, rather than just the character or void type specified.  */\n-  int char_lenient_flag;\n-  /* Whether the argument, dereferenced once, is written into and so the\n-     argument must not be a pointer to a const-qualified type.  */\n-  int writing_in_flag;\n-  /* Whether the argument, dereferenced once, is read from and so\n-     must not be a NULL pointer.  */\n-  int reading_from_flag;\n-  /* If warnings should be of the form \"field precision is not type int\",\n-     the name to use (in this case \"field precision\"), otherwise NULL,\n-     for \"%s format, %s arg\" type messages.  If (in an extension), this\n-     is a pointer type, wanted_type_name should be set to include the\n-     terminating '*' characters of the type name to give a correct\n-     message.  */\n-  const char *name;\n-  /* The actual parameter to check against the wanted type.  */\n-  tree param;\n-  /* The argument number of that parameter.  */\n-  int arg_num;\n-  /* The next type to check for this format conversion, or NULL if none.  */\n-  struct format_wanted_type *next;\n-} format_wanted_type;\n-\n-\n-static const format_length_info printf_length_specs[] =\n-{\n-  { \"h\", FMT_LEN_h, STD_C89, \"hh\", FMT_LEN_hh, STD_C99 },\n-  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C9L },\n-  { \"q\", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },\n-  { \"L\", FMT_LEN_L, STD_C89, NULL, 0, 0 },\n-  { \"z\", FMT_LEN_z, STD_C99, NULL, 0, 0 },\n-  { \"Z\", FMT_LEN_z, STD_EXT, NULL, 0, 0 },\n-  { \"t\", FMT_LEN_t, STD_C99, NULL, 0, 0 },\n-  { \"j\", FMT_LEN_j, STD_C99, NULL, 0, 0 },\n-  { NULL, 0, 0, NULL, 0, 0 }\n-};\n-\n-\n-/* This differs from printf_length_specs only in that \"Z\" is not accepted.  */\n-static const format_length_info scanf_length_specs[] =\n-{\n-  { \"h\", FMT_LEN_h, STD_C89, \"hh\", FMT_LEN_hh, STD_C99 },\n-  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C9L },\n-  { \"q\", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },\n-  { \"L\", FMT_LEN_L, STD_C89, NULL, 0, 0 },\n-  { \"z\", FMT_LEN_z, STD_C99, NULL, 0, 0 },\n-  { \"t\", FMT_LEN_t, STD_C99, NULL, 0, 0 },\n-  { \"j\", FMT_LEN_j, STD_C99, NULL, 0, 0 },\n-  { NULL, 0, 0, NULL, 0, 0 }\n-};\n-\n-\n-/* All tables for strfmon use STD_C89 everywhere, since -pedantic warnings\n-   make no sense for a format type not part of any C standard version.  */\n-static const format_length_info strfmon_length_specs[] =\n-{\n-  /* A GNU extension.  */\n-  { \"L\", FMT_LEN_L, STD_C89, NULL, 0, 0 },\n-  { NULL, 0, 0, NULL, 0, 0 }\n-};\n-\n-static const format_flag_spec printf_flag_specs[] =\n-{\n-  { ' ',  0, 0, N_(\"` ' flag\"),        N_(\"the ` ' printf flag\"),              STD_C89 },\n-  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n-  { '#',  0, 0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n-  { '0',  0, 0, N_(\"`0' flag\"),        N_(\"the `0' printf flag\"),              STD_C89 },\n-  { '-',  0, 0, N_(\"`-' flag\"),        N_(\"the `-' printf flag\"),              STD_C89 },\n-  { '\\'', 0, 0, N_(\"`'' flag\"),        N_(\"the `'' printf flag\"),              STD_EXT },\n-  { 'I',  0, 0, N_(\"`I' flag\"),        N_(\"the `I' printf flag\"),              STD_EXT },\n-  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n-  { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n-  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n-  { 0, 0, 0, NULL, NULL, 0 }\n-};\n-\n-\n-static const format_flag_pair printf_flag_pairs[] =\n-{\n-  { ' ', '+', 1, 0   },\n-  { '0', '-', 1, 0   },\n-  { '0', 'p', 1, 'i' },\n-  { 0, 0, 0, 0 }\n-};\n-\n-\n-static const format_flag_spec scanf_flag_specs[] =\n-{\n-  { '*',  0, 0, N_(\"assignment suppression\"), N_(\"assignment suppression\"),          STD_C89 },\n-  { 'a',  0, 0, N_(\"`a' flag\"),               N_(\"the `a' scanf flag\"),              STD_EXT },\n-  { 'w',  0, 0, N_(\"field width\"),            N_(\"field width in scanf format\"),     STD_C89 },\n-  { 'L',  0, 0, N_(\"length modifier\"),        N_(\"length modifier in scanf format\"), STD_C89 },\n-  { '\\'', 0, 0, N_(\"`'' flag\"),               N_(\"the `'' scanf flag\"),              STD_EXT },\n-  { 'I',  0, 0, N_(\"`I' flag\"),               N_(\"the `I' scanf flag\"),              STD_EXT },\n-  { 0, 0, 0, NULL, NULL, 0 }\n-};\n-\n-\n-static const format_flag_pair scanf_flag_pairs[] =\n-{\n-  { '*', 'L', 0, 0 },\n-  { 0, 0, 0, 0 }\n-};\n-\n-\n-static const format_flag_spec strftime_flag_specs[] =\n-{\n-  { '_', 0,   0, N_(\"`_' flag\"),     N_(\"the `_' strftime flag\"),          STD_EXT },\n-  { '-', 0,   0, N_(\"`-' flag\"),     N_(\"the `-' strftime flag\"),          STD_EXT },\n-  { '0', 0,   0, N_(\"`0' flag\"),     N_(\"the `0' strftime flag\"),          STD_EXT },\n-  { '^', 0,   0, N_(\"`^' flag\"),     N_(\"the `^' strftime flag\"),          STD_EXT },\n-  { '#', 0,   0, N_(\"`#' flag\"),     N_(\"the `#' strftime flag\"),          STD_EXT },\n-  { 'w', 0,   0, N_(\"field width\"),  N_(\"field width in strftime format\"), STD_EXT },\n-  { 'E', 0,   0, N_(\"`E' modifier\"), N_(\"the `E' strftime modifier\"),      STD_C99 },\n-  { 'O', 0,   0, N_(\"`O' modifier\"), N_(\"the `O' strftime modifier\"),      STD_C99 },\n-  { 'O', 'o', 0, NULL,               N_(\"the `O' modifier\"),               STD_EXT },\n-  { 0, 0, 0, NULL, NULL, 0 }\n-};\n-\n-\n-static const format_flag_pair strftime_flag_pairs[] =\n-{\n-  { 'E', 'O', 0, 0 },\n-  { '_', '-', 0, 0 },\n-  { '_', '0', 0, 0 },\n-  { '-', '0', 0, 0 },\n-  { '^', '#', 0, 0 },\n-  { 0, 0, 0, 0 }\n-};\n-\n-\n-static const format_flag_spec strfmon_flag_specs[] =\n-{\n-  { '=',  0, 1, N_(\"fill character\"),  N_(\"fill character in strfmon format\"),  STD_C89 },\n-  { '^',  0, 0, N_(\"`^' flag\"),        N_(\"the `^' strfmon flag\"),              STD_C89 },\n-  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' strfmon flag\"),              STD_C89 },\n-  { '(',  0, 0, N_(\"`(' flag\"),        N_(\"the `(' strfmon flag\"),              STD_C89 },\n-  { '!',  0, 0, N_(\"`!' flag\"),        N_(\"the `!' strfmon flag\"),              STD_C89 },\n-  { '-',  0, 0, N_(\"`-' flag\"),        N_(\"the `-' strfmon flag\"),              STD_C89 },\n-  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in strfmon format\"),     STD_C89 },\n-  { '#',  0, 0, N_(\"left precision\"),  N_(\"left precision in strfmon format\"),  STD_C89 },\n-  { 'p',  0, 0, N_(\"right precision\"), N_(\"right precision in strfmon format\"), STD_C89 },\n-  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in strfmon format\"), STD_C89 },\n-  { 0, 0, 0, NULL, NULL, 0 }\n-};\n-\n-static const format_flag_pair strfmon_flag_pairs[] =\n-{\n-  { '+', '(', 0, 0 },\n-  { 0, 0, 0, 0 }\n-};\n-\n-\n-#define T_I\t&integer_type_node\n-#define T89_I\t{ STD_C89, NULL, T_I }\n-#define T99_I\t{ STD_C99, NULL, T_I }\n-#define T_L\t&long_integer_type_node\n-#define T89_L\t{ STD_C89, NULL, T_L }\n-#define T_LL\t&long_long_integer_type_node\n-#define T9L_LL\t{ STD_C9L, NULL, T_LL }\n-#define TEX_LL\t{ STD_EXT, NULL, T_LL }\n-#define T_S\t&short_integer_type_node\n-#define T89_S\t{ STD_C89, NULL, T_S }\n-#define T_UI\t&unsigned_type_node\n-#define T89_UI\t{ STD_C89, NULL, T_UI }\n-#define T99_UI\t{ STD_C99, NULL, T_UI }\n-#define T_UL\t&long_unsigned_type_node\n-#define T89_UL\t{ STD_C89, NULL, T_UL }\n-#define T_ULL\t&long_long_unsigned_type_node\n-#define T9L_ULL\t{ STD_C9L, NULL, T_ULL }\n-#define TEX_ULL\t{ STD_EXT, NULL, T_ULL }\n-#define T_US\t&short_unsigned_type_node\n-#define T89_US\t{ STD_C89, NULL, T_US }\n-#define T_F\t&float_type_node\n-#define T89_F\t{ STD_C89, NULL, T_F }\n-#define T99_F\t{ STD_C99, NULL, T_F }\n-#define T_D\t&double_type_node\n-#define T89_D\t{ STD_C89, NULL, T_D }\n-#define T99_D\t{ STD_C99, NULL, T_D }\n-#define T_LD\t&long_double_type_node\n-#define T89_LD\t{ STD_C89, NULL, T_LD }\n-#define T99_LD\t{ STD_C99, NULL, T_LD }\n-#define T_C\t&char_type_node\n-#define T89_C\t{ STD_C89, NULL, T_C }\n-#define T_SC\t&signed_char_type_node\n-#define T99_SC\t{ STD_C99, NULL, T_SC }\n-#define T_UC\t&unsigned_char_type_node\n-#define T99_UC\t{ STD_C99, NULL, T_UC }\n-#define T_V\t&void_type_node\n-#define T89_V\t{ STD_C89, NULL, T_V }\n-#define T_W\t&wchar_type_node\n-#define T94_W\t{ STD_C94, \"wchar_t\", T_W }\n-#define TEX_W\t{ STD_EXT, \"wchar_t\", T_W }\n-#define T_WI\t&wint_type_node\n-#define T94_WI\t{ STD_C94, \"wint_t\", T_WI }\n-#define TEX_WI\t{ STD_EXT, \"wint_t\", T_WI }\n-#define T_ST    &c_size_type_node\n-#define T99_ST\t{ STD_C99, \"size_t\", T_ST }\n-#define T_SST   &signed_size_type_node\n-#define T99_SST\t{ STD_C99, \"signed size_t\", T_SST }\n-#define T_PD    &ptrdiff_type_node\n-#define T99_PD\t{ STD_C99, \"ptrdiff_t\", T_PD }\n-#define T_UPD   &unsigned_ptrdiff_type_node\n-#define T99_UPD\t{ STD_C99, \"unsigned ptrdiff_t\", T_UPD }\n-#define T_IM    &intmax_type_node\n-#define T99_IM\t{ STD_C99, \"intmax_t\", T_IM }\n-#define T_UIM   &uintmax_type_node\n-#define T99_UIM\t{ STD_C99, \"uintmax_t\", T_UIM }\n-\n-static const format_char_info print_char_table[] =\n-{\n-  /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"-wp0 +'I\", \"i\"  },\n-  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0#\",    \"i\"  },\n-  { \"u\",   0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0'I\",   \"i\"  },\n-  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'\", \"\"   },\n-  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\",  \"\"   },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\"   },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",      \"cR\" },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"c\"  },\n-  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",         \"W\"  },\n-  /* C99 conversion specifiers.  */\n-  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'\", \"\"   },\n-  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\",  \"\"   },\n-  /* X/Open conversion specifiers.  */\n-  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\"   },\n-  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",      \"R\"  },\n-  /* GNU conversion specifiers.  */\n-  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",      \"\"   },\n-  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n-};\n-\n-static const format_char_info scan_char_table[] =\n-{\n-  /* C89 conversion specifiers.  */\n-  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"*w'I\", \"W\"   },\n-  { \"u\",     1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w'I\", \"W\"   },\n-  { \"oxX\",   1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w\",   \"W\"   },\n-  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\"   },\n-  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"cW\"  },\n-  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW\"  },\n-  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW[\" },\n-  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\"   },\n-  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",     \"W\"   },\n-  /* C99 conversion specifiers.  */\n-  { \"FaA\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\"   },\n-  /* X/Open conversion specifiers.  */\n-  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\"   },\n-  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"W\"   },\n-  { NULL, 0, 0, NOLENGTHS, NULL, NULL }\n-};\n-\n-static const format_char_info time_char_table[] =\n-{\n-  /* C89 conversion specifiers.  */\n-  { \"ABZab\",\t\t0, STD_C89, NOLENGTHS, \"^#\",     \"\"   },\n-  { \"cx\", \t\t0, STD_C89, NOLENGTHS, \"E\",      \"3\"  },\n-  { \"HIMSUWdmw\",\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"\"   },\n-  { \"j\",\t\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"o\"  },\n-  { \"p\",\t\t0, STD_C89, NOLENGTHS, \"#\",      \"\"   },\n-  { \"X\",\t\t0, STD_C89, NOLENGTHS, \"E\",      \"\"   },\n-  { \"y\", \t\t0, STD_C89, NOLENGTHS, \"EO-_0w\", \"4\"  },\n-  { \"Y\",\t\t0, STD_C89, NOLENGTHS, \"-_0EOw\", \"o\"  },\n-  { \"%\",\t\t0, STD_C89, NOLENGTHS, \"\",       \"\"   },\n-  /* C99 conversion specifiers.  */\n-  { \"C\",\t\t0, STD_C99, NOLENGTHS, \"-_0EOw\", \"o\"  },\n-  { \"D\", \t\t0, STD_C99, NOLENGTHS, \"\",       \"2\"  },\n-  { \"eVu\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"\"   },\n-  { \"FRTnrt\",\t\t0, STD_C99, NOLENGTHS, \"\",       \"\"   },\n-  { \"g\", \t\t0, STD_C99, NOLENGTHS, \"O-_0w\",  \"2o\" },\n-  { \"G\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"o\"  },\n-  { \"h\",\t\t0, STD_C99, NOLENGTHS, \"^#\",     \"\"   },\n-  { \"z\",\t\t0, STD_C99, NOLENGTHS, \"O\",      \"o\"  },\n-  /* GNU conversion specifiers.  */\n-  { \"kls\",\t\t0, STD_EXT, NOLENGTHS, \"-_0Ow\",  \"\"   },\n-  { \"P\",\t\t0, STD_EXT, NOLENGTHS, \"\",       \"\"   },\n-  { NULL,\t\t0, 0, NOLENGTHS, NULL, NULL }\n-};\n-\n-static const format_char_info monetary_char_table[] =\n-{\n-  { \"in\", 0, STD_C89, { T89_D, BADLEN, BADLEN, BADLEN, BADLEN, T89_LD, BADLEN, BADLEN, BADLEN }, \"=^+(!-w#p\", \"\" },\n-  { NULL, 0, 0, NOLENGTHS, NULL, NULL }\n-};\n-\n-\n-/* This must be in the same order as enum format_type.  */\n-static const format_kind_info format_types[] =\n-{\n-  { \"printf\",   printf_length_specs,  print_char_table, \" +#0-'I\", NULL, \n-    printf_flag_specs, printf_flag_pairs,\n-    FMT_FLAG_ARG_CONVERT|FMT_FLAG_DOLLAR_MULTIPLE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_EMPTY_PREC_OK,\n-    'w', 0, 'p', 0, 'L',\n-    &integer_type_node, &integer_type_node\n-  },\n-  { \"scanf\",    scanf_length_specs,   scan_char_table,  \"*'I\", NULL, \n-    scanf_flag_specs, scanf_flag_pairs,\n-    FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD,\n-    'w', 0, 0, '*', 'L',\n-    NULL, NULL\n-  },\n-  { \"strftime\", NULL,                 time_char_table,  \"_-0^#\", \"EO\",\n-    strftime_flag_specs, strftime_flag_pairs,\n-    FMT_FLAG_FANCY_PERCENT_OK, 'w', 0, 0, 0, 0,\n-    NULL, NULL\n-  },\n-  { \"strfmon\",  strfmon_length_specs, monetary_char_table, \"=^+(!-\", NULL, \n-    strfmon_flag_specs, strfmon_flag_pairs,\n-    FMT_FLAG_ARG_CONVERT, 'w', '#', 'p', 0, 'L',\n-    NULL, NULL\n-  }\n-};\n-\n-\n-typedef struct function_format_info\n-{\n-  struct function_format_info *next;  /* next structure on the list */\n-  tree name;\t\t\t/* identifier such as \"printf\" */\n-  tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n-  enum format_type format_type;\t/* type of format (printf, scanf, etc.) */\n-  int format_num;\t\t/* number of format argument */\n-  int first_arg_num;\t\t/* number of first arg (zero for varargs) */\n-} function_format_info;\n-\n-static function_format_info *function_format_list = NULL;\n-\n-typedef struct international_format_info\n-{\n-  struct international_format_info *next;  /* next structure on the list */\n-  tree name;\t\t\t/* identifier such as \"gettext\" */\n-  tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n-  int format_num;\t\t/* number of format argument */\n-} international_format_info;\n-\n-static international_format_info *international_format_list = NULL;\n-\n-/* Structure detailing the results of checking a format function call\n-   where the format expression may be a conditional expression with\n-   many leaves resulting from nested conditional expressions.  */\n-typedef struct\n-{\n-  /* Number of leaves of the format argument that could not be checked\n-     as they were not string literals.  */\n-  int number_non_literal;\n-  /* Number of leaves of the format argument that were null pointers or\n-     string literals, but had extra format arguments.  */\n-  int number_extra_args;\n-  /* Number of leaves of the format argument that were null pointers or\n-     string literals, but had extra format arguments and used $ operand\n-     numbers.  */\n-  int number_dollar_extra_args;\n-  /* Number of leaves of the format argument that were wide string\n-     literals.  */\n-  int number_wide;\n-  /* Number of leaves of the format argument that were empty strings.  */\n-  int number_empty;\n-  /* Number of leaves of the format argument that were unterminated\n-     strings.  */\n-  int number_unterminated;\n-  /* Number of leaves of the format argument that were not counted above.  */\n-  int number_other;\n-} format_check_results;\n-\n-static void check_format_info\tPARAMS ((int *, function_format_info *, tree));\n-static void check_format_info_recurse PARAMS ((int *, format_check_results *,\n-\t\t\t\t\t       function_format_info *, tree,\n-\t\t\t\t\t       tree, int));\n-static void check_format_info_main PARAMS ((int *, format_check_results *,\n-\t\t\t\t\t    function_format_info *,\n-\t\t\t\t\t    const char *, int, tree, int));\n-static void status_warning PARAMS ((int *, const char *, ...))\n-     ATTRIBUTE_PRINTF_2;\n-\n-static void init_dollar_format_checking\t\tPARAMS ((int, tree));\n-static int maybe_read_dollar_number\t\tPARAMS ((int *, const char **, int,\n-\t\t\t\t\t\t\t tree, tree *,\n-\t\t\t\t\t\t\t const format_kind_info *));\n-static void finish_dollar_format_checking\tPARAMS ((int *, format_check_results *));\n-\n-static const format_flag_spec *get_flag_spec\tPARAMS ((const format_flag_spec *,\n-\t\t\t\t\t\t\t int, const char *));\n-\n-static void check_format_types\tPARAMS ((int *, format_wanted_type *));\n static int is_valid_printf_arglist PARAMS ((tree));\n static rtx c_expand_builtin PARAMS ((tree, rtx, enum machine_mode, enum expand_modifier));\n static rtx c_expand_builtin_printf PARAMS ((tree, rtx, enum machine_mode,\n \t\t\t\t\t    enum expand_modifier, int));\n static rtx c_expand_builtin_fprintf PARAMS ((tree, rtx, enum machine_mode,\n \t\t\t\t\t     enum expand_modifier, int));\n-\n-/* Initialize the table of functions to perform format checking on.\n-   The ISO C functions are always checked (whether <stdio.h> is\n-   included or not), since it is common to call printf without\n-   including <stdio.h>.  There shouldn't be a problem with this,\n-   since ISO C reserves these function names whether you include the\n-   header file or not.  In any case, the checking is harmless.  With\n-   -ffreestanding, these default attributes are disabled, and must be\n-   specified manually if desired.\n-\n-   Also initialize the name of function that modify the format string for\n-   internationalization purposes.  */\n-\n-void\n-init_function_format_info ()\n-{\n-  if (flag_hosted)\n-    {\n-      /* Functions from ISO/IEC 9899:1990.  */\n-      record_function_format (get_identifier (\"printf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 1, 2);\n-      record_function_format (get_identifier (\"__builtin_printf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 1, 2);\n-      record_function_format (get_identifier (\"fprintf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 2, 3);\n-      record_function_format (get_identifier (\"__builtin_fprintf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 2, 3);\n-      record_function_format (get_identifier (\"sprintf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 2, 3);\n-      record_function_format (get_identifier (\"scanf\"), NULL_TREE,\n-\t\t\t      scanf_format_type, 1, 2);\n-      record_function_format (get_identifier (\"fscanf\"), NULL_TREE,\n-\t\t\t      scanf_format_type, 2, 3);\n-      record_function_format (get_identifier (\"sscanf\"), NULL_TREE,\n-\t\t\t      scanf_format_type, 2, 3);\n-      record_function_format (get_identifier (\"vprintf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 1, 0);\n-      record_function_format (get_identifier (\"vfprintf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 2, 0);\n-      record_function_format (get_identifier (\"vsprintf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 2, 0);\n-      record_function_format (get_identifier (\"strftime\"), NULL_TREE,\n-\t\t\t      strftime_format_type, 3, 0);\n-    }\n-\n-  if (flag_hosted && flag_isoc99)\n-    {\n-      /* ISO C99 adds the snprintf and vscanf family functions.  */\n-      record_function_format (get_identifier (\"snprintf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 3, 4);\n-      record_function_format (get_identifier (\"vsnprintf\"), NULL_TREE,\n-\t\t\t      printf_format_type, 3, 0);\n-      record_function_format (get_identifier (\"vscanf\"), NULL_TREE,\n-\t\t\t      scanf_format_type, 1, 0);\n-      record_function_format (get_identifier (\"vfscanf\"), NULL_TREE,\n-\t\t\t      scanf_format_type, 2, 0);\n-      record_function_format (get_identifier (\"vsscanf\"), NULL_TREE,\n-\t\t\t      scanf_format_type, 2, 0);\n-    }\n-\n-  if (flag_hosted && flag_noniso_default_format_attributes)\n-    {\n-      /* Uniforum/GNU gettext functions, not in ISO C.  */\n-      record_international_format (get_identifier (\"gettext\"), NULL_TREE, 1);\n-      record_international_format (get_identifier (\"dgettext\"), NULL_TREE, 2);\n-      record_international_format (get_identifier (\"dcgettext\"), NULL_TREE, 2);\n-      /* X/Open strfmon function.  */\n-      record_function_format (get_identifier (\"strfmon\"), NULL_TREE,\n-\t\t\t      strfmon_format_type, 3, 4);\n-    }\n-}\n-\n-/* Decode a format type from a string, returning the type, or\n-   format_type_error if not valid, in which case the caller should print an\n-   error message.  */\n-static enum format_type\n-decode_format_type (s)\n-     const char *s;\n-{\n-  int i;\n-  int slen;\n-  slen = strlen (s);\n-  for (i = 0; i < (int) format_type_error; i++)\n-    {\n-      int alen;\n-      if (!strcmp (s, format_types[i].name))\n-\tbreak;\n-      alen = strlen (format_types[i].name);\n-      if (slen == alen + 4 && s[0] == '_' && s[1] == '_'\n-\t  && s[slen - 1] == '_' && s[slen - 2] == '_'\n-\t  && !strncmp (s + 2, format_types[i].name, alen))\n-\tbreak;\n-    }\n-  return ((enum format_type) i);\n-}\n-\n-/* Record information for argument format checking.  FUNCTION_IDENT is\n-   the identifier node for the name of the function to check (its decl\n-   need not exist yet).\n-   FORMAT_TYPE specifies the type of format checking.  FORMAT_NUM is the number\n-   of the argument which is the format control string (starting from 1).\n-   FIRST_ARG_NUM is the number of the first actual argument to check\n-   against the format string, or zero if no checking is not be done\n-   (e.g. for varargs such as vfprintf).  */\n-\n-static void\n-record_function_format (name, assembler_name, format_type,\n-\t\t\tformat_num, first_arg_num)\n-      tree name;\n-      tree assembler_name;\n-      enum format_type format_type;\n-      int format_num;\n-      int first_arg_num;\n-{\n-  function_format_info *info;\n-\n-  /* Re-use existing structure if it's there.  */\n-\n-  for (info = function_format_list; info; info = info->next)\n-    {\n-      if (info->name == name && info->assembler_name == assembler_name)\n-\tbreak;\n-    }\n-  if (! info)\n-    {\n-      info = (function_format_info *) xmalloc (sizeof (function_format_info));\n-      info->next = function_format_list;\n-      function_format_list = info;\n-\n-      info->name = name;\n-      info->assembler_name = assembler_name;\n-    }\n-\n-  info->format_type = format_type;\n-  info->format_num = format_num;\n-  info->first_arg_num = first_arg_num;\n-}\n-\n-/* Record information for the names of function that modify the format\n-   argument to format functions.  FUNCTION_IDENT is the identifier node for\n-   the name of the function (its decl need not exist yet) and FORMAT_NUM is\n-   the number of the argument which is the format control string (starting\n-   from 1).  */\n-\n-static void\n-record_international_format (name, assembler_name, format_num)\n-      tree name;\n-      tree assembler_name;\n-      int format_num;\n-{\n-  international_format_info *info;\n-\n-  /* Re-use existing structure if it's there.  */\n-\n-  for (info = international_format_list; info; info = info->next)\n-    {\n-      if (info->name == name && info->assembler_name == assembler_name)\n-\tbreak;\n-    }\n-\n-  if (! info)\n-    {\n-      info\n-\t= (international_format_info *)\n-\t  xmalloc (sizeof (international_format_info));\n-      info->next = international_format_list;\n-      international_format_list = info;\n-\n-      info->name = name;\n-      info->assembler_name = assembler_name;\n-    }\n-\n-  info->format_num = format_num;\n-}\n-\f\n-/* Check the argument list of a call to printf, scanf, etc.\n-   NAME is the function identifier.\n-   ASSEMBLER_NAME is the function's assembler identifier.\n-   (Either NAME or ASSEMBLER_NAME, but not both, may be NULL_TREE.)\n-   PARAMS is the list of argument values.  Also, if -Wmissing-format-attribute,\n-   warn for calls to vprintf or vscanf in functions with no such format\n-   attribute themselves.  */\n-\n-void\n-check_function_format (status, name, assembler_name, params)\n-     int *status;\n-     tree name;\n-     tree assembler_name;\n-     tree params;\n-{\n-  function_format_info *info;\n-\n-  /* See if this function is a format function.  */\n-  for (info = function_format_list; info; info = info->next)\n-    {\n-      if (info->assembler_name\n-\t  ? (info->assembler_name == assembler_name)\n-\t  : (info->name == name))\n-\t{\n-\t  /* Yup; check it.  */\n-\t  check_format_info (status, info, params);\n-\t  if (warn_missing_format_attribute && info->first_arg_num == 0\n-\t      && (format_types[info->format_type].flags & FMT_FLAG_ARG_CONVERT))\n-\t    {\n-\t      function_format_info *info2;\n-\t      for (info2 = function_format_list; info2; info2 = info2->next)\n-\t\tif ((info2->assembler_name\n-\t\t     ? (info2->assembler_name == DECL_ASSEMBLER_NAME (current_function_decl))\n-\t\t     : (info2->name == DECL_NAME (current_function_decl)))\n-\t\t    && info2->format_type == info->format_type)\n-\t\t  break;\n-\t      if (info2 == NULL)\n-\t\t{\n-\t\t  /* Check if the current function has a parameter to which\n-\t\t     the format attribute could be attached; if not, it\n-\t\t     can't be a candidate for a format attribute, despite\n-\t\t     the vprintf-like or vscanf-like call.  */\n-\t\t  tree args;\n-\t\t  for (args = DECL_ARGUMENTS (current_function_decl);\n-\t\t       args != 0;\n-\t\t       args = TREE_CHAIN (args))\n-\t\t    {\n-\t\t      if (TREE_CODE (TREE_TYPE (args)) == POINTER_TYPE\n-\t\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (args)))\n-\t\t\t      == char_type_node))\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  if (args != 0)\n-\t\t    warning (\"function might be possible candidate for `%s' format attribute\",\n-\t\t\t     format_types[info->format_type].name);\n-\t\t}\n-\t    }\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* This function replaces `warning' inside the printf format checking\n-   functions.  If the `status' parameter is non-NULL, then it is\n-   dereferenced and set to 1 whenever a warning is caught.  Otherwise\n-   it warns as usual by replicating the innards of the warning\n-   function from diagnostic.c.  */\n-static void\n-status_warning VPARAMS ((int *status, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  int *status;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  diagnostic_context dc;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  status = va_arg (ap, int *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  if (status)\n-    *status = 1;\n-  else\n-    {\n-      /* This duplicates the warning function behavior.  */\n-      set_diagnostic_context\n-\t(&dc, msgid, &ap, input_filename, lineno, /* warn = */ 1);\n-      report_diagnostic (&dc);\n-    }\n-\n-  va_end (ap);\n-}\n-\n-/* Variables used by the checking of $ operand number formats.  */\n-static char *dollar_arguments_used = NULL;\n-static int dollar_arguments_alloc = 0;\n-static int dollar_arguments_count;\n-static int dollar_first_arg_num;\n-static int dollar_max_arg_used;\n-static int dollar_format_warned;\n-\n-/* Initialize the checking for a format string that may contain $\n-   parameter number specifications; we will need to keep track of whether\n-   each parameter has been used.  FIRST_ARG_NUM is the number of the first\n-   argument that is a parameter to the format, or 0 for a vprintf-style\n-   function; PARAMS is the list of arguments starting at this argument.  */\n-\n-static void\n-init_dollar_format_checking (first_arg_num, params)\n-     int first_arg_num;\n-     tree params;\n-{\n-  dollar_first_arg_num = first_arg_num;\n-  dollar_arguments_count = 0;\n-  dollar_max_arg_used = 0;\n-  dollar_format_warned = 0;\n-  if (first_arg_num > 0)\n-    {\n-      while (params)\n-\t{\n-\t  dollar_arguments_count++;\n-\t  params = TREE_CHAIN (params);\n-\t}\n-    }\n-  if (dollar_arguments_alloc < dollar_arguments_count)\n-    {\n-      if (dollar_arguments_used)\n-\tfree (dollar_arguments_used);\n-      dollar_arguments_alloc = dollar_arguments_count;\n-      dollar_arguments_used = xmalloc (dollar_arguments_alloc);\n-    }\n-  if (dollar_arguments_alloc)\n-    memset (dollar_arguments_used, 0, dollar_arguments_alloc);\n-}\n-\n-\n-/* Look for a decimal number followed by a $ in *FORMAT.  If DOLLAR_NEEDED\n-   is set, it is an error if one is not found; otherwise, it is OK.  If\n-   such a number is found, check whether it is within range and mark that\n-   numbered operand as being used for later checking.  Returns the operand\n-   number if found and within range, zero if no such number was found and\n-   this is OK, or -1 on error.  PARAMS points to the first operand of the\n-   format; PARAM_PTR is made to point to the parameter referred to.  If\n-   a $ format is found, *FORMAT is updated to point just after it.  */\n-\n-static int\n-maybe_read_dollar_number (status, format, dollar_needed, params, param_ptr,\n-\t\t\t  fki)\n-     int *status;\n-     const char **format;\n-     int dollar_needed;\n-     tree params;\n-     tree *param_ptr;\n-     const format_kind_info *fki;\n-{\n-  int argnum;\n-  int overflow_flag;\n-  const char *fcp = *format;\n-  if (*fcp < '0' || *fcp > '9')\n-    {\n-      if (dollar_needed)\n-\t{\n-\t  status_warning (status, \"missing $ operand number in format\");\n-\t  return -1;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-  argnum = 0;\n-  overflow_flag = 0;\n-  while (*fcp >= '0' && *fcp <= '9')\n-    {\n-      int nargnum;\n-      nargnum = 10 * argnum + (*fcp - '0');\n-      if (nargnum < 0 || nargnum / 10 != argnum)\n-\toverflow_flag = 1;\n-      argnum = nargnum;\n-      fcp++;\n-    }\n-  if (*fcp != '$')\n-    {\n-      if (dollar_needed)\n-\t{\n-\t  status_warning (status, \"missing $ operand number in format\");\n-\t  return -1;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-  *format = fcp + 1;\n-  if (pedantic && !dollar_format_warned)\n-    {\n-      status_warning (status,\n-\t\t      \"%s does not support %%n$ operand number formats\",\n-\t\t      C_STD_NAME (STD_EXT));\n-      dollar_format_warned = 1;\n-    }\n-  if (overflow_flag || argnum == 0\n-      || (dollar_first_arg_num && argnum > dollar_arguments_count))\n-    {\n-      status_warning (status, \"operand number out of range in format\");\n-      return -1;\n-    }\n-  if (argnum > dollar_max_arg_used)\n-    dollar_max_arg_used = argnum;\n-  /* For vprintf-style functions we may need to allocate more memory to\n-     track which arguments are used.  */\n-  while (dollar_arguments_alloc < dollar_max_arg_used)\n-    {\n-      int nalloc;\n-      nalloc = 2 * dollar_arguments_alloc + 16;\n-      dollar_arguments_used = xrealloc (dollar_arguments_used, nalloc);\n-      memset (dollar_arguments_used + dollar_arguments_alloc, 0,\n-\t      nalloc - dollar_arguments_alloc);\n-      dollar_arguments_alloc = nalloc;\n-    }\n-  if (!(fki->flags & FMT_FLAG_DOLLAR_MULTIPLE)\n-      && dollar_arguments_used[argnum - 1] == 1)\n-    {\n-      dollar_arguments_used[argnum - 1] = 2;\n-      status_warning (status,\n-\t\t      \"format argument %d used more than once in %s format\",\n-\t\t      argnum, fki->name);\n-    }\n-  else\n-    dollar_arguments_used[argnum - 1] = 1;\n-  if (dollar_first_arg_num)\n-    {\n-      int i;\n-      *param_ptr = params;\n-      for (i = 1; i < argnum && *param_ptr != 0; i++)\n-\t*param_ptr = TREE_CHAIN (*param_ptr);\n-\n-      if (*param_ptr == 0)\n-\t{\n-\t  /* This case shouldn't be caught here.  */\n-\t  abort ();\n-\t}\n-    }\n-  else\n-    *param_ptr = 0;\n-  return argnum;\n-}\n-\n-\n-/* Finish the checking for a format string that used $ operand number formats\n-   instead of non-$ formats.  We check for unused operands before used ones\n-   (a serious error, since the implementation of the format function\n-   can't know what types to pass to va_arg to find the later arguments).\n-   and for unused operands at the end of the format (if we know how many\n-   arguments the format had, so not for vprintf).  If there were operand\n-   numbers out of range on a non-vprintf-style format, we won't have reached\n-   here.  */\n-\n-static void\n-finish_dollar_format_checking (status, res)\n-     int *status;\n-     format_check_results *res;\n-{\n-  int i;\n-  for (i = 0; i < dollar_max_arg_used; i++)\n-    {\n-      if (!dollar_arguments_used[i])\n-\tstatus_warning (status, \"format argument %d unused before used argument %d in $-style format\",\n-\t\t i + 1, dollar_max_arg_used);\n-    }\n-  if (dollar_first_arg_num && dollar_max_arg_used < dollar_arguments_count)\n-    {\n-      res->number_other--;\n-      res->number_dollar_extra_args++;\n-    }\n-}\n-\n-\n-/* Retrieve the specification for a format flag.  SPEC contains the\n-   specifications for format flags for the applicable kind of format.\n-   FLAG is the flag in question.  If PREDICATES is NULL, the basic\n-   spec for that flag must be retrieved and this function aborts if\n-   it cannot be found.  If PREDICATES is not NULL, it is a string listing\n-   possible predicates for the spec entry; if an entry predicated on any\n-   of these is found, it is returned, otherwise NULL is returned.  */\n-\n-static const format_flag_spec *\n-get_flag_spec (spec, flag, predicates)\n-     const format_flag_spec *spec;\n-     int flag;\n-     const char *predicates;\n-{\n-  int i;\n-  for (i = 0; spec[i].flag_char != 0; i++)\n-    {\n-      if (spec[i].flag_char != flag)\n-\tcontinue;\n-      if (predicates != NULL)\n-\t{\n-\t  if (spec[i].predicate != 0\n-\t      && strchr (predicates, spec[i].predicate) != 0)\n-\t    return &spec[i];\n-\t}\n-      else if (spec[i].predicate == 0)\n-\treturn &spec[i];\n-    }\n-  if (predicates == NULL)\n-    abort ();\n-  else\n-    return NULL;\n-}\n-\n-\n-/* Check the argument list of a call to printf, scanf, etc.\n-   INFO points to the function_format_info structure.\n-   PARAMS is the list of argument values.  */\n-\n-static void\n-check_format_info (status, info, params)\n-     int *status;\n-     function_format_info *info;\n-     tree params;\n-{\n-  int arg_num;\n-  tree format_tree;\n-  format_check_results res;\n-  /* Skip to format argument.  If the argument isn't available, there's\n-     no work for us to do; prototype checking will catch the problem.  */\n-  for (arg_num = 1; ; ++arg_num)\n-    {\n-      if (params == 0)\n-\treturn;\n-      if (arg_num == info->format_num)\n-\tbreak;\n-      params = TREE_CHAIN (params);\n-    }\n-  format_tree = TREE_VALUE (params);\n-  params = TREE_CHAIN (params);\n-  if (format_tree == 0)\n-    return;\n-\n-  res.number_non_literal = 0;\n-  res.number_extra_args = 0;\n-  res.number_dollar_extra_args = 0;\n-  res.number_wide = 0;\n-  res.number_empty = 0;\n-  res.number_unterminated = 0;\n-  res.number_other = 0;\n-\n-  check_format_info_recurse (status, &res, info, format_tree, params, arg_num);\n-\n-  if (res.number_non_literal > 0)\n-    {\n-      /* Functions taking a va_list normally pass a non-literal format\n-\t string.  These functions typically are declared with\n-\t first_arg_num == 0, so avoid warning in those cases.  */\n-      if (!(format_types[info->format_type].flags & FMT_FLAG_ARG_CONVERT))\n-\t{\n-\t  /* For strftime-like formats, warn for not checking the format\n-\t     string; but there are no arguments to check.  */\n-\t  if (warn_format_nonliteral)\n-\t    status_warning (status, \"format not a string literal, format string not checked\");\n-\t}\n-      else if (info->first_arg_num != 0)\n-\t{\n-\t  /* If there are no arguments for the format at all, we may have\n-\t     printf (foo) which is likely to be a security hole.  */\n-\t  while (arg_num + 1 < info->first_arg_num)\n-\t    {\n-\t      if (params == 0)\n-\t\tbreak;\n-\t      params = TREE_CHAIN (params);\n-\t      ++arg_num;\n-\t    }\n-\t  if (params == 0 && (warn_format_nonliteral || warn_format_security))\n-\t    status_warning (status, \"format not a string literal and no format arguments\");\n-\t  else if (warn_format_nonliteral)\n-\t    status_warning (status, \"format not a string literal, argument types not checked\");\n-\t}\n-    }\n-\n-  /* If there were extra arguments to the format, normally warn.  However,\n-     the standard does say extra arguments are ignored, so in the specific\n-     case where we have multiple leaves (conditional expressions or\n-     ngettext) allow extra arguments if at least one leaf didn't have extra\n-     arguments, but was otherwise OK (either non-literal or checked OK).\n-     If the format is an empty string, this should be counted similarly to the\n-     case of extra format arguments.  */\n-  if (res.number_extra_args > 0 && res.number_non_literal == 0\n-      && res.number_other == 0 && warn_format_extra_args)\n-    status_warning (status, \"too many arguments for format\");\n-  if (res.number_dollar_extra_args > 0 && res.number_non_literal == 0\n-      && res.number_other == 0 && warn_format_extra_args)\n-    status_warning (status, \"unused arguments in $-style format\");\n-  if (res.number_empty > 0 && res.number_non_literal == 0\n-      && res.number_other == 0)\n-    status_warning (status, \"zero-length format string\");\n-\n-  if (res.number_wide > 0)\n-    status_warning (status, \"format is a wide character string\");\n-\n-  if (res.number_unterminated > 0)\n-    status_warning (status, \"unterminated format string\");\n-}\n-\n-\n-/* Recursively check a call to a format function.  FORMAT_TREE is the\n-   format parameter, which may be a conditional expression in which\n-   both halves should be checked.  ARG_NUM is the number of the\n-   format argument; PARAMS points just after it in the argument list.  */\n-\n-static void\n-check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n-     int *status;\n-     format_check_results *res;\n-     function_format_info *info;\n-     tree format_tree;\n-     tree params;\n-     int arg_num;\n-{\n-  int format_length;\n-  const char *format_chars;\n-  tree array_size = 0;\n-  tree array_init;\n-\n-  if (TREE_CODE (format_tree) == NOP_EXPR)\n-    {\n-      /* Strip coercion.  */\n-      check_format_info_recurse (status, res, info,\n-\t\t\t\t TREE_OPERAND (format_tree, 0), params,\n-\t\t\t\t arg_num);\n-      return;\n-    }\n-\n-  if (TREE_CODE (format_tree) == CALL_EXPR\n-      && TREE_CODE (TREE_OPERAND (format_tree, 0)) == ADDR_EXPR\n-      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (format_tree, 0), 0))\n-\t  == FUNCTION_DECL))\n-    {\n-      tree function = TREE_OPERAND (TREE_OPERAND (format_tree, 0), 0);\n-\n-      /* See if this is a call to a known internationalization function\n-\t that modifies the format arg.  */\n-      international_format_info *iinfo;\n-\n-      for (iinfo = international_format_list; iinfo; iinfo = iinfo->next)\n-\tif (iinfo->assembler_name\n-\t    ? (iinfo->assembler_name == DECL_ASSEMBLER_NAME (function))\n-\t    : (iinfo->name == DECL_NAME (function)))\n-\t  {\n-\t    tree inner_args;\n-\t    int i;\n-\n-\t    for (inner_args = TREE_OPERAND (format_tree, 1), i = 1;\n-\t\t inner_args != 0;\n-\t\t inner_args = TREE_CHAIN (inner_args), i++)\n-\t      if (i == iinfo->format_num)\n-\t\t{\n-\t\t  /* FIXME: with Marc Espie's __attribute__((nonnull))\n-\t\t     patch in GCC, we will have chained attributes,\n-\t\t     and be able to handle functions like ngettext\n-\t\t     with multiple format_arg attributes properly.  */\n-\t\t  check_format_info_recurse (status, res, info,\n-\t\t\t\t\t     TREE_VALUE (inner_args), params,\n-\t\t\t\t\t     arg_num);\n-\t\t  return;\n-\t\t}\n-\t  }\n-    }\n-\n-  if (TREE_CODE (format_tree) == COND_EXPR)\n-    {\n-      /* Check both halves of the conditional expression.  */\n-      check_format_info_recurse (status, res, info,\n-\t\t\t\t TREE_OPERAND (format_tree, 1), params,\n-\t\t\t\t arg_num);\n-      check_format_info_recurse (status, res, info,\n-\t\t\t\t TREE_OPERAND (format_tree, 2), params,\n-\t\t\t\t arg_num);\n-      return;\n-    }\n-\n-  if (integer_zerop (format_tree))\n-    {\n-      /* FIXME: this warning should go away once Marc Espie's\n-\t __attribute__((nonnull)) patch is in.  Instead, checking for\n-\t nonnull attributes should probably change this function to act\n-\t specially if info == NULL and add a res->number_null entry for\n-\t that case, or maybe add a function pointer to be called at\n-\t the end instead of hardcoding check_format_info_main.  */\n-      status_warning (status, \"null format string\");\n-\n-      /* Skip to first argument to check, so we can see if this format\n-\t has any arguments (it shouldn't).  */\n-      while (arg_num + 1 < info->first_arg_num)\n-\t{\n-\t  if (params == 0)\n-\t    return;\n-\t  params = TREE_CHAIN (params);\n-\t  ++arg_num;\n-\t}\n-\n-      if (params == 0)\n-\tres->number_other++;\n-      else\n-\tres->number_extra_args++;\n-\n-      return;\n-    }\n-\n-  if (TREE_CODE (format_tree) != ADDR_EXPR)\n-    {\n-      res->number_non_literal++;\n-      return;\n-    }\n-  format_tree = TREE_OPERAND (format_tree, 0);\n-  if (TREE_CODE (format_tree) == VAR_DECL\n-      && TREE_CODE (TREE_TYPE (format_tree)) == ARRAY_TYPE\n-      && (array_init = decl_constant_value (format_tree)) != format_tree\n-      && TREE_CODE (array_init) == STRING_CST)\n-    {\n-      /* Extract the string constant initializer.  Note that this may include\n-\t a trailing NUL character that is not in the array (e.g.\n-\t const char a[3] = \"foo\";).  */\n-      array_size = DECL_SIZE_UNIT (format_tree);\n-      format_tree = array_init;\n-    }\n-  if (TREE_CODE (format_tree) != STRING_CST)\n-    {\n-      res->number_non_literal++;\n-      return;\n-    }\n-  if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (format_tree))) != char_type_node)\n-    {\n-      res->number_wide++;\n-      return;\n-    }\n-  format_chars = TREE_STRING_POINTER (format_tree);\n-  format_length = TREE_STRING_LENGTH (format_tree);\n-  if (array_size != 0)\n-    {\n-      /* Variable length arrays can't be initialized.  */\n-      if (TREE_CODE (array_size) != INTEGER_CST)\n-\tabort ();\n-      if (host_integerp (array_size, 0))\n-\t{\n-\t  HOST_WIDE_INT array_size_value = TREE_INT_CST_LOW (array_size);\n-\t  if (array_size_value > 0\n-\t      && array_size_value == (int) array_size_value\n-\t      && format_length > array_size_value)\n-\t    format_length = array_size_value;\n-\t}\n-    }\n-  if (format_length < 1)\n-    {\n-      res->number_unterminated++;\n-      return;\n-    }\n-  if (format_length == 1)\n-    {\n-      res->number_empty++;\n-      return;\n-    }\n-  if (format_chars[--format_length] != 0)\n-    {\n-      res->number_unterminated++;\n-      return;\n-    }\n-\n-  /* Skip to first argument to check.  */\n-  while (arg_num + 1 < info->first_arg_num)\n-    {\n-      if (params == 0)\n-\treturn;\n-      params = TREE_CHAIN (params);\n-      ++arg_num;\n-    }\n-  /* Provisionally increment res->number_other; check_format_info_main\n-     will decrement it if it finds there are extra arguments, but this way\n-     need not adjust it for every return.  */\n-  res->number_other++;\n-  check_format_info_main (status, res, info, format_chars, format_length,\n-\t\t\t  params, arg_num);\n-}\n-\n-\n-/* Do the main part of checking a call to a format function.  FORMAT_CHARS\n-   is the NUL-terminated format string (which at this point may contain\n-   internal NUL characters); FORMAT_LENGTH is its length (excluding the\n-   terminating NUL character).  ARG_NUM is one less than the number of\n-   the first format argument to check; PARAMS points to that format\n-   argument in the list of arguments.  */\n-\n-static void\n-check_format_info_main (status, res, info, format_chars, format_length,\n-\t\t\tparams, arg_num)\n-     int *status;\n-     format_check_results *res;\n-     function_format_info *info;\n-     const char *format_chars;\n-     int format_length;\n-     tree params;\n-     int arg_num;\n-{\n-  const char *orig_format_chars = format_chars;\n-  tree first_fillin_param = params;\n-\n-  const format_kind_info *fki = &format_types[info->format_type];\n-  const format_flag_spec *flag_specs = fki->flag_specs;\n-  const format_flag_pair *bad_flag_pairs = fki->bad_flag_pairs;\n-\n-  /* -1 if no conversions taking an operand have been found; 0 if one has\n-     and it didn't use $; 1 if $ formats are in use.  */\n-  int has_operand_number = -1;\n-\n-  init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n-\n-  while (1)\n-    {\n-      int i;\n-      int suppressed = FALSE;\n-      const char *length_chars = NULL;\n-      enum format_lengths length_chars_val = FMT_LEN_none;\n-      enum format_std_version length_chars_std = STD_C89;\n-      int format_char;\n-      tree cur_param;\n-      tree wanted_type;\n-      int main_arg_num = 0;\n-      tree main_arg_params = 0;\n-      enum format_std_version wanted_type_std;\n-      const char *wanted_type_name;\n-      format_wanted_type width_wanted_type;\n-      format_wanted_type precision_wanted_type;\n-      format_wanted_type main_wanted_type;\n-      format_wanted_type *first_wanted_type = NULL;\n-      format_wanted_type *last_wanted_type = NULL;\n-      const format_length_info *fli = NULL;\n-      const format_char_info *fci = NULL;\n-      char flag_chars[256];\n-      int aflag = 0;\n-      if (*format_chars == 0)\n-\t{\n-\t  if (format_chars - orig_format_chars != format_length)\n-\t    status_warning (status, \"embedded `\\\\0' in format\");\n-\t  if (info->first_arg_num != 0 && params != 0\n-\t      && has_operand_number <= 0)\n-\t    {\n-\t      res->number_other--;\n-\t      res->number_extra_args++;\n-\t    }\n-\t  if (has_operand_number > 0)\n-\t    finish_dollar_format_checking (status, res);\n-\t  return;\n-\t}\n-      if (*format_chars++ != '%')\n-\tcontinue;\n-      if (*format_chars == 0)\n-\t{\n-\t  status_warning (status, \"spurious trailing `%%' in format\");\n-\t  continue;\n-\t}\n-      if (*format_chars == '%')\n-\t{\n-\t  ++format_chars;\n-\t  continue;\n-\t}\n-      flag_chars[0] = 0;\n-\n-      if ((fki->flags & FMT_FLAG_USE_DOLLAR) && has_operand_number != 0)\n-\t{\n-\t  /* Possibly read a $ operand number at the start of the format.\n-\t     If one was previously used, one is required here.  If one\n-\t     is not used here, we can't immediately conclude this is a\n-\t     format without them, since it could be printf %m or scanf %*.  */\n-\t  int opnum;\n-\t  opnum = maybe_read_dollar_number (status, &format_chars, 0,\n-\t\t\t\t\t    first_fillin_param,\n-\t\t\t\t\t    &main_arg_params, fki);\n-\t  if (opnum == -1)\n-\t    return;\n-\t  else if (opnum > 0)\n-\t    {\n-\t      has_operand_number = 1;\n-\t      main_arg_num = opnum + info->first_arg_num - 1;\n-\t    }\n-\t}\n-\n-      /* Read any format flags, but do not yet validate them beyond removing\n-\t duplicates, since in general validation depends on the rest of\n-\t the format.  */\n-      while (*format_chars != 0\n-\t     && strchr (fki->flag_chars, *format_chars) != 0)\n-\t{\n-\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n-\t\t\t\t\t\t     *format_chars, NULL);\n-\t  if (strchr (flag_chars, *format_chars) != 0)\n-\t    {\n-\t      status_warning (status, \"repeated %s in format\", _(s->name));\n-\t    }\n-\t  else\n-\t    {\n-\t      i = strlen (flag_chars);\n-\t      flag_chars[i++] = *format_chars;\n-\t      flag_chars[i] = 0;\n-\t    }\n-\t  if (s->skip_next_char)\n-\t    {\n-\t      ++format_chars;\n-\t      if (*format_chars == 0)\n-\t\t{\n-\t\t  status_warning (status, \"missing fill character at end of strfmon format\");\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  ++format_chars;\n-\t}\n-\n-      /* Read any format width, possibly * or *m$.  */\n-      if (fki->width_char != 0)\n-\t{\n-\t  if (fki->width_type != NULL && *format_chars == '*')\n-\t    {\n-\t      i = strlen (flag_chars);\n-\t      flag_chars[i++] = fki->width_char;\n-\t      flag_chars[i] = 0;\n-\t      /* \"...a field width...may be indicated by an asterisk.\n-\t\t In this case, an int argument supplies the field width...\"  */\n-\t      ++format_chars;\n-\t      if (params == 0)\n-\t\t{\n-\t\t  status_warning (status, \"too few arguments for format\");\n-\t\t  return;\n-\t\t}\n-\t      if (has_operand_number != 0)\n-\t\t{\n-\t\t  int opnum;\n-\t\t  opnum = maybe_read_dollar_number (status, &format_chars,\n-\t\t\t\t\t\t    has_operand_number == 1,\n-\t\t\t\t\t\t    first_fillin_param,\n-\t\t\t\t\t\t    &params, fki);\n-\t\t  if (opnum == -1)\n-\t\t    return;\n-\t\t  else if (opnum > 0)\n-\t\t    {\n-\t\t      has_operand_number = 1;\n-\t\t      arg_num = opnum + info->first_arg_num - 1;\n-\t\t    }\n-\t\t  else\n-\t\t    has_operand_number = 0;\n-\t\t}\n-\t      if (info->first_arg_num != 0)\n-\t\t{\n-\t\t  cur_param = TREE_VALUE (params);\n-\t\t  if (has_operand_number <= 0)\n-\t\t    {\n-\t\t      params = TREE_CHAIN (params);\n-\t\t      ++arg_num;\n-\t\t    }\n-\t\t  width_wanted_type.wanted_type = *fki->width_type;\n-\t\t  width_wanted_type.wanted_type_name = NULL;\n-\t\t  width_wanted_type.pointer_count = 0;\n-\t\t  width_wanted_type.char_lenient_flag = 0;\n-\t\t  width_wanted_type.writing_in_flag = 0;\n-\t\t  width_wanted_type.reading_from_flag = 0;\n-\t\t  width_wanted_type.name = _(\"field width\");\n-\t\t  width_wanted_type.param = cur_param;\n-\t\t  width_wanted_type.arg_num = arg_num;\n-\t\t  width_wanted_type.next = NULL;\n-\t\t  if (last_wanted_type != 0)\n-\t\t    last_wanted_type->next = &width_wanted_type;\n-\t\t  if (first_wanted_type == 0)\n-\t\t    first_wanted_type = &width_wanted_type;\n-\t\t  last_wanted_type = &width_wanted_type;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Possibly read a numeric width.  If the width is zero,\n-\t\t we complain if appropriate.  */\n-\t      int non_zero_width_char = FALSE;\n-\t      int found_width = FALSE;\n-\t      while (ISDIGIT (*format_chars))\n-\t\t{\n-\t\t  found_width = TRUE;\n-\t\t  if (*format_chars != '0')\n-\t\t    non_zero_width_char = TRUE;\n-\t\t  ++format_chars;\n-\t\t}\n-\t      if (found_width && !non_zero_width_char &&\n-\t\t  (fki->flags & FMT_FLAG_ZERO_WIDTH_BAD))\n-\t\tstatus_warning (status, \"zero width in %s format\",\n-\t\t\t\tfki->name);\n-\t      if (found_width)\n-\t\t{\n-\t\t  i = strlen (flag_chars);\n-\t\t  flag_chars[i++] = fki->width_char;\n-\t\t  flag_chars[i] = 0;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Read any format left precision (must be a number, not *).  */\n-      if (fki->left_precision_char != 0 && *format_chars == '#')\n-\t{\n-\t  ++format_chars;\n-\t  i = strlen (flag_chars);\n-\t  flag_chars[i++] = fki->left_precision_char;\n-\t  flag_chars[i] = 0;\n-\t  if (!ISDIGIT (*format_chars))\n-\t    status_warning (status, \"empty left precision in %s format\",\n-\t\t\t    fki->name);\n-\t  while (ISDIGIT (*format_chars))\n-\t    ++format_chars;\n-\t}\n-\n-      /* Read any format precision, possibly * or *m$.  */\n-      if (fki->precision_char != 0 && *format_chars == '.')\n-\t{\n-\t  ++format_chars;\n-\t  i = strlen (flag_chars);\n-\t  flag_chars[i++] = fki->precision_char;\n-\t  flag_chars[i] = 0;\n-\t  if (fki->precision_type != NULL && *format_chars == '*')\n-\t    {\n-\t      /* \"...a...precision...may be indicated by an asterisk.\n-\t\t In this case, an int argument supplies the...precision.\"  */\n-\t      ++format_chars;\n-\t      if (has_operand_number != 0)\n-\t\t{\n-\t\t  int opnum;\n-\t\t  opnum = maybe_read_dollar_number (status, &format_chars,\n-\t\t\t\t\t\t    has_operand_number == 1,\n-\t\t\t\t\t\t    first_fillin_param,\n-\t\t\t\t\t\t    &params, fki);\n-\t\t  if (opnum == -1)\n-\t\t    return;\n-\t\t  else if (opnum > 0)\n-\t\t    {\n-\t\t      has_operand_number = 1;\n-\t\t      arg_num = opnum + info->first_arg_num - 1;\n-\t\t    }\n-\t\t  else\n-\t\t    has_operand_number = 0;\n-\t\t}\n-\t      if (info->first_arg_num != 0)\n-\t\t{\n-\t\t  if (params == 0)\n-\t\t    {\n-\t\t      status_warning (status, \"too few arguments for format\");\n-\t\t      return;\n-\t\t    }\n-\t\t  cur_param = TREE_VALUE (params);\n-\t\t  if (has_operand_number <= 0)\n-\t\t    {\n-\t\t      params = TREE_CHAIN (params);\n-\t\t      ++arg_num;\n-\t\t    }\n-\t\t  precision_wanted_type.wanted_type = *fki->precision_type;\n-\t\t  precision_wanted_type.wanted_type_name = NULL;\n-\t\t  precision_wanted_type.pointer_count = 0;\n-\t\t  precision_wanted_type.char_lenient_flag = 0;\n-\t\t  precision_wanted_type.writing_in_flag = 0;\n-\t\t  precision_wanted_type.reading_from_flag = 0;\n-\t\t  precision_wanted_type.name = _(\"field precision\");\n-\t\t  precision_wanted_type.param = cur_param;\n-\t\t  precision_wanted_type.arg_num = arg_num;\n-\t\t  precision_wanted_type.next = NULL;\n-\t\t  if (last_wanted_type != 0)\n-\t\t    last_wanted_type->next = &precision_wanted_type;\n-\t\t  if (first_wanted_type == 0)\n-\t\t    first_wanted_type = &precision_wanted_type;\n-\t\t  last_wanted_type = &precision_wanted_type;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (!(fki->flags & FMT_FLAG_EMPTY_PREC_OK)\n-\t\t  && !ISDIGIT (*format_chars))\n-\t\tstatus_warning (status, \"empty precision in %s format\",\n-\t\t\t\tfki->name);\n-\t      while (ISDIGIT (*format_chars))\n-\t\t++format_chars;\n-\t    }\n-\t}\n-\n-      /* Read any length modifier, if this kind of format has them.  */\n-      fli = fki->length_char_specs;\n-      length_chars = NULL;\n-      length_chars_val = FMT_LEN_none;\n-      length_chars_std = STD_C89;\n-      if (fli)\n-\t{\n-\t  while (fli->name != 0 && fli->name[0] != *format_chars)\n-\t    fli++;\n-\t  if (fli->name != 0)\n-\t    {\n-\t      format_chars++;\n-\t      if (fli->double_name != 0 && fli->name[0] == *format_chars)\n-\t\t{\n-\t\t  format_chars++;\n-\t\t  length_chars = fli->double_name;\n-\t\t  length_chars_val = fli->double_index;\n-\t\t  length_chars_std = fli->double_std;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  length_chars = fli->name;\n-\t\t  length_chars_val = fli->index;\n-\t\t  length_chars_std = fli->std;\n-\t\t}\n-\t      i = strlen (flag_chars);\n-\t      flag_chars[i++] = fki->length_code_char;\n-\t      flag_chars[i] = 0;\n-\t    }\n-\t  if (pedantic)\n-\t    {\n-\t      /* Warn if the length modifier is non-standard.  */\n-\t      if (ADJ_STD (length_chars_std) > C_STD_VER)\n-\t\tstatus_warning (status, \"%s does not support the `%s' %s length modifier\",\n-\t\t\t\tC_STD_NAME (length_chars_std), length_chars,\n-\t\t\t\tfki->name);\n-\t    }\n-\t}\n-\n-      /* Read any modifier (strftime E/O).  */\n-      if (fki->modifier_chars != NULL)\n-\t{\n-\t  while (*format_chars != 0\n-\t\t && strchr (fki->modifier_chars, *format_chars) != 0)\n-\t    {\n-\t      if (strchr (flag_chars, *format_chars) != 0)\n-\t\t{\n-\t\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n-\t\t\t\t\t\t\t     *format_chars, NULL);\n-\t\t  status_warning (status, \"repeated %s in format\", _(s->name));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  i = strlen (flag_chars);\n-\t\t  flag_chars[i++] = *format_chars;\n-\t\t  flag_chars[i] = 0;\n-\t\t}\n-\t      ++format_chars;\n-\t    }\n-\t}\n-\n-      /* Handle the scanf allocation kludge.  */\n-      if (fki->flags & FMT_FLAG_SCANF_A_KLUDGE)\n-\t{\n-\t  if (*format_chars == 'a' && !flag_isoc99)\n-\t    {\n-\t      if (format_chars[1] == 's' || format_chars[1] == 'S'\n-\t\t  || format_chars[1] == '[')\n-\t\t{\n-\t\t  /* `a' is used as a flag.  */\n-\t\t  i = strlen (flag_chars);\n-\t\t  flag_chars[i++] = 'a';\n-\t\t  flag_chars[i] = 0;\n-\t\t  format_chars++;\n-\t\t}\n-\t    }\n-\t}\n-\n-      format_char = *format_chars;\n-      if (format_char == 0\n-\t  || (!(fki->flags & FMT_FLAG_FANCY_PERCENT_OK) && format_char == '%'))\n-\t{\n-\t  status_warning (status, \"conversion lacks type at end of format\");\n-\t  continue;\n-\t}\n-      format_chars++;\n-      fci = fki->conversion_specs;\n-      while (fci->format_chars != 0\n-\t     && strchr (fci->format_chars, format_char) == 0)\n-\t  ++fci;\n-      if (fci->format_chars == 0)\n-\t{\n-          if (ISGRAPH(format_char))\n-\t    status_warning (status, \"unknown conversion type character `%c' in format\",\n-\t\t     format_char);\n-\t  else\n-\t    status_warning (status, \"unknown conversion type character 0x%x in format\",\n-\t\t     format_char);\n-\t  continue;\n-\t}\n-      if (pedantic)\n-\t{\n-\t  if (ADJ_STD (fci->std) > C_STD_VER)\n-\t    status_warning (status, \"%s does not support the `%%%c' %s format\",\n-\t\t\t    C_STD_NAME (fci->std), format_char, fki->name);\n-\t}\n-\n-      /* Validate the individual flags used, removing any that are invalid.  */\n-      {\n-\tint d = 0;\n-\tfor (i = 0; flag_chars[i] != 0; i++)\n-\t  {\n-\t    const format_flag_spec *s = get_flag_spec (flag_specs,\n-\t\t\t\t\t\t       flag_chars[i], NULL);\n-\t    flag_chars[i - d] = flag_chars[i];\n-\t    if (flag_chars[i] == fki->length_code_char)\n-\t      continue;\n-\t    if (strchr (fci->flag_chars, flag_chars[i]) == 0)\n-\t      {\n-\t\tstatus_warning (status, \"%s used with `%%%c' %s format\",\n-\t\t\t\t_(s->name), format_char, fki->name);\n-\t\td++;\n-\t\tcontinue;\n-\t      }\n-\t    if (pedantic)\n-\t      {\n-\t\tconst format_flag_spec *t;\n-\t\tif (ADJ_STD (s->std) > C_STD_VER)\n-\t\t  status_warning (status, \"%s does not support %s\",\n-\t\t\t\t  C_STD_NAME (s->std), _(s->long_name));\n-\t\tt = get_flag_spec (flag_specs, flag_chars[i], fci->flags2);\n-\t\tif (t != NULL && ADJ_STD (t->std) > ADJ_STD (s->std))\n-\t\t  {\n-\t\t    const char *long_name = (t->long_name != NULL\n-\t\t\t\t\t     ? t->long_name\n-\t\t\t\t\t     : s->long_name);\n-\t\t    if (ADJ_STD (t->std) > C_STD_VER)\n-\t\t      status_warning (status, \"%s does not support %s with the `%%%c' %s format\",\n-\t\t\t\t      C_STD_NAME (t->std), _(long_name),\n-\t\t\t\t      format_char, fki->name);\n-\t\t  }\n-\t      }\n-\t  }\n-\tflag_chars[i - d] = 0;\n-      }\n-\n-      if ((fki->flags & FMT_FLAG_SCANF_A_KLUDGE)\n-\t  && strchr (flag_chars, 'a') != 0)\n-\taflag = 1;\n-\n-      if (fki->suppression_char\n-\t  && strchr (flag_chars, fki->suppression_char) != 0)\n-\tsuppressed = 1;\n-\n-      /* Validate the pairs of flags used.  */\n-      for (i = 0; bad_flag_pairs[i].flag_char1 != 0; i++)\n-\t{\n-\t  const format_flag_spec *s, *t;\n-\t  if (strchr (flag_chars, bad_flag_pairs[i].flag_char1) == 0)\n-\t    continue;\n-\t  if (strchr (flag_chars, bad_flag_pairs[i].flag_char2) == 0)\n-\t    continue;\n-\t  if (bad_flag_pairs[i].predicate != 0\n-\t      && strchr (fci->flags2, bad_flag_pairs[i].predicate) == 0)\n-\t    continue;\n-\t  s = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char1, NULL);\n-\t  t = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char2, NULL);\n-\t  if (bad_flag_pairs[i].ignored)\n-\t    {\n-\t      if (bad_flag_pairs[i].predicate != 0)\n-\t\tstatus_warning (status, \"%s ignored with %s and `%%%c' %s format\",\n-\t\t\t\t_(s->name), _(t->name), format_char,\n-\t\t\t\tfki->name);\n-\t      else\n-\t\tstatus_warning (status, \"%s ignored with %s in %s format\",\n-\t\t\t\t_(s->name), _(t->name), fki->name);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (bad_flag_pairs[i].predicate != 0)\n-\t\tstatus_warning (status, \"use of %s and %s together with `%%%c' %s format\",\n-\t\t\t\t_(s->name), _(t->name), format_char,\n-\t\t\t\tfki->name);\n-\t      else\n-\t\tstatus_warning (status, \"use of %s and %s together in %s format\",\n-\t\t\t\t_(s->name), _(t->name), fki->name);\n-\t    }\n-\t}\n-\n-      /* Give Y2K warnings.  */\n-      if (warn_format_y2k)\n-\t{\n-\t  int y2k_level = 0;\n-\t  if (strchr (fci->flags2, '4') != 0)\n-\t    if (strchr (flag_chars, 'E') != 0)\n-\t      y2k_level = 3;\n-\t    else\n-\t      y2k_level = 2;\n-\t  else if (strchr (fci->flags2, '3') != 0)\n-\t    y2k_level = 3;\n-\t  else if (strchr (fci->flags2, '2') != 0)\n-\t    y2k_level = 2;\n-\t  if (y2k_level == 3)\n-\t    status_warning (status, \"`%%%c' yields only last 2 digits of year in some locales\",\n-\t\t\t    format_char);\n-\t  else if (y2k_level == 2)\n-\t    status_warning (status, \"`%%%c' yields only last 2 digits of year\", format_char);\n-\t}\n-\n-      if (strchr (fci->flags2, '[') != 0)\n-\t{\n-\t  /* Skip over scan set, in case it happens to have '%' in it.  */\n-\t  if (*format_chars == '^')\n-\t    ++format_chars;\n-\t  /* Find closing bracket; if one is hit immediately, then\n-\t     it's part of the scan set rather than a terminator.  */\n-\t  if (*format_chars == ']')\n-\t    ++format_chars;\n-\t  while (*format_chars && *format_chars != ']')\n-\t    ++format_chars;\n-\t  if (*format_chars != ']')\n-\t    /* The end of the format string was reached.  */\n-\t    status_warning (status, \"no closing `]' for `%%[' format\");\n-\t}\n-\n-      wanted_type = 0;\n-      wanted_type_name = 0;\n-      if (fki->flags & FMT_FLAG_ARG_CONVERT)\n-\t{\n-\t  wanted_type = (fci->types[length_chars_val].type\n-\t\t\t ? *fci->types[length_chars_val].type : 0);\n-\t  wanted_type_name = fci->types[length_chars_val].name;\n-\t  wanted_type_std = fci->types[length_chars_val].std;\n-\t  if (wanted_type == 0)\n-\t    {\n-\t      status_warning (status, \"use of `%s' length modifier with `%c' type character\",\n-\t\t\t      length_chars, format_char);\n-\t      /* Heuristic: skip one argument when an invalid length/type\n-\t\t combination is encountered.  */\n-\t      arg_num++;\n-\t      if (params == 0)\n-\t\t{\n-\t\t  status_warning (status, \"too few arguments for format\");\n-\t\t  return;\n-\t\t}\n-\t      params = TREE_CHAIN (params);\n-\t      continue;\n-\t    }\n-\t  else if (pedantic\n-\t\t   /* Warn if non-standard, provided it is more non-standard\n-\t\t      than the length and type characters that may already\n-\t\t      have been warned for.  */\n-\t\t   && ADJ_STD (wanted_type_std) > ADJ_STD (length_chars_std)\n-\t\t   && ADJ_STD (wanted_type_std) > ADJ_STD (fci->std))\n-\t    {\n-\t      if (ADJ_STD (wanted_type_std) > C_STD_VER)\n-\t\tstatus_warning (status, \"%s does not support the `%%%s%c' %s format\",\n-\t\t\t\tC_STD_NAME (wanted_type_std), length_chars,\n-\t\t\t\tformat_char, fki->name);\n-\t    }\n-\t}\n-\n-      /* Finally. . .check type of argument against desired type!  */\n-      if (info->first_arg_num == 0)\n-\tcontinue;\n-      if ((fci->pointer_count == 0 && wanted_type == void_type_node)\n-\t  || suppressed)\n-\t{\n-\t  if (main_arg_num != 0)\n-\t    {\n-\t      if (suppressed)\n-\t\tstatus_warning (status, \"operand number specified with suppressed assignment\");\n-\t      else\n-\t\tstatus_warning (status, \"operand number specified for format taking no argument\");\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (main_arg_num != 0)\n-\t    {\n-\t      arg_num = main_arg_num;\n-\t      params = main_arg_params;\n-\t    }\n-\t  else\n-\t    {\n-\t      ++arg_num;\n-\t      if (has_operand_number > 0)\n-\t\t{\n-\t\t  status_warning (status, \"missing $ operand number in format\");\n-\t\t  return;\n-\t\t}\n-\t      else\n-\t\thas_operand_number = 0;\n-\t      if (params == 0)\n-\t\t{\n-\t\t  status_warning (status, \"too few arguments for format\");\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  cur_param = TREE_VALUE (params);\n-\t  params = TREE_CHAIN (params);\n-\t  main_wanted_type.wanted_type = wanted_type;\n-\t  main_wanted_type.wanted_type_name = wanted_type_name;\n-\t  main_wanted_type.pointer_count = fci->pointer_count + aflag;\n-\t  main_wanted_type.char_lenient_flag = 0;\n-\t  if (strchr (fci->flags2, 'c') != 0)\n-\t    main_wanted_type.char_lenient_flag = 1;\n-\t  main_wanted_type.writing_in_flag = 0;\n-\t  main_wanted_type.reading_from_flag = 0;\n-\t  if (aflag)\n-\t    main_wanted_type.writing_in_flag = 1;\n-\t  else\n-\t    {\n-\t      if (strchr (fci->flags2, 'W') != 0)\n-\t\tmain_wanted_type.writing_in_flag = 1;\n-\t      if (strchr (fci->flags2, 'R') != 0)\n-\t\tmain_wanted_type.reading_from_flag = 1;\n-\t    }\n-\t  main_wanted_type.name = NULL;\n-\t  main_wanted_type.param = cur_param;\n-\t  main_wanted_type.arg_num = arg_num;\n-\t  main_wanted_type.next = NULL;\n-\t  if (last_wanted_type != 0)\n-\t    last_wanted_type->next = &main_wanted_type;\n-\t  if (first_wanted_type == 0)\n-\t    first_wanted_type = &main_wanted_type;\n-\t  last_wanted_type = &main_wanted_type;\n-\t}\n-\n-      if (first_wanted_type != 0)\n-\tcheck_format_types (status, first_wanted_type);\n-\n-    }\n-}\n-\n-\n-/* Check the argument types from a single format conversion (possibly\n-   including width and precision arguments).  */\n-static void\n-check_format_types (status, types)\n-     int *status;\n-     format_wanted_type *types;\n-{\n-  for (; types != 0; types = types->next)\n-    {\n-      tree cur_param;\n-      tree cur_type;\n-      tree orig_cur_type;\n-      tree wanted_type;\n-      tree promoted_type;\n-      int arg_num;\n-      int i;\n-      int char_type_flag;\n-      cur_param = types->param;\n-      cur_type = TREE_TYPE (cur_param);\n-      if (cur_type == error_mark_node)\n-\tcontinue;\n-      char_type_flag = 0;\n-      wanted_type = types->wanted_type;\n-      arg_num = types->arg_num;\n-\n-      /* The following should not occur here.  */\n-      if (wanted_type == 0)\n-\tabort ();\n-      if (wanted_type == void_type_node && types->pointer_count == 0)\n-\tabort ();\n-\n-      if (types->pointer_count == 0)\n-\t{\n-\t  promoted_type = simple_type_promotes_to (wanted_type);\n-\t  if (promoted_type != NULL_TREE)\n-\t    wanted_type = promoted_type;\n-\t}\n-\n-      STRIP_NOPS (cur_param);\n-\n-      /* Check the types of any additional pointer arguments\n-\t that precede the \"real\" argument.  */\n-      for (i = 0; i < types->pointer_count; ++i)\n-\t{\n-\t  if (TREE_CODE (cur_type) == POINTER_TYPE)\n-\t    {\n-\t      cur_type = TREE_TYPE (cur_type);\n-\t      if (cur_type == error_mark_node)\n-\t\tbreak;\n-\n-\t      /* Check for writing through a NULL pointer.  */\n-\t      if (types->writing_in_flag\n-\t\t  && i == 0\n-\t\t  && cur_param != 0\n-\t\t  && integer_zerop (cur_param))\n-\t\tstatus_warning (status,\n-\t\t\t\t\"writing through null pointer (arg %d)\",\n-\t\t\t\targ_num);\n-\n-\t      /* Check for reading through a NULL pointer.  */\n-\t      if (types->reading_from_flag\n-\t\t  && i == 0\n-\t\t  && cur_param != 0\n-\t\t  && integer_zerop (cur_param))\n-\t\tstatus_warning (status,\n-\t\t\t\t\"reading through null pointer (arg %d)\",\n-\t\t\t\targ_num);\n-\n-\t      if (cur_param != 0 && TREE_CODE (cur_param) == ADDR_EXPR)\n-\t\tcur_param = TREE_OPERAND (cur_param, 0);\n-\t      else\n-\t\tcur_param = 0;\n-\n-\t      /* See if this is an attempt to write into a const type with\n-\t\t scanf or with printf \"%n\".  Note: the writing in happens\n-\t\t at the first indirection only, if for example\n-\t\t void * const * is passed to scanf %p; passing\n-\t\t const void ** is simply passing an incompatible type.  */\n-\t      if (types->writing_in_flag\n-\t\t  && i == 0\n-\t\t  && (TYPE_READONLY (cur_type)\n-\t\t      || (cur_param != 0\n-\t\t\t  && (TREE_CODE_CLASS (TREE_CODE (cur_param)) == 'c'\n-\t\t\t      || (DECL_P (cur_param)\n-\t\t\t\t  && TREE_READONLY (cur_param))))))\n-\t\tstatus_warning (status, \"writing into constant object (arg %d)\", arg_num);\n-\n-\t      /* If there are extra type qualifiers beyond the first\n-\t\t indirection, then this makes the types technically\n-\t\t incompatible.  */\n-\t      if (i > 0\n-\t\t  && pedantic\n-\t\t  && (TYPE_READONLY (cur_type)\n-\t\t      || TYPE_VOLATILE (cur_type)\n-\t\t      || TYPE_RESTRICT (cur_type)))\n-\t\tstatus_warning (status, \"extra type qualifiers in format argument (arg %d)\",\n-\t\t\t arg_num);\n-\n-\t    }\n-\t  else\n-\t    {\n-\t      if (types->pointer_count == 1)\n-\t\tstatus_warning (status, \"format argument is not a pointer (arg %d)\", arg_num);\n-\t      else\n-\t\tstatus_warning (status, \"format argument is not a pointer to a pointer (arg %d)\", arg_num);\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (i < types->pointer_count)\n-\tcontinue;\n-\n-      orig_cur_type = cur_type;\n-      cur_type = TYPE_MAIN_VARIANT (cur_type);\n-\n-      /* Check whether the argument type is a character type.  This leniency\n-\t only applies to certain formats, flagged with 'c'.\n-      */\n-      if (types->char_lenient_flag)\n-\tchar_type_flag = (cur_type == char_type_node\n-\t\t\t  || cur_type == signed_char_type_node\n-\t\t\t  || cur_type == unsigned_char_type_node);\n-\n-      /* Check the type of the \"real\" argument, if there's a type we want.  */\n-      if (wanted_type == cur_type)\n-\tcontinue;\n-      /* If we want `void *', allow any pointer type.\n-\t (Anything else would already have got a warning.)\n-\t With -pedantic, only allow pointers to void and to character\n-\t types.  */\n-      if (wanted_type == void_type_node\n-\t  && (!pedantic || (i == 1 && char_type_flag)))\n-\tcontinue;\n-      /* Don't warn about differences merely in signedness, unless\n-\t -pedantic.  With -pedantic, warn if the type is a pointer\n-\t target and not a character type, and for character types at\n-\t a second level of indirection.  */\n-      if (TREE_CODE (wanted_type) == INTEGER_TYPE\n-\t  && TREE_CODE (cur_type) == INTEGER_TYPE\n-\t  && (! pedantic || i == 0 || (i == 1 && char_type_flag))\n-\t  && (TREE_UNSIGNED (wanted_type)\n-\t      ? wanted_type == unsigned_type (cur_type)\n-\t      : wanted_type == signed_type (cur_type)))\n-\tcontinue;\n-      /* Likewise, \"signed char\", \"unsigned char\" and \"char\" are\n-\t equivalent but the above test won't consider them equivalent.  */\n-      if (wanted_type == char_type_node\n-\t  && (! pedantic || i < 2)\n-\t  && char_type_flag)\n-\tcontinue;\n-      /* Now we have a type mismatch.  */\n-      {\n-\tregister const char *this;\n-\tregister const char *that;\n-\n-\tthis = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n-\tthat = 0;\n-\tif (TYPE_NAME (orig_cur_type) != 0\n-\t    && TREE_CODE (orig_cur_type) != INTEGER_TYPE\n-\t    && !(TREE_CODE (orig_cur_type) == POINTER_TYPE\n-\t\t && TREE_CODE (TREE_TYPE (orig_cur_type)) == INTEGER_TYPE))\n-\t  {\n-\t    if (TREE_CODE (TYPE_NAME (orig_cur_type)) == TYPE_DECL\n-\t\t&& DECL_NAME (TYPE_NAME (orig_cur_type)) != 0)\n-\t      that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (orig_cur_type)));\n-\t    else\n-\t      that = IDENTIFIER_POINTER (TYPE_NAME (orig_cur_type));\n-\t  }\n-\n-\t/* A nameless type can't possibly match what the format wants.\n-\t   So there will be a warning for it.\n-\t   Make up a string to describe vaguely what it is.  */\n-\tif (that == 0)\n-\t  {\n-\t    if (TREE_CODE (orig_cur_type) == POINTER_TYPE)\n-\t      that = \"pointer\";\n-\t    else\n-\t      that = \"different type\";\n-\t  }\n-\n-\t/* Make the warning better in case of mismatch of int vs long.  */\n-\tif (TREE_CODE (orig_cur_type) == INTEGER_TYPE\n-\t    && TREE_CODE (wanted_type) == INTEGER_TYPE\n-\t    && TYPE_PRECISION (orig_cur_type) == TYPE_PRECISION (wanted_type)\n-\t    && TYPE_NAME (orig_cur_type) != 0\n-\t    && TREE_CODE (TYPE_NAME (orig_cur_type)) == TYPE_DECL)\n-\t  that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (orig_cur_type)));\n-\n-\tif (strcmp (this, that) != 0)\n-\t  {\n-\t    /* There may be a better name for the format, e.g. size_t,\n-\t       but we should allow for programs with a perverse typedef\n-\t       making size_t something other than what the compiler\n-\t       thinks.  */\n-\t    if (types->wanted_type_name != 0\n-\t\t&& strcmp (types->wanted_type_name, that) != 0)\n-\t      this = types->wanted_type_name;\n-\t    if (types->name != 0)\n-\t      status_warning (status, \"%s is not type %s (arg %d)\", types->name, this,\n-\t\t       arg_num);\n-\t    else\n-\t      status_warning (status, \"%s format, %s arg (arg %d)\", this, that, arg_num);\n-\t  }\n-      }\n-    }\n-}\n-\n-/* Set format warning options according to a -Wformat=n option.  */\n-\n-void\n-set_Wformat (setting)\n-     int setting;\n-{\n-  warn_format = setting;\n-  warn_format_y2k = setting;\n-  warn_format_extra_args = setting;\n-  if (setting != 1)\n-    {\n-      warn_format_nonliteral = setting;\n-      warn_format_security = setting;\n-    }\n-}\n \f\n /* Print a warning if a constant expression had overflow in folding.\n    Invoke this function on every expression that the language"}, {"sha": "22f743ba18a54641fa4a59e00d7dcbd054b8d20c", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=1312c143f8f7a87b44e0536d66364bd9216ff5a4", "patch": "@@ -478,6 +478,8 @@ extern void decl_attributes\t\t\tPARAMS ((tree, tree, tree));\n extern void init_function_format_info\t\tPARAMS ((void));\n extern void check_function_format\t\tPARAMS ((int *, tree, tree, tree));\n extern void set_Wformat\t\t\t\tPARAMS ((int));\n+extern void decl_handle_format_attribute\tPARAMS ((tree, tree));\n+extern void decl_handle_format_arg_attribute\tPARAMS ((tree, tree));\n extern void c_apply_type_quals_to_decl\t\tPARAMS ((int, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */"}, {"sha": "5adb8e53abd3aabfad171e72bd2238b1451ff94b", "filename": "gcc/c-format.c", "status": "added", "additions": 2507, "deletions": 0, "changes": 2507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=1312c143f8f7a87b44e0536d66364bd9216ff5a4", "patch": "@@ -0,0 +1,2507 @@\n+/* Check calls to formatted I/O functions (-Wformat).\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"toplev.h\"\n+#include \"c-common.h\"\n+#include \"intl.h\"\n+#include \"diagnostic.h\"\n+\n+\f\n+/* Command line options and their associated flags.  */\n+\n+/* Warn about format/argument anomalies in calls to formatted I/O functions\n+   (*printf, *scanf, strftime, strfmon, etc.).  */\n+\n+int warn_format;\n+\n+/* Warn about Y2K problems with strftime formats.  */\n+\n+int warn_format_y2k;\n+\n+/* Warn about excess arguments to formats.  */\n+\n+int warn_format_extra_args;\n+\n+/* Warn about non-literal format arguments.  */\n+\n+int warn_format_nonliteral;\n+\n+/* Warn about possible security problems with calls to format functions.  */\n+\n+int warn_format_security;\n+\n+/* Set format warning options according to a -Wformat=n option.  */\n+\n+void\n+set_Wformat (setting)\n+     int setting;\n+{\n+  warn_format = setting;\n+  warn_format_y2k = setting;\n+  warn_format_extra_args = setting;\n+  if (setting != 1)\n+    {\n+      warn_format_nonliteral = setting;\n+      warn_format_security = setting;\n+    }\n+}\n+\n+\f\n+/* Handle attributes associated with format checking.  */\n+\n+/* This must be in the same order as format_types, with format_type_error\n+   last.  */\n+enum format_type { printf_format_type, scanf_format_type,\n+\t\t   strftime_format_type, strfmon_format_type,\n+\t\t   format_type_error };\n+\n+static enum format_type decode_format_type\tPARAMS ((const char *));\n+static void record_function_format\tPARAMS ((tree, tree, enum format_type,\n+\t\t\t\t\t\t int, int));\n+static void record_international_format\tPARAMS ((tree, tree, int));\n+\n+/* Handle the format attribute (with arguments ARGS) attached to the decl\n+   DECL.  It is already verified that DECL is a decl and ARGS contains\n+   exactly three arguments.  */\n+\n+void\n+decl_handle_format_attribute (decl, args)\n+     tree decl, args;\n+{\n+  tree type = TREE_TYPE (decl);\n+  tree format_type_id = TREE_VALUE (args);\n+  tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n+  tree first_arg_num_expr\n+    = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n+  unsigned HOST_WIDE_INT format_num, first_arg_num;\n+  enum format_type format_type;\n+  tree argument;\n+  unsigned int arg_num;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"argument format specified for non-function `%s'\");\n+      return;\n+    }\n+\n+  if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n+    {\n+      error (\"unrecognized format specifier\");\n+      return;\n+    }\n+  else\n+    {\n+      const char *p = IDENTIFIER_POINTER (format_type_id);\n+\n+      format_type = decode_format_type (p);\n+\n+      if (format_type == format_type_error)\n+\t{\n+\t  warning (\"`%s' is an unrecognized format function type\", p);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Strip any conversions from the string index and first arg number\n+     and verify they are constants.  */\n+  while (TREE_CODE (format_num_expr) == NOP_EXPR\n+\t || TREE_CODE (format_num_expr) == CONVERT_EXPR\n+\t || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n+    format_num_expr = TREE_OPERAND (format_num_expr, 0);\n+\n+  while (TREE_CODE (first_arg_num_expr) == NOP_EXPR\n+\t || TREE_CODE (first_arg_num_expr) == CONVERT_EXPR\n+\t || TREE_CODE (first_arg_num_expr) == NON_LVALUE_EXPR)\n+    first_arg_num_expr = TREE_OPERAND (first_arg_num_expr, 0);\n+\n+  if (TREE_CODE (format_num_expr) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (format_num_expr) != 0\n+      || TREE_CODE (first_arg_num_expr) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (first_arg_num_expr) != 0)\n+    {\n+      error (\"format string has invalid operand number\");\n+      return;\n+    }\n+\n+  format_num = TREE_INT_CST_LOW (format_num_expr);\n+  first_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);\n+  if (first_arg_num != 0 && first_arg_num <= format_num)\n+    {\n+      error (\"format string arg follows the args to be formatted\");\n+      return;\n+    }\n+\n+  /* If a parameter list is specified, verify that the format_num\n+     argument is actually a string, in case the format attribute\n+     is in error.  */\n+  argument = TYPE_ARG_TYPES (type);\n+  if (argument)\n+    {\n+      for (arg_num = 1; argument != 0 && arg_num != format_num;\n+\t   ++arg_num, argument = TREE_CHAIN (argument))\n+\t;\n+\n+      if (! argument\n+\t  || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n+\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n+\t      != char_type_node))\n+\t{\n+\t  error (\"format string arg not a string type\");\n+\t  return;\n+\t}\n+\n+      else if (first_arg_num != 0)\n+\t{\n+\t  /* Verify that first_arg_num points to the last arg,\n+\t     the ...  */\n+\t  while (argument)\n+\t    arg_num++, argument = TREE_CHAIN (argument);\n+\n+\t  if (arg_num != first_arg_num)\n+\t    {\n+\t      error (\"args to be formatted is not '...'\");\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  if (format_type == strftime_format_type && first_arg_num != 0)\n+    {\n+      error (\"strftime formats cannot format arguments\");\n+      return;\n+    }\n+\n+  record_function_format (DECL_NAME (decl), DECL_ASSEMBLER_NAME (decl),\n+\t\t\t  format_type, format_num, first_arg_num);\n+}\n+\n+\n+/* Handle the format_arg attribute (with arguments ARGS) attached to\n+   the decl DECL.  It is already verified that DECL is a decl and\n+   ARGS contains exactly one argument.  */\n+\n+void\n+decl_handle_format_arg_attribute (decl, args)\n+     tree decl, args;\n+{\n+  tree type = TREE_TYPE (decl);\n+  tree format_num_expr = TREE_VALUE (args);\n+  unsigned HOST_WIDE_INT format_num;\n+  unsigned int arg_num;\n+  tree argument;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"argument format specified for non-function `%s'\");\n+      return;\n+    }\n+\n+  /* Strip any conversions from the first arg number and verify it\n+     is a constant.  */\n+  while (TREE_CODE (format_num_expr) == NOP_EXPR\n+\t || TREE_CODE (format_num_expr) == CONVERT_EXPR\n+\t || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n+    format_num_expr = TREE_OPERAND (format_num_expr, 0);\n+\n+  if (TREE_CODE (format_num_expr) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (format_num_expr) != 0)\n+    {\n+      error (\"format string has invalid operand number\");\n+      return;\n+    }\n+\n+  format_num = TREE_INT_CST_LOW (format_num_expr);\n+\n+  /* If a parameter list is specified, verify that the format_num\n+     argument is actually a string, in case the format attribute\n+     is in error.  */\n+  argument = TYPE_ARG_TYPES (type);\n+  if (argument)\n+    {\n+      for (arg_num = 1; argument != 0 && arg_num != format_num;\n+\t   ++arg_num, argument = TREE_CHAIN (argument))\n+\t;\n+\n+      if (! argument\n+\t  || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n+\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n+\t      != char_type_node))\n+\t{\n+\t  error (\"format string arg not a string type\");\n+\t  return;\n+\t}\n+    }\n+\n+  if (TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) != POINTER_TYPE\n+      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (TREE_TYPE (decl))))\n+\t  != char_type_node))\n+    {\n+      error (\"function does not return string type\");\n+      return;\n+    }\n+\n+  record_international_format (DECL_NAME (decl), DECL_ASSEMBLER_NAME (decl),\n+\t\t\t       format_num);\n+}\n+\n+typedef struct function_format_info\n+{\n+  struct function_format_info *next;  /* next structure on the list */\n+  tree name;\t\t\t/* identifier such as \"printf\" */\n+  tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n+  enum format_type format_type;\t/* type of format (printf, scanf, etc.) */\n+  int format_num;\t\t/* number of format argument */\n+  int first_arg_num;\t\t/* number of first arg (zero for varargs) */\n+} function_format_info;\n+\n+static function_format_info *function_format_list = NULL;\n+\n+typedef struct international_format_info\n+{\n+  struct international_format_info *next;  /* next structure on the list */\n+  tree name;\t\t\t/* identifier such as \"gettext\" */\n+  tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n+  int format_num;\t\t/* number of format argument */\n+} international_format_info;\n+\n+static international_format_info *international_format_list = NULL;\n+\n+/* Initialize the table of functions to perform format checking on.\n+   The ISO C functions are always checked (whether <stdio.h> is\n+   included or not), since it is common to call printf without\n+   including <stdio.h>.  There shouldn't be a problem with this,\n+   since ISO C reserves these function names whether you include the\n+   header file or not.  In any case, the checking is harmless.  With\n+   -ffreestanding, these default attributes are disabled, and must be\n+   specified manually if desired.\n+\n+   Also initialize the name of function that modify the format string for\n+   internationalization purposes.  */\n+\n+void\n+init_function_format_info ()\n+{\n+  if (flag_hosted)\n+    {\n+      /* Functions from ISO/IEC 9899:1990.  */\n+      record_function_format (get_identifier (\"printf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 1, 2);\n+      record_function_format (get_identifier (\"__builtin_printf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 1, 2);\n+      record_function_format (get_identifier (\"fprintf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 2, 3);\n+      record_function_format (get_identifier (\"__builtin_fprintf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 2, 3);\n+      record_function_format (get_identifier (\"sprintf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 2, 3);\n+      record_function_format (get_identifier (\"scanf\"), NULL_TREE,\n+\t\t\t      scanf_format_type, 1, 2);\n+      record_function_format (get_identifier (\"fscanf\"), NULL_TREE,\n+\t\t\t      scanf_format_type, 2, 3);\n+      record_function_format (get_identifier (\"sscanf\"), NULL_TREE,\n+\t\t\t      scanf_format_type, 2, 3);\n+      record_function_format (get_identifier (\"vprintf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 1, 0);\n+      record_function_format (get_identifier (\"vfprintf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 2, 0);\n+      record_function_format (get_identifier (\"vsprintf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 2, 0);\n+      record_function_format (get_identifier (\"strftime\"), NULL_TREE,\n+\t\t\t      strftime_format_type, 3, 0);\n+    }\n+\n+  if (flag_hosted && flag_isoc99)\n+    {\n+      /* ISO C99 adds the snprintf and vscanf family functions.  */\n+      record_function_format (get_identifier (\"snprintf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 3, 4);\n+      record_function_format (get_identifier (\"vsnprintf\"), NULL_TREE,\n+\t\t\t      printf_format_type, 3, 0);\n+      record_function_format (get_identifier (\"vscanf\"), NULL_TREE,\n+\t\t\t      scanf_format_type, 1, 0);\n+      record_function_format (get_identifier (\"vfscanf\"), NULL_TREE,\n+\t\t\t      scanf_format_type, 2, 0);\n+      record_function_format (get_identifier (\"vsscanf\"), NULL_TREE,\n+\t\t\t      scanf_format_type, 2, 0);\n+    }\n+\n+  if (flag_hosted && flag_noniso_default_format_attributes)\n+    {\n+      /* Uniforum/GNU gettext functions, not in ISO C.  */\n+      record_international_format (get_identifier (\"gettext\"), NULL_TREE, 1);\n+      record_international_format (get_identifier (\"dgettext\"), NULL_TREE, 2);\n+      record_international_format (get_identifier (\"dcgettext\"), NULL_TREE, 2);\n+      /* X/Open strfmon function.  */\n+      record_function_format (get_identifier (\"strfmon\"), NULL_TREE,\n+\t\t\t      strfmon_format_type, 3, 4);\n+    }\n+}\n+\n+/* Record information for argument format checking.  FUNCTION_IDENT is\n+   the identifier node for the name of the function to check (its decl\n+   need not exist yet).\n+   FORMAT_TYPE specifies the type of format checking.  FORMAT_NUM is the number\n+   of the argument which is the format control string (starting from 1).\n+   FIRST_ARG_NUM is the number of the first actual argument to check\n+   against the format string, or zero if no checking is not be done\n+   (e.g. for varargs such as vfprintf).  */\n+\n+static void\n+record_function_format (name, assembler_name, format_type,\n+\t\t\tformat_num, first_arg_num)\n+      tree name;\n+      tree assembler_name;\n+      enum format_type format_type;\n+      int format_num;\n+      int first_arg_num;\n+{\n+  function_format_info *info;\n+\n+  /* Re-use existing structure if it's there.  */\n+\n+  for (info = function_format_list; info; info = info->next)\n+    {\n+      if (info->name == name && info->assembler_name == assembler_name)\n+\tbreak;\n+    }\n+  if (! info)\n+    {\n+      info = (function_format_info *) xmalloc (sizeof (function_format_info));\n+      info->next = function_format_list;\n+      function_format_list = info;\n+\n+      info->name = name;\n+      info->assembler_name = assembler_name;\n+    }\n+\n+  info->format_type = format_type;\n+  info->format_num = format_num;\n+  info->first_arg_num = first_arg_num;\n+}\n+\n+/* Record information for the names of function that modify the format\n+   argument to format functions.  FUNCTION_IDENT is the identifier node for\n+   the name of the function (its decl need not exist yet) and FORMAT_NUM is\n+   the number of the argument which is the format control string (starting\n+   from 1).  */\n+\n+static void\n+record_international_format (name, assembler_name, format_num)\n+      tree name;\n+      tree assembler_name;\n+      int format_num;\n+{\n+  international_format_info *info;\n+\n+  /* Re-use existing structure if it's there.  */\n+\n+  for (info = international_format_list; info; info = info->next)\n+    {\n+      if (info->name == name && info->assembler_name == assembler_name)\n+\tbreak;\n+    }\n+\n+  if (! info)\n+    {\n+      info\n+\t= (international_format_info *)\n+\t  xmalloc (sizeof (international_format_info));\n+      info->next = international_format_list;\n+      international_format_list = info;\n+\n+      info->name = name;\n+      info->assembler_name = assembler_name;\n+    }\n+\n+  info->format_num = format_num;\n+}\n+\n+\n+\n+\f\n+/* Check a call to a format function against a parameter list.  */\n+\n+/* The meaningfully distinct length modifiers for format checking recognised\n+   by GCC.  */\n+enum format_lengths\n+{\n+  FMT_LEN_none,\n+  FMT_LEN_hh,\n+  FMT_LEN_h,\n+  FMT_LEN_l,\n+  FMT_LEN_ll,\n+  FMT_LEN_L,\n+  FMT_LEN_z,\n+  FMT_LEN_t,\n+  FMT_LEN_j,\n+  FMT_LEN_MAX\n+};\n+\n+\n+/* The standard versions in which various format features appeared.  */\n+enum format_std_version\n+{\n+  STD_C89,\n+  STD_C94,\n+  STD_C9L, /* C99, but treat as C89 if -Wno-long-long.  */\n+  STD_C99,\n+  STD_EXT\n+};\n+\n+/* The C standard version C++ is treated as equivalent to\n+   or inheriting from, for the purpose of format features supported.  */\n+#define CPLUSPLUS_STD_VER\tSTD_C89\n+/* The C standard version we are checking formats against when pedantic.  */\n+#define C_STD_VER\t\t(c_language == clk_cplusplus\t\t  \\\n+\t\t\t\t ? CPLUSPLUS_STD_VER\t\t\t  \\\n+\t\t\t\t : (flag_isoc99\t\t\t\t  \\\n+\t\t\t\t    ? STD_C99\t\t\t\t  \\\n+\t\t\t\t    : (flag_isoc94 ? STD_C94 : STD_C89)))\n+/* The name to give to the standard version we are warning about when\n+   pedantic.  FEATURE_VER is the version in which the feature warned out\n+   appeared, which is higher than C_STD_VER.  */\n+#define C_STD_NAME(FEATURE_VER) (c_language == clk_cplusplus\t\\\n+\t\t\t\t ? \"ISO C++\"\t\t\t\\\n+\t\t\t\t : ((FEATURE_VER) == STD_EXT\t\\\n+\t\t\t\t    ? \"ISO C\"\t\t\t\\\n+\t\t\t\t    : \"ISO C89\"))\n+/* Adjust a C standard version, which may be STD_C9L, to account for\n+   -Wno-long-long.  Returns other standard versions unchanged.  */\n+#define ADJ_STD(VER)\t\t((int)((VER) == STD_C9L\t\t\t      \\\n+\t\t\t\t       ? (warn_long_long ? STD_C99 : STD_C89) \\\n+\t\t\t\t       : (VER)))\n+\n+/* Flags that may apply to a particular kind of format checked by GCC.  */\n+enum\n+{\n+  /* This format converts arguments of types determined by the\n+     format string.  */\n+  FMT_FLAG_ARG_CONVERT = 1,\n+  /* The scanf allocation 'a' kludge applies to this format kind.  */\n+  FMT_FLAG_SCANF_A_KLUDGE = 2,\n+  /* A % during parsing a specifier is allowed to be a modified % rather\n+     that indicating the format is broken and we are out-of-sync.  */\n+  FMT_FLAG_FANCY_PERCENT_OK = 4,\n+  /* With $ operand numbers, it is OK to reference the same argument more\n+     than once.  */\n+  FMT_FLAG_DOLLAR_MULTIPLE = 8,\n+  /* This format type uses $ operand numbers (strfmon doesn't).  */\n+  FMT_FLAG_USE_DOLLAR = 16,\n+  /* Zero width is bad in this type of format (scanf).  */\n+  FMT_FLAG_ZERO_WIDTH_BAD = 32,\n+  /* Empty precision specification is OK in this type of format (printf).  */\n+  FMT_FLAG_EMPTY_PREC_OK = 64\n+  /* Not included here: details of whether width or precision may occur\n+     (controlled by width_char and precision_char); details of whether\n+     '*' can be used for these (width_type and precision_type); details\n+     of whether length modifiers can occur (length_char_specs).  */\n+};\n+\n+\n+/* Structure describing a length modifier supported in format checking, and\n+   possibly a doubled version such as \"hh\".  */\n+typedef struct\n+{\n+  /* Name of the single-character length modifier.  */\n+  const char *name;\n+  /* Index into a format_char_info.types array.  */\n+  enum format_lengths index;\n+  /* Standard version this length appears in.  */\n+  enum format_std_version std;\n+  /* Same, if the modifier can be repeated, or NULL if it can't.  */\n+  const char *double_name;\n+  enum format_lengths double_index;\n+  enum format_std_version double_std;\n+} format_length_info;\n+\n+\n+/* Structure desribing the combination of a conversion specifier\n+   (or a set of specifiers which act identically) and a length modifier.  */\n+typedef struct\n+{\n+  /* The standard version this combination of length and type appeared in.\n+     This is only relevant if greater than those for length and type\n+     individually; otherwise it is ignored.  */\n+  enum format_std_version std;\n+  /* The name to use for the type, if different from that generated internally\n+     (e.g., \"signed size_t\").  */\n+  const char *name;\n+  /* The type itself.  */\n+  tree *type;\n+} format_type_detail;\n+\n+\n+/* Macros to fill out tables of these.  */\n+#define BADLEN\t{ 0, NULL, NULL }\n+#define NOLENGTHS\t{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n+\n+\n+/* Structure desribing a format conversion specifier (or a set of specifiers\n+   which act identically), and the length modifiers used with it.  */\n+typedef struct\n+{\n+  const char *format_chars;\n+  int pointer_count;\n+  enum format_std_version std;\n+  /* Types accepted for each length modifier.  */\n+  format_type_detail types[FMT_LEN_MAX];\n+  /* List of other modifier characters allowed with these specifiers.\n+     This lists flags, and additionally \"w\" for width, \"p\" for precision\n+     (right precision, for strfmon), \"#\" for left precision (strfmon),\n+     \"a\" for scanf \"a\" allocation extension (not applicable in C99 mode),\n+     \"*\" for scanf suppression, and \"E\" and \"O\" for those strftime\n+     modifiers.  */\n+  const char *flag_chars;\n+  /* List of additional flags describing these conversion specifiers.\n+     \"c\" for generic character pointers being allowed, \"2\" for strftime\n+     two digit year formats, \"3\" for strftime formats giving two digit\n+     years in some locales, \"4\" for \"2\" which becomes \"3\" with an \"E\" modifier,\n+     \"o\" if use of strftime \"O\" is a GNU extension beyond C99,\n+     \"W\" if the argument is a pointer which is dereferenced and written into,\n+     \"R\" if the argument is a pointer which is dereferenced and read from,\n+     \"i\" for printf integer formats where the '0' flag is ignored with\n+     precision, and \"[\" for the starting character of a scanf scanset.  */\n+  const char *flags2;\n+} format_char_info;\n+\n+\n+/* Structure describing a flag accepted by some kind of format.  */\n+typedef struct\n+{\n+  /* The flag character in question (0 for end of array).  */\n+  int flag_char;\n+  /* Zero if this entry describes the flag character in general, or a\n+     non-zero character that may be found in flags2 if it describes the\n+     flag when used with certain formats only.  If the latter, only\n+     the first such entry found that applies to the current conversion\n+     specifier is used; the values of `name' and `long_name' it supplies\n+     will be used, if non-NULL and the standard version is higher than\n+     the unpredicated one, for any pedantic warning.  For example, 'o'\n+     for strftime formats (meaning 'O' is an extension over C99).  */\n+  int predicate;\n+  /* Nonzero if the next character after this flag in the format should\n+     be skipped ('=' in strfmon), zero otherwise.  */\n+  int skip_next_char;\n+  /* The name to use for this flag in diagnostic messages.  For example,\n+     N_(\"`0' flag\"), N_(\"field width\").  */\n+  const char *name;\n+  /* Long name for this flag in diagnostic messages; currently only used for\n+     \"ISO C does not support ...\".  For example, N_(\"the `I' printf flag\").  */\n+  const char *long_name;\n+  /* The standard version in which it appeared.  */\n+  enum format_std_version std;\n+} format_flag_spec;\n+\n+\n+/* Structure describing a combination of flags that is bad for some kind\n+   of format.  */\n+typedef struct\n+{\n+  /* The first flag character in question (0 for end of array).  */\n+  int flag_char1;\n+  /* The second flag character.  */\n+  int flag_char2;\n+  /* Non-zero if the message should say that the first flag is ignored with\n+     the second, zero if the combination should simply be objected to.  */\n+  int ignored;\n+  /* Zero if this entry applies whenever this flag combination occurs,\n+     a non-zero character from flags2 if it only applies in some\n+     circumstances (e.g. 'i' for printf formats ignoring 0 with precision).  */\n+  int predicate;\n+} format_flag_pair;\n+\n+\n+/* Structure describing a particular kind of format processed by GCC.  */\n+typedef struct\n+{\n+  /* The name of this kind of format, for use in diagnostics.  Also\n+     the name of the attribute (without preceding and following __).  */\n+  const char *name;\n+  /* Specifications of the length modifiers accepted; possibly NULL.  */\n+  const format_length_info *length_char_specs;\n+  /* Details of the conversion specification characters accepted.  */\n+  const format_char_info *conversion_specs;\n+  /* String listing the flag characters that are accepted.  */\n+  const char *flag_chars;\n+  /* String listing modifier characters (strftime) accepted.  May be NULL.  */\n+  const char *modifier_chars;\n+  /* Details of the flag characters, including pseudo-flags.  */\n+  const format_flag_spec *flag_specs;\n+  /* Details of bad combinations of flags.  */\n+  const format_flag_pair *bad_flag_pairs;\n+  /* Flags applicable to this kind of format.  */\n+  int flags;\n+  /* Flag character to treat a width as, or 0 if width not used.  */\n+  int width_char;\n+  /* Flag character to treat a left precision (strfmon) as,\n+     or 0 if left precision not used.  */\n+  int left_precision_char;\n+  /* Flag character to treat a precision (for strfmon, right precision) as,\n+     or 0 if precision not used.  */\n+  int precision_char;\n+  /* If a flag character has the effect of suppressing the conversion of\n+     an argument ('*' in scanf), that flag character, otherwise 0.  */\n+  int suppression_char;\n+  /* Flag character to treat a length modifier as (ignored if length\n+     modifiers not used).  Need not be placed in flag_chars for conversion\n+     specifiers, but is used to check for bad combinations such as length\n+     modifier with assignment suppression in scanf.  */\n+  int length_code_char;\n+  /* Pointer to type of argument expected if '*' is used for a width,\n+     or NULL if '*' not used for widths.  */\n+  tree *width_type;\n+  /* Pointer to type of argument expected if '*' is used for a precision,\n+     or NULL if '*' not used for precisions.  */\n+  tree *precision_type;\n+} format_kind_info;\n+\n+\n+/* Structure describing details of a type expected in format checking,\n+   and the type to check against it.  */\n+typedef struct format_wanted_type\n+{\n+  /* The type wanted.  */\n+  tree wanted_type;\n+  /* The name of this type to use in diagnostics.  */\n+  const char *wanted_type_name;\n+  /* The level of indirection through pointers at which this type occurs.  */\n+  int pointer_count;\n+  /* Whether, when pointer_count is 1, to allow any character type when\n+     pedantic, rather than just the character or void type specified.  */\n+  int char_lenient_flag;\n+  /* Whether the argument, dereferenced once, is written into and so the\n+     argument must not be a pointer to a const-qualified type.  */\n+  int writing_in_flag;\n+  /* Whether the argument, dereferenced once, is read from and so\n+     must not be a NULL pointer.  */\n+  int reading_from_flag;\n+  /* If warnings should be of the form \"field precision is not type int\",\n+     the name to use (in this case \"field precision\"), otherwise NULL,\n+     for \"%s format, %s arg\" type messages.  If (in an extension), this\n+     is a pointer type, wanted_type_name should be set to include the\n+     terminating '*' characters of the type name to give a correct\n+     message.  */\n+  const char *name;\n+  /* The actual parameter to check against the wanted type.  */\n+  tree param;\n+  /* The argument number of that parameter.  */\n+  int arg_num;\n+  /* The next type to check for this format conversion, or NULL if none.  */\n+  struct format_wanted_type *next;\n+} format_wanted_type;\n+\n+\n+static const format_length_info printf_length_specs[] =\n+{\n+  { \"h\", FMT_LEN_h, STD_C89, \"hh\", FMT_LEN_hh, STD_C99 },\n+  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C9L },\n+  { \"q\", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },\n+  { \"L\", FMT_LEN_L, STD_C89, NULL, 0, 0 },\n+  { \"z\", FMT_LEN_z, STD_C99, NULL, 0, 0 },\n+  { \"Z\", FMT_LEN_z, STD_EXT, NULL, 0, 0 },\n+  { \"t\", FMT_LEN_t, STD_C99, NULL, 0, 0 },\n+  { \"j\", FMT_LEN_j, STD_C99, NULL, 0, 0 },\n+  { NULL, 0, 0, NULL, 0, 0 }\n+};\n+\n+\n+/* This differs from printf_length_specs only in that \"Z\" is not accepted.  */\n+static const format_length_info scanf_length_specs[] =\n+{\n+  { \"h\", FMT_LEN_h, STD_C89, \"hh\", FMT_LEN_hh, STD_C99 },\n+  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C9L },\n+  { \"q\", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },\n+  { \"L\", FMT_LEN_L, STD_C89, NULL, 0, 0 },\n+  { \"z\", FMT_LEN_z, STD_C99, NULL, 0, 0 },\n+  { \"t\", FMT_LEN_t, STD_C99, NULL, 0, 0 },\n+  { \"j\", FMT_LEN_j, STD_C99, NULL, 0, 0 },\n+  { NULL, 0, 0, NULL, 0, 0 }\n+};\n+\n+\n+/* All tables for strfmon use STD_C89 everywhere, since -pedantic warnings\n+   make no sense for a format type not part of any C standard version.  */\n+static const format_length_info strfmon_length_specs[] =\n+{\n+  /* A GNU extension.  */\n+  { \"L\", FMT_LEN_L, STD_C89, NULL, 0, 0 },\n+  { NULL, 0, 0, NULL, 0, 0 }\n+};\n+\n+static const format_flag_spec printf_flag_specs[] =\n+{\n+  { ' ',  0, 0, N_(\"` ' flag\"),        N_(\"the ` ' printf flag\"),              STD_C89 },\n+  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n+  { '0',  0, 0, N_(\"`0' flag\"),        N_(\"the `0' printf flag\"),              STD_C89 },\n+  { '-',  0, 0, N_(\"`-' flag\"),        N_(\"the `-' printf flag\"),              STD_C89 },\n+  { '\\'', 0, 0, N_(\"`'' flag\"),        N_(\"the `'' printf flag\"),              STD_EXT },\n+  { 'I',  0, 0, N_(\"`I' flag\"),        N_(\"the `I' printf flag\"),              STD_EXT },\n+  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n+  { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n+  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, 0, NULL, NULL, 0 }\n+};\n+\n+\n+static const format_flag_pair printf_flag_pairs[] =\n+{\n+  { ' ', '+', 1, 0   },\n+  { '0', '-', 1, 0   },\n+  { '0', 'p', 1, 'i' },\n+  { 0, 0, 0, 0 }\n+};\n+\n+\n+static const format_flag_spec scanf_flag_specs[] =\n+{\n+  { '*',  0, 0, N_(\"assignment suppression\"), N_(\"assignment suppression\"),          STD_C89 },\n+  { 'a',  0, 0, N_(\"`a' flag\"),               N_(\"the `a' scanf flag\"),              STD_EXT },\n+  { 'w',  0, 0, N_(\"field width\"),            N_(\"field width in scanf format\"),     STD_C89 },\n+  { 'L',  0, 0, N_(\"length modifier\"),        N_(\"length modifier in scanf format\"), STD_C89 },\n+  { '\\'', 0, 0, N_(\"`'' flag\"),               N_(\"the `'' scanf flag\"),              STD_EXT },\n+  { 'I',  0, 0, N_(\"`I' flag\"),               N_(\"the `I' scanf flag\"),              STD_EXT },\n+  { 0, 0, 0, NULL, NULL, 0 }\n+};\n+\n+\n+static const format_flag_pair scanf_flag_pairs[] =\n+{\n+  { '*', 'L', 0, 0 },\n+  { 0, 0, 0, 0 }\n+};\n+\n+\n+static const format_flag_spec strftime_flag_specs[] =\n+{\n+  { '_', 0,   0, N_(\"`_' flag\"),     N_(\"the `_' strftime flag\"),          STD_EXT },\n+  { '-', 0,   0, N_(\"`-' flag\"),     N_(\"the `-' strftime flag\"),          STD_EXT },\n+  { '0', 0,   0, N_(\"`0' flag\"),     N_(\"the `0' strftime flag\"),          STD_EXT },\n+  { '^', 0,   0, N_(\"`^' flag\"),     N_(\"the `^' strftime flag\"),          STD_EXT },\n+  { '#', 0,   0, N_(\"`#' flag\"),     N_(\"the `#' strftime flag\"),          STD_EXT },\n+  { 'w', 0,   0, N_(\"field width\"),  N_(\"field width in strftime format\"), STD_EXT },\n+  { 'E', 0,   0, N_(\"`E' modifier\"), N_(\"the `E' strftime modifier\"),      STD_C99 },\n+  { 'O', 0,   0, N_(\"`O' modifier\"), N_(\"the `O' strftime modifier\"),      STD_C99 },\n+  { 'O', 'o', 0, NULL,               N_(\"the `O' modifier\"),               STD_EXT },\n+  { 0, 0, 0, NULL, NULL, 0 }\n+};\n+\n+\n+static const format_flag_pair strftime_flag_pairs[] =\n+{\n+  { 'E', 'O', 0, 0 },\n+  { '_', '-', 0, 0 },\n+  { '_', '0', 0, 0 },\n+  { '-', '0', 0, 0 },\n+  { '^', '#', 0, 0 },\n+  { 0, 0, 0, 0 }\n+};\n+\n+\n+static const format_flag_spec strfmon_flag_specs[] =\n+{\n+  { '=',  0, 1, N_(\"fill character\"),  N_(\"fill character in strfmon format\"),  STD_C89 },\n+  { '^',  0, 0, N_(\"`^' flag\"),        N_(\"the `^' strfmon flag\"),              STD_C89 },\n+  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' strfmon flag\"),              STD_C89 },\n+  { '(',  0, 0, N_(\"`(' flag\"),        N_(\"the `(' strfmon flag\"),              STD_C89 },\n+  { '!',  0, 0, N_(\"`!' flag\"),        N_(\"the `!' strfmon flag\"),              STD_C89 },\n+  { '-',  0, 0, N_(\"`-' flag\"),        N_(\"the `-' strfmon flag\"),              STD_C89 },\n+  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in strfmon format\"),     STD_C89 },\n+  { '#',  0, 0, N_(\"left precision\"),  N_(\"left precision in strfmon format\"),  STD_C89 },\n+  { 'p',  0, 0, N_(\"right precision\"), N_(\"right precision in strfmon format\"), STD_C89 },\n+  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in strfmon format\"), STD_C89 },\n+  { 0, 0, 0, NULL, NULL, 0 }\n+};\n+\n+static const format_flag_pair strfmon_flag_pairs[] =\n+{\n+  { '+', '(', 0, 0 },\n+  { 0, 0, 0, 0 }\n+};\n+\n+\n+#define T_I\t&integer_type_node\n+#define T89_I\t{ STD_C89, NULL, T_I }\n+#define T99_I\t{ STD_C99, NULL, T_I }\n+#define T_L\t&long_integer_type_node\n+#define T89_L\t{ STD_C89, NULL, T_L }\n+#define T_LL\t&long_long_integer_type_node\n+#define T9L_LL\t{ STD_C9L, NULL, T_LL }\n+#define TEX_LL\t{ STD_EXT, NULL, T_LL }\n+#define T_S\t&short_integer_type_node\n+#define T89_S\t{ STD_C89, NULL, T_S }\n+#define T_UI\t&unsigned_type_node\n+#define T89_UI\t{ STD_C89, NULL, T_UI }\n+#define T99_UI\t{ STD_C99, NULL, T_UI }\n+#define T_UL\t&long_unsigned_type_node\n+#define T89_UL\t{ STD_C89, NULL, T_UL }\n+#define T_ULL\t&long_long_unsigned_type_node\n+#define T9L_ULL\t{ STD_C9L, NULL, T_ULL }\n+#define TEX_ULL\t{ STD_EXT, NULL, T_ULL }\n+#define T_US\t&short_unsigned_type_node\n+#define T89_US\t{ STD_C89, NULL, T_US }\n+#define T_F\t&float_type_node\n+#define T89_F\t{ STD_C89, NULL, T_F }\n+#define T99_F\t{ STD_C99, NULL, T_F }\n+#define T_D\t&double_type_node\n+#define T89_D\t{ STD_C89, NULL, T_D }\n+#define T99_D\t{ STD_C99, NULL, T_D }\n+#define T_LD\t&long_double_type_node\n+#define T89_LD\t{ STD_C89, NULL, T_LD }\n+#define T99_LD\t{ STD_C99, NULL, T_LD }\n+#define T_C\t&char_type_node\n+#define T89_C\t{ STD_C89, NULL, T_C }\n+#define T_SC\t&signed_char_type_node\n+#define T99_SC\t{ STD_C99, NULL, T_SC }\n+#define T_UC\t&unsigned_char_type_node\n+#define T99_UC\t{ STD_C99, NULL, T_UC }\n+#define T_V\t&void_type_node\n+#define T89_V\t{ STD_C89, NULL, T_V }\n+#define T_W\t&wchar_type_node\n+#define T94_W\t{ STD_C94, \"wchar_t\", T_W }\n+#define TEX_W\t{ STD_EXT, \"wchar_t\", T_W }\n+#define T_WI\t&wint_type_node\n+#define T94_WI\t{ STD_C94, \"wint_t\", T_WI }\n+#define TEX_WI\t{ STD_EXT, \"wint_t\", T_WI }\n+#define T_ST    &c_size_type_node\n+#define T99_ST\t{ STD_C99, \"size_t\", T_ST }\n+#define T_SST   &signed_size_type_node\n+#define T99_SST\t{ STD_C99, \"signed size_t\", T_SST }\n+#define T_PD    &ptrdiff_type_node\n+#define T99_PD\t{ STD_C99, \"ptrdiff_t\", T_PD }\n+#define T_UPD   &unsigned_ptrdiff_type_node\n+#define T99_UPD\t{ STD_C99, \"unsigned ptrdiff_t\", T_UPD }\n+#define T_IM    &intmax_type_node\n+#define T99_IM\t{ STD_C99, \"intmax_t\", T_IM }\n+#define T_UIM   &uintmax_type_node\n+#define T99_UIM\t{ STD_C99, \"uintmax_t\", T_UIM }\n+\n+static const format_char_info print_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"di\",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"-wp0 +'I\", \"i\"  },\n+  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0#\",    \"i\"  },\n+  { \"u\",   0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0'I\",   \"i\"  },\n+  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'\", \"\"   },\n+  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\",  \"\"   },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\"   },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",      \"cR\" },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"c\"  },\n+  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",         \"W\"  },\n+  /* C99 conversion specifiers.  */\n+  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'\", \"\"   },\n+  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\",  \"\"   },\n+  /* X/Open conversion specifiers.  */\n+  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\"   },\n+  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",      \"R\"  },\n+  /* GNU conversion specifiers.  */\n+  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",      \"\"   },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+};\n+\n+static const format_char_info scan_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"*w'I\", \"W\"   },\n+  { \"u\",     1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w'I\", \"W\"   },\n+  { \"oxX\",   1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w\",   \"W\"   },\n+  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\"   },\n+  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"cW\"  },\n+  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW\"  },\n+  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"cW[\" },\n+  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\"   },\n+  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\",     \"W\"   },\n+  /* C99 conversion specifiers.  */\n+  { \"FaA\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w'\",  \"W\"   },\n+  /* X/Open conversion specifiers.  */\n+  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\",   \"W\"   },\n+  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\",  \"W\"   },\n+  { NULL, 0, 0, NOLENGTHS, NULL, NULL }\n+};\n+\n+static const format_char_info time_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"ABZab\",\t\t0, STD_C89, NOLENGTHS, \"^#\",     \"\"   },\n+  { \"cx\", \t\t0, STD_C89, NOLENGTHS, \"E\",      \"3\"  },\n+  { \"HIMSUWdmw\",\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"\"   },\n+  { \"j\",\t\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"o\"  },\n+  { \"p\",\t\t0, STD_C89, NOLENGTHS, \"#\",      \"\"   },\n+  { \"X\",\t\t0, STD_C89, NOLENGTHS, \"E\",      \"\"   },\n+  { \"y\", \t\t0, STD_C89, NOLENGTHS, \"EO-_0w\", \"4\"  },\n+  { \"Y\",\t\t0, STD_C89, NOLENGTHS, \"-_0EOw\", \"o\"  },\n+  { \"%\",\t\t0, STD_C89, NOLENGTHS, \"\",       \"\"   },\n+  /* C99 conversion specifiers.  */\n+  { \"C\",\t\t0, STD_C99, NOLENGTHS, \"-_0EOw\", \"o\"  },\n+  { \"D\", \t\t0, STD_C99, NOLENGTHS, \"\",       \"2\"  },\n+  { \"eVu\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"\"   },\n+  { \"FRTnrt\",\t\t0, STD_C99, NOLENGTHS, \"\",       \"\"   },\n+  { \"g\", \t\t0, STD_C99, NOLENGTHS, \"O-_0w\",  \"2o\" },\n+  { \"G\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"o\"  },\n+  { \"h\",\t\t0, STD_C99, NOLENGTHS, \"^#\",     \"\"   },\n+  { \"z\",\t\t0, STD_C99, NOLENGTHS, \"O\",      \"o\"  },\n+  /* GNU conversion specifiers.  */\n+  { \"kls\",\t\t0, STD_EXT, NOLENGTHS, \"-_0Ow\",  \"\"   },\n+  { \"P\",\t\t0, STD_EXT, NOLENGTHS, \"\",       \"\"   },\n+  { NULL,\t\t0, 0, NOLENGTHS, NULL, NULL }\n+};\n+\n+static const format_char_info monetary_char_table[] =\n+{\n+  { \"in\", 0, STD_C89, { T89_D, BADLEN, BADLEN, BADLEN, BADLEN, T89_LD, BADLEN, BADLEN, BADLEN }, \"=^+(!-w#p\", \"\" },\n+  { NULL, 0, 0, NOLENGTHS, NULL, NULL }\n+};\n+\n+\n+/* This must be in the same order as enum format_type.  */\n+static const format_kind_info format_types[] =\n+{\n+  { \"printf\",   printf_length_specs,  print_char_table, \" +#0-'I\", NULL, \n+    printf_flag_specs, printf_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_DOLLAR_MULTIPLE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_EMPTY_PREC_OK,\n+    'w', 0, 'p', 0, 'L',\n+    &integer_type_node, &integer_type_node\n+  },\n+  { \"scanf\",    scanf_length_specs,   scan_char_table,  \"*'I\", NULL, \n+    scanf_flag_specs, scanf_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD,\n+    'w', 0, 0, '*', 'L',\n+    NULL, NULL\n+  },\n+  { \"strftime\", NULL,                 time_char_table,  \"_-0^#\", \"EO\",\n+    strftime_flag_specs, strftime_flag_pairs,\n+    FMT_FLAG_FANCY_PERCENT_OK, 'w', 0, 0, 0, 0,\n+    NULL, NULL\n+  },\n+  { \"strfmon\",  strfmon_length_specs, monetary_char_table, \"=^+(!-\", NULL, \n+    strfmon_flag_specs, strfmon_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT, 'w', '#', 'p', 0, 'L',\n+    NULL, NULL\n+  }\n+};\n+\n+\n+/* Structure detailing the results of checking a format function call\n+   where the format expression may be a conditional expression with\n+   many leaves resulting from nested conditional expressions.  */\n+typedef struct\n+{\n+  /* Number of leaves of the format argument that could not be checked\n+     as they were not string literals.  */\n+  int number_non_literal;\n+  /* Number of leaves of the format argument that were null pointers or\n+     string literals, but had extra format arguments.  */\n+  int number_extra_args;\n+  /* Number of leaves of the format argument that were null pointers or\n+     string literals, but had extra format arguments and used $ operand\n+     numbers.  */\n+  int number_dollar_extra_args;\n+  /* Number of leaves of the format argument that were wide string\n+     literals.  */\n+  int number_wide;\n+  /* Number of leaves of the format argument that were empty strings.  */\n+  int number_empty;\n+  /* Number of leaves of the format argument that were unterminated\n+     strings.  */\n+  int number_unterminated;\n+  /* Number of leaves of the format argument that were not counted above.  */\n+  int number_other;\n+} format_check_results;\n+\n+static void check_format_info\tPARAMS ((int *, function_format_info *, tree));\n+static void check_format_info_recurse PARAMS ((int *, format_check_results *,\n+\t\t\t\t\t       function_format_info *, tree,\n+\t\t\t\t\t       tree, int));\n+static void check_format_info_main PARAMS ((int *, format_check_results *,\n+\t\t\t\t\t    function_format_info *,\n+\t\t\t\t\t    const char *, int, tree, int));\n+static void status_warning PARAMS ((int *, const char *, ...))\n+     ATTRIBUTE_PRINTF_2;\n+\n+static void init_dollar_format_checking\t\tPARAMS ((int, tree));\n+static int maybe_read_dollar_number\t\tPARAMS ((int *, const char **, int,\n+\t\t\t\t\t\t\t tree, tree *,\n+\t\t\t\t\t\t\t const format_kind_info *));\n+static void finish_dollar_format_checking\tPARAMS ((int *, format_check_results *));\n+\n+static const format_flag_spec *get_flag_spec\tPARAMS ((const format_flag_spec *,\n+\t\t\t\t\t\t\t int, const char *));\n+\n+static void check_format_types\tPARAMS ((int *, format_wanted_type *));\n+\n+/* Decode a format type from a string, returning the type, or\n+   format_type_error if not valid, in which case the caller should print an\n+   error message.  */\n+static enum format_type\n+decode_format_type (s)\n+     const char *s;\n+{\n+  int i;\n+  int slen;\n+  slen = strlen (s);\n+  for (i = 0; i < (int) format_type_error; i++)\n+    {\n+      int alen;\n+      if (!strcmp (s, format_types[i].name))\n+\tbreak;\n+      alen = strlen (format_types[i].name);\n+      if (slen == alen + 4 && s[0] == '_' && s[1] == '_'\n+\t  && s[slen - 1] == '_' && s[slen - 2] == '_'\n+\t  && !strncmp (s + 2, format_types[i].name, alen))\n+\tbreak;\n+    }\n+  return ((enum format_type) i);\n+}\n+\n+\f\n+/* Check the argument list of a call to printf, scanf, etc.\n+   NAME is the function identifier.\n+   ASSEMBLER_NAME is the function's assembler identifier.\n+   (Either NAME or ASSEMBLER_NAME, but not both, may be NULL_TREE.)\n+   PARAMS is the list of argument values.  Also, if -Wmissing-format-attribute,\n+   warn for calls to vprintf or vscanf in functions with no such format\n+   attribute themselves.  */\n+\n+void\n+check_function_format (status, name, assembler_name, params)\n+     int *status;\n+     tree name;\n+     tree assembler_name;\n+     tree params;\n+{\n+  function_format_info *info;\n+\n+  /* See if this function is a format function.  */\n+  for (info = function_format_list; info; info = info->next)\n+    {\n+      if (info->assembler_name\n+\t  ? (info->assembler_name == assembler_name)\n+\t  : (info->name == name))\n+\t{\n+\t  /* Yup; check it.  */\n+\t  check_format_info (status, info, params);\n+\t  if (warn_missing_format_attribute && info->first_arg_num == 0\n+\t      && (format_types[info->format_type].flags & FMT_FLAG_ARG_CONVERT))\n+\t    {\n+\t      function_format_info *info2;\n+\t      for (info2 = function_format_list; info2; info2 = info2->next)\n+\t\tif ((info2->assembler_name\n+\t\t     ? (info2->assembler_name == DECL_ASSEMBLER_NAME (current_function_decl))\n+\t\t     : (info2->name == DECL_NAME (current_function_decl)))\n+\t\t    && info2->format_type == info->format_type)\n+\t\t  break;\n+\t      if (info2 == NULL)\n+\t\t{\n+\t\t  /* Check if the current function has a parameter to which\n+\t\t     the format attribute could be attached; if not, it\n+\t\t     can't be a candidate for a format attribute, despite\n+\t\t     the vprintf-like or vscanf-like call.  */\n+\t\t  tree args;\n+\t\t  for (args = DECL_ARGUMENTS (current_function_decl);\n+\t\t       args != 0;\n+\t\t       args = TREE_CHAIN (args))\n+\t\t    {\n+\t\t      if (TREE_CODE (TREE_TYPE (args)) == POINTER_TYPE\n+\t\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (args)))\n+\t\t\t      == char_type_node))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  if (args != 0)\n+\t\t    warning (\"function might be possible candidate for `%s' format attribute\",\n+\t\t\t     format_types[info->format_type].name);\n+\t\t}\n+\t    }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* This function replaces `warning' inside the printf format checking\n+   functions.  If the `status' parameter is non-NULL, then it is\n+   dereferenced and set to 1 whenever a warning is caught.  Otherwise\n+   it warns as usual by replicating the innards of the warning\n+   function from diagnostic.c.  */\n+static void\n+status_warning VPARAMS ((int *status, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  int *status;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  diagnostic_context dc;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  status = va_arg (ap, int *);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  if (status)\n+    *status = 1;\n+  else\n+    {\n+      /* This duplicates the warning function behavior.  */\n+      set_diagnostic_context\n+\t(&dc, msgid, &ap, input_filename, lineno, /* warn = */ 1);\n+      report_diagnostic (&dc);\n+    }\n+\n+  va_end (ap);\n+}\n+\n+/* Variables used by the checking of $ operand number formats.  */\n+static char *dollar_arguments_used = NULL;\n+static int dollar_arguments_alloc = 0;\n+static int dollar_arguments_count;\n+static int dollar_first_arg_num;\n+static int dollar_max_arg_used;\n+static int dollar_format_warned;\n+\n+/* Initialize the checking for a format string that may contain $\n+   parameter number specifications; we will need to keep track of whether\n+   each parameter has been used.  FIRST_ARG_NUM is the number of the first\n+   argument that is a parameter to the format, or 0 for a vprintf-style\n+   function; PARAMS is the list of arguments starting at this argument.  */\n+\n+static void\n+init_dollar_format_checking (first_arg_num, params)\n+     int first_arg_num;\n+     tree params;\n+{\n+  dollar_first_arg_num = first_arg_num;\n+  dollar_arguments_count = 0;\n+  dollar_max_arg_used = 0;\n+  dollar_format_warned = 0;\n+  if (first_arg_num > 0)\n+    {\n+      while (params)\n+\t{\n+\t  dollar_arguments_count++;\n+\t  params = TREE_CHAIN (params);\n+\t}\n+    }\n+  if (dollar_arguments_alloc < dollar_arguments_count)\n+    {\n+      if (dollar_arguments_used)\n+\tfree (dollar_arguments_used);\n+      dollar_arguments_alloc = dollar_arguments_count;\n+      dollar_arguments_used = xmalloc (dollar_arguments_alloc);\n+    }\n+  if (dollar_arguments_alloc)\n+    memset (dollar_arguments_used, 0, dollar_arguments_alloc);\n+}\n+\n+\n+/* Look for a decimal number followed by a $ in *FORMAT.  If DOLLAR_NEEDED\n+   is set, it is an error if one is not found; otherwise, it is OK.  If\n+   such a number is found, check whether it is within range and mark that\n+   numbered operand as being used for later checking.  Returns the operand\n+   number if found and within range, zero if no such number was found and\n+   this is OK, or -1 on error.  PARAMS points to the first operand of the\n+   format; PARAM_PTR is made to point to the parameter referred to.  If\n+   a $ format is found, *FORMAT is updated to point just after it.  */\n+\n+static int\n+maybe_read_dollar_number (status, format, dollar_needed, params, param_ptr,\n+\t\t\t  fki)\n+     int *status;\n+     const char **format;\n+     int dollar_needed;\n+     tree params;\n+     tree *param_ptr;\n+     const format_kind_info *fki;\n+{\n+  int argnum;\n+  int overflow_flag;\n+  const char *fcp = *format;\n+  if (*fcp < '0' || *fcp > '9')\n+    {\n+      if (dollar_needed)\n+\t{\n+\t  status_warning (status, \"missing $ operand number in format\");\n+\t  return -1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+  argnum = 0;\n+  overflow_flag = 0;\n+  while (*fcp >= '0' && *fcp <= '9')\n+    {\n+      int nargnum;\n+      nargnum = 10 * argnum + (*fcp - '0');\n+      if (nargnum < 0 || nargnum / 10 != argnum)\n+\toverflow_flag = 1;\n+      argnum = nargnum;\n+      fcp++;\n+    }\n+  if (*fcp != '$')\n+    {\n+      if (dollar_needed)\n+\t{\n+\t  status_warning (status, \"missing $ operand number in format\");\n+\t  return -1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+  *format = fcp + 1;\n+  if (pedantic && !dollar_format_warned)\n+    {\n+      status_warning (status,\n+\t\t      \"%s does not support %%n$ operand number formats\",\n+\t\t      C_STD_NAME (STD_EXT));\n+      dollar_format_warned = 1;\n+    }\n+  if (overflow_flag || argnum == 0\n+      || (dollar_first_arg_num && argnum > dollar_arguments_count))\n+    {\n+      status_warning (status, \"operand number out of range in format\");\n+      return -1;\n+    }\n+  if (argnum > dollar_max_arg_used)\n+    dollar_max_arg_used = argnum;\n+  /* For vprintf-style functions we may need to allocate more memory to\n+     track which arguments are used.  */\n+  while (dollar_arguments_alloc < dollar_max_arg_used)\n+    {\n+      int nalloc;\n+      nalloc = 2 * dollar_arguments_alloc + 16;\n+      dollar_arguments_used = xrealloc (dollar_arguments_used, nalloc);\n+      memset (dollar_arguments_used + dollar_arguments_alloc, 0,\n+\t      nalloc - dollar_arguments_alloc);\n+      dollar_arguments_alloc = nalloc;\n+    }\n+  if (!(fki->flags & FMT_FLAG_DOLLAR_MULTIPLE)\n+      && dollar_arguments_used[argnum - 1] == 1)\n+    {\n+      dollar_arguments_used[argnum - 1] = 2;\n+      status_warning (status,\n+\t\t      \"format argument %d used more than once in %s format\",\n+\t\t      argnum, fki->name);\n+    }\n+  else\n+    dollar_arguments_used[argnum - 1] = 1;\n+  if (dollar_first_arg_num)\n+    {\n+      int i;\n+      *param_ptr = params;\n+      for (i = 1; i < argnum && *param_ptr != 0; i++)\n+\t*param_ptr = TREE_CHAIN (*param_ptr);\n+\n+      if (*param_ptr == 0)\n+\t{\n+\t  /* This case shouldn't be caught here.  */\n+\t  abort ();\n+\t}\n+    }\n+  else\n+    *param_ptr = 0;\n+  return argnum;\n+}\n+\n+\n+/* Finish the checking for a format string that used $ operand number formats\n+   instead of non-$ formats.  We check for unused operands before used ones\n+   (a serious error, since the implementation of the format function\n+   can't know what types to pass to va_arg to find the later arguments).\n+   and for unused operands at the end of the format (if we know how many\n+   arguments the format had, so not for vprintf).  If there were operand\n+   numbers out of range on a non-vprintf-style format, we won't have reached\n+   here.  */\n+\n+static void\n+finish_dollar_format_checking (status, res)\n+     int *status;\n+     format_check_results *res;\n+{\n+  int i;\n+  for (i = 0; i < dollar_max_arg_used; i++)\n+    {\n+      if (!dollar_arguments_used[i])\n+\tstatus_warning (status, \"format argument %d unused before used argument %d in $-style format\",\n+\t\t i + 1, dollar_max_arg_used);\n+    }\n+  if (dollar_first_arg_num && dollar_max_arg_used < dollar_arguments_count)\n+    {\n+      res->number_other--;\n+      res->number_dollar_extra_args++;\n+    }\n+}\n+\n+\n+/* Retrieve the specification for a format flag.  SPEC contains the\n+   specifications for format flags for the applicable kind of format.\n+   FLAG is the flag in question.  If PREDICATES is NULL, the basic\n+   spec for that flag must be retrieved and this function aborts if\n+   it cannot be found.  If PREDICATES is not NULL, it is a string listing\n+   possible predicates for the spec entry; if an entry predicated on any\n+   of these is found, it is returned, otherwise NULL is returned.  */\n+\n+static const format_flag_spec *\n+get_flag_spec (spec, flag, predicates)\n+     const format_flag_spec *spec;\n+     int flag;\n+     const char *predicates;\n+{\n+  int i;\n+  for (i = 0; spec[i].flag_char != 0; i++)\n+    {\n+      if (spec[i].flag_char != flag)\n+\tcontinue;\n+      if (predicates != NULL)\n+\t{\n+\t  if (spec[i].predicate != 0\n+\t      && strchr (predicates, spec[i].predicate) != 0)\n+\t    return &spec[i];\n+\t}\n+      else if (spec[i].predicate == 0)\n+\treturn &spec[i];\n+    }\n+  if (predicates == NULL)\n+    abort ();\n+  else\n+    return NULL;\n+}\n+\n+\n+/* Check the argument list of a call to printf, scanf, etc.\n+   INFO points to the function_format_info structure.\n+   PARAMS is the list of argument values.  */\n+\n+static void\n+check_format_info (status, info, params)\n+     int *status;\n+     function_format_info *info;\n+     tree params;\n+{\n+  int arg_num;\n+  tree format_tree;\n+  format_check_results res;\n+  /* Skip to format argument.  If the argument isn't available, there's\n+     no work for us to do; prototype checking will catch the problem.  */\n+  for (arg_num = 1; ; ++arg_num)\n+    {\n+      if (params == 0)\n+\treturn;\n+      if (arg_num == info->format_num)\n+\tbreak;\n+      params = TREE_CHAIN (params);\n+    }\n+  format_tree = TREE_VALUE (params);\n+  params = TREE_CHAIN (params);\n+  if (format_tree == 0)\n+    return;\n+\n+  res.number_non_literal = 0;\n+  res.number_extra_args = 0;\n+  res.number_dollar_extra_args = 0;\n+  res.number_wide = 0;\n+  res.number_empty = 0;\n+  res.number_unterminated = 0;\n+  res.number_other = 0;\n+\n+  check_format_info_recurse (status, &res, info, format_tree, params, arg_num);\n+\n+  if (res.number_non_literal > 0)\n+    {\n+      /* Functions taking a va_list normally pass a non-literal format\n+\t string.  These functions typically are declared with\n+\t first_arg_num == 0, so avoid warning in those cases.  */\n+      if (!(format_types[info->format_type].flags & FMT_FLAG_ARG_CONVERT))\n+\t{\n+\t  /* For strftime-like formats, warn for not checking the format\n+\t     string; but there are no arguments to check.  */\n+\t  if (warn_format_nonliteral)\n+\t    status_warning (status, \"format not a string literal, format string not checked\");\n+\t}\n+      else if (info->first_arg_num != 0)\n+\t{\n+\t  /* If there are no arguments for the format at all, we may have\n+\t     printf (foo) which is likely to be a security hole.  */\n+\t  while (arg_num + 1 < info->first_arg_num)\n+\t    {\n+\t      if (params == 0)\n+\t\tbreak;\n+\t      params = TREE_CHAIN (params);\n+\t      ++arg_num;\n+\t    }\n+\t  if (params == 0 && (warn_format_nonliteral || warn_format_security))\n+\t    status_warning (status, \"format not a string literal and no format arguments\");\n+\t  else if (warn_format_nonliteral)\n+\t    status_warning (status, \"format not a string literal, argument types not checked\");\n+\t}\n+    }\n+\n+  /* If there were extra arguments to the format, normally warn.  However,\n+     the standard does say extra arguments are ignored, so in the specific\n+     case where we have multiple leaves (conditional expressions or\n+     ngettext) allow extra arguments if at least one leaf didn't have extra\n+     arguments, but was otherwise OK (either non-literal or checked OK).\n+     If the format is an empty string, this should be counted similarly to the\n+     case of extra format arguments.  */\n+  if (res.number_extra_args > 0 && res.number_non_literal == 0\n+      && res.number_other == 0 && warn_format_extra_args)\n+    status_warning (status, \"too many arguments for format\");\n+  if (res.number_dollar_extra_args > 0 && res.number_non_literal == 0\n+      && res.number_other == 0 && warn_format_extra_args)\n+    status_warning (status, \"unused arguments in $-style format\");\n+  if (res.number_empty > 0 && res.number_non_literal == 0\n+      && res.number_other == 0)\n+    status_warning (status, \"zero-length format string\");\n+\n+  if (res.number_wide > 0)\n+    status_warning (status, \"format is a wide character string\");\n+\n+  if (res.number_unterminated > 0)\n+    status_warning (status, \"unterminated format string\");\n+}\n+\n+\n+/* Recursively check a call to a format function.  FORMAT_TREE is the\n+   format parameter, which may be a conditional expression in which\n+   both halves should be checked.  ARG_NUM is the number of the\n+   format argument; PARAMS points just after it in the argument list.  */\n+\n+static void\n+check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n+     int *status;\n+     format_check_results *res;\n+     function_format_info *info;\n+     tree format_tree;\n+     tree params;\n+     int arg_num;\n+{\n+  int format_length;\n+  const char *format_chars;\n+  tree array_size = 0;\n+  tree array_init;\n+\n+  if (TREE_CODE (format_tree) == NOP_EXPR)\n+    {\n+      /* Strip coercion.  */\n+      check_format_info_recurse (status, res, info,\n+\t\t\t\t TREE_OPERAND (format_tree, 0), params,\n+\t\t\t\t arg_num);\n+      return;\n+    }\n+\n+  if (TREE_CODE (format_tree) == CALL_EXPR\n+      && TREE_CODE (TREE_OPERAND (format_tree, 0)) == ADDR_EXPR\n+      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (format_tree, 0), 0))\n+\t  == FUNCTION_DECL))\n+    {\n+      tree function = TREE_OPERAND (TREE_OPERAND (format_tree, 0), 0);\n+\n+      /* See if this is a call to a known internationalization function\n+\t that modifies the format arg.  */\n+      international_format_info *iinfo;\n+\n+      for (iinfo = international_format_list; iinfo; iinfo = iinfo->next)\n+\tif (iinfo->assembler_name\n+\t    ? (iinfo->assembler_name == DECL_ASSEMBLER_NAME (function))\n+\t    : (iinfo->name == DECL_NAME (function)))\n+\t  {\n+\t    tree inner_args;\n+\t    int i;\n+\n+\t    for (inner_args = TREE_OPERAND (format_tree, 1), i = 1;\n+\t\t inner_args != 0;\n+\t\t inner_args = TREE_CHAIN (inner_args), i++)\n+\t      if (i == iinfo->format_num)\n+\t\t{\n+\t\t  /* FIXME: with Marc Espie's __attribute__((nonnull))\n+\t\t     patch in GCC, we will have chained attributes,\n+\t\t     and be able to handle functions like ngettext\n+\t\t     with multiple format_arg attributes properly.  */\n+\t\t  check_format_info_recurse (status, res, info,\n+\t\t\t\t\t     TREE_VALUE (inner_args), params,\n+\t\t\t\t\t     arg_num);\n+\t\t  return;\n+\t\t}\n+\t  }\n+    }\n+\n+  if (TREE_CODE (format_tree) == COND_EXPR)\n+    {\n+      /* Check both halves of the conditional expression.  */\n+      check_format_info_recurse (status, res, info,\n+\t\t\t\t TREE_OPERAND (format_tree, 1), params,\n+\t\t\t\t arg_num);\n+      check_format_info_recurse (status, res, info,\n+\t\t\t\t TREE_OPERAND (format_tree, 2), params,\n+\t\t\t\t arg_num);\n+      return;\n+    }\n+\n+  if (integer_zerop (format_tree))\n+    {\n+      /* FIXME: this warning should go away once Marc Espie's\n+\t __attribute__((nonnull)) patch is in.  Instead, checking for\n+\t nonnull attributes should probably change this function to act\n+\t specially if info == NULL and add a res->number_null entry for\n+\t that case, or maybe add a function pointer to be called at\n+\t the end instead of hardcoding check_format_info_main.  */\n+      status_warning (status, \"null format string\");\n+\n+      /* Skip to first argument to check, so we can see if this format\n+\t has any arguments (it shouldn't).  */\n+      while (arg_num + 1 < info->first_arg_num)\n+\t{\n+\t  if (params == 0)\n+\t    return;\n+\t  params = TREE_CHAIN (params);\n+\t  ++arg_num;\n+\t}\n+\n+      if (params == 0)\n+\tres->number_other++;\n+      else\n+\tres->number_extra_args++;\n+\n+      return;\n+    }\n+\n+  if (TREE_CODE (format_tree) != ADDR_EXPR)\n+    {\n+      res->number_non_literal++;\n+      return;\n+    }\n+  format_tree = TREE_OPERAND (format_tree, 0);\n+  if (TREE_CODE (format_tree) == VAR_DECL\n+      && TREE_CODE (TREE_TYPE (format_tree)) == ARRAY_TYPE\n+      && (array_init = decl_constant_value (format_tree)) != format_tree\n+      && TREE_CODE (array_init) == STRING_CST)\n+    {\n+      /* Extract the string constant initializer.  Note that this may include\n+\t a trailing NUL character that is not in the array (e.g.\n+\t const char a[3] = \"foo\";).  */\n+      array_size = DECL_SIZE_UNIT (format_tree);\n+      format_tree = array_init;\n+    }\n+  if (TREE_CODE (format_tree) != STRING_CST)\n+    {\n+      res->number_non_literal++;\n+      return;\n+    }\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (format_tree))) != char_type_node)\n+    {\n+      res->number_wide++;\n+      return;\n+    }\n+  format_chars = TREE_STRING_POINTER (format_tree);\n+  format_length = TREE_STRING_LENGTH (format_tree);\n+  if (array_size != 0)\n+    {\n+      /* Variable length arrays can't be initialized.  */\n+      if (TREE_CODE (array_size) != INTEGER_CST)\n+\tabort ();\n+      if (host_integerp (array_size, 0))\n+\t{\n+\t  HOST_WIDE_INT array_size_value = TREE_INT_CST_LOW (array_size);\n+\t  if (array_size_value > 0\n+\t      && array_size_value == (int) array_size_value\n+\t      && format_length > array_size_value)\n+\t    format_length = array_size_value;\n+\t}\n+    }\n+  if (format_length < 1)\n+    {\n+      res->number_unterminated++;\n+      return;\n+    }\n+  if (format_length == 1)\n+    {\n+      res->number_empty++;\n+      return;\n+    }\n+  if (format_chars[--format_length] != 0)\n+    {\n+      res->number_unterminated++;\n+      return;\n+    }\n+\n+  /* Skip to first argument to check.  */\n+  while (arg_num + 1 < info->first_arg_num)\n+    {\n+      if (params == 0)\n+\treturn;\n+      params = TREE_CHAIN (params);\n+      ++arg_num;\n+    }\n+  /* Provisionally increment res->number_other; check_format_info_main\n+     will decrement it if it finds there are extra arguments, but this way\n+     need not adjust it for every return.  */\n+  res->number_other++;\n+  check_format_info_main (status, res, info, format_chars, format_length,\n+\t\t\t  params, arg_num);\n+}\n+\n+\n+/* Do the main part of checking a call to a format function.  FORMAT_CHARS\n+   is the NUL-terminated format string (which at this point may contain\n+   internal NUL characters); FORMAT_LENGTH is its length (excluding the\n+   terminating NUL character).  ARG_NUM is one less than the number of\n+   the first format argument to check; PARAMS points to that format\n+   argument in the list of arguments.  */\n+\n+static void\n+check_format_info_main (status, res, info, format_chars, format_length,\n+\t\t\tparams, arg_num)\n+     int *status;\n+     format_check_results *res;\n+     function_format_info *info;\n+     const char *format_chars;\n+     int format_length;\n+     tree params;\n+     int arg_num;\n+{\n+  const char *orig_format_chars = format_chars;\n+  tree first_fillin_param = params;\n+\n+  const format_kind_info *fki = &format_types[info->format_type];\n+  const format_flag_spec *flag_specs = fki->flag_specs;\n+  const format_flag_pair *bad_flag_pairs = fki->bad_flag_pairs;\n+\n+  /* -1 if no conversions taking an operand have been found; 0 if one has\n+     and it didn't use $; 1 if $ formats are in use.  */\n+  int has_operand_number = -1;\n+\n+  init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n+\n+  while (1)\n+    {\n+      int i;\n+      int suppressed = FALSE;\n+      const char *length_chars = NULL;\n+      enum format_lengths length_chars_val = FMT_LEN_none;\n+      enum format_std_version length_chars_std = STD_C89;\n+      int format_char;\n+      tree cur_param;\n+      tree wanted_type;\n+      int main_arg_num = 0;\n+      tree main_arg_params = 0;\n+      enum format_std_version wanted_type_std;\n+      const char *wanted_type_name;\n+      format_wanted_type width_wanted_type;\n+      format_wanted_type precision_wanted_type;\n+      format_wanted_type main_wanted_type;\n+      format_wanted_type *first_wanted_type = NULL;\n+      format_wanted_type *last_wanted_type = NULL;\n+      const format_length_info *fli = NULL;\n+      const format_char_info *fci = NULL;\n+      char flag_chars[256];\n+      int aflag = 0;\n+      if (*format_chars == 0)\n+\t{\n+\t  if (format_chars - orig_format_chars != format_length)\n+\t    status_warning (status, \"embedded `\\\\0' in format\");\n+\t  if (info->first_arg_num != 0 && params != 0\n+\t      && has_operand_number <= 0)\n+\t    {\n+\t      res->number_other--;\n+\t      res->number_extra_args++;\n+\t    }\n+\t  if (has_operand_number > 0)\n+\t    finish_dollar_format_checking (status, res);\n+\t  return;\n+\t}\n+      if (*format_chars++ != '%')\n+\tcontinue;\n+      if (*format_chars == 0)\n+\t{\n+\t  status_warning (status, \"spurious trailing `%%' in format\");\n+\t  continue;\n+\t}\n+      if (*format_chars == '%')\n+\t{\n+\t  ++format_chars;\n+\t  continue;\n+\t}\n+      flag_chars[0] = 0;\n+\n+      if ((fki->flags & FMT_FLAG_USE_DOLLAR) && has_operand_number != 0)\n+\t{\n+\t  /* Possibly read a $ operand number at the start of the format.\n+\t     If one was previously used, one is required here.  If one\n+\t     is not used here, we can't immediately conclude this is a\n+\t     format without them, since it could be printf %m or scanf %*.  */\n+\t  int opnum;\n+\t  opnum = maybe_read_dollar_number (status, &format_chars, 0,\n+\t\t\t\t\t    first_fillin_param,\n+\t\t\t\t\t    &main_arg_params, fki);\n+\t  if (opnum == -1)\n+\t    return;\n+\t  else if (opnum > 0)\n+\t    {\n+\t      has_operand_number = 1;\n+\t      main_arg_num = opnum + info->first_arg_num - 1;\n+\t    }\n+\t}\n+\n+      /* Read any format flags, but do not yet validate them beyond removing\n+\t duplicates, since in general validation depends on the rest of\n+\t the format.  */\n+      while (*format_chars != 0\n+\t     && strchr (fki->flag_chars, *format_chars) != 0)\n+\t{\n+\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t     *format_chars, NULL);\n+\t  if (strchr (flag_chars, *format_chars) != 0)\n+\t    {\n+\t      status_warning (status, \"repeated %s in format\", _(s->name));\n+\t    }\n+\t  else\n+\t    {\n+\t      i = strlen (flag_chars);\n+\t      flag_chars[i++] = *format_chars;\n+\t      flag_chars[i] = 0;\n+\t    }\n+\t  if (s->skip_next_char)\n+\t    {\n+\t      ++format_chars;\n+\t      if (*format_chars == 0)\n+\t\t{\n+\t\t  status_warning (status, \"missing fill character at end of strfmon format\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  ++format_chars;\n+\t}\n+\n+      /* Read any format width, possibly * or *m$.  */\n+      if (fki->width_char != 0)\n+\t{\n+\t  if (fki->width_type != NULL && *format_chars == '*')\n+\t    {\n+\t      i = strlen (flag_chars);\n+\t      flag_chars[i++] = fki->width_char;\n+\t      flag_chars[i] = 0;\n+\t      /* \"...a field width...may be indicated by an asterisk.\n+\t\t In this case, an int argument supplies the field width...\"  */\n+\t      ++format_chars;\n+\t      if (params == 0)\n+\t\t{\n+\t\t  status_warning (status, \"too few arguments for format\");\n+\t\t  return;\n+\t\t}\n+\t      if (has_operand_number != 0)\n+\t\t{\n+\t\t  int opnum;\n+\t\t  opnum = maybe_read_dollar_number (status, &format_chars,\n+\t\t\t\t\t\t    has_operand_number == 1,\n+\t\t\t\t\t\t    first_fillin_param,\n+\t\t\t\t\t\t    &params, fki);\n+\t\t  if (opnum == -1)\n+\t\t    return;\n+\t\t  else if (opnum > 0)\n+\t\t    {\n+\t\t      has_operand_number = 1;\n+\t\t      arg_num = opnum + info->first_arg_num - 1;\n+\t\t    }\n+\t\t  else\n+\t\t    has_operand_number = 0;\n+\t\t}\n+\t      if (info->first_arg_num != 0)\n+\t\t{\n+\t\t  cur_param = TREE_VALUE (params);\n+\t\t  if (has_operand_number <= 0)\n+\t\t    {\n+\t\t      params = TREE_CHAIN (params);\n+\t\t      ++arg_num;\n+\t\t    }\n+\t\t  width_wanted_type.wanted_type = *fki->width_type;\n+\t\t  width_wanted_type.wanted_type_name = NULL;\n+\t\t  width_wanted_type.pointer_count = 0;\n+\t\t  width_wanted_type.char_lenient_flag = 0;\n+\t\t  width_wanted_type.writing_in_flag = 0;\n+\t\t  width_wanted_type.reading_from_flag = 0;\n+\t\t  width_wanted_type.name = _(\"field width\");\n+\t\t  width_wanted_type.param = cur_param;\n+\t\t  width_wanted_type.arg_num = arg_num;\n+\t\t  width_wanted_type.next = NULL;\n+\t\t  if (last_wanted_type != 0)\n+\t\t    last_wanted_type->next = &width_wanted_type;\n+\t\t  if (first_wanted_type == 0)\n+\t\t    first_wanted_type = &width_wanted_type;\n+\t\t  last_wanted_type = &width_wanted_type;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Possibly read a numeric width.  If the width is zero,\n+\t\t we complain if appropriate.  */\n+\t      int non_zero_width_char = FALSE;\n+\t      int found_width = FALSE;\n+\t      while (ISDIGIT (*format_chars))\n+\t\t{\n+\t\t  found_width = TRUE;\n+\t\t  if (*format_chars != '0')\n+\t\t    non_zero_width_char = TRUE;\n+\t\t  ++format_chars;\n+\t\t}\n+\t      if (found_width && !non_zero_width_char &&\n+\t\t  (fki->flags & FMT_FLAG_ZERO_WIDTH_BAD))\n+\t\tstatus_warning (status, \"zero width in %s format\",\n+\t\t\t\tfki->name);\n+\t      if (found_width)\n+\t\t{\n+\t\t  i = strlen (flag_chars);\n+\t\t  flag_chars[i++] = fki->width_char;\n+\t\t  flag_chars[i] = 0;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Read any format left precision (must be a number, not *).  */\n+      if (fki->left_precision_char != 0 && *format_chars == '#')\n+\t{\n+\t  ++format_chars;\n+\t  i = strlen (flag_chars);\n+\t  flag_chars[i++] = fki->left_precision_char;\n+\t  flag_chars[i] = 0;\n+\t  if (!ISDIGIT (*format_chars))\n+\t    status_warning (status, \"empty left precision in %s format\",\n+\t\t\t    fki->name);\n+\t  while (ISDIGIT (*format_chars))\n+\t    ++format_chars;\n+\t}\n+\n+      /* Read any format precision, possibly * or *m$.  */\n+      if (fki->precision_char != 0 && *format_chars == '.')\n+\t{\n+\t  ++format_chars;\n+\t  i = strlen (flag_chars);\n+\t  flag_chars[i++] = fki->precision_char;\n+\t  flag_chars[i] = 0;\n+\t  if (fki->precision_type != NULL && *format_chars == '*')\n+\t    {\n+\t      /* \"...a...precision...may be indicated by an asterisk.\n+\t\t In this case, an int argument supplies the...precision.\"  */\n+\t      ++format_chars;\n+\t      if (has_operand_number != 0)\n+\t\t{\n+\t\t  int opnum;\n+\t\t  opnum = maybe_read_dollar_number (status, &format_chars,\n+\t\t\t\t\t\t    has_operand_number == 1,\n+\t\t\t\t\t\t    first_fillin_param,\n+\t\t\t\t\t\t    &params, fki);\n+\t\t  if (opnum == -1)\n+\t\t    return;\n+\t\t  else if (opnum > 0)\n+\t\t    {\n+\t\t      has_operand_number = 1;\n+\t\t      arg_num = opnum + info->first_arg_num - 1;\n+\t\t    }\n+\t\t  else\n+\t\t    has_operand_number = 0;\n+\t\t}\n+\t      if (info->first_arg_num != 0)\n+\t\t{\n+\t\t  if (params == 0)\n+\t\t    {\n+\t\t      status_warning (status, \"too few arguments for format\");\n+\t\t      return;\n+\t\t    }\n+\t\t  cur_param = TREE_VALUE (params);\n+\t\t  if (has_operand_number <= 0)\n+\t\t    {\n+\t\t      params = TREE_CHAIN (params);\n+\t\t      ++arg_num;\n+\t\t    }\n+\t\t  precision_wanted_type.wanted_type = *fki->precision_type;\n+\t\t  precision_wanted_type.wanted_type_name = NULL;\n+\t\t  precision_wanted_type.pointer_count = 0;\n+\t\t  precision_wanted_type.char_lenient_flag = 0;\n+\t\t  precision_wanted_type.writing_in_flag = 0;\n+\t\t  precision_wanted_type.reading_from_flag = 0;\n+\t\t  precision_wanted_type.name = _(\"field precision\");\n+\t\t  precision_wanted_type.param = cur_param;\n+\t\t  precision_wanted_type.arg_num = arg_num;\n+\t\t  precision_wanted_type.next = NULL;\n+\t\t  if (last_wanted_type != 0)\n+\t\t    last_wanted_type->next = &precision_wanted_type;\n+\t\t  if (first_wanted_type == 0)\n+\t\t    first_wanted_type = &precision_wanted_type;\n+\t\t  last_wanted_type = &precision_wanted_type;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!(fki->flags & FMT_FLAG_EMPTY_PREC_OK)\n+\t\t  && !ISDIGIT (*format_chars))\n+\t\tstatus_warning (status, \"empty precision in %s format\",\n+\t\t\t\tfki->name);\n+\t      while (ISDIGIT (*format_chars))\n+\t\t++format_chars;\n+\t    }\n+\t}\n+\n+      /* Read any length modifier, if this kind of format has them.  */\n+      fli = fki->length_char_specs;\n+      length_chars = NULL;\n+      length_chars_val = FMT_LEN_none;\n+      length_chars_std = STD_C89;\n+      if (fli)\n+\t{\n+\t  while (fli->name != 0 && fli->name[0] != *format_chars)\n+\t    fli++;\n+\t  if (fli->name != 0)\n+\t    {\n+\t      format_chars++;\n+\t      if (fli->double_name != 0 && fli->name[0] == *format_chars)\n+\t\t{\n+\t\t  format_chars++;\n+\t\t  length_chars = fli->double_name;\n+\t\t  length_chars_val = fli->double_index;\n+\t\t  length_chars_std = fli->double_std;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  length_chars = fli->name;\n+\t\t  length_chars_val = fli->index;\n+\t\t  length_chars_std = fli->std;\n+\t\t}\n+\t      i = strlen (flag_chars);\n+\t      flag_chars[i++] = fki->length_code_char;\n+\t      flag_chars[i] = 0;\n+\t    }\n+\t  if (pedantic)\n+\t    {\n+\t      /* Warn if the length modifier is non-standard.  */\n+\t      if (ADJ_STD (length_chars_std) > C_STD_VER)\n+\t\tstatus_warning (status, \"%s does not support the `%s' %s length modifier\",\n+\t\t\t\tC_STD_NAME (length_chars_std), length_chars,\n+\t\t\t\tfki->name);\n+\t    }\n+\t}\n+\n+      /* Read any modifier (strftime E/O).  */\n+      if (fki->modifier_chars != NULL)\n+\t{\n+\t  while (*format_chars != 0\n+\t\t && strchr (fki->modifier_chars, *format_chars) != 0)\n+\t    {\n+\t      if (strchr (flag_chars, *format_chars) != 0)\n+\t\t{\n+\t\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t\t     *format_chars, NULL);\n+\t\t  status_warning (status, \"repeated %s in format\", _(s->name));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  i = strlen (flag_chars);\n+\t\t  flag_chars[i++] = *format_chars;\n+\t\t  flag_chars[i] = 0;\n+\t\t}\n+\t      ++format_chars;\n+\t    }\n+\t}\n+\n+      /* Handle the scanf allocation kludge.  */\n+      if (fki->flags & FMT_FLAG_SCANF_A_KLUDGE)\n+\t{\n+\t  if (*format_chars == 'a' && !flag_isoc99)\n+\t    {\n+\t      if (format_chars[1] == 's' || format_chars[1] == 'S'\n+\t\t  || format_chars[1] == '[')\n+\t\t{\n+\t\t  /* `a' is used as a flag.  */\n+\t\t  i = strlen (flag_chars);\n+\t\t  flag_chars[i++] = 'a';\n+\t\t  flag_chars[i] = 0;\n+\t\t  format_chars++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      format_char = *format_chars;\n+      if (format_char == 0\n+\t  || (!(fki->flags & FMT_FLAG_FANCY_PERCENT_OK) && format_char == '%'))\n+\t{\n+\t  status_warning (status, \"conversion lacks type at end of format\");\n+\t  continue;\n+\t}\n+      format_chars++;\n+      fci = fki->conversion_specs;\n+      while (fci->format_chars != 0\n+\t     && strchr (fci->format_chars, format_char) == 0)\n+\t  ++fci;\n+      if (fci->format_chars == 0)\n+\t{\n+          if (ISGRAPH(format_char))\n+\t    status_warning (status, \"unknown conversion type character `%c' in format\",\n+\t\t     format_char);\n+\t  else\n+\t    status_warning (status, \"unknown conversion type character 0x%x in format\",\n+\t\t     format_char);\n+\t  continue;\n+\t}\n+      if (pedantic)\n+\t{\n+\t  if (ADJ_STD (fci->std) > C_STD_VER)\n+\t    status_warning (status, \"%s does not support the `%%%c' %s format\",\n+\t\t\t    C_STD_NAME (fci->std), format_char, fki->name);\n+\t}\n+\n+      /* Validate the individual flags used, removing any that are invalid.  */\n+      {\n+\tint d = 0;\n+\tfor (i = 0; flag_chars[i] != 0; i++)\n+\t  {\n+\t    const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t       flag_chars[i], NULL);\n+\t    flag_chars[i - d] = flag_chars[i];\n+\t    if (flag_chars[i] == fki->length_code_char)\n+\t      continue;\n+\t    if (strchr (fci->flag_chars, flag_chars[i]) == 0)\n+\t      {\n+\t\tstatus_warning (status, \"%s used with `%%%c' %s format\",\n+\t\t\t\t_(s->name), format_char, fki->name);\n+\t\td++;\n+\t\tcontinue;\n+\t      }\n+\t    if (pedantic)\n+\t      {\n+\t\tconst format_flag_spec *t;\n+\t\tif (ADJ_STD (s->std) > C_STD_VER)\n+\t\t  status_warning (status, \"%s does not support %s\",\n+\t\t\t\t  C_STD_NAME (s->std), _(s->long_name));\n+\t\tt = get_flag_spec (flag_specs, flag_chars[i], fci->flags2);\n+\t\tif (t != NULL && ADJ_STD (t->std) > ADJ_STD (s->std))\n+\t\t  {\n+\t\t    const char *long_name = (t->long_name != NULL\n+\t\t\t\t\t     ? t->long_name\n+\t\t\t\t\t     : s->long_name);\n+\t\t    if (ADJ_STD (t->std) > C_STD_VER)\n+\t\t      status_warning (status, \"%s does not support %s with the `%%%c' %s format\",\n+\t\t\t\t      C_STD_NAME (t->std), _(long_name),\n+\t\t\t\t      format_char, fki->name);\n+\t\t  }\n+\t      }\n+\t  }\n+\tflag_chars[i - d] = 0;\n+      }\n+\n+      if ((fki->flags & FMT_FLAG_SCANF_A_KLUDGE)\n+\t  && strchr (flag_chars, 'a') != 0)\n+\taflag = 1;\n+\n+      if (fki->suppression_char\n+\t  && strchr (flag_chars, fki->suppression_char) != 0)\n+\tsuppressed = 1;\n+\n+      /* Validate the pairs of flags used.  */\n+      for (i = 0; bad_flag_pairs[i].flag_char1 != 0; i++)\n+\t{\n+\t  const format_flag_spec *s, *t;\n+\t  if (strchr (flag_chars, bad_flag_pairs[i].flag_char1) == 0)\n+\t    continue;\n+\t  if (strchr (flag_chars, bad_flag_pairs[i].flag_char2) == 0)\n+\t    continue;\n+\t  if (bad_flag_pairs[i].predicate != 0\n+\t      && strchr (fci->flags2, bad_flag_pairs[i].predicate) == 0)\n+\t    continue;\n+\t  s = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char1, NULL);\n+\t  t = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char2, NULL);\n+\t  if (bad_flag_pairs[i].ignored)\n+\t    {\n+\t      if (bad_flag_pairs[i].predicate != 0)\n+\t\tstatus_warning (status, \"%s ignored with %s and `%%%c' %s format\",\n+\t\t\t\t_(s->name), _(t->name), format_char,\n+\t\t\t\tfki->name);\n+\t      else\n+\t\tstatus_warning (status, \"%s ignored with %s in %s format\",\n+\t\t\t\t_(s->name), _(t->name), fki->name);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (bad_flag_pairs[i].predicate != 0)\n+\t\tstatus_warning (status, \"use of %s and %s together with `%%%c' %s format\",\n+\t\t\t\t_(s->name), _(t->name), format_char,\n+\t\t\t\tfki->name);\n+\t      else\n+\t\tstatus_warning (status, \"use of %s and %s together in %s format\",\n+\t\t\t\t_(s->name), _(t->name), fki->name);\n+\t    }\n+\t}\n+\n+      /* Give Y2K warnings.  */\n+      if (warn_format_y2k)\n+\t{\n+\t  int y2k_level = 0;\n+\t  if (strchr (fci->flags2, '4') != 0)\n+\t    if (strchr (flag_chars, 'E') != 0)\n+\t      y2k_level = 3;\n+\t    else\n+\t      y2k_level = 2;\n+\t  else if (strchr (fci->flags2, '3') != 0)\n+\t    y2k_level = 3;\n+\t  else if (strchr (fci->flags2, '2') != 0)\n+\t    y2k_level = 2;\n+\t  if (y2k_level == 3)\n+\t    status_warning (status, \"`%%%c' yields only last 2 digits of year in some locales\",\n+\t\t\t    format_char);\n+\t  else if (y2k_level == 2)\n+\t    status_warning (status, \"`%%%c' yields only last 2 digits of year\", format_char);\n+\t}\n+\n+      if (strchr (fci->flags2, '[') != 0)\n+\t{\n+\t  /* Skip over scan set, in case it happens to have '%' in it.  */\n+\t  if (*format_chars == '^')\n+\t    ++format_chars;\n+\t  /* Find closing bracket; if one is hit immediately, then\n+\t     it's part of the scan set rather than a terminator.  */\n+\t  if (*format_chars == ']')\n+\t    ++format_chars;\n+\t  while (*format_chars && *format_chars != ']')\n+\t    ++format_chars;\n+\t  if (*format_chars != ']')\n+\t    /* The end of the format string was reached.  */\n+\t    status_warning (status, \"no closing `]' for `%%[' format\");\n+\t}\n+\n+      wanted_type = 0;\n+      wanted_type_name = 0;\n+      if (fki->flags & FMT_FLAG_ARG_CONVERT)\n+\t{\n+\t  wanted_type = (fci->types[length_chars_val].type\n+\t\t\t ? *fci->types[length_chars_val].type : 0);\n+\t  wanted_type_name = fci->types[length_chars_val].name;\n+\t  wanted_type_std = fci->types[length_chars_val].std;\n+\t  if (wanted_type == 0)\n+\t    {\n+\t      status_warning (status, \"use of `%s' length modifier with `%c' type character\",\n+\t\t\t      length_chars, format_char);\n+\t      /* Heuristic: skip one argument when an invalid length/type\n+\t\t combination is encountered.  */\n+\t      arg_num++;\n+\t      if (params == 0)\n+\t\t{\n+\t\t  status_warning (status, \"too few arguments for format\");\n+\t\t  return;\n+\t\t}\n+\t      params = TREE_CHAIN (params);\n+\t      continue;\n+\t    }\n+\t  else if (pedantic\n+\t\t   /* Warn if non-standard, provided it is more non-standard\n+\t\t      than the length and type characters that may already\n+\t\t      have been warned for.  */\n+\t\t   && ADJ_STD (wanted_type_std) > ADJ_STD (length_chars_std)\n+\t\t   && ADJ_STD (wanted_type_std) > ADJ_STD (fci->std))\n+\t    {\n+\t      if (ADJ_STD (wanted_type_std) > C_STD_VER)\n+\t\tstatus_warning (status, \"%s does not support the `%%%s%c' %s format\",\n+\t\t\t\tC_STD_NAME (wanted_type_std), length_chars,\n+\t\t\t\tformat_char, fki->name);\n+\t    }\n+\t}\n+\n+      /* Finally. . .check type of argument against desired type!  */\n+      if (info->first_arg_num == 0)\n+\tcontinue;\n+      if ((fci->pointer_count == 0 && wanted_type == void_type_node)\n+\t  || suppressed)\n+\t{\n+\t  if (main_arg_num != 0)\n+\t    {\n+\t      if (suppressed)\n+\t\tstatus_warning (status, \"operand number specified with suppressed assignment\");\n+\t      else\n+\t\tstatus_warning (status, \"operand number specified for format taking no argument\");\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (main_arg_num != 0)\n+\t    {\n+\t      arg_num = main_arg_num;\n+\t      params = main_arg_params;\n+\t    }\n+\t  else\n+\t    {\n+\t      ++arg_num;\n+\t      if (has_operand_number > 0)\n+\t\t{\n+\t\t  status_warning (status, \"missing $ operand number in format\");\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\thas_operand_number = 0;\n+\t      if (params == 0)\n+\t\t{\n+\t\t  status_warning (status, \"too few arguments for format\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  cur_param = TREE_VALUE (params);\n+\t  params = TREE_CHAIN (params);\n+\t  main_wanted_type.wanted_type = wanted_type;\n+\t  main_wanted_type.wanted_type_name = wanted_type_name;\n+\t  main_wanted_type.pointer_count = fci->pointer_count + aflag;\n+\t  main_wanted_type.char_lenient_flag = 0;\n+\t  if (strchr (fci->flags2, 'c') != 0)\n+\t    main_wanted_type.char_lenient_flag = 1;\n+\t  main_wanted_type.writing_in_flag = 0;\n+\t  main_wanted_type.reading_from_flag = 0;\n+\t  if (aflag)\n+\t    main_wanted_type.writing_in_flag = 1;\n+\t  else\n+\t    {\n+\t      if (strchr (fci->flags2, 'W') != 0)\n+\t\tmain_wanted_type.writing_in_flag = 1;\n+\t      if (strchr (fci->flags2, 'R') != 0)\n+\t\tmain_wanted_type.reading_from_flag = 1;\n+\t    }\n+\t  main_wanted_type.name = NULL;\n+\t  main_wanted_type.param = cur_param;\n+\t  main_wanted_type.arg_num = arg_num;\n+\t  main_wanted_type.next = NULL;\n+\t  if (last_wanted_type != 0)\n+\t    last_wanted_type->next = &main_wanted_type;\n+\t  if (first_wanted_type == 0)\n+\t    first_wanted_type = &main_wanted_type;\n+\t  last_wanted_type = &main_wanted_type;\n+\t}\n+\n+      if (first_wanted_type != 0)\n+\tcheck_format_types (status, first_wanted_type);\n+\n+    }\n+}\n+\n+\n+/* Check the argument types from a single format conversion (possibly\n+   including width and precision arguments).  */\n+static void\n+check_format_types (status, types)\n+     int *status;\n+     format_wanted_type *types;\n+{\n+  for (; types != 0; types = types->next)\n+    {\n+      tree cur_param;\n+      tree cur_type;\n+      tree orig_cur_type;\n+      tree wanted_type;\n+      tree promoted_type;\n+      int arg_num;\n+      int i;\n+      int char_type_flag;\n+      cur_param = types->param;\n+      cur_type = TREE_TYPE (cur_param);\n+      if (cur_type == error_mark_node)\n+\tcontinue;\n+      char_type_flag = 0;\n+      wanted_type = types->wanted_type;\n+      arg_num = types->arg_num;\n+\n+      /* The following should not occur here.  */\n+      if (wanted_type == 0)\n+\tabort ();\n+      if (wanted_type == void_type_node && types->pointer_count == 0)\n+\tabort ();\n+\n+      if (types->pointer_count == 0)\n+\t{\n+\t  promoted_type = simple_type_promotes_to (wanted_type);\n+\t  if (promoted_type != NULL_TREE)\n+\t    wanted_type = promoted_type;\n+\t}\n+\n+      STRIP_NOPS (cur_param);\n+\n+      /* Check the types of any additional pointer arguments\n+\t that precede the \"real\" argument.  */\n+      for (i = 0; i < types->pointer_count; ++i)\n+\t{\n+\t  if (TREE_CODE (cur_type) == POINTER_TYPE)\n+\t    {\n+\t      cur_type = TREE_TYPE (cur_type);\n+\t      if (cur_type == error_mark_node)\n+\t\tbreak;\n+\n+\t      /* Check for writing through a NULL pointer.  */\n+\t      if (types->writing_in_flag\n+\t\t  && i == 0\n+\t\t  && cur_param != 0\n+\t\t  && integer_zerop (cur_param))\n+\t\tstatus_warning (status,\n+\t\t\t\t\"writing through null pointer (arg %d)\",\n+\t\t\t\targ_num);\n+\n+\t      /* Check for reading through a NULL pointer.  */\n+\t      if (types->reading_from_flag\n+\t\t  && i == 0\n+\t\t  && cur_param != 0\n+\t\t  && integer_zerop (cur_param))\n+\t\tstatus_warning (status,\n+\t\t\t\t\"reading through null pointer (arg %d)\",\n+\t\t\t\targ_num);\n+\n+\t      if (cur_param != 0 && TREE_CODE (cur_param) == ADDR_EXPR)\n+\t\tcur_param = TREE_OPERAND (cur_param, 0);\n+\t      else\n+\t\tcur_param = 0;\n+\n+\t      /* See if this is an attempt to write into a const type with\n+\t\t scanf or with printf \"%n\".  Note: the writing in happens\n+\t\t at the first indirection only, if for example\n+\t\t void * const * is passed to scanf %p; passing\n+\t\t const void ** is simply passing an incompatible type.  */\n+\t      if (types->writing_in_flag\n+\t\t  && i == 0\n+\t\t  && (TYPE_READONLY (cur_type)\n+\t\t      || (cur_param != 0\n+\t\t\t  && (TREE_CODE_CLASS (TREE_CODE (cur_param)) == 'c'\n+\t\t\t      || (DECL_P (cur_param)\n+\t\t\t\t  && TREE_READONLY (cur_param))))))\n+\t\tstatus_warning (status, \"writing into constant object (arg %d)\", arg_num);\n+\n+\t      /* If there are extra type qualifiers beyond the first\n+\t\t indirection, then this makes the types technically\n+\t\t incompatible.  */\n+\t      if (i > 0\n+\t\t  && pedantic\n+\t\t  && (TYPE_READONLY (cur_type)\n+\t\t      || TYPE_VOLATILE (cur_type)\n+\t\t      || TYPE_RESTRICT (cur_type)))\n+\t\tstatus_warning (status, \"extra type qualifiers in format argument (arg %d)\",\n+\t\t\t arg_num);\n+\n+\t    }\n+\t  else\n+\t    {\n+\t      if (types->pointer_count == 1)\n+\t\tstatus_warning (status, \"format argument is not a pointer (arg %d)\", arg_num);\n+\t      else\n+\t\tstatus_warning (status, \"format argument is not a pointer to a pointer (arg %d)\", arg_num);\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (i < types->pointer_count)\n+\tcontinue;\n+\n+      orig_cur_type = cur_type;\n+      cur_type = TYPE_MAIN_VARIANT (cur_type);\n+\n+      /* Check whether the argument type is a character type.  This leniency\n+\t only applies to certain formats, flagged with 'c'.\n+      */\n+      if (types->char_lenient_flag)\n+\tchar_type_flag = (cur_type == char_type_node\n+\t\t\t  || cur_type == signed_char_type_node\n+\t\t\t  || cur_type == unsigned_char_type_node);\n+\n+      /* Check the type of the \"real\" argument, if there's a type we want.  */\n+      if (wanted_type == cur_type)\n+\tcontinue;\n+      /* If we want `void *', allow any pointer type.\n+\t (Anything else would already have got a warning.)\n+\t With -pedantic, only allow pointers to void and to character\n+\t types.  */\n+      if (wanted_type == void_type_node\n+\t  && (!pedantic || (i == 1 && char_type_flag)))\n+\tcontinue;\n+      /* Don't warn about differences merely in signedness, unless\n+\t -pedantic.  With -pedantic, warn if the type is a pointer\n+\t target and not a character type, and for character types at\n+\t a second level of indirection.  */\n+      if (TREE_CODE (wanted_type) == INTEGER_TYPE\n+\t  && TREE_CODE (cur_type) == INTEGER_TYPE\n+\t  && (! pedantic || i == 0 || (i == 1 && char_type_flag))\n+\t  && (TREE_UNSIGNED (wanted_type)\n+\t      ? wanted_type == unsigned_type (cur_type)\n+\t      : wanted_type == signed_type (cur_type)))\n+\tcontinue;\n+      /* Likewise, \"signed char\", \"unsigned char\" and \"char\" are\n+\t equivalent but the above test won't consider them equivalent.  */\n+      if (wanted_type == char_type_node\n+\t  && (! pedantic || i < 2)\n+\t  && char_type_flag)\n+\tcontinue;\n+      /* Now we have a type mismatch.  */\n+      {\n+\tregister const char *this;\n+\tregister const char *that;\n+\n+\tthis = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n+\tthat = 0;\n+\tif (TYPE_NAME (orig_cur_type) != 0\n+\t    && TREE_CODE (orig_cur_type) != INTEGER_TYPE\n+\t    && !(TREE_CODE (orig_cur_type) == POINTER_TYPE\n+\t\t && TREE_CODE (TREE_TYPE (orig_cur_type)) == INTEGER_TYPE))\n+\t  {\n+\t    if (TREE_CODE (TYPE_NAME (orig_cur_type)) == TYPE_DECL\n+\t\t&& DECL_NAME (TYPE_NAME (orig_cur_type)) != 0)\n+\t      that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (orig_cur_type)));\n+\t    else\n+\t      that = IDENTIFIER_POINTER (TYPE_NAME (orig_cur_type));\n+\t  }\n+\n+\t/* A nameless type can't possibly match what the format wants.\n+\t   So there will be a warning for it.\n+\t   Make up a string to describe vaguely what it is.  */\n+\tif (that == 0)\n+\t  {\n+\t    if (TREE_CODE (orig_cur_type) == POINTER_TYPE)\n+\t      that = \"pointer\";\n+\t    else\n+\t      that = \"different type\";\n+\t  }\n+\n+\t/* Make the warning better in case of mismatch of int vs long.  */\n+\tif (TREE_CODE (orig_cur_type) == INTEGER_TYPE\n+\t    && TREE_CODE (wanted_type) == INTEGER_TYPE\n+\t    && TYPE_PRECISION (orig_cur_type) == TYPE_PRECISION (wanted_type)\n+\t    && TYPE_NAME (orig_cur_type) != 0\n+\t    && TREE_CODE (TYPE_NAME (orig_cur_type)) == TYPE_DECL)\n+\t  that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (orig_cur_type)));\n+\n+\tif (strcmp (this, that) != 0)\n+\t  {\n+\t    /* There may be a better name for the format, e.g. size_t,\n+\t       but we should allow for programs with a perverse typedef\n+\t       making size_t something other than what the compiler\n+\t       thinks.  */\n+\t    if (types->wanted_type_name != 0\n+\t\t&& strcmp (types->wanted_type_name, that) != 0)\n+\t      this = types->wanted_type_name;\n+\t    if (types->name != 0)\n+\t      status_warning (status, \"%s is not type %s (arg %d)\", types->name, this,\n+\t\t       arg_num);\n+\t    else\n+\t      status_warning (status, \"%s format, %s arg (arg %d)\", this, that, arg_num);\n+\t  }\n+      }\n+    }\n+}"}, {"sha": "b5a9194e621811f5b4d1143f7214bb34ad22f640", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1312c143f8f7a87b44e0536d66364bd9216ff5a4", "patch": "@@ -1,3 +1,7 @@\n+2001-01-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Add c-format.o.\n+\n 2001-01-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* g++.1: Change to be \".so man1/gcc.1\"."}, {"sha": "766e695ab82d5b6e7f7214d5fcd251d6b140dd87", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312c143f8f7a87b44e0536d66364bd9216ff5a4/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=1312c143f8f7a87b44e0536d66364bd9216ff5a4", "patch": "@@ -90,7 +90,7 @@ $(DEMANGLER_PROG): cxxmain.o underscore.o $(LIBDEPS)\n \n # The compiler itself.\n # Shared with C front end:\n-CXX_C_OBJS = c-common.o c-pragma.o c-semantics.o c-lex.o c-dump.o $(CXX_TARGET_OBJS)\n+CXX_C_OBJS = c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o c-dump.o $(CXX_TARGET_OBJS)\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/errfn.o cp/expr.o cp/pt.o cp/typeck2.o \\"}]}