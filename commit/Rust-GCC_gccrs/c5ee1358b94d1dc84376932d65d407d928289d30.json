{"sha": "c5ee1358b94d1dc84376932d65d407d928289d30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlZTEzNThiOTRkMWRjODQzNzY5MzJkNjVkNDA3ZDkyODI4OWQzMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2010-09-06T17:48:53Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2010-09-06T17:48:53Z"}, "message": "c-common.h (do_warn_double_promotion): Declare.\n\n\t* c-common.h (do_warn_double_promotion): Declare.\n\t* c-common.c (do_warn_double_promotion): Define.\n\n\t* c-typeck.c (do_warn_double_promotion): Remove.\n\t* doc/invoke.texi (-Wdouble-promotion): Note available for C++ and\n\tObjective-C++ too.\n\n\t* typeck.c (cp_build_binary_op): Call do_warn_double_promotion.\n\t* call.c (build_conditional_expr): Likewise.\n\t(convert_arg_to_ellipsis): Likewise.\n\n\t* g++.dg/warn/Wdouble-promotion.C: New.\n\nFrom-SVN: r163925", "tree": {"sha": "8d764bed307ee0730b51e4687fd0373d0bbc7c5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d764bed307ee0730b51e4687fd0373d0bbc7c5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5ee1358b94d1dc84376932d65d407d928289d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ee1358b94d1dc84376932d65d407d928289d30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ee1358b94d1dc84376932d65d407d928289d30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ee1358b94d1dc84376932d65d407d928289d30/comments", "author": null, "committer": null, "parents": [{"sha": "c28350ab29cf774843ebdefc3f62cd6b203e4489", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c28350ab29cf774843ebdefc3f62cd6b203e4489", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c28350ab29cf774843ebdefc3f62cd6b203e4489"}], "stats": {"total": 235, "additions": 190, "deletions": 45}, "files": [{"sha": "38771e1d7ca305417c2d5c87f5f045114d249192", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -1,3 +1,9 @@\n+2010-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-typeck.c (do_warn_double_promotion): Remove.\n+\t* doc/invoke.texi (-Wdouble-promotion): Note available for C++ and\n+\tObjective-C++ too.\n+\n 2010-09-06  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/frv/frv.h (CLASS_LIKELY_SPILLED_P): Remove."}, {"sha": "50c4ea14aac2bf63c9c6790c6eb11b1d932a9449", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -1,3 +1,8 @@\n+2010-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.h (do_warn_double_promotion): Declare.\n+\t* c-common.c (do_warn_double_promotion): Define.\n+\n 2010-09-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c.opt (Wdouble-promotion): New."}, {"sha": "48c67b4bcd46ecaeffa102eb4224c97b62cc00fa", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -9128,6 +9128,40 @@ warn_for_sign_compare (location_t location,\n     }\n }\n \n+/* RESULT_TYPE is the result of converting TYPE1 and TYPE2 to a common\n+   type via c_common_type.  If -Wdouble-promotion is in use, and the\n+   conditions for warning have been met, issue a warning.  GMSGID is\n+   the warning message.  It must have two %T specifiers for the type\n+   that was converted (generally \"float\") and the type to which it was\n+   converted (generally \"double), respectively.  LOC is the location\n+   to which the awrning should refer.  */\n+\n+void\n+do_warn_double_promotion (tree result_type, tree type1, tree type2,\n+\t\t\t const char *gmsgid, location_t loc)\n+{\n+  tree source_type;\n+\n+  if (!warn_double_promotion)\n+    return;\n+  /* If the conversion will not occur at run-time, there is no need to\n+     warn about it.  */\n+  if (c_inhibit_evaluation_warnings)\n+    return;\n+  if (TYPE_MAIN_VARIANT (result_type) != double_type_node\n+      && TYPE_MAIN_VARIANT (result_type) != complex_double_type_node)\n+    return;\n+  if (TYPE_MAIN_VARIANT (type1) == float_type_node\n+      || TYPE_MAIN_VARIANT (type1) == complex_float_type_node)\n+    source_type = type1;\n+  else if (TYPE_MAIN_VARIANT (type2) == float_type_node\n+\t   || TYPE_MAIN_VARIANT (type2) == complex_float_type_node)\n+    source_type = type2;\n+  else\n+    return;\n+  warning_at (loc, OPT_Wdouble_promotion, gmsgid, source_type, result_type);\n+}\n+\n /* Setup a TYPE_DECL node as a typedef representation.\n \n    X is a TYPE_DECL for a typedef statement.  Create a brand new"}, {"sha": "6118f518bc67bc010f34a71d5ab4ba27682969d5", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -900,6 +900,8 @@ extern void warn_for_sign_compare (location_t,\n \t\t\t\t   tree op0, tree op1,\n \t\t\t\t   tree result_type,\n \t\t\t\t   enum tree_code resultcode);\n+extern void do_warn_double_promotion (tree, tree, tree, const char *, \n+\t\t\t\t      location_t);\n extern void set_underlying_type (tree x);\n extern VEC(tree,gc) *make_tree_vector (void);\n extern void release_tree_vector (VEC(tree,gc) *);"}, {"sha": "08a3825a436f67bb157c61ec39e5b43911cbf649", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -4036,40 +4036,6 @@ ep_convert_and_check (tree type, tree expr, tree semantic_type)\n   return convert (type, expr);\n }\n \n-/* RESULT_TYPE is the result of converting TYPE1 and TYPE2 to a common\n-   type via c_common_type.  If -Wdouble-promotion is in use, and the\n-   conditions for warning have been met, issue a warning.  GMSGID is\n-   the warning message.  It must have two %T specifiers for the type\n-   that was converted (generally \"float\") and the type to which it was\n-   converted (generally \"double), respectively.  LOC is the location\n-   to which the awrning should refer.  */\n-\n-static void\n-do_warn_double_promotion (tree result_type, tree type1, tree type2,\n-\t\t\t const char *gmsgid, location_t loc)\n-{\n-  tree source_type;\n-\n-  if (!warn_double_promotion)\n-    return;\n-  /* If the conversion will not occur at run-time, there is no need to\n-     warn about it.  */\n-  if (c_inhibit_evaluation_warnings)\n-    return;\n-  if (TYPE_MAIN_VARIANT (result_type) != double_type_node\n-      && TYPE_MAIN_VARIANT (result_type) != complex_double_type_node)\n-    return;\n-  if (TYPE_MAIN_VARIANT (type1) == float_type_node\n-      || TYPE_MAIN_VARIANT (type1) == complex_float_type_node)\n-    source_type = type1;\n-  else if (TYPE_MAIN_VARIANT (type2) == float_type_node\n-\t   || TYPE_MAIN_VARIANT (type2) == complex_float_type_node)\n-    source_type = type2;\n-  else\n-    return;\n-  warning_at (loc, OPT_Wdouble_promotion, gmsgid, source_type, result_type);\n-}\n-\n /* Build and return a conditional expression IFEXP ? OP1 : OP2.  If\n    IFEXP_BCP then the condition is a call to __builtin_constant_p, and\n    if folded to an integer constant then the unselected half may"}, {"sha": "99c720cad3d68e2bfeca5056be7b084a30cfbae9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -1,3 +1,9 @@\n+2010-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* typeck.c (cp_build_binary_op): Call do_warn_double_promotion.\n+\t* call.c (build_conditional_expr): Likewise.\n+\t(convert_arg_to_ellipsis): Likewise.\n+\n 2010-09-06  Arnaud Charlet  <charlet@adacore.com>\n \n \t* parser.c (make_pointer_declarator, make_reference_declarator,"}, {"sha": "37c6269455eb33f76a9a89687ed35e184f32e273", "filename": "gcc/cp/call.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -4009,6 +4009,10 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n       /* In this case, there is always a common type.  */\n       result_type = type_after_usual_arithmetic_conversions (arg2_type,\n \t\t\t\t\t\t\t     arg3_type);\n+      do_warn_double_promotion (result_type, arg2_type, arg3_type,\n+\t\t\t\t\"implicit conversion from %qT to %qT to \"\n+\t\t\t\t\"match other result of conditional\",\n+\t\t\t\tinput_location);\n \n       if (TREE_CODE (arg2_type) == ENUMERAL_TYPE\n \t  && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n@@ -5301,33 +5305,44 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n tree\n convert_arg_to_ellipsis (tree arg)\n {\n+  tree arg_type;\n+\n   /* [expr.call]\n \n      The lvalue-to-rvalue, array-to-pointer, and function-to-pointer\n      standard conversions are performed.  */\n   arg = decay_conversion (arg);\n+  arg_type = TREE_TYPE (arg);\n   /* [expr.call]\n \n      If the argument has integral or enumeration type that is subject\n      to the integral promotions (_conv.prom_), or a floating point\n      type that is subject to the floating point promotion\n      (_conv.fpprom_), the value of the argument is converted to the\n      promoted type before the call.  */\n-  if (TREE_CODE (TREE_TYPE (arg)) == REAL_TYPE\n-      && (TYPE_PRECISION (TREE_TYPE (arg))\n+  if (TREE_CODE (arg_type) == REAL_TYPE\n+      && (TYPE_PRECISION (arg_type)\n \t  < TYPE_PRECISION (double_type_node))\n-      && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (arg))))\n-    arg = convert_to_real (double_type_node, arg);\n-  else if (NULLPTR_TYPE_P (TREE_TYPE (arg)))\n+      && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (arg_type)))\n+    {\n+      if (warn_double_promotion && !c_inhibit_evaluation_warnings)\n+\twarning (OPT_Wdouble_promotion,\n+\t\t \"implicit conversion from %qT to %qT when passing \"\n+\t\t \"argument to function\",\n+\t\t arg_type, double_type_node);\n+      arg = convert_to_real (double_type_node, arg);\n+    }\n+  else if (NULLPTR_TYPE_P (arg_type))\n     arg = null_pointer_node;\n-  else if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (arg)))\n+  else if (INTEGRAL_OR_ENUMERATION_TYPE_P (arg_type))\n     arg = perform_integral_promotions (arg);\n \n   arg = require_complete_type (arg);\n+  arg_type = TREE_TYPE (arg);\n \n   if (arg != error_mark_node\n-      && (type_has_nontrivial_copy_init (TREE_TYPE (arg))\n-\t  || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (arg))))\n+      && (type_has_nontrivial_copy_init (arg_type)\n+\t  || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (arg_type)))\n     {\n       /* [expr.call] 5.2.2/7:\n \t Passing a potentially-evaluated argument of class type (Clause 9)\n@@ -5342,7 +5357,7 @@ convert_arg_to_ellipsis (tree arg)\n \t it is not potentially-evaluated.  */\n       if (cp_unevaluated_operand == 0)\n \terror (\"cannot pass objects of non-trivially-copyable \"\n-\t       \"type %q#T through %<...%>\", TREE_TYPE (arg));\n+\t       \"type %q#T through %<...%>\", arg_type);\n     }\n \n   return arg;"}, {"sha": "e96272fd7ccc4af2429f8c1335e6534ef14a5ffd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -265,6 +265,7 @@ cp_common_type (tree t1, tree t2)\n   enum tree_code code2 = TREE_CODE (t2);\n   tree attributes;\n \n+\n   /* In what follows, we slightly generalize the rules given in [expr] so\n      as to deal with `long long' and `complex'.  First, merge the\n      attributes.  */\n@@ -4362,7 +4363,14 @@ cp_build_binary_op (location_t location,\n   if (!result_type\n       && arithmetic_types_p\n       && (shorten || common || short_compare))\n-    result_type = cp_common_type (type0, type1);\n+    {\n+      result_type = cp_common_type (type0, type1);\n+      do_warn_double_promotion (result_type, type0, type1,\n+\t\t\t\t\"implicit conversion from %qT to %qT \"\n+\t\t\t\t\"to match other operand of binary \"\n+\t\t\t\t\"expression\",\n+\t\t\t\tlocation);\n+    }\n \n   if (!result_type)\n     {"}, {"sha": "5d9de6d6474b46c14467fe32888ef098f52d5275", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -3053,7 +3053,7 @@ This warning is enabled by @option{-Wall}.\n \n Suppress warning messages emitted by @code{#warning} directives.\n \n-@item -Wdouble-promotion @r{(C and Objective-C only)}\n+@item -Wdouble-promotion @r{(C, C++, Objective-C and Objective-C++ only)}\n @opindex Wdouble-promotion\n @opindex Wno-double-promotion\n Give a warning when a value of type @code{float} is implicitly"}, {"sha": "a00c76a9a06bd8a2cf2754aedb6c059d6bd1bf53", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -1,3 +1,7 @@\n+2010-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/warn/Wdouble-promotion.C: New.\n+\n 2010-09-06  Arnaud Charlet  <charlet@adacore.com>\n \n \t* g++.dg/parse/redef2.C: New."}, {"sha": "9b4044f77f62695f2cc17513817cedc4f3f0d030", "filename": "gcc/testsuite/g++.dg/warn/Wdouble-promotion.C", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee1358b94d1dc84376932d65d407d928289d30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C?ref=c5ee1358b94d1dc84376932d65d407d928289d30", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wdouble-promotion\" } */\n+\n+#include <stddef.h>\n+\n+/* Some targets do not provide <complex.h> so we define I ourselves.  */\n+#define I 1.0iF\n+#define ID ((_Complex double)I)\n+\n+float f;\n+double d;\n+int i;\n+long double ld;\n+_Complex float cf;\n+_Complex double cd;\n+_Complex long double cld;\n+size_t s;\n+\n+extern void varargs_fn (int, ...);\n+extern void double_fn (double);\n+extern float float_fn (void);\n+\n+void \n+usual_arithmetic_conversions(void) \n+{\n+  float local_f;\n+  _Complex float local_cf;\n+\n+  /* Values of type \"float\" are implicitly converted to \"double\" or\n+     \"long double\" due to use in arithmetic with \"double\" or \"long\n+     double\" operands.  */\n+  local_f = f + 1.0;         /* { dg-warning \"implicit\" } */\n+  local_f = f - d;           /* { dg-warning \"implicit\" } */\n+  local_f = 1.0f * 1.0;      /* { dg-warning \"implicit\" } */\n+  local_f = 1.0f / d;        /* { dg-warning \"implicit\" } */\n+\n+  local_cf = cf + 1.0;       /* { dg-warning \"implicit\" } */\n+  local_cf = cf - d;         /* { dg-warning \"implicit\" } */\n+  local_cf = cf + 1.0 * ID;  /* { dg-warning \"implicit\" } */\n+  local_cf = cf - cd;        /* { dg-warning \"implicit\" } */\n+  \n+  local_f = i ? f : d;       /* { dg-warning \"implicit\" } */\n+  i = f == d;                /* { dg-warning \"implicit\" } */\n+  i = d != f;                /* { dg-warning \"implicit\" } */\n+}\n+\n+void \n+default_argument_promotion (void) \n+{\n+  /* Because \"f\" is part of the variable argument list, it is promoted\n+     to \"double\".  */\n+  varargs_fn (1, f);   /* { dg-warning \"implicit\" } */\n+}\n+\n+/* There is no warning when an explicit cast is used to perform the\n+   conversion.  */\n+\n+void\n+casts (void) \n+{\n+  float local_f;\n+  _Complex float local_cf;\n+\n+  local_f = (double)f + 1.0;                 /* { dg-bogus \"implicit\" } */\n+  local_f = (double)f - d;                   /* { dg-bogus \"implicit\" } */\n+  local_f = (double)1.0f + 1.0;              /* { dg-bogus \"implicit\" } */\n+  local_f = (double)1.0f - d;                /* { dg-bogus \"implicit\" } */\n+\n+  local_cf = (_Complex double)cf + 1.0;      /* { dg-bogus \"implicit\" } */\n+  local_cf = (_Complex double)cf - d;        /* { dg-bogus \"implicit\" } */\n+  local_cf = (_Complex double)cf + 1.0 * ID; /* { dg-bogus \"implicit\" } */\n+  local_cf = (_Complex double)cf - cd;       /* { dg-bogus \"implicit\" } */\n+\n+  local_f = i ? (double)f : d;               /* { dg-bogus \"implicit\" } */\n+  i = (double)f == d;                        /* { dg-bogus \"implicit\" } */\n+  i = d != (double)f;                        /* { dg-bogus \"implicit\" } */\n+}\n+\n+/* There is no warning on conversions that occur in assignment (and\n+   assignment-like) contexts.  */\n+\n+void \n+assignments (void)\n+{\n+  d = f;           /* { dg-bogus \"implicit\" } */\n+  double_fn (f);   /* { dg-bogus \"implicit\" } */\n+  d = float_fn (); /* { dg-bogus \"implicit\" } */\n+}\n+\n+/* There is no warning in non-evaluated contexts.  */\n+\n+void\n+non_evaluated (void)\n+{\n+  s = sizeof (f + 1.0);             /* { dg-bogus \"implicit\" } */\n+  s = __alignof__ (f + 1.0);        /* { dg-bogus \"implicit\" } */\n+  d = (__typeof__(f + 1.0))f;       /* { dg-bogus \"implicit\" } */\n+  s = sizeof (i ? f : d);           /* { dg-bogus \"implicit\" } */\n+}"}]}