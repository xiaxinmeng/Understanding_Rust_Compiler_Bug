{"sha": "50c3308739f502960f3c39ce00fcaac47cd6d391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBjMzMwODczOWY1MDI5NjBmM2MzOWNlMDBmY2FhYzQ3Y2Q2ZDM5MQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-01-24T01:52:01Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-01-24T01:52:01Z"}, "message": "Convert all direct memory references to use LO_SUM and remove machdep hack that used to do this.\n\nConvert all direct memory references to use LO_SUM and remove machdep\nhack that used to do this.\nSun Jan 24 21:24:43 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n\t* config/c4x/c4x.c (c4x_emit_move_sequence, c4x_encode_section_info):\n\tNew functions.\n\t(c4x_check_legit_addr): Remove USE and PLUS, allow\n\tLO_SUM, and disable SYMBOL_REF, LABEL_REF, and CONST cases.\n\t(c4x_legitimize_address): Penalise SYMBOL_REF, LABEL_REF, and\n\tCONST cases.  Add LO_SUM.\n\t(c4x_print_operand): Modified 'C' and 'R' cases for calls.\n\tAdded 'U' case.  Remove dependence on SYMBOL_REF_FLAG.\n\t(c4x_print_operand_address): Handle LO_SUM.\n\t(c4x_scan_for_ldp): Delete.  Hooray!\n\t(c4x_process_after_reload): Remove call to c4x_scan_for_ldp.\n\tSplit all insns.\n\t(c4x_immed_int_constant): Renamed from c4x_int_constant.  All callers\n\tchanged.\n\t(c4x_immed_float_constant): Renamed from c4x_float_constant.  All\n \tcallers\tchanged.\n\t(c4x_T_constraint): Allow LO_SUM, disable SYMBOL_REF, LABEL_REF,\n\tand CONST.\n\t(c4x_U_constraint, symbolic_operand): New functions.\n\t(src_operand): Allow 'I' constants in HImode.  Allow LO_SUM,\n\tdisable SYMBOL_REF, LABEL_REF, and CONST.\n\t(lsrc_operand, tsrc_operand): Call src_operand instead of\n\tgeneral_operand.\n\t(c4x_operand_subword): Update comments.\n\t* config/c4x/c4x.c (TARGET_LOAD_ADDRESS): New macro.\n\t(LEGITIMATE_CONSTANT_P): Allow SYMBOL_REF, LABEL_REF, CONST,\n\tplus HIGH and LO_SUM for the C40.\n\t(ENCODE_SECTION_INFO): Define macro.\n\t(symbolic_operand, c4x_U_constraint, c4x_emit_move_sequence): New\n\tprototypes.\n\t(PREDICATE_CODES): Add symbolic_operand.\n\t* config/c4x/c4x.md (movqi, movgqf, movhi, movhi): Call\n\tc4x_emit_move_sequence.\n\t(floatunsqiqf2, fixuns_truncqfqi2): Rework emitted RTL\n\tto avoid symbol references.\n\t(all patterns with g constraint): Replace 'g' constraint with 'rIm'.\n\t(set_high): Renamed from set_high_use.\n\t(set_lo_sum): Renamed from set_ior_lo_use.\n\t(all call patterns): Make MEM explicit in call address operands.\n\tModified output templates to use 'U' modifier.\n\nFrom-SVN: r24842", "tree": {"sha": "0896b913e682e1e0cafd0aa2d8e78c8292368845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0896b913e682e1e0cafd0aa2d8e78c8292368845"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50c3308739f502960f3c39ce00fcaac47cd6d391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50c3308739f502960f3c39ce00fcaac47cd6d391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50c3308739f502960f3c39ce00fcaac47cd6d391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50c3308739f502960f3c39ce00fcaac47cd6d391/comments", "author": null, "committer": null, "parents": [{"sha": "4c1d5c872b9b4fd53ea69e955df5e56b72049d13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c1d5c872b9b4fd53ea69e955df5e56b72049d13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c1d5c872b9b4fd53ea69e955df5e56b72049d13"}], "stats": {"total": 1325, "additions": 710, "deletions": 615}, "files": [{"sha": "776dcdb0742ac225e9484e299822403692efccc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c3308739f502960f3c39ce00fcaac47cd6d391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c3308739f502960f3c39ce00fcaac47cd6d391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50c3308739f502960f3c39ce00fcaac47cd6d391", "patch": "@@ -1,3 +1,48 @@\n+Sun Jan 24 21:24:43 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c (c4x_emit_move_sequence, c4x_encode_section_info):\n+\tNew functions.\n+\t(c4x_check_legit_addr): Remove USE and PLUS, allow\n+\tLO_SUM, and disable SYMBOL_REF, LABEL_REF, and CONST cases.\n+\t(c4x_legitimize_address): Penalise SYMBOL_REF, LABEL_REF, and \n+\tCONST cases.  Add LO_SUM.\n+\t(c4x_print_operand): Modified 'C' and 'R' cases for calls.\n+\tAdded 'U' case.  Remove dependence on SYMBOL_REF_FLAG.\n+\t(c4x_print_operand_address): Handle LO_SUM.\n+\t(c4x_scan_for_ldp): Delete.  Hooray!\n+\t(c4x_process_after_reload): Remove call to c4x_scan_for_ldp.\n+\tSplit all insns.\n+\t(c4x_immed_int_constant): Renamed from c4x_int_constant.  All callers\n+\tchanged.\n+\t(c4x_immed_float_constant): Renamed from c4x_float_constant.  All\n+ \tcallers\tchanged.\n+\t(c4x_T_constraint): Allow LO_SUM, disable SYMBOL_REF, LABEL_REF, \n+\tand CONST.\n+\t(c4x_U_constraint, symbolic_operand): New functions.\n+\t(src_operand): Allow 'I' constants in HImode.  Allow LO_SUM,\n+\tdisable SYMBOL_REF, LABEL_REF, and CONST.\n+\t(lsrc_operand, tsrc_operand): Call src_operand instead of\n+\tgeneral_operand.\n+\t(c4x_operand_subword): Update comments.\n+\n+\t* config/c4x/c4x.c (TARGET_LOAD_ADDRESS): New macro.\n+\t(LEGITIMATE_CONSTANT_P): Allow SYMBOL_REF, LABEL_REF, CONST,\n+\tplus HIGH and LO_SUM for the C40.\n+\t(ENCODE_SECTION_INFO): Define macro.\n+\t(symbolic_operand, c4x_U_constraint, c4x_emit_move_sequence): New\n+\tprototypes.\n+\t(PREDICATE_CODES): Add symbolic_operand.\n+\n+\t* config/c4x/c4x.md (movqi, movgqf, movhi, movhi): Call\n+\tc4x_emit_move_sequence.\n+\t(floatunsqiqf2, fixuns_truncqfqi2): Rework emitted RTL\n+\tto avoid symbol references.\n+\t(all patterns with g constraint): Replace 'g' constraint with 'rIm'.\n+\t(set_high): Renamed from set_high_use.\n+\t(set_lo_sum): Renamed from set_ior_lo_use.\n+\t(all call patterns): Make MEM explicit in call address operands.\n+\tModified output templates to use 'U' modifier.\n+\t\n Sun Jan 24 01:15:05 PST 1999 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "2e4b941136ebdd89f3c92f13f78699c1e0c7c5e4", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 352, "deletions": 312, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c3308739f502960f3c39ce00fcaac47cd6d391/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c3308739f502960f3c39ce00fcaac47cd6d391/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=50c3308739f502960f3c39ce00fcaac47cd6d391", "patch": "@@ -1016,6 +1016,84 @@ c4x_null_epilogue_p ()\n }\n \n \n+int\n+c4x_emit_move_sequence (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;     \n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  if (! reload_in_progress\n+      && ! REG_P (op0) \n+      && ! REG_P (op1)\n+      && ! (stik_const_operand (op1, mode) && ! push_operand (op0, mode)))\n+    op1 = force_reg (mode, op1);\n+\n+  if (symbolic_operand (op1, mode))\n+    {\n+      if (TARGET_LOAD_ADDRESS)\n+\t{\n+\t  /* Alias analysis seems to do a better job if we force\n+\t     constant addresses to memory after reload.  */\n+\t  emit_insn (gen_load_immed_address (op0, op1));\n+\t  return 1;\n+\t}\n+      else\n+\t{\n+\t  /* Stick symbol or label address into the constant pool.  */\n+\t  op1 = force_const_mem (Pmode, op1);\n+\t}\n+    }\n+  else if (mode == HFmode && CONSTANT_P (op1) && ! LEGITIMATE_CONSTANT_P (op1))\n+    {\n+      /* We could be a lot smarter about loading some of these\n+\t constants...  */\n+      op1 = force_const_mem (mode, op1);\n+    }\n+  else if (mode == HImode && CONSTANT_P (op1) && ! LEGITIMATE_CONSTANT_P (op1))\n+    {\n+      /* We could load all sorts of constants in two goes by pulling all\n+\t sorts of tricks... The tricky thing is that we cannot clobber CC\n+\t so that stifles most of the obvious methods.  */\n+      op1 = force_const_mem (mode, op1);\n+    }\n+\n+  /* Convert (MEM (SYMREF)) to a (MEM (LO_SUM (REG) (SYMREF)))\n+     and emit associated (HIGH (SYMREF)) if large memory model.  \n+     c4x_legitimize_address could be used to do this,\n+     perhaps by calling validize_address.  */\n+  if (! (reload_in_progress || reload_completed)\n+      && GET_CODE (op1) == MEM\n+      && symbolic_operand (XEXP (op1, 0), Pmode))\n+    {\n+      rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+      if (! TARGET_SMALL)\n+\temit_insn (gen_set_ldp (dp_reg, XEXP (op1, 0)));\n+      op1 = change_address (op1, mode,\n+\t\t\t    gen_rtx_LO_SUM (Pmode, dp_reg, XEXP (op1, 0)));\n+    }\n+\n+  if (! (reload_in_progress || reload_completed)\n+      && GET_CODE (op0) == MEM \n+      && symbolic_operand (XEXP (op0, 0), Pmode))\n+    {\n+      rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+      if (! TARGET_SMALL)\n+\temit_insn (gen_set_ldp (dp_reg, XEXP (op0, 0)));\n+      op0 = change_address (op0, mode,\n+\t\t\t    gen_rtx_LO_SUM (Pmode, dp_reg, XEXP (op0, 0)));\n+    }\n+\n+  /* Adjust operands in case we have modified them.  */\n+  operands[0] = op0;\n+  operands[1] = op1;\n+\n+  /* Emit normal pattern.  */\n+  return 0;\n+}\n+\n+\n void\n c4x_emit_libcall (name, code, dmode, smode, noperands, operands)\n      char *name;\n@@ -1066,6 +1144,7 @@ c4x_emit_libcall3 (name, code, mode, operands)\n   return c4x_emit_libcall (name, code, mode, mode, 3, operands);\n }\n \n+\n void\n c4x_emit_libcall_mulhi (name, code, mode, operands)\n      char *name;\n@@ -1096,7 +1175,7 @@ c4x_emit_libcall_mulhi (name, code, mode, operands)\n \n enum reg_class\n c4x_preferred_reload_class (x, class)\n-     rtx x;\n+     rtx x ATTRIBUTE_UNUSED;\n      enum reg_class class;\n {\n   return class;\n@@ -1122,6 +1201,22 @@ c4x_secondary_memory_needed (class1, class2, mode)\n }\n \n \n+/* Set the SYMBOL_REF_FLAG for a function decl.  However, wo do not\n+   yet use this info.  */\n+void\n+c4x_encode_section_info (decl)\n+  tree decl;\n+{\n+#if 0\n+  if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)   \n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n+#else\n+  if (TREE_CODE (decl) == FUNCTION_DECL)   \n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n+#endif\n+}\n+\n+\n int\n c4x_check_legit_addr (mode, addr, strict)\n      enum machine_mode mode;\n@@ -1187,19 +1282,6 @@ c4x_check_legit_addr (mode, addr, strict)\n \n \tswitch (code0)\n \t  {\n-\t  case USE:\n-\t    /* The uses are put in to avoid problems\n-\t       with referenced things disappearing.  */\n-\t    return c4x_check_legit_addr (mode, op1, strict);\n-\n-\t  case PLUS:\n-\t    /* This is another reference to keep things\n-\t       from disappearing, but it contains a plus\n-\t       of a use and DP.  */\n-\t    if (GET_CODE (XEXP (op0, 0)) == USE)\n-\t      return c4x_check_legit_addr (mode, op1, strict);\n-\t    return 0;\n-\n \t  case REG:\n \t    if (REG_P (op1))\n \t      {\n@@ -1224,18 +1306,47 @@ c4x_check_legit_addr (mode, addr, strict)\n       }\n       break;\n \n+      /* Direct addressing with DP register.  */\n+    case LO_SUM:\n+      {\n+\trtx op0 = XEXP (addr, 0);\n+\trtx op1 = XEXP (addr, 1);\n+\n+\t/* HImode and HFmode direct memory references aren't truly\n+\t   offsettable (consider case at end of data page).  We\n+\t   probably get better code by loading a pointer and using an\n+\t   indirect memory reference.  */\n+\tif (mode == HImode || mode == HFmode)\n+\t  return 0;\n+\n+\tif (!REG_P (op0) || REGNO (op0) != DP_REGNO)\n+\t  return 0;\n+\n+\tif ((GET_CODE (op1) == SYMBOL_REF || GET_CODE (op1) == LABEL_REF))\n+\t  return 1;\n+\n+\tif (GET_CODE (op1) == CONST)\n+\t  {\n+\t    addr = XEXP (op1, 0);\n+\t    \n+\t    if (GET_CODE (addr) == PLUS\n+\t\t&& (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n+\t\t    || GET_CODE (XEXP (addr, 0)) == LABEL_REF)\n+\t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t      return 1;\n+\t  }\n+\treturn 0;\n+      }\n+      break;\n+\n       /* Direct addressing with some work for the assembler...  */\n     case CONST:\n-      if (GET_CODE (XEXP (addr, 0)) == PLUS\n-\t  && (GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF\n-\t      || GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF)\n-\t  && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)\n-\treturn 1;\n-\n       /* Direct addressing.  */\n-    case SYMBOL_REF:\n     case LABEL_REF:\n-      return 1;\n+    case SYMBOL_REF:\n+      /* These need to be converted to a LO_SUM (...). \n+\t c4x_legitimize_address will fix them up.  */\n+      return 0;\n \n       /* Do not allow direct memory access to absolute addresses.\n          This is more pain than its worth, especially for the\n@@ -1313,6 +1424,16 @@ c4x_legitimize_address (orig, mode)\n      rtx orig ATTRIBUTE_UNUSED;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n+  if (GET_CODE (orig) == SYMBOL_REF)\n+    {\n+      rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+\n+      if (! TARGET_SMALL)\n+\temit_insn (gen_set_ldp (dp_reg, orig));\n+      \n+      return gen_rtx_LO_SUM (Pmode, dp_reg, orig);\n+    }\n+\n   return NULL_RTX;\n }\n \n@@ -1332,32 +1453,46 @@ rtx addr;\n     case REG:\n       return 1;\n \n-    case CONST:\n-      {\n-\trtx offset = const0_rtx;\n-\taddr = eliminate_constant_term (addr, &offset);\n-\t\n-\tif (GET_CODE (addr) == LABEL_REF)\n-\t  return 3;\n-\t\n-\tif (GET_CODE (addr) != SYMBOL_REF)\n-\t  return 4;\n-\n-\tif (INTVAL (offset) == 0)\n-\t  return 3;\n-      }\n-      \n-      /* fall through */\n-      \n     case POST_INC:\n     case POST_DEC:\n     case PRE_INC:\n     case PRE_DEC:\n       return 1;\n       \n+      /* These shouldn't be directly generated.  */\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      return TARGET_SMALL ? 3 : 4;\n+    case CONST:\n+      return 10;\n+\n+    case LO_SUM:\n+      {\n+\trtx op1 = XEXP (addr, 1);\n+\n+\tif (GET_CODE (op1) == LABEL_REF || GET_CODE (op1) == SYMBOL_REF)\n+\t  return TARGET_SMALL ? 3 : 4;\n+\t\n+\tif (GET_CODE (op1) == CONST)\n+\t  {\n+\t    rtx offset = const0_rtx;\n+\t    \n+\t    op1 = eliminate_constant_term (op1, &offset);\n+\t    \n+\t    /* ??? These costs need rethinking... */\n+\t    if (GET_CODE (op1) == LABEL_REF)\n+\t      return 3;\n+\t    \n+\t    if (GET_CODE (op1) != SYMBOL_REF)\n+\t      return 4;\n+\t    \n+\t    if (INTVAL (offset) == 0)\n+\t      return 3;\n+\n+\t    return 4;\n+\t  }\n+\tfatal_insn (\"c4x_address_cost: Invalid addressing mode\", addr);\n+      }\n+      break;\n       \n     case PLUS:\n       {\n@@ -1479,18 +1614,9 @@ c4x_print_operand (file, op, letter)\n \tasm_fprintf (file, \"@\");\n       break;\n \n-    case 'C':\t\t\t/* call */\n-      if (code != MEM)\n-\tfatal_insn (\"c4x_print_operand: %%C inconsistency\", op);\n-      op1 = XEXP (op, 0);\n-      SYMBOL_REF_FLAG (op1) = 1;\n-      output_addr_const (file, op1);\n-      return;\n-\n     case 'H':\t\t\t/* sethi */\n-      if (code == SYMBOL_REF)\n-\tSYMBOL_REF_FLAG (op) = 1;\n-      break;\n+      output_addr_const (file, op);\n+      return;\n \n     case 'I':\t\t\t/* reversed condition */\n       code = reverse_condition (code);\n@@ -1511,9 +1637,9 @@ c4x_print_operand (file, op, letter)\n     case 'K':\t\t\t/* generate ldp(k) if direct address */\n       if (! TARGET_SMALL\n \t  && code == MEM\n-\t  && GET_CODE (XEXP (op, 0)) == PLUS\n-\t  && GET_CODE(XEXP (XEXP (op, 0), 0)) == REG\n-\t  && REGNO(XEXP (XEXP (op, 0), 0)) == DP_REGNO)\n+\t  && GET_CODE (XEXP (op, 0)) == LO_SUM\n+\t  && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n+\t  && REGNO (XEXP (XEXP (op, 0), 0)) == DP_REGNO)\n \t{\n \t  op1 = XEXP (XEXP (op, 0), 1);\n           if (GET_CODE(op1) == CONST_INT || GET_CODE(op1) == SYMBOL_REF)\n@@ -1548,12 +1674,18 @@ c4x_print_operand (file, op, letter)\n \tfatal_insn (\"c4x_print_operand: %%O inconsistency\", op);\n       return;\n \n-    case 'R':\t\t\t/* call register */\n-      op1 = XEXP (op, 0);\n-      if (code != MEM || GET_CODE (op1) != REG)\n-\tfatal_insn (\"c4x_print_operand: %%R inconsistency\", op);\n-      else\n-\tfprintf (file, \"%s\", reg_names[REGNO (op1)]);\n+    case 'C':\t\t\t/* call */\n+      if (code != MEM)\n+\tfatal_insn (\"c4x_print_operand: %%C inconsistency\", op);\n+      op = XEXP (op, 0);\n+      code = GET_CODE (op);\n+      break;\n+\n+    case 'U':\t\t\t/* call/callu */\n+      if (code != MEM)\n+\tfatal_insn (\"c4x_print_operand: %%U inconsistency\", op);\n+      if (GET_CODE (XEXP (op, 0)) != SYMBOL_REF)\n+\tasm_fprintf (file, \"u\");\n       return;\n \n     default:\n@@ -1721,20 +1853,10 @@ c4x_print_operand_address (file, addr)\n       {\n \trtx op0 = XEXP (addr, 0);\n \trtx op1 = XEXP (addr, 1);\n-\tenum rtx_code code0 = GET_CODE (op0);\n \n-\tif (code0 == USE || code0 == PLUS)\n-\t  {\n-\t    asm_fprintf (file, \"@\");\n-\t    output_addr_const (file, op1);\n-\t  }\n-\telse if (REG_P (op0))\n+\tif (REG_P (op0))\n \t  {\n-\t    if (REGNO (op0) == DP_REGNO)\n-\t      {\n-\t\tc4x_print_operand_address (file, op1);\n-\t      }\n-\t    else if (REG_P (op1))\n+\t    if (REG_P (op1))\n \t      {\n \t\tif (IS_INDEX_REGNO (op0))\n \t\t  {\n@@ -1762,16 +1884,28 @@ c4x_print_operand_address (file, addr)\n \t\t\t INTVAL (op1));\t\t/* base + displacement */\n \t      }\n \t  }\n+\telse\n+          fatal_insn (\"c4x_print_operand_address: Bad operand case\", addr);\n+      }\n+      break;\n+\n+    case LO_SUM:\n+      {\n+\trtx op0 = XEXP (addr, 0);\n+\trtx op1 = XEXP (addr, 1);\n+\t  \n+\tif (REG_P (op0) && REGNO (op0) == DP_REGNO)\n+\t  c4x_print_operand_address (file, op1);\n+\telse\n+          fatal_insn (\"c4x_print_operand_address: Bad operand case\", addr);\n       }\n       break;\n \n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      if (! SYMBOL_REF_FLAG (addr))\n-\tfprintf (file, \"@\");\n+      fprintf (file, \"@\");\n       output_addr_const (file, addr);\n-      SYMBOL_REF_FLAG (addr) = 0;\n       break;\n \n       /* We shouldn't access CONST_INT addresses.  */\n@@ -1783,17 +1917,18 @@ c4x_print_operand_address (file, addr)\n     }\n }\n \n-\n+/* Return nonzero if the floating point operand will fit\n+   in the immediate field.  */\n static int\n-c4x_immed_float_p (operand)\n-     rtx operand;\n+c4x_immed_float_p (op)\n+     rtx op;\n {\n   long convval[2];\n   int exponent;\n   REAL_VALUE_TYPE r;\n \n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operand);\n-  if (GET_MODE (operand) == HFmode)\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+  if (GET_MODE (op) == HFmode)\n     REAL_VALUE_TO_TARGET_DOUBLE (r, convval);\n   else\n     {\n@@ -1811,157 +1946,6 @@ c4x_immed_float_p (operand)\n     && (exponent >= -7);\t/* Negative exp */\n }\n \n-\n-/* This function checks for an insn operand that requires direct\n-   addressing and inserts a load of the DP register prior to the\n-   insn if the big memory model is being compiled for.  Immediate\n-   operands that do not fit within the opcode field get changed\n-   into memory references using direct addressing.  At this point\n-   all pseudos have been converted to hard registers.  */\n-\n-int\n-c4x_scan_for_ldp (newop, insn, operand0)\n-     rtx *newop;\n-     rtx insn;\n-     rtx operand0;\n-{\n-  int i;\n-  char *format_ptr;\n-  rtx op0, op1, op2, addr;\n-  rtx operand = *newop;\n-\n-  switch (GET_CODE (operand))\n-    {\n-    case MEM:\n-      op0 = XEXP (operand, 0);\n-\n-      /* We have something we need to emit a load dp insn for.\n-         The first operand should hold the rtx for the instruction\n-         required.  */\n-\n-      switch (GET_CODE (op0))\n-\t{\n-\tcase CONST_INT:\n-\t  fatal_insn (\"c4x_scan_for_ldp: Direct memory access to const_int\",\n-\t\t     op0);\n-\t  break;\n-\n-\tcase CONST:\n-\tcase SYMBOL_REF:\n-\t  if (! TARGET_C3X && ! TARGET_SMALL\n-\t      && recog_memoized (insn) == CODE_FOR_movqi_noclobber\n-\t      && ((addr = find_reg_note (insn, REG_EQUAL, NULL_RTX))\n-\t\t  || (addr = find_reg_note (insn, REG_EQUIV, NULL_RTX)))\n-\t      && (IS_STD_OR_PSEUDO_REGNO (operand0)))\n-\t    {\n-\t      addr = XEXP (addr, 0);\n-\t      if (GET_CODE (addr) == CONST_INT)\n-\t\t{\n-\t\t  op1 = GEN_INT (INTVAL (addr) & ~0xffff);\n-\t\t  emit_insn_before (gen_movqi (operand0, op1), insn);\n-\t\t  op1 = GEN_INT (INTVAL (addr) & 0xffff);\n-\t\t  emit_insn_before (gen_iorqi3_noclobber (operand0,\n-\t\t\t\t\t\t      operand0, op1), insn);\n-\t\t  delete_insn (insn);\n-\t\t  return 1;\n-\t\t}\n-\t      else if (GET_CODE (addr) == SYMBOL_REF)\n-\t\t{\n-\t\t  emit_insn_before (gen_set_high_use (operand0, addr, addr),\n-\t\t\t\t    insn);\n-\t\t  emit_insn_before (gen_set_ior_lo_use (operand0, addr, addr),\n-\t\t\t\t    insn);\n-\t\t  delete_insn (insn);\n-\t\t  return 1;\n-\t\t}\n-\t      else if (GET_CODE (addr) == CONST\n-\t\t       && GET_CODE (op1 = XEXP (addr, 0)) == PLUS\n-\t\t       && GET_CODE (op2 = XEXP (op1, 0)) == SYMBOL_REF\n-\t\t       && GET_CODE (XEXP (op1, 1)) == CONST_INT)\n-\t\t{\n-\t\t  emit_insn_before (gen_set_high_use (operand0, addr, op2),\n-\t\t\t\t    insn);\n-\t\t  emit_insn_before (gen_set_ior_lo_use (operand0, addr, op2),\n-\t\t\t\t    insn);\n-\t\t  delete_insn (insn);\n-\t\t  return 1;\n-\t\t}\n-\t    }\n-\t  if (! TARGET_SMALL)\n-\t    emit_insn_before (gen_set_ldp (gen_rtx_REG (Pmode, DP_REGNO),\n-\t\t\t\t\t   operand), insn);\n-\n-\t  /* Replace old memory reference with direct reference.  */\n-\t  *newop = gen_rtx_MEM (GET_MODE (operand),\n-\t\t\t\tgen_rtx_PLUS (Pmode,\n-\t\t\t\t\t      gen_rtx_REG (Pmode, DP_REGNO),\n-\t\t\t\t\t      op0));\n-\n-\t  /* Use change_address?  */\n-\t  RTX_UNCHANGING_P (*newop) = RTX_UNCHANGING_P (operand);\n-\t  MEM_COPY_ATTRIBUTES (*newop, operand);\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      return 0;\n-\n-    case CONST_INT:\n-      if (SMALL_CONST (INTVAL (operand), insn))\n-\tbreak;\n-      fatal_insn (\"Immediate integer too large\", insn);\n-\n-    case CONST_DOUBLE:\n-      if (c4x_immed_float_p (operand))\n-\tbreak;\n-\n-      /* We'll come here if a CONST_DOUBLE integer has slipped\n-         though the net...  */\n-      fatal_insn (\"Immediate CONST_DOUBLE integer too large\", insn);\n-\n-    case CONST:\n-      fatal_insn (\"Immediate integer not known\", insn);\n-\n-      /* Symbol and label immediate addresses cannot be stored\n-         within a C[34]x instruction, so we store them in memory\n-         and use direct addressing instead.  */\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      if (GET_CODE (operand0) != REG)\n-\tbreak;\n-\n-      op0 = XEXP (force_const_mem (Pmode, operand), 0);\n-      *newop = gen_rtx_MEM (GET_MODE (operand),\n-\t\t\t    gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t      gen_rtx_USE (VOIDmode, operand),\n-\t\t\t\t\t      gen_rtx_REG (Pmode, DP_REGNO)),\n-\t\t\t\t\t  op0));\n-      \n-      if (! TARGET_SMALL)\n-\temit_insn_before (gen_set_ldp_use (gen_rtx_REG (Pmode, DP_REGNO),\n-\t\t\t\t\t   *newop, operand), insn);\n-      return 0;\n-\n-    default:\n-      break;\n-    }\n-\n-  format_ptr = GET_RTX_FORMAT (GET_CODE (operand));\n-\n-  /* Recursively hunt for required loads of DP.  */\n-  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (operand)); i++)\n-    {\n-      if (*format_ptr++ == 'e')\t/* rtx expression */\n-\tif (c4x_scan_for_ldp (&XEXP (operand, i), insn, operand0))\n-\t  break;\n-    }\n-  return 0;\n-}\n-\n-\n /* The last instruction in a repeat block cannot be a Bcond, DBcound,\n    CALL, CALLCond, TRAPcond, RETIcond, RETScond, IDLE, RPTB or RPTS.\n \n@@ -1993,7 +1977,11 @@ c4x_rptb_nop_p (insn)\n \n   /* If there is a label at the end of the loop we must insert\n      a NOP.  */\n-  insn = prev_nonnote_insn (insn);\n+  do {\n+    insn = previous_insn (insn);\n+  } while (GET_CODE (insn) == NOTE\n+\t   || GET_CODE (insn) == USE\n+\t   || GET_CODE (insn) == CLOBBER);\n   if (GET_CODE (insn) == CODE_LABEL)\n     return 1;\n \n@@ -2006,15 +1994,15 @@ c4x_rptb_nop_p (insn)\n \t  if (insn == start_label)\n \t    return i == 0;\n \n-\t  insn = PREV_INSN (insn);\n+\t  insn = previous_insn (insn);\n \t};\n \n       /* If we have a jump instruction we should insert a NOP. If we\n \t hit repeat block top we should only insert a NOP if the loop\n \t is empty. */\n       if (GET_CODE (insn) == JUMP_INSN)\n \treturn 1;\n-      insn = PREV_INSN (insn);\n+      insn = previous_insn (insn);\n     }\n   return 0;\n }\n@@ -2053,20 +2041,16 @@ c4x_rptb_insert (insn)\n   emit_insn_before (gen_rptb_top (start_label, end_label), insn);\n }\n \n-/* This function is a C4x special. It scans through all the insn\n-   operands looking for places where the DP register needs to be\n-   reloaded and for large immediate operands that need to be converted\n-   to memory references.  The latter should be avoidable with proper\n-   definition of patterns in machine description.  We come here right\n-   near the end of things, immediately before delayed branch\n-   scheduling.  */\n+\n+/* This function is a C4x special called immediately before delayed\n+   branch scheduling.  We fix up RTPB style loops that didn't get RC\n+   allocated as the loop counter.  */\n \n void\n c4x_process_after_reload (first)\n      rtx first;\n {\n   rtx insn;\n-  int i;\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n@@ -2086,11 +2070,9 @@ c4x_process_after_reload (first)\n \t    c4x_rptb_insert(insn);\n \n \t  /* We split all insns here if they have a # for the output\n-\t     template if we are using the big memory model since there\n-\t     is a chance that we might be accessing memory across a\n-\t     page boundary.  */\n+\t     template.  */\n \n-\t  if (! TARGET_SMALL)\n+\t  if (1)\n \t    {\n \t      char *template;\n \n@@ -2106,30 +2088,9 @@ c4x_process_after_reload (first)\n \t\t  PUT_CODE (insn, NOTE);\n \t\t  NOTE_SOURCE_FILE (insn) = 0;\n \t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\n-\t\t  /* Do we have to update the basic block info here? \n-\t\t     Maybe reorg wants it sorted out... */\n-\n-\t\t  /* Continue with the first of the new insns generated\n-                     by the split. */\n \t\t  insn = new;\n-\n-\t\t  insn_code_number = recog_memoized (insn);\n-\t\t  \n-\t\t  if (insn_code_number < 0)\n-\t\t    continue;\n \t\t}\n \t    }\n-\n-\t  /* Ignore jumps and calls.  */\n-\t  if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN)\n-\t      continue;\t\n-\n-\t  insn_extract (insn);\n-\t  for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n-\t    if (c4x_scan_for_ldp (recog_operand_loc[i], insn, \n-\t\t\t\t  recog_operand[0]))\n-\t      break;\n \t}\n     }\n }\n@@ -2152,23 +2113,28 @@ c4x_x_register (op)\n \n \n static int\n-c4x_int_constant (op)\n+c4x_immed_int_constant (op)\n      rtx op;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n+\n   return GET_MODE (op) == VOIDmode\n     || GET_MODE_CLASS (op) == MODE_INT\n     || GET_MODE_CLASS (op) == MODE_PARTIAL_INT;\n }\n \n \n static int\n-c4x_float_constant (op)\n+c4x_immed_float_constant (op)\n      rtx op;\n {\n   if (GET_CODE (op) != CONST_DOUBLE)\n     return 0;\n+\n+  if (GET_CODE (XEXP (op, 0)) == MEM)\n+    return 0;\n+\n   return GET_MODE (op) == QFmode || GET_MODE (op) == HFmode;\n }\n \n@@ -2177,15 +2143,15 @@ int\n c4x_H_constant (op)\n      rtx op;\n {\n-  return c4x_float_constant (op) && c4x_immed_float_p (op);\n+  return c4x_immed_float_constant (op) && c4x_immed_float_p (op);\n }\n \n \n int\n c4x_I_constant (op)\n      rtx op;\n {\n-  return c4x_int_constant (op) && IS_INT16_CONST (INTVAL (op));\n+  return c4x_immed_int_constant (op) && IS_INT16_CONST (INTVAL (op));\n }\n \n \n@@ -2195,7 +2161,7 @@ c4x_J_constant (op)\n {\n   if (TARGET_C3X)\n     return 0;\n-  return c4x_int_constant (op) && IS_INT8_CONST (INTVAL (op));\n+  return c4x_immed_int_constant (op) && IS_INT8_CONST (INTVAL (op));\n }\n \n \n@@ -2205,31 +2171,31 @@ c4x_K_constant (op)\n {\n   if (TARGET_C3X)\n     return 0;\n-  return c4x_int_constant (op) && IS_INT5_CONST (INTVAL (op));\n+  return c4x_immed_int_constant (op) && IS_INT5_CONST (INTVAL (op));\n }\n \n \n int\n c4x_L_constant (op)\n      rtx op;\n {\n-  return c4x_int_constant (op) && IS_UINT16_CONST (INTVAL (op));\n+  return c4x_immed_int_constant (op) && IS_UINT16_CONST (INTVAL (op));\n }\n \n \n static int\n c4x_N_constant (op)\n      rtx op;\n {\n-  return c4x_int_constant (op) && IS_NOT_UINT16_CONST (INTVAL (op));\n+  return c4x_immed_int_constant (op) && IS_NOT_UINT16_CONST (INTVAL (op));\n }\n \n \n static int\n c4x_O_constant (op)\n      rtx op;\n {\n-  return c4x_int_constant (op) && IS_HIGH_CONST (INTVAL (op));\n+  return c4x_immed_int_constant (op) && IS_HIGH_CONST (INTVAL (op));\n }\n \n \n@@ -2277,6 +2243,7 @@ c4x_Q_constraint (op)\n \treturn IS_DISP8_CONST (INTVAL (op1));\n       }\n       break;\n+\n     default:\n       break;\n     }\n@@ -2508,7 +2475,7 @@ c4x_S_indirect (op)\n }\n \n \n-/* Symbol ref.  */\n+/* Direct memory operand.  */\n \n int\n c4x_T_constraint (op)\n@@ -2518,27 +2485,37 @@ c4x_T_constraint (op)\n     return 0;\n   op = XEXP (op, 0);\n \n-  if ((GET_CODE (op) == PLUS)\n-      && (GET_CODE (XEXP (op, 0)) == REG)\n-      && (REGNO (XEXP (op, 0)) == DP_REGNO))\n+  if (GET_CODE (op) != LO_SUM)\n     {\n-      op = XEXP (op, 1);\n-    }\n-  else if ((GET_CODE (op) == PLUS)\n-\t   && (GET_CODE (XEXP (op, 0)) == PLUS)\n-\t   && (GET_CODE (XEXP (XEXP (op, 0), 0)) == USE))\n-    {\n-      op = XEXP (op, 1);\n-    }\n-  else if ((GET_CODE (op) == PLUS) && (GET_CODE (XEXP (op, 0)) == USE))\n-    {\n-      op = XEXP (op, 1);\n+      /* Allow call operands.  */\n+      return GET_CODE (op) == SYMBOL_REF\n+\t&& GET_MODE (op) == Pmode\n+\t&& SYMBOL_REF_FLAG (op);\n     }\n \n+  /* HImode and HFmode are not offsettable.  */\n+  if (GET_MODE (op) == HImode || GET_CODE (op) == HFmode)\n+    return 0;\n+\n+  if ((GET_CODE (XEXP (op, 0)) == REG)\n+      && (REGNO (XEXP (op, 0)) == DP_REGNO))\n+    return c4x_U_constraint (XEXP (op, 1));\n+  \n+  return 0;\n+}\n+\n+\n+/* Symbolic operand.  */\n+\n+int\n+c4x_U_constraint (op)\n+     rtx op;\n+{\n   /* Don't allow direct addressing to an arbitrary constant.  */\n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+      && (GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (XEXP (op, 0), 0)) == LABEL_REF)\n       && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n     return 1;\n \n@@ -2657,6 +2634,7 @@ reg_operand (op, mode)\n   return register_operand (op, mode);\n }\n \n+\n int\n reg_imm_operand (op, mode)\n      rtx op;\n@@ -2667,6 +2645,7 @@ reg_imm_operand (op, mode)\n   return 0;\n }\n \n+\n int\n not_modify_reg (op, mode)\n      rtx op;\n@@ -2693,6 +2672,16 @@ not_modify_reg (op, mode)\n \tif (REG_P (op1) || GET_CODE (op1) == CONST_INT)\n \t  return 1;\n       }\n+\n+    case LO_SUM:\n+      {\n+\trtx op0 = XEXP (op, 0);\n+\t  \n+\tif (REG_P (op0) && REGNO (op0) == DP_REGNO)\n+\t  return 1;\n+      }\n+      break;\n+     \n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n@@ -2703,6 +2692,7 @@ not_modify_reg (op, mode)\n   return 0;\n }\n \n+\n int\n not_rc_reg (op, mode)\n      rtx op;\n@@ -2713,6 +2703,7 @@ not_rc_reg (op, mode)\n   return 1;\n }\n \n+\n /* Extended precision register R0-R1.  */\n \n int\n@@ -2867,8 +2858,6 @@ call_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n   op = XEXP (op, 0);\n   switch (GET_CODE (op))\n     {\n@@ -2881,6 +2870,29 @@ call_operand (op, mode)\n }\n \n \n+/* Symbolic operand.  */\n+\n+int\n+symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+\n /* Check src operand of two operand arithmetic instructions.  */\n \n int\n@@ -2894,14 +2906,29 @@ src_operand (op, mode)\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n \n-  /* We could allow certain CONST_INT values for HImode...  */\n   if (GET_CODE (op) == CONST_INT)\n-    return (mode == QImode || mode == Pmode) && c4x_I_constant (op);\n+    return (mode == QImode || mode == Pmode || mode == HImode)\n+      && c4x_I_constant (op);\n \n   /* We don't like CONST_DOUBLE integers.  */\n   if (GET_CODE (op) == CONST_DOUBLE)\n     return c4x_H_constant (op);\n \n+  /* Disallow symbolic addresses.  */\n+  if (GET_CODE (op) == SYMBOL_REF\n+      || GET_CODE (op) == LABEL_REF\n+      || GET_CODE (op) == CONST)\n+    return 0;\n+\n+  /* Disallow direct memory access symbolic addresses. \n+     These are usually caught by the movqi expander and\n+     converted to a LO_SUM.  */\n+  if (GET_CODE (op) == MEM\n+      && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t   || GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t   || GET_CODE (XEXP (op, 0)) == CONST)))\n+    return 0;\n+\n   return general_operand (op, mode);\n }\n \n@@ -2930,13 +2957,10 @@ lsrc_operand (op, mode)\n   if (mode != QImode && mode != Pmode)\n     fatal_insn (\"Mode not QImode\", op);\n \n-  if (REG_P (op))\n-    return reg_operand (op, mode);\n-\n   if (GET_CODE (op) == CONST_INT)\n     return c4x_L_constant (op) || c4x_J_constant (op);\n \n-  return general_operand (op, mode);\n+  return src_operand (op, mode);\n }\n \n \n@@ -2953,13 +2977,10 @@ tsrc_operand (op, mode)\n   if (mode != QImode && mode != Pmode)\n     fatal_insn (\"Mode not QImode\", op);\n \n-  if (REG_P (op))\n-    return reg_operand (op, mode);\n-\n   if (GET_CODE (op) == CONST_INT)\n     return c4x_L_constant (op) || c4x_N_constant (op) || c4x_J_constant (op);\n \n-  return general_operand (op, mode);\n+  return src_operand (op, mode);\n }\n \n \n@@ -3441,7 +3462,7 @@ c4x_valid_operands (code, operands, mode, force)\n \t  break;\n \t  \n \tdefault:\n-\t  fatal (\"c4x_valid_operands: Internal error\");\n+\t  fatal_insn (\"c4x_valid_operands: Internal error\", op2);\n \t  break;\n \t}\n       \n@@ -3922,16 +3943,19 @@ c4x_operand_subword (op, i, validate_address, mode)\n     {\n       enum rtx_code code = GET_CODE (XEXP (op, 0));\n       enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+      enum machine_mode submode;\n+\n+      submode = mode;\n+      if (mode == HImode)\n+\tsubmode = QImode;\n+      else if (mode == HFmode)\n+\tsubmode = QFmode;\n \n       switch (code)\n \t{\n \tcase POST_INC:\n \tcase PRE_INC:\n-\t  if (mode == HImode)\n-\t    mode = QImode;\n-\t  else if (mode == HFmode)\n-\t    mode = QFmode;\n-\t  return gen_rtx_MEM (mode, XEXP (op, 0));\n+\t  return gen_rtx_MEM (submode, XEXP (op, 0));\n \t  \n \tcase POST_DEC:\n \tcase PRE_DEC:\n@@ -3941,6 +3965,23 @@ c4x_operand_subword (op, i, validate_address, mode)\n \t     e.g., *p-- => *(p-=2); *(p+1).  */\n \t  fatal_insn (\"c4x_operand_subword: invalid autoincrement\", op);\n \n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\tcase CONST:\n+\tcase CONST_INT:\n+\t  fatal_insn (\"c4x_operand_subword: invalid address\", op);\n+\n+\t  /* Even though offsettable_address_p considers (MEM\n+\t     (LO_SUM)) to be offsettable, it is not safe if the\n+\t     address is at the end of the data page since we also have\n+\t     to fix up the associated high PART.  In this case where\n+\t     we are trying to split a HImode or HFmode memory\n+\t     reference, we would have to emit another insn to reload a\n+\t     new HIGH value.  It's easier to disable LO_SUM memory references\n+\t     in HImode or HFmode and we probably get better code.  */\n+\tcase LO_SUM:\n+\t  fatal_insn (\"c4x_operand_subword: address not offsettable\", op);\n+  \n \tdefault:\n \t  break;\n \t}\n@@ -4233,7 +4274,6 @@ c4x_adjust_cost (insn, link, dep_insn, cost)\n \n       /* Data dependency; DEP_INSN writes a register that INSN reads some\n \t cycles later.  */\n-\n       if (TARGET_C3X)\n \t{\n \t  if (get_attr_setgroup1 (dep_insn) && get_attr_usegroup1 (insn))\n@@ -4248,7 +4288,6 @@ c4x_adjust_cost (insn, link, dep_insn, cost)\n \t     insn uses ar0-ar7.  We then test if the same register\n \t     is used.  The tricky bit is that some operands will\n \t     use several registers...  */\n-\n \t  if (get_attr_setar0 (dep_insn) && get_attr_usear0 (insn))\n \t    max = SET_USE_COST > max ? SET_USE_COST : max;\n \t  if (get_attr_setlda_ar0 (dep_insn) && get_attr_usear0 (insn))\n@@ -4342,3 +4381,4 @@ c4x_adjust_cost (insn, link, dep_insn, cost)\n   else\n     abort ();\n }\n+"}, {"sha": "c001712c89446f8d0e943626e1ee8a51ee7921d8", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c3308739f502960f3c39ce00fcaac47cd6d391/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c3308739f502960f3c39ce00fcaac47cd6d391/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=50c3308739f502960f3c39ce00fcaac47cd6d391", "patch": "@@ -258,12 +258,16 @@ extern int target_flags;\n #define TARGET_C40\t\t(target_flags & C40_FLAG)\n #define TARGET_C44\t\t(target_flags & C44_FLAG)\n \n+#define TARGET_LOAD_ADDRESS\t(1 || (! TARGET_C3X && ! TARGET_SMALL))\n+\n /* -mrpts            allows the use of the RPTS instruction irregardless.\n    -mrpts=max-cycles will use RPTS if the number of cycles is constant\n    and less than max-cycles. */\n \n #define TARGET_RPTS_CYCLES(CYCLES) (TARGET_RPTS || (CYCLES) < c4x_rpts_cycles)\n \n+#define\tBCT_CHECK_LOOP_ITERATIONS  !(TARGET_LOOP_UNSIGNED)\n+\n /* -mcpu=XX    with XX = target DSP version number */\n \n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n@@ -836,16 +840,17 @@ c4x_secondary_memory_needed(CLASS1, CLASS2, MODE)\n \t: ((C) == 'O') ? (IS_HIGH_CONST (VAL))\t\t\t        \\\n         : 0 )\t\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VAL, C) \t\t\t\t\\\n-        ( ((C) == 'G') ? (fp_zero_operand (VAL))\t\t\t\\\n-\t: ((C) == 'H') ? (c4x_H_constant (VAL)) \t\t\t\\\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(OP, C) \t\t\t\t\\\n+        ( ((C) == 'G') ? (fp_zero_operand (OP))\t\t\t\t\\\n+\t: ((C) == 'H') ? (c4x_H_constant (OP)) \t\t\t\t\\\n \t: 0 )\n \n-#define EXTRA_CONSTRAINT(VAL, C) \\\n-        ( ((C) == 'Q') ? (c4x_Q_constraint (VAL))\t\t\t\\\n-\t: ((C) == 'R') ? (c4x_R_constraint (VAL))\t\t\t\\\n-\t: ((C) == 'S') ? (c4x_S_constraint (VAL))\t\t\t\\\n-\t: ((C) == 'T') ? (c4x_T_constraint (VAL))\t\t\t\\\n+#define EXTRA_CONSTRAINT(OP, C) \\\n+        ( ((C) == 'Q') ? (c4x_Q_constraint (OP))\t\t\t\\\n+\t: ((C) == 'R') ? (c4x_R_constraint (OP))\t\t\t\\\n+\t: ((C) == 'S') ? (c4x_S_constraint (OP))\t\t\t\\\n+\t: ((C) == 'T') ? (c4x_T_constraint (OP))\t\t\t\\\n+\t: ((C) == 'U') ? (c4x_U_constraint (OP))\t\t\t\\\n \t: 0 )\n \n #define SMALL_CONST(VAL, insn)\t\t\t\t\t\t\\\n@@ -1613,17 +1618,44 @@ extern struct rtx_def *c4x_legitimize_address ();\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE. \n \n-   The C4x can only load 16-bit immediate values, so we only allow\n-   a restricted subset of CONST_INT and CONST_DOUBLE and reject\n-   LABEL_REF, SYMBOL_REF, CONST, and HIGH codes.  */\n+   The C4x can only load 16-bit immediate values, so we only allow a\n+   restricted subset of CONST_INT and CONST_DOUBLE.  Disallow\n+   LABEL_REF and SYMBOL_REF (except on the C40 with the big memory\n+   model) so that the symbols will be forced into the constant pool.\n+   On second thoughts, lets do this with the move expanders.\n+*/\n \n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n   ((GET_CODE (X) == CONST_DOUBLE && c4x_H_constant (X))\t\t\\\n-  || (GET_CODE (X) == CONST_INT && c4x_I_constant (X)))\n-\n+  || (GET_CODE (X) == CONST_INT && c4x_I_constant (X))\t\t\\\n+  || (GET_CODE (X) == SYMBOL_REF)\t\t\t\t\\\n+  || (GET_CODE (X) == LABEL_REF)\t\t\t\t\\\n+  || (GET_CODE (X) == CONST)\t\t\t\t\t\\\n+  || (GET_CODE (X) == HIGH && ! TARGET_C3X)\t\t\t\\\n+  || (GET_CODE (X) == LO_SUM && ! TARGET_C3X))\n \n #define LEGITIMATE_DISPLACEMENT_P(X) IS_DISP8_CONST (INTVAL (X))\n \n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   The macro definition, if any, is executed immediately after the\n+   rtl for DECL or other node is created.\n+   The value of the rtl will be a `mem' whose address is a\n+   `symbol_ref'.\n+\n+   The usual thing for this macro to do is to a flag in the\n+   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified\n+   name string in the `symbol_ref' (if one bit is not enough\n+   information).\n+\n+   On the C4x we use this to indicate if a symbol is in text or\n+   data space.  */\n+\n+extern void c4x_encode_section_info ();\n+#define ENCODE_SECTION_INFO(DECL) c4x_encode_section_info (DECL);\n+\n /* Descripting Relative Cost of Operations  */\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n@@ -1912,7 +1944,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n \t  || ! TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n \t  || ! DECL_INITIAL (DECL)\t\t\t\t\t\\\n \t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n-\t      && ! TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n+\t      && ! TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\\\n \tdata_section ();\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \tconst_section ();\t\t\t\t\t\t\\\n@@ -2440,8 +2472,6 @@ do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n \n #define MACHINE_DEPENDENT_REORG(INSNS) c4x_process_after_reload(INSNS)\n \n-#define MACHINE_DEPENDENT_COMBINE(INSNS) c4x_combine_parallel(INSNS)\n-\n #define DBR_OUTPUT_SEQEND(FILE)\t\t\\\n if (final_sequence != NULL_RTX)\t\t\\\n {\t\t\t\t\t\\\n@@ -2492,7 +2522,8 @@ if (final_sequence != NULL_RTX)\t\t\\\n   {\"any_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n   {\"par_ind_operand\", {MEM}},\t\t\t\t\t\\\n   {\"parallel_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"mem_operand\", {MEM}},\t\t\t\t\t\\\n+  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\\\n+  {\"mem_operand\", {MEM}},\t\t\t\t\t\n \n \n /* Variables in c4x.c */\n@@ -2582,6 +2613,8 @@ extern int rc_reg_operand ();\n \n extern int st_reg_operand ();\n \n+extern int symbolic_operand ();\n+\n extern int ar0_reg_operand ();\n \n extern int ar0_mem_operand ();\n@@ -2652,12 +2685,16 @@ extern int c4x_S_constraint ();\n \n extern int c4x_T_constraint ();\n \n+extern int c4x_U_constraint ();\n+\n extern void c4x_emit_libcall ();\n \n extern void c4x_emit_libcall3 ();\n \n extern void c4x_emit_libcall_mulhi ();\n \n+extern int c4x_emit_move_sequence ();\n+\n extern int legitimize_operands ();\n \n extern int valid_operands ();"}, {"sha": "60bc43fd99f1f014f850731defcd0882bfec7a5b", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 259, "deletions": 286, "changes": 545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c3308739f502960f3c39ce00fcaac47cd6d391/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c3308739f502960f3c39ce00fcaac47cd6d391/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=50c3308739f502960f3c39ce00fcaac47cd6d391", "patch": "@@ -23,7 +23,6 @@\n \n ;\n ; TODO :\n-;        Set up addressing macros to handle direct memory references properly.\n ;        Try using PQImode again for addresses since C30 only uses\n ;        24-bit addresses.   Ideally GCC would emit different insns\n ;        for QImode and Pmode, whether Pmode was QImode or PQImode.\n@@ -66,7 +65,7 @@\n ; st_reg_operand        ST                                         [y]\n ; dp_reg_operand        DP                                         [z]\n ; stik_const_operand    5-bit const                                [K]\n-; src_operand           general operand                            [rfmHI]\n+; src_operand           general operand                            [rfHmI]\n ; par_ind_operand       indirect S mode (ARx + 0, 1, IRx)          [S<>]\n ; parallel_operand      par_ind_operand or ext_low_reg_operand\n \n@@ -125,16 +124,20 @@\n ; Q   ARx + 9-bit signed disp\n ; R   ARx + 5-bit unsigned disp  (C4x only)\n ; S   ARx + 0, 1, IRx disp\n-; T   symbol ref (direct)\n+; T   direct memory operand\n ; V   non offsettable memory\n ; X   any operand\n ; <   memory operand with autodecrement addressing\n ; >   memory operand with autoincrement addressing\n ; {   memory operand with pre-modify addressing\n ; }   memory operand with post-modify addressing\n \n-;  Note that the d, f, and h constraints are equivalent.\n-;  The m constraint is equivalent to QT<>{}\n+;  Note that the 'd', 'f', and 'h' constraints are equivalent.\n+;  The m constraint is equivalent to 'QT<>{}'\n+\n+;  Note we cannot use the 'g' constraint with Pmode (i.e, QImode)\n+;  operations since LEGITIMATE_CONSTANT_P accepts SYMBOL_REF.\n+;  So instead we use 'rIm' for signed operands or 'rLm' for unsigned operands.\n \n ;  Note that the constraints are used to select the operands\n ;  for a chosen pattern.  The constraint that requires the fewest\n@@ -1099,37 +1102,79 @@\n   \"* return (TARGET_C3X) ? \\\"ldp\\\\t%A1\\\" : \\\"ldpk\\\\t%A1\\\";\"\n   [(set_attr \"type\" \"ldp\")])\n \n-\n-; Used when moving a constant label reference to an external\n-; location, this will make sure the original label is still\n-; used so the optimizer will not optimize it away.\n-;\n-(define_insn \"set_ldp_use\"\n-  [(parallel [(set (match_operand:QI 0 \"dp_reg_operand\" \"=z\")\n-                   (high:QI (match_operand:QI 1 \"\" \"\")))\n-              (use (match_operand 2 \"\" \"\"))])]\n-  \"! TARGET_SMALL\"\n-  \"* return (TARGET_C3X) ? \\\"ldp\\\\t%A1\\\" : \\\"ldpk\\\\t%A1\\\";\"\n-  [(set_attr \"type\" \"ldp\")])\n-\n-(define_insn \"set_high_use\"\n-  [(parallel [(set (match_operand:QI 0 \"std_reg_operand\" \"=c\")\n-                   (high:QI (match_operand:QI 1 \"\" \"\")))\n-              (use (match_operand 2 \"\" \"\"))])]\n-  \"! TARGET_C3X && ! TARGET_SMALL\"\n+(define_insn \"set_high\"\n+  [(set (match_operand:QI 0 \"std_reg_operand\" \"=c\")\n+        (high:QI (match_operand:QI 1 \"symbolic_operand\" \"\")))]\n+  \"! TARGET_C3X \"\n   \"ldhi\\\\t^%H1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n-(define_insn \"set_ior_lo_use\"\n-  [(parallel [(set (match_operand:QI 0 \"std_reg_operand\" \"=c\")\n-                   (ior:QI (match_dup 0)\n-                           (and:QI (match_operand:QI 1 \"\" \"\")\n-                                   (const_int 65535))))\n-              (use (match_operand 2 \"\" \"\"))])]\n-  \"! TARGET_C3X && ! TARGET_SMALL\"\n+(define_insn \"set_lo_sum\"\n+  [(set (match_operand:QI 0 \"std_reg_operand\" \"=c\")\n+        (lo_sum:QI (match_dup 0)\n+                   (match_operand:QI 1 \"symbolic_operand\" \"\")))]\n+  \"\"\n   \"or\\\\t#%H1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n+(define_split\n+  [(set (match_operand:QI 0 \"std_reg_operand\" \"\")\n+        (match_operand:QI 1 \"symbolic_operand\" \"\"))]\n+  \"! TARGET_C3X\"\n+  [(set (match_dup 0) (high:QI (match_dup 1)))\n+   (set (match_dup 0) (lo_sum:QI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n+; This pattern is required to handle the case where a register that clobbers\n+; CC has been selected to load a symbolic address.  We force the address\n+; into memory and then generate LDP and LDIU insns.\n+; This is also required for the C30 if we pretend that we can \n+; easily load symbolic addresses into a register.\n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+        (match_operand:QI 1 \"symbolic_operand\" \"\"))]\n+  \"! TARGET_SMALL \n+   && (TARGET_C3X || (reload_completed\n+                      && ! std_reg_operand (operands[0], QImode)))\"\n+  [(set (match_dup 2) (high:QI (match_dup 3)))\n+   (set (match_dup 0) (match_dup 4))\n+   (use (match_dup 1))]\n+  \"\n+{\n+   rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+   operands[2] = dp_reg;\n+   operands[3] = force_const_mem (Pmode, operands[1]);\n+   operands[4] = change_address (operands[3], QImode,\n+\t\t\t         gen_rtx_LO_SUM (Pmode, dp_reg,\n+                                                 XEXP (operands[3], 0)));\n+   operands[3] = XEXP (operands[3], 0);\n+}\")\n+\n+; This pattern is similar to the above but does not emit a LDP\n+; for the small memory model.\n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+        (match_operand:QI 1 \"symbolic_operand\" \"\"))]\n+  \"TARGET_SMALL\n+   && (TARGET_C3X || (reload_completed\n+                      && ! std_reg_operand (operands[0], QImode)))\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\n+{  \n+   rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+   operands[1] = force_const_mem (Pmode, operands[1]);\n+   operands[1] = change_address (operands[1], QImode,\n+\t\t\t         gen_rtx_LO_SUM (Pmode, dp_reg,\n+                                                 XEXP (operands[1], 0)));\n+}\")\n+\n+(define_insn \"load_immed_address\"\n+  [(set (match_operand:QI 0 \"reg_operand\" \"=a?x?c*r\")\n+        (match_operand:QI 1 \"symbolic_operand\" \"\"))]\n+   \"TARGET_LOAD_ADDRESS\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n ;\n ; LDIU/LDA/STI/STIK\n ;\n@@ -1148,9 +1193,11 @@\n ; spill a register.\n (define_insn \"movqi_noclobber\"\n   [(set (match_operand:QI 0 \"src_operand\" \"=d,*c,m,r\")\n-        (match_operand:QI 1 \"src_hi_operand\" \"rmI,rmI,r,O\"))]\n-  \"reg_operand (operands[0], QImode)\n-   || reg_operand (operands[1], QImode)\"\n+        (match_operand:QI 1 \"src_hi_operand\" \"rIm,rIm,r,O\"))]\n+  \"(REG_P (operands[0]) || REG_P (operands[1])\n+    || GET_CODE (operands[0]) == SUBREG\n+    || GET_CODE (operands[1]) == SUBREG)\n+    && ! symbolic_operand (operands[1], QImode)\"\n   \"*\n    if (which_alternative == 2)\n      return \\\"sti\\\\t%1,%0\\\";\n@@ -1181,7 +1228,7 @@\n ; We shouldn't need these peepholes, but the combiner seems to miss them...\n (define_peephole\n   [(set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n-        (match_operand:QI 1 \"src_operand\" \"g\"))\n+        (match_operand:QI 1 \"src_operand\" \"rIm\"))\n    (set (reg:CC 21)\n         (compare:CC (match_dup 0) (const_int 0)))]\n   \"\"\n@@ -1192,7 +1239,7 @@\n \n (define_insn \"*movqi_set\"\n   [(set (reg:CC 21)\n-        (compare:CC (match_operand:QI 1 \"src_operand\" \"g\") \n+        (compare:CC (match_operand:QI 1 \"src_operand\" \"rIm\") \n                     (const_int 0)))\n    (set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n         (match_dup 1))]\n@@ -1206,7 +1253,7 @@\n ; when a simple compare with zero will suffice.\n ;(define_insn \"*movqi_test\"\n ; [(set (reg:CC 21)\n-;       (compare:CC (match_operand:QI 1 \"src_operand\" \"g\") \n+;       (compare:CC (match_operand:QI 1 \"src_operand\" \"rIm\") \n ;                   (const_int 0)))\n ;  (clobber (match_scratch:QI 0 \"=d\"))]\n ; \"\"\n@@ -1226,28 +1273,14 @@\n ;  the compiler, have memoized the insn number already.\n \n (define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"src_operand\" \"\")\n-        (match_operand:QI 1 \"src_operand\" \"\"))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+        (match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n-   /* We shouldn't have to do this, since reload is supposed to\n-      be able to do this if we have a memory constraint.  */\n-   if (CONSTANT_P (operands[1])\n-       && ! const_operand (operands[1], QImode))\n-     {\n-        operands[1] = force_const_mem (QImode, operands[1]);\n-        if (! memory_address_p (QImode, XEXP (operands[1], 0))\n-            && ! reload_in_progress)\n-          operands[1] = change_address (operands[1], QImode,\n-                                        XEXP (operands[1], 0));\n-     }\n-\n-   if (! reload_in_progress\n-       && ! reg_operand (operands[0], QImode) \n-       && ! reg_operand (operands[1], QImode)\n-       && ! (stik_const_operand (operands[1], QImode) \n-            && ! push_operand (operands[0], QImode)))\n-     operands[1] = force_reg (QImode, operands[1]);\")\n+{\n+  if (c4x_emit_move_sequence (operands, QImode))\n+    DONE;\n+}\")\n \n (define_insn \"*movqi_update\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=r\") \n@@ -1303,7 +1336,7 @@\n \n (define_insn \"*absqi2_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,c\")\n-        (abs:QI (match_operand:QI 1 \"src_operand\" \"g,g\")))\n+        (abs:QI (match_operand:QI 1 \"src_operand\" \"rIm,rIm\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"\"\n   \"absi\\\\t%1,%0\"\n@@ -1312,7 +1345,7 @@\n \n (define_insn \"*absqi2_test\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (abs:QI (match_operand:QI 1 \"src_operand\" \"g\"))\n+        (compare:CC_NOOV (abs:QI (match_operand:QI 1 \"src_operand\" \"rIm\"))\n                          (const_int 0)))\n    (clobber (match_scratch:QI 0 \"=d\"))]\n   \"\"\n@@ -1322,7 +1355,7 @@\n \n (define_insn \"*absqi2_set\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (abs:QI (match_operand:QI 1 \"src_operand\" \"g\"))\n+        (compare:CC_NOOV (abs:QI (match_operand:QI 1 \"src_operand\" \"rIm\"))\n                          (const_int 0)))\n    (set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n         (abs:QI (match_dup 1)))]\n@@ -1343,7 +1376,7 @@\n \n (define_insn \"*negqi2_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,c\")\n-        (neg:QI (match_operand:QI 1 \"src_operand\" \"g,g\")))\n+        (neg:QI (match_operand:QI 1 \"src_operand\" \"rIm,rIm\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"\"\n   \"negi\\\\t%1,%0\"\n@@ -1352,7 +1385,7 @@\n \n (define_insn \"*negqi2_test\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (neg:QI (match_operand:QI 1 \"src_operand\" \"g\"))\n+        (compare:CC_NOOV (neg:QI (match_operand:QI 1 \"src_operand\" \"rIm\"))\n                          (const_int 0)))\n    (clobber (match_scratch:QI 0 \"=d\"))]\n   \"\"\n@@ -1362,7 +1395,7 @@\n \n (define_insn \"*negqi2_set\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (neg:QI (match_operand:QI 1 \"src_operand\" \"g\"))\n+        (compare:CC_NOOV (neg:QI (match_operand:QI 1 \"src_operand\" \"rIm\"))\n                          (const_int 0)))\n    (set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n         (neg:QI (match_dup 1)))]\n@@ -1373,7 +1406,7 @@\n \n (define_insn \"*negbqi2_clobber\"\n   [(set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n-        (neg:QI (match_operand:QI 1 \"src_operand\" \"g\")))\n+        (neg:QI (match_operand:QI 1 \"src_operand\" \"rIm\")))\n    (use (reg:CC_NOOV 21))\n    (clobber (reg:CC_NOOV 21))]\n   \"\"\n@@ -1393,7 +1426,7 @@\n \n (define_insn \"*one_cmplqi2_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,c\")\n-        (not:QI (match_operand:QI 1 \"lsrc_operand\" \"g,g\")))\n+        (not:QI (match_operand:QI 1 \"lsrc_operand\" \"rLm,rLm\")))\n    (clobber (reg:CC 21))]\n   \"\"\n   \"not\\\\t%1,%0\"\n@@ -1402,7 +1435,7 @@\n \n (define_insn \"*one_cmplqi2_test\"\n   [(set (reg:CC 21)\n-        (compare:CC (not:QI (match_operand:QI 1 \"lsrc_operand\" \"g\"))\n+        (compare:CC (not:QI (match_operand:QI 1 \"lsrc_operand\" \"rLm\"))\n                     (const_int 0)))\n    (clobber (match_scratch:QI 0 \"=d\"))]\n   \"\"\n@@ -1412,7 +1445,7 @@\n \n (define_insn \"*one_cmplqi2_set\"\n   [(set (reg:CC 21)\n-        (compare:CC (not:QI (match_operand:QI 1 \"lsrc_operand\" \"g\"))\n+        (compare:CC (not:QI (match_operand:QI 1 \"lsrc_operand\" \"rLm\"))\n                     (const_int 0)))\n    (set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")        \n         (not:QI (match_dup 1)))]\n@@ -1565,7 +1598,7 @@\n (define_insn \"*addqi3_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d,c,?c,c\")\n         (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0,rR,rS<>,0\")\n-                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,JR,rS<>,g\")))\n+                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,JR,rS<>,rIm\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"valid_operands (PLUS, operands, QImode)\"\n   \"@\n@@ -1581,7 +1614,7 @@\n (define_insn \"*addqi3_test\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0\")\n-                                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g\"))\n+                                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm\"))\n                          (const_int 0)))\n    (clobber (match_scratch:QI 0 \"=d,?d,d\"))]\n   \"valid_operands (PLUS, operands, QImode)\"\n@@ -1622,7 +1655,7 @@\n (define_insn \"*addqi3_set\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0\")\n-                                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g\"))\n+                                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm\"))\n                          (const_int 0)))\n    (set (match_operand:QI 0 \"ext_reg_operand\" \"=d,?d,d\")\n         (plus:QI (match_dup 1) (match_dup 2)))]\n@@ -1640,7 +1673,7 @@\n (define_insn \"addqi3_noclobber\"\n   [(set (match_operand:QI 0 \"std_reg_operand\" \"=c,?c,c\")\n         (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0\")\n-                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g\")))]\n+                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm\")))]\n   \"valid_operands (PLUS, operands, QImode)\"\n   \"@\n    addi3\\\\t%2,%1,%0\n@@ -1669,7 +1702,7 @@\n (define_insn \"*addqi3_noclobber_reload\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=c,?c,c\")\n         (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0\")\n-                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g\")))]\n+                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm\")))]\n   \"reload_in_progress\"\n   \"@\n    addi3\\\\t%2,%1,%0\n@@ -1682,7 +1715,7 @@\n (define_insn \"*addqi3_carry_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d,c,?c,c\")\n         (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0,rR,rS<>,0\")\n-                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,JR,rS<>,g\")))\n+                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,JR,rS<>,rIm\")))\n    (use (reg:CC_NOOV 21))\n    (clobber (reg:CC_NOOV 21))]\n   \"valid_operands (PLUS, operands, QImode)\"\n@@ -1710,8 +1743,8 @@\n \n (define_insn \"*subqi3_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d,d,c,?c,c,c\")\n-        (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,g,rR,rS<>,0,g\")\n-                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,0,JR,rS<>,g,0\")))\n+        (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,rIm,rR,rS<>,0,rIm\")\n+                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,0,JR,rS<>,rIm,0\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"valid_operands (MINUS, operands, QImode)\"\n   \"@\n@@ -1728,8 +1761,8 @@\n \n (define_insn \"*subqi3_test\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,g\")\n-                                   (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,0\"))\n+        (compare:CC_NOOV (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,rIm\")\n+                                   (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,0\"))\n                          (const_int 0)))\n    (clobber (match_scratch:QI 0 \"=d,?d,d,d\"))]\n   \"valid_operands (MINUS, operands, QImode)\"\n@@ -1743,8 +1776,8 @@\n \n (define_peephole\n   [(parallel [(set (match_operand:QI 0 \"ext_reg_operand\" \"=d,?d,d,d\")\n-                   (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,g\")\n-                             (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,0\")))\n+                   (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,rIm\")\n+                             (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,0\")))\n               (clobber (reg:CC_NOOV 21))])\n    (set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (match_dup 0) (const_int 0)))]\n@@ -1758,8 +1791,8 @@\n   \n (define_insn \"*subqi3_set\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,g\")\n-                                   (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,0\"))\n+        (compare:CC_NOOV (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,rIm\")\n+                                   (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,0\"))\n                          (const_int 0)))\n    (set (match_operand:QI 0 \"ext_reg_operand\" \"=d,?d,d,d\")\n         (minus:QI (match_dup 1)\n@@ -1775,8 +1808,8 @@\n \n (define_insn \"*subqi3_carry_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d,d,c,?c,c,c\")\n-        (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,g,rR,rS<>,0,g\")\n-                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,0,JR,rS<>,g,0\")))\n+        (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,rIm,rR,rS<>,0,rIm\")\n+                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,0,JR,rS<>,rIm,0\")))\n    (use (reg:CC_NOOV 21))\n    (clobber (reg:CC_NOOV 21))]\n   \"valid_operands (MINUS, operands, QImode)\"\n@@ -1794,8 +1827,8 @@\n \n (define_insn \"*subqi3_carry_set\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,g\")\n-                                   (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,0\"))\n+        (compare:CC_NOOV (minus:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,rIm\")\n+                                   (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,0\"))\n                          (const_int 0)))\n    (set (match_operand:QI 0 \"ext_reg_operand\" \"=d,?d,d,d\")\n         (minus:QI (match_dup 1)\n@@ -1851,7 +1884,7 @@\n (define_insn \"*mulqi3_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d,c,?c,c\")\n         (mult:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0,rR,rS<>,0\")\n-                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,JR,rS<>,g\")))\n+                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,JR,rS<>,rIm\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"valid_operands (MULT, operands, QImode)\"\n   \"*\n@@ -1872,7 +1905,7 @@\n (define_insn \"*mulqi3_test\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (mult:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0\")\n-                                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g\"))\n+                                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm\"))\n                          (const_int 0)))\n    (clobber (match_scratch:QI 0 \"=d,?d,d\"))]\n   \"valid_operands (MULT, operands, QImode)\"\n@@ -1894,7 +1927,7 @@\n (define_insn \"*mulqi3_set\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (mult:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0\")\n-                                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g\"))\n+                                  (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm\"))\n                          (const_int 0)))\n    (set (match_operand:QI 0 \"ext_reg_operand\" \"=d,?d,d\")\n         (mult:QI (match_dup 1)\n@@ -1924,7 +1957,7 @@\n           (and:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0,rR,rS<>,0\")\n                   (const_int 16777215)))\n          (sign_extend:QI\n-          (and:QI (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,JR,rS<>,g\")\n+          (and:QI (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,JR,rS<>,rIm\")\n                   (const_int 16777215)))))\n    (clobber (reg:CC_NOOV 21))]\n   \"TARGET_C3X && valid_operands (MULT, operands, QImode)\"\n@@ -2065,7 +2098,7 @@\n          (lshiftrt:HI\n           (mult:HI\n            (sign_extend:HI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0,rR,rS<>,0\"))\n-           (sign_extend:HI (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,JR,rS<>,g\")))\n+           (sign_extend:HI (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,JR,rS<>,rIm\")))\n       (const_int 32))))\n    (clobber (reg:CC_NOOV 21))]\n   \"! TARGET_C3X && valid_operands (MULT, operands, QImode)\"\n@@ -2106,7 +2139,7 @@\n          (lshiftrt:HI\n           (mult:HI \n            (zero_extend:HI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0,rR,rS<>,0\"))\n-           (zero_extend:HI (match_operand:QI 2 \"lsrc_operand\" \"JR,rS<>,g,JR,rS<>,g\")))\n+           (zero_extend:HI (match_operand:QI 2 \"lsrc_operand\" \"JR,rS<>,rLm,JR,rS<>,rLm\")))\n           (const_int 32))))\n    (clobber (reg:CC_NOOV 21))]\n   \"! TARGET_C3X && valid_operands (MULT, operands, QImode)\"\n@@ -2414,7 +2447,7 @@\n (define_insn \"*ashlqi3_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d,c,?c,c\")\n         (ashift:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,rR,rS<>,0\")\n-                   (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,JR,rS<>,g\")))\n+                   (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,JR,rS<>,rIm\")))\n    (clobber (reg:CC 21))]\n   \"valid_operands (ASHIFT, operands, QImode)\"\n   \"@\n@@ -2431,7 +2464,7 @@\n   [(set (reg:CC 21)\n         (compare:CC\n           (ashift:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0\")\n-                     (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g\"))\n+                     (match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm\"))\n           (const_int 0)))\n    (set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d\")\n         (ashift:QI (match_dup 1)\n@@ -2449,7 +2482,7 @@\n (define_insn \"*lshlqi3_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d,c,?c,c\")\n         (ashift:QI (match_operand:QI 1 \"src_operand\" \"rR,rS<>,0,rR,rS<>,0\")\n-                   (unspec [(match_operand:QI 2 \"src_operand\" \"JR,rS<>,g,JR,rS<>,g\")] 3)))\n+                   (unspec [(match_operand:QI 2 \"src_operand\" \"JR,rS<>,rIm,JR,rS<>,rIm\")] 3)))\n    (clobber (reg:CC 21))]\n   \"valid_operands (ASHIFT, operands, QImode)\"\n   \"@\n@@ -2614,7 +2647,7 @@\n (define_insn \"*cmpqi_test\"\n   [(set (reg:CC 21)\n         (compare:CC (match_operand:QI 0 \"src_operand\" \"rR,?rS<>,r\")\n-                    (match_operand:QI 1 \"src_operand\" \"JR,rS<>,g\")))]\n+                    (match_operand:QI 1 \"src_operand\" \"JR,rS<>,rIm\")))]\n   \"valid_operands (COMPARE, operands, QImode)\"\n   \"@\n    cmpi3\\\\t%1,%0\n@@ -2625,7 +2658,7 @@\n (define_insn \"*cmpqi_test_noov\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (match_operand:QI 0 \"src_operand\" \"rR,?rS<>,r\")\n-                         (match_operand:QI 1 \"src_operand\" \"JR,rS<>,g\")))]\n+                         (match_operand:QI 1 \"src_operand\" \"JR,rS<>,rIm\")))]\n   \"valid_operands (COMPARE, operands, QImode)\"\n   \"@\n    cmpi3\\\\t%1,%0\n@@ -2698,7 +2731,7 @@\n \n (define_insn \"*extv_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,c\")\n-        (sign_extract:QI (match_operand:QI 1 \"src_operand\" \"g,g\")\n+        (sign_extract:QI (match_operand:QI 1 \"src_operand\" \"rLm,rLm\")\n                          (match_operand:QI 2 \"const_int_operand\" \"n,n\")\n                          (match_operand:QI 3 \"const_int_operand\" \"n,n\")))\n    (clobber (reg:CC 21))]\n@@ -2719,7 +2752,7 @@\n \n (define_insn \"*extv_clobber_test\"\n   [(set (reg:CC 21)\n-        (compare:CC (sign_extract:QI (match_operand:QI 1 \"src_operand\" \"g\")\n+        (compare:CC (sign_extract:QI (match_operand:QI 1 \"src_operand\" \"rLm\")\n                                      (match_operand:QI 2 \"const_int_operand\" \"n\")\n                                      (match_operand:QI 3 \"const_int_operand\" \"n\"))\n    \t\t    (const_int 0)))\n@@ -2741,7 +2774,7 @@\n \n (define_insn \"*extv_clobber_set\"\n   [(set (reg:CC 21)\n-        (compare:CC (sign_extract:QI (match_operand:QI 1 \"src_operand\" \"g\")\n+        (compare:CC (sign_extract:QI (match_operand:QI 1 \"src_operand\" \"rLm\")\n                                      (match_operand:QI 2 \"const_int_operand\" \"n\")\n                                      (match_operand:QI 3 \"const_int_operand\" \"n\"))\n    \t\t    (const_int 0)))\n@@ -2781,7 +2814,7 @@\n \n (define_insn \"*extzv_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,c\")\n-        (zero_extract:QI (match_operand:QI 1 \"src_operand\" \"g,g\")\n+        (zero_extract:QI (match_operand:QI 1 \"src_operand\" \"rLm,rLm\")\n                          (match_operand:QI 2 \"const_int_operand\" \"n,n\")\n                          (match_operand:QI 3 \"const_int_operand\" \"n,n\")))\n    (clobber (reg:CC 21))]\n@@ -2802,7 +2835,7 @@\n \n (define_insn \"*extzv_test\"\n   [(set (reg:CC 21)\n-        (compare:CC (zero_extract:QI (match_operand:QI 1 \"src_operand\" \"g\")\n+        (compare:CC (zero_extract:QI (match_operand:QI 1 \"src_operand\" \"rLm\")\n                                      (match_operand:QI 2 \"const_int_operand\" \"n\")\n                                      (match_operand:QI 3 \"const_int_operand\" \"n\"))\n    \t\t    (const_int 0)))\n@@ -2824,11 +2857,11 @@\n \n (define_insn \"*extzv_set\"\n   [(set (reg:CC 21)\n-        (compare:CC (zero_extract:QI (match_operand:QI 1 \"src_operand\" \"g\")\n+        (compare:CC (zero_extract:QI (match_operand:QI 1 \"src_operand\" \"rLm\")\n                                      (match_operand:QI 2 \"const_int_operand\" \"n\")\n                                      (match_operand:QI 3 \"const_int_operand\" \"n\"))\n    \t\t    (const_int 0)))\n-   (set (match_operand:QI 0 \"reg_operand\" \"=d\")\n+   (set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n         (zero_extract:QI (match_dup 1)\n                          (match_dup 2)\n                          (match_dup 3)))]\n@@ -2867,7 +2900,7 @@\n   [(set (zero_extract:QI (match_operand:QI 0 \"reg_operand\" \"=d,c\")\n                          (match_operand:QI 1 \"const_int_operand\" \"n,n\")\n                          (match_operand:QI 2 \"const_int_operand\" \"n,n\"))\n-        (match_operand:QI 3 \"src_operand\" \"g,g\"))\n+        (match_operand:QI 3 \"src_operand\" \"rLm,rLm\"))\n    (clobber (reg:CC 21))]\n   \"! TARGET_C3X\n    && (((INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n@@ -2890,10 +2923,10 @@\n    (set_attr \"data\" \"uint16,uint16\")])\n \n (define_peephole\n-  [(parallel [(set (zero_extract:QI (match_operand:QI 0 \"reg_operand\" \"=d\")\n+  [(parallel [(set (zero_extract:QI (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n                                     (match_operand:QI 1 \"const_int_operand\" \"n\")\n                                     (match_operand:QI 2 \"const_int_operand\" \"n\"))\n-                   (match_operand:QI 3 \"src_operand\" \"g\"))\n+                   (match_operand:QI 3 \"src_operand\" \"rLm\"))\n \t      (clobber (reg:CC 21))])\n    (set (reg:CC 21)\n         (compare:CC (match_dup 0) (const_int 0)))]\n@@ -2929,44 +2962,33 @@\n         (match_operand:QF 1 \"src_operand\" \"\"))]\n  \"\"\n  \"\n-  if (CONSTANT_P (operands[1]) && ! const_operand (operands[1], QFmode))\n-    {\n-      operands[1] = force_const_mem (QFmode, operands[1]);\n-      if (! memory_address_p (QFmode, XEXP (operands[1], 0))\n-          && ! reload_in_progress)\n-        operands[1] = change_address (operands[1], QFmode,\n-                                      XEXP (operands[1], 0));\n-    }\n-\n-  if (! reload_in_progress\n-      && ! reg_operand (operands[0], QFmode)\n-      && ! reg_operand (operands[1], QFmode))\n-    operands[1] = force_reg (QFmode, operands[1]);\n- \")\n+{\n+  if (c4x_emit_move_sequence (operands, QFmode))\n+    DONE;\n+}\")\n \n ; We must provide an alternative to store to memory in case we have to\n ; spill a register.\n-(define_insn \"*movqf_noclobber\"\n+(define_insn \"movqf_noclobber\"\n  [(set (match_operand:QF 0 \"src_operand\" \"=f,m\")\n-       (match_operand:QF 1 \"src_operand\" \"fmH,f\"))]\n- \"reg_operand (operands[0], QFmode)\n-  || reg_operand (operands[1], QFmode)\"\n+       (match_operand:QF 1 \"src_operand\" \"fHm,f\"))]\n+ \"REG_P (operands[0]) || REG_P (operands[1])\"\n  \"@\n   ldfu\\\\t%1,%0\n   stf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unary,store\")])\n \n ;(define_insn \"*movqf_clobber\"\n ;  [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n-;        (match_operand:QF 1 \"src_operand\" \"fmH\"))\n+;        (match_operand:QF 1 \"src_operand\" \"fHm\"))\n ;   (clobber (reg:CC 21))]\n ; \"0\"\n ; \"ldf\\\\t%1,%0\"\n ;  [(set_attr \"type\" \"unarycc\")])\n \n (define_insn \"*movqf_test\"\n   [(set (reg:CC 21)\n-        (compare:CC (match_operand:QF 1 \"src_operand\" \"fmH\")\n+        (compare:CC (match_operand:QF 1 \"src_operand\" \"fHm\")\n                     (const_int 0)))\n    (clobber (match_scratch:QF 0 \"=f\"))]\n  \"\"\n@@ -2975,7 +2997,7 @@\n \n (define_insn \"*movqf_set\"\n   [(set (reg:CC 21)\n-        (compare:CC (match_operand:QF 1 \"src_operand\" \"fmH\")\n+        (compare:CC (match_operand:QF 1 \"src_operand\" \"fHm\")\n                     (match_operand:QF 2 \"fp_zero_operand\" \"G\")))\n     (set (match_operand:QF 0 \"reg_operand\" \"=f\")\n          (match_dup 1))]\n@@ -3038,15 +3060,15 @@\n \n (define_insn \"*absqf2_clobber\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n-        (abs:QF (match_operand:QF 1 \"src_operand\" \"fmH\")))\n+        (abs:QF (match_operand:QF 1 \"src_operand\" \"fHm\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"\"\n   \"absf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n (define_insn \"*absqf2_test\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (abs:QF (match_operand:QF 1 \"src_operand\" \"fmH\"))\n+        (compare:CC_NOOV (abs:QF (match_operand:QF 1 \"src_operand\" \"fHm\"))\n                          (match_operand:QF 2 \"fp_zero_operand\" \"G\")))\n    (clobber (match_scratch:QF 0 \"=f\"))]\n   \"\"\n@@ -3055,7 +3077,7 @@\n \n (define_insn \"*absqf2_set\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (abs:QF (match_operand:QF 1 \"src_operand\" \"fmH\"))\n+        (compare:CC_NOOV (abs:QF (match_operand:QF 1 \"src_operand\" \"fHm\"))\n                          (match_operand:QF 2 \"fp_zero_operand\" \"G\")))\n    (set (match_operand:QF 0 \"reg_operand\" \"=f\")\n         (abs:QF (match_dup 1)))]\n@@ -3076,15 +3098,15 @@\n \n (define_insn \"*negqf2_clobber\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n-        (neg:QF (match_operand:QF 1 \"src_operand\" \"fmH\")))\n+        (neg:QF (match_operand:QF 1 \"src_operand\" \"fHm\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"\"\n   \"negf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n (define_insn \"*negqf2_test\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (neg:QF (match_operand:QF 1 \"src_operand\" \"fmH\"))\n+        (compare:CC_NOOV (neg:QF (match_operand:QF 1 \"src_operand\" \"fHm\"))\n                          (match_operand:QF 2 \"fp_zero_operand\" \"G\")))\n    (clobber (match_scratch:QF 0 \"=f\"))]\n   \"\"\n@@ -3093,7 +3115,7 @@\n \n (define_insn \"*negqf2_set\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (neg:QF (match_operand:QF 1 \"src_operand\" \"fmH\"))\n+        (compare:CC_NOOV (neg:QF (match_operand:QF 1 \"src_operand\" \"fHm\"))\n                          (match_operand:QF 2 \"fp_zero_operand\" \"G\")))\n    (set (match_operand:QF 0 \"reg_operand\" \"=f\")\n         (neg:QF (match_dup 1)))]\n@@ -3106,25 +3128,25 @@\n ;\n (define_insn \"floatqiqf2\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n-        (float:QF (match_operand:QI 1 \"src_operand\" \"g\")))\n+        (float:QF (match_operand:QI 1 \"src_operand\" \"rIm\")))\n    (clobber (reg:CC 21))]\n  \"\"\n  \"float\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n (define_insn \"*floatqiqf2_set\"\n   [(set (reg:CC 21)\n-        (compare:CC (float:QF (match_operand:QI 1 \"src_operand\" \"g\"))\n+        (compare:CC (float:QF (match_operand:QI 1 \"src_operand\" \"rIm\"))\n                     (match_operand:QF 2 \"fp_zero_operand\" \"G\")))\n    (set (match_operand:QF 0 \"reg_operand\" \"=f\")\n         (float:QF (match_dup 1)))]\n-\n  \"\"\n  \"float\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n ; Unsigned conversions are a little tricky because we need to\n ; add the value for the high bit if necessary.\n+; \n ;\n (define_expand \"floatunsqiqf2\"\n  [(set (match_dup 2) (match_dup 3))\n@@ -3133,22 +3155,25 @@\n                               (match_dup 3)))\n              (set (match_dup 4)\n                   (float:QF (match_dup 1)))])\n-  (set (match_dup 2)\n+  (set (match_dup 6)\n        (if_then_else:QF (lt (reg:CC 21) (const_int 0))\n-                        (mem:QF (symbol_ref:QF \"*___unsfltconst\"))\n+                        (match_dup 5)\n                         (match_dup 2)))\n   (parallel [(set (match_operand:QF 0 \"reg_operand\" \"\")\n-                  (plus:QF (match_dup 2) (match_dup 4)))\n+                  (plus:QF (match_dup 6) (match_dup 4)))\n              (clobber (reg:CC_NOOV 21))])]\n  \"\"\n  \"operands[2] = gen_reg_rtx (QFmode);\n   operands[3] = CONST0_RTX (QFmode); \n   operands[4] = gen_reg_rtx (QFmode);\n- \")\n+  operands[5] = gen_reg_rtx (QFmode);\n+  operands[6] = gen_reg_rtx (QFmode);\n+  emit_move_insn (operands[5], \n+   immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", QFmode), QFmode));\")\n \n (define_insn \"floatqihf2\"\n   [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n-        (float:HF (match_operand:QI 1 \"src_operand\" \"g\")))\n+        (float:HF (match_operand:QI 1 \"src_operand\" \"rIm\")))\n    (clobber (reg:CC 21))]\n  \"\"\n  \"float\\\\t%1,%0\"\n@@ -3159,17 +3184,17 @@\n ;\n (define_insn \"fixqfqi_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,c\")\n-        (fix:QI (match_operand:QF 1 \"src_operand\" \"fmH,fmH\")))\n+        (fix:QI (match_operand:QF 1 \"src_operand\" \"fHm,fHm\")))\n    (clobber (reg:CC 21))]\n  \"\"\n  \"fix\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n (define_insn \"*fixqfqi_set\"\n   [(set (reg:CC 21)\n-        (compare:CC (fix:QI (match_operand:QF 1 \"src_operand\" \"fmH\"))\n+        (compare:CC (fix:QI (match_operand:QF 1 \"src_operand\" \"fHm\"))\n                     (const_int 0)))\n-   (set (match_operand:QI 0 \"reg_operand\" \"=d\")\n+   (set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n         (fix:QI (match_dup 1)))]\n  \"\"\n  \"fix\\\\t%1,%0\"\n@@ -3215,26 +3240,20 @@\n   \"c4x_emit_libcall (FIX_TRUNCQFHI2_LIBCALL, FIX, HImode, QFmode, 2, operands);\n    DONE;\")\n \n+; Is this allowed to be implementation dependent?  If so, we can\n+; omit the conditional load.  Otherwise we should emit a split.\n (define_expand \"fixuns_truncqfqi2\"\n- [(set (match_dup 2) (match_dup 4))\n-  (set (reg:CC 21)\n-       (compare:CC (match_operand:QF 1 \"reg_operand\" \"\")\n-                   (mem:QF (symbol_ref \"*___unsfltcompare\"))))\n-  (set (match_dup 2)\n-       (if_then_else:QF (ge (reg:CC 21) (const_int 0))\n-                        (mem:QF (symbol_ref \"*___unsfltconst\"))\n-                        (match_dup 2)))\n-  (parallel [(set (match_dup 3)\n-                  (minus:QF (match_dup 1) (match_dup 2)))\n-             (clobber (reg:CC_NOOV 21))])\n-  (parallel [(set (match_operand:QI 0 \"reg_operand\" \"\")\n-                  (fix:QI (match_dup 3)))\n-             (clobber (reg:CC 21))])]\n+ [(parallel [(set (reg:CC 21)\n+                  (compare:CC (fix:QI (match_operand:QF 1 \"src_operand\" \"fHm\"))\n+                              (const_int 0)))\n+             (set (match_dup 2)\n+                  (fix:QI (match_dup 1)))])\n+  (set (match_operand:QI 0 \"reg_operand\" \"=r\")\n+       (if_then_else:QI (lt (reg:CC 21) (const_int 0))\n+                        (const_int 0)\n+                        (match_dup 2)))]\n  \"\"\n- \"operands[2] = gen_reg_rtx (QFmode);\n-  operands[3] = gen_reg_rtx (QFmode);\n-  operands[4] = CONST0_RTX (QFmode);\n- \")\n+ \"operands[2] = gen_reg_rtx (QImode);\")\n \n (define_expand \"fixuns_truncqfhi2\"\n   [(parallel [(set (match_operand:HI 0 \"reg_operand\" \"\")\n@@ -3250,7 +3269,7 @@\n ;\n (define_insn \"*rcpfqf_clobber\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n-        (unspec [(match_operand:QF 1 \"src_operand\" \"fmH\")] 5))\n+        (unspec [(match_operand:QF 1 \"src_operand\" \"fHm\")] 5))\n    (clobber (reg:CC_NOOV 21))]\n   \"! TARGET_C3X\"\n   \"rcpf\\\\t%1,%0\"\n@@ -3261,7 +3280,7 @@\n ;\n (define_insn \"*rsqrfqf_clobber\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n-        (unspec [(match_operand:QF 1 \"src_operand\" \"fmH\")] 10))\n+        (unspec [(match_operand:QF 1 \"src_operand\" \"fHm\")] 10))\n    (clobber (reg:CC_NOOV 21))]\n   \"! TARGET_C3X\"\n   \"rsqrf\\\\t%1,%0\"\n@@ -3272,7 +3291,7 @@\n ;\n (define_insn \"*rndqf_clobber\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n-        (unspec [(match_operand:QF 1 \"src_operand\" \"fmH\")] 6))\n+        (unspec [(match_operand:QF 1 \"src_operand\" \"fHm\")] 6))\n    (clobber (reg:CC_NOOV 21))]\n   \"! TARGET_C3X\"\n   \"rnd\\\\t%1,%0\"\n@@ -3351,7 +3370,7 @@\n (define_insn \"*addqf3_clobber\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f,?f,f\")\n         (plus:QF (match_operand:QF 1 \"src_operand\" \"%fR,fS<>,0\")\n-                 (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH\")))\n+                 (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"valid_operands (PLUS, operands, QFmode)\"\n   \"@\n@@ -3363,7 +3382,7 @@\n (define_insn \"*addqf3_test\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (plus:QF (match_operand:QF 1 \"src_operand\" \"%fR,fS<>,0\")\n-                                  (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH\"))\n+                                  (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm\"))\n                          (match_operand:QF 3 \"fp_zero_operand\" \"G,G,G\")))\n    (clobber (match_scratch:QF 0 \"=f,?f,f\"))]\n   \"valid_operands (PLUS, operands, QFmode)\"\n@@ -3376,7 +3395,7 @@\n (define_insn \"*addqf3_set\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (plus:QF (match_operand:QF 1 \"src_operand\" \"%fR,fS<>,0\")\n-                                  (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH\"))\n+                                  (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm\"))\n                          (match_operand:QF 3 \"fp_zero_operand\" \"G,G,G\")))\n    (set (match_operand:QF 0 \"reg_operand\" \"=f,?f,f\")\n         (plus:QF (match_dup 1)\n@@ -3401,8 +3420,8 @@\n \n (define_insn \"*subqf3_clobber\"\n    [(set (match_operand:QF 0 \"reg_operand\" \"=f,?f,f,f\")\n-         (minus:QF (match_operand:QF 1 \"src_operand\" \"fR,fS<>,0,fmH\")\n-                   (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH,0\")))\n+         (minus:QF (match_operand:QF 1 \"src_operand\" \"fR,fS<>,0,fHm\")\n+                   (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm,0\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"valid_operands (MINUS, operands, QFmode)\"\n   \"@\n@@ -3414,8 +3433,8 @@\n \n (define_insn \"*subqf3_test\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (minus:QF (match_operand:QF 1 \"src_operand\" \"fR,fS<>,0,fmH\")\n-                                   (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH,0\"))\n+        (compare:CC_NOOV (minus:QF (match_operand:QF 1 \"src_operand\" \"fR,fS<>,0,fHm\")\n+                                   (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm,0\"))\n                          (match_operand:QF 3 \"fp_zero_operand\" \"G,G,G,G\")))\n    (clobber (match_scratch:QF 0 \"=f,?f,f,f\"))]\n   \"valid_operands (MINUS, operands, QFmode)\"\n@@ -3428,8 +3447,8 @@\n \n (define_insn \"*subqf3_set\"\n   [(set (reg:CC_NOOV 21)\n-        (compare:CC_NOOV (minus:QF (match_operand:QF 1 \"src_operand\" \"fR,fS<>,0,fmH\")\n-                                   (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH,0\"))\n+        (compare:CC_NOOV (minus:QF (match_operand:QF 1 \"src_operand\" \"fR,fS<>,0,fHm\")\n+                                   (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm,0\"))\n                          (match_operand:QF 3 \"fp_zero_operand\" \"G,G,G,G\")))\n    (set (match_operand:QF 0 \"reg_operand\" \"=f,?f,f,f\")\n         (minus:QF (match_dup 1)\n@@ -3456,7 +3475,7 @@\n (define_insn \"*mulqf3_clobber\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f,?f,f\")\n         (mult:QF (match_operand:QF 1 \"src_operand\" \"%fR,fS<>,0\")\n-                 (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH\")))\n+                 (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm\")))\n    (clobber (reg:CC_NOOV 21))]\n   \"valid_operands (MULT, operands, QFmode)\"\n   \"@\n@@ -3468,7 +3487,7 @@\n (define_insn \"*mulqf3_test\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (mult:QF (match_operand:QF 1 \"src_operand\" \"%fR,fS<>,0\")\n-                                  (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH\"))\n+                                  (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm\"))\n                          (match_operand:QF 3 \"fp_zero_operand\" \"G,G,G\")))\n    (clobber (match_scratch:QF 0 \"=f,?f,f\"))]\n   \"valid_operands (MULT, operands, QFmode)\"\n@@ -3481,7 +3500,7 @@\n (define_insn \"*mulqf3_set\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (mult:QF (match_operand:QF 1 \"src_operand\" \"%fR,fS<>,0\")\n-                                  (match_operand:QF 2 \"src_operand\" \"R,fS<>,fmH\"))\n+                                  (match_operand:QF 2 \"src_operand\" \"R,fS<>,fHm\"))\n                          (match_operand:QF 3 \"fp_zero_operand\" \"G,G,G\")))\n    (set (match_operand:QF 0 \"reg_operand\" \"=f,?f,f\")\n         (mult:QF (match_dup 1)\n@@ -3509,7 +3528,7 @@\n (define_insn \"*cmpqf\"\n   [(set (reg:CC 21)\n         (compare:CC (match_operand:QF 0 \"src_operand\" \"fR,?fS<>,f\")\n-                    (match_operand:QF 1 \"src_operand\" \"R,fS<>,fmH\")))]\n+                    (match_operand:QF 1 \"src_operand\" \"R,fS<>,fHm\")))]\n   \"valid_operands (COMPARE, operands, QFmode)\"\n   \"@\n    cmpf3\\\\t%1,%0\n@@ -3520,7 +3539,7 @@\n (define_insn \"*cmpqf_noov\"\n   [(set (reg:CC_NOOV 21)\n         (compare:CC_NOOV (match_operand:QF 0 \"src_operand\" \"fR,?fS<>,f\")\n-                         (match_operand:QF 1 \"src_operand\" \"R,fS<>,fmH\")))]\n+                         (match_operand:QF 1 \"src_operand\" \"R,fS<>,fHm\")))]\n   \"valid_operands (COMPARE, operands, QFmode)\"\n   \"@\n    cmpf3\\\\t%1,%0\n@@ -3586,8 +3605,8 @@\n   [(set (match_operand:QI 0 \"reg_operand\" \"=r,r\")\n         (if_then_else:QI (match_operator 1 \"comparison_operator\"\n                           [(reg:CC 21) (const_int 0)])\n-                         (match_operand:QI 2 \"src_operand\" \"g,0\")\n-                         (match_operand:QI 3 \"src_operand\" \"0,g\")))]\n+                         (match_operand:QI 2 \"src_operand\" \"rIm,0\")\n+                         (match_operand:QI 3 \"src_operand\" \"0,rIm\")))]\n  \"\"\n  \"@\n   ldi%1\\\\t%2,%0\n@@ -3598,8 +3617,8 @@\n   [(set (match_operand:QI 0 \"reg_operand\" \"=r,r\")\n         (if_then_else:QI (match_operator 1 \"comparison_operator\"\n                           [(reg:CC_NOOV 21) (const_int 0)])\n-                         (match_operand:QI 2 \"src_operand\" \"g,0\")\n-                         (match_operand:QI 3 \"src_operand\" \"0,g\")))]\n+                         (match_operand:QI 2 \"src_operand\" \"rIm,0\")\n+                         (match_operand:QI 3 \"src_operand\" \"0,rIm\")))]\n  \"GET_CODE (operands[1]) != LE\n   && GET_CODE (operands[1]) != GE\n   && GET_CODE (operands[1]) != LT\n@@ -3634,8 +3653,8 @@\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f,f\")\n         (if_then_else:QF (match_operator 1 \"comparison_operator\"\n                           [(reg:CC 21) (const_int 0)])\n-                         (match_operand:QF 2 \"src_operand\" \"fmH,0\")\n-                         (match_operand:QF 3 \"src_operand\" \"0,fmH\")))]\n+                         (match_operand:QF 2 \"src_operand\" \"fHm,0\")\n+                         (match_operand:QF 3 \"src_operand\" \"0,fHm\")))]\n  \"\"\n  \"@\n   ldf%1\\\\t%2,%0\n@@ -3646,8 +3665,8 @@\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f,f\")\n         (if_then_else:QF (match_operator 1 \"comparison_operator\"\n                           [(reg:CC_NOOV 21) (const_int 0)])\n-                         (match_operand:QF 2 \"src_operand\" \"fmH,0\")\n-                         (match_operand:QF 3 \"src_operand\" \"0,fmH\")))]\n+                         (match_operand:QF 2 \"src_operand\" \"fHm,0\")\n+                         (match_operand:QF 3 \"src_operand\" \"0,fHm\")))]\n  \"GET_CODE (operands[1]) != LE\n   && GET_CODE (operands[1]) != GE\n   && GET_CODE (operands[1]) != LT\n@@ -4336,92 +4355,68 @@\n ; CALL\n ;\n (define_insn \"*call_c3x\"\n- [(call (match_operand:QI 0 \"call_operand\" \"T,!o\")\n+ [(call (mem:QI (match_operand:QI 0 \"call_operand\" \"\"))\n         (match_operand:QI 1 \"general_operand\" \"\"))\n   (clobber (reg:QI 31))]\n   ;; Operand 1 not really used on the C4x.  The C30 doesn't have reg 31.\n \n   \"TARGET_C3X\"\n-  \"@\n-   call\\\\t%C0\n-   callu\\\\t%R0\"\n-  [(set_attr \"type\" \"call,call\")])\n+  \"call%U0\\\\t%C0\"\n+  [(set_attr \"type\" \"call\")])\n \n ; LAJ requires R11 (31) for the return address\n (define_insn \"*laj\"\n- [(call (match_operand:QI 0 \"call_operand\" \"T,!o\")\n+ [(call (mem:QI (match_operand:QI 0 \"call_operand\" \"\"))\n         (match_operand:QI 1 \"general_operand\" \"\"))\n   (clobber (reg:QI 31))]\n   ;; Operand 1 not really used on the C4x.\n \n   \"! TARGET_C3X\"\n   \"*\n-   if (which_alternative == 0)\n-     {\n-       if (final_sequence)\n-         return \\\"laj\\\\t%C0\\\";\n-       else\n-         return \\\"call\\\\t%C0\\\";\n-     }\n+   if (final_sequence)\n+     return \\\"laj%U0\\\\t%C0\\\";\n    else\n-     {\n-       if (final_sequence)\n-         return \\\"laju\\\\t%R0\\\";\n-       else\n-         return \\\"callu\\\\t%R0\\\";\n-     }\"\n-  [(set_attr \"type\" \"laj,laj\")])\n+     return \\\"call%U0\\\\t%C0\\\";\"\n+  [(set_attr \"type\" \"laj\")])\n \n (define_expand \"call\"\n- [(parallel [(call (match_operand:QI 0 \"call_operand\" \"\")\n+ [(parallel [(call (mem:QI (match_operand:QI 0 \"call_operand\" \"\"))\n                    (match_operand:QI 1 \"general_operand\" \"\"))\n              (clobber (reg:QI 31))])]\n  \"\"\n  \"\")\n \n (define_insn \"*callv_c3x\"\n- [(set (match_operand 0 \"\" \"=r,r\")\n-       (call (match_operand:QI 1 \"call_operand\" \"T,!o\")\n+ [(set (match_operand 0 \"\" \"=r\")\n+       (call (mem:QI (match_operand:QI 1 \"call_operand\" \"\"))\n              (match_operand:QI 2 \"general_operand\" \"\")))\n   (clobber (reg:QI 31))]\n   ;; Operand 0 and 2 not really used for the C4x. \n   ;; The C30 doesn't have reg 31.\n \n   \"TARGET_C3X\"\n-  \"@\n-   call\\\\t%C1\n-   callu\\\\t%R1\"\n-  [(set_attr \"type\" \"call,call\")])\n+  \"call%U1\\\\t%C1\"\n+  [(set_attr \"type\" \"call\")])\n \n ; LAJ requires R11 (31) for the return address\n (define_insn \"*lajv\"\n- [(set (match_operand 0 \"\" \"=r,r\")\n-       (call (match_operand:QI 1 \"call_operand\" \"T,!o\")\n+ [(set (match_operand 0 \"\" \"=r\")\n+       (call (mem:QI (match_operand:QI 1 \"call_operand\" \"\"))\n              (match_operand:QI 2 \"general_operand\" \"\")))\n   (clobber (reg:QI 31))]\n   ;; Operand 0 and 2 not really used in the C30 instruction.\n \n   \"! TARGET_C3X\"\n   \"*\n-   if (which_alternative == 0)\n-     {\n-       if (final_sequence)\n-         return \\\"laj\\\\t%C1\\\";\n-       else\n-         return \\\"call\\\\t%C1\\\";\n-     }\n+   if (final_sequence)\n+     return \\\"laj%U1\\\\t%C1\\\";\n    else\n-     {\n-       if (final_sequence)\n-         return \\\"laju\\\\t%R1\\\";\n-       else\n-         return \\\"callu\\\\t%R1\\\";\n-     }\"\n-  [(set_attr \"type\" \"laj,laj\")])\n+     return \\\"call%U1\\\\t%C1\\\";\"\n+  [(set_attr \"type\" \"laj\")])\n \n (define_expand \"call_value\"\n  [(parallel [(set (match_operand 0 \"\" \"\")\n-                  (call (match_operand:QI 1 \"call_operand\" \"\")\n+                  (call (mem:QI (match_operand:QI 1 \"call_operand\" \"\"))\n                         (match_operand:QI 2 \"general_operand\" \"\")))\n              (clobber (reg:QI 31))])]\n  \"\"\n@@ -4787,7 +4782,7 @@\n \n \n (define_insn \"*cmpstrqi\"\n-  [(set (match_operand:QI 0 \"reg_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n         (compare:QI (mem:BLK (match_operand:QI 1 \"addr_reg_operand\" \"a\"))\n                     (mem:BLK (match_operand:QI 2 \"addr_reg_operand\" \"a\"))))\n    (use (match_operand:QI 3 \"immediate_operand\" \"i\"))\n@@ -4833,32 +4828,20 @@\n   [(set (match_operand:HF 0 \"src_operand\" \"\")\n         (match_operand:HF 1 \"src_operand\" \"\"))]\n  \"\"\n- \"if (CONSTANT_P (operands[1]))\n-    {\n-      operands[1] = force_const_mem (HFmode, operands[1]); \n-      if (! memory_address_p (HFmode, XEXP (operands[1], 0))\n-          && ! reload_in_progress)\n-        operands[1] = change_address (operands[1], HFmode,\n-                                      XEXP (operands[1], 0));\n-     }\n-\n-  /* Memory to memory copies must go through a register.  */\n-  if (GET_CODE (operands[1]) == MEM && GET_CODE (operands[0]) == MEM\n-      && ! reload_in_progress)\n-    operands[1] = force_reg (HFmode, operands[1]); \n-\")\n+ \"if (c4x_emit_move_sequence (operands, HFmode))\n+    DONE;\")\n \n (define_insn \"*movhf_noclobber_reg\"\n   [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n-        (match_operand:HF 1 \"reg_operand\" \"h\"))]\n- \"\"\n+        (match_operand:HF 1 \"src_operand\" \"Hh\"))]\n+ \"GET_CODE (operands[1]) != MEM\"\n  \"ldfu\\\\t%1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n ; The predicates could be tightened to disallow constants\n (define_insn \"*movhf_noclobber\"\n  [(set (match_operand:HF 0 \"src_operand\" \"=h,m\")\n-       (match_operand:HF 1 \"src_operand\" \"m,h\"))]\n+       (match_operand:HF 1 \"src_operand\" \"HQT>,h\"))]\n  \"reg_operand (operands[0], HFmode) ^ reg_operand (operands[1], HFmode)\"\n  \"#\"\n  [(set_attr \"type\" \"multi,multi\")])\n@@ -4917,7 +4900,7 @@\n \n (define_insn \"*loadhf_float\"\n  [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n-       (float_extend:HF (match_operand:QF 1 \"src_operand\" \"fmH\")))]\n+       (float_extend:HF (match_operand:QF 1 \"src_operand\" \"fHm\")))]\n  \"\"\n  \"@\n   ldfu\\\\t%1,%0\"\n@@ -4926,7 +4909,7 @@\n (define_insn \"*loadhf_int\"\n  [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n        (unspec[(subreg:QI (match_dup 0) 0)\n-               (match_operand:QI 1 \"src_operand\" \"g\")] 8))]\n+               (match_operand:QI 1 \"src_operand\" \"rIm\")] 8))]\n  \"\"\n  \"@\n   ldiu\\\\t%1,%0\"\n@@ -5372,30 +5355,16 @@\n   [(set (match_operand:HI 0 \"src_operand\" \"\")\n         (match_operand:HI 1 \"src_operand\" \"\"))]\n  \"\"\n- \"if (CONSTANT_P (operands[1]))\n-    {\n-      /* We don't need to force all constants into memory.\n-         This could be improved.... */\n-      operands[1] = force_const_mem (HImode, operands[1]); \n-      if (! memory_address_p (HImode, XEXP (operands[1], 0))\n-          && ! reload_in_progress)\n-        operands[1] = change_address (operands[1], HImode,\n-                                      XEXP (operands[1], 0));\n-     }\n-\n-  /* Memory to memory copies must go through a register.  */\n-  if (GET_CODE (operands[1]) == MEM && GET_CODE (operands[0]) == MEM\n-      && ! reload_in_progress)\n-    operands[1] = force_reg (HImode, operands[1]); \n-\")\n+ \"if (c4x_emit_move_sequence (operands, HImode))\n+    DONE;\")\n \n ; The constraints for movhi must include 'r' if we don't\n ; restrict HImode regnos to start on an even number, since\n ; we can get RC, R8 allocated as a pair.  We want more\n ; votes for FP_REGS so we use dr as the constraints.\n (define_insn \"*movhi_noclobber\"\n   [(set (match_operand:HI 0 \"src_operand\" \"=dr,m\")\n-        (match_operand:HI 1 \"src_operand\" \"drm,r\"))]\n+        (match_operand:HI 1 \"src_operand\" \"drIQT>,r\"))]\n   \"reg_operand (operands[0], HImode)\n    || reg_operand (operands[1], HImode)\"\n   \"#\"\n@@ -5416,15 +5385,15 @@\n \n (define_insn \"extendqihi2\"\n   [(set (match_operand:HI 0 \"reg_operand\" \"=dc\")\n-        (sign_extend:HI (match_operand:QI 1 \"src_operand\" \"g\")))\n+        (sign_extend:HI (match_operand:QI 1 \"src_operand\" \"rIm\")))\n    (clobber (reg:CC 21))]\n   \"\"\n   \"#\"\n   [(set_attr \"type\" \"multi\")])\n \n (define_split\n   [(set (match_operand:HI 0 \"reg_operand\" \"=?dc\")\n-        (sign_extend:HI (match_operand:QI 1 \"src_operand\" \"g\")))\n+        (sign_extend:HI (match_operand:QI 1 \"src_operand\" \"rIm\")))\n    (clobber (reg:CC 21))]\n   \"reload_completed && TARGET_C3X\"\n   [(set (match_dup 2) (match_dup 1))\n@@ -5436,7 +5405,7 @@\n \n (define_split\n   [(set (match_operand:HI 0 \"reg_operand\" \"=?dc\")\n-        (sign_extend:HI (match_operand:QI 1 \"src_operand\" \"g\")))\n+        (sign_extend:HI (match_operand:QI 1 \"src_operand\" \"rIm\")))\n    (clobber (reg:CC 21))]\n   \"reload_completed && ! TARGET_C3X\"\n   [(set (match_dup 2) (match_dup 1))\n@@ -5447,7 +5416,7 @@\n \n (define_insn \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"reg_operand\" \"=?dc\")\n-        (zero_extend:HI (match_operand:QI 1 \"src_operand\" \"g\")))\n+        (zero_extend:HI (match_operand:QI 1 \"src_operand\" \"rIm\")))\n    (clobber (reg:CC 21))]\n   \"\"\n   \"#\"\n@@ -5457,7 +5426,7 @@\n ; the first set.\n (define_split\n   [(set (match_operand:HI 0 \"reg_operand\" \"=?dc\")\n-        (zero_extend:HI (match_operand:QI 1 \"src_operand\" \"g\")))\n+        (zero_extend:HI (match_operand:QI 1 \"src_operand\" \"rIm\")))\n    (clobber (reg:CC 21))]\n   \"reload_completed\"\n   [(set (match_dup 2) (match_dup 1))\n@@ -6209,12 +6178,12 @@\n    (parallel\n     [(set (pc)\n           (if_then_else\n-            (ge (plus:QI (match_operand:QI 4 \"addr_reg_operand\" \"0\")\n+            (ge (plus:QI (match_operand:QI 0 \"addr_reg_operand\" \"+a\")\n                          (const_int -1))\n                 (const_int 0))\n             (label_ref (match_operand 1 \"\" \"\"))\n             (pc)))\n-     (set (match_operand:QI 0 \"addr_reg_operand\" \"+a\")\n+     (set (match_dup 0)\n           (plus:QI (match_dup 0)\n                    (const_int -1)))\n      (clobber (reg:CC_NOOV 21))])]\n@@ -6230,11 +6199,11 @@\n    (parallel\n     [(set (pc)\n           (if_then_else\n-            (ne (match_operand:QI 4 \"addr_reg_operand\" \"0\")\n+            (ne (match_operand:QI 0 \"addr_reg_operand\" \"+a\")\n                 (const_int 0))\n             (label_ref (match_operand 1 \"\" \"\"))\n             (pc)))\n-     (set (match_operand:QI 0 \"addr_reg_operand\" \"+a\")\n+     (set (match_dup 0)\n           (plus:QI (match_dup 0)\n                    (const_int -1)))\n      (clobber (reg:CC_NOOV 21))])]\n@@ -6246,27 +6215,31 @@\n ; Peepholes to convert 'call label; rets' into jump label\n ;\n (define_peephole\n-  [(parallel [(call (match_operand:QI 0 \"call_operand\" \"T,!o\")\n+  [(parallel [(call (mem:QI (match_operand:QI 0 \"call_operand\" \"\"))\n                     (match_operand:QI 1 \"general_operand\" \"\"))\n               (clobber (reg:QI 31))])\n    (return)]\n   \"c4x_null_epilogue_p ()\"\n-  \"@\n-   br%#\\\\t%C0\n-   bu%#\\\\t%R0\"\n-  [(set_attr \"type\" \"jump,jump\")])\n+  \"*\n+   if (GET_CODE (XEXP (operands[0], 0)) == REG)\n+     return \\\"bu%#\\\\t%C0\\\";\n+   else\n+     return \\\"br%#\\\\t%C0\\\";\"\n+  [(set_attr \"type\" \"jump\")])\n \n (define_peephole\n   [(parallel [(set (match_operand 0 \"\" \"\")\n-                   (call (match_operand:QI 1 \"call_operand\" \"T,!o\")\n+                   (call (mem:QI (match_operand:QI 1 \"call_operand\" \"\"))\n                          (match_operand:QI 2 \"general_operand\" \"\")))\n               (clobber (reg:QI 31))])\n    (return)]\n   \"c4x_null_epilogue_p ()\"\n-  \"@\n-   br%#\\\\t%C1\n-   bu%#\\\\t%R1\"\n-  [(set_attr \"type\" \"jump,jump\")])\n+  \"*\n+   if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+     return \\\"bu%#\\\\t%C1\\\";\n+   else\n+     return \\\"br%#\\\\t%C1\\\";\"\n+  [(set_attr \"type\" \"jump\")])\n \n ;\n ; Peepholes for parallel instructions"}]}