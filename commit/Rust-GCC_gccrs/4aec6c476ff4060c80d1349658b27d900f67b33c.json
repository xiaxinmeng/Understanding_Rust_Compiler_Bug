{"sha": "4aec6c476ff4060c80d1349658b27d900f67b33c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFlYzZjNDc2ZmY0MDYwYzgwZDEzNDk2NThiMjdkOTAwZjY3YjMzYw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2005-02-19T08:53:53Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-02-19T08:53:53Z"}, "message": "ActiveModeDTP.java, [...]: New files.\n\n2005-02-19  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/net/protocol/ftp/ActiveModeDTP.java,\n\tgnu/java/net/protocol/ftp/BlockInputStream.java,\n\tgnu/java/net/protocol/ftp/BlockOutputStream.java,\n\tgnu/java/net/protocol/ftp/CompressedInputStream.java,\n\tgnu/java/net/protocol/ftp/CompressedOutputStream.java,\n\tgnu/java/net/protocol/ftp/DTPInputStream.java,\n\tgnu/java/net/protocol/ftp/DTP.java,\n\tgnu/java/net/protocol/ftp/DTPOutputStream.java,\n\tgnu/java/net/protocol/ftp/FTPConnection.java,\n\tgnu/java/net/protocol/ftp/FTPException.java,\n\tgnu/java/net/protocol/ftp/FTPResponse.java,\n\tgnu/java/net/protocol/ftp/FTPURLConnection.java,\n\tgnu/java/net/protocol/ftp/Handler.java,\n\tgnu/java/net/protocol/ftp/PassiveModeDTP.java,\n\tgnu/java/net/protocol/ftp/StreamInputStream.java,\n\tgnu/java/net/protocol/ftp/StreamOutputStream.java,\n\tgnu/java/net/CRLFInputStream.java,\n\tgnu/java/net/CRLFOutputStream.java,\n\tgnu/java/net/GetLocalHostAction.java,\n\tgnu/java/net/protocol/ftp/package.html: New files.\n\t* Makefile.am: Added new files.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r95272", "tree": {"sha": "da3cd45805aca9425f0fb7ccbfce23794ee48bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da3cd45805aca9425f0fb7ccbfce23794ee48bbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4aec6c476ff4060c80d1349658b27d900f67b33c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aec6c476ff4060c80d1349658b27d900f67b33c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aec6c476ff4060c80d1349658b27d900f67b33c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aec6c476ff4060c80d1349658b27d900f67b33c/comments", "author": null, "committer": null, "parents": [{"sha": "fc544c8180f2ce4f98dbce18fcf1702b9a686ca6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc544c8180f2ce4f98dbce18fcf1702b9a686ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc544c8180f2ce4f98dbce18fcf1702b9a686ca6"}], "stats": {"total": 4343, "additions": 4341, "deletions": 2}, "files": [{"sha": "999d8b91f412d866d7d6030f01dca6b6bd097e2c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -1,3 +1,28 @@\n+2005-02-19  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/net/protocol/ftp/ActiveModeDTP.java,\n+\tgnu/java/net/protocol/ftp/BlockInputStream.java,\n+\tgnu/java/net/protocol/ftp/BlockOutputStream.java,\n+\tgnu/java/net/protocol/ftp/CompressedInputStream.java,\n+\tgnu/java/net/protocol/ftp/CompressedOutputStream.java,\n+\tgnu/java/net/protocol/ftp/DTPInputStream.java,\n+\tgnu/java/net/protocol/ftp/DTP.java,\n+\tgnu/java/net/protocol/ftp/DTPOutputStream.java,\n+\tgnu/java/net/protocol/ftp/FTPConnection.java,\n+\tgnu/java/net/protocol/ftp/FTPException.java,\n+\tgnu/java/net/protocol/ftp/FTPResponse.java,\n+\tgnu/java/net/protocol/ftp/FTPURLConnection.java,\n+\tgnu/java/net/protocol/ftp/Handler.java,\n+\tgnu/java/net/protocol/ftp/PassiveModeDTP.java,\n+\tgnu/java/net/protocol/ftp/StreamInputStream.java,\n+\tgnu/java/net/protocol/ftp/StreamOutputStream.java,\n+\tgnu/java/net/CRLFInputStream.java,\n+\tgnu/java/net/CRLFOutputStream.java,\n+\tgnu/java/net/GetLocalHostAction.java,\n+\tgnu/java/net/protocol/ftp/package.html: New files.\n+\t* Makefile.am: Added new files.\n+\t* Makefile.in: Regenerated.\n+\n 2005-02-18  Tom Tromey  <tromey@redhat.com>\n \n \t* link.cc (make_vtable): Remove abstract method check."}, {"sha": "0a3e7ce2b34125b9cccca01fb353ae34153e6f50", "filename": "libjava/Makefile.am", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -3032,8 +3032,11 @@ gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n gnu/java/net/BASE64.java \\\n+gnu/java/net/CRLFInputStream.java \\\n+gnu/java/net/CRLFOutputStream.java \\\n gnu/java/net/DefaultContentHandlerFactory.java \\\n gnu/java/net/EmptyX509TrustManager.java \\\n+gnu/java/net/GetLocalHostAction.java \\\n gnu/java/net/HeaderFieldHelper.java \\\n gnu/java/net/LineInputStream.java \\\n gnu/java/net/PlainDatagramSocketImpl.java \\\n@@ -3044,6 +3047,22 @@ gnu/java/net/protocol/core/CoreInputStream.java \\\n gnu/java/net/protocol/core/Handler.java \\\n gnu/java/net/protocol/file/Connection.java \\\n gnu/java/net/protocol/file/Handler.java \\\n+gnu/java/net/protocol/ftp/ActiveModeDTP.java \\\n+gnu/java/net/protocol/ftp/BlockInputStream.java \\\n+gnu/java/net/protocol/ftp/BlockOutputStream.java \\\n+gnu/java/net/protocol/ftp/CompressedInputStream.java \\\n+gnu/java/net/protocol/ftp/CompressedOutputStream.java \\\n+gnu/java/net/protocol/ftp/DTP.java \\\n+gnu/java/net/protocol/ftp/DTPInputStream.java \\\n+gnu/java/net/protocol/ftp/DTPOutputStream.java \\\n+gnu/java/net/protocol/ftp/FTPConnection.java \\\n+gnu/java/net/protocol/ftp/FTPException.java \\\n+gnu/java/net/protocol/ftp/FTPResponse.java \\\n+gnu/java/net/protocol/ftp/FTPURLConnection.java \\\n+gnu/java/net/protocol/ftp/Handler.java \\\n+gnu/java/net/protocol/ftp/PassiveModeDTP.java \\\n+gnu/java/net/protocol/ftp/StreamInputStream.java \\\n+gnu/java/net/protocol/ftp/StreamOutputStream.java \\\n gnu/java/net/protocol/gcjlib/Connection.java \\\n gnu/java/net/protocol/gcjlib/Handler.java \\\n gnu/java/net/protocol/http/Authenticator.java \\"}, {"sha": "dda007e6ee86efb42e080adac79deff643f45ec4", "filename": "libjava/Makefile.in", "status": "modified", "additions": 179, "deletions": 2, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -710,8 +710,11 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tgnu/java/locale/LocaleInformation_zh_SG.java \\\n \tgnu/java/locale/LocaleInformation_zh_TW.java \\\n \tgnu/java/math/MPN.java gnu/java/net/BASE64.java \\\n+\tgnu/java/net/CRLFInputStream.java \\\n+\tgnu/java/net/CRLFOutputStream.java \\\n \tgnu/java/net/DefaultContentHandlerFactory.java \\\n \tgnu/java/net/EmptyX509TrustManager.java \\\n+\tgnu/java/net/GetLocalHostAction.java \\\n \tgnu/java/net/HeaderFieldHelper.java \\\n \tgnu/java/net/LineInputStream.java \\\n \tgnu/java/net/PlainDatagramSocketImpl.java \\\n@@ -722,6 +725,22 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tgnu/java/net/protocol/core/Handler.java \\\n \tgnu/java/net/protocol/file/Connection.java \\\n \tgnu/java/net/protocol/file/Handler.java \\\n+\tgnu/java/net/protocol/ftp/ActiveModeDTP.java \\\n+\tgnu/java/net/protocol/ftp/BlockInputStream.java \\\n+\tgnu/java/net/protocol/ftp/BlockOutputStream.java \\\n+\tgnu/java/net/protocol/ftp/CompressedInputStream.java \\\n+\tgnu/java/net/protocol/ftp/CompressedOutputStream.java \\\n+\tgnu/java/net/protocol/ftp/DTP.java \\\n+\tgnu/java/net/protocol/ftp/DTPInputStream.java \\\n+\tgnu/java/net/protocol/ftp/DTPOutputStream.java \\\n+\tgnu/java/net/protocol/ftp/FTPConnection.java \\\n+\tgnu/java/net/protocol/ftp/FTPException.java \\\n+\tgnu/java/net/protocol/ftp/FTPResponse.java \\\n+\tgnu/java/net/protocol/ftp/FTPURLConnection.java \\\n+\tgnu/java/net/protocol/ftp/Handler.java \\\n+\tgnu/java/net/protocol/ftp/PassiveModeDTP.java \\\n+\tgnu/java/net/protocol/ftp/StreamInputStream.java \\\n+\tgnu/java/net/protocol/ftp/StreamOutputStream.java \\\n \tgnu/java/net/protocol/gcjlib/Connection.java \\\n \tgnu/java/net/protocol/gcjlib/Handler.java \\\n \tgnu/java/net/protocol/http/Authenticator.java \\\n@@ -4051,8 +4070,11 @@ am__objects_15 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/java/locale/LocaleInformation_zh_SG.lo \\\n \tgnu/java/locale/LocaleInformation_zh_TW.lo \\\n \tgnu/java/math/MPN.lo gnu/java/net/BASE64.lo \\\n+\tgnu/java/net/CRLFInputStream.lo \\\n+\tgnu/java/net/CRLFOutputStream.lo \\\n \tgnu/java/net/DefaultContentHandlerFactory.lo \\\n \tgnu/java/net/EmptyX509TrustManager.lo \\\n+\tgnu/java/net/GetLocalHostAction.lo \\\n \tgnu/java/net/HeaderFieldHelper.lo \\\n \tgnu/java/net/LineInputStream.lo \\\n \tgnu/java/net/PlainDatagramSocketImpl.lo \\\n@@ -4062,6 +4084,22 @@ am__objects_15 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/java/net/protocol/core/Handler.lo \\\n \tgnu/java/net/protocol/file/Connection.lo \\\n \tgnu/java/net/protocol/file/Handler.lo \\\n+\tgnu/java/net/protocol/ftp/ActiveModeDTP.lo \\\n+\tgnu/java/net/protocol/ftp/BlockInputStream.lo \\\n+\tgnu/java/net/protocol/ftp/BlockOutputStream.lo \\\n+\tgnu/java/net/protocol/ftp/CompressedInputStream.lo \\\n+\tgnu/java/net/protocol/ftp/CompressedOutputStream.lo \\\n+\tgnu/java/net/protocol/ftp/DTP.lo \\\n+\tgnu/java/net/protocol/ftp/DTPInputStream.lo \\\n+\tgnu/java/net/protocol/ftp/DTPOutputStream.lo \\\n+\tgnu/java/net/protocol/ftp/FTPConnection.lo \\\n+\tgnu/java/net/protocol/ftp/FTPException.lo \\\n+\tgnu/java/net/protocol/ftp/FTPResponse.lo \\\n+\tgnu/java/net/protocol/ftp/FTPURLConnection.lo \\\n+\tgnu/java/net/protocol/ftp/Handler.lo \\\n+\tgnu/java/net/protocol/ftp/PassiveModeDTP.lo \\\n+\tgnu/java/net/protocol/ftp/StreamInputStream.lo \\\n+\tgnu/java/net/protocol/ftp/StreamOutputStream.lo \\\n \tgnu/java/net/protocol/gcjlib/Connection.lo \\\n \tgnu/java/net/protocol/gcjlib/Handler.lo \\\n \tgnu/java/net/protocol/http/Authenticator.lo \\\n@@ -7306,8 +7344,11 @@ gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n gnu/java/net/BASE64.java \\\n+gnu/java/net/CRLFInputStream.java \\\n+gnu/java/net/CRLFOutputStream.java \\\n gnu/java/net/DefaultContentHandlerFactory.java \\\n gnu/java/net/EmptyX509TrustManager.java \\\n+gnu/java/net/GetLocalHostAction.java \\\n gnu/java/net/HeaderFieldHelper.java \\\n gnu/java/net/LineInputStream.java \\\n gnu/java/net/PlainDatagramSocketImpl.java \\\n@@ -7318,6 +7359,22 @@ gnu/java/net/protocol/core/CoreInputStream.java \\\n gnu/java/net/protocol/core/Handler.java \\\n gnu/java/net/protocol/file/Connection.java \\\n gnu/java/net/protocol/file/Handler.java \\\n+gnu/java/net/protocol/ftp/ActiveModeDTP.java \\\n+gnu/java/net/protocol/ftp/BlockInputStream.java \\\n+gnu/java/net/protocol/ftp/BlockOutputStream.java \\\n+gnu/java/net/protocol/ftp/CompressedInputStream.java \\\n+gnu/java/net/protocol/ftp/CompressedOutputStream.java \\\n+gnu/java/net/protocol/ftp/DTP.java \\\n+gnu/java/net/protocol/ftp/DTPInputStream.java \\\n+gnu/java/net/protocol/ftp/DTPOutputStream.java \\\n+gnu/java/net/protocol/ftp/FTPConnection.java \\\n+gnu/java/net/protocol/ftp/FTPException.java \\\n+gnu/java/net/protocol/ftp/FTPResponse.java \\\n+gnu/java/net/protocol/ftp/FTPURLConnection.java \\\n+gnu/java/net/protocol/ftp/Handler.java \\\n+gnu/java/net/protocol/ftp/PassiveModeDTP.java \\\n+gnu/java/net/protocol/ftp/StreamInputStream.java \\\n+gnu/java/net/protocol/ftp/StreamOutputStream.java \\\n gnu/java/net/protocol/gcjlib/Connection.java \\\n gnu/java/net/protocol/gcjlib/Handler.java \\\n gnu/java/net/protocol/http/Authenticator.java \\\n@@ -9909,11 +9966,17 @@ gnu/java/math/MPN.lo: gnu/java/math/$(am__dirstamp) \\\n \tgnu/java/math/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/BASE64.lo: gnu/java/net/$(am__dirstamp) \\\n \tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/CRLFInputStream.lo: gnu/java/net/$(am__dirstamp) \\\n+\tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/CRLFOutputStream.lo: gnu/java/net/$(am__dirstamp) \\\n+\tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/DefaultContentHandlerFactory.lo:  \\\n \tgnu/java/net/$(am__dirstamp) \\\n \tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/EmptyX509TrustManager.lo: gnu/java/net/$(am__dirstamp) \\\n \tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/GetLocalHostAction.lo: gnu/java/net/$(am__dirstamp) \\\n+\tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/HeaderFieldHelper.lo: gnu/java/net/$(am__dirstamp) \\\n \tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/LineInputStream.lo: gnu/java/net/$(am__dirstamp) \\\n@@ -9945,6 +10008,60 @@ gnu/java/net/protocol/file/Connection.lo:  \\\n gnu/java/net/protocol/file/Handler.lo:  \\\n \tgnu/java/net/protocol/file/$(am__dirstamp) \\\n \tgnu/java/net/protocol/file/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/net/protocol/ftp\n+\t@: > gnu/java/net/protocol/ftp/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/net/protocol/ftp/$(DEPDIR)\n+\t@: > gnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/ActiveModeDTP.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/BlockInputStream.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/BlockOutputStream.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/CompressedInputStream.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/CompressedOutputStream.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/DTP.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/DTPInputStream.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/DTPOutputStream.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/FTPConnection.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/FTPException.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/FTPResponse.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/FTPURLConnection.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/Handler.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/PassiveModeDTP.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/StreamInputStream.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/ftp/StreamOutputStream.lo:  \\\n+\tgnu/java/net/protocol/ftp/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/protocol/gcjlib/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/net/protocol/gcjlib\n \t@: > gnu/java/net/protocol/gcjlib/$(am__dirstamp)\n@@ -16601,10 +16718,16 @@ mostlyclean-compile:\n \t-rm -f gnu/java/math/MPN.lo\n \t-rm -f gnu/java/net/BASE64.$(OBJEXT)\n \t-rm -f gnu/java/net/BASE64.lo\n+\t-rm -f gnu/java/net/CRLFInputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/CRLFInputStream.lo\n+\t-rm -f gnu/java/net/CRLFOutputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/CRLFOutputStream.lo\n \t-rm -f gnu/java/net/DefaultContentHandlerFactory.$(OBJEXT)\n \t-rm -f gnu/java/net/DefaultContentHandlerFactory.lo\n \t-rm -f gnu/java/net/EmptyX509TrustManager.$(OBJEXT)\n \t-rm -f gnu/java/net/EmptyX509TrustManager.lo\n+\t-rm -f gnu/java/net/GetLocalHostAction.$(OBJEXT)\n+\t-rm -f gnu/java/net/GetLocalHostAction.lo\n \t-rm -f gnu/java/net/HeaderFieldHelper.$(OBJEXT)\n \t-rm -f gnu/java/net/HeaderFieldHelper.lo\n \t-rm -f gnu/java/net/LineInputStream.$(OBJEXT)\n@@ -16631,6 +16754,38 @@ mostlyclean-compile:\n \t-rm -f gnu/java/net/protocol/file/Connection.lo\n \t-rm -f gnu/java/net/protocol/file/Handler.$(OBJEXT)\n \t-rm -f gnu/java/net/protocol/file/Handler.lo\n+\t-rm -f gnu/java/net/protocol/ftp/ActiveModeDTP.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/ActiveModeDTP.lo\n+\t-rm -f gnu/java/net/protocol/ftp/BlockInputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/BlockInputStream.lo\n+\t-rm -f gnu/java/net/protocol/ftp/BlockOutputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/BlockOutputStream.lo\n+\t-rm -f gnu/java/net/protocol/ftp/CompressedInputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/CompressedInputStream.lo\n+\t-rm -f gnu/java/net/protocol/ftp/CompressedOutputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/CompressedOutputStream.lo\n+\t-rm -f gnu/java/net/protocol/ftp/DTP.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/DTP.lo\n+\t-rm -f gnu/java/net/protocol/ftp/DTPInputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/DTPInputStream.lo\n+\t-rm -f gnu/java/net/protocol/ftp/DTPOutputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/DTPOutputStream.lo\n+\t-rm -f gnu/java/net/protocol/ftp/FTPConnection.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/FTPConnection.lo\n+\t-rm -f gnu/java/net/protocol/ftp/FTPException.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/FTPException.lo\n+\t-rm -f gnu/java/net/protocol/ftp/FTPResponse.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/FTPResponse.lo\n+\t-rm -f gnu/java/net/protocol/ftp/FTPURLConnection.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/FTPURLConnection.lo\n+\t-rm -f gnu/java/net/protocol/ftp/Handler.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/Handler.lo\n+\t-rm -f gnu/java/net/protocol/ftp/PassiveModeDTP.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/PassiveModeDTP.lo\n+\t-rm -f gnu/java/net/protocol/ftp/StreamInputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/StreamInputStream.lo\n+\t-rm -f gnu/java/net/protocol/ftp/StreamOutputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/ftp/StreamOutputStream.lo\n \t-rm -f gnu/java/net/protocol/gcjlib/Connection.$(OBJEXT)\n \t-rm -f gnu/java/net/protocol/gcjlib/Connection.lo\n \t-rm -f gnu/java/net/protocol/gcjlib/Handler.$(OBJEXT)\n@@ -21812,8 +21967,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/locale/$(DEPDIR)/LocaleInformation_zh_TW.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/math/$(DEPDIR)/MPN.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/BASE64.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/CRLFInputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/CRLFOutputStream.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/DefaultContentHandlerFactory.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/EmptyX509TrustManager.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/GetLocalHostAction.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/HeaderFieldHelper.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/LineInputStream.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/PlainDatagramSocketImpl.Plo@am__quote@\n@@ -21827,6 +21985,22 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/core/$(DEPDIR)/natCoreInputStream.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/file/$(DEPDIR)/Connection.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/file/$(DEPDIR)/Handler.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/ActiveModeDTP.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/BlockInputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/BlockOutputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/CompressedInputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/CompressedOutputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/DTP.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/DTPInputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/DTPOutputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/FTPConnection.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/FTPException.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/FTPResponse.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/FTPURLConnection.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/Handler.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/PassiveModeDTP.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/StreamInputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/ftp/$(DEPDIR)/StreamOutputStream.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/gcjlib/$(DEPDIR)/Connection.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/gcjlib/$(DEPDIR)/Handler.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Authenticator.Plo@am__quote@\n@@ -25093,6 +25267,7 @@ clean-libtool:\n \t-rm -rf gnu/java/net/.libs gnu/java/net/_libs\n \t-rm -rf gnu/java/net/protocol/core/.libs gnu/java/net/protocol/core/_libs\n \t-rm -rf gnu/java/net/protocol/file/.libs gnu/java/net/protocol/file/_libs\n+\t-rm -rf gnu/java/net/protocol/ftp/.libs gnu/java/net/protocol/ftp/_libs\n \t-rm -rf gnu/java/net/protocol/gcjlib/.libs gnu/java/net/protocol/gcjlib/_libs\n \t-rm -rf gnu/java/net/protocol/http/.libs gnu/java/net/protocol/http/_libs\n \t-rm -rf gnu/java/net/protocol/http/event/.libs gnu/java/net/protocol/http/event/_libs\n@@ -25630,6 +25805,8 @@ distclean-generic:\n \t-rm -f gnu/java/net/protocol/core/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/file/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/file/$(am__dirstamp)\n+\t-rm -f gnu/java/net/protocol/ftp/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f gnu/java/net/protocol/ftp/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/gcjlib/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/gcjlib/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n@@ -25914,7 +26091,7 @@ clean-am: clean-binPROGRAMS clean-generic clean-libtool clean-local \\\n \n distclean: distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/ber/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/pkcs/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) gnu/xml/aelfred2/$(DEPDIR) gnu/xml/dom/$(DEPDIR) gnu/xml/dom/ls/$(DEPDIR) gnu/xml/pipeline/$(DEPDIR) gnu/xml/transform/$(DEPDIR) gnu/xml/util/$(DEPDIR) gnu/xml/xpath/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) javax/xml/$(DEPDIR) javax/xml/datatype/$(DEPDIR) javax/xml/namespace/$(DEPDIR) javax/xml/parsers/$(DEPDIR) javax/xml/transform/$(DEPDIR) javax/xml/transform/dom/$(DEPDIR) javax/xml/transform/sax/$(DEPDIR) javax/xml/transform/stream/$(DEPDIR) javax/xml/validation/$(DEPDIR) javax/xml/xpath/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/ftp/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/ber/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/pkcs/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) gnu/xml/aelfred2/$(DEPDIR) gnu/xml/dom/$(DEPDIR) gnu/xml/dom/ls/$(DEPDIR) gnu/xml/pipeline/$(DEPDIR) gnu/xml/transform/$(DEPDIR) gnu/xml/util/$(DEPDIR) gnu/xml/xpath/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) javax/xml/$(DEPDIR) javax/xml/datatype/$(DEPDIR) javax/xml/namespace/$(DEPDIR) javax/xml/parsers/$(DEPDIR) javax/xml/transform/$(DEPDIR) javax/xml/transform/dom/$(DEPDIR) javax/xml/transform/sax/$(DEPDIR) javax/xml/transform/stream/$(DEPDIR) javax/xml/validation/$(DEPDIR) javax/xml/xpath/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-libtool distclean-local distclean-tags\n@@ -25944,7 +26121,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/ber/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/pkcs/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) gnu/xml/aelfred2/$(DEPDIR) gnu/xml/dom/$(DEPDIR) gnu/xml/dom/ls/$(DEPDIR) gnu/xml/pipeline/$(DEPDIR) gnu/xml/transform/$(DEPDIR) gnu/xml/util/$(DEPDIR) gnu/xml/xpath/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) javax/xml/$(DEPDIR) javax/xml/datatype/$(DEPDIR) javax/xml/namespace/$(DEPDIR) javax/xml/parsers/$(DEPDIR) javax/xml/transform/$(DEPDIR) javax/xml/transform/dom/$(DEPDIR) javax/xml/transform/sax/$(DEPDIR) javax/xml/transform/stream/$(DEPDIR) javax/xml/validation/$(DEPDIR) javax/xml/xpath/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/ftp/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/ber/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/pkcs/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) gnu/xml/aelfred2/$(DEPDIR) gnu/xml/dom/$(DEPDIR) gnu/xml/dom/ls/$(DEPDIR) gnu/xml/pipeline/$(DEPDIR) gnu/xml/transform/$(DEPDIR) gnu/xml/util/$(DEPDIR) gnu/xml/xpath/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) javax/xml/$(DEPDIR) javax/xml/datatype/$(DEPDIR) javax/xml/namespace/$(DEPDIR) javax/xml/parsers/$(DEPDIR) javax/xml/transform/$(DEPDIR) javax/xml/transform/dom/$(DEPDIR) javax/xml/transform/sax/$(DEPDIR) javax/xml/transform/stream/$(DEPDIR) javax/xml/validation/$(DEPDIR) javax/xml/xpath/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n "}, {"sha": "706c23447bec1771e68b46b7bde72632db79247a", "filename": "libjava/gnu/java/net/CRLFInputStream.java", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,205 @@\n+/* CRLFInputStream.java --\n+   Copyright (C) 2002, 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net;\n+\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * An input stream that filters out CR/LF pairs into LFs.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class CRLFInputStream\n+  extends FilterInputStream\n+{\n+  /**\n+   * The CR octet.\n+   */\n+  public static final int CR = 13;\n+\n+  /**\n+   * The LF octet.\n+   */\n+  public static final int LF = 10;\n+\n+  /**\n+   * Buffer.\n+   */\n+  protected int buf = -1;\n+\n+  /**\n+   * Buffer at time of mark.\n+   */\n+  protected int markBuf = -1;\n+\n+  /**\n+   * Constructs a CR/LF input stream connected to the specified input\n+   * stream.\n+   */\n+  public CRLFInputStream(InputStream in)\n+  {\n+    super(in);\n+  }\n+\n+  /**\n+   * Reads the next byte of data from this input stream.\n+   * Returns -1 if the end of the stream has been reached.\n+   * @exception IOException if an I/O error occurs\n+   */\n+  public int read()\n+    throws IOException\n+  {\n+    int c;\n+    if (buf != -1)\n+      {\n+        c = buf;\n+        buf = -1;\n+        return c;\n+      }\n+    else\n+      {\n+        c = super.read();\n+        if (c == CR)\n+          {\n+            buf = super.read();\n+            if (buf == LF)\n+              {\n+                c = buf;\n+                buf = -1;\n+              }\n+          }\n+      }\n+    return c;\n+  }\n+  \n+  /**\n+   * Reads up to b.length bytes of data from this input stream into\n+   * an array of bytes.\n+   * Returns -1 if the end of the stream has been reached.\n+   * @exception IOException if an I/O error occurs\n+   */\n+  public int read(byte[] b)\n+    throws IOException\n+  {\n+    return read(b, 0, b.length);\n+  }\n+\n+  /**\n+   * Reads up to len bytes of data from this input stream into an\n+   * array of bytes, starting at the specified offset.\n+   * Returns -1 if the end of the stream has been reached.\n+   * @exception IOException if an I/O error occurs\n+   */\n+  public int read(byte[] b, int off, int len)\n+    throws IOException\n+  {\n+    int shift = 0;\n+    if (buf != -1)\n+      {\n+        // Push buf onto start of byte array\n+        b[off] = (byte) buf;\n+        off++;\n+        len--;\n+        buf = -1;\n+        shift++;\n+      }\n+    int l = super.read(b, off, len);\n+    l = removeCRLF(b, off - shift, l);\n+    return l;\n+  }\n+\n+  /**\n+   * Indicates whether this stream supports the mark and reset methods.\n+   */\n+  public boolean markSupported()\n+  {\n+    return in.markSupported();\n+  }\n+\n+  /**\n+   * Marks the current position in this stream.\n+   */\n+  public void mark(int readlimit)\n+  {\n+    in.mark(readlimit);\n+    markBuf = buf;\n+  }\n+\n+  /**\n+   * Repositions this stream to the position at the time the mark method was\n+   * called.\n+   */\n+  public void reset()\n+    throws IOException\n+  {\n+    in.reset();\n+    buf = markBuf;\n+  }\n+\n+  private int removeCRLF(byte[] b, int off, int len)\n+  {\n+    int end = off + len;\n+    for (int i = off; i < end; i++)\n+      {\n+        if (b[i] == CR)\n+          {\n+            if (i + 1 == end)\n+              {\n+                // This is the last byte, impossible to determine whether CRLF\n+                buf = CR;\n+                len--;\n+              }\n+            else if (b[i + 1] == LF)\n+              {\n+                // Shift left\n+                end--;\n+                for (int j = i; j < end; j++)\n+                  {\n+                    b[j] = b[j + 1];\n+                  }\n+                  len--;\n+                  end = off + len;\n+              }\n+          }\n+      }\n+    return len;\n+  }\n+}"}, {"sha": "665a02b62d0d13516c3d7440231af4a489cd4c53", "filename": "libjava/gnu/java/net/CRLFOutputStream.java", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFOutputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,183 @@\n+/* CRLFOutputStream.java --\n+   Copyright (C) 2002, 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+/** \n+ * An output stream that filters LFs into CR/LF pairs.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class CRLFOutputStream\n+  extends FilterOutputStream\n+{\n+  static final String US_ASCII = \"US-ASCII\";\n+\n+  /**\n+   * The CR octet.\n+   */\n+  public static final int CR = 13;\n+\n+  /**\n+   * The LF octet.\n+   */\n+  public static final int LF = 10;\n+\n+  /**\n+   * The CR/LF pair.\n+   */\n+  public static final byte[] CRLF = { CR, LF };\n+\n+  /**\n+   * The last byte read.\n+   */\n+  protected int last;\n+\n+  /**\n+   * Constructs a CR/LF output stream connected to the specified output stream.\n+   */\n+  public CRLFOutputStream(OutputStream out)\n+  {\n+    super(out);\n+    last = -1;\n+  }\n+\n+  /**\n+   * Writes a character to the underlying stream.\n+   * @exception IOException if an I/O error occurred\n+   */\n+  public void write(int ch) throws IOException\n+  {\n+    if (ch == CR)\n+      {\n+        out.write(CRLF);\n+      }\n+    else if (ch == LF)\n+      {\n+        if (last != CR)\n+          {\n+            out.write(CRLF);\n+          }\n+      }\n+    else\n+      {\n+        out.write(ch);\n+      }\n+    last = ch;\n+  }\n+  \n+  /**\n+   * Writes a byte array to the underlying stream.\n+   * @exception IOException if an I/O error occurred\n+   */\n+  public void write(byte[] b)\n+    throws IOException\n+  {\n+    write(b, 0, b.length);\n+  }\n+\n+  /**\n+   * Writes a portion of a byte array to the underlying stream.\n+   * @exception IOException if an I/O error occurred\n+   */\n+  public void write(byte[] b, int off, int len)\n+    throws IOException\n+  {\n+    int d = off;\n+    len += off;\n+    for (int i = off; i < len; i++)\n+      {\n+        switch (b[i])\n+          {\n+          case CR:\n+            out.write (b, d, i - d);\n+            out.write (CRLF, 0, 2);\n+            d = i + 1;\n+            break;\n+          case LF:\n+            if (last != CR)\n+              {\n+                out.write (b, d, i - d);\n+                out.write (CRLF, 0, 2);\n+              }\n+            d = i + 1;\n+            break;\n+          }\n+        last = b[i];\n+      }\n+    if (len - d > 0)\n+      {\n+        out.write (b, d, len - d);\n+      }\n+  }\n+  \n+  /**\n+   * Writes the specified ASCII string to the underlying stream.\n+   * @exception IOException if an I/O error occurred\n+   */\n+  public void write(String text)\n+    throws IOException\n+  {\n+    try\n+      {\n+        byte[] bytes = text.getBytes(US_ASCII);\n+        write(bytes, 0, bytes.length);\n+        }\n+    catch (UnsupportedEncodingException e)\n+      {\n+        throw new IOException(\"The US-ASCII encoding is not supported \" +\n+                              \"on this system\");\n+      }\n+  }\n+\n+  /**\n+   * Writes a newline to the underlying stream.\n+   * @exception IOException if an I/O error occurred\n+   */\n+  public void writeln()\n+    throws IOException\n+  {\n+    out.write(CRLF, 0, 2);\n+  }\n+}\n+"}, {"sha": "36d17d9df45229ea07e97fbf6d8087ece767ade4", "filename": "libjava/gnu/java/net/GetLocalHostAction.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2FGetLocalHostAction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2FGetLocalHostAction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FGetLocalHostAction.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,65 @@\n+/* GetLocalHostAction.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.security.PrivilegedAction;\n+\n+/**\n+ * Privileged action to retrieve the local host InetAddress.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class GetLocalHostAction\n+  implements PrivilegedAction\n+{\n+  public Object run()\n+  {\n+    try\n+      {\n+        return InetAddress.getLocalHost();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+        return null;\n+      }\n+  }\n+}\n+"}, {"sha": "ab387e4a96fb12f027bd4cef19f791ac92298461", "filename": "libjava/gnu/java/net/protocol/ftp/ActiveModeDTP.java", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FActiveModeDTP.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FActiveModeDTP.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FActiveModeDTP.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,251 @@\n+/* ActiveModeDTP.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+\n+/**\n+ * An active mode FTP data transfer process.\n+ * This starts a server on the specified port listening for a data\n+ * connection. It converts the socket input into a file stream for reading.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+final class ActiveModeDTP\n+  implements DTP, Runnable\n+{\n+\n+  ServerSocket server;\n+  Socket socket;\n+  DTPInputStream in;\n+  DTPOutputStream out;\n+  boolean completed;\n+  boolean inProgress;\n+  int transferMode;\n+  IOException exception;\n+  Thread acceptThread;\n+  int connectionTimeout;\n+\n+  ActiveModeDTP(InetAddress localhost, int port,\n+                int connectionTimeout, int timeout)\n+    throws IOException\n+  {\n+    completed = false;\n+    inProgress = false;\n+    server = new ServerSocket(port, 1, localhost);\n+    if (timeout > 0)\n+      {\n+        server.setSoTimeout(timeout);\n+      }\n+    if (connectionTimeout <= 0)\n+      {\n+        connectionTimeout = 20000;\n+      }\n+    this.connectionTimeout = connectionTimeout;\n+    acceptThread = new Thread(this, \"ActiveModeDTP\");\n+    acceptThread.start();\n+  }\n+\n+  /**\n+   * Start listening.\n+   */\n+  public void run()\n+  {\n+    try\n+      {\n+        socket = server.accept();\n+        //System.err.println(\"Accepted connection from \"+socket.getInetAddress()+\":\"+socket.getPort());\n+      }\n+    catch (IOException e)\n+      {\n+        exception = e;\n+      }\n+  }\n+\n+  /**\n+   * Waits until a client has connected.\n+   */\n+  public void waitFor()\n+    throws IOException\n+  {\n+    try\n+      {\n+        acceptThread.join(connectionTimeout);\n+      }\n+    catch (InterruptedException e)\n+      {\n+      }\n+    if (exception != null)\n+      {\n+        throw exception;\n+      }\n+    if (socket == null)\n+      {\n+        server.close();\n+        throw new IOException(\"client did not connect before timeout\");\n+      }\n+    acceptThread = null;\n+  }\n+  \n+  /**\n+   * Returns an input stream from which a remote file can be read.\n+   */\n+  public InputStream getInputStream()\n+    throws IOException\n+  {\n+    if (inProgress)\n+      {\n+        throw new IOException(\"Transfer in progress\");\n+      }\n+    if (acceptThread != null)\n+      {\n+        waitFor();\n+      }\n+    switch (transferMode)\n+      {\n+      case FTPConnection.MODE_STREAM:\n+        in = new StreamInputStream(this, socket.getInputStream());\n+        break;\n+      case FTPConnection.MODE_BLOCK:\n+        in = new BlockInputStream(this, socket.getInputStream());\n+        break;\n+      case FTPConnection.MODE_COMPRESSED:\n+        in = new CompressedInputStream(this, socket.getInputStream());\n+        break;\n+      default:\n+        throw new IllegalStateException(\"invalid transfer mode\");\n+      }\n+    in.setTransferComplete(false);\n+    return in;\n+  }\n+\n+  /**\n+   * Returns an output stream to which a local file can be written for\n+   * upload.\n+   */\n+  public OutputStream getOutputStream() throws IOException\n+  {\n+    if (inProgress)\n+      {\n+        throw new IOException(\"Transfer in progress\");\n+      }\n+    if (acceptThread != null)\n+      {\n+        waitFor();\n+      }\n+    switch (transferMode)\n+      {\n+      case FTPConnection.MODE_STREAM:\n+        out = new StreamOutputStream(this, socket.getOutputStream());\n+        break;\n+      case FTPConnection.MODE_BLOCK:\n+        out = new BlockOutputStream(this, socket.getOutputStream());\n+        break;\n+      case FTPConnection.MODE_COMPRESSED:\n+        out = new CompressedOutputStream(this, socket.getOutputStream());\n+        break;\n+      default:\n+        throw new IllegalStateException(\"invalid transfer mode\");\n+      }\n+    out.setTransferComplete(false);\n+    return out;\n+  }\n+\n+  public void setTransferMode(int mode)\n+  {\n+    transferMode = mode;\n+  }\n+\n+  public void complete()\n+  {\n+    completed = true;\n+    if (!inProgress)\n+      {\n+        transferComplete();\n+      }\n+  }\n+\n+  public boolean abort()\n+  {\n+    completed = true;\n+    transferComplete();\n+    return inProgress;\n+  }\n+  \n+  public void transferComplete()\n+  {\n+    if (socket == null)\n+      {\n+        return;\n+      }\n+    if (in != null)\n+      {\n+        in.setTransferComplete(true);\n+      }\n+    if (out != null)\n+      {\n+        out.setTransferComplete(true);\n+      }\n+    completed = completed || (transferMode == FTPConnection.MODE_STREAM);\n+    if (completed && socket != null)\n+      {\n+        try\n+          {\n+            socket.close();\n+          }\n+        catch (IOException e)\n+          {\n+          }\n+        try\n+          {\n+            server.close();\n+          }\n+        catch (IOException e)\n+          {\n+          }\n+      }\n+  }\n+  \n+}\n+"}, {"sha": "f72d8df25c2a6ec6e7ced67bda3d05a02a23c90c", "filename": "libjava/gnu/java/net/protocol/ftp/BlockInputStream.java", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FBlockInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FBlockInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FBlockInputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,150 @@\n+/* BlockInputStream.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * A DTP input stream that implements the FTP block transfer mode.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+class BlockInputStream\n+  extends DTPInputStream\n+{\n+\n+  static final int EOF = 64;\n+\n+  int descriptor;\n+  int max = -1;\n+  int count = -1;\n+\n+  BlockInputStream(DTP dtp, InputStream in)\n+  {\n+    super(dtp, in);\n+  }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return -1;\n+      }\n+    if (count == -1)\n+      {\n+        readHeader();\n+      }\n+    if (max < 1)\n+      {\n+        close();\n+        return -1;\n+      }\n+    int c = in.read();\n+    if (c == -1)\n+      {\n+        dtp.transferComplete();\n+      }\n+    count++;\n+    if (count >= max)\n+      {\n+        count = -1;\n+        if (descriptor == EOF)\n+          {\n+            close();\n+          }\n+      }\n+    return c;\n+  }\n+\n+  public int read(byte[] buf)\n+    throws IOException\n+  {\n+    return read(buf, 0, buf.length);\n+  }\n+\n+  public int read(byte[] buf, int off, int len)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return -1;\n+      }\n+    if (count == -1)\n+      {\n+        readHeader();\n+      }\n+    if (max < 1)\n+      {\n+        close();\n+        return -1;\n+      }\n+    int l = in.read(buf, off, len);\n+    if (l == -1)\n+      {\n+        dtp.transferComplete();\n+      }\n+    count += l;\n+    if (count >= max)\n+      {\n+        count = -1;\n+        if (descriptor == EOF)\n+          {\n+            close();\n+          }\n+      }\n+    return l;\n+  }\n+\n+  /**\n+   * Reads the block header.\n+   */\n+  void readHeader()\n+    throws IOException\n+  {\n+    descriptor = in.read();\n+    int max_hi = in.read();\n+    int max_lo = in.read();\n+    max = (max_hi << 8) | max_lo;\n+    count = 0;\n+  }\n+\n+}\n+"}, {"sha": "15ee9567962770f8e25cc0e937d60b51679909a7", "filename": "libjava/gnu/java/net/protocol/ftp/BlockOutputStream.java", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FBlockOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FBlockOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FBlockOutputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,111 @@\n+/* BlockOutputStream.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * A DTP output stream that implements the FTP block transfer mode.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+class BlockOutputStream\n+  extends DTPOutputStream\n+{\n+\n+  static final byte RECORD = -128;      // 0x80\n+  static final byte EOF = 64;   // 0x40\n+\n+  BlockOutputStream(DTP dtp, OutputStream out)\n+  {\n+    super(dtp, out);\n+  }\n+\n+  public void write(int c)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return;\n+      }\n+    byte[] buf = new byte[]\n+      {\n+        RECORD,                 /* record descriptor */\n+        0x00, 0x01,             /* one byte */\n+        (byte) c                /* the byte */\n+      };\n+    out.write(buf, 0, 4);\n+  }\n+\n+  public void write(byte[] b)\n+    throws IOException\n+  {\n+    write(b, 0, b.length);\n+  }\n+\n+  public void write(byte[] b, int off, int len)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return;\n+      }\n+    byte[] buf = new byte[len + 3];\n+    buf[0] = RECORD;            /* record descriptor */\n+    buf[1] = (byte) ((len & 0x00ff) >> 8);      /* high byte of bytecount */\n+    buf[2] = (byte) (len & 0xff00);     /* low byte of bytecount */\n+    System.arraycopy(b, off, buf, 3, len);\n+    out.write(buf, 0, len);\n+  }\n+\n+  public void close()\n+    throws IOException\n+  {\n+    byte[] buf = new byte[]\n+      {\n+        EOF,                    /* eof descriptor */\n+        0x00, 0x00              /* no bytes */\n+      };\n+    out.write(buf, 0, 3);\n+    super.close();\n+  }\n+\n+}\n+"}, {"sha": "4e2eb717613507f57e6ec7fb6fe83d0cc90bfbb7", "filename": "libjava/gnu/java/net/protocol/ftp/CompressedInputStream.java", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FCompressedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FCompressedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FCompressedInputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,215 @@\n+/* CompressedInputStream.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.net.ProtocolException;\n+\n+/**\n+ * A DTP input stream that implements the FTP compressed transfer mode.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+class CompressedInputStream\n+  extends DTPInputStream\n+{\n+\n+  static final int EOF = 64;\n+\n+  static final int RAW = 0x00;\n+  static final int COMPRESSED = 0x80;\n+  static final int FILLER = 0xc0;\n+\n+  int descriptor;\n+  int max = -1;\n+  int count = -1;\n+\n+  int state = RAW;              // RAW | STATE | FILLER\n+  int rep;                      // the compressed byte\n+  int n = 0;                    // the number of compressed or raw bytes\n+\n+  CompressedInputStream(DTP dtp, InputStream in)\n+  {\n+    super(dtp, in);\n+  }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return -1;\n+      }\n+    if (count == -1)\n+      {\n+        readHeader();\n+      }\n+    if (max < 1)\n+      {\n+        close();\n+        return -1;\n+      }\n+    if (n > 0 && (state == COMPRESSED || state == FILLER))\n+      {\n+        n--;\n+        return rep;\n+      }\n+    int c = in.read();\n+    if (c == -1)\n+      {\n+        close();\n+      }\n+    count++;\n+    if (count >= max)\n+      {\n+        count = -1;\n+        if (descriptor == EOF)\n+          {\n+            close();\n+          }\n+      }\n+    if (c == -1)\n+      {\n+        return c;\n+      }\n+    while (n == 0)              // read code header\n+      {\n+        state = (c & 0xc0);\n+        n = (c & 0x3f);\n+        c = in.read();\n+        if (c == -1)\n+          {\n+            return -1;\n+          }\n+      }\n+    switch (state)\n+      {\n+      case RAW:\n+        break;\n+      case COMPRESSED:\n+      case FILLER:\n+        rep = c;\n+        break;\n+      default:\n+        throw new ProtocolException(\"Illegal state: \" + state);\n+      }\n+    n--;\n+    return c;\n+  }\n+  \n+  public int read(byte[] buf)\n+    throws IOException\n+  {\n+    return read(buf, 0, buf.length);\n+  }\n+  \n+  public int read(byte[] buf, int off, int len)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return -1;\n+      }\n+    if (count == -1)\n+      {\n+        readHeader();\n+      }\n+    if (max < 1)\n+      {\n+        close();\n+        return -1;\n+      }\n+    // TODO improve performance\n+    for (int i = off; i < len; i++)\n+      {\n+        int c = read();\n+        if (c == -1)\n+          {\n+            close();\n+            return i;\n+          }\n+        buf[i] = (byte) c;\n+      }\n+    return len;\n+    /*\n+       int l = in.read (buf, off, len);\n+       if (l==-1)\n+       {\n+       close ();\n+       }\n+       count += l;\n+       if (count>=max)\n+       {\n+       count = -1;\n+       if (descriptor==EOF)\n+       {\n+       close ();\n+       }\n+       }\n+       return l;\n+     */\n+  }\n+  \n+  /**\n+   * Reads the block header.\n+   */\n+  void readHeader()\n+    throws IOException\n+  {\n+    descriptor = in.read();\n+    int max_hi = in.read();\n+    int max_lo = in.read();\n+    max = (max_hi << 8) | max_lo;\n+    count = 0;\n+  }\n+\n+  /**\n+   * Reads the code header.\n+   */\n+  void readCodeHeader()\n+    throws IOException\n+  {\n+    int code = in.read();\n+    state = (code & 0xc0);\n+    n = (code & 0x3f);\n+  }\n+\n+}\n+"}, {"sha": "136d8b635f48ff20910147f81ff340dd4fbe8d44", "filename": "libjava/gnu/java/net/protocol/ftp/CompressedOutputStream.java", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FCompressedOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FCompressedOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FCompressedOutputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,228 @@\n+/* CompressedOutputStream.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * A DTP output stream that implements the FTP compressed transfer mode.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+class CompressedOutputStream\n+  extends DTPOutputStream\n+{\n+\n+  static final byte RECORD = -128;      // 0x80\n+  static final byte EOF = 64;   // 0x40\n+\n+  CompressedOutputStream(DTP dtp, OutputStream out)\n+  {\n+    super(dtp, out);\n+  }\n+  \n+  /**\n+   * Just one byte cannot be compressed.\n+   * It takes 5 bytes to transmit - hardly very compressed!\n+   */\n+  public void write(int c)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return;\n+      }\n+    byte[] buf = new byte[]\n+      {\n+        RECORD,                   /* record descriptor */\n+        0x00, 0x01,             /* one byte */\n+        0x01,                   /* one uncompressed byte */\n+        (byte) c                /* the byte */\n+      };\n+    out.write(buf, 0, 5);\n+  }\n+\n+  public void write(byte[] b)\n+    throws IOException\n+  {\n+    write(b, 0, b.length);\n+  }\n+\n+  /**\n+   * The larger len is, the better.\n+   */\n+  public void write(byte[] b, int off, int len)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return;\n+      }\n+    byte[] buf = compress(b, off, len);\n+    len = buf.length;\n+    buf[0] = RECORD;            /* record descriptor */\n+    buf[1] = (byte) ((len & 0x00ff) >> 8);      /* high byte of bytecount */\n+    buf[2] = (byte) (len & 0xff00);     /* low byte of bytecount */\n+    out.write(buf, 0, len);\n+  }\n+\n+  /**\n+   * Returns the compressed form of the given byte array.\n+   * The first 3 bytes are left free for header information.\n+   */\n+  byte[] compress(byte[] b, int off, int len)\n+  {\n+    byte[] buf = new byte[len];\n+    byte last = 0;\n+    int pos = 0, raw_count = 0, rep_count = 1;\n+    for (int i = off; i < len; i++)\n+      {\n+        byte c = b[i];\n+        if (i > off && c == last) // compress\n+          {\n+            if (raw_count > 0)      // flush raw bytes to buf\n+              {\n+                // need to add raw_count+1 bytes\n+                if (pos + (raw_count + 1) > buf.length)\n+                  {\n+                    buf = realloc(buf, len);\n+                  }\n+                pos = flush_raw(buf, pos, b, (i - raw_count) - 1,\n+                                raw_count);\n+                raw_count = 0;\n+              }\n+            rep_count++;            // keep looking for same byte\n+          }\n+        else\n+          {\n+            if (rep_count > 1)      // flush compressed bytes to buf\n+              {\n+                // need to add 2 bytes\n+                if (pos + 2 > buf.length)\n+                  {\n+                    buf = realloc(buf, len);\n+                  }\n+                pos = flush_compressed(buf, pos, rep_count, last);\n+                rep_count = 1;\n+              }\n+            raw_count++;            // keep looking for raw bytes\n+          }\n+        if (rep_count == 127)     // flush compressed bytes\n+          {\n+            // need to add 2 bytes\n+            if (pos + 2 > buf.length)\n+              {\n+                buf = realloc(buf, len);\n+              }\n+            pos = flush_compressed(buf, pos, rep_count, last);\n+            rep_count = 1;\n+          }\n+        if (raw_count == 127)     // flush raw bytes\n+          {\n+            // need to add raw_count+1 bytes\n+            if (pos + (raw_count + 1) > buf.length)\n+              {\n+                buf = realloc(buf, len);\n+              }\n+            pos = flush_raw(buf, pos, b, (i - raw_count), raw_count);\n+            raw_count = 0;\n+          }\n+        last = c;\n+      }\n+    if (rep_count > 1)          // flush compressed bytes\n+      {\n+        // need to add 2 bytes\n+        if (pos + 2 > buf.length)\n+          {\n+            buf = realloc(buf, len);\n+          }\n+        pos = flush_compressed(buf, pos, rep_count, last);\n+        rep_count = 1;\n+      }\n+    if (raw_count > 0)          // flush raw bytes\n+      {\n+        // need to add raw_count+1 bytes\n+        if (pos + (raw_count + 1) > buf.length)\n+          {\n+            buf = realloc(buf, len);\n+          }\n+        pos = flush_raw(buf, pos, b, (len - raw_count), raw_count);\n+        raw_count = 0;\n+      }\n+    byte[] ret = new byte[pos + 3];\n+    System.arraycopy(buf, 0, ret, 3, pos);\n+    return ret;\n+  }\n+  \n+  int flush_compressed(byte[] buf, int pos, int count, byte c)\n+  {\n+    buf[pos++] = (byte) (0x80 | count);\n+    buf[pos++] = c;\n+    return pos;\n+  }\n+\n+  int flush_raw(byte[] buf, int pos, byte[] src, int off, int len)\n+  {\n+    buf[pos++] = (byte) len;\n+    System.arraycopy(src, off, buf, pos, len);\n+    return pos + len;\n+  }\n+\n+  byte[] realloc(byte[] buf, int len)\n+  {\n+    byte[] ret = new byte[buf.length + len];\n+    System.arraycopy(buf, 0, ret, 0, buf.length);\n+    return ret;\n+  }\n+\n+  public void close()\n+    throws IOException\n+  {\n+    byte[] buf = new byte[]\n+      {\n+        EOF,                      /* eof descriptor */\n+        0x00, 0x00              /* no bytes */\n+      };\n+    out.write(buf, 0, 3);\n+    out.close();\n+  }\n+\n+}\n+"}, {"sha": "54016b8a4feebb0a3b82c5cee710ca618ef1ce9e", "filename": "libjava/gnu/java/net/protocol/ftp/DTP.java", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTP.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTP.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTP.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,92 @@\n+/* DTP.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * An FTP data transfer process.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+interface DTP\n+{\n+\n+  /**\n+   * Returns an input stream from which a remote file can be read.\n+   */\n+  InputStream getInputStream()\n+    throws IOException;\n+\n+  /**\n+   * Returns an output stream to which a local file can be written for\n+   * upload.\n+   */\n+  OutputStream getOutputStream()\n+    throws IOException;\n+\n+  /**\n+   * Sets the transfer mode to be used with this DTP.\n+   */\n+  void setTransferMode(int mode);\n+\n+  /**\n+   * Marks this DTP completed.\n+   * When the current transfer has finished, any resources will be released.\n+   */\n+  void complete();\n+\n+  /**\n+   * Aborts any current transfer and releases all resources held by this\n+   * DTP.\n+   * @return true if a transfer was interrupted, false otherwise\n+   */\n+  boolean abort();\n+\n+  /**\n+   * Used to notify the DTP that its current transfer is complete.\n+   * This occurs either when end-of-stream is reached or a 226 response is\n+   * received.\n+   */\n+  void transferComplete();\n+\n+}\n+"}, {"sha": "73b6aa63512f97b438895250d5d8d72f2f0c453a", "filename": "libjava/gnu/java/net/protocol/ftp/DTPInputStream.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTPInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTPInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTPInputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,88 @@\n+/* DTPInputStream.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * An input stream that notifies a DTP on completion.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+abstract class DTPInputStream\n+  extends FilterInputStream\n+{\n+\n+  DTP dtp;\n+  boolean transferComplete;\n+\n+  /**\n+   * Constructor.\n+   * @param dtp the controlling data transfer process\n+   * @param in the underlying socket stream\n+   */\n+  DTPInputStream (DTP dtp, InputStream in)\n+  {\n+    super(in);\n+    this.dtp = dtp;\n+    transferComplete = false;\n+  }\n+\n+  /**\n+   * Marks this input stream complete.\n+   * This is called by the DTP.\n+   */\n+  void setTransferComplete(boolean flag)\n+  {\n+    transferComplete = flag;\n+  }\n+  \n+  /**\n+   * Notifies the controlling DTP that this stream has completed transfer.\n+   */\n+  public void close()\n+    throws IOException\n+  {\n+    dtp.transferComplete();\n+  }\n+\n+}\n+"}, {"sha": "69ae0f81ab64933b1118d2c95bc037bf3f418993", "filename": "libjava/gnu/java/net/protocol/ftp/DTPOutputStream.java", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTPOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTPOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FDTPOutputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,85 @@\n+/* DTPOutputStream.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * An output stream that notifies a DTP on end of stream.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+abstract class DTPOutputStream extends FilterOutputStream\n+{\n+\n+  DTP dtp;\n+  boolean transferComplete;\n+\n+  /**\n+   * Constructor.\n+   * @param dtp the controlling data transfer process\n+   * @param out the socket output stream\n+   */\n+  DTPOutputStream (DTP dtp, OutputStream out)\n+    {\n+      super (out);\n+      this.dtp = dtp;\n+      transferComplete = false;\n+    }\n+\n+  /**\n+   * Tells this stream whether transfer has completed or not.\n+   * @param flag true if the process has completed, false otherwise\n+   */\n+  void setTransferComplete (boolean flag)\n+    {\n+      transferComplete = flag;\n+    }\n+\n+  /**\n+   * Notifies the controlling DTP that this stream has been terminated.\n+   */\n+  public void close () throws IOException\n+    {\n+      dtp.transferComplete ();\n+    }\n+\n+}"}, {"sha": "2c1237349f55cf66d29e55332facf1a3efd17b50", "filename": "libjava/gnu/java/net/protocol/ftp/FTPConnection.java", "status": "added", "additions": 1348, "deletions": 0, "changes": 1348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPConnection.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,1348 @@\n+/* FTPConnection.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import gnu.java.net.CRLFInputStream;\n+import gnu.java.net.CRLFOutputStream;\n+import gnu.java.net.EmptyX509TrustManager;\n+import gnu.java.net.LineInputStream;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.BindException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ProtocolException;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.security.GeneralSecurityException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+\n+/**\n+ * An FTP client connection, or PI.\n+ * This implements RFC 959, with the following exceptions:\n+ * <ul>\n+ * <li>STAT, HELP, SITE, SMNT, and ACCT commands are not supported.</li>\n+ * <li>the TYPE command does not allow alternatives to the default bytesize\n+ * (Non-print), and local bytesize is not supported.</li>\n+ * </ul>\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class FTPConnection\n+{\n+\n+  /**\n+   * The default FTP transmission control port.\n+   */\n+  public static final int FTP_PORT = 21;\n+\n+  /**\n+   * The FTP data port.\n+   */\n+  public static final int FTP_DATA_PORT = 20;\n+\n+  // -- FTP vocabulary --\n+  protected static final String USER = \"USER\";\n+  protected static final String PASS = \"PASS\";\n+  protected static final String ACCT = \"ACCT\";\n+  protected static final String CWD = \"CWD\";\n+  protected static final String CDUP = \"CDUP\";\n+  protected static final String SMNT = \"SMNT\";\n+  protected static final String REIN = \"REIN\";\n+  protected static final String QUIT = \"QUIT\";\n+\n+  protected static final String PORT = \"PORT\";\n+  protected static final String PASV = \"PASV\";\n+  protected static final String TYPE = \"TYPE\";\n+  protected static final String STRU = \"STRU\";\n+  protected static final String MODE = \"MODE\";\n+\n+  protected static final String RETR = \"RETR\";\n+  protected static final String STOR = \"STOR\";\n+  protected static final String STOU = \"STOU\";\n+  protected static final String APPE = \"APPE\";\n+  protected static final String ALLO = \"ALLO\";\n+  protected static final String REST = \"REST\";\n+  protected static final String RNFR = \"RNFR\";\n+  protected static final String RNTO = \"RNTO\";\n+  protected static final String ABOR = \"ABOR\";\n+  protected static final String DELE = \"DELE\";\n+  protected static final String RMD = \"RMD\";\n+  protected static final String MKD = \"MKD\";\n+  protected static final String PWD = \"PWD\";\n+  protected static final String LIST = \"LIST\";\n+  protected static final String NLST = \"NLST\";\n+  protected static final String SITE = \"SITE\";\n+  protected static final String SYST = \"SYST\";\n+  protected static final String STAT = \"STAT\";\n+  protected static final String HELP = \"HELP\";\n+  protected static final String NOOP = \"NOOP\";\n+  \n+  protected static final String AUTH = \"AUTH\";\n+  protected static final String PBSZ = \"PBSZ\";\n+  protected static final String PROT = \"PROT\";\n+  protected static final String CCC = \"CCC\";\n+  protected static final String TLS = \"TLS\";\n+\n+  public static final int TYPE_ASCII = 1;\n+  public static final int TYPE_EBCDIC = 2;\n+  public static final int TYPE_BINARY = 3;\n+\n+  public static final int STRUCTURE_FILE = 1;\n+  public static final int STRUCTURE_RECORD = 2;\n+  public static final int STRUCTURE_PAGE = 3;\n+\n+  public static final int MODE_STREAM = 1;\n+  public static final int MODE_BLOCK = 2;\n+  public static final int MODE_COMPRESSED = 3;\n+\n+  // -- Telnet constants --\n+  private static final String US_ASCII = \"US-ASCII\";\n+\n+  /**\n+   * The socket used to communicate with the server.\n+   */\n+  protected Socket socket;\n+\n+  /**\n+   * The socket input stream.\n+   */\n+  protected LineInputStream in;\n+\n+  /**\n+   * The socket output stream.\n+   */\n+  protected CRLFOutputStream out;\n+\n+  /**\n+   * The timeout when attempting to connect a socket.\n+   */\n+  protected int connectionTimeout;\n+\n+  /**\n+   * The read timeout on sockets.\n+   */\n+  protected int timeout;\n+\n+  /**\n+   * If true, print debugging information.\n+   */\n+  protected boolean debug;\n+\n+  /**\n+   * The current data transfer process in use by this connection.\n+   */\n+  protected DTP dtp;\n+\n+  /**\n+   * The current representation type.\n+   */\n+  protected int representationType = TYPE_ASCII;\n+\n+  /**\n+   * The current file structure type.\n+   */\n+  protected int fileStructure = STRUCTURE_FILE;\n+\n+  /**\n+   * The current transfer mode.\n+   */\n+  protected int transferMode = MODE_STREAM;\n+\n+  /**\n+   * If true, use passive mode.\n+   */\n+  protected boolean passive = false;\n+\n+  /**\n+   * Creates a new connection to the server using the default port.\n+   * @param hostname the hostname of the server to connect to\n+   */\n+  public FTPConnection(String hostname)\n+    throws UnknownHostException, IOException\n+  {\n+    this(hostname, -1, 0, 0, false);\n+  }\n+  \n+  /**\n+   * Creates a new connection to the server.\n+   * @param hostname the hostname of the server to connect to\n+   * @param port the port to connect to(if &lt;=0, use default port)\n+   */\n+  public FTPConnection(String hostname, int port)\n+    throws UnknownHostException, IOException\n+  {\n+    this(hostname, port, 0, 0, false);\n+  }\n+\n+  /**\n+   * Creates a new connection to the server.\n+   * @param hostname the hostname of the server to connect to\n+   * @param port the port to connect to(if &lt;=0, use default port)\n+   * @param connectionTimeout the connection timeout, in milliseconds\n+   * @param timeout the I/O timeout, in milliseconds\n+   * @param debug print debugging information\n+   */\n+  public FTPConnection(String hostname, int port,\n+                        int connectionTimeout, int timeout, boolean debug)\n+    throws UnknownHostException, IOException\n+  {\n+    this.connectionTimeout = connectionTimeout;\n+    this.timeout = timeout;\n+    this.debug = debug;\n+    if (port <= 0)\n+      {\n+        port = FTP_PORT;\n+      }\n+    \n+    // Set up socket\n+    socket = new Socket();\n+    InetSocketAddress address = new InetSocketAddress(hostname, port);\n+    if (connectionTimeout > 0)\n+      {\n+        socket.connect(address, connectionTimeout);\n+      }\n+    else\n+      {\n+        socket.connect(address);\n+      }\n+    if (timeout > 0)\n+      {\n+        socket.setSoTimeout(timeout);\n+      }\n+    \n+    InputStream in = socket.getInputStream();\n+    in = new BufferedInputStream(in);\n+    in = new CRLFInputStream(in);\n+    this.in = new LineInputStream(in);\n+    OutputStream out = socket.getOutputStream();\n+    out = new BufferedOutputStream(out);\n+    this.out = new CRLFOutputStream(out);\n+    \n+    // Read greeting\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 220:                  // hello\n+        break;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Authenticate using the specified username and password.\n+   * If the username suffices for the server, the password will not be used\n+   * and may be null.\n+   * @param username the username\n+   * @param password the optional password\n+   * @return true on success, false otherwise\n+   */\n+  public boolean authenticate(String username, String password)\n+    throws IOException\n+  {\n+    String cmd = USER + ' ' + username;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 230:                  // User logged in\n+        return true;\n+      case 331:                 // User name okay, need password\n+        break;\n+      case 332:                 // Need account for login\n+      case 530:                 // No such user\n+        return false;\n+      default:\n+        throw new FTPException(response);\n+      }\n+    cmd = PASS + ' ' + password;\n+    send(cmd);\n+    response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 230:                  // User logged in\n+      case 202:                  // Superfluous\n+        return true;\n+      case 332:                  // Need account for login\n+      case 530:                  // Bad password\n+        return false;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+\n+  /**\n+   * Negotiates TLS over the current connection.\n+   * See IETF draft-murray-auth-ftp-ssl-15.txt for details.\n+   * @param confidential whether to provide confidentiality for the\n+   * connection\n+   */\n+  public boolean starttls(boolean confidential)\n+    throws IOException\n+  {\n+    return starttls(confidential, new EmptyX509TrustManager());\n+  }\n+  \n+  /**\n+   * Negotiates TLS over the current connection.\n+   * See IETF draft-murray-auth-ftp-ssl-15.txt for details.\n+   * @param confidential whether to provide confidentiality for the\n+   * connection\n+   * @param tm the trust manager used to validate the server certificate.\n+   */\n+  public boolean starttls(boolean confidential, TrustManager tm)\n+    throws IOException\n+  {\n+    try\n+      {\n+        // Use SSLSocketFactory to negotiate a TLS session and wrap the\n+        // current socket.\n+        SSLContext context = SSLContext.getInstance(\"TLS\");\n+        // We don't require strong validation of the server certificate\n+        TrustManager[] trust = new TrustManager[] { tm };\n+        context.init(null, trust, null);\n+        SSLSocketFactory factory = context.getSocketFactory();\n+        \n+        send(AUTH + ' ' + TLS);\n+        FTPResponse response = getResponse();\n+        switch (response.getCode())\n+          {\n+          case 500:\n+          case 502:\n+          case 504:\n+          case 534:\n+          case 431:\n+            return false;\n+          case 234:\n+            break;\n+          default:\n+            throw new FTPException(response);\n+          }\n+        \n+        String hostname = socket.getInetAddress().getHostName();\n+        int port = socket.getPort();\n+        SSLSocket ss =\n+         (SSLSocket) factory.createSocket(socket, hostname, port, true);\n+        String[] protocols = { \"TLSv1\", \"SSLv3\" };\n+        ss.setEnabledProtocols(protocols);\n+        ss.setUseClientMode(true);\n+        ss.startHandshake();\n+\n+        // PBSZ:PROT sequence\n+        send(PBSZ + ' ' + Integer.MAX_VALUE);\n+        response = getResponse();\n+        switch (response.getCode())\n+          {\n+          case 501: // syntax error\n+          case 503: // not authenticated\n+            return false;\n+          case 200:\n+            break;\n+          default:\n+            throw new FTPException(response);\n+          }\n+        send(PROT + ' ' +(confidential ? 'P' : 'C'));\n+        response = getResponse();\n+        switch (response.getCode())\n+          {\n+          case 503: // not authenticated\n+          case 504: // invalid level\n+          case 536: // level not supported\n+            return false;\n+          case 200:\n+            break;\n+          default:\n+            throw new FTPException(response);\n+          }\n+        \n+        if (confidential)\n+          {\n+            // Set up streams\n+            InputStream in = ss.getInputStream();\n+            in = new BufferedInputStream(in);\n+            in = new CRLFInputStream(in);\n+            this.in = new LineInputStream(in);\n+            OutputStream out = ss.getOutputStream();\n+            out = new BufferedOutputStream(out);\n+            this.out = new CRLFOutputStream(out);\n+          }\n+        return true;\n+      }\n+    catch (GeneralSecurityException e)\n+      {\n+        return false;\n+      }\n+  }\n+  \n+  /**\n+   * Changes directory to the specified path.\n+   * @param path an absolute or relative pathname\n+   * @return true on success, false if the specified path does not exist\n+   */\n+  public boolean changeWorkingDirectory(String path)\n+    throws IOException\n+  {\n+    String cmd = CWD + ' ' + path;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 250:\n+        return true;\n+      case 550:\n+        return false;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Changes directory to the parent of the current working directory.\n+   * @return true on success, false otherwise\n+   */\n+  public boolean changeToParentDirectory()\n+    throws IOException\n+  {\n+    send(CDUP);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 250:\n+        return true;\n+      case 550:\n+        return false;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+\n+  /**\n+   * Terminates an authenticated login.\n+   * If file transfer is in progress, it remains active for result response\n+   * only.\n+   */\n+  public void reinitialize()\n+    throws IOException\n+  {\n+    send(REIN);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 220:\n+        if (dtp != null)\n+          {\n+            dtp.complete();\n+            dtp = null;\n+          }\n+        break;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+\n+  /**\n+   * Terminates the control connection.\n+   * The file transfer connection remains open for result response only.\n+   * This connection is invalid and no further commands may be issued.\n+   */\n+  public void logout()\n+    throws IOException\n+  {\n+    send(QUIT);\n+    try\n+      {\n+        getResponse();            // not required\n+      }\n+    catch (IOException e)\n+      {\n+      }\n+    if (dtp != null)\n+      {\n+        dtp.complete();\n+        dtp = null;\n+      }\n+    try\n+      {\n+        socket.close();\n+      }\n+    catch (IOException e)\n+      {\n+      }\n+  }\n+  \n+  /**\n+   * Initialise the data transfer process.\n+   */\n+  protected void initialiseDTP()\n+    throws IOException\n+  {\n+    if (dtp != null)\n+      {\n+        dtp.complete();\n+        dtp = null;\n+      }\n+    \n+    InetAddress localhost = socket.getLocalAddress();\n+    if (passive)\n+      {\n+        send(PASV);\n+        FTPResponse response = getResponse();\n+        switch (response.getCode())\n+          {\n+          case 227:\n+            String message = response.getMessage();\n+            try\n+              {\n+                int start = message.indexOf(',');\n+                char c = message.charAt(start - 1);\n+                while (c >= 0x30 && c <= 0x39)\n+                  {\n+                    c = message.charAt((--start) - 1);\n+                  }\n+                int mid1 = start;\n+                for (int i = 0; i < 4; i++)\n+                  {\n+                    mid1 = message.indexOf(',', mid1 + 1);\n+                  }\n+                int mid2 = message.indexOf(',', mid1 + 1);\n+                if (mid1 == -1 || mid2 < mid1)\n+                  {\n+                    throw new ProtocolException(\"Malformed 227: \" +\n+                                                 message);\n+                  }\n+                int end = mid2;\n+                c = message.charAt(end + 1);\n+                while (c >= 0x30 && c <= 0x39)\n+                  {\n+                    c = message.charAt((++end) + 1);\n+                  }\n+                \n+                String address =\n+                  message.substring(start, mid1).replace(',', '.');\n+                int port_hi =\n+                  Integer.parseInt(message.substring(mid1 + 1, mid2));\n+                int port_lo =\n+                  Integer.parseInt(message.substring(mid2 + 1, end + 1));\n+                int port = (port_hi << 8) | port_lo;\n+                \n+                /*System.out.println(\"Entering passive mode: \" + address +\n+                  \":\" + port);*/\n+                dtp = new PassiveModeDTP(address, port, localhost,\n+                                          connectionTimeout, timeout);\n+                break;\n+              }\n+            catch (ArrayIndexOutOfBoundsException e)\n+              {\n+                throw new ProtocolException(e.getMessage() + \": \" +\n+                                             message);\n+              }\n+            catch (NumberFormatException e)\n+              {\n+                throw new ProtocolException(e.getMessage() + \": \" +\n+                                             message);\n+              }\n+          default:\n+            throw new FTPException(response);\n+          }\n+      }\n+    else\n+      {\n+        // Get the local port\n+        int port = socket.getLocalPort() + 1;\n+        int tries = 0;\n+        // Bind the active mode DTP\n+        while (dtp == null)\n+          {\n+            try\n+              {\n+                dtp = new ActiveModeDTP(localhost, port,\n+                                         connectionTimeout, timeout);\n+                /*System.out.println(\"Listening on: \" + port);*/\n+              }\n+            catch (BindException e)\n+              {\n+                port++;\n+                tries++;\n+                if (tries > 9)\n+                  {\n+                    throw e;\n+                  }\n+              }\n+          }\n+        \n+        // Send PORT command\n+        StringBuffer buf = new StringBuffer(PORT);\n+        buf.append(' ');\n+        // Construct the address/port string form\n+        byte[] address = localhost.getAddress();\n+        for (int i = 0; i < address.length; i++)\n+          {\n+            int a =(int) address[i];\n+            if (a < 0)\n+              {\n+                a += 0x100;\n+              }\n+            buf.append(a);\n+            buf.append(',');\n+          }\n+        int port_hi =(port & 0xff00) >> 8;\n+        int port_lo =(port & 0x00ff);\n+        buf.append(port_hi);\n+        buf.append(',');\n+        buf.append(port_lo);\n+        send(buf.toString());\n+        // Get response\n+        FTPResponse response = getResponse();\n+        switch (response.getCode())\n+          {\n+          case 200:                // OK\n+            break;\n+          default:\n+            dtp.abort();\n+            dtp = null;\n+            throw new FTPException(response);\n+          }\n+      }\n+    dtp.setTransferMode(transferMode);\n+  }\n+  \n+  /**\n+   * Set passive mode.\n+   * @param flag true if we should use passive mode, false otherwise\n+   */\n+  public void setPassive(boolean flag)\n+    throws IOException\n+  {\n+    if (passive != flag)\n+      {\n+        passive = flag;\n+        initialiseDTP();\n+      }\n+  }\n+  \n+  /**\n+   * Returns the current representation type of the transfer data.\n+   * @return TYPE_ASCII, TYPE_EBCDIC, or TYPE_BINARY\n+   */\n+  public int getRepresentationType()\n+  {\n+    return representationType;\n+  }\n+\n+  /**\n+   * Sets the desired representation type of the transfer data.\n+   * @param type TYPE_ASCII, TYPE_EBCDIC, or TYPE_BINARY\n+   */\n+  public void setRepresentationType(int type)\n+    throws IOException\n+  {\n+    StringBuffer buf = new StringBuffer(TYPE);\n+    buf.append(' ');\n+    switch (type)\n+      {\n+      case TYPE_ASCII:\n+        buf.append('A');\n+        break;\n+      case TYPE_EBCDIC:\n+        buf.append('E');\n+        break;\n+      case TYPE_BINARY:\n+        buf.append('I');\n+        break;\n+      default:\n+        throw new IllegalArgumentException(Integer.toString(type));\n+      }\n+    //buf.append(' ');\n+    //buf.append('N');\n+    send(buf.toString());\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 200:\n+        representationType = type;\n+        break;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+\n+  /**\n+   * Returns the current file structure type.\n+   * @return STRUCTURE_FILE, STRUCTURE_RECORD, or STRUCTURE_PAGE\n+   */\n+  public int getFileStructure()\n+  {\n+    return fileStructure;\n+  }\n+\n+  /**\n+   * Sets the desired file structure type.\n+   * @param structure STRUCTURE_FILE, STRUCTURE_RECORD, or STRUCTURE_PAGE\n+   */\n+  public void setFileStructure(int structure)\n+    throws IOException\n+  {\n+    StringBuffer buf = new StringBuffer(STRU);\n+    buf.append(' ');\n+    switch (structure)\n+      {\n+      case STRUCTURE_FILE:\n+        buf.append('F');\n+        break;\n+      case STRUCTURE_RECORD:\n+        buf.append('R');\n+        break;\n+      case STRUCTURE_PAGE:\n+        buf.append('P');\n+        break;\n+      default:\n+        throw new IllegalArgumentException(Integer.toString(structure));\n+      }\n+    send(buf.toString());\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 200:\n+        fileStructure = structure;\n+        break;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+\n+  /**\n+   * Returns the current transfer mode.\n+   * @return MODE_STREAM, MODE_BLOCK, or MODE_COMPRESSED\n+   */\n+  public int getTransferMode()\n+  {\n+    return transferMode;\n+  }\n+\n+  /**\n+   * Sets the desired transfer mode.\n+   * @param mode MODE_STREAM, MODE_BLOCK, or MODE_COMPRESSED\n+   */\n+  public void setTransferMode(int mode)\n+    throws IOException\n+  {\n+    StringBuffer buf = new StringBuffer(MODE);\n+    buf.append(' ');\n+    switch (mode)\n+      {\n+      case MODE_STREAM:\n+        buf.append('S');\n+        break;\n+      case MODE_BLOCK:\n+        buf.append('B');\n+        break;\n+      case MODE_COMPRESSED:\n+        buf.append('C');\n+        break;\n+      default:\n+        throw new IllegalArgumentException(Integer.toString(mode));\n+      }\n+    send(buf.toString());\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 200:\n+        transferMode = mode;\n+        if (dtp != null)\n+          {\n+            dtp.setTransferMode(mode);\n+          }\n+        break;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Retrieves the specified file.\n+   * @param filename the filename of the file to retrieve\n+   * @return an InputStream containing the file content\n+   */\n+  public InputStream retrieve(String filename)\n+    throws IOException\n+  {\n+    if (dtp == null || transferMode == MODE_STREAM)\n+      {\n+        initialiseDTP();\n+      }\n+    /*\n+       int size = -1;\n+       String cmd = SIZE + ' ' + filename;\n+       send(cmd);\n+       FTPResponse response = getResponse();\n+       switch (response.getCode())\n+       {\n+       case 213:\n+       size = Integer.parseInt(response.getMessage());\n+       break;\n+       case 550: // File not found\n+       default:\n+       throw new FTPException(response);\n+       }\n+     */\n+    String cmd = RETR + ' ' + filename;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 125:                  // Data connection already open; transfer starting\n+      case 150:                  // File status okay; about to open data connection\n+        return dtp.getInputStream();\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Returns a stream for uploading a file.\n+   * If a file with the same filename already exists on the server, it will\n+   * be overwritten.\n+   * @param filename the name of the file to save the content as\n+   * @return an OutputStream to write the file data to\n+   */\n+  public OutputStream store(String filename)\n+    throws IOException\n+  {\n+    if (dtp == null || transferMode == MODE_STREAM)\n+      {\n+        initialiseDTP();\n+      }\n+    String cmd = STOR + ' ' + filename;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 125:                  // Data connection already open; transfer starting\n+      case 150:                  // File status okay; about to open data connection\n+        return dtp.getOutputStream();\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+\n+  /**\n+   * Returns a stream for uploading a file.\n+   * If a file with the same filename already exists on the server, the\n+   * content specified will be appended to the existing file.\n+   * @param filename the name of the file to save the content as\n+   * @return an OutputStream to write the file data to\n+   */\n+  public OutputStream append(String filename)\n+    throws IOException\n+  {\n+    if (dtp == null || transferMode == MODE_STREAM)\n+      {\n+        initialiseDTP();\n+      }\n+    String cmd = APPE + ' ' + filename;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 125:                  // Data connection already open; transfer starting\n+      case 150:                  // File status okay; about to open data connection\n+        return dtp.getOutputStream();\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * This command may be required by some servers to reserve sufficient\n+   * storage to accommodate the new file to be transferred.\n+   * It should be immediately followed by a <code>store</code> or\n+   * <code>append</code>.\n+   * @param size the number of bytes of storage to allocate\n+   */\n+  public void allocate(long size)\n+    throws IOException\n+  {\n+    String cmd = ALLO + ' ' + size;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 200:                  // OK\n+      case 202:                  // Superfluous\n+        break;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Renames a file.\n+   * @param oldName the current name of the file\n+   * @param newName the new name\n+   * @return true if successful, false otherwise\n+   */\n+  public boolean rename(String oldName, String newName)\n+    throws IOException\n+  {\n+    String cmd = RNFR + ' ' + oldName;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 450:                  // File unavailable\n+      case 550:                  // File not found\n+        return false;\n+      case 350:                 // Pending\n+        break;\n+      default:\n+        throw new FTPException(response);\n+      }\n+    cmd = RNTO + ' ' + newName;\n+    send(cmd);\n+    response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 250:                  // OK\n+        return true;\n+      case 450:\n+      case 550:\n+        return false;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Aborts the transfer in progress.\n+   * @return true if a transfer was in progress, false otherwise\n+   */\n+  public boolean abort()\n+    throws IOException\n+  {\n+    send(ABOR);\n+    FTPResponse response = getResponse();\n+    // Abort client DTP\n+    if (dtp != null)\n+      {\n+        dtp.abort();\n+      }\n+    switch (response.getCode())\n+      {\n+      case 226:                  // successful abort\n+        return false;\n+      case 426:                 // interrupted\n+        response = getResponse();\n+        if (response.getCode() == 226)\n+          {\n+            return true;\n+          }\n+        // Otherwise fall through to throw exception\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Causes the file specified to be deleted at the server site.\n+   * @param filename the file to delete\n+   */\n+  public boolean delete(String filename)\n+    throws IOException\n+  {\n+    String cmd = DELE + ' ' + filename;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 250:                  // OK\n+        return true;\n+      case 450:                 // File unavailable\n+      case 550:                 // File not found\n+        return false;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Causes the directory specified to be deleted.\n+   * This may be an absolute or relative pathname.\n+   * @param pathname the directory to delete\n+   */\n+  public boolean removeDirectory(String pathname)\n+    throws IOException\n+  {\n+    String cmd = RMD + ' ' + pathname;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 250:                  // OK\n+        return true;\n+      case 550:                 // File not found\n+        return false;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+\n+  /**\n+   * Causes the directory specified to be created at the server site.\n+   * This may be an absolute or relative pathname.\n+   * @param pathname the directory to create\n+   */\n+  public boolean makeDirectory(String pathname)\n+    throws IOException\n+  {\n+    String cmd = MKD + ' ' + pathname;\n+    send(cmd);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 257:                  // Directory created\n+        return true;\n+      case 550:                 // File not found\n+        return false;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Returns the current working directory.\n+   */\n+  public String getWorkingDirectory()\n+    throws IOException\n+  {\n+    send(PWD);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 257:\n+        String message = response.getMessage();\n+        if (message.charAt(0) == '\"')\n+          {\n+            int end = message.indexOf('\"', 1);\n+            if (end == -1)\n+              {\n+                throw new ProtocolException(message);\n+              }\n+            return message.substring(1, end);\n+          }\n+        else\n+          {\n+            int end = message.indexOf(' ');\n+            if (end == -1)\n+              {\n+                return message;\n+              }\n+            else\n+              {\n+                return message.substring(0, end);\n+              }\n+          }\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Returns a listing of information about the specified pathname.\n+   * If the pathname specifies a directory or other group of files, the\n+   * server should transfer a list of files in the specified directory.\n+   * If the pathname specifies a file then the server should send current\n+   * information on the file.  A null argument implies the user's\n+   * current working or default directory.\n+   * @param pathname the context pathname, or null\n+   */\n+  public InputStream list(String pathname)\n+    throws IOException\n+  {\n+    if (dtp == null || transferMode == MODE_STREAM)\n+      {\n+        initialiseDTP();\n+      }\n+    if (pathname == null)\n+      {\n+        send(LIST);\n+      }\n+    else\n+      {\n+        String cmd = LIST + ' ' + pathname;\n+        send(cmd);\n+      }\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 125:                  // Data connection already open; transfer starting\n+      case 150:                  // File status okay; about to open data connection\n+        return dtp.getInputStream();\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Returns a directory listing. The pathname should specify a\n+   * directory or other system-specific file group descriptor; a null\n+   * argument implies the user's current working or default directory.\n+   * @param pathname the directory pathname, or null\n+   * @return a list of filenames(strings)\n+   */\n+  public List nameList(String pathname)\n+    throws IOException\n+  {\n+    if (dtp == null || transferMode == MODE_STREAM)\n+      {\n+        initialiseDTP();\n+      }\n+    if (pathname == null)\n+      {\n+        send(NLST);\n+      }\n+    else\n+      {\n+        String cmd = NLST + ' ' + pathname;\n+        send(cmd);\n+      }\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 125:                  // Data connection already open; transfer starting\n+      case 150:                  // File status okay; about to open data connection\n+        InputStream in = dtp.getInputStream();\n+        in = new BufferedInputStream(in);\n+        in = new CRLFInputStream(in);     // TODO ensure that TYPE is correct\n+        LineInputStream li = new LineInputStream(in);\n+        List ret = new ArrayList();\n+        for (String line = li.readLine();\n+             line != null;\n+             line = li.readLine())\n+          {\n+            ret.add(line);\n+          }\n+        li.close();\n+        return ret;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Returns the type of operating system at the server.\n+   */\n+  public String system()\n+    throws IOException\n+  {\n+    send(SYST);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 215:\n+        String message = response.getMessage();\n+        int end = message.indexOf(' ');\n+        if (end == -1)\n+          {\n+            return message;\n+          }\n+        else\n+          {\n+            return message.substring(0, end);\n+          }\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+  \n+  /**\n+   * Does nothing.\n+   * This method can be used to ensure that the connection does not time\n+   * out.\n+   */\n+  public void noop()\n+    throws IOException\n+  {\n+    send(NOOP);\n+    FTPResponse response = getResponse();\n+    switch (response.getCode())\n+      {\n+      case 200:\n+        break;\n+      default:\n+        throw new FTPException(response);\n+      }\n+  }\n+\n+  // -- I/O --\n+\n+  /**\n+   * Sends the specified command line to the server.\n+   * The CRLF sequence is automatically appended.\n+   * @param cmd the command line to send\n+   */\n+  protected void send(String cmd)\n+    throws IOException\n+  {\n+    byte[] data = cmd.getBytes(US_ASCII);\n+    out.write(data);\n+    out.writeln();\n+    out.flush();\n+  }\n+\n+  /**\n+   * Reads the next response from the server.\n+   * If the server sends the \"transfer complete\" code, this is handled here,\n+   * and the next response is passed to the caller.\n+   */\n+  protected FTPResponse getResponse()\n+    throws IOException\n+  {\n+    FTPResponse response = readResponse();\n+    if (response.getCode() == 226)\n+      {\n+        if (dtp != null)\n+          {\n+            dtp.transferComplete();\n+          }\n+        response = readResponse();\n+      }\n+    return response;\n+  }\n+\n+  /**\n+   * Reads and parses the next response from the server.\n+   */\n+  protected FTPResponse readResponse()\n+    throws IOException\n+  {\n+    String line = in.readLine();\n+    if (line == null)\n+      {\n+        throw new ProtocolException( \"EOF\");\n+      }\n+    if (line.length() < 4)\n+      {\n+        throw new ProtocolException(line);\n+      }\n+    int code = parseCode(line);\n+    if (code == -1)\n+      {\n+        throw new ProtocolException(line);\n+      }\n+    char c = line.charAt(3);\n+    if (c == ' ')\n+      {\n+        return new FTPResponse(code, line.substring(4));\n+      }\n+    else if (c == '-')\n+      {\n+        StringBuffer buf = new StringBuffer(line.substring(4));\n+        buf.append('\\n');\n+        while(true)\n+          {\n+            line = in.readLine();\n+            if (line == null)\n+              {\n+                throw new ProtocolException(\"EOF\");\n+              }\n+            if (line.length() >= 4 &&\n+                line.charAt(3) == ' ' &&\n+                parseCode(line) == code)\n+              {\n+                return new FTPResponse(code, line.substring(4),\n+                                        buf.toString());\n+              }\n+            else\n+              {\n+                buf.append(line);\n+                buf.append('\\n');\n+              }\n+          }\n+      }\n+    else\n+      {\n+        throw new ProtocolException(line);\n+      }\n+  }\n+  \n+  /*\n+   * Parses the 3-digit numeric code at the beginning of the given line.\n+   * Returns -1 on failure.\n+   */\n+  static final int parseCode(String line)\n+  {\n+    char[] c = { line.charAt(0), line.charAt(1), line.charAt(2) };\n+    int ret = 0;\n+    for (int i = 0; i < 3; i++)\n+      {\n+        int digit =((int) c[i]) - 0x30;\n+        if (digit < 0 || digit > 9)\n+          {\n+            return -1;\n+          }\n+        // Computing integer powers is way too expensive in Java!\n+        switch (i)\n+          {\n+          case 0:\n+            ret +=(100 * digit);\n+            break;\n+          case 1:\n+            ret +=(10 * digit);\n+            break;\n+          case 2:\n+            ret += digit;\n+            break;\n+          }\n+      }\n+    return ret;\n+  }\n+\n+}\n+"}, {"sha": "cdf4cc7a49157167673bb284aad2cfd1532e2a60", "filename": "libjava/gnu/java/net/protocol/ftp/FTPException.java", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPException.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,76 @@\n+/* FTPException.java --\n+   Copyright (C) 2003. 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.IOException;\n+\n+/**\n+ * An FTP control exception.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class FTPException\n+  extends IOException\n+{\n+\n+  /**\n+   * The response that provoked this exception.\n+   */\n+  protected final FTPResponse response;\n+\n+  /**\n+   * Constructs a new FTP exception.\n+   * @param response the response that provoked this exception\n+   */\n+  public FTPException(FTPResponse response)\n+  {\n+    super(response.getMessage());\n+    this.response = response;\n+  }\n+  \n+  /**\n+   * Returns the response that provoked this exception.\n+   */\n+  public FTPResponse getResponse()\n+  {\n+    return response;\n+  }\n+\n+}\n+"}, {"sha": "3ce9982918bef46b01647a55b1a0625ed7ee0abc", "filename": "libjava/gnu/java/net/protocol/ftp/FTPResponse.java", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPResponse.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPResponse.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPResponse.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,112 @@\n+/* FTPResponse.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+/**\n+ * An FTP control response.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public final class FTPResponse\n+{\n+\n+  /**\n+   * The 3-digit status code.\n+   */\n+  protected final int code;\n+\n+  /**\n+   * The human-readable message.\n+   */\n+  protected final String message;\n+\n+  /**\n+   * Multiline data, if present.\n+   */\n+  protected final String data;\n+\n+  /**\n+   * Constructs a new FTP response.\n+   * @param code the status code\n+   * @param message the message\n+   */\n+  public FTPResponse(int code, String message)\n+  {\n+    this(code, message, null);\n+  }\n+\n+  /**\n+   * Constructs a new multiline FTP response.\n+   * @param code the status code\n+   * @param message the message\n+   * @param data multiline data\n+   */\n+  public FTPResponse(int code, String message, String data)\n+  {\n+    this.code = code;\n+    this.message = message;\n+    this.data = data;\n+  }\n+\n+  /**\n+   * Returns the 3-digit status code.\n+   */\n+  public int getCode()\n+  {\n+    return code;\n+  }\n+\n+  /**\n+   * Returns the human-readable message.\n+   */\n+  public String getMessage()\n+  {\n+    return message;\n+  }\n+\n+  /**\n+   * Returns the multiline data, or null if there was no such data.\n+   */\n+  public String getData()\n+  {\n+    return data;\n+  }\n+\n+}\n+"}, {"sha": "368c035c33902065c5e115c37d537c7d4ace8010", "filename": "libjava/gnu/java/net/protocol/ftp/FTPURLConnection.java", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FFTPURLConnection.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,398 @@\n+/* FTPURLConnection.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import gnu.java.net.GetLocalHostAction;\n+import gnu.java.security.action.GetPropertyAction;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FilterInputStream;\n+import java.io.FilterOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * An FTP URL connection.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class FTPURLConnection\n+  extends URLConnection\n+{\n+\n+  /**\n+   * The connection managing the protocol exchange.\n+   */\n+  protected FTPConnection connection;\n+\n+  protected boolean passive;\n+  protected int representationType;\n+  protected int fileStructure;\n+  protected int transferMode;\n+\n+  /**\n+   * Constructs an FTP connection to the specified URL.\n+   * @param url the URL\n+   */\n+  public FTPURLConnection(URL url)\n+  {\n+    super(url);\n+    passive = true;\n+    representationType = FTPConnection.TYPE_BINARY;\n+    fileStructure = -1;\n+    transferMode = -1;\n+  }\n+\n+  /**\n+   * Establishes the connection.\n+   */\n+  public void connect()\n+    throws IOException\n+  {\n+    if (connected)\n+      {\n+        return;\n+      }\n+    String host = url.getHost();\n+    int port = url.getPort();\n+    String username = url.getUserInfo();\n+    String password = null;\n+    if (username != null)\n+      {\n+        int ci = username.indexOf(':');\n+        if (ci != -1)\n+          {\n+            password = username.substring(ci + 1);\n+            username = username.substring(0, ci);\n+          }\n+      }\n+    else\n+      {\n+        username = \"anonymous\";\n+        PrivilegedAction a = new GetPropertyAction(\"user.name\");\n+        String systemUsername =(String) AccessController.doPrivileged(a);\n+        a = new GetLocalHostAction();\n+        InetAddress localhost =(InetAddress) AccessController.doPrivileged(a);\n+        password = systemUsername + \"@\" +\n+          ((localhost == null) ? \"localhost\" : localhost.getHostName());\n+      }\n+    connection = new FTPConnection(host, port);\n+    if (!connection.authenticate(username, password))\n+      {\n+        throw new SecurityException(\"Authentication failed\");\n+      }\n+    connection.setPassive(passive);\n+    if (representationType != -1)\n+      {\n+        connection.setRepresentationType(representationType);\n+      }\n+    if (fileStructure != -1)\n+      {\n+        connection.setFileStructure(fileStructure);\n+      }\n+    if (transferMode != -1)\n+      {\n+        connection.setTransferMode(transferMode);\n+      }\n+  }\n+  \n+  /**\n+   * This connection supports doInput.\n+   */\n+  public void setDoInput(boolean doinput)\n+  {\n+    doInput = doinput;\n+  }\n+\n+  /**\n+   * This connection supports doOutput.\n+   */\n+  public void setDoOutput(boolean dooutput)\n+  {\n+    doOutput = dooutput;\n+  }\n+  \n+  /**\n+   * Returns an input stream that reads from this open connection.\n+   */\n+  public InputStream getInputStream()\n+    throws IOException\n+  {\n+    if (!connected)\n+      {\n+        connect();\n+      }\n+    String path = url.getPath();\n+    String filename = null;\n+    int lsi = path.lastIndexOf('/');\n+    if (lsi != -1)\n+      {\n+        filename = path.substring(lsi + 1);\n+        path = path.substring(0, lsi);\n+        if (!connection.changeWorkingDirectory(path))\n+          {\n+            throw new FileNotFoundException(path);\n+          }\n+      }\n+    if (filename != null && filename.length() > 0)\n+      {\n+        return this.new ClosingInputStream(connection.retrieve(filename));\n+      }\n+    else\n+      {\n+        return this.new ClosingInputStream(connection.list(null));\n+      }\n+  }\n+  \n+  /**\n+   * Returns an output stream that writes to this connection.\n+   */\n+  public OutputStream getOutputStream()\n+    throws IOException\n+  {\n+    if (!connected)\n+      {\n+        connect();\n+      }\n+    String dir = url.getPath();\n+    String filename = url.getFile();\n+    if (!connection.changeWorkingDirectory(dir))\n+      {\n+        throw new FileNotFoundException(dir);\n+      }\n+    if (filename != null)\n+      {\n+        return this.new ClosingOutputStream(connection.store(filename));\n+      }\n+    else\n+      {\n+        throw new FileNotFoundException(filename);\n+      }\n+  }\n+\n+  public String getRequestProperty(String key)\n+  {\n+    if (\"passive\".equals(key))\n+      {\n+        return Boolean.toString(passive);\n+      }\n+    else if (\"representationType\".equals(key))\n+      {\n+        switch (representationType)\n+          {\n+          case FTPConnection.TYPE_ASCII:\n+            return \"ASCII\";\n+          case FTPConnection.TYPE_EBCDIC:\n+            return \"EBCDIC\";\n+          case FTPConnection.TYPE_BINARY:\n+            return \"BINARY\";\n+          }\n+      }\n+    else if (\"fileStructure\".equals(key))\n+      {\n+        switch (fileStructure)\n+          {\n+          case FTPConnection.STRUCTURE_FILE:\n+            return \"FILE\";\n+          case FTPConnection.STRUCTURE_RECORD:\n+            return \"RECORD\";\n+          case FTPConnection.STRUCTURE_PAGE:\n+            return \"PAGE\";\n+          }\n+      }\n+    else if (\"transferMode\".equals(key))\n+      {\n+        switch (transferMode)\n+          {\n+          case FTPConnection.MODE_STREAM:\n+            return \"STREAM\";\n+          case FTPConnection.MODE_BLOCK:\n+            return \"BLOCK\";\n+          case FTPConnection.MODE_COMPRESSED:\n+            return \"COMPRESSED\";\n+          }\n+      }\n+    return null;\n+  }\n+\n+  public Map getRequestProperties()\n+  {\n+    Map map = new HashMap();\n+    addRequestPropertyValue(map, \"passive\");\n+    addRequestPropertyValue(map, \"representationType\");\n+    addRequestPropertyValue(map, \"fileStructure\");\n+    addRequestPropertyValue(map, \"transferMode\");\n+    return map;\n+  }\n+\n+  private void addRequestPropertyValue(Map map, String key)\n+  {\n+    String value = getRequestProperty(key);\n+    map.put(key, value);\n+  }\n+  \n+  public void setRequestProperty(String key, String value)\n+  {\n+    if (connected)\n+      {\n+        throw new IllegalStateException();\n+      }\n+    if (\"passive\".equals(key))\n+      {\n+        passive = Boolean.valueOf(value).booleanValue();\n+      }\n+    else if (\"representationType\".equals(key))\n+      {\n+        if (\"A\".equalsIgnoreCase(value) ||\n+            \"ASCII\".equalsIgnoreCase(value))\n+          {\n+            representationType = FTPConnection.TYPE_ASCII;\n+          }\n+        else if (\"E\".equalsIgnoreCase(value) ||\n+                 \"EBCDIC\".equalsIgnoreCase(value))\n+          {\n+            representationType = FTPConnection.TYPE_EBCDIC;\n+          }\n+        else if (\"I\".equalsIgnoreCase(value) ||\n+                 \"BINARY\".equalsIgnoreCase(value))\n+          {\n+            representationType = FTPConnection.TYPE_BINARY;\n+          }\n+        else\n+          {\n+            throw new IllegalArgumentException(value);\n+          }\n+      }\n+    else if (\"fileStructure\".equals(key))\n+      {\n+        if (\"F\".equalsIgnoreCase(value) ||\n+            \"FILE\".equalsIgnoreCase(value))\n+          {\n+            fileStructure = FTPConnection.STRUCTURE_FILE;\n+          }\n+        else if (\"R\".equalsIgnoreCase(value) ||\n+                 \"RECORD\".equalsIgnoreCase(value))\n+          {\n+            fileStructure = FTPConnection.STRUCTURE_RECORD;\n+          }\n+        else if (\"P\".equalsIgnoreCase(value) ||\n+                 \"PAGE\".equalsIgnoreCase(value))\n+          {\n+            fileStructure = FTPConnection.STRUCTURE_PAGE;\n+          }\n+        else\n+          {\n+            throw new IllegalArgumentException(value);\n+          }\n+      }\n+    else if (\"transferMode\".equals(key))\n+      {\n+        if (\"S\".equalsIgnoreCase(value) ||\n+            \"STREAM\".equalsIgnoreCase(value))\n+          {\n+            transferMode = FTPConnection.MODE_STREAM;\n+          }\n+        else if (\"B\".equalsIgnoreCase(value) ||\n+                 \"BLOCK\".equalsIgnoreCase(value))\n+          {\n+            transferMode = FTPConnection.MODE_BLOCK;\n+          }\n+        else if (\"C\".equalsIgnoreCase(value) ||\n+                 \"COMPRESSED\".equalsIgnoreCase(value))\n+          {\n+            transferMode = FTPConnection.MODE_COMPRESSED;\n+          }\n+        else\n+          {\n+            throw new IllegalArgumentException(value);\n+          }\n+      }\n+  }\n+\n+  public void addRequestProperty(String key, String value)\n+  {\n+    setRequestProperty(key, value);\n+  }\n+\n+  class ClosingInputStream\n+    extends FilterInputStream\n+  {\n+\n+    ClosingInputStream(InputStream in)\n+    {\n+      super(in);\n+    }\n+\n+    public void close()\n+      throws IOException\n+    {\n+      super.close();\n+      connection.logout();\n+    }\n+    \n+  }\n+\n+  class ClosingOutputStream\n+    extends FilterOutputStream\n+  {\n+\n+    ClosingOutputStream(OutputStream out)\n+    {\n+      super(out);\n+    }\n+\n+    public void close()\n+      throws IOException\n+    {\n+      super.close();\n+      connection.logout();\n+    }\n+    \n+  }\n+\n+}\n+"}, {"sha": "01e187c4c9e2b60eb90cc0dab27192b9f7b3610c", "filename": "libjava/gnu/java/net/protocol/ftp/Handler.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FHandler.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,70 @@\n+/* Handler.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+\n+/**\n+ * An FTP URL stream handler.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class Handler\n+  extends URLStreamHandler\n+{\n+\n+  protected int getDefaultPort()\n+  {\n+    return FTPConnection.FTP_PORT;\n+  }\n+\n+  /**\n+   * Returns an FTPURLConnection for the given URL.\n+   */\n+  public URLConnection openConnection(URL url)\n+    throws IOException\n+  {\n+    return new FTPURLConnection(url);\n+  }\n+\n+}\n+"}, {"sha": "c08eb5ca18f5868fc959f9a67b5931cf5c8bc53c", "filename": "libjava/gnu/java/net/protocol/ftp/PassiveModeDTP.java", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FPassiveModeDTP.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FPassiveModeDTP.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FPassiveModeDTP.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,201 @@\n+/* PassiveModeDTP.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+\n+/**\n+ * A passive mode FTP data transfer process.\n+ * This connects to the host specified and proxies the resulting socket's\n+ * input and output streams.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+final class PassiveModeDTP\n+  implements DTP\n+{\n+\n+  final String address;\n+  final int port;\n+  Socket socket;\n+  DTPInputStream in;\n+  DTPOutputStream out;\n+  boolean completed;\n+  boolean inProgress;\n+  int transferMode;\n+\n+  PassiveModeDTP(String address, int port, InetAddress localhost,\n+                 int connectionTimeout, int timeout)\n+    throws IOException\n+  {\n+    this.address = address;\n+    this.port = port;\n+    completed = false;\n+    inProgress = false;\n+    socket = new Socket();\n+    InetSocketAddress remote = new InetSocketAddress(address, port);\n+    InetSocketAddress local = new InetSocketAddress(localhost, port + 1);\n+    socket.bind(local);\n+    if (connectionTimeout > 0)\n+      {\n+        socket.connect(remote, connectionTimeout);\n+      }\n+    else\n+      {\n+        socket.connect(remote);\n+      }\n+    if (timeout > 0)\n+      {\n+        socket.setSoTimeout(timeout);\n+      }\n+  }\n+\n+  /**\n+   * Returns an input stream from which a remote file can be read.\n+   */\n+  public InputStream getInputStream()\n+    throws IOException\n+  {\n+    if (inProgress)\n+      {\n+        throw new IOException(\"Transfer in progress\");\n+      }\n+    switch (transferMode)\n+      {\n+      case FTPConnection.MODE_STREAM:\n+        in = new StreamInputStream(this, socket.getInputStream());\n+        break;\n+      case FTPConnection.MODE_BLOCK:\n+        in = new BlockInputStream(this, socket.getInputStream());\n+        break;\n+      case FTPConnection.MODE_COMPRESSED:\n+        in = new CompressedInputStream(this, socket.getInputStream());\n+        break;\n+      default:\n+        throw new IllegalStateException(\"Invalid transfer mode\");\n+      }\n+    in.setTransferComplete(false);\n+    return in;\n+  }\n+  \n+  /**\n+   * Returns an output stream to which a local file can be written for\n+   * upload.\n+   */\n+  public OutputStream getOutputStream()\n+    throws IOException\n+  {\n+    if (inProgress)\n+      {\n+        throw new IOException(\"Transfer in progress\");\n+      }\n+    switch (transferMode)\n+      {\n+      case FTPConnection.MODE_STREAM:\n+        out = new StreamOutputStream(this, socket.getOutputStream());\n+        break;\n+      case FTPConnection.MODE_BLOCK:\n+        out = new BlockOutputStream(this, socket.getOutputStream());\n+        break;\n+      case FTPConnection.MODE_COMPRESSED:\n+        out = new CompressedOutputStream(this, socket.getOutputStream());\n+        break;\n+      default:\n+        throw new IllegalStateException(\"Invalid transfer mode\");\n+      }\n+    out.setTransferComplete(false);\n+    return out;\n+  }\n+  \n+  public void setTransferMode(int mode)\n+  {\n+    transferMode = mode;\n+  }\n+  \n+  public void complete()\n+  {\n+    completed = true;\n+    if (!inProgress)\n+      {\n+        transferComplete();\n+      }\n+  }\n+\n+  public boolean abort()\n+  {\n+    completed = true;\n+    transferComplete();\n+    return inProgress;\n+  }\n+\n+  /*\n+   * Called by DTPInputStream or DTPOutputStream when end of\n+   * stream is reached.\n+   */\n+  public void transferComplete()\n+  {\n+    if (in != null)\n+      {\n+        in.setTransferComplete(true);\n+      }\n+    if (out != null)\n+      {\n+        out.setTransferComplete(true);\n+      }\n+    inProgress = false;\n+    completed = completed ||(transferMode == FTPConnection.MODE_STREAM);\n+    if (completed && socket != null)\n+      {\n+        try\n+          {\n+            socket.close();\n+          }\n+        catch (IOException e)\n+          {\n+          }\n+      }\n+  }\n+\n+}\n+"}, {"sha": "0ee8857f85298651fdce8bdd86930532fb12d55d", "filename": "libjava/gnu/java/net/protocol/ftp/StreamInputStream.java", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FStreamInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FStreamInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FStreamInputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,95 @@\n+/* StreamInputStream.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * A DTP input stream that implements the FTP stream data transfer mode.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+class StreamInputStream\n+  extends DTPInputStream\n+{\n+\n+  StreamInputStream(DTP dtp, InputStream in)\n+  {\n+    super(dtp, in);\n+  }\n+  \n+  public int read()\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return -1;\n+      }\n+    int c = in.read();\n+    if (c == -1)\n+      {\n+        close();\n+      }\n+    return c;\n+  }\n+\n+  public int read(byte[] buf)\n+    throws IOException\n+  {\n+    return read(buf, 0, buf.length);\n+  }\n+\n+  public int read(byte[] buf, int off, int len)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return -1;\n+      }\n+    int l = in.read(buf, off, len);\n+    if (l == -1)\n+      {\n+        close();\n+      }\n+    return l;\n+  }\n+\n+}\n+"}, {"sha": "67fd4f3b83e88c6ae3f44492766590f15b8ee9a3", "filename": "libjava/gnu/java/net/protocol/ftp/StreamOutputStream.java", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FStreamOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FStreamOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2FStreamOutputStream.java?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,85 @@\n+/* StreamOutputStream.java --\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.ftp;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * A DTP output stream that implements the FTP stream transfer mode.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+class StreamOutputStream\n+  extends DTPOutputStream\n+{\n+\n+  StreamOutputStream(DTP dtp, OutputStream out)\n+  {\n+    super(dtp, out);\n+  }\n+  \n+  public void write(int c)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return;\n+      }\n+    out.write(c);\n+  }\n+\n+  public void write(byte[] b)\n+    throws IOException\n+  {\n+    write(b, 0, b.length);\n+  }\n+  \n+  public void write(byte[] b, int off, int len)\n+    throws IOException\n+  {\n+    if (transferComplete)\n+      {\n+        return;\n+      }\n+    out.write(b, off, len);\n+  }\n+  \n+}\n+"}, {"sha": "ce48c39183c156f35811f4333b3ca972c589f899", "filename": "libjava/gnu/java/net/protocol/ftp/package.html", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2Fpackage.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aec6c476ff4060c80d1349658b27d900f67b33c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2Fpackage.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fftp%2Fpackage.html?ref=4aec6c476ff4060c80d1349658b27d900f67b33c", "patch": "@@ -0,0 +1,60 @@\n+<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n+<!-- package.html - describes classes in gnu.java.net.protocol.ftp package.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. -->\n+\n+<html>\n+<head><title>GNU Classpath - gnu.java.net.protocol.ftp</title></head>\n+\n+<body>\n+\n+<p>\n+This package contains an FTP client. It can handle both active and passive\n+mode connections and the various transfer modes and representation types.\n+</p>\n+\n+<p>\n+Interaction with the server is via a simple stream interface. Only one\n+concurrent stream (input or output) is supported.\n+</p>\n+\n+<p>\n+The control connection to the server can be protected using TLS\n+(the starttls method).\n+</p>\n+\n+</body>\n+</html>"}]}