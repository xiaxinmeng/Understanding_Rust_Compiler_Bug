{"sha": "4ed88ee36cb81d22afeb3b5beba1d1655642b46b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVkODhlZTM2Y2I4MWQyMmFmZWIzYjViZWJhMWQxNjU1NjQyYjQ2Yg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-07-24T23:31:28Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-07-24T23:31:28Z"}, "message": "cfgloop.c (init_loops_structure): New function.\n\n\t* cfgloop.c (init_loops_structure): New function.\n\t(flow_loops_find): Create root of the loop tree unconditionally.\n\nFrom-SVN: r126891", "tree": {"sha": "a96cbdf48b071cfed25532a66f9b0589d936deee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a96cbdf48b071cfed25532a66f9b0589d936deee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ed88ee36cb81d22afeb3b5beba1d1655642b46b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed88ee36cb81d22afeb3b5beba1d1655642b46b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ed88ee36cb81d22afeb3b5beba1d1655642b46b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed88ee36cb81d22afeb3b5beba1d1655642b46b/comments", "author": null, "committer": null, "parents": [{"sha": "7d0a07d0c66be19ec1bd822242a6451dc0d3b024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0a07d0c66be19ec1bd822242a6451dc0d3b024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d0a07d0c66be19ec1bd822242a6451dc0d3b024"}], "stats": {"total": 53, "additions": 35, "deletions": 18}, "files": [{"sha": "bc794a25a42372d24b42808348c20293a1a69d34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed88ee36cb81d22afeb3b5beba1d1655642b46b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed88ee36cb81d22afeb3b5beba1d1655642b46b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ed88ee36cb81d22afeb3b5beba1d1655642b46b", "patch": "@@ -1,3 +1,8 @@\n+2007-07-25  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* cfgloop.c (init_loops_structure): New function.\n+\t(flow_loops_find): Create root of the loop tree unconditionally.\n+\n 2007-07-24  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* tree-ssa-ccp.c (fold_const_aggregate_ref): Use fold_convert."}, {"sha": "6542b3a5ed595f8f675c1a59a3b0ee48ede9783e", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed88ee36cb81d22afeb3b5beba1d1655642b46b/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed88ee36cb81d22afeb3b5beba1d1655642b46b/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=4ed88ee36cb81d22afeb3b5beba1d1655642b46b", "patch": "@@ -343,6 +343,29 @@ alloc_loop (void)\n   return loop;\n }\n \n+/* Initializes loops structure LOOPS, reserving place for NUM_LOOPS loops\n+   (including the root of the loop tree).  */\n+\n+static void\n+init_loops_structure (struct loops *loops, unsigned num_loops)\n+{\n+  struct loop *root;\n+\n+  memset (loops, 0, sizeof *loops);\n+  loops->larray = VEC_alloc (loop_p, gc, num_loops);\n+\n+  /* Dummy loop containing whole function.  */\n+  root = alloc_loop ();\n+  root->num_nodes = n_basic_blocks;\n+  root->latch = EXIT_BLOCK_PTR;\n+  root->header = ENTRY_BLOCK_PTR;\n+  ENTRY_BLOCK_PTR->loop_father = root;\n+  EXIT_BLOCK_PTR->loop_father = root;\n+\n+  VEC_quick_push (loop_p, loops->larray, root);\n+  loops->tree_root = root;\n+}\n+\n /* Find all the natural loops in the function and save in LOOPS structure and\n    recalculate loop_depth information in basic block structures.\n    Return the number of natural loops found.  */\n@@ -358,21 +381,21 @@ flow_loops_find (struct loops *loops)\n   int *rc_order;\n   basic_block header;\n   basic_block bb;\n-  struct loop *root;\n \n-  memset (loops, 0, sizeof *loops);\n+  /* Ensure that the dominators are computed.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n   if (n_basic_blocks == NUM_FIXED_BLOCKS)\n-    return 0;\n+    {\n+      init_loops_structure (loops, 1);\n+      return 1;\n+    }\n \n   dfs_order = NULL;\n   rc_order = NULL;\n \n-  /* Ensure that the dominators are computed.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n   /* Count the number of loop headers.  This should be the\n      same as the number of natural loops.  */\n   headers = sbitmap_alloc (last_basic_block);\n@@ -415,18 +438,7 @@ flow_loops_find (struct loops *loops)\n     }\n \n   /* Allocate loop structures.  */\n-  loops->larray = VEC_alloc (loop_p, gc, num_loops + 1);\n-\n-  /* Dummy loop containing whole function.  */\n-  root = alloc_loop ();\n-  root->num_nodes = n_basic_blocks;\n-  root->latch = EXIT_BLOCK_PTR;\n-  root->header = ENTRY_BLOCK_PTR;\n-  ENTRY_BLOCK_PTR->loop_father = root;\n-  EXIT_BLOCK_PTR->loop_father = root;\n-\n-  VEC_quick_push (loop_p, loops->larray, root);\n-  loops->tree_root = root;\n+  init_loops_structure (loops, num_loops + 1);\n \n   /* Find and record information about all the natural loops\n      in the CFG.  */"}]}