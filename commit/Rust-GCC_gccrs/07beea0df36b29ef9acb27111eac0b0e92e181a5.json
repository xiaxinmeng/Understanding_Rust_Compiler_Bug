{"sha": "07beea0df36b29ef9acb27111eac0b0e92e181a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiZWVhMGRmMzZiMjllZjlhY2IyNzExMWVhYzBiMGU5MmUxODFhNQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2006-12-05T17:26:05Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2006-12-05T17:26:05Z"}, "message": "Merge gimple-tuples-branch into mainline.\n\nFrom-SVN: r119546", "tree": {"sha": "32d3ee1ddfcad180d619d756a84eeb0df779a6a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32d3ee1ddfcad180d619d756a84eeb0df779a6a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07beea0df36b29ef9acb27111eac0b0e92e181a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07beea0df36b29ef9acb27111eac0b0e92e181a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07beea0df36b29ef9acb27111eac0b0e92e181a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07beea0df36b29ef9acb27111eac0b0e92e181a5/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3b8aab767b942e122caf583493d7cd858c091cde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8aab767b942e122caf583493d7cd858c091cde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8aab767b942e122caf583493d7cd858c091cde"}], "stats": {"total": 4131, "additions": 2750, "deletions": 1381}, "files": [{"sha": "5d432ceabc3cff717244d358e788e09a35a0bebf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 734, "deletions": 0, "changes": 734, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1,3 +1,737 @@\n+2006-12-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tMerge from gimple-tuples-branch.\n+\n+\t2006-12-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * config/s390/s390.c (s390_va_start): Replace MODIFY_EXPR with\n+        GIMPLE_MODIFY_STMT.\n+        (s390_gimplify_va_arg): Same.\n+        * config/sparc/sparc.c (sparc_gimplify_va_arg): Same.\n+        * config/sh/sh.c (sh_va_start): Same.\n+        (sh_gimplify_va_arg_expr): Same.\n+        * config/xtensa/xtensa.c (xtensa_va_start): Same.\n+        (xtensa_gimplify_va_arg_expr): Same.\n+        * config/ia64/ia64.c (ia64_gimplify_va_arg): Same.\n+        * config/pa/pa.c (hppa_gimplify_va_arg_expr): Same.\n+        * config/mips/mips.c (mips_va_start): Same.\n+        (mips_gimplify_va_arg_expr): Same.\n+\n+\t2006-12-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * Merge from mainline at revision 119445.\n+\n+\t2006-12-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * config/spu/spu.c (spu_va_start): Change MODIFY_EXPR to\n+        GIMPLE_MODIFY_STMT.\n+        (spu_gimplify_va_arg_expr): Same.\n+\n+\t2006-12-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * config/stormy16/stormy16.c (xstormy16_expand_builtin_va_start): \n+        Change uses of MODIFY_EXPR to GIMPLE_MODIFY_STMT.\n+        (xstormy16_expand_builtin_va_arg): Same.\n+\n+\t2006-12-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * config/frv/frv.c (frv_expand_builtin_va_start): Change MODIFY_EXPR\n+        to GIMPLE_MODIFY_STMT.\n+\n+\t2006-12-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * config/alpha/alpha.c (va_list_skip_additions): Change all\n+\toccurrences of MODIFY_EXPR to GIMPLE_MODIFY_STMT.\n+        (alpha_va_start): Same.\n+        (alpha_gimplify_va_arg_1): Same.\n+        (alpha_gimplify_va_arg): Same.\n+\n+\t2006-12-01  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gimplify.c (gimplify_modify_expr): Remove FIXME comment.\n+\n+\t2006-12-01  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree-ssa-loop-im.c: Rename all PROTECTED_TREE_OPERAND to\n+        GENERIC_TREE_OPERAND, and all PROTECTED_TREE_TYPE to\n+        GENERIC_TREE_TYPE.\n+        * tree-complex.c: Same.\n+        * tree-pretty-print.c: Same.\n+        * tree.c: Same.\n+        * tree.h: Same.\n+        * builtins.c: Same.\n+        * fold-const.c: Same.\n+        * tree-ssa-dom.c: Same.\n+        * tree-ssa-propagate.c: Same.\n+        * tree-ssa-alias.c: Same.\n+        * gimple-low.c: Same.\n+        * dwarf2out.c: Same.\n+        * c-pretty-print.c: Same.\n+        * gimplify.c: Same.\n+        * tree-inline.c: Same.\n+        * tree-outof-ssa.c: Same.\n+        * tree-ssa-structalias.c: Same.\n+        * tree-ssa-reassoc.c: Same.\n+        * stmt.c: Same.\n+\n+\t2006-11-16  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree.c (build2_stat): Fix comment.\n+\n+\t2006-11-13  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree-ssa-propagate.c (get_rhs): Use GIMPLE_MODIFY_STMT and\n+        TREE_OPERAND when appropriate.\n+\n+\t2006-11-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * java/java-tree.h (lang_tree_node): Handle gimple tuples.\n+        (EXPR_WFL_EMIT_LINE_NOTE): Look inside base.\n+        (EXPR_WFL_LINECOL): Use EXPR_LOCUS macro instead of exp.locus.\n+        * java/java-gimplify.c (java_gimplify_expr): Comment on why we do\n+        not handle GIMPLE_MODIFY_STMT in the switch statement.\n+        (java_gimplify_modify_expr): Call build2 with GIMPLE_MODIFY_STMT.\n+        (java_gimplify_new_array_init): Same.\n+\n+\t2006-11-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * gimplify.c (gimplify_omp_for): Allow gimple statements.\n+        * tree-outof-ssa.c (check_replaceable): Use PROTECTED_TREE_OPERAND.\n+        * fold-const.c (fold_binary): Allow gimple statements.\n+        (fold): Same.\n+        * fortran/trans-array.c (gfc_conv_descriptor_data_set_internal):\n+        Rename from gfc_conv_descriptor_data_set.\n+        Call gfc_add_modify instead of gfc_add_modify_expr.\n+        * fortran/trans-array.h (gfc_conv_descriptor_data_set_internal):\n+        Rename from gfc_conv_descriptor_data_set.\n+        (gfc_conv_descriptor_data_set): New macro.\n+        (gfc_conv_descriptor_data_set_tuples): New macros.\n+        * fortran/trans-openmp.c (gfc_omp_clause_default_ctor): Call\n+        gfc_conv_descriptor_data_set_tuples.\n+        * fortran/trans.c (gfc_add_modify): Rename from gfc_add_modify_expr.\n+        Generate GIMPLE_MODIFY_STMT when appropriate.\n+        * fortran/trans.h (gfc_add_modify): Rename from gfc_add_modify_expr.\n+        (gfc_add_modify_expr): New macro.\n+        (gfc_add_modify_stmt): New macro.\n+        * fortran/f95-lang.c (lang_tree_node): Handle gimple statements.\n+\n+\t2006-11-02  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* ada/ada-tree.h (lang_tree_node): Handle gimple tuples.\n+\t* ada/trans.c (gnat_gimplify_expr): Replace MODIFY_EXPR with\n+\tGIMPLE_MODIFY_STMT.\n+\n+\t2006-11-01  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Merge from mainline at revision 118200.\n+\n+\t2006-10-09  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-inline.c (copy_bb): Check for GIMPLE_MODIFY_STMT, and adjust\n+\taccordingly.\n+\n+\t2006-10-09  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree.h (TREE_CHAIN, TREE_TYPE): Add versions for non GCC or not\n+\tenable checking.\n+        Also, add __extension__ to GCC versions.\n+        * tree-mudflap.c (mf_xform_derefs_1): Add parentheses around TREE_TYPE.\n+        * tree-inline.c (copy_tree_r): Initialize chain to assuage the warning\n+\tpatrol.\n+\n+\t2006-10-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-complex.c (expand_complex_libcall): Adjust for\n+\tGIMPLE_MODIFY_STMT.\n+\t(expand_complex_comparison): Same.\n+\t* tree-pretty-print.c (dump_generic_node): Is_expr should include\n+\tGIMPLE_STMT_P statements.\n+\t* value-prof.c (tree_divmod_fixed_value_transform): Adjust for\n+\tGIMPLE_MODIFY_STMT.\n+\t(tree_mod_pow2_value_transform): Same.\n+\t(tree_mod_subtract_transform): Same.\n+\t* tree.c (build2_stat): Check for gimplified function in cfun.\n+\t* tree.h (DECL_GIMPLIFIED): Delete.\n+\t(struct tree_function_decl): Remove gimplified_flag.\n+\t* omp-low.c (lower_omp_for): Adjust for GIMPLE_MODIFY_STMT.\n+\t* cp/cp-gimplify.c (cp_gimplify_expr): Adjust for GIMPLE_MODIFY_STMT.\n+\t(cxx_omp_clause_apply_fn): Adjust for GIMPLE_MODIFY_STMT.\n+\t(cxx_omp_clause_copy_ctor): Same.\n+\t(cxx_omp_clause_assign_op): Same.\n+\t* c-pretty-print.c (pp_c_conditional_expression): Same.\n+\t(pp_c_expression): Same.\n+\t* langhooks.c (lhd_omp_predetermined_sharing): Same.\n+\t* function.h (struct function): Add gimplified field.\n+\t* tree-if-conv.c (add_to_dst_predicate_list): Adjust for\n+\tGIMPLE_MODIFY_STMT.\n+\t(find_phi_replacement_condition): Same.\n+\t* gimplify.c (gimplify_modify_expr_to_memcpy): Same.\n+\t(gimplify_modify_expr_to_memset): Same.\n+\t(gimplify_init_ctor_eval_range): Same.\n+\t(gimplify_modify_expr_complex_part): Same.\n+\t(tree_to_gimple_tuple): Same.\n+\t(gimplify_modify_expr): Same.\n+\t(gimple_push_cleanup): Same.\n+\t(gimplify_omp_for): Same.\n+\t(gimplify_omp_atomic_pipeline): Same.\n+\t(gimplify_omp_atomic_mutex): Same.\n+\t(gimplify_expr): Same.\n+\t(gimplify_one_sizepos): Same.\n+\t(gimplify_function_tree): Same.\n+\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): Same.\n+\t(vect_recog_widen_sum_pattern): Same.\n+\t* tree-vect-transform.c (get_initial_def_for_reduction): Same.\n+\t(vect_create_epilog_for_reduction): Same.\n+\t(vectorizable_reduction): Same.\n+\n+\t2006-09-28  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree-ssa-math-opts.c (replace_reciprocal): Use GIMPLE_STMT_OPERAND.\n+        * tree-if-conv.c (if_convertible_gimple_modify_stmt_p): Same.\n+        (ifc_temp_var): Same.\n+        * tree-vect-analyze.c (vect_determine_vectorization_factor): Check\n+\tfor gimple statements.\n+        (vect_analyze_operations): Same.\n+        (exist_non_indexing_operands_for_use_p): Use GIMPLE_STMT_OPERAND.\n+        * gimplify.c (gimplify_return_expr): Handle gimple statements.\n+        * lambda-code.c (can_put_in_inner_loop): Same.\n+        (can_put_after_inner_loop): Same.\n+        * tree-vect-transform.c (vect_create_addr_base_for_vector_ref): Same.\n+        (vect_create_data_ref_ptr): Same.\n+        (vect_init_vector): Same.\n+        (vect_get_vec_def_for_operand): Same.\n+        (vect_create_epilog_for_reduction): Same.\n+        (vectorizable_reduction): Same.\n+        (vectorizable_assignment): Same.\n+        (vectorizable_operation): Same.\n+        (vectorizable_load): Same.\n+        (vectorizable_condition): Same.\n+        * config/rs6000/rs6000.c (rs6000_va_start): Do not create MODIFY_EXPRs.\n+        (rs6000_gimplify_va_arg): Same.\n+\n+\t2006-09-25  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree-vrp.c (simplify_div_or_mod_using_ranges): Use\n+        GIMPLE_STMT_OPERAND.\n+        (simplify_abs_using_ranges): Same.\n+        * tree-complex.c (expand_complex_operations_1): Use\n+        PROTECTED_TREE_OPERAND.\n+        * tree-ssa-loop-niter.c (simplify_replace_tree): Check for gimple\n+        stmt.\n+        (get_val_for): Use GIMPLE_STMT_OPERAND.\n+        * tree-tailcall.c (adjust_accumulator_values): Same.\n+        (adjust_return_value): Same.\n+        * tree.c (walk_tree): Use IS_GIMPLE_STMT_CODE_CLASS on default\n+        case.  Remove special case for tcc_gimple_stmt.\n+        * tree.h (CAN_HAVE_LOCATION_P): New.\n+        * tree-ssa-loop-ivopts.c (expr_invariant_in_loop_p): Check for\n+        GIMPLE_STMT_P.\n+        * tree-stdarg.c (va_list_counter_bump): Use GIMPLE_STMT_OPERAND.\n+        * tree-ssa-dom.c (propagate_rhs_into_lhs): Same.\n+        * tree-nrv.c (execute_return_slot_opt): Same.\n+        * tree-ssa-alias.c (count_uses_and_derefs): Check for GIMPLE_STMT_P.\n+        * tree-vn.c (set_value_handle): Same.\n+        (get_value_handle): Same.\n+        * c-decl.c (add_stmt): Use CAN_HAVE_LOCATION_P.\n+        * tree-vectorizer.c (find_loop_location): Same.\n+        * c-typeck.c (c_process_expr_stmt): Same.\n+        (c_finish_stmt_expr): Same.\n+        * gimplify.c (should_carry_locus_p): Same.\n+        (tree_to_gimple_tuple): Delete definition and use of unecessary\n+        variable save_tree_block.\n+        * tree-ssa-pre.c (phi_translate): Check for GIMPLE_STMT_P.\n+        (create_expression_by_pieces): Use GIMPLE_STMT_OPERAND.\n+        (realify_fake_stores): Same.\n+        * tree-ssa-forwprop.c (forward_propagate_addr_into_variable_arr):\n+        Use TREE_OPERAND.\n+        * tree-inline.c (copy_body_r): Check for EXPR_P and GIMPLE_STMT_P.\n+        (copy_tree_r): Check for IS_GIMPLE_STMT_CODE_CLASS.\n+        * tree-cfg.c (move_stmt_r): Use EXPR_P.  Check for GIMPLE_STMT_P.\n+        * c-parser.c (c_parser_typeof_specifier): Use CAN_HAVE_LOCATION_P.\n+        (c_parser_statement_after_labels): Same.\n+        (c_parser_paren_condition): Same.\n+        (c_parser_for_statement): Same.\n+        (c_parser_omp_for_loop): Same.\n+        * tree-ssa-reassoc.c (linearize_expr): Use GIMPLE_STMT_OPERAND.\n+        (linearize_expr_tree): Same.\n+        * dwarf2out.c (reference_to_unused): Check for GIMPLE_STMT_P.\n+        * function.c (instantiate_expr): Same.\n+\n+\t2006-09-22  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree.c (expr_location): Use GIMPLE_STMT_LOCUS.\n+        (set_expr_location): Same.\n+        (expr_locus): Same.\n+        (set_expr_locus): Same.\n+        (expr_filename): Same.\n+        (expr_lineno): Same.\n+        (tree_block): Use GIMPLE_STMT_BLOCK.\n+        (protected_tree_operand): Use GIMPLE_STMT_OPERAND.\n+        * tree.h (struct gimple_stmt): Remove prev and next.\n+        (GIMPLE_STMT_OPERAND_CHECK): New.\n+        (TREE_TO_GIMPLE_STMT): Delete.\n+        (GIMPLE_STMT_TO_TREE): Delete.\n+        (GIMPLE_STMT_OPERAND): Use union, not cast.\n+        (GIMPLE_STMT_LOCUS): New.\n+        (GIMPLE_STMT_BLOCK): New.\n+        * gimplify.c (tree_to_gimple_tuple): Use union.  Do not cast\n+        to tree_base.\n+        * tree-cfg.c (verify_gimple_tuples_1): Call gcc_unreachable.\n+\n+\t2006-09-21  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree-into-ssa.c (REGISTER_DEFS_IN_STMT): Change common.base\n+        to base.\n+        * tree-tailcall.c (adjust_return_value): Same.\n+        * tree.c (tree_code_size): Remove GIMPLE_STATEMENT_LIST case.\n+        (copy_node_stat): Change common.base to base.\n+        (tree_node_structure): Return TS_GIMPLE_STATEMENT for tcc_gimple_stmt.\n+        Remove GIMPLE_STATEMENT_LIST case.\n+        * tree.h (struct gimple_stmt): Make operands of type tree.\n+        (TREE_CODE, TREE_SET_CODE, TREE_ADDRESSABLE, CALL_EXPR_TAILCALL,\n+        CASE_LOW_SEEN, TREE_STATIC, CLEANUP_EH_ONLY, CASE_HIGH_SEEN,\n+        TREE_NO_WARNING, TREE_CONSTANT_OVERFLOW, TREE_SYMBOL_REFERENCED,\n+        TYPE_REF_CAN_ALIAS_ALL, TREE_OVERFLOW, TREE_PUBLIC,\n+        TYPE_CACHED_VALUES_P, TREE_SIDE_EFFECTS, FORCED_LABEL,\n+        TREE_THIS_VOLATILE, TREE_THIS_NOTRAP, TREE_READONLY,\n+        TREE_CONSTANT, TYPE_SIZES_GIMPLIFIED, DECL_UNSIGNED,\n+        BIT_FIELD_REF_UNSIGNED, TYPE_UNSIGNED, TREE_ASM_WRITTEN, TREE_USED,\n+        TREE_NOTHROW, CALL_EXPR_RETURN_SLOT_OPT, DECL_BY_REFERENCE,\n+        CALL_FROM_THUNK_P, TYPE_ALIGN_OK, TREE_PRIVATE, TREE_PROTECTED,\n+        TREE_DEPRECATED, IDENTIFIER_TRANSPARENT_ALIAS, TREE_INVARIANT,\n+        TREE_LANG_FLAG_*, SSA_NAME_OCCURS_IN_ABNORMAL_PHI,\n+        SSA_NAME_IN_FREE_LIST, TYPE_VOLATILE, TYPE_READONLY, BINFO_VIRTUAL_P):\n+        Change common.base to base.\n+        (GIMPLE_STATEMENT_LIST*): Remove.\n+        (union tree_node): Add base.  Remove gimple_statement_list.\n+        Remove pointer from gstmt.\n+        * tree-ssa-propagate.c (set_rhs): Change common.base to base.\n+        * treestruct.def: Add TS_BASE.  Remove TS_GIMPLE_STATEMENT_LIST.\n+        * tree-vn.c (vn_compute): Change common.base to base.\n+        * tree-eh.c (verify_eh_throw_stmt_node): Same.\n+        * tree-flow-inline.h (var_ann): Same.\n+        (function_ann): Same.\n+        (stmt_ann): Same.\n+        (mark_non_addressable): Same.\n+        * gimplify.c (tree_to_gimple_tuple): Same.\n+        * tree.def (DEFTREECODE): Remove GIMPLE_STATEMENT_LIST.\n+        * tree-dfa.c (create_var_ann): Change common.base to base.\n+        (create_function_ann): Same.\n+        (create_stmt_ann): Same.\n+        (create_tree_ann): Same.\n+        (collect_dfa_stats_r): Same.\n+        * tree-ssa-pre.c (NECESSARY): Change common.base to base.\n+        * tree-ssa-dce.c (NECESSARY): Same.\n+        * tree-ssa.c (delete_tree_ssa): Same.\n+        * tree-optimize.c (execute_free_cfg_annotations): Same.\n+        * tree-flow.h: Same.\n+\n+\t2006-09-19  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * tree.c (tree_code_size): Handle GIMPLE_STATEMENT_LIST.\n+        (tree_node_structure): Handle GIMPLE_STATEMENT_LIST and\n+\tGIMPLE_MODIFY_STMT.\n+        * tree.h (struct gimple_stmt): Add prev and next fields.\n+\t(GIMPLE_STMT_TO_TREE): Cast, do not call GIMPLE_STMT_CHECK.\n+\t(GIMPLE_STATEMENT_LIST_HEAD): New.\n+\t(GIMPLE_STATEMENT_LIST_TAIL): New.\n+\t(struct gimple_statement_list): New.\n+\t(union tree_node): Add gimple_stmt_list and gstmt.\n+        * treestruct.def: Add TS_GIMPLE_STATEMENT_LIST, TS_GIMPLE_STATEMENT.\n+        * tree.def: Add GIMPLE_STATEMENT_LIST.\n+\n+\t2006-09-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-dump.c (dequeue_and_dump): Handle GIMPLE_MODIFY_STMT.\n+\t* tree-vrp.c (build_assert_expr_for): Change uses of\n+\tMODIFY_EXPR to GIMPLE_MODIFY_STMT and adjust accordingly.\n+\t(find_assert_locations): Same.\n+\t(remove_range_assertions): Same.\n+\t(stmt_interesting_for_vrp): Same.\n+\t(vrp_visit_assignment): Same.\n+\t(vrp_visit_stmt): Same.\n+\t(simplify_cond_using_ranges): Same.\n+\t* tree-into-ssa.c (REGISTER_DEFS_IN_THIS_STMT): Adjust for new\n+\ttree structure.\n+\t* tree-ssa-loop-im.c (movement_possibility): Change uses of\n+\tMODIFY_EXPR to GIMPLE_MODIFY_STMT and adjust accordingly.\n+\t(stmt_cost): Same.\n+\t(determine_invariantness_stmt): Same.\n+\t(schedule_sm): Same.\n+\t(gather_mem_refs_stmt): Same.\n+\t* tree-complex.c (init_dont_simulate_again): Same.\n+\t(complex_visit_stmt): Same.\n+\t(set_component_ssa_name): Same.\n+\t(expand_complex_move): Same.\n+\t(expand_complex_div_wide): Same.\n+\t(expand_complex_comparison): Same.\n+\t(expand_complex_operations_1): Same.\n+\t* tree-ssa-loop-niter.c (expand_simple_operations): Same.\n+\t(chain_of_csts_start): Same.\n+\t(infer_loop_bounds_from_undefined): Same.\n+\t* tree-pretty-print.c (dump_generic_node): Same.\n+\t(op_prio): Same.\n+\t(op_symbol_1): Same.\n+\t* tree-ssa-loop-manip.c (create_iv): Same.\n+\t* value-prof.c (tree_divmod_fixed_value): Same.\n+\t(tree_divmod_fixed_value_transform): Same.\n+\t(tree_mod_pow2): Same.\n+\t(tree_mod_pow2_value_transform): Same.\n+\t(tree_mod_subtract): Same.\n+\t(tree_mod_subtract_transform): Same.\n+\t(tree_divmod_values_to_profile): Same.\n+\t* tree-tailcall.c (process_assignment): Same.\n+\t(find_tail_calls): Same.\n+\t(adjust_accumulator_values): Same.\n+\t(adjust_return_value): Same.\n+\t(eliminate_tail_call): Same.\n+\t* tree.c (tree_code_size): Handle tcc_gimple_stmt.\n+\t(make_node_stat): Same.\n+\t(copy_node_stat): Handle gimple tuples.\n+\t(expr_align): Handle GIMPLE_MODIFY_STMT.  Abort on MODIFY_EXPR.\n+\t(tree_node_structure): Handle tcc_gimple_stmt.\n+\t(build2_stat): Abort on MODIFY_EXPR after gimplification.  Handle\n+\ttcc_gimple_stmt.\n+\t(build2_gimple_stat): New.\n+\t(expr_location): New.\n+\t(set_expr_location): New.\n+\t(expr_has_location): New.\n+\t(expr_locus): New.\n+\t(set_expr_locus): New.\n+\t(expr_filename): New.\n+\t(expr_lineno): New.\n+\t(walk_tree): Handle tcc_gimple_stmt.\n+\t(tree_block): New.\n+\t(protected_tree_operand): New.\n+\t(protected_tree_type): New.\n+\t(tree_code_kind): Add gimple statements.\n+\t* tree.h (tree_code_class): Add tcc_gimple_stmt.\n+\t(IS_GIMPLE_STMT_CODE_CLASS): New.\n+\t(struct tree_base): New.\n+\t(struct tree_common): Shrink.\n+\t(struct gimple_stmt): New.\n+\t(struct gimple_expr): New.\n+\t(TREE_SET_CODE, TREE_ADDRESSABLE, CALL_EXPR_TAILCALL,\n+\tCASE_LOW_SEEN, TREE_STATIC, CLEANUP_EH_ONLY, CASE_HIGH_SEEN,\n+\tTREE_NO_WARNING, TREE_CONSTANT_OVERFLOW, TREE_SYMBOL_REFERENCED,\n+\tTYPE_REF_CAN_ALIAS_ALL, TREE_OVERFLOW, TREE_PUBLIC,\n+\tTYPE_CACHED_VALUES_P, SAVE_EXPR_RESOLVED_P, TREE_SIDE_EFFECTS,\n+\tFORCED_LABEL, TREE_THIS_VOLATILE, TREE_THIS_NOTRAP, TREE_READONLY,\n+\tTREE_CONSTANT, TYPE_SIZES_GIMPLIFIED, DECL_UNSIGNED,\n+\tBIT_FIELD_REF_UNSIGNED, TYPE_UNSIGNED, TREE_ASM_WRITTEN,\n+\tTREE_USED, TREE_NOTHROW, CALL_EXPR_RETURN_SLOT_OPT,\n+\tDECL_BY_REFERENCE, CALL_FROM_THUNK_P, TYPE_ALIGN_OK,\n+\tTREE_PRIVATE, TREE_PROTECTED, TREE_DEPRECATED,\n+\tIDENTIFIER_TRANSPARENT_ALIAS, TREE_INVARIANT,\n+\tTREE_LANG_FLAG_[0-6], SSA_NAME_CHECK, SSA_NAME_IN_FREE_LIST,\n+\tTYPE_VOLATILE, TYPE_READONLY, TREE_VISITED, BINFO_VIRTUAL_P):\n+\tAdjust for new `common' layout.\n+\t(struct tree_function_decl): Add gimplified_flag.\n+\t(DECL_GIMPLIFIED): NEW.\n+\t(EXPR_LOCATION, SET_EXPR_LOCUS, EXPR_FILENAME, EXPR_LOCUS,\n+\tSET_EXPR_LOCUS, SET_EXPR_LOCATION, EXPR_LINENO,\n+\tEXPR_HAS_LOCATION): Call corresponding function.\n+\t(GIMPLE_STMT_CHECK): New.\n+\t(TREE_OPERAND_CHECK, TREE_TYPE, TREE_CHAIN): Abort on gimple tuples.\n+\t(TREE_BLOCK): Call tree_block.\n+\t(GIMPLE_STMT_P): New.\n+\t(GIMPLE_TUPLE_P): New.\n+\t(TREE_TO_GIMPLE_STMT): New.\n+\t(GIMPLE_STMT_TO_TREE): New.\n+\t(GIMPLE_STMT_OPERAND): New.\n+\t(GIMPLE_TUPLE_HAS_LOCUS_P): New.\n+\t(PROTECTED_TREE_OPERAND): New.\n+\t(PROTECTED_TREE_TYPE): New.\n+\t(build2_gimple_stat): Protoize.\n+\t(build2_gimple): New.\n+\t(expr_location): Protoize.\n+\t(set_expr_location): Protoize.\n+\t(expr_has_location): Protoize.\n+\t(expr_locus): Protoize.\n+\t(set_expr_locus): Protoize.\n+\t(expr_filename): Protoize.\n+\t(expr_lineno): Protoize.\n+\t(tree_block): Protoize.\n+\t(protected_tree_operand): Protoize.\n+\t(protected_tree_type): Protoize.\n+\t(enum tree_node_kind): Add gimple_stmt_kind.\n+\t* c-decl.c (union lang_tree_node): Tuples do not have a\n+\tTREE_CHAIN.\n+\t* ipa-cp.c (constant_val_insert): Change uses of MODIFY_EXPR to\n+\tGIMPLE_MODIFY_STMT and adjust accordingly.\n+\t* tree-scalar-evolution.c (follow_ssa_edge): Same.\n+\t(interpret_condition_phi): Same.\n+\t(pointer_used_p): Same.\n+\t(analyze_scalar_evolution_1): Same.\n+\t(scev_const_prop): Same.\n+\t(interpret_rhs_modify_stmt): Rename from\n+\tinterpret_rhs_modify_expr.\n+\t* builtins.c (std_expand_builtin_va_start): Change uses of\n+\tMODIFY_EXPR to GIMPLE_MODIFY_STMT and adjust accordingly.\n+\t(std_gimplify_va_arg_expr): Same.\n+\t(expand_builtin_va_copy): Same.\n+\t(integer_valued_real_p): Same.\n+\t* fold-const.c (maybe_lvalue_p): Same.\n+\t(fold_unary): Same.\n+\t(tree_expr_nonnegative_p): Same.\n+\t(tree_expr_nonzero_p): Same.\n+\t* omp-low.c (extract_omp_for_data): Same.\n+\t(lower_rec_input_clauses): Same.\n+\t(lower_reduction_clauses): Same.\n+\t(lower_copyprivate_clauses): Same.\n+\t(lower_send_clauses): Same.\n+\t(lower_send_shared_vars): Same.\n+\t(expand_parallel_call): Same.\n+\t(expand_omp_parallel): Same.\n+\t(expand_omp_for_generic): Same.\n+\t(expand_omp_for_static_nochunk): Same.\n+\t(expand_omp_for_static_chunk): Same.\n+\t(expand_omp_sections): Same.\n+\t(lower_omp_single_copy): Same.\n+\t(lower_omp_parallel): Same.\n+\t* tree-ssa-dse.c (memory_address_same): Same.\n+\t(dse_optimize_stmt): Same.\n+\t* ipa-reference.c (scan_for_static_refs): Same.\n+\t* tree-gimple.c (is_gimple_reg_rhs): Same.\n+\t(get_call_expr_in): Same.\n+\t(recalculate_side_effects): Same.\n+\t* cgraphunit.c (cgraph_create_edges): Same.\n+\t* tree-ssa-copyrename.c (rename_ssa_copies): Same.\n+\t* tree-ssa-ccp.c (get_default_value): Same.\n+\t(likely_value): Same.\n+\t(visit_assignment): Same.\n+\t(ccp_visit_stmt): Same.\n+\t(get_maxval_strlen): Same.\n+\t(ccp_fold_builtin): Same.\n+\t* tree-ssa-loop-ivopts.c (find_givs_in_stmt_scev): Same.\n+\t(find_givs_in_stmt): Same.\n+\t(find_interesting_uses_op): Same.\n+\t(find_interesting_uses_stmt): Same.\n+\t(rewrite_use_nonlinear_expr): Same.\n+\t* ipa-pure-const.c (scan_function): Same.\n+\t* tree-stdarg.c (va_list_counter_bump): Same.\n+\t(check_all_va_list_escapes): Same.\n+\t(execute_optimize_stdarg): Same.\n+\t* tree-ssa-math-opts.c (compute_merit): Same.\n+\t(insert_reciprocals): Same.\n+\t(execute_cse_reciprocals): Same.\n+\t* tree-ssa-dom.c (initialize_hash_element): Same.\n+\t(simple_iv_increment_p): Same.\n+\t(record_equivalences_from_stmt): Same.\n+\t(optimize_stmt): Same.\n+\t(remove_stmt_or_phi): Same.\n+\t(get_rhs_or_phi_arg): Same.\n+\t(get_lhs_or_phi_result): Same.\n+\t(propagate_rhs_into_lhs): Same.\n+\t* tree-nrv.c (tree_nrv): Same.\n+\t(execute_return_slot_opt): Same.\n+\t* tree-ssa-propagate.c (get_rhs): Same.\n+\t(set_rhs): Same.\n+\t(stmt_makes_single_load): Same.\n+\t(stmt_makes_single_store): Same.\n+\t(replace_vuses_in): Same.\n+\t(fold_predicate_in): Same.\n+\t(substitute_and_fold): Same.\n+\t* tree-ssa-alias.c (compute_call_clobbered): Same.\n+\t(recalculate_used_alone): Same.\n+\t(count_uses_and_derefs): Same.\n+\t(is_escape_site): Same.\n+\t(find_used_portions): Same.\n+\t* gimple-low.c (lower_stmt): Same.\n+\t(block_may_fallthru): Same.\n+\t(lower_return_expr): Same.\n+\t* tree-ssa-sink.c (is_hidden_global_store): Same.\n+\t(statement_sink_location): Same.\n+\t* dwarf2out.c (loc_descriptor_from_tree_1): Same.\n+\t* expr.c (safe_from_p): Same.\n+\t(expand_expr_real): Same.\n+\t(expand_expr_real_1): Same.\n+\t* tree-ssa-loop-ivcanon.c (empty_loop_p): Same.\n+\t* predict.c (expr_expected_value): Same.\n+\t(strip_builtin_expect): Same.\n+\t(apply_return_prediction): Same.\n+\t(tree_bb_level_predictions): Same.\n+\t(tree_estimate_probability): Same.\n+\t* tree-vn.c (vn_compute): Same.\n+\t* tree-eh.c (add_stmt_to_eh_region_fn): Same.\n+\t(remove_stmt_from_eh_region_fn): Same.\n+\t(do_return_redirection): Same.\n+\t(honor_protect_cleanup_actions): Same.\n+\t(lower_try_finally_switch): Same.\n+\t(lower_eh_constructs_1): Same.\n+\t(tree_could_throw_p): Same.\n+\t(verify_eh_throw_stmt_node): Same.\n+\t* function.c (gimplify_parameters): Same.\n+\t* tree-vectorizer.c (vect_is_simple_use): Same.\n+\t(vect_is_simple_reduction): Same.\n+\t* ipa-type-escape.c (scan_for_refs): Same.\n+\t* tree-if-conv.c (tree_if_conversion): Same.\n+\t(tree_if_convert_stmt): Same.\n+\t(if_convertible_gimplify_modify_stmt_p): Rename from\n+\tif_convertible_modify_expr_p.\n+\t(if_convertible_stmt_p): Adjust for GIMPLE_MODIFY_STMT.\n+\t(ifc_temp_var): Same.\n+\t(replace_phi_with_cond_modify_stmt): Rename from\n+\treplace_phi_with_cond_modify_expr.\n+\t(process_phi_nodes): Call replace_phi_with_cond_modify_stmt.\n+\t* tree.def (DEFTREECODE): Add GIMPLE_MODIFY_STMT.\n+\t* tree-data-ref.c (find_data_references_in_loop): Adjust for\n+\tGIMPLE_MODIFY_STMT.\n+\t* tree-flow-inline.h (var_ann): Same.\n+\t(function_ann): Same.\n+\t(stmt_ann): Same.\n+\t(mark_non_addressable): Same.\n+\t* tree-vect-analyze.c (vect_determine_vectorization_factor): Same.\n+\t* gimplify.c (tree_to_gimple_tuple): New.\n+\t(build_stack_save_restore): Adjust for GIMPLE_MODIFY_STMT.\n+\t(gimplify_return_expr): Same.\n+\t(gimplify_decl_expr): Same.\n+\t(gimplify_self_mod_expr): Same.\n+\t(gimplify_cond_expr): Same.\n+\t(gimplify_init_constructor): Same.\n+\t(gimplify_modify_expr): Same.\n+\t(gimplify_expr): Same.\n+\t(gimplify_function_tree): Same.\n+\t(force_gimple_operand): Same.\n+\t* tree-ssa-phiopt.c (conditional_replacement): Same.\n+\t(minmax_replacement): Same.\n+\t(abs_replacement): Same.\n+\t* tree-dfa.c (create_var_ann): Same.\n+\t(create_function_ann): Same.\n+\t(create_stmt_ann): Same.\n+\t(create_tree_ann): Same.\n+\t(collect_dfa_stats_r): Same.\n+\t* tree-ssa-pre.c (find_or_generate_expression): Same.\n+\t(create_expression_by_pieces): Same.\n+\t(try_look_through_load): Same.\n+\t(insert_fake_stores): Same.\n+\t(realify_fake_stores): Same.\n+\t(compute_avail): Same.\n+\t(eliminate): Same.\n+\t(init_pre): Same.\n+\t(poolify_modify_stmt): Rename from poolify_modify_stmt.\n+\tAdjust for GIMPLE_MODIFY_STMT.\n+\t(NECESSARY): Adjust for new `common' layout.\n+\t* tree-ssa-live.c (build_tree_conflict_graph): Adjust for\n+\tGIMPLE_MODIFY_STMT.\n+\t* tree-sra.c (sra_walk_modify_stmt): Rename from\n+\tsra_walk_modify_expr.\n+\t(sra_walk_function): Adjust for GIMPLE_MODIFY_STMT.\n+\t(generate_copy_inout): Same.\n+\t(generate_element_copy): Same.\n+\t(generate_element_zero): Same.\n+\t(scalarize_copy): Same.\n+\t* tree-mudflap.c (mf_decl_cache_locals): Same.\n+\t(mf_build_check_statement_for): Same.\n+\t(mf_xform_derefs): Same.\n+\t* ipa-prop.c (ipa_method_modify_stmt): Same.\n+\t* print-tree.c (print_node): Handle gimple tuples.\n+\tAdd case for tcc_gimple_stmt.\n+\t* tree-ssa-copy.c (stmt_may_generate_copy): Adjust for\n+\tGIMPLE_MODIFY_STMT.\n+\t(copy_prop_visit_assignment): Same.\n+\t(copy_prop_visit_stmt): Same.\n+\t(init_copy_prop): Same.\n+\t* tree-ssa-forwprop.c (ssa_name_defined_by_comparison_p): Same.\n+\t(forward_propagate_into_cond_1): Same.\n+\t(find_equivalent_equality_comparison): Same.\n+\t(tidy_after_forward_propagate_addr): Same.\n+\t(forward_propagate_addr_expr_1): Same.\n+\t(simplify_not_neg_expr): Same.\n+\t(simplify_switch_expr): Same.\n+\t* tree-ssa-dce.c (find_pdom): Same.\n+\t(mark_stmt_if_obviously_necessary): Same.\n+\t(NECESSARY): Adjust for new `common' layout.\n+\t* tree-flow.h: Same.\n+\t* tree-vect-patterns.c (widened_name_p): Adjust for\n+\tGIMPLE_MODIFY_STMT.\n+\t(vect_recog_dot_prod_pattern): Same.\n+\t(vect_recog_widen_sum_pattern): Same.\n+\t(vect_pattern_recog_1): Same.\n+\t* tree-nested.c (init_tmp_var): Same.\n+\t(save_tmp_var): Same.\n+\t(walk_stmts): Same.\n+\t(convert_call_expr): Same.\n+\t(finalize_nesting_tree_1): Same.\n+\t* tree-ssa.c (verify_ssa): Same.\n+\t(delete_tree_ssa): Same.\n+\t* lambda-code.c (lbv_to_gcc_expression): Same.\n+\t(lle_to_gcc_expression): Same.\n+\t(lambda_loopnest_to_gcc_loopnest): Same.\n+\t(can_put_in_inner_loop): Same.\n+\t(can_convert_to_perfect_nest): Same.\n+\t(perfect_nestify): Same.\n+\t* tree-ssa-loop-prefetch.c (gather_memory_references): Same.\n+\t* tree-inline.c (copy_body_r): Same.\n+\t(setup_one_parameter): Same.\n+\t(initialize_inlined_parameters): Same.\n+\t(estimate_num_insns_1): Same.\n+\t(expand_call_inline): Same.\n+\t(gimple_expand_calls_inline): Same.\n+\t(copy_tree_r): Same.\n+\t* tree-optimize.c (execute_free_cfg_annotations): Same.\n+\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref): Same.\n+\t(vect_align_data_ref): Same.\n+\t(vect_create_data_ref_ptr): Same.\n+\t(vect_init_vector): Same.\n+\t(vect_create_epilog_for_reduction): Same.\n+\t(vectorizable_reduction): Same.\n+\t(vectorizable_assignment): Same.\n+\t(vectorizable_operation): Same.\n+\t(vectorizable_store): Same.\n+\t(vectorizable_load): Same.\n+\t(vectorizable_live_operation): Same.\n+\t(vectorizable_condition): Same.\n+\t(vect_generate_tmps_on_preheader): Same.\n+\t(vect_create_cond_for_align_checks): Same.\n+\t* tree-object-size.c (collect_object_sizes_for): Same.\n+\t(check_for_plus_in_loops_1): Same.\n+\t(check_for_plus_in_loops): Same.\n+\t* tree-outof-ssa.c (insert_copy_on_edge): Same.\n+\t(replace_use_variable): Same.\n+\t(check_replaceable): Same.\n+\t(rewrite_trees): Same.\n+\t(identical_copies_p): Same.\n+\t(insert_backedge_copies): Same.\n+\t* tree-profile.c (tree_gen_edge_profiler): Same.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Same.\n+\t* tree-ssa-structalias.c (update_alias_info): Same.\n+\t(find_func_aliases): Same.\n+\t* tree-cfg.c (factor_computed_gotos): Same.\n+\t(make_edges): Same.\n+\t(make_goto_expr_edges): Same.\n+\t(tree_merge_blocks): Same.\n+\t(remove_useless_stmts_cond): Same.\n+\t(remove_useless_stmts_1): Same.\n+\t(tree_find_edge_insert_loc): Same.\n+\t(verify_expr): Same.\n+\t(gimplify_val): Same.\n+\t(verify_gimple_tuples_1): New.\n+\t(verify_gimple_tuples): New.\n+\t(verify_stmts): Call verify_gimple_tuples.\n+\t* tree-ssa-reassoc.c (get_rank): Adjust for GIMPLE_MODIFY_STMT.\n+\t(get_unary_op): Same.\n+\t(linearize_expr): Same.\n+\t(get_single_immediate_use): Same.\n+\t(negate_value): Same.\n+\t(should_break_up_subtract): Same.\n+\t(break_up_subtract): Same.\n+\t(repropagate_negates): Same.\n+\t(break_up_subtract_bb): Same.\n+\t(reassociate_bb): Same.\n+\t* config/i386/i386.c (ix86_va_start): Same.\n+\t(ix86_gimplify_va_arg): Same.\n+\t* stmt.c (expand_expr_stmt): Same.\n+\t(warn_if_unused_value): Same.\n+\t(expand_return): Same.\n+\t* tree-ssanames.c (make_ssa_name): Same.\n+\t* tree-ssa-threadedge.c (lhs_of_dominating_assert): Same.\n+\t* tree-ssa-operands.c (finalize_ssa_defs): Same.\n+\t(add_virtual_operand): Same.\n+\t(get_expr_operands): Same.\n+\t(parse_ssa_operands): Same.\n+\t(get_modify_stmt_operands): Rename from get_modify_expr_operands.\n+\n 2006-12-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config.host: Remove extra blank line."}, {"sha": "608f75e9df29c9ac66162e5a9393d5098f4eba9c", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -36,7 +36,8 @@ enum gnat_tree_code {\n /* Ada uses the lang_decl and lang_type fields to hold a tree.  */\n union lang_tree_node\n   GTY((desc (\"0\"),\n-       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.t)\")))\n+       chain_next (\"(GIMPLE_STMT_P (&%h.t) ? (union lang_tree_node *) 0 : (union lang_tree_node *)TREE_CHAIN (&%h.t))\")))\n+\n {\n   union tree_node GTY((tag (\"0\"))) t;\n };"}, {"sha": "b19f2f5f518be680088c80172a1f316eb9cefd47", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -4840,7 +4840,7 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n \t       && TREE_CODE_CLASS (TREE_CODE (op)) != tcc_constant)\n \t{\n \t  tree new_var = create_tmp_var (TREE_TYPE (op), \"A\");\n-\t  tree mod = build2 (MODIFY_EXPR, TREE_TYPE (op), new_var, op);\n+\t  tree mod = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (op), new_var, op);\n \n \t  TREE_ADDRESSABLE (new_var) = 1;\n "}, {"sha": "fa7ed0133ba034d8090e11249de688b80ece7c52", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -4319,7 +4319,7 @@ std_expand_builtin_va_start (tree valist, rtx nextarg)\n {\n   tree t;\n \n-  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist,\n \t      make_tree (ptr_type_node, nextarg));\n   TREE_SIDE_EFFECTS (t) = 1;\n \n@@ -4390,12 +4390,12 @@ std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       && !integer_zerop (TYPE_SIZE (type)))\n     {\n       t = fold_convert (TREE_TYPE (valist), size_int (boundary - 1));\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist_tmp,\n \t\t  build2 (PLUS_EXPR, TREE_TYPE (valist), valist_tmp, t));\n       gimplify_and_add (t, pre_p);\n \n       t = fold_convert (TREE_TYPE (valist), size_int (-boundary));\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist_tmp,\n \t\t  build2 (BIT_AND_EXPR, TREE_TYPE (valist), valist_tmp, t));\n       gimplify_and_add (t, pre_p);\n     }\n@@ -4434,7 +4434,7 @@ std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n   /* Compute new value for AP.  */\n   t = fold_convert (TREE_TYPE (valist), rounded_size);\n   t = build2 (PLUS_EXPR, TREE_TYPE (valist), valist_tmp, t);\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist, t);\n   gimplify_and_add (t, pre_p);\n \n   addr = fold_convert (build_pointer_type (type), addr);\n@@ -4599,7 +4599,7 @@ expand_builtin_va_copy (tree arglist)\n \n   if (TREE_CODE (va_list_type_node) != ARRAY_TYPE)\n     {\n-      t = build2 (MODIFY_EXPR, va_list_type_node, dst, src);\n+      t = build2 (GIMPLE_MODIFY_STMT, va_list_type_node, dst, src);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -6738,9 +6738,9 @@ integer_valued_real_p (tree t)\n       return integer_valued_real_p (TREE_OPERAND (t, 0));\n \n     case COMPOUND_EXPR:\n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n     case BIND_EXPR:\n-      return integer_valued_real_p (TREE_OPERAND (t, 1));\n+      return integer_valued_real_p (GENERIC_TREE_OPERAND (t, 1));\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -8096,7 +8096,7 @@ fold_builtin_memset (tree arglist, tree type, bool ignore)\n     }\n \n   ret = build_int_cst_type (TREE_TYPE (var), cval);\n-  ret = build2 (MODIFY_EXPR, TREE_TYPE (var), var, ret);\n+  ret = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), var, ret);\n   if (ignore)\n     return ret;\n \n@@ -8251,7 +8251,7 @@ fold_builtin_memory_op (tree arglist, tree type, bool ignore, int endp)\n \texpr = fold_convert (TREE_TYPE (destvar), srcvar);\n       else\n \texpr = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (destvar), srcvar);\n-      expr = build2 (MODIFY_EXPR, TREE_TYPE (destvar), destvar, expr);\n+      expr = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (destvar), destvar, expr);\n     }\n \n   if (ignore)\n@@ -9474,7 +9474,7 @@ fold_builtin (tree fndecl, tree arglist, bool ignore)\n   tree exp = fold_builtin_1 (fndecl, arglist, ignore);\n   if (exp && !ignore)\n     {\n-      exp = build1 (NOP_EXPR, TREE_TYPE (exp), exp);\n+      exp = build1 (NOP_EXPR, GENERIC_TREE_TYPE (exp), exp);\n       TREE_NO_WARNING (exp) = 1;\n     }\n \n@@ -11704,9 +11704,11 @@ do_mpfr_sincos (tree arg, tree arg_sinp, tree arg_cosp)\n \t\t  && TYPE_MAIN_VARIANT (TREE_TYPE (arg_cosp)) == TYPE_MAIN_VARIANT (type))\n \t        {\n \t\t  /* Set the values. */\n-\t\t  result_s = fold_build2 (MODIFY_EXPR, type, arg_sinp, result_s);\n+\t\t  result_s = fold_build2 (GIMPLE_MODIFY_STMT, type, arg_sinp,\n+\t\t      \t\t\t  result_s);\n \t\t  TREE_SIDE_EFFECTS (result_s) = 1;\n-\t\t  result_c = fold_build2 (MODIFY_EXPR, type, arg_cosp, result_c);\n+\t\t  result_c = fold_build2 (GIMPLE_MODIFY_STMT, type, arg_cosp,\n+\t\t      \t\t\t  result_c);\n \t\t  TREE_SIDE_EFFECTS (result_c) = 1;\n \t\t  /* Combine the assignments into a compound expr.  */\n \t\t  result = non_lvalue (fold_build2 (COMPOUND_EXPR, type,"}, {"sha": "c95f495398546e909a388a66be743c2e3e097523", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -256,7 +256,7 @@ extern char C_SIZEOF_STRUCT_LANG_IDENTIFIER_isnt_accurate\n \n union lang_tree_node\n   GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-       chain_next (\"TREE_CODE (&%h.generic) == INTEGER_TYPE ? (union lang_tree_node *) TYPE_NEXT_VARIANT (&%h.generic) : (union lang_tree_node *) TREE_CHAIN (&%h.generic)\")))\n+       chain_next (\"TREE_CODE (&%h.generic) == INTEGER_TYPE ? (union lang_tree_node *) TYPE_NEXT_VARIANT (&%h.generic) : (GIMPLE_TUPLE_P (&%h.generic) ? (union lang_tree_node *) 0 : (union lang_tree_node *) TREE_CHAIN (&%h.generic))\")))\n {\n   union tree_node GTY ((tag (\"0\"),\n \t\t\tdesc (\"tree_node_structure (&%h)\")))\n@@ -434,7 +434,7 @@ add_stmt (tree t)\n {\n   enum tree_code code = TREE_CODE (t);\n \n-  if (EXPR_P (t) && code != LABEL_EXPR)\n+  if (CAN_HAVE_LOCATION_P (t) && code != LABEL_EXPR)\n     {\n       if (!EXPR_HAS_LOCATION (t))\n \tSET_EXPR_LOCATION (t, input_location);"}, {"sha": "a54674ff01dad4c2a47b7a2125d039bb4328dc46", "filename": "gcc/c-parser.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -2172,7 +2172,7 @@ c_parser_typeof_specifier (c_parser *parser)\n \t  if (DECL_P (e) || CONSTANT_CLASS_P (e))\n \t    e = build1 (NOP_EXPR, void_type_node, e);\n \n-\t  if (EXPR_P (e))\n+\t  if (CAN_HAVE_LOCATION_P (e))\n \t    SET_EXPR_LOCATION (e, input_location);\n \n \t  add_stmt (e);\n@@ -3817,7 +3817,7 @@ c_parser_statement_after_labels (c_parser *parser)\n      (recursively) all of the component statements should already have\n      line numbers assigned.  ??? Can we discard no-op statements\n      earlier?  */\n-  if (stmt && EXPR_P (stmt))\n+  if (stmt && CAN_HAVE_LOCATION_P (stmt))\n     SET_EXPR_LOCATION (stmt, loc);\n }\n \n@@ -3836,7 +3836,7 @@ c_parser_paren_condition (c_parser *parser)\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_objc_common_truthvalue_conversion\n     (c_parser_expression_conv (parser).value);\n-  if (EXPR_P (cond))\n+  if (CAN_HAVE_LOCATION_P (cond))\n     SET_EXPR_LOCATION (cond, loc);\n   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n   return cond;\n@@ -4073,7 +4073,7 @@ c_parser_for_statement (c_parser *parser)\n \t{\n \t  tree ocond = c_parser_expression_conv (parser).value;\n \t  cond = c_objc_common_truthvalue_conversion (ocond);\n-\t  if (EXPR_P (cond))\n+\t  if (CAN_HAVE_LOCATION_P (cond))\n \t    SET_EXPR_LOCATION (cond, loc);\n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \t}\n@@ -7424,7 +7424,7 @@ c_parser_omp_for_loop (c_parser *parser)\n     {\n       cond = c_parser_expression_conv (parser).value;\n       cond = c_objc_common_truthvalue_conversion (cond);\n-      if (EXPR_P (cond))\n+      if (CAN_HAVE_LOCATION_P (cond))\n \tSET_EXPR_LOCATION (cond, input_location);\n     }\n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");"}, {"sha": "56b2b47a56960f235b213eeb9385b0fdfdb7fa66", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1795,13 +1795,15 @@ pp_c_conditional_expression (c_pretty_printer *pp, tree e)\n static void\n pp_c_assignment_expression (c_pretty_printer *pp, tree e)\n {\n-  if (TREE_CODE (e) == MODIFY_EXPR || TREE_CODE (e) == INIT_EXPR)\n+  if (TREE_CODE (e) == MODIFY_EXPR \n+      || TREE_CODE (e) == GIMPLE_MODIFY_STMT\n+      || TREE_CODE (e) == INIT_EXPR)\n     {\n-      pp_c_unary_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_unary_expression (pp, GENERIC_TREE_OPERAND (e, 0));\n       pp_c_whitespace (pp);\n       pp_equal (pp);\n       pp_space (pp);\n-      pp_c_expression (pp, TREE_OPERAND (e, 1));\n+      pp_c_expression (pp, GENERIC_TREE_OPERAND (e, 1));\n     }\n   else\n     pp_c_conditional_expression (pp, e);\n@@ -1942,6 +1944,7 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n     case INIT_EXPR:\n       pp_assignment_expression (pp, e);\n       break;"}, {"sha": "ec145334afaa754df16a20574c5eca6097766e0a", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -7450,7 +7450,7 @@ c_process_expr_stmt (tree expr)\n   if (DECL_P (expr) || CONSTANT_CLASS_P (expr))\n     expr = build1 (NOP_EXPR, TREE_TYPE (expr), expr);\n \n-  if (EXPR_P (expr))\n+  if (CAN_HAVE_LOCATION_P (expr))\n     SET_EXPR_LOCATION (expr, input_location);\n \n   return expr;\n@@ -7587,7 +7587,7 @@ c_finish_stmt_expr (tree body)\n     {\n       /* Do not warn if the return value of a statement expression is\n \t unused.  */\n-      if (EXPR_P (last))\n+      if (CAN_HAVE_LOCATION_P (last))\n \tTREE_NO_WARNING (last) = 1;\n       return last;\n     }"}, {"sha": "240ac85bd22ec25eb31bdaf2cc02d94f2fb9f403", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -591,8 +591,8 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n \t\t\t\tbb->loop_depth);\n \t    walk_tree (&TREE_OPERAND (call, 1),\n \t\t       record_reference, node, visited_nodes);\n-\t    if (TREE_CODE (stmt) == MODIFY_EXPR)\n-\t      walk_tree (&TREE_OPERAND (stmt, 0),\n+\t    if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+\t      walk_tree (&GIMPLE_STMT_OPERAND (stmt, 0),\n \t\t\t record_reference, node, visited_nodes);\n \t  }\n \telse"}, {"sha": "cf19dc0ed328ced8e9e2cf5932a6c667906e12b8", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -5921,11 +5921,11 @@ va_list_skip_additions (tree lhs)\n       if (TREE_CODE (stmt) == PHI_NODE)\n \treturn stmt;\n \n-      if (TREE_CODE (stmt) != MODIFY_EXPR\n-\t  || TREE_OPERAND (stmt, 0) != lhs)\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n+\t  || GIMPLE_STMT_OPERAND (stmt, 0) != lhs)\n \treturn lhs;\n \n-      rhs = TREE_OPERAND (stmt, 1);\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n       if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n \trhs = TREE_OPERAND (rhs, 0);\n \n@@ -6184,7 +6184,7 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n     {\n       nextarg = plus_constant (nextarg, offset);\n       nextarg = plus_constant (nextarg, NUM_ARGS * UNITS_PER_WORD);\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist,\n \t\t  make_tree (ptr_type_node, nextarg));\n       TREE_SIDE_EFFECTS (t) = 1;\n \n@@ -6203,12 +6203,13 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       t = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n       t = build2 (PLUS_EXPR, ptr_type_node, t,\n \t\t  build_int_cst (NULL_TREE, offset));\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (base_field), base_field, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (base_field), base_field, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       t = build_int_cst (NULL_TREE, NUM_ARGS * UNITS_PER_WORD);\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (offset_field), offset_field, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (offset_field),\n+\t  \t  offset_field, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -6224,7 +6225,7 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n   if (targetm.calls.must_pass_in_stack (TYPE_MODE (type), type))\n     {\n       t = build_int_cst (TREE_TYPE (offset), 6*8);\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (offset), offset,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (offset), offset,\n \t\t  build2 (MAX_EXPR, TREE_TYPE (offset), offset, t));\n       gimplify_and_add (t, pre_p);\n     }\n@@ -6278,7 +6279,7 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n       t = size_binop (MULT_EXPR, t, size_int (8));\n     }\n   t = fold_convert (TREE_TYPE (offset), t);\n-  t = build2 (MODIFY_EXPR, void_type_node, offset,\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, offset,\n \t      build2 (PLUS_EXPR, TREE_TYPE (offset), offset, t));\n   gimplify_and_add (t, pre_p);\n \n@@ -6318,7 +6319,7 @@ alpha_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   r = alpha_gimplify_va_arg_1 (type, base, offset, pre_p);\n \n   /* Stuff the offset temporary back into its field.  */\n-  t = build2 (MODIFY_EXPR, void_type_node, offset_field,\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, offset_field,\n \t      fold_convert (TREE_TYPE (offset_field), offset));\n   gimplify_and_add (t, pre_p);\n "}, {"sha": "942f3c688ede12493929f778f4f5e2e1a6645504", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -2203,7 +2203,7 @@ frv_expand_builtin_va_start (tree valist, rtx nextarg)\n       debug_rtx (nextarg);\n     }\n \n-  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist,\n \t      make_tree (ptr_type_node, nextarg));\n   TREE_SIDE_EFFECTS (t) = 1;\n "}, {"sha": "dd715b4ac1c276fb3664c58d9058b18b7f81c7b3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -4522,7 +4522,7 @@ ix86_va_start (tree valist, rtx nextarg)\n   if (cfun->va_list_gpr_size)\n     {\n       type = TREE_TYPE (gpr);\n-      t = build2 (MODIFY_EXPR, type, gpr,\n+      t = build2 (GIMPLE_MODIFY_STMT, type, gpr,\n \t\t  build_int_cst (type, n_gpr * 8));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -4531,7 +4531,7 @@ ix86_va_start (tree valist, rtx nextarg)\n   if (cfun->va_list_fpr_size)\n     {\n       type = TREE_TYPE (fpr);\n-      t = build2 (MODIFY_EXPR, type, fpr,\n+      t = build2 (GIMPLE_MODIFY_STMT, type, fpr,\n \t\t  build_int_cst (type, n_fpr * 16 + 8*REGPARM_MAX));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -4543,7 +4543,7 @@ ix86_va_start (tree valist, rtx nextarg)\n   if (words != 0)\n     t = build2 (PLUS_EXPR, type, t,\n \t        build_int_cst (type, words * UNITS_PER_WORD));\n-  t = build2 (MODIFY_EXPR, type, ovf, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, type, ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -4553,7 +4553,7 @@ ix86_va_start (tree valist, rtx nextarg)\n \t Prologue of the function save it right above stack frame.  */\n       type = TREE_TYPE (sav);\n       t = make_tree (type, frame_pointer_rtx);\n-      t = build2 (MODIFY_EXPR, type, sav, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, type, sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -4690,15 +4690,15 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t  /* int_addr = gpr + sav; */\n \t  t = fold_convert (ptr_type_node, gpr);\n \t  t = build2 (PLUS_EXPR, ptr_type_node, sav, t);\n-\t  t = build2 (MODIFY_EXPR, void_type_node, int_addr, t);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, int_addr, t);\n \t  gimplify_and_add (t, pre_p);\n \t}\n       if (needed_sseregs)\n \t{\n \t  /* sse_addr = fpr + sav; */\n \t  t = fold_convert (ptr_type_node, fpr);\n \t  t = build2 (PLUS_EXPR, ptr_type_node, sav, t);\n-\t  t = build2 (MODIFY_EXPR, void_type_node, sse_addr, t);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, sse_addr, t);\n \t  gimplify_and_add (t, pre_p);\n \t}\n       if (need_temp)\n@@ -4708,7 +4708,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \n \t  /* addr = &temp; */\n \t  t = build1 (ADDR_EXPR, build_pointer_type (type), temp);\n-\t  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n \t  gimplify_and_add (t, pre_p);\n \n \t  for (i = 0; i < XVECLEN (container, 0); i++)\n@@ -4742,7 +4742,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t\t\t\t\tsize_int (INTVAL (XEXP (slot, 1)))));\n \t      dest = build_va_arg_indirect_ref (dest_addr);\n \n-\t      t = build2 (MODIFY_EXPR, void_type_node, dest, src);\n+\t      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, dest, src);\n \t      gimplify_and_add (t, pre_p);\n \t    }\n \t}\n@@ -4751,14 +4751,14 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t{\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n \t\t      build_int_cst (TREE_TYPE (gpr), needed_intregs * 8));\n-\t  t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (gpr), gpr, t);\n \t  gimplify_and_add (t, pre_p);\n \t}\n       if (needed_sseregs)\n \t{\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (fpr), fpr,\n \t\t      build_int_cst (TREE_TYPE (fpr), needed_sseregs * 16));\n-\t  t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr, t);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (fpr), fpr, t);\n \t  gimplify_and_add (t, pre_p);\n \t}\n \n@@ -4785,12 +4785,12 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n-  t2 = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+  t2 = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (t2, pre_p);\n \n   t = build2 (PLUS_EXPR, TREE_TYPE (t), t,\n \t      build_int_cst (TREE_TYPE (t), rsize * UNITS_PER_WORD));\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n   gimplify_and_add (t, pre_p);\n \n   if (container)"}, {"sha": "8915a024ea5a14bcc8824ca5cd9ee36e2ddf06a8", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -4324,7 +4324,7 @@ ia64_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t\t       build_int_cst (NULL_TREE, 2 * UNITS_PER_WORD - 1));\n       t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n \t\t  build_int_cst (NULL_TREE, -2 * UNITS_PER_WORD));\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist, t);\n       gimplify_and_add (t, pre_p);\n     }\n "}, {"sha": "9b4746fe28ea940990a9599ec369dada9c375fef", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -4278,12 +4278,12 @@ mips_va_start (tree valist, rtx nextarg)\n \tt = build2 (PLUS_EXPR, TREE_TYPE (ovfl), t,\n \t\t    build_int_cst (NULL_TREE,\n \t\t\t\t   cum->stack_words * UNITS_PER_WORD));\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovfl), ovfl, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize GTOP, the top of the GPR save area.  */\n       t = make_tree (TREE_TYPE (gtop), virtual_incoming_args_rtx);\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (gtop), gtop, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (gtop), gtop, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize FTOP, the top of the FPR save area.\n@@ -4295,18 +4295,18 @@ mips_va_start (tree valist, rtx nextarg)\n       if (fpr_offset)\n \tt = build2 (PLUS_EXPR, TREE_TYPE (ftop), t,\n \t\t    build_int_cst (NULL_TREE, -fpr_offset));\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (ftop), ftop, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ftop), ftop, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize GOFF, the offset from GTOP of the\n \t next GPR argument.  */\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (goff), goff,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (goff), goff,\n \t\t  build_int_cst (NULL_TREE, gpr_save_area_size));\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Likewise emit code to initialize FOFF, the offset from FTOP\n \t of the next FPR argument.  */\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (foff), foff,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (foff), foff,\n \t\t  build_int_cst (NULL_TREE, fpr_save_area_size));\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -4427,7 +4427,7 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t      /* [1] Emit code for: off &= -rsize.\t*/\n \t      t = build2 (BIT_AND_EXPR, TREE_TYPE (off), off,\n \t\t\t  build_int_cst (NULL_TREE, -rsize));\n-\t      t = build2 (MODIFY_EXPR, TREE_TYPE (off), off, t);\n+\t      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (off), off, t);\n \t      gimplify_and_add (t, pre_p);\n \t    }\n \t  osize = rsize;\n@@ -4466,7 +4466,7 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t  u = fold_convert (TREE_TYPE (ovfl),\n \t\t\t    build_int_cst (NULL_TREE, -osize));\n \t  t = build2 (BIT_AND_EXPR, TREE_TYPE (ovfl), t, u);\n-\t  align = build2 (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+\t  align = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovfl), ovfl, t);\n \t}\n       else\n \talign = NULL;"}, {"sha": "26ada7e0600089cd355a55e47f25c8cf544e4348", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -5891,7 +5891,7 @@ hppa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       u = build_int_cst (valist_type, (size > 4 ? -8 : -4));\n       t = build2 (BIT_AND_EXPR, valist_type, t, u);\n \n-      t = build2 (MODIFY_EXPR, valist_type, valist, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, valist_type, valist, t);\n \n       ofs = (8 - size) % 4;\n       if (ofs != 0)"}, {"sha": "08b3d01a50e1066ea9c6fdf4fc342880f1bec607", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -6013,15 +6013,15 @@ rs6000_va_start (tree valist, rtx nextarg)\n \n   if (cfun->va_list_gpr_size)\n     {\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (gpr), gpr,\n \t\t  build_int_cst (NULL_TREE, n_gpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (cfun->va_list_fpr_size)\n     {\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (fpr), fpr,\n \t\t  build_int_cst (NULL_TREE, n_fpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6032,7 +6032,7 @@ rs6000_va_start (tree valist, rtx nextarg)\n   if (words != 0)\n     t = build2 (PLUS_EXPR, TREE_TYPE (ovf), t,\n \t        build_int_cst (NULL_TREE, words * UNITS_PER_WORD));\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -6049,7 +6049,7 @@ rs6000_va_start (tree valist, rtx nextarg)\n   if (cfun->machine->varargs_save_offset)\n     t = build2 (PLUS_EXPR, TREE_TYPE (sav), t,\n \t        build_int_cst (NULL_TREE, cfun->machine->varargs_save_offset));\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (sav), sav, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -6182,7 +6182,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       u = build2 (MULT_EXPR, integer_type_node, u, size_int (sav_scale));\n       t = build2 (PLUS_EXPR, ptr_type_node, t, u);\n \n-      t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n       gimplify_and_add (t, pre_p);\n \n       t = build1 (GOTO_EXPR, void_type_node, lab_over);\n@@ -6195,7 +6195,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t{\n \t  /* Ensure that we don't find any more args in regs.\n \t     Alignment has taken care of the n_reg == 2 gpr case.  */\n-\t  t = build2 (MODIFY_EXPR, TREE_TYPE (reg), reg, size_int (8));\n+\t  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (reg), reg, size_int (8));\n \t  gimplify_and_add (t, pre_p);\n \t}\n     }\n@@ -6212,11 +6212,11 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n-  u = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+  u = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (u, pre_p);\n \n   t = build2 (PLUS_EXPR, TREE_TYPE (t), t, size_int (size));\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n   gimplify_and_add (t, pre_p);\n \n   if (lab_over)"}, {"sha": "af449f8f92814ac298ed07e4725e18601471b839", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -7931,15 +7931,15 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   if (cfun->va_list_gpr_size)\n     {\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (gpr), gpr,\n \t          build_int_cst (NULL_TREE, n_gpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (cfun->va_list_fpr_size)\n     {\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (fpr), fpr,\n \t          build_int_cst (NULL_TREE, n_fpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -7959,7 +7959,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n       t = build2 (PLUS_EXPR, TREE_TYPE (ovf), t, build_int_cst (NULL_TREE, off));\n \n-      t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -7972,7 +7972,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       t = build2 (PLUS_EXPR, TREE_TYPE (sav), t,\n \t          build_int_cst (NULL_TREE, -RETURN_REGNUM * UNITS_PER_WORD));\n   \n-      t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (sav), sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -8105,7 +8105,7 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n \t      fold_convert (TREE_TYPE (reg), size_int (sav_scale)));\n   t = build2 (PLUS_EXPR, ptr_type_node, t, fold_convert (ptr_type_node, u));\n \n-  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build1 (GOTO_EXPR, void_type_node, lab_over);\n@@ -8124,12 +8124,12 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n \n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n-  u = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+  u = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (u, pre_p);\n \n   t = build2 (PLUS_EXPR, ptr_type_node, t, \n \t      fold_convert (ptr_type_node, size_int (size)));\n-  t = build2 (MODIFY_EXPR, ptr_type_node, ovf, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, ovf, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build1 (LABEL_EXPR, void_type_node, lab_over);"}, {"sha": "f9de2a68d77dbe5b0ecd12a3a8326b80a8c40470", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -7117,7 +7117,7 @@ sh_va_start (tree valist, rtx nextarg)\n \n   /* Call __builtin_saveregs.  */\n   u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n-  t = build2 (MODIFY_EXPR, ptr_type_node, next_fp, u);\n+  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -7128,11 +7128,11 @@ sh_va_start (tree valist, rtx nextarg)\n     nfp = 0;\n   u = fold_build2 (PLUS_EXPR, ptr_type_node, u,\n \t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nfp));\n-  t = build2 (MODIFY_EXPR, ptr_type_node, next_fp_limit, u);\n+  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build2 (MODIFY_EXPR, ptr_type_node, next_o, u);\n+  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_o, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -7143,12 +7143,12 @@ sh_va_start (tree valist, rtx nextarg)\n     nint = 0;\n   u = fold_build2 (PLUS_EXPR, ptr_type_node, u,\n \t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nint));\n-  t = build2 (MODIFY_EXPR, ptr_type_node, next_o_limit, u);\n+  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_o_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   u = make_tree (ptr_type_node, nextarg);\n-  t = build2 (MODIFY_EXPR, ptr_type_node, next_stack, u);\n+  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_stack, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -7268,10 +7268,10 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  bool is_double = size == 8 && TREE_CODE (eff_type) == REAL_TYPE;\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_fp);\n-\t  tmp = build2 (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, tmp);\n \t  gimplify_and_add (tmp, pre_p);\n \n-\t  tmp = build2 (MODIFY_EXPR, ptr_type_node, next_fp_tmp, valist);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp_tmp, valist);\n \t  gimplify_and_add (tmp, pre_p);\n \t  tmp = next_fp_limit;\n \t  if (size > 4 && !is_double)\n@@ -7290,7 +7290,8 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t      tmp = fold_convert (ptr_type_node, size_int (UNITS_PER_WORD));\n \t      tmp = build2 (BIT_AND_EXPR, ptr_type_node, next_fp_tmp, tmp);\n \t      tmp = build2 (PLUS_EXPR, ptr_type_node, next_fp_tmp, tmp);\n-\t      tmp = build2 (MODIFY_EXPR, ptr_type_node, next_fp_tmp, tmp);\n+\t      tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node,\n+\t\t  \t    next_fp_tmp, tmp);\n \t      gimplify_and_add (tmp, pre_p);\n \t    }\n \t  if (is_double)\n@@ -7323,12 +7324,12 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n-\t  tmp = build2 (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, tmp);\n \t  gimplify_and_add (tmp, pre_p);\n-\t  tmp = build2 (MODIFY_EXPR, ptr_type_node, next_fp_tmp, valist);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp_tmp, valist);\n \t  gimplify_and_add (tmp, pre_p);\n \n-\t  tmp = build2 (MODIFY_EXPR, ptr_type_node, valist, next_fp_tmp);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, valist, next_fp_tmp);\n \t  gimplify_and_add (tmp, post_p);\n \t  valist = next_fp_tmp;\n \t}\n@@ -7343,7 +7344,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_o);\n-\t  tmp = build2 (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, tmp);\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (GOTO_EXPR, void_type_node, lab_over);\n@@ -7354,12 +7355,13 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \n \t  if (size > 4 && ! TARGET_SH4)\n \t    {\n-\t      tmp = build2 (MODIFY_EXPR, ptr_type_node, next_o, next_o_limit);\n+\t      tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node,\n+\t\t  \t    next_o, next_o_limit);\n \t      gimplify_and_add (tmp, pre_p);\n \t    }\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n-\t  tmp = build2 (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, tmp);\n \t  gimplify_and_add (tmp, pre_p);\n \t}\n \n@@ -7376,7 +7378,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n   tmp = std_gimplify_va_arg_expr (valist, type, pre_p, NULL);\n   if (result)\n     {\n-      tmp = build2 (MODIFY_EXPR, void_type_node, result, tmp);\n+      tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, result, tmp);\n       gimplify_and_add (tmp, pre_p);\n \n       tmp = build1 (LABEL_EXPR, void_type_node, lab_over);"}, {"sha": "75c7de729e686e348504c1cedd0e7839ac6a3026", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -5716,7 +5716,7 @@ sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n     addr = fold_convert (ptrtype, addr);\n \n   incr = fold (build2 (PLUS_EXPR, ptr_type_node, incr, ssize_int (rsize)));\n-  incr = build2 (MODIFY_EXPR, ptr_type_node, valist, incr);\n+  incr = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, valist, incr);\n   gimplify_and_add (incr, post_p);\n \n   return build_va_arg_indirect_ref (addr);"}, {"sha": "4aa8e38be9293746773dfddfcfc5307b0bee25d9", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -2801,7 +2801,7 @@ spu_va_start (tree valist, rtx nextarg)\n   if (current_function_pretend_args_size > 0)\n     t = build2 (PLUS_EXPR, TREE_TYPE (args), t,\n \t\tbuild_int_cst (integer_type_node, -STACK_POINTER_OFFSET));\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (args), args, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (args), args, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -2811,7 +2811,7 @@ spu_va_start (tree valist, rtx nextarg)\n \t      build_int_cst (integer_type_node,\n \t\t\t     (current_function_pretend_args_size\n \t\t\t      - STACK_POINTER_OFFSET)));\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (skip), skip, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (skip), skip, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -2876,12 +2876,12 @@ spu_gimplify_va_arg_expr (tree valist, tree type, tree * pre_p,\n \t\tbuild2 (PLUS_EXPR, ptr_type_node, skip,\n \t\t\tfold_convert (ptr_type_node, size_int (32))), args);\n \n-  tmp = build2 (MODIFY_EXPR, ptr_type_node, addr, tmp);\n+  tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, addr, tmp);\n   gimplify_and_add (tmp, pre_p);\n \n   /* update VALIST.__args */\n   tmp = build2 (PLUS_EXPR, ptr_type_node, addr, paddedsize);\n-  tmp = build2 (MODIFY_EXPR, TREE_TYPE (args), args, tmp);\n+  tmp = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (args), args, tmp);\n   gimplify_and_add (tmp, pre_p);\n \n   addr = fold_convert (build_pointer_type (type), addr);"}, {"sha": "00b6e643760f3ed5ba2732252eb2535227004724", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1375,11 +1375,11 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   t = make_tree (TREE_TYPE (base), virtual_incoming_args_rtx);\n   t = build2 (PLUS_EXPR, TREE_TYPE (base), t, \n \t      build_int_cst (NULL_TREE, INCOMING_FRAME_SP_OFFSET));\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (base), base, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (base), base, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build2 (MODIFY_EXPR, TREE_TYPE (count), count, \n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (count), count, \n \t      build_int_cst (NULL_TREE,\n \t\t\t     current_function_args_info * UNITS_PER_WORD));\n   TREE_SIDE_EFFECTS (t) = 1;\n@@ -1434,7 +1434,7 @@ xstormy16_expand_builtin_va_arg (tree valist, tree type, tree *pre_p,\n   \n       t = fold_convert (ptr_type_node, count_tmp);\n       t = build2 (PLUS_EXPR, ptr_type_node, base, t);\n-      t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n       gimplify_and_add (t, pre_p);\n \n       t = build1 (GOTO_EXPR, void_type_node, lab_gotaddr);\n@@ -1453,7 +1453,7 @@ xstormy16_expand_builtin_va_arg (tree valist, tree type, tree *pre_p,\n       tree r, u;\n \n       r = size_int (NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD);\n-      u = build2 (MODIFY_EXPR, void_type_node, count_tmp, r);\n+      u = build2 (GIMPLE_MODIFY_STMT, void_type_node, count_tmp, r);\n \n       t = fold_convert (TREE_TYPE (count), r);\n       t = build2 (GE_EXPR, boolean_type_node, count_tmp, t);\n@@ -1469,15 +1469,15 @@ xstormy16_expand_builtin_va_arg (tree valist, tree type, tree *pre_p,\n \t      fold_convert (TREE_TYPE (count), size_tree));\n   t = fold_convert (TREE_TYPE (base), fold (t));\n   t = build2 (MINUS_EXPR, TREE_TYPE (base), base, t);\n-  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build1 (LABEL_EXPR, void_type_node, lab_gotaddr);\n   gimplify_and_add (t, pre_p);\n \n   t = fold_convert (TREE_TYPE (count), size_tree);\n   t = build2 (PLUS_EXPR, TREE_TYPE (count), count_tmp, t);\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (count), count, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (count), count, t);\n   gimplify_and_add (t, pre_p);\n   \n   addr = fold_convert (build_pointer_type (type), addr);"}, {"sha": "49a89920239438901f137bcba08a3b4dbe628821", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -2102,15 +2102,15 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   /* Call __builtin_saveregs; save the result in __va_reg */\n   u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n-  t = build2 (MODIFY_EXPR, ptr_type_node, reg, u);\n+  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, reg, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Set the __va_stk member to ($arg_ptr - 32).  */\n   u = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n   u = fold_build2 (PLUS_EXPR, ptr_type_node, u,\n \t\t   build_int_cst (NULL_TREE, -32));\n-  t = build2 (MODIFY_EXPR, ptr_type_node, stk, u);\n+  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, stk, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -2120,7 +2120,7 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   if (arg_words >= MAX_ARGS_IN_REGISTERS)\n     arg_words += 2;\n   u = build_int_cst (NULL_TREE, arg_words * UNITS_PER_WORD);\n-  t = build2 (MODIFY_EXPR, integer_type_node, ndx, u);\n+  t = build2 (GIMPLE_MODIFY_STMT, integer_type_node, ndx, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -2189,7 +2189,7 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t\t  build_int_cst (NULL_TREE, align - 1));\n       t = build2 (BIT_AND_EXPR, integer_type_node, t,\n \t\t  build_int_cst (NULL_TREE, -align));\n-      t = build2 (MODIFY_EXPR, integer_type_node, orig_ndx, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, integer_type_node, orig_ndx, t);\n       gimplify_and_add (t, pre_p);\n     }\n \n@@ -2200,7 +2200,7 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \n   t = fold_convert (integer_type_node, va_size);\n   t = build2 (PLUS_EXPR, integer_type_node, orig_ndx, t);\n-  t = build2 (MODIFY_EXPR, integer_type_node, ndx, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, integer_type_node, ndx, t);\n   gimplify_and_add (t, pre_p);\n \n \n@@ -2225,7 +2225,7 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t\t  NULL_TREE);\n       gimplify_and_add (t, pre_p);\n \n-      t = build2 (MODIFY_EXPR, void_type_node, array, reg);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, array, reg);\n       gimplify_and_add (t, pre_p);\n \n       t = build1 (GOTO_EXPR, void_type_node, lab_over);\n@@ -2257,13 +2257,13 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \n   t = size_binop (PLUS_EXPR, va_size, size_int (32));\n   t = fold_convert (integer_type_node, t);\n-  t = build2 (MODIFY_EXPR, integer_type_node, ndx, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, integer_type_node, ndx, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build1 (LABEL_EXPR, void_type_node, lab_false2);\n   gimplify_and_add (t, pre_p);\n \n-  t = build2 (MODIFY_EXPR, void_type_node, array, stk);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, array, stk);\n   gimplify_and_add (t, pre_p);\n \n   if (lab_over)"}, {"sha": "8c57d4fffa31a8e632a7a6699bd768ed2d0dc9d1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1,3 +1,20 @@\n+2006-12-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tMerge from gimple-tuples-branch.\n+\t\n+\t2006-10-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* cp-gimplify.c (cp_gimplify_expr): Adjust for GIMPLE_MODIFY_STMT.\n+\t(cxx_omp_clause_apply_fn): Adjust for GIMPLE_MODIFY_STMT.\n+\t(cxx_omp_clause_copy_ctor): Same.\n+\t(cxx_omp_clause_assign_op): Same.\n+\n+\t2006-09-28  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * cp-tree.h (union lang_tree_node): Gimple statements do not\n+\thave a TREE_CHAIN.\n+\t(TREE_INDIRECT_USING): Look in base.\n+\n 2006-12-04  Jan Hubicka  <jh@suse.cz>\n \n \t* cp-objcp-common.c (cp_expr_size): Return NULL in the case"}, {"sha": "b6ca617ab30c5e90d00044bad313376899d8bfd2", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -483,7 +483,7 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       ret = GS_OK;\n       break;\n \n-      /* We used to do this for MODIFY_EXPR as well, but that's unsafe; the\n+      /* We used to do this for GIMPLE_MODIFY_STMT as well, but that's unsafe; the\n \t LHS of an assignment might also be involved in the RHS, as in bug\n \t 25979.  */\n     case INIT_EXPR:\n@@ -784,13 +784,13 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n       end1 = build2 (PLUS_EXPR, TREE_TYPE (start1), start1, end1);\n \n       p1 = create_tmp_var (TREE_TYPE (start1), NULL);\n-      t = build2 (MODIFY_EXPR, void_type_node, p1, start1);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p1, start1);\n       append_to_statement_list (t, &ret);\n \n       if (arg2)\n \t{\n \t  p2 = create_tmp_var (TREE_TYPE (start2), NULL);\n-\t  t = build2 (MODIFY_EXPR, void_type_node, p2, start2);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p2, start2);\n \t  append_to_statement_list (t, &ret);\n \t}\n \n@@ -812,14 +812,14 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n \n       t = fold_convert (TREE_TYPE (p1), TYPE_SIZE_UNIT (inner_type));\n       t = build2 (PLUS_EXPR, TREE_TYPE (p1), p1, t);\n-      t = build2 (MODIFY_EXPR, void_type_node, p1, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p1, t);\n       append_to_statement_list (t, &ret);\n \n       if (arg2)\n \t{\n \t  t = fold_convert (TREE_TYPE (p2), TYPE_SIZE_UNIT (inner_type));\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (p2), p2, t);\n-\t  t = build2 (MODIFY_EXPR, void_type_node, p2, t);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p2, t);\n \t  append_to_statement_list (t, &ret);\n \t}\n \n@@ -870,7 +870,7 @@ cxx_omp_clause_copy_ctor (tree clause, tree dst, tree src)\n   if (info)\n     ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 0), dst, src);\n   if (ret == NULL)\n-    ret = build2 (MODIFY_EXPR, void_type_node, dst, src);\n+    ret = build2 (GIMPLE_MODIFY_STMT, void_type_node, dst, src);\n \n   return ret;\n }\n@@ -886,7 +886,7 @@ cxx_omp_clause_assign_op (tree clause, tree dst, tree src)\n   if (info)\n     ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 2), dst, src);\n   if (ret == NULL)\n-    ret = build2 (MODIFY_EXPR, void_type_node, dst, src);\n+    ret = build2 (GIMPLE_MODIFY_STMT, void_type_node, dst, src);\n \n   return ret;\n }"}, {"sha": "ae250bfbdfef4b14846b42baa47876c72f79c3a4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -486,7 +486,7 @@ enum cp_tree_node_structure_enum {\n \n /* The resulting tree type.  */\n union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\"),\n-       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n+       chain_next (\"(GIMPLE_STMT_P (&%h.generic) ? (union lang_tree_node *) 0 : (union lang_tree_node *)TREE_CHAIN (&%h.generic))\")))\n {\n   union tree_node GTY ((tag (\"TS_CP_GENERIC\"),\n \t\t\tdesc (\"tree_node_structure (&%h)\"))) generic;\n@@ -2067,7 +2067,7 @@ struct lang_decl GTY(())\n \n /* In a TREE_LIST concatenating using directives, indicate indirect\n    directives  */\n-#define TREE_INDIRECT_USING(NODE) (TREE_LIST_CHECK (NODE)->common.lang_flag_0)\n+#define TREE_INDIRECT_USING(NODE) (TREE_LIST_CHECK (NODE)->base.lang_flag_0)\n \n extern tree decl_shadowed_for_var_lookup (tree);\n extern void decl_shadowed_for_var_insert (tree, tree);"}, {"sha": "9a4903bdb48e8c4ef3f3ab145ef72d6f9a04390e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -9266,8 +9266,9 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n     case NON_LVALUE_EXPR:\n     case VIEW_CONVERT_EXPR:\n     case SAVE_EXPR:\n-    case MODIFY_EXPR:\n-      return loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), want_address);\n+    case GIMPLE_MODIFY_STMT:\n+      return loc_descriptor_from_tree_1 (GENERIC_TREE_OPERAND (loc, 0),\n+\t\t\t\t\t want_address);\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -10040,7 +10041,7 @@ static tree\n reference_to_unused (tree * tp, int * walk_subtrees,\n \t\t     void * data ATTRIBUTE_UNUSED)\n {\n-  if (! EXPR_P (*tp) && ! CONSTANT_CLASS_P (*tp))\n+  if (! EXPR_P (*tp) && ! GIMPLE_STMT_P (*tp) && ! CONSTANT_CLASS_P (*tp))\n     *walk_subtrees = 0;\n   \n   if (DECL_P (*tp) && ! TREE_PUBLIC (*tp) && ! TREE_USED (*tp)"}, {"sha": "05bb9b80f6c735e18988aa29100e53242b18b335", "filename": "gcc/expr.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -6247,6 +6247,9 @@ safe_from_p (rtx x, tree exp, int top_p)\n     case tcc_type:\n       /* Should never get a type here.  */\n       gcc_unreachable ();\n+\n+    case tcc_gimple_stmt:\n+      gcc_unreachable ();\n     }\n \n   /* If we have an rtl, find any enclosed object.  Then see if we conflict\n@@ -6667,7 +6670,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \n   /* Handle ERROR_MARK before anybody tries to access its type.  */\n   if (TREE_CODE (exp) == ERROR_MARK\n-      || TREE_CODE (TREE_TYPE (exp)) == ERROR_MARK)\n+      || (!GIMPLE_TUPLE_P (exp) && TREE_CODE (TREE_TYPE (exp)) == ERROR_MARK))\n     {\n       ret = CONST0_RTX (tmode);\n       return ret ? ret : const0_rtx;\n@@ -6737,7 +6740,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    enum expand_modifier modifier, rtx *alt_rtl)\n {\n   rtx op0, op1, temp, decl_rtl;\n-  tree type = TREE_TYPE (exp);\n+  tree type;\n   int unsignedp;\n   enum machine_mode mode;\n   enum tree_code code = TREE_CODE (exp);\n@@ -6752,8 +6755,18 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\t\t\t\t  type)\t  \\\n \t\t\t\t : (expr))\n \n-  mode = TYPE_MODE (type);\n-  unsignedp = TYPE_UNSIGNED (type);\n+  if (GIMPLE_STMT_P (exp))\n+    {\n+      type = void_type_node;\n+      mode = VOIDmode;\n+      unsignedp = 0;\n+    }\n+  else\n+    {\n+      type = TREE_TYPE (exp);\n+      mode = TYPE_MODE (type);\n+      unsignedp = TYPE_UNSIGNED (type);\n+    }\n   if (lang_hooks.reduce_bit_field_operations\n       && TREE_CODE (type) == INTEGER_TYPE\n       && GET_MODE_PRECISION (mode) > TYPE_PRECISION (type))\n@@ -8563,10 +8576,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttarget = expand_vec_cond_expr (exp, target);\n \treturn target;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       {\n-\ttree lhs = TREE_OPERAND (exp, 0);\n-\ttree rhs = TREE_OPERAND (exp, 1);\n+\ttree lhs = GIMPLE_STMT_OPERAND (exp, 0);\n+\ttree rhs = GIMPLE_STMT_OPERAND (exp, 1);\n \n \tgcc_assert (ignore);\n "}, {"sha": "0908e2840f2f0dbe69201ee34a6b62a16eb73f1c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -41,7 +41,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n    force_fit_type takes a constant, an overflowable flag and prior\n    overflow indicators.  It forces the value to fit the type and sets\n-   TREE_OVERFLOW and TREE_CONSTANT_OVERFLOW as appropriate.  */\n+   TREE_OVERFLOW and TREE_CONSTANT_OVERFLOW as appropriate.\n+   \n+   Note: Since the folders get called on non-gimple code as well as\n+   gimple code, we need to handle GIMPLE tuples as well as their\n+   corresponding tree equivalents.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -2181,6 +2185,7 @@ maybe_lvalue_p (tree x)\n   case WITH_CLEANUP_EXPR:\n   case COMPOUND_EXPR:\n   case MODIFY_EXPR:\n+  case GIMPLE_MODIFY_STMT:\n   case TARGET_EXPR:\n   case COND_EXPR:\n   case BIND_EXPR:\n@@ -7474,15 +7479,17 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t    return fold_convert (type, build_fold_addr_expr (base));\n         }\n \n-      if (TREE_CODE (op0) == MODIFY_EXPR\n-\t  && TREE_CONSTANT (TREE_OPERAND (op0, 1))\n+      if ((TREE_CODE (op0) == MODIFY_EXPR\n+\t   || TREE_CODE (op0) == GIMPLE_MODIFY_STMT)\n+\t  && TREE_CONSTANT (GENERIC_TREE_OPERAND (op0, 1))\n \t  /* Detect assigning a bitfield.  */\n-\t  && !(TREE_CODE (TREE_OPERAND (op0, 0)) == COMPONENT_REF\n-\t       && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (op0, 0), 1))))\n+\t  && !(TREE_CODE (GENERIC_TREE_OPERAND (op0, 0)) == COMPONENT_REF\n+\t       && DECL_BIT_FIELD\n+\t       (TREE_OPERAND (GENERIC_TREE_OPERAND (op0, 0), 1))))\n \t{\n \t  /* Don't leave an assignment inside a conversion\n \t     unless assigning a bitfield.  */\n-\t  tem = fold_build1 (code, type, TREE_OPERAND (op0, 1));\n+\t  tem = fold_build1 (code, type, GENERIC_TREE_OPERAND (op0, 1));\n \t  /* First do the assignment, then return converted constant.  */\n \t  tem = build2 (COMPOUND_EXPR, TREE_TYPE (tem), op0, tem);\n \t  TREE_NO_WARNING (tem) = 1;\n@@ -8461,7 +8468,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n   tree arg0, arg1, tem;\n   tree t1 = NULL_TREE;\n \n-  gcc_assert (IS_EXPR_CODE_CLASS (kind)\n+  gcc_assert ((IS_EXPR_CODE_CLASS (kind)\n+\t       || IS_GIMPLE_STMT_CODE_CLASS (kind))\n \t      && TREE_CODE_LENGTH (code) == 2\n \t      && op0 != NULL_TREE\n \t      && op1 != NULL_TREE);\n@@ -11673,7 +11681,8 @@ fold (tree expr)\n   if (kind == tcc_constant)\n     return t;\n \n-  if (IS_EXPR_CODE_CLASS (kind))\n+  if (IS_EXPR_CODE_CLASS (kind)\n+      || IS_GIMPLE_STMT_CODE_CLASS (kind))\n     {\n       tree type = TREE_TYPE (t);\n       tree op0, op1, op2;\n@@ -12359,7 +12368,8 @@ tree_expr_nonnegative_p (tree t)\n \n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n-      return tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+    case GIMPLE_MODIFY_STMT:\n+      return tree_expr_nonnegative_p (GENERIC_TREE_OPERAND (t, 1));\n \n     case BIND_EXPR:\n       return tree_expr_nonnegative_p (expr_last (TREE_OPERAND (t, 1)));\n@@ -12419,9 +12429,10 @@ tree_expr_nonnegative_p (tree t)\n \t    else\n \t      break;\n \t  }\n-\tif (TREE_CODE (t) == MODIFY_EXPR\n-\t    && TREE_OPERAND (t, 0) == temp)\n-\t  return tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\tif ((TREE_CODE (t) == MODIFY_EXPR\n+\t     || TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+\t    && GENERIC_TREE_OPERAND (t, 0) == temp)\n+\t  return tree_expr_nonnegative_p (GENERIC_TREE_OPERAND (t, 1));\n \n \treturn false;\n       }\n@@ -12657,8 +12668,9 @@ tree_expr_nonzero_p (tree t)\n \n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n     case BIND_EXPR:\n-      return tree_expr_nonzero_p (TREE_OPERAND (t, 1));\n+      return tree_expr_nonzero_p (GENERIC_TREE_OPERAND (t, 1));\n \n     case SAVE_EXPR:\n     case NON_LVALUE_EXPR:"}, {"sha": "11513186c046869c0ad37ff213475c7c55243a72", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -62,7 +62,8 @@ GTY(())\n \n union lang_tree_node\n GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-     chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n+     chain_next (\"(GIMPLE_STMT_P (&%h.generic) ? (union lang_tree_node *) 0 : (union lang_tree_node *)TREE_CHAIN (&%h.generic))\")))\n+\n {\n   union tree_node GTY((tag (\"0\"),\n \t\t       desc (\"tree_node_structure (&%h)\"))) generic;"}, {"sha": "8cbcac93dab20b8f85bc6a9156b961ca1d12cc48", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -5741,6 +5741,19 @@ resolve_fl_derived (gfc_symbol *sym)\n       sym->ns->derived_types = dt_list;\n     }\n \n+  /* Add derived type to the derived type list.  */\n+  for (dt_list = sym->ns->derived_types; dt_list; dt_list = dt_list->next)\n+    if (sym == dt_list->derived)\n+      break;\n+\n+  if (dt_list == NULL)\n+    {\n+      dt_list = gfc_get_dt_list ();\n+      dt_list->next = sym->ns->derived_types;\n+      dt_list->derived = sym;\n+      sym->ns->derived_types = dt_list;\n+    }\n+\n   return SUCCESS;\n }\n "}, {"sha": "0049ad5b54b86c081ed5757a058815dc03fe1dfe", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -156,10 +156,18 @@ gfc_conv_descriptor_data_get (tree desc)\n   return t;\n }\n \n-/* This provides WRITE access to the data field.  */\n+/* This provides WRITE access to the data field.\n+\n+   TUPLES_P is true if we are generating tuples.\n+   \n+   This function gets called through the following macros:\n+     gfc_conv_descriptor_data_set\n+     gfc_conv_descriptor_data_set_tuples.  */\n \n void\n-gfc_conv_descriptor_data_set (stmtblock_t *block, tree desc, tree value)\n+gfc_conv_descriptor_data_set_internal (stmtblock_t *block,\n+\t\t\t\t       tree desc, tree value,\n+\t\t\t\t       bool tuples_p)\n {\n   tree field, type, t;\n \n@@ -170,7 +178,7 @@ gfc_conv_descriptor_data_set (stmtblock_t *block, tree desc, tree value)\n   gcc_assert (DATA_FIELD == 0);\n \n   t = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n-  gfc_add_modify_expr (block, t, fold_convert (TREE_TYPE (field), value));\n+  gfc_add_modify (block, t, fold_convert (TREE_TYPE (field), value), tuples_p);\n }\n \n "}, {"sha": "38ad123624b291f8674363ded33256c5b2fb6b1d", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -118,7 +118,11 @@ tree gfc_conv_array_ubound (tree, int);\n \n /* Build expressions for accessing components of an array descriptor.  */\n tree gfc_conv_descriptor_data_get (tree);\n-void gfc_conv_descriptor_data_set (stmtblock_t *, tree, tree);\n+void gfc_conv_descriptor_data_set_internal (stmtblock_t *, tree, tree, bool);\n+#define gfc_conv_descriptor_data_set(BLOCK, T1, T2)\t\t\t\\\n+  gfc_conv_descriptor_data_set_internal ((BLOCK), (T1), (T2), false)\n+#define gfc_conv_descriptor_data_set_tuples(BLOCK, T1, T2)\t\t\\\n+  gfc_conv_descriptor_data_set_internal ((BLOCK), (T1), (T2), true)\n tree gfc_conv_descriptor_data_addr (tree);\n tree gfc_conv_descriptor_offset (tree);\n tree gfc_conv_descriptor_dtype (tree);"}, {"sha": "827631612772aff6d990aa5c49f41dcc12d9b14a", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -111,7 +111,7 @@ gfc_omp_clause_default_ctor (tree clause ATTRIBUTE_UNUSED, tree decl)\n      \"not currently allocated\" allocation status.  */\n   gfc_init_block (&block);\n \n-  gfc_conv_descriptor_data_set (&block, decl, null_pointer_node);\n+  gfc_conv_descriptor_data_set_tuples (&block, decl, null_pointer_node);\n \n   return gfc_finish_block (&block);\n }\n@@ -832,15 +832,15 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t  tree accum = gfc_create_var (TREE_TYPE (rse.expr), NULL);\n \t  gfc_actual_arglist *arg;\n \n-\t  gfc_add_modify_expr (&block, accum, rse.expr);\n+\t  gfc_add_modify_stmt (&block, accum, rse.expr);\n \t  for (arg = expr2->value.function.actual->next->next; arg;\n \t       arg = arg->next)\n \t    {\n \t      gfc_init_block (&rse.pre);\n \t      gfc_conv_expr (&rse, arg->expr);\n \t      gfc_add_block_to_block (&block, &rse.pre);\n \t      x = fold_build2 (op, TREE_TYPE (accum), accum, rse.expr);\n-\t      gfc_add_modify_expr (&block, accum, x);\n+\t      gfc_add_modify_stmt (&block, accum, x);\n \t    }\n \n \t  rse.expr = accum;\n@@ -957,11 +957,11 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n   /* Loop body.  */\n   if (simple)\n     {\n-      init = build2_v (MODIFY_EXPR, dovar, from);\n+      init = build2_v (GIMPLE_MODIFY_STMT, dovar, from);\n       cond = build2 (simple > 0 ? LE_EXPR : GE_EXPR, boolean_type_node,\n \t\t     dovar, to);\n       incr = fold_build2 (PLUS_EXPR, type, dovar, step);\n-      incr = fold_build2 (MODIFY_EXPR, type, dovar, incr);\n+      incr = fold_build2 (GIMPLE_MODIFY_STMT, type, dovar, incr);\n       if (pblock != &block)\n \t{\n \t  pushlevel (0);\n@@ -983,10 +983,10 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n       tmp = fold_build2 (TRUNC_DIV_EXPR, type, tmp, step);\n       tmp = gfc_evaluate_now (tmp, pblock);\n       count = gfc_create_var (type, \"count\");\n-      init = build2_v (MODIFY_EXPR, count, build_int_cst (type, 0));\n+      init = build2_v (GIMPLE_MODIFY_STMT, count, build_int_cst (type, 0));\n       cond = build2 (LT_EXPR, boolean_type_node, count, tmp);\n       incr = fold_build2 (PLUS_EXPR, type, count, build_int_cst (type, 1));\n-      incr = fold_build2 (MODIFY_EXPR, type, count, incr);\n+      incr = fold_build2 (GIMPLE_MODIFY_STMT, type, count, incr);\n \n       if (pblock != &block)\n \t{\n@@ -998,7 +998,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n       /* Initialize DOVAR.  */\n       tmp = fold_build2 (MULT_EXPR, type, count, step);\n       tmp = build2 (PLUS_EXPR, type, from, tmp);\n-      gfc_add_modify_expr (&body, dovar, tmp);\n+      gfc_add_modify_stmt (&body, dovar, tmp);\n     }\n \n   if (!dovar_found)"}, {"sha": "3040319f14ea99253b0b15a7532958e1b18cc094", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -140,11 +140,13 @@ gfc_evaluate_now (tree expr, stmtblock_t * pblock)\n }\n \n \n-/* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.\n-   A MODIFY_EXPR is an assignment: LHS <- RHS.  */\n+/* Build a MODIFY_EXPR (or GIMPLE_MODIFY_STMT) node and add it to a\n+   given statement block PBLOCK.  A MODIFY_EXPR is an assignment:\n+   LHS <- RHS.  */\n \n void\n-gfc_add_modify_expr (stmtblock_t * pblock, tree lhs, tree rhs)\n+gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs,\n+\t\tbool tuples_p)\n {\n   tree tmp;\n \n@@ -157,7 +159,8 @@ gfc_add_modify_expr (stmtblock_t * pblock, tree lhs, tree rhs)\n \t      || AGGREGATE_TYPE_P (TREE_TYPE (lhs)));\n #endif\n \n-  tmp = fold_build2 (MODIFY_EXPR, void_type_node, lhs, rhs);\n+  tmp = fold_build2 (tuples_p ? GIMPLE_MODIFY_STMT : MODIFY_EXPR,\n+\t\t     void_type_node, lhs, rhs);\n   gfc_add_expr_to_block (pblock, tmp);\n }\n "}, {"sha": "ed96838608307e54758c1de86993e050ac9ae334", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -334,8 +334,12 @@ void gfc_trans_vla_type_sizes (gfc_symbol *, stmtblock_t *);\n void gfc_add_expr_to_block (stmtblock_t *, tree);\n /* Add a block to the end of a block.  */\n void gfc_add_block_to_block (stmtblock_t *, stmtblock_t *);\n-/* Add a MODIFY_EXPR to a block.  */\n-void gfc_add_modify_expr (stmtblock_t *, tree, tree);\n+/* Add a MODIFY_EXPR or a GIMPLE_MODIFY_STMT to a block.  */\n+void gfc_add_modify (stmtblock_t *, tree, tree, bool);\n+#define gfc_add_modify_expr(BLOCK, LHS, RHS) \\\n+       gfc_add_modify ((BLOCK), (LHS), (RHS), false)\n+#define gfc_add_modify_stmt(BLOCK, LHS, RHS) \\\n+       gfc_add_modify ((BLOCK), (LHS), (RHS), true)\n \n /* Initialize a statement block.  */\n void gfc_init_block (stmtblock_t *);"}, {"sha": "b61b9004a78cbc60dbbb1db1cf9123788d711299", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1609,7 +1609,7 @@ static tree\n instantiate_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   tree t = *tp;\n-  if (! EXPR_P (t))\n+  if (! EXPR_P (t) && ! GIMPLE_STMT_P (t))\n     {\n       *walk_subtrees = 0;\n       if (DECL_P (t) && DECL_RTL_SET_P (t))\n@@ -3227,11 +3227,11 @@ gimplify_parameters (void)\n \t\t  t = built_in_decls[BUILT_IN_ALLOCA];\n \t\t  t = build_function_call_expr (t, args);\n \t\t  t = fold_convert (ptr_type, t);\n-\t\t  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+\t\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n \t\t  gimplify_and_add (t, &stmts);\n \t\t}\n \n-\t      t = build2 (MODIFY_EXPR, void_type_node, local, parm);\n+\t      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, local, parm);\n \t      gimplify_and_add (t, &stmts);\n \n \t      SET_DECL_VALUE_EXPR (parm, local);"}, {"sha": "b37907cc41615a0ae4b4adad104b1fea6e7ef7d1", "filename": "gcc/function.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -469,6 +469,11 @@ struct function GTY(())\n   /* Number of units of floating point registers that need saving in stdarg\n      function.  */\n   unsigned int va_list_fpr_size : 8;\n+\n+  /* FIXME tuples: This bit is temporarily here to mark when a\n+     function has been gimplified, so we can make sure we're not\n+     creating non GIMPLE tuples after gimplification.  */\n+  unsigned gimplified : 1;\n };\n \n /* If va_list_[gf]pr_size is set to this, it means we don't know how"}, {"sha": "9c68447206c3a0b2ba7e73918bd264f5869cbb9d", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -138,7 +138,7 @@ lower_function_body (void)\n       arg = tree_cons (NULL, t, NULL);\n       t = implicit_built_in_decls[BUILT_IN_SETJMP_DISPATCHER];\n       t = build_function_call_expr (t,arg);\n-      x = build2 (MODIFY_EXPR, void_type_node, disp_var, t);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, disp_var, t);\n \n       /* Build 'goto DISP_VAR;' and insert.  */\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n@@ -254,9 +254,9 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n     case OMP_CONTINUE:\n       break;\n \n-    case MODIFY_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)\n-\tstmt = TREE_OPERAND (stmt, 1);\n+    case GIMPLE_MODIFY_STMT:\n+      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR)\n+\tstmt = GIMPLE_STMT_OPERAND (stmt, 1);\n       else\n \tbreak;\n       /* FALLTHRU */\n@@ -436,9 +436,9 @@ block_may_fallthru (tree block)\n       return (block_may_fallthru (TREE_OPERAND (stmt, 0))\n \t      && block_may_fallthru (TREE_OPERAND (stmt, 1)));\n \n-    case MODIFY_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)\n-\tstmt = TREE_OPERAND (stmt, 1);\n+    case GIMPLE_MODIFY_STMT:\n+      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR)\n+\tstmt = GIMPLE_STMT_OPERAND (stmt, 1);\n       else\n \treturn true;\n       /* FALLTHRU */\n@@ -560,15 +560,15 @@ lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n \n   /* Extract the value being returned.  */\n   value = TREE_OPERAND (stmt, 0);\n-  if (value && TREE_CODE (value) == MODIFY_EXPR)\n-    value = TREE_OPERAND (value, 1);\n+  if (value && TREE_CODE (value) == GIMPLE_MODIFY_STMT)\n+    value = GIMPLE_STMT_OPERAND (value, 1);\n \n   /* Match this up with an existing return statement that's been created.  */\n   for (t = data->return_statements; t ; t = TREE_CHAIN (t))\n     {\n       tree tvalue = TREE_OPERAND (TREE_VALUE (t), 0);\n-      if (tvalue && TREE_CODE (tvalue) == MODIFY_EXPR)\n-\ttvalue = TREE_OPERAND (tvalue, 1);\n+      if (tvalue && TREE_CODE (tvalue) == GIMPLE_MODIFY_STMT)\n+\ttvalue = GIMPLE_STMT_OPERAND (tvalue, 1);\n \n       if (value == tvalue)\n \t{\n@@ -654,18 +654,18 @@ lower_builtin_setjmp (tree_stmt_iterator *tsi)\n      passed to both __builtin_setjmp_setup and __builtin_setjmp_receiver.  */\n   FORCED_LABEL (next_label) = 1;\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      dest = TREE_OPERAND (stmt, 0);\n-      stmt = TREE_OPERAND (stmt, 1);\n+      dest = GIMPLE_STMT_OPERAND (stmt, 0);\n+      stmt = GIMPLE_STMT_OPERAND (stmt, 1);\n     }\n   else\n     dest = NULL_TREE;\n \n   /* Build '__builtin_setjmp_setup (BUF, NEXT_LABEL)' and insert.  */\n   t = build_addr (next_label, current_function_decl);\n   arg = tree_cons (NULL, t, NULL);\n-  t = TREE_VALUE (TREE_OPERAND (stmt, 1));\n+  t = TREE_VALUE (GENERIC_TREE_OPERAND (stmt, 1));\n   arg = tree_cons (NULL, t, arg);\n   t = implicit_built_in_decls[BUILT_IN_SETJMP_SETUP];\n   t = build_function_call_expr (t, arg);\n@@ -675,7 +675,7 @@ lower_builtin_setjmp (tree_stmt_iterator *tsi)\n   /* Build 'DEST = 0' and insert.  */\n   if (dest)\n     {\n-      t = build2 (MODIFY_EXPR, void_type_node, dest, integer_zero_node);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, dest, integer_zero_node);\n       SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n       tsi_link_before (tsi, t, TSI_SAME_STMT);\n     }\n@@ -699,7 +699,7 @@ lower_builtin_setjmp (tree_stmt_iterator *tsi)\n   /* Build 'DEST = 1' and insert.  */\n   if (dest)\n     {\n-      t = build2 (MODIFY_EXPR, void_type_node, dest, integer_one_node);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, dest, integer_one_node);\n       SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n       tsi_link_before (tsi, t, TSI_SAME_STMT);\n     }"}, {"sha": "efe6b96dcdf6205648d32a48e466457956ee8f22", "filename": "gcc/gimplify.c", "status": "modified", "additions": 127, "deletions": 55, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -769,7 +769,8 @@ should_carry_locus_p (tree stmt)\n static void\n annotate_one_with_locus (tree t, location_t locus)\n {\n-  if (EXPR_P (t) && ! EXPR_HAS_LOCATION (t) && should_carry_locus_p (t))\n+  if (CAN_HAVE_LOCATION_P (t)\n+      && ! EXPR_HAS_LOCATION (t) && should_carry_locus_p (t))\n     SET_EXPR_LOCATION (t, locus);\n }\n \n@@ -1040,7 +1041,7 @@ build_stack_save_restore (tree *save, tree *restore)\n \t\t\t\tNULL_TREE);\n   tmp_var = create_tmp_var (ptr_type_node, \"saved_stack\");\n \n-  *save = build2 (MODIFY_EXPR, ptr_type_node, tmp_var, save_call);\n+  *save = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, tmp_var, save_call);\n   *restore =\n     build_function_call_expr (implicit_built_in_decls[BUILT_IN_STACK_RESTORE],\n \t\t\t      tree_cons (NULL_TREE, tmp_var, NULL_TREE));\n@@ -1141,12 +1142,13 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n     result_decl = NULL_TREE;\n   else\n     {\n-      result_decl = TREE_OPERAND (ret_expr, 0);\n+      result_decl = GENERIC_TREE_OPERAND (ret_expr, 0);\n       if (TREE_CODE (result_decl) == INDIRECT_REF)\n \t/* See through a return by reference.  */\n \tresult_decl = TREE_OPERAND (result_decl, 0);\n \n       gcc_assert ((TREE_CODE (ret_expr) == MODIFY_EXPR\n+\t    \t   || TREE_CODE (ret_expr) == GIMPLE_MODIFY_STMT\n \t\t   || TREE_CODE (ret_expr) == INIT_EXPR)\n \t\t  && TREE_CODE (result_decl) == RESULT_DECL);\n     }\n@@ -1177,10 +1179,10 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n       gimplify_ctxp->return_temp = result;\n     }\n \n-  /* Smash the lhs of the MODIFY_EXPR to the temporary we plan to use.\n+  /* Smash the lhs of the GIMPLE_MODIFY_STMT to the temporary we plan to use.\n      Then gimplify the whole thing.  */\n   if (result != result_decl)\n-    TREE_OPERAND (ret_expr, 0) = result;\n+    GENERIC_TREE_OPERAND (ret_expr, 0) = result;\n \n   gimplify_and_add (TREE_OPERAND (stmt, 0), pre_p);\n \n@@ -1189,7 +1191,8 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n   if (result == result_decl)\n     ret_expr = result;\n   else\n-    ret_expr = build2 (MODIFY_EXPR, TREE_TYPE (result), result_decl, result);\n+    ret_expr = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (result), result_decl,\n+\t\t       result);\n   TREE_OPERAND (stmt, 0) = ret_expr;\n \n   return GS_ALL_DONE;\n@@ -1244,7 +1247,7 @@ gimplify_decl_expr (tree *stmt_p)\n \t  t = built_in_decls[BUILT_IN_ALLOCA];\n \t  t = build_function_call_expr (t, args);\n \t  t = fold_convert (ptr_type, t);\n-\t  t = build2 (MODIFY_EXPR, void_type_node, addr, t);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n \n \t  gimplify_and_add (t, stmt_p);\n \n@@ -1943,7 +1946,7 @@ gimplify_self_mod_expr (tree *expr_p, tree *pre_p, tree *post_p,\n     }\n \n   t1 = build2 (arith_code, TREE_TYPE (*expr_p), lhs, rhs);\n-  t1 = build2 (MODIFY_EXPR, TREE_TYPE (lvalue), lvalue, t1);\n+  t1 = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (lvalue), lvalue, t1);\n \n   if (postfix)\n     {\n@@ -2466,12 +2469,14 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, fallback_t fallback)\n \t if this branch is void; in C++ it can be, if it's a throw.  */\n       if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n \tTREE_OPERAND (expr, 1)\n-\t  = build2 (MODIFY_EXPR, void_type_node, tmp, TREE_OPERAND (expr, 1));\n+\t  = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp,\n+\t      \t    TREE_OPERAND (expr, 1));\n \n       /* Build the else clause, 't1 = b;'.  */\n       if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n \tTREE_OPERAND (expr, 2)\n-\t  = build2 (MODIFY_EXPR, void_type_node, tmp2, TREE_OPERAND (expr, 2));\n+\t  = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp2,\n+\t      \t    TREE_OPERAND (expr, 2));\n \n       TREE_TYPE (expr) = void_type_node;\n       recalculate_side_effects (expr);\n@@ -2551,8 +2556,8 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value)\n {\n   tree args, t, to, to_ptr, from;\n \n-  to = TREE_OPERAND (*expr_p, 0);\n-  from = TREE_OPERAND (*expr_p, 1);\n+  to = GENERIC_TREE_OPERAND (*expr_p, 0);\n+  from = GENERIC_TREE_OPERAND (*expr_p, 1);\n \n   args = tree_cons (NULL, size, NULL);\n \n@@ -2583,7 +2588,7 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value)\n {\n   tree args, t, to, to_ptr;\n \n-  to = TREE_OPERAND (*expr_p, 0);\n+  to = GENERIC_TREE_OPERAND (*expr_p, 0);\n \n   args = tree_cons (NULL, size, NULL);\n \n@@ -2746,7 +2751,8 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n   /* Create and initialize the index variable.  */\n   var_type = TREE_TYPE (upper);\n   var = create_tmp_var (var_type, NULL);\n-  append_to_statement_list (build2 (MODIFY_EXPR, var_type, var, lower), pre_p);\n+  append_to_statement_list (build2 (GIMPLE_MODIFY_STMT, var_type, var, lower),\n+\t\t\t    pre_p);\n \n   /* Add the loop entry label.  */\n   append_to_statement_list (build1 (LABEL_EXPR,\n@@ -2767,7 +2773,7 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n     gimplify_init_ctor_eval (cref, CONSTRUCTOR_ELTS (value),\n \t\t\t     pre_p, cleared);\n   else\n-    append_to_statement_list (build2 (MODIFY_EXPR, TREE_TYPE (cref),\n+    append_to_statement_list (build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (cref),\n \t\t\t\t      cref, value),\n \t\t\t      pre_p);\n \n@@ -2782,7 +2788,7 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n \t\t    pre_p);\n \n   /* Otherwise, increment the index var...  */\n-  append_to_statement_list (build2 (MODIFY_EXPR, var_type, var,\n+  append_to_statement_list (build2 (GIMPLE_MODIFY_STMT, var_type, var,\n \t\t\t\t    build2 (PLUS_EXPR, var_type, var,\n \t\t\t\t\t    fold_convert (var_type,\n \t\t\t\t\t\t\t  integer_one_node))),\n@@ -2918,19 +2924,19 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t\t\t   tree *post_p, bool want_value)\n {\n   tree object;\n-  tree ctor = TREE_OPERAND (*expr_p, 1);\n+  tree ctor = GENERIC_TREE_OPERAND (*expr_p, 1);\n   tree type = TREE_TYPE (ctor);\n   enum gimplify_status ret;\n   VEC(constructor_elt,gc) *elts;\n \n   if (TREE_CODE (ctor) != CONSTRUCTOR)\n     return GS_UNHANDLED;\n \n-  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+  ret = gimplify_expr (&GENERIC_TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n \t\t       is_gimple_lvalue, fb_lvalue);\n   if (ret == GS_ERROR)\n     return ret;\n-  object = TREE_OPERAND (*expr_p, 0);\n+  object = GENERIC_TREE_OPERAND (*expr_p, 0);\n \n   elts = CONSTRUCTOR_ELTS (ctor);\n \n@@ -3056,7 +3062,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t\t  }\n \t        walk_tree (&DECL_INITIAL (new), force_labels_r, NULL, NULL);\n \n-\t\tTREE_OPERAND (*expr_p, 1) = new;\n+\t\tGENERIC_TREE_OPERAND (*expr_p, 1) = new;\n \n \t\t/* This is no longer an assignment of a CONSTRUCTOR, but\n \t\t   we still may have processing to do on the LHS.  So\n@@ -3075,7 +3081,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t      preeval_data.lhs_base_decl = NULL;\n \t    preeval_data.lhs_alias_set = get_alias_set (object);\n \n-\t    gimplify_init_ctor_preeval (&TREE_OPERAND (*expr_p, 1),\n+\t    gimplify_init_ctor_preeval (&GENERIC_TREE_OPERAND (*expr_p, 1),\n \t\t\t\t\tpre_p, post_p, &preeval_data);\n \t  }\n \n@@ -3462,8 +3468,8 @@ gimplify_modify_expr_complex_part (tree *expr_p, tree *pre_p, bool want_value)\n   enum tree_code code, ocode;\n   tree lhs, rhs, new_rhs, other, realpart, imagpart;\n \n-  lhs = TREE_OPERAND (*expr_p, 0);\n-  rhs = TREE_OPERAND (*expr_p, 1);\n+  lhs = GENERIC_TREE_OPERAND (*expr_p, 0);\n+  rhs = GENERIC_TREE_OPERAND (*expr_p, 1);\n   code = TREE_CODE (lhs);\n   lhs = TREE_OPERAND (lhs, 0);\n \n@@ -3479,8 +3485,8 @@ gimplify_modify_expr_complex_part (tree *expr_p, tree *pre_p, bool want_value)\n   else\n     new_rhs = build2 (COMPLEX_EXPR, TREE_TYPE (lhs), realpart, imagpart);\n \n-  TREE_OPERAND (*expr_p, 0) = lhs;\n-  TREE_OPERAND (*expr_p, 1) = new_rhs;\n+  GENERIC_TREE_OPERAND (*expr_p, 0) = lhs;\n+  GENERIC_TREE_OPERAND (*expr_p, 1) = new_rhs;\n \n   if (want_value)\n     {\n@@ -3491,6 +3497,53 @@ gimplify_modify_expr_complex_part (tree *expr_p, tree *pre_p, bool want_value)\n   return GS_ALL_DONE;\n }\n \n+\n+/* Destructively convert the TREE pointer in TP into a gimple tuple if\n+   appropriate.  */\n+\n+static void\n+tree_to_gimple_tuple (tree *tp)\n+{\n+\n+  switch (TREE_CODE (*tp))\n+    {\n+    case GIMPLE_MODIFY_STMT:\n+      return;\n+    case MODIFY_EXPR:\n+      {\n+        struct gimple_stmt *gs;\n+\ttree lhs = TREE_OPERAND (*tp, 0);\n+\tbool def_stmt_self_p = false;\n+\n+\tif (TREE_CODE (lhs) == SSA_NAME)\n+\t  {\n+\t    if (SSA_NAME_DEF_STMT (lhs) == *tp)\n+\t      def_stmt_self_p = true;\n+\t  }\n+\n+        gs = &make_node (GIMPLE_MODIFY_STMT)->gstmt;\n+        gs->base = (*tp)->base;\n+        /* The set to base above overwrites the CODE.  */\n+        TREE_SET_CODE ((tree) gs, GIMPLE_MODIFY_STMT);\n+\n+        gs->locus = EXPR_LOCUS (*tp);\n+        gs->operands[0] = TREE_OPERAND (*tp, 0);\n+        gs->operands[1] = TREE_OPERAND (*tp, 1);\n+        gs->block = TREE_BLOCK (*tp);\n+        *tp = (tree)gs;\n+\n+\t/* If we re-gimplify a set to an SSA_NAME, we must change the\n+\t   SSA name's DEF_STMT link.  */\n+\tif (def_stmt_self_p)\n+\t  SSA_NAME_DEF_STMT (GIMPLE_STMT_OPERAND (*tp, 0)) = *tp;\n+\n+        return;\n+      }\n+    default:\n+      break;\n+    }\n+}\n+\n /* Gimplify the MODIFY_EXPR node pointed to by EXPR_P.\n \n       modify_expr\n@@ -3509,11 +3562,12 @@ gimplify_modify_expr_complex_part (tree *expr_p, tree *pre_p, bool want_value)\n static enum gimplify_status\n gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n {\n-  tree *from_p = &TREE_OPERAND (*expr_p, 1);\n-  tree *to_p = &TREE_OPERAND (*expr_p, 0);\n+  tree *from_p = &GENERIC_TREE_OPERAND (*expr_p, 1);\n+  tree *to_p = &GENERIC_TREE_OPERAND (*expr_p, 0);\n   enum gimplify_status ret = GS_UNHANDLED;\n \n   gcc_assert (TREE_CODE (*expr_p) == MODIFY_EXPR\n+\t      || TREE_CODE (*expr_p) == GIMPLE_MODIFY_STMT\n \t      || TREE_CODE (*expr_p) == INIT_EXPR);\n \n   /* For zero sized types only gimplify the left hand side and right hand side\n@@ -3592,6 +3646,8 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n \n   if (want_value)\n     {\n+      tree_to_gimple_tuple (expr_p);\n+\n       append_to_statement_list (*expr_p, pre_p);\n       *expr_p = *to_p;\n       return GS_OK;\n@@ -4182,9 +4238,9 @@ gimple_push_cleanup (tree var, tree cleanup, bool eh_only, tree *pre_p)\n       */\n \n       tree flag = create_tmp_var (boolean_type_node, \"cleanup\");\n-      tree ffalse = build2 (MODIFY_EXPR, void_type_node, flag,\n+      tree ffalse = build2 (GIMPLE_MODIFY_STMT, void_type_node, flag,\n \t\t\t    boolean_false_node);\n-      tree ftrue = build2 (MODIFY_EXPR, void_type_node, flag,\n+      tree ftrue = build2 (GIMPLE_MODIFY_STMT, void_type_node, flag,\n \t\t\t   boolean_true_node);\n       cleanup = build3 (COND_EXPR, void_type_node, flag, cleanup, NULL);\n       wce = build1 (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n@@ -4883,8 +4939,9 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n   gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, false, false);\n \n   t = OMP_FOR_INIT (for_stmt);\n-  gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n-  decl = TREE_OPERAND (t, 0);\n+  gcc_assert (TREE_CODE (t) == MODIFY_EXPR\n+\t      || TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+  decl = GENERIC_TREE_OPERAND (t, 0);\n   gcc_assert (DECL_P (decl));\n   gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (decl)));\n \n@@ -4894,16 +4951,21 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n   else\n     omp_add_variable (gimplify_omp_ctxp, decl, GOVD_PRIVATE | GOVD_SEEN);\n \n-  ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n+  ret |= gimplify_expr (&GENERIC_TREE_OPERAND (t, 1),\n+\t\t\t&OMP_FOR_PRE_BODY (for_stmt),\n \t\t\tNULL, is_gimple_val, fb_rvalue);\n \n+  tree_to_gimple_tuple (&OMP_FOR_INIT (for_stmt));\n+\n   t = OMP_FOR_COND (for_stmt);\n   gcc_assert (COMPARISON_CLASS_P (t));\n-  gcc_assert (TREE_OPERAND (t, 0) == decl);\n+  gcc_assert (GENERIC_TREE_OPERAND (t, 0) == decl);\n \n-  ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n+  ret |= gimplify_expr (&GENERIC_TREE_OPERAND (t, 1),\n+\t\t\t&OMP_FOR_PRE_BODY (for_stmt),\n \t\t\tNULL, is_gimple_val, fb_rvalue);\n \n+  tree_to_gimple_tuple (&OMP_FOR_INCR (for_stmt));\n   t = OMP_FOR_INCR (for_stmt);\n   switch (TREE_CODE (t))\n     {\n@@ -4917,13 +4979,13 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n       goto build_modify;\n     build_modify:\n       t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n-      t = build2 (MODIFY_EXPR, void_type_node, decl, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, decl, t);\n       OMP_FOR_INCR (for_stmt) = t;\n       break;\n       \n-    case MODIFY_EXPR:\n-      gcc_assert (TREE_OPERAND (t, 0) == decl);\n-      t = TREE_OPERAND (t, 1);\n+    case GIMPLE_MODIFY_STMT:\n+      gcc_assert (GIMPLE_STMT_OPERAND (t, 0) == decl);\n+      t = GIMPLE_STMT_OPERAND (t, 1);\n       switch (TREE_CODE (t))\n \t{\n \tcase PLUS_EXPR:\n@@ -5133,7 +5195,7 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n     return GS_ERROR;\n \n   x = build_fold_indirect_ref (addr);\n-  x = build2 (MODIFY_EXPR, void_type_node, oldval, x);\n+  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldval, x);\n   gimplify_and_add (x, pre_p);\n \n   /* For floating-point values, we'll need to view-convert them to integers\n@@ -5151,7 +5213,7 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n       newival = create_tmp_var (itype, NULL);\n \n       x = build1 (VIEW_CONVERT_EXPR, itype, oldval);\n-      x = build2 (MODIFY_EXPR, void_type_node, oldival, x);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldival, x);\n       gimplify_and_add (x, pre_p);\n       iaddr = fold_convert (build_pointer_type (itype), addr);\n     }\n@@ -5162,17 +5224,17 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n   x = build1 (LABEL_EXPR, void_type_node, label);\n   gimplify_and_add (x, pre_p);\n \n-  x = build2 (MODIFY_EXPR, void_type_node, newval, rhs);\n+  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, newval, rhs);\n   gimplify_and_add (x, pre_p);\n \n   if (newval != newival)\n     {\n       x = build1 (VIEW_CONVERT_EXPR, itype, newval);\n-      x = build2 (MODIFY_EXPR, void_type_node, newival, x);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, newival, x);\n       gimplify_and_add (x, pre_p);\n     }\n \n-  x = build2 (MODIFY_EXPR, void_type_node, oldival2,\n+  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldival2,\n \t      fold_convert (itype, oldival));\n   gimplify_and_add (x, pre_p);\n \n@@ -5182,14 +5244,14 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n   x = build_function_call_expr (cmpxchg, args);\n   if (oldval == oldival)\n     x = fold_convert (type, x);\n-  x = build2 (MODIFY_EXPR, void_type_node, oldival, x);\n+  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldival, x);\n   gimplify_and_add (x, pre_p);\n \n   /* For floating point, be prepared for the loop backedge.  */\n   if (oldval != oldival)\n     {\n       x = build1 (VIEW_CONVERT_EXPR, type, oldival);\n-      x = build2 (MODIFY_EXPR, void_type_node, oldval, x);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldval, x);\n       gimplify_and_add (x, pre_p);\n     }\n \n@@ -5227,7 +5289,7 @@ gimplify_omp_atomic_mutex (tree *expr_p, tree *pre_p, tree addr, tree rhs)\n   gimplify_and_add (t, pre_p);\n \n   t = build_fold_indirect_ref (addr);\n-  t = build2 (MODIFY_EXPR, void_type_node, t, rhs);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, t, rhs);\n   gimplify_and_add (t, pre_p);\n   \n   t = built_in_decls[BUILT_IN_GOMP_ATOMIC_END];\n@@ -5362,7 +5424,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n       /* Die, die, die, my darling.  */\n       if (save_expr == error_mark_node\n-\t  || (TREE_TYPE (save_expr)\n+\t  || (!GIMPLE_STMT_P (save_expr)\n+\t      && TREE_TYPE (save_expr)\n \t      && TREE_TYPE (save_expr) == error_mark_node))\n \t{\n \t  ret = GS_ERROR;\n@@ -5438,14 +5501,23 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase MODIFY_EXPR:\n+\tcase GIMPLE_MODIFY_STMT:\n \tcase INIT_EXPR:\n \t  ret = gimplify_modify_expr (expr_p, pre_p, post_p,\n \t\t\t\t      fallback != fb_none);\n \n-\t  /* The distinction between MODIFY_EXPR and INIT_EXPR is no longer\n-\t     useful.  */\n-\t  if (*expr_p && TREE_CODE (*expr_p) == INIT_EXPR)\n-\t    TREE_SET_CODE (*expr_p, MODIFY_EXPR);\n+\t  if (*expr_p)\n+\t    {\n+\t      /* The distinction between MODIFY_EXPR and INIT_EXPR is no longer\n+\t\t useful.  */\n+\t      if (TREE_CODE (*expr_p) == INIT_EXPR)\n+\t\tTREE_SET_CODE (*expr_p, MODIFY_EXPR);\n+\n+\t      /* Convert MODIFY_EXPR to GIMPLE_MODIFY_STMT.  */\n+\t      if (TREE_CODE (*expr_p) == MODIFY_EXPR)\n+\t\ttree_to_gimple_tuple (expr_p);\n+\t    }\n+\n \t  break;\n \n \tcase TRUTH_ANDIF_EXPR:\n@@ -5885,7 +5957,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t     given a TREE_ADDRESSABLE type.  */\n \t  tree tmp = create_tmp_var_raw (type, \"vol\");\n \t  gimple_add_tmp_var (tmp);\n-\t  *expr_p = build2 (MODIFY_EXPR, type, tmp, *expr_p);\n+\t  *expr_p = build2 (GIMPLE_MODIFY_STMT, type, tmp, *expr_p);\n \t}\n       else\n \t/* We can't do anything useful with a volatile reference to\n@@ -6117,7 +6189,7 @@ gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n \n       *expr_p = create_tmp_var (type, NULL);\n       tmp = build1 (NOP_EXPR, type, expr);\n-      tmp = build2 (MODIFY_EXPR, type, *expr_p, tmp);\n+      tmp = build2 (GIMPLE_MODIFY_STMT, type, *expr_p, tmp);\n       if (EXPR_HAS_LOCATION (expr))\n \tSET_EXPR_LOCUS (tmp, EXPR_LOCUS (expr));\n       else\n@@ -6340,10 +6412,10 @@ gimplify_function_tree (tree fndecl)\n       DECL_SAVED_TREE (fndecl) = bind;\n     }\n \n+  cfun->gimplified = true;\n   current_function_decl = oldfn;\n   cfun = oldfn ? DECL_STRUCT_FUNCTION (oldfn) : NULL;\n }\n-\n \f\n /* Expands EXPR to list of gimple statements STMTS.  If SIMPLE is true,\n    force the result to be either ssa_name or an invariant, otherwise\n@@ -6368,7 +6440,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n   gimplify_ctxp->into_ssa = gimple_in_ssa_p (cfun);\n \n   if (var)\n-    expr = build2 (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n+    expr = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), var, expr);\n \n   ret = gimplify_expr (&expr, stmts, NULL,\n \t\t       gimple_test_f, fb_rvalue);"}, {"sha": "305b1a5f4e27dab8c8b53d13f92ffba948d7ebe9", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -446,7 +446,7 @@ constant_val_insert (tree fn, tree parm1, tree val)\n   edge e_step;\n   edge_iterator ei;\n \n-  init_stmt = build2 (MODIFY_EXPR, void_type_node, parm1, val);\n+  init_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, parm1, val);\n   func = DECL_STRUCT_FUNCTION (fn);\n   cfun = func;\n   current_function_decl = fn;"}, {"sha": "91eff199337909bfd829d173f33df2013c19a1fd", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -247,10 +247,10 @@ ipa_method_modify_stmt (struct cgraph_node *mt, tree stmt)\n \n   switch (TREE_CODE (stmt))\n     {\n-    case MODIFY_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (stmt, 0)) == PARM_DECL)\n+    case GIMPLE_MODIFY_STMT:\n+      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == PARM_DECL)\n \t{\n-\t  i = ipa_method_tree_map (mt, TREE_OPERAND (stmt, 0));\n+\t  i = ipa_method_tree_map (mt, GIMPLE_STMT_OPERAND (stmt, 0));\n \t  if (i >= 0)\n             ipa_method_modify_set (mt, i, true);\n \t}"}, {"sha": "bd1d72b75067368ee0ba3664d05c79ae3de00f85", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -412,11 +412,11 @@ scan_function (tree *tp,\n       *walk_subtrees = 0;\n       break;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       {\n \t/* First look on the lhs and see what variable is stored to */\n-\ttree lhs = TREE_OPERAND (t, 0);\n-\ttree rhs = TREE_OPERAND (t, 1);\n+\ttree lhs = GIMPLE_STMT_OPERAND (t, 0);\n+\ttree rhs = GIMPLE_STMT_OPERAND (t, 1);\n \tcheck_lhs_var (local, lhs);\n \n \t/* For the purposes of figuring out what the cast affects */"}, {"sha": "9780acf74700cc0cef3b43f2ecee562397509e6d", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -494,11 +494,11 @@ scan_for_static_refs (tree *tp,\n       *walk_subtrees = 0;\n       break;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       {\n \t/* First look on the lhs and see what variable is stored to */\n-\ttree lhs = TREE_OPERAND (t, 0);\n-\ttree rhs = TREE_OPERAND (t, 1);\n+\ttree lhs = GIMPLE_STMT_OPERAND (t, 0);\n+\ttree rhs = GIMPLE_STMT_OPERAND (t, 1);\n \tcheck_lhs_var (local, lhs);\n \n \t/* For the purposes of figuring out what the cast affects */"}, {"sha": "0b0c19a7e91de8adbdc264667430936b47f48eab", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1184,11 +1184,11 @@ scan_for_refs (tree *tp, int *walk_subtrees, void *data)\n       *walk_subtrees = 0;\n       break;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       {\n \t/* First look on the lhs and see what variable is stored to */\n-\ttree lhs = TREE_OPERAND (t, 0);\n-\ttree rhs = TREE_OPERAND (t, 1);\n+\ttree lhs = GIMPLE_STMT_OPERAND (t, 0);\n+\ttree rhs = GIMPLE_STMT_OPERAND (t, 1);\n \n \tcheck_lhs_var (lhs);\n  \tcheck_cast (TREE_TYPE (lhs), rhs);"}, {"sha": "76d299f947f96d2be8f635cf6dcf5a348718ffab", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -120,6 +120,9 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n       *expr_p = java_replace_reference (*expr_p, /* want_lvalue */ false);\n       return GS_UNHANDLED;\n \n+      /* We don't handle GIMPLE_MODIFY_STMT, as MODIFY_EXPRs with java\n+         semantics should only be generated by the front-end, and never\n+         by anything after gimplification.  */\n     case MODIFY_EXPR:\n       return java_gimplify_modify_expr (expr_p, pre_p, post_p);\n \n@@ -326,7 +329,7 @@ java_gimplify_modify_expr (tree *modify_expr_p, tree *pre_p, tree *post_p)\n     {\n       tree new_lhs = java_replace_reference (lhs, /* want_lvalue */ true);\n       tree new_rhs = build1 (NOP_EXPR, TREE_TYPE (new_lhs), rhs);\n-      modify_expr = build2 (MODIFY_EXPR, TREE_TYPE (new_lhs),\n+      modify_expr = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (new_lhs),\n \t\t\t    new_lhs, new_rhs);\n       modify_expr = build1 (NOP_EXPR, lhs_type, modify_expr);\n     }\n@@ -424,7 +427,7 @@ java_gimplify_new_array_init (tree exp)\n \n   tree array_ptr_type = build_pointer_type (array_type);\n   tree tmp = create_tmp_var (array_ptr_type, \"array\");\n-  tree body = build2 (MODIFY_EXPR, array_ptr_type, tmp,\n+  tree body = build2 (GIMPLE_MODIFY_STMT, array_ptr_type, tmp,\n \t\t      build_new_array (element_type, length));\n \n   int index = 0;\n@@ -437,7 +440,7 @@ java_gimplify_new_array_init (tree exp)\n       tree lhs = build3 (COMPONENT_REF, TREE_TYPE (data_field),    \n \t\t\t build_java_indirect_ref (array_type, tmp, 0),\n \t\t\t data_field, NULL_TREE);\n-      tree assignment = build2 (MODIFY_EXPR, element_type,\n+      tree assignment = build2 (GIMPLE_MODIFY_STMT, element_type,\n \t\t\t\tbuild4 (ARRAY_REF, element_type, lhs,\n \t\t\t\t\tbuild_int_cst (NULL_TREE, index++),\n \t\t\t\t\tNULL_TREE, NULL_TREE),"}, {"sha": "a7bfa38eb574e7cf04bab82b872c97c4bb94c193", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -725,7 +725,8 @@ struct lang_identifier GTY(())\n /* The resulting tree type.  */\n union lang_tree_node \n   GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n+       chain_next (\"(GIMPLE_STMT_P (&%h.generic) ? (union lang_tree_node *) 0 : (union lang_tree_node *)TREE_CHAIN (&%h.generic))\")))\n+\n {\n   union tree_node GTY ((tag (\"0\"), \n \t\t\tdesc (\"tree_node_structure (&%h)\"))) \n@@ -1881,12 +1882,12 @@ enum\n \n /* In an EXPR_WITH_FILE_LOCATION node.  */\n #define EXPR_WFL_EMIT_LINE_NOTE(NODE) \\\n-  (EXPR_WITH_FILE_LOCATION_CHECK (NODE)->common.public_flag)\n+  (EXPR_WITH_FILE_LOCATION_CHECK (NODE)->base.public_flag)\n #undef EXPR_WFL_NODE\n #define EXPR_WFL_NODE(NODE) \\\n   TREE_OPERAND (EXPR_WITH_FILE_LOCATION_CHECK (NODE), 0)\n #ifdef USE_MAPPED_LOCATION\n-#define EXPR_WFL_LINECOL(NODE) ((NODE)->exp.locus)\n+#define EXPR_WFL_LINECOL(NODE) EXPR_LOCUS(NODE)\n #define EXPR_WFL_FILENAME(NODE) EXPR_FILENAME (NODE)\n #define EXPR_WFL_LINENO(NODE) EXPR_LINENO (NODE)\n extern tree build_expr_wfl (tree, source_location);"}, {"sha": "0eb3286503b491e99fd6e5498f753abe2c5cd5d6", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1540,9 +1540,10 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n   add_referenced_var (resvar);\n \n   /* Start at 0.  */\n-  stmt = build2 (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n+  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n+      \t\t integer_zero_node);\n   name = make_ssa_name (resvar, stmt);\n-  TREE_OPERAND (stmt, 0) = name;\n+  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n   tsi = tsi_last (stmts);\n   tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n@@ -1555,20 +1556,20 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n \t  \n \t  /* newname = coefficient * induction_variable */\n \t  coeffmult = build_int_cst (type, LBV_COEFFICIENTS (lbv)[i]);\n-\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n \t\t\t fold_build2 (MULT_EXPR, type, iv, coeffmult));\n \n \t  newname = make_ssa_name (resvar, stmt);\n-\t  TREE_OPERAND (stmt, 0) = newname;\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n \t  fold_stmt (&stmt);\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t  /* name = name + newname */\n-\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n \t\t\t build2 (PLUS_EXPR, type, name, newname));\n \t  name = make_ssa_name (resvar, stmt);\n-\t  TREE_OPERAND (stmt, 0) = name;\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n@@ -1580,10 +1581,10 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n   if (LBV_DENOMINATOR (lbv) != 1)\n     {\n       tree denominator = build_int_cst (type, LBV_DENOMINATOR (lbv));\n-      stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n \t\t     build2 (CEIL_DIV_EXPR, type, name, denominator));\n       name = make_ssa_name (resvar, stmt);\n-      TREE_OPERAND (stmt, 0) = name;\n+      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n       fold_stmt (&stmt);\n       tsi = tsi_last (stmts);\n       tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n@@ -1631,9 +1632,10 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n   for (; lle != NULL; lle = LLE_NEXT (lle))\n     {\n       /* Start at name = 0.  */\n-      stmt = build2 (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n+      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n+\t  \t     integer_zero_node);\n       name = make_ssa_name (resvar, stmt);\n-      TREE_OPERAND (stmt, 0) = name;\n+      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n       fold_stmt (&stmt);\n       tsi = tsi_last (stmts);\n       tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n@@ -1662,18 +1664,18 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t}\n \n \t      /* newname = mult */\n-\t      stmt = build2 (MODIFY_EXPR, void_type_node, resvar, mult);\n+\t      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar, mult);\n \t      newname = make_ssa_name (resvar, stmt);\n-\t      TREE_OPERAND (stmt, 0) = newname;\n+\t      GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n \t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t      /* name = name + newname */\n-\t      stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n \t\t\t     build2 (PLUS_EXPR, type, name, newname));\n \t      name = make_ssa_name (resvar, stmt);\n-\t      TREE_OPERAND (stmt, 0) = name;\n+\t      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n@@ -1703,18 +1705,18 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t}\n \n \t      /* newname = mult */\n-\t      stmt = build2 (MODIFY_EXPR, void_type_node, resvar, mult);\n+\t      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar, mult);\n \t      newname = make_ssa_name (resvar, stmt);\n-\t      TREE_OPERAND (stmt, 0) = newname;\n+\t      GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n \t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t      /* name = name + newname */\n-\t      stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n \t\t\t     build2 (PLUS_EXPR, type, name, newname));\n \t      name = make_ssa_name (resvar, stmt);\n-\t      TREE_OPERAND (stmt, 0) = name;\n+\t      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n@@ -1725,11 +1727,11 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n          name = name + constant.  */\n       if (LLE_CONSTANT (lle) != 0)\n \t{\n-\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n \t\t\t build2 (PLUS_EXPR, type, name, \n \t\t\t         build_int_cst (type, LLE_CONSTANT (lle))));\n \t  name = make_ssa_name (resvar, stmt);\n-\t  TREE_OPERAND (stmt, 0) = name;\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n@@ -1739,11 +1741,11 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n          name = name + linear offset.  */\n       if (LLE_CONSTANT (offset) != 0)\n \t{\n-\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n \t\t\t build2 (PLUS_EXPR, type, name, \n \t\t\t         build_int_cst (type, LLE_CONSTANT (offset))));\n \t  name = make_ssa_name (resvar, stmt);\n-\t  TREE_OPERAND (stmt, 0) = name;\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n@@ -1755,11 +1757,11 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t  stmt = build_int_cst (type, LLE_DENOMINATOR (lle));\n \t  stmt = build2 (wrap == MAX_EXPR ? CEIL_DIV_EXPR : FLOOR_DIV_EXPR,\n \t\t\t type, name, stmt);\n-\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar, stmt);\n+\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar, stmt);\n \n \t  /* name = {ceil, floor}(name/denominator) */\n \t  name = make_ssa_name (resvar, stmt);\n-\t  TREE_OPERAND (stmt, 0) = name;\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \t}\n@@ -1775,10 +1777,10 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n     {\n       tree op1 = VEC_index (tree, results, 0);\n       tree op2 = VEC_index (tree, results, 1);\n-      stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n \t\t     build2 (wrap, type, op1, op2));\n       name = make_ssa_name (resvar, stmt);\n-      TREE_OPERAND (stmt, 0) = name;\n+      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n       tsi = tsi_last (stmts);\n       tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n     }\n@@ -1893,10 +1895,10 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t test,  and let redundancy elimination sort it out.  */\n       inc_stmt = build2 (PLUS_EXPR, type, \n \t\t\t ivvar, build_int_cst (type, LL_STEP (newloop)));\n-      inc_stmt = build2 (MODIFY_EXPR, void_type_node, SSA_NAME_VAR (ivvar),\n-\t\t\t inc_stmt);\n+      inc_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t  \t\t SSA_NAME_VAR (ivvar), inc_stmt);\n       ivvarinced = make_ssa_name (SSA_NAME_VAR (ivvar), inc_stmt);\n-      TREE_OPERAND (inc_stmt, 0) = ivvarinced;\n+      GIMPLE_STMT_OPERAND (inc_stmt, 0) = ivvarinced;\n       bsi = bsi_for_stmt (exitcond);\n       bsi_insert_before (&bsi, inc_stmt, BSI_SAME_STMT);\n \n@@ -2185,9 +2187,9 @@ replace_uses_equiv_to_x_with_y (struct loop *loop, tree stmt, tree x,\n       var = create_tmp_var (TREE_TYPE (use), \"perfecttmp\");\n       add_referenced_var (var);\n       val = force_gimple_operand_bsi (firstbsi, val, false, NULL);\n-      setstmt = build2 (MODIFY_EXPR, void_type_node, var, val);\n+      setstmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, var, val);\n       var = make_ssa_name (var, setstmt);\n-      TREE_OPERAND (setstmt, 0) = var;\n+      GIMPLE_STMT_OPERAND (setstmt, 0) = var;\n       bsi_insert_before (firstbsi, setstmt, BSI_SAME_STMT);\n       update_stmt (setstmt);\n       SET_USE (use_p, var);\n@@ -2224,12 +2226,12 @@ can_put_in_inner_loop (struct loop *inner, tree stmt)\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n   \n-  gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n+  gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n   if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS)\n-      || !expr_invariant_in_loop_p (inner, TREE_OPERAND (stmt, 1)))\n+      || !expr_invariant_in_loop_p (inner, GIMPLE_STMT_OPERAND (stmt, 1)))\n     return false;\n   \n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, TREE_OPERAND (stmt, 0))\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, GIMPLE_STMT_OPERAND (stmt, 0))\n     {\n       if (!exit_phi_for_loop_p (inner, USE_STMT (use_p)))\n \t{\n@@ -2252,7 +2254,7 @@ can_put_after_inner_loop (struct loop *loop, tree stmt)\n   if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return false;\n   \n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, TREE_OPERAND (stmt, 0))\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, GIMPLE_STMT_OPERAND (stmt, 0))\n     {\n       if (!exit_phi_for_loop_p (loop, USE_STMT (use_p)))\n \t{\n@@ -2310,12 +2312,12 @@ can_convert_to_perfect_nest (struct loop *loop)\n \t\t win we get from rearranging the memory walk\n \t\t the loop is doing so that it has better\n \t\t cache behavior.  */\n-\t      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t\t{\n \t\t  use_operand_p use_a, use_b;\n \t\t  imm_use_iterator imm_iter;\n \t\t  ssa_op_iter op_iter, op_iter1;\n-\t\t  tree op0 = TREE_OPERAND (stmt, 0);\n+\t\t  tree op0 = GIMPLE_STMT_OPERAND (stmt, 0);\n \t\t  tree scev = instantiate_parameters\n \t\t    (loop, analyze_scalar_evolution (loop, op0));\n \n@@ -2538,10 +2540,10 @@ perfect_nestify (struct loop *loop,\n   exit_condition = get_loop_exit_condition (newloop);\n   uboundvar = create_tmp_var (integer_type_node, \"uboundvar\");\n   add_referenced_var (uboundvar);\n-  stmt = build2 (MODIFY_EXPR, void_type_node, uboundvar, \n+  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, uboundvar, \n \t\t VEC_index (tree, ubounds, 0));\n   uboundvar = make_ssa_name (uboundvar, stmt);\n-  TREE_OPERAND (stmt, 0) = uboundvar;\n+  GIMPLE_STMT_OPERAND (stmt, 0) = uboundvar;\n \n   if (insert_after)\n     bsi_insert_after (&bsi, stmt, BSI_SAME_STMT);"}, {"sha": "5b0e09f471c2b2eeb87a5fd00d5a05c2d1470720", "filename": "gcc/langhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -577,7 +577,7 @@ lhd_omp_predetermined_sharing (tree decl ATTRIBUTE_UNUSED)\n tree\n lhd_omp_assignment (tree clause ATTRIBUTE_UNUSED, tree dst, tree src)\n {\n-  return build2 (MODIFY_EXPR, void_type_node, dst, src);\n+  return build2 (GIMPLE_MODIFY_STMT, void_type_node, dst, src);\n }\n \n /* Register language specific type size variables as potentially OpenMP"}, {"sha": "625ac37496784a82138952381b02d22eeca79cbe", "filename": "gcc/omp-low.c", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -157,11 +157,11 @@ extract_omp_for_data (tree for_stmt, struct omp_for_data *fd)\n   fd->pre = NULL;\n \n   t = OMP_FOR_INIT (for_stmt);\n-  gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n-  fd->v = TREE_OPERAND (t, 0);\n+  gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+  fd->v = GIMPLE_STMT_OPERAND (t, 0);\n   gcc_assert (DECL_P (fd->v));\n   gcc_assert (TREE_CODE (TREE_TYPE (fd->v)) == INTEGER_TYPE);\n-  fd->n1 = TREE_OPERAND (t, 1);\n+  fd->n1 = GIMPLE_STMT_OPERAND (t, 1);\n \n   t = OMP_FOR_COND (for_stmt);\n   fd->cond_code = TREE_CODE (t);\n@@ -187,9 +187,9 @@ extract_omp_for_data (tree for_stmt, struct omp_for_data *fd)\n     }\n \n   t = OMP_FOR_INCR (fd->for_stmt);\n-  gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n-  gcc_assert (TREE_OPERAND (t, 0) == fd->v);\n-  t = TREE_OPERAND (t, 1);\n+  gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+  gcc_assert (GIMPLE_STMT_OPERAND (t, 0) == fd->v);\n+  t = GIMPLE_STMT_OPERAND (t, 1);\n   gcc_assert (TREE_OPERAND (t, 0) == fd->v);\n   switch (TREE_CODE (t))\n     {\n@@ -1680,7 +1680,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t      x = built_in_decls[BUILT_IN_ALLOCA];\n \t      x = build_function_call_expr (x, args);\n \t      x = fold_convert (TREE_TYPE (ptr), x);\n-\t      x = build2 (MODIFY_EXPR, void_type_node, ptr, x);\n+\t      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ptr, x);\n \t      gimplify_and_add (x, ilist);\n \t    }\n \t  else if (is_reference (var))\n@@ -1716,7 +1716,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t\t  x = fold_convert (TREE_TYPE (new_var), x);\n \t\t}\n \n-\t      x = build2 (MODIFY_EXPR, void_type_node, new_var, x);\n+\t      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, new_var, x);\n \t      gimplify_and_add (x, ilist);\n \n \t      new_var = build_fold_indirect_ref (new_var);\n@@ -1799,7 +1799,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t\t{\n \t\t  x = omp_reduction_init (c, TREE_TYPE (new_var));\n \t\t  gcc_assert (TREE_CODE (TREE_TYPE (new_var)) != ARRAY_TYPE);\n-\t\t  x = build2 (MODIFY_EXPR, void_type_node, new_var, x);\n+\t\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, new_var, x);\n \t\t  gimplify_and_add (x, ilist);\n \t\t}\n \t      break;\n@@ -1964,7 +1964,7 @@ lower_reduction_clauses (tree clauses, tree *stmt_list, omp_context *ctx)\n \t{\n \t  x = build2 (code, TREE_TYPE (ref), ref, new_var);\n \t  ref = build_outer_var_ref (var, ctx);\n-\t  x = build2 (MODIFY_EXPR, void_type_node, ref, x);\n+\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ref, x);\n \t  append_to_statement_list (x, &sub_list);\n \t}\n     }\n@@ -2003,7 +2003,7 @@ lower_copyprivate_clauses (tree clauses, tree *slist, tree *rlist,\n       ref = build_sender_ref (var, ctx);\n       x = (ctx->is_nested) ? lookup_decl_in_outer_ctx (var, ctx) : var;\n       x = by_ref ? build_fold_addr_expr (x) : x;\n-      x = build2 (MODIFY_EXPR, void_type_node, ref, x);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ref, x);\n       gimplify_and_add (x, slist);\n \n       ref = build_receiver_ref (var, by_ref, ctx);\n@@ -2084,14 +2084,14 @@ lower_send_clauses (tree clauses, tree *ilist, tree *olist, omp_context *ctx)\n \t{\n \t  ref = build_sender_ref (val, ctx);\n \t  x = by_ref ? build_fold_addr_expr (var) : var;\n-\t  x = build2 (MODIFY_EXPR, void_type_node, ref, x);\n+\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ref, x);\n \t  gimplify_and_add (x, ilist);\n \t}\n \n       if (do_out)\n \t{\n \t  ref = build_sender_ref (val, ctx);\n-\t  x = build2 (MODIFY_EXPR, void_type_node, var, ref);\n+\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, var, ref);\n \t  gimplify_and_add (x, olist);\n \t}\n     }\n@@ -2128,17 +2128,17 @@ lower_send_shared_vars (tree *ilist, tree *olist, omp_context *ctx)\n \t{\n \t  x = build_sender_ref (ovar, ctx);\n \t  var = build_fold_addr_expr (var);\n-\t  x = build2 (MODIFY_EXPR, void_type_node, x, var);\n+\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, x, var);\n \t  gimplify_and_add (x, ilist);\n \t}\n       else\n \t{\n \t  x = build_sender_ref (ovar, ctx);\n-\t  x = build2 (MODIFY_EXPR, void_type_node, x, var);\n+\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, x, var);\n \t  gimplify_and_add (x, ilist);\n \n \t  x = build_sender_ref (ovar, ctx);\n-\t  x = build2 (MODIFY_EXPR, void_type_node, var, x);\n+\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, var, x);\n \t  gimplify_and_add (x, olist);\n \t}\n     }\n@@ -2236,13 +2236,13 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t  si = bsi_start (then_bb);\n \t  t = build1 (LABEL_EXPR, void_type_node, then_lab);\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n-\t  t = build2 (MODIFY_EXPR, void_type_node, tmp, val);\n+\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp, val);\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n \t  si = bsi_start (else_bb);\n \t  t = build1 (LABEL_EXPR, void_type_node, else_lab);\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n-\t  t = build2 (MODIFY_EXPR, void_type_node, tmp, \n+\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp, \n \t              build_int_cst (unsigned_type_node, 1));\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n@@ -2483,19 +2483,20 @@ expand_omp_parallel (struct omp_region *region)\n \n \t      gcc_assert (!bsi_end_p (si));\n \t      stmt = bsi_stmt (si);\n-\t      if (TREE_CODE (stmt) != MODIFY_EXPR)\n+\t      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \t\tcontinue;\n \n-\t      arg = TREE_OPERAND (stmt, 1);\n+\t      arg = GIMPLE_STMT_OPERAND (stmt, 1);\n \t      STRIP_NOPS (arg);\n \t      if (TREE_CODE (arg) == ADDR_EXPR\n \t\t  && TREE_OPERAND (arg, 0)\n \t\t     == OMP_PARALLEL_DATA_ARG (entry_stmt))\n \t\t{\n-\t\t  if (TREE_OPERAND (stmt, 0) == DECL_ARGUMENTS (child_fn))\n+\t\t  if (GIMPLE_STMT_OPERAND (stmt, 0)\n+\t\t      == DECL_ARGUMENTS (child_fn))\n \t\t    bsi_remove (&si, true);\n \t\t  else\n-\t\t    TREE_OPERAND (stmt, 1) = DECL_ARGUMENTS (child_fn);\n+\t\t    GIMPLE_STMT_OPERAND (stmt, 1) = DECL_ARGUMENTS (child_fn);\n \t\t  break;\n \t\t}\n \t    }\n@@ -2651,11 +2652,11 @@ expand_omp_for_generic (struct omp_region *region,\n   /* Iteration setup for sequential loop goes in L0_BB.  */\n   list = alloc_stmt_list ();\n   t = fold_convert (type, istart0);\n-  t = build2 (MODIFY_EXPR, void_type_node, fd->v, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = fold_convert (type, iend0);\n-  t = build2 (MODIFY_EXPR, void_type_node, iend, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, iend, t);\n   gimplify_and_add (t, &list);\n \n   si = bsi_start (l0_bb);\n@@ -2677,7 +2678,7 @@ expand_omp_for_generic (struct omp_region *region,\n   list = alloc_stmt_list ();\n \n   t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build2 (MODIFY_EXPR, void_type_node, fd->v, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n   gimplify_and_add (t, &list);\n   \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, iend);\n@@ -2856,7 +2857,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   t = fold_convert (type, s0);\n   t = build2 (MULT_EXPR, type, t, fd->step);\n   t = build2 (PLUS_EXPR, type, t, fd->n1);\n-  t = build2 (MODIFY_EXPR, void_type_node, fd->v, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = fold_convert (type, e0);\n@@ -2871,7 +2872,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   list = alloc_stmt_list ();\n \n   t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build2 (MODIFY_EXPR, void_type_node, fd->v, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, e);\n@@ -3040,7 +3041,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   t = fold_convert (type, s0);\n   t = build2 (MULT_EXPR, type, t, fd->step);\n   t = build2 (PLUS_EXPR, type, t, fd->n1);\n-  t = build2 (MODIFY_EXPR, void_type_node, fd->v, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = fold_convert (type, e0);\n@@ -3056,7 +3057,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   list = alloc_stmt_list ();\n \n   t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build2 (MODIFY_EXPR, void_type_node, fd->v, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, e);\n@@ -3075,7 +3076,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n \n   t = build_int_cst (type, 1);\n   t = build2 (PLUS_EXPR, type, trip, t);\n-  t = build2 (MODIFY_EXPR, void_type_node, trip, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, trip, t);\n   gimplify_and_add (t, &list);\n \n   si = bsi_start (trip_update_bb);\n@@ -3224,7 +3225,7 @@ expand_omp_sections (struct omp_region *region)\n       t = tree_cons (NULL, t, NULL);\n       u = built_in_decls[BUILT_IN_GOMP_SECTIONS_START];\n       t = build_function_call_expr (u, t);\n-      t = build2 (MODIFY_EXPR, void_type_node, v, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, v, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n     }\n   bsi_remove (&si, true);\n@@ -3293,7 +3294,7 @@ expand_omp_sections (struct omp_region *region)\n \n       t = built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT];\n       t = build_function_call_expr (t, NULL);\n-      t = build2 (MODIFY_EXPR, void_type_node, v, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, v, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n       bsi_remove (&si, true);\n     }\n@@ -3731,7 +3732,7 @@ lower_omp_single_copy (tree single_stmt, tree *pre_p, omp_context *ctx)\n   t = built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_START];\n   t = build_function_call_expr (t, NULL);\n   t = fold_convert (ptr_type, t);\n-  t = build2 (MODIFY_EXPR, void_type_node, ctx->receiver_decl, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, ctx->receiver_decl, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build2 (EQ_EXPR, boolean_type_node, ctx->receiver_decl,\n@@ -4048,15 +4049,15 @@ lower_omp_for (tree *stmt_p, omp_context *ctx)\n \n      We just need to make sure that VAL1, VAL2 and VAL3 are lowered\n      using the .omp_data_s mapping, if needed.  */\n-  rhs_p = &TREE_OPERAND (OMP_FOR_INIT (stmt), 1);\n+  rhs_p = &GIMPLE_STMT_OPERAND (OMP_FOR_INIT (stmt), 1);\n   if (!is_gimple_min_invariant (*rhs_p))\n     *rhs_p = get_formal_tmp_var (*rhs_p, body_p);\n \n   rhs_p = &TREE_OPERAND (OMP_FOR_COND (stmt), 1);\n   if (!is_gimple_min_invariant (*rhs_p))\n     *rhs_p = get_formal_tmp_var (*rhs_p, body_p);\n \n-  rhs_p = &TREE_OPERAND (TREE_OPERAND (OMP_FOR_INCR (stmt), 1), 1);\n+  rhs_p = &TREE_OPERAND (GIMPLE_STMT_OPERAND (OMP_FOR_INCR (stmt), 1), 1);\n   if (!is_gimple_min_invariant (*rhs_p))\n     *rhs_p = get_formal_tmp_var (*rhs_p, body_p);\n \n@@ -4144,7 +4145,7 @@ lower_omp_parallel (tree *stmt_p, omp_context *ctx)\n       t = build_fold_addr_expr (ctx->sender_decl);\n       /* fixup_child_record_type might have changed receiver_decl's type.  */\n       t = fold_convert (TREE_TYPE (ctx->receiver_decl), t);\n-      t = build2 (MODIFY_EXPR, void_type_node, ctx->receiver_decl, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, ctx->receiver_decl, t);\n       append_to_statement_list (t, &new_body);\n     }\n "}, {"sha": "4b5344b7481f8f5eee1317934ed46a41d4b68967", "filename": "gcc/predict.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -902,9 +902,10 @@ expr_expected_value (tree expr, bitmap visited)\n \t    }\n \t  return val;\n \t}\n-      if (TREE_CODE (def) != MODIFY_EXPR || TREE_OPERAND (def, 0) != expr)\n+      if (TREE_CODE (def) != GIMPLE_MODIFY_STMT\n+\t  || GIMPLE_STMT_OPERAND (def, 0) != expr)\n \treturn NULL;\n-      return expr_expected_value (TREE_OPERAND (def, 1), visited);\n+      return expr_expected_value (GIMPLE_STMT_OPERAND (def, 1), visited);\n     }\n   else if (TREE_CODE (expr) == CALL_EXPR)\n     {\n@@ -968,15 +969,15 @@ strip_builtin_expect (void)\n \t  tree fndecl;\n \t  tree arglist;\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR\n-\t      && (fndecl = get_callee_fndecl (TREE_OPERAND (stmt, 1)))\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR\n+\t      && (fndecl = get_callee_fndecl (GIMPLE_STMT_OPERAND (stmt, 1)))\n \t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n \t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n-\t      && (arglist = TREE_OPERAND (TREE_OPERAND (stmt, 1), 1))\n+\t      && (arglist = TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 1))\n \t      && TREE_CHAIN (arglist))\n \t    {\n-\t      TREE_OPERAND (stmt, 1) = TREE_VALUE (arglist);\n+\t      GIMPLE_STMT_OPERAND (stmt, 1) = TREE_VALUE (arglist);\n \t      update_stmt (stmt);\n \t    }\n \t}\n@@ -1167,8 +1168,8 @@ apply_return_prediction (int *heads)\n   return_val = TREE_OPERAND (return_stmt, 0);\n   if (!return_val)\n     return;\n-  if (TREE_CODE (return_val) == MODIFY_EXPR)\n-    return_val = TREE_OPERAND (return_val, 1);\n+  if (TREE_CODE (return_val) == GIMPLE_MODIFY_STMT)\n+    return_val = GIMPLE_STMT_OPERAND (return_val, 1);\n   if (TREE_CODE (return_val) != SSA_NAME\n       || !SSA_NAME_DEF_STMT (return_val)\n       || TREE_CODE (SSA_NAME_DEF_STMT (return_val)) != PHI_NODE)\n@@ -1221,10 +1222,10 @@ tree_bb_level_predictions (void)\n \t  tree stmt = bsi_stmt (bsi);\n \t  switch (TREE_CODE (stmt))\n \t    {\n-\t      case MODIFY_EXPR:\n-\t\tif (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)\n+\t      case GIMPLE_MODIFY_STMT:\n+\t\tif (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR)\n \t\t  {\n-\t\t    stmt = TREE_OPERAND (stmt, 1);\n+\t\t    stmt = GIMPLE_STMT_OPERAND (stmt, 1);\n \t\t    goto call_expr;\n \t\t  }\n \t\tbreak;\n@@ -1306,8 +1307,9 @@ tree_estimate_probability (void)\n \t\t{\n \t\t  tree stmt = bsi_stmt (bi);\n \t\t  if ((TREE_CODE (stmt) == CALL_EXPR\n-\t\t       || (TREE_CODE (stmt) == MODIFY_EXPR\n-\t\t\t   && TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR))\n+\t\t       || (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t\t\t   && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1))\n+\t\t\t      == CALL_EXPR))\n \t\t      /* Constant and pure calls are hardly used to signalize\n \t\t\t something exceptional.  */\n \t\t      && TREE_SIDE_EFFECTS (stmt))"}, {"sha": "1ed17de864117180a759e4413e7d0ad53d5ed0b1", "filename": "gcc/print-tree.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -263,7 +263,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       if (indent <= 4)\n \tprint_node_brief (file, \"type\", TREE_TYPE (node), indent + 4);\n     }\n-  else\n+  else if (!GIMPLE_TUPLE_P (node))\n     {\n       print_node (file, \"type\", TREE_TYPE (node), indent + 4);\n       if (TREE_TYPE (node))\n@@ -679,6 +679,18 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       print_node (file, \"chain\", TREE_CHAIN (node), indent + 4);\n       break;\n \n+    case tcc_gimple_stmt:\n+      len = TREE_CODE_LENGTH (TREE_CODE (node));\n+\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  char temp[10];\n+\n+\t  sprintf (temp, \"arg %d\", i);\n+\t  print_node (file, temp, GIMPLE_STMT_OPERAND (node, i), indent + 4);\n+\t}\n+      break;\n+\n     case tcc_constant:\n     case tcc_exceptional:\n       switch (TREE_CODE (node))"}, {"sha": "819d9be85b6b8bb517ae1742abb0167e1b8c79da", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1362,6 +1362,9 @@ expand_expr_stmt (tree exp)\n   tree type;\n \n   value = expand_expr (exp, const0_rtx, VOIDmode, 0);\n+  if (GIMPLE_TUPLE_P (exp))\n+    type = void_type_node;\n+  else\n   type = TREE_TYPE (exp);\n \n   /* If all we do is reference a volatile value in memory,\n@@ -1415,6 +1418,7 @@ warn_if_unused_value (tree exp, location_t locus)\n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n     case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n     case INIT_EXPR:\n     case TARGET_EXPR:\n     case CALL_EXPR:\n@@ -1582,10 +1586,10 @@ expand_return (tree retval)\n       expand_null_return ();\n       return;\n     }\n-  else if ((TREE_CODE (retval) == MODIFY_EXPR\n+  else if ((TREE_CODE (retval) == GIMPLE_MODIFY_STMT\n \t    || TREE_CODE (retval) == INIT_EXPR)\n-\t   && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n-    retval_rhs = TREE_OPERAND (retval, 1);\n+\t   && TREE_CODE (GENERIC_TREE_OPERAND (retval, 0)) == RESULT_DECL)\n+    retval_rhs = GENERIC_TREE_OPERAND (retval, 1);\n   else\n     retval_rhs = retval;\n \n@@ -1604,7 +1608,7 @@ expand_return (tree retval)\n      (and in expand_call).  */\n \n   else if (retval_rhs != 0\n-\t   && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n+\t   && TYPE_MODE (GENERIC_TREE_TYPE (retval_rhs)) == BLKmode\n \t   && REG_P (result_rtl))\n     {\n       int i;"}, {"sha": "e4733a2012f5a3979adf5c87e7c97f35d8ee87a1", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -314,8 +314,8 @@ factor_computed_gotos (void)\n \t    }\n \n \t  /* Copy the original computed goto's destination into VAR.  */\n-\t  assignment = build2 (MODIFY_EXPR, ptr_type_node,\n-\t\t\t       var, GOTO_DESTINATION (last));\n+\t  assignment = build2_gimple (GIMPLE_MODIFY_STMT,\n+\t\t\t              var, GOTO_DESTINATION (last));\n \t  bsi_insert_before (&bsi, assignment, BSI_SAME_STMT);\n \n \t  /* And re-vector the computed goto to the new destination.  */\n@@ -501,11 +501,14 @@ make_edges (void)\n \t      break;\n \n \t    case MODIFY_EXPR:\n+\t      gcc_unreachable ();\n+\n+\t    case GIMPLE_MODIFY_STMT:\n \t      if (is_ctrl_altering_stmt (last))\n \t\t{\n-\t\t  /* A MODIFY_EXPR may have a CALL_EXPR on its RHS and the\n-\t\t     CALL_EXPR may have an abnormal edge.  Search the RHS for\n-\t\t     this case and create any required edges.  */\n+\t\t  /* A GIMPLE_MODIFY_STMT may have a CALL_EXPR on its RHS and\n+\t\t     the CALL_EXPR may have an abnormal edge.  Search the RHS\n+\t\t     for this case and create any required edges.  */\n \t\t  if (tree_can_make_abnormal_goto (last))\n \t\t    make_abnormal_goto_edges (bb, true);  \n \n@@ -1330,7 +1333,7 @@ tree_merge_blocks (basic_block a, basic_block b)\n \t     with ordering of phi nodes.  This is because A is the single\n \t     predecessor of B, therefore results of the phi nodes cannot\n \t     appear as arguments of the phi nodes.  */\n-\t  copy = build2 (MODIFY_EXPR, void_type_node, def, use);\n+\t  copy = build2_gimple (GIMPLE_MODIFY_STMT, def, use);\n \t  bsi_insert_after (&bsi, copy, BSI_NEW_STMT);\n \t  SET_PHI_RESULT (phi, NULL_TREE);\n \t  SSA_NAME_DEF_STMT (def) = copy;\n@@ -1559,9 +1562,9 @@ remove_useless_stmts_cond (tree *stmt_p, struct rus_data *data)\n       else if (TREE_CODE (cond) == VAR_DECL || TREE_CODE (cond) == PARM_DECL)\n \t{\n \t  if (else_stmt\n-\t      && TREE_CODE (else_stmt) == MODIFY_EXPR\n-\t      && TREE_OPERAND (else_stmt, 0) == cond\n-\t      && integer_zerop (TREE_OPERAND (else_stmt, 1)))\n+\t      && TREE_CODE (else_stmt) == GIMPLE_MODIFY_STMT\n+\t      && GIMPLE_STMT_OPERAND (else_stmt, 0) == cond\n+\t      && integer_zerop (GIMPLE_STMT_OPERAND (else_stmt, 1)))\n \t    COND_EXPR_ELSE (*stmt_p) = alloc_stmt_list ();\n \t}\n       else if ((TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n@@ -1576,9 +1579,9 @@ remove_useless_stmts_cond (tree *stmt_p, struct rus_data *data)\n \t\t\t    : &COND_EXPR_ELSE (*stmt_p));\n \n \t  if (stmt\n-\t      && TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && TREE_OPERAND (stmt, 0) == TREE_OPERAND (cond, 0)\n-\t      && TREE_OPERAND (stmt, 1) == TREE_OPERAND (cond, 1))\n+\t      && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && GIMPLE_STMT_OPERAND (stmt, 0) == TREE_OPERAND (cond, 0)\n+\t      && GIMPLE_STMT_OPERAND (stmt, 1) == TREE_OPERAND (cond, 1))\n \t    *location = alloc_stmt_list ();\n \t}\n     }\n@@ -1871,6 +1874,9 @@ remove_useless_stmts_1 (tree *tp, struct rus_data *data)\n       break;\n \n     case MODIFY_EXPR:\n+      gcc_unreachable ();\n+\n+    case GIMPLE_MODIFY_STMT:\n       data->last_goto = NULL;\n       fold_stmt (tp);\n       op = get_call_expr_in (t);\n@@ -2508,8 +2514,8 @@ tree_can_make_abnormal_goto (tree t)\n {\n   if (computed_goto_p (t))\n     return true;\n-  if (TREE_CODE (t) == MODIFY_EXPR)\n-    t = TREE_OPERAND (t, 1);\n+  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+    t = GIMPLE_STMT_OPERAND (t, 1);\n   if (TREE_CODE (t) == WITH_SIZE_EXPR)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == CALL_EXPR)\n@@ -3011,9 +3017,9 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n \t  tree op = TREE_OPERAND (tmp, 0);\n \t  if (op && !is_gimple_val (op))\n \t    {\n-\t      gcc_assert (TREE_CODE (op) == MODIFY_EXPR);\n+\t      gcc_assert (TREE_CODE (op) == GIMPLE_MODIFY_STMT);\n \t      bsi_insert_before (bsi, op, BSI_NEW_STMT);\n-\t      TREE_OPERAND (tmp, 0) = TREE_OPERAND (op, 0);\n+\t      TREE_OPERAND (tmp, 0) = GIMPLE_STMT_OPERAND (op, 0);\n \t    }\n \t  bsi_prev (bsi);\n \t  return true;\n@@ -3232,7 +3238,10 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       break;\n \n     case MODIFY_EXPR:\n-      x = TREE_OPERAND (t, 0);\n+      gcc_unreachable ();\n+\n+    case GIMPLE_MODIFY_STMT:\n+      x = GIMPLE_STMT_OPERAND (t, 0);\n       if (TREE_CODE (x) == BIT_FIELD_REF\n \t  && is_gimple_reg (TREE_OPERAND (x, 0)))\n \t{\n@@ -3536,6 +3545,35 @@ verify_node_sharing (tree * tp, int *walk_subtrees, void *data)\n }\n \n \n+/* Helper function for verify_gimple_tuples.  */\n+\n+static tree\n+verify_gimple_tuples_1 (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n+{\n+  switch (TREE_CODE (*tp))\n+    {\n+    case MODIFY_EXPR:\n+      error (\"unexpected non-tuple\");\n+      debug_tree (*tp);\n+      gcc_unreachable ();\n+      return NULL_TREE;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Verify that there are no trees that should have been converted to\n+   gimple tuples.  Return true if T contains a node that should have\n+   been converted to a gimple tuple, but hasn't.  */\n+\n+static bool\n+verify_gimple_tuples (tree t)\n+{\n+  return walk_tree (&t, verify_gimple_tuples_1, NULL, NULL) != NULL;\n+}\n+\n /* Verify the GIMPLE statement chain.  */\n \n void\n@@ -3604,6 +3642,8 @@ verify_stmts (void)\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n \n+\t  err |= verify_gimple_tuples (stmt);\n+\n \t  if (bb_for_stmt (stmt) != bb)\n \t    {\n \t      error (\"bb_for_stmt (stmt) is set to a wrong basic block\");\n@@ -4570,7 +4610,8 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n   struct move_stmt_d *p = (struct move_stmt_d *) data;\n   tree t = *tp;\n \n-  if (p->block && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t))))\n+  if (p->block\n+      && (EXPR_P (t) || GIMPLE_STMT_P (t)))\n     TREE_BLOCK (t) = p->block;\n \n   if (OMP_DIRECTIVE_P (t)\n@@ -5638,7 +5679,7 @@ gimplify_val (block_stmt_iterator *bsi, tree type, tree exp)\n     return exp;\n \n   t = make_rename_temp (type, NULL);\n-  new_stmt = build2 (MODIFY_EXPR, type, t, exp);\n+  new_stmt = build2_gimple (GIMPLE_MODIFY_STMT, t, exp);\n \n   orig_stmt = bsi_stmt (*bsi);\n   SET_EXPR_LOCUS (new_stmt, EXPR_LOCUS (orig_stmt));"}, {"sha": "38b2101d33c281990534d474fa2c90e63ff50451", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -206,13 +206,13 @@ init_dont_simulate_again (void)\n \t\t since it's never used as an input to another computation.  */\n \t      dsa = true;\n \t      stmt = TREE_OPERAND (stmt, 0);\n-\t      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n+\t      if (!stmt || TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \t\tbreak;\n \t      /* FALLTHRU */\n \n-\t    case MODIFY_EXPR:\n-\t      dsa = !is_complex_reg (TREE_OPERAND (stmt, 0));\n-\t      rhs = TREE_OPERAND (stmt, 1);\n+\t    case GIMPLE_MODIFY_STMT:\n+\t      dsa = !is_complex_reg (GIMPLE_STMT_OPERAND (stmt, 0));\n+\t      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \t      break;\n \n \t    case COND_EXPR:\n@@ -267,11 +267,11 @@ complex_visit_stmt (tree stmt, edge *taken_edge_p ATTRIBUTE_UNUSED,\n   unsigned int ver;\n   tree lhs, rhs;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return SSA_PROP_VARYING;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n-  rhs = TREE_OPERAND (stmt, 1);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   /* These conditions should be satisfied due to the initial filter\n      set up in init_dont_simulate_again.  */\n@@ -532,7 +532,7 @@ set_component_ssa_name (tree ssa_name, bool imag_p, tree value)\n   \n   /* Do all the work to assign VALUE to COMP.  */\n   value = force_gimple_operand (value, &list, false, NULL);\n-  last = build2 (MODIFY_EXPR, TREE_TYPE (comp), comp, value);\n+  last = build2_gimple (GIMPLE_MODIFY_STMT, comp, value);\n   append_to_statement_list (last, &list);\n \n   gcc_assert (SSA_NAME_DEF_STMT (comp) == NULL);\n@@ -588,7 +588,7 @@ extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p,\n static void\n update_complex_components (block_stmt_iterator *bsi, tree stmt, tree r, tree i)\n {\n-  tree lhs = TREE_OPERAND (stmt, 0);\n+  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   tree list;\n \n   list = set_component_ssa_name (lhs, false, r);\n@@ -628,8 +628,8 @@ update_complex_assignment (block_stmt_iterator *bsi, tree r, tree i)\n   else if (gimple_in_ssa_p (cfun))\n     update_complex_components (bsi, stmt, r, i);\n   \n-  type = TREE_TYPE (TREE_OPERAND (mod, 1));\n-  TREE_OPERAND (mod, 1) = build2 (COMPLEX_EXPR, type, r, i);\n+  type = TREE_TYPE (GIMPLE_STMT_OPERAND (mod, 1));\n+  GIMPLE_STMT_OPERAND (mod, 1) = build2 (COMPLEX_EXPR, type, r, i);\n   update_stmt (stmt);\n }\n \n@@ -773,25 +773,24 @@ expand_complex_move (block_stmt_iterator *bsi, tree stmt, tree type,\n       i = extract_component (bsi, rhs, 1, false);\n \n       x = build1 (REALPART_EXPR, inner_type, unshare_expr (lhs));\n-      x = build2 (MODIFY_EXPR, inner_type, x, r);\n+      x = build2_gimple (GIMPLE_MODIFY_STMT, x, r);\n       bsi_insert_before (bsi, x, BSI_SAME_STMT);\n \n       if (stmt == bsi_stmt (*bsi))\n \t{\n \t  x = build1 (IMAGPART_EXPR, inner_type, unshare_expr (lhs));\n-\t  TREE_OPERAND (stmt, 0) = x;\n-\t  TREE_OPERAND (stmt, 1) = i;\n-\t  TREE_TYPE (stmt) = inner_type;\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = x;\n+\t  GIMPLE_STMT_OPERAND (stmt, 1) = i;\n \t}\n       else\n \t{\n \t  x = build1 (IMAGPART_EXPR, inner_type, unshare_expr (lhs));\n-\t  x = build2 (MODIFY_EXPR, inner_type, x, i);\n+\t  x = build2_gimple (GIMPLE_MODIFY_STMT, x, i);\n \t  bsi_insert_before (bsi, x, BSI_SAME_STMT);\n \n \t  stmt = bsi_stmt (*bsi);\n \t  gcc_assert (TREE_CODE (stmt) == RETURN_EXPR);\n-\t  TREE_OPERAND (stmt, 0) = lhs;\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = lhs;\n \t}\n \n       update_all_vops (stmt);\n@@ -894,7 +893,7 @@ expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n   args = tree_cons (NULL, ar, args);\n \n   stmt = bsi_stmt (*bsi);\n-  type = TREE_TYPE (TREE_OPERAND (stmt, 1));\n+  type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 1));\n \n   mode = TYPE_MODE (type);\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT);\n@@ -906,13 +905,13 @@ expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n     gcc_unreachable ();\n   fn = built_in_decls[bcode];\n \n-  TREE_OPERAND (stmt, 1)\n+  GIMPLE_STMT_OPERAND (stmt, 1)\n     = build3 (CALL_EXPR, type, build_fold_addr_expr (fn), args, NULL);\n   update_stmt (stmt);\n \n   if (gimple_in_ssa_p (cfun))\n     {\n-      tree lhs = TREE_OPERAND (stmt, 0);\n+      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n       type = TREE_TYPE (type);\n       update_complex_components (bsi, stmt,\n \t\t\t\t build1 (REALPART_EXPR, type, lhs),\n@@ -1122,9 +1121,9 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n \n      if (bb_true)\n        {\n-\t t1 = build2 (MODIFY_EXPR, inner_type, rr, tr);\n+\t t1 = build2_gimple (GIMPLE_MODIFY_STMT, rr, tr);\n \t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n-\t t1 = build2 (MODIFY_EXPR, inner_type, ri, ti);\n+\t t1 = build2_gimple (GIMPLE_MODIFY_STMT, ri, ti);\n \t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n \t bsi_remove (bsi, true);\n        }\n@@ -1161,9 +1160,9 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n \n      if (bb_false)\n        {\n-\t t1 = build2 (MODIFY_EXPR, inner_type, rr, tr);\n+\t t1 = build2_gimple (GIMPLE_MODIFY_STMT, rr, tr);\n \t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n-\t t1 = build2 (MODIFY_EXPR, inner_type, ri, ti);\n+\t t1 = build2_gimple (GIMPLE_MODIFY_STMT, ri, ti);\n \t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n \t bsi_remove (bsi, true);\n        }\n@@ -1307,9 +1306,9 @@ expand_complex_comparison (block_stmt_iterator *bsi, tree ar, tree ai,\n     case RETURN_EXPR:\n       expr = TREE_OPERAND (stmt, 0);\n       /* FALLTHRU */\n-    case MODIFY_EXPR:\n-      type = TREE_TYPE (TREE_OPERAND (expr, 1));\n-      TREE_OPERAND (expr, 1) = fold_convert (type, cc);\n+    case GIMPLE_MODIFY_STMT:\n+      type = TREE_TYPE (GIMPLE_STMT_OPERAND (expr, 1));\n+      GIMPLE_STMT_OPERAND (expr, 1) = fold_convert (type, cc);\n       break;\n     case COND_EXPR:\n       TREE_OPERAND (stmt, 0) = cc;\n@@ -1338,12 +1337,12 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n       stmt = TREE_OPERAND (stmt, 0);\n       if (!stmt)\n \treturn;\n-      if (TREE_CODE (stmt) != MODIFY_EXPR)\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \treturn;\n       /* FALLTHRU */\n \n-    case MODIFY_EXPR:\n-      rhs = TREE_OPERAND (stmt, 1);\n+    case GIMPLE_MODIFY_STMT:\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n       break;\n \n     case COND_EXPR:\n@@ -1384,16 +1383,16 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n \n     default:\n       {\n-\ttree lhs = TREE_OPERAND (stmt, 0);\n-\ttree rhs = TREE_OPERAND (stmt, 1);\n+\ttree lhs = GENERIC_TREE_OPERAND (stmt, 0);\n+\ttree rhs = GENERIC_TREE_OPERAND (stmt, 1);\n \n \tif (TREE_CODE (type) == COMPLEX_TYPE)\n \t  expand_complex_move (bsi, stmt, type, lhs, rhs);\n \telse if ((TREE_CODE (rhs) == REALPART_EXPR\n \t\t  || TREE_CODE (rhs) == IMAGPART_EXPR)\n \t\t && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n \t  {\n-\t    TREE_OPERAND (stmt, 1)\n+\t    GENERIC_TREE_OPERAND (stmt, 1)\n \t      = extract_component (bsi, TREE_OPERAND (rhs, 0),\n \t\t\t\t   TREE_CODE (rhs) == IMAGPART_EXPR, false);\n \t    update_stmt (stmt);"}, {"sha": "7ed14f0e55a960c73733d0c1dbe1a9f68505f075", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -4019,10 +4019,10 @@ get_references_in_stmt (tree stmt, VEC (data_ref_loc, heap) **references)\n   if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return clobbers_memory;\n \n-  if (TREE_CODE (stmt) ==  MODIFY_EXPR)\n+  if (TREE_CODE (stmt) ==  GIMPLE_MODIFY_STMT)\n     {\n-      op0 = &TREE_OPERAND (stmt, 0);\n-      op1 = &TREE_OPERAND (stmt, 1);\n+      op0 = &GIMPLE_STMT_OPERAND (stmt, 0);\n+      op1 = &GIMPLE_STMT_OPERAND (stmt, 1);\n \t\t\n       if (DECL_P (*op1)\n \t  || REFERENCE_CLASS_P (*op1))"}, {"sha": "b2d09f4b031bd2c788263b4789761637b6a55aee", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -128,13 +128,13 @@ create_var_ann (tree t)\n \n   gcc_assert (t);\n   gcc_assert (DECL_P (t));\n-  gcc_assert (!t->common.ann || t->common.ann->common.type == VAR_ANN);\n+  gcc_assert (!t->base.ann || t->base.ann->common.type == VAR_ANN);\n \n   ann = GGC_CNEW (struct var_ann_d);\n \n   ann->common.type = VAR_ANN;\n \n-  t->common.ann = (tree_ann_t) ann;\n+  t->base.ann = (tree_ann_t) ann;\n \n   return ann;\n }\n@@ -148,14 +148,14 @@ create_function_ann (tree t)\n \n   gcc_assert (t);\n   gcc_assert (TREE_CODE (t) == FUNCTION_DECL);\n-  gcc_assert (!t->common.ann || t->common.ann->common.type == FUNCTION_ANN);\n+  gcc_assert (!t->base.ann || t->base.ann->common.type == FUNCTION_ANN);\n \n   ann = ggc_alloc (sizeof (*ann));\n   memset ((void *) ann, 0, sizeof (*ann));\n \n   ann->common.type = FUNCTION_ANN;\n \n-  t->common.ann = (tree_ann_t) ann;\n+  t->base.ann = (tree_ann_t) ann;\n \n   return ann;\n }\n@@ -168,7 +168,7 @@ create_stmt_ann (tree t)\n   stmt_ann_t ann;\n \n   gcc_assert (is_gimple_stmt (t));\n-  gcc_assert (!t->common.ann || t->common.ann->common.type == STMT_ANN);\n+  gcc_assert (!t->base.ann || t->base.ann->common.type == STMT_ANN);\n \n   ann = GGC_CNEW (struct stmt_ann_d);\n \n@@ -177,7 +177,7 @@ create_stmt_ann (tree t)\n   /* Since we just created the annotation, mark the statement modified.  */\n   ann->modified = true;\n \n-  t->common.ann = (tree_ann_t) ann;\n+  t->base.ann = (tree_ann_t) ann;\n \n   return ann;\n }\n@@ -190,12 +190,12 @@ create_tree_common_ann (tree t)\n   tree_ann_common_t ann;\n \n   gcc_assert (t);\n-  gcc_assert (!t->common.ann || t->common.ann->common.type == TREE_ANN_COMMON);\n+  gcc_assert (!t->base.ann || t->base.ann->common.type == TREE_ANN_COMMON);\n \n   ann = GGC_CNEW (struct tree_ann_common_d);\n \n   ann->type = TREE_ANN_COMMON;\n-  t->common.ann = (tree_ann_t) ann;\n+  t->base.ann = (tree_ann_t) ann;\n \n   return ann;\n }\n@@ -540,9 +540,9 @@ collect_dfa_stats_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   tree t = *tp;\n   struct dfa_stats_d *dfa_stats_p = (struct dfa_stats_d *)data;\n \n-  if (t->common.ann)\n+  if (t->base.ann)\n     {\n-      switch (ann_type (t->common.ann))\n+      switch (ann_type (t->base.ann))\n \t{\n \tcase STMT_ANN:\n \t  {"}, {"sha": "2cea58248837ae25b3b4d0d5ba72816047e249de", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -576,6 +576,11 @@ dequeue_and_dump (dump_info_p di)\n       dump_child (\"op 1\", TREE_OPERAND (t, 1));\n       break;\n \n+    case GIMPLE_MODIFY_STMT:\n+      dump_child (\"op 0\", GIMPLE_STMT_OPERAND (t, 0));\n+      dump_child (\"op 1\", GIMPLE_STMT_OPERAND (t, 1));\n+      break;\n+\n     case COMPONENT_REF:\n       dump_child (\"op 0\", TREE_OPERAND (t, 0));\n       dump_child (\"op 1\", TREE_OPERAND (t, 1));"}, {"sha": "760cdc3da108899a85652b703e59b610db3194c0", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -115,7 +115,7 @@ add_stmt_to_eh_region_fn (struct function *ifun, tree t, int num)\n   /* ??? For the benefit of calls.c, converting all this to rtl,\n      we need to record the call expression, not just the outer\n      modify statement.  */\n-  if (TREE_CODE (t) == MODIFY_EXPR\n+  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT\n       && (t = get_call_expr_in (t)))\n     add_stmt_to_eh_region_fn (ifun, t, num);\n }\n@@ -144,7 +144,7 @@ remove_stmt_from_eh_region_fn (struct function *ifun, tree t)\n       /* ??? For the benefit of calls.c, converting all this to rtl,\n \t we need to record the call expression, not just the outer\n \t modify statement.  */\n-      if (TREE_CODE (t) == MODIFY_EXPR\n+      if (TREE_CODE (t) == GIMPLE_MODIFY_STMT\n \t  && (t = get_call_expr_in (t)))\n \tremove_stmt_from_eh_region_fn (ifun, t);\n       return true;\n@@ -624,10 +624,10 @@ do_return_redirection (struct goto_queue_node *q, tree finlab, tree mod,\n \t  q->cont_stmt = q->stmt;\n \t  break;\n \n-\tcase MODIFY_EXPR:\n+\tcase GIMPLE_MODIFY_STMT:\n \t  {\n-\t    tree result = TREE_OPERAND (ret_expr, 0);\n-\t    tree new, old = TREE_OPERAND (ret_expr, 1);\n+\t    tree result = GIMPLE_STMT_OPERAND (ret_expr, 0);\n+\t    tree new, old = GIMPLE_STMT_OPERAND (ret_expr, 1);\n \n \t    if (!*return_value_p)\n \t      {\n@@ -646,13 +646,13 @@ do_return_redirection (struct goto_queue_node *q, tree finlab, tree mod,\n \t    else\n \t      new = *return_value_p;\n \n-\t    x = build2 (MODIFY_EXPR, TREE_TYPE (new), new, old);\n+\t    x = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (new), new, old);\n \t    append_to_statement_list (x, &q->repl_stmt);\n \n \t    if (new == result)\n \t      x = result;\n \t    else\n-\t      x = build2 (MODIFY_EXPR, TREE_TYPE (result), result, new);\n+\t      x = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (result), result, new);\n \t    q->cont_stmt = build1 (RETURN_EXPR, void_type_node, x);\n \t  }\n \n@@ -842,20 +842,20 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n \n       i = tsi_start (finally);\n       x = build0 (EXC_PTR_EXPR, ptr_type_node);\n-      x = build2 (MODIFY_EXPR, void_type_node, save_eptr, x);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, save_eptr, x);\n       tsi_link_before (&i, x, TSI_CONTINUE_LINKING);\n \n       x = build0 (FILTER_EXPR, integer_type_node);\n-      x = build2 (MODIFY_EXPR, void_type_node, save_filt, x);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, save_filt, x);\n       tsi_link_before (&i, x, TSI_CONTINUE_LINKING);\n \n       i = tsi_last (finally);\n       x = build0 (EXC_PTR_EXPR, ptr_type_node);\n-      x = build2 (MODIFY_EXPR, void_type_node, x, save_eptr);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, x, save_eptr);\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n \n       x = build0 (FILTER_EXPR, integer_type_node);\n-      x = build2 (MODIFY_EXPR, void_type_node, x, save_filt);\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, x, save_filt);\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n \n       x = build_resx (get_eh_region_number (tf->region));\n@@ -1177,7 +1177,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n   if (tf->may_fallthru)\n     {\n-      x = build2 (MODIFY_EXPR, void_type_node, finally_tmp,\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, finally_tmp,\n \t\t  build_int_cst (NULL_TREE, fallthru_index));\n       append_to_statement_list (x, tf->top_p);\n \n@@ -1207,7 +1207,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       x = build1 (LABEL_EXPR, void_type_node, tf->eh_label);\n       append_to_statement_list (x, tf->top_p);\n \n-      x = build2 (MODIFY_EXPR, void_type_node, finally_tmp,\n+      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, finally_tmp,\n \t\t  build_int_cst (NULL_TREE, eh_index));\n       append_to_statement_list (x, tf->top_p);\n \n@@ -1239,14 +1239,14 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n       if (q->index < 0)\n \t{\n-\t  mod = build2 (MODIFY_EXPR, void_type_node, finally_tmp,\n+\t  mod = build2 (GIMPLE_MODIFY_STMT, void_type_node, finally_tmp,\n \t\t        build_int_cst (NULL_TREE, return_index));\n \t  do_return_redirection (q, finally_label, mod, &return_val);\n \t  switch_id = return_index;\n \t}\n       else\n \t{\n-\t  mod = build2 (MODIFY_EXPR, void_type_node, finally_tmp,\n+\t  mod = build2 (GIMPLE_MODIFY_STMT, void_type_node, finally_tmp,\n \t\t        build_int_cst (NULL_TREE, q->index));\n \t  do_goto_redirection (q, finally_label, mod);\n \t  switch_id = q->index;\n@@ -1612,7 +1612,7 @@ lower_eh_constructs_1 (struct leh_state *state, tree *tp)\n \t}\n       break;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       /* Look for things that can throw exceptions, and record them.  */\n       if (state->cur_region && tree_could_throw_p (t))\n \t{\n@@ -1997,12 +1997,12 @@ tree_could_throw_p (tree t)\n {\n   if (!flag_exceptions)\n     return false;\n-  if (TREE_CODE (t) == MODIFY_EXPR)\n+  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n     {\n       if (flag_non_call_exceptions\n-\t  && tree_could_trap_p (TREE_OPERAND (t, 0)))\n+\t  && tree_could_trap_p (GIMPLE_STMT_OPERAND (t, 0)))\n \treturn true;\n-      t = TREE_OPERAND (t, 1);\n+      t = GIMPLE_STMT_OPERAND (t, 1);\n     }\n \n   if (TREE_CODE (t) == WITH_SIZE_EXPR)\n@@ -2081,7 +2081,7 @@ verify_eh_throw_stmt_node (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   struct throw_stmt_node *node = (struct throw_stmt_node *)*slot;\n \n-  gcc_assert (node->stmt->common.ann == NULL);\n+  gcc_assert (node->stmt->base.ann == NULL);\n   return 1;\n }\n "}, {"sha": "f19faa1c4ff22adf73433531be733f9f48416424", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -194,9 +194,10 @@ var_ann (tree t)\n   gcc_assert (t);\n   gcc_assert (DECL_P (t));\n   gcc_assert (TREE_CODE (t) != FUNCTION_DECL);\n-  gcc_assert (!t->common.ann || t->common.ann->common.type == VAR_ANN);\n+  gcc_assert (!t->base.ann\n+\t      || t->base.ann->common.type == VAR_ANN);\n \n-  return (var_ann_t) t->common.ann;\n+  return (var_ann_t) t->base.ann;\n }\n \n /* Return the variable annotation for T, which must be a _DECL node.\n@@ -215,9 +216,10 @@ function_ann (tree t)\n {\n   gcc_assert (t);\n   gcc_assert (TREE_CODE (t) == FUNCTION_DECL);\n-  gcc_assert (!t->common.ann || t->common.ann->common.type == FUNCTION_ANN);\n+  gcc_assert (!t->base.ann\n+\t      || t->base.ann->common.type == FUNCTION_ANN);\n \n-  return (function_ann_t) t->common.ann;\n+  return (function_ann_t) t->base.ann;\n }\n \n /* Return the function annotation for T, which must be a FUNCTION_DECL node.\n@@ -226,7 +228,7 @@ static inline function_ann_t\n get_function_ann (tree var)\n {\n   function_ann_t ann = function_ann (var);\n-  gcc_assert (!var->common.ann || var->common.ann->common.type == FUNCTION_ANN);\n+  gcc_assert (!var->base.ann || var->base.ann->common.type == FUNCTION_ANN);\n   return (ann) ? ann : create_function_ann (var);\n }\n \n@@ -238,7 +240,7 @@ has_stmt_ann (tree t)\n #ifdef ENABLE_CHECKING\n   gcc_assert (is_gimple_stmt (t));\n #endif\n-  return t->common.ann && t->common.ann->common.type == STMT_ANN;\n+  return t->base.ann && t->base.ann->common.type == STMT_ANN;\n }\n \n /* Return the statement annotation for T, which must be a statement\n@@ -249,8 +251,8 @@ stmt_ann (tree t)\n #ifdef ENABLE_CHECKING\n   gcc_assert (is_gimple_stmt (t));\n #endif\n-  gcc_assert (!t->common.ann || t->common.ann->common.type == STMT_ANN);\n-  return (stmt_ann_t) t->common.ann;\n+  gcc_assert (!t->base.ann || t->base.ann->common.type == STMT_ANN);\n+  return (stmt_ann_t) t->base.ann;\n }\n \n /* Return the statement annotation for T, which must be a statement\n@@ -868,7 +870,7 @@ mark_non_addressable (tree var)\n static inline tree_ann_common_t\n tree_common_ann (tree t)\n {\n-  return &t->common.ann->common;\n+  return &t->base.ann->common;\n }\n \n /* Return a common annotation for T.  Create the constant annotation if it"}, {"sha": "bee5cd94794ca02af691725e834f213fcaf64a28", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -156,7 +156,7 @@ struct ptr_info_def GTY(())\n \n \n /*---------------------------------------------------------------------------\n-\t\t   Tree annotations stored in tree_common.ann\n+\t\t   Tree annotations stored in tree_base.ann\n ---------------------------------------------------------------------------*/\n enum tree_ann_type { TREE_ANN_COMMON, VAR_ANN, FUNCTION_ANN, STMT_ANN };\n "}, {"sha": "eda454186655fa69ca8eccc35254ae452ad6d4bf", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -87,7 +87,7 @@ is_gimple_formal_tmp_rhs (tree t)\n bool\n is_gimple_reg_rhs (tree t)\n {\n-  /* If the RHS of the MODIFY_EXPR may throw or make a nonlocal goto\n+  /* If the RHS of the GIMPLE_MODIFY_STMT may throw or make a nonlocal goto\n      and the LHS is a user variable, then we need to introduce a formal\n      temporary.  This way the optimizers can determine that the user\n      variable is only modified if evaluation of the RHS does not throw.\n@@ -233,7 +233,7 @@ is_gimple_stmt (tree t)\n       return true;\n \n     case CALL_EXPR:\n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       /* These are valid regardless of their type.  */\n       return true;\n \n@@ -427,8 +427,10 @@ is_gimple_call_addr (tree t)\n tree\n get_call_expr_in (tree t)\n {\n-  if (TREE_CODE (t) == MODIFY_EXPR)\n-    t = TREE_OPERAND (t, 1);\n+  /* FIXME tuples: delete the assertion below when conversion complete.  */\n+  gcc_assert (TREE_CODE (t) != MODIFY_EXPR);\n+  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+    t = GIMPLE_STMT_OPERAND (t, 1);\n   if (TREE_CODE (t) == WITH_SIZE_EXPR)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == CALL_EXPR)\n@@ -473,7 +475,7 @@ recalculate_side_effects (tree t)\n       switch (code)\n \t{\n \tcase INIT_EXPR:\n-\tcase MODIFY_EXPR:\n+\tcase GIMPLE_MODIFY_STMT:\n \tcase VA_ARG_EXPR:\n \tcase PREDECREMENT_EXPR:\n \tcase PREINCREMENT_EXPR:"}, {"sha": "2f304356efb61206a7a400f7795172b982b26a9d", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -108,7 +108,8 @@ static tree tree_if_convert_stmt (struct loop *loop, tree, tree,\n static void tree_if_convert_cond_expr (struct loop *, tree, tree,\n \t\t\t\t       block_stmt_iterator *);\n static bool if_convertible_phi_p (struct loop *, basic_block, tree);\n-static bool if_convertible_modify_expr_p (struct loop *, basic_block, tree);\n+static bool if_convertible_gimple_modify_stmt_p (struct loop *, basic_block,\n+    \t\t\t\t\t\t tree);\n static bool if_convertible_stmt_p (struct loop *, basic_block, tree);\n static bool if_convertible_bb_p (struct loop *, basic_block, basic_block);\n static bool if_convertible_loop_p (struct loop *, bool);\n@@ -119,7 +120,7 @@ static void clean_predicate_lists (struct loop *loop);\n static basic_block find_phi_replacement_condition (struct loop *loop,\n \t\t\t\t\t\t   basic_block, tree *,\n \t\t\t\t\t\t   block_stmt_iterator *);\n-static void replace_phi_with_cond_modify_expr (tree, tree, basic_block,\n+static void replace_phi_with_cond_gimple_modify_stmt (tree, tree, basic_block,\n                                                block_stmt_iterator *);\n static void process_phi_nodes (struct loop *);\n static void combine_blocks (struct loop *);\n@@ -209,7 +210,7 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n }\n \n /* if-convert stmt T which is part of LOOP.\n-   If T is a MODIFY_EXPR than it is converted into conditional modify\n+   If T is a GIMPLE_MODIFY_STMT than it is converted into conditional modify\n    expression using COND.  For conditional expressions, add condition in the\n    destination basic block's predicate list and remove conditional\n    expression itself. BSI is the iterator used to traverse statements of\n@@ -232,12 +233,12 @@ tree_if_convert_stmt (struct loop *  loop, tree t, tree cond,\n     case LABEL_EXPR:\n       break;\n \n-    case MODIFY_EXPR:\n-      /* This modify_expr is killing previous value of LHS. Appropriate value will\n-\t be selected by PHI node based on condition. It is possible that before\n-\t this transformation, PHI nodes was selecting default value and now it will\n-\t use this new value. This is OK because it does not change validity the\n-\t program.  */\n+    case GIMPLE_MODIFY_STMT:\n+      /* This GIMPLE_MODIFY_STMT is killing previous value of LHS. Appropriate\n+\t value will be selected by PHI node based on condition. It is possible\n+\t that before this transformation, PHI nodes was selecting default\n+\t value and now it will use this new value. This is OK because it does \n+\t not change validity the program.  */\n       break;\n \n     case COND_EXPR:\n@@ -334,15 +335,16 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, tree phi)\n }\n \n /* Return true, if M_EXPR is if-convertible.\n-   MODIFY_EXPR is not if-convertible if,\n+   GIMPLE_MODIFY_STMT is not if-convertible if,\n    - It is not movable.\n    - It could trap.\n    - LHS is not var decl.\n-  MODIFY_EXPR is part of block BB, which is inside loop LOOP.\n+  GIMPLE_MODIFY_STMT is part of block BB, which is inside loop LOOP.\n */\n \n static bool\n-if_convertible_modify_expr_p (struct loop *loop, basic_block bb, tree m_expr)\n+if_convertible_gimple_modify_stmt_p (struct loop *loop, basic_block bb,\n+    \t\t\t\t     tree m_expr)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -360,21 +362,21 @@ if_convertible_modify_expr_p (struct loop *loop, basic_block bb, tree m_expr)\n \n   /* See if it needs speculative loading or not.  */\n   if (bb != loop->header\n-      && tree_could_trap_p (TREE_OPERAND (m_expr, 1)))\n+      && tree_could_trap_p (GIMPLE_STMT_OPERAND (m_expr, 1)))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"tree could trap...\\n\");\n       return false;\n     }\n \n-  if (TREE_CODE (TREE_OPERAND (m_expr, 1)) == CALL_EXPR)\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (m_expr, 1)) == CALL_EXPR)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"CALL_EXPR \\n\");\n       return false;\n     }\n \n-  if (TREE_CODE (TREE_OPERAND (m_expr, 0)) != SSA_NAME\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (m_expr, 0)) != SSA_NAME\n       && bb != loop->header\n       && !bb_with_exit_edge_p (loop, bb))\n     {\n@@ -392,7 +394,7 @@ if_convertible_modify_expr_p (struct loop *loop, basic_block bb, tree m_expr)\n \n /* Return true, iff STMT is if-convertible.\n    Statement is if-convertible if,\n-   - It is if-convertible MODIFY_EXPR\n+   - It is if-convertible GIMPLE_MODIFY_STMT\n    - IT is LABEL_EXPR or COND_EXPR.\n    STMT is inside block BB, which is inside loop LOOP.  */\n \n@@ -404,9 +406,9 @@ if_convertible_stmt_p (struct loop *loop, basic_block bb, tree stmt)\n     case LABEL_EXPR:\n       break;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n \n-      if (!if_convertible_modify_expr_p (loop, bb, stmt))\n+      if (!if_convertible_gimple_modify_stmt_p (loop, bb, stmt))\n \treturn false;\n       break;\n \n@@ -634,7 +636,7 @@ add_to_dst_predicate_list (struct loop * loop, basic_block bb,\n \t\t    unshare_expr (prev_cond), cond);\n       tmp_stmt = ifc_temp_var (boolean_type_node, tmp);\n       bsi_insert_before (bsi, tmp_stmt, BSI_SAME_STMT);\n-      new_cond = TREE_OPERAND (tmp_stmt, 0);\n+      new_cond = GIMPLE_STMT_OPERAND (tmp_stmt, 0);\n     }\n   add_to_predicate_list (bb, new_cond);\n   return new_cond;\n@@ -741,7 +743,7 @@ find_phi_replacement_condition (struct loop *loop,\n \n       new_stmt = ifc_temp_var (TREE_TYPE (*cond), unshare_expr (*cond));\n       bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n-      *cond = TREE_OPERAND (new_stmt, 0);\n+      *cond = GIMPLE_STMT_OPERAND (new_stmt, 0);\n     }\n \n   gcc_assert (*cond);\n@@ -761,8 +763,9 @@ find_phi_replacement_condition (struct loop *loop,\n */\n \n static void\n-replace_phi_with_cond_modify_expr (tree phi, tree cond, basic_block true_bb,\n-                                   block_stmt_iterator *bsi)\n+replace_phi_with_cond_gimple_modify_stmt (tree phi, tree cond,\n+    \t\t\t\t\t  basic_block true_bb,\n+                                   \t  block_stmt_iterator *bsi)\n {\n   tree new_stmt;\n   basic_block bb;\n@@ -799,7 +802,7 @@ replace_phi_with_cond_modify_expr (tree phi, tree cond, basic_block true_bb,\n \t        unshare_expr (arg_1));\n \n   /* Create new MODIFY expression using RHS.  */\n-  new_stmt = build2 (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n+  new_stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (PHI_RESULT (phi)),\n \t\t     unshare_expr (PHI_RESULT (phi)), rhs);\n \n   /* Make new statement definition of the original phi result.  */\n@@ -848,7 +851,7 @@ process_phi_nodes (struct loop *loop)\n       while (phi)\n \t{\n \t  tree next = PHI_CHAIN (phi);\n-\t  replace_phi_with_cond_modify_expr (phi, cond, true_bb, &bsi);\n+\t  replace_phi_with_cond_gimple_modify_stmt (phi, cond, true_bb, &bsi);\n \t  release_phi_node (phi);\n \t  phi = next;\n \t}\n@@ -963,7 +966,7 @@ combine_blocks (struct loop *loop)\n     merge_blocks (loop->header, exit_bb);\n }\n \n-/* Make new  temp variable of type TYPE. Add MODIFY_EXPR to assign EXP\n+/* Make new  temp variable of type TYPE. Add GIMPLE_MODIFY_STMT to assign EXP\n    to the new variable.  */\n \n static tree\n@@ -980,12 +983,12 @@ ifc_temp_var (tree type, tree exp)\n   add_referenced_var (var);\n \n   /* Build new statement to assign EXP to new variable.  */\n-  stmt = build2 (MODIFY_EXPR, type, var, exp);\n+  stmt = build2 (GIMPLE_MODIFY_STMT, type, var, exp);\n \n   /* Get SSA name for the new variable and set make new statement\n      its definition statement.  */\n   new_name = make_ssa_name (var, stmt);\n-  TREE_OPERAND (stmt, 0) = new_name;\n+  GIMPLE_STMT_OPERAND (stmt, 0) = new_name;\n   SSA_NAME_DEF_STMT (new_name) = stmt;\n \n   return stmt;"}, {"sha": "429cc2cb0f6d1704b8bcaa19a5a32b54b09f5c39", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -58,7 +58,7 @@ Boston, MA 02110-1301, USA.  */\n \n    Inlining: a function body is duplicated, but the PARM_DECLs are\n    remapped into VAR_DECLs, and non-void RETURN_EXPRs become\n-   MODIFY_EXPRs that store to a dedicated returned-value variable.\n+   GIMPLE_MODIFY_STMTs that store to a dedicated returned-value variable.\n    The duplicated eh_region info of the copy will later be appended\n    to the info for the caller; the eh_region info in copied throwing\n    statements and RESX_EXPRs is adjusted accordingly.\n@@ -476,7 +476,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n      duplicated and/or tweaked.  */\n \n   /* When requested, RETURN_EXPRs should be transformed to just the\n-     contained MODIFY_EXPR.  The branch semantics of the return will\n+     contained GIMPLE_MODIFY_STMT.  The branch semantics of the return will\n      be handled elsewhere by manipulating the CFG rather than a statement.  */\n   if (TREE_CODE (*tp) == RETURN_EXPR && id->transform_return_to_modify)\n     {\n@@ -487,10 +487,10 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t If the \"assignment\" is just the result decl, the result\n \t decl has already been set (e.g. a recent \"foo (&result_decl,\n \t ...)\"); just toss the entire RETURN_EXPR.  */\n-      if (assignment && TREE_CODE (assignment) == MODIFY_EXPR)\n+      if (assignment && TREE_CODE (assignment) == GIMPLE_MODIFY_STMT)\n \t{\n \t  /* Replace the RETURN_EXPR with (a copy of) the\n-\t     MODIFY_EXPR hanging underneath.  */\n+\t     GIMPLE_MODIFY_STMT hanging underneath.  */\n \t  *tp = copy_node (assignment);\n \t}\n       else /* Else the RETURN_EXPR returns no value.  */\n@@ -557,15 +557,15 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n       /* Here we handle trees that are not completely rewritten.\n \t First we detect some inlining-induced bogosities for\n \t discarding.  */\n-      if (TREE_CODE (*tp) == MODIFY_EXPR\n-\t  && TREE_OPERAND (*tp, 0) == TREE_OPERAND (*tp, 1)\n+      if (TREE_CODE (*tp) == GIMPLE_MODIFY_STMT\n+\t  && GIMPLE_STMT_OPERAND (*tp, 0) == GIMPLE_STMT_OPERAND (*tp, 1)\n \t  && (lang_hooks.tree_inlining.auto_var_in_fn_p\n-\t      (TREE_OPERAND (*tp, 0), fn)))\n+\t      (GIMPLE_STMT_OPERAND (*tp, 0), fn)))\n \t{\n \t  /* Some assignments VAR = VAR; don't generate any rtl code\n \t     and thus don't count as variable modification.  Avoid\n \t     keeping bogosities like 0 = 0.  */\n-\t  tree decl = TREE_OPERAND (*tp, 0), value;\n+\t  tree decl = GIMPLE_STMT_OPERAND (*tp, 0), value;\n \t  splay_tree_node n;\n \n \t  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n@@ -624,7 +624,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n       /* If EXPR has block defined, map it to newly constructed block.\n          When inlining we want EXPRs without block appear in the block\n \t of function call.  */\n-      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (*tp))))\n+      if (EXPR_P (*tp) || GIMPLE_STMT_P (*tp))\n \t{\n \t  new_block = id->block;\n \t  if (TREE_BLOCK (*tp))\n@@ -644,7 +644,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t    (NULL_TREE,\n \t     id->eh_region_offset + TREE_INT_CST_LOW (TREE_OPERAND (*tp, 0)));\n \n-      TREE_TYPE (*tp) = remap_type (TREE_TYPE (*tp), id);\n+      if (!GIMPLE_TUPLE_P (*tp))\n+\tTREE_TYPE (*tp) = remap_type (TREE_TYPE (*tp), id);\n \n       /* The copied TARGET_EXPR has never been expanded, even if the\n \t original node was expanded already.  */\n@@ -708,9 +709,9 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scal\n \n \t  /* With return slot optimization we can end up with\n \t     non-gimple (foo *)&this->m, fix that here.  */\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) == NOP_EXPR\n-\t      && !is_gimple_val (TREE_OPERAND (TREE_OPERAND (stmt, 1), 0)))\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == NOP_EXPR\n+\t      && !is_gimple_val (TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 0)))\n \t    gimplify_stmt (&stmt);\n \n           bsi_insert_after (&copy_bsi, stmt, BSI_NEW_STMT);\n@@ -1093,9 +1094,9 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \n       STRIP_USELESS_TYPE_CONVERSION (rhs);\n \n-      /* We want to use MODIFY_EXPR, not INIT_EXPR here so that we\n+      /* We want to use GIMPLE_MODIFY_STMT, not INIT_EXPR here so that we\n \t keep our trees in gimple form.  */\n-      init_stmt = build2 (MODIFY_EXPR, TREE_TYPE (var), var, rhs);\n+      init_stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), var, rhs);\n \n       /* If we did not create a gimple value and we did not create a gimple\n \t cast of a gimple value, then we will need to gimplify INIT_STMTS\n@@ -1167,7 +1168,7 @@ initialize_inlined_parameters (copy_body_data *id, tree args, tree static_chain,\n \n    RETURN_SLOT_ADDR, if non-null, was a fake parameter that\n    took the address of the result.  MODIFY_DEST, if non-null, was the LHS of\n-   the MODIFY_EXPR to which this call is the RHS.\n+   the GIMPLE_MODIFY_STMT to which this call is the RHS.\n \n    The return value is a (possibly null) value that is the result of the\n    function as seen by the callee.  *USE_P is a (possibly null) value that\n@@ -1657,30 +1658,32 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n \t3) TARGET_EXPRs.\n \n        Let us look at the first two cases, assuming we have \"a = b + C\":\n-       <modify_expr <var_decl \"a\"> <plus_expr <var_decl \"b\"> <constant C>>\n+       <GIMPLE_MODIFY_STMT <var_decl \"a\">\n+       \t\t\t   <plus_expr <var_decl \"b\"> <constant C>>\n        If \"a\" is a GIMPLE register, the assignment to it is free on almost\n        any target, because \"a\" usually ends up in a real register.  Hence\n        the only cost of this expression comes from the PLUS_EXPR, and we\n-       can ignore the MODIFY_EXPR.\n+       can ignore the GIMPLE_MODIFY_STMT.\n        If \"a\" is not a GIMPLE register, the assignment to \"a\" will most\n-       likely be a real store, so the cost of the MODIFY_EXPR is the cost\n+       likely be a real store, so the cost of the GIMPLE_MODIFY_STMT is the cost\n        of moving something into \"a\", which we compute using the function\n        estimate_move_cost.\n \n        The third case deals with TARGET_EXPRs, for which the semantics are\n        that a temporary is assigned, unless the TARGET_EXPR itself is being\n        assigned to something else.  In the latter case we do not need the\n-       temporary.  E.g. in <modify_expr <var_decl \"a\"> <target_expr>>, the\n-       MODIFY_EXPR is free.  */\n+       temporary.  E.g. in:\n+       \t\t<GIMPLE_MODIFY_STMT <var_decl \"a\"> <target_expr>>, the\n+       GIMPLE_MODIFY_STMT is free.  */\n     case INIT_EXPR:\n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       /* Is the right and side a TARGET_EXPR?  */\n-      if (TREE_CODE (TREE_OPERAND (x, 1)) == TARGET_EXPR)\n+      if (TREE_CODE (GENERIC_TREE_OPERAND (x, 1)) == TARGET_EXPR)\n \tbreak;\n       /* ... fall through ...  */\n \n     case TARGET_EXPR:\n-      x = TREE_OPERAND (x, 0);\n+      x = GENERIC_TREE_OPERAND (x, 0);\n       /* Is this an assignments to a register?  */\n       if (is_gimple_reg (x))\n \tbreak;\n@@ -2100,9 +2103,9 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \n   /* Find the lhs to which the result of this call is assigned.  */\n   return_slot_addr = NULL;\n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      modify_dest = TREE_OPERAND (stmt, 0);\n+      modify_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n \n       /* The function which we are inlining might not return a value,\n \t in which case we should issue a warning that the function\n@@ -2189,7 +2192,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \n /* Expand call statements reachable from STMT_P.\n    We can only have CALL_EXPRs as the \"toplevel\" tree code or nested\n-   in a MODIFY_EXPR.  See tree-gimple.c:get_call_expr_in().  We can\n+   in a GIMPLE_MODIFY_STMT.  See tree-gimple.c:get_call_expr_in().  We can\n    unfortunately not use that function here because we need a pointer\n    to the CALL_EXPR, not the tree itself.  */\n \n@@ -2205,8 +2208,8 @@ gimple_expand_calls_inline (basic_block bb, copy_body_data *id)\n       tree *expr_p = bsi_stmt_ptr (bsi);\n       tree stmt = *expr_p;\n \n-      if (TREE_CODE (*expr_p) == MODIFY_EXPR)\n-\texpr_p = &TREE_OPERAND (*expr_p, 1);\n+      if (TREE_CODE (*expr_p) == GIMPLE_MODIFY_STMT)\n+\texpr_p = &GIMPLE_STMT_OPERAND (*expr_p, 1);\n       if (TREE_CODE (*expr_p) == WITH_SIZE_EXPR)\n \texpr_p = &TREE_OPERAND (*expr_p, 0);\n       if (TREE_CODE (*expr_p) == CALL_EXPR)\n@@ -2320,18 +2323,22 @@ tree\n copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   enum tree_code code = TREE_CODE (*tp);\n+  enum tree_code_class cl = TREE_CODE_CLASS (code);\n \n   /* We make copies of most nodes.  */\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n+  if (IS_EXPR_CODE_CLASS (cl)\n+      || IS_GIMPLE_STMT_CODE_CLASS (cl)\n       || code == TREE_LIST\n       || code == TREE_VEC\n       || code == TYPE_DECL\n       || code == OMP_CLAUSE)\n     {\n       /* Because the chain gets clobbered when we make a copy, we save it\n \t here.  */\n-      tree chain = TREE_CHAIN (*tp);\n-      tree new;\n+      tree chain = NULL_TREE, new;\n+\n+      if (!GIMPLE_TUPLE_P (*tp))\n+\tchain = TREE_CHAIN (*tp);\n \n       /* Copy the node.  */\n       new = copy_node (*tp);"}, {"sha": "90f3dd359d3b10841b9f7ff1f7e69385d0073daf", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -245,7 +245,7 @@ enum rewrite_mode {\n    processed from those that only need to have their defs processed.\n    Statements that define new SSA names only need to have their defs\n    registered, but they don't need to have their uses renamed.  */\n-#define REGISTER_DEFS_IN_THIS_STMT(T)\t(T)->common.unsigned_flag\n+#define REGISTER_DEFS_IN_THIS_STMT(T)\t(T)->base.unsigned_flag\n \n \n /* Prototypes for debugging functions.  */"}, {"sha": "4d80c19d385d63b7c8ba3bd7de4d281e972e47f3", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -458,13 +458,13 @@ mf_decl_cache_locals (void)\n \n   /* Build initialization nodes for the cache vars.  We just load the\n      globals into the cache variables.  */\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (mf_cache_shift_decl_l),\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (mf_cache_shift_decl_l),\n               mf_cache_shift_decl_l, mf_cache_shift_decl);\n   SET_EXPR_LOCATION (t, DECL_SOURCE_LOCATION (current_function_decl));\n   gimplify_to_stmt_list (&t);\n   shift_init_stmts = t;\n \n-  t = build2 (MODIFY_EXPR, TREE_TYPE (mf_cache_mask_decl_l),\n+  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (mf_cache_mask_decl_l),\n               mf_cache_mask_decl_l, mf_cache_mask_decl);\n   SET_EXPR_LOCATION (t, DECL_SOURCE_LOCATION (current_function_decl));\n   gimplify_to_stmt_list (&t);\n@@ -553,15 +553,15 @@ mf_build_check_statement_for (tree base, tree limit,\n   mf_limit = create_tmp_var (mf_uintptr_type, \"__mf_limit\");\n \n   /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n-  t = build2 (MODIFY_EXPR, void_type_node, mf_base,\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, mf_base,\n               convert (mf_uintptr_type, unshare_expr (base)));\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   head = tsi_start (t);\n   tsi = tsi_last (t);\n \n   /* Build: __mf_limit = (uintptr_t) <limit address expression>.  */\n-  t = build2 (MODIFY_EXPR, void_type_node, mf_limit,\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, mf_limit,\n               convert (mf_uintptr_type, unshare_expr (limit)));\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n@@ -577,7 +577,7 @@ mf_build_check_statement_for (tree base, tree limit,\n               TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n               mf_cache_array_decl, t, NULL_TREE, NULL_TREE);\n   t = build1 (ADDR_EXPR, mf_cache_structptr_type, t);\n-  t = build2 (MODIFY_EXPR, void_type_node, mf_elem, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, mf_elem, t);\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n@@ -623,7 +623,7 @@ mf_build_check_statement_for (tree base, tree limit,\n      can use as the condition for the conditional jump.  */\n   t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, u);\n   cond = create_tmp_var (boolean_type_node, \"__mf_unlikely_cond\");\n-  t = build2 (MODIFY_EXPR, boolean_type_node, cond, t);\n+  t = build2 (GIMPLE_MODIFY_STMT, boolean_type_node, cond, t);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n@@ -676,11 +676,11 @@ mf_build_check_statement_for (tree base, tree limit,\n \n   if (! flag_mudflap_threads)\n     {\n-      t = build2 (MODIFY_EXPR, void_type_node,\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n                   mf_cache_shift_decl_l, mf_cache_shift_decl);\n       tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n-      t = build2 (MODIFY_EXPR, void_type_node,\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n                   mf_cache_mask_decl_l, mf_cache_mask_decl);\n       tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n     }\n@@ -912,18 +912,19 @@ mf_xform_derefs (void)\n           /* Only a few GIMPLE statements can reference memory.  */\n           switch (TREE_CODE (s))\n             {\n-            case MODIFY_EXPR:\n-              mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n-                                 integer_one_node);\n-              mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 1), EXPR_LOCUS (s),\n-                                 integer_zero_node);\n+            case GIMPLE_MODIFY_STMT:\n+              mf_xform_derefs_1 (&i, &GIMPLE_STMT_OPERAND (s, 0),\n+\t\t  \t\t EXPR_LOCUS (s), integer_one_node);\n+              mf_xform_derefs_1 (&i, &GIMPLE_STMT_OPERAND (s, 1),\n+\t\t  \t\t EXPR_LOCUS (s), integer_zero_node);\n               break;\n \n             case RETURN_EXPR:\n               if (TREE_OPERAND (s, 0) != NULL_TREE)\n                 {\n-                  if (TREE_CODE (TREE_OPERAND (s, 0)) == MODIFY_EXPR)\n-                    mf_xform_derefs_1 (&i, &TREE_OPERAND (TREE_OPERAND (s, 0), 1),\n+                  if (TREE_CODE (TREE_OPERAND (s, 0)) == GIMPLE_MODIFY_STMT)\n+                    mf_xform_derefs_1 (&i, &GIMPLE_STMT_OPERAND\n+\t\t\t\t\t     (TREE_OPERAND (s, 0), 1),\n                                        EXPR_LOCUS (s), integer_zero_node);\n                   else\n                     mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),"}, {"sha": "ed4a1ae664706b01060d90469603d407cbda7287", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -388,7 +388,7 @@ init_tmp_var (struct nesting_info *info, tree exp, tree_stmt_iterator *tsi)\n   tree t, stmt;\n \n   t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n-  stmt = build2 (MODIFY_EXPR, TREE_TYPE (t), t, exp);\n+  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (t), t, exp);\n   SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n   tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n \n@@ -416,7 +416,7 @@ save_tmp_var (struct nesting_info *info, tree exp,\n   tree t, stmt;\n \n   t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n-  stmt = build2 (MODIFY_EXPR, TREE_TYPE (t), exp, t);\n+  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (t), exp, t);\n   SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n   tsi_link_after (tsi, stmt, TSI_SAME_STMT);\n \n@@ -613,16 +613,16 @@ walk_stmts (struct walk_stmt_info *wi, tree *tp)\n       walk_stmts (wi, &TREE_OPERAND (t, 0));\n       break;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       /* A formal temporary lhs may use a COMPONENT_REF rhs.  */\n-      wi->val_only = !is_gimple_formal_tmp_var (TREE_OPERAND (t, 0));\n-      walk_tree (&TREE_OPERAND (t, 1), wi->callback, wi, NULL);\n+      wi->val_only = !is_gimple_formal_tmp_var (GIMPLE_STMT_OPERAND (t, 0));\n+      walk_tree (&GIMPLE_STMT_OPERAND (t, 1), wi->callback, wi, NULL);\n \n       /* If the rhs is appropriate for a memory, we may use a\n \t COMPONENT_REF on the lhs.  */\n-      wi->val_only = !is_gimple_mem_rhs (TREE_OPERAND (t, 1));\n+      wi->val_only = !is_gimple_mem_rhs (GIMPLE_STMT_OPERAND (t, 1));\n       wi->is_lhs = true;\n-      walk_tree (&TREE_OPERAND (t, 0), wi->callback, wi, NULL);\n+      walk_tree (&GIMPLE_STMT_OPERAND (t, 0), wi->callback, wi, NULL);\n \n       wi->val_only = true;\n       wi->is_lhs = false;\n@@ -1648,7 +1648,7 @@ convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     case RETURN_EXPR:\n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n     case WITH_SIZE_EXPR:\n       /* Only return modify and with_size_expr may contain calls.  */\n       *walk_subtrees = 1;\n@@ -1770,7 +1770,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \n \t  y = build3 (COMPONENT_REF, TREE_TYPE (field),\n \t\t      root->frame_decl, field, NULL_TREE);\n-\t  x = build2 (MODIFY_EXPR, TREE_TYPE (field), y, x);\n+\t  x = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (field), y, x);\n \t  append_to_statement_list (x, &stmt_list);\n \t}\n     }\n@@ -1781,7 +1781,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n     {\n       tree x = build3 (COMPONENT_REF, TREE_TYPE (root->chain_field),\n \t\t       root->frame_decl, root->chain_field, NULL_TREE);\n-      x = build2 (MODIFY_EXPR, TREE_TYPE (x), x, get_chain_decl (root));\n+      x = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (x), x, get_chain_decl (root));\n       append_to_statement_list (x, &stmt_list);\n     }\n "}, {"sha": "c33ff0ea31aba54b5aaaa3e0252384e2920e7682", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -133,10 +133,10 @@ tree_nrv (void)\n \t      if (ret_expr)\n \t\tgcc_assert (ret_expr == result);\n \t    }\n-\t  else if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t\t   && TREE_OPERAND (stmt, 0) == result)\n+\t  else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t\t   && GIMPLE_STMT_OPERAND (stmt, 0) == result)\n \t    {\n-\t      ret_expr = TREE_OPERAND (stmt, 1);\n+\t      ret_expr = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t      /* Now verify that this return statement uses the same value\n \t\t as any previously encountered return statement.  */\n@@ -197,9 +197,9 @@ tree_nrv (void)\n \t{\n \t  tree *tp = bsi_stmt_ptr (bsi);\n \t  /* If this is a copy from VAR to RESULT, remove it.  */\n-\t  if (TREE_CODE (*tp) == MODIFY_EXPR\n-\t      && TREE_OPERAND (*tp, 0) == result\n-\t      && TREE_OPERAND (*tp, 1) == found)\n+\t  if (TREE_CODE (*tp) == GIMPLE_MODIFY_STMT\n+\t      && GIMPLE_STMT_OPERAND (*tp, 0) == result\n+\t      && GIMPLE_STMT_OPERAND (*tp, 1) == found)\n \t    bsi_remove (&bsi, true);\n \t  else\n \t    {\n@@ -264,7 +264,7 @@ dest_safe_for_nrv_p (tree dest)\n     }\n }\n \n-/* Walk through the function looking for MODIFY_EXPRs with calls that\n+/* Walk through the function looking for GIMPLE_MODIFY_STMTs with calls that\n    return in memory on the RHS.  For each of these, determine whether it is\n    safe to pass the address of the LHS as the return slot, and mark the\n    call appropriately if so.\n@@ -289,15 +289,15 @@ execute_return_slot_opt (void)\n \t  tree stmt = bsi_stmt (i);\n \t  tree call;\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && (call = TREE_OPERAND (stmt, 1),\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && (call = GIMPLE_STMT_OPERAND (stmt, 1),\n \t\t  TREE_CODE (call) == CALL_EXPR)\n \t      && !CALL_EXPR_RETURN_SLOT_OPT (call)\n \t      && aggregate_value_p (call, call))\n \t    /* Check if the location being assigned to is\n \t       call-clobbered.  */\n \t    CALL_EXPR_RETURN_SLOT_OPT (call) =\n-\t      dest_safe_for_nrv_p (TREE_OPERAND (stmt, 0)) ? 1 : 0;\n+\t      dest_safe_for_nrv_p (GIMPLE_STMT_OPERAND (stmt, 0)) ? 1 : 0;\n \t}\n     }\n   return 0;"}, {"sha": "7ae87d67539810bb2bab2a297d79a0d7a960d691", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -688,13 +688,13 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n   switch (TREE_CODE (stmt))\n     {\n     case RETURN_EXPR:\n-      gcc_assert (TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR);\n+      gcc_assert (TREE_CODE (TREE_OPERAND (stmt, 0)) == GIMPLE_MODIFY_STMT);\n       stmt = TREE_OPERAND (stmt, 0);\n       /* FALLTHRU  */\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       {\n-\ttree rhs = TREE_OPERAND (stmt, 1), arg;\n+\ttree rhs = GIMPLE_STMT_OPERAND (stmt, 1), arg;\n \tSTRIP_NOPS (rhs);\n \n \tif (TREE_CODE (rhs) == CALL_EXPR)\n@@ -814,13 +814,13 @@ check_for_plus_in_loops_1 (struct object_size_info *osi, tree var,\n   switch (TREE_CODE (stmt))\n     {\n     case RETURN_EXPR:\n-      gcc_assert (TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR);\n+      gcc_assert (TREE_CODE (TREE_OPERAND (stmt, 0)) == GIMPLE_MODIFY_STMT);\n       stmt = TREE_OPERAND (stmt, 0);\n       /* FALLTHRU  */\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       {\n-\ttree rhs = TREE_OPERAND (stmt, 1), arg;\n+\ttree rhs = GIMPLE_STMT_OPERAND (stmt, 1), arg;\n \tSTRIP_NOPS (rhs);\n \n \tif (TREE_CODE (rhs) == CALL_EXPR)\n@@ -892,13 +892,13 @@ check_for_plus_in_loops (struct object_size_info *osi, tree var)\n   switch (TREE_CODE (stmt))\n     {\n     case RETURN_EXPR:\n-      gcc_assert (TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR);\n+      gcc_assert (TREE_CODE (TREE_OPERAND (stmt, 0)) == GIMPLE_MODIFY_STMT);\n       stmt = TREE_OPERAND (stmt, 0);\n       /* FALLTHRU  */\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       {\n-\ttree rhs = TREE_OPERAND (stmt, 1), arg;\n+\ttree rhs = GIMPLE_STMT_OPERAND (stmt, 1), arg;\n \tSTRIP_NOPS (rhs);\n \n \tif (TREE_CODE (rhs) == CALL_EXPR)"}, {"sha": "9e4af19bbad66a0865d9fa7e5f77f3cab32a6a24", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -206,8 +206,8 @@ execute_free_cfg_annotations (void)\n     for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n       {\n \ttree stmt = bsi_stmt (bsi);\n-\tggc_free (stmt->common.ann);\n-\tstmt->common.ann = NULL;\n+\tggc_free (stmt->base.ann);\n+\tstmt->base.ann = NULL;\n       }\n \n   /* And get rid of annotations we no longer need.  */"}, {"sha": "279934d98e638dac55b23f6f477a0563998b5a27", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -188,7 +188,7 @@ insert_copy_on_edge (edge e, tree dest, tree src)\n {\n   tree copy;\n \n-  copy = build2 (MODIFY_EXPR, TREE_TYPE (dest), dest, src);\n+  copy = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (dest), dest, src);\n   set_is_used (dest);\n \n   if (TREE_CODE (src) == ADDR_EXPR)\n@@ -1026,10 +1026,10 @@ replace_use_variable (var_map map, use_operand_p p, tree *expr)\n       int version = SSA_NAME_VERSION (var);\n       if (expr[version])\n         {\n-\t  tree new_expr = TREE_OPERAND (expr[version], 1);\n+\t  tree new_expr = GIMPLE_STMT_OPERAND (expr[version], 1);\n \t  SET_USE (p, new_expr);\n \t  /* Clear the stmt's RHS, or GC might bite us.  */\n-\t  TREE_OPERAND (expr[version], 1) = NULL_TREE;\n+\t  GIMPLE_STMT_OPERAND (expr[version], 1) = NULL_TREE;\n \t  return true;\n \t}\n     }\n@@ -1437,7 +1437,7 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n   tree call_expr;\n   bitmap def_vars, use_vars;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n   \n   /* Punt if there is more than 1 def, or more than 1 use.  */\n@@ -1453,7 +1453,8 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n     return false;\n \n   /* Float expressions must go through memory if float-store is on.  */\n-  if (flag_float_store && FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 1))))\n+  if (flag_float_store && FLOAT_TYPE_P (TREE_TYPE\n+\t\t\t\t\t(GENERIC_TREE_OPERAND (stmt, 1))))\n     return false;\n \n   /* Calls to functions with side-effects cannot be replaced.  */\n@@ -1793,8 +1794,8 @@ rewrite_trees (var_map map, tree *values)\n \t  ann = stmt_ann (stmt);\n \t  changed = false;\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR \n-\t      && (TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME))\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT \n+\t      && (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == SSA_NAME))\n \t    is_copy = true;\n \n \t  copy_use_p = NULL_USE_OPERAND_P;\n@@ -1877,17 +1878,17 @@ static inline bool\n identical_copies_p (tree s1, tree s2)\n {\n #ifdef ENABLE_CHECKING\n-  gcc_assert (TREE_CODE (s1) == MODIFY_EXPR);\n-  gcc_assert (TREE_CODE (s2) == MODIFY_EXPR);\n-  gcc_assert (DECL_P (TREE_OPERAND (s1, 0)));\n-  gcc_assert (DECL_P (TREE_OPERAND (s2, 0)));\n+  gcc_assert (TREE_CODE (s1) == GIMPLE_MODIFY_STMT);\n+  gcc_assert (TREE_CODE (s2) == GIMPLE_MODIFY_STMT);\n+  gcc_assert (DECL_P (GIMPLE_STMT_OPERAND (s1, 0)));\n+  gcc_assert (DECL_P (GIMPLE_STMT_OPERAND (s2, 0)));\n #endif\n \n-  if (TREE_OPERAND (s1, 0) != TREE_OPERAND (s2, 0))\n+  if (GIMPLE_STMT_OPERAND (s1, 0) != GIMPLE_STMT_OPERAND (s2, 0))\n     return false;\n \n-  s1 = TREE_OPERAND (s1, 1);\n-  s2 = TREE_OPERAND (s2, 1);\n+  s1 = GIMPLE_STMT_OPERAND (s1, 1);\n+  s2 = GIMPLE_STMT_OPERAND (s2, 1);\n \n   if (s1 != s2)\n     return false;\n@@ -2343,10 +2344,10 @@ insert_backedge_copies (void)\n \n \t\t  /* Create a new instance of the underlying\n \t\t     variable of the PHI result.  */\n-\t\t  stmt = build2 (MODIFY_EXPR, TREE_TYPE (result_var),\n+\t\t  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (result_var),\n \t\t\t\t NULL_TREE, PHI_ARG_DEF (phi, i));\n \t\t  name = make_ssa_name (result_var, stmt);\n-\t\t  TREE_OPERAND (stmt, 0) = name;\n+\t\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \n \t\t  /* Insert the new statement into the block and update\n \t\t     the PHI node.  */"}, {"sha": "2c9a8c8a2cba0d7adb38a2d1a281eb5196e8ecef", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -419,7 +419,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n   if (node == NULL_TREE)\n     return spc;\n \n-  is_expr = EXPR_P (node);\n+  is_expr = EXPR_P (node) || GIMPLE_STMT_P (node);\n \n   /* We use has_stmt_ann because CALL_EXPR can be both an expression\n      and a statement, and we have no guarantee that it will have a\n@@ -1024,12 +1024,15 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n     case INIT_EXPR:\n-      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      dump_generic_node (buffer, GENERIC_TREE_OPERAND (node, 0), spc, flags,\n+\t  \t\t false);\n       pp_space (buffer);\n       pp_character (buffer, '=');\n       pp_space (buffer);\n-      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      dump_generic_node (buffer, GENERIC_TREE_OPERAND (node, 1), spc, flags,\n+\t  \t\t false);\n       break;\n \n     case TARGET_EXPR:\n@@ -1485,8 +1488,10 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       if (op0)\n \t{\n \t  pp_space (buffer);\n-\t  if (TREE_CODE (op0) == MODIFY_EXPR)\n-\t    dump_generic_node (buffer, TREE_OPERAND (op0, 1), spc, flags, false);\n+\t  if (TREE_CODE (op0) == MODIFY_EXPR\n+\t      || TREE_CODE (op0) == GIMPLE_MODIFY_STMT)\n+\t    dump_generic_node (buffer, GENERIC_TREE_OPERAND (op0, 1),\n+\t\t\t       spc, flags, false);\n \t  else\n \t    dump_generic_node (buffer, op0, spc, flags, false);\n \t}\n@@ -2180,6 +2185,7 @@ op_prio (tree op)\n       return 1;\n \n     case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n     case INIT_EXPR:\n       return 2;\n \n@@ -2311,6 +2317,7 @@ op_symbol_1 (enum tree_code code)\n   switch (code)\n     {\n     case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       return \"=\";\n \n     case TRUTH_OR_EXPR:"}, {"sha": "329ebcd4b6e7e4e4751243ca2db6825a62354601", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -106,11 +106,11 @@ tree_gen_edge_profiler (int edgeno, edge e)\n   tree tmp1 = create_tmp_var (gcov_type_node, \"PROF\");\n   tree tmp2 = create_tmp_var (gcov_type_node, \"PROF\");\n   tree ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n-  tree stmt1 = build2 (MODIFY_EXPR, gcov_type_node, tmp1, ref);\n-  tree stmt2 = build2 (MODIFY_EXPR, gcov_type_node, tmp2,\n+  tree stmt1 = build2 (GIMPLE_MODIFY_STMT, gcov_type_node, tmp1, ref);\n+  tree stmt2 = build2 (GIMPLE_MODIFY_STMT, gcov_type_node, tmp2,\n \t\t       build2 (PLUS_EXPR, gcov_type_node, \n \t\t\t      tmp1, integer_one_node));\n-  tree stmt3 = build2 (MODIFY_EXPR, gcov_type_node, ref, tmp2);\n+  tree stmt3 = build2 (GIMPLE_MODIFY_STMT, gcov_type_node, ref, tmp2);\n   bsi_insert_on_edge (e, stmt1);\n   bsi_insert_on_edge (e, stmt2);\n   bsi_insert_on_edge (e, stmt3);"}, {"sha": "b882d458b882ec8fccde3a271ae5779da70b31f3", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -48,7 +48,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    Given a scalar variable to be analyzed, follow the SSA edge to\n    its definition:\n      \n-   - When the definition is a MODIFY_EXPR: if the right hand side\n+   - When the definition is a GIMPLE_MODIFY_STMT: if the right hand side\n    (RHS) of the definition cannot be statically analyzed, the answer\n    of the analyzer is: \"don't know\".  \n    Otherwise, for all the variables that are not yet analyzed in the\n@@ -1405,15 +1405,15 @@ follow_ssa_edge (struct loop *loop, tree def, tree halting_phi,\n       /* Outer loop.  */\n       return t_false;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       return follow_ssa_edge_in_rhs (loop, def,\n-\t\t\t\t     TREE_OPERAND (def, 1), \n+\t\t\t\t     GIMPLE_STMT_OPERAND (def, 1), \n \t\t\t\t     halting_phi, \n \t\t\t\t     evolution_of_loop, limit);\n       \n     default:\n       /* At this level of abstraction, the program is just a set\n-\t of MODIFY_EXPRs and PHI_NODEs.  In principle there is no\n+\t of GIMPLE_MODIFY_STMTs and PHI_NODEs.  In principle there is no\n \t other node to be handled.  */\n       return t_false;\n     }\n@@ -1607,16 +1607,16 @@ interpret_condition_phi (struct loop *loop, tree condition_phi)\n   return res;\n }\n \n-/* Interpret the right hand side of a modify_expr OPND1.  If we didn't\n+/* Interpret the right hand side of a GIMPLE_MODIFY_STMT OPND1.  If we didn't\n    analyze this node before, follow the definitions until ending\n-   either on an analyzed modify_expr, or on a loop-phi-node.  On the\n+   either on an analyzed GIMPLE_MODIFY_STMT, or on a loop-phi-node.  On the\n    return path, this function propagates evolutions (ala constant copy\n    propagation).  OPND1 is not a GIMPLE expression because we could\n    analyze the effect of an inner loop: see interpret_loop_phi.  */\n \n static tree\n-interpret_rhs_modify_expr (struct loop *loop, tree at_stmt,\n-\t\t\t   tree opnd1, tree type)\n+interpret_rhs_modify_stmt (struct loop *loop, tree at_stmt,\n+\t\t\t   \t  tree opnd1, tree type)\n {\n   tree res, opnd10, opnd11, chrec10, chrec11;\n \n@@ -1883,15 +1883,15 @@ pointer_used_p (tree ptr)\n       if (TREE_CODE (stmt) == COND_EXPR)\n \treturn true;\n \n-      if (TREE_CODE (stmt) != MODIFY_EXPR)\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \tcontinue;\n \n-      rhs = TREE_OPERAND (stmt, 1);\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n       if (!COMPARISON_CLASS_P (rhs))\n \tcontinue;\n \n-      if (TREE_OPERAND (stmt, 0) == ptr\n-\t  || TREE_OPERAND (stmt, 1) == ptr)\n+      if (GIMPLE_STMT_OPERAND (stmt, 0) == ptr\n+\t  || GIMPLE_STMT_OPERAND (stmt, 1) == ptr)\n \treturn true;\n     }\n \n@@ -1911,7 +1911,7 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n     return chrec_dont_know;\n \n   if (TREE_CODE (var) != SSA_NAME)\n-    return interpret_rhs_modify_expr (loop, NULL_TREE, var, type);\n+    return interpret_rhs_modify_stmt (loop, NULL_TREE, var, type);\n \n   def = SSA_NAME_DEF_STMT (var);\n   bb = bb_for_stmt (def);\n@@ -1944,8 +1944,9 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n \n   switch (TREE_CODE (def))\n     {\n-    case MODIFY_EXPR:\n-      res = interpret_rhs_modify_expr (loop, def, TREE_OPERAND (def, 1), type);\n+    case GIMPLE_MODIFY_STMT:\n+      res = interpret_rhs_modify_stmt (loop, def,\n+\t  \t\t\t       GIMPLE_STMT_OPERAND (def, 1), type);\n \n       if (POINTER_TYPE_P (type)\n \t  && !automatically_generated_chrec_p (res)\n@@ -3005,14 +3006,14 @@ scev_const_prop (void)\n \t  SET_PHI_RESULT (phi, NULL_TREE);\n \t  remove_phi_node (phi, NULL_TREE);\n \n-\t  ass = build2 (MODIFY_EXPR, void_type_node, rslt, NULL_TREE);\n+\t  ass = build2 (GIMPLE_MODIFY_STMT, void_type_node, rslt, NULL_TREE);\n \t  SSA_NAME_DEF_STMT (rslt) = ass;\n \t  {\n \t    block_stmt_iterator dest = bsi;\n \t    bsi_insert_before (&dest, ass, BSI_NEW_STMT);\n \t    def = force_gimple_operand_bsi (&dest, def, false, NULL_TREE);\n \t  }\n-\t  TREE_OPERAND (ass, 1) = def;\n+\t  GIMPLE_STMT_OPERAND (ass, 1) = def;\n \t  update_stmt (ass);\n \t}\n     }"}, {"sha": "2db1925013ce7ae7220b1afcdce1e43a6d4bdd48", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -851,17 +851,17 @@ sra_walk_asm_expr (tree expr, block_stmt_iterator *bsi,\n   sra_walk_tree_list (ASM_OUTPUTS (expr), bsi, true, fns);\n }\n \n-/* Walk a MODIFY_EXPR and categorize the assignment appropriately.  */\n+/* Walk a GIMPLE_MODIFY_STMT and categorize the assignment appropriately.  */\n \n static void\n-sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n+sra_walk_gimple_modify_stmt (tree expr, block_stmt_iterator *bsi,\n \t\t      const struct sra_walk_fns *fns)\n {\n   struct sra_elt *lhs_elt, *rhs_elt;\n   tree lhs, rhs;\n \n-  lhs = TREE_OPERAND (expr, 0);\n-  rhs = TREE_OPERAND (expr, 1);\n+  lhs = GIMPLE_STMT_OPERAND (expr, 0);\n+  rhs = GIMPLE_STMT_OPERAND (expr, 1);\n   lhs_elt = maybe_lookup_element_for_expr (lhs);\n   rhs_elt = maybe_lookup_element_for_expr (rhs);\n \n@@ -878,7 +878,7 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n       if (!rhs_elt->is_scalar)\n \tfns->ldst (rhs_elt, lhs, bsi, false);\n       else\n-\tfns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false, false);\n+\tfns->use (rhs_elt, &GIMPLE_STMT_OPERAND (expr, 1), bsi, false, false);\n     }\n \n   /* If it isn't scalarizable, there may be scalarizable variables within, so\n@@ -892,7 +892,7 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n       if (call)\n \tsra_walk_call_expr (call, bsi, fns);\n       else\n-\tsra_walk_expr (&TREE_OPERAND (expr, 1), bsi, false, fns);\n+\tsra_walk_expr (&GIMPLE_STMT_OPERAND (expr, 1), bsi, false, fns);\n     }\n \n   /* Likewise, handle the LHS being scalarizable.  We have cases similar\n@@ -924,14 +924,14 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n       /* Otherwise we're being used in some context that requires the\n \t aggregate to be seen as a whole.  Invoke USE.  */\n       else\n-\tfns->use (lhs_elt, &TREE_OPERAND (expr, 0), bsi, true, false);\n+\tfns->use (lhs_elt, &GIMPLE_STMT_OPERAND (expr, 0), bsi, true, false);\n     }\n \n   /* Similarly to above, LHS_ELT being null only means that the LHS as a\n      whole is not a scalarizable reference.  There may be occurrences of\n      scalarizable variables within, which implies a USE.  */\n   else\n-    sra_walk_expr (&TREE_OPERAND (expr, 0), bsi, true, fns);\n+    sra_walk_expr (&GIMPLE_STMT_OPERAND (expr, 0), bsi, true, fns);\n }\n \n /* Entry point to the walk functions.  Search the entire function,\n@@ -977,14 +977,14 @@ sra_walk_function (const struct sra_walk_fns *fns)\n \t       as a USE of the variable on the RHS of this assignment.  */\n \n \t    t = TREE_OPERAND (stmt, 0);\n-\t    if (TREE_CODE (t) == MODIFY_EXPR)\n-\t      sra_walk_expr (&TREE_OPERAND (t, 1), &si, false, fns);\n+\t    if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+\t      sra_walk_expr (&GIMPLE_STMT_OPERAND (t, 1), &si, false, fns);\n \t    else\n \t      sra_walk_expr (&TREE_OPERAND (stmt, 0), &si, false, fns);\n \t    break;\n \n-\t  case MODIFY_EXPR:\n-\t    sra_walk_modify_expr (stmt, &si, fns);\n+\t  case GIMPLE_MODIFY_STMT:\n+\t    sra_walk_gimple_modify_stmt (stmt, &si, fns);\n \t    break;\n \t  case CALL_EXPR:\n \t    sra_walk_call_expr (stmt, &si, fns);\n@@ -1689,16 +1689,16 @@ generate_copy_inout (struct sra_elt *elt, bool copy_out, tree expr,\n       i = c->replacement;\n \n       t = build2 (COMPLEX_EXPR, elt->type, r, i);\n-      t = build2 (MODIFY_EXPR, void_type_node, expr, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, expr, t);\n       SSA_NAME_DEF_STMT (expr) = t;\n       append_to_statement_list (t, list_p);\n     }\n   else if (elt->replacement)\n     {\n       if (copy_out)\n-\tt = build2 (MODIFY_EXPR, void_type_node, elt->replacement, expr);\n+\tt = build2 (GIMPLE_MODIFY_STMT, void_type_node, elt->replacement, expr);\n       else\n-\tt = build2 (MODIFY_EXPR, void_type_node, expr, elt->replacement);\n+\tt = build2 (GIMPLE_MODIFY_STMT, void_type_node, expr, elt->replacement);\n       append_to_statement_list (t, list_p);\n     }\n   else\n@@ -1733,7 +1733,7 @@ generate_element_copy (struct sra_elt *dst, struct sra_elt *src, tree *list_p)\n \n       gcc_assert (src->replacement);\n \n-      t = build2 (MODIFY_EXPR, void_type_node, dst->replacement,\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, dst->replacement,\n \t\t  src->replacement);\n       append_to_statement_list (t, list_p);\n     }\n@@ -1765,7 +1765,7 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n       gcc_assert (elt->is_scalar);\n       t = fold_convert (elt->type, integer_zero_node);\n \n-      t = build2 (MODIFY_EXPR, void_type_node, elt->replacement, t);\n+      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, elt->replacement, t);\n       append_to_statement_list (t, list_p);\n     }\n }\n@@ -1777,7 +1777,7 @@ static void\n generate_one_element_init (tree var, tree init, tree *list_p)\n {\n   /* The replacement can be almost arbitrarily complex.  Gimplify.  */\n-  tree stmt = build2 (MODIFY_EXPR, void_type_node, var, init);\n+  tree stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, var, init);\n   gimplify_and_add (stmt, list_p);\n }\n \n@@ -2024,10 +2024,10 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n \n       /* See the commentary in sra_walk_function concerning\n \t RETURN_EXPR, and why we should never see one here.  */\n-      gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n+      gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n \n-      TREE_OPERAND (stmt, 0) = lhs_elt->replacement;\n-      TREE_OPERAND (stmt, 1) = rhs_elt->replacement;\n+      GIMPLE_STMT_OPERAND (stmt, 0) = lhs_elt->replacement;\n+      GIMPLE_STMT_OPERAND (stmt, 1) = rhs_elt->replacement;\n       update_stmt (stmt);\n     }\n   else if (lhs_elt->use_block_copy || rhs_elt->use_block_copy)"}, {"sha": "6853ea14712c115568e04fc94d9a2a298331f4a7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -408,7 +408,7 @@ compute_call_clobbered (struct alias_info *ai)\n static bool\n lhs_may_store_to (tree stmt, tree sym ATTRIBUTE_UNUSED)\n {\n-  tree lhs = TREE_OPERAND (stmt, 0);\n+  tree lhs = GENERIC_TREE_OPERAND (stmt, 0);\n   \n   lhs = get_base_address (lhs);\n   \n@@ -459,8 +459,8 @@ recalculate_used_alone (void)\n \t  stmt = bsi_stmt (bsi);\n \t  \n \t  if (TREE_CODE (stmt) == CALL_EXPR\n-\t      || (TREE_CODE (stmt) == MODIFY_EXPR \n-\t\t  && TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR))\n+\t      || (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT \n+\t\t  && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR))\n \t    {\n \t      iscall = true;\n \t      VEC_safe_push (tree, heap, calls, stmt);\t    \n@@ -786,24 +786,24 @@ count_uses_and_derefs (tree ptr, tree stmt, unsigned *num_uses_p,\n      find all the indirect and direct uses of x_1 inside.  The only\n      shortcut we can take is the fact that GIMPLE only allows\n      INDIRECT_REFs inside the expressions below.  */\n-  if (TREE_CODE (stmt) == MODIFY_EXPR\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n       || (TREE_CODE (stmt) == RETURN_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (stmt, 0)) == GIMPLE_MODIFY_STMT)\n       || TREE_CODE (stmt) == ASM_EXPR\n       || TREE_CODE (stmt) == CALL_EXPR)\n     {\n       tree lhs, rhs;\n \n-      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t{\n-\t  lhs = TREE_OPERAND (stmt, 0);\n-\t  rhs = TREE_OPERAND (stmt, 1);\n+\t  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \t}\n       else if (TREE_CODE (stmt) == RETURN_EXPR)\n \t{\n \t  tree e = TREE_OPERAND (stmt, 0);\n-\t  lhs = TREE_OPERAND (e, 0);\n-\t  rhs = TREE_OPERAND (e, 1);\n+\t  lhs = GIMPLE_STMT_OPERAND (e, 0);\n+\t  rhs = GIMPLE_STMT_OPERAND (e, 1);\n \t}\n       else if (TREE_CODE (stmt) == ASM_EXPR)\n \t{\n@@ -816,7 +816,8 @@ count_uses_and_derefs (tree ptr, tree stmt, unsigned *num_uses_p,\n \t  rhs = stmt;\n \t}\n \n-      if (lhs && (TREE_CODE (lhs) == TREE_LIST || EXPR_P (lhs)))\n+      if (lhs && (TREE_CODE (lhs) == TREE_LIST\n+\t\t  || EXPR_P (lhs) || GIMPLE_STMT_P (lhs)))\n \t{\n \t  struct count_ptr_d count;\n \t  count.ptr = ptr;\n@@ -826,7 +827,8 @@ count_uses_and_derefs (tree ptr, tree stmt, unsigned *num_uses_p,\n \t  *num_derefs_p = count.count;\n \t}\n \n-      if (rhs && (TREE_CODE (rhs) == TREE_LIST || EXPR_P (rhs)))\n+      if (rhs && (TREE_CODE (rhs) == TREE_LIST\n+\t\t  || EXPR_P (rhs) || GIMPLE_STMT_P (rhs)))\n \t{\n \t  struct count_ptr_d count;\n \t  count.ptr = ptr;\n@@ -2167,9 +2169,9 @@ is_escape_site (tree stmt)\n     }\n   else if (TREE_CODE (stmt) == ASM_EXPR)\n     return ESCAPE_TO_ASM;\n-  else if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      tree lhs = TREE_OPERAND (stmt, 0);\n+      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n \n       /* Get to the base of _REF nodes.  */\n       if (TREE_CODE (lhs) != SSA_NAME)\n@@ -2180,12 +2182,13 @@ is_escape_site (tree stmt)\n       if (lhs == NULL_TREE)\n \treturn ESCAPE_UNKNOWN;\n \n-      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == NOP_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (stmt, 1)) == CONVERT_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (stmt, 1)) == VIEW_CONVERT_EXPR)\n+      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == NOP_EXPR\n+\t  || TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CONVERT_EXPR\n+\t  || TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == VIEW_CONVERT_EXPR)\n \t{\n-\t  tree from = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (stmt, 1), 0));\n-\t  tree to = TREE_TYPE (TREE_OPERAND (stmt, 1));\n+\t  tree from\n+\t    = TREE_TYPE (TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 0));\n+\t  tree to = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 1));\n \n \t  /* If the RHS is a conversion between a pointer and an integer, the\n \t     pointer escapes since we can't track the integer.  */\n@@ -3173,11 +3176,12 @@ find_used_portions (tree *tp, int *walk_subtrees, void *lhs_p)\n {\n   switch (TREE_CODE (*tp))\n     {\n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       /* Recurse manually here to track whether the use is in the\n \t LHS of an assignment.  */\n-      find_used_portions (&TREE_OPERAND (*tp, 0), walk_subtrees, tp);\n-      return find_used_portions (&TREE_OPERAND (*tp, 1), walk_subtrees, NULL);\n+      find_used_portions (&GIMPLE_STMT_OPERAND (*tp, 0), walk_subtrees, tp);\n+      return find_used_portions (&GIMPLE_STMT_OPERAND (*tp, 1),\n+\t  \t\t\t walk_subtrees, NULL);\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n     case COMPONENT_REF:"}, {"sha": "c8ec228e244c1b859dcdd2366a963f32c01cafde", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -375,7 +375,7 @@ get_default_value (tree var)\n \t  else\n \t    val.lattice_val = VARYING;\n \t}\n-      else if (TREE_CODE (stmt) == MODIFY_EXPR\n+      else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n \t       || TREE_CODE (stmt) == PHI_NODE)\n \t{\n \t  /* Any other variable defined by an assignment or a PHI node\n@@ -543,7 +543,7 @@ likely_value (tree stmt)\n \n   /* Anything other than assignments and conditional jumps are not\n      interesting for CCP.  */\n-  if (TREE_CODE (stmt) != MODIFY_EXPR\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n       && !(TREE_CODE (stmt) == RETURN_EXPR && get_rhs (stmt) != NULL_TREE)\n       && TREE_CODE (stmt) != COND_EXPR\n       && TREE_CODE (stmt) != SWITCH_EXPR)\n@@ -601,7 +601,7 @@ surely_varying_stmt_p (tree stmt)\n \n   /* Anything other than assignments and conditional jumps are not\n      interesting for CCP.  */\n-  if (TREE_CODE (stmt) != MODIFY_EXPR\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n       && !(TREE_CODE (stmt) == RETURN_EXPR && get_rhs (stmt) != NULL_TREE)\n       && TREE_CODE (stmt) != COND_EXPR\n       && TREE_CODE (stmt) != SWITCH_EXPR)\n@@ -1184,8 +1184,8 @@ visit_assignment (tree stmt, tree *output_p)\n   tree lhs, rhs;\n   enum ssa_prop_result retval;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n-  rhs = TREE_OPERAND (stmt, 1);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n@@ -1219,7 +1219,7 @@ visit_assignment (tree stmt, tree *output_p)\n      the constant value into the type of the destination variable.  This\n      should not be necessary if GCC represented bitfields properly.  */\n   {\n-    tree orig_lhs = TREE_OPERAND (stmt, 0);\n+    tree orig_lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n \n     if (TREE_CODE (orig_lhs) == VIEW_CONVERT_EXPR\n \t&& val.lattice_val == CONSTANT)\n@@ -1364,7 +1364,7 @@ ccp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n       /* If the statement is an assignment that produces a single\n \t output value, evaluate its RHS to see if the lattice value of\n@@ -2145,14 +2145,14 @@ get_maxval_strlen (tree arg, tree *length, bitmap visited, int type)\n \n   switch (TREE_CODE (def_stmt))\n     {\n-      case MODIFY_EXPR:\n+      case GIMPLE_MODIFY_STMT:\n \t{\n \t  tree rhs;\n \n \t  /* The RHS of the statement defining VAR must either have a\n \t     constant length or come from another SSA_NAME with a constant\n \t     length.  */\n-\t  rhs = TREE_OPERAND (def_stmt, 1);\n+\t  rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n \t  STRIP_NOPS (rhs);\n \t  return get_maxval_strlen (rhs, length, visited, type);\n \t}\n@@ -2204,7 +2204,7 @@ ccp_fold_builtin (tree stmt, tree fn)\n   bitmap visited;\n   bool ignore;\n \n-  ignore = TREE_CODE (stmt) != MODIFY_EXPR;\n+  ignore = TREE_CODE (stmt) != GIMPLE_MODIFY_STMT;\n \n   /* First try the generic builtin folder.  If that succeeds, return the\n      result directly.  */\n@@ -2308,13 +2308,13 @@ ccp_fold_builtin (tree stmt, tree fn)\n \n     case BUILT_IN_FPUTS:\n       result = fold_builtin_fputs (arglist,\n-\t\t\t\t   TREE_CODE (stmt) != MODIFY_EXPR, 0,\n+\t\t\t\t   TREE_CODE (stmt) != GIMPLE_MODIFY_STMT, 0,\n \t\t\t\t   val[0]);\n       break;\n \n     case BUILT_IN_FPUTS_UNLOCKED:\n       result = fold_builtin_fputs (arglist,\n-\t\t\t\t   TREE_CODE (stmt) != MODIFY_EXPR, 1,\n+\t\t\t\t   TREE_CODE (stmt) != GIMPLE_MODIFY_STMT, 1,\n \t\t\t\t   val[0]);\n       break;\n \n@@ -2578,7 +2578,7 @@ execute_fold_all_builtins (void)\n \t    {\n \t      result = convert_to_gimple_builtin (&i, result,\n \t\t\t      \t\t\t  TREE_CODE (old_stmt)\n-\t\t\t\t\t\t  != MODIFY_EXPR);\n+\t\t\t\t\t\t  != GIMPLE_MODIFY_STMT);\n \t      if (result)\n \t\t{\n \t\t  bool ok = set_rhs (stmtp, result);"}, {"sha": "6b9f353034601afc4bcb732421b6cce16fca01bf", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -370,11 +370,11 @@ stmt_may_generate_copy (tree stmt)\n   if (TREE_CODE (stmt) == PHI_NODE)\n     return !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (stmt));\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n-  rhs = TREE_OPERAND (stmt, 1);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n   ann = stmt_ann (stmt);\n \n   /* If the statement has volatile operands, it won't generate a\n@@ -554,8 +554,8 @@ copy_prop_visit_assignment (tree stmt, tree *result_p)\n   tree lhs, rhs;\n   prop_value_t *rhs_val;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n-  rhs = TREE_OPERAND (stmt, 1);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   gcc_assert (TREE_CODE (rhs) == SSA_NAME);\n \n@@ -690,17 +690,17 @@ copy_prop_visit_stmt (tree stmt, edge *taken_edge_p, tree *result_p)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR\n-      && TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == SSA_NAME\n       && (do_store_copy_prop\n-\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME))\n+\t  || TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME))\n     {\n       /* If the statement is a copy assignment, evaluate its RHS to\n \t see if the lattice value of its output has changed.  */\n       retval = copy_prop_visit_assignment (stmt, result_p);\n     }\n-  else if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n+  else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t   && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n \t   && do_store_copy_prop\n \t   && stmt_makes_single_load (stmt))\n     {\n@@ -711,14 +711,14 @@ copy_prop_visit_stmt (tree stmt, edge *taken_edge_p, tree *result_p)\n       if (val\n \t  && val->mem_ref\n \t  && is_gimple_reg (val->value)\n-\t  && operand_equal_p (val->mem_ref, TREE_OPERAND (stmt, 1), 0))\n+\t  && operand_equal_p (val->mem_ref, GIMPLE_STMT_OPERAND (stmt, 1), 0))\n         {\n \t  bool changed;\n-\t  changed = set_copy_of_val (TREE_OPERAND (stmt, 0),\n+\t  changed = set_copy_of_val (GIMPLE_STMT_OPERAND (stmt, 0),\n \t\t\t\t     val->value, val->mem_ref);\n \t  if (changed)\n \t    {\n-\t      *result_p = TREE_OPERAND (stmt, 0);\n+\t      *result_p = GIMPLE_STMT_OPERAND (stmt, 0);\n \t      retval = SSA_PROP_INTERESTING;\n \t    }\n \t  else\n@@ -910,7 +910,7 @@ init_copy_prop (void)\n \t  if (stmt_ends_bb_p (stmt))\n \t    DONT_SIMULATE_AGAIN (stmt) = false;\n \t  else if (stmt_may_generate_copy (stmt)\n-\t\t   && loop_depth_of_name (TREE_OPERAND (stmt, 1)) <= depth)\n+\t\t   && loop_depth_of_name (GIMPLE_STMT_OPERAND (stmt, 1)) <= depth)\n \t    DONT_SIMULATE_AGAIN (stmt) = false;\n \t  else\n \t    DONT_SIMULATE_AGAIN (stmt) = true;"}, {"sha": "a2423a02ff8dc78f72096ad3d3bd37d499484276", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -315,10 +315,10 @@ rename_ssa_copies (void)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  stmt = bsi_stmt (bsi); \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t    {\n-\t      tree lhs = TREE_OPERAND (stmt, 0);\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n               if (TREE_CODE (lhs) == SSA_NAME && TREE_CODE (rhs) == SSA_NAME)\n \t\tcopy_rename_partition_coalesce (map, lhs, rhs, debug);"}, {"sha": "3b205629e33da41ae495e50e6bfd7b9d3edad629", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -216,7 +216,7 @@ find_pdom (basic_block block)\n     }\n }\n \f\n-#define NECESSARY(stmt)\t\tstmt->common.asm_written_flag\n+#define NECESSARY(stmt)\t\tstmt->base.asm_written_flag\n \n /* If STMT is not already marked necessary, mark it, and add it to the\n    worklist if ADD_TO_WORKLIST is true.  */\n@@ -318,7 +318,7 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n \tmark_stmt_necessary (stmt, true);\n       return;\n \n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       op = get_call_expr_in (stmt);\n       if (op && TREE_SIDE_EFFECTS (op))\n \t{\n@@ -329,8 +329,8 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n       /* These values are mildly magic bits of the EH runtime.  We can't\n \t see the entire lifetime of these values until landing pads are\n \t generated.  */\n-      if (TREE_CODE (TREE_OPERAND (stmt, 0)) == EXC_PTR_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == FILTER_EXPR)\n+      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == EXC_PTR_EXPR\n+\t  || TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == FILTER_EXPR)\n \t{\n \t  mark_stmt_necessary (stmt, true);\n \t  return;"}, {"sha": "134cfe934e8d052a69efd13d359c45580a30991f", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -489,7 +489,7 @@ initialize_hash_element (tree expr, tree lhs, struct expr_hash_elt *element)\n   else if (TREE_CODE (expr) == RETURN_EXPR && TREE_OPERAND (expr, 0))\n     {\n       element->stmt = expr;\n-      element->rhs = TREE_OPERAND (TREE_OPERAND (expr, 0), 1);\n+      element->rhs = GIMPLE_STMT_OPERAND (TREE_OPERAND (expr, 0), 1);\n     }\n   else if (TREE_CODE (expr) == GOTO_EXPR)\n     {\n@@ -499,7 +499,7 @@ initialize_hash_element (tree expr, tree lhs, struct expr_hash_elt *element)\n   else\n     {\n       element->stmt = expr;\n-      element->rhs = TREE_OPERAND (expr, 1);\n+      element->rhs = GENERIC_TREE_OPERAND (expr, 1);\n     }\n \n   element->lhs = lhs;\n@@ -1183,14 +1183,14 @@ simple_iv_increment_p (tree stmt)\n   tree lhs, rhs, preinc, phi;\n   unsigned i;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   if (TREE_CODE (lhs) != SSA_NAME)\n     return false;\n \n-  rhs = TREE_OPERAND (stmt, 1);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   if (TREE_CODE (rhs) != PLUS_EXPR\n       && TREE_CODE (rhs) != MINUS_EXPR)\n@@ -1473,8 +1473,8 @@ eliminate_redundant_computations (tree stmt)\n   bool retval = false;\n   bool modify_expr_p = false;\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n-    def = TREE_OPERAND (stmt, 0);\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+    def = GIMPLE_STMT_OPERAND (stmt, 0);\n \n   /* Certain expressions on the RHS can be optimized away, but can not\n      themselves be entered into the hash tables.  */\n@@ -1499,12 +1499,12 @@ eliminate_redundant_computations (tree stmt)\n     expr_p = &SWITCH_COND (stmt);\n   else if (TREE_CODE (stmt) == RETURN_EXPR && TREE_OPERAND (stmt, 0))\n     {\n-      expr_p = &TREE_OPERAND (TREE_OPERAND (stmt, 0), 1);\n+      expr_p = &GIMPLE_STMT_OPERAND (TREE_OPERAND (stmt, 0), 1);\n       modify_expr_p = true;\n     }\n   else\n     {\n-      expr_p = &TREE_OPERAND (stmt, 1);\n+      expr_p = &GENERIC_TREE_OPERAND (stmt, 1);\n       modify_expr_p = true;\n     }\n \n@@ -1552,7 +1552,7 @@ eliminate_redundant_computations (tree stmt)\n   return retval;\n }\n \n-/* STMT, a MODIFY_EXPR, may create certain equivalences, in either\n+/* STMT, a GIMPLE_MODIFY_STMT, may create certain equivalences, in either\n    the available expressions table or the const_and_copies table.\n    Detect and record those equivalences.  */\n \n@@ -1561,12 +1561,12 @@ record_equivalences_from_stmt (tree stmt,\n \t\t\t       int may_optimize_p,\n \t\t\t       stmt_ann_t ann)\n {\n-  tree lhs = TREE_OPERAND (stmt, 0);\n+  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   enum tree_code lhs_code = TREE_CODE (lhs);\n \n   if (lhs_code == SSA_NAME)\n     {\n-      tree rhs = TREE_OPERAND (stmt, 1);\n+      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n       /* Strip away any useless type conversions.  */\n       STRIP_USELESS_TYPE_CONVERSION (rhs);\n@@ -1588,11 +1588,11 @@ record_equivalences_from_stmt (tree stmt,\n      vops and recording the result in the available expression table,\n      we may be able to expose more redundant loads.  */\n   if (!ann->has_volatile_ops\n-      && (TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME\n-\t  || is_gimple_min_invariant (TREE_OPERAND (stmt, 1)))\n+      && (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == SSA_NAME\n+\t  || is_gimple_min_invariant (GIMPLE_STMT_OPERAND (stmt, 1)))\n       && !is_gimple_reg (lhs))\n     {\n-      tree rhs = TREE_OPERAND (stmt, 1);\n+      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n       tree new;\n \n       /* FIXME: If the LHS of the assignment is a bitfield and the RHS\n@@ -1619,7 +1619,7 @@ record_equivalences_from_stmt (tree stmt,\n       if (rhs)\n \t{\n \t  /* Build a new statement with the RHS and LHS exchanged.  */\n-\t  new = build2 (MODIFY_EXPR, TREE_TYPE (stmt), rhs, lhs);\n+\t  new = build2_gimple (GIMPLE_MODIFY_STMT, rhs, lhs);\n \n \t  create_ssa_artficial_load_stmt (new, stmt);\n \n@@ -1840,19 +1840,22 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   may_optimize_p = (!ann->has_volatile_ops\n \t\t    && ((TREE_CODE (stmt) == RETURN_EXPR\n \t\t\t && TREE_OPERAND (stmt, 0)\n-\t\t\t && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR\n+\t\t\t && TREE_CODE (TREE_OPERAND (stmt, 0))\n+\t\t\t    == GIMPLE_MODIFY_STMT\n \t\t\t && ! (TREE_SIDE_EFFECTS\n-\t\t\t       (TREE_OPERAND (TREE_OPERAND (stmt, 0), 1))))\n-\t\t\t|| (TREE_CODE (stmt) == MODIFY_EXPR\n-\t\t\t    && ! TREE_SIDE_EFFECTS (TREE_OPERAND (stmt, 1)))\n+\t\t\t       (GIMPLE_STMT_OPERAND\n+\t\t\t\t(TREE_OPERAND (stmt, 0), 1))))\n+\t\t\t|| (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t\t\t    && ! TREE_SIDE_EFFECTS (GIMPLE_STMT_OPERAND (stmt,\n+\t\t\t\t\t\t\t\t\t 1)))\n \t\t\t|| TREE_CODE (stmt) == COND_EXPR\n \t\t\t|| TREE_CODE (stmt) == SWITCH_EXPR));\n \n   if (may_optimize_p)\n     may_have_exposed_new_symbols |= eliminate_redundant_computations (stmt);\n \n   /* Record any additional equivalences created by this statement.  */\n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     record_equivalences_from_stmt (stmt,\n \t\t\t\t   may_optimize_p,\n \t\t\t\t   ann);\n@@ -1917,7 +1920,7 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n    is also added to the stack pointed to by BLOCK_AVAIL_EXPRS_P, so that they\n    can be removed when we finish processing this block and its children.\n \n-   NOTE: This function assumes that STMT is a MODIFY_EXPR node that\n+   NOTE: This function assumes that STMT is a GIMPLE_MODIFY_STMT node that\n    contains no CALL_EXPR on its RHS and makes no volatile nor\n    aliased references.  */\n \n@@ -1929,7 +1932,8 @@ lookup_avail_expr (tree stmt, bool insert)\n   tree temp;\n   struct expr_hash_elt *element = XNEW (struct expr_hash_elt);\n \n-  lhs = TREE_CODE (stmt) == MODIFY_EXPR ? TREE_OPERAND (stmt, 0) : NULL;\n+  lhs = TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+    \t\t\t    ? GIMPLE_STMT_OPERAND (stmt, 0) : NULL;\n \n   initialize_hash_element (stmt, lhs, element);\n \n@@ -1978,8 +1982,8 @@ lookup_avail_expr (tree stmt, bool insert)\n }\n \n /* Hashing and equality functions for AVAIL_EXPRS.  The table stores\n-   MODIFY_EXPR statements.  We compute a value number for expressions using\n-   the code of the expression and the SSA numbers of its operands.  */\n+   GIMPLE_MODIFY_STMT statements.  We compute a value number for expressions\n+   using the code of the expression and the SSA numbers of its operands.  */\n \n static hashval_t\n avail_expr_hash (const void *p)\n@@ -2078,7 +2082,7 @@ degenerate_phi_result (tree phi)\n   return (i == PHI_NUM_ARGS (phi) ? val : NULL);\n }\n \n-/* Given a tree node T, which is either a PHI_NODE or MODIFY_EXPR,\n+/* Given a tree node T, which is either a PHI_NODE or GIMPLE_MODIFY_STMT,\n    remove it from the IL.  */\n \n static void\n@@ -2093,7 +2097,7 @@ remove_stmt_or_phi (tree t)\n     }\n }\n \n-/* Given a tree node T, which is either a PHI_NODE or MODIFY_EXPR,\n+/* Given a tree node T, which is either a PHI_NODE or GIMPLE_MODIFY_STMT,\n    return the \"rhs\" of the node, in the case of a non-degenerate\n    PHI, NULL is returned.  */\n \n@@ -2102,22 +2106,22 @@ get_rhs_or_phi_arg (tree t)\n {\n   if (TREE_CODE (t) == PHI_NODE)\n     return degenerate_phi_result (t);\n-  else if (TREE_CODE (t) == MODIFY_EXPR)\n-    return TREE_OPERAND (t, 1);\n+  else if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+    return GIMPLE_STMT_OPERAND (t, 1);\n   gcc_unreachable ();\n }\n \n \n-/* Given a tree node T, which is either a PHI_NODE or a MODIFY_EXPR,\n+/* Given a tree node T, which is either a PHI_NODE or a GIMPLE_MODIFY_STMT,\n    return the \"lhs\" of the node.  */\n \n static tree\n get_lhs_or_phi_result (tree t)\n {\n   if (TREE_CODE (t) == PHI_NODE)\n     return PHI_RESULT (t);\n-  else if (TREE_CODE (t) == MODIFY_EXPR)\n-    return TREE_OPERAND (t, 0);\n+  else if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+    return GIMPLE_STMT_OPERAND (t, 0);\n   gcc_unreachable ();\n }\n \n@@ -2239,9 +2243,10 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n \n \t  /* If we replaced a variable index with a constant, then\n \t     we would need to update the invariant flag for ADDR_EXPRs.  */\n-\t  if (TREE_CODE (use_stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == ADDR_EXPR)\n-\t    recompute_tree_invariant_for_addr_expr (TREE_OPERAND (use_stmt, 1));\n+\t  if (TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr\n+\t      (GIMPLE_STMT_OPERAND (use_stmt, 1));\n \n \t  /* If we cleaned up EH information from the statement,\n \t     mark its containing block as needing EH cleanups.  */\n@@ -2254,10 +2259,11 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n \n \t  /* Propagation may expose new trivial copy/constant propagation\n \t     opportunities.  */\n-\t  if (TREE_CODE (use_stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (use_stmt, 0)) == SSA_NAME\n-\t      && (TREE_CODE (TREE_OPERAND (use_stmt, 1)) == SSA_NAME\n-\t\t  || is_gimple_min_invariant (TREE_OPERAND (use_stmt, 1))))\n+\t  if (TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) == SSA_NAME\n+\t      && (TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == SSA_NAME\n+\t\t  || is_gimple_min_invariant (GIMPLE_STMT_OPERAND (use_stmt,\n+\t\t      \t\t\t\t\t\t   1))))\n \t    {\n \t      tree result = get_lhs_or_phi_result (use_stmt);\n \t      bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));"}, {"sha": "8cc4762ea04fd919e3dfd11b643fc563c39ba7da", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -205,7 +205,7 @@ memory_address_same (tree store1, tree store2)\n   walk_data.store1_bb = bb_for_stmt (store1);\n   walk_data.store2_bb = bb_for_stmt (store2);\n \n-  return (walk_tree (&TREE_OPERAND (store1, 0), memory_ssa_name_same,\n+  return (walk_tree (&GIMPLE_STMT_OPERAND (store1, 0), memory_ssa_name_same,\n \t\t     &walk_data, NULL)\n \t  == NULL);\n }\n@@ -237,15 +237,15 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n   if (ZERO_SSA_OPERANDS (stmt, (SSA_OP_VMAYDEF|SSA_OP_VMUSTDEF)))\n     return;\n \n-  /* We know we have virtual definitions.  If this is a MODIFY_EXPR that's\n-     not also a function call, then record it into our table.  */\n+  /* We know we have virtual definitions.  If this is a GIMPLE_MODIFY_STMT\n+     that's not also a function call, then record it into our table.  */\n   if (get_call_expr_in (stmt))\n     return;\n \n   if (ann->has_volatile_ops)\n     return;\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n       use_operand_p first_use_p = NULL_USE_OPERAND_P;\n       use_operand_p use_p = NULL;\n@@ -328,8 +328,8 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \t SSA-form variables in the address will have the same values.  */\n       if (use_p != NULL_USE_OPERAND_P\n \t  && bitmap_bit_p (dse_gd->stores, get_stmt_uid (use_stmt))\n-\t  && operand_equal_p (TREE_OPERAND (stmt, 0),\n-\t\t\t      TREE_OPERAND (use_stmt, 0), 0)\n+\t  && operand_equal_p (GIMPLE_STMT_OPERAND (stmt, 0),\n+\t\t\t      GIMPLE_STMT_OPERAND (use_stmt, 0), 0)\n \t  && memory_address_same (stmt, use_stmt))\n \t{\n \t  /* Make sure we propagate the ABNORMAL bit setting.  */"}, {"sha": "dd20d00bf228e84fa9140f3f5cdd88fb9f2ee2f0", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -162,9 +162,9 @@ ssa_name_defined_by_comparison_p (tree var)\n {\n   tree def = SSA_NAME_DEF_STMT (var);\n \n-  if (TREE_CODE (def) == MODIFY_EXPR)\n+  if (TREE_CODE (def) == GIMPLE_MODIFY_STMT)\n     {\n-      tree rhs = TREE_OPERAND (def, 1);\n+      tree rhs = GIMPLE_STMT_OPERAND (def, 1);\n       return COMPARISON_CLASS_P (rhs);\n     }\n \n@@ -203,12 +203,12 @@ forward_propagate_into_cond_1 (tree cond, tree *test_var_p)\n     test_var = TREE_OPERAND (cond, 0);\n \n   /* Now get the defining statement for TEST_VAR.  Skip this case if\n-     it's not defined by some MODIFY_EXPR.  */\n+     it's not defined by some GIMPLE_MODIFY_STMT.  */\n   def = SSA_NAME_DEF_STMT (test_var);\n-  if (TREE_CODE (def) != MODIFY_EXPR)\n+  if (TREE_CODE (def) != GIMPLE_MODIFY_STMT)\n     return NULL_TREE;\n \n-  def_rhs = TREE_OPERAND (def, 1);\n+  def_rhs = GIMPLE_STMT_OPERAND (def, 1);\n \n   /* If TEST_VAR is set by adding or subtracting a constant\n      from an SSA_NAME, then it is interesting to us as we\n@@ -429,15 +429,15 @@ find_equivalent_equality_comparison (tree cond)\n   tree def_stmt = SSA_NAME_DEF_STMT (op0);\n \n   while (def_stmt\n-\t && TREE_CODE (def_stmt) == MODIFY_EXPR\n-\t && TREE_CODE (TREE_OPERAND (def_stmt, 1)) == SSA_NAME)\n-    def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (def_stmt, 1));\n+\t && TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n+\t && TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == SSA_NAME)\n+    def_stmt = SSA_NAME_DEF_STMT (GIMPLE_STMT_OPERAND (def_stmt, 1));\n \n   /* OP0 might have been a parameter, so first make sure it\n-     was defined by a MODIFY_EXPR.  */\n-  if (def_stmt && TREE_CODE (def_stmt) == MODIFY_EXPR)\n+     was defined by a GIMPLE_MODIFY_STMT.  */\n+  if (def_stmt && TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      tree def_rhs = TREE_OPERAND (def_stmt, 1);\n+      tree def_rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n \n       /* If either operand to the comparison is a pointer to\n \t a function, then we can not apply this optimization\n@@ -450,7 +450,7 @@ find_equivalent_equality_comparison (tree cond)\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (op1))) == FUNCTION_TYPE))\n \treturn NULL;\n \t      \n-      /* Now make sure the RHS of the MODIFY_EXPR is a typecast.  */\n+      /* Now make sure the RHS of the GIMPLE_MODIFY_STMT is a typecast.  */\n       if ((TREE_CODE (def_rhs) == NOP_EXPR\n \t   || TREE_CODE (def_rhs) == CONVERT_EXPR)\n \t  && TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME)\n@@ -583,8 +583,8 @@ tidy_after_forward_propagate_addr (tree stmt)\n       && tree_purge_dead_eh_edges (bb_for_stmt (stmt)))\n     cfg_changed = true;\n \n-  if (TREE_CODE (TREE_OPERAND (stmt, 1)) == ADDR_EXPR)\n-     recompute_tree_invariant_for_addr_expr (TREE_OPERAND (stmt, 1));\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ADDR_EXPR)\n+     recompute_tree_invariant_for_addr_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n \n   mark_new_vars_to_rename (stmt);\n }\n@@ -610,13 +610,13 @@ forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n {\n   tree index;\n \n-  /* The offset must be defined by a simple MODIFY_EXPR statement.  */\n-  if (TREE_CODE (offset) != MODIFY_EXPR)\n+  /* The offset must be defined by a simple GIMPLE_MODIFY_STMT statement.  */\n+  if (TREE_CODE (offset) != GIMPLE_MODIFY_STMT)\n     return false;\n \n   /* The RHS of the statement which defines OFFSET must be a gimple\n      cast of another SSA_NAME.  */\n-  offset = TREE_OPERAND (offset, 1);\n+  offset = GIMPLE_STMT_OPERAND (offset, 1);\n   if (!is_gimple_cast (offset))\n     return false;\n \n@@ -629,15 +629,15 @@ forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n   offset = SSA_NAME_DEF_STMT (offset);\n \n   /* The statement which defines OFFSET before type conversion\n-     must be a simple MODIFY_EXPR.  */\n-  if (TREE_CODE (offset) != MODIFY_EXPR)\n+     must be a simple GIMPLE_MODIFY_STMT.  */\n+  if (TREE_CODE (offset) != GIMPLE_MODIFY_STMT)\n     return false;\n \n   /* The RHS of the statement which defines OFFSET must be a\n      multiplication of an object by the size of the array elements. \n      This implicitly verifies that the size of the array elements\n      is constant.  */\n-  offset = TREE_OPERAND (offset, 1);\n+  offset = GIMPLE_STMT_OPERAND (offset, 1);\n   if (TREE_CODE (offset) != MULT_EXPR\n       || TREE_CODE (TREE_OPERAND (offset, 1)) != INTEGER_CST\n       || !simple_cst_equal (TREE_OPERAND (offset, 1),\n@@ -648,8 +648,10 @@ forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n   index = TREE_OPERAND (offset, 0);\n \n   /* Replace the pointer addition with array indexing.  */\n-  TREE_OPERAND (use_stmt, 1) = unshare_expr (TREE_OPERAND (stmt, 1));\n-  TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 0), 1) = index;\n+  GIMPLE_STMT_OPERAND (use_stmt, 1)\n+    = unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n+  TREE_OPERAND (TREE_OPERAND (GIMPLE_STMT_OPERAND (use_stmt, 1), 0), 1)\n+    = index;\n \n   /* That should have created gimple, so there is no need to\n      record information to undo the propagation.  */\n@@ -673,12 +675,12 @@ forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n static bool\n forward_propagate_addr_expr_1 (tree stmt, tree use_stmt, bool *changed)\n {\n-  tree name = TREE_OPERAND (stmt, 0);\n+  tree name = GIMPLE_STMT_OPERAND (stmt, 0);\n   tree lhs, rhs, array_ref;\n \n   /* Strip away any outer COMPONENT_REF/ARRAY_REF nodes from the LHS. \n      ADDR_EXPR will not appear on the LHS.  */\n-  lhs = TREE_OPERAND (use_stmt, 0);\n+  lhs = GIMPLE_STMT_OPERAND (use_stmt, 0);\n   while (TREE_CODE (lhs) == COMPONENT_REF || TREE_CODE (lhs) == ARRAY_REF)\n     lhs = TREE_OPERAND (lhs, 0);\n \n@@ -688,7 +690,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt, bool *changed)\n     {\n       /* This should always succeed in creating gimple, so there is\n \t no need to save enough state to undo this propagation.  */\n-      TREE_OPERAND (lhs, 0) = unshare_expr (TREE_OPERAND (stmt, 1));\n+      TREE_OPERAND (lhs, 0) = unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n       fold_stmt_inplace (use_stmt);\n       tidy_after_forward_propagate_addr (use_stmt);\n       if (changed)\n@@ -702,9 +704,11 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt, bool *changed)\n      we can catch some cascading effects, ie the single use is\n      in a copy, and the copy is used later by a single INDIRECT_REF\n      for example.  */\n-  else if (TREE_CODE (lhs) == SSA_NAME && TREE_OPERAND (use_stmt, 1) == name)\n+  else if (TREE_CODE (lhs) == SSA_NAME\n+      \t   && GIMPLE_STMT_OPERAND (use_stmt, 1) == name)\n     {\n-      TREE_OPERAND (use_stmt, 1) = unshare_expr (TREE_OPERAND (stmt, 1));\n+      GIMPLE_STMT_OPERAND (use_stmt, 1)\n+\t= unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n       tidy_after_forward_propagate_addr (use_stmt);\n       if (changed)\n \t*changed = true;\n@@ -713,7 +717,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt, bool *changed)\n \n   /* Strip away any outer COMPONENT_REF, ARRAY_REF or ADDR_EXPR\n      nodes from the RHS.  */\n-  rhs = TREE_OPERAND (use_stmt, 1);\n+  rhs = GIMPLE_STMT_OPERAND (use_stmt, 1);\n   while (TREE_CODE (rhs) == COMPONENT_REF\n \t || TREE_CODE (rhs) == ARRAY_REF\n \t || TREE_CODE (rhs) == ADDR_EXPR)\n@@ -725,7 +729,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt, bool *changed)\n     {\n       /* This should always succeed in creating gimple, so there is\n          no need to save enough state to undo this propagation.  */\n-      TREE_OPERAND (rhs, 0) = unshare_expr (TREE_OPERAND (stmt, 1));\n+      TREE_OPERAND (rhs, 0) = unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n       fold_stmt_inplace (use_stmt);\n       tidy_after_forward_propagate_addr (use_stmt);\n       if (changed)\n@@ -737,7 +741,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt, bool *changed)\n      array indexing.  They only apply when we have the address of\n      element zero in an array.  If that is not the case then there\n      is nothing to do.  */\n-  array_ref = TREE_OPERAND (TREE_OPERAND (stmt, 1), 0);\n+  array_ref = TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 0);\n   if (TREE_CODE (array_ref) != ARRAY_REF\n       || TREE_CODE (TREE_TYPE (TREE_OPERAND (array_ref, 0))) != ARRAY_TYPE\n       || !integer_zerop (TREE_OPERAND (array_ref, 1)))\n@@ -754,7 +758,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt, bool *changed)\n       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n     {\n       tree orig = unshare_expr (rhs);\n-      TREE_OPERAND (rhs, 0) = unshare_expr (TREE_OPERAND (stmt, 1));\n+      TREE_OPERAND (rhs, 0) = unshare_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n \n       /* If folding succeeds, then we have just exposed new variables\n \t in USE_STMT which will need to be renamed.  If folding fails,\n@@ -768,7 +772,7 @@ forward_propagate_addr_expr_1 (tree stmt, tree use_stmt, bool *changed)\n \t}\n       else\n \t{\n-\t  TREE_OPERAND (use_stmt, 1) = orig;\n+\t  GIMPLE_STMT_OPERAND (use_stmt, 1) = orig;\n \t  update_stmt (use_stmt);\n \t  return false;\n \t}\n@@ -826,7 +830,7 @@ static bool\n forward_propagate_addr_expr (tree stmt, bool *some)\n {\n   int stmt_loop_depth = bb_for_stmt (stmt)->loop_depth;\n-  tree name = TREE_OPERAND (stmt, 0);\n+  tree name = GIMPLE_STMT_OPERAND (stmt, 0);\n   imm_use_iterator iter;\n   tree use_stmt;\n   bool all = true;\n@@ -837,7 +841,7 @@ forward_propagate_addr_expr (tree stmt, bool *some)\n \n       /* If the use is not in a simple assignment statement, then\n \t there is nothing we can do.  */\n-      if (TREE_CODE (use_stmt) != MODIFY_EXPR)\n+      if (TREE_CODE (use_stmt) != GIMPLE_MODIFY_STMT)\n \t{\n \t  all = false;\n \t  continue;\n@@ -877,20 +881,21 @@ forward_propagate_addr_expr (tree stmt, bool *some)\n static void\n simplify_not_neg_expr (tree stmt)\n {\n-  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n   tree rhs_def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n \n   /* See if the RHS_DEF_STMT has the same form as our statement.  */\n-  if (TREE_CODE (rhs_def_stmt) == MODIFY_EXPR\n-      && TREE_CODE (TREE_OPERAND (rhs_def_stmt, 1)) == TREE_CODE (rhs))\n+  if (TREE_CODE (rhs_def_stmt) == GIMPLE_MODIFY_STMT\n+      && TREE_CODE (GIMPLE_STMT_OPERAND (rhs_def_stmt, 1)) == TREE_CODE (rhs))\n     {\n-      tree rhs_def_operand = TREE_OPERAND (TREE_OPERAND (rhs_def_stmt, 1), 0);\n+      tree rhs_def_operand =\n+\tTREE_OPERAND (GIMPLE_STMT_OPERAND (rhs_def_stmt, 1), 0);\n \n       /* Verify that RHS_DEF_OPERAND is a suitable SSA_NAME.  */\n       if (TREE_CODE (rhs_def_operand) == SSA_NAME\n \t  && ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs_def_operand))\n \t{\n-\t  TREE_OPERAND (stmt, 1) = rhs_def_operand;\n+\t  GIMPLE_STMT_OPERAND (stmt, 1) = rhs_def_operand;\n \t  update_stmt (stmt);\n \t}\n     }\n@@ -911,9 +916,9 @@ simplify_switch_expr (tree stmt)\n   if (TREE_CODE (cond) == SSA_NAME)\n     {\n       def = SSA_NAME_DEF_STMT (cond);\n-      if (TREE_CODE (def) == MODIFY_EXPR)\n+      if (TREE_CODE (def) == GIMPLE_MODIFY_STMT)\n \t{\n-\t  def = TREE_OPERAND (def, 1);\n+\t  def = GIMPLE_STMT_OPERAND (def, 1);\n \t  if (TREE_CODE (def) == NOP_EXPR)\n \t    {\n \t      int need_precision;\n@@ -974,10 +979,10 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \n \t  /* If this statement sets an SSA_NAME to an address,\n \t     try to propagate the address into the uses of the SSA_NAME.  */\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t    {\n-\t      tree lhs = TREE_OPERAND (stmt, 0);\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \n \t      if (TREE_CODE (lhs) != SSA_NAME)"}, {"sha": "277e2763bc505768469569835311d1a0bc0f78df", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1331,10 +1331,10 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n \t     be interested in trying to coalesce SSA_NAME variables with\n \t     root variables in some cases.  */\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t    {\n-\t      tree lhs = TREE_OPERAND (stmt, 0);\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \t      int p1, p2;\n \t      int bit;\n "}, {"sha": "9fd0eba16a09ed1d75e0659e7a871d8486b8739f", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -244,7 +244,7 @@ movement_possibility (tree stmt)\n       return MOVE_POSSIBLE;\n     }\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return MOVE_IMPOSSIBLE;\n \n   if (stmt_ends_bb_p (stmt))\n@@ -253,12 +253,12 @@ movement_possibility (tree stmt)\n   if (stmt_ann (stmt)->has_volatile_ops)\n     return MOVE_IMPOSSIBLE;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   if (TREE_CODE (lhs) == SSA_NAME\n       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n     return MOVE_IMPOSSIBLE;\n \n-  rhs = TREE_OPERAND (stmt, 1);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   if (TREE_SIDE_EFFECTS (rhs))\n     return MOVE_IMPOSSIBLE;\n@@ -423,7 +423,7 @@ stmt_cost (tree stmt)\n   if (TREE_CODE (stmt) == COND_EXPR)\n     return LIM_EXPENSIVE;\n \n-  rhs = TREE_OPERAND (stmt, 1);\n+  rhs = GENERIC_TREE_OPERAND (stmt, 1);\n \n   /* Hoisting memory references out should almost surely be a win.  */\n   if (stmt_references_memory_p (stmt))\n@@ -609,7 +609,7 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n       /* If divisor is invariant, convert a/b to a*(1/b), allowing reciprocal\n \t to be hoisted out of loop, saving expensive divide.  */\n       if (pos == MOVE_POSSIBLE\n-\t  && (rhs = TREE_OPERAND (stmt, 1)) != NULL\n+\t  && (rhs = GENERIC_TREE_OPERAND (stmt, 1)) != NULL\n \t  && TREE_CODE (rhs) == RDIV_EXPR\n \t  && flag_unsafe_math_optimizations\n \t  && !flag_trapping_math\n@@ -620,19 +620,19 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t{\n \t  tree lhs, stmt1, stmt2, var, name;\n \n-\t  lhs = TREE_OPERAND (stmt, 0);\n+\t  lhs = GENERIC_TREE_OPERAND (stmt, 0);\n \n-\t  /* stmt must be MODIFY_EXPR.  */\n+\t  /* stmt must be GIMPLE_MODIFY_STMT.  */\n \t  var = create_tmp_var (TREE_TYPE (rhs), \"reciptmp\");\n \t  add_referenced_var (var);\n \n-\t  stmt1 = build2 (MODIFY_EXPR, void_type_node, var,\n+\t  stmt1 = build2 (GIMPLE_MODIFY_STMT, void_type_node, var,\n \t\t\t  build2 (RDIV_EXPR, TREE_TYPE (rhs),\n \t\t\t\t  build_real (TREE_TYPE (rhs), dconst1),\n \t\t\t\t  TREE_OPERAND (rhs, 1)));\n \t  name = make_ssa_name (var, stmt1);\n-\t  TREE_OPERAND (stmt1, 0) = name;\n-\t  stmt2 = build2 (MODIFY_EXPR, void_type_node, lhs,\n+\t  GIMPLE_STMT_OPERAND (stmt1, 0) = name;\n+\t  stmt2 = build2 (GIMPLE_MODIFY_STMT, void_type_node, lhs,\n \t\t\t  build2 (MULT_EXPR, TREE_TYPE (rhs),\n \t\t\t\t  name, TREE_OPERAND (rhs, 0)));\n \n@@ -1051,7 +1051,7 @@ schedule_sm (struct loop *loop, VEC (edge, heap) *exits, tree ref,\n       LIM_DATA (aref->stmt)->sm_done = true;\n \n   /* Emit the load & stores.  */\n-  load = build2 (MODIFY_EXPR, void_type_node, tmp_var, ref);\n+  load = build2_gimple (GIMPLE_MODIFY_STMT, tmp_var, ref);\n   get_stmt_ann (load)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n   LIM_DATA (load)->max_loop = loop;\n   LIM_DATA (load)->tgt_loop = loop;\n@@ -1062,8 +1062,7 @@ schedule_sm (struct loop *loop, VEC (edge, heap) *exits, tree ref,\n \n   for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n     {\n-      store = build2 (MODIFY_EXPR, void_type_node,\n-\t\t      unshare_expr (ref), tmp_var);\n+      store = build2_gimple (GIMPLE_MODIFY_STMT, unshare_expr (ref), tmp_var);\n       bsi_insert_on_edge (ex, store);\n     }\n }\n@@ -1201,11 +1200,11 @@ gather_mem_refs_stmt (struct loop *loop, htab_t mem_refs,\n     return;\n \n   /* Recognize MEM = (SSA_NAME | invariant) and SSA_NAME = MEM patterns.  */\n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     goto fail;\n \n-  lhs = &TREE_OPERAND (stmt, 0);\n-  rhs = &TREE_OPERAND (stmt, 1);\n+  lhs = &GIMPLE_STMT_OPERAND (stmt, 0);\n+  rhs = &GIMPLE_STMT_OPERAND (stmt, 1);\n \n   if (TREE_CODE (*lhs) == SSA_NAME)\n     {"}, {"sha": "7dcb0da01dafb6166e07109c1caf5218d84ecd92", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -455,7 +455,7 @@ empty_loop_p (struct loop *loop)\n \t  switch (TREE_CODE (stmt))\n \t    {\n \t    case RETURN_EXPR:\n-\t    case MODIFY_EXPR:\n+\t    case GIMPLE_MODIFY_STMT:\n \t      stmt = get_call_expr_in (stmt);\n \t      if (!stmt)\n \t\tbreak;"}, {"sha": "0132fc9cdb47987db9203d9498f57596f5f978bc", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1037,14 +1037,14 @@ find_givs_in_stmt_scev (struct ivopts_data *data, tree stmt, affine_iv *iv)\n   iv->base = NULL_TREE;\n   iv->step = NULL_TREE;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   if (TREE_CODE (lhs) != SSA_NAME)\n     return false;\n \n-  if (!simple_iv (loop, stmt, TREE_OPERAND (stmt, 1), iv, true))\n+  if (!simple_iv (loop, stmt, GIMPLE_STMT_OPERAND (stmt, 1), iv, true))\n     return false;\n   iv->base = expand_simple_operations (iv->base);\n \n@@ -1065,7 +1065,7 @@ find_givs_in_stmt (struct ivopts_data *data, tree stmt)\n   if (!find_givs_in_stmt_scev (data, stmt, &iv))\n     return;\n \n-  set_iv (data, TREE_OPERAND (stmt, 0), iv.base, iv.step);\n+  set_iv (data, GIMPLE_STMT_OPERAND (stmt, 0), iv.base, iv.step);\n }\n \n /* Finds general ivs in basic block BB.  */\n@@ -1222,7 +1222,7 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n \n   stmt = SSA_NAME_DEF_STMT (op);\n   gcc_assert (TREE_CODE (stmt) == PHI_NODE\n-\t      || TREE_CODE (stmt) == MODIFY_EXPR);\n+\t      || TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n \n   use = record_use (data, NULL, civ, stmt, USE_NONLINEAR_EXPR);\n   iv->use_id = use->id;\n@@ -1314,7 +1314,7 @@ expr_invariant_in_loop_p (struct loop *loop, tree expr)\n       return true;\n     }\n \n-  if (!EXPR_P (expr))\n+  if (!EXPR_P (expr) && !GIMPLE_STMT_P (expr))\n     return false;\n \n   len = TREE_CODE_LENGTH (TREE_CODE (expr));\n@@ -1636,10 +1636,10 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n       return;\n     }\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      lhs = TREE_OPERAND (stmt, 0);\n-      rhs = TREE_OPERAND (stmt, 1);\n+      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n       if (TREE_CODE (lhs) == SSA_NAME)\n \t{\n@@ -1655,13 +1655,16 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n       switch (TREE_CODE_CLASS (TREE_CODE (rhs)))\n \t{\n \tcase tcc_comparison:\n-\t  find_interesting_uses_cond (data, stmt, &TREE_OPERAND (stmt, 1));\n+\t  find_interesting_uses_cond (data, stmt,\n+\t      \t\t\t      &GIMPLE_STMT_OPERAND (stmt, 1));\n \t  return;\n \n \tcase tcc_reference:\n-\t  find_interesting_uses_address (data, stmt, &TREE_OPERAND (stmt, 1));\n+\t  find_interesting_uses_address (data, stmt,\n+\t\t\t\t\t &GIMPLE_STMT_OPERAND (stmt, 1));\n \t  if (REFERENCE_CLASS_P (lhs))\n-\t    find_interesting_uses_address (data, stmt, &TREE_OPERAND (stmt, 0));\n+\t    find_interesting_uses_address (data, stmt,\n+\t\t\t\t\t   &GIMPLE_STMT_OPERAND (stmt, 0));\n \t  return;\n \n \tdefault: ;\n@@ -1670,7 +1673,8 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n       if (REFERENCE_CLASS_P (lhs)\n \t  && is_gimple_val (rhs))\n \t{\n-\t  find_interesting_uses_address (data, stmt, &TREE_OPERAND (stmt, 0));\n+\t  find_interesting_uses_address (data, stmt,\n+\t\t\t\t\t &GIMPLE_STMT_OPERAND (stmt, 0));\n \t  find_interesting_uses_op (data, rhs);\n \t  return;\n \t}\n@@ -5383,8 +5387,8 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n       tree step, ctype, utype;\n       enum tree_code incr_code = PLUS_EXPR;\n \n-      gcc_assert (TREE_CODE (use->stmt) == MODIFY_EXPR);\n-      gcc_assert (TREE_OPERAND (use->stmt, 0) == cand->var_after);\n+      gcc_assert (TREE_CODE (use->stmt) == GIMPLE_MODIFY_STMT);\n+      gcc_assert (GIMPLE_STMT_OPERAND (use->stmt, 0) == cand->var_after);\n \n       step = cand->iv->step;\n       ctype = TREE_TYPE (step);\n@@ -5400,7 +5404,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t computations in the loop -- otherwise, the computation\n \t we rely upon may be removed in remove_unused_ivs,\n \t thus leading to ICE.  */\n-      op = TREE_OPERAND (use->stmt, 1);\n+      op = GIMPLE_STMT_OPERAND (use->stmt, 1);\n       if (TREE_CODE (op) == PLUS_EXPR\n \t  || TREE_CODE (op) == MINUS_EXPR)\n \t{\n@@ -5448,8 +5452,8 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t}\n       break;\n \n-    case MODIFY_EXPR:\n-      tgt = TREE_OPERAND (use->stmt, 0);\n+    case GIMPLE_MODIFY_STMT:\n+      tgt = GIMPLE_STMT_OPERAND (use->stmt, 0);\n       bsi = bsi_for_stmt (use->stmt);\n       break;\n \n@@ -5463,7 +5467,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n     {\n       if (stmts)\n \tbsi_insert_after (&bsi, stmts, BSI_CONTINUE_LINKING);\n-      ass = build2 (MODIFY_EXPR, TREE_TYPE (tgt), tgt, op);\n+      ass = build2_gimple (GIMPLE_MODIFY_STMT, tgt, op);\n       bsi_insert_after (&bsi, ass, BSI_NEW_STMT);\n       remove_statement (use->stmt, false);\n       SSA_NAME_DEF_STMT (tgt) = ass;\n@@ -5472,7 +5476,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n     {\n       if (stmts)\n \tbsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n-      TREE_OPERAND (use->stmt, 1) = op;\n+      GIMPLE_STMT_OPERAND (use->stmt, 1) = op;\n     }\n }\n "}, {"sha": "7cfb9e1301abb6a40cf0fa9baa6796c786616ff6", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -100,9 +100,8 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n   if (stmts)\n     bsi_insert_on_edge_immediate (pe, stmts);\n \n-  stmt = build2 (MODIFY_EXPR, void_type_node, va,\n-\t\t build2 (incr_op, TREE_TYPE (base),\n-\t\t\t vb, step));\n+  stmt = build2_gimple (GIMPLE_MODIFY_STMT, va,\n+\t\t        build2 (incr_op, TREE_TYPE (base), vb, step));\n   SSA_NAME_DEF_STMT (va) = stmt;\n   if (after)\n     bsi_insert_after (incr_pos, stmt, BSI_NEW_STMT);"}, {"sha": "de9ce1c2ea48def14ae7178dd22e81555c6ae232", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -684,7 +684,7 @@ simplify_replace_tree (tree expr, tree old, tree new)\n       || operand_equal_p (expr, old, 0))\n     return unshare_expr (new);\n \n-  if (!EXPR_P (expr))\n+  if (!EXPR_P (expr) && !GIMPLE_STMT_P (expr))\n     return expr;\n \n   n = TREE_CODE_LENGTH (TREE_CODE (expr));\n@@ -744,10 +744,10 @@ expand_simple_operations (tree expr)\n     return expr;\n \n   stmt = SSA_NAME_DEF_STMT (expr);\n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return expr;\n \n-  e = TREE_OPERAND (stmt, 1);\n+  e = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (/* Casts are simple.  */\n       TREE_CODE (e) != NOP_EXPR\n       && TREE_CODE (e) != CONVERT_EXPR\n@@ -1255,7 +1255,7 @@ chain_of_csts_start (struct loop *loop, tree x)\n       return NULL_TREE;\n     }\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return NULL_TREE;\n \n   if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n@@ -1337,7 +1337,7 @@ get_val_for (tree x, tree base)\n       nx = USE_FROM_PTR (op);\n       val = get_val_for (nx, base);\n       SET_USE (op, val);\n-      val = fold (TREE_OPERAND (stmt, 1));\n+      val = fold (GIMPLE_STMT_OPERAND (stmt, 1));\n       SET_USE (op, nx);\n       /* only iterate loop once.  */\n       return val;\n@@ -1655,10 +1655,11 @@ derive_constant_upper_bound (tree val, tree additional)\n \n     case SSA_NAME:\n       stmt = SSA_NAME_DEF_STMT (val);\n-      if (TREE_CODE (stmt) != MODIFY_EXPR\n-\t  || TREE_OPERAND (stmt, 0) != val)\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n+\t  || GIMPLE_STMT_OPERAND (stmt, 0) != val)\n \treturn max;\n-      return derive_constant_upper_bound (TREE_OPERAND (stmt, 1), additional);\n+      return derive_constant_upper_bound (GIMPLE_STMT_OPERAND (stmt, 1),\n+\t  \t\t\t\t  additional);\n \n     default: \n       return max;\n@@ -1872,10 +1873,10 @@ infer_loop_bounds_from_array (struct loop *loop, tree stmt)\n {\n   tree call;\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      tree op0 = TREE_OPERAND (stmt, 0);\n-      tree op1 = TREE_OPERAND (stmt, 1);\n+      tree op0 = GIMPLE_STMT_OPERAND (stmt, 0);\n+      tree op1 = GIMPLE_STMT_OPERAND (stmt, 1);\n \n       /* For each memory access, analyze its access function\n \t and record a bound on the loop iteration domain.  */\n@@ -1906,10 +1907,10 @@ infer_loop_bounds_from_signedness (struct loop *loop, tree stmt)\n {\n   tree def, base, step, scev, type, low, high;\n \n-  if (flag_wrapv || TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (flag_wrapv || TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return;\n \n-  def = TREE_OPERAND (stmt, 0);\n+  def = GIMPLE_STMT_OPERAND (stmt, 0);\n \n   if (TREE_CODE (def) != SSA_NAME)\n     return;"}, {"sha": "114d0e3ebe05b4e1fb9368b7e1e7db52dc3e01e7", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -461,11 +461,11 @@ gather_memory_references (struct loop *loop)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  stmt = bsi_stmt (bsi);\n-\t  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+\t  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \t    continue;\n \n-\t  lhs = TREE_OPERAND (stmt, 0);\n-\t  rhs = TREE_OPERAND (stmt, 1);\n+\t  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t  if (REFERENCE_CLASS_P (rhs))\n \t    gather_memory_references_ref (loop, &refs, rhs, false, stmt);"}, {"sha": "5b2834089ec7107590681b467467c5d3dbd83a0f", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -111,7 +111,7 @@ struct occurrence {\n      inserted in BB.  */\n   tree recip_def;\n \n-  /* If non-NULL, the MODIFY_EXPR for a reciprocal computation that\n+  /* If non-NULL, the GIMPLE_MODIFY_STMT for a reciprocal computation that\n      was inserted in BB.  */\n   tree recip_def_stmt;\n \n@@ -274,9 +274,9 @@ compute_merit (struct occurrence *occ)\n static inline bool\n is_division_by (tree use_stmt, tree def)\n {\n-  return TREE_CODE (use_stmt) == MODIFY_EXPR\n-\t && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == RDIV_EXPR\n-\t && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 1) == def;\n+  return TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == RDIV_EXPR\n+\t && TREE_OPERAND (GIMPLE_STMT_OPERAND (use_stmt, 1), 1) == def;\n }\n \n /* Walk the subset of the dominator tree rooted at OCC, setting the\n@@ -303,7 +303,7 @@ insert_reciprocals (block_stmt_iterator *def_bsi, struct occurrence *occ,\n       /* Make a variable with the replacement and substitute it.  */\n       type = TREE_TYPE (def);\n       recip_def = make_rename_temp (type, \"reciptmp\");\n-      new_stmt = build2 (MODIFY_EXPR, void_type_node, recip_def,\n+      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, recip_def,\n \t\t         fold_build2 (RDIV_EXPR, type, build_one_cst (type),\n \t\t\t\t      def));\n   \n@@ -353,7 +353,7 @@ replace_reciprocal (use_operand_p use_p)\n \n   if (occ->recip_def && use_stmt != occ->recip_def_stmt)\n     {\n-      TREE_SET_CODE (TREE_OPERAND (use_stmt, 1), MULT_EXPR);\n+      TREE_SET_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1), MULT_EXPR);\n       SET_USE (use_p, occ->recip_def);\n       fold_stmt_inplace (use_stmt);\n       update_stmt (use_stmt);\n@@ -490,7 +490,7 @@ execute_cse_reciprocals (void)\n       for (bsi = bsi_after_labels (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n         {\n \t  tree stmt = bsi_stmt (bsi);\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n \t      && (def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF)) != NULL\n \t      && FLOAT_TYPE_P (TREE_TYPE (def))\n \t      && TREE_CODE (def) == SSA_NAME)"}, {"sha": "05876846a35d2ef52ff81c543000878fe13d3111", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -98,7 +98,7 @@ Boston, MA 02110-1301, USA.  */\n \n /* Operand is a \"non-specific\" kill for call-clobbers and such.  This\n    is used to distinguish \"reset the world\" events from explicit\n-   MODIFY_EXPRs.  */\n+   GIMPLE_MODIFY_STMTs.  */\n #define opf_non_specific  (1 << 3)\n \n /* Array for building all the def operands.  */\n@@ -533,7 +533,7 @@ finalize_ssa_defs (tree stmt)\n   unsigned int num = VEC_length (tree, build_defs);\n \n   /* There should only be a single real definition per assignment.  */\n-  gcc_assert ((stmt && TREE_CODE (stmt) != MODIFY_EXPR) || num <= 1);\n+  gcc_assert ((stmt && TREE_CODE (stmt) != GIMPLE_MODIFY_STMT) || num <= 1);\n \n   /* If there is an old list, often the new list is identical, or close, so\n      find the elements at the beginning that are the same as the vector.  */\n@@ -1230,7 +1230,7 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n      check that this only happens on non-specific stores.\n \n      Note that if this is a specific store, i.e. associated with a\n-     modify_expr, then we can't suppress the V_MAY_DEF, lest we run\n+     gimple_modify_stmt, then we can't suppress the V_MAY_DEF, lest we run\n      into validation problems.\n \n      This can happen when programs cast away const, leaving us with a\n@@ -1814,10 +1814,10 @@ get_asm_expr_operands (tree stmt)\n /* Scan operands for the assignment expression EXPR in statement STMT.  */\n \n static void\n-get_modify_expr_operands (tree stmt, tree expr)\n+get_modify_stmt_operands (tree stmt, tree expr)\n {\n   /* First get operands from the RHS.  */\n-  get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n+  get_expr_operands (stmt, &GIMPLE_STMT_OPERAND (expr, 1), opf_none);\n \n   /* For the LHS, use a regular definition (OPF_IS_DEF) for GIMPLE\n      registers.  If the LHS is a store to memory, we will either need\n@@ -1832,7 +1832,8 @@ get_modify_expr_operands (tree stmt, tree expr)\n      The determination of whether to use a preserving or a killing\n      definition is done while scanning the LHS of the assignment.  By\n      default, assume that we will emit a V_MUST_DEF.  */\n-  get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_is_def|opf_kill_def);\n+  get_expr_operands (stmt, &GIMPLE_STMT_OPERAND (expr, 0),\n+      \t\t     opf_is_def|opf_kill_def);\n }\n \n \n@@ -2005,8 +2006,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n       return;\n \n-    case MODIFY_EXPR:\n-      get_modify_expr_operands (stmt, expr);\n+    case GIMPLE_MODIFY_STMT:\n+      get_modify_stmt_operands (stmt, expr);\n       return;\n \n     case CONSTRUCTOR:\n@@ -2106,8 +2107,8 @@ parse_ssa_operands (tree stmt)\n   code = TREE_CODE (stmt);\n   switch (code)\n     {\n-    case MODIFY_EXPR:\n-      get_modify_expr_operands (stmt, stmt);\n+    case GIMPLE_MODIFY_STMT:\n+      get_modify_stmt_operands (stmt, stmt);\n       break;\n \n     case COND_EXPR:"}, {"sha": "2cc7ad794252772b9483ad039fae2c67e55a3147", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -439,7 +439,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t     TREE_OPERAND (old_result, 0),\n \t\t     TREE_OPERAND (old_result, 1));\n \n-      new1 = build2 (MODIFY_EXPR, TREE_TYPE (old_result), new_var, new1);\n+      new1 = build2_gimple (GIMPLE_MODIFY_STMT, new_var, new1);\n       SSA_NAME_DEF_STMT (new_var) = new1;\n \n       bsi_insert_after (&bsi, new1, BSI_NEW_STMT);\n@@ -470,7 +470,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n       || (e1 == true_edge && integer_onep (arg1))\n       || (e1 == false_edge && integer_zerop (arg1)))\n     {\n-      new = build2 (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n+      new = build2_gimple (GIMPLE_MODIFY_STMT, new_var1, cond);\n     }\n   else\n     {\n@@ -514,14 +514,14 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  tmp = create_tmp_var (TREE_TYPE (op0), NULL);\n \t  add_referenced_var (tmp);\n \t  cond_tmp = make_ssa_name (tmp, NULL);\n-\t  new = build2 (MODIFY_EXPR, TREE_TYPE (cond_tmp), cond_tmp, op0);\n+\t  new = build2_gimple (GIMPLE_MODIFY_STMT, cond_tmp, op0);\n \t  SSA_NAME_DEF_STMT (cond_tmp) = new;\n \n \t  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n \t  cond = fold_convert (TREE_TYPE (result), cond_tmp);\n \t}\n \n-      new = build2 (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n+      new = build2_gimple (GIMPLE_MODIFY_STMT, new_var1, cond);\n     }\n \n   bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n@@ -715,11 +715,11 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n       tree lhs, rhs, op0, op1, bound;\n \n       if (!assign\n-\t  || TREE_CODE (assign) != MODIFY_EXPR)\n+\t  || TREE_CODE (assign) != GIMPLE_MODIFY_STMT)\n \treturn false;\n \n-      lhs = TREE_OPERAND (assign, 0);\n-      rhs = TREE_OPERAND (assign, 1);\n+      lhs = GIMPLE_STMT_OPERAND (assign, 0);\n+      rhs = GIMPLE_STMT_OPERAND (assign, 1);\n       ass_code = TREE_CODE (rhs);\n       if (ass_code != MAX_EXPR && ass_code != MIN_EXPR)\n \treturn false;\n@@ -853,8 +853,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* Emit the statement to compute min/max.  */\n   result = duplicate_ssa_name (PHI_RESULT (phi), NULL);\n-  new = build2 (MODIFY_EXPR, type, result,\n-\t\tbuild2 (minmax, type, arg0, arg1));\n+  new = build2_gimple (GIMPLE_MODIFY_STMT, result,\n+\t\t       build2 (minmax, type, arg0, arg1));\n   SSA_NAME_DEF_STMT (result) = new;\n   bsi = bsi_last (cond_bb);\n   bsi_insert_before (&bsi, new, BSI_NEW_STMT);\n@@ -901,11 +901,11 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   /* If we got here, then we have found the only executable statement\n      in OTHER_BLOCK.  If it is anything other than arg = -arg1 or\n      arg1 = -arg0, then we can not optimize.  */\n-  if (TREE_CODE (assign) != MODIFY_EXPR)\n+  if (TREE_CODE (assign) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  lhs = TREE_OPERAND (assign, 0);\n-  rhs = TREE_OPERAND (assign, 1);\n+  lhs = GIMPLE_STMT_OPERAND (assign, 0);\n+  rhs = GIMPLE_STMT_OPERAND (assign, 1);\n \n   if (TREE_CODE (rhs) != NEGATE_EXPR)\n     return false;\n@@ -966,8 +966,8 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n     lhs = result;\n \n   /* Build the modify expression with abs expression.  */\n-  new = build2 (MODIFY_EXPR, TREE_TYPE (lhs),\n-\t\tlhs, build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n+  new = build2_gimple (GIMPLE_MODIFY_STMT,\n+\t\t       lhs, build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n   SSA_NAME_DEF_STMT (lhs) = new;\n \n   bsi = bsi_last (cond_bb);\n@@ -978,8 +978,8 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n       /* Get the right BSI.  We want to insert after the recently\n \t added ABS_EXPR statement (which we know is the first statement\n \t in the block.  */\n-      new = build2 (MODIFY_EXPR, TREE_TYPE (result),\n-\t\t    result, build1 (NEGATE_EXPR, TREE_TYPE (lhs), lhs));\n+      new = build2_gimple (GIMPLE_MODIFY_STMT,\n+\t\t           result, build1 (NEGATE_EXPR, TREE_TYPE (lhs), lhs));\n       SSA_NAME_DEF_STMT (result) = new;\n \n       bsi_insert_after (&bsi, new, BSI_NEW_STMT);"}, {"sha": "492b42d1551136de757ef2322863df1ece2950f5", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -61,9 +61,9 @@ Boston, MA 02110-1301, USA.  */\n */\n \n /* For ease of terminology, \"expression node\" in the below refers to\n-   every expression node but MODIFY_EXPR, because MODIFY_EXPR's represent\n-   the actual statement containing the expressions we care about, and\n-   we cache the value number by putting it in the expression.  */\n+   every expression node but GIMPLE_MODIFY_STMT, because GIMPLE_MODIFY_STMT's\n+   represent the actual statement containing the expressions we care about,\n+   and we cache the value number by putting it in the expression.  */\n \n /* Basic algorithm\n \n@@ -986,7 +986,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n     return expr;\n \n   /* Phi translations of a given expression don't change.  */\n-  if (EXPR_P (expr))\n+  if (EXPR_P (expr) || GIMPLE_STMT_P (expr))\n     {\n       tree vh;\n \n@@ -1115,7 +1115,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\tTREE_OPERAND (newexpr, 0) = newop0 == oldop0 ? oldval0 : get_value_handle (newop0);\n \t\tTREE_OPERAND (newexpr, 1) = listchanged ? newarglist : oldarglist;\n \t\tTREE_OPERAND (newexpr, 2) = newop2 == oldop2 ? oldval2 : get_value_handle (newop2);\n-\t\tnewexpr->common.ann = NULL;\n+\t\tnewexpr->base.ann = NULL;\n \t\tvn_lookup_or_add_with_vuses (newexpr, tvuses);\n \t\texpr = newexpr;\n \t\tphi_trans_add (oldexpr, newexpr, pred, tvuses);\n@@ -1227,7 +1227,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t      }\n \t    else\n \t      {\n-\t\tnewexpr->common.ann = NULL;\n+\t\tnewexpr->base.ann = NULL;\n \t\tvn_lookup_or_add_with_vuses (newexpr, newvuses);\n \t      }\n \t    expr = newexpr;\n@@ -1272,7 +1272,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t      }\n \t    else\n \t      {\n-\t\tnewexpr->common.ann = NULL;\n+\t\tnewexpr->base.ann = NULL;\n \t\tvn_lookup_or_add (newexpr, NULL);\n \t      }\n \t    expr = newexpr;\n@@ -1305,7 +1305,7 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t      }\n \t    else\n \t      {\n-\t\tnewexpr->common.ann = NULL;\n+\t\tnewexpr->base.ann = NULL;\n \t\tvn_lookup_or_add (newexpr, NULL);\n \t      }\n \t    expr = newexpr;\n@@ -2490,7 +2490,7 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n   return genop;\n }\n \n-#define NECESSARY(stmt)\t\tstmt->common.asm_written_flag\n+#define NECESSARY(stmt)\t\tstmt->base.asm_written_flag\n /* Create an expression in pieces, so that we can handle very complex\n    expressions that may be ANTIC, but not necessary GIMPLE.\n    BLOCK is the basic block the expression will be inserted into,\n@@ -2608,8 +2608,8 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n       for (; !tsi_end_p (tsi); tsi_next (&tsi))\n \t{\n \t  tree stmt = tsi_stmt (tsi);\n-\t  tree forcedname = TREE_OPERAND (stmt, 0);\n-\t  tree forcedexpr = TREE_OPERAND (stmt, 1);\n+\t  tree forcedname = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  tree forcedexpr = GIMPLE_STMT_OPERAND (stmt, 1);\n \t  tree val = vn_lookup_or_add (forcedexpr, NULL);\n \n \t  VEC_safe_push (tree, heap, inserted_exprs, stmt);\n@@ -2636,9 +2636,9 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   if (TREE_CODE (TREE_TYPE (expr)) == COMPLEX_TYPE)\n     DECL_COMPLEX_GIMPLE_REG_P (temp) = 1;\n \n-  newexpr = build2 (MODIFY_EXPR, TREE_TYPE (expr), temp, newexpr);\n+  newexpr = build2_gimple (GIMPLE_MODIFY_STMT, temp, newexpr);\n   name = make_ssa_name (temp, newexpr);\n-  TREE_OPERAND (newexpr, 0) = name;\n+  GIMPLE_STMT_OPERAND (newexpr, 0) = name;\n   NECESSARY (newexpr) = 0;\n \n   tsi = tsi_last (stmts);\n@@ -3375,7 +3375,7 @@ try_look_through_load (tree lhs, tree mem_ref, tree stmt, basic_block block)\n \t uses, we can stop right here.  Note that this means we do\n \t not look through PHI nodes, which is intentional.  */\n       if (!def_stmt\n-\t  || TREE_CODE (def_stmt) != MODIFY_EXPR\n+\t  || TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT\n \t  || !ZERO_SSA_OPERANDS (def_stmt, SSA_OP_VIRTUAL_USES))\n \treturn false;\n \n@@ -3388,7 +3388,7 @@ try_look_through_load (tree lhs, tree mem_ref, tree stmt, basic_block block)\n \t{\n \t  /* Is this a store to the exact same location as the one we are\n \t     loading from in STMT?  */\n-\t  if (!operand_equal_p (TREE_OPERAND (def_stmt, 0), mem_ref, 0))\n+\t  if (!operand_equal_p (GIMPLE_STMT_OPERAND (def_stmt, 0), mem_ref, 0))\n \t    return false;\n \n \t  /* Otherwise remember this statement and see if all other VUSEs\n@@ -3400,7 +3400,7 @@ try_look_through_load (tree lhs, tree mem_ref, tree stmt, basic_block block)\n   /* Alright then, we have visited all VUSEs of STMT and we've determined\n      that all of them come from the same statement STORE_STMT.  See if there\n      is a useful expression we can deduce from STORE_STMT.  */\n-  rhs = TREE_OPERAND (store_stmt, 1);\n+  rhs = GIMPLE_STMT_OPERAND (store_stmt, 1);\n   if ((TREE_CODE (rhs) == SSA_NAME\n        && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs))\n       || is_gimple_min_invariant (rhs)\n@@ -3438,12 +3438,14 @@ poolify_tree (tree node)\n \treturn temp;\n       }\n       break;\n-    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n       {\n \ttree temp = (tree) pool_alloc (modify_expr_node_pool);\n \tmemcpy (temp, node, tree_size (node));\n-\tTREE_OPERAND (temp, 0) = poolify_tree (TREE_OPERAND (temp, 0));\n-\tTREE_OPERAND (temp, 1) = poolify_tree (TREE_OPERAND (temp, 1));\n+\tGIMPLE_STMT_OPERAND (temp, 0) =\n+\t  poolify_tree (GIMPLE_STMT_OPERAND (temp, 0));\n+\tGIMPLE_STMT_OPERAND (temp, 1) =\n+\t  poolify_tree (GIMPLE_STMT_OPERAND (temp, 1));\n \treturn temp;\n       }\n       break;\n@@ -3462,17 +3464,16 @@ poolify_tree (tree node)\n \n static tree modify_expr_template;\n \n-/* Allocate a MODIFY_EXPR with TYPE, and operands OP1, OP2 in the\n+/* Allocate a GIMPLE_MODIFY_STMT with TYPE, and operands OP1, OP2 in the\n    alloc pools and return it.  */\n static tree\n-poolify_modify_expr (tree type, tree op1, tree op2)\n+poolify_modify_stmt (tree op1, tree op2)\n {\n   if (modify_expr_template == NULL)\n-    modify_expr_template = build2 (MODIFY_EXPR, type, op1, op2);\n+    modify_expr_template = build2_gimple (GIMPLE_MODIFY_STMT, op1, op2);\n \n-  TREE_OPERAND (modify_expr_template, 0) = op1;\n-  TREE_OPERAND (modify_expr_template, 1) = op2;\n-  TREE_TYPE (modify_expr_template) = type;\n+  GIMPLE_STMT_OPERAND (modify_expr_template, 0) = op1;\n+  GIMPLE_STMT_OPERAND (modify_expr_template, 1) = op2;\n \n   return poolify_tree (modify_expr_template);\n }\n@@ -3506,15 +3507,16 @@ insert_fake_stores (void)\n \t     or aggregate.  We also want to ignore things whose\n \t     virtual uses occur in abnormal phis.  */\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == INDIRECT_REF\n-\t      && !AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 0)))\n-\t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (stmt, 0))) != COMPLEX_TYPE)\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == INDIRECT_REF\n+\t      && !AGGREGATE_TYPE_P (TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0)))\n+\t      && TREE_CODE (TREE_TYPE (GIMPLE_STMT_OPERAND\n+\t\t\t\t\t(stmt, 0))) != COMPLEX_TYPE)\n \t    {\n \t      ssa_op_iter iter;\n \t      def_operand_p defp;\n-\t      tree lhs = TREE_OPERAND (stmt, 0);\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \t      tree new;\n \t      bool notokay = false;\n \n@@ -3537,10 +3539,10 @@ insert_fake_stores (void)\n \t\t  get_var_ann (storetemp);\n \t\t}\n \n-\t      new = poolify_modify_expr (TREE_TYPE (stmt), storetemp, lhs);\n+\t      new = poolify_modify_stmt (storetemp, lhs);\n \n \t      lhs = make_ssa_name (storetemp, new);\n-\t      TREE_OPERAND (new, 0) = lhs;\n+\t      GIMPLE_STMT_OPERAND (new, 0) = lhs;\n \t      create_ssa_artficial_load_stmt (new, stmt);\n \n \t      NECESSARY (new) = 0;\n@@ -3570,18 +3572,18 @@ realify_fake_stores (void)\n \t  tree newstmt;\n \n \t  /* Mark the temp variable as referenced */\n-\t  add_referenced_var (SSA_NAME_VAR (TREE_OPERAND (stmt, 0)));\n+\t  add_referenced_var (SSA_NAME_VAR (GIMPLE_STMT_OPERAND (stmt, 0)));\n \n \t  /* Put the new statement in GC memory, fix up the\n \t     SSA_NAME_DEF_STMT on it, and then put it in place of\n \t     the old statement before the store in the IR stream\n \t     as a plain ssa name copy.  */\n \t  bsi = bsi_for_stmt (stmt);\n \t  bsi_prev (&bsi);\n-\t  newstmt = build2 (MODIFY_EXPR, void_type_node,\n-\t\t\t    TREE_OPERAND (stmt, 0),\n-\t\t\t    TREE_OPERAND (bsi_stmt (bsi), 1));\n-\t  SSA_NAME_DEF_STMT (TREE_OPERAND (newstmt, 0)) = newstmt;\n+\t  newstmt = build2_gimple (GIMPLE_MODIFY_STMT,\n+\t\t\t           GIMPLE_STMT_OPERAND (stmt, 0),\n+\t\t\t    \t   GIMPLE_STMT_OPERAND (bsi_stmt (bsi), 1));\n+\t  SSA_NAME_DEF_STMT (GIMPLE_STMT_OPERAND (newstmt, 0)) = newstmt;\n \t  bsi_insert_before (&bsi, newstmt, BSI_SAME_STMT);\n \t  bsi = bsi_for_stmt (stmt);\n \t  bsi_remove (&bsi, true);\n@@ -3752,10 +3754,10 @@ compute_avail (void)\n \t      tree rhs;\n \n \t      stmt = TREE_OPERAND (stmt, 0);\n-\t      if (stmt && TREE_CODE (stmt) == MODIFY_EXPR)\n+\t      if (stmt && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t\t{\n-\t\t  lhs  = TREE_OPERAND (stmt, 0);\n-\t\t  rhs = TREE_OPERAND (stmt, 1);\n+\t\t  lhs  = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t\t  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \t\t  if (TREE_CODE (rhs) == SSA_NAME\n \t\t      && !is_undefined_value (rhs))\n \t\t    bitmap_value_insert_into_set (EXP_GEN (block), rhs);\n@@ -3767,13 +3769,14 @@ compute_avail (void)\n \t      continue;\n \t    }\n \n-\t  else if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t  else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n \t      && !ann->has_volatile_ops\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n-\t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (stmt, 0)))\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n+\t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n+\t           (GIMPLE_STMT_OPERAND (stmt, 0)))\n \t    {\n-\t      tree lhs = TREE_OPERAND (stmt, 0);\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t      /* Try to look through loads.  */\n \t      if (TREE_CODE (lhs) == SSA_NAME\n@@ -3868,14 +3871,14 @@ eliminate (void)\n \t  /* Lookup the RHS of the expression, see if we have an\n \t     available computation for it.  If so, replace the RHS with\n \t     the available computation.  */\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n-\t      && TREE_CODE (TREE_OPERAND (stmt ,1)) != SSA_NAME\n-\t      && !is_gimple_min_invariant (TREE_OPERAND (stmt, 1))\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) != SSA_NAME\n+\t      && !is_gimple_min_invariant (GIMPLE_STMT_OPERAND (stmt, 1))\n \t      && !stmt_ann (stmt)->has_volatile_ops)\n \t    {\n-\t      tree lhs = TREE_OPERAND (stmt, 0);\n-\t      tree *rhs_p = &TREE_OPERAND (stmt, 1);\n+\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t      tree *rhs_p = &GIMPLE_STMT_OPERAND (stmt, 1);\n \t      tree sprime;\n \n \t      sprime = bitmap_find_leader (AVAIL_OUT (b),\n@@ -4097,8 +4100,8 @@ init_pre (bool do_fre)\n \t\t\t\t      tree_code_size (TREE_LIST), 30);\n   comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n \t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n-  modify_expr_node_pool = create_alloc_pool (\"MODIFY_EXPR nodes\",\n-\t\t\t\t\t     tree_code_size (MODIFY_EXPR),\n+  modify_expr_node_pool = create_alloc_pool (\"GIMPLE_MODIFY_STMT nodes\",\n+\t\t\t\t\t     tree_code_size (GIMPLE_MODIFY_STMT),\n \t\t\t\t\t     30);\n   modify_expr_template = NULL;\n "}, {"sha": "b787aae70ba370de2ebffd87e1149045d26e4848", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -531,12 +531,12 @@ get_rhs (tree stmt)\n     {\n     case RETURN_EXPR:\n       stmt = TREE_OPERAND (stmt, 0);\n-      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n+      if (!stmt || TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \treturn stmt;\n       /* FALLTHRU */\n \n-    case MODIFY_EXPR:\n-      stmt = TREE_OPERAND (stmt, 1);\n+    case GIMPLE_MODIFY_STMT:\n+      stmt = GENERIC_TREE_OPERAND (stmt, 1);\n       if (TREE_CODE (stmt) == WITH_SIZE_EXPR)\n \treturn TREE_OPERAND (stmt, 0);\n       else\n@@ -641,7 +641,8 @@ set_rhs (tree *stmt_p, tree expr)\n     }\n \n   if (EXPR_HAS_LOCATION (stmt)\n-      && EXPR_P (expr)\n+      && (EXPR_P (expr)\n+\t  || GIMPLE_STMT_P (expr))\n       && ! EXPR_HAS_LOCATION (expr)\n       && TREE_SIDE_EFFECTS (expr)\n       && TREE_CODE (expr) != LABEL_EXPR)\n@@ -651,19 +652,23 @@ set_rhs (tree *stmt_p, tree expr)\n     {\n     case RETURN_EXPR:\n       op = TREE_OPERAND (stmt, 0);\n-      if (TREE_CODE (op) != MODIFY_EXPR)\n+      if (TREE_CODE (op) != GIMPLE_MODIFY_STMT)\n \t{\n-\t  TREE_OPERAND (stmt, 0) = expr;\n+\t  GIMPLE_STMT_OPERAND (stmt, 0) = expr;\n \t  break;\n \t}\n       stmt = op;\n       /* FALLTHRU */\n \n-    case MODIFY_EXPR:\n-      op = TREE_OPERAND (stmt, 1);\n+    case GIMPLE_MODIFY_STMT:\n+      op = GIMPLE_STMT_OPERAND (stmt, 1);\n       if (TREE_CODE (op) == WITH_SIZE_EXPR)\n-\tstmt = op;\n-      TREE_OPERAND (stmt, 1) = expr;\n+\t{\n+\t  stmt = op;\n+          TREE_OPERAND (stmt, 1) = expr;\n+\t}\n+      else\n+        GIMPLE_STMT_OPERAND (stmt, 1) = expr;\n       break;\n \n     case COND_EXPR:\n@@ -686,7 +691,7 @@ set_rhs (tree *stmt_p, tree expr)\n \t effects, then replace *STMT_P with an empty statement.  */\n       ann = stmt_ann (stmt);\n       *stmt_p = TREE_SIDE_EFFECTS (expr) ? expr : build_empty_stmt ();\n-      (*stmt_p)->common.ann = (tree_ann_t) ann;\n+      (*stmt_p)->base.ann = (tree_ann_t) ann;\n \n       if (gimple_in_ssa_p (cfun)\n \t  && TREE_SIDE_EFFECTS (expr))\n@@ -770,13 +775,13 @@ stmt_makes_single_load (tree stmt)\n {\n   tree rhs;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n   if (ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF|SSA_OP_VUSE))\n     return false;\n \n-  rhs = TREE_OPERAND (stmt, 1);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n   STRIP_NOPS (rhs);\n \n   return (!TREE_THIS_VOLATILE (rhs)\n@@ -795,13 +800,13 @@ stmt_makes_single_store (tree stmt)\n {\n   tree lhs;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n   if (ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF|SSA_OP_VMUSTDEF))\n     return false;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   STRIP_NOPS (lhs);\n \n   return (!TREE_THIS_VOLATILE (lhs)\n@@ -963,7 +968,7 @@ replace_vuses_in (tree stmt, bool *replaced_addresses_p,\n \t see if we are trying to propagate a constant or a GIMPLE\n \t register (case #1 above).  */\n       prop_value_t *val = get_value_loaded_by (stmt, prop_value);\n-      tree rhs = TREE_OPERAND (stmt, 1);\n+      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n       if (val\n \t  && val->value\n@@ -975,7 +980,7 @@ replace_vuses_in (tree stmt, bool *replaced_addresses_p,\n \t  /* If we are replacing a constant address, inform our\n \t     caller.  */\n \t  if (TREE_CODE (val->value) != SSA_NAME\n-\t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 1)))\n+\t      && POINTER_TYPE_P (TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 1)))\n \t      && replaced_addresses_p)\n \t    *replaced_addresses_p = true;\n \n@@ -985,7 +990,7 @@ replace_vuses_in (tree stmt, bool *replaced_addresses_p,\n \t     stores between DEF_STMT and STMT, we only need to check\n \t     that the RHS of STMT is the same as the memory reference\n \t     propagated together with the value.  */\n-\t  TREE_OPERAND (stmt, 1) = val->value;\n+\t  GIMPLE_STMT_OPERAND (stmt, 1) = val->value;\n \n \t  if (TREE_CODE (val->value) != SSA_NAME)\n \t    prop_stats.num_const_prop++;\n@@ -1084,14 +1089,14 @@ static bool\n fold_predicate_in (tree stmt)\n {\n   tree *pred_p = NULL;\n-  bool modify_expr_p = false;\n+  bool modify_stmt_p = false;\n   tree val;\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR\n-      && COMPARISON_CLASS_P (TREE_OPERAND (stmt, 1)))\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+      && COMPARISON_CLASS_P (GIMPLE_STMT_OPERAND (stmt, 1)))\n     {\n-      modify_expr_p = true;\n-      pred_p = &TREE_OPERAND (stmt, 1);\n+      modify_stmt_p = true;\n+      pred_p = &GIMPLE_STMT_OPERAND (stmt, 1);\n     }\n   else if (TREE_CODE (stmt) == COND_EXPR)\n     pred_p = &COND_EXPR_COND (stmt);\n@@ -1101,7 +1106,7 @@ fold_predicate_in (tree stmt)\n   val = vrp_evaluate_conditional (*pred_p, true);\n   if (val)\n     {\n-      if (modify_expr_p)\n+      if (modify_stmt_p)\n         val = fold_convert (TREE_TYPE (*pred_p), val);\n       \n       if (dump_file)\n@@ -1167,8 +1172,8 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t  /* Ignore ASSERT_EXPRs.  They are used by VRP to generate\n \t     range information for names and they are discarded\n \t     afterwards.  */\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) == ASSERT_EXPR)\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ASSERT_EXPR)\n \t    continue;\n \n \t  /* Replace the statement with its folded version and mark it"}, {"sha": "17c4c6f4a5292883128ccb38316560a93a558302", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -271,7 +271,7 @@ get_rank (tree e)\n       if (bb_for_stmt (stmt) == NULL)\n \treturn 0;\n \n-      if (TREE_CODE (stmt) != MODIFY_EXPR\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n \t  || !ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n \treturn bb_rank[bb_for_stmt (stmt)->index];\n \n@@ -284,7 +284,7 @@ get_rank (tree e)\n \t rank, whichever is less.   */\n       rank = 0;\n       maxrank = bb_rank[bb_for_stmt(stmt)->index];\n-      rhs = TREE_OPERAND (stmt, 1);\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n       if (TREE_CODE_LENGTH (TREE_CODE (rhs)) == 0)\n \trank = MAX (rank, get_rank (rhs));\n       else\n@@ -378,9 +378,9 @@ static bool\n is_reassociable_op (tree stmt, enum tree_code code)\n {\n   if (!IS_EMPTY_STMT (stmt)\n-      && TREE_CODE (stmt) == MODIFY_EXPR\n-      && TREE_CODE (TREE_OPERAND (stmt, 1)) == code\n-      && has_single_use (TREE_OPERAND (stmt, 0)))\n+      && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == code\n+      && has_single_use (GIMPLE_STMT_OPERAND (stmt, 0)))\n     return true;\n   return false;\n }\n@@ -395,10 +395,10 @@ get_unary_op (tree name, enum tree_code opcode)\n   tree stmt = SSA_NAME_DEF_STMT (name);\n   tree rhs;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return NULL_TREE;\n \n-  rhs = TREE_OPERAND (stmt, 1);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (TREE_CODE (rhs) == opcode)\n     return TREE_OPERAND (rhs, 0);\n   return NULL_TREE;\n@@ -814,7 +814,7 @@ static bool\n is_phi_for_stmt (tree stmt, tree operand)\n {\n   tree def_stmt;\n-  tree lhs = TREE_OPERAND (stmt, 0);\n+  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   use_operand_p arg_p;\n   ssa_op_iter i;\n \n@@ -839,7 +839,7 @@ static void\n rewrite_expr_tree (tree stmt, unsigned int opindex,\n \t\t   VEC(operand_entry_t, heap) * ops)\n {\n-  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n   operand_entry_t oe;\n \n   /* If we have three operands left, then we want to make sure the one\n@@ -952,7 +952,7 @@ static void\n linearize_expr (tree stmt)\n {\n   block_stmt_iterator bsinow, bsirhs;\n-  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n   enum tree_code rhscode = TREE_CODE (rhs);\n   tree binrhs = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 1));\n   tree binlhs = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n@@ -965,11 +965,12 @@ linearize_expr (tree stmt)\n   bsirhs = bsi_for_stmt (binrhs);\n   bsi_move_before (&bsirhs, &bsinow);\n \n-  TREE_OPERAND (rhs, 1) = TREE_OPERAND (TREE_OPERAND (binrhs, 1), 0);\n+  TREE_OPERAND (rhs, 1) = TREE_OPERAND (GIMPLE_STMT_OPERAND (binrhs, 1), 0);\n   if (TREE_CODE (TREE_OPERAND (rhs, 1)) == SSA_NAME)\n     newbinrhs = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 1));\n-  TREE_OPERAND (TREE_OPERAND (binrhs, 1), 0) = TREE_OPERAND (binlhs, 0);\n-  TREE_OPERAND (rhs, 0) = TREE_OPERAND (binrhs, 0);\n+  TREE_OPERAND (GIMPLE_STMT_OPERAND (binrhs, 1), 0)\n+    = GIMPLE_STMT_OPERAND (binlhs, 0);\n+  TREE_OPERAND (rhs, 0) = GIMPLE_STMT_OPERAND (binrhs, 0);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -991,7 +992,7 @@ linearize_expr (tree stmt)\n \n }\n \n-/* If LHS has a single immediate use that is a MODIFY_EXPR, return\n+/* If LHS has a single immediate use that is a GIMPLE_MODIFY_STMT, return\n    it.  Otherwise, return NULL.  */\n \n static tree\n@@ -1005,7 +1006,7 @@ get_single_immediate_use (tree lhs)\n     {\n       if (TREE_CODE (immusestmt) == RETURN_EXPR)\n \timmusestmt = TREE_OPERAND (immusestmt, 0);\n-      if (TREE_CODE (immusestmt) == MODIFY_EXPR)\n+      if (TREE_CODE (immusestmt) == GIMPLE_MODIFY_STMT)\n \treturn immusestmt;\n     }\n   return NULL_TREE;\n@@ -1032,13 +1033,13 @@ negate_value (tree tonegate, block_stmt_iterator *bsi)\n   /* If we are trying to negate a name, defined by an add, negate the\n      add operands instead.  */\n   if (TREE_CODE (tonegate) == SSA_NAME\n-      && TREE_CODE (negatedef) == MODIFY_EXPR\n-      && TREE_CODE (TREE_OPERAND (negatedef, 0)) == SSA_NAME\n-      && has_single_use (TREE_OPERAND (negatedef, 0))\n-      && TREE_CODE (TREE_OPERAND (negatedef, 1)) == PLUS_EXPR)\n+      && TREE_CODE (negatedef) == GIMPLE_MODIFY_STMT\n+      && TREE_CODE (GIMPLE_STMT_OPERAND (negatedef, 0)) == SSA_NAME\n+      && has_single_use (GIMPLE_STMT_OPERAND (negatedef, 0))\n+      && TREE_CODE (GIMPLE_STMT_OPERAND (negatedef, 1)) == PLUS_EXPR)\n     {\n       block_stmt_iterator bsi;\n-      tree binop = TREE_OPERAND (negatedef, 1);\n+      tree binop = GIMPLE_STMT_OPERAND (negatedef, 1);\n \n       bsi = bsi_for_stmt (negatedef);\n       TREE_OPERAND (binop, 0) = negate_value (TREE_OPERAND (binop, 0),\n@@ -1047,7 +1048,7 @@ negate_value (tree tonegate, block_stmt_iterator *bsi)\n       TREE_OPERAND (binop, 1) = negate_value (TREE_OPERAND (binop, 1),\n \t\t\t\t\t      &bsi);\n       update_stmt (negatedef);\n-      return TREE_OPERAND (negatedef, 0);\n+      return GIMPLE_STMT_OPERAND (negatedef, 0);\n     }\n \n   tonegate = fold_build1 (NEGATE_EXPR, TREE_TYPE (tonegate), tonegate);\n@@ -1068,8 +1069,8 @@ static bool\n should_break_up_subtract (tree stmt)\n {\n \n-  tree lhs = TREE_OPERAND (stmt, 0);\n-  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n   tree binlhs = TREE_OPERAND (rhs, 0);\n   tree binrhs = TREE_OPERAND (rhs, 1);\n   tree immusestmt;\n@@ -1084,7 +1085,7 @@ should_break_up_subtract (tree stmt)\n \n   if (TREE_CODE (lhs) == SSA_NAME\n       && (immusestmt = get_single_immediate_use (lhs))\n-      && TREE_CODE (TREE_OPERAND (immusestmt, 1)) == PLUS_EXPR)\n+      && TREE_CODE (GIMPLE_STMT_OPERAND (immusestmt, 1)) == PLUS_EXPR)\n     return true;\n   return false;\n \n@@ -1095,15 +1096,15 @@ should_break_up_subtract (tree stmt)\n static void\n break_up_subtract (tree stmt, block_stmt_iterator *bsi)\n {\n-  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Breaking up subtract \");\n       print_generic_stmt (dump_file, stmt, 0);\n     }\n \n-  TREE_SET_CODE (TREE_OPERAND (stmt, 1), PLUS_EXPR);\n+  TREE_SET_CODE (GIMPLE_STMT_OPERAND (stmt, 1), PLUS_EXPR);\n   TREE_OPERAND (rhs, 1) = negate_value (TREE_OPERAND (rhs, 1), bsi);\n \n   update_stmt (stmt);\n@@ -1116,7 +1117,7 @@ static void\n linearize_expr_tree (VEC(operand_entry_t, heap) **ops, tree stmt)\n {\n   block_stmt_iterator bsinow, bsilhs;\n-  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree rhs = GENERIC_TREE_OPERAND (stmt, 1);\n   tree binrhs = TREE_OPERAND (rhs, 1);\n   tree binlhs = TREE_OPERAND (rhs, 0);\n   tree binlhsdef, binrhsdef;\n@@ -1180,7 +1181,7 @@ linearize_expr_tree (VEC(operand_entry_t, heap) **ops, tree stmt)\n   else if (binrhsisreassoc)\n     {\n       linearize_expr (stmt);\n-      gcc_assert (rhs == TREE_OPERAND (stmt, 1));\n+      gcc_assert (rhs == GIMPLE_STMT_OPERAND (stmt, 1));\n       binlhs = TREE_OPERAND (rhs, 0);\n       binrhs = TREE_OPERAND (rhs, 1);\n     }\n@@ -1213,15 +1214,15 @@ repropagate_negates (void)\n \t Force the negate operand to the RHS of the PLUS_EXPR, then\n \t transform the PLUS_EXPR into a MINUS_EXPR.  */\n       if (user\n-\t  && TREE_CODE (user) == MODIFY_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (user, 1)) == PLUS_EXPR)\n+\t  && TREE_CODE (user) == GIMPLE_MODIFY_STMT\n+\t  && TREE_CODE (GIMPLE_STMT_OPERAND (user, 1)) == PLUS_EXPR)\n \t{\n-\t  tree rhs = TREE_OPERAND (user, 1);\n+\t  tree rhs = GIMPLE_STMT_OPERAND (user, 1);\n \n \t  /* If the negated operand appears on the LHS of the\n \t     PLUS_EXPR, exchange the operands of the PLUS_EXPR\n \t     to force the negated operand to the RHS of the PLUS_EXPR.  */\n-\t  if (TREE_OPERAND (TREE_OPERAND (user, 1), 0) == negate)\n+\t  if (TREE_OPERAND (GIMPLE_STMT_OPERAND (user, 1), 0) == negate)\n \t    {\n \t      tree temp = TREE_OPERAND (rhs, 0);\n \t      TREE_OPERAND (rhs, 0) = TREE_OPERAND (rhs, 1);\n@@ -1230,7 +1231,7 @@ repropagate_negates (void)\n \n \t  /* Now transform the PLUS_EXPR into a MINUS_EXPR and replace\n \t     the RHS of the PLUS_EXPR with the operand of the NEGATE_EXPR.  */\n-\t  if (TREE_OPERAND (TREE_OPERAND (user, 1), 1) == negate)\n+\t  if (TREE_OPERAND (GIMPLE_STMT_OPERAND (user, 1), 1) == negate)\n \t    {\n \t      TREE_SET_CODE (rhs, MINUS_EXPR);\n \t      TREE_OPERAND (rhs, 1) = get_unary_op (negate, NEGATE_EXPR);\n@@ -1265,10 +1266,10 @@ break_up_subtract_bb (basic_block bb)\n     {\n       tree stmt = bsi_stmt (bsi);\n \n-      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t{\n-\t  tree lhs = TREE_OPERAND (stmt, 0);\n-\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\t  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t  TREE_VISITED (stmt) = 0;\n \t  /* If unsafe math optimizations we can do reassociation for\n@@ -1308,10 +1309,10 @@ reassociate_bb (basic_block bb)\n     {\n       tree stmt = bsi_stmt (bsi);\n \n-      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t{\n-\t  tree lhs = TREE_OPERAND (stmt, 0);\n-\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\t  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t  /* If this was part of an already processed tree, we don't\n \t     need to touch it again. */\n@@ -1351,14 +1352,15 @@ reassociate_bb (basic_block bb)\n \t\t      fprintf (dump_file, \"Transforming \");\n \t\t      print_generic_expr (dump_file, rhs, 0);\n \t\t    }\n-\t\t  TREE_OPERAND (stmt, 1) = VEC_last (operand_entry_t, ops)->op;\n+\t\t  GIMPLE_STMT_OPERAND (stmt, 1) \n+\t\t    = VEC_last (operand_entry_t, ops)->op;\n \t\t  update_stmt (stmt);\n \n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    {\n \t\t      fprintf (dump_file, \" into \");\n \t\t      print_generic_stmt (dump_file,\n-\t\t\t\t\t  TREE_OPERAND (stmt, 1), 0);\n+\t\t\t\t\t  GIMPLE_STMT_OPERAND (stmt, 1), 0);\n \t\t    }\n \t\t}\n \t      else"}, {"sha": "7bb37187e2023ad7f319aa02fb806903fa731486", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -144,7 +144,7 @@ is_hidden_global_store (tree stmt)\n     {\n       tree lhs;\n \n-      gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n+      gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n \n       /* Note that we must not check the individual virtual operands\n \t here.  In particular, if this is an aliased store, we could\n@@ -171,7 +171,7 @@ is_hidden_global_store (tree stmt)\n \t address is a pointer, we check if its name tag or symbol tag is\n \t a global variable.  Otherwise, we check if the base variable\n \t is a global.  */\n-      lhs = TREE_OPERAND (stmt, 0);\n+      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n       if (REFERENCE_CLASS_P (lhs))\n \tlhs = get_base_address (lhs);\n \n@@ -292,9 +292,9 @@ statement_sink_location (tree stmt, basic_block frombb)\n   if (one_use == NULL_USE_OPERAND_P)\n     return NULL;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return NULL;\n-  rhs = TREE_OPERAND (stmt, 1);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   /* There are a few classes of things we can't or don't move, some because we\n      don't have code to handle it, some because it's not profitable and some"}, {"sha": "99deb41b555599f45aa0f851730437c062398086", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -2763,13 +2763,13 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t of an assignment and their base address is always an\n \t INDIRECT_REF expression.  */\n       is_potential_deref = false;\n-      if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (stmt, 1)) == ADDR_EXPR\n-\t  && !is_gimple_val (TREE_OPERAND (stmt, 1)))\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t  && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ADDR_EXPR\n+\t  && !is_gimple_val (GIMPLE_STMT_OPERAND (stmt, 1)))\n \t{\n \t  /* If the RHS if of the form &PTR->FLD and PTR == OP, then\n \t     this represents a potential dereference of PTR.  */\n-\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \t  tree base = get_base_address (TREE_OPERAND (rhs, 0));\n \t  if (TREE_CODE (base) == INDIRECT_REF\n \t      && TREE_OPERAND (base, 0) == op)\n@@ -2971,9 +2971,9 @@ find_func_aliases (tree origt)\n      modify_expr when we are returning a value, or just a plain\n      call_expr when we are not.   */\n   else if (in_ipa_mode\n-\t   && ((TREE_CODE (t) == MODIFY_EXPR\n-\t\t&& TREE_CODE (TREE_OPERAND (t, 1)) == CALL_EXPR\n-\t       && !(call_expr_flags (TREE_OPERAND (t, 1))\n+\t   && ((TREE_CODE (t) == GIMPLE_MODIFY_STMT\n+\t\t&& TREE_CODE (GIMPLE_STMT_OPERAND (t, 1)) == CALL_EXPR\n+\t       && !(call_expr_flags (GIMPLE_STMT_OPERAND (t, 1))\n \t\t    & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n \t       || (TREE_CODE (t) == CALL_EXPR\n \t\t   && !(call_expr_flags (t)\n@@ -2986,10 +2986,10 @@ find_func_aliases (tree origt)\n       varinfo_t fi;\n       int i = 1;\n       tree decl;\n-      if (TREE_CODE (t) == MODIFY_EXPR)\n+      if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n \t{\n-\t  lhsop = TREE_OPERAND (t, 0);\n-\t  rhsop = TREE_OPERAND (t, 1);\n+\t  lhsop = GIMPLE_STMT_OPERAND (t, 0);\n+\t  rhsop = GIMPLE_STMT_OPERAND (t, 1);\n \t}\n       else\n \t{\n@@ -3068,10 +3068,10 @@ find_func_aliases (tree origt)\n \t}\n     }\n   /* Otherwise, just a regular assignment statement.  */\n-  else if (TREE_CODE (t) == MODIFY_EXPR)\n+  else if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n     {\n-      tree lhsop = TREE_OPERAND (t, 0);\n-      tree rhsop = TREE_OPERAND (t, 1);\n+      tree lhsop = GIMPLE_STMT_OPERAND (t, 0);\n+      tree rhsop = GIMPLE_STMT_OPERAND (t, 1);\n       int i;\n \n       if ((AGGREGATE_TYPE_P (TREE_TYPE (lhsop))"}, {"sha": "e48cd650d17f37ecb6a9bda125e58b718e2d10b0", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -91,12 +91,12 @@ lhs_of_dominating_assert (tree op, basic_block bb, tree stmt)\n     {\n       use_stmt = USE_STMT (use_p);\n       if (use_stmt != stmt\n-          && TREE_CODE (use_stmt) == MODIFY_EXPR\n-          && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == ASSERT_EXPR\n-          && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 0) == op\n+          && TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+          && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == ASSERT_EXPR\n+          && TREE_OPERAND (GIMPLE_STMT_OPERAND (use_stmt, 1), 0) == op\n \t  && dominated_by_p (CDI_DOMINATORS, bb, bb_for_stmt (use_stmt)))\n \t{\n-\t  return TREE_OPERAND (use_stmt, 0);\n+\t  return GIMPLE_STMT_OPERAND (use_stmt, 0);\n \t}\n     }\n   return op;\n@@ -245,11 +245,11 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       if (stmt_count > max_stmt_count)\n \treturn NULL;\n \n-      /* If this is not a MODIFY_EXPR which sets an SSA_NAME to a new\n+      /* If this is not a GIMPLE_MODIFY_STMT which sets an SSA_NAME to a new\n \t value, then do not try to simplify this statement as it will\n \t not simplify in any way that is helpful for jump threading.  */\n-      if (TREE_CODE (stmt) != MODIFY_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n+\t  || TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n \tcontinue;\n \n       /* At this point we have a statement which assigns an RHS to an\n@@ -259,10 +259,10 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \n \t Handle simple copy operations as well as implied copies from\n \t ASSERT_EXPRs.  */\n-      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME)\n-\tcached_lhs = TREE_OPERAND (stmt, 1);\n-      else if (TREE_CODE (TREE_OPERAND (stmt, 1)) == ASSERT_EXPR)\n-\tcached_lhs = TREE_OPERAND (TREE_OPERAND (stmt, 1), 0);\n+      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == SSA_NAME)\n+\tcached_lhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+      else if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ASSERT_EXPR)\n+\tcached_lhs = TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 0);\n       else\n \t{\n \t  /* A statement that is not a trivial copy or ASSERT_EXPR.\n@@ -296,19 +296,19 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t     here, because fold expects all the operands of an expression\n \t     to be folded before the expression itself is folded, but we\n \t     can't just substitute the folded condition here.  */\n-\t  if (TREE_CODE (TREE_OPERAND (stmt, 1)) == COND_EXPR)\n+\t  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == COND_EXPR)\n \t    {\n-\t      tree cond = COND_EXPR_COND (TREE_OPERAND (stmt, 1));\n+\t      tree cond = COND_EXPR_COND (GIMPLE_STMT_OPERAND (stmt, 1));\n \t      cond = fold (cond);\n \t      if (cond == boolean_true_node)\n-\t\tpre_fold_expr = COND_EXPR_THEN (TREE_OPERAND (stmt, 1));\n+\t\tpre_fold_expr = COND_EXPR_THEN (GIMPLE_STMT_OPERAND (stmt, 1));\n \t      else if (cond == boolean_false_node)\n-\t\tpre_fold_expr = COND_EXPR_ELSE (TREE_OPERAND (stmt, 1));\n+\t\tpre_fold_expr = COND_EXPR_ELSE (GIMPLE_STMT_OPERAND (stmt, 1));\n \t      else\n-\t\tpre_fold_expr = TREE_OPERAND (stmt, 1);\n+\t\tpre_fold_expr = GIMPLE_STMT_OPERAND (stmt, 1);\n \t    }\n \t  else\n-\t    pre_fold_expr = TREE_OPERAND (stmt, 1);\n+\t    pre_fold_expr = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t  if (pre_fold_expr)\n \t    {\n@@ -331,7 +331,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       if (cached_lhs\n \t  && (TREE_CODE (cached_lhs) == SSA_NAME\n \t      || is_gimple_min_invariant (cached_lhs)))\n-\trecord_temporary_equivalence (TREE_OPERAND (stmt, 0),\n+\trecord_temporary_equivalence (GIMPLE_STMT_OPERAND (stmt, 0),\n \t\t\t\t      cached_lhs,\n \t\t\t\t      stack);\n     }"}, {"sha": "ce46fa27902a3852c65a4787e52262db23d7e0c5", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -624,12 +624,12 @@ verify_ssa (bool check_modified_stmt)\n \t      goto err;\n \t    }\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n \t    {\n \t      tree lhs, base_address;\n \n-\t      lhs = TREE_OPERAND (stmt, 0);\n+\t      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n \t      base_address = get_base_address (lhs);\n \n \t      if (base_address\n@@ -758,8 +758,8 @@ delete_tree_ssa (void)\n   /* Remove annotations from every referenced variable.  */\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      ggc_free (var->common.ann);\n-      var->common.ann = NULL;\n+      ggc_free (var->base.ann);\n+      var->base.ann = NULL;\n     }\n   htab_delete (gimple_referenced_vars (cfun));\n   cfun->gimple_df->referenced_vars = NULL;"}, {"sha": "a8716dad8d16c3f59ba0474a1aefaad16453023c", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -119,7 +119,9 @@ make_ssa_name (tree var, tree stmt)\n   gcc_assert (DECL_P (var)\n \t      || TREE_CODE (var) == INDIRECT_REF);\n \n-  gcc_assert (!stmt || EXPR_P (stmt) || TREE_CODE (stmt) == PHI_NODE);\n+  gcc_assert (!stmt\n+\t      || EXPR_P (stmt) || GIMPLE_STMT_P (stmt)\n+\t      || TREE_CODE (stmt) == PHI_NODE);\n \n   /* If our free list has an element, then use it.  */\n   if (FREE_SSANAMES (cfun))"}, {"sha": "bc72c17baeacab222c79e2e80b5dc0bad77ae277", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -149,11 +149,11 @@ va_list_counter_bump (struct stdarg_info *si, tree counter, tree rhs,\n \n       stmt = SSA_NAME_DEF_STMT (lhs);\n \n-      if (TREE_CODE (stmt) != MODIFY_EXPR\n-\t  || TREE_OPERAND (stmt, 0) != lhs)\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n+\t  || GIMPLE_STMT_OPERAND (stmt, 0) != lhs)\n \treturn (unsigned HOST_WIDE_INT) -1;\n \n-      rhs = TREE_OPERAND (stmt, 1);\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n       if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n \trhs = TREE_OPERAND (rhs, 0);\n \n@@ -211,7 +211,7 @@ va_list_counter_bump (struct stdarg_info *si, tree counter, tree rhs,\n \n       stmt = SSA_NAME_DEF_STMT (lhs);\n \n-      rhs = TREE_OPERAND (stmt, 1);\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n       if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n \trhs = TREE_OPERAND (rhs, 0);\n \n@@ -522,10 +522,10 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t\t\t\t  DECL_UID (SSA_NAME_VAR (use))))\n \t\tcontinue;\n \n-\t      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t\t{\n-\t\t  tree lhs = TREE_OPERAND (stmt, 0);\n-\t\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\t\t  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t\t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t\t  if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n \t\t    rhs = TREE_OPERAND (rhs, 0);\n@@ -807,10 +807,10 @@ execute_optimize_stdarg (void)\n \t\tcontinue;\n \t    }\n \n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t    {\n-\t      tree lhs = TREE_OPERAND (stmt, 0);\n-\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t      if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n \t\trhs = TREE_OPERAND (rhs, 0);"}, {"sha": "05c2778ae120bafd814b7e7961db6a0703f68923", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -272,8 +272,8 @@ process_assignment (tree ass, tree stmt, block_stmt_iterator call, tree *m,\n \t\t    tree *a, tree *ass_var)\n {\n   tree op0, op1, non_ass_var;\n-  tree dest = TREE_OPERAND (ass, 0);\n-  tree src = TREE_OPERAND (ass, 1);\n+  tree dest = GIMPLE_STMT_OPERAND (ass, 0);\n+  tree src = GIMPLE_STMT_OPERAND (ass, 1);\n   enum tree_code code = TREE_CODE (src);\n   tree src_var = src;\n \n@@ -395,10 +395,10 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \tcontinue;\n \n       /* Check for a call.  */\n-      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t{\n-\t  ass_var = TREE_OPERAND (stmt, 0);\n-\t  call = TREE_OPERAND (stmt, 1);\n+\t  ass_var = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t  call = GIMPLE_STMT_OPERAND (stmt, 1);\n \t  if (TREE_CODE (call) == WITH_SIZE_EXPR)\n \t    call = TREE_OPERAND (call, 0);\n \t}\n@@ -454,7 +454,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \t\t of copying the value.  This test implies is_gimple_reg_type\n \t\t from the previous condition, however this one could be\n \t\t relaxed by being more careful with copying the new value\n-\t\t of the parameter (emitting appropriate MODIFY_EXPR and\n+\t\t of the parameter (emitting appropriate GIMPLE_MODIFY_STMT and\n \t\t updating the virtual operands).  */\n \t      if (!is_gimple_reg (param))\n \t\tbreak;\n@@ -492,7 +492,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n       if (TREE_CODE (stmt) == RETURN_EXPR)\n \tbreak;\n \n-      if (TREE_CODE (stmt) != MODIFY_EXPR)\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \treturn;\n \n       if (!process_assignment (stmt, stmt, bsi, &m, &a, &ass_var))\n@@ -502,17 +502,17 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   /* See if this is a tail call we can handle.  */\n   ret_var = TREE_OPERAND (stmt, 0);\n   if (ret_var\n-      && TREE_CODE (ret_var) == MODIFY_EXPR)\n+      && TREE_CODE (ret_var) == GIMPLE_MODIFY_STMT)\n     {\n-      tree ret_op = TREE_OPERAND (ret_var, 1);\n+      tree ret_op = GIMPLE_STMT_OPERAND (ret_var, 1);\n       STRIP_NOPS (ret_op);\n       if (!tail_recursion\n \t  && TREE_CODE (ret_op) != SSA_NAME)\n \treturn;\n \n       if (!process_assignment (ret_var, stmt, bsi, &m, &a, &ass_var))\n \treturn;\n-      ret_var = TREE_OPERAND (ret_var, 0);\n+      ret_var = GIMPLE_STMT_OPERAND (ret_var, 0);\n     }\n \n   /* We may proceed if there either is no return value, or the return value\n@@ -558,34 +558,34 @@ adjust_accumulator_values (block_stmt_iterator bsi, tree m, tree a, edge back)\n \t    var = m_acc;\n \t  else\n \t    {\n-\t      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+\t      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n \t\t\t     build2 (MULT_EXPR, ret_type, m_acc, a));\n \n \t      tmp = create_tmp_var (ret_type, \"acc_tmp\");\n \t      add_referenced_var (tmp);\n \n \t      var = make_ssa_name (tmp, stmt);\n-\t      TREE_OPERAND (stmt, 0) = var;\n+\t      GIMPLE_STMT_OPERAND (stmt, 0) = var;\n \t      bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n \t    }\n \t}\n       else\n \tvar = a;\n \n-      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n \t\t     build2 (PLUS_EXPR, ret_type, a_acc, var));\n       var = make_ssa_name (SSA_NAME_VAR (a_acc), stmt);\n-      TREE_OPERAND (stmt, 0) = var;\n+      GIMPLE_STMT_OPERAND (stmt, 0) = var;\n       bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n       a_acc_arg = var;\n     }\n \n   if (m)\n     {\n-      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n \t\t     build2 (MULT_EXPR, ret_type, m_acc, m));\n       var = make_ssa_name (SSA_NAME_VAR (m_acc), stmt);\n-      TREE_OPERAND (stmt, 0) = var;\n+      GIMPLE_STMT_OPERAND (stmt, 0) = var;\n       bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n       m_acc_arg = var;\n     }\n@@ -625,41 +625,41 @@ adjust_return_value (basic_block bb, tree m, tree a)\n   if (!ret_var)\n     return;\n \n-  if (TREE_CODE (ret_var) == MODIFY_EXPR)\n+  if (TREE_CODE (ret_var) == GIMPLE_MODIFY_STMT)\n     {\n-      ret_var->common.ann = (tree_ann_t) stmt_ann (ret_stmt);\n+      ret_var->base.ann = (tree_ann_t) stmt_ann (ret_stmt);\n       bsi_replace (&bsi, ret_var, true);\n-      SSA_NAME_DEF_STMT (TREE_OPERAND (ret_var, 0)) = ret_var;\n-      ret_var = TREE_OPERAND (ret_var, 0);\n+      SSA_NAME_DEF_STMT (GIMPLE_STMT_OPERAND (ret_var, 0)) = ret_var;\n+      ret_var = GIMPLE_STMT_OPERAND (ret_var, 0);\n       ret_stmt = build1 (RETURN_EXPR, TREE_TYPE (ret_stmt), ret_var);\n       bsi_insert_after (&bsi, ret_stmt, BSI_NEW_STMT);\n     }\n \n   if (m)\n     {\n-      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n \t\t     build2 (MULT_EXPR, ret_type, m_acc, ret_var));\n \n       tmp = create_tmp_var (ret_type, \"acc_tmp\");\n       add_referenced_var (tmp);\n \n       var = make_ssa_name (tmp, stmt);\n-      TREE_OPERAND (stmt, 0) = var;\n+      GIMPLE_STMT_OPERAND (stmt, 0) = var;\n       bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n     }\n   else\n     var = ret_var;\n \n   if (a)\n     {\n-      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+      stmt = build2 (GIMPLE_MODIFY_STMT, ret_type, NULL_TREE,\n \t\t     build2 (PLUS_EXPR, ret_type, a_acc, var));\n \n       tmp = create_tmp_var (ret_type, \"acc_tmp\");\n       add_referenced_var (tmp);\n \n       var = make_ssa_name (tmp, stmt);\n-      TREE_OPERAND (stmt, 0) = var;\n+      GIMPLE_STMT_OPERAND (stmt, 0) = var;\n       bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n     }\n \n@@ -733,8 +733,8 @@ eliminate_tail_call (struct tailcall *t)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n-    stmt = TREE_OPERAND (stmt, 1);\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+    stmt = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   first = single_succ (ENTRY_BLOCK_PTR);\n \n@@ -788,9 +788,9 @@ eliminate_tail_call (struct tailcall *t)\n   adjust_accumulator_values (t->call_bsi, t->mult, t->add, e);\n \n   call = bsi_stmt (t->call_bsi);\n-  if (TREE_CODE (call) == MODIFY_EXPR)\n+  if (TREE_CODE (call) == GIMPLE_MODIFY_STMT)\n     {\n-      rslt = TREE_OPERAND (call, 0);\n+      rslt = GIMPLE_STMT_OPERAND (call, 0);\n \n       /* Result of the call will no longer be defined.  So adjust the\n \t SSA_NAME_DEF_STMT accordingly.  */"}, {"sha": "31895733534266077f7b6ccbf4e57216f577300d", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -130,7 +130,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n               continue;\n             }\n \n-          if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n+          if (!GIMPLE_STMT_P (stmt)\n+\t      && VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n             {\n               if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n                 {\n@@ -150,8 +151,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      if (STMT_VINFO_DATA_REF (stmt_info))\n \t\tscalar_type = \n \t\t\tTREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (stmt_info)));\n-\t      else if (TREE_CODE (stmt) == MODIFY_EXPR)\n-\t\tscalar_type = TREE_TYPE (TREE_OPERAND (stmt, 0));\n+\t      else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+\t\tscalar_type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0));\n \t      else\n \t\tscalar_type = TREE_TYPE (stmt);\n \n@@ -293,7 +294,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n           if (STMT_VINFO_RELEVANT_P (stmt_info))\n             {\n-              gcc_assert (!VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))));\n+              gcc_assert (GIMPLE_STMT_P (stmt)\n+\t\t  \t  || !VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))));\n               gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n \n \t      ok = (vectorizable_type_promotion (stmt, NULL, NULL)\n@@ -429,10 +431,10 @@ exist_non_indexing_operands_for_use_p (tree use, tree stmt)\n      Therefore, all we need to check is if STMT falls into the\n      first case, and whether var corresponds to USE.  */\n  \n-  if (TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME)\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME)\n     return false;\n \n-  operand = TREE_OPERAND (stmt, 1);\n+  operand = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   if (TREE_CODE (operand) != SSA_NAME)\n     return false;"}, {"sha": "fb310f23ed63f705c72c322fcf17bf6808314818", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -380,14 +380,14 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n     {\n     case RETURN_EXPR:\n       stmt = TREE_OPERAND (stmt, 0);\n-      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n+      if (!stmt || TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \treturn;\n \n       /* FALLTHRU */\n \n-    case MODIFY_EXPR:\n-      p_lhs = &TREE_OPERAND (stmt, 0);\n-      p_rhs = &TREE_OPERAND (stmt, 1);\n+    case GIMPLE_MODIFY_STMT:\n+      p_lhs = &GIMPLE_STMT_OPERAND (stmt, 0);\n+      p_rhs = &GIMPLE_STMT_OPERAND (stmt, 1);\n       lhs = *p_lhs;\n       rhs = *p_rhs;\n       break;"}, {"sha": "cb5d4e72d2a5732a99597ea63412f09cea7c2ed8", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -91,10 +91,10 @@ widened_name_p (tree name, tree use_stmt, tree *half_type, tree *def_stmt)\n   if (! *def_stmt)\n     return false;\n \n-  if (TREE_CODE (*def_stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (*def_stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  expr = TREE_OPERAND (*def_stmt, 1);\n+  expr = GIMPLE_STMT_OPERAND (*def_stmt, 1);\n   if (TREE_CODE (expr) != NOP_EXPR)\n     return false;\n \n@@ -166,10 +166,10 @@ vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n   tree pattern_expr;\n   tree prod_type;\n \n-  if (TREE_CODE (last_stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (last_stmt) != GIMPLE_MODIFY_STMT)\n     return NULL;\n \n-  expr = TREE_OPERAND (last_stmt, 1);\n+  expr = GIMPLE_STMT_OPERAND (last_stmt, 1);\n   type = TREE_TYPE (expr);\n \n   /* Look for the following pattern \n@@ -228,7 +228,7 @@ vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n       if (widened_name_p (oprnd0, stmt, &half_type, &def_stmt))\n         {\n           stmt = def_stmt;\n-          expr = TREE_OPERAND (stmt, 1);\n+          expr = GIMPLE_STMT_OPERAND (stmt, 1);\n           oprnd0 = TREE_OPERAND (expr, 0);\n         }\n       else\n@@ -247,15 +247,15 @@ vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n   gcc_assert (stmt_vinfo);\n   if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_loop_def)\n     return NULL;\n-  expr = TREE_OPERAND (stmt, 1);\n+  expr = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (TREE_CODE (expr) != MULT_EXPR)\n     return NULL;\n   if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n     {\n       /* Has been detected as a widening multiplication?  */\n \n       stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n-      expr = TREE_OPERAND (stmt, 1);\n+      expr = GIMPLE_STMT_OPERAND (stmt, 1);\n       if (TREE_CODE (expr) != WIDEN_MULT_EXPR)\n         return NULL;\n       stmt_vinfo = vinfo_for_stmt (stmt);\n@@ -279,10 +279,10 @@ vect_recog_dot_prod_pattern (tree last_stmt, tree *type_in, tree *type_out)\n         return NULL;\n       if (!widened_name_p (oprnd0, stmt, &half_type0, &def_stmt))\n         return NULL;\n-      oprnd00 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n+      oprnd00 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n       if (!widened_name_p (oprnd1, stmt, &half_type1, &def_stmt))\n         return NULL;\n-      oprnd01 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n+      oprnd01 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n       if (TYPE_MAIN_VARIANT (half_type0) != TYPE_MAIN_VARIANT (half_type1))\n         return NULL;\n       if (TYPE_PRECISION (prod_type) != TYPE_PRECISION (half_type0) * 2)\n@@ -349,10 +349,10 @@ vect_recog_widen_mult_pattern (tree last_stmt,\n   tree dummy;\n   enum tree_code dummy_code;\n \n-  if (TREE_CODE (last_stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (last_stmt) != GIMPLE_MODIFY_STMT)\n     return NULL;\n \n-  expr = TREE_OPERAND (last_stmt, 1);\n+  expr = GIMPLE_STMT_OPERAND (last_stmt, 1);\n   type = TREE_TYPE (expr);\n \n   /* Starting from LAST_STMT, follow the defs of its uses in search\n@@ -370,12 +370,12 @@ vect_recog_widen_mult_pattern (tree last_stmt,\n   /* Check argument 0 */\n   if (!widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0))\n     return NULL;\n-  oprnd0 = TREE_OPERAND (TREE_OPERAND (def_stmt0, 1), 0);\n+  oprnd0 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt0, 1), 0);\n \n   /* Check argument 1 */\n   if (!widened_name_p (oprnd1, last_stmt, &half_type1, &def_stmt1))\n     return NULL;\n-  oprnd1 = TREE_OPERAND (TREE_OPERAND (def_stmt1, 1), 0);\n+  oprnd1 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt1, 1), 0);\n \n   if (TYPE_MAIN_VARIANT (half_type0) != TYPE_MAIN_VARIANT (half_type1))\n     return NULL;\n@@ -435,10 +435,10 @@ vect_recog_pow_pattern (tree last_stmt, tree *type_in, tree *type_out)\n   tree type;\n   tree fn, arglist, base, exp;\n \n-  if (TREE_CODE (last_stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (last_stmt) != GIMPLE_MODIFY_STMT)\n     return NULL;\n \n-  expr = TREE_OPERAND (last_stmt, 1);\n+  expr = GIMPLE_STMT_OPERAND (last_stmt, 1);\n   type = TREE_TYPE (expr);\n \n   if (TREE_CODE (expr) != CALL_EXPR)\n@@ -538,10 +538,10 @@ vect_recog_widen_sum_pattern (tree last_stmt, tree *type_in, tree *type_out)\n   tree type, half_type;\n   tree pattern_expr;\n \n-  if (TREE_CODE (last_stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (last_stmt) != GIMPLE_MODIFY_STMT)\n     return NULL;\n \n-  expr = TREE_OPERAND (last_stmt, 1);\n+  expr = GIMPLE_STMT_OPERAND (last_stmt, 1);\n   type = TREE_TYPE (expr);\n \n   /* Look for the following pattern\n@@ -575,7 +575,7 @@ vect_recog_widen_sum_pattern (tree last_stmt, tree *type_in, tree *type_out)\n   if (!widened_name_p (oprnd0, last_stmt, &half_type, &stmt))\n     return NULL;\n \n-  oprnd0 = TREE_OPERAND (TREE_OPERAND (stmt, 1), 0);\n+  oprnd0 = TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 0);\n   *type_in = half_type;\n   *type_out = type;\n \n@@ -672,7 +672,8 @@ vect_pattern_recog_1 (\n   var = create_tmp_var (pattern_type, \"patt\");\n   add_referenced_var (var);\n   var_name = make_ssa_name (var, NULL_TREE);\n-  pattern_expr = build2 (MODIFY_EXPR, void_type_node, var_name, pattern_expr);\n+  pattern_expr = build2 (GIMPLE_MODIFY_STMT, void_type_node, var_name,\n+      \t\t\t pattern_expr);\n   SSA_NAME_DEF_STMT (var_name) = pattern_expr;\n   bsi_insert_before (&si, pattern_expr, BSI_SAME_STMT);\n   ann = stmt_ann (pattern_expr);"}, {"sha": "213ced9ddc9a514dd9555b843e2a0a63e72283e5", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 120, "deletions": 108, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -210,7 +210,8 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n \n    Input:\n    1. STMT: a stmt that references memory. Expected to be of the form\n-         MODIFY_EXPR <name, data-ref> or MODIFY_EXPR <data-ref, name>.\n+         GIMPLE_MODIFY_STMT <name, data-ref> or\n+\t GIMPLE_MODIFY_STMT <data-ref, name>.\n    2. BSI: block_stmt_iterator where new stmts can be added.\n    3. OFFSET (optional): an offset to be added to the initial address accessed\n         by the data-ref in STMT.\n@@ -317,9 +318,9 @@ vect_create_data_ref_ptr (tree stmt,\n \n   /* Create: p = (vectype *) initial_base  */\n   vec_stmt = fold_convert (vect_ptr_type, new_temp);\n-  vec_stmt = build2 (MODIFY_EXPR, void_type_node, vect_ptr, vec_stmt);\n+  vec_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vect_ptr, vec_stmt);\n   vect_ptr_init = make_ssa_name (vect_ptr, vec_stmt);\n-  TREE_OPERAND (vec_stmt, 0) = vect_ptr_init;\n+  GIMPLE_STMT_OPERAND (vec_stmt, 0) = vect_ptr_init;\n   new_bb = bsi_insert_on_edge_immediate (pe, vec_stmt);\n   gcc_assert (!new_bb);\n \n@@ -410,10 +411,10 @@ bump_vector_ptr (tree dataref_ptr, tree ptr_incr, block_stmt_iterator *bsi,\n   use_operand_p use_p;\n   tree new_dataref_ptr;\n \n-  incr_stmt = build2 (MODIFY_EXPR, void_type_node, ptr_var,\n+  incr_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, ptr_var,\n                 build2 (PLUS_EXPR, vptr_type, dataref_ptr, update));\n   new_dataref_ptr = make_ssa_name (ptr_var, incr_stmt);\n-  TREE_OPERAND (incr_stmt, 0) = new_dataref_ptr;\n+  GIMPLE_STMT_OPERAND (incr_stmt, 0) = new_dataref_ptr;\n   vect_finish_stmt_generation (stmt, incr_stmt, bsi);\n \n   /* Update the vector-pointer's cross-iteration increment.  */\n@@ -485,9 +486,9 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n   new_var = vect_get_new_vect_var (vector_type, vect_simple_var, \"cst_\");\n   add_referenced_var (new_var); \n  \n-  init_stmt = build2 (MODIFY_EXPR, void_type_node, new_var, vector_var);\n+  init_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, new_var, vector_var);\n   new_temp = make_ssa_name (new_var, init_stmt);\n-  TREE_OPERAND (init_stmt, 0) = new_temp;\n+  GIMPLE_STMT_OPERAND (init_stmt, 0) = new_temp;\n \n   pe = loop_preheader_edge (loop);\n   new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n@@ -499,7 +500,7 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n       print_generic_expr (vect_dump, init_stmt, TDF_SLIM);\n     }\n \n-  vec_oprnd = TREE_OPERAND (init_stmt, 0);\n+  vec_oprnd = GIMPLE_STMT_OPERAND (init_stmt, 0);\n   return vec_oprnd;\n }\n \n@@ -611,7 +612,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n         def_stmt_info = vinfo_for_stmt (def_stmt);\n         vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n         gcc_assert (vec_stmt);\n-        vec_oprnd = TREE_OPERAND (vec_stmt, 0);\n+        vec_oprnd = GIMPLE_STMT_OPERAND (vec_stmt, 0);\n         return vec_oprnd;\n       }\n \n@@ -712,7 +713,7 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n   gcc_assert (def_stmt_info);\n   vec_stmt_for_operand = STMT_VINFO_RELATED_STMT (def_stmt_info);\n   gcc_assert (vec_stmt_for_operand);\n-  vec_oprnd = TREE_OPERAND (vec_stmt_for_operand, 0);\n+  vec_oprnd = GIMPLE_STMT_OPERAND (vec_stmt_for_operand, 0);\n \n   return vec_oprnd;\n }\n@@ -802,7 +803,7 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   int nunits = GET_MODE_NUNITS (TYPE_MODE (vectype));\n   int nelements;\n-  enum tree_code code = TREE_CODE (TREE_OPERAND (stmt, 1));\n+  enum tree_code code = TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1));\n   tree type = TREE_TYPE (init_val);\n   tree def;\n   tree vec, t = NULL_TREE;\n@@ -940,7 +941,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   tree epilog_stmt;\n   tree new_scalar_dest, exit_phi;\n   tree bitsize, bitpos, bytesize; \n-  enum tree_code code = TREE_CODE (TREE_OPERAND (stmt, 1));\n+  enum tree_code code = TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1));\n   tree scalar_initial_def;\n   tree vec_initial_def;\n   tree orig_name;\n@@ -950,7 +951,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   tree reduction_op;\n   tree orig_stmt;\n   tree use_stmt;\n-  tree operation = TREE_OPERAND (stmt, 1);\n+  tree operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   int op_type;\n   \n   op_type = TREE_CODE_LENGTH (TREE_CODE (operation));\n@@ -1037,8 +1038,8 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n       gcc_assert (STMT_VINFO_IN_PATTERN_P (stmt_vinfo));\n       gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n     }\n-  code = TREE_CODE (TREE_OPERAND (orig_stmt, 1));\n-  scalar_dest = TREE_OPERAND (orig_stmt, 0);\n+  code = TREE_CODE (GIMPLE_STMT_OPERAND (orig_stmt, 1));\n+  scalar_dest = GIMPLE_STMT_OPERAND (orig_stmt, 0);\n   scalar_type = TREE_TYPE (scalar_dest);\n   new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n   bitsize = TYPE_SIZE (scalar_type);\n@@ -1056,10 +1057,10 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \tfprintf (vect_dump, \"Reduce using direct vector reduction.\");\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n+      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n \t\t\tbuild1 (reduc_code, vectype,  PHI_RESULT (new_phi)));\n       new_temp = make_ssa_name (vec_dest, epilog_stmt);\n-      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n       extract_scalar_result = true;\n@@ -1114,18 +1115,20 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t    {\n \t      tree bitpos = size_int (bit_offset);\n \n-\t      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n+\t      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t\t  \t\t    vec_dest,\n \t\t\t\t    build2 (shift_code, vectype,\n \t\t\t\t\t    new_temp, bitpos));\n \t      new_name = make_ssa_name (vec_dest, epilog_stmt);\n-\t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n+\t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n-\t      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n+\t      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t\t  \t\t    vec_dest,\n \t\t\t\t    build2 (code, vectype,\n \t\t\t\t\t    new_name, new_temp));\n \t      new_temp = make_ssa_name (vec_dest, epilog_stmt);\n-\t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+\t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \t    }\n \n@@ -1153,9 +1156,10 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t  rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n \t\t\t bitsize_zero_node);\n \t  BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t  epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest, rhs);\n+\t  epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t      \t\t\tnew_scalar_dest, rhs);\n \t  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-\t  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+\t  GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n \t  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \t      \n \t  for (bit_offset = element_bitsize;\n@@ -1167,16 +1171,17 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t\t\t\t bitpos);\n \t\t\n \t      BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest,\n-\t\t\t\t    rhs);\t\n+\t      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t\t  \t\t    new_scalar_dest, rhs);\t\n \t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n-\t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n+\t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n-\t      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest,\n+\t      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t\t  \t\tnew_scalar_dest,\n \t\t\t\tbuild2 (code, scalar_type, new_name, new_temp));\n \t      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-\t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+\t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \t    }\n \n@@ -1203,9 +1208,10 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \n       rhs = build3 (BIT_FIELD_REF, scalar_type, new_temp, bitsize, bitpos);\n       BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest, rhs);\n+      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t  \t\t    new_scalar_dest, rhs);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-      TREE_OPERAND (epilog_stmt, 0) = new_temp; \n+      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp; \n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n     }\n \n@@ -1218,10 +1224,11 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   \n   if (scalar_initial_def)\n     {\n-      epilog_stmt = build2 (MODIFY_EXPR, void_type_node, new_scalar_dest,\n+      epilog_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t  \t      new_scalar_dest,\n                       build2 (code, scalar_type, new_temp, scalar_initial_def));\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n     }\n \n@@ -1357,14 +1364,14 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n         inside the loop body. The last operand is the reduction variable,\n         which is defined by the loop-header-phi.  */\n \n-  gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n+  gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n \n-  operation = TREE_OPERAND (stmt, 1);\n+  operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n   op_type = TREE_CODE_LENGTH (code);\n   if (op_type != binary_op && op_type != ternary_op)\n     return false;\n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   scalar_type = TREE_TYPE (scalar_dest);\n \n   /* All uses but the last are expected to be defined in the loop.\n@@ -1462,7 +1469,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     {\n       /* This is a reduction pattern: get the vectype from the type of the\n          reduction variable, and get the tree-code from orig_stmt.  */\n-      orig_code = TREE_CODE (TREE_OPERAND (orig_stmt, 1));\n+      orig_code = TREE_CODE (GIMPLE_STMT_OPERAND (orig_stmt, 1));\n       vectype = get_vectype_for_scalar_type (TREE_TYPE (def));\n       vec_mode = TYPE_MODE (vectype);\n     }\n@@ -1538,7 +1545,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n                                                                                 \n           /* Get the vector def for the reduction variable from the vectorized\n              reduction operation generated in the previous iteration (j-1)  */\n-          reduc_def = TREE_OPERAND (new_stmt ,0);\n+          reduc_def = GIMPLE_STMT_OPERAND (new_stmt ,0);\n         }\n                                                                                 \n       /* Arguments are ready. create the new vector stmt.  */\n@@ -1548,9 +1555,9 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       else\n         expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1, \n \t\t\t\t\t\t\t\treduc_def);\n-      new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, expr);\n+      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, expr);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n                                                                                 \n       if (j == 0)\n@@ -1632,13 +1639,13 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum vect_def_type dt;\n \n   /* Is STMT a vectorizable call?   */\n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n     return false;\n \n-  operation = TREE_OPERAND (stmt, 1);\n+  operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (TREE_CODE (operation) != CALL_EXPR)\n     return false;\n    \n@@ -1679,7 +1686,7 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     fprintf (vect_dump, \"transform operation.\");\n \n   /* Handle def.  */\n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n   /* Handle uses.  */\n@@ -1696,9 +1703,9 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   fndecl = get_callee_fndecl (operation);\n   rhs = build_vectorized_function_call (fndecl, vectype, vargs);\n-  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, rhs);\n+  *vec_stmt = build2 (GIMPLE_MODIFY_STMT, vectype, vec_dest, rhs);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);\n-  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n+  GIMPLE_STMT_OPERAND (*vec_stmt, 0) = new_temp;\n \n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n \n@@ -1746,14 +1753,14 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   if (TREE_CODE (scalar_dest) != SSA_NAME)\n     return false;\n \n-  op = TREE_OPERAND (stmt, 1);\n+  op = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1775,13 +1782,13 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n   /* Handle use.  */\n-  op = TREE_OPERAND (stmt, 1);\n+  op = GIMPLE_STMT_OPERAND (stmt, 1);\n   vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n \n   /* Arguments are ready. create the new vector stmt.  */\n-  *vec_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, vec_oprnd);\n+  *vec_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, vec_oprnd);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);\n-  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n+  GIMPLE_STMT_OPERAND (*vec_stmt, 0) = new_temp;\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n   \n   return true;\n@@ -1866,19 +1873,19 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n     return false;\n \n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   vectype_out = get_vectype_for_scalar_type (TREE_TYPE (scalar_dest));\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (nunits_out != nunits_in)\n     return false;\n \n-  operation = TREE_OPERAND (stmt, 1);\n+  operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n   optab = optab_for_tree_code (code, vectype);\n \n@@ -2064,13 +2071,13 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       /* Arguments are ready. create the new vector stmt.  */\n                                                                                 \n       if (op_type == binary_op)\n-        new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n+        new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n                     build2 (code, vectype, vec_oprnd0, vec_oprnd1));\n       else\n-        new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest,\n+        new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n                     build1 (code, vectype, vec_oprnd0));\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n                                                                                 \n       if (j == 0)\n@@ -2135,13 +2142,13 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n       return false;\n     }\n                                                                                 \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n                                                                                 \n-  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n     return false;\n                                                                                 \n-  operation = TREE_OPERAND (stmt, 1);\n+  operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n   if (code != NOP_EXPR && code != CONVERT_EXPR)\n     return false;\n@@ -2150,7 +2157,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n   vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op0));\n   nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n                                                                                 \n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   scalar_type = TREE_TYPE (scalar_dest);\n   vectype_out = get_vectype_for_scalar_type (scalar_type);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n@@ -2217,9 +2224,9 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n                                                                                 \n       /* Arguments are ready. Create the new vector stmt.  */\n       expr = build2 (code, vectype_out, vec_oprnd0, vec_oprnd1);\n-      new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, expr);\n+      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, expr);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n                                                                                 \n       if (j == 0)\n@@ -2275,9 +2282,9 @@ vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n       else  \n         expr = build1 (code, vectype, vec_oprnd0); \n     } \n-  new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, expr);\n+  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, expr);\n   new_temp = make_ssa_name (vec_dest, new_stmt); \n-  TREE_OPERAND (new_stmt, 0) = new_temp; \n+  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp; \n   vect_finish_stmt_generation (stmt, new_stmt, bsi); \n \n   if (code == CALL_EXPR)\n@@ -2342,13 +2349,13 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n       return false;\n     }\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n     return false;\n \n-  operation = TREE_OPERAND (stmt, 1);\n+  operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n   if (code != NOP_EXPR && code != WIDEN_MULT_EXPR)\n     return false;\n@@ -2359,7 +2366,7 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n   gcc_assert (ncopies >= 1);\n \n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   vectype_out = get_vectype_for_scalar_type (TREE_TYPE (scalar_dest));\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (nunits_out != nunits_in / 2) /* FORNOW */\n@@ -2588,22 +2595,22 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t  /* high = interleave_high (vect1, vect2);  */\n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_high\");\n \t  add_referenced_var (perm_dest);\n-\t  perm_stmt = build2 (MODIFY_EXPR, void_type_node, perm_dest,\n+\t  perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n \t\t\t      build2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, vect1, \n \t\t\t\t      vect2));\n \t  high = make_ssa_name (perm_dest, perm_stmt);\n-\t  TREE_OPERAND (perm_stmt, 0) = high;\n+\t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = high;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n \t  VEC_replace (tree, *result_chain, 2*j, high);\n \n \t  /* low = interleave_low (vect1, vect2);  */\n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_low\");\n \t  add_referenced_var (perm_dest);\n-\t  perm_stmt = build2 (MODIFY_EXPR, void_type_node, perm_dest,\n+\t  perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n \t\t\t      build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, vect1, \n \t\t\t\t      vect2));\n \t  low = make_ssa_name (perm_dest, perm_stmt);\n-\t  TREE_OPERAND (perm_stmt, 0) = low;\n+\t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = low;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n \t  VEC_replace (tree, *result_chain, 2*j+1, low);\n \t}\n@@ -2652,16 +2659,16 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /* Is vectorizable store? */\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   if (TREE_CODE (scalar_dest) != ARRAY_REF\n       && TREE_CODE (scalar_dest) != INDIRECT_REF\n       && !DR_GROUP_FIRST_DR (stmt_info))\n     return false;\n \n-  op = TREE_OPERAND (stmt, 1);\n+  op = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2791,7 +2798,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t\t executed.\n \t      */\n \t      gcc_assert (next_stmt);\n-\t      op = TREE_OPERAND (next_stmt, 1);\n+\t      op = GIMPLE_STMT_OPERAND (next_stmt, 1);\n \t      vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt, NULL);\n \t      VEC_quick_push(tree, dr_chain, vec_oprnd); \n \t      VEC_quick_push(tree, oprnds, vec_oprnd); \n@@ -2840,7 +2847,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n \t  data_ref = build_fold_indirect_ref (dataref_ptr);\n \t  /* Arguments are ready. Create the new vector stmt.  */\n-\t  new_stmt = build2 (MODIFY_EXPR, void_type_node, data_ref, \n+\t  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, data_ref, \n \t\t\t     vec_oprnd);\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \n@@ -2952,12 +2959,12 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n   ptr = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &init_addr, &inc, true,\n \t\t\t\t  NULL_TREE);\n   data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n-  new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, data_ref);\n+  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest, data_ref);\n   new_temp = make_ssa_name (vec_dest, new_stmt);\n-  TREE_OPERAND (new_stmt, 0) = new_temp;\n+  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n   new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n   gcc_assert (!new_bb);\n-  msq_init = TREE_OPERAND (new_stmt, 0);\n+  msq_init = GIMPLE_STMT_OPERAND (new_stmt, 0);\n   copy_virtual_operands (new_stmt, stmt);\n   update_vuses_to_preheader (new_stmt, loop);\n \n@@ -2971,12 +2978,13 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n       new_stmt = build_function_call_expr (builtin_decl, params);\n       vec_dest = vect_create_destination_var (scalar_dest, \n \t\t\t\t\t      TREE_TYPE (new_stmt));\n-      new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, new_stmt);\n+      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n+\t  \t\t new_stmt);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n       gcc_assert (!new_bb);\n-      *realignment_token = TREE_OPERAND (new_stmt, 0);\n+      *realignment_token = GIMPLE_STMT_OPERAND (new_stmt, 0);\n \n       /* The result of the CALL_EXPR to this builtin is determined from\n          the value of the parameter and no global variables are touched\n@@ -3147,12 +3155,12 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  perm_dest = create_tmp_var (vectype, \"vect_perm_even\");\n \t  add_referenced_var (perm_dest);\n \t \n-\t  perm_stmt = build2 (MODIFY_EXPR, void_type_node, perm_dest,\n+\t  perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n \t\t\t      build2 (VEC_EXTRACT_EVEN_EXPR, vectype, \n \t\t\t\t      first_vect, second_vect));\n \n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n-\t  TREE_OPERAND (perm_stmt, 0) = data_ref;\n+\t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = data_ref;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n \t  mark_new_vars_to_rename (perm_stmt);\n \n@@ -3162,11 +3170,11 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  perm_dest = create_tmp_var (vectype, \"vect_perm_odd\");\n \t  add_referenced_var (perm_dest);\n \n-\t  perm_stmt = build2 (MODIFY_EXPR, void_type_node, perm_dest,\n+\t  perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n \t\t\t      build2 (VEC_EXTRACT_ODD_EXPR, vectype, \n \t\t\t\t      first_vect, second_vect));\n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n-\t  TREE_OPERAND (perm_stmt, 0) = data_ref;\n+\t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = data_ref;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n \t  mark_new_vars_to_rename (perm_stmt);\n \n@@ -3312,14 +3320,14 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   if (TREE_CODE (scalar_dest) != SSA_NAME)\n     return false;\n \n-  op = TREE_OPERAND (stmt, 1);\n+  op = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (TREE_CODE (op) != ARRAY_REF \n       && TREE_CODE (op) != INDIRECT_REF\n       && !DR_GROUP_FIRST_DR (stmt_info))\n@@ -3526,9 +3534,10 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t      gcc_unreachable ();\n \t    }\n \t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-\t  new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, data_ref);\n+\t  new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n+\t      \t\t     data_ref);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t  TREE_OPERAND (new_stmt, 0) = new_temp;\n+\t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \t  copy_virtual_operands (new_stmt, stmt);\n \t  mark_new_vars_to_rename (new_stmt);\n@@ -3538,15 +3547,16 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t    {\n \t      /* Create in loop: \n \t\t <vec_dest = realign_load (msq, lsq, realignment_token)>  */\n-\t      lsq = TREE_OPERAND (new_stmt, 0);\n+\t      lsq = GIMPLE_STMT_OPERAND (new_stmt, 0);\n \t      if (!realignment_token)\n \t\trealignment_token = dataref_ptr;\n \t      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \t      new_stmt =\n \t\tbuild3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, realignment_token);\n-\t      new_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, new_stmt);\n+\t      new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n+\t\t  \t\t new_stmt);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t      TREE_OPERAND (new_stmt, 0) = new_temp;\n+\t      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n \t      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \t      if (i == group_size - 1 && j == ncopies - 1)\n \t\tadd_phi_arg (phi_stmt, lsq, loop_latch_edge (loop));\n@@ -3602,13 +3612,13 @@ vectorizable_live_operation (tree stmt,\n   if (!STMT_VINFO_LIVE_P (stmt_info))\n     return false;\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  if (TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n     return false;\n \n-  operation = TREE_OPERAND (stmt, 1);\n+  operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n \n   op_type = TREE_CODE_LENGTH (code);\n@@ -3724,10 +3734,10 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n-  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n-  op = TREE_OPERAND (stmt, 1);\n+  op = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   if (TREE_CODE (op) != COND_EXPR)\n     return false;\n@@ -3778,7 +3788,7 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   /* Transform */\n \n   /* Handle def.  */\n-  scalar_dest = TREE_OPERAND (stmt, 0);\n+  scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n   /* Handle cond expr.  */\n@@ -3795,9 +3805,10 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_cond_expr = build3 (VEC_COND_EXPR, vectype, \n \t\t\t  vec_compare, vec_then_clause, vec_else_clause);\n \n-  *vec_stmt = build2 (MODIFY_EXPR, void_type_node, vec_dest, vec_cond_expr);\n+  *vec_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n+      \t\t      vec_cond_expr);\n   new_temp = make_ssa_name (vec_dest, *vec_stmt);\n-  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n+  GIMPLE_STMT_OPERAND (*vec_stmt, 0) = new_temp;\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n   \n   return true;\n@@ -4574,7 +4585,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n       add_referenced_var (addr_tmp);\n       addr_tmp_name = make_ssa_name (addr_tmp, NULL_TREE);\n       addr_stmt = fold_convert (int_ptrsize_type, addr_base);\n-      addr_stmt = build2 (MODIFY_EXPR, void_type_node,\n+      addr_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n                           addr_tmp_name, addr_stmt);\n       SSA_NAME_DEF_STMT (addr_tmp_name) = addr_stmt;\n       append_to_statement_list_force (addr_stmt, cond_expr_stmt_list);\n@@ -4588,7 +4599,8 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n           or_tmp = create_tmp_var (int_ptrsize_type, tmp_name);\n           add_referenced_var (or_tmp);\n           new_or_tmp_name = make_ssa_name (or_tmp, NULL_TREE);\n-          or_stmt = build2 (MODIFY_EXPR, void_type_node, new_or_tmp_name,\n+          or_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t      \t\t    new_or_tmp_name,\n                             build2 (BIT_IOR_EXPR, int_ptrsize_type,\n \t                            or_tmp_name,\n                                     addr_tmp_name));\n@@ -4608,7 +4620,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   add_referenced_var (and_tmp);\n   and_tmp_name = make_ssa_name (and_tmp, NULL_TREE);\n \n-  and_stmt = build2 (MODIFY_EXPR, void_type_node,\n+  and_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n                      and_tmp_name,\n                      build2 (BIT_AND_EXPR, int_ptrsize_type,\n                              or_tmp_name, mask_cst));"}, {"sha": "9974343dce7fd235304129b50f6e7dbeda3ac222", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1233,7 +1233,7 @@ find_loop_location (struct loop *loop)\n \n   node = get_loop_exit_condition (loop);\n \n-  if (node && EXPR_P (node) && EXPR_HAS_LOCATION (node)\n+  if (node && CAN_HAVE_LOCATION_P (node) && EXPR_HAS_LOCATION (node)\n       && EXPR_FILENAME (node) && EXPR_LINENO (node))\n     return EXPR_LOC (node);\n \n@@ -1248,7 +1248,7 @@ find_loop_location (struct loop *loop)\n   for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n     {\n       node = bsi_stmt (si);\n-      if (node && EXPR_P (node) && EXPR_HAS_LOCATION (node))\n+      if (node && CAN_HAVE_LOCATION_P (node) && EXPR_HAS_LOCATION (node))\n         return EXPR_LOC (node);\n     }\n \n@@ -1681,7 +1681,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n     }\n \n   /* empty stmt is expected only in case of a function argument.\n-     (Otherwise - we expect a phi_node or a modify_expr).  */\n+     (Otherwise - we expect a phi_node or a GIMPLE_MODIFY_STMT).  */\n   if (IS_EMPTY_STMT (*def_stmt))\n     {\n       tree arg = TREE_OPERAND (*def_stmt, 0);\n@@ -1733,8 +1733,8 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n                   || *dt == vect_invariant_def);\n       break;\n \n-    case MODIFY_EXPR:\n-      *def = TREE_OPERAND (*def_stmt, 0);\n+    case GIMPLE_MODIFY_STMT:\n+      *def = GIMPLE_STMT_OPERAND (*def_stmt, 0);\n       gcc_assert (*dt == vect_loop_def || *dt == vect_invariant_def);\n       break;\n \n@@ -1783,7 +1783,7 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n   enum machine_mode vec_mode;\n   enum insn_code icode1, icode2;\n   optab optab1, optab2;\n-  tree expr = TREE_OPERAND (stmt, 1);\n+  tree expr = GIMPLE_STMT_OPERAND (stmt, 1);\n   tree type = TREE_TYPE (expr);\n   tree wide_vectype = get_vectype_for_scalar_type (type);\n   enum tree_code c1, c2;\n@@ -1960,7 +1960,7 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n       return NULL_TREE;\n     }\n \n-  if (TREE_CODE (def_stmt) != MODIFY_EXPR)\n+  if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n@@ -1969,7 +1969,7 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n       return NULL_TREE;\n     }\n \n-  operation = TREE_OPERAND (def_stmt, 1);\n+  operation = GIMPLE_STMT_OPERAND (def_stmt, 1);\n   code = TREE_CODE (operation);\n   if (!commutative_tree_code (code) || !associative_tree_code (code))\n     {\n@@ -2059,7 +2059,7 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n       return NULL_TREE;\n     }\n \n-  if (TREE_CODE (def1) == MODIFY_EXPR\n+  if (TREE_CODE (def1) == GIMPLE_MODIFY_STMT\n       && flow_bb_inside_loop_p (loop, bb_for_stmt (def1))\n       && def2 == phi)\n     {\n@@ -2070,7 +2070,7 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n         }\n       return def_stmt;\n     }\n-  else if (TREE_CODE (def2) == MODIFY_EXPR\n+  else if (TREE_CODE (def2) == GIMPLE_MODIFY_STMT\n       && flow_bb_inside_loop_p (loop, bb_for_stmt (def2))\n       && def1 == phi)\n     {"}, {"sha": "aceacc5ebcb987fec507bbac5965c2ca6e30ef4c", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -85,8 +85,8 @@ vn_compute (tree expr, hashval_t val)\n   /* EXPR must not be a statement.  We are only interested in value\n      numbering expressions on the RHS of assignments.  */\n   gcc_assert (expr);\n-  gcc_assert (!expr->common.ann\n-\t      || expr->common.ann->common.type != STMT_ANN);\n+  gcc_assert (!expr->base.ann\n+\t      || expr->base.ann->common.type != STMT_ANN);\n \n   val = iterative_hash_expr (expr, val);\n   return val;\n@@ -181,6 +181,7 @@ set_value_handle (tree e, tree v)\n   if (TREE_CODE (e) == SSA_NAME)\n     SSA_NAME_VALUE (e) = v;\n   else if (EXPR_P (e) || DECL_P (e) || TREE_CODE (e) == TREE_LIST\n+\t   || GIMPLE_STMT_P (e)\n \t   || TREE_CODE (e) == CONSTRUCTOR)\n     get_tree_common_ann (e)->value_handle = v;\n   else"}, {"sha": "759bf7518e08285d4ed3755c6b06a4773830f499", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -2399,20 +2399,22 @@ build_assert_expr_for (tree cond, tree v)\n   if (COMPARISON_CLASS_P (cond))\n     {\n       tree a = build2 (ASSERT_EXPR, TREE_TYPE (v), v, cond); \n-      assertion = build2 (MODIFY_EXPR, TREE_TYPE (v), n, a);\n+      assertion = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (v), n, a);\n     }\n   else if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n     {\n       /* Given !V, build the assignment N = false.  */\n       tree op0 = TREE_OPERAND (cond, 0);\n       gcc_assert (op0 == v);\n-      assertion = build2 (MODIFY_EXPR, TREE_TYPE (v), n, boolean_false_node);\n+      assertion = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (v), n,\n+\t\t\t  boolean_false_node);\n     }\n   else if (TREE_CODE (cond) == SSA_NAME)\n     {\n       /* Given V, build the assignment N = true.  */\n       gcc_assert (v == cond);\n-      assertion = build2 (MODIFY_EXPR, TREE_TYPE (v), n, boolean_true_node);\n+      assertion = build2 (GIMPLE_MODIFY_STMT,\n+\t  \t\t  TREE_TYPE (v), n, boolean_true_node);\n     }\n   else\n     gcc_unreachable ();\n@@ -2797,10 +2799,10 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n      a truth operation or some bit operations, then we may be able\n      to register information about the operands of that assignment.  */\n   op_def = SSA_NAME_DEF_STMT (op);\n-  if (TREE_CODE (op_def) != MODIFY_EXPR)\n+  if (TREE_CODE (op_def) != GIMPLE_MODIFY_STMT)\n     return retval;\n \n-  rhs = TREE_OPERAND (op_def, 1);\n+  rhs = GIMPLE_STMT_OPERAND (op_def, 1);\n \n   if (COMPARISON_CLASS_P (rhs))\n     {\n@@ -2908,12 +2910,12 @@ register_edge_assert_for (tree name, edge e, block_stmt_iterator si, tree cond)\n     {\n       tree def_stmt = SSA_NAME_DEF_STMT (name);\n \n-      if (TREE_CODE (def_stmt) == MODIFY_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (def_stmt, 1)) == TRUTH_AND_EXPR\n-\t      || TREE_CODE (TREE_OPERAND (def_stmt, 1)) == BIT_AND_EXPR))\n+      if (TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n+\t  && (TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == TRUTH_AND_EXPR\n+\t      || TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == BIT_AND_EXPR))\n \t{\n-\t  tree op0 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n-\t  tree op1 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 1);\n+\t  tree op0 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n+\t  tree op1 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 1);\n \t  retval |= register_edge_assert_for_1 (op0, NE_EXPR, e, si);\n \t  retval |= register_edge_assert_for_1 (op1, NE_EXPR, e, si);\n \t}\n@@ -2927,12 +2929,12 @@ register_edge_assert_for (tree name, edge e, block_stmt_iterator si, tree cond)\n     {\n       tree def_stmt = SSA_NAME_DEF_STMT (name);\n \n-      if (TREE_CODE (def_stmt) == MODIFY_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (def_stmt, 1)) == TRUTH_OR_EXPR\n-\t      || TREE_CODE (TREE_OPERAND (def_stmt, 1)) == BIT_IOR_EXPR))\n+      if (TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n+\t  && (TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == TRUTH_OR_EXPR\n+\t      || TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == BIT_IOR_EXPR))\n \t{\n-\t  tree op0 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n-\t  tree op1 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 1);\n+\t  tree op0 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n+\t  tree op1 = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 1);\n \t  retval |= register_edge_assert_for_1 (op0, EQ_EXPR, e, si);\n \t  retval |= register_edge_assert_for_1 (op1, EQ_EXPR, e, si);\n \t}\n@@ -3156,12 +3158,18 @@ find_assert_locations (basic_block bb)\n \t\t  tree t = op;\n \t\t  tree def_stmt = SSA_NAME_DEF_STMT (t);\n \t\n-\t\t  while (TREE_CODE (def_stmt) == MODIFY_EXPR\n-\t\t\t && TREE_CODE (TREE_OPERAND (def_stmt, 1)) == NOP_EXPR\n-\t\t\t && TREE_CODE (TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0)) == SSA_NAME\n-\t\t\t && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0))))\n+\t\t  while (TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n+\t\t\t && TREE_CODE\n+\t\t\t     (GIMPLE_STMT_OPERAND (def_stmt, 1)) == NOP_EXPR\n+\t\t\t && TREE_CODE\n+\t\t\t     (TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1),\n+\t\t\t\t\t    0)) == SSA_NAME\n+\t\t\t && POINTER_TYPE_P\n+\t\t\t     (TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t  (GIMPLE_STMT_OPERAND (def_stmt,\n+\t\t\t\t\t\t\t\t1), 0))))\n \t\t    {\n-\t\t      t = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n+\t\t      t = TREE_OPERAND (GIMPLE_STMT_OPERAND (def_stmt, 1), 0);\n \t\t      def_stmt = SSA_NAME_DEF_STMT (t);\n \n \t\t      /* Note we want to register the assert for the\n@@ -3412,10 +3420,10 @@ remove_range_assertions (void)\n \ttree stmt = bsi_stmt (si);\n \ttree use_stmt;\n \n-\tif (TREE_CODE (stmt) == MODIFY_EXPR\n-\t    && TREE_CODE (TREE_OPERAND (stmt, 1)) == ASSERT_EXPR)\n+\tif (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ASSERT_EXPR)\n \t  {\n-\t    tree rhs = TREE_OPERAND (stmt, 1), var;\n+\t    tree rhs = GIMPLE_STMT_OPERAND (stmt, 1), var;\n \t    tree cond = fold (ASSERT_EXPR_COND (rhs));\n \t    use_operand_p use_p;\n \t    imm_use_iterator iter;\n@@ -3424,7 +3432,8 @@ remove_range_assertions (void)\n \n \t    /* Propagate the RHS into every use of the LHS.  */\n \t    var = ASSERT_EXPR_VAR (rhs);\n-\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, TREE_OPERAND (stmt, 0))\n+\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter,\n+\t\t\t\t   GIMPLE_STMT_OPERAND (stmt, 0))\n \t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n \t\t{\n \t\t  SET_USE (use_p, var);\n@@ -3452,10 +3461,10 @@ stmt_interesting_for_vrp (tree stmt)\n       && (INTEGRAL_TYPE_P (TREE_TYPE (PHI_RESULT (stmt)))\n \t  || POINTER_TYPE_P (TREE_TYPE (PHI_RESULT (stmt)))))\n     return true;\n-  else if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      tree lhs = TREE_OPERAND (stmt, 0);\n-      tree rhs = TREE_OPERAND (stmt, 1);\n+      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n       /* In general, assignments with virtual operands are not useful\n \t for deriving ranges, with the obvious exception of calls to\n@@ -3533,8 +3542,8 @@ vrp_visit_assignment (tree stmt, tree *output_p)\n   tree lhs, rhs, def;\n   ssa_op_iter iter;\n \n-  lhs = TREE_OPERAND (stmt, 0);\n-  rhs = TREE_OPERAND (stmt, 1);\n+  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   /* We only keep track of ranges in integral and pointer types.  */\n   if (TREE_CODE (lhs) == SSA_NAME\n@@ -3951,9 +3960,9 @@ vrp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n     }\n \n   ann = stmt_ann (stmt);\n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      tree rhs = TREE_OPERAND (stmt, 1);\n+      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n       /* In general, assignments with virtual operands are not useful\n \t for deriving ranges, with the obvious exception of calls to\n@@ -4267,7 +4276,7 @@ simplify_div_or_mod_using_ranges (tree stmt, tree rhs, enum tree_code rhs_code)\n \t  t = build2 (BIT_AND_EXPR, TREE_TYPE (op0), op0, t);\n \t}\n \n-      TREE_OPERAND (stmt, 1) = t;\n+      GIMPLE_STMT_OPERAND (stmt, 1) = t;\n       update_stmt (stmt);\n     }\n }\n@@ -4314,7 +4323,7 @@ simplify_abs_using_ranges (tree stmt, tree rhs)\n \t  else\n \t    t = op;\n \n-\t  TREE_OPERAND (stmt, 1) = t;\n+\t  GIMPLE_STMT_OPERAND (stmt, 1) = t;\n \t  update_stmt (stmt);\n \t}\n     }\n@@ -4464,9 +4473,9 @@ simplify_cond_using_ranges (tree stmt)\n void\n simplify_stmt_using_ranges (tree stmt)\n {\n-  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      tree rhs = TREE_OPERAND (stmt, 1);\n+      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n       enum tree_code rhs_code = TREE_CODE (rhs);\n \n       /* Transform TRUNC_DIV_EXPR and TRUNC_MOD_EXPR into RSHIFT_EXPR"}, {"sha": "68aa58f9619e4533eb7468093feac4c8c51faf3c", "filename": "gcc/tree.c", "status": "modified", "additions": 233, "deletions": 8, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -98,7 +98,8 @@ static const char * const tree_node_kind_names[] = {\n   \"random kinds\",\n   \"lang_decl kinds\",\n   \"lang_type kinds\",\n-  \"omp clauses\"\n+  \"omp clauses\",\n+  \"gimple statements\"\n };\n #endif /* GATHER_STATISTICS */\n \n@@ -356,6 +357,10 @@ tree_code_size (enum tree_code code)\n       return (sizeof (struct tree_exp)\n \t      + (TREE_CODE_LENGTH (code) - 1) * sizeof (char *));\n \n+    case tcc_gimple_stmt:\n+      return (sizeof (struct gimple_stmt)\n+\t      + (TREE_CODE_LENGTH (code) - 1) * sizeof (char *));\n+\n     case tcc_constant:  /* a constant */\n       switch (code)\n \t{\n@@ -476,6 +481,10 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       kind = c_kind;\n       break;\n \n+    case tcc_gimple_stmt:\n+      kind = gimple_stmt_kind;\n+      break;\n+\n     case tcc_exceptional:  /* something random, like an identifier.  */\n       switch (code)\n \t{\n@@ -591,6 +600,17 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \t}\n       break;\n \n+    case tcc_gimple_stmt:\n+      switch (code)\n+\t{\n+      case GIMPLE_MODIFY_STMT:\n+\tTREE_SIDE_EFFECTS (t) = 1;\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+\t}\n+\n     default:\n       /* Other classes need no special treatment.  */\n       break;\n@@ -615,10 +635,11 @@ copy_node_stat (tree node MEM_STAT_DECL)\n   t = ggc_alloc_zone_pass_stat (length, &tree_zone);\n   memcpy (t, node, length);\n \n-  TREE_CHAIN (t) = 0;\n+  if (!GIMPLE_TUPLE_P (node))\n+    TREE_CHAIN (t) = 0;\n   TREE_ASM_WRITTEN (t) = 0;\n   TREE_VISITED (t) = 0;\n-  t->common.ann = 0;\n+  t->base.ann = 0;\n \n   if (TREE_CODE_CLASS (code) == tcc_declaration)\n     {\n@@ -1872,7 +1893,14 @@ expr_align (tree t)\n       align1 = TYPE_ALIGN (TREE_TYPE (t));\n       return MAX (align0, align1);\n \n-    case SAVE_EXPR:         case COMPOUND_EXPR:       case MODIFY_EXPR:\n+    case MODIFY_EXPR:\n+      /* FIXME tuples: It is unclear to me if this function, which\n+         is only called from ADA, is called on gimple or non gimple\n+         trees.  Let's assume it's from gimple trees unless we hit\n+         this abort.  */\n+      gcc_unreachable ();\n+\n+    case SAVE_EXPR:         case COMPOUND_EXPR:       case GIMPLE_MODIFY_STMT:\n     case INIT_EXPR:         case TARGET_EXPR:         case WITH_CLEANUP_EXPR:\n     case CLEANUP_POINT_EXPR:\n       /* These don't change the alignment of an object.  */\n@@ -2141,6 +2169,8 @@ tree_node_structure (tree t)\n     case tcc_expression:\n     case tcc_statement:\n       return TS_EXP;\n+    case tcc_gimple_stmt:\n+      return TS_GIMPLE_STATEMENT;\n     default:  /* tcc_constant and tcc_exceptional */\n       break;\n     }\n@@ -2153,6 +2183,8 @@ tree_node_structure (tree t)\n     case VECTOR_CST:\t\treturn TS_VECTOR;\n     case STRING_CST:\t\treturn TS_STRING;\n       /* tcc_exceptional cases.  */\n+    /* FIXME tuples: eventually this should be TS_BASE.  For now, nothing\n+       returns TS_BASE.  */\n     case ERROR_MARK:\t\treturn TS_COMMON;\n     case IDENTIFIER_NODE:\treturn TS_IDENTIFIER;\n     case TREE_LIST:\t\treturn TS_LIST;\n@@ -2967,6 +2999,17 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n \n   gcc_assert (TREE_CODE_LENGTH (code) == 2);\n \n+  if (code == MODIFY_EXPR && cfun && cfun->gimplified)\n+    {\n+      /* We should be talking GIMPLE_MODIFY_STMT by now.  */\n+      gcc_unreachable ();\n+    }\n+\n+  /* FIXME tuples: For now let's be lazy; later we must rewrite all\n+     build2 calls to build2_gimple calls.  */\n+  if (TREE_CODE_CLASS (code) == tcc_gimple_stmt)\n+    return build2_gimple (code, arg0, arg1);\n+\n   t = make_node_stat (code PASS_MEM_STAT);\n   TREE_TYPE (t) = tt;\n \n@@ -2997,6 +3040,35 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n   return t;\n }\n \n+\n+/* Similar as build2_stat, but for GIMPLE tuples.  For convenience's sake,\n+   arguments and return type are trees.  */\n+\n+tree\n+build2_gimple_stat (enum tree_code code, tree arg0, tree arg1 MEM_STAT_DECL)\n+{\n+  bool side_effects;\n+  tree t;\n+\n+  gcc_assert (TREE_CODE_LENGTH (code) == 2);\n+\n+  t = make_node_stat (code PASS_MEM_STAT);\n+\n+  side_effects = TREE_SIDE_EFFECTS (t);\n+\n+  /* ?? We don't care about setting flags for tuples...  */\n+  GIMPLE_STMT_OPERAND (t, 0) = arg0;\n+  GIMPLE_STMT_OPERAND (t, 1) = arg1;\n+\n+  /* ...except perhaps side_effects and volatility.  ?? */\n+  TREE_SIDE_EFFECTS (t) = side_effects;\n+  TREE_THIS_VOLATILE (t) = (TREE_CODE_CLASS (code) == tcc_reference\n+\t             \t    && arg0 && TREE_THIS_VOLATILE (arg0));\n+\n+\n+  return t;\n+}\n+\n tree\n build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n \t     tree arg2 MEM_STAT_DECL)\n@@ -3286,6 +3358,130 @@ annotate_with_locus (tree node, location_t locus)\n }\n #endif\n \f\n+/* Source location accessor functions.  */\n+\n+\n+/* The source location of this expression.  Non-tree_exp nodes such as\n+   decls and constants can be shared among multiple locations, so\n+   return nothing.  */\n+location_t\n+expr_location (tree node)\n+{\n+#ifdef USE_MAPPED_LOCATION\n+  if (GIMPLE_STMT_P (node))\n+    return GIMPLE_STMT_LOCUS (node);\n+  return EXPR_P (node) ? node->exp.locus : UNKNOWN_LOCATION;\n+#else\n+  if (GIMPLE_STMT_P (node))\n+    return EXPR_HAS_LOCATION (node)\n+      ? *GIMPLE_STMT_LOCUS (node) : UNKNOWN_LOCATION;\n+  return EXPR_HAS_LOCATION (node) ? *node->exp.locus : UNKNOWN_LOCATION;\n+#endif\n+}\n+\n+void\n+set_expr_location (tree node, location_t locus)\n+{\n+#ifdef USE_MAPPED_LOCATION\n+  if (GIMPLE_STMT_P (node))\n+    GIMPLE_STMT_LOCUS (node) = locus;\n+  else\n+    EXPR_CHECK (node)->exp.locus = locus;\n+#else\n+      annotate_with_locus (node, locus);\n+#endif\n+}\n+\n+bool\n+expr_has_location (tree node)\n+{\n+#ifdef USE_MAPPED_LOCATION\n+  return expr_location (node) != UNKNOWN_LOCATION;\n+#else\n+  return expr_locus (node) != NULL;\n+#endif\n+}\n+\n+#ifdef USE_MAPPED_LOCATION\n+source_location *\n+#else\n+source_locus\n+#endif\n+expr_locus (tree node)\n+{\n+#ifdef USE_MAPPED_LOCATION\n+  if (GIMPLE_STMT_P (node))\n+    return &GIMPLE_STMT_LOCUS (node);\n+  return EXPR_P (node) ? &node->exp.locus : (location_t *) NULL;\n+#else\n+  if (GIMPLE_STMT_P (node))\n+    return GIMPLE_STMT_LOCUS (node);\n+  /* ?? The cast below was originally \"(location_t *)\" in the macro,\n+     but that makes no sense.  ?? */\n+  return EXPR_P (node) ? node->exp.locus : (source_locus) NULL;\n+#endif\n+}\n+\n+void\n+set_expr_locus (tree node,\n+#ifdef USE_MAPPED_LOCATION\n+\t\tsource_location *loc\n+#else\n+\t\tsource_locus loc\n+#endif\n+\t\t)\n+{\n+#ifdef USE_MAPPED_LOCATION\n+  if (loc == NULL)\n+    {\n+      if (GIMPLE_STMT_P (node))\n+\tGIMPLE_STMT_LOCUS (node) = UNKNOWN_LOCATION;\n+      else\n+\tEXPR_CHECK (node)->exp.locus = UNKNOWN_LOCATION;\n+    }\n+  else\n+    {\n+      if (GIMPLE_STMT_P (node))\n+\tGIMPLE_STMT_LOCUS (node) = *loc;\n+      else\n+\tEXPR_CHECK (node)->exp.locus = *loc;\n+    }\n+#else\n+  if (GIMPLE_STMT_P (node))\n+    GIMPLE_STMT_LOCUS (node) = loc;\n+  else\n+    EXPR_CHECK (node)->exp.locus = loc;\n+#endif\n+}\n+\n+const char **\n+expr_filename (tree node)\n+{\n+#ifdef USE_MAPPED_LOCATION\n+  if (GIMPLE_STMT_P (node))\n+    return &LOCATION_FILE (GIMPLE_STMT_LOCUS (node));\n+  return &LOCATION_FILE (EXPR_CHECK (node)->exp.locus);\n+#else\n+  if (GIMPLE_STMT_P (node))\n+    return &GIMPLE_STMT_LOCUS (node)->file;\n+  return &(EXPR_CHECK (node)->exp.locus->file);\n+#endif\n+}\n+\n+int *\n+expr_lineno (tree node)\n+{\n+#ifdef USE_MAPPED_LOCATION\n+  if (GIMPLE_STMT_P (node))\n+    return &LOCATION_LINE (GIMPLE_STMT_LOCUS (node));\n+  return &LOCATION_LINE (EXPR_CHECK (node)->exp.locus);\n+#else\n+  if (GIMPLE_STMT_P (node))\n+    return &GIMPLE_STMT_LOCUS (node)->line;\n+  return &EXPR_CHECK (node)->exp.locus->line;\n+#endif\n+}\n+\f\n /* Return a declaration like DDECL except that its DECL_ATTRIBUTES\n    is ATTRIBUTE.  */\n \n@@ -7709,7 +7905,8 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n       /* FALLTHRU */\n \n     default:\n-      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n+      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n+\t  || IS_GIMPLE_STMT_CODE_CLASS (TREE_CODE_CLASS (code)))\n \t{\n \t  int i, len;\n \n@@ -7721,11 +7918,10 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n \t  if (len)\n \t    {\n \t      for (i = 0; i < len - 1; ++i)\n-\t\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n-\t      WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, len - 1));\n+\t\tWALK_SUBTREE (GENERIC_TREE_OPERAND (*tp, i));\n+\t      WALK_SUBTREE_TAIL (GENERIC_TREE_OPERAND (*tp, len - 1));\n \t    }\n \t}\n-\n       /* If this is a type, walk the needed fields in the type.  */\n       else if (TYPE_P (*tp))\n \treturn walk_type_fields (*tp, func, data, pset);\n@@ -7779,4 +7975,33 @@ empty_body_p (tree stmt)\n   return true;\n }\n \n+tree *\n+tree_block (tree t)\n+{\n+  char const c = TREE_CODE_CLASS (TREE_CODE (t));\n+\n+  if (IS_EXPR_CODE_CLASS (c))\n+    return &t->exp.block;\n+  else if (IS_GIMPLE_STMT_CODE_CLASS (c))\n+    return &GIMPLE_STMT_BLOCK (t);\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+tree *\n+generic_tree_operand (tree node, int i)\n+{\n+  if (GIMPLE_STMT_P (node))\n+    return &GIMPLE_STMT_OPERAND (node, i);\n+  return &TREE_OPERAND (node, i);\n+}\n+\n+tree *\n+generic_tree_type (tree node)\n+{\n+  if (GIMPLE_STMT_P (node))\n+    return &void_type_node;\n+  return &TREE_TYPE (node);\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "c53d9be5a892870614428552b971280663583710", "filename": "gcc/tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -1065,6 +1065,11 @@ DEFTREECODE (WIDEN_MULT_EXPR, \"widen_mult_expr\", tcc_binary, 2)\n    Operand 1 is an integer shift amount in bits.  */\n DEFTREECODE (VEC_LSHIFT_EXPR, \"vec_lshift_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_RSHIFT_EXPR, \"vec_rshift_expr\", tcc_binary, 2)\n+\f\n+/* GIMPLE tree codes.  */\n+\n+/* Assignment expression.  Operand 0 is the what to set; 1, the new value.  */\n+DEFTREECODE (GIMPLE_MODIFY_STMT, \"gimple_modify_stmt\", tcc_gimple_stmt, 2)\n \n /* Widening vector multiplication.\n    The two operands are vectors with N elements of size S. Multiplying the"}, {"sha": "50a7762bc5b93527c2c60ff1455c173e32591ffc", "filename": "gcc/tree.h", "status": "modified", "additions": 199, "deletions": 109, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -64,7 +64,8 @@ enum tree_code_class {\n   tcc_binary,      /* A binary arithmetic expression.  */\n   tcc_statement,   /* A statement expression, which have side effects\n \t\t      but usually no interesting value.  */\n-  tcc_expression   /* Any other expression.  */\n+  tcc_expression,  /* Any other expression.  */\n+  tcc_gimple_stmt  /* A GIMPLE statement.  */\n };\n \n /* Each tree code class has an associated string representation.\n@@ -163,6 +164,10 @@ extern const enum tree_code_class tree_code_type[];\n #define IS_EXPR_CODE_CLASS(CLASS)\\\n \t((CLASS) >= tcc_reference && (CLASS) <= tcc_expression)\n \n+/* Returns nonzer iff CLASS is a GIMPLE statement.  */\n+\n+#define IS_GIMPLE_STMT_CODE_CLASS(CLASS) ((CLASS) == tcc_gimple_stmt)\n+\n /* Returns nonzero iff NODE is an expression of some kind.  */\n \n #define EXPR_P(NODE) IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))\n@@ -347,12 +352,8 @@ enum omp_clause_code\n    fields.  */\n union tree_ann_d;\n \n-struct tree_common GTY(())\n+struct tree_base GTY(())\n {\n-  tree chain;\n-  tree type;\n-  union tree_ann_d *ann;\n-\n   ENUM_BITFIELD(tree_code) code : 8;\n \n   unsigned side_effects_flag : 1;\n@@ -381,6 +382,27 @@ struct tree_common GTY(())\n   unsigned lang_flag_5 : 1;\n   unsigned lang_flag_6 : 1;\n   unsigned visited : 1;\n+\n+  /* FIXME tuples: Eventually, we need to move this somewhere external to\n+     the trees.  */\n+  union tree_ann_d *ann;\n+};\n+\n+struct tree_common GTY(())\n+{\n+  struct tree_base base;\n+  tree chain;\n+  tree type;\n+};\n+\n+/* GIMPLE_MODIFY_STMT */\n+struct gimple_stmt GTY(())\n+{\n+  struct tree_base base;\n+  source_locus locus;\n+  tree block;\n+  /* FIXME tuples: Eventually this should be of type ``struct gimple_expr''.  */\n+  tree GTY ((length (\"TREE_CODE_LENGTH (TREE_CODE (&%h))\"))) operands[1];\n };\n \n /* The following table lists the uses of each of the above flags and\n@@ -555,8 +577,8 @@ enum tree_node_structure_enum {\n \n /* The tree-code says what kind of node it is.\n    Codes are defined in tree.def.  */\n-#define TREE_CODE(NODE) ((enum tree_code) (NODE)->common.code)\n-#define TREE_SET_CODE(NODE, VALUE) ((NODE)->common.code = (VALUE))\n+#define TREE_CODE(NODE) ((enum tree_code) (NODE)->base.code)\n+#define TREE_SET_CODE(NODE, VALUE) ((NODE)->base.code = (VALUE))\n \n /* When checking is enabled, errors will be generated if a tree node\n    is accessed incorrectly. The macros die with a fatal error.  */\n@@ -703,6 +725,14 @@ enum tree_node_structure_enum {\n \t\t\t       __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n+#define GIMPLE_STMT_CHECK(T) __extension__\t\t\t\t\\\n+({  const tree __t = (T);\t\t\t\t\t\t\\\n+    char const __c = TREE_CODE_CLASS (TREE_CODE (__t));\t\t\t\\\n+    if (!IS_GIMPLE_STMT_CODE_CLASS (__c))\t\t\t\t\\\n+      tree_class_check_failed (__t, tcc_gimple_stmt, __FILE__, __LINE__,\\\n+\t\t\t       __FUNCTION__);\t\t\t\t\\\n+    __t; })\n+\n /* These checks have to be special cased.  */\n #define NON_TYPE_CHECK(T) __extension__\t\t\t\t\t\\\n ({  const tree __t = (T);\t\t\t\t\t\t\\\n@@ -748,6 +778,8 @@ enum tree_node_structure_enum {\n #define TREE_OPERAND_CHECK(T, I) __extension__\t\t\t\t\\\n (*({const tree __t = EXPR_CHECK (T);\t\t\t\t\t\\\n     const int __i = (I);\t\t\t\t\t\t\\\n+    if (GIMPLE_TUPLE_P (__t))\t\t\t\t\t\t\\\n+      gcc_unreachable ();\t\t\t\t\t\t\\\n     if (__i < 0 || __i >= TREE_CODE_LENGTH (TREE_CODE (__t)))\t\t\\\n       tree_operand_check_failed (__i, TREE_CODE (__t),\t\t\t\\\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n@@ -763,6 +795,15 @@ enum tree_node_structure_enum {\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     &__t->exp.operands[__i]; }))\n \n+/* Special checks for GIMPLE_STMT_OPERANDs.  */\n+#define GIMPLE_STMT_OPERAND_CHECK(T, I) __extension__\t\t\t\\\n+(*({const tree __t = GIMPLE_STMT_CHECK (T);\t\t\t\t\\\n+    const int __i = (I);\t\t\t\t\t\t\\\n+    if (__i < 0 || __i >= TREE_CODE_LENGTH (TREE_CODE (__t)))\t\t\\\n+      tree_operand_check_failed (__i, TREE_CODE (__t),\t\t\t\\\n+\t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n+    &__t->gstmt.operands[__i]; }))\n+\n #define TREE_RTL_OPERAND_CHECK(T, CODE, I) __extension__\t\t\\\n (*(rtx *)\t\t\t\t\t\t\t\t\\\n  ({const tree __t = (T);\t\t\t\t\t\t\\\n@@ -774,6 +815,31 @@ enum tree_node_structure_enum {\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     &__t->exp.operands[__i]; }))\n \n+/* Nodes are chained together for many purposes.\n+   Types are chained together to record them for being output to the debugger\n+   (see the function `chain_type').\n+   Decls in the same scope are chained together to record the contents\n+   of the scope.\n+   Statement nodes for successive statements used to be chained together.\n+   Often lists of things are represented by TREE_LIST nodes that\n+   are chained together.  */\n+\n+#define TREE_CHAIN(NODE) __extension__ \\\n+(*({const tree __t = (NODE);\t\t\t\t\t\\\n+    if (GIMPLE_TUPLE_P (__t))\t\t\t\t\t\\\n+      gcc_unreachable ();\t\t\t\t\t\\\n+    &__t->common.chain; }))\n+\n+/* In all nodes that are expressions, this is the data type of the expression.\n+   In POINTER_TYPE nodes, this is the type that the pointer points to.\n+   In ARRAY_TYPE nodes, this is the type of the elements.\n+   In VECTOR_TYPE nodes, this is the type of the elements.  */\n+#define TREE_TYPE(NODE) __extension__ \\\n+(*({const tree __t = (NODE);\t\t\t\t\t\\\n+    if (GIMPLE_TUPLE_P (__t))\t\t\t\t\t\\\n+      gcc_unreachable ();\t\t\t\t\t\\\n+    &__t->common.type; }))\n+\n extern void tree_contains_struct_check_failed (const tree,\n \t\t\t\t\t       const enum tree_node_structure_enum,\n \t\t\t\t\t       const char *, int, const char *)\n@@ -829,19 +895,24 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n #define TREE_CLASS_CHECK(T, CODE)\t\t(T)\n #define TREE_RANGE_CHECK(T, CODE1, CODE2)\t(T)\n #define EXPR_CHECK(T)\t\t\t\t(T)\n+#define GIMPLE_STMT_CHECK(T)\t\t\t(T)\n #define NON_TYPE_CHECK(T)\t\t\t(T)\n #define TREE_VEC_ELT_CHECK(T, I)\t\t((T)->vec.a[I])\n #define TREE_OPERAND_CHECK(T, I)\t\t((T)->exp.operands[I])\n #define TREE_OPERAND_CHECK_CODE(T, CODE, I)\t((T)->exp.operands[I])\n+#define GIMPLE_STMT_OPERAND_CHECK(T, I)\t\t((T)->gstmt.operands[I])\n #define TREE_RTL_OPERAND_CHECK(T, CODE, I)  (*(rtx *) &((T)->exp.operands[I]))\n #define PHI_NODE_ELT_CHECK(T, i)\t((T)->phi.a[i])\n #define OMP_CLAUSE_ELT_CHECK(T, i)\t        ((T)->omp_clause.ops[i])\n #define OMP_CLAUSE_RANGE_CHECK(T, CODE1, CODE2)\t(T)\n #define OMP_CLAUSE_SUBCODE_CHECK(T, CODE)\t(T)\n \n+#define TREE_CHAIN(NODE) ((NODE)->common.chain)\n+#define TREE_TYPE(NODE) ((NODE)->common.type)\n+\n #endif\n \n-#define TREE_BLOCK(NODE)\t\t(EXPR_CHECK (NODE)->exp.block)\n+#define TREE_BLOCK(NODE)\t\t*(tree_block (NODE))\n \n #include \"tree-check.h\"\n \n@@ -865,11 +936,26 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n #define NUMERICAL_TYPE_CHECK(T)\t\t\t\t\t\\\n   TREE_CHECK4 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE, REAL_TYPE)\n \n-/* In all nodes that are expressions, this is the data type of the expression.\n-   In POINTER_TYPE nodes, this is the type that the pointer points to.\n-   In ARRAY_TYPE nodes, this is the type of the elements.\n-   In VECTOR_TYPE nodes, this is the type of the elements.  */\n-#define TREE_TYPE(NODE) ((NODE)->common.type)\n+/* Nonzero if NODE is a GIMPLE statement.  */\n+#define GIMPLE_STMT_P(NODE) \\\n+  (TREE_CODE_CLASS (TREE_CODE ((NODE))) == tcc_gimple_stmt)\n+\n+/* Nonzero if NODE is a GIMPLE tuple.  */\n+#define GIMPLE_TUPLE_P(NODE) (GIMPLE_STMT_P (NODE))\n+\n+/* A GIMPLE tuple that has a ``locus'' field.  */\n+#define GIMPLE_TUPLE_HAS_LOCUS_P(NODE) GIMPLE_STMT_P ((NODE))\n+\n+/* Like TREE_OPERAND but works with GIMPLE stmt tuples as well.\n+\n+   If you know the NODE is a GIMPLE statement, use GIMPLE_STMT_OPERAND.  If the\n+   NODE code is unknown at compile time, use this macro.  */\n+#define GENERIC_TREE_OPERAND(NODE, I) *(generic_tree_operand ((NODE), (I)))\n+\n+/* Like TREE_TYPE but returns void_type_node for gimple tuples that have\n+   no type.  */\n+\n+#define GENERIC_TREE_TYPE(NODE) *(generic_tree_type ((NODE)))\n \n /* Here is how primitive or already-canonicalized types' hash codes\n    are made.  */\n@@ -879,17 +965,6 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n    used in hash tables which are saved to a PCH.  */\n #define TREE_HASH(NODE) ((size_t) (NODE) & 0777777)\n \n-/* Nodes are chained together for many purposes.\n-   Types are chained together to record them for being output to the debugger\n-   (see the function `chain_type').\n-   Decls in the same scope are chained together to record the contents\n-   of the scope.\n-   Statement nodes for successive statements used to be chained together.\n-   Often lists of things are represented by TREE_LIST nodes that\n-   are chained together.  */\n-\n-#define TREE_CHAIN(NODE) ((NODE)->common.chain)\n-\n /* Given an expression as a tree, strip any NON_LVALUE_EXPRs and NOP_EXPRs\n    that don't change the machine mode.  */\n \n@@ -899,7 +974,7 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n \t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n \t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\\\n \t && (TYPE_MODE (TREE_TYPE (EXP))\t\t\t\\\n-\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0)))))\t\\\n+\t     == TYPE_MODE (GENERIC_TREE_TYPE (TREE_OPERAND (EXP, 0))))) \\\n     (EXP) = TREE_OPERAND (EXP, 0)\n \n /* Like STRIP_NOPS, but don't let the signedness change either.  */\n@@ -1019,94 +1094,95 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n    object cannot go into register parameters, for example.\n    In IDENTIFIER_NODEs, this means that some extern decl for this name\n    had its address taken.  That matters for inline functions.  */\n-#define TREE_ADDRESSABLE(NODE) ((NODE)->common.addressable_flag)\n+#define TREE_ADDRESSABLE(NODE) ((NODE)->base.addressable_flag)\n \n /* Set on a CALL_EXPR if the call is in a tail position, ie. just before the\n    exit of a function.  Calls for which this is true are candidates for tail\n    call optimizations.  */\n-#define CALL_EXPR_TAILCALL(NODE) (CALL_EXPR_CHECK(NODE)->common.addressable_flag)\n+#define CALL_EXPR_TAILCALL(NODE) \\\n+  (CALL_EXPR_CHECK(NODE)->base.addressable_flag)\n \n /* Used as a temporary field on a CASE_LABEL_EXPR to indicate that the\n    CASE_LOW operand has been processed.  */\n #define CASE_LOW_SEEN(NODE) \\\n-  (CASE_LABEL_EXPR_CHECK (NODE)->common.addressable_flag)\n+  (CASE_LABEL_EXPR_CHECK (NODE)->base.addressable_flag)\n \n /* In a VAR_DECL, nonzero means allocate static storage.\n    In a FUNCTION_DECL, nonzero if function has been defined.\n    In a CONSTRUCTOR, nonzero means allocate static storage.\n \n    ??? This is also used in lots of other nodes in unclear ways which\n    should be cleaned up some day.  */\n-#define TREE_STATIC(NODE) ((NODE)->common.static_flag)\n+#define TREE_STATIC(NODE) ((NODE)->base.static_flag)\n \n /* In a TARGET_EXPR, WITH_CLEANUP_EXPR, means that the pertinent cleanup\n    should only be executed if an exception is thrown, not on normal exit\n    of its scope.  */\n-#define CLEANUP_EH_ONLY(NODE) ((NODE)->common.static_flag)\n+#define CLEANUP_EH_ONLY(NODE) ((NODE)->base.static_flag)\n \n /* Used as a temporary field on a CASE_LABEL_EXPR to indicate that the\n    CASE_HIGH operand has been processed.  */\n #define CASE_HIGH_SEEN(NODE) \\\n-  (CASE_LABEL_EXPR_CHECK (NODE)->common.static_flag)\n+  (CASE_LABEL_EXPR_CHECK (NODE)->base.static_flag)\n \n /* In an expr node (usually a conversion) this means the node was made\n    implicitly and should not lead to any sort of warning.  In a decl node,\n    warnings concerning the decl should be suppressed.  This is used at\n    least for used-before-set warnings, and it set after one warning is\n    emitted.  */\n-#define TREE_NO_WARNING(NODE) ((NODE)->common.nowarning_flag)\n+#define TREE_NO_WARNING(NODE) ((NODE)->base.nowarning_flag)\n \n /* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST this means\n    there was an overflow in folding.  This is distinct from\n    TREE_OVERFLOW because ANSI C requires a diagnostic when overflows\n    occur in constant expressions.  */\n-#define TREE_CONSTANT_OVERFLOW(NODE) (CST_CHECK (NODE)->common.static_flag)\n+#define TREE_CONSTANT_OVERFLOW(NODE) (CST_CHECK (NODE)->base.static_flag)\n \n /* In an IDENTIFIER_NODE, this means that assemble_name was called with\n    this string as an argument.  */\n #define TREE_SYMBOL_REFERENCED(NODE) \\\n-  (IDENTIFIER_NODE_CHECK (NODE)->common.static_flag)\n+  (IDENTIFIER_NODE_CHECK (NODE)->base.static_flag)\n \n /* Nonzero in a pointer or reference type means the data pointed to\n    by this type can alias anything.  */\n #define TYPE_REF_CAN_ALIAS_ALL(NODE) \\\n-  (PTR_OR_REF_CHECK (NODE)->common.static_flag)\n+  (PTR_OR_REF_CHECK (NODE)->base.static_flag)\n \n /* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST, this means\n    there was an overflow in folding, and no warning has been issued\n    for this subexpression.  TREE_OVERFLOW implies TREE_CONSTANT_OVERFLOW,\n    but not vice versa.  */\n \n-#define TREE_OVERFLOW(NODE) (CST_CHECK (NODE)->common.public_flag)\n+#define TREE_OVERFLOW(NODE) (CST_CHECK (NODE)->base.public_flag)\n \n /* In a VAR_DECL, FUNCTION_DECL, NAMESPACE_DECL or TYPE_DECL,\n    nonzero means name is to be accessible from outside this module.\n    In an IDENTIFIER_NODE, nonzero means an external declaration\n    accessible from outside this module was previously seen\n    for this name in an inner scope.  */\n-#define TREE_PUBLIC(NODE) ((NODE)->common.public_flag)\n+#define TREE_PUBLIC(NODE) ((NODE)->base.public_flag)\n \n /* In a _TYPE, indicates whether TYPE_CACHED_VALUES contains a vector\n    of cached values, or is something else.  */\n-#define TYPE_CACHED_VALUES_P(NODE) (TYPE_CHECK(NODE)->common.public_flag)\n+#define TYPE_CACHED_VALUES_P(NODE) (TYPE_CHECK(NODE)->base.public_flag)\n \n /* In a SAVE_EXPR, indicates that the original expression has already\n    been substituted with a VAR_DECL that contains the value.  */\n #define SAVE_EXPR_RESOLVED_P(NODE) \\\n-  (TREE_CHECK (NODE, SAVE_EXPR)->common.public_flag)\n+  (TREE_CHECK (NODE, SAVE_EXPR)->base.public_flag)\n \n /* In any expression, decl, or constant, nonzero means it has side effects or\n    reevaluation of the whole expression could produce a different value.\n    This is set if any subexpression is a function call, a side effect or a\n    reference to a volatile variable.  In a ..._DECL, this is set only if the\n    declaration said `volatile'.  This will never be set for a constant.  */\n #define TREE_SIDE_EFFECTS(NODE) \\\n-  (NON_TYPE_CHECK (NODE)->common.side_effects_flag)\n+  (NON_TYPE_CHECK (NODE)->base.side_effects_flag)\n \n /* In a LABEL_DECL, nonzero means this label had its address taken\n    and therefore can never be deleted and is a jump target for\n    computed gotos.  */\n-#define FORCED_LABEL(NODE) ((NODE)->common.side_effects_flag)\n+#define FORCED_LABEL(NODE) ((NODE)->base.side_effects_flag)\n \n /* Nonzero means this expression is volatile in the C sense:\n    its address should be of type `volatile WHATEVER *'.\n@@ -1121,7 +1197,7 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n    because eventually we may make that a different bit.\n \n    If this bit is set in an expression, so is TREE_SIDE_EFFECTS.  */\n-#define TREE_THIS_VOLATILE(NODE) ((NODE)->common.volatile_flag)\n+#define TREE_THIS_VOLATILE(NODE) ((NODE)->base.volatile_flag)\n \n /* Nonzero means this node will not trap.  In an INDIRECT_REF, means\n    accessing the memory pointed to won't generate a trap.  However,\n@@ -1133,32 +1209,34 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n    (or slice of the array) always belongs to the range of the array.\n    I.e. that the access will not trap, provided that the access to\n    the base to the array will not trap.  */\n-#define TREE_THIS_NOTRAP(NODE) ((NODE)->common.nothrow_flag)\n+#define TREE_THIS_NOTRAP(NODE) ((NODE)->base.nothrow_flag)\n \n /* In a VAR_DECL, PARM_DECL or FIELD_DECL, or any kind of ..._REF node,\n    nonzero means it may not be the lhs of an assignment.  */\n-#define TREE_READONLY(NODE) (NON_TYPE_CHECK (NODE)->common.readonly_flag)\n+#define TREE_READONLY(NODE) (NON_TYPE_CHECK (NODE)->base.readonly_flag)\n \n /* Nonzero if NODE is a _DECL with TREE_READONLY set.  */\n #define TREE_READONLY_DECL_P(NODE)\\\n \t(DECL_P (NODE) && TREE_READONLY (NODE))\n \n /* Value of expression is constant.  Always on in all ..._CST nodes.  May\n    also appear in an expression or decl where the value is constant.  */\n-#define TREE_CONSTANT(NODE) (NON_TYPE_CHECK (NODE)->common.constant_flag)\n+#define TREE_CONSTANT(NODE) (NON_TYPE_CHECK (NODE)->base.constant_flag)\n \n /* Nonzero if NODE, a type, has had its sizes gimplified.  */\n-#define TYPE_SIZES_GIMPLIFIED(NODE) (TYPE_CHECK (NODE)->common.constant_flag)\n+#define TYPE_SIZES_GIMPLIFIED(NODE) \\\n+  (TYPE_CHECK (NODE)->base.constant_flag)\n \n /* In a decl (most significantly a FIELD_DECL), means an unsigned field.  */\n-#define DECL_UNSIGNED(NODE) (DECL_COMMON_CHECK (NODE)->common.unsigned_flag)\n+#define DECL_UNSIGNED(NODE) \\\n+  (DECL_COMMON_CHECK (NODE)->base.unsigned_flag)\n \n /* In a BIT_FIELD_REF, means the bitfield is to be interpreted as unsigned.  */\n #define BIT_FIELD_REF_UNSIGNED(NODE) \\\n-  (BIT_FIELD_REF_CHECK (NODE)->common.unsigned_flag)\n+  (BIT_FIELD_REF_CHECK (NODE)->base.unsigned_flag)\n \n /* In integral and pointer types, means an unsigned type.  */\n-#define TYPE_UNSIGNED(NODE) (TYPE_CHECK (NODE)->common.unsigned_flag)\n+#define TYPE_UNSIGNED(NODE) (TYPE_CHECK (NODE)->base.unsigned_flag)\n \n #define TYPE_TRAP_SIGNED(NODE) \\\n   (flag_trapv && ! TYPE_UNSIGNED (NODE))\n@@ -1172,30 +1250,32 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n    In a BLOCK node, nonzero if reorder_blocks has already seen this block.\n    In an SSA_NAME node, nonzero if the SSA_NAME occurs in an abnormal\n    PHI node.  */\n-#define TREE_ASM_WRITTEN(NODE) ((NODE)->common.asm_written_flag)\n+#define TREE_ASM_WRITTEN(NODE) ((NODE)->base.asm_written_flag)\n \n /* Nonzero in a _DECL if the name is used in its scope.\n    Nonzero in an expr node means inhibit warning if value is unused.\n    In IDENTIFIER_NODEs, this means that some extern decl for this name\n    was used.\n    In a BLOCK, this means that the block contains variables that are used.  */\n-#define TREE_USED(NODE) ((NODE)->common.used_flag)\n+#define TREE_USED(NODE) ((NODE)->base.used_flag)\n \n /* In a FUNCTION_DECL, nonzero means a call to the function cannot throw\n    an exception.  In a CALL_EXPR, nonzero means the call cannot throw.  */\n-#define TREE_NOTHROW(NODE) ((NODE)->common.nothrow_flag)\n+#define TREE_NOTHROW(NODE) ((NODE)->base.nothrow_flag)\n \n /* In a CALL_EXPR, means that it's safe to use the target of the call\n    expansion as the return slot for a call that returns in memory.  */\n-#define CALL_EXPR_RETURN_SLOT_OPT(NODE) ((NODE)->common.private_flag)\n+#define CALL_EXPR_RETURN_SLOT_OPT(NODE) ((NODE)->base.private_flag)\n \n /* In a RESULT_DECL or PARM_DECL, means that it is passed by invisible\n    reference (and the TREE_TYPE is a pointer to the true type).  */\n-#define DECL_BY_REFERENCE(NODE) (DECL_COMMON_CHECK (NODE)->common.private_flag)\n+#define DECL_BY_REFERENCE(NODE) \\\n+  (DECL_COMMON_CHECK (NODE)->base.private_flag)\n \n /* In a CALL_EXPR, means that the call is the jump from a thunk to the\n    thunked-to function.  */\n-#define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)->common.protected_flag)\n+#define CALL_FROM_THUNK_P(NODE) \\\n+  (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n \n /* In a type, nonzero means that all objects of the type are guaranteed by the\n    language or front-end to be properly aligned, so we can indicate that a MEM\n@@ -1206,38 +1286,38 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n \n    In an SSA_NAME node, nonzero if the SSA_NAME node is on the SSA_NAME\n    freelist.  */\n-#define TYPE_ALIGN_OK(NODE) (TYPE_CHECK (NODE)->common.nothrow_flag)\n+#define TYPE_ALIGN_OK(NODE) (TYPE_CHECK (NODE)->base.nothrow_flag)\n \n /* Used in classes in C++.  */\n-#define TREE_PRIVATE(NODE) ((NODE)->common.private_flag)\n+#define TREE_PRIVATE(NODE) ((NODE)->base.private_flag)\n /* Used in classes in C++.\n    In a BLOCK node, this is BLOCK_HANDLER_BLOCK.  */\n-#define TREE_PROTECTED(NODE) ((NODE)->common.protected_flag)\n+#define TREE_PROTECTED(NODE) ((NODE)->base.protected_flag)\n \n /* Nonzero in a _DECL if the use of the name is defined as a\n    deprecated feature by __attribute__((deprecated)).  */\n #define TREE_DEPRECATED(NODE) \\\n-  ((NODE)->common.deprecated_flag)\n+  ((NODE)->base.deprecated_flag)\n \n /* Nonzero in an IDENTIFIER_NODE if the name is a local alias, whose\n    uses are to be substituted for uses of the TREE_CHAINed identifier.  */\n #define IDENTIFIER_TRANSPARENT_ALIAS(NODE) \\\n-  (IDENTIFIER_NODE_CHECK (NODE)->common.deprecated_flag)\n+  (IDENTIFIER_NODE_CHECK (NODE)->base.deprecated_flag)\n \n /* Value of expression is function invariant.  A strict subset of\n    TREE_CONSTANT, such an expression is constant over any one function\n    invocation, though not across different invocations.  May appear in\n    any expression node.  */\n-#define TREE_INVARIANT(NODE) ((NODE)->common.invariant_flag)\n+#define TREE_INVARIANT(NODE) ((NODE)->base.invariant_flag)\n \n /* These flags are available for each language front end to use internally.  */\n-#define TREE_LANG_FLAG_0(NODE) ((NODE)->common.lang_flag_0)\n-#define TREE_LANG_FLAG_1(NODE) ((NODE)->common.lang_flag_1)\n-#define TREE_LANG_FLAG_2(NODE) ((NODE)->common.lang_flag_2)\n-#define TREE_LANG_FLAG_3(NODE) ((NODE)->common.lang_flag_3)\n-#define TREE_LANG_FLAG_4(NODE) ((NODE)->common.lang_flag_4)\n-#define TREE_LANG_FLAG_5(NODE) ((NODE)->common.lang_flag_5)\n-#define TREE_LANG_FLAG_6(NODE) ((NODE)->common.lang_flag_6)\n+#define TREE_LANG_FLAG_0(NODE) ((NODE)->base.lang_flag_0)\n+#define TREE_LANG_FLAG_1(NODE) ((NODE)->base.lang_flag_1)\n+#define TREE_LANG_FLAG_2(NODE) ((NODE)->base.lang_flag_2)\n+#define TREE_LANG_FLAG_3(NODE) ((NODE)->base.lang_flag_3)\n+#define TREE_LANG_FLAG_4(NODE) ((NODE)->base.lang_flag_4)\n+#define TREE_LANG_FLAG_5(NODE) ((NODE)->base.lang_flag_5)\n+#define TREE_LANG_FLAG_6(NODE) ((NODE)->base.lang_flag_6)\n \f\n /* Define additional fields and accessors for nodes representing constants.  */\n \n@@ -1424,46 +1504,28 @@ struct tree_constructor GTY(())\n #define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)\n #define TREE_COMPLEXITY(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n \n+/* In gimple statements.  */\n+#define GIMPLE_STMT_OPERAND(NODE, I) GIMPLE_STMT_OPERAND_CHECK (NODE, I)\n+#define GIMPLE_STMT_LOCUS(NODE) (GIMPLE_STMT_CHECK (NODE)->gstmt.locus)\n+#define GIMPLE_STMT_BLOCK(NODE) (GIMPLE_STMT_CHECK (NODE)->gstmt.block)\n+\n /* In a LOOP_EXPR node.  */\n #define LOOP_EXPR_BODY(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_EXPR, 0)\n \n-#ifdef USE_MAPPED_LOCATION\n /* The source location of this expression.  Non-tree_exp nodes such as\n    decls and constants can be shared among multiple locations, so\n    return nothing.  */\n-#define EXPR_LOCATION(NODE)\t\t\t\t\t\\\n-  (EXPR_P (NODE) ? (NODE)->exp.locus : UNKNOWN_LOCATION)\n-#define SET_EXPR_LOCATION(NODE, FROM) \\\n-  (EXPR_CHECK (NODE)->exp.locus = (FROM))\n-#define EXPR_HAS_LOCATION(NODE) (EXPR_LOCATION (NODE) != UNKNOWN_LOCATION)\n-/* EXPR_LOCUS and SET_EXPR_LOCUS are deprecated.  */\n-#define EXPR_LOCUS(NODE)\t\t\t\t\t\\\n-  (EXPR_P (NODE) ? &(NODE)->exp.locus : (location_t *)NULL)\n-#define SET_EXPR_LOCUS(NODE, FROM) \\\n-  do { source_location *loc_tmp = FROM; \\\n-       EXPR_CHECK (NODE)->exp.locus \\\n-       = loc_tmp == NULL ? UNKNOWN_LOCATION : *loc_tmp; } while (0)\n-#define EXPR_FILENAME(NODE) \\\n-  LOCATION_FILE (EXPR_CHECK (NODE)->exp.locus)\n-#define EXPR_LINENO(NODE) \\\n-  LOCATION_LINE (EXPR_CHECK (NODE)->exp.locus)\n-#else\n-/* The source location of this expression.  Non-tree_exp nodes such as\n-   decls and constants can be shared among multiple locations, so\n-   return nothing.  */\n-#define EXPR_LOCUS(NODE)\t\t\t\t\t\\\n-  (EXPR_P (NODE) ? (NODE)->exp.locus : (location_t *)NULL)\n-#define SET_EXPR_LOCUS(NODE, FROM) \\\n-  (EXPR_CHECK (NODE)->exp.locus = (FROM))\n-#define SET_EXPR_LOCATION(NODE, FROM) annotate_with_locus (NODE, FROM)\n-#define EXPR_FILENAME(NODE) \\\n-  (EXPR_CHECK (NODE)->exp.locus->file)\n-#define EXPR_LINENO(NODE) \\\n-  (EXPR_CHECK (NODE)->exp.locus->line)\n-#define EXPR_HAS_LOCATION(NODE) (EXPR_LOCUS (NODE) != NULL)\n-#define EXPR_LOCATION(NODE) \\\n-  (EXPR_HAS_LOCATION(NODE) ? *(NODE)->exp.locus : UNKNOWN_LOCATION)\n-#endif\n+#define EXPR_LOCATION(NODE) expr_location ((NODE))\n+#define SET_EXPR_LOCATION(NODE, FROM) set_expr_location ((NODE), (FROM))\n+#define EXPR_HAS_LOCATION(NODE) expr_has_location ((NODE))\n+#define EXPR_LOCUS(NODE) expr_locus ((NODE))\n+#define SET_EXPR_LOCUS(NODE, FROM) set_expr_locus ((NODE), (FROM))\n+#define EXPR_FILENAME(NODE) *(expr_filename ((NODE)))\n+#define EXPR_LINENO(NODE) *(expr_lineno ((NODE)))\n+\n+/* True if a tree is an expression or statement that can have a\n+   location.  */\n+#define CAN_HAVE_LOCATION_P(NODE) (EXPR_P (NODE) || GIMPLE_STMT_P (NODE))\n \n /* In a TARGET_EXPR node.  */\n #define TARGET_EXPR_SLOT(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 0)\n@@ -1686,13 +1748,13 @@ struct tree_exp GTY(())\n    never output, so we can safely use the ASM_WRITTEN_FLAG for this\n    status bit.  */\n #define SSA_NAME_OCCURS_IN_ABNORMAL_PHI(NODE) \\\n-    SSA_NAME_CHECK (NODE)->common.asm_written_flag\n+    SSA_NAME_CHECK (NODE)->base.asm_written_flag\n \n /* Nonzero if this SSA_NAME expression is currently on the free list of\n    SSA_NAMES.  Using NOTHROW_FLAG seems reasonably safe since throwing\n    has no meaning for an SSA_NAME.  */\n #define SSA_NAME_IN_FREE_LIST(NODE) \\\n-    SSA_NAME_CHECK (NODE)->common.nothrow_flag\n+    SSA_NAME_CHECK (NODE)->base.nothrow_flag\n \n /* Attributes for SSA_NAMEs for pointer-type variables.  */\n #define SSA_NAME_PTR_INFO(N) \\\n@@ -1998,10 +2060,10 @@ struct tree_block GTY(())\n   (FUNCTION_TYPE_CHECK (NODE)->type.no_force_blk_flag)\n \n /* Nonzero in a type considered volatile as a whole.  */\n-#define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->common.volatile_flag)\n+#define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->base.volatile_flag)\n \n /* Means this type is const-qualified.  */\n-#define TYPE_READONLY(NODE) (TYPE_CHECK (NODE)->common.readonly_flag)\n+#define TYPE_READONLY(NODE) (TYPE_CHECK (NODE)->base.readonly_flag)\n \n /* If nonzero, this type is `restrict'-qualified, in the C sense of\n    the term.  */\n@@ -2033,7 +2095,7 @@ struct tree_block GTY(())\n \n /* Used to keep track of visited nodes in tree traversals.  This is set to\n    0 by copy_node and make_node.  */\n-#define TREE_VISITED(NODE) ((NODE)->common.visited)\n+#define TREE_VISITED(NODE) ((NODE)->base.visited)\n \n /* If set in an ARRAY_TYPE, indicates a string type (for languages\n    that distinguish string from array of char).\n@@ -2150,7 +2212,7 @@ struct tree_type GTY(())\n /* BINFO specific flags.  */\n \n /* Nonzero means that the derivation chain is via a `virtual' declaration.  */\n-#define BINFO_VIRTUAL_P(NODE) (TREE_BINFO_CHECK (NODE)->common.static_flag)\n+#define BINFO_VIRTUAL_P(NODE) (TREE_BINFO_CHECK (NODE)->base.static_flag)\n \n /* Flags for language dependent use.  */\n #define BINFO_MARKED(NODE) TREE_LANG_FLAG_0(TREE_BINFO_CHECK(NODE))\n@@ -3164,6 +3226,7 @@ struct tree_value_handle GTY(())\n union tree_node GTY ((ptr_alias (union lang_tree_node),\n \t\t      desc (\"tree_node_structure (&%h)\")))\n {\n+  struct tree_base GTY ((tag (\"TS_BASE\"))) base;\n   struct tree_common GTY ((tag (\"TS_COMMON\"))) common;\n   struct tree_int_cst GTY ((tag (\"TS_INT_CST\"))) int_cst;\n   struct tree_real_cst GTY ((tag (\"TS_REAL_CST\"))) real_cst;\n@@ -3193,6 +3256,7 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_block GTY ((tag (\"TS_BLOCK\"))) block;\n   struct tree_binfo GTY ((tag (\"TS_BINFO\"))) binfo;\n   struct tree_statement_list GTY ((tag (\"TS_STATEMENT_LIST\"))) stmt_list;\n+  struct gimple_stmt GTY ((tag (\"TS_GIMPLE_STATEMENT\"))) gstmt;\n   struct tree_value_handle GTY ((tag (\"TS_VALUE_HANDLE\"))) value_handle;\n   struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n   struct tree_memory_tag GTY ((tag (\"TS_MEMORY_TAG\"))) mtag;\n@@ -3530,6 +3594,8 @@ extern tree build1_stat (enum tree_code, tree, tree MEM_STAT_DECL);\n #define build1(c,t1,t2) build1_stat (c,t1,t2 MEM_STAT_INFO)\n extern tree build2_stat (enum tree_code, tree, tree, tree MEM_STAT_DECL);\n #define build2(c,t1,t2,t3) build2_stat (c,t1,t2,t3 MEM_STAT_INFO)\n+extern tree build2_gimple_stat (enum tree_code, tree, tree MEM_STAT_DECL);\n+#define build2_gimple(c,t1,t2) build2_gimple_stat (c,t1,t2 MEM_STAT_INFO)\n extern tree build3_stat (enum tree_code, tree, tree, tree, tree MEM_STAT_DECL);\n #define build3(c,t1,t2,t3,t4) build3_stat (c,t1,t2,t3,t4 MEM_STAT_INFO)\n extern tree build4_stat (enum tree_code, tree, tree, tree, tree,\n@@ -4353,6 +4419,29 @@ extern tree build_addr (tree, tree);\n extern bool fields_compatible_p (tree, tree);\n extern tree find_compatible_field (tree, tree);\n \n+extern location_t expr_location (tree);\n+extern void set_expr_location (tree, location_t);\n+extern bool expr_has_location (tree);\n+extern\n+#ifdef USE_MAPPED_LOCATION\n+source_location *\n+#else\n+source_locus\n+#endif\n+expr_locus (tree);\n+extern void set_expr_locus (tree,\n+#ifdef USE_MAPPED_LOCATION\n+                            source_location *loc\n+#else\n+\t\t            source_locus loc\n+#endif\n+\t\t\t   );\n+extern const char **expr_filename (tree);\n+extern int *expr_lineno (tree);\n+extern tree *tree_block (tree);\n+extern tree *generic_tree_operand (tree, int);\n+extern tree *generic_tree_type (tree);\n+\n /* In function.c */\n extern void expand_main_function (void);\n extern void init_dummy_function_start (void);\n@@ -4570,6 +4659,7 @@ typedef enum\n   lang_decl,\n   lang_type,\n   omp_clause_kind,\n+  gimple_stmt_kind,\n   all_kinds\n } tree_node_kind;\n "}, {"sha": "741876dd31ee34597746fc27fcd49e4785df1a15", "filename": "gcc/treestruct.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    tree_node for garbage collection purposes, as well as specifying what structures\n    contain what other structures in the tree_contains_struct array.  */\n \t\n+DEFTREESTRUCT(TS_BASE, \"base\")\n DEFTREESTRUCT(TS_COMMON, \"common\")\n DEFTREESTRUCT(TS_INT_CST, \"integer cst\")\n DEFTREESTRUCT(TS_REAL_CST, \"real cst\")\n@@ -57,6 +58,7 @@ DEFTREESTRUCT(TS_PHI_NODE, \"phi node\")\n DEFTREESTRUCT(TS_BLOCK, \"block\")\n DEFTREESTRUCT(TS_BINFO, \"binfo\")\n DEFTREESTRUCT(TS_STATEMENT_LIST, \"statement list\")\n+DEFTREESTRUCT(TS_GIMPLE_STATEMENT, \"gimple statement\")\n DEFTREESTRUCT(TS_VALUE_HANDLE, \"value handle\")\n DEFTREESTRUCT(TS_CONSTRUCTOR, \"constructor\")\n DEFTREESTRUCT(TS_MEMORY_TAG, \"memory tag\")"}, {"sha": "93704e28410d66248c2628a1a115158859966b84", "filename": "gcc/value-prof.c", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07beea0df36b29ef9acb27111eac0b0e92e181a5/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=07beea0df36b29ef9acb27111eac0b0e92e181a5", "patch": "@@ -193,8 +193,9 @@ tree_divmod_fixed_value (tree stmt, tree operation,\n \n   tmpv = create_tmp_var (optype, \"PROF\");\n   tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, optype, tmpv, fold_convert (optype, value));\n-  stmt2 = build2 (MODIFY_EXPR, optype, tmp1, op2);\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmpv,\n+\t\t  fold_convert (optype, value));\n+  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, op2);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t    build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n \t    build1 (GOTO_EXPR, void_type_node, label_decl2),\n@@ -206,14 +207,14 @@ tree_divmod_fixed_value (tree stmt, tree operation,\n \n   tmp2 = create_tmp_var (optype, \"PROF\");\n   label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n-  stmt1 = build2 (MODIFY_EXPR, optype, tmp2,\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmp2,\n \t\t  build2 (TREE_CODE (operation), optype, op1, tmpv));\n   bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb2end = stmt1;\n \n   label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  stmt1 = build2 (MODIFY_EXPR, optype, tmp2,\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmp2,\n \t\t  build2 (TREE_CODE (operation), optype, op1, op2));\n   bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n@@ -269,11 +270,11 @@ tree_divmod_fixed_value_transform (tree stmt)\n   modify = stmt;\n   if (TREE_CODE (stmt) == RETURN_EXPR\n       && TREE_OPERAND (stmt, 0)\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == GIMPLE_MODIFY_STMT)\n     modify = TREE_OPERAND (stmt, 0);\n-  if (TREE_CODE (modify) != MODIFY_EXPR)\n+  if (TREE_CODE (modify) != GIMPLE_MODIFY_STMT)\n     return false;\n-  op = TREE_OPERAND (modify, 1);\n+  op = GIMPLE_STMT_OPERAND (modify, 1);\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n     return false;\n   code = TREE_CODE (op);\n@@ -325,7 +326,7 @@ tree_divmod_fixed_value_transform (tree stmt)\n       print_generic_stmt (dump_file, stmt, TDF_SLIM);\n     }\n \n-  TREE_OPERAND (modify, 1) = result;\n+  GIMPLE_STMT_OPERAND (modify, 1) = result;\n \n   return true;\n }\n@@ -357,9 +358,9 @@ tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob,\n \n   tmp2 = create_tmp_var (optype, \"PROF\");\n   tmp3 = create_tmp_var (optype, \"PROF\");\n-  stmt2 = build2 (MODIFY_EXPR, optype, tmp2, \n+  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp2, \n \t\t  build2 (PLUS_EXPR, optype, op2, build_int_cst (optype, -1)));\n-  stmt3 = build2 (MODIFY_EXPR, optype, tmp3,\n+  stmt3 = build2 (GIMPLE_MODIFY_STMT, optype, tmp3,\n \t\t  build2 (BIT_AND_EXPR, optype, tmp2, op2));\n   stmt4 = build3 (COND_EXPR, void_type_node,\n \t\t  build2 (NE_EXPR, boolean_type_node,\n@@ -373,14 +374,14 @@ tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob,\n \n   /* tmp2 == op2-1 inherited from previous block */\n   label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n-  stmt1 = build2 (MODIFY_EXPR, optype, result,\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result,\n \t\t  build2 (BIT_AND_EXPR, optype, op1, tmp2));\n   bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb2end = stmt1;\n \n   label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  stmt1 = build2 (MODIFY_EXPR, optype, result,\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result,\n \t\t  build2 (TREE_CODE (operation), optype, op1, op2));\n   bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n@@ -436,11 +437,11 @@ tree_mod_pow2_value_transform (tree stmt)\n   modify = stmt;\n   if (TREE_CODE (stmt) == RETURN_EXPR\n       && TREE_OPERAND (stmt, 0)\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == GIMPLE_MODIFY_STMT)\n     modify = TREE_OPERAND (stmt, 0);\n-  if (TREE_CODE (modify) != MODIFY_EXPR)\n+  if (TREE_CODE (modify) != GIMPLE_MODIFY_STMT)\n     return false;\n-  op = TREE_OPERAND (modify, 1);\n+  op = GIMPLE_STMT_OPERAND (modify, 1);\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n     return false;\n   code = TREE_CODE (op);\n@@ -483,7 +484,7 @@ tree_mod_pow2_value_transform (tree stmt)\n \n   result = tree_mod_pow2 (stmt, op, op1, op2, prob, count, all);\n \n-  TREE_OPERAND (modify, 1) = result;\n+  GIMPLE_STMT_OPERAND (modify, 1) = result;\n \n   return true;\n }\n@@ -520,8 +521,8 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n   bsi = bsi_for_stmt (stmt);\n \n   tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (MODIFY_EXPR, optype, result, op1);\n-  stmt2 = build2 (MODIFY_EXPR, optype, tmp1, op2);\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result, op1);\n+  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, op2);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t    build2 (LT_EXPR, boolean_type_node, result, tmp1),\n \t    build1 (GOTO_EXPR, void_type_node, label_decl3),\n@@ -535,7 +536,7 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n   if (ncounts)\t/* Assumed to be 0 or 1 */\n     {\n       label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n-      stmt1 = build2 (MODIFY_EXPR, optype, result,\n+      stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result,\n \t\t      build2 (MINUS_EXPR, optype, result, tmp1));\n       stmt2 = build3 (COND_EXPR, void_type_node,\n \t\tbuild2 (LT_EXPR, boolean_type_node, result, tmp1),\n@@ -549,7 +550,7 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n \n   /* Fallback case. */\n   label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  stmt1 = build2 (MODIFY_EXPR, optype, result,\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result,\n \t\t    build2 (TREE_CODE (operation), optype, result, tmp1));\n   bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n@@ -619,11 +620,11 @@ tree_mod_subtract_transform (tree stmt)\n   modify = stmt;\n   if (TREE_CODE (stmt) == RETURN_EXPR\n       && TREE_OPERAND (stmt, 0)\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == GIMPLE_MODIFY_STMT)\n     modify = TREE_OPERAND (stmt, 0);\n-  if (TREE_CODE (modify) != MODIFY_EXPR)\n+  if (TREE_CODE (modify) != GIMPLE_MODIFY_STMT)\n     return false;\n-  op = TREE_OPERAND (modify, 1);\n+  op = GIMPLE_STMT_OPERAND (modify, 1);\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n     return false;\n   code = TREE_CODE (op);\n@@ -685,7 +686,7 @@ tree_mod_subtract_transform (tree stmt)\n \t\t\t    histogram->hvalue.counters[0], \n \t\t\t    histogram->hvalue.counters[1], all);\n \n-  TREE_OPERAND (modify, 1) = result;\n+  GIMPLE_STMT_OPERAND (modify, 1) = result;\n \n   return true;\n }\n@@ -713,14 +714,14 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n     assign = stmt;\n \n   if (!assign\n-      || TREE_CODE (assign) != MODIFY_EXPR)\n+      || TREE_CODE (assign) != GIMPLE_MODIFY_STMT)\n     return;\n-  lhs = TREE_OPERAND (assign, 0);\n+  lhs = GIMPLE_STMT_OPERAND (assign, 0);\n   type = TREE_TYPE (lhs);\n   if (!INTEGRAL_TYPE_P (type))\n     return;\n \n-  rhs = TREE_OPERAND (assign, 1);\n+  rhs = GIMPLE_STMT_OPERAND (assign, 1);\n   switch (TREE_CODE (rhs))\n     {\n     case TRUNC_DIV_EXPR:"}]}