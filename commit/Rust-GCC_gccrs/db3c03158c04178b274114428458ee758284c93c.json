{"sha": "db3c03158c04178b274114428458ee758284c93c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzYzAzMTU4YzA0MTc4YjI3NDExNDQyODQ1OGVlNzU4Mjg0YzkzYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-05-18T07:25:50Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-05-18T07:25:50Z"}, "message": "function.c (expand_function_start): Avoid creating BLKmode pseudos.\n\n\t* function.c (expand_function_start): Avoid creating BLKmode\n\tpseudos.\n\n\t* dwarf2out.c (output_comp_unit): Always output a compilation-unit\n\tDIE, even if it has no children.\n\t(dwarf2out_finish): Always output the line-number table, even if\n\tit has no content.\n\nFrom-SVN: r42254", "tree": {"sha": "42a17eef2f12f7a1de6ec4d4deee148f64370649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42a17eef2f12f7a1de6ec4d4deee148f64370649"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db3c03158c04178b274114428458ee758284c93c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3c03158c04178b274114428458ee758284c93c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3c03158c04178b274114428458ee758284c93c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3c03158c04178b274114428458ee758284c93c/comments", "author": null, "committer": null, "parents": [{"sha": "52a57250621b05048f505946c662675d083d8335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a57250621b05048f505946c662675d083d8335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a57250621b05048f505946c662675d083d8335"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "cf694258dc770d95b6120674ff027b6cc7b87810", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3c03158c04178b274114428458ee758284c93c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3c03158c04178b274114428458ee758284c93c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db3c03158c04178b274114428458ee758284c93c", "patch": "@@ -1,3 +1,15 @@\n+2001-05-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* function.c (expand_function_start): Avoid creating BLKmode\n+\tpseudos.\n+\n+2001-05-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* dwarf2out.c (output_comp_unit): Always output a compilation-unit\n+\tDIE, even if it has no children.\n+\t(dwarf2out_finish): Always output the line-number table, even if\n+\tit has no content.\n+\n 2001-05-18  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.md (movsfcc,movdfcc): Remove NE case."}, {"sha": "5c05d03298ebad4d641f9e7153ef2fd91a069942", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3c03158c04178b274114428458ee758284c93c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3c03158c04178b274114428458ee758284c93c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=db3c03158c04178b274114428458ee758284c93c", "patch": "@@ -5929,10 +5929,13 @@ output_comp_unit (die)\n {\n   const char *secname;\n \n-  if (die->die_child == 0)\n-    return;\n-\n-  /* Mark all the DIEs in this CU so we know which get local refs.  */\n+  /* Even if there are no children of this DIE, we must output the\n+     information about the compilation unit.  Otherwise, on an empty\n+     translation unit, we will generate a present, but empty,\n+     .debug_info section.  IRIX 6.5 `nm' will then complain when\n+     examining the file.\n+     \n+     Mark all the DIEs in this CU so we know which get local refs.  */\n   mark_dies (die);\n \n   build_abbrev_table (die);\n@@ -11250,27 +11253,28 @@ dwarf2out_finish ()\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BSS_END_LABEL, 0);\n #endif\n \n-  /* Output the source line correspondence table.  */\n-  if (line_info_table_in_use > 1 || separate_line_info_table_in_use)\n+  /* Output the source line correspondence table.  We must do this\n+     even if there is no line information.  Otherwise, on an empty\n+     translation unit, we will generate a present, but empty,\n+     .debug_info section.  IRIX 6.5 `nm' will then complain when\n+     examining the file.  */\n+  if (! DWARF2_ASM_LINE_DEBUG_INFO)\n     {\n-      if (! DWARF2_ASM_LINE_DEBUG_INFO)\n-\t{\n-\t  ASM_OUTPUT_SECTION (asm_out_file, DEBUG_LINE_SECTION);\n-\t  output_line_info ();\n-\t}\n-\n-      /* We can only use the low/high_pc attributes if all of the code\n-\t was in .text.  */\n-      if (separate_line_info_table_in_use == 0)\n-\t{\n-\t  add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, text_section_label);\n-\t  add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, text_end_label);\n-\t}\n+      ASM_OUTPUT_SECTION (asm_out_file, DEBUG_LINE_SECTION);\n+      output_line_info ();\n+    }\n \n-      add_AT_lbl_offset (comp_unit_die, DW_AT_stmt_list,\n-\t\t\t debug_line_section_label);\n+  /* We can only use the low/high_pc attributes if all of the code was\n+     in .text.  */\n+  if (separate_line_info_table_in_use == 0)\n+    {\n+      add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, text_section_label);\n+      add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, text_end_label);\n     }\n \n+  add_AT_lbl_offset (comp_unit_die, DW_AT_stmt_list,\n+\t\t     debug_line_section_label);\n+\n #if 0 /* unimplemented */\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE && primary)\n     add_AT_unsigned (die, DW_AT_macro_info, 0);"}, {"sha": "54dd3084a06f80bf4b9f16640ff664a65cf7ccff", "filename": "gcc/function.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3c03158c04178b274114428458ee758284c93c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3c03158c04178b274114428458ee758284c93c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=db3c03158c04178b274114428458ee758284c93c", "patch": "@@ -6370,21 +6370,25 @@ expand_function_start (subr, parms_have_cleanups)\n \t   || current_function_instrument_entry_exit\n \t   || (flag_exceptions && USING_SJLJ_EXCEPTIONS))\n     {\n-      /* If function will end with cleanup code for parms,\n-\t compute the return values into a pseudo reg,\n-\t which we will copy into the true return register\n-\t after the cleanups are done.  */\n-\n-      enum machine_mode mode = DECL_MODE (DECL_RESULT (subr));\n-\n-#ifdef PROMOTE_FUNCTION_RETURN\n-      tree type = TREE_TYPE (DECL_RESULT (subr));\n-      int unsignedp = TREE_UNSIGNED (type);\n-\n-      mode = promote_mode (type, mode, &unsignedp, 1);\n-#endif\n+      /* If function will end with cleanup code for parms, compute the\n+\t return values into a pseudo reg, which we will copy into the\n+\t true return register after the cleanups are done.  */\n+\n+      /* In order to figure out what mode to use for the pseudo, we\n+\t figure out what the mode of the eventual return register will\n+\t actually be, and use that.  */\n+      rtx hard_reg\n+\t= hard_function_value (TREE_TYPE (DECL_RESULT (subr)),\n+\t\t\t       subr, 1);\n+\n+      /* Since we know the return value is not an aggregate, we should\n+\t have a REG here.  */\n+      if (!REG_P (hard_reg))\n+\tabort ();\n \n-      SET_DECL_RTL (DECL_RESULT (subr), gen_reg_rtx (mode));\n+      /* Create the pseudo.  */\n+      SET_DECL_RTL (DECL_RESULT (subr), \n+\t\t    gen_reg_rtx (GET_MODE (hard_reg)));\n       /* Needed because we may need to move this to memory\n \t in case it's a named return value whose address is taken.  */\n       DECL_REGISTER (DECL_RESULT (subr)) = 1;"}]}